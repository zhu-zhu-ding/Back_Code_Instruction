[
    {
        "instruction": "Give me a Fortran subroutine code called trisolve to solve a tridiagonal linear system with constant coefficients. The number of input parameters is 6, all of them are arrays. The first four parameters (a, b, c, r) represent the coefficients of the tridiagonal matrix and the right-hand side vector, all of type real. The fifth parameter (n) is the size of the system, of type integer. The last parameter (x) is the output array that will store the solution to the system, also of type real.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    real*8, allocatable :: a(:), b(:), c(:), r(:), x(:)\n    \n    ! Test case 1\n    n = 3\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 2.0, 0.0]\n    b = [3.0, 4.0, 5.0]\n    c = [0.0, 6.0, 7.0]\n    r = [8.0, 9.0, 10.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 4\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [0.0, 1.0, 2.0, 0.0]\n    b = [3.0, 4.0, 5.0, 6.0]\n    c = [7.0, 0.0, 8.0, 9.0]\n    r = [10.0, 11.0, 12.0, 13.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 5\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 2.0, 0.0, 3.0, 0.0]\n    b = [4.0, 5.0, 6.0, 7.0, 8.0]\n    c = [0.0, 9.0, 10.0, 0.0, 11.0]\n    r = [12.0, 13.0, 14.0, 15.0, 16.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 2\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 0.0]\n    b = [2.0, 3.0]\n    c = [0.0, 4.0]\n    r = [5.0, 6.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 1\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = 0.0\n    b = 1.0\n    c = 0.0\n    r = 2.0\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.7499999999999991        5.2499999999999982       -3.2499999999999987",
                "-7.4000000000000021        4.6000000000000005       -20.666666666666675        13.266666666666671",
                "3.8095238095238093        8.8761904761904749       -4.3333333333333330        4.0000000000000000       -3.2380952380952381",
                "4.5000000000000000       -4.0000000000000000",
                "2.0000000000000000"
            ]
        },
        "code": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called lin1db that performs 1D linear interpolation on a bounded domain. The subroutine takes 5 input parameters: n, an integer representing the size of the arrays; xg, xd, and q, arrays of type real, representing grid points, departure points, and the quantity to be interpolated, respectively. The subroutine also has one output parameter, qnew, an array of type real, representing the interpolated values of q.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    real*8 :: xg(5), xd(5), q(5), qnew(5)\n    ! Test case 1\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.5, 1.5, 2.5, 3.5, 4.5]\n    q = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n\n    ! Test case 2\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [1.2, 1.8, 2.4, 3.6, 4.5]\n    q = [1.5, 2.5, 3.5, 4.5, 5.5]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.5, 1.5, 2.5, 3.5, 3.0]\n    q = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.0, 1.0, 2.0, 3.0, 4.0]\n    q = [2.0, 3.0, 4.0, 5.0, 6.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.3, 1.7, 2.8, 3.2, 4.1]\n    q = [1.2, 2.4, 3.6, 4.8, 6.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\nend program main",
            "result": [
                "1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.0000000000000000",
                "2.7000000476837158        3.2999999523162842        3.9000000953674316        5.0999999046325684        5.5000000000000000",
                "1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        4.0000000000000000",
                "2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "1.5600000762939459        3.2400000190734772        4.5600000762939317        5.0400002098083405        6.0000000000000000"
            ]
        },
        "code": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"residual\" to calculate the residual for an elliptic problem. The subroutine takes multiple input parameters: \n- \"ff\" is an input array of type real with dimensions (nx, ny)\n- \"rf\" is an input array of type real with dimensions (nx, ny)\n- \"a\" is an input array of type real with dimension (ny)\n- \"b\" is an input array of type real with dimension (ny)\n- \"c\" is an input array of type real with dimension (ny)\n- \"nu\" is an input parameter of type real\n- \"nx\" is an input parameter of type integer\n- \"ny\" is an input parameter of type integer\n- \"nnx\" is an input parameter of type integer\n- \"nny\" is an input parameter of type integer\n  \nThe subroutine also has one output parameter:\n- \"resf\" is an output array of type real with dimensions (nx, ny)\n\nThe purpose of the subroutine is to calculate the residual values for the elliptic problem based on the input arrays and parameters provided. The calculation involves iterating over the elements of the arrays and performing various mathematical operations to determine the residual values. The subroutine uses loops and conditional statements to handle different parts of the arrays separately.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: nx = 5, ny = 4, nnx = 6, nny = 5\n    real*8 :: ff(nx, ny), rf(nx, ny), a(ny), b(ny), c(ny), nu\n    real*8 :: resf(nx, ny)\n    \n    ! Test case 1\n    ff = 1.0\n    rf = 2.0\n    a = 0.5\n    b = 0.2\n    c = 0.3\n    nu = 0.1\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 2\n    ff = 0.0\n    rf = 1.0\n    a = 1.0\n    b = 0.5\n    c = 0.0\n    nu = 0.2\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 3\n    ff = 2.0\n    rf = 0.0\n    a = 0.1\n    b = 0.3\n    c = 0.2\n    nu = 0.3\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 4\n    ff = 3.0\n    rf = 2.5\n    a = 0.4\n    b = 0.1\n    c = 0.5\n    nu = 0.4\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 5\n    ff = 1.5\n    rf = 1.5\n    a = 0.3\n    b = 0.4\n    c = 0.1\n    nu = 0.5\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.5899999952316284        2.4499999955296516        2.4499999955296516        2.4499999955296516        2.6399999997019767",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000       0.50000000000000000",
                "0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791        1.3200000467896462       0.78000002622604381       0.78000002622604381       0.78000002622604381        1.3100000457465648",
                "3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        4.9500000365078449        4.7000000327825546        4.7000000327825546        4.7000000327825546        5.1100000382959845",
                "2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        3.2300000239908693        2.6700000162422657        2.6700000162422657        2.6700000162422657        3.1400000190734865"
            ]
        },
        "code": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called insertionsort to sort an array in ascending order using the insertion sort algorithm. The subroutine takes three parameters. The first parameter is the size of the array, which is an integer and is passed as an input parameter. The second parameter is the input array (inarray), which is an array of integers and is also passed as an input parameter. The third parameter is the output array (outarray), which is an array of integers and is passed as an output parameter. The subroutine performs the insertion sort algorithm on the input array and populates the output array with the sorted elements.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    integer, dimension(:), allocatable :: inarray, outarray\n    integer :: i\n\n    ! Test case 1\n    n = 5\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [5, 2, 8, 1, 9]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 2\n    n = 7\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [3, 9, 2, 7, 1, 5, 8]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 3\n    n = 3\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [10, 5, 1]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 4\n    n = 6\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [4, 6, 2, 9, 3, 1]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 5\n    n = 4\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [7, 3, 5, 2]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\nend program main",
            "result": [
                "1\n           2\n           5\n           8\n           9",
                "1\n           2\n           3\n           5\n           7\n           8\n           9",
                "1\n           5\n          10",
                "1\n           2\n           3\n           4\n           6\n           9",
                "2\n           3\n           5\n           7"
            ]
        },
        "code": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called \"driver\" that calculates the time rate of change of surface temperature and the incremental change in surface temperature. The subroutine takes in 11 input parameters: jm and im of type integer, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, and dt of type real(8). The subroutine also has two output parameters: tsinc and tsdot, both of type real(8) and dimension jm x im.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: jm, im\n    real*8, allocatable :: srf_rad_flx(:,:), srf_lat_flx(:,:), srf_sen_flx(:,:), qflx(:,:)\n    real*8, allocatable :: tsinc(:,:), tsdot(:,:)\n    real*8 :: hslab, rowl, cl, dt\n    integer :: i, j\n    \n    jm = 3\n    im = 3\n    allocate(srf_rad_flx(jm, im), srf_lat_flx(jm, im), srf_sen_flx(jm, im), qflx(jm, im))\n    allocate(tsinc(jm, im), tsdot(jm, im))\n    \n    ! Test case 1\n    hslab = 0.1\n    rowl = 1000.0\n    cl = 1000.0\n    dt = 0.01\n    srf_rad_flx = 100.0\n    srf_lat_flx = 50.0\n    srf_sen_flx = 75.0\n    qflx = 25.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    hslab = 0.05\n    rowl = 2000.0\n    cl = 500.0\n    dt = 0.02\n    srf_rad_flx = 150.0\n    srf_lat_flx = 75.0\n    srf_sen_flx = 100.0\n    qflx = 50.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    hslab = 0.2\n    rowl = 1500.0\n    cl = 750.0\n    dt = 0.025\n    srf_rad_flx = 125.0\n    srf_lat_flx = 100.0\n    srf_sen_flx = 50.0\n    qflx = 75.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    hslab = 0.15\n    rowl = 1750.0\n    cl = 625.0\n    dt = 0.03\n    srf_rad_flx = 175.0\n    srf_lat_flx = 125.0\n    srf_sen_flx = 25.0\n    qflx = 100.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    hslab = 0.25\n    rowl = 1250.0\n    cl = 875.0\n    dt = 0.035\n    srf_rad_flx = 200.0\n    srf_lat_flx = 150.0\n    srf_sen_flx = 0.0\n    qflx = 125.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\nend program main",
            "result": [
                "4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003",
                "2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003",
                "7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003",
                "1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003",
                "1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003"
            ]
        },
        "code": "subroutine driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, &\n                             tsinc, tsdot )\n\nimplicit none\n\n! input\ninteger, intent(in)                   :: jm,im\nreal(8), intent(in), dimension(jm,im) :: srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx\nreal(8), intent(in)                   :: hslab, rowl, cl, dt\n!f2py intent(in,hide)  jm,im\n\n! output\nreal(8), intent(out), dimension(jm,im) :: tsinc, tsdot\n\n! local\nreal(8) :: invcslab\n\ninvcslab = 1. / (hslab*rowl*cl)\ntsdot = (srf_rad_flx + srf_lat_flx + srf_sen_flx + qflx) * invcslab\ntsinc = 2.*dt*tsdot\n\nend subroutine driver\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called \"point_to_taylor\" that calculates the coefficients of a Taylor series polynomial interpolation. The subroutine takes in five input parameters: an integer \"m\" representing the degree of the polynomial, two arrays of type double precision \"x\" and \"y\" which store the data points, a double precision scalar \"x0\" representing the center of the interpolation, and an output array of type double precision \"c\" to store the computed coefficients. The subroutine does not return any value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 4\n    real*8, dimension(0:m) :: x, y, c\n    real*8 :: x0\n    ! Test case 1\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 1.0, 4.0, 9.0, 16.0]\n    x0 = 2.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n\n    ! Test case 2\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 1.0, 8.0, 27.0, 64.0]\n    x0 = 1.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 0.0, 0.0, 0.0, 0.0]\n    x0 = 2.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, -1.0, -4.0, -9.0, -16.0]\n    x0 = 3.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 2.0, 4.0, 6.0, 8.0]\n    x0 = 0.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\nend program main",
            "result": [
                "6.2500000000000000        5.0000000000000000        1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "3.3750000000000000        6.7500000000000000        4.5000000000000000        1.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-12.250000000000000       -7.0000000000000000       -1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        2.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine point_to_taylor(x,y,c,x0,m)\n!\n! compute the coefficients in taylor form centered at x0\n! of the interpolant of the data y at the nodes x\n!\n  integer, intent(in) :: m  ! the degree\n  double precision, dimension(0:m), intent(in) :: x,y\n  double precision, dimension(0:m), intent(out) :: c\n  double precision, intent(in) :: x0\n!\n  double precision, dimension(0:m) :: dx,newton\n  integer :: j,k\n!\n! compute the newton polynomial\n!\n  dx=x-x0\n  newton=y\n  do k=1,m\n    do j=0,m-k\n      newton(j)=(newton(j+1)-newton(j))/(dx(j+k)-dx(j))\n    end do\n  end do\n!\n! now change from newton to taylor\n!\n  c=0.d0\n  c(0)=newton(0)\n  do k=1,m\n    do j=k,1,-1\n      c(j)=c(j-1)-dx(k)*c(j)\n    end do\n    c(0)=newton(k)-dx(k)*c(0)\n  end do\n!\n  end subroutine point_to_taylor\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called ffff that calculates the values of a system of differential equations. The number of input parameters is 6. The first parameter is an integer representing the number of dimensions, the second parameter is an array of type double precision representing the initial values of the variables in the system, the third parameter is an array of integers representing the indices of the parameters in the system, the fourth parameter is an array of double precision representing the values of the parameters in the system, the fifth parameter is an integer indicating whether the Jacobian matrix is required, and the sixth parameter is an array of double precision that will store the values of the system equations. The number of output parameters is 1, which is an array of double precision that will store the partial derivatives of the system equations with respect to the variables.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ndm, icp(2), ijac, i\n    double precision :: u(2), par(2), f(2), dfdu(2,2)\n    ! Test case 1\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.5, 0.5]\n    par = [1.0, 2.0]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n\n    ! Test case 2\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [1.0, 1.0]\n    par = [0.5, 3.0]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 3\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [2.0, 0.5]\n    par = [2.5, 1.5]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 4\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.75, 0.25]\n    par = [1.2, 0.8]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 5\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.2, 0.7]\n    par = [0.9, 1.3]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000        1.1250000000000000     \n   0.0000000000000000      -0.25000000000000000        1.0000000000000000        2.0000000000000000",
                "1.0000000000000000        3.0000000000000000     \n   0.0000000000000000       0.50000000000000000        1.0000000000000000        3.0000000000000000",
                "0.50000000000000000      -0.25000000000000000     \n   0.0000000000000000       0.50000000000000000        1.0000000000000000        1.5000000000000000",
                "0.25000000000000000       0.28437501192092896     \n   0.0000000000000000      -0.41250002384185791        1.0000000000000000       0.80000001192092896",
                "0.69999998807907104        1.0219999480843549     \n   0.0000000000000000       0.25999997794628160        1.0000000000000000        1.2999999523162842"
            ]
        },
        "code": "      subroutine ffff(ndm,u,icp,par,ijac,f,dfdu)\n!     ---------- ----\n\n      implicit none\n      integer, intent(in) :: ndm, icp(*), ijac\n      double precision, intent(in) :: u(ndm), par(*)\n      double precision, intent(out) :: f(ndm)\n      double precision, intent(inout) :: dfdu(ndm,ndm)\n\n      double precision a,c\n\n       a=par(1)\n       c=par(2)\n       f(1)= u(2)\n       f(2)= c*u(2) - u(1) * (1-u(1)) * (u(1)-a)\n\n      if(ijac.eq.0)return\n\n       dfdu(1,1)= 0\n       dfdu(1,2)= 1\n\n       dfdu(2,1)= - (1-u(1))*(u(1)-a) + u(1)*(u(1)-a) - u(1)*(1-u(1))\n       dfdu(2,2)= c\n\n      end subroutine ffff\n"
    },
    {
        "instruction": "Write a Fortran subroutine called plschmidt that evaluates all the Schmidt normalized Legendre polynomials up to a given degree. The subroutine has three parameters: an input parameter lmax of type integer, an output parameter p of type real*8 (a vector of length lmax+1), and an input parameter z of type real*8. The subroutine calculates the Legendre polynomials and stores them in the output parameter p. The Legendre polynomials are normalized such that their integral over (-1,1) is equal to 2 / (2l+1). The subroutine checks for the validity of the input parameters and stops if any error is encountered.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: lmax\n    real*8, allocatable :: p(:)\n    real*8 :: z\n    integer :: l\n\n    ! Test case 1\n    lmax = 3\n    z = 0.5\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n\n    ! Test case 2\n    lmax = 2\n    z = -0.75\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 3\n    lmax = 5\n    z = 1.0\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 4\n    lmax = 1\n    z = -0.2\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 5\n    lmax = 4\n    z = 0.9\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000     \n  0.50000000000000000     \n -0.12500000000000000     \n -0.43750000000000000",
                "1.0000000000000000     \n -0.75000000000000000     \n  0.34375000000000000",
                "1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000",
                "1.0000000000000000     \n -0.20000000298023224",
                "1.0000000000000000     \n  0.89999997615814209     \n  0.71499993562698450     \n  0.47249989092350386     \n  0.20793735677004854"
            ]
        },
        "code": "subroutine plschmidt(p,lmax,z)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis function evalutates all of the schmidt normalized legendre \n!\tpolynomials up to degree lmax. \n!\n!\tcalling parameters:\n!\t\tout\n!\t\t\tp:\ta vector of all schmidt normalized legendgre polynomials evaluated at \n!\t\t\t\tz up to lmax. the lenght must by greater or equal to (lmax+1).\n!\t\tin\n!\t\t\tlmax:\tmaximum degree to compute.\n!\t\t\tz:\t[-1, 1], cos(colatitude) or sin(latitude).\n!\n!\tnotes:\n!\t\n!\t1.\tthe integral of plm**2 over (-1,1) is 2 * / (2l+1).\n!\t2.\tthe integral of plm**2 over all space is 4 pi / (2l+1).\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek june 2004\n!\n!\tcopyright (c) 2005, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\t\n\timplicit none\n\tinteger, intent(in) ::\tlmax\n\treal*8, intent(out) ::\tp(:)\n       \treal*8, intent(in) ::\tz\n       \treal*8 ::\tpm2, pm1, pl\n      \tinteger ::\tl\n\n\n\tif (size(p) < lmax+1) then\n\t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"p must be dimensioned as (lmax+1) where lmax is \", lmax \n     \t\tprint*, \"input array is dimensioned \", size(p)\n     \t\tstop\n     \telseif (lmax < 0) then \n     \t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"lmax must be greater than or equal to 0.\"\n     \t\tprint*, \"input value is \", lmax\n     \t\tstop\n     \telseif(abs(z) > 1.0d0) then\n     \t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"abs(z) must be less than or equal to 1.\"\n     \t\tprint*, \"input value is \", z\n     \t\tstop\n     \tendif\n     \t\n   \tpm2  = 1.d0\n      \tp(1) = 1.d0\n      \t\n      \tpm1  = z\n      \tp(2) = pm1\n      \t\n      \tdo l = 2, lmax\n         \tpl = ( dble(2*l-1)  * z * pm1 - dble(l-1) * pm2 )  / dble(l)\n         \tp(l+1) = pl\n         \tpm2  = pm1\n         \tpm1  = pl\n      \tenddo\n\nend subroutine plschmidt\n"
    },
    {
        "instruction": "Write a Fortran subroutine named \"eig_order_real_part\" that sorts complex eigenvalues of a matrix based on their real parts. The subroutine takes three input parameters, all of which are passed by reference. The first parameter is an array of complex numbers called \"ev\" with a dimension of \"ndim\". The second parameter is an integer array called \"idxarr\" with a dimension of \"ndim\". The last parameter is an integer called \"ndim\" representing the dimension of the matrices.\n\nThe subroutine first initializes some local variables and allocates memory for intermediate arrays. Then, it iterates through the \"ev\" array to find the smallest real part of the remaining unsorted eigenvalues. It updates the index array \"idxarr\" accordingly to indicate the proper order of the eigenvalues. Finally, the subroutine deallocates the memory and returns.\n\nMake sure to call this subroutine by passing the required input parameters and store the resulting ordered indices in \"idxarr\".",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: eigenvalues(5)\n    integer :: index_array(5)\n    integer :: ndim, i\n\n    ! Test case 1\n    ndim = 5\n    eigenvalues = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (5.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n\n    ! Test case 2\n    ndim = 5\n    eigenvalues = [(5.0, 0.0), (4.0, 0.0), (3.0, 0.0), (2.0, 0.0), (1.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 3\n    ndim = 5\n    eigenvalues = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (5.0, 0.0), (4.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 4\n    ndim = 5\n    eigenvalues = [(4.0, 0.0), (1.0, 0.0), (5.0, 0.0), (3.0, 0.0), (2.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 5\n    ndim = 5\n    eigenvalues = [(2.0, 0.0), (3.0, 0.0), (1.0, 0.0), (5.0, 0.0), (4.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1           2           3           4           5",
                "5           4           3           2           1",
                "1           2           3           5           4",
                "2           5           4           1           3",
                "3           1           2           5           4"
            ]
        },
        "code": "subroutine eig_order_real_part(ev, idxarr, ndim)\n  implicit none \n!!!-----------------------------------------------------------------!!!\n!!! this routine sorts complex eigenvalues of a matrix according to !!!\n!!! its real parts with the smallest in the first slot and reorders !!!\n!!! the matrices of left (row) and right (column) eigenvectors in a !!!\n!!! corresponding manner.                                           !!!\n!!!-----------------------------------------------------------------!!!\n  !---------- passed variables ----------\n  complex*16, intent(in) :: ev(ndim)         ! array of eigenvalues\n  integer, intent(out)   :: idxarr(ndim)     ! index array which gives proper order\n  integer :: ndim                            ! dimension of matrices \n  !f2py integer intent(hide), depend(ev)  :: ndim=shape(ev,0)\n  !---------- parameters ----------\n  real*8, parameter :: maxval = 1000.d0\n  !---------- local variables ----------\n  logical, allocatable :: sorted(:)\n  real*8,  allocatable :: sortonr(:)\n  integer :: p\n  integer :: q\n  integer :: idx\n  real*8  :: min\n  !---------- allocate dynamic memory storage ----------\n  allocate(sortonr(ndim), sorted(ndim))\n  !---------- initialize arrays ----------\n  idxarr = 0\n  sortonr = dble(ev)\n  sorted = .false.\n  !---------- create index array for real value ----------\n  sorted = .false.\n  do p = 1,ndim\n     min = maxval\n     do q = 1,ndim\n        if(.not.sorted(q).and.min.gt.sortonr(q)) then\n           min = sortonr(q)\n           idx = q\n        endif\n     enddo\n     idxarr(p) = idx\n     sorted(idx) = .true.\n  enddo\n  deallocate(sortonr, sorted)\n  return\nend subroutine eig_order_real_part\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called linear_interp to perform linear interpolation. The subroutine takes 3 input parameters and has 2 output parameters. The input parameters are: \n- x: the point where the function value is needed, of type real*8\n- x_tables: an array of 2 points from tables, of type real*8\n- f_tables: an array of 2 function values corresponding to the x_tables, of type real*8\n\nThe output parameters are:\n- fx: the function value at x, of type real*8\n- ierr: an integer error code indicating the success or failure of the interpolation\n\nThe subroutine uses the 2 points from the tables and performs linear interpolation to compute the function value at the given point x. The result is stored in the variable fx. If any error occurs during the interpolation, the ierr is set to 1.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ierr\n    real*8 :: x, fx\n    real*8 :: x_tables(2), f_tables(2)\n    \n    ! Test case 1\n    x = 3.0\n    x_tables = [1.0, 4.0]\n    f_tables = [2.0, 8.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 2\n    x = 2.5\n    x_tables = [1.0, 3.0]\n    f_tables = [2.0, 6.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 0.5\n    x_tables = [0.0, 1.0]\n    f_tables = [0.0, 2.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 5.0\n    x_tables = [3.0, 7.0]\n    f_tables = [4.0, 8.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 5\n    x = 1.0\n    x_tables = [0.0, 2.0]\n    f_tables = [1.0, 5.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\nend program main",
            "result": [
                "6.0000000000000000",
                "5.0000000000000000",
                "1.0000000000000000",
                "6.0000000000000000",
                "3.0000000000000000"
            ]
        },
        "code": "subroutine linear_interp(x,x_tables,f_tables,fx,ierr)\n! 2 points linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x ! point where function needed\n  real*8, intent(in) ::x_tables(2),f_tables(2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx\n\n  ierr=0\n  hx=(x_tables(2)-x_tables(1))\n  if(hx.eq.0.0_r8) then\n     ierr=1\n     return\n  endif\n  fx = f_tables(1)+(x-x_tables(1))/hx*(f_tables(2)-f_tables(1))\n  return\n  \nend subroutine linear_interp\n"
    },
    {
        "instruction": "Write a Fortran subroutine called check_lu to compute the sum of the absolute values of elements in a matrix. The subroutine takes two parameters: an output parameter called check, which is an array of three real numbers, and an input parameter called t, which is a two-dimensional array of real numbers. The subroutine iterates over the elements of the matrix and accumulates the absolute values based on the conditions specified in the code. The subroutine updates the check array with the computed sums.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: matrix1(3, 3), matrix2(3, 3)\n    real(8) :: check1(3), check2(3)\n    \n    ! Test case 1\n    matrix1 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n\n    ! Test case 2\n    matrix2 = reshape([9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0], shape(matrix2))\n    call check_lu(check2, matrix2)\n    print *, check2\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix1 = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix2 = reshape([1.5, 0.0, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0, 1.5], shape(matrix2))\n    call check_lu(check2, matrix2)\n    print *, check2\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix1 = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n    \nend program main",
            "result": [
                "19.000000000000000        11.000000000000000        15.000000000000000",
                "11.000000000000000        19.000000000000000        15.000000000000000",
                "20.500000000000000        12.500000000000000        16.500000000000000",
                "11.000000000000000        19.000000000000000        19.500000000000000",
                "20.500000000000000        12.500000000000000        19.500000000000000"
            ]
        },
        "code": "  subroutine check_lu( check, t )\n    implicit none\n    real(8),intent(out) :: check(3)\n    real(8),intent(in)  :: t(:,:)\n    integer :: i,j\n    do j=1,size(t,2)\n    do i=1,size(t,1)\n       if ( i <  j ) check(1)=check(1)+abs( t(i,j) )\n       if ( j <  i ) check(2)=check(2)+abs( t(i,j) )\n       if ( i == j ) check(3)=check(3)+abs( t(i,j) )\n    end do\n    end do\n  end subroutine check_lu\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called \"iqsort\" that sorts a sequence of integers in ascending order. The subroutine has two input parameters, both of which are arrays of integers. The first parameter, \"list\", is a sequence of integers that needs to be sorted. The second parameter, \"order\", is an optional array that stores the indices of the sorted sequence. The subroutine also has a recursive subroutine called \"quick_sort_1\" and a separate subroutine called \"interchange_sort\" to perform the sorting operations.\n\nIn the \"quick_sort_1\" subroutine, there are two input parameters; \"left_end\" and \"right_end\", both of which are integers. This subroutine uses the quicksort algorithm to partition the list and recursively sort the partitions until the entire list is sorted.\n\nIn the \"interchange_sort\" subroutine, there is one input parameter, \"left_end\" and \"right_end\", both of which are integers. This subroutine uses the interchange sort algorithm to sort the list by repeatedly swapping adjacent elements until the entire list is sorted.\n\nThe \"iqsort\" subroutine sorts the \"list\" in ascending order and if the \"order\" array is present, it stores the indices of the sorted sequence.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, dimension(10) :: test1, test2, test3, test4, test5\n    integer, dimension(10) :: order1, order2, order3, order4, order5\n\n    ! Test case 1\n    test1 = [9, 2, 5, 1, 6, 8, 3, 7, 4, 0]\n    call iqsort(test1, order1)\n    print *, test1\n    print *, order1\n    print *, \"&\"\n\n    ! Test case 2\n    test2 = [10, 8, 6, 4, 2, 9, 7, 5, 3, 1]\n    call iqsort(test2, order2)\n    print *, test2\n    print *, order2\n    print *, \"&\"\n\n    ! Test case 3\n    test3 = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    call iqsort(test3, order3)\n    print *, test3\n    print *, order3\n    print *, \"&\"\n\n    ! Test case 4\n    test4 = [5, 7, 2, 8, 1, 3, 9, 4, 10, 6]\n    call iqsort(test4, order4)\n    print *, test4\n    print *, order4\n    print *, \"&\"\n\n    ! Test case 5\n    test5 = [4, 7, 1, 8, 10, 2, 3, 9, 6, 5]\n    call iqsort(test5, order5)\n    print *, test5\n    print *, order5\n    print *, \"&\"\n\nend program main",
            "result": [
                "0           1           2           3           4           5           6           7           8           9\n          10           4           2           7           9           3           5           8           6           1",
                "1           2           3           4           5           6           7           8           9          10\n          10           5           9           4           8           3           7           2           6           1",
                "1           2           3           4           5           6           7           8           9          10\n           1           6           2           7           3           8           4           9           5          10",
                "1           2           3           4           5           6           7           8           9          10\n           5           3           6           8           1          10           2           4           7           9",
                "1           2           3           4           5           6           7           8           9          10\n           3           6           7           1          10           9           2           4           8           5"
            ]
        },
        "code": "recursive subroutine iqsort(list, order)\n    !!  sorts a sequence of integers\n\nimplicit none\n\ninteger, dimension (:), intent(in out)  :: list\n    !!  sequence of integers to be sorted\ninteger, dimension (:), intent(out), optional  :: order\n    !!  indices of the sorted sequence\n\n! local variable\ninteger :: i\n\nif (present(order)) then\n    do i = 1, size(list)\n      order(i) = i\n    end do\nend if\n\ncall quick_sort_1(1, size(list))\n\ncontains\n\n    recursive subroutine quick_sort_1(left_end, right_end)\n    \n    integer, intent(in) :: left_end, right_end\n    \n    !     local variables\n    integer             :: i, j, itemp\n    integer             :: reference, temp\n    integer, parameter  :: max_simple_sort_size = 8\n    \n    if (right_end < left_end + max_simple_sort_size) then\n        ! use interchange sort for small lists\n        call interchange_sort(left_end, right_end)\n    \n    else\n        ! use partition (\"quick\") sort\n        reference = list((left_end + right_end)/2)\n        i = left_end - 1; j = right_end + 1\n    \n        do\n            ! scan list from left end until element >= reference is found\n            do\n                i = i + 1\n                if (list(i) >= reference) exit\n            end do\n            ! scan list from right end until element <= reference is found\n            do\n                j = j - 1\n                if (list(j) <= reference) exit\n            end do\n    \n            if (i < j) then\n                ! swap two out-of-order elements\n                temp = list(i); list(i) = list(j); list(j) = temp\n                if (present(order)) then\n                    itemp = order(i); order(i) = order(j); order(j) = itemp\n                end if\n            else if (i == j) then\n                i = i + 1\n                exit\n            else\n                exit\n            end if\n        end do\n    \n        if (left_end < j) call quick_sort_1(left_end, j)\n        if (i < right_end) call quick_sort_1(i, right_end)\n    end if\n    \n    end subroutine quick_sort_1\n\n\n    subroutine interchange_sort(left_end, right_end)\n    \n    integer, intent(in) :: left_end, right_end\n    \n    !     local variables\n    integer             :: i, j, itemp\n    integer                :: temp\n    \n    do i = left_end, right_end - 1\n        do j = i+1, right_end\n            if (list(i) > list(j)) then\n                temp = list(i); list(i) = list(j); list(j) = temp\n                if (present(order)) then\n                    itemp = order(i); order(i) = order(j); order(j) = itemp\n                end if\n            end if\n        end do\n    end do\n    \n    end subroutine interchange_sort\n\nend subroutine iqsort\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"average\" that calculates the average of an array. The subroutine takes three arguments: \"arr\" - an input array of real numbers, \"size\" - the size of the array (integer input), and \"value\" - the average value (real output). \n\nTo use the subroutine, provide the input array and its size, and the subroutine will calculate the average value and store it in the \"value\" variable.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: i, size\n    real, dimension(:), allocatable :: arr\n    real :: value\n    \n    ! Test case 1\n    size = 5\n    allocate(arr(size))\n    arr = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 2\n    size = 8\n    allocate(arr(size))\n    arr = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 3\n    size = 3\n    allocate(arr(size))\n    arr = [10.0, 20.0, 30.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 4\n    size = 6\n    allocate(arr(size))\n    arr = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 5\n    size = 4\n    allocate(arr(size))\n    arr = [2.0, 4.0, 6.0, 8.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.00000000",
                "4.00000000",
                "20.0000000",
                "5.00000000",
                "5.00000000"
            ]
        },
        "code": "subroutine average(arr, size, value)\n    implicit none\n    integer:: size, count\n    real, intent(out):: value\n    real, dimension(size):: arr\n    count = 1\n    value = 0\n!f2py intent(in) size\n!f2py depend(size) arr\n\n100 if (count.le.size) then\n        value = value + arr(count)\n        count = count + 1\n        goto 100\n    endif\n    value = value / size\n    return\nend subroutine average\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called \"msa\" to perform the two-dimensional method of successive approximations (MSA). The subroutine takes in six parameters: \n\n1. \"n1\" and \"n2\" are integers representing the dimensions of the two-dimensional arrays.\n2. \"y0\" is a two-dimensional real array that serves as input.\n3. \"x0\" is a two-dimensional real array that serves as both input and output.\n4. \"stepsize\" is a real number representing the step size. \n5. \"x1\" is a two-dimensional real array that serves as the output.\n\nIn the subroutine, the elements of \"x1\" are initialized to zero. Then, a nested loop is used to iterate over the elements of the arrays. For each element, the value in \"x0\" is updated using the MSA formula: \n\nx1(j, i) = x0(j, i) + stepsize * (y0(j, i) - x0(j, i))\n\nFinally, the subroutine is concluded with a return statement.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n1 = 3, n2 = 2\n    real*8 :: x0(n1, n2), y0(n1, n2), x1(n1, n2), stepsize\n    integer :: i, j\n    \n    ! Test case 1\n    stepsize = 0.1\n    x0 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n1, n2])\n    y0 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    stepsize = 0.01\n    x0 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n1, n2])\n    y0 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    stepsize = 0.001\n    x0 = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0], [n1, n2])\n    y0 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    stepsize = 0.5\n    x0 = reshape([2.0, 3.0, 4.0, 5.0, 6.0, 7.0], [n1, n2])\n    y0 = reshape([1.0, 1.5, 2.0, 2.5, 3.0, 3.5], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    stepsize = 0.05\n    x0 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [n1, n2])\n    y0 = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.94999999925494194     \n   1.8999999985098839     \n   2.8499999977648258     \n   3.7999999970197678     \n   4.7499999962747097     \n   5.6999999955296516",
                "9.9999997764825821E-003\n   1.9999999552965164E-002\n   2.9999999329447746E-002\n   3.9999999105930328E-002\n   4.9999998882412910E-002\n   5.9999998658895493E-002",
                "9.9899999995250255     \n   19.979999999050051     \n   29.969999998575076     \n   39.959999998100102     \n   49.949999997625127     \n   59.939999997150153",
                "1.5000000000000000     \n   2.2500000000000000     \n   3.0000000000000000     \n   3.7500000000000000     \n   4.5000000000000000     \n   5.2500000000000000",
                "0.47999999977648256     \n  0.95999999955296511     \n   1.4399999997019768     \n   1.9199999991059302     \n   2.3999999985098839     \n   2.8799999994039536"
            ]
        },
        "code": "    subroutine msa(x0,y0,x1,stepsize,n1,n2) ! two dimension msa\n    implicit none\n! x0 is input and also output\n    integer,intent(in)::n1,n2! two dimension\n    real*8,intent(in)::y0(n1,n2)\n    real*8,intent(in)::x0(n1,n2)\n    real*8,intent(out)::x1(n1,n2)\n    real*8,intent(in)::stepsize\n    integer:: i,j\n\n    x1=0.0\n    do i=1,n2\n      do j=1,n1\n        x1(j,i)=x0(j,i)+stepsize*(y0(j,i)-x0(j,i))\n      enddo \n    enddo \n    return \n    end subroutine\n"
    },
    {
        "instruction": "Please write a Fortran subroutine called nearsquare that finds two numbers a and b, such that their product is closest to a given number n. The subroutine takes in 1 input parameter of type integer, which represents the number n. It also has 2 output parameters, both of type integer, which represent the numbers a and b.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: num, result1, result2\n    ! Test case 1\n    num = 10\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n\n    ! Test case 2\n    num = 20\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    num = 15\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 4\n    num = 7\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 5\n    num = 25\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\nend program main",
            "result": [
                "2           5",
                "5           4",
                "3           5",
                "1           7",
                "5           5"
            ]
        },
        "code": "    subroutine nearsquare(n, a, b)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: a, b\n\n        do a=ceiling(sqrt(n*1.0)),1,-1\n            b = n/a\n            if (a*b == n) exit\n        enddo\n    end subroutine nearsquare\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called \"potinv\" to compute the inverse of a matrix using a power iteration method. The subroutine contains several input and output parameters. The input parameters are:\n- \"a\" is a two-dimensional real array that represents the matrix.\n- \"q\" is a real number that represents the initial value for the power iteration method.\n- \"xlam\" is a real number that represents the initial eigenvalue estimate.\n- \"eps\" is a real number that represents the tolerance for convergence.\n- \"nmaxit\" is an integer that represents the maximum number of iterations allowed.\n\nThe output parameters are:\n- \"u\" is a one-dimensional real array that represents the left eigenvector.\n- \"v\" is a one-dimensional real array that represents the right eigenvector.\n- \"ier\" is an integer that represents the convergence status of the power iteration method.\n\nTo use the subroutine, make sure to pass the correct dimensions for the array \"a\" and allocate enough memory for the arrays \"u\" and \"v\". After calling the subroutine, check the value of \"ier\" to determine if the computation was successful.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real, dimension(3,3) :: matrix\n    real :: q, xlam, eps\n    real, dimension(3) :: u, v\n    integer :: nmaxit, ier\n    ! Test case 1\n    matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])\n    q = 0.5\n    xlam = 1.0\n    eps = 1.0E-6\n    nmaxit = 100\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 2\n    matrix = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [3, 3])\n    q = 1.0\n    xlam = 2.0\n    eps = 1.0E-8\n    nmaxit = 200\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 3\n    matrix = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [3, 3])\n    q = 0.1\n    xlam = 0.5\n    eps = 1.0E-4\n    nmaxit = 50\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 4\n    matrix = reshape([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0, 27.0], [3, 3])\n    q = 1.5\n    xlam = 0.2\n    eps = 1.0E-5\n    nmaxit = 150\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 5\n    matrix = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3, 3])\n    q = 0.8\n    xlam = 0.1\n    eps = 1.0E-7\n    nmaxit = 80\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.00000000       2.00000000       3.00000000       4.00000000       5.00000000       6.00000000       7.00000000       8.00000000       9.00000000    \n  0.500000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n   1.00000000    \n   9.99999997E-07\n         100\n           0",
                "2.00000000       4.00000000       6.00000000       8.00000000       10.0000000       12.0000000       14.0000000       16.0000000       18.0000000    \n   1.00000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n   2.00000000    \n   9.99999994E-09\n         200\n           0",
                "0.100000001      0.200000003      0.300000012      0.400000006      0.500000000      0.600000024      0.699999988      0.800000012      0.899999976    \n  0.100000001    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.500000000    \n   9.99999975E-05\n          50\n           0",
                "3.00000000       6.00000000       9.00000000       12.0000000       15.0000000       18.0000000       21.0000000       24.0000000       27.0000000    \n   1.50000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.200000003    \n   9.99999975E-06\n         150\n           0",
                "0.500000000      0.600000024      0.699999988      0.800000012      0.899999976       1.00000000       1.10000002       1.20000005       1.29999995    \n  0.800000012    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.100000001    \n   1.00000001E-07\n          80\n           0"
            ]
        },
        "code": "    subroutine potinv(a, q, u, v, xlam, eps, nmaxit, ier)\n      implicit none\n      real, dimension(:,:), intent(inout) :: a\n      real, intent(in) :: q\n      real, dimension(:), intent(out) :: u, v\n      real, intent(inout) :: xlam\n      real, intent(in) :: eps\n      integer, intent(in) :: nmaxit\n      integer, intent(out) :: ier\n    end subroutine\n"
    },
    {
        "instruction": "Write a Fortran subroutine named \"intplt3d\" that performs bi-linear interpolation. The subroutine takes 6 input parameters and 2 output parameters. The input parameters are:\n- l: an array of 3 integers\n- n: an array of 3 integers\n- x: an array of 3 real numbers\n- d: an array of 3 real numbers\n- dm: a 2x3 array of real numbers\n\nThe output parameters are:\n- idx: an array of 3 integers\n- coe: an array of 3 real numbers\n\nThe subroutine checks if the given coordinates are inside a defined box, and assigns an error code to \"ier\" accordingly. It then calculates the interpolation indices and coefficients based on the input parameters. Finally, it updates \"idx\" and \"coe\" variables accordingly.\n\nYour task is to write the Fortran subroutine called \"intplt3d\" with the specified input and output parameters, following the given code.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: x(3), d(3), dm(2,3)\n    integer :: l(3), n(3), idx(3), ier\n    real :: coe(3)\n    \n    ! Test case 1\n    x = [1.5, 2.5, 3.5]\n    l = [1, 1, 1]\n    n = [5, 5, 5]\n    d = [0.5, 0.5, 0.5]\n    dm = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [2.0, 3.0, 4.0]\n    l = [2, 3, 4]\n    n = [4, 4, 4]\n    d = [0.25, 0.25, 0.25]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [3.0, 1.0, 5.0]\n    l = [1, 2, 3]\n    n = [3, 2, 4]\n    d = [0.5, 0.5, 0.5]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [4.5, 3.5, 2.5]\n    l = [3, 3, 2]\n    n = [6, 5, 4]\n    d = [0.2, 0.2, 0.2]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [2.0, 4.0, 6.0]\n    l = [2, 4, 6]\n    n = [6, 8, 10]\n    d = [0.1, 0.1, 0.1]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2           0          -2          -3\n   0.00000000       0.00000000       0.00000000",
                "9           5           1           1\n   0.00000000       0.00000000       0.00000000",
                "7          -1           3          -2\n   0.00000000       0.00000000       0.00000000",
                "23           8          -6          -3\n  0.499999523      0.499999523     -0.499999523",
                "21          21          21           3\n   0.00000000       0.00000000       0.00000000"
            ]
        },
        "code": "subroutine intplt3d(x,l,n,d,dm,idx,coe,ier)\n\n!*************************************************\n!  this routine computes an interpolation indices\n!  and coefficients using bi-linear interpolation.\n!\n!  history: jan. 2004 by yuanfu xie.\n!*************************************************\n\n  implicit none\n\n  integer, intent(in) :: l(3),n(3)\n  real,    intent(in) :: x(3),d(3),dm(2,3)\n\n  integer, intent(out) :: idx(3),ier\n  real,    intent(out) :: coe(3)\n\n  ! local variables:\n  integer :: i\n\n  ier = 0\n  ! check in box?\n  do i=1,3\n     if (x(i) .lt. dm(1,i)) ier = -i\n     if (x(i) .gt. dm(2,i)) ier = i\n  enddo\n\n  ! indices:\n  idx = (x-dm(1,1:3))/d\n\n  ! coefficients:\n  coe = (x-idx*d-dm(1,1:3))/d\n\n  idx = idx+1\n\nend subroutine intplt3d\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called simp to perform numerical integration using Simpson's rule. The subroutine takes in three parameters: an integer m representing the number of subintervals, a real array f containing the function values, and a real variable s to store the computed integration result. The subroutine also allocates memory for another real array g to perform the integration calculations. The subroutine uses a select case statement to handle different values of m and calculates the integration using Simpson's rule formula. The final result is stored in the variable s.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8, allocatable :: f(:)\n    real*8 :: s\n    integer :: m, i\n    ! Test case 1\n    m = 3\n    allocate(f(6))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 2\n    m = 2\n    allocate(f(8))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 3\n    m = 4\n    allocate(f(7))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 4\n    m = 6\n    allocate(f(9))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 5\n    m = 5\n    allocate(f(10))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\nend program main",
            "result": [
                "17.500000000000000",
                "24.000000000000000",
                "12.000000000000000",
                "24.000000000000000",
                "49.500000000000000"
            ]
        },
        "code": "  subroutine simp(f,s,m)\n    implicit none\n    integer,intent(in)  :: m\n    real(8),intent(in)  :: f(:)\n    real(8),intent(out) :: s\n    real(8),allocatable :: g(:)\n    integer :: i,n,nn,nmax\n    n=size(f) ; nmax=int(n/m)*m\n    do i=0,m\n       nmax=nmax+i ; if ( nmax>=n ) exit\n    end do\n    allocate( g(nmax) ) ; g(1:n)=f ; if ( nmax>n ) g(n+1:)=0.d0\n    select case(m)\n    case default\n       s = 0.5d0*(f(1)+f(n)) + sum(f(2:n-1))\n    case(2)\n       s=0.d0\n       do i=1,nmax-2,2\n          s = s + g(i) + 4.d0*g(i+1) + g(i+2)\n       end do\n       s=s/3.d0\n    case(4)\n       s=0.d0\n       do i=1,nmax-4,4\n          s=s+7*g(i)+32*g(i+1)+12*g(i+2)+32*g(i+3)+7*g(i+4)\n       end do\n       s=s*2.d0/45.d0\n    case(6)\n       s=0.d0\n       do i=1,nmax-6,6\n          s=s+41*g(i)+216*g(i+1)+27*g(i+2)+272*g(i+3) &\n               +27*g(i+4)+216*g(i+5)+41*g(i+6)\n       end do\n       s=s/140.d0\n    end select\n    deallocate( g )\n    return\n  end subroutine simp\n"
    },
    {
        "instruction": "Please create a Fortran subroutine named \"tria_getneighbourvertex\" that calculates the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes in three input parameters: the vertex number, either ivt1 or ivt2, of one vertex adjacent to the edge, the vertex number of the other vertex adjacent to that edge, and the vertex number of the vertex for which we want to find the neighbor. All input parameters should be of type integer. The subroutine has one output parameter, the vertex number of the neighbor of the input vertex, which is also of type integer.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ivertex, ivt1, ivt2, ineighbour\n    ! Test case 1\n    ivertex = 1\n    ivt1 = 2\n    ivt2 = 3\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n\n    ! Test case 2\n    ivertex = 3\n    ivt1 = 5\n    ivt2 = 7\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 3\n    ivertex = 2\n    ivt1 = 9\n    ivt2 = 4\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 4\n    ivertex = 7\n    ivt1 = 10\n    ivt2 = 12\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 5\n    ivertex = 1\n    ivt1 = 20\n    ivt2 = 15\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\nend program main",
            "result": [
                "4",
                "9",
                "11",
                "15",
                "34"
            ]
        },
        "code": "  elemental subroutine tria_getneighbourvertex(ivertex,ivt1,ivt2,ineighbour)\n\n!<description>\n  ! calculates the vertex number of the neighbour vertex of a vertex on an\n  ! edge.\n  !\n  ! ivt1 and ivt2 are the vertex numbers of two vertices connected\n  ! by an edge. ivertex is either ivt1 or ivt2.\n  ! the result of this routine is the number of the neighbour vertex\n  ! of ivertex, i.e. if ivertex=ivt1, ineighbour=ivt2 and if\n  ! ivertex=ivt2, ineighbour=ivt1.\n!</description>\n\n!<input>\n  ! vertex number. either ivt1 or ivt2.\n  integer, intent(in) :: ivertex\n\n  ! vertex number of one vertex adjacent to an edge.\n  integer, intent(in) :: ivt1\n\n  ! vertex number of the other vertex adjacent to that edge.\n  integer, intent(in) :: ivt2\n!</input>\n\n!<output>\n  ! vertex number of the neighbour of ivertex.\n  integer, intent(out) :: ineighbour\n!</output>\n\n\n    ! note: directly implementing this formula into the program\n    ! code brings more speed :-)\n    ! but to have a reference not to forget the formula, we have\n    ! this routine...\n\n    ineighbour = ivt1 + ivt2 - ivertex\n\n  end subroutine tria_getneighbourvertex\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called diag3x3 to compute the eigenvalues and eigenvectors of a 3x3 complex matrix. The number of input parameters is 2, both are arrays of type complex. The first argument is the input matrix to be diagonalized. The second argument is an empty array to store the eigenvectors. The number of output arguments is 1, which is an array of type real to store the eigenvalues.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex(8) :: za(3,3), zb(3,3)\n    real(8) :: lambda(3)\n    ! Test case 1\n    za = reshape([ (1.0,0.0), (2.0,0.0), (3.0,0.0), &\n                   (4.0,0.0), (5.0,0.0), (6.0,0.0), &\n                   (7.0,0.0), (8.0,0.0), (9.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n\n    ! Test case 2\n    za = reshape([ (1.0,0.0), (0.0,2.0), (0.0,3.0), &\n                   (0.0,4.0), (5.0,0.0), (0.0,6.0), &\n                   (0.0,7.0), (0.0,8.0), (9.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 3\n    za = reshape([ (1.0,2.0), (2.0,3.0), (3.0,4.0), &\n                   (4.0,5.0), (5.0,6.0), (6.0,7.0), &\n                   (7.0,8.0), (8.0,9.0), (9.0,10.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 4\n    za = reshape([ (1.0,1.0), (2.0,2.0), (3.0,3.0), &\n                   (4.0,4.0), (5.0,5.0), (6.0,6.0), &\n                   (7.0,7.0), (8.0,8.0), (9.0,9.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 5\n    za = reshape([ (1.0,0.0), (0.0,1.0), (0.0,0.0), &\n                   (0.0,0.0), (0.0,1.0), (0.0,0.0), &\n                   (0.0,0.0), (0.0,0.0), (1.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\nend program main",
            "result": [
                "( 0.40962667186957691     ,  0.0000000000000000     ) ( 0.54264864772970856     ,  0.0000000000000000     ) ( 0.73330650809206144     ,  0.0000000000000000     ) ( 0.80238890789373596     ,  0.0000000000000000     ) ( 0.16812656383796734     ,  0.0000000000000000     ) (-0.57263033365438787     , -0.0000000000000000     ) ( 0.43402537965210303     ,  0.0000000000000000     ) (-0.82296166596577036     , -0.0000000000000000     ) ( 0.36654613102403844     ,  0.0000000000000000     )\n   18.830235795506841       -3.1574678406080730      -0.67276795489876073",
                "(-0.12517209412915209     , 0.34653515621389558     ) ( 0.10952558236300809     , 0.52121227265931835     ) ( 0.76196275893017640     ,  0.0000000000000000     ) ( 0.67609728026600180     ,  0.0000000000000000     ) ( 0.34642490457344727     , 0.37896661786495800     ) (-0.19795708832768413     , 0.48997912897695300     ) (-0.59616659337805411     , 0.22742733546355981     ) ( 0.67284173597706110     ,  0.0000000000000000     ) (-0.29808329668902706     , 0.22647857864779952     )\n   17.655861716958530       -6.3151017148784687        3.6592399979199439",
                "( 0.13947815163301430     , 0.36595195406202330     ) ( 0.27295851347756461     , 0.42489449665013257     ) ( 0.76914454374439467     ,  0.0000000000000000     ) ( 0.87353504210425792     ,  0.0000000000000000     ) ( 0.13191815827504771     , 0.10264409584098245     ) (-0.17884989949405666     , 0.42072679112838168     ) ( 0.82659319087957672     ,  0.0000000000000000     ) (-0.16975192835512903     , -9.1653045206760486E-002) ( 0.17049916179951613     , 0.50045752541172228     )\n   26.950081976061885       -12.731180857299655       0.78109888123778382",
                "( 0.18945014374311919     , 0.34801959129372367     ) ( 0.30757220253834183     , 0.41079280937449114     ) ( 0.76134066954510382     ,  0.0000000000000000     ) ( 0.87428249558047888     ,  0.0000000000000000     ) ( 0.11640138688428994     ,  7.0688213013176321E-002) (-0.19545674287675729     , 0.42294287233383770     ) ( 0.83630338537964866     ,  0.0000000000000000     ) (-0.18996721697932903     ,-0.11127747686419090     ) ( 0.11158552846557929     , 0.48956623357362389     )\n   25.114432314033717       -10.493870414289161       0.37943810025545233",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     )\n   1.3333333333333333       0.33333333333333348       0.33333333333333348"
            ]
        },
        "code": "subroutine diag3x3(za,zb,lambda)\n  implicit none\n  real(8),parameter :: pi=4d0*atan(1d0)\n  complex(8), intent(in) :: za(3,3)\n  complex(8), intent(out) :: zb(3,3)\n  real(8), intent(out) :: lambda(3)\n\n  real(8) :: c0,c1,c2\n  real(8) :: p,q,t,ss,phi,xx(3),xx_t(3)\n  complex(8) :: zc(3,3),zx,zy\n  integer :: ivec,imin\n\n  c2 = -real(za(1,1)+za(2,2)+za(3,3))\n  c1 = real( za(1,1)*za(2,2) + za(2,2)*za(3,3) + za(3,3)*za(1,1) &\n       -abs(za(1,2))**2 -abs(za(1,3))**2 -abs(za(2,3))**2 )\n  c0 = real( za(1,1)*abs(za(2,3))**2 + za(2,2)*abs(za(1,3))**2 &\n       + za(3,3)*abs(za(1,2))**2 - za(1,1)*za(2,2)*za(3,3) &\n       - 2d0*conjg(za(1,3))*za(1,2)*za(2,3) )\n\n  p = c2**2 - 3d0*c1\n  q = -27d0*c0/2d0 -c2**3 + 9d0*c2*c1/2d0\n  ss = c1**2*(p-c1)/4d0+c0*(q+27d0*c0/4d0)\n  ss = sqrt(27d0*ss)/q\n  phi = atan(ss)/3d0\n  if(phi < 0)phi = phi + pi\n\n  xx(1) = 2d0*cos(phi)\n  xx(2) = 2d0*cos(phi+2d0*pi/3d0)\n  xx(3) = 2d0*cos(phi-2d0*pi/3d0)\n\n  lambda(:) = (sqrt(p)*xx(:)-c2)/3d0\n\n  do ivec = 1,3\n\n    zc = za\n    zc(1,1) = zc(1,1) -lambda(ivec)\n    zc(2,2) = zc(2,2) -lambda(ivec)\n    zc(3,3) = zc(3,3) -lambda(ivec)\n\n    xx(1) = abs(zc(1,1))\n    xx(2) = abs(zc(2,2))\n    xx(3) = abs(zc(3,3))\n    if(xx(1)<xx(2))then\n      if(xx(1)<xx(3))then\n        imin = 1\n      else\n        imin = 3\n      end if\n    else\n      if(xx(2)<xx(3))then\n        imin=2\n      else\n        imin=3\n      end if\n    end if\n\n    select case(imin)\n    case(1)\n! first vector\n      zx = (conjg(zc(1,3))*zc(2,3) - zc(3,3)*conjg(zc(1,2))) &\n        /(zc(2,2)*zc(3,3)-abs(zc(2,3))**2)\n      zy = -(conjg(zc(1,3)) + conjg(zc(2,3))*zx)/zc(3,3)\n  \n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = ss; zb(2,ivec) = zx*ss; zb(3,ivec) = zy*ss\n    case(2)\n! second vector\n      zx = (conjg(zc(1,3))*zc(1,2) - zc(1,1)*conjg(zc(2,3))) &\n        /(zc(1,1)*zc(3,3)-abs(zc(1,3))**2)\n      zy = -(zc(1,2) + zc(1,3)*zx)/zc(1,1)\n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = zy*ss; zb(2,ivec) = ss; zb(3,ivec) = zx*ss\n    case(3)\n! third vector\n      zx = (zc(1,2)*zc(2,3) - zc(2,2)*zc(1,3)) &\n        /(zc(1,1)*zc(2,2)-abs(zc(1,2))**2)\n      zy = -(zc(2,3) + conjg(zc(1,2))*zx)/zc(2,2)\n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = zx*ss; zb(2,ivec) = zy*ss; zb(3,ivec) = ss\n    case default\n      stop \"failed in diag3x3\"\n    end select\n  end do\nend subroutine diag3x3\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called forward that calculates the solution vector for a given input vector using a finite difference method. The subroutine takes in 5 input parameters: a (velocity), dx (spatial step size), dt (time step size), u0 (initial vector), and an output parameter u (solution vector). All parameters are of type double precision. The subroutine updates the elements of the solution vector u using parallel computation, except for the leftmost element. The subroutine then calculates the value of the leftmost element of u.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision, dimension(5) :: u0, u\n    double precision :: a, dx, dt\n    \n    ! Test case 1\n    a = 1.0\n    dx = 0.1\n    dt = 0.01\n    u0 = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 2\n    a = 0.5\n    dx = 0.2\n    dt = 0.001\n    u0 = [0.0, 1.0, 0.0, 1.0, 0.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 3\n    a = 2.0\n    dx = 0.05\n    dt = 0.005\n    u0 = [2.0, 3.0, 4.0, 5.0, 6.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 4\n    a = 1.5\n    dx = 0.1\n    dt = 0.01\n    u0 = [3.0, 2.0, 1.0, 2.0, 3.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 5\n    a = 0.8\n    dx = 0.2\n    dt = 0.001\n    u0 = [1.0, 1.0, 1.0, 1.0, 1.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0999999962747098        1.9000000037252902        2.9000000037252902        3.9000000037252902        4.9000000037252907",
                "0.0000000000000000       0.99749999991850924        2.5000000814907239E-003  0.99749999991850924        2.5000000814907239E-003",
                "2.3999999850988392        2.8000000074505804        3.8000000074505804        4.8000000074505804        5.8000000074505804",
                "3.4499999832361938        2.1499999944120645        1.1499999944120647        1.8500000055879353        2.8500000055879355",
                "1.0040000001899898        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "  subroutine forward(u0,u,a,dx,dt)\n\n    ! eingabe:\n    ! u0 = ausgangsvektor\n    ! u = ausgabevektor\n    ! a = geschwindigkeit (>0)\n    ! dx = ortsschrittweite\n    ! dt = zeitschrittweite\n\n    double precision, intent(in)\t\t\t:: a, dx, dt\n    double precision, dimension(:), intent(out)\t\t:: u\n    double precision, dimension(:), intent(in)\t\t:: u0\n    integer\t\t\t\t\t\t:: i,j\n    double precision\t\t\t\t\t:: k1\n\n    ! hilfsvariable\n    k1 = a*dt/dx\n\n    ! berechne den loesungsvektor fuer alle ausser dem linken x (parallel)\n    forall(i=lbound(u0,1)+1:ubound(u0,1))\n       u(i) = u0(i)-k1*(u0(i)-u0(i-1))\n    end forall\n\n    ! berechne den loesungswert fuer das linke x\n    u(lbound(u0,1)) = u0(lbound(u0,1))+k1*u0(lbound(u0,1))\n\n  end subroutine forward\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine code called vmflow that calculates the Von Mises flow stress components of a material. The subroutine has three input parameters and one output parameter. The first input parameter is an array of real numbers called \"stress\". The second input parameter is a single real number called \"dsbar\". The third input parameter is an array of real numbers called \"vmfl\". The output parameter is also an array of real numbers called \"vmfl\".",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n = 4\n    real*8 :: stress(4), dsbar, vmfl(4)\n    \n    ! Test case 1\n    stress = [1.0, 2.0, 3.0, 4.0]\n    dsbar = 2.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 2\n    stress = [5.0, 6.0, 7.0, 8.0]\n    dsbar = 1.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 3\n    stress = [0.0, 0.0, 0.0, 0.0]\n    dsbar = 0.5\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 4\n    stress = [10.0, 20.0, 30.0, 40.0]\n    dsbar = 5.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 5\n    stress = [4.0, 3.0, 2.0, 1.0]\n    dsbar = 3.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-1.0000000000000000      -0.25000000000000011        4.5000000000000000        1.2500000000000000",
                "-1.9999999999999996      -0.49999999999999956        21.000000000000000        2.5000000000000004",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-4.0000000000000000      -0.99999999999999967        18.000000000000000        5.0000000000000000",
                "0.66666666666666663       0.16666666666666674        2.0000000000000000      -0.83333333333333337"
            ]
        },
        "code": "subroutine vmflow(stress,dsbar,vmfl)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::stress(:),dsbar\n real(iwp),intent(out)::vmfl(:)\n real(iwp)::sigm,onept5=1.5_iwp,two=2.0_iwp,d3=3.0_iwp\n sigm=(stress(1)+stress(2)+stress(4))/d3\n vmfl(1)=stress(1)-sigm\n vmfl(2)=stress(2)-sigm\n vmfl(3)=stress(3)*two \n vmfl(4)=stress(4)-sigm\n vmfl=vmfl*onept5/dsbar\nreturn\nend subroutine vmflow\n"
    },
    {
        "instruction": "Provide a Fortran subroutine named transpose2_d that performs a transpose operation on a 2-dimensional matrix. The subroutine takes in 4 input parameters and 2 output parameters. The first input parameter is an integer m, representing the number of rows in the matrix. The second input parameter is an integer n, representing the number of columns in the matrix. The third and fourth input parameters, mtx and mtxd, are 2-dimensional arrays of real numbers with dimensions (m, n). The output parameters, new_mtx and new_mtxd, are also 2-dimensional arrays of real numbers with dimensions (n, m). \n\nIn the subroutine, the transpose operation is performed by iterating over each element of the input matrices and assigning the corresponding element to the transposed position in the output matrices. The resulting transposed matrices are stored in the new_mtx and new_mtxd arrays, respectively.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 3\n    integer, parameter :: n = 2\n    real(kind=8) :: mtx(m, n)\n    real(kind=8) :: mtxd(m, n)\n    real(kind=8) :: new_mtx(n, m)\n    real(kind=8) :: new_mtxd(n, m)\n    \n    ! Test case 1\n    mtx = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [m, n])\n    mtxd = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 2\n    mtx = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0], [m, n])\n    mtxd = reshape([0.2, 0.4, 0.6, 0.8, 1.0, 1.2], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 3\n    mtx = reshape([3.0, 6.0, 9.0, 12.0, 15.0, 18.0], [m, n])\n    mtxd = reshape([0.3, 0.6, 0.9, 1.2, 1.5, 1.8], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 4\n    mtx = reshape([4.0, 8.0, 12.0, 16.0, 20.0, 24.0], [m, n])\n    mtxd = reshape([0.4, 0.8, 1.2, 1.6, 2.0, 2.4], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 5\n    mtx = reshape([5.0, 10.0, 15.0, 20.0, 25.0, 30.0], [m, n])\n    mtxd = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000        4.0000000000000000        2.0000000000000000        5.0000000000000000        3.0000000000000000        6.0000000000000000     \n  0.10000000149011612       0.40000000596046448       0.20000000298023224       0.50000000000000000       0.30000001192092896       0.60000002384185791",
                "2.0000000000000000        8.0000000000000000        4.0000000000000000        10.000000000000000        6.0000000000000000        12.000000000000000     \n  0.20000000298023224       0.80000001192092896       0.40000000596046448        1.0000000000000000       0.60000002384185791        1.2000000476837158",
                "3.0000000000000000        12.000000000000000        6.0000000000000000        15.000000000000000        9.0000000000000000        18.000000000000000     \n  0.30000001192092896        1.2000000476837158       0.60000002384185791        1.5000000000000000       0.89999997615814209        1.7999999523162842",
                "4.0000000000000000        16.000000000000000        8.0000000000000000        20.000000000000000        12.000000000000000        24.000000000000000     \n  0.40000000596046448        1.6000000238418579       0.80000001192092896        2.0000000000000000        1.2000000476837158        2.4000000953674316",
                "5.0000000000000000        20.000000000000000        10.000000000000000        25.000000000000000        15.000000000000000        30.000000000000000     \n  0.50000000000000000        2.0000000000000000        1.0000000000000000        2.5000000000000000        1.5000000000000000        3.0000000000000000"
            ]
        },
        "code": "  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(in) :: mtxd(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    real(kind=8), intent(out) :: new_mtxd(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtxd(j, i) = mtxd(i, j)\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2_d\n"
    },
    {
        "instruction": "Write a Fortran subroutine called matmul2_d that performs matrix multiplication. The subroutine takes in 7 input parameters and 2 output parameters. The first three input parameters are integers representing the dimensions of the matrices. The next two input parameters are 2D arrays of type real, representing matrices A and B. The following two input parameters are also 2D arrays of type real, representing matrices AD and BD. The last two parameters are 2D arrays of type real, representing matrices C and CD, which are the output matrices. \n\nThe subroutine initializes matrices C and CD with zeros. Then, it performs matrix multiplication by multiplying corresponding elements of matrices AD and B, and adding them to CD. Similarly, it multiplies corresponding elements of matrices A and BD, and adds them to CD. Finally, it multiplies corresponding elements of matrices A and B, and adds them to C.\n\nImplement the subroutine according to these instructions.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 3, n = 2, p = 4\n    real(kind=8) :: a(m, n), ad(m, n), b(n, p), bd(n, p), c(m, p), cd(m, p)\n    \n    ! Test case 1\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 2\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0., 0., 0., 0., 0., 0.], [m, n])\n    b = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8], [n, p])\n    bd = reshape([0., 0., 0., 0., 0., 0., 0., 0.], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 3\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([1., 0., 0., 1., 1., 0., 0., 1.], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 4\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], [n, p])\n    bd = reshape([0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 5\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([1., 2., 3., 4., 5., 6., 7., 8.], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\nend program main",
            "result": [
                "0.90000001341104507        1.2000000178813934        1.5000000223517418        1.9000000357627869        2.6000000536441803        3.3000000715255737        2.9000000953674316        4.0000001192092896        5.1000001430511475        3.9000000357627869        5.4000000357627869        6.9000000357627869     \n  0.18000000067055227       0.23999999940395356       0.30000000484287748       0.38000000216066843       0.52000000044703487       0.66000001288950472       0.58000000923872008       0.80000000819563866        1.0200000287592417       0.78000000253319746        1.0799999973177909        1.3800000211596490",
                "0.90000001341104507        1.2000000178813934        1.5000000223517418        1.9000000357627869        2.6000000536441803        3.3000000715255737        2.9000000953674316        4.0000001192092896        5.1000001430511475        3.9000000357627869        5.4000000357627869        6.9000000357627869     \n   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000        1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000     \n  0.18999999947845936       0.32000000029802322       0.45000000856816769       0.59000000171363354       0.75999999418854713       0.93000001646578312       0.38999999687075615       0.59999999776482582       0.81000000610947609       0.78999999910593033        1.0399999916553497        1.2900000140070915",
                "2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000     \n  0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597",
                "9.0000000000000000        12.000000000000000        15.000000000000000        19.000000000000000        26.000000000000000        33.000000000000000        29.000000000000000        40.000000000000000        51.000000000000000        39.000000000000000        54.000000000000000        69.000000000000000     \n  0.99000001139938831        1.3200000002980232        1.6500000562518835        2.0900000240653753        2.8600000031292439        3.6300001237541437        3.1900000385940075        4.4000000096857548        5.6100001968443394        4.2900000512599945        5.9400000125169754        7.5900002643465996"
            ]
        },
        "code": "  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(in) :: ad(m, n), bd(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    real(kind=8), intent(out) :: cd(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    cd = 0.0_8\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2_d\n"
    },
    {
        "instruction": "Write a Fortran subroutine called dot that calculates the dot product of two 3D arrays. The subroutine takes three parameters: two input arrays of real numbers, a and b, and one output parameter, dot_prod, which is also a real number. The input arrays, a and b, are of size 3. The subroutine calculates the dot product by multiplying corresponding elements of the arrays and summing them up. The result is stored in the output parameter, dot_prod.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: vec1(3), vec2(3), result\n    ! Test case 1\n    vec1 = [1.0, 2.0, 3.0]\n    vec2 = [4.0, 5.0, 6.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    vec1 = [0.5, 0.5, 0.5]\n    vec2 = [1.0, 2.0, 3.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    vec1 = [0.0, 1.0, 0.0]\n    vec2 = [1.0, 0.0, 0.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    vec1 = [2.0, -3.0, 1.0]\n    vec2 = [-1.0, 4.0, -2.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    vec1 = [1.0, 0.0, 0.0]\n    vec2 = [0.0, 1.0, 0.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "32.000000000000000",
                "3.0000000000000000",
                "0.0000000000000000",
                "-16.000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "  subroutine dot(a, b, dot_prod)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: dot_prod\n    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  end subroutine dot\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine code called cross_d that calculates the cross product of two 3-dimensional vectors. The subroutine takes in 4 input parameters and 2 output parameters. The input parameters are:\n1. a - an array of real numbers representing the first vector,\n2. ad - an array of real numbers representing the derivatives of the first vector,\n3. b - an array of real numbers representing the second vector, and\n4. bd - an array of real numbers representing the derivatives of the second vector.\n\nThe output parameters are:\n1. c - an array of real numbers representing the resulting cross product vector, and\n2. cd - an array of real numbers representing the derivatives of the resulting cross product vector.\n\nThe subroutine uses double precision (kind=8) for real numbers.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: a(3), b(3), ad(3), bd(3), c(3), cd(3)\n    \n    ! Test case 1\n    a = [1.0, 2.0, 3.0]\n    b = [4.0, 5.0, 6.0]\n    ad = [7.0, 8.0, 9.0]\n    bd = [10.0, 11.0, 12.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    a = [0.5, 0.5, 0.5]\n    b = [1.0, 1.0, 1.0]\n    ad = [2.0, 2.0, 2.0]\n    bd = [3.0, 3.0, 3.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    a = [-1.0, 2.0, -3.0]\n    b = [4.0, -5.0, 6.0]\n    ad = [7.0, -8.0, 9.0]\n    bd = [-10.0, 11.0, -12.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    a = [0.0, 0.0, 0.0]\n    b = [1.0, 1.0, 1.0]\n    ad = [2.0, 2.0, 2.0]\n    bd = [3.0, 3.0, 3.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    a = [1.0, 1.0, 1.0]\n    b = [1.0, 1.0, 1.0]\n    ad = [1.0, 1.0, 1.0]\n    bd = [1.0, 1.0, 1.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\nend program main",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000       -6.0000000000000000        12.000000000000000       -6.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-3.0000000000000000       -6.0000000000000000       -3.0000000000000000        6.0000000000000000        12.000000000000000        6.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine cross_d(a, ad, b, bd, c, cd)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(in) :: ad(3), bd(3)\n    real(kind=8), intent(out) :: c(3)\n    real(kind=8), intent(out) :: cd(3)\n    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n  end subroutine cross_d\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine code called sparin_gauss. The subroutine performs Gaussian elimination on a sparse matrix represented by an array. It has two input parameters: kdiag, which is an integer array representing the diagonal positions of the sparse matrix, and kv, which is a real array representing the values of the sparse matrix. The subroutine also has no output parameters.\n\nTo understand the subroutine, it iterates over the diagonal positions of the sparse matrix and performs Gaussian elimination by dividing each element in the lower triangular part of the matrix by the corresponding diagonal element. It then subtracts the product of the divided element and the corresponding element in the upper triangular part from the corresponding element in the lower triangular part of the matrix.\n\nThe subroutine uses nested do-loops to perform the Gaussian elimination process. The subroutine ends with a return statement.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: iwp = selected_real_kind(15)\n    real(iwp) :: kv(6), result(6)\n    integer :: kdiag(6)\n    \n    ! Test case 1\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 2.0_iwp, 3.0_iwp, 4.0_iwp, 5.0_iwp, 6.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 2\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [6.0_iwp, 5.0_iwp, 4.0_iwp, 3.0_iwp, 2.0_iwp, 1.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 2.0_iwp, 1.0_iwp, 2.0_iwp, 1.0_iwp, 2.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "6.0000000000000000        5.0000000000000000        4.0000000000000000        3.0000000000000000        2.0000000000000000        1.0000000000000000",
                "1.0000000000000000        2.0000000000000000        1.0000000000000000        2.0000000000000000        1.0000000000000000        2.0000000000000000",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine sparin_gauss(kv,kdiag)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n integer,intent(in)::kdiag(:)\n real(iwp),intent(out)::kv(:)\n real(iwp)::num,den,fac,zero=0.0_iwp\n integer::n,ii,i,j,k,l,kk,l1,l2,l3\n n=ubound(kdiag,1)\n do j=1,n-1\n   den=kv(kdiag(j))\n   ii=0                 \n   do i=j+1,n\n     ii=ii+1\n     l=kdiag(i)-ii\n     if(l-kdiag(i-1)>zero)then\n       num=kv(l)\n       fac=num/den\n       kk=-1\n       do k=i,n\n         kk=kk+1\n         l1=kdiag(i+kk)-kk\n         l2=l1-ii\n         l3=kdiag(i+kk-1)\n         if(l2-l3>zero)kv(l1)=kv(l1)-fac*kv(l2)\n       end do \n     end if\n   end do\n end do\nreturn\nend subroutine sparin_gauss\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called getptonline. This subroutine calculates the intersection point between a line and a given distance ratio along that line. The number of input parameters is 3. The first parameter is an array of 2 real numbers representing the direction of the line. The second parameter is also an array of 2 real numbers representing another point on the line. The third parameter is a real number representing the distance ratio along the line. The number of output parameters is 1. The output parameter is an array of 2 real numbers representing the computed intersection point.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: rp1(2), rp2(2), distratio, rptc(2)\n    \n    ! Test case 1\n    rp1 = [1.0, 2.0]\n    rp2 = [3.0, 4.0]\n    distratio = 0.5\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 2\n    rp1 = [0.0, 0.0]\n    rp2 = [1.0, 1.0]\n    distratio = 0.25\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    rp1 = [-2.0, 3.0]\n    rp2 = [4.0, 1.0]\n    distratio = 0.75\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    rp1 = [10.0, -5.0]\n    rp2 = [20.0, -10.0]\n    distratio = 0.1\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    rp1 = [-1.0, -1.0]\n    rp2 = [1.0, 1.0]\n    distratio = 0.5\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.0000000000000000        3.0000000000000000",
                "0.25000000000000000       0.25000000000000000",
                "2.5000000000000000        1.5000000000000000",
                "11.000000014901161       -5.5000000074505806",
                "0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "    subroutine getptonline(rp1,rp2,distratio,rptc)\n        implicit none\n        real*8 , intent(in)::rp1(2),rp2(2),distratio !- input line direction\n        real*8 , intent(out)::rptc(2) !-output points\n        real*8 ::v21(2) !- output intersection point\n\n        v21=rp2-rp1\n        rptc=rp1+distratio*v21\n\n    end subroutine getptonline\n"
    },
    {
        "instruction": "Write a Fortran subroutine called quat2eul to convert a quaternion representation to Euler angles. The subroutine takes two input parameters: \n- The first parameter is an array of four real numbers representing the quaternion, specified as q(4).\n- The second parameter is an array of three real numbers representing the Euler angles, specified as eul(3).\n\nThe subroutine computes the Euler angles using the formulas:\n- eul(1) = atan2(2.0*(q(4)*q(3) + q(1)*q(2)), 1.0 - 2.0*(q(2)**2 + q(3)**2))\n- eul(2) = asin(2.0*(q(4)*q(2) - q(3)*q(1)))\n- eul(3) = atan2(2.0*(q(4)*q(1) + q(2)*q(3)), 1.0 - 2.0*(q(1)**2 + q(2)**2))\n\nThe subroutine then assigns these computed values to the elements of the eul array.\n\nRemember to use the \"real\" and \"intent\" keywords to specify the types and intentions of the input and output parameters respectively.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: quat(4), eul(3)\n    \n    ! Test case 1\n    quat = [0.707, 0.0, 0.707, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    quat = [0.5, 0.5, 0.5, 0.5]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    quat = [0.866, 0.0, 0.5, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    quat = [0.0, 0.0, 1.0, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    quat = [0.0, 0.707, 0.0, 0.707]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.00000000      -1.54622102       0.00000000",
                "1.57079637       0.00000000       1.57079637",
                "0.00000000      -1.04714680       3.14159274",
                "3.14159274       0.00000000       0.00000000",
                "0.00000000       1.54622102       0.00000000"
            ]
        },
        "code": "subroutine quat2eul(q,eul) \nreal, intent(in):: q(4)\nreal, intent(out):: eul(3)\neul(1) = atan2(2.*(q(4)*q(3)+q(1)*q(2)), &\n\t1.-2.*(q(2)**2.+q(3)**2.))\neul(2) = asin(2.*(q(4)*q(2)-q(3)*q(1)))\neul(3) = atan2(2.*(q(4)*q(1)+q(2)*q(3)), &\n\t1.-2.*(q(1)**2.+q(2)**2.))\nend subroutine quat2eul\n"
    },
    {
        "instruction": "Please provide me with a Fortran subroutine code named \"maxi\" to compute the maximum value in a given vector. The subroutine takes in three parameters. The first parameter is an integer called \"vect_len\" which specifies the length of the input vector. The second parameter is a real array called \"vect\" of length \"vect_len\" containing the actual vector values. The third parameter is a real variable called \"mm\" which is used to deliver the result, i.e., the maximum value of the vector. The subroutine calculates the maximum value using the \"maxval\" function in Fortran and assigns it to the \"mm\" variable.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: vect_len\n    real*8, dimension(:), allocatable :: vect\n    real*8 :: mm\n    ! Test case 1\n    vect_len = 5\n    allocate(vect(vect_len))\n    vect = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n\n    ! Test case 2\n    vect_len = 3\n    allocate(vect(vect_len))\n    vect = [0.5, 0.2, 0.8]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 3\n    vect_len = 7\n    allocate(vect(vect_len))\n    vect = [10.0, 5.0, 8.0, 3.0, 9.0, 2.0, 7.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 4\n    vect_len = 4\n    allocate(vect(vect_len))\n    vect = [0.1, 0.3, 0.2, 0.4]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 5\n    vect_len = 6\n    allocate(vect(vect_len))\n    vect = [100.0, 50.0, 80.0, 30.0, 90.0, 20.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\nend program main",
            "result": [
                "5.0000000000000000",
                "0.80000001192092896",
                "10.000000000000000",
                "0.40000000596046448",
                "100.00000000000000"
            ]
        },
        "code": "subroutine maxi(vect, vect_len, mm)\n!simple example for computing the maximum of a given vector\n!dec$ attributes dllexport,c,reference,alias:'maxi_' :: maxi\n    !the previous line is necessary for r to find the external function under its name\n\n    implicit none\n    !-------------------------------------------------------------------------------\n    !input\n    integer, intent(in)                     :: vect_len !length of input vector (needs to be specified explicitly)\n    real(8), intent(in), dimension(vect_len):: vect !actual vector\n    !-------------------------------------------------------------------------------\n    ! output\n    real(8), intent(out):: mm  !for delivering the result\n    !-------------------------------------------------------------------------------\n\n    !-------------------------------------------------------------------------------\n    ! code\n        mm = maxval(vect) \n    !-------------------------------------------------------------------------------\nend subroutine maxi\n"
    },
    {
        "instruction": "Create a Fortran subroutine named `residual_2dpoisson` that calculates the residual of a 2-dimensional Poisson equation. The subroutine takes in five input parameters: `u` and `f` are 2-dimensional arrays of type real, `h` and `c` are scalars of type real, and `res` is a 2-dimensional array of type real. The subroutine also has no return value. \n\nInside the subroutine, the local variables `nx` and `ny` are declared as integers. The size of `u` in the first dimension is assigned to `nx`, and the size of `u` in the second dimension is assigned to `ny`.\n\nThe `res` array is computed by evaluating the Poisson equation at the internal grid points. The equation is solved by taking the average of the four neighboring grid points and subtracting the value at the current grid point. The result is divided by the square of `h` and subtracted from the corresponding `f` value.\n\nEnsure that the computation is only performed at the internal grid points by using the array slicing `2:nx-1` for the first dimension and `2:ny-1` for the second dimension.\n\nEnd the subroutine after the calculation is complete.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: u(5, 5), f(5, 5), h, c, res(5, 5)\n    \n    ! Test case 1\n    u = reshape([1.0, 2.0, 3.0, 4.0, 5.0, &\n                 6.0, 7.0, 8.0, 9.0, 10.0, &\n                 11.0, 12.0, 13.0, 14.0, 15.0, &\n                 16.0, 17.0, 18.0, 19.0, 20.0, &\n                 21.0, 22.0, 23.0, 24.0, 25.0], [5, 5])\n    f = reshape([0.1, 0.2, 0.3, 0.4, 0.5, &\n                 0.6, 0.7, 0.8, 0.9, 1.0, &\n                 1.1, 1.2, 1.3, 1.4, 1.5, &\n                 1.6, 1.7, 1.8, 1.9, 2.0, &\n                 2.1, 2.2, 2.3, 2.4, 2.5], [5, 5])\n    h = 0.1\n    c = 0.5\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 2\n    u = reshape([0.5, 1.5, 2.5, 3.5, 4.5, &\n                 5.5, 6.5, 7.5, 8.5, 9.5, &\n                 10.5, 11.5, 12.5, 13.5, 14.5, &\n                 15.5, 16.5, 17.5, 18.5, 19.5, &\n                 20.5, 21.5, 22.5, 23.5, 24.5], [5, 5])\n    f = reshape([0.2, 0.4, 0.6, 0.8, 1.0, &\n                 1.2, 1.4, 1.6, 1.8, 2.0, &\n                 2.2, 2.4, 2.6, 2.8, 3.0, &\n                 3.2, 3.4, 3.6, 3.8, 4.0, &\n                 4.2, 4.4, 4.6, 4.8, 5.0], [5, 5])\n    h = 0.2\n    c = 0.7\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 3\n    u = reshape([1.0, 2.0, 3.0, 4.0, 5.0, &\n                 6.0, 7.0, 8.0, 9.0, 10.0, &\n                 11.0, 12.0, 13.0, 14.0, 15.0, &\n                 16.0, 17.0, 18.0, 19.0, 20.0, &\n                 21.0, 22.0, 23.0, 24.0, 25.0], [5, 5])\n    f = reshape([0.3, 0.6, 0.9, 1.2, 1.5, &\n                 1.8, 2.1, 2.4, 2.7, 3.0, &\n                 3.3, 3.6, 3.9, 4.2, 4.5, &\n                 4.8, 5.1, 5.4, 5.7, 6.0, &\n                 6.3, 6.6, 6.9, 7.2, 7.5], [5, 5])\n    h = 0.3\n    c = 0.9\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 4\n    u = reshape([0.5, 1.0, 1.5, 2.0, 2.5, &\n                 3.0, 3.5, 4.0, 4.5, 5.0, &\n                 5.5, 6.0, 6.5, 7.0, 7.5, &\n                 8.0, 8.5, 9.0, 9.5, 10.0, &\n                 10.5, 11.0, 11.5, 12.0, 12.5], [5, 5])\n    f = reshape([0.4, 0.8, 1.2, 1.6, 2.0, &\n                 2.4, 2.8, 3.2, 3.6, 4.0, &\n                 4.4, 4.8, 5.2, 5.6, 6.0, &\n                 6.4, 6.8, 7.2, 7.6, 8.0, &\n                 8.4, 8.8, 9.2, 9.6, 10.0], [5, 5])\n    h = 0.4\n    c = 1.2\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 5\n    u = reshape([1.0, 1.5, 2.0, 2.5, 3.0, &\n                 3.5, 4.0, 4.5, 5.0, 5.5, &\n                 6.0, 6.5, 7.0, 7.5, 8.0, &\n                 8.5, 9.0, 9.5, 10.0, 10.5, &\n                 11.0, 11.5, 12.0, 12.5, 13.0], [5, 5])\n    f = reshape([0.5, 1.0, 1.5, 2.0, 2.5, &\n                 3.0, 3.5, 4.0, 4.5, 5.0, &\n                 5.5, 6.0, 6.5, 7.0, 7.5, &\n                 8.0, 8.5, 9.0, 9.5, 10.0, &\n                 10.5, 11.0, 11.5, 12.0, 12.5], [5, 5])\n    h = 0.5\n    c = 1.5\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\nend program main",
            "result": [
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -4.19998455      -4.80009127      -5.40019798       1.28919459E-43   8.99540858E-15  -7.20013714      -7.80024338      -8.39996910       0.00000000       0.00000000      -10.1999073      -10.8003960      -11.4001207       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -5.94997978      -6.84997654      -7.74997330       1.28919459E-43   8.99540858E-15  -10.4499645      -11.3499603      -12.2499580       0.00000000       0.00000000      -14.9499493      -15.8499451      -16.7499428       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -8.39999390      -9.59998703      -10.8000002       1.28919459E-43   8.99540858E-15  -14.4000015      -15.5999737      -16.7999878       0.00000000       0.00000000      -20.3999863      -21.6000004      -22.7999306       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -6.99999905      -7.99999714      -9.00000191       1.28919459E-43   8.99540858E-15  -12.0000019      -12.9999943      -13.9999981       0.00000000       0.00000000      -17.0000000      -18.0000038      -18.9999828       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -9.50000000      -10.7500000      -12.0000000       1.28919459E-43   8.99540858E-15  -15.7500000      -17.0000000      -18.2500000       0.00000000       0.00000000      -22.0000000      -23.2500000      -24.5000000       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38"
            ]
        },
        "code": "  subroutine residual_2dpoisson(u, f, h, c, res)\n    implicit none\n    ! arguments\n    real, intent(in)  :: u(:, :)\n    real, intent(in)  :: f(:, :)\n    real, intent(in)  :: h\n    real, intent(in)  :: c\n    real, intent(out) :: res(:, :)\n    ! local variables\n    integer           :: nx, ny\n\n    nx = size(u, 1)\n    ny = size(u, 2)\n\n    res(2:nx-1, 2:ny-1) = ( u(3:nx,   2:ny-1) &\n                          + u(1:nx-2, 2:ny-1) &\n                          + u(2:nx-1, 3:ny  ) &\n                          + u(2:nx-1, 1:ny-2) &\n                          - (4.0 + c * h**2) * u(2:nx-1, 2:ny-1) ) / h**2 &\n                          - f(2:nx-1, 2:ny-1)\n\n  end subroutine\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called put_1d_to_2d that takes an input 1D array and converts it into a 2D array. The subroutine takes two parameters as input: tau, which is an output 2D array of type real(8), and xin, which is the input 1D array of type real(8). The subroutine does not return any value.",
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    real(8) :: arr_1d(6), arr_2d(2, 3)\n    ! Test case 1\n    arr_1d = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n\n    ! Test case 2\n    arr_1d = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 3\n    arr_1d = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 4\n    arr_1d = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 5\n    arr_1d = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\nend program main\n",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "0.50000000000000000        1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.5000000000000000",
                "10.000000000000000        20.000000000000000        30.000000000000000        40.000000000000000        50.000000000000000        60.000000000000000",
                "0.10000000149011612       0.20000000298023224       0.30000001192092896       0.40000000596046448       0.50000000000000000       0.60000002384185791",
                "100.00000000000000        200.00000000000000        300.00000000000000        400.00000000000000        500.00000000000000        600.00000000000000"
            ]
        },
        "code": "  subroutine put_1d_to_2d( tau, xin )\n    implicit none\n    real(8),intent(out) ::  tau(:,:)\n    real(8),intent(in)  :: xin(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          tau(j,i) = xin(k)\n       end do\n    end do\n  end subroutine put_1d_to_2d\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called put_2d_to_1d to convert a 2-dimensional array into a 1-dimensional array. The number of input parameters is 1, which is an array of type real(8). The number of output parameters is 1, which is also an array of type real(8).",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: tau(3,3), xout(9)\n    ! Test case 1\n    tau = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n\n    ! Test case 2\n    tau = reshape([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 3\n    tau = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 4\n    tau = reshape([0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 5\n    tau = reshape([10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000        7.0000000000000000        8.0000000000000000        9.0000000000000000",
                "0.50000000000000000        1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.5000000000000000        6.5000000000000000        7.5000000000000000        8.5000000000000000",
                "2.0000000000000000        4.0000000000000000        6.0000000000000000        8.0000000000000000        10.000000000000000        12.000000000000000        14.000000000000000        16.000000000000000        18.000000000000000",
                "0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000",
                "10.000000000000000        9.0000000000000000        8.0000000000000000        7.0000000000000000        6.0000000000000000        5.0000000000000000        4.0000000000000000        3.0000000000000000        2.0000000000000000"
            ]
        },
        "code": "  subroutine put_2d_to_1d( tau, xout )\n    implicit none\n    real(8),intent(in)  :: tau(:,:)\n    real(8),intent(out) :: xout(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          xout(k) = tau(j,i)\n       end do\n    end do\n  end subroutine put_2d_to_1d\n"
    },
    {
        "instruction": "Write a Fortran subroutine called constraint_func_distance that calculates the distance between two points in three-dimensional space. The subroutine takes in five parameters: \n- The first parameter, d0, is a real number and represents the desired distance between the two points. \n- The next two parameters, x and y, are arrays of three real numbers each, representing the coordinates of the two points. \n- The last two parameters, d and fd, are output variables of type real. \n\nInside the subroutine, the distance between the two points is computed using the Euclidean distance formula. The calculated distance is then assigned to the variable d. The difference between the calculated distance and the desired distance (d0) is assigned to the variable fd.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: d0, d, fd\n    real(8), dimension(3) :: x, y\n    \n    ! Test case 1\n    d0 = 2.0\n    x = [1.0, 2.0, 3.0]\n    y = [4.0, 5.0, 6.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 2\n    d0 = 1.5\n    x = [0.0, 0.0, 0.0]\n    y = [1.0, 2.0, 3.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 3\n    d0 = 3.0\n    x = [5.0, 10.0, 15.0]\n    y = [2.0, 4.0, 6.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 4\n    d0 = 1.0\n    x = [1.0, 1.0, 1.0]\n    y = [2.0, 2.0, 2.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 5\n    d0 = 0.5\n    x = [0.0, 0.0, 0.0]\n    y = [0.0, 0.0, 0.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\nend program main",
            "result": [
                "3.1961524227066320        5.1961524227066320",
                "2.2416573867739413        3.7416573867739413",
                "8.2249721603218244        11.224972160321824",
                "0.73205080756887719        1.7320508075688772",
                "-0.50000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine constraint_func_distance( fd, d, d0, x, y )\n    implicit none\n    real(8),intent(in)  :: d0, x(3), y(3)\n    real(8),intent(out) :: d, fd\n    d  = sqrt( sum( (x-y)**2 ) )\n    fd = d - d0\n  end subroutine constraint_func_distance\n"
    },
    {
        "instruction": "Please create a Fortran subroutine called \"bcnd\" that computes the boundary conditions for a system of differential equations. The subroutine takes in several input parameters: \"ndim\" (integer), \"par\" (array of double precision), \"icp\" (array of integers), \"nbc\" (integer), \"u0\" (array of double precision), and \"u1\" (array of double precision). The subroutine also has output parameters: \"fb\" (array of double precision) and \"dbc\" (array of double precision). \n\nThe subroutine sets the value of \"fb\" to the difference between the first element of \"u0\" and the first element of \"u1\" minus the second element of \"par\". \n\nIf the input parameter \"ijac\" is equal to 0, the subroutine returns. Otherwise, if \"ijac\" is equal to 1, the subroutine sets the derivatives of \"fb\" with respect to the parameters in \"dbc\". \n\nThe subroutine calculates the derivatives of \"fb\" with respect to the parameters and stores them in \"dbc\". \n\nPlease ensure that the subroutine is implemented according to these instructions.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ndim, icp(2), nbc, ijac\n    double precision :: par(2), u0(2), u1(2), fb(1), dbc(1,7)\n    \n    ! Test case 1\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 0\n    par = [2.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n\n    ! Test case 2\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 0\n    par = [-1.0, 0.0]\n    u0 = [0.5, 0.0]\n    u1 = [0.2, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 3\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [1.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 4\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [2.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 5\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [0.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000     \n   5.9394832831961298E-317   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "0.29999999701976776     \n   5.9394832831961298E-317   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310"
            ]
        },
        "code": "      subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc) \n!     ---------- ---- \n\n      implicit none\n      integer, intent(in) :: ndim, icp(*), nbc, ijac\n      double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n      double precision, intent(out) :: fb(nbc)\n      double precision, intent(inout) :: dbc(nbc,*)\n\n       fb(1)=u0(1)-u1(1)-par(2) \n\n      if(ijac.eq.0)return \n\n       dbc(1,1)=1.0 \n       dbc(1,2)=0.0 \n\n       dbc(1,3)=-1.0 \n       dbc(1,4)=0.0 \n\n      if(ijac.eq.1)return \n\n!      *parameter derivatives\n       dbc(1,5)=0.0 \n       dbc(1,6)=-1.0 \n       dbc(1,7)=0.0 \n\n      end subroutine bcnd\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called legp to compute the Legendre polynomials and their derivatives. The number of input parameters is 2, the first parameter is a double precision variable called x which represents the cosine of the angle, and the second parameter is an integer called n which represents the number of terms in the polynomial series. The number of output parameters is 2, the first output parameter is a double precision variable called pn which represents the value of the Legendre polynomial, and the second output parameter is a double precision variable called pp which represents the derivative of the Legendre polynomial.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: x, pn, pp\n    integer :: n\n    \n    ! Test case 1\n    n = 5\n    x = 0.5d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 10\n    x = -0.8d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 3\n    x = 0.2d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 7\n    x = 0.9d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 6\n    x = -0.3d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\nend program main",
            "result": [
                "8.9843750000000000E-002  -2.2265625000000000",
                "0.30052979560000004        1.4602376800000043",
                "-0.28000000000000003       -1.2000000000000002",
                "-0.36782499375000016        3.3113014375000023",
                "0.12918118750000002       -2.0217487500000000"
            ]
        },
        "code": "        subroutine legp(n, x, pn, pp) ! standard 3 terms rec for pn and dpn / d cth\n        implicit none\n        double precision, intent(in) :: x  ! cos(tht)\n        integer, intent(in) :: n\n        double precision, intent(out) :: pn, pp\n        double precision p2, p3\n        integer j\n        pn = 1.0d0\n        p2 = 0.0d0\n        do j=1,n\n            p3 = p2\n            p2 = pn\n            pn = ((2*j-1)*x*p2-(j-1)*p3)/j\n        end do\n        pp = n*(x*pn-p2)/(x*x-1)\n        end subroutine legp\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called rescal_jacobi to compute the coefficients for transforming Jacobi polynomials into Wigner small d's. The subroutine has four input parameters:\n- s1: an integer representing a value\n- s2: an integer representing another value\n- lmax: an integer representing the maximum value of l\n- rl: an output array of type double precision\n\nThe subroutine calculates the coefficients and stores them in the array rl. The coefficients are used to transform Jacobi polynomials into Wigner small d's. The code includes calculations using various mathematical functions such as abs, max, and dsqrt.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: s1, s2, lmax\n    double precision, allocatable :: rl(:)\n    \n    ! Test case 1\n    s1 = 2\n    s2 = -1\n    lmax = 5\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 2\n    s1 = 3\n    s2 = 4\n    lmax = 7\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 3\n    s1 = -2\n    s2 = 0\n    lmax = 10\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 4\n    s1 = 1\n    s2 = 1\n    lmax = 3\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 5\n    s1 = 0\n    s2 = 0\n    lmax = 5\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.0000000000000000        1.5811388300841898        1.4142135623730951        1.3228756555322954",
                "2.8284271247461903        2.1213203435596428        1.8257418583505540        1.6583123951777001",
                "2.4494897427831783        1.8257418583505538        1.5811388300841898        1.4491376746189437        1.3662601021279464        1.3093073414159542        1.2677313820927747        1.2360330811826106        1.2110601416389968",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "    subroutine rescal_jacobi(s1, s2, lmax, rl)\n        ! coefficients turning jacobi polynomials onto wigner small d's\n        ! ~0.1 ms at most for high lmax\n        ! these coeffs are (for integer a, b)\n        ! ( (k + (a + b)) ! * k ! / (k + a)! / (k + b)! )^1/2\n        implicit none\n        integer, intent(in) :: s1, s2\n        integer, intent(in) :: lmax\n        double precision, intent(out) :: rl(0:lmax - max(abs(s1), abs(s2)))\n        integer a, b, lmin, k\n        double precision dmab\n\n        a = abs(s1 - s2)\n        b = abs(s1 + s2)\n        lmin = max(abs(s1), abs(s2))\n        dmab = max(a, b)\n        rl(0) = 1d0\n        do k = 1, min(a, b)\n            rl(0) = rl(0) * dsqrt(1.d0 + dmab / k)\n        end do\n        do k = 0, lmax - lmin - 1\n            rl(k + 1) = rl(k) * dsqrt(  (k + 1.d0 + (a + b) ) / (k + 1.d0 + a) * (k + 1.d0) / (k + 1.d0 + b))\n        end do\n    end subroutine rescal_jacobi\n"
    },
    {
        "instruction": "Write a Fortran subroutine called pol2pos that calculates the position space values for a set of input values using orthogonal polynomials. The subroutine takes in six input parameters: xi, nx, lmax, x, an, bn, cn, cl, p0. The xi parameter is an array of double precision values that will store the position space values. The nx parameter is an integer representing the size of the arrays xi and x. The lmax parameter is an integer representing the maximum order of the orthogonal polynomials. The x parameter is an array of double precision values that are used in the computation. The an, bn, cn, and cl parameters are arrays of double precision values representing coefficients for the orthogonal polynomials. The p0 parameter is a double precision value representing an initial value for the orthogonal polynomials. \n\nThe subroutine uses a three-term recurrence relation to calculate the orthogonal polynomials up to the specified order. The recurrence relation is: p_{n+1}(x) = (a_n x + b_n) p_{n}(x) - c_n p_{n-1}(x). The subroutine initializes the necessary variables and then iterates over the orders of the orthogonal polynomials. It calculates the values of the orthogonal polynomials using the recurrence relation and updates the position space values by adding the product of the orthogonal polynomial value and the corresponding coefficient. \n\nThe subroutine outputs the position space values in the xi array.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: x(5), an(5), bn(5), cn(5), cl(5), p0\n    double precision :: xi(5), pl(5), plp1(5), plm1(5)\n    integer :: nx, lmax, l\n\n    ! Test case 1\n    nx = 5\n    lmax = 3\n    x = [1.0, 2.0, 3.0, 4.0, 5.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 2\n    lmax = 2\n    x = [0.5, 1.0, 1.5, 2.0, 2.5]\n    an = [0.2, 0.3, 0.4, 0.5, 0.6]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.7, 0.8, 0.9, 1.0, 1.1]\n    p0 = 0.5\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 3\n    lmax = 4\n    x = [1.0, 1.0, 1.0, 1.0, 1.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 4\n    lmax = 3\n    x = [5.0, 4.0, 3.0, 2.0, 1.0]\n    an = [0.5, 0.4, 0.3, 0.2, 0.1]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.05, 0.04, 0.03, 0.02, 0.01]\n    cl = [0.9, 0.8, 0.7, 0.6, 0.5]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 5\n    lmax = 2\n    x = [1.0, 2.0, 3.0, 4.0, 5.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 0.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.3956000539213420        4.4780000973850500        5.8220001575142160        7.4564002367407110        9.4100003374964061",
                "1.3502499902732670        1.5229999924078581        1.7092499949224291        1.9089999978169794        2.1222500010915093",
                "5.4366200390197328        5.4366200390197328        5.4366200390197328        5.4366200390197328        5.4366200390197328",
                "26.649001121081437        18.921200693807020        12.901400388483712        8.3736001847267172        5.1218000621512543",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "        subroutine pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n            ! computes position space \\sum_l cl pl(x) without openmp threading\n            ! ortho polynomial eval up to lmax with 3 term recurrence relation\n            ! p_{n+1}(x) = (a_n x + b_n) p_{n}(x) - c_n p_{n-1}(x) (andrews, askey and roy)\n            ! normalization for ortho pol can also be gained from recurrence relation (see same ref)\n            implicit none\n            double precision, intent(in) :: x(nx)\n            double precision, intent(in) :: an(0:lmax-1), bn(0:lmax-1), cn(0:lmax-1), cl(0:lmax)\n            double precision, intent(out) :: xi(nx)\n            double precision :: pl(nx), plp1(nx), plm1(nx), p0\n            integer, intent(in) :: nx, lmax\n            integer :: l\n\n            if (lmax == 0) then\n                xi = cl(0) * p0\n                return\n            end if\n            plm1 = 0.\n            pl = p0\n            plp1 = (an(0) * x + bn(0)) * pl\n            xi = cl(0) * pl + cl(1) * plp1\n            do l = 1, lmax - 1\n                plm1 = pl\n                pl = plp1\n                plp1 = (an(l) * x + bn(l)) * pl - cn(l) * plm1\n                xi = xi + plp1 * cl(l + 1)\n            end do\n        end subroutine pol2pos\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called running_avg that calculates the running average and standard deviation of a series of values. The subroutine has 5 input/output parameters. The first input parameter, x, is a real number representing the current value. The second and third output parameters, avg and std_dev, are also real numbers and represent the running average and standard deviation, respectively. The fourth output parameter, nvals, is an integer that stores the number of values processed so far. The last input parameter, reset, is a logical value that determines whether to reset the running average and standard deviation calculations. When reset is true, the subroutine initializes the average, standard deviation, and count to zero. When reset is false, the subroutine updates the average, standard deviation, and count based on the current value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: value, avg, std_dev\n    integer :: nvals\n    logical :: reset\n    ! Test case 1\n    value = 1.0\n    reset = .true.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n\n    ! Test case 2\n    value = 2.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 3\n    value = 3.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 4\n    value = 4.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 5\n    value = 5.0\n    reset = .true.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\nend program main",
            "result": [
                "0.00000000       0.00000000               0",
                "2.00000000       0.00000000               1",
                "2.50000000      0.707106769               2",
                "3.00000000       1.00000000               3",
                "0.00000000       0.00000000               0"
            ]
        },
        "code": "subroutine running_avg(x, avg, std_dev, nvals, reset)\nimplicit none\n\nreal, intent(in) :: x\nreal, intent(out) :: avg, std_dev\ninteger, intent(out) :: nvals\nlogical, intent(in) :: reset\ninteger, save :: n\nreal, save :: sum_x, sum_x2\n\ncalc_sums: if(reset) then\n  n       = 0\n  sum_x   = 0.\n  sum_x2  = 0.\n  avg     = 0.\n  std_dev = 0.\n  nvals   = 0\nelse\n  n      = n + 1\n  sum_x  = sum_x + x\n  sum_x2 = sum_x2 + x**2\n\n  avg = sum_x / real(n)\n\n  if (n >= 2) then\n    std_dev = sqrt((real(n) * sum_x2 - sum_x**2) &\n            / (real(n) * real(n-1)))\n  else\n    std_dev = 0.\n  end if\n\n  nvals = n\nend if calc_sums\nend subroutine running_avg\n"
    },
    {
        "instruction": "Please provide me with a Fortran subroutine code called index that calculates the refractive index in a magnetized plasma using the Appleton-Hartree equation. The subroutine takes in five input parameters: x, y, k, mode, and mu. The x parameter is an array of real numbers, y and k are arrays of real numbers with two dimensions, mode is an array of characters with one dimension, and mu is an array of real numbers. The subroutine also has one output parameter, mu, which is also an array of real numbers.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: x(3), y(3,3), k(3,3), mu(3)\n    character(len=1) :: mode(3)\n    ! Test case 1\n    x = [0.2, 0.3, 0.4]\n    y = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3,3])\n    k = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [3,3])\n    mode = ['x', 'y', 'z']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n\n    ! Test case 2\n    x = [0.5, 0.6, 0.7]\n    y = reshape([0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7], [3,3])\n    k = reshape([0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], [3,3])\n    mode = ['y', 'z', 'x']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [0.8, 0.9, 1.0]\n    y = reshape([1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1], [3,3])\n    k = reshape([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1], [3,3])\n    mode = ['z', 'x', 'y']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [0.4, 0.5, 0.6]\n    y = reshape([1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5], [3,3])\n    k = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3,3])\n    mode = ['x', 'y', 'z']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.6, 0.7, 0.8]\n    y = reshape([2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9], [3,3])\n    k = reshape([0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4], [3,3])\n    mode = ['y', 'z', 'x']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\nend program main",
            "result": [
                "2.0903655019008314       0.93939482301416843       0.93276135887889755",
                "0.89912781171049183       0.90193760129566758        1.1791740575925205",
                "0.86245019045133942        1.1911116933449157       -0.0000000000000000",
                "1.0880974754925452       0.94409058212756547       0.93972831641211507",
                "0.93384108123658927       0.93099584106591637        1.0974055722581879"
            ]
        },
        "code": "subroutine index(x,y,k,mode,mu)\n\t!------------------------------------\n\t! calculation of the mu refractive index in a magnetised\n\t! plasma according to the appleton-hartree equation\n\t! [haselgrove, 1960]\n\t! calling sequence: call index(x,y,th,mu)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!        th: (k,b) angle\n\t! outputs: mu\n\t!------------------------------------\n\treal(kind=8), dimension(:), intent(in)     \t :: x\n\treal(kind=8), dimension(:,:), intent(in)   \t :: y,k\n\tcharacter(len=1), intent(in), dimension(:) \t :: mode\n\treal(kind=8), dimension(:), intent(out)    \t :: mu\n\treal(kind=8), dimension(size(mu))          \t :: normy,normk,vdotk,a,b,c,b2mac\n\treal(kind=8), dimension(size(mu))\t\t   \t :: nmode\n\t\n\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\tnormk = sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\twhere (normy .eq.0.d0)\n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\ta = 1.d0-x-normy**2*(1.d0-x*vdotk**2/normk**2)\n\tb = 0.5d0*(-2.d0*(1.d0-x)*(1.d0-x-normy**2)+x*normy**2*(1.d0-vdotk**2/normk**2))\n\tc = (1.d0-x)*((1.d0-x)**2-normy**2)\n\t\n\tb2mac = b**2-a*c\n\t\n\t! when magnetic field -> 0 then b2mac -> 0 => numerical effects => when abs(b2mac) < 1.d-15 => b2mac=0\n\twhere (abs(b2mac) < 1.d-15)\n\t\tb2mac = 0.d0\n\tend where\n\t\n\tmu = sqrt((-b+nmode*sqrt(b2mac))/a)\n\t\n\t\n\t!write(*,*) b2mac, -b+sqrt(b2mac), mu\n\t\nend subroutine index\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called ztable_integral to compute the integral of a complex function. The subroutine takes 4 input parameters: k (integer), zeta (real), alpha (real), and specifies the output parameter zfunc (complex). The subroutine also includes several internal variables and parameters. The subroutine uses a loop to calculate the integral iteratively until a certain tolerance level is reached. The subroutine includes various calculations involving exponentials, complex numbers, and mathematical functions.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: k\n    real :: zeta, alpha\n    complex :: zfunc\n    \n    ! Test case 1\n    k = 2\n    zeta = 1.0\n    alpha = 0.5\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 2\n    k = 3\n    zeta = 2.5\n    alpha = -1.0\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 3\n    k = 0\n    zeta = 1.5\n    alpha = 0.0\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 4\n    k = 5\n    zeta = -2.0\n    alpha = 1.2\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 5\n    k = 4\n    zeta = 3.0\n    alpha = 0.8\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\nend program main",
            "result": [
                "-0.670557797     -0.350514770",
                "-0.434719265      -1.82412453E-02",
                "-0.856345832      0.186814845",
                "-0.672848225      0.209748670",
                "-0.580752671     -0.120127797"
            ]
        },
        "code": "      subroutine ztable_integral(k,zeta,alpha,zfunc)\n!         use kinds\n         implicit none\n         integer     , intent(in)  :: k\n         real        , intent(in)  :: zeta,alpha\n         complex , intent(out) :: zfunc\n         integer  , parameter :: nperiod = 100  ! ... points per zeta-cycle\n         real, parameter :: beta = 4.5\n         logical      :: l_at_alpha_inv,l_alpha_positive\n         real    :: tol,twopi,zetascale\n         real    :: dt,halfdt,t,dtz\n         real    :: amplitude_factor,deriv_factor,test\n         complex :: eye,phase_factor\n!\n         twopi = 8.0*atan(1.0)\n         eye = cmplx(0.0,1.0)\n         tol = exp(-beta**2)\n         l_alpha_positive = alpha.gt.0.0\n         zetascale = sqrt(1.0+abs(alpha))\n         dt = twopi/sqrt(zeta**2+real(k+1)**2*zetascale**2)/nperiod\n         halfdt = 0.5*dt\n         zfunc = cmplx(0.0,0.0)\n         dtz = halfdt\n         t   = 0.0\n         l_at_alpha_inv = .false.\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol.and.(.not.l_at_alpha_inv))\n            t = t+dt\n            if (l_alpha_positive) l_at_alpha_inv = (t+halfdt).ge.(1.0/alpha)\n            if (l_at_alpha_inv) dtz = t+halfdt-1.0/alpha\n            if (l_at_alpha_inv) t   = 1.0/alpha-0.5*dtz\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                                  exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                      -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n         if (.not.l_alpha_positive) return\n         dtz = halfdt\n         t   = 0.0\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         amplitude_factor = amplitude_factor - &\n                            exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol)\n            t = t-dt\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n!\n      end subroutine ztable_integral\n"
    },
    {
        "instruction": "Write a Fortran subroutine called v_wire_nonperiodic to calculate the electric potential due to a charged wire. The subroutine takes 3 input parameters: x (distance between the wire and the point of interest) of type double precision, lambda (line charged density of the wire) of type double precision, and potential (output variable to store the calculated potential) of type double precision. The subroutine also has a local variable lamb to convert lambda to units of e/ang. The subroutine calculates the potential using the formula: potential = -lamb/(2*pi*epsilon0) * log(x), where pi and epsilon0 are predefined constants.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: distance, charge_density, potential\n    ! Test case 1\n    distance = 1.0\n    charge_density = 1.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n\n    ! Test case 2\n    distance = 2.5\n    charge_density = 0.5\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 3\n    distance = 0.5\n    charge_density = 2.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 4\n    distance = 10.0\n    charge_density = 0.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 5\n    distance = 3.0\n    charge_density = -1.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\nend program main",
            "result": [
                "-0.0000000000000000",
                "-1.3194261480068376E-007",
                "3.9924294009932879E-007",
                "-0.0000000000000000",
                "3.1639254436754947E-007"
            ]
        },
        "code": "subroutine v_wire_nonperiodic(x,lambda,potential)\n\n  !! charged wire at a distance x\n\n  double precision, intent(in) :: x \n  !! x is the distance in ang between the wire and the point of interest\n  double precision, intent(in) :: lambda \n  !! lambda is the line charged density of the wire in e/cm\n\n  double precision, intent(out) :: potential \n  !! in v\n  double precision :: lamb \n  !! lambda in units of e/ang\n\n  double precision :: pi, epsilon0\n  parameter(pi = 3.1415926535897932d0)\n  parameter(epsilon0 = 0.0055263496) ! in e/(v*ang)\n\n  !first off, need lambda in e/ang\n  lamb = lambda*1.e-8\n\n  potential = -lamb/(2.*pi*epsilon0) * log(x)\n\nend subroutine v_wire_nonperiodic\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called outerprod3 that computes the outer product of two 3-dimensional vectors. The subroutine takes in 2 input parameters: va and vb, both of type real and dimension 3. It also has 1 output parameter called vv, which is a 3x3 matrix of type real.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(4), dimension(3) :: vector1, vector2\n    real(4), dimension(3,3) :: result\n    integer :: i, j\n    \n    ! Test case 1\n    vector1 = [1.0, 2.0, 3.0]\n    vector2 = [4.0, 5.0, 6.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    vector1 = [0.5, 1.5, 2.5]\n    vector2 = [2.0, 3.0, 4.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    vector1 = [2.0, 2.0, 2.0]\n    vector2 = [0.0, 1.0, 2.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    vector1 = [3.0, 4.0, 5.0]\n    vector2 = [-1.0, -2.0, -3.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    vector1 = [1.0, 0.0, -1.0]\n    vector2 = [-1.0, 0.0, 1.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "4.00000000    \n   5.00000000    \n   6.00000000    \n   8.00000000    \n   10.0000000    \n   12.0000000    \n   12.0000000    \n   15.0000000    \n   18.0000000",
                "1.00000000    \n   1.50000000    \n   2.00000000    \n   3.00000000    \n   4.50000000    \n   6.00000000    \n   5.00000000    \n   7.50000000    \n   10.0000000",
                "0.00000000    \n   2.00000000    \n   4.00000000    \n   0.00000000    \n   2.00000000    \n   4.00000000    \n   0.00000000    \n   2.00000000    \n   4.00000000",
                "-3.00000000    \n  -6.00000000    \n  -9.00000000    \n  -4.00000000    \n  -8.00000000    \n  -12.0000000    \n  -5.00000000    \n  -10.0000000    \n  -15.0000000",
                "-1.00000000    \n   0.00000000    \n   1.00000000    \n  -0.00000000    \n   0.00000000    \n   0.00000000    \n   1.00000000    \n  -0.00000000    \n  -1.00000000"
            ]
        },
        "code": "subroutine outerprod3(va,vb,vv)\n!=============================================================================\nimplicit none\nreal(4),dimension(3),  intent(in ):: va,vb\nreal(4),dimension(3,3),intent(out):: vv\ninteger                        :: i\n!-----------------------------------------------------------------------------\ndo i=1,3\n   vv(:,i)=va(:)*vb(i)\nenddo\nend subroutine outerprod3\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called matrix_diagonal to extract the diagonal elements of a matrix and store them in an array. The number of input parameters is 3, the first parameter is a two-dimensional array of type real, representing the matrix; The second parameter is a one-dimensional array of type real, representing the diagonal elements; The third parameter is an integer, representing the size of the matrix. The number of output parameters is 1, which is the diagonal array.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    real, dimension(n,n) :: matrix\n    real, dimension(n) :: diagonal\n    \n    ! Test case 1\n    matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 2\n    matrix = reshape([0.5, -1.0, 2.0, -3.0, 4.5, -6.0, 7.5, -9.0, 10.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix = reshape([-1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \nend program main\n",
            "result": [
                "1.00000000       5.00000000       9.00000000",
                "0.500000000       4.50000000       10.0000000",
                "2.00000000       10.0000000       18.0000000",
                "-1.00000000      -5.00000000      -9.00000000",
                "0.00000000       0.00000000       0.00000000"
            ]
        },
        "code": "    subroutine matrix_diagonal(a, diag, n)\n        implicit none\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:), intent(out) :: diag\n        integer, intent(in) :: n\n        real, dimension(1:size(a)) :: tmp\n\n        tmp = pack(a,.true.)\n        diag = tmp(1:n*n:n+1)\n    end subroutine\n"
    },
    {
        "instruction": "Write a Fortran subroutine called scattering_matrix_fresnel to compute the scattering matrix for the Fresnel equation. The subroutine takes 2 input parameters, both of type complex*16. The first parameter is k1, the incident wavevector, and the second parameter is k2, the transmitted wavevector. The subroutine also takes an optional input parameter, sigma, of type double precision. The subroutine has 1 output parameter, s, which is a 2x2 matrix of type complex*16.\n\nTo compute the scattering matrix, the subroutine first calculates the reflection coefficient r using the Fresnel equation. Then, it calculates the transmission coefficient t. Finally, it assigns the values of r and t to the elements of the output matrix s.\n\nThe subroutine should be called by providing the values for k1 and k2 as input, and optionally providing the value for sigma. The resulting scattering matrix s will be returned as output.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: k1, k2, r11, r12, r21, r22\n    double precision :: sigma\n    complex*16, dimension(2,2) :: s\n    ! Test case 1\n    k1 = (1.0, 0.0)\n    k2 = (2.0, 0.0)\n    sigma = 0.5\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 2\n    k1 = (2.0, 1.0)\n    k2 = (3.0, -2.0)\n    sigma = 1.0\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 3\n    k1 = (0.5, 0.5)\n    k2 = (0.5, -0.5)\n    sigma = 0.25\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 4\n    k1 = (1.0, 1.0)\n    k2 = (1.0, 1.0)\n    sigma = 0.0\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 5\n    k1 = (-1.0, 0.0)\n    k2 = (0.0, -1.0)\n    sigma = 0.5\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \nend program main",
            "result": [
                "(-0.12262648039048077     ,  0.0000000000000000     ) (  1.0683426070061324     ,  0.0000000000000000     ) (  1.0683426070061324     ,  0.0000000000000000     ) ( 0.12262648039048077     , -0.0000000000000000     )",
                "( -4.0690075827569781E-008, -5.6702298301253908E-008) ( -1.9621765089947452E-002, -5.5746313707530273E-003) ( -1.9621765089947452E-002, -5.5746313707530273E-003) (  4.0690075827569781E-008,  5.6702298301253908E-008)",
                "(  0.0000000000000000     , 0.93941306281347581     ) (  1.3707027852991880     ,  0.0000000000000000     ) (  1.3707027852991880     ,  0.0000000000000000     ) ( -0.0000000000000000     ,-0.93941306281347581     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     , -0.0000000000000000     )",
                "(-0.47942553860420301     ,-0.87758256189037276     ) ( -1.3702490875349536     , 0.34988203456254696     ) ( -1.3702490875349536     , 0.34988203456254696     ) ( 0.47942553860420301     , 0.87758256189037276     )"
            ]
        },
        "code": "    subroutine scattering_matrix_fresnel(k1, k2, sigma, s)\n        complex*16, intent(in) :: k1, k2\n        double precision, intent(in) :: sigma\n        !f2py double precision, intent(in), optional:: sigma=0\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        complex*16 :: r, t\n        \n        r = (k1-k2) / (k1+k2) * cdexp(-2*sigma**2*k1*k2)\n        t = 2*cdsqrt(k1*k2) / (k1+k2) * cdexp(5d-1*sigma**2*(k1-k2)**2)\n        s(1,1) = r\n        s(1,2) = t\n        s(2,1) = t\n        s(2,2) = -r\n    end subroutine scattering_matrix_fresnel\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called scattering_matrix_translation that calculates the scattering matrix for a given wavevector and thickness. The subroutine expects 2 input parameters: k1 of type complex*16 and thickness of type double precision. It also has 1 output parameter: s, which is a 2x2 array of complex*16. \n\nTo compute the scattering matrix, set the first element of s to 0 and the second element to cdexp(-ci*thickness*k1), where cdexp is the complex exponential function and ci is the imaginary unit. Then set the third element of s to cdexp(-ci*thickness*k1) and the fourth element to 0.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: k, result(2,2)\n    double precision :: thickness\n    ! Test case 1\n    k = (1.0, 0.0)\n    thickness = 0.1\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n\n    ! Test case 2\n    k = (0.5, 0.5)\n    thickness = 0.5\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 3\n    k = (1.0, 1.0)\n    thickness = 1.0\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 4\n    k = (0.0, 1.0)\n    thickness = 0.2\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 5\n    k = (2.0, 2.0)\n    thickness = 0.7\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\nend program main",
            "result": [
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -0.0000000000000000     ) (  1.0000000000000000     , -0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -3.9043678462250216E-042) (  1.0000000000000000     , -3.9043678462250216E-042) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -1.5617471384900086E-041) (  1.0000000000000000     , -1.5617471384900086E-041) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -3.1234943235237090E-042) (  1.0000000000000000     , -3.1234943235237090E-042) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -2.1864459566510587E-041) (  1.0000000000000000     , -2.1864459566510587E-041) (  0.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "    subroutine scattering_matrix_translation(k1, thickness, s)\n        complex*16, intent(in) :: k1\n        double precision, intent(in) :: thickness\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        s(1,1) = 0d0\n        s(1,2) = cdexp(-ci*thickness*k1)\n        s(2,1) = cdexp(-ci*thickness*k1)\n        s(2,2) = 0d0\n    end subroutine scattering_matrix_translation\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"second_order_centered_real\" that computes the second-order centered finite difference approximation for the derivative of a real-valued function. The subroutine takes 4 input parameters: an integer \"llim\" representing the lower limit of the array indices, a real array \"f\" that contains the function values, a real \"del\" representing the step size, and an output real array \"df\" to store the computed derivatives. The subroutine calculates the derivative values for the function array \"f\" using the centered differencing formula and stores the results in the output array \"df\". The subroutine uses a do loop to iterate over the function array and perform the difference calculation.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: llim, i\n    real, dimension(:), allocatable :: f, df\n    real :: del\n    \n    ! Test case 1\n    llim = 1\n    del = 0.1\n    allocate(f(llim:3))\n    f = [1.0, 2.0, 3.0]\n    allocate(df(llim:3))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 2\n    llim = 2\n    del = 0.2\n    allocate(f(llim:5))\n    f = [2.0, 4.0, 6.0, 8.0]\n    allocate(df(llim:5))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 3\n    llim = 4\n    del = 0.05\n    allocate(f(llim:6))\n    f = [4.0, 5.0, 6.0, 7.0]\n    allocate(df(llim:6))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 4\n    llim = 3\n    del = 0.1\n    allocate(f(llim:7))\n    f = [3.0, 4.0, 5.0, 6.0, 7.0]\n    allocate(df(llim:7))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 5\n    llim = 2\n    del = 0.3\n    allocate(f(llim:4))\n    f = [2.0, 3.0, 4.0]\n    allocate(df(llim:4))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "10.0000000    \n   10.0000000    \n  -10.0000000",
                "10.0000000    \n   10.0000000    \n   10.0000000    \n  -15.0000000",
                "50.0000000    \n   20.0000000    \n   20.0000000    \n  -60.0000000",
                "20.0000000    \n   10.0000000    \n   10.0000000    \n   10.0000000    \n  -30.0000000",
                "5.00000000    \n   3.33333325    \n  -5.00000000"
            ]
        },
        "code": "   subroutine second_order_centered_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      df(istart) = f(istart + 1) / (2.*del)\n      df(iend) = -f(iend - 1) / (2.*del)\n\n      ! 2nd order accurate centered\n      do i = istart + 1, iend - 1\n         df(i) = (f(i + 1) - f(i - 1)) / (2.*del)\n      end do\n\n   end subroutine second_order_centered_real\n"
    },
    {
        "instruction": "Write a Fortran subroutine called four_point_triangle_real that calculates the derivative of a given function at multiple points using a four-point triangular stencil. The subroutine takes four input parameters and has one output parameter. \n\nThe input parameters are:\n1. llim: an integer indicating the lower limit of the array indices.\n2. f: a real array of size llim and above, representing the function values.\n3. del: a real value representing the step size for the derivative calculation.\n\nThe output parameter is:\n1. df: a real array of size llim and above, representing the derivative values.\n\nTo calculate the derivative, the subroutine uses a four-point stencil centered at each point. It applies different formulas depending on whether the point is at the lower limit or upper limit of the array or if it is an interior point. The derivative values are stored in the df array.\n\nPlease note that this subroutine assumes that the f array has been properly initialized and has enough elements to perform the calculations.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: llim, i\n    real, dimension(10) :: f, df\n    real :: del\n    \n    ! Test case 1\n    llim = 1\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n    del = 0.1\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    llim = 0\n    f = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n    del = 0.2\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    llim = 5\n    f = [5.0, 4.0, 3.0, 2.0, 1.0, 0.0, -1.0, -2.0, -3.0, -4.0]\n    del = 0.5\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    llim = -3\n    f = [-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    del = 0.05\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    llim = 2\n    f = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]\n    del = 0.1\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "10.0000000    \n   10.0000000    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   15.5555553    \n   10.0000000    \n  -45.0000000",
                "0.00000000    \n   1.25000000    \n   2.50000000    \n   1.11111104    \n  0.833333313    \n  0.833333313    \n  0.833333313    \n  0.833333313    \n   3.61111093    \n   2.50000000",
                "-0.666666687    \n -0.666666687    \n -0.666666687    \n  -1.77777779    \n  -2.00000000    \n   3.00000000    \n  0.500000000    \n   1.68155816E-44\n  -1.92279614E-09\n   4.59149455E-41",
                "5.00000000    \n   6.00000000    \n   1.10756837E-37\n   0.00000000    \n  -20.0000000    \n   20.0000000    \n   15.5555553    \n   6.66666651    \n   6.66666651    \n   6.66666651",
                "0.00000000    \n  -2.22222209    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   2.22222209    \n   0.00000000    \n  -10.0000000    \n  0.100000001"
            ]
        },
        "code": "   subroutine four_point_triangle_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      i = istart\n      df(i) = f(i + 1) / (2.0 * del)\n      i = istart + 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = istart + 2\n      df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1)) / (18.0 * del)\n\n      i = iend\n      df(i) = -f(i - 1) / (2.0 * del)\n      i = iend - 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = iend - 2\n      df(i) = (9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n\n      ! 2nd order accurate centered\n      do i = istart + 3, iend - 3\n         df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n      end do\n\n   end subroutine four_point_triangle_real\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called \"get_overlap\" to calculate the overlap between two Gaussian distributions. The subroutine takes in six parameters: \n- The number of variables (integer)\n- A logical parameter indicating whether to apply a factor to the overlap calculation (logical)\n- Arrays \"vs1\", \"vs2\", and \"sigmas\" of type real, each with \"nv\" elements\n- An output variable \"ov\" of type real\n\nTo use the subroutine, provide the number of variables, the logical flag, and the arrays \"vs1\", \"vs2\", and \"sigmas\" as input. The subroutine will calculate the overlap and store the result in the \"ov\" variable.\n\nMake sure to define the \"pi\" constant and variables \"dv\" and \"factor\" as real*8. The subroutine iterates over the arrays and calculates the overlap between the two Gaussian distributions using the provided formulas.\n\nRemember to use the \"implicit none\" statement at the beginning of the subroutine to enforce explicit variable declaration.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nv\n    logical :: ifactor\n    real*8 :: vs1(3), vs2(3), sigmas(3), ov\n    integer :: i\n    real*8 :: pi = 3.1415926\n\n    ! Test case 1\n    nv = 3\n    ifactor = .true.\n    vs1 = [1.0, 2.0, 3.0]\n    vs2 = [4.0, 5.0, 6.0]\n    sigmas = [0.1, 0.2, 0.3]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n\n    ! Test case 2\n    nv = 3\n    ifactor = .false.\n    vs1 = [0.5, 1.5, 2.5]\n    vs2 = [3.5, 4.5, 5.5]\n    sigmas = [0.2, 0.3, 0.4]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 3\n    nv = 3\n    ifactor = .true.\n    vs1 = [0.1, 0.2, 0.3]\n    vs2 = [0.4, 0.5, 0.6]\n    sigmas = [0.3, 0.4, 0.5]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 4\n    nv = 3\n    ifactor = .false.\n    vs1 = [1.0, 1.0, 1.0]\n    vs2 = [1.0, 1.0, 1.0]\n    sigmas = [0.1, 0.1, 0.1]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 5\n    nv = 3\n    ifactor = .true.\n    vs1 = [0.5, 0.5, 0.5]\n    vs2 = [0.0, 0.0, 0.0]\n    sigmas = [0.2, 0.2, 0.2]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.7183766133961392E-133",
                "4.0393265722719726E-042",
                "0.23136687520179433",
                "1.0000000000000000",
                "2.5842820176605625E-002"
            ]
        },
        "code": "subroutine get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n\n    ! \n    ! calculate the overlap between two \n    ! gaussian distribution \n    !\n    ! parameters\n    ! =============================================\n    ! \n    ! \n\n    implicit none\n\n    integer, intent(in) :: nv\n    logical, intent(in) :: ifactor\n    real*8, intent(in) :: vs1(nv), vs2(nv), sigmas(nv)\n    real*8, intent(out) :: ov\n    integer :: i\n    real*8, parameter :: pi = 3.1415926\n    real*8 :: dv, factor\n\n    ov = 1.0\n    do i = 1,nv\n        dv = vs1(i) - vs2(i)\n        factor = 1.0\n        if ( ifactor ) then \n            factor = 2.0 * sigmas(i) * sqrt(pi)\n        endif\n        ov = ov * exp( -dv*dv/(4.0*sigmas(i)*sigmas(i)) )/factor\n    enddo\n\nend subroutine get_overlap\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called cross_product to compute the cross product of two vectors in three-dimensional space. The number of input parameters is 6, all of type real and represent the x, y, and z components of the two vectors. The number of output parameters is also 3, all of type real and represent the components of the resulting cross product vector.",
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    real*8 :: x1, y1, z1, x2, y2, z2, x3, y3, z3\n    \n    ! Test case 1\n    x1 = 1.0\n    y1 = 2.0\n    z1 = 3.0\n    x2 = 4.0\n    y2 = 5.0\n    z2 = 6.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n\n    ! Test case 2\n    x1 = 0.5\n    y1 = -1.0\n    z1 = 2.0\n    x2 = -1.5\n    y2 = 0.0\n    z2 = 3.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = 2.0\n    y1 = 3.0\n    z1 = 4.0\n    x2 = -1.0\n    y2 = -2.0\n    z2 = -3.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 0.0\n    y1 = 1.0\n    z1 = 0.0\n    x2 = 0.0\n    y2 = 0.0\n    z2 = 1.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -2.0\n    y1 = 4.0\n    z1 = -1.0\n    x2 = 3.0\n    y2 = -2.0\n    z2 = 5.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\nend program main\n",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000",
                "-3.0000000000000000       -4.5000000000000000       -1.5000000000000000",
                "-1.0000000000000000        2.0000000000000000       -1.0000000000000000",
                "1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "18.000000000000000        7.0000000000000000       -8.0000000000000000"
            ]
        },
        "code": "      subroutine cross_product(x1,y1,z1,x2,y2,z2,x3,y3,z3)\n      implicit real*8(a-h,o-z)\n      real(8),intent(in) :: x1,y1,z1,x2,y2,z2\n      real(8),intent(out) :: x3,y3,z3\n\n      x3=y1*z2-y2*z1\n      y3=x2*z1-x1*z2\n      z3=x1*y2-x2*y1\n\n      end subroutine cross_product\n"
    },
    {
        "instruction": "Provide me with a Fortran subroutine code called ssm_title that converts an integer into a 3-character zero-filled string. The subroutine takes 2 input parameters: an integer called n and a character variable called nchar. It also has 1 output parameter: a 3-character zero-filled string called nchar.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input1, input2, input3, input4, input5\n    character(len=3) :: result1, result2, result3, result4, result5\n    ! Test case 1\n    input1 = 123\n    call ssm_title(input1, result1)\n    print *, result1\n    print *, \"&\"\n\n    ! Test case 2\n    input2 = 9\n    call ssm_title(input2, result2)\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    input3 = 56\n    call ssm_title(input3, result3)\n    print *, result3\n    print *, \"&\"\n    \n    ! Test case 4\n    input4 = 789\n    call ssm_title(input4, result4)\n    print *, result4\n    print *, \"&\"\n    \n    ! Test case 5\n    input5 = 1\n    call ssm_title(input5, result5)\n    print *, result5\n    print *, \"&\"\nend program main",
            "result": [
                "123",
                "009",
                "056",
                "789",
                "001"
            ]
        },
        "code": "subroutine ssm_title(n,nchar)\n  ! returns integer as a 3-character zero-filled string\n  ! used to generate filenames for tables\n\n  implicit none\n  integer,intent(in)::n\n  character(len=3),intent(out)::nchar\n\n  character(len=1)::nchar1\n  character(len=2)::nchar2\n  character(len=3)::nchar3\n\n  if(n.ge.100)then\n     write(nchar3,'(i3)') n\n     nchar = nchar3\n  elseif(n.ge.10)then\n     write(nchar2,'(i2)') n\n     nchar = '0'//nchar2\n  else\n     write(nchar1,'(i1)') n\n     nchar = '00'//nchar1\n  endif\n\nend subroutine ssm_title\n"
    },
    {
        "instruction": "Write a Fortran subroutine called factorial that computes the factorial of a given number. The subroutine takes 2 input parameters: an integer called \"n\" to represent the number for which the factorial is to be computed, and an output parameter \"result\" of type integer to store the computed factorial value. \n\nInstruct the subroutine to use recursion to calculate the factorial. If the input number \"n\" is greater than or equal to 1, call the factorial subroutine recursively with the argument \"n-1\" and store the result in a temporary variable \"temp\". Multiply \"n\" with \"temp\" and assign the result to the output parameter \"result\". \n\nIf the input number \"n\" is less than 1, set the output parameter \"result\" to 1.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input, output\n    ! Test case 1\n    input = 5\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = 0\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 10\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 3\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 7\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "120",
                "1",
                "3628800",
                "6",
                "5040"
            ]
        },
        "code": "recursive subroutine factorial(n, result)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: result\ninteger :: temp\n\nif (n >= 1) then\n  call factorial(n-1, temp)\n  result = n * temp\nelse\n  result = 1\nend if\nend subroutine factorial\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called parse_date that extracts various components (year, month, day, hour, minute, second) from a given date string. The subroutine takes one input parameter, the date string, of type character. It also has six output parameters: sec, min, hour, day, month, and year, all of type integer. \n\nTo use the subroutine, pass the date string as the input parameter. The subroutine will then extract the year, month, day, hour, minute, and second from the date string and store them in the corresponding output parameters.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    character(len=20) :: date\n    integer :: year, month, day, hour, min, sec\n    ! Test case 1\n    date = \"2022-12-31 23:59:59\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n\n    ! Test case 2\n    date = \"2021-02-15\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 3\n    date = \"2023-08-01 12:34:56\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 4\n    date = \"2024-06-10\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 5\n    date = \"2025-11-20 10:25:00\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\nend program main",
            "result": [
                "2022          12          31          23          59          59",
                "2021           2          15           0           0           0",
                "2023           8           1          12          34          56",
                "2024           6          10           0           0           0",
                "2025          11          20          10          25           0"
            ]
        },
        "code": "    subroutine parse_date(date, year, month, day, hour, min, sec)\n      implicit none\n      character (len=*), intent(in) :: date\n      integer, intent(out) :: sec, min, hour, day, month, year\n\n      read(date(9:10),*) day\n      read(date(6:7),*) month\n      read(date(1:4),*) year\n      if(len_trim(date) <= 11) then\n         sec = 0\n         min = 0\n         hour = 0\n      else\n         read(date(18:19), *) sec\n         read(date(15:16), *) min\n         read(date(12:13), *) hour\n      endif\n    end subroutine parse_date\n"
    },
    {
        "instruction": "Write a Fortran subroutine called `cart_sph` to convert Cartesian coordinates to spherical coordinates. The subroutine takes two input parameters: `x`, which is a two-dimensional array of real numbers representing the position vector in Cartesian coordinates, and `r`, which is a two-dimensional array of real numbers representing the position vector in spherical coordinates. The subroutine has no output parameters.\n\nIn the subroutine, the Cartesian coordinates are converted to spherical coordinates using the following formulas:\n1. The radial distance (`r(1,:)`) is computed as the square root of the sum of the squares of the Cartesian coordinates.\n2. The azimuthal angle (`r(2,:)`) is calculated as the inverse cosine of `x(1,:)` divided by the square root of the sum of the squares of `x(1,:)` and `x(2,:)`. If `x(2,:)` is negative, `r(2,:)` is computed as `2*pi` minus the azimuthal angle.\n3. If `x(1,:)` and `x(2,:)` are both zero, the azimuthal angle (`r(2,:)`) is set to `pi/2`.\n4. The polar angle or colatitude (`r(3,:)`) is computed as `pi/2` minus the inverse cosine of `x(3,:)` divided by the radial distance. If the radial distance is zero, the polar angle is set to `pi/2`.\n\nTo use the `cart_sph` subroutine, call it with the input parameter `x` containing the Cartesian coordinates, and the output parameter `r` to store the computed spherical coordinates.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8, dimension(3, 3) :: cartesian_coords\n    real*8, dimension(3, 3) :: spherical_coords\n    ! Test case 1\n    cartesian_coords = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n\n    ! Test case 2\n    cartesian_coords = reshape([0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 3\n    cartesian_coords = reshape([1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 4\n    cartesian_coords = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 5\n    cartesian_coords = reshape([0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 1.0, -1.0, 0.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000       -1.5707963267948966        1.0000000000000000        1.5707963267948966       -1.5707963267948966        1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        1.5707963267948966       -1.5707963267948966        1.0000000000000000        3.1415926535897931       -1.5707963267948966        1.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042",
                "1.7320508075688772       0.78539816339744839      -0.95531661812450919        0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   1.7320508075688772       -2.3561944901923448       -2.1862760354652839",
                "0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   1.7320508075688772       0.78539816339744839      -0.95531661812450919",
                "1.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042  0.70710678118654757       0.78539816339744839       -1.5707963267948966        1.4142135623730951      -0.78539816339744839       -1.5707963267948966"
            ]
        },
        "code": "subroutine cart_sph(x,r)\n\t!----------------------------------------------------------\n\t! switching from cartesian to spherical coordinates\n\t! calling sequence: call cart_sph(x,r)\n\t! input:  x: position vector in cartesian coordinates\n\t! output: r: position vector in spherical coordinates \n\t!            (radial distance,azimuthal angle,polar angle)\t\t\t!\n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: x\n\treal(kind=8), dimension(:,:), intent(out) :: r\n\n\tr(1,:) = sqrt(x(1,:)**2+x(2,:)**2+x(3,:)**2)\n\t\n\t!longitude\n\twhere (x(2,:) < 0.d0)\n\t\tr(2,:) = 2.d0*pi-acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\telsewhere  \n\t\tr(2,:) = acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\tend where\n\n\twhere (x(1,:) .eq. 0.d0 .and. x(2,:).eq. 0.d0)\n\t\tr(2,:) = pi/2.d0\n\tend where\n\t\n\t!colatitude\n\twhere (r(1,:) .ne. 0.d0)\n\t\tr(3,:) = pi/2.d0 - acos(x(3,:)/r(1,:))\n\telsewhere\n\t\tr(3,:) = pi/2.d0\n\tend where\n\nend subroutine cart_sph\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called cart_cyl to convert coordinates from Cartesian to cylindrical system. The subroutine takes two input parameters and one output parameter. The first input parameter is a two-dimensional array called x, which represents the position vector in Cartesian coordinates and has a real kind of precision. The second input parameter, r, is also a two-dimensional array of real kind and represents the output position vector in cylindrical coordinates. The subroutine calculates the radial distance, angular coordinate, and altitude of each point in the Cartesian system and stores them in the corresponding elements of the output array, r. The subroutine follows the calling sequence: call cart_cyl(x, r).",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8), dimension(3,3) :: cartesian_coords, cylindrical_coords\n    \n    ! Test case 1\n    cartesian_coords = reshape([1.0, 2.0, 3.0, 3.0, -2.0, 1.0, 0.0, 0.0, 2.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 2\n    cartesian_coords = reshape([0.5, 0.5, 1.0, 6.0, -7.0, 2.0, 0.0, 0.0, -3.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 3\n    cartesian_coords = reshape([2.0, -2.0, -3.0, 2.0, -1.0, 4.0, 0.0, 0.0, 0.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 4\n    cartesian_coords = reshape([0.0, 0.0, 0.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 5\n    cartesian_coords = reshape([5.0, 0.0, 0.0, 10.0, 0.0, 0.0, 15.0, 0.0, 0.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.2360679774997898        1.1071487177940904        3.0000000000000000        3.6055512754639891      -0.58800260354756761        1.0000000000000000        0.0000000000000000        0.0000000000000000        2.0000000000000000",
                "0.70710678118654757       0.78539816339744817        1.0000000000000000        9.2195444572928871      -0.86217005466722629        2.0000000000000000        0.0000000000000000        0.0000000000000000       -3.0000000000000000",
                "2.8284271247461903      -0.78539816339744817       -3.0000000000000000        2.2360679774997898      -0.46364760900080609        4.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        1.4142135623730951       0.78539816339744817        1.0000000000000000        1.4142135623730951       0.78539816339744817       -1.0000000000000000",
                "5.0000000000000000        0.0000000000000000        0.0000000000000000        10.000000000000000       0.78539816339744817        0.0000000000000000        15.000000000000000       0.78539816339744817        0.0000000000000000"
            ]
        },
        "code": "subroutine cart_cyl(x,r)\n\t!----------------------------------------------------------\n\t! switching from cartesian to cylindrical coordinates\n\t! calling sequence: call cart_cyl(x,r)\n\t! input:  x: position vector in cartesian coordinates\n\t! output: r: position vector in cylindrical coordinates \n\t!\t     (radial distance,angular coordinate,altitude)\t\t\t!\n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: x\n\treal(kind=8), dimension(:,:), intent(out) :: r\n\t\n\t! altitude\n\tr(3,:)=x(3,:)\n\n\t! radial distance\n\tr(1,:) = sqrt(x(1,:)**2+x(2,:)**2)\n\t\n\t! angular coordinate\n\twhere (x(1,:) .ge. 0.d0 .and. x(2,:) .ne. 0.d0)\n\t\tr(2,:) = asin(x(2,:)/r(1,:)) \n\tend where \n\twhere (x(1,:) .lt. 0.d0 .and. x(2,:) .ne. 0.d0)\n\t\tr(2,:) = pi - asin(x(2,:)/r(1,:)) \n\tend where\n\n\twhere (x(1,:) .eq. 0.d0 .and. x(2,:).eq. 0.d0)\n\t\tr(2,:) = 0.d0\n\tend where\n\nend subroutine cart_cyl\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called rot to rotate a vector in Cartesian coordinates by an angle in degrees. The subroutine has three input parameters and one output parameter. The input parameters are: vin - a 2D array of real numbers representing the vector in Cartesian coordinates, theta - a 1D array of real numbers representing the rotation angles in degrees. The output parameter is vout - a 2D array of real numbers representing the modified vector in Cartesian coordinates. The subroutine uses a 3x3 rotation matrix to perform the rotation.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8), dimension(3,3) :: vin, vout\n    real(kind=8), dimension(5) :: theta\n    integer :: i\n    \n    ! Test case 1\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [30.d0, 45.d0, 60.d0, 90.d0, 120.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 2\n    vin = reshape([1.d0, 0.d0, 0.d0, 0.d0, 1.d0, 0.d0, 0.d0, 0.d0, 1.d0], [3, 3])\n    theta = [90.d0, 180.d0, 270.d0, 360.d0, 45.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 3\n    vin = reshape([2.d0, -1.d0, 0.d0, 4.d0, 3.d0, 1.d0, 0.d0, -2.d0, 5.d0], [3, 3])\n    theta = [60.d0, 45.d0, 30.d0, 15.d0, 75.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 4\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [0.d0, 0.d0, 0.d0, 0.d0, 0.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 5\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [180.d0, 270.d0, 360.d0, 90.d0, 0.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \nend program main",
            "result": [
                "30.000000000000000        45.000000000000000        60.000000000000000        90.000000000000000        120.00000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   30.000000000000000        45.000000000000000     \n   60.000000000000000        90.000000000000000        120.00000000000000",
                "90.000000000000000        180.00000000000000        270.00000000000000        360.00000000000000        45.000000000000000     \n   1.0000000000000000        0.0000000000000000        0.0000000000000000     \n   0.0000000000000000        1.0000000000000000        0.0000000000000000     \n   0.0000000000000000        0.0000000000000000        1.0000000000000000     \n   3.9525251667299724E-323   90.000000000000000        180.00000000000000     \n   270.00000000000000        360.00000000000000        45.000000000000000",
                "60.000000000000000        45.000000000000000        30.000000000000000        15.000000000000000        75.000000000000000     \n   2.0000000000000000       -1.0000000000000000        0.0000000000000000     \n   4.0000000000000000        3.0000000000000000        1.0000000000000000     \n   0.0000000000000000       -2.0000000000000000        5.0000000000000000     \n   3.9525251667299724E-323   60.000000000000000        45.000000000000000     \n   30.000000000000000        15.000000000000000        75.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000     \n   0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "180.00000000000000        270.00000000000000        360.00000000000000        90.000000000000000        0.0000000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   180.00000000000000        270.00000000000000     \n   360.00000000000000        90.000000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine rot(vin,theta,vout)\n\t!------------------------------------------------------\n\t! rotation of the vin vector by an angle theta\n\t! calling sequence: call rot(vin,theta,vout)\n\t! input:  vin: vector in cartesian coordinates\n\t!       theta: angle in degre\n\t!\t\t\t\t\n\t! output: vout: modified vector in cartesian coordinates.\n\t!------------------------------------------------------\n\treal(kind=8), dimension(:,:), intent(in)  :: vin\n\treal(kind=8), dimension(:), intent(in)    :: theta\n\treal(kind=8), dimension(:,:), intent(out) :: vout\n\treal(kind=8), dimension(3,3)\t\t\t  :: matrot\n\tinteger\t\t\t\t\t\t\t\t\t  :: i\n\t\n\twrite(*,*) theta\n\tdo i=1,size(theta)\n!\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) = -sin(theta(i)*pi/180.) ; matrot(1,3)=0.d0\n!\t\tmatrot(2,1) = sin(theta(i)*pi/180.) ; matrot(2,2) = cos(theta(i)*pi/180.)  ; matrot(2,3)=0.d0\n!\t\tmatrot(3,1) = 0.d0\t\t \t\t    ; matrot(3,2) = 0.d0\t\t\t\t   ; matrot(3,3)=1.d0\n\n\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) =  0.d0\t\t; matrot(1,3)=-sin(theta(i)*pi/180.)\n\t\tmatrot(2,1) = 0.d0\t\t\t\t    ; matrot(2,2) =  1.d0\t\t; matrot(2,3)=0.d0\n\t\tmatrot(3,1) = sin(theta(i)*pi/180.) ; matrot(3,2) = 0.d0\t\t; matrot(3,3)=cos(theta(i)*pi/180.) \n\n\t\tvout(:,i) = matmul(matrot,vin(:,i)) \n\n\tenddo\n\nend subroutine rot\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine code named eos that calculates the density of a material based on different equations of state. The subroutine takes in 5 input parameters: ec, t, s, z, and ieos. The ec parameter is an array of 5 real numbers, t and s are real numbers, z is a real number, and ieos is an integer. The subroutine has 1 output parameter called rho of type real. \n\nIn the subroutine, if the ieos value is 0, the density is calculated without considering the thermobaricity term. The density is computed using the formula: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3.\n\nIf the ieos value is 1, the density is computed with the thermobaricity term. The density is calculated using the formula: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z.\n\nPlease implement the eos subroutine according to the provided instructions.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: ec(5), t, s, z, rho\n    integer :: ieos\n\n    ! Test case 1\n    ec = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t = 300.0\n    s = 10.0\n    z = 0.0\n    ieos = 0\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 2\n    ec = [2.0, 3.0, 4.0, 5.0, 6.0]\n    t = 400.0\n    s = 20.0\n    z = 0.5\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 3\n    ec = [0.5, 1.0, 1.5, 2.0, 2.5]\n    t = 200.0\n    s = -5.0\n    z = 1.0\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 4\n    ec = [3.0, 4.0, 5.0, 6.0, 7.0]\n    t = 500.0\n    s = 15.0\n    z = -0.5\n    ieos = 0\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 5\n    ec = [4.0, 5.0, 6.0, 7.0, 8.0]\n    t = 350.0\n    s = 25.0\n    z = 1.5\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\nend program main",
            "result": [
                "108270320.",
                "320642048.",
                "16060595.0",
                "751251584.",
                "300865696."
            ]
        },
        "code": "  subroutine eos(ec, t, s, z, ieos, rho)\n    implicit none\n    real, intent(in) :: ec(5), t, s, z\n    integer, intent(in) :: ieos\n    real, intent(out) :: rho\n\n    if (ieos == 0) then\n       ! no thermobaricity term\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3\n    elseif (ieos == 1) then\n       ! thermobaricity term is in\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z\n    end if\n  end subroutine eos\n"
    },
    {
        "instruction": "Write a Fortran subroutine called linear_solver that solves a linear equation of the form f(tau) = a * tau + b. The subroutine takes in two input parameters: 'a' and 'b' of type double precision. There is one output parameter called 'dtau' of type double precision that stores the solution to the equation.\n\nTo write the subroutine, first, declare the input and output parameters using the 'intent' keyword. 'a' and 'b' are input parameters, while 'dtau' is the output parameter. \n\nInside the subroutine, check if 'a' is equal to zero. If it is, assign the value of 'dtau' as the maximum representable value for double precision using the 'huge()' function. Otherwise, compute the value of 'dtau' by dividing 'b' by 'a' and negating the result.\n\nEnd the subroutine after the 'endif' statement using the 'end subroutine linear_solver' statement.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: a, b, dtau\n    ! Test case 1\n    a = 2.0\n    b = 3.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n\n    ! Test case 2\n    a = 0.0\n    b = 4.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 3\n    a = 7.0\n    b = 1.5\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 4\n    a = 3.0\n    b = 3.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 5\n    a = 1.0\n    b = 0.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\nend program main",
            "result": [
                "-1.5000000000000000",
                "1.7976931348623157E+308",
                "-0.21428571428571427",
                "-1.0000000000000000",
                "-0.0000000000000000"
            ]
        },
        "code": "    subroutine linear_solver(a,b,dtau)\n!\n        !find the root of the equation\n        !f(tau) = a * tau + b\n!\n        implicit none\n!\n        double precision,intent(out)                :: dtau\n        double precision,intent(in)                 :: a,b\n!\n        if(a.eq.0.d0) then\n            dtau = huge(0.d0)\n        else\n            dtau = -b/a    \n        endif        \n!\n    end subroutine linear_solver\n"
    },
    {
        "instruction": "Provide me with a Fortran subroutine code called gaulegf that calculates the Gauss-Legendre quadrature points and weights. The subroutine takes 5 input parameters and has no output parameter. The first input parameter is x1, which is of type real(8) and represents the lower limit of integration. The second input parameter is x2, also of type real(8), representing the upper limit of integration. The third input parameter is n, of type integer, representing the number of points and weights to be computed. The fourth and fifth input parameters are arrays x and w, both of type real(8) and of size n. The subroutine calculates the Gauss-Legendre quadrature points and weights and stores them in the arrays x and w, respectively.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: x1, x2\n    real(8), dimension(n) :: x, w\n    integer :: i\n    \n    ! Test case 1\n    x1 = 0.0\n    x2 = 1.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    x1 = -1.0\n    x2 = 1.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = -10.0\n    x2 = 10.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 0.0\n    x2 = 100.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -100.0\n    x2 = 100.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "6.9431844202973714E-002  0.17392742256872379     \n  0.33000947820757187       0.32607257743127321     \n  0.66999052179242813       0.32607257743127321     \n  0.93056815579702623       0.17392742256872379",
                "-0.86113631159405257       0.34785484513744758     \n -0.33998104358485631       0.65214515486254643     \n  0.33998104358485631       0.65214515486254643     \n  0.86113631159405257       0.34785484513744758",
                "-8.6113631159405255        3.4785484513744760     \n  -3.3998104358485630        6.5214515486254641     \n   3.3998104358485630        6.5214515486254641     \n   8.6113631159405255        3.4785484513744760",
                "6.9431844202973707        17.392742256872378     \n   33.000947820757183        32.607257743127320     \n   66.999052179242824        32.607257743127320     \n   93.056815579702629        17.392742256872378",
                "-86.113631159405259        34.785484513744755     \n  -33.998104358485634        65.214515486254641     \n   33.998104358485634        65.214515486254641     \n   86.113631159405259        34.785484513744755"
            ]
        },
        "code": "subroutine gaulegf(x1, x2, x, w, n)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x1, x2\n  real(8), dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  real(8) :: p1, p2, p3, pp, xl, xm, z, z1\n  real(8), parameter :: eps=3.d-14\n\n  pp = 0.0d0\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.0\n    do while(abs(z-z1) .gt. eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\n\nend subroutine gaulegf\n"
    },
    {
        "instruction": "Write a Fortran subroutine called calc_hypotenuse to calculate the hypotenuse of a right triangle. The subroutine has three parameters: two input parameters, side_1 and side_2, both of type real, and one output parameter, hypotenuse, of type real. The subroutine uses the Pythagorean theorem to calculate the hypotenuse. \n\nTo use the subroutine, provide the lengths of the two sides of the right triangle as input values for side_1 and side_2. After calling the subroutine, the calculated hypotenuse will be stored in the hypotenuse output parameter.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: side1, side2, hypotenuse\n    \n    ! Test case 1\n    side1 = 3.0\n    side2 = 4.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 2\n    side1 = 5.0\n    side2 = 12.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 3\n    side1 = 8.0\n    side2 = 15.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 4\n    side1 = 1.5\n    side2 = 6.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 5\n    side1 = 0.5\n    side2 = 0.5\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\nend program main",
            "result": [
                "5.00000000",
                "13.0000000",
                "17.0000000",
                "6.18465853",
                "0.707106769"
            ]
        },
        "code": "subroutine calc_hypotenuse(side_1, side_2, hypotenuse)\nimplicit none\n  real, intent(in) :: side_1, side_2\n  real, intent(out) :: hypotenuse\n  real :: temp\n\n  temp = side_1**2 + side_2**2\n  hypotenuse = sqrt(temp)\n\nend subroutine calc_hypotenuse\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called calc_d2vec to calculate the second derivative matrix of a given normalized vector. The subroutine takes 3 input parameters: v, an array of type real representing the normalized vector; len, a real number representing the length of the vector. The subroutine also has 1 output parameter: d2_mat, a 3-dimensional array of type real to store the calculated second derivative matrix.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: vector(3), length, result(3,3,3)\n    \n    ! Test case 1\n    vector = [1.0, 2.0, 3.0]\n    length = 2.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 2\n    vector = [0.5, 1.5, 2.5]\n    length = 1.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    vector = [2.0, 2.0, 2.0]\n    length = 3.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    vector = [5.0, 0.0, 1.0]\n    length = 4.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    vector = [3.5, 2.5, 1.5]\n    length = 2.5\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-1.2187500000000000      -0.68750000000000000       -1.0312500000000000      -0.68750000000000000       -6.2500000000000000E-002  0.56250000000000000       -1.0312500000000000       0.56250000000000000       0.40625000000000000      -0.68750000000000000       -6.2500000000000000E-002  0.56250000000000000       -6.2500000000000000E-002  -1.8750000000000000      -0.18750000000000000       0.56250000000000000      -0.18750000000000000       0.81250000000000000       -1.0312500000000000       0.56250000000000000       0.40625000000000000       0.56250000000000000      -0.18750000000000000       0.81250000000000000       0.40625000000000000       0.81250000000000000       -1.4062500000000000",
                "-12.750000000000000       -12.000000000000000       -20.000000000000000       -12.000000000000000       -1.0000000000000000        5.6250000000000000       -20.000000000000000        5.6250000000000000        5.0000000000000000       -12.000000000000000       -1.0000000000000000        5.6250000000000000       -1.0000000000000000       -29.250000000000000       -5.0000000000000000        5.6250000000000000       -5.0000000000000000        15.000000000000000       -20.000000000000000        5.6250000000000000        5.0000000000000000        5.6250000000000000       -5.0000000000000000        15.000000000000000        5.0000000000000000        15.000000000000000       -18.750000000000000",
                "-0.19753086419753085       -0.0000000000000000       -0.0000000000000000       -0.0000000000000000        0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        9.8765432098765427E-002   0.0000000000000000        0.0000000000000000       -0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000      -0.19753086419753085       -0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        0.0000000000000000        0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        9.8765432098765427E-002   0.0000000000000000       -0.0000000000000000       -0.0000000000000000       -0.0000000000000000      -0.19753086419753085",
                "-1.4648437500000000E-002   0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.12695312500000000        0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.11230468750000000        0.0000000000000000      -0.12695312500000000        0.0000000000000000      -0.12695312500000000       -0.0000000000000000       -2.5390625000000000E-002   0.0000000000000000       -2.5390625000000000E-002  -0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.11230468750000000        0.0000000000000000       -2.5390625000000000E-002  -0.0000000000000000      -0.11230468750000000       -0.0000000000000000       -7.3242187500000000E-002",
                "-0.91391999999999995       0.40960000000000002       0.24576000000000001       0.40960000000000002       -7.1679999999999994E-002  0.40320000000000000       0.24576000000000001       0.40320000000000000      -0.50175999999999998       0.40960000000000002       -7.1679999999999994E-002  0.40320000000000000       -7.1679999999999994E-002  -1.1135999999999999       -3.0720000000000001E-002  0.40320000000000000       -3.0720000000000001E-002 -0.35840000000000000       0.24576000000000001       0.40320000000000000      -0.50175999999999998       0.40320000000000000       -3.0720000000000001E-002 -0.35840000000000000      -0.50175999999999998      -0.35840000000000000      -0.85248000000000002"
            ]
        },
        "code": "subroutine calc_d2vec(d2_mat,v,len)\nimplicit none \n!     the normalized vector to be derivated \nreal(kind=8), intent(in) :: v(3)\n!     the length of the given vector \nreal(kind=8), intent(in) :: len\n!     the calculated second derivative matrix \nreal(kind=8), intent(out) :: d2_mat(3,3,3)\n\n!\n!     calculate entries of second derivative matrix \n!     --> the matrix is diagonal!\n!\n!     dv/dx^2\nd2_mat(1,1,1)=-3d0*v(1)*(v(2)**2+v(3)**2)\nd2_mat(1,1,2)=v(2)*(2d0*v(1)**2-v(3)**2-v(2)**2)\nd2_mat(1,1,3)=v(3)*(2d0*v(1)**2-v(2)**2-v(3)**2)\n!     dv/dxdy\nd2_mat(1,2,1)=-v(2)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,2,2)=-v(1)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(1,2,3)=3d0*v(1)*v(2)*v(3)\n!     dv/dxdz\nd2_mat(1,3,1)=-v(3)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,3,2)=3d0*v(1)*v(2)*v(3)\nd2_mat(1,3,3)=-v(1)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dydx\nd2_mat(2,1,:)=d2_mat(1,2,:)\n!     dv/dydy\nd2_mat(2,2,1)=v(1)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\nd2_mat(2,2,2)=-3d0*v(2)*(v(1)**2+v(3)**2)\nd2_mat(2,2,3)=v(3)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\n!     dv/dydz\nd2_mat(2,3,1)=3d0*v(1)*v(2)*v(3)\nd2_mat(2,3,2)=-v(3)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(2,3,3)=-v(2)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dzdx\nd2_mat(3,1,:)=d2_mat(1,3,:)\n!     dv/dzdy\nd2_mat(3,2,:)=d2_mat(2,3,:)\n!     dv/dzdz\nd2_mat(3,3,1)=v(1)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,2)=v(2)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,3)=-3d0*v(3)*(v(1)**2+v(2)**2)\n!\n!     apply length prefactor \n!\nd2_mat=d2_mat/(len**5)\n\nreturn\nend subroutine calc_d2vec\n"
    },
    {
        "instruction": "Write a Fortran subroutine called adt_sphere that calculates the scattering properties of a sphere. The subroutine takes 4 input parameters and has 4 output parameters. The input parameters are: xx, a real number representing the size of the sphere; crefin, a complex number representing the refractive index of the sphere. The output parameters are: qext, a real number representing the extinction efficiency; qabs, a real number representing the absorption efficiency; qsca, a real number representing the scattering efficiency; and g, a real number representing the scattering asymmetry parameter. The subroutine computes these properties based on the size and refractive index of the sphere using mathematical calculations and conditional statements.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: xx, qext, qabs, qsca, g\n    complex :: crefin\n    ! Test case 1\n    xx = 0.1\n    crefin = (1.0, 1.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 2\n    xx = 0.5\n    crefin = (0.5, 0.5)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 3\n    xx = 1.0\n    crefin = (1.0, 0.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 4\n    xx = 2.0\n    crefin = (0.0, 1.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 5\n    xx = 10.0\n    crefin = (2.0, 2.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\nend program main",
            "result": [
                "-32.5015335      0.230600178      -32.7321320       1.00000000",
                "-1.29226851      0.471517801      -1.76378632       1.00000000",
                "2.00000000       0.00000000       2.00000000       1.00000000",
                "2.00078797      0.968844354       1.03194356       1.00000000",
                "1.99880004      0.999687493      0.999112546       1.00000000"
            ]
        },
        "code": "subroutine adt_sphere(xx, crefin, qext, qabs, qsca, g)\n  implicit none\n  real, intent(in) :: xx\n  complex, intent(in) :: crefin\n  real, intent(out) :: qext, qabs, qsca, g\n  complex rho\n  real rho1, rho2, beta, rr\n  !\n  rho = 2.0 * xx * (crefin - 1.0)\n  rr = abs(rho)\n  rho1 = real(rho)\n  rho2 = aimag(rho)\n  !\n  if (rr .le. 1e-3) then\n    qext = 2.0\n    qabs = 4.0/3.0 * rho2\n    qsca = qext - qabs\n    g = 1.0\n  else\n    !\n    beta = atan2(rho2, rho1)\n    !\n    qext = 2.0 + 4.0/(rr*rr) * &\n      (cos(2.0*beta) - &\n       exp(-rho2) * &\n       (cos(rho1-2.0*beta) - rr*sin(rho1-beta)))\n    qabs = 1.0 + (exp(-2.0*rho2)*(2.0*rho2+1.0) - 1.0) / (2.0*rho2*rho2)\n    qsca = qext - qabs\n    g = 1.0\n  end if\nend subroutine adt_sphere\n"
    },
    {
        "instruction": "Create a Fortran subroutine called crossproduct that calculates the cross product of two vectors. The subroutine has 3 input parameters and 1 output parameter. The input parameters are arrays of type real*8, representing the components of the two vectors. The output parameter is an array of type real*8, representing the resulting cross product vector.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: vector1(3), vector2(3), result(3)\n    \n    ! Test case 1\n    vector1 = [1.0, 2.0, 3.0]\n    vector2 = [4.0, 5.0, 6.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    vector1 = [0.5, 0.5, 0.5]\n    vector2 = [1.0, 2.0, 3.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    vector1 = [1.0, 0.0, 0.0]\n    vector2 = [0.0, 1.0, 0.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    vector1 = [3.0, 4.0, 5.0]\n    vector2 = [1.0, -2.0, 3.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    vector1 = [-1.0, -1.0, -1.0]\n    vector2 = [2.0, 2.0, 2.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000",
                "0.50000000000000000       -1.0000000000000000       0.50000000000000000",
                "0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "22.000000000000000       -4.0000000000000000       -10.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine crossproduct( a,b,ans )\n    implicit none\n    real*8, intent(in) :: a(3),b(3)\n    real*8, intent(out) :: ans(3)\n    ans(1) = a(2)*b(3)-a(3)*b(2)\n    ans(2) = -a(1)*b(3)+a(3)*b(1)\n    ans(3) = a(1)*b(2)-a(2)*b(1)\n  end subroutine crossproduct\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called intersection to find the intersection of two rectangles. The subroutine takes 14 input parameters, all of type real. These parameters represent the coordinates of the two rectangles. The subroutine also has 3 output parameters, indicator of type integer, and area, xintlo, xinthi, yintlo, and yinthi of type real. \n\nTo find the intersection, the subroutine compares the x and y coordinates of the rectangles and determines the overlapping region. If there is an intersection, the subroutine sets indicator to 1 and calculates the area of the intersection. If there is no intersection, indicator is set to 0 and the area is set to 0.\n\nWrite a Fortran subroutine called intersection that takes 14 input parameters: x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi, all of type real. The subroutine also has 5 output parameters: indicator, area, xintlo, xinthi, yintlo, and yinthi, all of type real.\n\nThe subroutine should find the intersection of two rectangles based on their coordinates. If there is an intersection, set the indicator to 1 and calculate the area of the intersection. If there is no intersection, set the indicator to 0 and the area to 0.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: indicator\n    real*8 :: area, xintlo, xinthi, yintlo, yinthi\n    real*8 :: x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi\n    \n    ! Test case 1: Rectangles overlap\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 3.0\n    x2hi = 8.0\n    y2lo = 3.0\n    y2hi = 8.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 2: Rectangles do not overlap\n    x1lo = 0.0\n    x1hi = 2.0\n    y1lo = 0.0\n    y1hi = 2.0\n    x2lo = 3.0\n    x2hi = 4.0\n    y2lo = 3.0\n    y2hi = 4.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 3: One rectangle is completely inside the other\n    x1lo = 0.0\n    x1hi = 10.0\n    y1lo = 0.0\n    y1hi = 10.0\n    x2lo = 3.0\n    x2hi = 8.0\n    y2lo = 3.0\n    y2hi = 8.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 4: Rectangles share one side\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 5.0\n    x2hi = 10.0\n    y2lo = 0.0\n    y2hi = 5.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 5: Rectangles share one corner\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 5.0\n    x2hi = 10.0\n    y2lo = 5.0\n    y2hi = 10.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\nend program main",
            "result": [
                "1   4.0000000000000000        3.0000000000000000        5.0000000000000000        3.0000000000000000        5.0000000000000000",
                "0   0.0000000000000000        3.0000000000000000        2.0000000000000000        3.0000000000000000        2.0000000000000000",
                "1   25.000000000000000        3.0000000000000000        8.0000000000000000        3.0000000000000000        8.0000000000000000",
                "0   0.0000000000000000        5.0000000000000000        5.0000000000000000        0.0000000000000000        5.0000000000000000",
                "0   0.0000000000000000        5.0000000000000000        5.0000000000000000        5.0000000000000000        5.0000000000000000"
            ]
        },
        "code": "subroutine intersection(indicator,area,xintlo,xinthi, &\n           yintlo,yinthi,x1lo,x1hi,y1lo,y1hi,x2lo,x2hi,y2lo,y2hi)\n\n    ! find the intersection of two rectangles, return the intersection\n    ! and it's area, and indicator =1\n    ! if there is no intersection, indicator =0\n\n      implicit none\n\n      integer, intent(out) :: indicator\n\n      real(kind=8), intent(in) ::  x1lo,x1hi,y1lo,y1hi,x2lo,x2hi,y2lo,y2hi\n      real(kind=8), intent(out) :: area,xintlo,xinthi,yintlo,yinthi\n\n      xintlo=dmax1(x1lo,x2lo)\n      xinthi=dmin1(x1hi,x2hi)\n      yintlo=dmax1(y1lo,y2lo)\n      yinthi=dmin1(y1hi,y2hi)\n\n\n      if (xinthi.gt.xintlo.and.yinthi.gt.yintlo) then\n         area = (xinthi-xintlo)*(yinthi-yintlo)\n         indicator = 1\n      else\n         area = 0.d0\n         indicator = 0\n      endif\n\nend subroutine intersection\n"
    },
    {
        "instruction": "I need a Fortran subroutine called xtoz that converts x coordinates to z coordinates on a discretized space. The subroutine takes in the following input parameters: nd (an integer representing the dimension of the space), x (an array of real numbers representing the coordinates of the point to be converted), h (an array of real numbers representing the space grid size), lb (an array of real numbers representing the lower bounds of the space), and ub (an array of real numbers representing the upper bounds of the space). The subroutine also has one output parameter: z (an array of integers representing the z coordinates of the point).",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nd\n    real :: x(3), h(3), lb(3), ub(3)\n    integer :: z(3)\n    \n    nd = 3\n    \n    ! Test case 1\n    x = [1.0, 2.0, 3.0]\n    h = [0.5, 0.5, 0.5]\n    lb = [0.0, 1.0, 2.0]\n    ub = [2.0, 4.0, 6.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [0.5, 1.5, 2.5]\n    h = [0.2, 0.4, 0.6]\n    lb = [0.0, 1.0, 2.0]\n    ub = [1.0, 2.0, 3.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [2.0, 2.0, 2.0]\n    h = [0.1, 0.1, 0.1]\n    lb = [1.0, 1.0, 1.0]\n    ub = [3.0, 3.0, 3.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [3.5, 4.0, 4.5]\n    h = [0.5, 0.5, 0.5]\n    lb = [1.0, 2.0, 3.0]\n    ub = [5.0, 6.0, 7.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.0, 0.0, 0.0]\n    h = [0.2, 0.2, 0.2]\n    lb = [-1.0, -1.0, -1.0]\n    ub = [1.0, 1.0, 1.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\nend program main",
            "result": [
                "3           3           3",
                "3           2           1",
                "11          11          11",
                "6           5           4",
                "6           6           6"
            ]
        },
        "code": "subroutine xtoz(z, x, h, lb, ub, nd)\n!------------------------------------------------------------------\n!\txtoz converts x coordinates to z coordinates on the discretized space\n!\tinput:\n!\t\t\tx\t\tthe coordinates of the point to be converted\n!\t\t\th\t\tthe space grid size\n!\t\t\tlb\t\tthe lower bound of the space\n!\t\t\tub\t\tthe upper bound of the space\n!\t\t\tnd\t\tthe dimension of apace\n!\toutput:\n!\t\t\tz\t\tthe z coordinates of the point\n!\tby: yousef naranjani-mar 30 2016\n!------------------------------------------------------------------\n\timplicit none\n\tinteger, intent(in)::nd\n\treal, dimension (1 : nd), intent(in):: x, h, lb, ub\n\tinteger, dimension (1 : nd), intent(out):: z\n\tinteger:: i\n\tdo i = 1, nd\n\t\tif ((x(i) < lb(i)).or.(x(i) > ub(i))) then\n!\t\t\terror stop \"xtoz: the x coordinate was out of bound\"\n\t\t\tz = -1\n\t\t\texit\n\t\telse if (x(i) == ub(i)) then\n\t\t\tz(i) = floor((ub(i)-lb(i))/h(i))\n\t\telse\n\t\t\tz(i) = floor((x(i)-lb(i))/h(i)) + 1\n\t\tend if\n\tend do\nend subroutine xtoz\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"sparin_gauss\" that performs sparse matrix factorization using Gaussian elimination. It has two input parameters: \"kdiag\" is an integer array representing the diagonals of the sparse matrix, and \"kv\" is an output real array used to store the factorized matrix. The subroutine does not return any value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n, i\n    integer, parameter :: k = 5\n    integer :: kdiag(k)\n    real*8 :: kv(10)\n    \n    ! Test case 1\n    n = 5\n    kdiag = [(i, i=1,k)]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 3\n    kdiag = [0, 1, 0, 2, 3]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 4\n    kdiag = [1, 2, 3, 4, 5]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 2\n    kdiag = [2, 0, 3, 0, 1]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 3\n    kdiag = [1, 2, 3, 2, 1]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\nend program main",
            "result": [
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317\n   8.9164432238799354E-317\n   8.9165331438274785E-317\n   8.9163355175691420E-317\n   3.9525251667299724E-323\n   4.2439915824246103E-314\n   8.4879831653432862E-314\n   6.9527192090979618E-310\n   2.9707941075984141E-313\n   6.9528798000410905E-310",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317\n   8.9164432238799354E-317\n   8.9165331438274785E-317\n   8.9163355175691420E-317\n   3.9525251667299724E-323",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317"
            ]
        },
        "code": "subroutine sparin_gauss(kv,kdiag)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n integer,intent(in)::kdiag(:)\r\n real(iwp),intent(out)::kv(:)\r\nend subroutine sparin_gauss\r\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"bar\" to calculate the sum of squares of elements in a two-dimensional array. The subroutine has 2 input parameters and 1 output parameter. The first input parameter is an array of real numbers, and the second input parameter is the size of the array. The output parameter is a single real number representing the sum of squares. The subroutine iterates over each element of the array, squares it, and adds it to the running total. The calculated sum is then stored in the output parameter.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real, dimension(3, 3) :: matrix1, matrix2, matrix3, matrix4, matrix5\n    real :: result1, result2, result3, result4, result5\n    integer :: i, j\n    \n    ! Test case 1\n    matrix1 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])\n    call bar(matrix1, result1)\n    print *, result1\n    print *, \"&\"\n    \n    ! Test case 2\n    matrix2 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5], [3, 3])\n    call bar(matrix2, result2)\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix3 = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0], [3, 3])\n    call bar(matrix3, result3)\n    print *, result3\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix4 = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [3, 3])\n    call bar(matrix4, result4)\n    print *, result4\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix5 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3, 3])\n    call bar(matrix5, result5)\n    print *, result5\n    print *, \"&\"\n    \nend program main",
            "result": [
                "285.000000",
                "71.2500000",
                "28500.0000",
                "1140.00000",
                "0.00000000"
            ]
        },
        "code": "  subroutine bar(a,x)\n    real, dimension(:,:), intent(in) :: a\n    real, intent(out) :: x\n    integer :: i,j\n\n    x = 0\n    do j=1,ubound(a,2)\n       do i=1,ubound(a,1)\n          x = x + a(i,j)**2\n       end do\n    end do\n  end subroutine bar\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called in1_ord11 to calculate the first inner product of two arrays. The subroutine takes in 4 parameters. The first parameter is an integer representing the size of the arrays. The next two parameters are real arrays, t1f_a and t1f_b, which contain the elements of the arrays. The last parameter is the output variable, res, which is also a real number. \n\nTo compute the inner product, the subroutine initializes the result, res, to zero. Then, it iterates over each element of the arrays using a loop. In each iteration, it multiplies the corresponding elements of t1f_a and t1f_b and adds the result to the current value of res. Finally, the subroutine returns the computed inner product.\n\nPlease note that the code assumes that the arrays t1f_a and t1f_b have the same size, specified by the idm parameter.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: idm = 5 ! dimension of arrays\n    real(8) :: t1f_a(idm), t1f_b(idm), result\n    ! Test case 1\n    t1f_a = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t1f_b = [5.0, 4.0, 3.0, 2.0, 1.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    t1f_a = [0.5, 0.2, 1.0, 0.8, 0.9]\n    t1f_b = [0.1, 0.3, 0.5, 0.7, 0.9]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    t1f_a = [10.0, 20.0, 30.0, 40.0, 50.0]\n    t1f_b = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    t1f_a = [0.0, 0.0, 0.0, 0.0, 0.0]\n    t1f_b = [1.5, 2.5, 3.5, 4.5, 5.5]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    t1f_a = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t1f_b = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "35.000000000000000",
                "1.9799999599158769",
                "550.00000000000000",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "      subroutine in1_ord11 (res, t1f_a, t1f_b, idm)\n      ! returns the first inner product of a and b\n      ! res = a_i * b_i\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res\n         real(8), intent(in)  :: t1f_a (idm)\n         real(8), intent(in)  :: t1f_b (idm)\n      \n         !### var ###!\n         integer  :: ii\n         \n         !### code ###!\n         res = 0.0d0\n         do ii = 1,idm\n            res = res + t1f_a(ii) * t1f_b(ii)\n         enddo\n      \n      end subroutine\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called radial_basis that calculates the basis functions for radial functions. The subroutine has several input parameters: an integer l, a double precision alpha, an integer n_b, an integer n_r, and an array r_grid of type double precision. The subroutine also has two output parameters: an array basis of type double precision and an integer status. The subroutine calculates the basis functions by applying recurrence relations and scales them by normalization constants. The basis functions are stored in the array basis. The status parameter is used to indicate if there were any errors during the computation.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: l, n_b, n_r, status, kk\n    double precision :: alpha\n    double precision, allocatable :: r_grid(:), basis(:,:)\n    \n    ! Test case 1\n    l = 2\n    alpha = 0.5\n    n_b = 3\n    n_r = 5\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 2\n    l = 3\n    alpha = 1.0\n    n_b = 2\n    n_r = 4\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.2, 0.4, 0.6, 0.8]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 3\n    l = 1\n    alpha = 0.7\n    n_b = 3\n    n_r = 3\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.3, 0.6, 0.9]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 4\n    l = 4\n    alpha = 1.5\n    n_b = 4\n    n_r = 6\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 5\n    l = 0\n    alpha = 0.3\n    n_b = 2\n    n_r = 5\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \nend program main",
            "result": [
                "3.5450229148029559E-005   2.6977040836619412E-004   8.6607079290971448E-004   1.9527868752387092E-003   3.6280239414119356E-003   7.3947937385630233E-005   5.5319380656143082E-004   1.7453529087138818E-003   3.8663207526262724E-003   7.0548509110186959E-003   1.2167126355235084E-004   8.9466261455733206E-004   2.7734093697270542E-003   6.0338848209109276E-003   1.0808495542952802E-002",
                "1.4761681463944885E-004   1.9337348073046824E-003   8.0149919377768362E-003   2.0739539157233800E-002   3.5477206967341704E-004   4.4028045876276581E-003   1.7235028246000341E-002   4.1973875913464104E-002",
                "3.4534657286656362E-002  0.11197299601224384       0.20421796021582389        5.0473398846081784E-002  0.14445239720046285       0.22843827937573838        6.1686350908104218E-002  0.15405333109548161       0.20520724788666211",
                "1.9016966595250715E-006   5.2377775357938272E-005   3.4234124030166644E-004   1.2416771254551765E-003   3.2614786863799281E-003   6.9851650679741348E-003   5.3250336272708904E-006   1.4212951656637445E-004   8.9931116942082066E-004   3.1542835331544164E-003   8.0028162895351331E-003   1.6534836278320957E-002   1.1214096059187139E-005   2.8997409102586710E-004   1.7753049845598331E-003   6.0166752622521202E-003   1.4727819651723166E-002   2.9309950656421908E-002   2.0346705324988351E-005   5.0956042765451189E-004   3.0169066761456765E-003   9.8711199037292609E-003   2.3283346505164403E-002   4.4553657562830785E-002",
                "3.1892096897150300E-002   6.1899085877210984E-002   9.0104539019090560E-002  0.11658872709867828       0.14142875982061820        3.0935333937960569E-002   5.8185140521657304E-002   8.1995129862894506E-002  0.10259807908242162       0.12021444500454437"
            ]
        },
        "code": "  subroutine radial_basis (l, alpha, n_b, n_r, r_grid, basis, status)\n    integer , intent(in) :: l\n    double precision , intent(in) :: alpha\n    integer , intent(in) :: n_b\n    integer , intent(in) :: n_r\n    double precision , intent(in) :: r_grid(n_r)\n    double precision , intent(out) :: basis(n_r, n_b)\n    integer , intent(out) :: status\n    double precision :: norm(n_b)\n    double precision :: alpha_grid(n_r)\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1) .or. (n_r < 1)) then\n      status = 1\n      return\n    end if\n\n    ! recurrence relation for basis normalisation constants\n    norm(1) = sqrt(alpha / dble((l + 1d0) * gamma(dble((2d0 * l) + 2d0))))\n\n    if (n_b >= 2) then\n      do kk = 2, n_b\n        norm(kk) = norm(kk-1) * sqrt(dble((kk - 1d0) * (kk - 1d0 + l)) / &\n            dble((kk + l) * (kk + (2d0 * l))))\n      end do\n    end if\n\n    ! in-lined array since r_grid(:) on its own is never used\n    alpha_grid(:) = alpha * r_grid(:)\n\n    ! recurrence relation for basis functions\n    basis(:, 1) = ((2.0d0 * alpha_grid(:)) ** (l + 1)) * &\n        exp(-alpha_grid(:))\n\n    if (n_b >= 2) then\n      basis(:, 2) = 2.0d0 * (dble(l + 1d0) - alpha_grid(:)) * basis(:, 1)\n    end if\n\n    if (n_b >= 3) then\n      do kk = 3, n_b\n        basis(:, kk) = &\n            ((2.0d0 * (dble(kk - 1d0 + l) - alpha_grid(:)) * basis(:, kk-1)) &\n            - dble(kk + (2d0 * l) - 1d0) * basis(:, kk-2)) / dble(kk - 1)\n      end do\n    end if\n\n    ! scaling basis functions by normalisation constants\n    do kk = 1, n_b\n      basis(:, kk) = basis(:, kk) * norm(kk)\n    end do\n\n  end subroutine radial_basis\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called helm3d_f that calculates the potential at target points due to a set of sources in three-dimensional space using the Helmholtz equation. The subroutine expects several input parameters: \n1. nd (integer*4): the number of dimensions\n2. zk (complex*8): a complex number representing the wave number\n3. sources (real*8): an array of real numbers representing the source values\n4. charge (complex*8): an array of complex numbers representing the charge distribution\n5. ns (integer*4): the number of sources\n6. ztarg (real*8): an array of real numbers representing the target coordinates\n7. nt (integer*4): the number of target points\n8. thresh (real*8): a real number representing the threshold value\n\nThe subroutine also has an output parameter:\n1. pot (complex*8): an array of complex numbers representing the calculated potential at the target points\n\nTo use the subroutine, provide the necessary input parameters and an array to store the calculated potential. The subroutine will compute the potential at the target points based on the specified sources and charge distribution using the Helmholtz equation.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer*4 :: nd, ns, nt\n    complex*8 :: zk\n    real*8, allocatable :: sources(:), ztarg(:)\n    complex*8, allocatable :: charge(:), pot(:)\n    real*8 :: thresh\n    \n    ! Test case 1\n    nd = 3\n    zk = (1.0, 2.0)\n    ns = 4\n    nt = 5\n    thresh = 0.001\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [1.0, 2.0, 3.0] \n    charge = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]\n    ztarg = [1.0, 2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 2\n    nd = 2\n    zk = (-1.0, 0.5)\n    ns = 3\n    nt = 4\n    thresh = 0.01\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [0.5, 1.0] \n    charge = [(-1.0, 0.5), (-2.0, 1.0), (-3.0, 1.5)]\n    ztarg = [2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 3\n    nd = 4\n    zk = (0.0, 0.0)\n    ns = 2\n    nt = 3\n    thresh = 0.1\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [0.0, 1.0, 2.0, 3.0] \n    charge = [(0.0, 0.0), (1.0, 1.0)]\n    ztarg = [3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 4\n    nd = 1\n    zk = (2.5, -1.5)\n    ns = 1\n    nt = 2\n    thresh = 0.001\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [4.0] \n    charge = [(1.0, -1.0)]\n    ztarg = [1.0, 2.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 5\n    nd = 3\n    zk = (0.0, 1.0)\n    ns = 2\n    nt = 4\n    thresh = 0.1\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [1.0, 2.0, 3.0] \n    charge = [(0.0, 1.0), (0.5, 1.5)]\n    ztarg = [2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \nend program main",
            "result": [
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41) (  2.63363452E+20,  1.01397088E-38) (  4.82217751E+30,  1.07647170E+21) (  8.67567934E+29,  4.07402584E-11)",
                "(  3.00643765E-38,  0.00000000    ) (  0.00000000    ,  2.00000000    ) (  0.00000000    ,  2.12500000    ) (  0.00000000    ,  2.25000000    )",
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41) (  1.84707640E+25,  8.09124309E+20)",
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41)",
                "(  3.00643765E-38,  0.00000000    ) (  0.00000000    ,  2.12500000    ) (  0.00000000    ,  2.25000000    ) (  0.00000000    ,  2.31250000    )"
            ]
        },
        "code": "  subroutine helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh) !bind(c, name=\"helm3d_f_\")\n    implicit none\n    integer *4, intent(in) :: nd\n    complex *8, intent(in) :: zk\n    real    *8, intent(in) :: sources(*)\n    complex *8, intent(in) :: charge(*)\n    integer *4, intent(in) :: ns\n    real    *8, intent(in) :: ztarg(*)\n    integer *4, intent(in) :: nt\n    complex *8, intent(out):: pot(*)\n    real    *8, intent(in) :: thresh\n  end subroutine\n"
    },
    {
        "instruction": "Write a Fortran subroutine called get_opacities that calculates the opacities for a given set of parameters. The subroutine takes 6 input parameters and 2 output parameters. \n\nThe input parameters are:\n- kp: a logical value indicating whether to calculate the Planck mean opacity\n- kr: a logical value indicating whether to calculate the Rosseland mean opacity\n- rho: a real value representing the density\n- temp: a real value representing the temperature\n- rhoye: a real value representing the mass density times the specific internal energy\n- nu: a real value representing the frequency\n\nThe output parameters are:\n- kp: a real value representing the Planck mean opacity\n- kr: a real value representing the Rosseland mean opacity\n\nInside the subroutine, there are two conditional statements that calculate the opacities based on the input parameters. If the kp flag is true, the Planck mean opacity is calculated and stored in the kp variable. If the kr flag is true, the Rosseland mean opacity is calculated and stored in the kr variable.\n\nPlease note that the Thompon scattering cross-section constant is defined as ksc = 0.4 and the Planck mean opacity is assumed to be fac times the Thompon scattering cross-section constant, where fac = 1.0e-4.\n\nMake sure to provide the input and output parameters with the correct data types and follow the specified logic for calculating the opacities.",
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    double precision :: rho, temp, rhoye, nu, kp, kr\n    logical :: get_planck_mean, get_rosseland_mean\n    \n    ! Test case 1\n    rho = 1.0\n    temp = 5000.0\n    rhoye = 0.75\n    nu = 1.5\n    get_planck_mean = .true.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 2\n    rho = 0.5\n    temp = 10000.0\n    rhoye = 0.6\n    nu = 2.0\n    get_planck_mean = .true.\n    get_rosseland_mean = .false.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 3\n    rho = 2.0\n    temp = 8000.0\n    rhoye = 0.9\n    nu = 1.8\n    get_planck_mean = .false.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 4\n    rho = 1.2\n    temp = 6000.0\n    rhoye = 0.8\n    nu = 1.6\n    get_planck_mean = .false.\n    get_rosseland_mean = .false.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 5\n    rho = 0.8\n    temp = 7000.0\n    rhoye = 0.7\n    nu = 1.4\n    get_planck_mean = .true.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\nend program main\n",
            "result": [
                "3.0000000000000008E-005  0.30000000000000004",
                "2.4000000953674318E-005  0.30000000000000004",
                "2.4000000953674318E-005  0.35999999046325687",
                "2.4000000953674318E-005  0.35999999046325687",
                "2.7999999523162846E-005  0.27999999523162844"
            ]
        },
        "code": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: ksc = 0.4d0 ! thomson scattering \n    double precision, parameter :: fac = 1.d-4 ! planck mean is assumed to be fac*ksc\n\n    if (get_planck_mean) then\n       kp = rhoye*ksc * fac\n    end if\n\n    if (get_rosseland_mean) then\n       kr = rhoye*ksc\n    end if\n\n  end subroutine get_opacities\n"
    },
    {
        "instruction": "Create a Fortran subroutine called \"lennardjones\" to calculate the Lennard-Jones potential. The subroutine takes two input parameters and one output parameter. The first input parameter is a real number representing the distance between two centers, and the second input parameter is the output variable \"pot\" of type real to store the calculated potential. The subroutine also declares and initializes some variables used in the calculations. Within the subroutine, the Lennard-Jones potential is computed based on the given formula. Finally, the subroutine returns without any value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: r, pot\n    integer :: p, q\n    real :: epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    \n    ! Test case 1\n    r = 1.0\n    p = 4\n    q = 2\n    epl = 1.5\n    radius = 0.5\n    r_eq = 0.8\n    r_mn = 1.2\n    r_cof = 1.6\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 2\n    r = 2.5\n    p = 6\n    q = 3\n    epl = 2.0\n    radius = 1.0\n    r_eq = 1.8\n    r_mn = 3.5\n    r_cof = 4.5\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 3\n    r = 0.7\n    p = 10\n    q = 5\n    epl = 2.5\n    radius = 0.3\n    r_eq = 0.6\n    r_mn = 0.9\n    r_cof = 1.2\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 4\n    r = 1.2\n    p = 8\n    q = 4\n    epl = 1.8\n    radius = 0.7\n    r_eq = 1.1\n    r_mn = 1.8\n    r_cof = 2.5\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 5\n    r = 3.0\n    p = 12\n    q = 6\n    epl = 3.5\n    radius = 1.2\n    r_eq = 2.5\n    r_mn = 3.8\n    r_cof = 4.8\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\nend program main",
            "result": [
                "-0.380787015",
                "-0.259280562",
                "-0.461273909",
                "-0.334675848",
                "-0.406245112"
            ]
        },
        "code": "  subroutine lennardjones(r,pot)\n\n    !---- compute lj potential:\n    ! \n    !                   r(eq)^p     p   r(eq)^q\n    !     pot = epl ( ---------- - --- ---------- )\n    !                  r(m,n)^p     q   r(m,n)^q\n    !     where\n    !          epl    : strength of lj potential\n    !          r_eq   : equilibrium center-to-center distance\n    !          r(m,n) : center distance between m and n\n    !          r_cof  : cut-off center-to-center distance\n\n    integer p,q\n    real epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    real, intent(in) :: r\n    real, intent(out) :: pot\n\n\n    p = 18\n    q = 6\n    epl = 3.\n    pq = p*1./(q*1.)\n\n    radius = lz/6.\n    r_eq = 2.*radius + 3.5*dz\n    r_mn = 2.*radius + r\n    r_cof = 2.*radius + 6.*dz\n\n    pot_cof = epl*( r_eq**p/r_cof**p - pq* r_eq**q/r_cof**q) !potential at cut-off\n    pot = epl*( r_eq**p/r_mn**p - pq* r_eq**q/r_mn**q) - pot_cof !make potential zero at cut-off\n    if (r_mn .gt. r_cof) pot = 0. !make potential zero after cut-off\n\n\n    return\n  end subroutine lennardjones\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine code named calc_ps3d to calculate the power spectrum of a three-dimensional density field. The subroutine takes several input parameters: the size and boundaries of the density field (lo, hi, ng), the Fourier transform of the real and imaginary parts of the density field (overdensity_fft_real, overdensity_fft_imag), the number of bins for the power spectrum (num_bins), the edges of the k bins (k_bin_edges), the length of the domain (domain_length), and the grid length of the domain (domain_grid_length). \n\nThe subroutine also has several output parameters: the count of data points in each k bin (k_bin_count), the sum of weighted k values in each k bin (k_bin_power_weighted_k_sum), and the sum of power values in each k bin (k_bin_power_sum).\n\nThe subroutine calculates the magnitude of the wavevector for each grid point in k-space and assigns it to k_mag. It then checks if the magnitude is within the specified k bin edges and skips the value if it is out of bounds. It finds the matching k bin for each magnitude and increments the count, weighted k sum, and power sum for that bin. Finally, the subroutine returns the calculated power spectrum for the density field.\n\nPlease note that this subroutine uses the intrinsic module iso_c_binding for data type compatibility with C.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: lo(3) = [1, 1, 1], hi(3) = [64, 64, 64]\n    integer, parameter :: ng = 0, num_bins = 5\n    real*8, allocatable :: overdensity_fft_real(:,:,:,:), overdensity_fft_imag(:,:,:,:)\n    real*8, allocatable :: k_bin_edges(:), domain_length\n    integer, allocatable :: k_bin_count(:)\n    real*8, allocatable :: k_bin_power_weighted_k_sum(:), k_bin_power_sum(:)\n    integer :: i\n    \n    allocate(overdensity_fft_real(lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1))\n    allocate(overdensity_fft_imag(lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1))\n    allocate(k_bin_edges(num_bins+1))\n    allocate(k_bin_count(num_bins))\n    allocate(k_bin_power_weighted_k_sum(num_bins))\n    allocate(k_bin_power_sum(num_bins))\n    \n    ! Test case 1\n    overdensity_fft_real = 1.0\n    overdensity_fft_imag = 1.0\n    k_bin_edges = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]\n    domain_length = 1.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    overdensity_fft_real = 2.0\n    overdensity_fft_imag = 0.5\n    k_bin_edges = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n    domain_length = 2.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    overdensity_fft_real = 0.0\n    overdensity_fft_imag = 0.0\n    k_bin_edges = [0.0, 0.3, 0.6, 0.9, 1.2, 1.5]\n    domain_length = 3.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    overdensity_fft_real = 3.0\n    overdensity_fft_imag = 2.0\n    k_bin_edges = [0.0, 0.4, 0.8, 1.2, 1.6, 2.0]\n    domain_length = 4.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    overdensity_fft_real = 1.5\n    overdensity_fft_imag = 0.3\n    k_bin_edges = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]\n    domain_length = 5.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    deallocate(overdensity_fft_real)\n    deallocate(overdensity_fft_imag)\n    deallocate(k_bin_edges)\n    deallocate(k_bin_count)\n    deallocate(k_bin_power_weighted_k_sum)\n    deallocate(k_bin_power_sum)\nend program main",
            "result": [
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           6   1.9144080765545368        1.2187500000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           6  0.14114547909964500       0.11232000034332278     \n          12  0.39921970162073234       0.22464000068664555     \n           8  0.32596152141231499       0.14976000045776369"
            ]
        },
        "code": "subroutine calc_ps3d (overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                      domain_grid_length, k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n\n  use, intrinsic :: iso_c_binding\n  implicit none\n\n  integer(c_int), intent(in) :: lo(3), hi(3), ng, num_bins\n  real(c_double), intent(in), target :: overdensity_fft_real (lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1)\n  real(c_double), intent(in), target :: overdensity_fft_imag (lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1)\n  real(c_double), intent(in) :: k_bin_edges (num_bins+1)\n  real(c_double), intent(in) :: domain_length\n  integer(c_int), intent(in) :: domain_grid_length\n\n  integer(c_int), intent(out) :: k_bin_count (num_bins)\n  real(c_double), intent(out) :: k_bin_power_weighted_k_sum (num_bins)\n  real(c_double), intent(out) :: k_bin_power_sum (num_bins)\n\n  integer(c_int) :: i, j, k\n  integer(c_int) :: kk\n  integer(c_int) :: k_bin_index\n  integer(c_int) :: k_index_i, k_index_j, k_index_k\n\n  real(c_double) :: k_fund\n  real(c_double) :: k_mag\n  real(c_double) :: k_max\n  real(c_double) :: k_min\n  real(c_double) :: p_i\n  real(c_double) :: pi\n\n  pi = acos(-1.0)\n\n  k_fund = 2.0 * pi / domain_length\n\n  k_min = minval(k_bin_edges)\n  k_max = maxval(k_bin_edges)\n\n  k_bin_count (:) = 0\n  k_bin_power_weighted_k_sum (:) = 0.0\n  k_bin_power_sum (:) = 0.0\n\n  do k = lo(3), hi(3)\n    do j = lo(2), hi(2)\n      do i = lo(1), hi(1)\n\n        ! calculate grid points in k-space.\n        if (i <= domain_grid_length/2) then\n          k_index_i = i\n        else\n          k_index_i = i-domain_grid_length\n        end if\n        if (j <= domain_grid_length/2) then\n          k_index_j = j\n        else\n          k_index_j = j-domain_grid_length\n        end if\n        if (k <= domain_grid_length/2) then\n          k_index_k = k\n        else\n          k_index_k = k-domain_grid_length\n        end if\n\n        ! skip 0 mode.\n        if ((k_index_i == 0) .and. (k_index_j == 0) .and. (k_index_k == 0)) cycle\n\n        ! calculate magnitude of k vector.\n        k_mag = k_fund * sqrt(real(k_index_i*k_index_i + k_index_j*k_index_j + k_index_k*k_index_k, c_double))\n\n        ! skip value if out of bounds.\n        if ((k_mag < k_min) .or. (k_mag >= k_max)) cycle\n\n        ! find matching k bin.\n        k_bin_index = -1\n        do kk = 1, num_bins\n        if (k_mag >= k_bin_edges(kk) .and. k_mag < k_bin_edges(kk+1)) then\n            k_bin_index = kk\n              exit\n          end if\n        end do\n        if (k_bin_index < 0) stop 'could not match k bin'\n\n        p_i = (overdensity_fft_real(i, j, k, 1)**2 + overdensity_fft_imag(i, j, k, 1)**2) / domain_length**3\n\n        k_bin_count                (k_bin_index) = k_bin_count                (k_bin_index) + 1\n        k_bin_power_weighted_k_sum (k_bin_index) = k_bin_power_weighted_k_sum (k_bin_index) + k_mag*p_i\n        k_bin_power_sum            (k_bin_index) = k_bin_power_sum            (k_bin_index) + p_i\n\n      end do\n    end do\n  end do\n\nend subroutine calc_ps3d\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called matrix_multiply to multiply two matrices and compute the transpose of one matrix. The number of input parameters is 5. The first parameter is the size of the matrices, the type is integer. The second and third parameters are the matrices to be multiplied, both of type real and are of size nxn. The fourth and fifth parameters are the output matrices, both of type real and are also of size nxn.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    real :: a(n, n), b(n, n), c(n, n), a_t(n, n)\n    integer :: i, j\n    \n    ! Test case 1\n    a = reshape([1., 2., 3., 4., 5., 6., 7., 8., 9.], [n, n])\n    b = reshape([9., 8., 7., 6., 5., 4., 3., 2., 1.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    a = reshape([1., 0., 0., 0., 1., 0., 0., 0., 1.], [n, n])\n    b = reshape([1., 2., 3., 4., 5., 6., 7., 8., 9.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    a = reshape([2., 4., 6., 8., 10., 12., 14., 16., 18.], [n, n])\n    b = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    a = reshape([1., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    b = reshape([1., 1., 1., 1., 1., 1., 1., 1., 1.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    a = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    b = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "90.0000000    \n   54.0000000    \n   18.0000000    \n   114.000000    \n   69.0000000    \n   24.0000000    \n   138.000000    \n   84.0000000    \n   30.0000000",
                "1.00000000    \n   4.00000000    \n   7.00000000    \n   2.00000000    \n   5.00000000    \n   8.00000000    \n   3.00000000    \n   6.00000000    \n   9.00000000",
                "0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000",
                "1.00000000    \n   1.00000000    \n   1.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000",
                "0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000"
            ]
        },
        "code": "    subroutine matrix_bits(a, b, c, a_t, n)\n        implicit none\n\n        integer, intent(in) :: n\n        real, dimension(:,:), intent(in) :: a, b\n        real, dimension(:,:), intent(out) :: c, a_t\n        integer :: i, j, k\n\n        do i = 1, n\n            do j = 1, n\n                c(i,j) = 0.\n                do k = 1, n\n                    c(i,j) = c(i,j)+a(i,k)*b(k,j)\n                end do\n            end do\n        end do\n\n        do i = 1, n\n            do j = 1, n\n                a_t(i,j) = a(j,i)\n            end do\n        end do\n    end subroutine\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called bessj that calculates the regular Bessel functions of the first kind and their derivatives. This subroutine takes in four input parameters. The first parameter, x, is of type real(8) and represents the argument of the Bessel functions. The second parameter, nl, is of type integer and represents the maximum index of the Bessel functions. The third parameter, rj, is an array of type real(8) and represents the regular Bessel functions. The fourth parameter, rjp, is also an array of type real(8) and represents the derivatives of the Bessel functions. The subroutine does not return any values.\n\nThe subroutine uses Steed's method to compute the Bessel functions. It initializes necessary variables and performs downward recurrence to calculate the Bessel functions and their derivatives. The subroutine also handles special cases and performs necessary scaling.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: x, result1(10), result2(10)\n    integer :: nl\n    ! Test case 1\n    x = 2.0\n    nl = 5\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n\n    ! Test case 2\n    x = 0.5\n    nl = 3\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 7.0\n    nl = 7\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 3.0\n    nl = 2\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 5\n    x = 1.0\n    nl = 4\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\nend program main",
            "result": [
                "0.51301613656182732       0.49129377868716195       0.22392453146891558        6.8517549985127019E-002   1.5886893479028968E-002   2.9734706705033293E-003   0.0000000000000000        0.0000000000000000        6.9533384425872239E-310   2.0731943105538720E-317\n -0.36303974454670512       0.14454580254645585       0.21138811435101748       0.10401881899494331        3.2772039657311847E-002   7.7098491351448141E-003   1.1996396089095807E-316   3.9525251667299724E-323   0.0000000000000000        2.3635306506143582E-310",
                "0.54097378993452805        9.1701699625651306E-002   9.2364078193797258E-003   6.6237856814594265E-004   1.5886893479028968E-002   2.9734706705033293E-003   0.0000000000000000        0.0000000000000000        6.9533384425872239E-310   2.0731943105538720E-317\n  0.44927209030887671       0.26586869105757416        4.5519660528752684E-002   4.5997578423581280E-003   3.2772039657311847E-002   7.7098491351448141E-003   1.1996396089095807E-316   3.9525251667299724E-323   0.0000000000000000        2.3635306506143582E-310",
                "0.19812877407634455      -0.19905171329249380      -0.28343665120169914       -3.4030375658628542E-003  0.28003361363583623       0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n  0.21320376858366130       0.24078271263902185       -9.7824337863315472E-002 -0.28173513241876769      -0.18342464633175762       -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310",
                "6.5008182877375587E-002  0.47771821508709156       0.41271003220971592       -3.4030375658628542E-003  0.28003361363583623       0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n -0.46688351794086230      -0.17385092466617016       0.13379318824566167      -0.28173513241876769      -0.18342464633175762       -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310",
                "0.67139670714180288       0.24029783912342695        4.9496810228477933E-002   7.1862120189627003E-003   8.0667390426096075E-004  0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n   9.5400514447474494E-002  0.31094994845666246       0.11655581355223213        2.4345068162108487E-002   3.5561794497883767E-003  -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310"
            ]
        },
        "code": "subroutine bessj(x,nl,rj,rjp)\n  !returns the regular bessel functions of first kind\n  !$\\texttt{rj(l)}=j_{l-\\frac{1}{2}}$ and their derivatives\n  !$\\texttt{rjp(l)}=j'_{l-\\frac{1}{2}}$, for positive \\texttt{x} and for\n  !$1\\le l \\le nl+1$, using steed's method.\n  implicit none\n  real(8), intent(in) :: x\n  integer, intent(in) :: nl\n  real(8), intent(out) :: rj(*)            \n  real(8), intent(out) :: rjp(*)            \n  !    \n  integer :: i, isign, l \n  real(8) :: xnu, b, c, d, del, f, fact, gam, h, p, q, rjl, rjl1, rjmu, rjp1, rjpl, rjtemp, w, xi, xi2, xmu, xmu2\n  integer, parameter :: maxit=10000\n  real(8), parameter :: eps=1.e-16\n  real(8), parameter :: fpmin=1.e-30\n  real(8), parameter :: pi=3.141592653589793d+0\n\n  if(x.le.0..or.nl.lt.0) stop 'bad arguments in bessj'\n  xnu=dble(nl)+0.5d0\n  xmu=0.5d0\n  xmu2=xmu*xmu\n  xi=1.d0/x\n  xi2=2.d0*xi\n  !     the wronskian\n  w=xi2/pi\n  !     evaluate the continued fraction expansion for j'_(nl-1/2)/j_(nl-1/2)\n  !     by the modified lentz's method. isign keeps track of sign changes in\n  !     the denominator\n  isign=1\n  h=xnu*xi\n  if(h.lt.fpmin)h=fpmin\n  b=xi2*xnu\n  d=0.d0\n  c=h\n  do i=1,maxit\n     b=b+xi2\n     d=b-d\n     if(abs(d).lt.fpmin) d=fpmin\n     c=b-1.d0/c\n     if(abs(c).lt.fpmin) c=fpmin\n     d=1.d0/d\n     del=c*d\n     h=del*h\n     if(d.lt.0.d0) isign=-isign\n     if(abs(del-1.d0).lt.eps) goto 1\n  enddo\n!11   continue\n  stop 'x too large in bessjy; try asymptotic expansion'\n1 continue\n  !     initialize j and j' for downward recurrence\n  rjl=isign*fpmin\n  rjpl=h*rjl\n  !     store values for later rescaling      \n  rjl1=rjl\n  rjp1=rjpl\n  !     downward recurrence (unnormalized)\n  fact=xnu*xi\n  do l=nl,0,-1\n     rjtemp=fact*rjl+rjpl\n     fact=fact-xi\n     rjpl=fact*rjtemp-rjl\n     rjl=rjtemp\n  enddo\n  if(rjl.eq.0.d0)rjl=eps\n  f=rjpl/rjl\n  !     equation 6.7.3 numerical recipies in fortran\n  p=-.5d0*xi\n  q=1.d0\n  !     equation 6.7.6 numerical recipies in fortran\n  gam=(p-f)/q\n  !     equation 6.7.7 numerical recipies in fortran\n  rjmu=sqrt(w/((p-f)*gam+q))\n  rjmu=sign(rjmu,rjl)\n  !     scale original j and j'\n  fact=rjmu/rjl\n  rj(nl+1)=rjl1*fact\n  rjp(nl+1)=rjp1*fact\n  fact=xnu*xi\n  !     downward recurence\n  do l=nl,1,-1\n     rj(l)=fact*rj(l+1)+rjp(l+1)\n     fact=fact-xi\n     rjp(l)=fact*rj(l)-rj(l+1)\n  enddo ! l\nend subroutine bessj\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called `ostokesletp` that calculates the complex potential `p` for a given point in a 2D space. The subroutine takes 5 input parameters: `zk` (complex), `src` (real array of size 2), `targ` (real array of size 2), `mu` (complex array of size 2), and `p` (complex). The subroutine also has no output parameters.\n\nTo calculate `p`, the subroutine first calculates the difference between the x-coordinates and y-coordinates of `targ` and `src` respectively, storing them in `rx` and `ry`. It then calculates the square of the distance between `targ` and `src` and stores it in `r2`. Next, using the calculated values, it computes the complex potential `p` using the formula `(-rx*mu(1)-ry*mu(2))/(r2*pi2)`, where `pi2` is a constant value. Finally, the subroutine returns from the subroutine.\n\nPlease note that the subroutine uses the `implicit none` statement to enforce explicit variable declarations.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: zk, mu(2), p\n    real*8 :: src(2), targ(2)\n    \n    ! Test case 1\n    zk = cmplx(1.0, 2.0)\n    mu(1) = cmplx(0.5, 0.0)\n    mu(2) = cmplx(0.0, -0.5)\n    src(1) = 1.5\n    src(2) = 2.5\n    targ(1) = 3.0\n    targ(2) = 4.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n\n    ! Test case 2\n    zk = cmplx(-2.0, 1.0)\n    mu(1) = cmplx(0.0, 0.5)\n    mu(2) = cmplx(-0.5, 0.0)\n    src(1) = -1.0\n    src(2) = 3.2\n    targ(1) = 2.8\n    targ(2) = -4.7\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 3\n    zk = cmplx(3.0, -2.0)\n    mu(1) = cmplx(1.0, 0.0)\n    mu(2) = cmplx(0.0, 1.0)\n    src(1) = 0.0\n    src(2) = 0.0\n    targ(1) = 1.0\n    targ(2) = 1.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 4\n    zk = cmplx(0.5, 0.5)\n    mu(1) = cmplx(0.0, -1.0)\n    mu(2) = cmplx(-1.0, 0.0)\n    src(1) = -3.0\n    src(2) = 2.5\n    targ(1) = 1.2\n    targ(2) = -0.8\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 5\n    zk = cmplx(2.0, 0.0)\n    mu(1) = cmplx(0.0, 0.0)\n    mu(2) = cmplx(0.0, 0.0)\n    src(1) = -1.0\n    src(2) = 0.0\n    targ(1) = 1.0\n    targ(2) = 0.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \nend program main",
            "result": [
                "( -2.6525823848649224E-002,  2.6525823848649224E-002)",
                "( -8.1803778176087489E-003, -3.9348653012315736E-003)",
                "( -7.9577471545947673E-002, -7.9577471545947673E-002)",
                "( -1.8409088863599758E-002,  2.3429749644129808E-002)",
                "( -0.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "subroutine ostokesletp(zk,src,targ, &\n     mu,p)\n\n  implicit none\n  ! global \n  complex *16, intent(in) :: zk, mu(2)\n  real *8, intent(in) :: src(2), targ(2)\n  complex *16, intent(out) :: p\n  ! local\n  real *8 rx, ry, r2, pi2\n\n  pi2 = 8.0d0*datan(1.0d0)\n  \n\n  rx = targ(1)-src(1)\n  ry = targ(2)-src(2)\n\n  r2 = rx**2 + ry**2\n\n  p = (-rx*mu(1)-ry*mu(2))/(r2*pi2)\n\n  return\nend subroutine ostokesletp\n"
    },
    {
        "instruction": "Write a Fortran subroutine called `ostokesletpvec` that calculates the vector components of a Stokeslet influence function for a given complex number `zk`, source coordinates `src`, and target coordinates `targ`. The subroutine takes three input parameters: `zk` of type complex, `src` of type real array with size 2, and `targ` of type real array with size 2. It also has one output parameter `pvec` of type complex array with size 2. \n\nTo compute the vector components, the subroutine calculates the difference between the target and source coordinates `rx` and `ry`, then computes the square of their magnitudes `r2`. Finally, it computes the vector components of the influence function `pvec` using the formula `-rx/(r2*pi2)` for the first component and `-ry/(r2*pi2)` for the second component.\n\nRemember to use the `implicit none` statement to enforce explicit declaration of variables.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: complex_num, pvec(2)\n    real*8 :: src(2), targ(2)\n    \n    ! Test case 1\n    complex_num = (1.0, 2.0)\n    src = [0.0, 0.0]\n    targ = [1.0, 1.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n\n    ! Test case 2\n    complex_num = (2.0, -3.0)\n    src = [1.0, 2.0]\n    targ = [3.0, 4.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    complex_num = (0.5, 0.5)\n    src = [2.0, 3.0]\n    targ = [4.0, 5.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    complex_num = (4.0, 0.0)\n    src = [0.0, 0.0]\n    targ = [1.0, 1.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    complex_num = (1.0, 1.0)\n    src = [1.0, 2.0]\n    targ = [3.0, 4.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "( -7.9577471545947673E-002,  0.0000000000000000     ) ( -7.9577471545947673E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )",
                "( -7.9577471545947673E-002,  0.0000000000000000     ) ( -7.9577471545947673E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )"
            ]
        },
        "code": "subroutine ostokesletpvec(zk,src,targ, &\n     pvec)\n\n  implicit none\n  ! global \n  complex *16, intent(in) :: zk\n  real *8, intent(in) :: src(2), targ(2)\n  complex *16, intent(out) :: pvec(2)\n  ! local\n  real *8 rx, ry, r2, pi2\n\n  pi2 = 8.0d0*datan(1.0d0)\n  \n\n  rx = targ(1)-src(1)\n  ry = targ(2)-src(2)\n\n  r2 = rx**2 + ry**2\n\n  pvec(1) = -rx/(r2*pi2)\n  pvec(2) = -ry/(r2*pi2)\n\n  return\nend subroutine ostokesletpvec\n"
    },
    {
        "instruction": "Write a Fortran subroutine called find_next_smallest_location that finds the smallest value in an array and returns its location. The subroutine takes in three parameters: lengths, which is an integer array representing the values to search for the smallest; available, a logical array specifying if each element is available for selection; and location, an integer that will store the location of the smallest value. The subroutine modifies the available array by marking the smallest value as unavailable. The input arrays, lengths and available, are allocated dynamically.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, allocatable :: lengths(:)\n    logical, allocatable :: available(:)\n    integer :: location, i\n\n    ! Test case 1\n    allocate(lengths(3))\n    allocate(available(3))\n    lengths = [4, 2, 6]\n    available = [.true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 2\n    allocate(lengths(5))\n    allocate(available(5))\n    lengths = [1, 3, 2, 4, 5]\n    available = [.true., .true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 3\n    allocate(lengths(4))\n    allocate(available(4))\n    lengths = [7, 1, 3, 6]\n    available = [.true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 4\n    allocate(lengths(2))\n    allocate(available(2))\n    lengths = [2, 9]\n    available = [.true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 5\n    allocate(lengths(6))\n    allocate(available(6))\n    lengths = [5, 4, 2, 6, 3, 1]\n    available = [.true., .true., .true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\nend program main",
            "result": [
                "2",
                "3",
                "2",
                "2",
                "6"
            ]
        },
        "code": "   pure recursive subroutine find_next_smallest_location(lengths, available, location)\n      intent(in)    lengths\n      intent(out)   location\n      intent(inout) available\n\n      integer, allocatable :: lengths(:)\n      logical, allocatable :: available(:)\n      integer              :: location\n\n      location = minloc(lengths, dim=1, mask=available)\n\n      if (location == 1 .and. all(available)) then\n         available(location) = .false.\n         call find_next_smallest_location(lengths, available, location)\n      endif\n\n      available(location) = .false.\n   end subroutine find_next_smallest_location\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"calculate_sum\" that calculates the sum of numbers from 1 to a given value. The subroutine has 2 input parameters and 1 output parameter. The first input parameter \"n\" is an integer that represents the upper limit of the range. The second input parameter \"ret\" is an integer that will store the computed sum. The output parameter \"ret\" is also an integer that will hold the final sum.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input, output1, output2, output3, output4, output5\n    \n    ! Test case 1\n    input = 5\n    call test_do_loop_variable_trip_count(output1, input)\n    print *, output1\n    print *, \"&\"\n    \n    ! Test case 2\n    input = 10\n    call test_do_loop_variable_trip_count(output2, input)\n    print *, output2\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 20\n    call test_do_loop_variable_trip_count(output3, input)\n    print *, output3\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 3\n    call test_do_loop_variable_trip_count(output4, input)\n    print *, output4\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 0\n    call test_do_loop_variable_trip_count(output5, input)\n    print *, output5\n    print *, \"&\"\n    \nend program main",
            "result": [
                "15",
                "55",
                "210",
                "6",
                "0"
            ]
        },
        "code": "subroutine test_do_loop_variable_trip_count(ret, n)\n  integer, intent(out) :: ret\n  integer, intent(in) :: n\n  ret = 0\n  do i=1, n\n    ret = ret + i\n  end do\nend subroutine\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called \"areacal\" that calculates the area of a polygon. The subroutine takes three parameters: \"xc\" and \"yc\" are arrays of type real, representing the x and y coordinates of the vertices of the polygon respectively; \"area\" is a real variable used for storing the calculated area. The subroutine uses the formula for calculating the area of a polygon with given vertices. The number of vertices is determined by the size of the arrays \"xc\" and \"yc\". The calculated area is stored in the \"area\" variable and returned as an output.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: xc(5), yc(5), area\n    ! Test case 1\n    xc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    yc = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n\n    ! Test case 2\n    xc = [0.0, 1.0, 1.0, 0.0, 0.0]\n    yc = [0.0, 0.0, 1.0, 1.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 3\n    xc = [0.0, 2.0, 4.0, 6.0, 8.0]\n    yc = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 4\n    xc = [0.0, 1.0, 2.0, 2.0, 1.0]\n    yc = [0.0, 0.0, 0.0, 1.0, 1.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 5\n    xc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    yc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\nend program main",
            "result": [
                "0.0000000000000000",
                "1.0000000000000000",
                "0.0000000000000000",
                "1.5000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": " subroutine areacal(xc,yc,area)   \n  !area calculation of a polygon\n  !with given vextices (xc,yc)\n  real(8),intent(in) ::xc(:),yc(:)\n  real(8),intent(out)::area\n  real(8)::xvec(2),yvec(2)\n  integer(4)::npol,k\n  npol = size(xc)\n  area = 0\n  xvec(1)=xc(2)-xc(1)\n  yvec(1)=yc(2)-yc(1)\n  do k=3,npol\n    xvec(2) = xc(k)-xc(1)\n    yvec(2) = yc(k)-yc(1)\n    area = area+0.5*abs( xvec(1)*yvec(2)-xvec(2)*yvec(1))\n    xvec(1)=xvec(2)\n    yvec(1)=yvec(2)\n  enddo\n end subroutine\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called add1 to compute the sum of two integers. The number of input parameters is 2, both of which are integers. The number of output arguments is 1, which is also an integer.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: num1, num2, result\n    ! Test case 1\n    num1 = 2\n    num2 = 3\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    num1 = -5\n    num2 = 8\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    num1 = 0\n    num2 = 0\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    num1 = 100\n    num2 = -50\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    num1 = 999\n    num2 = 1\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "5",
                "3",
                "0",
                "50",
                "1000"
            ]
        },
        "code": "subroutine add1(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + y\nend subroutine\n"
    },
    {
        "instruction": "Please create a Fortran subroutine called rotate_euler_3d_inv to perform inverse 3D Euler angle rotation. The subroutine takes six input parameters and three output parameters, all of type double precision. The input parameters are alpha, beta, gamma, srcx, srcy, and srcz. The output parameters are destx, desty, and destz.\n\nTo calculate the inverse rotation, use the following equations:\n- destx = srcz * sin(beta) * sin(gamma) + srcy * (cos(gamma) * sin(alpha) + cos(alpha) * cos(beta) * sin(gamma)) + srcx * (cos(alpha) * cos(gamma) - cos(beta) * sin(alpha) * sin(gamma))\n- desty = srcz * cos(gamma) * sin(beta) + srcx * (-(cos(beta) * cos(gamma) * sin(alpha)) - cos(alpha) * sin(gamma)) + srcy * (cos(alpha) * cos(beta) * cos(gamma) - sin(alpha) * sin(gamma))\n- destz = srcz * cos(beta) - srcy * cos(alpha) * sin(beta) + srcx * sin(alpha) * sin(beta)\n\nUse the provided equations to assign the computed values to the output parameters destx, desty, and destz.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz\n    ! Test case 1\n    alpha = 0.0\n    beta = 0.0\n    gamma = 0.0\n    srcx = 1.0\n    srcy = 2.0\n    srcz = 3.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n\n    ! Test case 2\n    alpha = 1.0\n    beta = 1.0\n    gamma = 1.0\n    srcx = 2.0\n    srcy = 3.0\n    srcz = 4.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 3\n    alpha = 2.0\n    beta = 0.5\n    gamma = 1.5\n    srcx = 3.0\n    srcy = 4.0\n    srcz = 5.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 4\n    alpha = 1.5\n    beta = 0.0\n    gamma = 0.5\n    srcx = 4.0\n    srcy = 5.0\n    srcz = 6.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 5\n    alpha = 0.5\n    beta = 1.0\n    gamma = 1.0\n    srcx = 5.0\n    srcy = 6.0\n    srcz = 7.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000",
                "4.7518888202021952       -1.2330325086759331        2.2134099197811787",
                "-1.2850109997883696       -2.4858744286429353        6.4937797202740146",
                "2.8818997879398394       -5.7179238900384384        6.0000000000000000",
                "10.185621355353463       -2.0929436283318799        1.3684679660088808"
            ]
        },
        "code": "subroutine rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(beta)*dsin(gamma) + srcy*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = srcz*dcos(gamma)*dsin(beta) + srcx*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) - srcy*dcos(alpha)*dsin(beta) + srcx*dsin(alpha)*dsin(beta)\n\nend subroutine\n"
    },
    {
        "instruction": "Create a Fortran subroutine called \"circumcircle\" that calculates the center coordinates and radius of a circle that circumscribes three points in a 2D plane. The subroutine takes six input parameters: p1, p2, and p3 are arrays of size 2, containing the x and y coordinates of each point. The output parameters are x0, y0, and r, all of type double precision. \n\nTo calculate the circumcircle, the subroutine first checks if the three points lie on a straight line. If they do, the radius is set to -1 to indicate that the points do not form a circle. If the points are not collinear, the subroutine proceeds to compute the center coordinates and radius of the circumcircle using mathematical formulas.\n\nThe subroutine uses double precision variables for increased numerical precision.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: p1(2), p2(2), p3(2), x0, y0, r\n    ! Test case 1\n    p1 = [0.0, 0.0]\n    p2 = [1.0, 0.0]\n    p3 = [0.0, 1.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n\n    ! Test case 2\n    p1 = [2.0, 3.0]\n    p2 = [4.0, 5.0]\n    p3 = [6.0, 7.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 3\n    p1 = [1.0, 1.0]\n    p2 = [2.0, 3.0]\n    p3 = [4.0, 2.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 4\n    p1 = [0.0, 0.0]\n    p2 = [1.0, 1.0]\n    p3 = [2.0, 2.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 5\n    p1 = [0.5, 0.5]\n    p2 = [1.0, 1.0]\n    p3 = [1.5, 1.5]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000       0.50000000000000000       0.70710678118654757",
                "0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "2.5000000000000000        1.5000000000000000        1.5811388300841898",
                "2.5000000000000000        1.5000000000000000       -1.0000000000000000",
                "2.5000000000000000        1.5000000000000000       -1.0000000000000000"
            ]
        },
        "code": "  subroutine circumcircle(p1, p2, p3, x0, y0, r)\n\n    implicit none\n\n    double precision, dimension(2), intent(in)  :: p1, p2, p3\n    double precision,               intent(out) :: x0, y0, r\n\n    double precision :: xy1, xy2, xy3, d21, d31, d32, dx, dy\n    double precision :: f\n\n    f  = p1(2)*(p3(1)-p2(1)) + p2(2)*(p1(1)-p3(1)) + p3(2)*(p2(1)-p1(1))\n    if (abs(f) <= 1.0d-15) then\n       ! the points don't lie on a circle (since they are all on one line)\n       ! --> return negative radius\n       r = -1.0d0\n       return\n    end if\n\n    f  = 0.5d0 / f\n\n    xy1 = p1(1)*p1(1) + p1(2)*p1(2)\n    xy2 = p2(1)*p2(1) + p2(2)*p2(2)\n    xy3 = p3(1)*p3(1) + p3(2)*p3(2)\n\n    d21 = xy2 - xy1\n    d31 = xy3 - xy1\n    d32 = xy3 - xy2\n\n    x0 =  f*(p1(2)*d32 - p2(2)*d31 + p3(2)*d21)\n    y0 = -f*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21)\n\n    dx = p1(1) - x0\n    dy = p1(2) - y0\n    r  = sqrt(dx*dx + dy*dy)\n\n  end subroutine circumcircle\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called \"circumsphere\" to calculate the center and radius of the circumsphere of a tetrahedron. The subroutine has 7 input parameters and 4 output parameters. The input parameters are all of type double precision and represent the coordinates of the four points of the tetrahedron (p1, p2, p3, p4). The output parameters (x0, y0, z0, r) are also of type double precision and represent the center coordinates (x0, y0, z0) and the radius (r) of the circumsphere.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: p1(3), p2(3), p3(3), p4(3), x0, y0, z0, r\n\n    ! Test case 1\n    p1 = [1.0, 1.0, 1.0]\n    p2 = [2.0, 2.0, 2.0]\n    p3 = [3.0, 3.0, 3.0]\n    p4 = [4.0, 4.0, 4.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 2\n    p1 = [0.0, 0.0, 0.0]\n    p2 = [1.0, 0.0, 0.0]\n    p3 = [0.0, 1.0, 0.0]\n    p4 = [0.0, 0.0, 1.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 3\n    p1 = [1.0, 2.0, 3.0]\n    p2 = [4.0, 5.0, 6.0]\n    p3 = [7.0, 8.0, 9.0]\n    p4 = [10.0, 11.0, 12.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 4\n    p1 = [2.0, 2.0, 2.0]\n    p2 = [4.0, 4.0, 4.0]\n    p3 = [6.0, 6.0, 6.0]\n    p4 = [8.0, 8.0, 8.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 5\n    p1 = [0.0, 0.0, 0.0]\n    p2 = [1.0, 1.0, 0.0]\n    p3 = [1.0, 0.0, 1.0]\n    p4 = [0.0, 1.0, 1.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\nend program main",
            "result": [
                "9.3872472709836843E-323   2.3554754163633613E-310   0.0000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       0.86602540378443860",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       0.86602540378443860"
            ]
        },
        "code": "  subroutine circumsphere(p1,p2,p3,p4,x0,y0,z0,r)\n\n    implicit none\n\n    double precision, dimension(3), intent(in)  :: p1, p2, p3, p4\n    double precision,               intent(out) :: x0, y0, z0, r\n\n    double precision :: xyz1, xyz2, xyz3, xyz4\n    double precision :: d21, d31, d41, d32, d42, d43\n    double precision :: dx, dy, dz\n    double precision :: f\n\n    f = p1(3)*(p2(2)*(p4(1)-p3(1)) - p3(2)*(p4(1)-p2(1)) + p4(2)*(p3(1)-p2(1))) &\n      - p2(3)*(p1(2)*(p4(1)-p3(1)) - p3(2)*(p4(1)-p1(1)) + p4(2)*(p3(1)-p1(1))) &\n      + p3(3)*(p1(2)*(p4(1)-p2(1)) - p2(2)*(p4(1)-p1(1)) + p4(2)*(p2(1)-p1(1))) &\n      - p4(3)*(p1(2)*(p3(1)-p2(1)) - p2(2)*(p3(1)-p1(1)) + p3(2)*(p2(1)-p1(1)))\n\n    if (abs(f) <= 1.0d-15) then\n       ! the points don't lie on a circle (since they are all on one line)\n       ! --> return negative radius\n       r = -1.0d0\n       return\n    end if\n\n    f = 0.5d0 / f\n\n    xyz1 = p1(1)*p1(1) + p1(2)*p1(2) + p1(3)*p1(3)\n    xyz2 = p2(1)*p2(1) + p2(2)*p2(2) + p2(3)*p2(3)\n    xyz3 = p3(1)*p3(1) + p3(2)*p3(2) + p3(3)*p3(3)\n    xyz4 = p4(1)*p4(1) + p4(2)*p4(2) + p4(3)*p4(3)\n\n    d21  = xyz2 - xyz1\n    d31  = xyz3 - xyz1\n    d41  = xyz4 - xyz1\n    d32  = xyz3 - xyz2\n    d42  = xyz4 - xyz2\n    d43  = xyz4 - xyz3\n\n    x0   =  f*( p1(3)*(p2(2)*d43 - p3(2)*d42 + p4(2)*d32) &\n              - p2(3)*(p1(2)*d43 - p3(2)*d41 + p4(2)*d31) &\n              + p3(3)*(p1(2)*d42 - p2(2)*d41 + p4(2)*d21) &\n              - p4(3)*(p1(2)*d32 - p2(2)*d31 + p3(2)*d21) )\n\n    y0   = -f*( p1(3)*(p2(1)*d43 - p3(1)*d42 + p4(1)*d32) &\n              - p2(3)*(p1(1)*d43 - p3(1)*d41 + p4(1)*d31) &\n              + p3(3)*(p1(1)*d42 - p2(1)*d41 + p4(1)*d21) &\n              - p4(3)*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21) )\n\n    z0   =  f*( p1(2)*(p2(1)*d43 - p3(1)*d42 + p4(1)*d32) &\n              - p2(2)*(p1(1)*d43 - p3(1)*d41 + p4(1)*d31) &\n              + p3(2)*(p1(1)*d42 - p2(1)*d41 + p4(1)*d21) &\n              - p4(2)*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21) )\n\n    dx = p1(1) - x0\n    dy = p1(2) - y0\n    dz = p1(3) - z0\n    r = sqrt(dx*dx + dy*dy + dz*dz)\n\n  end subroutine circumsphere\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called ell_cov_2d to calculate the lower triangular matrix for three ellipses in a 2D space. The subroutine takes three input parameters and one output parameter. The first input parameter is an array of size 2 containing the coordinates of a point, with a type of real. The second input parameter is an integer representing the ellipse to be computed. The third input parameter is a 2x2 lower triangular matrix of type real, which will be updated with the computed values. The subroutine does not return any value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: p(2)\n    integer :: k_ell\n    real(kind=8), dimension(2,2) :: l\n    \n    ! Test case 1\n    p = [0.3, 0.6]\n    k_ell = 1\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 2\n    p = [-0.5, 0.8]\n    k_ell = 2\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 3\n    p = [0.9, 0.1]\n    k_ell = 3\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 4\n    p = [0.2, -0.7]\n    k_ell = 1\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 5\n    p = [-0.3, -0.4]\n    k_ell = 2\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.1155466862140624       0.43825043298325733        0.0000000000000000        1.3363061754263843",
                "1.1999999682108555        0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "1.0981581674632266        1.1399554434079029E-002   0.0000000000000000       0.99510731308739164",
                "1.0329219430355818      -0.22678101236501846        0.0000000000000000        1.3298252291283703",
                "3.0550503332358998        0.0000000000000000        0.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "subroutine ell_cov_2d( p, k_ell, l )\n\n!  in 2d, given the point p (|p|<1, |p_1|>0), three ellipses are defined:\n!  e_1 is the unit circle, shrunk in the p direction to intersect p \n!  e_2 is the unit circle, shrunk in the x_1 direction to intersect p, and\n!  e_3 is the minimum-area ellipse covering e_1 and e_2.\n!  the 2 x 2 lower trianglular matrix l is returned, \n!  where e_{k_ell} = { x | |l^t * x| <1 }.\n\n!  s.b. pope  12/16/05\n\nimplicit none\n\ninteger, parameter      :: k_dp = kind(1.d0)\nreal(k_dp), intent(in)  :: p(2)\ninteger,    intent(in)  :: k_ell\nreal(k_dp), intent(out) :: l(2,2)\n\nreal(k_dp), parameter   :: tol = 1.d-12\n\nreal(k_dp) :: psq, chi, theta, a, b, c, phi, sp, cp, sig1sq, sig2sq, sig1, &\n              sig2, alpha, d11, d21, d12, d22, ca, sa\n\n\nl = 0.d0  ! set l to unit circle\nl(1,1) = 1.d0\nl(2,2) = 1.d0\n\n!  check that input is valid\nif( abs(p(1))==0.d0 ) then\n   write(0,*) 'ell_cov_2d: p_1 is zero'\n   return\nendif\n\nif( k_ell < 1  .or.  k_ell > 3 ) then\n   write(0,*) 'ell_cov_2d: invalid k_ell = ', k_ell\n   stop\nendif\n\npsq = sum(p*p)\nif( psq > 1.d0+tol ) then  !  treat boundary and exterior\n   write(0,*) 'ell_cov_2d: |p| > 1, ', psq-1.d0\n   return \nelseif( psq >= 1.d0-tol ) then\n   return\nendif\n\nchi   = abs(p(1))/sqrt(1-p(2)**2)  ! intersection of e_2 and x_1 axis\n\nif( k_ell == 2 ) then  !  short-cut for e_2\n   l(1,1) = 1.d0 / chi\n   return\nendif\n\ntheta = (1-psq)/psq**2             ! e_1={x | x^t*(i+theta*p*p^t)*x <1 }\n\n!  transform so that e_1 is the unit circle: (x,y)->(x/chi,y)\na = (1.d0+theta*p(1)**2)*chi**2     ! b=[a cc b] is the matrix describing e_1\nb = 1.d0 + theta*p(2)**2\nc = theta*chi*p(1)*p(2)\n\n!  eigendecomposition of b\nphi = .5d0*atan2(-2.d0*c,(a-b))\nsp  = sin(phi)\ncp  = cos(phi)\n\nsig1sq = a*cp*cp-2.d0*c*sp*cp+b*sp*sp\nsig2sq = a*sp*sp+2.d0*c*sp*cp+b*cp*cp\n\n!  check that sigs bracket unity\nif( min(sig1sq,sig2sq) >1.d0 + tol .or. max(sig1sq,sig2sq) <1.d0 - tol ) then \n    write(0,*) 'ell_cov_2d: sig1sq-1, sig2sq-1= ' ,sig1sq-1.d0, sig2sq-1.d0\nendif\n\n! set principal axes for e_1, e_2 or e_3\n!  no change needed for e_1\n\nif( k_ell == 2 ) then\n    sig1sq=1.d0  ! set to e_2\n\tsig2sq=1.d0 \n    \nelseif( k_ell ==3 ) then\n    sig1sq = min(sig1sq, 1.d0)  ! e_3\n    sig2sq = min(sig2sq, 1.d0)\nendif\n\n!  the matrix for e_3 is: d*d^t,  d=c*u*sig = [q r s t]\nsig1 = sqrt(sig1sq)\nsig2 = sqrt(sig2sq)\nd11  = sig1*cp/chi\nd12  = sig2*sp/chi\nd21  =-sig1*sp\nd22  = sig2*cp\n!!  d = [d11 d12 d21 d22]\n!  transform back\nalpha = atan2(-d12, d11)\nca = cos(alpha)\nsa = sin(alpha)\n!!  qt = [ca sa; -sa ca]\n!! l  = d*qt\nl(1,1) = ca*d11 - sa*d12\nl(2,1) = ca*d21 - sa*d22\nl(2,2) = sa*d21 + ca*d22\n\nreturn\n\nend subroutine ell_cov_2d\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called kern_sqexp that computes the exponential function of each element in an array. The subroutine takes three parameters: nx, which is an integer representing the size of the array; nu, which is an array of real numbers; and out, which is an array of real numbers that will store the computed exponential values. The subroutine calculates the exponential value of each element in the nu array and stores the results in the out array.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nx\n    real*8, allocatable :: nu(:), out(:)\n    \n    ! Test case 1\n    nx = 5\n    allocate(nu(nx), out(nx))\n    nu = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 2\n    nx = 3\n    allocate(nu(nx), out(nx))\n    nu = [0.0, -1.0, -2.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 3\n    nx = 2\n    allocate(nu(nx), out(nx))\n    nu = [0.5, 1.5]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 4\n    nx = 4\n    allocate(nu(nx), out(nx))\n    nu = [-0.5, 1.0, -1.5, 2.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 5\n    nx = 1\n    allocate(nu(nx), out(nx))\n    nu = [3.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\nend program main",
            "result": [
                "0.60653065971263342       0.36787944117144233       0.22313016014842982       0.13533528323661270        8.2084998623898800E-002",
                "1.0000000000000000        1.6487212707001282        2.7182818284590451",
                "0.77880078307140488       0.47236655274101469",
                "1.2840254166877414       0.60653065971263342        2.1170000166126748       0.36787944117144233",
                "0.22313016014842982"
            ]
        },
        "code": "pure subroutine kern_sqexp(nx, nu, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: nu(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*nu)\nend subroutine kern_sqexp\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called get_dist that calculates the distance between two atoms in a three-dimensional space. The subroutine takes in 5 input parameters: two integers i and j representing the indices of the atoms, a 3x3 real matrix aa representing the transformation matrix, and aa_atom, a two-dimensional real array representing the atomic coordinates. The subroutine also has 1 output parameter: a real variable d representing the calculated distance.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: i, j\n    real*8 :: aa(3,3), aa_atom(3,5), d\n    ! Test case 1\n    i = 1\n    j = 2\n    aa = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n\n    ! Test case 2\n    i = 2\n    j = 3\n    aa = reshape([2.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 3\n    i = 3\n    j = 4\n    aa = reshape([1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 4\n    i = 1\n    j = 4\n    aa = reshape([2.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 5\n    i = 2\n    j = 5\n    aa = reshape([1.0, 0.0, 0.0, 2.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\nend program main",
            "result": [
                "1.4142135623730951",
                "1.4142135623730951",
                "2.2360679774997898",
                "2.4494897427831779",
                "1.7320508075688772"
            ]
        },
        "code": "  subroutine get_dist( i, j, aa, aa_atom, d )\n    implicit none\n    integer,intent(in)  :: i,j\n    real(8),intent(in)  :: aa(3,3),aa_atom(:,:)\n    real(8),intent(out) :: d\n    real(8) :: ri(3),rj(3)\n    ri=matmul(aa,aa_atom(:,i))\n    rj=matmul(aa,aa_atom(:,j))\n    d=sqrt( sum((ri-rj)**2) )\n  end subroutine get_dist\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code called plschmidt to evaluate the Schmidt normalized Legendre polynomials up to a specified degree. The subroutine has four input parameters and one optional output parameter. The first input parameter, lmax, is an integer representing the maximum degree to compute. The second input parameter, p, is a real*8 array that will store the evaluated Legendre polynomials. The third input parameter, z, is a real*8 representing the cos(colatitude) or sin(latitude) and must be within the range [-1, 1]. The fourth input parameter, exitstatus, is an optional integer that will be set to 0 if no errors occur during execution.\n\nThe subroutine computes the Schmidt normalized Legendre polynomials up to the specified degree and stores the results in the p array. It performs error checks for the dimensions of the input array and the bounds of the input variables. If an error is encountered, the subroutine either stops execution or sets the exitstatus variable accordingly.\n\nNote that the subroutine assumes the p array is dimensioned as (lmax+1), where lmax is the maximum degree specified. The computed Legendre polynomials follow certain integral properties, such as the integral of plm**2 over (-1,1) and over all space.\n\nEnsure the input and output parameters are correctly specified and conform to the Fortran subroutine syntax.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: lmax = 5\n    real*8 :: z\n    real*8 :: p(lmax+1)\n    integer :: exitstatus\n    \n    ! Test case 1\n    z = 0.5\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 2\n    z = -0.8\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 3\n    z = 1.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 4\n    z = -1.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 5\n    z = 0.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000       0.50000000000000000      -0.12500000000000000      -0.43750000000000000      -0.28906250000000000        8.9843750000000000E-002",
                "1.0000000000000000      -0.80000001192092896       0.46000002861022971       -8.0000039339066367E-002 -0.23299996471404849       0.39951998565911973",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "1.0000000000000000       -1.0000000000000000        1.0000000000000000       -1.0000000000000000        1.0000000000000000       -1.0000000000000000",
                "1.0000000000000000        0.0000000000000000      -0.50000000000000000       -0.0000000000000000       0.37500000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine plschmidt(p, lmax, z, exitstatus)\n!------------------------------------------------------------------------------\n!\n!   this function evalutates all of the schmidt normalized legendre\n!   polynomials up to degree lmax.\n!\n!   calling parameters\n!\n!       out\n!           p       a vector of all schmidt normalized legendgre polynomials\n!                   evaluated at z up to lmax. the lenght must by greater or\n!                   equal to (lmax+1).\n!\n!       in\n!           lmax    maximum degree to compute.\n!           z       [-1, 1], cos(colatitude) or sin(latitude).\n!\n!       optional (out)\n!           exitstatus  if present, instead of executing a stop when an error\n!                       is encountered, the variable exitstatus will be\n!                       returned describing the error.\n!                       0 = no errors;\n!                       1 = improper dimensions of input array;\n!                       2 = improper bounds for input variable;\n!                       3 = error allocating memory;\n!                       4 = file io error.\n!\n!   notes:\n!\n!   1.  the integral of plm**2 over (-1,1) is 2 * / (2l+1).\n!   2.  the integral of plm**2 over all space is 4 pi / (2l+1).\n!\n!   copyright (c) 2016, shtools\n!   all rights reserved.\n!\n!------------------------------------------------------------------------------\n    implicit none\n\n    integer, intent(in) :: lmax\n    real*8, intent(out) :: p(:)\n    real*8, intent(in) :: z\n    integer, intent(out), optional :: exitstatus\n    real*8 :: pm2, pm1, pl\n    integer :: l\n\n    if (present(exitstatus)) exitstatus = 0\n\n    if (size(p) < lmax+1) then\n        print*, \"error --- plschmidt\"\n        print*, \"p must be dimensioned as (lmax+1) where lmax is \", lmax\n        print*, \"input array is dimensioned \", size(p)\n        if (present(exitstatus)) then\n            exitstatus = 1\n            return\n        else\n            stop\n        endif\n\n    else if (lmax < 0) then\n        print*, \"error --- plschmidt\"\n        print*, \"lmax must be greater than or equal to 0.\"\n        print*, \"input value is \", lmax\n        if (present(exitstatus)) then\n            exitstatus = 2\n            return\n        else\n            stop\n        endif\n\n    else if(abs(z) > 1.0d0) then\n        print*, \"error --- plschmidt\"\n        print*, \"abs(z) must be less than or equal to 1.\"\n        print*, \"input value is \", z\n        if (present(exitstatus)) then\n            exitstatus = 2\n            return\n        else\n            stop\n        endif\n\n    end if\n\n    pm2 = 1.d0\n    p(1) = 1.d0\n\n    pm1 = z\n    p(2) = pm1\n\n    do l = 2, lmax, 1\n        pl = ( dble(2*l-1)  * z * pm1 - dble(l-1) * pm2 ) / dble(l)\n        p(l+1) = pl\n        pm2 = pm1\n        pm1 = pl\n\n    end do\n\nend subroutine plschmidt\n"
    },
    {
        "instruction": "Create a Fortran subroutine called fit_line to calculate the coefficients of a line that fits two given points. The subroutine has 6 parameters. The outputs are a0 and a1, both of type real. The inputs are x1, y1, x2, and y2, all of type real. The subroutine should compute the values of a0 and a1 using the given formula.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: a0, a1, x1, y1, x2, y2\n    ! Test case 1\n    x1 = 1.0\n    y1 = 2.0\n    x2 = 3.0\n    y2 = 6.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n\n    ! Test case 2\n    x1 = -2.0\n    y1 = 5.0\n    x2 = 4.0\n    y2 = 1.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = 0.0\n    y1 = 0.0\n    x2 = 10.0\n    y2 = 5.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 2.5\n    y1 = 10.0\n    x2 = 5.0\n    y2 = 0.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -3.0\n    y1 = -6.0\n    x2 = 3.0\n    y2 = 12.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\nend program main",
            "result": [
                "2.00000000       0.00000000",
                "-0.666666687       3.66666651",
                "0.500000000       0.00000000",
                "-4.00000000       20.0000000",
                "3.00000000       3.00000000"
            ]
        },
        "code": "  subroutine fit_line(a1,a0,x1,y1,x2,y2)\n\n    implicit none\n    real, intent(out) :: a0, a1\n    real, intent(in) :: x1, y1, x2, y2\n\n    !given xi, yi i=1,2 fits a line between these points\n\n    a1=(y2-y1)/(x2-x1)\n    a0=y1-a1*x1\n\n  end subroutine fit_line\n"
    },
    {
        "instruction": "Create a Fortran subroutine called split_kv that takes in a single input parameter of type character and splits it into two separate output parameters, also of type character. The input parameter is intended to be in the format \"key=value\" where \"key\" and \"value\" are strings. The subroutine extracts the key and value from the input parameter and assigns them to the respective output parameters. The subroutine uses the keywords \"character\", \"intent\", \"in\", \"out\", \"index\", \"trim\", \"adjustl\", and \"end subroutine\".",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    character(len=30) :: parameter\n    character(len=15) :: key, value\n    \n    ! Test case 1\n    parameter = \"name=John Doe\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 2\n    parameter = \"age=25\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 3\n    parameter = \"location=New York\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 4\n    parameter = \"salary=50000\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 5\n    parameter = \"gender=Male\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \nend program main",
            "result": [
                "name           John Doe",
                "age            25",
                "location       New York",
                "salary         50000",
                "gender         Male"
            ]
        },
        "code": "    subroutine split_kv(par,key,val)\n    character(len=*),intent(in):: par\n    character(len=*),intent(out):: key,val\n    character:: eq='='\n    integer:: id\n    id=index(par,eq)\n    key=trim(adjustl(par(1:id-1)))\n    val=trim(adjustl(par(id+1:)))\n    end subroutine\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"interpolation\" to perform linear interpolation. The subroutine takes 4 input parameters, all of type real(8). The first two parameters represent the left value and distance, while the next two parameters represent the right value and distance. There is one output parameter, also of type real(8), which represents the interpolated value. Your task is to implement the interpolation formula: f = (fl*dr + fr*dl) / (dl + dr).",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: fl, dl, fr, dr, f\n    \n    ! Test case 1\n    fl = 1.0\n    dl = 2.0\n    fr = 3.0\n    dr = 4.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 2\n    fl = 0.0\n    dl = 10.0\n    fr = 5.0\n    dr = 7.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 3\n    fl = -3.5\n    dl = 6.0\n    fr = 2.5\n    dr = 1.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 4\n    fl = 8.0\n    dl = 3.0\n    fr = -1.0\n    dr = 2.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 5\n    fl = -2.5\n    dl = 0.5\n    fr = 1.5\n    dr = -1.5\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.6666666666666667",
                "2.9411764705882355",
                "1.6428571428571428",
                "2.6000000000000001",
                "-4.5000000000000000"
            ]
        },
        "code": "subroutine interpolation(fl, dl, fr, dr, f)\n  implicit none\n  real(8), intent(in) :: fl, dl, fr, dr\n  real(8), intent(out) :: f\n  f = (fl*dr+fr*dl)/(dl+dr)\nend subroutine interpolation\n"
    },
    {
        "instruction": "Please write a Fortran subroutine called \"func\" to calculate the exponential function of a given input value. The subroutine should have 2 parameters. The first parameter is the input value, which is of type real and passed by value. The second parameter is the output value, which is also of type real and passed by reference. The output value should store the result of applying the exponential function to the input value.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind(0.d0)) :: input, output\n    ! Test case 1\n    input = 0.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = 1.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 2.5\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = -1.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 5.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000",
                "0.36787944117144233",
                "8.2084998623898800E-002",
                "2.7182818284590451",
                "6.7379469990854670E-003"
            ]
        },
        "code": "        subroutine func(x,fx)\n        implicit none\n        real (kind(0.d0)), intent(in)  :: x\n        real (kind(0.d0)), intent(out) :: fx\n!\n        fx = exp(-x)\n        return\n        end subroutine func\n"
    },
    {
        "instruction": "Provide a Fortran subroutine called linear_shape_1d to calculate the shape functions and their derivatives for a 1D linear shape. The subroutine takes in three parameters: \n1. xi, a real number that represents the location on the shape.\n2. n_shape, an array of size 2 to store the calculated shape functions.\n3. dn_shape, an array of size 2 to store the calculated derivatives of the shape functions.\n\nIn the subroutine, the shape functions are calculated as follows:\n- The first shape function (n_shape(1)) is half of (1-xi).\n- The second shape function (n_shape(2)) is half of (1+xi).\n\nThe derivatives of the shape functions are calculated as follows:\n- The derivative of the first shape function (dn_shape(1)) is -0.5.\n- The derivative of the second shape function (dn_shape(2)) is 0.5.\n\nMake sure to use the \"implicit none\" statement to enforce explicit declaration of variables.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: xi, n_shape(2), dn_shape(2)\n    ! Test case 1\n    xi = 0.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n\n    ! Test case 2\n    xi = 1.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = -0.5\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = 0.75\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = -1.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000       0.50000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.0000000000000000        1.0000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.75000000000000000       0.25000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.12500000000000000       0.87500000000000000      -0.50000000000000000       0.50000000000000000",
                "1.0000000000000000        0.0000000000000000      -0.50000000000000000       0.50000000000000000"
            ]
        },
        "code": " subroutine linear_shape_1d(xi,n_shape,dn_shape)\n   implicit none\n   !--dummy arguments\n   real(kind=8),intent(in) :: xi\n   real(kind=8),intent(out) :: n_shape(2),dn_shape(2)\n   !--local arguments\n\n   !functions\n   n_shape(1) = 0.5d0*(1.d0-xi)\n   n_shape(2) = 0.5d0*(1.d0+xi)\n   !derivatives\n   dn_shape(1) = -0.5d0\n   dn_shape(2) = 0.5d0\n\n end subroutine linear_shape_1d\n"
    },
    {
        "instruction": "Create a Fortran subroutine called quadratic_shape_1d to calculate the shape functions and their derivatives for a one-dimensional quadratic element. The subroutine takes in three input parameters: xi of type real(kind=8) as the independent variable, and n_shape(3) and dn_shape(3) of type real(kind=8) arrays to store the shape functions and their derivatives, respectively. The subroutine has no local variables. The shape functions and their derivatives are calculated using specific formulas and stored in the respective arrays. The subroutine returns the calculated values of the shape functions and their derivatives through the output parameters n_shape and dn_shape.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: xi, n_shape(3), dn_shape(3)\n    \n    ! Test case 1\n    xi = 0.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    xi = 0.5\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = 1.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = -0.5\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = 2.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-0.0000000000000000        1.0000000000000000        0.0000000000000000      -0.50000000000000000        1.0000000000000000       0.50000000000000000",
                "-0.12500000000000000       0.75000000000000000       0.37500000000000000        0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        1.0000000000000000       0.50000000000000000       -1.0000000000000000        1.5000000000000000",
                "0.37500000000000000       0.75000000000000000      -0.12500000000000000       -1.0000000000000000        2.0000000000000000        0.0000000000000000",
                "1.0000000000000000       -3.0000000000000000        3.0000000000000000        1.5000000000000000       -3.0000000000000000        2.5000000000000000"
            ]
        },
        "code": "  subroutine quadratic_shape_1d(xi,n_shape,dn_shape)\n    implicit none\n    !--dummy arguments\n    real(kind=8),intent(in) :: xi\n    real(kind=8),intent(out) :: n_shape(3),dn_shape(3)\n    !--local arguments\n\n    !functions\n    n_shape(1) = 0.5d0*xi*(xi-1.d0)\n    n_shape(2) = 1.d0-xi**2.d0\n    n_shape(3) = 0.5d0*xi*(xi+1.d0)\n    !derivatives\n    dn_shape(1) = 0.5d0*(2.d0*xi-1.d0)\n    dn_shape(2) = 1.d0-2.d0*xi\n    dn_shape(3) = 0.5d0*(2.d0*xi+1.d0)\n\n  end subroutine quadratic_shape_1d\n"
    },
    {
        "instruction": "Please provide a Fortran subroutine called locate_ij that performs a binary search algorithm to find the index of the element in a given array that is closest to, but less than, a given value. The subroutine takes 3 input parameters: length, an integer representing the size of the array; array, a real array containing the elements; value, a real value to search for. The subroutine also has 1 output parameter: idx, an integer representing the index of the closest element. The subroutine should be implemented to find the closest element in a sorted array.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: length, idx\n    real, dimension(:), allocatable :: array\n    real :: value\n    \n    ! Test case 1\n    length = 5\n    allocate(array(length))\n    array = [1.0, 2.0, 3.0, 4.0, 5.0]\n    value = 2.5\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 2\n    length = 6\n    allocate(array(length))\n    array = [2.0, 4.0, 6.0, 8.0, 10.0, 12.0]\n    value = 7.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 3\n    length = 3\n    allocate(array(length))\n    array = [1.5, 2.5, 3.5]\n    value = 3.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 4\n    length = 4\n    allocate(array(length))\n    array = [0.1, 0.2, 0.3, 0.4]\n    value = 0.3\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 5\n    length = 1\n    allocate(array(length))\n    array = [5.0]\n    value = 3.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\nend program main",
            "result": [
                "2",
                "3",
                "2",
                "3",
                "0"
            ]
        },
        "code": "subroutine locate_ij(length, array, value, idx)\n        ! given an array and a value, returns the index of the element that\n        ! is closest to, but less than, the given value.\n        ! uses a binary search algorithm.\n        implicit none\n        integer, intent(in) :: length\n        real, dimension(length), intent(in) :: array      \n        real, intent(in) :: value\n\tinteger, intent(out) :: idx\n        integer :: left, middle, right\n       \n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            end if\n            middle = nint((left+right) / 2.0)\n            if ( abs(array(middle) - value) <= 1e-9) then\n                idx = middle\n                return\n            else if (array(middle) > value) then\n                right = middle - 1\n            else\n                left = middle + 1\n            end if\n        end do\n        idx = right\n\n\treturn\nend subroutine locate_ij\n"
    },
    {
        "instruction": "Give me a Fortran subroutine code called cross to compute the cross product of two 3-dimensional vectors. The subroutine takes in 2 input parameters and 1 output parameter. The first input parameter is an array of type real with dimension 3, representing the first vector. The second input parameter is also an array of type real with dimension 3, representing the second vector. The output parameter is an array of type real with dimension 3, representing the resulting cross product.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: x(3), y(3), tmp(3)\n    \n    ! Test case 1\n    x = [1.0, 2.0, 3.0]\n    y = [4.0, 5.0, 6.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [0.5, 1.5, 2.5]\n    y = [1.0, 2.0, 3.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [10.0, 20.0, 30.0]\n    y = [3.0, 2.0, 1.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [1.0, 1.0, 1.0]\n    y = [2.0, 2.0, 2.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [-1.0, -2.0, -3.0]\n    y = [4.0, 5.0, 6.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-3.00000000       6.00000000      -3.00000000",
                "-0.500000000       1.00000000     -0.500000000",
                "-40.0000000       80.0000000      -40.0000000",
                "0.00000000       0.00000000       0.00000000",
                "3.00000000      -6.00000000       3.00000000"
            ]
        },
        "code": "    subroutine cross(tmp, x,y)\n        real, dimension(3), intent(in) :: x,y\n        real, dimension(3), intent(out) :: tmp\n\n        tmp(1) = x(2)*y(3)-x(3)*y(2)\n        tmp(2) = x(3)*y(1)-x(1)*y(3)\n        tmp(3) = x(1)*y(2)-x(2)*y(1)\n    end subroutine\n"
    },
    {
        "instruction": "Please create a Fortran subroutine called \"unrotate_frame\" to rotate a given set of coordinates in three dimensions. The subroutine takes in 7 input parameters: x_in, y_in, z_in (real values representing the initial coordinates), stheta, ctheta, sphi, cphi (real values representing the sine and cosine of the rotation angles). It also has 3 output parameters: xn, yn, zn (real values representing the rotated coordinates).\n\nTo implement the subroutine, declare the necessary variables and use the provided rotation formulas to calculate the new coordinates. Assign the results to xn, yn, and zn. Finally, use the \"return\" statement to exit the subroutine.\n\nMake sure to specify the data types of the input and output parameters correctly, using the \"real (kind=8)\" declaration for double-precision floating-point numbers.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn\n    ! Test case 1\n    x = 1.0\n    y = 0.0\n    z = 0.0\n    stheta = 0.0\n    ctheta = 1.0\n    sphi = 0.0\n    cphi = 1.0\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n\n    ! Test case 2\n    x = 0.0\n    y = 1.0\n    z = 0.0\n    stheta = 1.0\n    ctheta = 0.0\n    sphi = 1.0\n    cphi = 0.0\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 1.0\n    y = 1.0\n    z = 1.0\n    stheta = 0.5\n    ctheta = 0.866\n    sphi = 0.707\n    cphi = 0.707\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 2.0\n    y = 3.0\n    z = 1.0\n    stheta = 0.258\n    ctheta = 0.966\n    sphi = 0.866\n    cphi = 0.5\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 5\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    stheta = -0.5\n    ctheta = 0.866\n    sphi = -0.707\n    cphi = -0.707\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.25876200392293924        1.6727620382552146       0.36599999666213989",
                "-1.5029999762773514        3.3965400164341926       0.45000004768371582",
                "-0.44823801324319845       0.96576202108907694       -1.3659999966621399"
            ]
        },
        "code": "  subroutine unrotate_frame(x_in, y_in, z_in, stheta, ctheta, sphi, cphi, xn, yn, zn)\n!     \n!\n!     -----description: rotates the frame using input angles\n!          phi and theta\n!\n!\n!          on input:  \n!\n!          on output:\n!          \n!\n!     ----------------------------------------------------------------\n!\n    implicit none\n!\n!     -----variable declarations\n!          ---------------------\n!\n    real (kind=8), intent(in) :: x_in, y_in, z_in\n    real (kind=8), intent(in) :: stheta, ctheta, sphi, cphi\n    real (kind=8), intent(out) :: xn, yn, zn\n\n    real (kind=8) :: x1, y1, z1\n    real (kind=8) :: x2, y2, z2\n!\n!     ----------------------------------------------------------------\n!\n\n    x1 = x_in\n    y1 = y_in\n    z1 = z_in\n\n    x2  =   x1 * ctheta +  z1 * stheta\n    y2  =   y1\n    z2  =  -x1 * stheta +  z1 * ctheta\n\n    xn  =   x2  * cphi -  y2 * sphi\n    yn  =   x2  * sphi +  y2 * cphi\n    zn  =   z2\n    \n    return\n\n  end subroutine unrotate_frame\n"
    },
    {
        "instruction": "Write a Fortran subroutine called gram_schmidt that performs the Gram-Schmidt orthogonalization process on a given matrix. The subroutine takes four parameters as input: an integer n representing the number of rows in the matrix, an integer m representing the number of columns in the matrix, a double precision two-dimensional array u_in containing the input matrix, and a double precision two-dimensional array u_out that will store the output matrix after the orthogonalization process. The subroutine does not return a value.\n\nIn the subroutine, create local variables i and j. Then, iterate over each column of the input matrix using the outer loop (j loop) and copy the corresponding column to the output matrix. Inside the outer loop, if j is greater than 1, iterate over each previous column (i loop) and subtract the projection of the j-th column onto each previous column from the j-th column of the output matrix. After the i loop, normalize the j-th column of the output matrix by dividing it by its Euclidean norm using the sqrt and dot_product functions.\n\nEnsure that the output matrix u_out is updated correctly at each step of the Gram-Schmidt orthogonalization process.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    integer, parameter :: m = 2\n    double precision :: u_in(n,m), u_out(n,m)\n    integer :: i, j\n    \n    ! Test case 1\n    u_in = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    u_in = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    u_in = reshape([2.0, -3.0, 1.0, 4.0, 3.0, -1.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    u_in = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    u_in = reshape([3.0, -2.0, 1.0, -1.0, 2.0, -3.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"    \n    \nend program main",
            "result": [
                "1.0000000000000000     \n   0.0000000000000000     \n   0.0000000000000000     \n   1.0000000000000000     \n   0.0000000000000000     \n   0.0000000000000000",
                "0.26726124191242440     \n  0.87287156094396945     \n  0.53452248382484879     \n  0.21821789023599208     \n  0.80178372573727319     \n -0.43643578047198506",
                "0.53452248382484879     \n  0.84515425472851669     \n -0.80178372573727319     \n  0.50709255283711008     \n  0.26726124191242440     \n -0.16903085094570336",
                "0.57735026918962584     \n -0.57735026918962584     \n  0.57735026918962584     \n -0.57735026918962584     \n  0.57735026918962584     \n -0.57735026918962584",
                "0.80178372573727319     \n  0.43643578047198489     \n -0.53452248382484879     \n  0.21821789023599228     \n  0.26726124191242440     \n -0.87287156094396945"
            ]
        },
        "code": "  subroutine gram_schmidt(u_in, n, m, u_out)\n    implicit none\n    integer,          intent(in)                 :: n,m\n    double precision, dimension(n,m),intent(in)  :: u_in\n    double precision, dimension(n,m),intent(out) :: u_out    \n\n    !! local variables\n    integer :: i,j\n\n    do i = 1, m\n       u_out(:,i) = u_in(:,i)\n    end do\n\n    do j = 1, m\n       if(j .gt. 1)then\n          do i = 1, j-1\n             u_out(:,j) = u_out(:,j) - dot_product(u_out(:,j), u_out(:,i))*u_out(:,i)\n          end do\n       end if\n       u_out(:,j) = u_out(:,j)/sqrt(dot_product(u_out(:,j),u_out(:,j)))\n    end do\n\n    return\n    \n  end subroutine gram_schmidt\n"
    },
    {
        "instruction": "Write a Fortran subroutine called \"check_even\" that determines whether a given number is even or odd. The subroutine takes one input parameter, \"num\", which is an integer. It also has one output parameter, \"pass\", which is a logical value. \n\nIn the subroutine, check if the given number is divisible by 2 using modulo operation. If the result is equal to 0, set the output parameter \"pass\" to true, indicating that the number is even. Otherwise, set \"pass\" to false, indicating that the number is odd.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: number\n    logical :: is_even\n    ! Test case 1\n    number = 10\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n\n    ! Test case 2\n    number = 7\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 3\n    number = 0\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 4\n    number = -6\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 5\n    number = 15\n    call even(number, is_even)\n    print *, is_even\nend program main",
            "result": [
                "T",
                "F",
                "T",
                "T",
                "F"
            ]
        },
        "code": "subroutine even(num, pass)\n  implicit none\n  integer, intent(in)  :: num\n  logical, intent(out) :: pass\n\n  pass = modulo(num,2) == 0\n  \nend subroutine even\n"
    },
    {
        "instruction": "Write a Fortran subroutine called cubito that calculates the cube of a given number. The subroutine takes one input parameter of type real, named xx, and one output parameter also of type real, named ww.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: input, output\n    ! Test case 1\n    input = 2.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = -3.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 0.5\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 4.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = -1.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "8.00000000",
                "-27.0000000",
                "0.125000000",
                "64.0000000",
                "-1.00000000"
            ]
        },
        "code": "subroutine cubito(xx, ww)\r\nimplicit none\r\n\r\nreal, intent(in) :: xx\r\nreal, intent(out) :: ww\r\n\r\nww = xx**3\r\n\r\nend subroutine cubito\n"
    },
    {
        "instruction": "Provide a Fortran subroutine code named abq_pml2d_1d_integrationpoints. This subroutine calculates the integration points and weights for a one-dimensional integration scheme used in a two-dimensional PML (perfectly matched layer) implementation. The subroutine takes in three input parameters: n_points of type integer, representing the number of integration points to be calculated; n_nodes of type integer, representing the number of nodes in the element. It also has two output parameters: xi, an array of type double precision, which stores the integration points; w, an array of type double precision, which stores the weights corresponding to each integration point.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n_points, n_nodes\n    double precision :: xi(6), w(6)\n\n    ! Test case 1\n    n_points = 2\n    n_nodes = 4\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 2\n    n_points = 3\n    n_nodes = 2\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 3\n    n_points = 4\n    n_nodes = 3\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 4\n    n_points = 5\n    n_nodes = 1\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 5\n    n_points = 6\n    n_nodes = 5\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\nend program main",
            "result": [
                "0.57735026918962573      -0.57735026918962573        0.0000000000000000        1.5902226617571677E-316   1.5902231064162490E-316   1.5902320984110033E-316\n   1.0000000000000000        1.0000000000000000        0.0000000000000000        0.0000000000000000        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.77459666924148340        0.0000000000000000      -0.77459666924148340        1.5902226617571677E-316   1.5902231064162490E-316   1.5902320984110033E-316\n  0.55555555555555558       0.88888888888888884       0.55555555555555558        0.0000000000000000        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.86113631159405257       0.33998104358485631      -0.33998104358485631      -0.86113631159405257        1.5902231064162490E-316   1.5902320984110033E-316\n  0.34785484513745379       0.65214515486254609       0.65214515486254609       0.34785484513745379        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.90617984593866396       0.53846931010568311        0.0000000000000000      -0.53846931010568311      -0.90617984593866396        1.5902320984110033E-316\n  0.23692688505618911       0.47862867049936653       0.56888888888888889       0.47862867049936653       0.23692688505618911        2.0731468802518713E-317",
                "0.93246951420315205       0.66120938646626448       0.23861918608319690      -0.23861918608319690      -0.66120938646626448      -0.93246951420315205     \n  0.17132449237917030       0.36076157304813861       0.46791393457269098       0.46791393457269098       0.36076157304813861       0.17132449237917030"
            ]
        },
        "code": "      subroutine abq_pml2d_1d_integrationpoints(n_points,n_nodes,xi,w)\n\n\n      implicit none\n      integer, intent(in) :: n_points\n      integer, intent(in) :: n_nodes\n\n      double precision, intent(out) :: xi(*)\n      double precision, intent(out) :: w(*)\n\n      integer :: i,j,k,n\n\n      double precision x1d(4), w1d(4)\n\n\n\n      select case ( n_points )\n        case (2)\n            xi(1) = .5773502691896257d+00\n            xi(2) = -.5773502691896257d+00\n            w(1) = .1000000000000000d+01\n            w(2) = .1000000000000000d+01\n            return\n        case (3)\n            xi(1) = 0.7745966692414834d+00\n            xi(2) = .0000000000000000d+00\n            xi(3) = -.7745966692414834d+00\n            w(1) = .5555555555555556d+00\n            w(2) = .8888888888888888d+00\n            w(3) = .5555555555555556d+00\n            return\n        case (4)\n            xi(1) = .8611363115940526d+00\n            xi(2) = .3399810435848563d+00\n            xi(3) = -.3399810435848563d+00\n            xi(4) = -.8611363115940526d+00\n            w(1) = .3478548451374538d+00\n            w(2) = .6521451548625461d+00\n            w(3) = .6521451548625461d+00\n            w(4) = .3478548451374538d+00\n            return\n        case (5)\n            xi(1) = .9061798459386640d+00\n            xi(2) = .5384693101056831d+00\n            xi(3) = .0000000000000000d+00\n            xi(4) = -.5384693101056831d+00\n            xi(5) = -.9061798459386640d+00\n            w(1) = .2369268850561891d+00\n            w(2) = .4786286704993665d+00\n            w(3) = .5688888888888889d+00\n            w(4) = .4786286704993665d+00\n            w(5) = .2369268850561891d+00\n            return\n        case (6)\n            xi(1) = .9324695142031521d+00\n            xi(2) = .6612093864662645d+00\n            xi(3) = .2386191860831969d+00\n            xi(4) = -.2386191860831969d+00\n            xi(5) = -.6612093864662645d+00\n            xi(6) = -.9324695142031521d+00\n            w(1) = .1713244923791703d+00\n            w(2) = .3607615730481386d+00\n            w(3) = .4679139345726910d+00\n            w(4) = .4679139345726910d+00\n            w(5) = .3607615730481386d+00\n            w(6) = .1713244923791703d+00\n            return\n        case default\n            write(6,*)'error in routine abq_pml2d_1d_integrationpoints'\n            write(6,*) ' invalid number of integration points for 1d'\n            write(6,*) ' n_points must be between 1 and 6'\n            stop\n      end select\n\n\n      end subroutine abq_pml2d_1d_integrationpoints\n"
    },
    {
        "instruction": "Write a Fortran subroutine called lagrange_any that computes the Lagrange interpolants and their first derivatives at a given point. The subroutine requires 4 input parameters: xi of type double precision, ngll of type integer, and two arrays xigll, hprime of type double precision. The subroutine also has 3 output parameters: h and hprime, both arrays of type double precision.",
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: ngll = 4\n    real*8 :: xi, xigll(ngll), h(ngll), hprime(ngll)\n    \n    ! Test case 1\n    xi = 0.5\n    xigll = [0.0, 0.25, 0.5, 0.75]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 2\n    xi = -0.3\n    xigll = [-1.0, -0.75, -0.5, -0.25]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = 1.0\n    xigll = [0.0, 0.5, 0.75, 1.0]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = -0.8\n    xigll = [-0.75, -0.5, -0.25, 0.0]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = 0.9\n    xigll = [0.5, 0.75, 1.0, 1.25]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.0000000000000000       -0.0000000000000000        1.0000000000000000        0.0000000000000000     \n  0.66666666666666663       -4.0000000000000000        2.0000000000000000        1.3333333333333333",
                "4.8000007311502182E-002 -0.22400003623962017       0.50400009822844960       0.67199993069966846     \n -0.61333318074544718        3.0399993515014785       -8.2399991607666152        5.8133329900105837",
                "-0.0000000000000000        0.0000000000000000       -0.0000000000000000        1.0000000000000000     \n -0.33333333333333331        4.0000000000000000       -10.666666666666666        7.0000000000000000",
                "1.4080001074473087      -0.70400019359589261       0.38400011253357458       -8.8000026384990784E-002\n  -9.0133337529500359        16.240001068115248       -9.4400008773803847        2.2133335622151735",
                "-5.6000008265175594E-002  0.44800011062621981       0.67199989891051881       -6.4000001271563023E-002\n  0.34666651407875781       -4.6399999237060001        4.2400003051757267        5.3333104451515581E-002"
            ]
        },
        "code": "  subroutine lagrange_any(xi,ngll,xigll,h,hprime)\n\n! and their first derivatives at any point xi in [-1,1]\n\n  implicit none\n\n  double precision,intent(in) :: xi\n\n  integer,intent(in) :: ngll\n  double precision,dimension(ngll),intent(in) :: xigll\n  double precision,dimension(ngll),intent(out) :: h,hprime\n\n  ! local parameters\n  integer :: dgr,i,j\n  double precision :: prod1,prod2,prod3\n  double precision :: prod2_inv\n  double precision :: sum\n  double precision :: x0,x\n\n! note: this routine is hit pretty hard by the mesher, optimizing the loops here will be beneficial\n\n  do dgr = 1,ngll\n\n    prod1 = 1.0d0\n    prod2 = 1.0d0\n\n    ! lagrangian interpolants\n    x0 = xigll(dgr)\n    do i = 1,ngll\n      if (i /= dgr) then\n        x = xigll(i)\n        prod1 = prod1*(xi-x)\n        prod2 = prod2*(x0-x)\n      endif\n    enddo\n\n    ! takes inverse to avoid additional divisions\n    ! (multiplications are cheaper than divisions)\n    prod2_inv = 1.d0/prod2\n\n    h(dgr) = prod1 * prod2_inv\n\n    ! first derivatives\n    sum = 0.0d0\n    do i = 1,ngll\n      if (i /= dgr) then\n        prod3 = 1.0d0\n        do j = 1,ngll\n          if (j /= dgr .and. j /= i) prod3 = prod3*(xi-xigll(j))\n        enddo\n        sum = sum + prod3\n      endif\n    enddo\n\n    hprime(dgr) = sum * prod2_inv\n\n  enddo\n\n  end subroutine lagrange_any\n"
    }
]