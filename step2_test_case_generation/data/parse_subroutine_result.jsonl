{"id": 0, "param_info": {"param_name": ["kf", "hc", "f"], "type_in_num": 2, "type_in": ["integer", "real*8, dimension(kf,kf)"], "type_out_num": 1, "type_out": ["real*8, dimension(kf,kf)"]}, "code": "    subroutine core_guess(kf,hc,f)\n        ! ----------------------------\n        ! core hamiltonian\n        ! ----------------------------\n        !\n        ! source:\n        !   a. szabo and n. s. ostlund\n        !   modern quantum chemistry\n        !   dover\n        !   1996\n        !\n        !-----------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        ! initial guess: core hamiltonian\n        f = hc\n\n    end subroutine core_guess\n"}
{"id": 1, "param_info": {"param_name": ["kf", "s", "hc", "cst", "f"], "type_in_num": 4, "type_in": ["integer", "real*8, dimension(kf,kf)", "real*8, dimension(kf,kf)", "real*8"], "type_out_num": 1, "type_out": ["real*8, dimension(kf,kf)"]}, "code": "    subroutine huckel_guess(kf,hc,s,f,cst)\n        ! -----------------------------------------------------\n        ! extended h\u00fcckel theory\n        ! -----------------------------------------------------\n        !\n        ! source:\n        !   extended h\u00fcckel and slater\u2019s rule initial guess for\n        !       real space grid-based density functional theory\n        !   m. lee, k. leiter, c. eisner, j. crone and j. knap\n        !   computational and theoretical chemistry\n        !   2015\n        !\n        !------------------------------------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf),intent(in) :: s    ! overlap matrix\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n        real*8, intent(in) :: cst                   ! multiplicative constant in h\u00fcckel model\n\n        ! intermediate variables\n        integer :: i, j                             ! loop indices\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        f(:,:) = 0.0d0\n\n        do i = 1,kf\n            do j = 1,kf\n                f(i,j) = cst * s(i,j) * 0.5d0 * (hc(i,i) + hc(j,j))\n            end do\n        end do\n\n    end subroutine huckel_guess\n"}
{"id": 2, "param_info": {"param_name": ["n", "a(n)", "b(n)", "c(n)", "r(n)", "x(n)"], "type_in_num": 5, "type_in": ["integer", "real*8", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"}
{"id": 3, "param_info": {"param_name": ["n", "xg(n)", "xd(n)", "q(n)", "qnew(n)"], "type_in_num": 4, "type_in": ["integer", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"}
{"id": 4, "param_info": {"param_name": ["nx", "ny", "nnx", "nny", "ff(nx,ny)", "ccf(ny)", "ccc(ny)", "cf(nx,ny)"], "type_in_num": 7, "type_in": ["integer", "integer", "integer", "integer", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine inject(ff,cf,ccf,ccc,nx,ny,nnx,nny)\n\n  ! inject data from a fine grid to a coarser grid\n  ! using full area weighting for phi\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny),ccf(ny),ccc(ny)\n  real*8, intent(out) :: cf(nx,ny)\n  integer :: i, i2, j, j2, i2m, i2p, j2m, j2p\n\n\n  do j = 1, nny/2\n     j2 = j + j\n     j2m = modulo(j2-2,nny) + 1\n     j2p = modulo(j2,nny) + 1\n     do i = 1, nnx/2\n        i2 = i + i\n        i2m = modulo(i2-2,nnx) + 1\n        i2p = modulo(i2,nnx) + 1\n\n        ! basic version\n        cf(i,j) = 0.25*( &\n             (ff(i2m,j2m) + ff(i2,j2m))*ccf(j2m) &\n             + (ff(i2m,j2 ) + ff(i2,j2 ))*ccf(j2 ) &\n             )/ccc(j)\n\n     enddo\n  enddo\n\nend subroutine inject\n"}
{"id": 5, "param_info": {"param_name": ["nx", "ny", "nnx", "nny", "cf(nx,ny)", "ff(nx,ny)"], "type_in_num": 5, "type_in": ["integer", "integer", "integer", "integer", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine prolong(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! cheap version using linear fitting\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: i, i2, j, j2, im, jm, ip, i2m, jp, j2m, hnnx, hnny\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n        ff(i2m,j2m) = 0.0625*(cf(im,jm) + 3*cf(i,jm) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2m,j2 ) = 0.0625*(cf(im,jp) + 3*cf(i,jp) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2 ,j2m) = 0.0625*(cf(ip,jm) + 3*cf(i,jm) + 3*cf(ip,j) + 9*cf(i,j))\n        ff(i2 ,j2 ) = 0.0625*(cf(ip,jp) + 3*cf(i,jp) + 3*cf(ip,j) + 9*cf(i,j))\n     enddo\n  enddo\n\nend subroutine prolong\n"}
{"id": 6, "param_info": {"param_name": ["nx", "ny", "nnx", "nny", "cf(nx,ny)", "ff(nx,ny)"], "type_in_num": 5, "type_in": ["integer", "integer", "integer", "integer", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine prolong2(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! accurate version using cubic fitting\n\n  implicit none\n\n  real*8, parameter :: a = -0.1318, b = 0.8439, c = 0.4575, d = -0.1696\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: hnnx, hnny, i, im, imm, ip, ipp, j, jm, jmm, jp, jpp, &\n       i2, i2m, j2, j2m\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jmm = modulo(jm-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     jpp = modulo(jp,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        imm = modulo(im-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        ipp = modulo(ip,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n\n        ff(i2 ,j2 ) = a*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + d*(a*cf(ipp,jm) + b*cf(ipp,j) + c*cf(ipp,jp) + d*cf(ipp,jpp))\n\n        ff(i2m,j2 ) = a*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + d*(a*cf(imm,jm) + b*cf(imm,j) + c*cf(imm,jp) + d*cf(imm,jpp))\n\n        ff(i2 ,j2m) = a*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + d*(a*cf(ipp,jp) + b*cf(ipp,j) + c*cf(ipp,jm) + d*cf(ipp,jmm))\n\n        ff(i2m,j2m) = a*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + d*(a*cf(imm,jp) + b*cf(imm,j) + c*cf(imm,jm) + d*cf(imm,jmm))\n\n     enddo\n  enddo\n\n\nend subroutine prolong2\n"}
{"id": 7, "param_info": {"param_name": ["nx", "ny", "nnx", "nny", "ff(nx,ny)", "rf(nx,ny)", "a(ny)", "b(ny)", "c(ny)", "nu", "resf(nx,ny)"], "type_in_num": 10, "type_in": ["integer", "integer", "integer", "integer", "real*8", "real*8", "real*8", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}
{"id": 8, "param_info": {"param_name": ["nx", "ny", "u(nx,ny)", "v(nx,ny+1)", "up(nx,ny)", "vp(nx,ny)"], "type_in_num": 4, "type_in": ["integer", "integer", "real*8", "real*8"], "type_out_num": 2, "type_out": ["real*8", "real*8"]}, "code": "subroutine uvatphi(nx,ny,u,v,up,vp)\n\n  ! to average u and v to phi points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: up(nx,ny), vp(nx,ny)\n\n  integer :: i, ip, j, jp\n\n  ! assume polar values of v have been defined by a previous\n  ! call to polar, e.g. within cgridave\n\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        ip = i+1\n        if ( i == nx ) ip = 1\n        up(i,j) = 0.5*(u(i,j) + u(ip,j))\n        vp(i,j) = 0.5*(v(i,j) + v(i,jp))\n     enddo\n  enddo\n\nend subroutine uvatphi\n"}
{"id": 9, "param_info": {"param_name": ["lon", "lat", "x", "y", "z"], "type_in_num": 2, "type_in": ["real (8)", "real (8)"], "type_out_num": 3, "type_out": ["real (8)", "real (8)", "real (8)"]}, "code": "subroutine sph2cart (lon, lat, x, y, z )\n  !------------------------------------------------------------------------------------\n  ! sph2cart\n  !\n  !     transforms geographical coordinates (lat,lon) to cartesian coordinates.\n  !     similar to stripack's trans\n  !\n  !    input: lat, latitudes of the node in radians [-pi/2,pi/2]\n  !           lon, longitudes of the nodes in radians [-pi,pi]\n  !\n  !    output:  x, y, z, the coordinates in the range -1 to 1.\n  !                    x**2 + y**2 + z**2 = 1\n  !\n  !   p. peixoto 2015\n  !---------------------------------------------------------------------\n  real (8), intent(in) :: lon\n  real (8), intent(in) :: lat\n  real (8), intent(out) :: x\n  real (8), intent(out) :: y\n  real (8), intent(out) :: z\n  real (8):: coslat\n\n  coslat = dcos (lat)\n  x = coslat * dcos (lon)\n  y = coslat * dsin (lon)\n  z = dsin (lat)\n\n  return\nend subroutine sph2cart\n"}
{"id": 10, "param_info": {"param_name": ["nd1", "nd2", "ne1", "ne2", "ibrd", "ibre", "is(4)", "kaps(4)", "ks(4)"], "type_in_num": 3, "type_in": ["integer", "integer", "integer"], "type_out_num": 6, "type_out": ["integer", "integer", "integer", "integer", "integer", "integer"]}, "code": "      subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n"}
{"id": 11, "param_info": {"param_name": ["n", "r0", "r1", "positions(n,3)", "bn"], "type_in_num": 4, "type_in": ["integer*4", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["integer*4"]}, "code": "subroutine bondseek(n,positions,r0,r1,bn)\n\n    implicit none\n\n    integer*4, intent(in)       :: n\n    real*8,    intent(in)       :: r0,r1\n    real*8,    intent(in)       :: positions(n,3)\n\n    integer*4 :: i,j,k\n    integer*4, intent(out) :: bn\n\n    real*8 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n\n    bn = 0\n\n    do i = 1, (n - 1)\n        xi = positions(i,1)\n        yi = positions(i,2)\n        zi = positions(i,3)\n        do j = 1, n\n            if (i .ge. j) cycle\n            xj = positions(j,1)\n            yj = positions(j,2)\n            zj = positions(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = sqrt(dx * dx + dy * dy + dz * dz)\n\n            if (mdl .ge. r0 .and. mdl .le. r1) bn = bn + 1\n\n        end do\n    end do\n    return\nend subroutine bondseek\n"}
{"id": 12, "param_info": {"param_name": ["ncomp", "nbeads", "nsitemax", "xika0", "xi", "nui", "nk", "delta", "rho", "obj_func", "xika"], "type_in_num": 9, "type_in": ["integer", "integer", "integer", "real(8), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1)", "real(8), dimension(0:ncomp-1)", "real(8), dimension(0:ncomp-1,0:nbeads-1)", "real(8), dimension(0:nbeads-1,0:nsitemax-1)", "real(8), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1)", "real(8)"], "type_out_num": 2, "type_out": ["real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)", "real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)"]}, "code": "subroutine calc_xika(xika0,xi,rho,nui,nk,delta,obj_func,xika,ncomp,nbeads,nsitemax)\n    implicit none\n    integer,intent(in) :: ncomp, nbeads, nsitemax\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika0\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    real(8), intent(in) :: rho\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: obj_func\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: xika\n    integer :: i,k,a,j,l,b\n    \n    !initialize xika to 1.0\n    xika=1.0\n    \n    do i=0, ncomp-1\n        do k=0, nbeads-1\n            do a=0, nsitemax-1\n                do j=0, ncomp-1\n                    do l=0, nbeads-1\n                        do b=0, nsitemax-1\n                            xika(i,k,a)=xika(i,k,a) + (rho * xi(j) * nui(j,l) * nk(l,b) * xika0(j,l,b) * delta(i,j,k,l,a,b))\n                        enddo\n                    enddo\n                enddo\n            enddo\n        enddo\n    enddo\n    xika = (1.0/xika)\n    \n    obj_func = xika - xika0\n    \nend subroutine\n"}
{"id": 13, "param_info": {"param_name": ["xi", "yi", "xo", "yo", "old", "ns", "new"], "type_in_num": 6, "type_in": ["integer", "integer", "integer", "integer", "real, dimension(xi,yi)", "integer"], "type_out_num": 1, "type_out": ["real, dimension(xo,yo)"]}, "code": "  subroutine bilin(old,xi,yi,ns,new,xo,yo)\n\n! assume: xo = (xi-1)*ns + 1, xi=50, xo=49*3+1=148\n!         yo = (yi-1)*ns + 1\n\n    implicit none\n\n    integer,                 intent(in) :: xi,yi,xo,yo\n    real, dimension(xi,yi),  intent(in) :: old\n    integer,                 intent(in) :: ns\n    real, dimension(xo,yo),  intent(out):: new\n\n    real  :: im(1:ns+1,2)\n!    real  :: imm(1:ns+3,2)\n    integer:: i,j,jm1,im1,ix1,ix2,iy1,iy2\n\n    forall(i=1:ns+1) im(i,2) = real(i-1)/ns\n      im(:,1) = 1 - im(:,2)\n\n    do j=2,yi\n      jm1 = j - 1\n      iy2 = jm1 * ns + 1\n      iy1 = iy2 - ns\n      do i=2,xi\n        im1 = i - 1\n        ix2 = im1 * ns + 1\n        ix1 = ix2 - ns\n        new(ix1:ix2,iy1:iy2) = matmul(im,matmul(old(im1:i,jm1:j),transpose(im)))\n      end do\n    end do\n\n\n   !   ns = ns + 2\n   ! forall(i=1:ns+1) imm(i,2) = real(i-1)/ns\n   !   imm(:,1) = 1 - imm(:,2)\n!\n!      j=yi\n!      jm1 = j - 1\n!      iy2 = jm1 * ns + 1\n!      iy1 = iy2 - ns\n!\n!      i=xi\n!        im1 = i - 1\n!        ix2 = im1 * ns + 1\n!        ix1 = ix2 - ns\n!        new(ix1:ix2,iy1:iy2) = matmul(imm,matmul(old(im1:i,jm1:j),transpose(imm)))\n!      end do\n!    end do\n\n  end subroutine bilin\n"}
{"id": 14, "param_info": {"param_name": ["ff", "ia", "ja", "ka", "imt", "jmt", "km", "do3d", "rr", "uflux", "vflux", "wflux"], "type_in_num": 11, "type_in": ["integer", "integer", "integer", "integer", "integer", "integer", "integer", "integer", "real(kind=8)", "real(kind=8),     dimension(imt-1,jmt,km,2)", "real(kind=8),     dimension(imt,jmt-1,km,2)"], "type_out_num": 1, "type_out": ["real(kind=8),    dimension(0:km,2)"]}, "code": "subroutine vertvel(rr,ia,ja,ka,imt,jmt,km,ff,uflux,vflux,do3d,wflux)\n!====================================================================\n! calculate the vertical flux based on the uflux and vflux\n!\n!  input:\n!    rr             : time interpolation constant between 0 and 1. controls how much\n!                   : of earlier time step is used in interpolation.\n!    ia,ja,ka       : original position in integers\n!    imt,jmt,km     : grid index sizing constants in (x,y,z), are for \n!                     horizontal and vertical rho grid [scalar]\n!    ff             : time direction. ff=1 forward, ff=-1 backward\n!    uflux          : u velocity (zonal) flux field, two time steps [ixjxkxt]\n!    vflux          : v velocity (meridional) flux field, two time steps [ixjxkxt]\n!    do3d           : flag to set whether to use 3d velocities or not\n!\n!  output:\n!    wflux          : w velocity (vertical) flux field, two time steps [kxt]\n!\n!  other parameters used in function:\n!    rg             : rg=1-rr for time interpolation between time steps. controls how much\n!                   : of later time step is used in interpolation.\n!    uu             : time-interpolated flux at ia/ja/ka (depending on ijk)\n!    um             : time-interpolated flux at ia-1/ja-1/ka-1 (depending on ijk)\n!    nsm=1,nsp=2    : time index. nsm picks out the earlier bounding time step and \n!                     nsp picks out the later bounding time step for interpolation.\n!    iam            : generic index for grid index -1 for whichever direction, ijk. \n!                     is only used in the i direction for whatever reason.\n!    k              : index for looping through depth layers\n!    n              : index for looping through times (1 and 2)\n!\n!  notes:\n!    computes the vertical velocity by integrating the continuity eq. from the bottom \n!    for the nsm and nsp velocity time steps.\n!    this is set up to use neither the -full_wflux nor -explicit_w flags currently, \n!    just the default w flux option.\n!====================================================================\n  \nimplicit none\n  \ninteger,        intent(in)                                      :: ff,ia,ja,ka,imt,jmt,km\ninteger,        intent(in)                                      :: do3d\nreal(kind=8),   intent(in)                                      :: rr\nreal(kind=8),   intent(in),     dimension(imt-1,jmt,km,2)       :: uflux\nreal(kind=8),   intent(in),     dimension(imt,jmt-1,km,2)       :: vflux\nreal(kind=8),   intent(out),    dimension(0:km,2)               :: wflux\nreal(kind=8)                                                    :: rg\n! real(kind=8)                                                    :: uu,um,rg\ninteger                                                         :: nsm=1,nsp=2,k,n,iam\n   \n\nrg=1.d0-rr\nwflux=0.d0\niam=ia-1 \n\n! print *,'in vertvel'\n! print '(a,i3,a,i3,a,i3)','ia=',ia,&\n!     ' ja=',ja,' ka=',ka\n! print *,'imt=',imt,' jmt=',jmt,' km=',km\n! print *,'size(uflux)=',size(uflux,1),' size(vflux)=',size(vflux,1)\n\n\nif(do3d==0) then\n    return\n  \n! start 3d code\nelse\n    kloop: do k=1,ka\n  ! these only need to be defined if we use full_wflux, which we aren't doing right now\n!      uu=rg*uflux(ia ,ja  ,k,nsp)+rr*uflux(ia ,ja  ,k,nsm)\n!      um=rg*uflux(iam,ja  ,k,nsp)+rr*uflux(iam,ja  ,k,nsm)\n!      vv=rg*vflux(ia ,ja  ,k,nsp)+rr*vflux(ia ,ja  ,k,nsm)\n!      vm=rg*vflux(ia ,ja-1,k,nsp)+rr*vflux(ia ,ja-1,k,nsm)\n\n! ! start ifs code\n! #if defined ifs\n!     do n=nsm,nsp\n!      wflux(k,n) = wflux(k-1,n) - ff * &\n!      ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n)  &\n!      + (dzt(ia,ja,k,nsp)-dzt(ia,ja,k,nsm))*dxdy(ia,ja)/tseas )  ! time change of the mass the in grid box\n!     enddo\n! #endif\n! ! end ifs code\n\n! start ocean code\n! #ifdef  full_wflux\n!      wflux(ia,ja,k,nsm)=wflux(ia,ja,k-1,nsm) - ff * ( uu - um + vv - vm )\n! #else\n        do n=nsm,nsp\n            wflux(k,n) = wflux(k-1,n) - ff * &\n                        ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + &\n                        vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n) )\n        enddo\n! #endif\n!end ocean code\n    end do kloop\n\nendif\n! end 3d code\n  \n!#endif\n  return\nend subroutine vertvel\n"}
{"id": 15, "param_info": {"param_name": ["data(:)", "threshold", "series(:)"], "type_in_num": 2, "type_in": ["real", "integer"], "type_out_num": 1, "type_out": ["real, allocatable"]}, "code": "    subroutine lttb_downsize(data, threshold, series)\n        implicit none\n\n        real, intent(in) :: data(:)\n        integer, intent(in) :: threshold\n        real, intent(out), allocatable :: series(:)\n\n        ! internal variables\n        integer i, sampledindex, a, nexta, datalength\n        real maxareapoint, maxarea, area, every\n\n        datalength = size(data)\n\n        ! just copy the data 'as-is'\n        if (datalength .le. threshold) then\n            print *, 'no downsizing needed, copying time-series'\n\n            allocate (series(datalength))\n            series(:) = data(:)\n\n            return\n        end if\n\n        print *, 'downsizing time-series with largest-triangle-three-buckets'\n\n        allocate (series(threshold))\n\n        ! always add the first point\n        series(1) = data(1)\n        sampledindex = 1\n        a = 0\n        nexta = 0\n        maxareapoint = 0.0\n\n        ! bucket size. leave room for start and end data points\n        every = real(datalength - 2)/real(threshold - 2)\n\n        do i = 0, threshold - 2 - 1\n            block\n                integer avgrangestart, avgrangeend, avgrangelength\n                real avgx, avgy, pointax, pointay\n                integer rangeoffs, rangeto\n\n                avgrangestart = floor((i + 1)*every) + 1\n                avgrangeend = floor((i + 2)*every) + 1\n                avgrangeend = min(avgrangeend, datalength)\n                avgrangelength = avgrangeend - avgrangestart\n\n                avgx = 0.0\n                avgy = 0.0\n\n                do while (avgrangestart < avgrangeend)\n                    avgx = avgx + avgrangestart\n                    avgy = avgy + data(1 + avgrangestart)\n                    avgrangestart = avgrangestart + 1\n                end do\n\n                avgx = avgx/avgrangelength\n                avgy = avgy/avgrangelength\n\n                ! get the range for this bucket\n                rangeoffs = floor((i + 0)*every) + 1\n                rangeto = floor((i + 1)*every) + 1\n\n                ! point a\n                pointax = a\n                pointay = data(1 + a)\n\n                maxarea = -1\n\n                do while (rangeoffs < rangeto)\n                    ! calculate triangle area over three buckets\n                    area = abs((pointax - avgx)*(data(1 + rangeoffs) - pointay) -&\n                    &(pointax - rangeoffs)*(avgy - pointay))*0.5\n\n                    if (area .gt. maxarea) then\n                        maxarea = area\n                        maxareapoint = data(1 + rangeoffs)\n                        nexta = rangeoffs ! next a is this b\n                    end if\n\n                    rangeoffs = rangeoffs + 1\n                end do\n\n                series(1 + sampledindex) = maxareapoint ! pick this point from the bucket\n                sampledindex = sampledindex + 1\n                a = nexta ! this a is the next a (chosen b)\n            end block\n        end do\n\n        ! always add the last element\n        series(1 + sampledindex) = data(datalength)\n        sampledindex = sampledindex + 1\n\n    end subroutine lttb_downsize\n"}
{"id": 16, "param_info": {"param_name": ["medium", "n1", "rho( * )", "cp( * )", "cs( * )"], "type_in_num": 2, "type_in": ["integer", "integer"], "type_out_num": 3, "type_out": ["real     (kind=8)", "complex  (kind=8)", "complex  (kind=8)"]}, "code": "subroutine analyt( cp, cs, rho, medium, n1 )\r\n\r\n  !     munk profile\r\n\r\n  !     returns\r\n  !        cs, cp, rho at depths i*h i = 1, n\r\n  !        depths of interfaces\r\n\r\n  implicit none\r\n  integer,           intent(in)  :: medium, n1\r\n  real     (kind=8), intent(out) :: rho( * )\r\n  complex  (kind=8), intent(out) :: cp( * ), cs( * )\r\n  integer                        :: i, n\r\n  real     (kind=8), parameter   :: eps = 0.00737\r\n  real     (kind=8)              :: h, x, z\r\n\r\n  n = n1 - 1\r\n\r\n  select case ( medium )\r\n\r\n  case ( 1 )   ! the ocean\r\n     h = 5000.0 / n\r\n     do i = 1, n1\r\n        z = ( i - 1 ) * h\r\n        x = 2.0 * ( z - 1300.0 ) / 1300.0\r\n        cp(  i ) = 1500.0 * ( 1.0 + eps * ( x - 1.0 + exp( -x ) ) )\r\n        cs(  i ) = 0.0\r\n        rho( i ) = 1.0\r\n     end do\r\n     return\r\n\r\n  case ( 2 )   ! the fluid half-space\r\n     cp(  1 ) = 1551.91\r\n     cs(  1 ) = 0.0\r\n     rho( 1 ) = 1.0e20\r\n     return\r\n\r\n  case( 9 )  ! an elastic layer\r\n     h = 1000.0 / n\r\n     z = 5000.0\r\n\r\n     do i = 1,n+1\r\n        cp( i ) = 4700.0 + ( z - 5000.0 ) / 10.0\r\n        cs( i ) = 2000.0 + ( z - 5000.0 ) / 10.0\r\n        cp( i ) = 4700.0\r\n        cs( i ) = 2000.0\r\n        rho( i ) = 2.0\r\n        z = z + h\r\n     end do\r\n  end select\r\n\r\nend subroutine analyt\r\n"}
{"id": 17, "param_info": {"param_name": ["n", "inarray(1:n)", "outarray(1:n)"], "type_in_num": 2, "type_in": ["integer", "integer"], "type_out_num": 1, "type_out": ["integer"]}, "code": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"}
