{"id": 0, "param_info": {"type_in_num": 1, "type_in": ["double precision"], "type_out_num": 1, "type_out": ["logical"]}, "code": "    elemental function effectively_zero(a)\n        double precision, intent(in) :: a\n        logical :: effectively_zero\n\n        effectively_zero = abs(a) < machine_epsilon\n    end function\n"}
{"id": 1, "param_info": {"type_in_num": 3, "type_in": ["double precision", "double precision", "double precision"], "type_out_num": 1, "type_out": ["logical"]}, "code": "    pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n"}
{"id": 2, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "code": "  pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n"}
{"id": 3, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "code": "  pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n"}
{"id": 4, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["complex*16, dimension(n,n)"]}, "code": "function random_hermitian(n)\n! generates an order n hermitian matrix with random entries x+iy\n! where each x and y are uniformly distributed between -1 and 1\nimplicit none\ninteger :: n, ii, jj\ncomplex*16, dimension(n,n) :: random_hermitian\nreal*8, dimension(n,n) :: a, b\n\n    call random_number(a)\n    ! rescaling into an element in (-1,1)\n    a = 2*a - 1\n    call random_number(b)\n    ! rescaling into an element in (-1,1)\n    b = 2*b - 1\n\n    ! populating the matrix\n    do ii = 1,n\n        do jj = 1,n\n            ! replacing entries in the lower triangle\n            if ((jj.gt.ii).and.(ii.lt.n)) then\n                a(jj,ii) = a(ii,jj)\n                ! the imaginary part is negative, to achieve hermicity\n                b(jj,ii) = -b(ii,jj)\n            end if\n            ! cast into a complex entry\n            random_hermitian(ii,jj) = complex(a(ii,jj),b(ii,jj))\n        end do\n    end do\n\nend function random_hermitian\n"}
{"id": 5, "param_info": {"type_in_num": 2, "type_in": ["character(len=*)", "character(len=*)"], "type_out_num": 1, "type_out": ["integer"]}, "code": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}
{"id": 6, "param_info": {"type_in_num": 1, "type_in": ["character ( len = * )"], "type_out_num": 1, "type_out": ["integer, dimension(3)"]}, "code": "            function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n"}
{"id": 7, "param_info": {"type_in_num": 2, "type_in": ["real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}
{"id": 8, "param_info": {"type_in_num": 1, "type_in": ["integer,optional"], "type_out_num": 1, "type_out": ["integer"]}, "code": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}
{"id": 9, "param_info": {"type_in_num": 2, "type_in": ["integer, optional", "integer"], "type_out_num": 1, "type_out": ["integer"]}, "code": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 10, "param_info": {"type_in_num": 2, "type_in": ["double precision, optional", "double precision"], "type_out_num": 1, "type_out": ["double precision"]}, "code": "    elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 11, "param_info": {"type_in_num": 2, "type_in": ["logical, optional", "logical"], "type_out_num": 1, "type_out": ["logical"]}, "code": "    elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 12, "param_info": {"type_in_num": 2, "type_in": ["complex, optional", "complex"], "type_out_num": 1, "type_out": ["complex"]}, "code": "    elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 13, "param_info": {"type_in_num": 2, "type_in": ["character, optional", "character"], "type_out_num": 1, "type_out": ["character"]}, "code": "    elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 14, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "code": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}
{"id": 15, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "code": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}
{"id": 16, "param_info": {"type_in_num": 1, "type_in": ["character (*)"], "type_out_num": 1, "type_out": ["integer"]}, "code": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}
{"id": 17, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["character(len=maxtextlength)"]}, "code": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}
{"id": 18, "param_info": {"type_in_num": 2, "type_in": ["character(len=*)", "character(len=*)"], "type_out_num": 1, "type_out": ["integer"]}, "code": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}
{"id": 19, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["character(12)"]}, "code": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}
{"id": 20, "param_info": {"type_in_num": 1, "type_in": ["character(*)"], "type_out_num": 1, "type_out": ["character(len(str))"]}, "code": "  function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n"}
{"id": 21, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "code": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}
{"id": 22, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "code": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}
