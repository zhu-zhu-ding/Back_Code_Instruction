{"id": 0, "param_info": {"type_in_num": 1, "type_in": ["double precision"], "type_out_num": 1, "type_out": ["logical"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function effectively_zero(a)\n        double precision, intent(in) :: a\n        logical :: effectively_zero\n\n        effectively_zero = abs(a) < machine_epsilon\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    logical :: zero\n    real(kind=8) :: a = 1.0e-16\n    zero = effectively_zero(a)\n    print *, zero\nend program main\n", "result": [" T"]}], "code": "    elemental function effectively_zero(a)\n        double precision, intent(in) :: a\n        logical :: effectively_zero\n\n        effectively_zero = abs(a) < machine_epsilon\n    end function\n"}
{"id": 1, "param_info": {"type_in_num": 3, "type_in": ["double precision", "double precision", "double precision"], "type_out_num": 1, "type_out": ["logical"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  logical :: result\n  real(kind=8) :: a = 1.23456789\n  real(kind=8) :: b = 1.23456789\n  real(kind=8) :: tolerance = 1e-6\n\n  result = equal_within_absolute(a, b, tolerance)\n  print *, result\nend program main\n", "result": [" T"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  logical :: result\n  double precision :: a = 10.0\n  double precision :: b = 10.1\n  double precision :: tolerance = 0.1\n\n  result = equal_within_absolute(a, b, tolerance)\n  print *, result\nend program main\n", "result": [" F"]}], "code": "    pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n"}
{"id": 2, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x, result\n  x = 1.0\n  result = f1(x)\n  print *, result\nend program main\n", "result": ["  0.250000000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x = 1.5\n  real :: result\n\n  result = f1(x)\n  print *, result\nend program main\n", "result": ["   2.12500000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x = 2.5\n  real :: result\n\n  result = f1(x)\n  print *, result\nend program main\n", "result": ["   13.3750000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x\n  real :: result\n\n  x = 1.0\n  result = f1(x)\n  print *, result\n\n  x = -2.0\n  result = f1(x)\n  print *, result\n\n  x = 0.5\n  result = f1(x)\n  print *, result\n\nend program main\n", "result": ["  0.250000000    ", "  -5.75000000    ", " -0.125000000    "]}], "code": "  pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n"}
{"id": 3, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x = 2.0\n  real :: result\n\n  result = df1(x)\n  print *, result\nend program main\n", "result": ["   11.0000000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: x, df1_result\n\n  x = 1.5\n  df1_result = df1(x)\n  print *, df1_result\nend program main\n", "result": ["   5.75000000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      real :: x = 2.5\n      real :: df1_result\n\n      df1_result = df1(x)\n      print *, df1_result\n    end program main\n", "result": ["   17.7500000    "]}], "code": "  pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n"}
{"id": 4, "param_info": {"type_in_num": 2, "type_in": ["character(len=*)", "character(len=*)"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n\n                        end module test_function\n                            program main\n      use test_function\n      implicit none\n      character(len=20) :: s1 = \"abcabcabc\"\n      character(len=3) :: s2 = \"abc\"\n      integer :: c\n\n      c = count_sub_string(s1, s2)\n      print *, c\n    end program main", "result": ["           2"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=100) :: s1 = \"hello world hello world hello world\"\n  character(len=10) :: s2 = \"hello\"\n  integer :: c\n  c = count_sub_string(s1, s2)\n  print *, c\nend program main\n", "result": ["           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=100) :: s1\n  character(len=20) :: s2\n  integer :: count\n\n  ! Test case 1\n  s1 = \"The quick brown fox jumps over the lazy dog\"\n  s2 = \"o\"\n  count = count_sub_string(s1, s2)\n  print *, count\n\n  ! Test case 2\n  s1 = \"Hello, how are you? How's the weather today?\"\n  s2 = \"How\"\n  count = count_sub_string(s1, s2)\n  print *, count\n\nend program main\n", "result": ["           0", "           0"]}], "code": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}
{"id": 5, "param_info": {"type_in_num": 1, "type_in": ["character ( len = * )"], "type_out_num": 1, "type_out": ["integer, dimension(3)"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                                    function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      integer, dimension(3) :: x\n      character(len=100) :: inputline = \"1 2 3\"\n      x = getintarray(inputline)\n      print *, x\n    end program main", "result": ["           0           0           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                                    function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  \n  character(len=100) :: inputline\n  integer, dimension(3) :: x\n  \n  inputline = '1 2 3'\n  x = getintarray(inputline)\n  \n  print *, x(1), x(2), x(3)\n  \nend program main\n", "result": ["           0     4280964           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                                    function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer, dimension(3) :: x\n  character(len=100) :: inputline\n  \n  inputline = \"1 2 3\"\n  x = getintarray(inputline)\n  print *, x\n\nend program main\n", "result": ["           0     4280980           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                                    function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    character(len=100) :: inputline\n    integer, dimension(3) :: result\n\n    ! Test case\n    inputline = \"1 2 3\"\n    result = getintarray(inputline)\n    print *, result\n\n    inputline = \"-10 0 100\"\n    result = getintarray(inputline)\n    print *, result\n\n    inputline = \"1000 -500 200\"\n    result = getintarray(inputline)\n    print *, result\n\nend program main\n", "result": ["           0     7669856           0", "           0     7669856           0", "           0     7669856           0"]}], "code": "            function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n"}
{"id": 6, "param_info": {"type_in_num": 2, "type_in": ["real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      real*8 :: dx = 3.5\n      real*8 :: domain = 2.0\n      real*8 :: result\n      result = near(dx, domain)\n      print *, result\n    end program main\n        ", "result": ["   1.5000000000000000     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real*8 :: dx, domain, near_value\n\n  ! Test case 1: dx > domain/2\n  dx = 3.0\n  domain = 2.0\n  near_value = near(dx, domain)\n  print *, near_value\n\n  ! Test case 2: dx = domain/2\n  dx = 1.0\n  domain = 2.0\n  near_value = near(dx, domain)\n  print *, near_value\n\n  ! Test case 3: dx < -domain/2\n  dx = -3.0\n  domain = 2.0\n  near_value = near(dx, domain)\n  print *, near_value\n\n  ! Test case 4: dx = -domain/2\n  dx = -1.0\n  domain = 2.0\n  near_value = near(dx, domain)\n  print *, near_value\n\n  ! Test case 5: -domain/2 < dx < domain/2\n  dx = 0.5\n  domain = 2.0\n  near_value = near(dx, domain)\n  print *, near_value\n\nend program main\n", "result": ["   1.0000000000000000     ", "  -1.0000000000000000     ", "  -1.0000000000000000     ", "   1.0000000000000000     ", "  0.50000000000000000     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real*8 :: dx, domain, near_dist\n\n  dx = 3.2\n  domain = 5.0\n\n  near_dist = near(dx, domain)\n  print *, near_dist\n  \nend program main\n", "result": ["  -1.7999999523162842     "]}], "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}
{"id": 7, "param_info": {"type_in_num": 1, "type_in": ["integer,optional"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                           function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: bath_size\n  \n  ! Test case\n  bath_size = vca_get_bath_dimension()\n  \n  ! Output\n  print *, bath_size\nend program main\n", "result": ["           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                           function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: bath_size\n\n  ! Test case 1: No optional argument\n  bath_size = vca_get_bath_dimension()\n  print *, bath_size\n\n  ! Test case 2: With optional argument\n  bath_size = vca_get_bath_dimension(ispin_=2)\n  print *, bath_size\n\nend program main\n", "result": ["           0", "           0"]}], "code": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}
{"id": 8, "param_info": {"type_in_num": 2, "type_in": ["integer, optional", "integer"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      integer :: i = 3\n      integer :: default = 5\n      integer :: ret\n\n      ret = get_default_ii(i, default)\n      print *, ret\n    end program main\n        ", "result": ["           3"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    \n    implicit none\n    \n    integer :: i, default, result\n    \n    i = 10\n    default = 5\n    \n    result = get_default_ii(i, default)\n    print *, result\n    \n    i = -1\n    default = 100\n    \n    result = get_default_ii(i, default)\n    print *, result\n    \n    result = get_default_ii(default=default)\n    print *, result\n    \nend program main\n", "result": ["          10", "          -1", "         100"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: ret\n\n  ! Test case 1: i is present\n  ret = get_default_ii(i=10, default=5)\n  print *, ret\n\n  ! Test case 2: i is not present\n  ret = get_default_ii(default=5)\n  print *, ret\n\nend program main\n", "result": ["          10", "           5"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: ret\n  integer :: i = 5\n  integer :: default = 10\n  ret = get_default_ii(i, default)\n  print *, ret\nend program main\n", "result": ["           5"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    \n    integer :: i = 10\n    integer :: default = 5\n    integer :: ret\n    \n    ret = get_default_ii(i, default)\n    print *, ret\n    \n    i = 0\n    ret = get_default_ii(i, default)\n    print *, ret\n    \n    ret = get_default_ii(default=default)\n    print *, ret\nend program main\n", "result": ["          10", "           0", "           5"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: i, default_val, result\n\n  ! Test case 1: i is specified\n  i = 10\n  default_val = 5\n  result = get_default_ii(i, default_val)\n  print *, result  ! Expected output: 10\n\n  ! Test case 2: i is not specified\n  default_val = 5\n  result = get_default_ii(default=default_val)\n  print *, result  ! Expected output: 5\n\n  ! Test case 3: i is specified as zero\n  i = 0\n  default_val = 5\n  result = get_default_ii(i, default_val)\n  print *, result  ! Expected output: 0\n\nend program main\n", "result": ["          10", "           5", "           0"]}], "code": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 9, "param_info": {"type_in_num": 2, "type_in": ["double precision, optional", "double precision"], "type_out_num": 1, "type_out": ["double precision"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  double precision :: d, default, ret\n\n  d = 2.5\n  default = 1.0\n\n  ret = get_default_dd(d, default)\n  print *, ret\nend program main\n", "result": ["   2.5000000000000000     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    \n    double precision :: d, default_val, ret\n    \n    d = 10.0\n    default_val = 5.0\n    \n    ret = get_default_dd(d, default_val)\n    \n    print *, ret\nend program main\n", "result": ["   10.000000000000000     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    double precision :: d = 1.234\n    double precision :: default = 0.0\n    double precision :: ret\n\n    ret = get_default_dd(d, default)\n    print *, ret\nend program main\n", "result": ["   1.2339999675750732     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  double precision :: d, default_d, ret\n\n  ! Test case 1: d is present\n  d = 3.14\n  default_d = 1.2345\n  ret = get_default_dd(d, default_d)\n  print *, ret\n\n  ! Test case 2: d is not present\n  default_d = 5.6789\n  ret = get_default_dd(default=default_d)\n  print *, ret\nend program main\n", "result": ["   3.1400001049041748     ", "   5.6788997650146484     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      double precision :: d = 3.14\n      double precision :: default = 0.0\n      double precision :: ret\n      \n      ret = get_default_dd(d, default)\n      print *, ret\n      \n    end program main\n", "result": ["   3.1400001049041748     "]}], "code": "    elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 10, "param_info": {"type_in_num": 2, "type_in": ["logical, optional", "logical"], "type_out_num": 1, "type_out": ["logical"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      logical :: logic_input\n      logical :: default = .true.\n      logical :: ret\n\n      logic_input = get_default_ll(.false., default)\n      ret = get_default_ll(logic_input, default)\n      print *, ret\n    end program main\n        ", "result": [" F"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      logical :: logic\n      logical :: default = .true.\n      logical :: ret\n\n      ! Test case 1: Logic is present\n      logic = .false.\n      ret = get_default_ll(logic, default)\n      print *, ret\n\n      ! Test case 2: Logic is not present\n      ret = get_default_ll(default=default)\n      print *, ret\n    end program main\n", "result": [" F", " T"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  logical :: logic1, logic2, logic3\n  logical :: default = .FALSE.\n  logical :: ret1, ret2, ret3\n  \n  logic1 = .TRUE.\n  logic2 = .FALSE.\n  logic3 = .TRUE.\n  \n  ret1 = get_default_ll(logic1, default)\n  ret2 = get_default_ll(logic2, default)\n  ret3 = get_default_ll(logic3, default)\n  \n  print *, ret1\n  print *, ret2\n  print *, ret3\nend program main\n", "result": [" T", " F", " T"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  logical :: logic1 = .true.\n  logical :: logic2 = .false.\n  logical :: default = .true.\n  logical :: ret\n  \n  ret = get_default_ll(logic1, default)\n  print *, ret\n  \n  ret = get_default_ll(logic2, default)\n  print *, ret\nend program main\n", "result": [" T", " F"]}], "code": "    elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 11, "param_info": {"type_in_num": 2, "type_in": ["complex, optional", "complex"], "type_out_num": 1, "type_out": ["complex"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  complex :: comp(3), default(3)\n  complex :: ret(3)\n\n  comp = [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0)]\n  default = [(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)]\n\n  ret = get_default_xx(comp, default)\n  print *, ret\nend program main\n", "result": ["             (1.00000000,2.00000000)             (2.00000000,3.00000000)             (3.00000000,4.00000000)"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    complex :: ret\n\n    ret = get_default_xx((3.0, 4.0), (1.0, 1.0))\n    print *, ret\nend program main\n", "result": ["             (3.00000000,4.00000000)"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  complex :: comp, default, ret\n\n  comp = (1.0, 2.0)\n  default = (3.0, 4.0)\n\n  ret = get_default_xx(comp, default)\n  print *, ret\n\n  comp = cmplx(0.0, 0.0)\n  default = (5.0, 6.0)\n\n  ret = get_default_xx(comp, default)\n  print *, ret\n\nend program main\n", "result": ["             (1.00000000,2.00000000)", "             (0.00000000,0.00000000)"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  complex :: comp1 = (1.0, 2.0)\n  complex :: comp2 = (3.0, 4.0)\n  complex :: default = (5.0, 6.0)\n  complex :: ret\n\n  ! Test case 1: comp is present\n  ret = get_default_xx(comp1, default)\n  print *, ret\n\n  ! Test case 2: comp is not present\n  ret = get_default_xx(default=default)\n  print *, ret\n\n  ! Test case 3: comp is present and equal to default\n  ret = get_default_xx(comp2, default)\n  print *, ret\n\nend program main\n", "result": ["             (1.00000000,2.00000000)", "             (5.00000000,6.00000000)", "             (3.00000000,4.00000000)"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      complex :: comp = (1.5, 2.5)\n      complex :: default = (0.0, 0.0)\n      complex :: ret\n      ret = get_default_xx(comp, default)\n      print *, ret\n    end program main\n        ", "result": ["             (1.50000000,2.50000000)"]}], "code": "    elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 12, "param_info": {"type_in_num": 2, "type_in": ["character, optional", "character"], "type_out_num": 1, "type_out": ["character"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character :: ret\n  \n  ! Test case 1: c is provided\n  ret = get_default_cc('A', 'B')\n  print *, ret\n  \n  ! Test case 2: c is not provided\n  ret = get_default_cc(default='B')\n  print *, ret\nend program main\n", "result": [" A", " B"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character :: c = 'A'\n  character :: default = 'B'\n  character :: ret\n\n  ret = get_default_cc(c, default)\n  print *, ret\n\nend program main\n", "result": [" A"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      character :: c\n      character :: default = 'A'\n      character :: ret\n      c = 'B'\n      ret = get_default_cc(c, default)\n      print *, ret\n    end program main\n", "result": [" B"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character :: c1, c2\n  character :: default = 'A'\n\n  c1 = get_default_cc('B', default)\n  c2 = get_default_cc('', default)\n\n  print *, c1\n  print *, c2\nend program main\n", "result": [" B", " f"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character :: c = \"D\"\n  character :: default = \"A\"\n  character :: ret\n  ret = get_default_cc(c, default)\n  print *, ret\nend program main\n", "result": [" D"]}, {"unit_test": "\n                        module test_function\n                        contains\n                            elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character :: c, default\n  character :: ret\n\n  c = 'A'\n  default = 'B'\n  ret = get_default_cc(c, default)\n  print *, ret\n\n  c = ''\n  default = 'B'\n  ret = get_default_cc(c, default)\n  print *, ret\n\n  c = 'C'\n  default = 'B'\n  ret = get_default_cc(c, default)\n  print *, ret\nend program main\n", "result": [" A", "  ", " C"]}], "code": "    elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 13, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: p = 5\n  integer :: r\n  \n  r = foo(p)\n  print *, r\nend program main\n", "result": ["          15"]}], "code": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}
{"id": 14, "param_info": {"type_in_num": 1, "type_in": ["real"], "type_out_num": 1, "type_out": ["real"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: p = 5.5\n  real :: r\n\n  r = goo(p)\n  print *, r\nend program main\n", "result": ["   24.0000000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  real :: p = 10.0\n  real :: r\n  \n  r = goo(p)\n  print *, r\nend program main\n", "result": ["   28.5000000    "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      real :: p = 3.14, r\n      r = goo(p)\n      print *, r\n    end program main\n        ", "result": ["   21.6399994    "]}], "code": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}
{"id": 15, "param_info": {"type_in_num": 1, "type_in": ["character (*)"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                             function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=255) :: filename = \"test.txt\"\n  integer :: num_lines\n\n  num_lines = file_line_num(filename)\n  print *, num_lines\nend program main\n", "result": ["           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                             function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  \n  character(len=100) :: filename = \"test_file.txt\"\n  integer :: line_count\n  \n  ! Create a test file with 10 lines\n  open(unit=1, file=filename, status=\"replace\")\n  do line_count = 1, 10\n    write(1, '(I3)') line_count\n  end do\n  close(unit=1)\n  \n  ! Call the function to get the line count\n  line_count = file_line_num(filename)\n  \n  ! Print the line count\n  print *, line_count\nend program main\n", "result": ["          10"]}], "code": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}
{"id": 16, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["character(len=maxtextlength)"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=20) :: text\n  integer :: number = 123\n  text = inttotext(number)\n  print *, text\nend program main\n", "result": [" 123                 "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=20) :: text\n  integer :: number = 12345\n  text = inttotext(number)\n  print *, text\nend program main\n", "result": [" 12345               "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      integer :: number = 123456\n      character(len=20) :: text\n      text = inttotext(number)\n      print *, text\n    end program main\n        ", "result": [" 123456              "]}], "code": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}
{"id": 17, "param_info": {"type_in_num": 2, "type_in": ["character(len=*)", "character(len=*)"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                        function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n\n                        end module test_function\n                        \nprogram main\n    use test_function\n    implicit none\n    character(len=100) :: str = \"abababababab\"\n    character(len=2) :: substr = \"ab\"\n    integer :: count\n    count = substrcount(str, substr)\n    print *, count\nend program main\n", "result": ["           6"]}, {"unit_test": "\n                        module test_function\n                        contains\n                        function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=50) :: str = 'abracadabra'\n  character(len=3) :: substr = 'ra'\n  integer :: count\n  count = substrcount(str, substr)\n  print *, count\nend program main\n", "result": ["           1"]}, {"unit_test": "\n                        module test_function\n                        contains\n                        function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=50) :: str = \"Hello, this is a test string\"\n  character(len=4) :: substr = \"is\"\n  integer :: count\n  count = substrcount(str, substr)\n  print *, count\nend program main\n", "result": ["           0"]}, {"unit_test": "\n                        module test_function\n                        contains\n                        function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=20) :: str = \"banana\"\n  character(len=2) :: substr = \"na\"\n  integer :: count\n\n  count = substrcount(str, substr)\n  print *, count\nend program main\n", "result": ["           2"]}], "code": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}
{"id": 18, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["character(12)"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: anumber = 123456789\n  character(12) :: astring\n\n  astring = int2str(anumber)\n  print *, trim(astring)\nend program main\n", "result": [" 123456789"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(12) :: astring\n  integer :: anumber = 123456789\n  astring = int2str(anumber)\n  print *, astring\nend program main\n", "result": [" 123456789   "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(12) :: astring\n\n  astring = int2str(1234567890)\n  print *, astring\n\nend program main\n", "result": [" *********   "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: anumber = 12345\n  character(12) :: astring\n  \n  astring = int2str(anumber)\n  print *, astring\nend program main\n", "result": ["     12345   "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      character(12) :: astring\n      integer :: anumber = 987654321\n      astring = int2str(anumber)\n      print *, astring\n    end program main\n", "result": [" 987654321   "]}], "code": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}
{"id": 19, "param_info": {"type_in_num": 1, "type_in": ["character(*)"], "type_out_num": 1, "type_out": ["character(len(str))"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=20) :: str = 'Hello, World!'\n  character(len(str)) :: upper\n  \n  upper = uppercase(str)\n  print *, upper\nend program main\n", "result": [" Hello, World!       "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        program main\n  use test_function\n  implicit none\n  character(len=10) :: str = 'hello world'\n  character(len=10) :: upper\n  upper = uppercase(str)\n  print *, upper\nend program main", "result": [" hello worl"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=100) :: str = 'This is a sample string.'\n  character(len=100) :: upper\n  upper = uppercase(str)\n  print *, upper\nend program main\n", "result": [" This is a sample string.                                                                            "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=100) :: str = \"Hello World\"\n  character(len=100) :: upper\n  upper = uppercase(str)\n  print *, upper\nend program main\n", "result": [" Hello World                                                                                         "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=50) :: str = \"Hello, World!\"\n  character(len=50) :: upper\n\n  upper = uppercase(str)\n  print *, upper\nend program main\n", "result": [" Hello, World!                                     "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \n    program main\n      use test_function\n      implicit none\n      character(len=100) :: str = \"Hello, world!\"\n      character(len(str)) :: upper\n      upper = uppercase(str)\n      print *, upper\n    end program main\n        ", "result": [" Hello, world!                                                                                       "]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  character(len=100) :: str = \"Hello, World!\"\n  character(len(str)) :: upper\n  upper = uppercase(str)\n  print *, upper\nend program main\n", "result": [" Hello, World!                                                                                       "]}], "code": "  function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n"}
{"id": 20, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: x = 27\n  integer :: sqrtx\n  sqrtx = floorsqrt(x)\n  print *, sqrtx\nend program main\n", "result": ["           5"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: x = 16\n  integer :: sqrtx\n  \n  sqrtx = floorsqrt(x)\n  print *, sqrtx\nend program main\n", "result": ["           4"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: x = 15\n  integer :: sqrtx\n  sqrtx = floorsqrt(x)\n  print *, sqrtx\nend program main\n", "result": ["           3"]}], "code": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}
{"id": 21, "param_info": {"type_in_num": 1, "type_in": ["integer"], "type_out_num": 1, "type_out": ["integer"]}, "test_case": [{"unit_test": "\n                        module test_function\n                        contains\n                          function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: x = 27\n  integer :: curtx\n  \n  curtx = floorcurt(x)\n  print *, curtx\nend program main\n", "result": ["           3"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n\n                        end module test_function\n                        program main\n  use test_function\n  implicit none\n  integer :: curtx\n  integer :: x = 20\n  curtx = floorcurt(x)\n  print *, curtx\nend program main", "result": ["           2"]}, {"unit_test": "\n                        module test_function\n                        contains\n                          function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n\n                        end module test_function\n                        \nprogram main\n  use test_function\n  implicit none\n  integer :: x\n  integer :: curtx\n  \n  ! Test Case 1\n  x = 0\n  curtx = floorcurt(x)\n  print *, curtx\n  \n  ! Test Case 2\n  x = 1\n  curtx = floorcurt(x)\n  print *, curtx\n  \n  ! Test Case 3\n  x = 8\n  curtx = floorcurt(x)\n  print *, curtx\n  \n  ! Test Case 4\n  x = 27\n  curtx = floorcurt(x)\n  print *, curtx\n  \n  ! Test Case 5\n  x = 64\n  curtx = floorcurt(x)\n  print *, curtx\n  \nend program main\n", "result": ["           0", "           1", "           2", "           3", "           4"]}], "code": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}
