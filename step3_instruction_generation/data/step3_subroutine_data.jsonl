{"instruction": "Write a Fortran subroutine called \"residual\" that calculates the residual for an elliptic problem. The subroutine takes 10 input parameters: \"ff\" and \"rf\" are 2D arrays of type \"real*8\" with dimensions nx by ny; \"a\", \"b\", \"c\", and \"nu\" are 1D arrays of type \"real*8\" with length ny; \"nx\" and \"ny\" are integers representing the dimensions of the arrays; \"nnx\" and \"nny\" are integers representing the periodic dimensions of the arrays. The subroutine has one output parameter, \"resf\", a 2D array of type \"real*8\" with dimensions nx by ny.\n\nThe subroutine calculates the residual in the phi equation for the elliptic problem. It uses the input arrays and parameters to perform calculations for each element of the output array \"resf\". The calculations involve accessing neighboring elements of the input arrays and applying various coefficients and values to compute the residual.\n\nTo use the subroutine, provide the necessary input arrays and parameters and allocate memory for the output array \"resf\". After calling the subroutine, the computed residual values will be stored in the \"resf\" array, which can be used for further calculations or analysis.", "param_info": {"param_name": ["nx", "ny", "nnx", "nny", "ff(nx,ny)", "rf(nx,ny)", "a(ny)", "b(ny)", "c(ny)", "nu", "resf(nx,ny)"], "type_in_num": 10, "type_in": ["integer", "integer", "integer", "integer", "real*8", "real*8", "real*8", "real*8", "real*8", "real*8"], "type_out_num": 1, "type_out": ["real*8"]}, "test_case": [{"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        \nprogram main\n  use test_subroutine\n  implicit none\n  \n  ! Define the input arrays and variables\n  real*8, dimension(10, 10) :: ff, rf, resf\n  real*8, dimension(10) :: a, b, c\n  real*8 :: nu\n  integer :: nx, ny, nnx, nny\n\n  ! Set the values of the input arrays and variables\n\n  ! Call the residual subroutine\n  call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n\n  ! Print the output variable\n  print *, resf\n\nend program main\n", "result": []}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n\n  integer, parameter :: nx = 10, ny = 10, nnx = nx + 2, nny = ny + 2\n  real*8 :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu\n  real*8 :: resf(nx,ny)\n  \n  ! Initialize input arrays\n  ff = 1.0\n  rf = 2.0\n  a = 3.0\n  b = 4.0\n  c = 5.0\n  nu = 6.0\n  \n  ! Call the subroutine\n  call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n  \n  ! Print the output variable\n  print *, resf\n  \nend program main", "result": ["   8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000        8.0000000000000000       -20.000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -4.0000000000000000       -20.000000000000000     "]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer, parameter :: nx = 10, ny = 10, nnx = nx+2, nny = ny+2\n  real*8, dimension(nx,ny) :: ff, rf, a, b, c, resf\n  real*8 :: nu\n\n  ! Initialize input arrays\n  ff = 0.0\n  rf = 1.0\n  a = 0.5\n  b = 0.3\n  c = 0.2\n  nu = 0.1\n\n  ! Call the subroutine\n  call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n\n  ! Print the output variable\n  print *, resf\n\nend program main\n", "result": ["   1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000       0.83999999523162838       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.89999999850988388       0.83999999523162838     "]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer, parameter :: nx = 5, ny = 5, nnx = 7, nny = 7\n  real*8 :: ff(nx, ny), rf(nx, ny), a(ny), b(ny), c(ny), nu\n  real*8 :: resf(nx, ny)\n  \n  ! Initialize input arrays\n  \n  ff = reshape([1.0, 2.0, 3.0, 4.0, 5.0, &\n                6.0, 7.0, 8.0, 9.0, 10.0, &\n                11.0, 12.0, 13.0, 14.0, 15.0, &\n                16.0, 17.0, 18.0, 19.0, 20.0, &\n                21.0, 22.0, 23.0, 24.0, 25.0], [nx, ny])\n  \n  rf = reshape([0.1, 0.2, 0.3, 0.4, 0.5, &\n                0.6, 0.7, 0.8, 0.9, 1.0, &\n                1.1, 1.2, 1.3, 1.4, 1.5, &\n                1.6, 1.7, 1.8, 1.9, 2.0, &\n                2.1, 2.2, 2.3, 2.4, 2.5], [nx, ny])\n  \n  a = [0.1, 0.2, 0.3, 0.4, 0.5]\n  b = [0.5, 0.4, 0.3, 0.2, 0.1]\n  c = [1.0, 1.0, 1.0, 1.0, 1.0]\n  \n  nu = 0.01\n  \n  ! Call the subroutine\n  \n  call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n  \n  ! Print the output variable\n  \n  print *, resf\n  \nend program main", "result": ["  -3.8900000061839819      -0.28000000491738319      -0.16999999620020390       -6.0000002384185791E-002   4.9999991431832314E-002   1.8599999658763409        4.7699999716132879        4.8799999952316284        4.9899999592453241        5.0999999828636646        2.6099998783320189        4.8199999853968620        4.9299998898059130        5.0399999134242535        5.1499999370425940        3.3599999696016312        4.8700000140815973        4.9799999184906483        5.0899999421089888        5.1999999657273293        19.709999928250909        17.920000042766333        18.529999947175384        19.140000090003014        22.350000033155084     "]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n\n  integer, parameter :: nx = 5, ny = 5, nnx = 7, nny = 7\n  real*8 :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu\n  real*8 :: resf(nx,ny)\n  integer :: i, j\n\n  ! Set input arrays\n  nu = 0.1\n  do j = 1, ny\n    do i = 1, nx\n      ff(i,j) = real(i) + real(j)\n      rf(i,j) = real(i) - real(j)\n    end do\n  end do\n  do j = 1, ny\n    a(j) = real(j)\n    b(j) = real(j) * 2\n    c(j) = real(j) * 3\n  end do\n\n  ! Call the subroutine\n  call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n\n  ! Print the output\n  do j = 1, ny\n    do i = 1, nx\n      print *, resf(i,j)\n    end do\n  end do\n\nend program main", "result": ["  -6.7999999970197678     ", "  0.30000000447034836     ", "   1.4000000059604645     ", "   2.5000000074505806     ", "   11.600000008940697     ", "  -8.6999999955296516     ", "   4.4000000059604645     ", "   5.5000000074505806     ", "   6.6000000089406967     ", "   23.700000010430813     ", "  -13.599999994039536     ", "   5.5000000074505806     ", "   6.6000000089406967     ", "   7.7000000104308128     ", "   32.800000011920929     ", "  -18.499999992549419     ", "   6.6000000089406967     ", "   7.7000000104308128     ", "   8.8000000119209290     ", "   41.900000013411045     ", "   61.600000008940697     ", "   32.700000010430813     ", "   23.800000011920929     ", "   14.900000013411045     ", "   116.00000001490116     "]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                        subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  real*8 :: ff(4,4), rf(4,4), a(4), b(4), c(4), nu\n  real*8 :: resf(4,4)\n  \n  ! Set values for test case\n  ff = reshape([-0.1, 0.2, -0.3, 0.4, &\n                -0.5, 0.6, -0.7, 0.8, &\n                -0.9, 1.0, -1.1, 1.2, &\n                -1.3, 1.4, -1.5, 1.6], [4,4])\n  rf = reshape([0.1, -0.2, 0.3, -0.4, &\n                0.5, -0.6, 0.7, -0.8, &\n                0.9, -1.0, 1.1, -1.2, &\n                1.3, -1.4, 1.5, -1.6], [4,4])\n  a = [0.1, 0.2, 0.3, 0.4]\n  b = [0.5, 0.6, 0.7, 0.8]\n  c = [0.9, 1.0, 1.1, 1.2]\n  nu = 0.01\n  \n  ! Call the subroutine\n  call residual(ff, rf, resf, a, b, c, nu, 4, 4, 4, 4)\n  \n  ! Print the output variable\n  print *, resf\n  \nend program main", "result": [" -0.26100000401586293       0.16200000400841233      -0.26300000631064180       0.16400000548362731       -1.2650000806525359        1.1660000793784866       -1.3070000533685091        1.2080000595450402       -2.2289999614134430        2.1299999377876517       -2.3110000417158005        2.2120000180900097       -3.6730000278428174        3.5740000042170266       -3.7950000616535533        3.6960000380277620     "]}], "code": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}
{"instruction": "Write a Fortran subroutine called \"snrc\" that determines the range of tensor rank nu for direct/exchange terms and classifies the types of radial integrals. The number of input parameters is 3, the first parameter is an array of orbital labels of type integer, the second parameter is an array of values of 2*kappa of type integer, and the third parameter is an array of values of 2*j+1 of type integer. The number of output parameters is 6, the first four parameters (nd1, nd2, ne1, ne2) are the lowest nu values and corresponding number of contributing nu values for direct and exchange terms, and they are all of type integer. The last two parameters (ibrd, ibre) classify the types of radial integrals contributing, with a negative value indicating null contribution, and they are also of type integer.", "param_info": {"param_name": ["nd1", "nd2", "ne1", "ne2", "ibrd", "ibre", "is(4)", "kaps(4)", "ks(4)"], "type_in_num": 3, "type_in": ["integer", "integer", "integer"], "type_out_num": 6, "type_out": ["integer", "integer", "integer", "integer", "integer", "integer"]}, "test_case": [{"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n  integer, dimension(4) :: is = [1, 2, 3, 4]\n  integer, dimension(4) :: kaps = [2, -3, 4, -5]\n  integer, dimension(4) :: ks = [3, 4, 2, 5]\n  \n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n  \n  print *, \"nd1 =\", nd1\n  print *, \"nd2 =\", nd2\n  print *, \"ne1 =\", ne1\n  print *, \"ne2 =\", ne2\n  print *, \"ibrd =\", ibrd\n  print *, \"ibre =\", ibre\nend program main", "result": [" nd1 =           1", " nd2 =           1", " ne1 =           1", " ne2 =           2", " ibrd =           1", " ibre =           1"]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n  integer, dimension(4) :: is = [1, 2, 1, 3]\n  integer, dimension(4) :: kaps = [2, -3, 1, -4]\n  integer, dimension(4) :: ks = [3, 5, 3, 1]\n  \n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n  \n  print *, \"nd1 =\", nd1\n  print *, \"nd2 =\", nd2\n  print *, \"ne1 =\", ne1\n  print *, \"ne2 =\", ne2\n  print *, \"ibrd =\", ibrd\n  print *, \"ibre =\", ibre\nend program main", "result": [" nd1 =           1", " nd2 =           2", " ne1 =           1", " ne2 =           2", " ibrd =           2", " ibre =           1"]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n  integer, dimension(4) :: is = [1, 2, 3, 4]\n  integer, dimension(4) :: kaps = [2, -4, 3, -6]\n  integer, dimension(4) :: ks = [3, 2, 4, 1]\n  \n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n  \n  print *, \"Direct Terms:\"\n  print *, \"nd1 =\", nd1\n  print *, \"nd2 =\", nd2\n  print *, \"ibrd =\", ibrd\n  \n  print *, \"Exchange Terms:\"\n  print *, \"ne1 =\", ne1\n  print *, \"ne2 =\", ne2\n  print *, \"ibre =\", ibre\nend program main", "result": [" Direct Terms:", " nd1 =           1", " nd2 =           1", " ibrd =           1", " Exchange Terms:", " ne1 =           1", " ne2 =           2", " ibre =           1"]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n  integer, dimension(4) :: is = [1, 2, 3, 4]\n  integer, dimension(4) :: kaps = [1, -2, -3, 4]\n  integer, dimension(4) :: ks = [1, 2, 3, 4]\n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n  print *, \"nd1 =\", nd1\n  print *, \"nd2 =\", nd2\n  print *, \"ne1 =\", ne1\n  print *, \"ne2 =\", ne2\n  print *, \"ibrd =\", ibrd\n  print *, \"ibre =\", ibre\nend program main", "result": [" nd1 =           1", " nd2 =           2", " ne1 =           0", " ne2 =           0", " ibrd =           1", " ibre =          -1"]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        program main\n  use test_subroutine\n  implicit none\n  integer :: is(4) = [1, 2, 3, 4]\n  integer :: kaps(4) = [1, -1, 1, -1]\n  integer :: ks(4) = [3, 2, 1, 4]\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n  print *, nd1, nd2, ne1, ne2, ibrd, ibre\nend program main", "result": ["           0           2           0           2           1           1"]}, {"unit_test": "\n                        module test_subroutine\n                        contains\n                              subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n\n                        end module test_subroutine\n                        \nprogram main\n  use test_subroutine\n  implicit none\n  integer :: is(4)\n  integer :: kaps(4)\n  integer :: ks(4)\n  integer :: nd1, nd2, ne1, ne2, ibrd, ibre\n\n  ! Set the values for the input variables\n  is = [1, 2, 3, 4]\n  kaps = [1, -1, -2, 2]\n  ks = [3, 4, 5, 6]\n\n  ! Call the subroutine\n  call snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n\n  ! Print the output variables\n  print *, nd1\n  print *, nd2\n  print *, ne1\n  print *, ne2\n  print *, ibrd\n  print *, ibre\nend program main\n", "result": ["           1", "           3", "           0", "           0", "           1", "          -1"]}], "code": "      subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n"}
