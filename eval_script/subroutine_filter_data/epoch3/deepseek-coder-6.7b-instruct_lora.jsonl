[
    {
        "instruction": [
            "Give me a Fortran subroutine code called trisolve to solve a tridiagonal linear system with constant coefficients. The number of input parameters is 6, all of them are arrays. The first four parameters (a, b, c, r) represent the coefficients of the tridiagonal matrix and the right-hand side vector, all of type real. The fifth parameter (n) is the size of the system, of type integer. The last parameter (x) is the output array that will store the solution to the system, also of type real.",
            "Give me a Fortran subroutine code called trisolve to solve a tridiagonal linear system with constant coefficients. The number of input parameters is 6, all of them are arrays. The first four parameters (a, b, c, r) represent the coefficients of the tridiagonal matrix and the right-hand side vector, all of type real. The fifth parameter (n) is the size of the system, of type integer. The last parameter (x) is the output array that will store the solution to the system, also of type real.",
            "Provide a Fortran subroutine code named trisolve to solve a tridiagonal linear system with constant coefficients. The subroutine takes 6 input parameters and 1 output parameter. The input parameters are: the size of the system, an array a containing the values below the diagonal, an array b containing the values on the diagonal, an array c containing the values above the diagonal, and an array r containing the right hand side vector. The output parameter is an array x containing the solution to the system. The subroutine uses forward elimination and backward substitution to solve the system."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    real*8, allocatable :: a(:), b(:), c(:), r(:), x(:)\n    \n    ! Test case 1\n    n = 3\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 2.0, 0.0]\n    b = [3.0, 4.0, 5.0]\n    c = [0.0, 6.0, 7.0]\n    r = [8.0, 9.0, 10.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 4\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [0.0, 1.0, 2.0, 0.0]\n    b = [3.0, 4.0, 5.0, 6.0]\n    c = [7.0, 0.0, 8.0, 9.0]\n    r = [10.0, 11.0, 12.0, 13.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 5\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 2.0, 0.0, 3.0, 0.0]\n    b = [4.0, 5.0, 6.0, 7.0, 8.0]\n    c = [0.0, 9.0, 10.0, 0.0, 11.0]\n    r = [12.0, 13.0, 14.0, 15.0, 16.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 2\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = [1.0, 0.0]\n    b = [2.0, 3.0]\n    c = [0.0, 4.0]\n    r = [5.0, 6.0]\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 1\n    allocate(a(n), b(n), c(n), r(n), x(n))\n    a = 0.0\n    b = 1.0\n    c = 0.0\n    r = 2.0\n    call trisolve(x, a, b, c, r, n)\n    print *, x\n    deallocate(a, b, c, r, x)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.7499999999999991        5.2499999999999982       -3.2499999999999987",
                "-7.4000000000000021        4.6000000000000005       -20.666666666666675        13.266666666666671",
                "3.8095238095238093        8.8761904761904749       -4.3333333333333330        4.0000000000000000       -3.2380952380952381",
                "4.5000000000000000       -4.0000000000000000",
                "2.0000000000000000"
            ]
        },
        "code": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n",
        "answer": "subroutine trisolve(a, b, c, r, n, x)\n    implicit none\n    real, dimension(n), intent(in) :: a, b, c, r\n    real, dimension(n), intent(out) :: x\n    integer, intent(in) :: n\n    real :: alpha, beta\n    integer :: i\n\n    x(1) = r(1) / b(1)\n    do i = 2, n\n        alpha = a(i) / b(i-1)\n        beta = (r(i) - alpha * c(i-1)) / (b(i) - alpha * a(i))\n        x(i) = beta\n    end do\n\n    do i = n-1, 1, -1\n        x(i) = x(i) - alpha * x(i+1)\n    end do\n\nend subroutine trisolve\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called lin1db that performs 1D linear interpolation on a bounded domain. The subroutine takes 5 input parameters: n, an integer representing the size of the arrays; xg, xd, and q, arrays of type real, representing grid points, departure points, and the quantity to be interpolated, respectively. The subroutine also has one output parameter, qnew, an array of type real, representing the interpolated values of q.",
            "Please provide a Fortran subroutine called lin1db that performs 1D linear interpolation on a bounded domain. The subroutine takes in five input parameters: n (an integer representing the size of the arrays), xg (an array of real numbers representing the grid points), xd (an array of real numbers representing the departure points), q (an array of real numbers representing the quantity to be interpolated), and qnew (an array of real numbers to store the interpolated values). The subroutine outputs the interpolated values in the qnew array.",
            "Please provide a Fortran subroutine code called lin1db to perform 1D linear interpolation on a bounded domain. The subroutine takes 5 input parameters: n, an integer representing the size of the domain; xg, an array of real numbers representing the grid points; xd, an array of real numbers representing the departure points; q, an array of real numbers representing the quantity q at each grid point. The subroutine also has 1 output parameter: qnew, an array of real numbers representing the interpolated quantity q at each departure point."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    real*8 :: xg(5), xd(5), q(5), qnew(5)\n    ! Test case 1\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.5, 1.5, 2.5, 3.5, 4.5]\n    q = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n\n    ! Test case 2\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [1.2, 1.8, 2.4, 3.6, 4.5]\n    q = [1.5, 2.5, 3.5, 4.5, 5.5]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.5, 1.5, 2.5, 3.5, 3.0]\n    q = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.0, 1.0, 2.0, 3.0, 4.0]\n    q = [2.0, 3.0, 4.0, 5.0, 6.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 5\n    xg = [0.0, 1.0, 2.0, 3.0, 4.0]\n    xd = [0.3, 1.7, 2.8, 3.2, 4.1]\n    q = [1.2, 2.4, 3.6, 4.8, 6.0]\n    call lin1db(xg, xd, q, qnew, n)\n    print *, qnew\n    print *, \"&\"\nend program main",
            "result": [
                "1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.0000000000000000",
                "2.7000000476837158        3.2999999523162842        3.9000000953674316        5.0999999046325684        5.5000000000000000",
                "1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        4.0000000000000000",
                "2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "1.5600000762939459        3.2400000190734772        4.5600000762939317        5.0400002098083405        6.0000000000000000"
            ]
        },
        "code": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n",
        "answer": "subroutine lin1db(n, xg, xd, q, qnew)\n    implicit none\n    integer, intent(in) :: n\n    real, dimension(n), intent(in) :: xg, xd, q\n    real, dimension(n), intent(out) :: qnew\n    integer :: i, j\n    real :: w\n\n    do i = 1, n\n        do j = 1, n\n            if (xd(i) < xg(j)) then\n                w = (xd(i) - xg(j-1)) / (xg(j) - xg(j-1))\n                qnew(i) = q(j-1) + w * (q(j) - q(j-1))\n                exit\n            end if\n        end do\n    end do\n\nend subroutine lin1db\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"residual\" to calculate the residual for an elliptic problem. The subroutine takes multiple input parameters: \n- \"ff\" is an input array of type real with dimensions (nx, ny)\n- \"rf\" is an input array of type real with dimensions (nx, ny)\n- \"a\" is an input array of type real with dimension (ny)\n- \"b\" is an input array of type real with dimension (ny)\n- \"c\" is an input array of type real with dimension (ny)\n- \"nu\" is an input parameter of type real\n- \"nx\" is an input parameter of type integer\n- \"ny\" is an input parameter of type integer\n- \"nnx\" is an input parameter of type integer\n- \"nny\" is an input parameter of type integer\n  \nThe subroutine also has one output parameter:\n- \"resf\" is an output array of type real with dimensions (nx, ny)\n\nThe purpose of the subroutine is to calculate the residual values for the elliptic problem based on the input arrays and parameters provided. The calculation involves iterating over the elements of the arrays and performing various mathematical operations to determine the residual values. The subroutine uses loops and conditional statements to handle different parts of the arrays separately.",
            "Please provide a Fortran subroutine code called \"residual\" that calculates the residual for an elliptic problem. The subroutine takes in several input parameters: \n- \"ff\" is a 2D array of type real*8 with dimensions (nx, ny)\n- \"rf\" is a 2D array of type real*8 with dimensions (nx, ny)\n- \"a\", \"b\", and \"c\" are 1D arrays of type real*8 with dimension (ny)\n- \"nu\" is a scalar of type real*8\n- \"nx\" and \"ny\" are integers representing the dimensions of the arrays ff and rf\n- \"nnx\" and \"nny\" are integers representing modified dimensions of the arrays\n\nThe subroutine calculates the residual for the elliptic problem and returns the result in the output parameter \"resf\", which is a 2D array of type real*8 with dimensions (nx, ny).\n\nPlease provide a Fortran subroutine code called \"residual\" to calculate the residual for an elliptic problem. The subroutine should take in several input parameters: \n- \"ff\" is a 2D array of type real*8 with dimensions (nx, ny)\n- \"rf\" is a 2D array of type real*8 with dimensions (nx, ny)\n- \"a\", \"b\", and \"c\" are 1D arrays of type real*8 with dimension (ny)\n- \"nu\" is a scalar of type real*8\n- \"nx\" and \"ny\" are integers representing the dimensions of the arrays ff and rf\n- \"nnx\" and \"nny\" are integers representing modified dimensions of the arrays\n\nThe subroutine should calculate the residual for the elliptic problem and store the result in the output parameter \"resf\", which is a 2D array of type real*8 with dimensions (nx, ny).",
            "Write a Fortran subroutine called \"residual\" to calculate the residual for an elliptic problem. The subroutine has multiple input and output parameters. The input parameters are:\n- nx: an integer representing the number of grid points in the x-direction\n- ny: an integer representing the number of grid points in the y-direction\n- nnx: an integer representing the size of the x-direction array\n- nny: an integer representing the size of the y-direction array\n- ff: a 2D array of real numbers with dimensions (nx, ny)\n- rf: a 2D array of real numbers with dimensions (nx, ny)\n- a: a 1D array of real numbers with size ny\n- b: a 1D array of real numbers with size ny\n- c: a 1D array of real numbers with size ny\n- nu: a real number\n\nThe output parameter is:\n- resf: a 2D array of real numbers with dimensions (nx, ny)\n\nTo calculate the residual, the subroutine performs calculations on the input arrays ff, rf, a, b, c, and nu. The results are stored in the output array resf.\n\nPlease implement the \"residual\" subroutine according to the provided code."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: nx = 5, ny = 4, nnx = 6, nny = 5\n    real*8 :: ff(nx, ny), rf(nx, ny), a(ny), b(ny), c(ny), nu\n    real*8 :: resf(nx, ny)\n    \n    ! Test case 1\n    ff = 1.0\n    rf = 2.0\n    a = 0.5\n    b = 0.2\n    c = 0.3\n    nu = 0.1\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 2\n    ff = 0.0\n    rf = 1.0\n    a = 1.0\n    b = 0.5\n    c = 0.0\n    nu = 0.2\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 3\n    ff = 2.0\n    rf = 0.0\n    a = 0.1\n    b = 0.3\n    c = 0.2\n    nu = 0.3\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 4\n    ff = 3.0\n    rf = 2.5\n    a = 0.4\n    b = 0.1\n    c = 0.5\n    nu = 0.4\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \n    ! Test case 5\n    ff = 1.5\n    rf = 1.5\n    a = 0.3\n    b = 0.4\n    c = 0.1\n    nu = 0.5\n    call residual(ff, rf, resf, a, b, c, nu, nx, ny, nnx, nny)\n    print *, resf\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.1000000014901161        2.5899999952316284        2.4499999955296516        2.4499999955296516        2.4499999955296516        2.6399999997019767",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000       0.50000000000000000",
                "0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791       0.60000002384185791        1.3200000467896462       0.78000002622604381       0.78000002622604381       0.78000002622604381        1.3100000457465648",
                "3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        3.7000000178813934        4.9500000365078449        4.7000000327825546        4.7000000327825546        4.7000000327825546        5.1100000382959845",
                "2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        2.2500000000000000        3.2300000239908693        2.6700000162422657        2.6700000162422657        2.6700000162422657        3.1400000190734865"
            ]
        },
        "code": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n",
        "answer": "subroutine residual(ff, rf, a, b, c, nu, nx, ny, nnx, nny)\n    implicit none\n    integer, intent(in) :: nx, ny, nnx, nny\n    real, intent(in) :: ff(nx, ny), rf(nx, ny), a(ny), b(ny), c(ny), nu\n    real :: resf(nx, ny)\n    integer :: i, j\n\n    do i = 1, nx\n        do j = 1, ny\n            if (j == 1) then\n                resf(i, j) = (a(j) * ff(i, j) - b(j) * rf(i, j) - c(j) * ff(i, j+1)) / (a(j) + nu)\n            else if (j == ny) then\n                resf(i, j) = (a(j) * ff(i, j) - b(j) * rf(i, j) - c(j) * ff(i, j-1)) / (a(j) + nu)\n            else\n                resf(i, j) = (a(j) * ff(i, j) - b(j) * rf(i, j) - c(j) * (ff(i, j+1) + ff(i, j-1))) / (a(j) + nu)\n            end if\n        end do\n    end do\n\nend subroutine residual\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called insertionsort to sort an array in ascending order using the insertion sort algorithm. The subroutine takes three parameters. The first parameter is the size of the array, which is an integer and is passed as an input parameter. The second parameter is the input array (inarray), which is an array of integers and is also passed as an input parameter. The third parameter is the output array (outarray), which is an array of integers and is passed as an output parameter. The subroutine performs the insertion sort algorithm on the input array and populates the output array with the sorted elements.",
            "Write a Fortran subroutine called insertionsort that performs the insertion sort algorithm on an array. The subroutine has three input parameters: \n1. n, an integer representing the size of the array \n2. inarray, an integer array of size n containing the elements to be sorted \n\nThe subroutine also has one output parameter: \n1. outarray, an integer array of size n that will store the sorted elements \n\nTo implement the insertion sort algorithm, the subroutine initializes outarray as a copy of inarray. It then iterates over each element of outarray, starting from the second element, and compares it with the previous elements. If an element is smaller than the one before it, the elements are swapped until the correct position is found. \n\nTo use the subroutine, pass the size of the array, the input array, and an uninitialized output array to the subroutine. After the subroutine call, the output array will contain the sorted elements.",
            "Please create a Fortran subroutine called \"insertionsort\" to sort an array in ascending order using the insertion sort algorithm. The subroutine takes 3 parameters: the size of the array (an integer), the input array (an array of integers), and the output array (an array of integers). The subroutine modifies the output array to contain the sorted elements."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n\n    integer, dimension(:), allocatable :: inarray, outarray\n    integer :: i\n\n    ! Test case 1\n    n = 5\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [5, 2, 8, 1, 9]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 2\n    n = 7\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [3, 9, 2, 7, 1, 5, 8]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 3\n    n = 3\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [10, 5, 1]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 4\n    n = 6\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [4, 6, 2, 9, 3, 1]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\n    ! Test case 5\n    n = 4\n    allocate(inarray(1:n))\n    allocate(outarray(1:n))\n    inarray = [7, 3, 5, 2]\n    call insertionsort(inarray, outarray, n)\n    do i = 1, n\n        print *, outarray(i)\n    end do\n    deallocate(inarray)\n    deallocate(outarray)\n    print *, \"&\"\n\nend program main",
            "result": [
                "1\n           2\n           5\n           8\n           9",
                "1\n           2\n           3\n           5\n           7\n           8\n           9",
                "1\n           5\n          10",
                "1\n           2\n           3\n           4\n           6\n           9",
                "2\n           3\n           5\n           7"
            ]
        },
        "code": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n",
        "answer": "subroutine insertionsort(inarray, outarray, size)\n    integer, intent(in) :: size\n    integer, intent(in) :: inarray(size)\n    integer, intent(out) :: outarray(size)\n    integer :: i, j, key\n\n    do i = 2, size\n        key = inarray(i)\n        j = i - 1\n        do while (j > 0 .and. outarray(j) > key)\n            outarray(j+1) = outarray(j)\n            j = j - 1\n        end do\n        outarray(j+1) = key\n    end do\n\nend subroutine insertionsort\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called \"driver\" that calculates the time rate of change of surface temperature and the incremental change in surface temperature. The subroutine takes in 11 input parameters: jm and im of type integer, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, and dt of type real(8). The subroutine also has two output parameters: tsinc and tsdot, both of type real(8) and dimension jm x im.",
            "Provide a Fortran subroutine called \"driver\" that calculates the time derivative and incremental change of surface temperature. The subroutine takes in 11 input parameters: jm (integer), im (integer), srf_rad_flx (real array of dimensions jm,im), srf_lat_flx (real array of dimensions jm,im), srf_sen_flx (real array of dimensions jm,im), qflx (real array of dimensions jm,im), hslab (real), rowl (real), cl (real), dt (real), and tsinc (real array of dimensions jm,im). The subroutine also has two output parameters: tsdot (real array of dimensions jm,im) and tsinc (real array of dimensions jm,im).\n",
            "Please implement a Fortran subroutine called \"driver\" which calculates the time rate of change of a temperature field and the increment in the temperature field. The subroutine takes several input parameters: jm and im (integers), srf_rad_flx, srf_lat_flx, srf_sen_flx, and qflx (real arrays of dimensions jm and im), hslab, rowl, cl, and dt (real values). The subroutine also has two output parameters: tsinc and tsdot (real arrays of dimensions jm and im). \n\nTo compute the time rate of change and the increment in the temperature field, the subroutine performs several calculations using the input parameters. It first calculates the inverse of the product of hslab, rowl, and cl, and assigns it to the variable invcslab. Then, it computes tsdot by adding srf_rad_flx, srf_lat_flx, srf_sen_flx, and qflx, and multiplying the result by invcslab. Finally, it calculates tsinc by multiplying tsdot by 2*dt.\n\nPlease ensure that all the input and output parameters are properly declared and that the appropriate dimensions are specified for the arrays."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: jm, im\n    real*8, allocatable :: srf_rad_flx(:,:), srf_lat_flx(:,:), srf_sen_flx(:,:), qflx(:,:)\n    real*8, allocatable :: tsinc(:,:), tsdot(:,:)\n    real*8 :: hslab, rowl, cl, dt\n    integer :: i, j\n    \n    jm = 3\n    im = 3\n    allocate(srf_rad_flx(jm, im), srf_lat_flx(jm, im), srf_sen_flx(jm, im), qflx(jm, im))\n    allocate(tsinc(jm, im), tsdot(jm, im))\n    \n    ! Test case 1\n    hslab = 0.1\n    rowl = 1000.0\n    cl = 1000.0\n    dt = 0.01\n    srf_rad_flx = 100.0\n    srf_lat_flx = 50.0\n    srf_sen_flx = 75.0\n    qflx = 25.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    hslab = 0.05\n    rowl = 2000.0\n    cl = 500.0\n    dt = 0.02\n    srf_rad_flx = 150.0\n    srf_lat_flx = 75.0\n    srf_sen_flx = 100.0\n    qflx = 50.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    hslab = 0.2\n    rowl = 1500.0\n    cl = 750.0\n    dt = 0.025\n    srf_rad_flx = 125.0\n    srf_lat_flx = 100.0\n    srf_sen_flx = 50.0\n    qflx = 75.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    hslab = 0.15\n    rowl = 1750.0\n    cl = 625.0\n    dt = 0.03\n    srf_rad_flx = 175.0\n    srf_lat_flx = 125.0\n    srf_sen_flx = 25.0\n    qflx = 100.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    hslab = 0.25\n    rowl = 1250.0\n    cl = 875.0\n    dt = 0.035\n    srf_rad_flx = 200.0\n    srf_lat_flx = 150.0\n    srf_sen_flx = 0.0\n    qflx = 125.0\n    call driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n    do j = 1, jm\n        do i = 1, im\n            print *, tsinc(j,i), tsdot(j,i)\n        end do\n    end do\nend program main",
            "result": [
                "4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003\n   4.9999998137354887E-005   2.4999999627470979E-003",
                "2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003\n   2.9999998882412931E-004   7.4999998882412933E-003",
                "7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003\n   7.7777777777777782E-005   1.5555555323759718E-003",
                "1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003\n   1.5542856177829599E-004   2.5904760875399193E-003",
                "1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003\n   1.2160000051770892E-004   1.7371428571428572E-003"
            ]
        },
        "code": "subroutine driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, &\n                             tsinc, tsdot )\n\nimplicit none\n\n! input\ninteger, intent(in)                   :: jm,im\nreal(8), intent(in), dimension(jm,im) :: srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx\nreal(8), intent(in)                   :: hslab, rowl, cl, dt\n!f2py intent(in,hide)  jm,im\n\n! output\nreal(8), intent(out), dimension(jm,im) :: tsinc, tsdot\n\n! local\nreal(8) :: invcslab\n\ninvcslab = 1. / (hslab*rowl*cl)\ntsdot = (srf_rad_flx + srf_lat_flx + srf_sen_flx + qflx) * invcslab\ntsinc = 2.*dt*tsdot\n\nend subroutine driver\n",
        "answer": "subroutine driver(jm, im, srf_rad_flx, srf_lat_flx, srf_sen_flx, qflx, hslab, rowl, cl, dt, tsinc, tsdot)\n\n    implicit none\n\n    integer, intent(in) :: jm, im\n    real(8), intent(in) :: srf_rad_flx(jm,im), srf_lat_flx(jm,im), srf_sen_flx(jm,im), qflx(jm,im), hslab(jm,im), rowl(jm,im), cl(jm,im)\n    real(8), intent(in) :: dt\n    real(8), intent(out) :: tsinc(jm,im), tsdot(jm,im)\n\n    ! local variables\n    integer :: i, j\n\n    ! calculate the time rate of change of surface temperature\n    do j = 1, im\n        do i = 1, jm\n            tsdot(i,j) = (srf_rad_flx(i,j) + srf_lat_flx(i,j) + srf_sen_flx(i,j)) / (hslab(i,j) * rowl(i,j) * cl(i,j))\n        end do\n    end do\n\n    ! calculate the incremental change in surface temperature\n    do j = 1, im\n        do i = 1, jm\n            tsinc(i,j) = qflx(i,j) / (hslab(i,j) * rowl(i,j) * cl(i,j))\n        end do\n    end do\n\nend subroutine driver\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called \"point_to_taylor\" that calculates the coefficients of a Taylor series polynomial interpolation. The subroutine takes in five input parameters: an integer \"m\" representing the degree of the polynomial, two arrays of type double precision \"x\" and \"y\" which store the data points, a double precision scalar \"x0\" representing the center of the interpolation, and an output array of type double precision \"c\" to store the computed coefficients. The subroutine does not return any value.",
            "Provide a Fortran subroutine called point_to_taylor that computes the coefficients for a Taylor polynomial interpolation centered at a given point x0. The subroutine takes 5 input parameters: an integer m representing the degree of the polynomial, two arrays of double precision numbers x and y representing the data points, a double precision number x0 representing the center point, and an output array of double precision numbers c representing the coefficients of the Taylor polynomial.",
            "Provide a Fortran subroutine code called point_to_taylor to compute the coefficients in Taylor form for an interpolant. The subroutine has 5 input parameters and no output parameters. The first input parameter is an integer called m, representing the degree of the interpolant. The next two input parameters are arrays of type double precision called x and y, representing the data points. The fourth input parameter is a double precision scalar called x0, representing the center point for the Taylor expansion. The last input parameter is an array of type double precision called c, which will store the computed coefficients."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 4\n    real*8, dimension(0:m) :: x, y, c\n    real*8 :: x0\n    ! Test case 1\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 1.0, 4.0, 9.0, 16.0]\n    x0 = 2.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n\n    ! Test case 2\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 1.0, 8.0, 27.0, 64.0]\n    x0 = 1.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 0.0, 0.0, 0.0, 0.0]\n    x0 = 2.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, -1.0, -4.0, -9.0, -16.0]\n    x0 = 3.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.0, 1.0, 2.0, 3.0, 4.0]\n    y = [0.0, 2.0, 4.0, 6.0, 8.0]\n    x0 = 0.5\n    call point_to_taylor(x, y, c, x0, m)\n    print *, c\n    print *, \"&\"\nend program main",
            "result": [
                "6.2500000000000000        5.0000000000000000        1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "3.3750000000000000        6.7500000000000000        4.5000000000000000        1.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-12.250000000000000       -7.0000000000000000       -1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        2.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine point_to_taylor(x,y,c,x0,m)\n!\n! compute the coefficients in taylor form centered at x0\n! of the interpolant of the data y at the nodes x\n!\n  integer, intent(in) :: m  ! the degree\n  double precision, dimension(0:m), intent(in) :: x,y\n  double precision, dimension(0:m), intent(out) :: c\n  double precision, intent(in) :: x0\n!\n  double precision, dimension(0:m) :: dx,newton\n  integer :: j,k\n!\n! compute the newton polynomial\n!\n  dx=x-x0\n  newton=y\n  do k=1,m\n    do j=0,m-k\n      newton(j)=(newton(j+1)-newton(j))/(dx(j+k)-dx(j))\n    end do\n  end do\n!\n! now change from newton to taylor\n!\n  c=0.d0\n  c(0)=newton(0)\n  do k=1,m\n    do j=k,1,-1\n      c(j)=c(j-1)-dx(k)*c(j)\n    end do\n    c(0)=newton(k)-dx(k)*c(0)\n  end do\n!\n  end subroutine point_to_taylor\n",
        "answer": "subroutine point_to_taylor(m, x, y, x0, c)\n    integer, intent(in) :: m\n    double precision, dimension(m+1), intent(in) :: x, y\n    double precision, intent(in) :: x0\n    double precision, dimension(m+1), intent(out) :: c\n    double precision :: prod\n    integer :: i, j\n\n    c(1) = y(1)\n    do i = 2, m+1\n        c(i) = 0.0d0\n        do j = 1, i-1\n            prod = 1.0d0\n            do k = 1, i-1\n                if (k /= j) then\n                    prod = prod * (x0 - x(k)) / (x(i) - x(k))\n                end if\n            end do\n            c(i) = c(i) + prod * c(j)\n        end do\n        c(i) = c(i) * y(i)\n    end do\nend subroutine point_to_taylor\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called ffff that calculates the values of a system of differential equations. The number of input parameters is 6. The first parameter is an integer representing the number of dimensions, the second parameter is an array of type double precision representing the initial values of the variables in the system, the third parameter is an array of integers representing the indices of the parameters in the system, the fourth parameter is an array of double precision representing the values of the parameters in the system, the fifth parameter is an integer indicating whether the Jacobian matrix is required, and the sixth parameter is an array of double precision that will store the values of the system equations. The number of output parameters is 1, which is an array of double precision that will store the partial derivatives of the system equations with respect to the variables.",
            "Provide a Fortran subroutine code called \"ffff\" to compute the value of a system of differential equations. The subroutine has several input and output parameters. The input parameters are:\n- \"ndm\": an integer representing the size of the system\n- \"u\": a one-dimensional array of double precision numbers representing the current values of the system variables\n- \"icp\": an array of integers representing the indices of the free parameters\n- \"par\": an array of double precision numbers representing the values of the free parameters\n- \"ijac\": an integer flag indicating whether the Jacobian matrix needs to be computed\n\nThe output parameters are:\n- \"f\": a one-dimensional array of double precision numbers representing the values of the right-hand side of the differential equations\n- \"dfdu\": a two-dimensional array of double precision numbers representing the Jacobian matrix\n\nThe subroutine computes the values of \"f\" and \"dfdu\" based on the input values of \"u\" and \"par\". The computations involve some mathematical operations and assignments.\n\nTo use the subroutine, provide the necessary input parameters and allocate memory for the output parameters. Call the subroutine by its name \"ffff\" and pass the input and output parameters to it. After the subroutine call, the values of \"f\" and \"dfdu\" will be updated with the computed results.",
            "Write a Fortran subroutine called \"ffff\" to compute the value of a system of differential equations. The subroutine takes in several input parameters: \"ndm\" (integer), \"u\" (an array of double precision numbers), \"icp\" (an array of integers), \"par\" (an array of double precision numbers), \"ijac\" (integer). The subroutine also has output parameters: \"f\" (an array of double precision numbers) and \"dfdu\" (a two-dimensional array of double precision numbers).\n\nThe subroutine calculates the values of \"f\" based on the values of \"u\" and \"par\" according to a specific mathematical equation. If \"ijac\" is equal to zero, the subroutine will skip the calculation of \"dfdu\" and return. Otherwise, it will compute the values of \"dfdu\" based on the values of \"u\" and \"par\".\n\nTo use the subroutine, pass the appropriate values for the input parameters and ensure that the output parameters are appropriately allocated."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ndm, icp(2), ijac, i\n    double precision :: u(2), par(2), f(2), dfdu(2,2)\n    ! Test case 1\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.5, 0.5]\n    par = [1.0, 2.0]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n\n    ! Test case 2\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [1.0, 1.0]\n    par = [0.5, 3.0]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 3\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [2.0, 0.5]\n    par = [2.5, 1.5]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 4\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.75, 0.25]\n    par = [1.2, 0.8]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\n    \n    ! Test case 5\n    ndm = 2\n    icp = [1, 2]\n    ijac = 1\n    u = [0.2, 0.7]\n    par = [0.9, 1.3]\n    call ffff(ndm, u, icp, par, ijac, f, dfdu)\n    print *, f\n    print *, dfdu\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000        1.1250000000000000     \n   0.0000000000000000      -0.25000000000000000        1.0000000000000000        2.0000000000000000",
                "1.0000000000000000        3.0000000000000000     \n   0.0000000000000000       0.50000000000000000        1.0000000000000000        3.0000000000000000",
                "0.50000000000000000      -0.25000000000000000     \n   0.0000000000000000       0.50000000000000000        1.0000000000000000        1.5000000000000000",
                "0.25000000000000000       0.28437501192092896     \n   0.0000000000000000      -0.41250002384185791        1.0000000000000000       0.80000001192092896",
                "0.69999998807907104        1.0219999480843549     \n   0.0000000000000000       0.25999997794628160        1.0000000000000000        1.2999999523162842"
            ]
        },
        "code": "      subroutine ffff(ndm,u,icp,par,ijac,f,dfdu)\n!     ---------- ----\n\n      implicit none\n      integer, intent(in) :: ndm, icp(*), ijac\n      double precision, intent(in) :: u(ndm), par(*)\n      double precision, intent(out) :: f(ndm)\n      double precision, intent(inout) :: dfdu(ndm,ndm)\n\n      double precision a,c\n\n       a=par(1)\n       c=par(2)\n       f(1)= u(2)\n       f(2)= c*u(2) - u(1) * (1-u(1)) * (u(1)-a)\n\n      if(ijac.eq.0)return\n\n       dfdu(1,1)= 0\n       dfdu(1,2)= 1\n\n       dfdu(2,1)= - (1-u(1))*(u(1)-a) + u(1)*(u(1)-a) - u(1)*(1-u(1))\n       dfdu(2,2)= c\n\n      end subroutine ffff\n",
        "answer": "subroutine ffff(n, x, ipar, par, jacobian, f)\n    integer, intent(in) :: n, ipar(6)\n    double precision, intent(in) :: x(n), par(6)\n    logical, intent(in) :: jacobian\n    double precision :: f(n), fjac(n,n)\n    double precision :: a, b, c, d, e, f\n    a = par(1)\n    b = par(2)\n    c = par(3)\n    d = par(4)\n    e = par(5)\n    f = par(6)\n    f = (/ a*x(1) - b*x(2), c*x(1) - d*x(2), e*x(1) - f*x(2) /)\n    if (jacobian) then\n        fjac = reshape((/ a, -b, c, -d, e, -f /), shape(fjac))\n    end if\nend subroutine ffff\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called plschmidt that evaluates all the Schmidt normalized Legendre polynomials up to a given degree. The subroutine has three parameters: an input parameter lmax of type integer, an output parameter p of type real*8 (a vector of length lmax+1), and an input parameter z of type real*8. The subroutine calculates the Legendre polynomials and stores them in the output parameter p. The Legendre polynomials are normalized such that their integral over (-1,1) is equal to 2 / (2l+1). The subroutine checks for the validity of the input parameters and stops if any error is encountered.",
            "Write a Fortran subroutine called plschmidt that computes all the Schmidt-normalized Legendre polynomials up to a specified degree. The subroutine has three parameters: \n1. An integer input parameter called lmax, which specifies the maximum degree of the polynomials to compute.\n2. A real input parameter called z, which is the cosine of the colatitude or the sine of the latitude.\n3. A real output array parameter called p, which contains the computed Legendre polynomials.\n\nThe subroutine first checks if the size of the output array p is sufficient to store all the polynomials. If p is not large enough, an error message is printed. Then, lmax is checked to ensure it is not negative, and z is checked to ensure its absolute value is not greater than 1.\n\nNext, the subroutine initializes the variables pm2, pm1, and pl. pm2 is set to 1, p(1) is set to 1. pm1 is set to z, and p(2) is set to pm1.\n\nThe subroutine then enters a loop, starting from l = 2 up to lmax. Inside the loop, pl is computed using a formula involving pm1, pm2, z, and l. The computed value of pl is stored in p(l+1), and then pm2 is updated to pm1, and pm1 is updated to pl.\n\nThe loop continues until l reaches lmax, and then the subroutine ends.\n\nTo use this subroutine, you need to provide the maximum degree lmax as an input, the value of z, and an array p with a size of at least (lmax+1) to store the computed Legendre polynomials.",
            "Please provide a Fortran subroutine called plschmidt. This subroutine computes the Schmidt-normalized Legendre polynomials up to a given maximum degree lmax. The subroutine has three input parameters and one output parameter. The input parameters are lmax, which is an integer representing the maximum degree to compute, and z, which is a real number between -1 and 1 representing cos(colatitude) or sin(latitude). The output parameter, p, is a vector of Schmidt-normalized Legendre polynomials evaluated at z up to lmax. The length of p must be greater than or equal to (lmax+1)."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: lmax\n    real*8, allocatable :: p(:)\n    real*8 :: z\n    integer :: l\n\n    ! Test case 1\n    lmax = 3\n    z = 0.5\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n\n    ! Test case 2\n    lmax = 2\n    z = -0.75\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 3\n    lmax = 5\n    z = 1.0\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 4\n    lmax = 1\n    z = -0.2\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\n    \n    ! Test case 5\n    lmax = 4\n    z = 0.9\n    allocate(p(lmax+1))\n    call plschmidt(p, lmax, z)\n    do l = 1, lmax+1\n        print *, p(l)\n    end do\n    deallocate(p)\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000     \n  0.50000000000000000     \n -0.12500000000000000     \n -0.43750000000000000",
                "1.0000000000000000     \n -0.75000000000000000     \n  0.34375000000000000",
                "1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000     \n   1.0000000000000000",
                "1.0000000000000000     \n -0.20000000298023224",
                "1.0000000000000000     \n  0.89999997615814209     \n  0.71499993562698450     \n  0.47249989092350386     \n  0.20793735677004854"
            ]
        },
        "code": "subroutine plschmidt(p,lmax,z)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis function evalutates all of the schmidt normalized legendre \n!\tpolynomials up to degree lmax. \n!\n!\tcalling parameters:\n!\t\tout\n!\t\t\tp:\ta vector of all schmidt normalized legendgre polynomials evaluated at \n!\t\t\t\tz up to lmax. the lenght must by greater or equal to (lmax+1).\n!\t\tin\n!\t\t\tlmax:\tmaximum degree to compute.\n!\t\t\tz:\t[-1, 1], cos(colatitude) or sin(latitude).\n!\n!\tnotes:\n!\t\n!\t1.\tthe integral of plm**2 over (-1,1) is 2 * / (2l+1).\n!\t2.\tthe integral of plm**2 over all space is 4 pi / (2l+1).\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek june 2004\n!\n!\tcopyright (c) 2005, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\t\n\timplicit none\n\tinteger, intent(in) ::\tlmax\n\treal*8, intent(out) ::\tp(:)\n       \treal*8, intent(in) ::\tz\n       \treal*8 ::\tpm2, pm1, pl\n      \tinteger ::\tl\n\n\n\tif (size(p) < lmax+1) then\n\t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"p must be dimensioned as (lmax+1) where lmax is \", lmax \n     \t\tprint*, \"input array is dimensioned \", size(p)\n     \t\tstop\n     \telseif (lmax < 0) then \n     \t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"lmax must be greater than or equal to 0.\"\n     \t\tprint*, \"input value is \", lmax\n     \t\tstop\n     \telseif(abs(z) > 1.0d0) then\n     \t\tprint*, \"error --- plschmidt\"\n     \t\tprint*, \"abs(z) must be less than or equal to 1.\"\n     \t\tprint*, \"input value is \", z\n     \t\tstop\n     \tendif\n     \t\n   \tpm2  = 1.d0\n      \tp(1) = 1.d0\n      \t\n      \tpm1  = z\n      \tp(2) = pm1\n      \t\n      \tdo l = 2, lmax\n         \tpl = ( dble(2*l-1)  * z * pm1 - dble(l-1) * pm2 )  / dble(l)\n         \tp(l+1) = pl\n         \tpm2  = pm1\n         \tpm1  = pl\n      \tenddo\n\nend subroutine plschmidt\n",
        "answer": "subroutine plschmidt(lmax, p, z)\n    implicit none\n    integer, intent(in) :: lmax\n    real*8, intent(out) :: p(0:lmax)\n    real*8, intent(in) :: z\n    integer :: l\n    real*8 :: factorial\n\n    if (lmax < 0) then\n        write(*,*) 'error: lmax must be nonnegative'\n        stop\n    end if\n\n    if (abs(z) > 1.0d0) then\n        write(*,*) 'error: z must be between -1 and 1'\n        stop\n    end if\n\n    p(0) = 1.0d0\n    if (lmax > 0) then\n        p(1) = z\n        do l = 1, lmax-1\n            p(l+1) = ((2*l+1) * z * p(l) - (l+1) * p(l-1)) / (l+1)\n        end do\n    end if\n\n    do l = 0, lmax\n        factorial = 1.0d0\n        do i = 1, 2*l+1\n            factorial = factorial * real(i, kind=8)\n        end do\n        p(l) = p(l) / sqrt(factorial)\n    end do\nend subroutine plschmidt\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine named \"eig_order_real_part\" that sorts complex eigenvalues of a matrix based on their real parts. The subroutine takes three input parameters, all of which are passed by reference. The first parameter is an array of complex numbers called \"ev\" with a dimension of \"ndim\". The second parameter is an integer array called \"idxarr\" with a dimension of \"ndim\". The last parameter is an integer called \"ndim\" representing the dimension of the matrices.\n\nThe subroutine first initializes some local variables and allocates memory for intermediate arrays. Then, it iterates through the \"ev\" array to find the smallest real part of the remaining unsorted eigenvalues. It updates the index array \"idxarr\" accordingly to indicate the proper order of the eigenvalues. Finally, the subroutine deallocates the memory and returns.\n\nMake sure to call this subroutine by passing the required input parameters and store the resulting ordered indices in \"idxarr\".",
            "Please write a Fortran subroutine called `eig_order_real_part` that sorts an array of complex eigenvalues based on their real parts. The subroutine takes in three input parameters: `ev`, an array of complex numbers; `idxarr`, an integer array that will store the sorted indices; and `ndim`, an integer representing the size of the arrays. There are no output parameters specified in the code, but assume that `idxarr` will be modified in the subroutine.\n\nHere's a summary of what the subroutine does:\n1. It first initializes some variables and allocates memory for arrays.\n2. It creates a copy of the real parts of the complex eigenvalues in the `sortonr` array.\n3. It initializes the `sorted` array as false, indicating that no elements have been sorted yet.\n4. It iterates over the elements in the `ev` array to find the element with the smallest real part that hasn't been sorted yet.\n5. It updates the `idxarr` array with the index of the found element and marks it as sorted in the `sorted` array.\n6. Once all elements have been sorted, the subroutine deallocates the memory and returns.\n\nPlease implement the subroutine `eig_order_real_part`.",
            "Please provide a Fortran subroutine called `eig_order_real_part` that sorts complex eigenvalues of a matrix according to their real parts. The number of input parameters is 3. The first parameter is an array of complex numbers representing eigenvalues, with the type `complex*16`. The second parameter is an array of integers to store the proper order of the sorted eigenvalues. The third parameter is an integer representing the dimension of the matrices. There are no output parameters.\n\nTo comply with the requirements, the generated instructions are as follows:\n\n1. Define a Fortran subroutine called `eig_order_real_part` that takes in three parameters: `ev` (an array of complex numbers representing eigenvalues), `idxarr` (an array of integers to store the proper order of the sorted eigenvalues), and `ndim` (an integer representing the dimension of the matrices).\n\n2. Inside the subroutine, define the following local variables: `sorted` (an allocatable array of logical values), `sortonr` (an allocatable array of real numbers), `p` (an integer), `q` (an integer), `idx` (an integer), and `min` (a real number).\n\n3. Allocate dynamic memory storage for the `sorted` and `sortonr` arrays using the `allocate` statement.\n\n4. Initialize the `idxarr` array to zeros using the assignment statement `idxarr = 0`.\n\n5. Copy the real parts of the complex eigenvalues into the `sortonr` array using the `dble` function.\n\n6. Set all elements of the `sorted` array to `.false.` using the assignment statement `sorted = .false.`.\n\n7. Use nested `do` loops to iterate over the `ndim` elements and find the minimum real value among the unsorted eigenvalues. Update the `min` and `idx` variables accordingly.\n\n8. Assign the index `idx` to the `p`th element of the `idxarr` array.\n\n9. Update the `sorted` array by setting the element at index `idx` to `.true.`.\n\n10. Repeat steps 7-9 until all elements of the `idxarr` array have been filled.\n\n11. Deallocate the memory used by the `sortonr` and `sorted` arrays using the `deallocate` statement.\n\n12. End the subroutine using the `return` statement."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: eigenvalues(5)\n    integer :: index_array(5)\n    integer :: ndim, i\n\n    ! Test case 1\n    ndim = 5\n    eigenvalues = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (5.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n\n    ! Test case 2\n    ndim = 5\n    eigenvalues = [(5.0, 0.0), (4.0, 0.0), (3.0, 0.0), (2.0, 0.0), (1.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 3\n    ndim = 5\n    eigenvalues = [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (5.0, 0.0), (4.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 4\n    ndim = 5\n    eigenvalues = [(4.0, 0.0), (1.0, 0.0), (5.0, 0.0), (3.0, 0.0), (2.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \n    ! Test case 5\n    ndim = 5\n    eigenvalues = [(2.0, 0.0), (3.0, 0.0), (1.0, 0.0), (5.0, 0.0), (4.0, 0.0)]\n    call eig_order_real_part(eigenvalues, index_array, ndim)\n    print *, index_array\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1           2           3           4           5",
                "5           4           3           2           1",
                "1           2           3           5           4",
                "2           5           4           1           3",
                "3           1           2           5           4"
            ]
        },
        "code": "subroutine eig_order_real_part(ev, idxarr, ndim)\n  implicit none \n!!!-----------------------------------------------------------------!!!\n!!! this routine sorts complex eigenvalues of a matrix according to !!!\n!!! its real parts with the smallest in the first slot and reorders !!!\n!!! the matrices of left (row) and right (column) eigenvectors in a !!!\n!!! corresponding manner.                                           !!!\n!!!-----------------------------------------------------------------!!!\n  !---------- passed variables ----------\n  complex*16, intent(in) :: ev(ndim)         ! array of eigenvalues\n  integer, intent(out)   :: idxarr(ndim)     ! index array which gives proper order\n  integer :: ndim                            ! dimension of matrices \n  !f2py integer intent(hide), depend(ev)  :: ndim=shape(ev,0)\n  !---------- parameters ----------\n  real*8, parameter :: maxval = 1000.d0\n  !---------- local variables ----------\n  logical, allocatable :: sorted(:)\n  real*8,  allocatable :: sortonr(:)\n  integer :: p\n  integer :: q\n  integer :: idx\n  real*8  :: min\n  !---------- allocate dynamic memory storage ----------\n  allocate(sortonr(ndim), sorted(ndim))\n  !---------- initialize arrays ----------\n  idxarr = 0\n  sortonr = dble(ev)\n  sorted = .false.\n  !---------- create index array for real value ----------\n  sorted = .false.\n  do p = 1,ndim\n     min = maxval\n     do q = 1,ndim\n        if(.not.sorted(q).and.min.gt.sortonr(q)) then\n           min = sortonr(q)\n           idx = q\n        endif\n     enddo\n     idxarr(p) = idx\n     sorted(idx) = .true.\n  enddo\n  deallocate(sortonr, sorted)\n  return\nend subroutine eig_order_real_part\n",
        "answer": "subroutine eig_order_real_part(ev, idxarr, ndim)\n    complex(8), intent(in) :: ev(:)\n    integer, intent(out) :: idxarr(:)\n    integer, intent(in) :: ndim\n    integer :: i, j, k, min_idx\n    real(8) :: min_val\n    real(8), allocatable :: real_part(:)\n    integer, allocatable :: temp_idxarr(:)\n\n    allocate(real_part(ndim), temp_idxarr(ndim))\n\n    do i = 1, ndim\n        real_part(i) = real(ev(i))\n    end do\n\n    do i = 1, ndim\n        min_val = real_part(i)\n        min_idx = i\n        do j = i+1, ndim\n            if (real_part(j) < min_val) then\n                min_val = real_part(j)\n                min_idx = j\n            end if\n        end do\n        temp_idxarr(i) = min_idx\n        real_part(min_idx) = real_part(i)\n    end do\n\n    do i = 1, ndim\n        idxarr(i) = temp_idxarr(i)\n    end do\n\n    deallocate(real_part, temp_idxarr)\nend subroutine eig_order_real_part\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called linear_interp to perform linear interpolation. The subroutine takes 3 input parameters and has 2 output parameters. The input parameters are: \n- x: the point where the function value is needed, of type real*8\n- x_tables: an array of 2 points from tables, of type real*8\n- f_tables: an array of 2 function values corresponding to the x_tables, of type real*8\n\nThe output parameters are:\n- fx: the function value at x, of type real*8\n- ierr: an integer error code indicating the success or failure of the interpolation\n\nThe subroutine uses the 2 points from the tables and performs linear interpolation to compute the function value at the given point x. The result is stored in the variable fx. If any error occurs during the interpolation, the ierr is set to 1.",
            "Implement a Fortran subroutine named \"linear_interp\" that performs linear interpolation. The subroutine takes 5 input parameters, all of type real*8. The first parameter, \"x\", represents the point at which the function value is needed. The next two parameters, \"x_tables\" and \"f_tables\", are arrays of size 2 and represent the two points from which interpolation is performed. The last two parameters, \"fx\" and \"ierr\", are output parameters of type real*8 and integer respectively. \n\nThe subroutine calculates the function value \"fx\" at the point \"x\" using the linear interpolation formula. If the difference between the two x values in \"x_tables\" is zero, an error code \"ierr\" is set to 1. \n\nEnsure that the subroutine is implemented with the Fortran programming language and use imperative instructions.",
            "Give me a Fortran subroutine code called linear_interp to perform linear interpolation. The subroutine takes 3 input parameters and has 2 output parameters. The input parameters are: \n- x: the point where the function value is needed, of type real*8\n- x_tables: an array of 2 points from tables, of type real*8\n- f_tables: an array of 2 function values corresponding to the x_tables, of type real*8\n\nThe output parameters are:\n- fx: the function value at x, of type real*8\n- ierr: an integer error code indicating the success or failure of the interpolation\n\nThe subroutine uses the 2 points from the tables and performs linear interpolation to compute the function value at the given point x. The result is stored in the variable fx. If any error occurs during the interpolation, the ierr is set to 1."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ierr\n    real*8 :: x, fx\n    real*8 :: x_tables(2), f_tables(2)\n    \n    ! Test case 1\n    x = 3.0\n    x_tables = [1.0, 4.0]\n    f_tables = [2.0, 8.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 2\n    x = 2.5\n    x_tables = [1.0, 3.0]\n    f_tables = [2.0, 6.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 0.5\n    x_tables = [0.0, 1.0]\n    f_tables = [0.0, 2.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 5.0\n    x_tables = [3.0, 7.0]\n    f_tables = [4.0, 8.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\n    \n    ! Test case 5\n    x = 1.0\n    x_tables = [0.0, 2.0]\n    f_tables = [1.0, 5.0]\n    call linear_interp(x, x_tables, f_tables, fx, ierr)\n    print *, fx\n    print *, \"&\"\nend program main",
            "result": [
                "6.0000000000000000",
                "5.0000000000000000",
                "1.0000000000000000",
                "6.0000000000000000",
                "3.0000000000000000"
            ]
        },
        "code": "subroutine linear_interp(x,x_tables,f_tables,fx,ierr)\n! 2 points linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x ! point where function needed\n  real*8, intent(in) ::x_tables(2),f_tables(2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx\n\n  ierr=0\n  hx=(x_tables(2)-x_tables(1))\n  if(hx.eq.0.0_r8) then\n     ierr=1\n     return\n  endif\n  fx = f_tables(1)+(x-x_tables(1))/hx*(f_tables(2)-f_tables(1))\n  return\n  \nend subroutine linear_interp\n",
        "answer": "subroutine linear_interp(x, x_tables, f_tables, fx, ierr)\n    implicit none\n    real*8, intent(in) :: x, x_tables(2), f_tables(2)\n    real*8, intent(out) :: fx\n    integer :: ierr\n    real*8 :: dx, df\n\n    ierr = 0\n\n    if (x < x_tables(1) .or. x > x_tables(2)) then\n        ierr = 1\n        return\n    end if\n\n    dx = x - x_tables(1)\n    df = f_tables(2) - f_tables(1)\n    fx = f_tables(1) + dx * df / (x_tables(2) - x_tables(1))\n\nend subroutine linear_interp\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called check_lu to compute the sum of the absolute values of elements in a matrix. The subroutine takes two parameters: an output parameter called check, which is an array of three real numbers, and an input parameter called t, which is a two-dimensional array of real numbers. The subroutine iterates over the elements of the matrix and accumulates the absolute values based on the conditions specified in the code. The subroutine updates the check array with the computed sums.",
            "Create a Fortran subroutine named check_lu that calculates the sum of absolute values in a given matrix. The subroutine has two input parameters: the first parameter is a two-dimensional array of type real, and the second parameter is the size of the matrix. The subroutine also has an output parameter called check, which is a one-dimensional array of type real with three elements. The first element of the check array represents the sum of absolute values of the upper triangular part of the matrix where i is less than j. The second element represents the sum of absolute values of the lower triangular part of the matrix where j is less than i. The third element represents the sum of absolute values of the diagonal elements of the matrix.",
            "Write a Fortran subroutine called check_lu to calculate the sum of absolute values of elements in a matrix. The subroutine takes 2 input parameters: an array of type real, named t, and its dimensions are determined by the size of the array. The subroutine also has 1 output parameter: an array of type real, named check, with a size of 3. In the subroutine, iterate over the elements of the matrix and compute the sums based on the values of the indices. If i is less than j, add the absolute value of t(i,j) to check(1). If j is less than i, add the absolute value of t(i,j) to check(2). If i is equal to j, add the absolute value of t(i,j) to check(3)."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: matrix1(3, 3), matrix2(3, 3)\n    real(8) :: check1(3), check2(3)\n    \n    ! Test case 1\n    matrix1 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n\n    ! Test case 2\n    matrix2 = reshape([9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0], shape(matrix2))\n    call check_lu(check2, matrix2)\n    print *, check2\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix1 = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix2 = reshape([1.5, 0.0, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0, 1.5], shape(matrix2))\n    call check_lu(check2, matrix2)\n    print *, check2\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix1 = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], shape(matrix1))\n    call check_lu(check1, matrix1)\n    print *, check1\n    print *, \"&\"\n    \nend program main",
            "result": [
                "19.000000000000000        11.000000000000000        15.000000000000000",
                "11.000000000000000        19.000000000000000        15.000000000000000",
                "20.500000000000000        12.500000000000000        16.500000000000000",
                "11.000000000000000        19.000000000000000        19.500000000000000",
                "20.500000000000000        12.500000000000000        19.500000000000000"
            ]
        },
        "code": "  subroutine check_lu( check, t )\n    implicit none\n    real(8),intent(out) :: check(3)\n    real(8),intent(in)  :: t(:,:)\n    integer :: i,j\n    do j=1,size(t,2)\n    do i=1,size(t,1)\n       if ( i <  j ) check(1)=check(1)+abs( t(i,j) )\n       if ( j <  i ) check(2)=check(2)+abs( t(i,j) )\n       if ( i == j ) check(3)=check(3)+abs( t(i,j) )\n    end do\n    end do\n  end subroutine check_lu\n",
        "answer": "subroutine check_lu(check, t)\n    implicit none\n    real, dimension(3) :: check\n    real, dimension(3,3) :: t\n    integer :: i, j\n    real :: sum\n\n    sum = 0.0\n    do i = 1, 3\n        do j = 1, 3\n            if (i == j) then\n                sum = sum + abs(t(i,j))\n            end if\n        end do\n    end do\n    check(1) = sum\n\n    sum = 0.0\n    do i = 1, 3\n        do j = 1, 3\n            if (i /= j) then\n                sum = sum + abs(t(i,j))\n            end if\n        end do\n    end do\n    check(2) = sum\n\n    sum = 0.0\n    do i = 1, 3\n        do j = 1, 3\n            if (i /= j) then\n                sum = sum + abs(t(j,i))\n            end if\n        end do\n    end do\n    check(3) = sum\n\nend subroutine check_lu\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called \"iqsort\" that sorts a sequence of integers in ascending order. The subroutine has two input parameters, both of which are arrays of integers. The first parameter, \"list\", is a sequence of integers that needs to be sorted. The second parameter, \"order\", is an optional array that stores the indices of the sorted sequence. The subroutine also has a recursive subroutine called \"quick_sort_1\" and a separate subroutine called \"interchange_sort\" to perform the sorting operations.\n\nIn the \"quick_sort_1\" subroutine, there are two input parameters; \"left_end\" and \"right_end\", both of which are integers. This subroutine uses the quicksort algorithm to partition the list and recursively sort the partitions until the entire list is sorted.\n\nIn the \"interchange_sort\" subroutine, there is one input parameter, \"left_end\" and \"right_end\", both of which are integers. This subroutine uses the interchange sort algorithm to sort the list by repeatedly swapping adjacent elements until the entire list is sorted.\n\nThe \"iqsort\" subroutine sorts the \"list\" in ascending order and if the \"order\" array is present, it stores the indices of the sorted sequence.",
            "Provide a Fortran subroutine called \"iqsort\" to sort a sequence of integers. The subroutine takes in two input parameters: \"list\" is an array of integers that needs to be sorted, and \"order\" is an optional output parameter that stores the indices of the sorted sequence. The subroutine uses the quick sort algorithm to sort the sequence. \n\nInside the \"iqsort\" subroutine, there is a recursive subroutine called \"quick_sort_1\" that performs the quick sort algorithm. It takes in two input parameters: \"left_end\" and \"right_end\" which specify the range of elements to be sorted. If the size of the range is smaller than a predefined threshold, the subroutine uses the interchange sort algorithm to sort the elements. Otherwise, it partitions the range based on a reference element and recursively calls itself to sort the two partitions.\n\nAdditionally, there is another subroutine called \"interchange_sort\" which performs the interchange sort algorithm. It takes in two input parameters: \"left_end\" and \"right_end\" which specify the range of elements to be sorted.\n\nTo use the \"iqsort\" subroutine, provide it with the array of integers that needs to be sorted. Optionally, you can also provide the \"order\" parameter to receive the indices of the sorted sequence.",
            "Provide a Fortran subroutine called iqsort to sort a sequence of integers. The subroutine has two input parameters, both are integer arrays passed by reference. The first parameter, named \"list\", is the sequence of integers to be sorted. The second parameter, named \"order\", is an optional output array that contains the indices of the sorted sequence. If the \"order\" parameter is present, the indices will be stored in it.\n\nInside the subroutine, there are two nested subroutines: quick_sort_1 and interchange_sort. The quick_sort_1 subroutine implements the partition or \"quick\" sort algorithm, while the interchange_sort subroutine implements the interchange sort algorithm for small lists.\n\nThe iqsort subroutine first initializes the \"order\" array if it is present. Then it calls the quick_sort_1 subroutine to sort the \"list\" array.\n\nTo use this subroutine, pass the array to be sorted as the first parameter and provide an optional array as the second parameter to store the sorted indices.\n\nExample usage: \ncall iqsort(my_list, sorted_indices)"
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, dimension(10) :: test1, test2, test3, test4, test5\n    integer, dimension(10) :: order1, order2, order3, order4, order5\n\n    ! Test case 1\n    test1 = [9, 2, 5, 1, 6, 8, 3, 7, 4, 0]\n    call iqsort(test1, order1)\n    print *, test1\n    print *, order1\n    print *, \"&\"\n\n    ! Test case 2\n    test2 = [10, 8, 6, 4, 2, 9, 7, 5, 3, 1]\n    call iqsort(test2, order2)\n    print *, test2\n    print *, order2\n    print *, \"&\"\n\n    ! Test case 3\n    test3 = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    call iqsort(test3, order3)\n    print *, test3\n    print *, order3\n    print *, \"&\"\n\n    ! Test case 4\n    test4 = [5, 7, 2, 8, 1, 3, 9, 4, 10, 6]\n    call iqsort(test4, order4)\n    print *, test4\n    print *, order4\n    print *, \"&\"\n\n    ! Test case 5\n    test5 = [4, 7, 1, 8, 10, 2, 3, 9, 6, 5]\n    call iqsort(test5, order5)\n    print *, test5\n    print *, order5\n    print *, \"&\"\n\nend program main",
            "result": [
                "0           1           2           3           4           5           6           7           8           9\n          10           4           2           7           9           3           5           8           6           1",
                "1           2           3           4           5           6           7           8           9          10\n          10           5           9           4           8           3           7           2           6           1",
                "1           2           3           4           5           6           7           8           9          10\n           1           6           2           7           3           8           4           9           5          10",
                "1           2           3           4           5           6           7           8           9          10\n           5           3           6           8           1          10           2           4           7           9",
                "1           2           3           4           5           6           7           8           9          10\n           3           6           7           1          10           9           2           4           8           5"
            ]
        },
        "code": "recursive subroutine iqsort(list, order)\n    !!  sorts a sequence of integers\n\nimplicit none\n\ninteger, dimension (:), intent(in out)  :: list\n    !!  sequence of integers to be sorted\ninteger, dimension (:), intent(out), optional  :: order\n    !!  indices of the sorted sequence\n\n! local variable\ninteger :: i\n\nif (present(order)) then\n    do i = 1, size(list)\n      order(i) = i\n    end do\nend if\n\ncall quick_sort_1(1, size(list))\n\ncontains\n\n    recursive subroutine quick_sort_1(left_end, right_end)\n    \n    integer, intent(in) :: left_end, right_end\n    \n    !     local variables\n    integer             :: i, j, itemp\n    integer             :: reference, temp\n    integer, parameter  :: max_simple_sort_size = 8\n    \n    if (right_end < left_end + max_simple_sort_size) then\n        ! use interchange sort for small lists\n        call interchange_sort(left_end, right_end)\n    \n    else\n        ! use partition (\"quick\") sort\n        reference = list((left_end + right_end)/2)\n        i = left_end - 1; j = right_end + 1\n    \n        do\n            ! scan list from left end until element >= reference is found\n            do\n                i = i + 1\n                if (list(i) >= reference) exit\n            end do\n            ! scan list from right end until element <= reference is found\n            do\n                j = j - 1\n                if (list(j) <= reference) exit\n            end do\n    \n            if (i < j) then\n                ! swap two out-of-order elements\n                temp = list(i); list(i) = list(j); list(j) = temp\n                if (present(order)) then\n                    itemp = order(i); order(i) = order(j); order(j) = itemp\n                end if\n            else if (i == j) then\n                i = i + 1\n                exit\n            else\n                exit\n            end if\n        end do\n    \n        if (left_end < j) call quick_sort_1(left_end, j)\n        if (i < right_end) call quick_sort_1(i, right_end)\n    end if\n    \n    end subroutine quick_sort_1\n\n\n    subroutine interchange_sort(left_end, right_end)\n    \n    integer, intent(in) :: left_end, right_end\n    \n    !     local variables\n    integer             :: i, j, itemp\n    integer                :: temp\n    \n    do i = left_end, right_end - 1\n        do j = i+1, right_end\n            if (list(i) > list(j)) then\n                temp = list(i); list(i) = list(j); list(j) = temp\n                if (present(order)) then\n                    itemp = order(i); order(i) = order(j); order(j) = itemp\n                end if\n            end if\n        end do\n    end do\n    \n    end subroutine interchange_sort\n\nend subroutine iqsort\n",
        "answer": "subroutine iqsort(list, order)\n    integer, dimension(:), intent(inout) :: list\n    integer, dimension(:), intent(out), optional :: order\n    integer :: left_end, right_end\n\n    if (size(list) < 2) return\n\n    left_end = 1\n    right_end = size(list)\n\n    call quick_sort_1(left_end, right_end)\n\n    if (present(order)) then\n        order = list\n    end if\n\ncontains\n\n    recursive subroutine quick_sort_1(left_end, right_end)\n        integer, intent(in) :: left_end, right_end\n        integer :: i, j, pivot\n\n        if (right_end - left_end < 1) return\n\n        pivot = list((left_end + right_end) / 2)\n        i = left_end\n        j = right_end\n\n        do\n            do while (list(i) < pivot)\n                i = i + 1\n            end do\n\n            do while (pivot < list(j))\n                j = j - 1\n            end do\n\n            if (i >= j) exit\n\n            call interchange(i, j)\n        end do\n\n        call quick_sort_1(left_end, j)\n        call quick_sort_1(i, right_end)\n\n    end subroutine quick_sort_1\n\n    subroutine interchange_sort(left_end, right_end)\n        integer, intent(in) :: left_end, right_end\n        integer :: i, j\n\n        do i = left_end, right_end - 1\n            do j = i + 1, right_end\n                if (list(i) > list(j)) then\n                    call interchange(i, j)\n                end if\n            end do\n        end do\n\n    end subroutine interchange_sort\n\n    subroutine interchange(i, j)\n        integer, intent(in) :: i, j\n        integer :: temp\n\n        temp = list(i)\n        list(i) = list(j)\n        list(j) = temp\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"average\" that calculates the average of an array. The subroutine takes three arguments: \"arr\" - an input array of real numbers, \"size\" - the size of the array (integer input), and \"value\" - the average value (real output). \n\nTo use the subroutine, provide the input array and its size, and the subroutine will calculate the average value and store it in the \"value\" variable.",
            "Create a Fortran subroutine named \"average\" to calculate the average value of an array. The subroutine takes three parameters - \"arr\", which is an array of real numbers, \"size\", which is an integer representing the size of the array, and \"value\", which is the average value of the array and is of type real. \n\nInside the subroutine, initialize the variables \"count\" and \"value\". Then, using a loop with label 100, iterate through each element of the array and add its value to the variable \"value\". Increment the \"count\" by 1 after each iteration. \n\nOnce the loop is finished, divide the value of \"value\" by the \"size\" to calculate the average. Finally, return from the subroutine.\n\nNote: The code snippet contains commented lines related to the F2PY interface, which is used for generating Python interfaces for Fortran code. These lines can be ignored for the purpose of this instruction.",
            "Provide a Fortran subroutine called \"calculate_average\" to compute the average of an array. The subroutine expects three parameters: an array of real numbers, the size of the array (integer), and the average value (real) as an output. The subroutine utilizes a loop to iterate through each element of the array and calculate the sum. At the end of the loop, the sum is divided by the size of the array to obtain the average value."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: i, size\n    real, dimension(:), allocatable :: arr\n    real :: value\n    \n    ! Test case 1\n    size = 5\n    allocate(arr(size))\n    arr = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 2\n    size = 8\n    allocate(arr(size))\n    arr = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 3\n    size = 3\n    allocate(arr(size))\n    arr = [10.0, 20.0, 30.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 4\n    size = 6\n    allocate(arr(size))\n    arr = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \n    ! Test case 5\n    size = 4\n    allocate(arr(size))\n    arr = [2.0, 4.0, 6.0, 8.0]\n    call average(arr, size, value)\n    print *, value\n    deallocate(arr)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.00000000",
                "4.00000000",
                "20.0000000",
                "5.00000000",
                "5.00000000"
            ]
        },
        "code": "subroutine average(arr, size, value)\n    implicit none\n    integer:: size, count\n    real, intent(out):: value\n    real, dimension(size):: arr\n    count = 1\n    value = 0\n!f2py intent(in) size\n!f2py depend(size) arr\n\n100 if (count.le.size) then\n        value = value + arr(count)\n        count = count + 1\n        goto 100\n    endif\n    value = value / size\n    return\nend subroutine average\n",
        "answer": "subroutine average(arr, size, value)\n    real, dimension(:), intent(in) :: arr\n    integer, intent(in) :: size\n    real :: value\n    real :: sum\n    integer :: i\n\n    sum = 0.0\n    do i = 1, size\n        sum = sum + arr(i)\n    end do\n\n    value = sum / real(size)\nend subroutine average\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called \"msa\" to perform the two-dimensional method of successive approximations (MSA). The subroutine takes in six parameters: \n\n1. \"n1\" and \"n2\" are integers representing the dimensions of the two-dimensional arrays.\n2. \"y0\" is a two-dimensional real array that serves as input.\n3. \"x0\" is a two-dimensional real array that serves as both input and output.\n4. \"stepsize\" is a real number representing the step size. \n5. \"x1\" is a two-dimensional real array that serves as the output.\n\nIn the subroutine, the elements of \"x1\" are initialized to zero. Then, a nested loop is used to iterate over the elements of the arrays. For each element, the value in \"x0\" is updated using the MSA formula: \n\nx1(j, i) = x0(j, i) + stepsize * (y0(j, i) - x0(j, i))\n\nFinally, the subroutine is concluded with a return statement.",
            "Provide a Fortran subroutine called \"msa\" to perform a two-dimensional Mean-Shift Algorithm (MSA). The subroutine takes in 5 input parameters and has no output parameters. The first input parameter, \"x0\", is an array of real numbers and is both an input and an output. The second input parameter, \"y0\", is a two-dimensional array of real numbers. The third input parameter, \"x1\", is a two-dimensional array of real numbers and serves as the output. The fourth input parameter, \"stepsize\", is a real number. The fifth input parameter, \"n1\", is an integer representing the dimension of the first axis of the arrays. The sixth input parameter, \"n2\", is an integer representing the dimension of the second axis of the arrays. The subroutine computes the mean-shift of each element in \"x0\" based on the corresponding element in \"y0\" using the formula x1(j,i) = x0(j,i) + stepsize * (y0(j,i) - x0(j,i)), where i and j iterate over the dimensions of the arrays.",
            "Write a Fortran subroutine called \"msa\" to perform a two-dimensional Modified Stochastic Approximation (MSA) algorithm. The subroutine takes multiple input parameters: \n- \"x0\": an array of type real containing initial values\n- \"y0\": a two-dimensional array of type real containing target values\n- \"stepsize\": a real value representing the step size\n- \"n1\" and \"n2\": integer values representing the dimensions of the arrays\n\nThe subroutine also has an output parameter:\n- \"x1\": a two-dimensional array of type real containing the updated values\n\nThe subroutine uses a nested do loop to iterate over the elements of the arrays and update the values in \"x1\" based on the MSA algorithm. The updated values are calculated by adding the product of the step size and the difference between the corresponding elements in \"y0\" and \"x0\" to the initial values in \"x0\".\n\nMake sure to call the subroutine \"msa\" and provide the appropriate arguments to execute the MSA algorithm."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n1 = 3, n2 = 2\n    real*8 :: x0(n1, n2), y0(n1, n2), x1(n1, n2), stepsize\n    integer :: i, j\n    \n    ! Test case 1\n    stepsize = 0.1\n    x0 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n1, n2])\n    y0 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    stepsize = 0.01\n    x0 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n1, n2])\n    y0 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    stepsize = 0.001\n    x0 = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0], [n1, n2])\n    y0 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    stepsize = 0.5\n    x0 = reshape([2.0, 3.0, 4.0, 5.0, 6.0, 7.0], [n1, n2])\n    y0 = reshape([1.0, 1.5, 2.0, 2.5, 3.0, 3.5], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    stepsize = 0.05\n    x0 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [n1, n2])\n    y0 = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [n1, n2])\n    call msa(x0, y0, x1, stepsize, n1, n2)\n    do i = 1, n2\n        do j = 1, n1\n            print *, x1(j, i)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.94999999925494194     \n   1.8999999985098839     \n   2.8499999977648258     \n   3.7999999970197678     \n   4.7499999962747097     \n   5.6999999955296516",
                "9.9999997764825821E-003\n   1.9999999552965164E-002\n   2.9999999329447746E-002\n   3.9999999105930328E-002\n   4.9999998882412910E-002\n   5.9999998658895493E-002",
                "9.9899999995250255     \n   19.979999999050051     \n   29.969999998575076     \n   39.959999998100102     \n   49.949999997625127     \n   59.939999997150153",
                "1.5000000000000000     \n   2.2500000000000000     \n   3.0000000000000000     \n   3.7500000000000000     \n   4.5000000000000000     \n   5.2500000000000000",
                "0.47999999977648256     \n  0.95999999955296511     \n   1.4399999997019768     \n   1.9199999991059302     \n   2.3999999985098839     \n   2.8799999994039536"
            ]
        },
        "code": "    subroutine msa(x0,y0,x1,stepsize,n1,n2) ! two dimension msa\n    implicit none\n! x0 is input and also output\n    integer,intent(in)::n1,n2! two dimension\n    real*8,intent(in)::y0(n1,n2)\n    real*8,intent(in)::x0(n1,n2)\n    real*8,intent(out)::x1(n1,n2)\n    real*8,intent(in)::stepsize\n    integer:: i,j\n\n    x1=0.0\n    do i=1,n2\n      do j=1,n1\n        x1(j,i)=x0(j,i)+stepsize*(y0(j,i)-x0(j,i))\n      enddo \n    enddo \n    return \n    end subroutine\n",
        "answer": "subroutine msa(n1, n2, y0, x0, stepsize, x1)\n    integer, intent(in) :: n1, n2\n    real, dimension(n1, n2), intent(in) :: y0\n    real, dimension(n1, n2), intent(inout) :: x0\n    real, intent(in) :: stepsize\n    real, dimension(n1, n2) :: x1\n    integer :: i, j\n\n    x1 = 0.0\n\n    do j = 1, n2\n        do i = 1, n1\n            x1(j, i) = x0(j, i) + stepsize * (y0(j, i) - x0(j, i))\n        end do\n    end do\n\n    return\nend subroutine msa\n\n"
    },
    {
        "instruction": [
            "Please write a Fortran subroutine called nearsquare that finds two numbers a and b, such that their product is closest to a given number n. The subroutine takes in 1 input parameter of type integer, which represents the number n. It also has 2 output parameters, both of type integer, which represent the numbers a and b.",
            "Provide me with a Fortran subroutine code called nearsquare that finds the two nearest square numbers to a given number. The subroutine requires 3 parameters, all of which are integers. The first parameter, n, is the input number for which we want to find the nearest squares. The second parameter, a, is an output parameter that will store the smaller square number. The third parameter, b, is an output parameter that will store the larger square number.",
            "Provide a Fortran subroutine code called nearsquare that finds the two nearest square numbers to a given input value. The subroutine takes 3 parameters: an input parameter n of type integer, and two output parameters a and b, also of type integer. The subroutine finds the two largest integers a and b such that their product is equal to or slightly smaller than n. The result is stored in the output parameters a and b."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: num, result1, result2\n    ! Test case 1\n    num = 10\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n\n    ! Test case 2\n    num = 20\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    num = 15\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 4\n    num = 7\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\n    \n    ! Test case 5\n    num = 25\n    call nearsquare(num, result1, result2)\n    print *, result1, result2\n    print *, \"&\"\nend program main",
            "result": [
                "2           5",
                "5           4",
                "3           5",
                "1           7",
                "5           5"
            ]
        },
        "code": "    subroutine nearsquare(n, a, b)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: a, b\n\n        do a=ceiling(sqrt(n*1.0)),1,-1\n            b = n/a\n            if (a*b == n) exit\n        enddo\n    end subroutine nearsquare\n",
        "answer": "subroutine nearsquare(n, a, b)\n    integer, intent(in) :: n\n    integer, intent(out) :: a, b\n    integer :: i, j, k, l, m, p, q, r, s, t\n\n    i = n\n    j = n\n    k = n\n    l = n\n    m = n\n    p = n\n    q = n\n    r = n\n    s = n\n    t = n\n\n    do while (i*i > n)\n        i = i - 1\n    end do\n\n    do while (j*j > n)\n        j = j - 1\n    end do\n\n    do while (k*k > n)\n        k = k - 1\n    end do\n\n    do while (l*l > n)\n        l = l - 1\n    end do\n\n    do while (m*m > n)\n        m = m - 1\n    end do\n\n    do while (p*p > n)\n        p = p - 1\n    end do\n\n    do while (q*q > n)\n        q = q - 1\n    end do\n\n    do while (r*r > n)\n        r = r - 1\n    end do\n\n    do while (s*s > n)\n        s = s - 1\n    end do\n\n    do while (t*t > n)\n        t = t - 1\n    end do\n\n    a = i\n    b = j\n\nend subroutine nearsquare\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called \"potinv\" to compute the inverse of a matrix using a power iteration method. The subroutine contains several input and output parameters. The input parameters are:\n- \"a\" is a two-dimensional real array that represents the matrix.\n- \"q\" is a real number that represents the initial value for the power iteration method.\n- \"xlam\" is a real number that represents the initial eigenvalue estimate.\n- \"eps\" is a real number that represents the tolerance for convergence.\n- \"nmaxit\" is an integer that represents the maximum number of iterations allowed.\n\nThe output parameters are:\n- \"u\" is a one-dimensional real array that represents the left eigenvector.\n- \"v\" is a one-dimensional real array that represents the right eigenvector.\n- \"ier\" is an integer that represents the convergence status of the power iteration method.\n\nTo use the subroutine, make sure to pass the correct dimensions for the array \"a\" and allocate enough memory for the arrays \"u\" and \"v\". After calling the subroutine, check the value of \"ier\" to determine if the computation was successful.",
            "Please provide a Fortran subroutine called \"potinv\" that performs calculations related to a matrix. The subroutine has several input and output parameters. The input parameters are:\n1. \"a\": a two-dimensional array of real numbers, which is passed by reference and can be modified within the subroutine.\n2. \"q\": a single real number, which indicates a specific value.\n3. \"xlam\": a single real number, which is initially passed by reference but can also be modified within the subroutine.\n4. \"eps\": a single real number, which is not modified within the subroutine.\n5. \"nmaxit\": an integer number, which represents a maximum iteration limit.\n\nThe output parameters are:\n1. \"u\": a one-dimensional array of real numbers, which is passed by reference and will store the results of the calculation.\n2. \"v\": a one-dimensional array of real numbers, which is passed by reference and will store the results of the calculation.\n3. \"ier\": an integer number, which indicates the status of the calculation.\n\nPlease write the Fortran subroutine \"potinv\" that takes these input and output parameters, performs the required calculations, and updates the results accordingly.",
            "Please write a Fortran subroutine called \"potinv\" to compute the inverse of a matrix using the potential method. The subroutine has several input and output parameters. \nThe input parameters are:\n- \"a\": a two-dimensional array of real numbers.\n- \"q\": a real number.\n- \"xlam\": a real number.\n\nThe output parameters are:\n- \"u\": a one-dimensional array of real numbers.\n- \"v\": a one-dimensional array of real numbers.\n- \"ier\": an integer variable.\n\nAdditionally, there are three other input parameters:\n- \"eps\": a real number.\n- \"nmaxit\": an integer.\n\nPlease make sure to properly specify the intent of each parameter and provide the necessary logic to compute the inverse of the matrix using the potential method."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real, dimension(3,3) :: matrix\n    real :: q, xlam, eps\n    real, dimension(3) :: u, v\n    integer :: nmaxit, ier\n    ! Test case 1\n    matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])\n    q = 0.5\n    xlam = 1.0\n    eps = 1.0E-6\n    nmaxit = 100\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 2\n    matrix = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [3, 3])\n    q = 1.0\n    xlam = 2.0\n    eps = 1.0E-8\n    nmaxit = 200\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 3\n    matrix = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [3, 3])\n    q = 0.1\n    xlam = 0.5\n    eps = 1.0E-4\n    nmaxit = 50\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 4\n    matrix = reshape([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0, 27.0], [3, 3])\n    q = 1.5\n    xlam = 0.2\n    eps = 1.0E-5\n    nmaxit = 150\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n\n    ! Test case 5\n    matrix = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3, 3])\n    q = 0.8\n    xlam = 0.1\n    eps = 1.0E-7\n    nmaxit = 80\n    call potinv(matrix, q, u, v, xlam, eps, nmaxit, ier)\n    print *, matrix\n    print *, q\n    print *, u\n    print *, v\n    print *, xlam\n    print *, eps\n    print *, nmaxit\n    print *, ier\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.00000000       2.00000000       3.00000000       4.00000000       5.00000000       6.00000000       7.00000000       8.00000000       9.00000000    \n  0.500000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n   1.00000000    \n   9.99999997E-07\n         100\n           0",
                "2.00000000       4.00000000       6.00000000       8.00000000       10.0000000       12.0000000       14.0000000       16.0000000       18.0000000    \n   1.00000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n   2.00000000    \n   9.99999994E-09\n         200\n           0",
                "0.100000001      0.200000003      0.300000012      0.400000006      0.500000000      0.600000024      0.699999988      0.800000012      0.899999976    \n  0.100000001    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.500000000    \n   9.99999975E-05\n          50\n           0",
                "3.00000000       6.00000000       9.00000000       12.0000000       15.0000000       18.0000000       21.0000000       24.0000000       27.0000000    \n   1.50000000    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.200000003    \n   9.99999975E-06\n         150\n           0",
                "0.500000000      0.600000024      0.699999988      0.800000012      0.899999976       1.00000000       1.10000002       1.20000005       1.29999995    \n  0.800000012    \n   3.41401428E-38   0.00000000       3.41406528E-38\n   0.00000000       0.00000000       3.41401175E-38\n  0.100000001    \n   1.00000001E-07\n          80\n           0"
            ]
        },
        "code": "    subroutine potinv(a, q, u, v, xlam, eps, nmaxit, ier)\n      implicit none\n      real, dimension(:,:), intent(inout) :: a\n      real, intent(in) :: q\n      real, dimension(:), intent(out) :: u, v\n      real, intent(inout) :: xlam\n      real, intent(in) :: eps\n      integer, intent(in) :: nmaxit\n      integer, intent(out) :: ier\n    end subroutine\n",
        "answer": "subroutine potinv(a,q,xlam,eps,nmaxit,u,v,ier)\n\n    implicit none\n\n    real(8), dimension(:,:), intent(in) :: a\n    real(8), intent(in) :: q\n    real(8), intent(inout) :: xlam\n    real(8), intent(in) :: eps\n    integer, intent(in) :: nmaxit\n    real(8), dimension(:), intent(out) :: u, v\n    integer, intent(out) :: ier\n\n    ! local variables\n    integer :: i, j, k\n    real(8) :: xlamold, norm\n    real(8), dimension(size(a,1)) :: uold, vold, unew, vnew\n\n    ! initialize u and v\n    u = 0.0d0\n    v = 0.0d0\n    u(1) = 1.0d0\n    v(1) = xlam\n\n    ! power iteration method\n    do k = 1, nmaxit\n        uold = u\n        vold = v\n        unew = matmul(a, uold)\n        vnew = matmul(transpose(a), vold)\n        xlam = dot_product(unew, vnew) / dot_product(vold, vold)\n        u = unew / sqrt(dot_product(unew, unew))\n        v = vnew / sqrt(dot_product(vnew, vnew))\n        if (abs(xlam - xlamold) < eps) then\n            ier = 0\n            return\n        end if\n        xlamold = xlam\n    end do\n\n    ! if max iterations reached, return error\n    ier = 1\n\nend subroutine potinv\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine named \"intplt3d\" that performs bi-linear interpolation. The subroutine takes 6 input parameters and 2 output parameters. The input parameters are:\n- l: an array of 3 integers\n- n: an array of 3 integers\n- x: an array of 3 real numbers\n- d: an array of 3 real numbers\n- dm: a 2x3 array of real numbers\n\nThe output parameters are:\n- idx: an array of 3 integers\n- coe: an array of 3 real numbers\n\nThe subroutine checks if the given coordinates are inside a defined box, and assigns an error code to \"ier\" accordingly. It then calculates the interpolation indices and coefficients based on the input parameters. Finally, it updates \"idx\" and \"coe\" variables accordingly.\n\nYour task is to write the Fortran subroutine called \"intplt3d\" with the specified input and output parameters, following the given code.",
            "Please provide a Fortran subroutine named intplt3d that performs bi-linear interpolation. The subroutine takes in 5 input parameters: l(3) and n(3) are integer arrays, x(3) and d(3) are real arrays, and dm(2,3) is a 2D real array. There are 2 output parameters: idx(3) is an integer array and coe(3) is a real array. Additionally, there is an output parameter ier of type integer.\n\nThe purpose of this subroutine is to compute interpolation indices and coefficients using bi-linear interpolation. It checks if the input values x(3) are within the boundaries defined by dm(2,3). If any of the x values are outside the boundaries, the subroutine sets ier to indicate the index of the dimension that is out of bounds. Otherwise, it calculates the indices and coefficients using the provided formulas. Finally, it increments the indices by 1 and assigns the computed values to the respective output arrays idx(3) and coe(3).",
            "Give me a Fortran subroutine code called intplt3d that computes interpolation indices and coefficients using bi-linear interpolation. The subroutine takes in 5 input parameters: \n1. An array of integers called \"l\" of length 3 representing the size of the box in each dimension.\n2. An array of integers called \"n\" of length 3 representing the number of grid points in each dimension.\n3. An array of real numbers called \"x\" of length 3 representing the coordinates where interpolation is performed.\n4. An array of real numbers called \"d\" of length 3 representing the grid spacing in each dimension.\n5. A 2D array of real numbers called \"dm\" of size 2x3 representing the minimum and maximum coordinates of the box in each dimension.\n\nThe subroutine has 2 output parameters: \n1. An array of integers called \"idx\" of length 3 representing the interpolation indices.\n2. An array of real numbers called \"coe\" of length 3 representing the interpolation coefficients.\n\nThe subroutine also has a local integer variable called \"ier\" to indicate any errors encountered during the computation.\n\nThe subroutine checks if the coordinates \"x\" are within the specified box. If any coordinate is outside the box, then \"ier\" is set to the corresponding index value (positive or negative). The interpolation indices \"idx\" are calculated by subtracting the minimum coordinates and dividing by the grid spacing. The interpolation coefficients \"coe\" are calculated by subtracting the indices times the grid spacing and dividing by the grid spacing. Finally, the indices \"idx\" are incremented by 1.\n\nPlease note that the subroutine assumes that the input arrays \"l\", \"n\", \"x\", \"d\", and \"dm\" are pre-initialized with appropriate values."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: x(3), d(3), dm(2,3)\n    integer :: l(3), n(3), idx(3), ier\n    real :: coe(3)\n    \n    ! Test case 1\n    x = [1.5, 2.5, 3.5]\n    l = [1, 1, 1]\n    n = [5, 5, 5]\n    d = [0.5, 0.5, 0.5]\n    dm = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [2.0, 3.0, 4.0]\n    l = [2, 3, 4]\n    n = [4, 4, 4]\n    d = [0.25, 0.25, 0.25]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [3.0, 1.0, 5.0]\n    l = [1, 2, 3]\n    n = [3, 2, 4]\n    d = [0.5, 0.5, 0.5]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [4.5, 3.5, 2.5]\n    l = [3, 3, 2]\n    n = [6, 5, 4]\n    d = [0.2, 0.2, 0.2]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [2.0, 4.0, 6.0]\n    l = [2, 4, 6]\n    n = [6, 8, 10]\n    d = [0.1, 0.1, 0.1]\n    dm = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], [2, 3])\n    call intplt3d(x, l, n, d, dm, idx, coe, ier)\n    print *, idx(1), idx(2), idx(3), ier\n    print *, coe(1), coe(2), coe(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2           0          -2          -3\n   0.00000000       0.00000000       0.00000000",
                "9           5           1           1\n   0.00000000       0.00000000       0.00000000",
                "7          -1           3          -2\n   0.00000000       0.00000000       0.00000000",
                "23           8          -6          -3\n  0.499999523      0.499999523     -0.499999523",
                "21          21          21           3\n   0.00000000       0.00000000       0.00000000"
            ]
        },
        "code": "subroutine intplt3d(x,l,n,d,dm,idx,coe,ier)\n\n!*************************************************\n!  this routine computes an interpolation indices\n!  and coefficients using bi-linear interpolation.\n!\n!  history: jan. 2004 by yuanfu xie.\n!*************************************************\n\n  implicit none\n\n  integer, intent(in) :: l(3),n(3)\n  real,    intent(in) :: x(3),d(3),dm(2,3)\n\n  integer, intent(out) :: idx(3),ier\n  real,    intent(out) :: coe(3)\n\n  ! local variables:\n  integer :: i\n\n  ier = 0\n  ! check in box?\n  do i=1,3\n     if (x(i) .lt. dm(1,i)) ier = -i\n     if (x(i) .gt. dm(2,i)) ier = i\n  enddo\n\n  ! indices:\n  idx = (x-dm(1,1:3))/d\n\n  ! coefficients:\n  coe = (x-idx*d-dm(1,1:3))/d\n\n  idx = idx+1\n\nend subroutine intplt3d\n",
        "answer": "subroutine intplt3d(l,n,x,d,dm,idx,coe,ier)\n\n    implicit none\n\n    integer, intent(in) :: l(3),n(3)\n    real(8), intent(in) :: x(3),d(3),dm(2,3)\n    integer :: idx(3),ier\n    real(8) :: coe(3)\n\n    integer :: i,j,k\n    real(8) :: t(3)\n\n    do i=1,3\n        if(x(i)<d(i) .or. x(i)>d(i)+n(i)*d(i)) then\n            ier=1\n            return\n        endif\n    enddo\n\n    do i=1,3\n        idx(i)=int((x(i)-d(i))/d(i))+1\n        t(i)=(x(i)-d(i))/d(i)-real(idx(i)-1)\n    enddo\n\n    do i=1,2\n        do j=1,2\n            do k=1,2\n                coe(1)=dm(i,1)*dm(j,2)*dm(k,3)\n                coe(2)=dm(i,2)*dm(j,3)*dm(k,1)\n                coe(3)=dm(i,3)*dm(j,1)*dm(k,2)\n            enddo\n        enddo\n    enddo\n\nend subroutine intplt3d\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called simp to perform numerical integration using Simpson's rule. The subroutine takes in three parameters: an integer m representing the number of subintervals, a real array f containing the function values, and a real variable s to store the computed integration result. The subroutine also allocates memory for another real array g to perform the integration calculations. The subroutine uses a select case statement to handle different values of m and calculates the integration using Simpson's rule formula. The final result is stored in the variable s.",
            "Give me a Fortran subroutine code called simp that implements Simpson's rule for numerical integration. The subroutine takes in three parameters: an integer parameter called m, representing the number of subintervals to divide the interval into, a real array parameter called f containing the function values at each point, and a real parameter called s which will store the computed integral value. The subroutine also allocates an internal real array called g which is used for computation. The subroutine calculates the integral using Simpson's rule with different formulas based on the value of m. The result is stored in the variable s.",
            "I will provide you with an instruction for a Fortran subroutine called simp. This subroutine calculates the numerical integration using the Simpson's rule for a given array of function values. The subroutine takes 3 parameters as inputs and has no output arguments. The first input parameter is an integer, representing the size of the array. The second input parameter is an array of real numbers. The third input parameter is the integration step size, which determines the width of each subinterval. To use the subroutine, follow these steps:\n\n1. Declare an integer variable to store the size of the array.\n2. Declare a real array to store the function values.\n3. Declare a real variable to store the result of the integration.\n4. Call the simp subroutine, passing the size of the array, the array of function values, and the integration step size as arguments.\n5. After the subroutine call, the result of the integration will be stored in the variable specified in step 3."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8, allocatable :: f(:)\n    real*8 :: s\n    integer :: m, i\n    ! Test case 1\n    m = 3\n    allocate(f(6))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 2\n    m = 2\n    allocate(f(8))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 3\n    m = 4\n    allocate(f(7))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 4\n    m = 6\n    allocate(f(9))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\n    \n    ! Test case 5\n    m = 5\n    allocate(f(10))\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n    call simp(f, s, m)\n    print *, s\n    deallocate(f)\n    print *, \"&\"\nend program main",
            "result": [
                "17.500000000000000",
                "24.000000000000000",
                "12.000000000000000",
                "24.000000000000000",
                "49.500000000000000"
            ]
        },
        "code": "  subroutine simp(f,s,m)\n    implicit none\n    integer,intent(in)  :: m\n    real(8),intent(in)  :: f(:)\n    real(8),intent(out) :: s\n    real(8),allocatable :: g(:)\n    integer :: i,n,nn,nmax\n    n=size(f) ; nmax=int(n/m)*m\n    do i=0,m\n       nmax=nmax+i ; if ( nmax>=n ) exit\n    end do\n    allocate( g(nmax) ) ; g(1:n)=f ; if ( nmax>n ) g(n+1:)=0.d0\n    select case(m)\n    case default\n       s = 0.5d0*(f(1)+f(n)) + sum(f(2:n-1))\n    case(2)\n       s=0.d0\n       do i=1,nmax-2,2\n          s = s + g(i) + 4.d0*g(i+1) + g(i+2)\n       end do\n       s=s/3.d0\n    case(4)\n       s=0.d0\n       do i=1,nmax-4,4\n          s=s+7*g(i)+32*g(i+1)+12*g(i+2)+32*g(i+3)+7*g(i+4)\n       end do\n       s=s*2.d0/45.d0\n    case(6)\n       s=0.d0\n       do i=1,nmax-6,6\n          s=s+41*g(i)+216*g(i+1)+27*g(i+2)+272*g(i+3) &\n               +27*g(i+4)+216*g(i+5)+41*g(i+6)\n       end do\n       s=s/140.d0\n    end select\n    deallocate( g )\n    return\n  end subroutine simp\n",
        "answer": "subroutine simp(m, f, s)\n    integer, intent(in) :: m\n    real, dimension(0:m), intent(in) :: f\n    real :: s\n    real, dimension(:), allocatable :: g\n    integer :: i\n\n    allocate(g(0:m))\n\n    select case(m)\n    case(0)\n        s = 0.0\n    case(1)\n        s = f(0) + f(1)\n    case default\n        s = f(0) + f(m)\n        do i = 1, m-1, 2\n            s = s + 4.0*f(i) + 2.0*f(i+1)\n        end do\n        s = s + 4.0*f(m-1)\n        s = s*h/3.0\n    end select\n\n    deallocate(g)\nend subroutine simp\n\n"
    },
    {
        "instruction": [
            "Please create a Fortran subroutine named \"tria_getneighbourvertex\" that calculates the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes in three input parameters: the vertex number, either ivt1 or ivt2, of one vertex adjacent to the edge, the vertex number of the other vertex adjacent to that edge, and the vertex number of the vertex for which we want to find the neighbor. All input parameters should be of type integer. The subroutine has one output parameter, the vertex number of the neighbor of the input vertex, which is also of type integer.",
            "Write a Fortran subroutine called \"tria_getneighbourvertex\" that calculates the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes three input parameters: \"ivertex\" (an integer representing the vertex number), \"ivt1\" (an integer representing the vertex number of one vertex adjacent to the edge), and \"ivt2\" (an integer representing the vertex number of the other vertex adjacent to the edge). The subroutine has one output parameter: \"ineighbour\" (an integer representing the vertex number of the neighbor vertex). The subroutine should calculate the value of \"ineighbour\" based on the formula: ineighbour = ivt1 + ivt2 - ivertex.",
            "Provide a Fortran subroutine called \"tria_getneighbourvertex\" that calculates the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes in three input parameters: \"ivertex,\" an integer representing the vertex number; \"ivt1,\" an integer representing the vertex number of one vertex adjacent to the edge; and \"ivt2,\" an integer representing the vertex number of the other vertex adjacent to the edge. The subroutine has one output parameter: \"ineighbour,\" an integer representing the vertex number of the neighbor of \"ivertex.\""
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ivertex, ivt1, ivt2, ineighbour\n    ! Test case 1\n    ivertex = 1\n    ivt1 = 2\n    ivt2 = 3\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n\n    ! Test case 2\n    ivertex = 3\n    ivt1 = 5\n    ivt2 = 7\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 3\n    ivertex = 2\n    ivt1 = 9\n    ivt2 = 4\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 4\n    ivertex = 7\n    ivt1 = 10\n    ivt2 = 12\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\n    \n    ! Test case 5\n    ivertex = 1\n    ivt1 = 20\n    ivt2 = 15\n    call tria_getneighbourvertex(ivertex, ivt1, ivt2, ineighbour)\n    print *, ineighbour\n    print *, \"&\"\nend program main",
            "result": [
                "4",
                "9",
                "11",
                "15",
                "34"
            ]
        },
        "code": "  elemental subroutine tria_getneighbourvertex(ivertex,ivt1,ivt2,ineighbour)\n\n!<description>\n  ! calculates the vertex number of the neighbour vertex of a vertex on an\n  ! edge.\n  !\n  ! ivt1 and ivt2 are the vertex numbers of two vertices connected\n  ! by an edge. ivertex is either ivt1 or ivt2.\n  ! the result of this routine is the number of the neighbour vertex\n  ! of ivertex, i.e. if ivertex=ivt1, ineighbour=ivt2 and if\n  ! ivertex=ivt2, ineighbour=ivt1.\n!</description>\n\n!<input>\n  ! vertex number. either ivt1 or ivt2.\n  integer, intent(in) :: ivertex\n\n  ! vertex number of one vertex adjacent to an edge.\n  integer, intent(in) :: ivt1\n\n  ! vertex number of the other vertex adjacent to that edge.\n  integer, intent(in) :: ivt2\n!</input>\n\n!<output>\n  ! vertex number of the neighbour of ivertex.\n  integer, intent(out) :: ineighbour\n!</output>\n\n\n    ! note: directly implementing this formula into the program\n    ! code brings more speed :-)\n    ! but to have a reference not to forget the formula, we have\n    ! this routine...\n\n    ineighbour = ivt1 + ivt2 - ivertex\n\n  end subroutine tria_getneighbourvertex\n",
        "answer": "subroutine tria_getneighbourvertex(ivt1, ivt2, ivt, ivtneighbour)\n    integer, intent(in) :: ivt1, ivt2, ivt\n    integer, intent(out) :: ivtneighbour\n\n    if (ivt == ivt1) then\n        ivtneighbour = ivt2\n    else\n        ivtneighbour = ivt1\n    end if\nend subroutine tria_getneighbourvertex\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called diag3x3 to compute the eigenvalues and eigenvectors of a 3x3 complex matrix. The number of input parameters is 2, both are arrays of type complex. The first argument is the input matrix to be diagonalized. The second argument is an empty array to store the eigenvectors. The number of output arguments is 1, which is an array of type real to store the eigenvalues.",
            "Write a Fortran subroutine called diag3x3 that performs a diagonalization of a 3x3 matrix. The subroutine takes in two input parameters: za, a 3x3 complex matrix, and lambda, a 1-dimensional real array of length 3. It also has one output parameter, zb, a 3x3 complex matrix. \n\nThe subroutine first calculates the eigenvalues of the matrix za and stores them in the lambda array. It then iterates over each eigenvalue and calculates the corresponding eigenvector using the Jacobi method. The eigenvectors are stored in the zb matrix. \n\nThe subroutine uses complex arithmetic and performs various matrix operations to diagonalize the input matrix. It also uses mathematical functions such as square root and trigonometric functions.",
            "Write a Fortran subroutine called diag3x3 that computes the eigenvalues and eigenvectors of a 3x3 complex matrix. The subroutine takes three input parameters: za, a 3x3 complex matrix; zb, an output array to store the eigenvectors; and lambda, an output array to store the eigenvalues. The subroutine also uses the Fortran keywords implicit none to enforce explicit variable declaration. The subroutine computes the eigenvalues and eigenvectors using the diagonalization algorithm. The complex matrix za is diagonalized by subtracting the eigenvalues from the diagonal elements. Then, the subroutine iterates over each eigenvalue and determines the corresponding eigenvector. Finally, the eigenvectors are normalized and stored in the zb array, and the eigenvalues are stored in the lambda array."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex(8) :: za(3,3), zb(3,3)\n    real(8) :: lambda(3)\n    ! Test case 1\n    za = reshape([ (1.0,0.0), (2.0,0.0), (3.0,0.0), &\n                   (4.0,0.0), (5.0,0.0), (6.0,0.0), &\n                   (7.0,0.0), (8.0,0.0), (9.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n\n    ! Test case 2\n    za = reshape([ (1.0,0.0), (0.0,2.0), (0.0,3.0), &\n                   (0.0,4.0), (5.0,0.0), (0.0,6.0), &\n                   (0.0,7.0), (0.0,8.0), (9.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 3\n    za = reshape([ (1.0,2.0), (2.0,3.0), (3.0,4.0), &\n                   (4.0,5.0), (5.0,6.0), (6.0,7.0), &\n                   (7.0,8.0), (8.0,9.0), (9.0,10.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 4\n    za = reshape([ (1.0,1.0), (2.0,2.0), (3.0,3.0), &\n                   (4.0,4.0), (5.0,5.0), (6.0,6.0), &\n                   (7.0,7.0), (8.0,8.0), (9.0,9.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\n    print *, \"&\"\n    \n    ! Test case 5\n    za = reshape([ (1.0,0.0), (0.0,1.0), (0.0,0.0), &\n                   (0.0,0.0), (0.0,1.0), (0.0,0.0), &\n                   (0.0,0.0), (0.0,0.0), (1.0,0.0) ], [3,3])\n    call diag3x3(za, zb, lambda)\n    print *, zb\n    print *, lambda\nend program main",
            "result": [
                "( 0.40962667186957691     ,  0.0000000000000000     ) ( 0.54264864772970856     ,  0.0000000000000000     ) ( 0.73330650809206144     ,  0.0000000000000000     ) ( 0.80238890789373596     ,  0.0000000000000000     ) ( 0.16812656383796734     ,  0.0000000000000000     ) (-0.57263033365438787     , -0.0000000000000000     ) ( 0.43402537965210303     ,  0.0000000000000000     ) (-0.82296166596577036     , -0.0000000000000000     ) ( 0.36654613102403844     ,  0.0000000000000000     )\n   18.830235795506841       -3.1574678406080730      -0.67276795489876073",
                "(-0.12517209412915209     , 0.34653515621389558     ) ( 0.10952558236300809     , 0.52121227265931835     ) ( 0.76196275893017640     ,  0.0000000000000000     ) ( 0.67609728026600180     ,  0.0000000000000000     ) ( 0.34642490457344727     , 0.37896661786495800     ) (-0.19795708832768413     , 0.48997912897695300     ) (-0.59616659337805411     , 0.22742733546355981     ) ( 0.67284173597706110     ,  0.0000000000000000     ) (-0.29808329668902706     , 0.22647857864779952     )\n   17.655861716958530       -6.3151017148784687        3.6592399979199439",
                "( 0.13947815163301430     , 0.36595195406202330     ) ( 0.27295851347756461     , 0.42489449665013257     ) ( 0.76914454374439467     ,  0.0000000000000000     ) ( 0.87353504210425792     ,  0.0000000000000000     ) ( 0.13191815827504771     , 0.10264409584098245     ) (-0.17884989949405666     , 0.42072679112838168     ) ( 0.82659319087957672     ,  0.0000000000000000     ) (-0.16975192835512903     , -9.1653045206760486E-002) ( 0.17049916179951613     , 0.50045752541172228     )\n   26.950081976061885       -12.731180857299655       0.78109888123778382",
                "( 0.18945014374311919     , 0.34801959129372367     ) ( 0.30757220253834183     , 0.41079280937449114     ) ( 0.76134066954510382     ,  0.0000000000000000     ) ( 0.87428249558047888     ,  0.0000000000000000     ) ( 0.11640138688428994     ,  7.0688213013176321E-002) (-0.19545674287675729     , 0.42294287233383770     ) ( 0.83630338537964866     ,  0.0000000000000000     ) (-0.18996721697932903     ,-0.11127747686419090     ) ( 0.11158552846557929     , 0.48956623357362389     )\n   25.114432314033717       -10.493870414289161       0.37943810025545233",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     )\n   1.3333333333333333       0.33333333333333348       0.33333333333333348"
            ]
        },
        "code": "subroutine diag3x3(za,zb,lambda)\n  implicit none\n  real(8),parameter :: pi=4d0*atan(1d0)\n  complex(8), intent(in) :: za(3,3)\n  complex(8), intent(out) :: zb(3,3)\n  real(8), intent(out) :: lambda(3)\n\n  real(8) :: c0,c1,c2\n  real(8) :: p,q,t,ss,phi,xx(3),xx_t(3)\n  complex(8) :: zc(3,3),zx,zy\n  integer :: ivec,imin\n\n  c2 = -real(za(1,1)+za(2,2)+za(3,3))\n  c1 = real( za(1,1)*za(2,2) + za(2,2)*za(3,3) + za(3,3)*za(1,1) &\n       -abs(za(1,2))**2 -abs(za(1,3))**2 -abs(za(2,3))**2 )\n  c0 = real( za(1,1)*abs(za(2,3))**2 + za(2,2)*abs(za(1,3))**2 &\n       + za(3,3)*abs(za(1,2))**2 - za(1,1)*za(2,2)*za(3,3) &\n       - 2d0*conjg(za(1,3))*za(1,2)*za(2,3) )\n\n  p = c2**2 - 3d0*c1\n  q = -27d0*c0/2d0 -c2**3 + 9d0*c2*c1/2d0\n  ss = c1**2*(p-c1)/4d0+c0*(q+27d0*c0/4d0)\n  ss = sqrt(27d0*ss)/q\n  phi = atan(ss)/3d0\n  if(phi < 0)phi = phi + pi\n\n  xx(1) = 2d0*cos(phi)\n  xx(2) = 2d0*cos(phi+2d0*pi/3d0)\n  xx(3) = 2d0*cos(phi-2d0*pi/3d0)\n\n  lambda(:) = (sqrt(p)*xx(:)-c2)/3d0\n\n  do ivec = 1,3\n\n    zc = za\n    zc(1,1) = zc(1,1) -lambda(ivec)\n    zc(2,2) = zc(2,2) -lambda(ivec)\n    zc(3,3) = zc(3,3) -lambda(ivec)\n\n    xx(1) = abs(zc(1,1))\n    xx(2) = abs(zc(2,2))\n    xx(3) = abs(zc(3,3))\n    if(xx(1)<xx(2))then\n      if(xx(1)<xx(3))then\n        imin = 1\n      else\n        imin = 3\n      end if\n    else\n      if(xx(2)<xx(3))then\n        imin=2\n      else\n        imin=3\n      end if\n    end if\n\n    select case(imin)\n    case(1)\n! first vector\n      zx = (conjg(zc(1,3))*zc(2,3) - zc(3,3)*conjg(zc(1,2))) &\n        /(zc(2,2)*zc(3,3)-abs(zc(2,3))**2)\n      zy = -(conjg(zc(1,3)) + conjg(zc(2,3))*zx)/zc(3,3)\n  \n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = ss; zb(2,ivec) = zx*ss; zb(3,ivec) = zy*ss\n    case(2)\n! second vector\n      zx = (conjg(zc(1,3))*zc(1,2) - zc(1,1)*conjg(zc(2,3))) &\n        /(zc(1,1)*zc(3,3)-abs(zc(1,3))**2)\n      zy = -(zc(1,2) + zc(1,3)*zx)/zc(1,1)\n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = zy*ss; zb(2,ivec) = ss; zb(3,ivec) = zx*ss\n    case(3)\n! third vector\n      zx = (zc(1,2)*zc(2,3) - zc(2,2)*zc(1,3)) &\n        /(zc(1,1)*zc(2,2)-abs(zc(1,2))**2)\n      zy = -(zc(2,3) + conjg(zc(1,2))*zx)/zc(2,2)\n      ss = 1d0 + abs(zx)**2 + abs(zy)**2; ss = 1d0/sqrt(ss)\n      zb(1,ivec) = zx*ss; zb(2,ivec) = zy*ss; zb(3,ivec) = ss\n    case default\n      stop \"failed in diag3x3\"\n    end select\n  end do\nend subroutine diag3x3\n",
        "answer": "subroutine diag3x3(a,evec,eval)\n\n    implicit none\n\n    complex(8), intent(in) :: a(3,3)\n    complex(8), intent(out) :: evec(3,3)\n    real(8), intent(out) :: eval(3)\n\n    integer :: i, j, k\n    complex(8) :: z(3,3), w(3,3)\n    real(8) :: r(3,3), theta(3)\n\n    do i = 1, 3\n        do j = 1, 3\n            z(i,j) = a(i,j)\n        end do\n    end do\n\n    do k = 1, 100\n        do i = 1, 3\n            do j = 1, 3\n                w(i,j) = (0.0d0, 0.0d0)\n                do m = 1, 3\n                    w(i,j) = w(i,j) + z(i,m) * z(m,j)\n                end do\n            end do\n        end do\n\n        z = w\n    end do\n\n    do i = 1, 3\n        do j = 1, 3\n            r(i,j) = real(z(i,j))\n        end do\n    end do\n\n    do i = 1, 3\n        eval(i) = sqrt(r(i,i)**2 + r(i,j)**2 + r(i,k)**2)\n    end do\n\n    do i = 1, 3\n        do j = 1, 3\n            evec(i,j) = z(i,j) / eval(i)\n        end do\n    end do\n\nend subroutine diag3x3\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called forward that calculates the solution vector for a given input vector using a finite difference method. The subroutine takes in 5 input parameters: a (velocity), dx (spatial step size), dt (time step size), u0 (initial vector), and an output parameter u (solution vector). All parameters are of type double precision. The subroutine updates the elements of the solution vector u using parallel computation, except for the leftmost element. The subroutine then calculates the value of the leftmost element of u.",
            "Please provide a Fortran subroutine called \"forward\" to update a vector \"u\" based on a given initial vector \"u0\" using the forward difference method. The subroutine requires 5 input parameters: \"u0\" (an array of type real) representing the initial vector, \"u\" (an array of type real) representing the updated vector, \"a\" (a positive real number) representing the velocity, \"dx\" (a real number) representing the spatial step size, and \"dt\" (a real number) representing the time step size. The subroutine does not return any output value.\n\nThe subroutine calculates the updated vector \"u\" by iterating over all elements of \"u0\" except the first element. For each element, it applies the forward difference formula: u(i) = u0(i) - (a * dt / dx) * (u0(i) - u0(i-1)). Finally, it calculates the value of the first element of \"u\" using the same formula. The calculations are performed in parallel using the \"forall\" construct.\n\nPlease implement the \"forward\" subroutine according to these specifications.",
            "Create a Fortran subroutine called forward that calculates the forward difference approximation for a given array. The subroutine takes in 5 input parameters: a (speed), dx (spatial step size), dt (time step size), u0 (initial vector), and an output array u (solution vector). All parameters are of type double precision except for u0 and u which are arrays of double precision. The subroutine performs calculations to update the values of u based on the values of u0 and the given parameters. The subroutine uses a parallel loop (forall) to iterate over the elements of u0, excluding the leftmost element. It calculates the updated values of u based on a mathematical formula and assigns them to the corresponding elements in u. Finally, it calculates the updated value for the leftmost element separately and assigns it to the corresponding element in u."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision, dimension(5) :: u0, u\n    double precision :: a, dx, dt\n    \n    ! Test case 1\n    a = 1.0\n    dx = 0.1\n    dt = 0.01\n    u0 = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 2\n    a = 0.5\n    dx = 0.2\n    dt = 0.001\n    u0 = [0.0, 1.0, 0.0, 1.0, 0.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 3\n    a = 2.0\n    dx = 0.05\n    dt = 0.005\n    u0 = [2.0, 3.0, 4.0, 5.0, 6.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 4\n    a = 1.5\n    dx = 0.1\n    dt = 0.01\n    u0 = [3.0, 2.0, 1.0, 2.0, 3.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \n    ! Test case 5\n    a = 0.8\n    dx = 0.2\n    dt = 0.001\n    u0 = [1.0, 1.0, 1.0, 1.0, 1.0]\n    call forward(u0, u, a, dx, dt)\n    print *, u\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0999999962747098        1.9000000037252902        2.9000000037252902        3.9000000037252902        4.9000000037252907",
                "0.0000000000000000       0.99749999991850924        2.5000000814907239E-003  0.99749999991850924        2.5000000814907239E-003",
                "2.3999999850988392        2.8000000074505804        3.8000000074505804        4.8000000074505804        5.8000000074505804",
                "3.4499999832361938        2.1499999944120645        1.1499999944120647        1.8500000055879353        2.8500000055879355",
                "1.0040000001899898        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "  subroutine forward(u0,u,a,dx,dt)\n\n    ! eingabe:\n    ! u0 = ausgangsvektor\n    ! u = ausgabevektor\n    ! a = geschwindigkeit (>0)\n    ! dx = ortsschrittweite\n    ! dt = zeitschrittweite\n\n    double precision, intent(in)\t\t\t:: a, dx, dt\n    double precision, dimension(:), intent(out)\t\t:: u\n    double precision, dimension(:), intent(in)\t\t:: u0\n    integer\t\t\t\t\t\t:: i,j\n    double precision\t\t\t\t\t:: k1\n\n    ! hilfsvariable\n    k1 = a*dt/dx\n\n    ! berechne den loesungsvektor fuer alle ausser dem linken x (parallel)\n    forall(i=lbound(u0,1)+1:ubound(u0,1))\n       u(i) = u0(i)-k1*(u0(i)-u0(i-1))\n    end forall\n\n    ! berechne den loesungswert fuer das linke x\n    u(lbound(u0,1)) = u0(lbound(u0,1))+k1*u0(lbound(u0,1))\n\n  end subroutine forward\n",
        "answer": "subroutine forward(a, dx, dt, u0, u)\n    double precision, intent(in) :: a, dx, dt\n    double precision, dimension(:), intent(in) :: u0\n    double precision, dimension(size(u0)) :: u\n    integer :: i\n\n    !$omp parallel do private(i)\n    do i = 2, size(u0)\n        u(i) = u0(i) + a * dt / dx * (u0(i-1) - 2*u0(i) + u0(i+1))\n    end do\n    !$omp end parallel do\n\n    u(1) = u0(1) + a * dt / dx * (u0(size(u0)) - 2*u0(1) + u0(2))\nend subroutine forward\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine code called vmflow that calculates the Von Mises flow stress components of a material. The subroutine has three input parameters and one output parameter. The first input parameter is an array of real numbers called \"stress\". The second input parameter is a single real number called \"dsbar\". The third input parameter is an array of real numbers called \"vmfl\". The output parameter is also an array of real numbers called \"vmfl\".",
            "Give me a Fortran subroutine code called vmflow to compute the Von Mises flow values. The number of input parameters is 2, the first parameter is an array of stresses of type real, and the second parameter is a scalar value of type real. The number of output parameters is 1, which is also an array of Von Mises flow values of type real.",
            "Write a Fortran subroutine called vmflow that calculates the Von Mises flow stress components based on the given stress components and strain rate. The subroutine takes 2 input parameters: stress, which is a real array, and dsbar, which is a real value. The stress array contains the stress components, and dsbar represents the strain rate. The subroutine also has 1 output parameter: vmfl, which is a real array. The vmfl array stores the Von Mises flow stress components calculated by the subroutine."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n = 4\n    real*8 :: stress(4), dsbar, vmfl(4)\n    \n    ! Test case 1\n    stress = [1.0, 2.0, 3.0, 4.0]\n    dsbar = 2.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 2\n    stress = [5.0, 6.0, 7.0, 8.0]\n    dsbar = 1.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 3\n    stress = [0.0, 0.0, 0.0, 0.0]\n    dsbar = 0.5\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 4\n    stress = [10.0, 20.0, 30.0, 40.0]\n    dsbar = 5.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \n    ! Test case 5\n    stress = [4.0, 3.0, 2.0, 1.0]\n    dsbar = 3.0\n    call vmflow(stress, dsbar, vmfl)\n    print *, vmfl\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-1.0000000000000000      -0.25000000000000011        4.5000000000000000        1.2500000000000000",
                "-1.9999999999999996      -0.49999999999999956        21.000000000000000        2.5000000000000004",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-4.0000000000000000      -0.99999999999999967        18.000000000000000        5.0000000000000000",
                "0.66666666666666663       0.16666666666666674        2.0000000000000000      -0.83333333333333337"
            ]
        },
        "code": "subroutine vmflow(stress,dsbar,vmfl)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::stress(:),dsbar\n real(iwp),intent(out)::vmfl(:)\n real(iwp)::sigm,onept5=1.5_iwp,two=2.0_iwp,d3=3.0_iwp\n sigm=(stress(1)+stress(2)+stress(4))/d3\n vmfl(1)=stress(1)-sigm\n vmfl(2)=stress(2)-sigm\n vmfl(3)=stress(3)*two \n vmfl(4)=stress(4)-sigm\n vmfl=vmfl*onept5/dsbar\nreturn\nend subroutine vmflow\n",
        "answer": "subroutine vmflow(stress,dsbar,vmfl)\n\n    implicit none\n\n    real, intent(in) :: stress(3), dsbar\n    real, intent(out) :: vmfl(3)\n\n    real :: dev(3), dev2, dev3, dev4, dev5, dev6\n\n    dev(1) = stress(1) - stress(2)\n    dev(2) = stress(2) - stress(3)\n    dev(3) = stress(3) - stress(1)\n\n    dev2 = dev(1)**2 + dev(2)**2 + dev(3)**2\n    dev3 = sqrt(dev2)\n    dev4 = dev(1)*dev(2) + dev(2)*dev(3) + dev(3)*dev(1)\n    dev5 = dev(1)**2 - dev(2)**2 + dev(3)**2\n    dev6 = dev(2)**2 - dev(3)**2 + dev(1)**2\n\n    vmfl(1) = stress(1) + 2.0*dsbar*dev(1)/dev3\n    vmfl(2) = stress(2) + 2.0*dsbar*dev(2)/dev3\n    vmfl(3) = stress(3) + 2.0*dsbar*dev(3)/dev3\n\n    if (dev3 > 1.0e-10) then\n        vmfl(1) = vmfl(1) + 2.0*dsbar*(dev4*dev(1) - dev5)/(3.0*dev3**2)\n        vmfl(2) = vmfl(2) + 2.0*dsbar*(dev4*dev(2) - dev6)/(3.0*dev3**2)\n        vmfl(3) = vmfl(3) + 2.0*dsbar*(dev4*dev(3) - dev5)/(3.0*dev3**2)\n    end if\n\nend subroutine vmflow\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine named transpose2_d that performs a transpose operation on a 2-dimensional matrix. The subroutine takes in 4 input parameters and 2 output parameters. The first input parameter is an integer m, representing the number of rows in the matrix. The second input parameter is an integer n, representing the number of columns in the matrix. The third and fourth input parameters, mtx and mtxd, are 2-dimensional arrays of real numbers with dimensions (m, n). The output parameters, new_mtx and new_mtxd, are also 2-dimensional arrays of real numbers with dimensions (n, m). \n\nIn the subroutine, the transpose operation is performed by iterating over each element of the input matrices and assigning the corresponding element to the transposed position in the output matrices. The resulting transposed matrices are stored in the new_mtx and new_mtxd arrays, respectively.",
            "Write a Fortran subroutine called transpose2_d to transpose a 2-dimensional matrix. The subroutine has 5 input parameters and 2 output parameters. The first input parameter is an integer m representing the number of rows in the matrix. The second input parameter is an integer n representing the number of columns in the matrix. The third input parameter is a 2-dimensional real matrix mtx of size m x n. The fourth input parameter is another 2-dimensional real matrix mtxd of size m x n. The fifth output parameter is a 2-dimensional real matrix new_mtx of size n x m. The sixth output parameter is another 2-dimensional real matrix new_mtxd of size n x m. The subroutine transposes the elements of mtx and mtxd matrices and stores the transposed matrices in new_mtx and new_mtxd, respectively. Each element in new_mtx and new_mtxd is the corresponding element from mtx and mtxd after transposing the rows and columns.",
            "Give me a Fortran subroutine code called transpose2_d to transpose a 2-dimensional matrix. The number of input parameters is 4. The first parameter is the number of rows in the original matrix, the second parameter is the number of columns in the original matrix, both parameters are of type integer. The third and fourth parameters are the original matrix and its derivative, both of type real. The number of output parameters is also 2. The first output parameter is the transposed matrix, and the second output parameter is the transposed derivative matrix, both of type real."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 3\n    integer, parameter :: n = 2\n    real(kind=8) :: mtx(m, n)\n    real(kind=8) :: mtxd(m, n)\n    real(kind=8) :: new_mtx(n, m)\n    real(kind=8) :: new_mtxd(n, m)\n    \n    ! Test case 1\n    mtx = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [m, n])\n    mtxd = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 2\n    mtx = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0], [m, n])\n    mtxd = reshape([0.2, 0.4, 0.6, 0.8, 1.0, 1.2], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 3\n    mtx = reshape([3.0, 6.0, 9.0, 12.0, 15.0, 18.0], [m, n])\n    mtxd = reshape([0.3, 0.6, 0.9, 1.2, 1.5, 1.8], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 4\n    mtx = reshape([4.0, 8.0, 12.0, 16.0, 20.0, 24.0], [m, n])\n    mtxd = reshape([0.4, 0.8, 1.2, 1.6, 2.0, 2.4], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \n    ! Test case 5\n    mtx = reshape([5.0, 10.0, 15.0, 20.0, 25.0, 30.0], [m, n])\n    mtxd = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], [m, n])\n    call transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    print *, new_mtx\n    print *, new_mtxd\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000        4.0000000000000000        2.0000000000000000        5.0000000000000000        3.0000000000000000        6.0000000000000000     \n  0.10000000149011612       0.40000000596046448       0.20000000298023224       0.50000000000000000       0.30000001192092896       0.60000002384185791",
                "2.0000000000000000        8.0000000000000000        4.0000000000000000        10.000000000000000        6.0000000000000000        12.000000000000000     \n  0.20000000298023224       0.80000001192092896       0.40000000596046448        1.0000000000000000       0.60000002384185791        1.2000000476837158",
                "3.0000000000000000        12.000000000000000        6.0000000000000000        15.000000000000000        9.0000000000000000        18.000000000000000     \n  0.30000001192092896        1.2000000476837158       0.60000002384185791        1.5000000000000000       0.89999997615814209        1.7999999523162842",
                "4.0000000000000000        16.000000000000000        8.0000000000000000        20.000000000000000        12.000000000000000        24.000000000000000     \n  0.40000000596046448        1.6000000238418579       0.80000001192092896        2.0000000000000000        1.2000000476837158        2.4000000953674316",
                "5.0000000000000000        20.000000000000000        10.000000000000000        25.000000000000000        15.000000000000000        30.000000000000000     \n  0.50000000000000000        2.0000000000000000        1.0000000000000000        2.5000000000000000        1.5000000000000000        3.0000000000000000"
            ]
        },
        "code": "  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(in) :: mtxd(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    real(kind=8), intent(out) :: new_mtxd(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtxd(j, i) = mtxd(i, j)\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2_d\n",
        "answer": "subroutine transpose2_d(m, n, mtx, mtxd)\n    integer, intent(in) :: m, n\n    real, dimension(m,n), intent(in) :: mtx\n    real, dimension(n,m), intent(out) :: mtxd\n    integer :: i, j\n\n    do i = 1, m\n        do j = 1, n\n            mtxd(j,i) = mtx(i,j)\n        end do\n    end do\n\nend subroutine transpose2_d\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called matmul2_d that performs matrix multiplication. The subroutine takes in 7 input parameters and 2 output parameters. The first three input parameters are integers representing the dimensions of the matrices. The next two input parameters are 2D arrays of type real, representing matrices A and B. The following two input parameters are also 2D arrays of type real, representing matrices AD and BD. The last two parameters are 2D arrays of type real, representing matrices C and CD, which are the output matrices. \n\nThe subroutine initializes matrices C and CD with zeros. Then, it performs matrix multiplication by multiplying corresponding elements of matrices AD and B, and adding them to CD. Similarly, it multiplies corresponding elements of matrices A and BD, and adds them to CD. Finally, it multiplies corresponding elements of matrices A and B, and adds them to C.\n\nImplement the subroutine according to these instructions.",
            "Give me a Fortran subroutine code called matmul2_d to perform matrix multiplication. The subroutine takes in six input parameters and two output parameters. The input parameters are:\n- m: an integer representing the number of rows in matrix A and matrix C\n- n: an integer representing the number of columns in matrix A and the number of rows in matrix B\n- p: an integer representing the number of columns in matrix B and matrix C\n- a: a 2D array of type real, representing the matrix A\n- ad: a 2D array of type real, representing another matrix A\n- b: a 2D array of type real, representing the matrix B\n- bd: a 2D array of type real, representing another matrix B\n\nThe two output parameters are:\n- c: a 2D array of type real, representing the matrix C\n- cd: a 2D array of type real, representing another matrix C\n\nTo calculate the matrix multiplication, the subroutine initializes the matrices C and Cd to zero. Then, it performs a nested loop to calculate the values of Cd using the matrices Ad, B, A, and Bd. Additionally, it calculates the values of C using the matrices A and B.\n\nTo use this subroutine, you need to call it and provide the appropriate input parameters. The resulting matrices C and Cd will be updated with the respective calculations.",
            "Provide a Fortran subroutine code called matmul2_d to perform matrix multiplication. The subroutine takes 8 input parameters: m, n, and p of type integer, representing the dimensions of the matrices; a and b of type real arrays with dimensions (m, n) and (n, p) respectively; ad and bd of type real arrays with the same dimensions as a and b respectively. There are also 2 output parameters: c and cd of type real arrays with dimensions (m, p). \n\nThe subroutine initializes c and cd to zero. It then performs the matrix multiplication by iterating through the rows and columns of the matrices, calculating the dot product of corresponding row and column elements using both a and ad, as well as b and bd. The results are stored in the corresponding elements of cd and c. \n\nTo use this subroutine, call it by providing the appropriate input parameters and ensure that matrices a, b, ad, and bd have been initialized before the subroutine call. The resulting matrix multiplication will be stored in c and cd."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: m = 3, n = 2, p = 4\n    real(kind=8) :: a(m, n), ad(m, n), b(n, p), bd(n, p), c(m, p), cd(m, p)\n    \n    ! Test case 1\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 2\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0., 0., 0., 0., 0., 0.], [m, n])\n    b = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8], [n, p])\n    bd = reshape([0., 0., 0., 0., 0., 0., 0., 0.], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 3\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([1., 0., 0., 1., 1., 0., 0., 1.], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 4\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], [n, p])\n    bd = reshape([0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\n    print *, \"&\"\n    \n    ! Test case 5\n    a = reshape([1., 2., 3., 4., 5., 6.], [m, n])\n    ad = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6], [m, n])\n    b = reshape([1., 2., 3., 4., 5., 6., 7., 8.], [n, p])\n    bd = reshape([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08], [n, p])\n    call matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    print *, c\n    print *, cd\nend program main",
            "result": [
                "0.90000001341104507        1.2000000178813934        1.5000000223517418        1.9000000357627869        2.6000000536441803        3.3000000715255737        2.9000000953674316        4.0000001192092896        5.1000001430511475        3.9000000357627869        5.4000000357627869        6.9000000357627869     \n  0.18000000067055227       0.23999999940395356       0.30000000484287748       0.38000000216066843       0.52000000044703487       0.66000001288950472       0.58000000923872008       0.80000000819563866        1.0200000287592417       0.78000000253319746        1.0799999973177909        1.3800000211596490",
                "0.90000001341104507        1.2000000178813934        1.5000000223517418        1.9000000357627869        2.6000000536441803        3.3000000715255737        2.9000000953674316        4.0000001192092896        5.1000001430511475        3.9000000357627869        5.4000000357627869        6.9000000357627869     \n   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000        1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000     \n  0.18999999947845936       0.32000000029802322       0.45000000856816769       0.59000000171363354       0.75999999418854713       0.93000001646578312       0.38999999687075615       0.59999999776482582       0.81000000610947609       0.78999999910593033        1.0399999916553497        1.2900000140070915",
                "2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000     \n  0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597       0.50000000745058060       0.70000000670552254       0.90000002458691597",
                "9.0000000000000000        12.000000000000000        15.000000000000000        19.000000000000000        26.000000000000000        33.000000000000000        29.000000000000000        40.000000000000000        51.000000000000000        39.000000000000000        54.000000000000000        69.000000000000000     \n  0.99000001139938831        1.3200000002980232        1.6500000562518835        2.0900000240653753        2.8600000031292439        3.6300001237541437        3.1900000385940075        4.4000000096857548        5.6100001968443394        4.2900000512599945        5.9400000125169754        7.5900002643465996"
            ]
        },
        "code": "  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(in) :: ad(m, n), bd(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    real(kind=8), intent(out) :: cd(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    cd = 0.0_8\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2_d\n",
        "answer": "subroutine matmul2_d(a, ad, b, bd, c, cd, m, n, p)\n    integer, intent(in) :: m, n, p\n    real, dimension(m,n), intent(in) :: a, ad\n    real, dimension(n,p), intent(in) :: b, bd\n    real, dimension(m,p), intent(out) :: c, cd\n    integer :: i, j, k\n\n    ! initialize c and cd\n    c = 0.0\n    cd = 0.0\n\n    ! perform matrix multiplication\n    do i = 1, m\n        do j = 1, p\n            do k = 1, n\n                cd(i,j) = cd(i,j) + ad(i,k) * bd(k,j)\n            end do\n        end do\n    end do\n\n    do i = 1, m\n        do j = 1, p\n            do k = 1, n\n                c(i,j) = c(i,j) + a(i,k) * b(k,j)\n            end do\n        end do\n    end do\n\nend subroutine matmul2_d\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called dot that calculates the dot product of two 3D arrays. The subroutine takes three parameters: two input arrays of real numbers, a and b, and one output parameter, dot_prod, which is also a real number. The input arrays, a and b, are of size 3. The subroutine calculates the dot product by multiplying corresponding elements of the arrays and summing them up. The result is stored in the output parameter, dot_prod.",
            "Write a Fortran subroutine called \"dot\" that calculates the dot product of two 3-dimensional arrays. The subroutine takes in two input parameters: \"a\" and \"b\", both of type real(kind=8), representing the two arrays. It also has one output parameter called \"dot_prod\" of type real(kind=8), which stores the computed dot product.",
            "Provide a Fortran subroutine code called \"dot\" that calculates the dot product of two arrays. The subroutine takes in three parameters. The first two parameters, \"a\" and \"b\", are arrays of type real with a size of 3. These arrays represent the vectors whose dot product needs to be computed. The third parameter, \"dot_prod\", is a single real value used to store the result of the dot product calculation. This parameter is passed by reference and will hold the computed dot product value after the subroutine is executed."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: vec1(3), vec2(3), result\n    ! Test case 1\n    vec1 = [1.0, 2.0, 3.0]\n    vec2 = [4.0, 5.0, 6.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    vec1 = [0.5, 0.5, 0.5]\n    vec2 = [1.0, 2.0, 3.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    vec1 = [0.0, 1.0, 0.0]\n    vec2 = [1.0, 0.0, 0.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    vec1 = [2.0, -3.0, 1.0]\n    vec2 = [-1.0, 4.0, -2.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    vec1 = [1.0, 0.0, 0.0]\n    vec2 = [0.0, 1.0, 0.0]\n    call dot(vec1, vec2, result)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "32.000000000000000",
                "3.0000000000000000",
                "0.0000000000000000",
                "-16.000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "  subroutine dot(a, b, dot_prod)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: dot_prod\n    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  end subroutine dot\n",
        "answer": "subroutine dot(a, b, dot_prod)\n    real, dimension(3) :: a, b\n    real :: dot_prod\n    integer :: i\n\n    dot_prod = 0.0\n    do i = 1, 3\n        dot_prod = dot_prod + a(i) * b(i)\n    end do\nend subroutine dot\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine code called cross_d that calculates the cross product of two 3-dimensional vectors. The subroutine takes in 4 input parameters and 2 output parameters. The input parameters are:\n1. a - an array of real numbers representing the first vector,\n2. ad - an array of real numbers representing the derivatives of the first vector,\n3. b - an array of real numbers representing the second vector, and\n4. bd - an array of real numbers representing the derivatives of the second vector.\n\nThe output parameters are:\n1. c - an array of real numbers representing the resulting cross product vector, and\n2. cd - an array of real numbers representing the derivatives of the resulting cross product vector.\n\nThe subroutine uses double precision (kind=8) for real numbers.",
            "Write a Fortran subroutine called cross_d that computes the cross product of two 3D vectors. The subroutine takes in 4 input parameters and 2 output parameters, all of type real(kind=8). The input parameters are:\n- a: a 3D vector\n- ad: the derivative of vector a\n- b: another 3D vector\n- bd: the derivative of vector b\n\nThe output parameters are:\n- c: the resulting cross product vector\n- cd: the derivative of vector c\n\nThe subroutine uses the formula to compute the cross product and its derivative. \n\nWrite the Fortran code for the subroutine cross_d to perform these calculations.",
            "Write a Fortran subroutine called cross_d to compute the cross product of two vectors. The subroutine takes in six input parameters: a vector a and its derivative ad, a vector b and its derivative bd. All vectors have three elements and are of type real. The subroutine also has two output parameters: a vector c which stores the result of the cross product, and its derivative cd. Both c and cd are of type real and have three elements. The subroutine applies the cross product formula to calculate the values of c and cd based on the input vectors and their derivatives."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: a(3), b(3), ad(3), bd(3), c(3), cd(3)\n    \n    ! Test case 1\n    a = [1.0, 2.0, 3.0]\n    b = [4.0, 5.0, 6.0]\n    ad = [7.0, 8.0, 9.0]\n    bd = [10.0, 11.0, 12.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    a = [0.5, 0.5, 0.5]\n    b = [1.0, 1.0, 1.0]\n    ad = [2.0, 2.0, 2.0]\n    bd = [3.0, 3.0, 3.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    a = [-1.0, 2.0, -3.0]\n    b = [4.0, -5.0, 6.0]\n    ad = [7.0, -8.0, 9.0]\n    bd = [-10.0, 11.0, -12.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    a = [0.0, 0.0, 0.0]\n    b = [1.0, 1.0, 1.0]\n    ad = [2.0, 2.0, 2.0]\n    bd = [3.0, 3.0, 3.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    a = [1.0, 1.0, 1.0]\n    b = [1.0, 1.0, 1.0]\n    ad = [1.0, 1.0, 1.0]\n    bd = [1.0, 1.0, 1.0]\n    call cross_d(a, ad, b, bd, c, cd)\n    print *, c(1), c(2), c(3), cd(1), cd(2), cd(3)\nend program main",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000       -6.0000000000000000        12.000000000000000       -6.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-3.0000000000000000       -6.0000000000000000       -3.0000000000000000        6.0000000000000000        12.000000000000000        6.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine cross_d(a, ad, b, bd, c, cd)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(in) :: ad(3), bd(3)\n    real(kind=8), intent(out) :: c(3)\n    real(kind=8), intent(out) :: cd(3)\n    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n  end subroutine cross_d\n",
        "answer": "subroutine cross_d(a, ad, b, bd, c, cd)\n\n    implicit none\n\n    real(kind=8), intent(in) :: a(3), ad(3), b(3), bd(3)\n    real(kind=8), intent(out) :: c(3), cd(3)\n\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n\n    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)\n    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)\n    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)\n\nend subroutine cross_d\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine code called sparin_gauss. The subroutine performs Gaussian elimination on a sparse matrix represented by an array. It has two input parameters: kdiag, which is an integer array representing the diagonal positions of the sparse matrix, and kv, which is a real array representing the values of the sparse matrix. The subroutine also has no output parameters.\n\nTo understand the subroutine, it iterates over the diagonal positions of the sparse matrix and performs Gaussian elimination by dividing each element in the lower triangular part of the matrix by the corresponding diagonal element. It then subtracts the product of the divided element and the corresponding element in the upper triangular part from the corresponding element in the lower triangular part of the matrix.\n\nThe subroutine uses nested do-loops to perform the Gaussian elimination process. The subroutine ends with a return statement.",
            "Please write a Fortran subroutine called \"sparin_gauss\" to perform Gaussian elimination on a sparse matrix. The subroutine has two input parameters. The first parameter, \"kdiag,\" is an integer array that represents the diagonal positions of the nonzero elements in the matrix. The second parameter, \"kv,\" is a real array that stores the values of the nonzero elements. The subroutine also has no output parameters.\nTo implement the Gaussian elimination, the subroutine iterates over the elements of the \"kdiag\" array and performs row operations to eliminate the elements below the diagonal. The subroutine uses the \"num\" and \"den\" variables to store temporary values during the calculations. The subroutine accomplishes the elimination process by updating the \"kv\" array based on the calculated factors.\nPlease note that the subroutine uses the \"selected_real_kind\" function to determine the precision of the real numbers.",
            "Write a Fortran subroutine called sparin_gauss that performs Gaussian elimination on a sparse matrix stored in compressed format. The subroutine takes two input parameters: kdiag, an integer array representing the diagonal indices of the matrix, and kv, a real array storing the non-zero values of the matrix. The subroutine has no output parameters.\n\nHere are the steps to follow:\n1. Declare local variables using the selected_real_kind(15) to ensure the precision of real numbers.\n2. Iterate through the array kdiag from the first element to the second-to-last element.\n3. Inside the loop, assign the value of kv(kdiag(j)) to the variable den.\n4. Initialize the variable ii to 0.\n5. Iterate through the remaining elements of kdiag starting from j+1 to the last element.\n6. Inside the nested loop, increment ii by 1.\n7. Calculate the index l as kdiag(i) - ii.\n8. Check if l - kdiag(i-1) is greater than zero.\n9. If it is, assign the value of kv(l) to the variable num and calculate the ratio fac = num/den.\n10. Initialize the variable kk to -1.\n11. Iterate through the range k from i to the last element of kdiag.\n12. Inside the nested loop, increment kk by 1.\n13. Calculate the indices l1, l2, and l3 using the values from kdiag and kk.\n14. Check if l2 - l3 is greater than zero.\n15. If it is, subtract fac multiplied by kv(l2) from kv(l1).\n16. End the nested loop.\n17. End the outer loop.\n18. Return from the subroutine.\n\nMake sure to use the correct data types and order of arguments when calling the subroutine sparin_gauss."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: iwp = selected_real_kind(15)\n    real(iwp) :: kv(6), result(6)\n    integer :: kdiag(6)\n    \n    ! Test case 1\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 2.0_iwp, 3.0_iwp, 4.0_iwp, 5.0_iwp, 6.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 2\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [6.0_iwp, 5.0_iwp, 4.0_iwp, 3.0_iwp, 2.0_iwp, 1.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 2.0_iwp, 1.0_iwp, 2.0_iwp, 1.0_iwp, 2.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp, 1.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    kdiag = [1, 2, 3, 4, 5, 6]\n    kv = [0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp, 0.0_iwp]\n    call sparin_gauss(kv, kdiag)\n    result = kv\n    print *, result\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "6.0000000000000000        5.0000000000000000        4.0000000000000000        3.0000000000000000        2.0000000000000000        1.0000000000000000",
                "1.0000000000000000        2.0000000000000000        1.0000000000000000        2.0000000000000000        1.0000000000000000        2.0000000000000000",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine sparin_gauss(kv,kdiag)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n integer,intent(in)::kdiag(:)\n real(iwp),intent(out)::kv(:)\n real(iwp)::num,den,fac,zero=0.0_iwp\n integer::n,ii,i,j,k,l,kk,l1,l2,l3\n n=ubound(kdiag,1)\n do j=1,n-1\n   den=kv(kdiag(j))\n   ii=0                 \n   do i=j+1,n\n     ii=ii+1\n     l=kdiag(i)-ii\n     if(l-kdiag(i-1)>zero)then\n       num=kv(l)\n       fac=num/den\n       kk=-1\n       do k=i,n\n         kk=kk+1\n         l1=kdiag(i+kk)-kk\n         l2=l1-ii\n         l3=kdiag(i+kk-1)\n         if(l2-l3>zero)kv(l1)=kv(l1)-fac*kv(l2)\n       end do \n     end if\n   end do\n end do\nreturn\nend subroutine sparin_gauss\n",
        "answer": "subroutine sparin_gauss(kdiag,kv)\n\n    implicit none\n\n    integer, intent(in) :: kdiag(:)\n    real, intent(inout) :: kv(:)\n\n    integer :: i, j, k\n    real :: temp\n\n    do i = 1, size(kdiag)\n        do j = kdiag(i)+1, size(kdiag)\n            temp = kv(j) / kv(kdiag(i))\n            do k = kdiag(i)+1, size(kdiag)\n                kv(k) = kv(k) - temp * kv(kdiag(j))\n            end do\n        end do\n    end do\n\n    return\n\nend subroutine sparin_gauss\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called getptonline. This subroutine calculates the intersection point between a line and a given distance ratio along that line. The number of input parameters is 3. The first parameter is an array of 2 real numbers representing the direction of the line. The second parameter is also an array of 2 real numbers representing another point on the line. The third parameter is a real number representing the distance ratio along the line. The number of output parameters is 1. The output parameter is an array of 2 real numbers representing the computed intersection point.",
            "Write a Fortran subroutine called getptonline that calculates the intersection point between a line segment and a line. The subroutine has two input parameters and one output parameter. The first input parameter, rp1, is an array of two real values representing the coordinates of the starting point of the line segment. The second input parameter, rp2, is an array of two real values representing the coordinates of the ending point of the line segment. The third input parameter, distratio, is a real value representing the ratio of the distance from rp1 to the intersection point with respect to the line segment distance. The output parameter, rptc, is an array of two real values representing the coordinates of the intersection point.",
            "Create a Fortran subroutine called getptonline that calculates the intersection point between two lines. The subroutine takes in 3 input parameters: rp1 and rp2, both arrays of type real*8 with size 2, representing the direction of the lines, and distratio, a real*8 value representing the distance ratio along the lines. The subroutine also has 1 output parameter, rptc, an array of type real*8 with size 2, representing the computed intersection point. \n\nTo calculate the intersection point, subtract rp1 from rp2 and store the result in v21. Then, multiply distratio with v21 and add the result to rp1. Finally, assign the calculated value to rptc."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: rp1(2), rp2(2), distratio, rptc(2)\n    \n    ! Test case 1\n    rp1 = [1.0, 2.0]\n    rp2 = [3.0, 4.0]\n    distratio = 0.5\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 2\n    rp1 = [0.0, 0.0]\n    rp2 = [1.0, 1.0]\n    distratio = 0.25\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    rp1 = [-2.0, 3.0]\n    rp2 = [4.0, 1.0]\n    distratio = 0.75\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    rp1 = [10.0, -5.0]\n    rp2 = [20.0, -10.0]\n    distratio = 0.1\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    rp1 = [-1.0, -1.0]\n    rp2 = [1.0, 1.0]\n    distratio = 0.5\n    call getptonline(rp1, rp2, distratio, rptc)\n    print *, rptc(1), rptc(2)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.0000000000000000        3.0000000000000000",
                "0.25000000000000000       0.25000000000000000",
                "2.5000000000000000        1.5000000000000000",
                "11.000000014901161       -5.5000000074505806",
                "0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "    subroutine getptonline(rp1,rp2,distratio,rptc)\n        implicit none\n        real*8 , intent(in)::rp1(2),rp2(2),distratio !- input line direction\n        real*8 , intent(out)::rptc(2) !-output points\n        real*8 ::v21(2) !- output intersection point\n\n        v21=rp2-rp1\n        rptc=rp1+distratio*v21\n\n    end subroutine getptonline\n",
        "answer": "subroutine getptonline(line, point, ratio, pt)\n\n    implicit none\n\n    real, intent(in) :: line(2), point(2), ratio\n    real :: pt(2)\n\n    pt = point + ratio * (line - point)\n\n  end subroutine getptonline\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called quat2eul to convert a quaternion representation to Euler angles. The subroutine takes two input parameters: \n- The first parameter is an array of four real numbers representing the quaternion, specified as q(4).\n- The second parameter is an array of three real numbers representing the Euler angles, specified as eul(3).\n\nThe subroutine computes the Euler angles using the formulas:\n- eul(1) = atan2(2.0*(q(4)*q(3) + q(1)*q(2)), 1.0 - 2.0*(q(2)**2 + q(3)**2))\n- eul(2) = asin(2.0*(q(4)*q(2) - q(3)*q(1)))\n- eul(3) = atan2(2.0*(q(4)*q(1) + q(2)*q(3)), 1.0 - 2.0*(q(1)**2 + q(2)**2))\n\nThe subroutine then assigns these computed values to the elements of the eul array.\n\nRemember to use the \"real\" and \"intent\" keywords to specify the types and intentions of the input and output parameters respectively.",
            "Provide a Fortran subroutine called quat2eul that converts a quaternion to Euler angles. The subroutine takes in 4 input parameters, an array q of type real, representing the quaternion. It also has 3 output parameters, an array eul of type real, representing the Euler angles. \n\nTo convert the quaternion to Euler angles, compute the three angles using the following formulas:\n- eul(1) = atan2(2*(q(4)*q(3) + q(1)*q(2)), 1 - 2*(q(2)**2 + q(3)**2))\n- eul(2) = asin(2*(q(4)*q(2) - q(3)*q(1)))\n- eul(3) = atan2(2*(q(4)*q(1) + q(2)*q(3)), 1 - 2*(q(1)**2 + q(2)**2))\n\nImplement this subroutine and ensure that the computed Euler angles are stored in the eul array as output.",
            "Write a Fortran subroutine called quat2eul to convert a quaternion to Euler angles. The subroutine takes two input parameters: \n- q, an array of 4 real numbers representing the quaternion.\n- eul, an array of 3 real numbers where the Euler angles will be stored.\n\nThe subroutine computes the Euler angles using the formulas: \n- eul(1) = atan2(2*(q(4)*q(3) + q(1)*q(2)), 1 - 2*(q(2)**2 + q(3)**2))\n- eul(2) = asin(2*(q(4)*q(2) - q(3)*q(1)))\n- eul(3) = atan2(2*(q(4)*q(1) + q(2)*q(3)), 1 - 2*(q(1)**2 + q(2)**2))\n\nThe computed Euler angles are then stored in the eul array."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: quat(4), eul(3)\n    \n    ! Test case 1\n    quat = [0.707, 0.0, 0.707, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    quat = [0.5, 0.5, 0.5, 0.5]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    quat = [0.866, 0.0, 0.5, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    quat = [0.0, 0.0, 1.0, 0.0]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    quat = [0.0, 0.707, 0.0, 0.707]\n    call quat2eul(quat, eul)\n    print *, eul(1), eul(2), eul(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.00000000      -1.54622102       0.00000000",
                "1.57079637       0.00000000       1.57079637",
                "0.00000000      -1.04714680       3.14159274",
                "3.14159274       0.00000000       0.00000000",
                "0.00000000       1.54622102       0.00000000"
            ]
        },
        "code": "subroutine quat2eul(q,eul) \nreal, intent(in):: q(4)\nreal, intent(out):: eul(3)\neul(1) = atan2(2.*(q(4)*q(3)+q(1)*q(2)), &\n\t1.-2.*(q(2)**2.+q(3)**2.))\neul(2) = asin(2.*(q(4)*q(2)-q(3)*q(1)))\neul(3) = atan2(2.*(q(4)*q(1)+q(2)*q(3)), &\n\t1.-2.*(q(1)**2.+q(2)**2.))\nend subroutine quat2eul\n",
        "answer": "subroutine quat2eul(q, eul)\n    real, intent(in) :: q(4)\n    real, intent(out) :: eul(3)\n\n    eul(1) = atan2(2.0*(q(4)*q(3) + q(1)*q(2)), 1.0 - 2.0*(q(2)**2 + q(3)**2))\n    eul(2) = asin(2.0*(q(4)*q(2) - q(3)*q(1)))\n    eul(3) = atan2(2.0*(q(4)*q(1) + q(2)*q(3)), 1.0 - 2.0*(q(1)**2 + q(2)**2))\n\nend subroutine quat2eul\n\n"
    },
    {
        "instruction": [
            "Please provide me with a Fortran subroutine code named \"maxi\" to compute the maximum value in a given vector. The subroutine takes in three parameters. The first parameter is an integer called \"vect_len\" which specifies the length of the input vector. The second parameter is a real array called \"vect\" of length \"vect_len\" containing the actual vector values. The third parameter is a real variable called \"mm\" which is used to deliver the result, i.e., the maximum value of the vector. The subroutine calculates the maximum value using the \"maxval\" function in Fortran and assigns it to the \"mm\" variable.",
            "Write a Fortran subroutine called \"maxi\" that computes the maximum value of a given vector. The subroutine requires 2 input parameters: an integer called \"vect_len\" representing the length of the input vector, and a real array called \"vect\" containing the actual vector. It also has 1 output parameter, a real called \"mm\", which will store the maximum value of the vector. \n\nTo use the subroutine, provide the length of the vector and the vector itself as input arguments, and the subroutine will return the maximum value in the \"mm\" parameter.",
            "Create a Fortran subroutine called \"maxi\" that computes the maximum value of a given vector. The subroutine has 3 parameters: the length of the input vector, an array of real numbers, and the maximum value. The length of the vector is an input parameter of type integer. The vector itself is an input parameter of type real and has a dimension specified by the length parameter. The maximum value is an output parameter of type real. The subroutine calculates the maximum value of the vector using the \"maxval\" function and assigns it to the output parameter."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: vect_len\n    real*8, dimension(:), allocatable :: vect\n    real*8 :: mm\n    ! Test case 1\n    vect_len = 5\n    allocate(vect(vect_len))\n    vect = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n\n    ! Test case 2\n    vect_len = 3\n    allocate(vect(vect_len))\n    vect = [0.5, 0.2, 0.8]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 3\n    vect_len = 7\n    allocate(vect(vect_len))\n    vect = [10.0, 5.0, 8.0, 3.0, 9.0, 2.0, 7.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 4\n    vect_len = 4\n    allocate(vect(vect_len))\n    vect = [0.1, 0.3, 0.2, 0.4]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\n    \n    ! Test case 5\n    vect_len = 6\n    allocate(vect(vect_len))\n    vect = [100.0, 50.0, 80.0, 30.0, 90.0, 20.0]\n    call maxi(vect, vect_len, mm)\n    print *, mm\n    deallocate(vect)\n    print *, \"&\"\nend program main",
            "result": [
                "5.0000000000000000",
                "0.80000001192092896",
                "10.000000000000000",
                "0.40000000596046448",
                "100.00000000000000"
            ]
        },
        "code": "subroutine maxi(vect, vect_len, mm)\n!simple example for computing the maximum of a given vector\n!dec$ attributes dllexport,c,reference,alias:'maxi_' :: maxi\n    !the previous line is necessary for r to find the external function under its name\n\n    implicit none\n    !-------------------------------------------------------------------------------\n    !input\n    integer, intent(in)                     :: vect_len !length of input vector (needs to be specified explicitly)\n    real(8), intent(in), dimension(vect_len):: vect !actual vector\n    !-------------------------------------------------------------------------------\n    ! output\n    real(8), intent(out):: mm  !for delivering the result\n    !-------------------------------------------------------------------------------\n\n    !-------------------------------------------------------------------------------\n    ! code\n        mm = maxval(vect) \n    !-------------------------------------------------------------------------------\nend subroutine maxi\n",
        "answer": "subroutine maxi(vect,vect_len,mm)\n\n    implicit none\n\n    integer, intent(in) :: vect_len\n    real, dimension(vect_len), intent(in) :: vect\n    real, intent(out) :: mm\n\n    mm = maxval(vect)\n\n  end subroutine maxi\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine named `residual_2dpoisson` that calculates the residual of a 2-dimensional Poisson equation. The subroutine takes in five input parameters: `u` and `f` are 2-dimensional arrays of type real, `h` and `c` are scalars of type real, and `res` is a 2-dimensional array of type real. The subroutine also has no return value. \n\nInside the subroutine, the local variables `nx` and `ny` are declared as integers. The size of `u` in the first dimension is assigned to `nx`, and the size of `u` in the second dimension is assigned to `ny`.\n\nThe `res` array is computed by evaluating the Poisson equation at the internal grid points. The equation is solved by taking the average of the four neighboring grid points and subtracting the value at the current grid point. The result is divided by the square of `h` and subtracted from the corresponding `f` value.\n\nEnsure that the computation is only performed at the internal grid points by using the array slicing `2:nx-1` for the first dimension and `2:ny-1` for the second dimension.\n\nEnd the subroutine after the calculation is complete.",
            "I need you to create a Fortran subroutine called `residual_2dpoisson` that calculates the residual of a 2D Poisson problem. This subroutine has five input parameters and one output parameter. \n\nThe input parameters are:\n- `u` is a 2D array of real numbers, representing the current solution.\n- `f` is also a 2D array of real numbers, representing the source term of the Poisson equation.\n- `h` is a real number that represents the grid spacing.\n- `c` is a real number that represents a coefficient.\n- `res` is a 2D array of real numbers, which will store the computed residual.\n\nThe output parameter is:\n- `res` is a 2D array of real numbers, which stores the calculated residual of the Poisson problem.\n\nInside the subroutine, `nx` and `ny` are local variables, representing the size of the `u` array.\n\nThe computation of the residual is done by updating the elements of the `res` array based on the values of `u`, `f`, `h`, and `c` according to the given formula.\n\nPlease make sure to implement this subroutine with the correct variable assignments and array indexing to ensure accurate computation of the residual.",
            "I need a Fortran subroutine called residual_2dpoisson to calculate the residual of a two-dimensional Poisson equation. The subroutine has five input parameters and one output parameter. The input parameters are:\n- u: a two-dimensional real array representing the solution\n- f: a two-dimensional real array representing the source term\n- h: a real value representing the grid spacing\n- c: a real value representing a coefficient\nThe output parameter is:\n- res: a two-dimensional real array representing the residual\n\nTo execute the subroutine, first declare the input and output parameters with their appropriate dimensions. Then within the subroutine, compute the size of the input array using the size() function. Next, calculate the residual of the Poisson equation using the provided formula and assign the result to the appropriate elements of the output array. Finally, the subroutine will return the computed residual in the res array."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: u(5, 5), f(5, 5), h, c, res(5, 5)\n    \n    ! Test case 1\n    u = reshape([1.0, 2.0, 3.0, 4.0, 5.0, &\n                 6.0, 7.0, 8.0, 9.0, 10.0, &\n                 11.0, 12.0, 13.0, 14.0, 15.0, &\n                 16.0, 17.0, 18.0, 19.0, 20.0, &\n                 21.0, 22.0, 23.0, 24.0, 25.0], [5, 5])\n    f = reshape([0.1, 0.2, 0.3, 0.4, 0.5, &\n                 0.6, 0.7, 0.8, 0.9, 1.0, &\n                 1.1, 1.2, 1.3, 1.4, 1.5, &\n                 1.6, 1.7, 1.8, 1.9, 2.0, &\n                 2.1, 2.2, 2.3, 2.4, 2.5], [5, 5])\n    h = 0.1\n    c = 0.5\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 2\n    u = reshape([0.5, 1.5, 2.5, 3.5, 4.5, &\n                 5.5, 6.5, 7.5, 8.5, 9.5, &\n                 10.5, 11.5, 12.5, 13.5, 14.5, &\n                 15.5, 16.5, 17.5, 18.5, 19.5, &\n                 20.5, 21.5, 22.5, 23.5, 24.5], [5, 5])\n    f = reshape([0.2, 0.4, 0.6, 0.8, 1.0, &\n                 1.2, 1.4, 1.6, 1.8, 2.0, &\n                 2.2, 2.4, 2.6, 2.8, 3.0, &\n                 3.2, 3.4, 3.6, 3.8, 4.0, &\n                 4.2, 4.4, 4.6, 4.8, 5.0], [5, 5])\n    h = 0.2\n    c = 0.7\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 3\n    u = reshape([1.0, 2.0, 3.0, 4.0, 5.0, &\n                 6.0, 7.0, 8.0, 9.0, 10.0, &\n                 11.0, 12.0, 13.0, 14.0, 15.0, &\n                 16.0, 17.0, 18.0, 19.0, 20.0, &\n                 21.0, 22.0, 23.0, 24.0, 25.0], [5, 5])\n    f = reshape([0.3, 0.6, 0.9, 1.2, 1.5, &\n                 1.8, 2.1, 2.4, 2.7, 3.0, &\n                 3.3, 3.6, 3.9, 4.2, 4.5, &\n                 4.8, 5.1, 5.4, 5.7, 6.0, &\n                 6.3, 6.6, 6.9, 7.2, 7.5], [5, 5])\n    h = 0.3\n    c = 0.9\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 4\n    u = reshape([0.5, 1.0, 1.5, 2.0, 2.5, &\n                 3.0, 3.5, 4.0, 4.5, 5.0, &\n                 5.5, 6.0, 6.5, 7.0, 7.5, &\n                 8.0, 8.5, 9.0, 9.5, 10.0, &\n                 10.5, 11.0, 11.5, 12.0, 12.5], [5, 5])\n    f = reshape([0.4, 0.8, 1.2, 1.6, 2.0, &\n                 2.4, 2.8, 3.2, 3.6, 4.0, &\n                 4.4, 4.8, 5.2, 5.6, 6.0, &\n                 6.4, 6.8, 7.2, 7.6, 8.0, &\n                 8.4, 8.8, 9.2, 9.6, 10.0], [5, 5])\n    h = 0.4\n    c = 1.2\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\n    print *, \"&\"\n    \n    ! Test case 5\n    u = reshape([1.0, 1.5, 2.0, 2.5, 3.0, &\n                 3.5, 4.0, 4.5, 5.0, 5.5, &\n                 6.0, 6.5, 7.0, 7.5, 8.0, &\n                 8.5, 9.0, 9.5, 10.0, 10.5, &\n                 11.0, 11.5, 12.0, 12.5, 13.0], [5, 5])\n    f = reshape([0.5, 1.0, 1.5, 2.0, 2.5, &\n                 3.0, 3.5, 4.0, 4.5, 5.0, &\n                 5.5, 6.0, 6.5, 7.0, 7.5, &\n                 8.0, 8.5, 9.0, 9.5, 10.0, &\n                 10.5, 11.0, 11.5, 12.0, 12.5], [5, 5])\n    h = 0.5\n    c = 1.5\n    call residual_2dpoisson(u, f, h, c, res)\n    print *, res\nend program main",
            "result": [
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -4.19998455      -4.80009127      -5.40019798       1.28919459E-43   8.99540858E-15  -7.20013714      -7.80024338      -8.39996910       0.00000000       0.00000000      -10.1999073      -10.8003960      -11.4001207       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -5.94997978      -6.84997654      -7.74997330       1.28919459E-43   8.99540858E-15  -10.4499645      -11.3499603      -12.2499580       0.00000000       0.00000000      -14.9499493      -15.8499451      -16.7499428       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -8.39999390      -9.59998703      -10.8000002       1.28919459E-43   8.99540858E-15  -14.4000015      -15.5999737      -16.7999878       0.00000000       0.00000000      -20.3999863      -21.6000004      -22.7999306       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -6.99999905      -7.99999714      -9.00000191       1.28919459E-43   8.99540858E-15  -12.0000019      -12.9999943      -13.9999981       0.00000000       0.00000000      -17.0000000      -18.0000038      -18.9999828       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38",
                "8.99533998E-15   4.59121429E-41   0.00000000       0.00000000       1.73761010E-43   0.00000000      -9.50000000      -10.7500000      -12.0000000       1.28919459E-43   8.99540858E-15  -15.7500000      -17.0000000      -18.2500000       0.00000000       0.00000000      -22.0000000      -23.2500000      -24.5000000       1.55782350E-41   2.66246708E-44   0.00000000       1.31328795E-38   0.00000000       1.31323190E-38"
            ]
        },
        "code": "  subroutine residual_2dpoisson(u, f, h, c, res)\n    implicit none\n    ! arguments\n    real, intent(in)  :: u(:, :)\n    real, intent(in)  :: f(:, :)\n    real, intent(in)  :: h\n    real, intent(in)  :: c\n    real, intent(out) :: res(:, :)\n    ! local variables\n    integer           :: nx, ny\n\n    nx = size(u, 1)\n    ny = size(u, 2)\n\n    res(2:nx-1, 2:ny-1) = ( u(3:nx,   2:ny-1) &\n                          + u(1:nx-2, 2:ny-1) &\n                          + u(2:nx-1, 3:ny  ) &\n                          + u(2:nx-1, 1:ny-2) &\n                          - (4.0 + c * h**2) * u(2:nx-1, 2:ny-1) ) / h**2 &\n                          - f(2:nx-1, 2:ny-1)\n\n  end subroutine\n",
        "answer": "subroutine residual_2dpoisson(u, f, h, c, res)\n    real, dimension(:,:), intent(in) :: u, f\n    real, intent(in) :: h, c\n    real, dimension(size(u,1), size(u,2)) :: res\n    integer :: nx, ny\n\n    nx = size(u, 1)\n    ny = size(u, 2)\n\n    res = 0.0\n\n    res(2:nx-1, 2:ny-1) = (u(2:nx-1, 2:ny-1) + u(3:nx, 2:ny-1) + &\n                            u(2:nx-1, 3:ny) + u(3:nx, 3:ny))/4.0 - u(2:nx-1, 2:ny-1)\n    res = res/h**2 - f(2:nx-1, 2:ny-1)\n\nend subroutine residual_2dpoisson\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called put_1d_to_2d that takes an input 1D array and converts it into a 2D array. The subroutine takes two parameters as input: tau, which is an output 2D array of type real(8), and xin, which is the input 1D array of type real(8). The subroutine does not return any value.",
            "Write a Fortran subroutine called put_1d_to_2d that transforms a one-dimensional array into a two-dimensional array. The subroutine takes two input parameters and one output parameter. The first input parameter, xin, is an array of real numbers. The second input parameter, tau, is an empty two-dimensional array of real numbers. The output parameter, tau, is the transformed two-dimensional array. The subroutine uses a nested do loop to assign the elements of the one-dimensional array to the elements of the two-dimensional array in column-major order.",
            "Write a Fortran subroutine called put_1d_to_2d that takes a one-dimensional array and reshapes it into a two-dimensional array. The subroutine has 2 input parameters: tau, which is a two-dimensional real array, and xin, which is a one-dimensional real array. The subroutine also has no output parameters. The subroutine iterates over the elements of the two-dimensional array and assigns the corresponding elements from the one-dimensional array to it, in a column-major order."
        ],
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    real(8) :: arr_1d(6), arr_2d(2, 3)\n    ! Test case 1\n    arr_1d = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n\n    ! Test case 2\n    arr_1d = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 3\n    arr_1d = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 4\n    arr_1d = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\n    \n    ! Test case 5\n    arr_1d = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0]\n    call put_1d_to_2d(arr_2d, arr_1d)\n    print *, arr_2d\n    print *, \"&\"\nend program main\n",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000",
                "0.50000000000000000        1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.5000000000000000",
                "10.000000000000000        20.000000000000000        30.000000000000000        40.000000000000000        50.000000000000000        60.000000000000000",
                "0.10000000149011612       0.20000000298023224       0.30000001192092896       0.40000000596046448       0.50000000000000000       0.60000002384185791",
                "100.00000000000000        200.00000000000000        300.00000000000000        400.00000000000000        500.00000000000000        600.00000000000000"
            ]
        },
        "code": "  subroutine put_1d_to_2d( tau, xin )\n    implicit none\n    real(8),intent(out) ::  tau(:,:)\n    real(8),intent(in)  :: xin(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          tau(j,i) = xin(k)\n       end do\n    end do\n  end subroutine put_1d_to_2d\n",
        "answer": "subroutine put_1d_to_2d(xin, tau)\n    implicit none\n    real(8), intent(in) :: xin(:)\n    real(8), intent(out) :: tau(:,:)\n    integer :: i, j\n\n    do i = 1, size(xin)\n        do j = 1, size(xin)\n            tau(i,j) = xin(i) * xin(j)\n        end do\n    end do\nend subroutine put_1d_to_2d\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called put_2d_to_1d to convert a 2-dimensional array into a 1-dimensional array. The number of input parameters is 1, which is an array of type real(8). The number of output parameters is 1, which is also an array of type real(8).",
            "Write a Fortran subroutine called put_2d_to_1d that converts a two-dimensional array into a one-dimensional array. The subroutine takes two input parameters: a two-dimensional array called tau of type real(8) and an output array called xout of type real(8). The subroutine does not return any values. \n\nTo convert the two-dimensional array into a one-dimensional array, initialize a counter variable k to 0. Then, iterate over the columns of the tau array using the variable i and iterate over the rows of the tau array using the variable j. Increment the counter variable k by 1 for each element of the tau array. Assign the value of the tau(j,i) element to the corresponding index of the xout array.\n\nThe subroutine is implemented using the do loop construct to iterate over the dimensions of the tau array and assign the values to the xout array.",
            "I need a Fortran subroutine code called put_2d_to_1d that converts a 2-dimensional array into a 1-dimensional array. The subroutine takes two input parameters and one output parameter. The first input parameter, tau, is a 2-dimensional array of type real(8). The second input parameter, xout, is a 1-dimensional array of type real(8) and will hold the converted values. The output parameter, xout, is also a 1-dimensional array of type real(8) and contains the converted values from tau. The subroutine uses nested do-loops to iterate through each element of tau and assign it to the corresponding element in xout."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: tau(3,3), xout(9)\n    ! Test case 1\n    tau = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n\n    ! Test case 2\n    tau = reshape([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 3\n    tau = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 4\n    tau = reshape([0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\n    \n    ! Test case 5\n    tau = reshape([10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0], shape(tau))\n    call put_2d_to_1d(tau, xout)\n    print *, xout\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        4.0000000000000000        5.0000000000000000        6.0000000000000000        7.0000000000000000        8.0000000000000000        9.0000000000000000",
                "0.50000000000000000        1.5000000000000000        2.5000000000000000        3.5000000000000000        4.5000000000000000        5.5000000000000000        6.5000000000000000        7.5000000000000000        8.5000000000000000",
                "2.0000000000000000        4.0000000000000000        6.0000000000000000        8.0000000000000000        10.000000000000000        12.000000000000000        14.000000000000000        16.000000000000000        18.000000000000000",
                "0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000",
                "10.000000000000000        9.0000000000000000        8.0000000000000000        7.0000000000000000        6.0000000000000000        5.0000000000000000        4.0000000000000000        3.0000000000000000        2.0000000000000000"
            ]
        },
        "code": "  subroutine put_2d_to_1d( tau, xout )\n    implicit none\n    real(8),intent(in)  :: tau(:,:)\n    real(8),intent(out) :: xout(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          xout(k) = tau(j,i)\n       end do\n    end do\n  end subroutine put_2d_to_1d\n",
        "answer": "subroutine put_2d_to_1d(a, b)\n\n    implicit none\n\n    real(8), intent(in) :: a(:,:)\n    real(8), intent(out) :: b(:)\n\n    integer :: i, j, k\n\n    k = 1\n    do i = 1, size(a, 1)\n        do j = 1, size(a, 2)\n            b(k) = a(i, j)\n            k = k + 1\n        end do\n    end do\n\nend subroutine put_2d_to_1d\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called constraint_func_distance that calculates the distance between two points in three-dimensional space. The subroutine takes in five parameters: \n- The first parameter, d0, is a real number and represents the desired distance between the two points. \n- The next two parameters, x and y, are arrays of three real numbers each, representing the coordinates of the two points. \n- The last two parameters, d and fd, are output variables of type real. \n\nInside the subroutine, the distance between the two points is computed using the Euclidean distance formula. The calculated distance is then assigned to the variable d. The difference between the calculated distance and the desired distance (d0) is assigned to the variable fd.",
            "Write a Fortran subroutine called constraint_func_distance to calculate the Euclidean distance between two three-dimensional points and the difference between the calculated distance and a given reference distance. The subroutine takes five parameters in total. The first parameter is a real number representing the reference distance (d0). The second and third parameters are arrays of three real numbers each, representing the coordinates of two points (x and y). The fourth and fifth parameters are output variables of type real. The subroutine calculates the Euclidean distance between the points using the formula d = sqrt( sum( (x-y)**2 ) ) and assigns the result to the variable d. It then computes the difference between d and d0 and assigns it to the variable fd.",
            "Write a Fortran subroutine called \"constraint_func_distance\" that calculates the Euclidean distance between two 3D points and the difference between the calculated distance and a given reference distance. The subroutine takes in five parameters: \n1. \"d0\" of type real(8) - the reference distance.\n2. \"x\" of type real(8) and size 3 - the coordinates of the first point.\n3. \"y\" of type real(8) and size 3 - the coordinates of the second point.\nThe subroutine has two output parameters: \n1. \"d\" of type real(8) - the calculated distance between the points.\n2. \"fd\" of type real(8) - the difference between the calculated distance and the reference distance."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: d0, d, fd\n    real(8), dimension(3) :: x, y\n    \n    ! Test case 1\n    d0 = 2.0\n    x = [1.0, 2.0, 3.0]\n    y = [4.0, 5.0, 6.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 2\n    d0 = 1.5\n    x = [0.0, 0.0, 0.0]\n    y = [1.0, 2.0, 3.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 3\n    d0 = 3.0\n    x = [5.0, 10.0, 15.0]\n    y = [2.0, 4.0, 6.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 4\n    d0 = 1.0\n    x = [1.0, 1.0, 1.0]\n    y = [2.0, 2.0, 2.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\n    \n    ! Test case 5\n    d0 = 0.5\n    x = [0.0, 0.0, 0.0]\n    y = [0.0, 0.0, 0.0]\n    call constraint_func_distance(fd, d, d0, x, y)\n    print *, fd, d\n    print *, \"&\"\nend program main",
            "result": [
                "3.1961524227066320        5.1961524227066320",
                "2.2416573867739413        3.7416573867739413",
                "8.2249721603218244        11.224972160321824",
                "0.73205080756887719        1.7320508075688772",
                "-0.50000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine constraint_func_distance( fd, d, d0, x, y )\n    implicit none\n    real(8),intent(in)  :: d0, x(3), y(3)\n    real(8),intent(out) :: d, fd\n    d  = sqrt( sum( (x-y)**2 ) )\n    fd = d - d0\n  end subroutine constraint_func_distance\n",
        "answer": "subroutine constraint_func_distance(d0, x, y, d, fd)\n    real, intent(in) :: d0\n    real, dimension(3), intent(in) :: x, y\n    real, intent(out) :: d, fd\n\n    d = sqrt((x(1) - y(1))**2 + (x(2) - y(2))**2 + (x(3) - y(3))**2)\n    fd = d - d0\nend subroutine constraint_func_distance\n\n"
    },
    {
        "instruction": [
            "Please create a Fortran subroutine called \"bcnd\" that computes the boundary conditions for a system of differential equations. The subroutine takes in several input parameters: \"ndim\" (integer), \"par\" (array of double precision), \"icp\" (array of integers), \"nbc\" (integer), \"u0\" (array of double precision), and \"u1\" (array of double precision). The subroutine also has output parameters: \"fb\" (array of double precision) and \"dbc\" (array of double precision). \n\nThe subroutine sets the value of \"fb\" to the difference between the first element of \"u0\" and the first element of \"u1\" minus the second element of \"par\". \n\nIf the input parameter \"ijac\" is equal to 0, the subroutine returns. Otherwise, if \"ijac\" is equal to 1, the subroutine sets the derivatives of \"fb\" with respect to the parameters in \"dbc\". \n\nThe subroutine calculates the derivatives of \"fb\" with respect to the parameters and stores them in \"dbc\". \n\nPlease ensure that the subroutine is implemented according to these instructions.",
            "Please provide a Fortran subroutine called \"bcnd\" which calculates boundary conditions for a system of differential equations. The subroutine takes in 6 input parameters: \"ndim\" (integer), \"par\" (double precision array), \"icp\" (integer array), \"nbc\" (integer), \"u0\" (double precision array), and \"u1\" (double precision array). It also has 2 output parameters: \"fb\" (double precision array) and \"dbc\" (double precision 2D array).\n\nThe purpose of the subroutine is to compute the boundary conditions for the differential equations. The first boundary condition is defined as the difference between the first element of \"u0\" and \"u1\", subtracted by the second element of \"par\". This result is stored in the first element of the \"fb\" array.\n\nIf the \"ijac\" parameter is 0, the subroutine exits after calculating \"fb\". If \"ijac\" is 1, the subroutine continues to calculate the Jacobian matrix.\n\nThe Jacobian matrix is stored in the \"dbc\" array. The values of the matrix depend on the value of \"ijac\". If \"ijac\" is 0, only the first two columns of the first row of the \"dbc\" array are set: the first column is set to 1.0 and the second column is set to 0.0. If \"ijac\" is 1, the first row of the \"dbc\" array is set as follows: the fifth column is set to 0.0, the sixth column is set to -1.0, and the seventh column is set to 0.0.\n\nThe generated instructions use the imperative tone and the provided input and output parameters are specified according to their number and type.",
            "Please create a Fortran subroutine called \"bcnd\" that computes the boundary conditions for a system of differential equations. The subroutine takes in several input parameters: \"ndim\" (integer), \"par\" (array of double precision), \"icp\" (array of integers), \"nbc\" (integer), \"u0\" (array of double precision), and \"u1\" (array of double precision). The subroutine also has output parameters: \"fb\" (array of double precision) and \"dbc\" (array of double precision). \n\nThe subroutine sets the value of \"fb\" to the difference between the first element of \"u0\" and the first element of \"u1\" minus the second element of \"par\". \n\nIf the input parameter \"ijac\" is equal to 0, the subroutine returns. Otherwise, if \"ijac\" is equal to 1, the subroutine sets the derivatives of \"fb\" with respect to the parameters in \"dbc\". \n\nThe subroutine calculates the derivatives of \"fb\" with respect to the parameters and stores them in \"dbc\". \n\nPlease ensure that the subroutine is implemented according to these instructions."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: ndim, icp(2), nbc, ijac\n    double precision :: par(2), u0(2), u1(2), fb(1), dbc(1,7)\n    \n    ! Test case 1\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 0\n    par = [2.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n\n    ! Test case 2\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 0\n    par = [-1.0, 0.0]\n    u0 = [0.5, 0.0]\n    u1 = [0.2, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 3\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [1.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 4\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [2.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \n    ! Test case 5\n    ndim = 2\n    icp = [1, 2]\n    nbc = 1\n    ijac = 1\n    par = [0.0, 0.0]\n    u0 = [1.0, 0.0]\n    u1 = [0.0, 0.0]\n    call bcnd(ndim, par, icp, nbc, u0, u1, fb, ijac, dbc)\n    print *, fb\n    print *, dbc\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000     \n   5.9394832831961298E-317   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "0.29999999701976776     \n   5.9394832831961298E-317   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310",
                "1.0000000000000000     \n   1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        6.9531680211469664E-310   2.0730994499498705E-317   6.9531680211580334E-310"
            ]
        },
        "code": "      subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc) \n!     ---------- ---- \n\n      implicit none\n      integer, intent(in) :: ndim, icp(*), nbc, ijac\n      double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n      double precision, intent(out) :: fb(nbc)\n      double precision, intent(inout) :: dbc(nbc,*)\n\n       fb(1)=u0(1)-u1(1)-par(2) \n\n      if(ijac.eq.0)return \n\n       dbc(1,1)=1.0 \n       dbc(1,2)=0.0 \n\n       dbc(1,3)=-1.0 \n       dbc(1,4)=0.0 \n\n      if(ijac.eq.1)return \n\n!      *parameter derivatives\n       dbc(1,5)=0.0 \n       dbc(1,6)=-1.0 \n       dbc(1,7)=0.0 \n\n      end subroutine bcnd\n",
        "answer": "subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,dbc,ijac)\n\n    implicit none\n\n    integer, intent(in) :: ndim, icp(*)\n    integer, intent(in) :: nbc\n    double precision, intent(in) :: par(*)\n    double precision, intent(in) :: u0(ndim), u1(ndim)\n    double precision, intent(out) :: fb(nbc)\n    double precision, intent(out) :: dbc(nbc,*)\n    integer, intent(in) :: ijac\n\n    fb(1) = u0(1) - u1(1) - par(1)\n\n    if (ijac == 0) return\n\n    if (ijac == 1) then\n        dbc(1,1) = 1.0d0\n    end if\n\nend subroutine bcnd\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called legp to compute the Legendre polynomials and their derivatives. The number of input parameters is 2, the first parameter is a double precision variable called x which represents the cosine of the angle, and the second parameter is an integer called n which represents the number of terms in the polynomial series. The number of output parameters is 2, the first output parameter is a double precision variable called pn which represents the value of the Legendre polynomial, and the second output parameter is a double precision variable called pp which represents the derivative of the Legendre polynomial.",
            "Provide a Fortran subroutine called legp that calculates the Legendre polynomial and its derivative at a given point. The subroutine takes in 3 input parameters: an integer n representing the degree of the polynomial, a double precision number x representing the value at which to evaluate the polynomial, and 2 output parameters pn and pp of type double precision to store the polynomial value and its derivative, respectively. \n\nTo compute the Legendre polynomial and its derivative, the subroutine uses a standard 3-term recurrence relation. It initializes pn to 1 and sets p2 to 0. It then iterates from j = 1 to n, updating p3 to p2, p2 to pn, and pn according to the recurrence relation: pn = ((2*j-1)*x*p2-(j-1)*p3)/j. Finally, it computes the derivative pp using the formula: pp = n*(x*pn-p2)/(x*x-1).\n\nPlease implement the legp subroutine following these instructions.",
            "Please provide instructions for a Fortran subroutine called legp that calculates the Legendre polynomial and its derivative. The subroutine takes in 3 input parameters: x (a double precision number representing the cosine of theta), n (an integer representing the number of terms in the polynomial), and two output parameters: pn (a double precision number representing the value of the Legendre polynomial) and pp (a double precision number representing the derivative of the Legendre polynomial). \n\nTo use the subroutine, follow these steps:\n1. Pass the value of x, the number of terms n, and the variables pn and pp to the subroutine legp.\n2. Inside the subroutine, initialize pn to 1.0 and create two additional variables, p2 and p3, both set to 0.0.\n3. Use a loop to iterate from 1 to n. Inside the loop, perform the following calculations:\n   - Set p3 to the value of p2.\n   - Set p2 to the value of pn.\n   - Update pn using the recurrence relation ((2*j-1)*x*p2-(j-1)*p3)/j.\n4. After the loop, calculate the value of pp by using the formula n*(x*pn-p2)/(x*x-1).\n5. The subroutine will automatically update the values of pn and pp, which can be used outside the subroutine.\n\nMake sure to include the subroutine legp in your Fortran program and provide the necessary input values to obtain the desired output."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: x, pn, pp\n    integer :: n\n    \n    ! Test case 1\n    n = 5\n    x = 0.5d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 10\n    x = -0.8d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 3\n    x = 0.2d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 7\n    x = 0.9d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 6\n    x = -0.3d0\n    call legp(n, x, pn, pp)\n    print *, pn, pp\nend program main",
            "result": [
                "8.9843750000000000E-002  -2.2265625000000000",
                "0.30052979560000004        1.4602376800000043",
                "-0.28000000000000003       -1.2000000000000002",
                "-0.36782499375000016        3.3113014375000023",
                "0.12918118750000002       -2.0217487500000000"
            ]
        },
        "code": "        subroutine legp(n, x, pn, pp) ! standard 3 terms rec for pn and dpn / d cth\n        implicit none\n        double precision, intent(in) :: x  ! cos(tht)\n        integer, intent(in) :: n\n        double precision, intent(out) :: pn, pp\n        double precision p2, p3\n        integer j\n        pn = 1.0d0\n        p2 = 0.0d0\n        do j=1,n\n            p3 = p2\n            p2 = pn\n            pn = ((2*j-1)*x*p2-(j-1)*p3)/j\n        end do\n        pp = n*(x*pn-p2)/(x*x-1)\n        end subroutine legp\n",
        "answer": "subroutine legp(x,n,pn,pp)\n\n    implicit none\n\n    integer, intent(in) :: n\n    double precision, intent(in) :: x\n    double precision, intent(out) :: pn,pp\n\n    double precision :: p,dp,p1,p2\n    integer :: i\n\n    p1 = 1.0d0\n    p2 = x\n    p  = p2\n    dp = 1.0d0\n    do i = 2, n\n        p1 = p2\n        p2 = (2.0d0*i-1.0d0)*x*p2 - (i-1.0d0)*p1\n        p  = p2\n        dp = (2.0d0*i-1.0d0)*x*p2 + (i-1.0d0)*p1\n    end do\n\n    pn = p\n    pp = dp\n\nend subroutine legp\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called rescal_jacobi to compute the coefficients for transforming Jacobi polynomials into Wigner small d's. The subroutine has four input parameters:\n- s1: an integer representing a value\n- s2: an integer representing another value\n- lmax: an integer representing the maximum value of l\n- rl: an output array of type double precision\n\nThe subroutine calculates the coefficients and stores them in the array rl. The coefficients are used to transform Jacobi polynomials into Wigner small d's. The code includes calculations using various mathematical functions such as abs, max, and dsqrt.",
            "Provide a Fortran subroutine code called rescal_jacobi that calculates the coefficients for transforming Jacobi polynomials into Wigner small d's. The subroutine takes four input parameters, all of which are integers. The first two parameters, s1 and s2, represent the indices used in the calculations. The third parameter, lmax, specifies the maximum value for the array size. The fourth parameter, rl, is an output array of type double precision. \n\nTo summarize the subroutine, it calculates the coefficients needed for the transformation using a series of mathematical operations. It initializes the first element of the output array to 1 and then iterates over the array, updating each element based on a formula involving the previous element and various factors derived from the input parameters.\n\nTo use this subroutine, you need to call it with the appropriate input parameters and provide an array of appropriate size to store the results.",
            "Write a Fortran subroutine called rescal_jacobi that calculates coefficients for Jacobi polynomials. The subroutine takes in four input parameters: s1 and s2 (integers), lmax (integer), and rl (an array of double precision numbers). The subroutine does not return any value. \n\nTo use the subroutine, provide the values of s1, s2, and lmax. The subroutine will calculate the coefficients and store them in the array rl."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: s1, s2, lmax\n    double precision, allocatable :: rl(:)\n    \n    ! Test case 1\n    s1 = 2\n    s2 = -1\n    lmax = 5\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 2\n    s1 = 3\n    s2 = 4\n    lmax = 7\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 3\n    s1 = -2\n    s2 = 0\n    lmax = 10\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 4\n    s1 = 1\n    s2 = 1\n    lmax = 3\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \n    ! Test case 5\n    s1 = 0\n    s2 = 0\n    lmax = 5\n    allocate(rl(0:lmax - max(abs(s1), abs(s2))))\n    call rescal_jacobi(s1, s2, lmax, rl)\n    print *, rl\n    deallocate(rl)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.0000000000000000        1.5811388300841898        1.4142135623730951        1.3228756555322954",
                "2.8284271247461903        2.1213203435596428        1.8257418583505540        1.6583123951777001",
                "2.4494897427831783        1.8257418583505538        1.5811388300841898        1.4491376746189437        1.3662601021279464        1.3093073414159542        1.2677313820927747        1.2360330811826106        1.2110601416389968",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "    subroutine rescal_jacobi(s1, s2, lmax, rl)\n        ! coefficients turning jacobi polynomials onto wigner small d's\n        ! ~0.1 ms at most for high lmax\n        ! these coeffs are (for integer a, b)\n        ! ( (k + (a + b)) ! * k ! / (k + a)! / (k + b)! )^1/2\n        implicit none\n        integer, intent(in) :: s1, s2\n        integer, intent(in) :: lmax\n        double precision, intent(out) :: rl(0:lmax - max(abs(s1), abs(s2)))\n        integer a, b, lmin, k\n        double precision dmab\n\n        a = abs(s1 - s2)\n        b = abs(s1 + s2)\n        lmin = max(abs(s1), abs(s2))\n        dmab = max(a, b)\n        rl(0) = 1d0\n        do k = 1, min(a, b)\n            rl(0) = rl(0) * dsqrt(1.d0 + dmab / k)\n        end do\n        do k = 0, lmax - lmin - 1\n            rl(k + 1) = rl(k) * dsqrt(  (k + 1.d0 + (a + b) ) / (k + 1.d0 + a) * (k + 1.d0) / (k + 1.d0 + b))\n        end do\n    end subroutine rescal_jacobi\n",
        "answer": "subroutine rescal_jacobi(s1,s2,lmax,rl)\n    integer, intent(in) :: s1,s2,lmax\n    double precision, intent(out) :: rl(0:lmax)\n    integer :: l, m, n, s, t\n    double precision :: a, b, c, d, e, f, g, h, j, k, lam, mu, nu, r, sigma, tau, zeta\n\n    do l = 0, lmax\n        rl(l) = 0.0d0\n    end do\n\n    do l = 0, lmax\n        do m = 0, l\n            do n = 0, l\n                do s = 0, s1\n                    do t = 0, s2\n                        a = dble(s)\n                        b = dble(t)\n                        c = dble(l)\n                        d = dble(m)\n                        e = dble(n)\n                        f = dble(l + m)\n                        g = dble(l + n)\n                        h = dble(l + m + n)\n                        j = dble(l - m)\n                        k = dble(l - n)\n                        lam = dble(m - n)\n                        mu = dble(s1 - s)\n                        nu = dble(s2 - t)\n                        r = dble(l + s1 + s2)\n                        sigma = dble(l - s1 - s2)\n                        tau = dble(l + m - n)\n                        zeta = dble(l - m + n)\n\n                        rl(l) = rl(l) + (2.0d0 * a + 1.0d0) * (2.0d0 * b + 1.0d0) / (4.0d0 * c + 2.0d0) * (2.0d0 * f + 1.0d0) / (4.0d0 * g + 2.0d0) * (2.0d0 * h + 1.0d0) / (4.0d0 * r + 2.0d0) * (2.0d0"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called pol2pos that calculates the position space values for a set of input values using orthogonal polynomials. The subroutine takes in six input parameters: xi, nx, lmax, x, an, bn, cn, cl, p0. The xi parameter is an array of double precision values that will store the position space values. The nx parameter is an integer representing the size of the arrays xi and x. The lmax parameter is an integer representing the maximum order of the orthogonal polynomials. The x parameter is an array of double precision values that are used in the computation. The an, bn, cn, and cl parameters are arrays of double precision values representing coefficients for the orthogonal polynomials. The p0 parameter is a double precision value representing an initial value for the orthogonal polynomials. \n\nThe subroutine uses a three-term recurrence relation to calculate the orthogonal polynomials up to the specified order. The recurrence relation is: p_{n+1}(x) = (a_n x + b_n) p_{n}(x) - c_n p_{n-1}(x). The subroutine initializes the necessary variables and then iterates over the orders of the orthogonal polynomials. It calculates the values of the orthogonal polynomials using the recurrence relation and updates the position space values by adding the product of the orthogonal polynomial value and the corresponding coefficient. \n\nThe subroutine outputs the position space values in the xi array.",
            "Write a Fortran subroutine called pol2pos that calculates the position space values for a given set of input parameters. The subroutine requires several input parameters: an array of type double precision called x, an array of type double precision called an, an array of type double precision called bn, an array of type double precision called cn, an array of type double precision called cl, a scalar of type double precision called p0, and two scalars of type integer called nx and lmax. The output parameter is an array of type double precision called xi.\n\nThe subroutine uses a three-term recurrence relation to evaluate the orthogonal polynomials up to a specified maximum degree (lmax). It starts by calculating the values for the zeroth and first degree polynomials using the given coefficients. Then, it iteratively calculates the values for higher degree polynomials using the recurrence relation. Finally, it computes the position space values (xi) by multiplying the orthogonal polynomials with the corresponding cl coefficients and summing them up.\n\nTo use the subroutine, pass the appropriate input arrays and scalars, and provide an output array for xi.",
            "Provide a Fortran subroutine called \"pol2pos\" to compute the position space sum of orthogonal polynomials. The subroutine accepts 7 input parameters and 1 output parameter. The input parameters are:\n- \"x\": an array of double precision numbers\n- \"nx\": an integer representing the size of the array\n- \"lmax\": an integer representing the maximum degree of the polynomials\n- \"an\": an array of double precision numbers representing the coefficients \"a\" for the recurrence relation\n- \"bn\": an array of double precision numbers representing the coefficients \"b\" for the recurrence relation\n- \"cn\": an array of double precision numbers representing the coefficients \"c\" for the recurrence relation\n- \"cl\": an array of double precision numbers representing the coefficients \"c\" for the polynomial sum\nThe output parameter is:\n- \"xi\": an array of double precision numbers representing the position space sum of the polynomials\n\nThe subroutine uses a 3-term recurrence relation to evaluate the orthogonal polynomials up to degree \"lmax\". It initializes the polynomials, iteratively computes the polynomials using the recurrence relation, and computes the position space sum using the given coefficients. The resulting position space sum is stored in the \"xi\" array.\n\nPlease note that the subroutine does not use OpenMP threading."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: x(5), an(5), bn(5), cn(5), cl(5), p0\n    double precision :: xi(5), pl(5), plp1(5), plm1(5)\n    integer :: nx, lmax, l\n\n    ! Test case 1\n    nx = 5\n    lmax = 3\n    x = [1.0, 2.0, 3.0, 4.0, 5.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 2\n    lmax = 2\n    x = [0.5, 1.0, 1.5, 2.0, 2.5]\n    an = [0.2, 0.3, 0.4, 0.5, 0.6]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.7, 0.8, 0.9, 1.0, 1.1]\n    p0 = 0.5\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 3\n    lmax = 4\n    x = [1.0, 1.0, 1.0, 1.0, 1.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 4\n    lmax = 3\n    x = [5.0, 4.0, 3.0, 2.0, 1.0]\n    an = [0.5, 0.4, 0.3, 0.2, 0.1]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.05, 0.04, 0.03, 0.02, 0.01]\n    cl = [0.9, 0.8, 0.7, 0.6, 0.5]\n    p0 = 1.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n\n    ! Test case 5\n    lmax = 2\n    x = [1.0, 2.0, 3.0, 4.0, 5.0]\n    an = [0.1, 0.2, 0.3, 0.4, 0.5]\n    bn = [1.0, 1.0, 1.0, 1.0, 1.0]\n    cn = [0.01, 0.02, 0.03, 0.04, 0.05]\n    cl = [0.5, 0.6, 0.7, 0.8, 0.9]\n    p0 = 0.0\n    call pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    print *, xi\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.3956000539213420        4.4780000973850500        5.8220001575142160        7.4564002367407110        9.4100003374964061",
                "1.3502499902732670        1.5229999924078581        1.7092499949224291        1.9089999978169794        2.1222500010915093",
                "5.4366200390197328        5.4366200390197328        5.4366200390197328        5.4366200390197328        5.4366200390197328",
                "26.649001121081437        18.921200693807020        12.901400388483712        8.3736001847267172        5.1218000621512543",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "        subroutine pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n            ! computes position space \\sum_l cl pl(x) without openmp threading\n            ! ortho polynomial eval up to lmax with 3 term recurrence relation\n            ! p_{n+1}(x) = (a_n x + b_n) p_{n}(x) - c_n p_{n-1}(x) (andrews, askey and roy)\n            ! normalization for ortho pol can also be gained from recurrence relation (see same ref)\n            implicit none\n            double precision, intent(in) :: x(nx)\n            double precision, intent(in) :: an(0:lmax-1), bn(0:lmax-1), cn(0:lmax-1), cl(0:lmax)\n            double precision, intent(out) :: xi(nx)\n            double precision :: pl(nx), plp1(nx), plm1(nx), p0\n            integer, intent(in) :: nx, lmax\n            integer :: l\n\n            if (lmax == 0) then\n                xi = cl(0) * p0\n                return\n            end if\n            plm1 = 0.\n            pl = p0\n            plp1 = (an(0) * x + bn(0)) * pl\n            xi = cl(0) * pl + cl(1) * plp1\n            do l = 1, lmax - 1\n                plm1 = pl\n                pl = plp1\n                plp1 = (an(l) * x + bn(l)) * pl - cn(l) * plm1\n                xi = xi + plp1 * cl(l + 1)\n            end do\n        end subroutine pol2pos\n",
        "answer": "subroutine pol2pos(xi, nx, lmax, x, an, bn, cn, cl, p0)\n    implicit none\n    integer, intent(in) :: nx, lmax\n    double precision, intent(out) :: xi(nx)\n    double precision, intent(in) :: x(nx), an(lmax), bn(lmax), cn(lmax), cl(lmax), p0\n    integer :: n, l\n    double precision :: p1, p2, p3\n\n    xi = 0.0d0\n    p1 = p0\n    p2 = p0\n\n    do n = 1, lmax\n        p3 = (an(n) * x + bn(n)) * p2 - cn(n) * p1\n        p1 = p2\n        p2 = p3\n\n        do l = 1, nx\n            xi(l) = xi(l) + cl(n) * p3\n        end do\n    end do\nend subroutine pol2pos\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called running_avg that calculates the running average and standard deviation of a series of values. The subroutine has 5 input/output parameters. The first input parameter, x, is a real number representing the current value. The second and third output parameters, avg and std_dev, are also real numbers and represent the running average and standard deviation, respectively. The fourth output parameter, nvals, is an integer that stores the number of values processed so far. The last input parameter, reset, is a logical value that determines whether to reset the running average and standard deviation calculations. When reset is true, the subroutine initializes the average, standard deviation, and count to zero. When reset is false, the subroutine updates the average, standard deviation, and count based on the current value.",
            "Please create a Fortran subroutine named \"running_avg\" that calculates the running average and standard deviation of a series of values. The subroutine has 5 input/output parameters. \n\nThe first parameter \"x\" is of type real and is the current value to be included in the calculation. \n\nThe second and third parameters \"avg\" and \"std_dev\" are of type real and are the output variables that store the calculated running average and standard deviation, respectively. \n\nThe fourth parameter \"nvals\" is of type integer and is the output variable that stores the number of values that have been included in the calculation so far. \n\nThe fifth parameter \"reset\" is of type logical and is the input variable that indicates whether to reset the calculation to its initial state or not. \n\nIf \"reset\" is true, the subroutine resets all the variables to their initial values (including setting \"avg\" and \"std_dev\" to 0) and sets \"nvals\" to 0. \n\nIf \"reset\" is false, the subroutine updates the running average and standard deviation based on the current value \"x\" and increments \"nvals\" by 1. \n\nPlease write the Fortran subroutine \"running_avg\" according to these specifications.",
            "Please provide a Fortran subroutine code called running_avg that calculates the running average and standard deviation of a series of values. The subroutine has five input/output parameters. \n\nThe first parameter is a real number x, which represents the current value in the series. It is passed as input to the subroutine. \n\nThe next three parameters are real numbers: avg, std_dev, and nvals. avg represents the running average of the series and is passed as output from the subroutine. std_dev represents the running standard deviation and is also passed as output. nvals represents the number of values in the series and is also passed as output. \n\nThe final parameter is a logical variable called reset. If reset is true, the subroutine resets the running average and standard deviation to zero and starts calculating from the beginning. If reset is false, the subroutine updates the running average and standard deviation based on the current value. \n\nPlease provide the code for the running_avg subroutine according to the given requirements."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: value, avg, std_dev\n    integer :: nvals\n    logical :: reset\n    ! Test case 1\n    value = 1.0\n    reset = .true.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n\n    ! Test case 2\n    value = 2.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 3\n    value = 3.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 4\n    value = 4.0\n    reset = .false.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\n    \n    ! Test case 5\n    value = 5.0\n    reset = .true.\n    call running_avg(value, avg, std_dev, nvals, reset)\n    print *, avg, std_dev, nvals\n    print *, \"&\"\nend program main",
            "result": [
                "0.00000000       0.00000000               0",
                "2.00000000       0.00000000               1",
                "2.50000000      0.707106769               2",
                "3.00000000       1.00000000               3",
                "0.00000000       0.00000000               0"
            ]
        },
        "code": "subroutine running_avg(x, avg, std_dev, nvals, reset)\nimplicit none\n\nreal, intent(in) :: x\nreal, intent(out) :: avg, std_dev\ninteger, intent(out) :: nvals\nlogical, intent(in) :: reset\ninteger, save :: n\nreal, save :: sum_x, sum_x2\n\ncalc_sums: if(reset) then\n  n       = 0\n  sum_x   = 0.\n  sum_x2  = 0.\n  avg     = 0.\n  std_dev = 0.\n  nvals   = 0\nelse\n  n      = n + 1\n  sum_x  = sum_x + x\n  sum_x2 = sum_x2 + x**2\n\n  avg = sum_x / real(n)\n\n  if (n >= 2) then\n    std_dev = sqrt((real(n) * sum_x2 - sum_x**2) &\n            / (real(n) * real(n-1)))\n  else\n    std_dev = 0.\n  end if\n\n  nvals = n\nend if calc_sums\nend subroutine running_avg\n",
        "answer": "subroutine running_avg(x, avg, std_dev, nvals, reset)\n    real, intent(in) :: x\n    real, intent(out) :: avg, std_dev\n    integer, intent(out) :: nvals\n    logical, intent(in) :: reset\n    real :: sum, sum_sq\n    real :: old_avg, old_std_dev\n    integer :: old_nvals\n\n    if (reset) then\n        avg = 0.0\n        std_dev = 0.0\n        nvals = 0\n    else\n        old_avg = avg\n        old_std_dev = std_dev\n        old_nvals = nvals\n\n        nvals = nvals + 1\n        sum = old_avg * (nvals - 1) + x\n        avg = sum / nvals\n        sum_sq = old_std_dev * (nvals - 1) + (x - old_avg) * (x - avg)\n        std_dev = sqrt(sum_sq / nvals)\n    end if\nend subroutine running_avg\n\n"
    },
    {
        "instruction": [
            "Please provide me with a Fortran subroutine code called index that calculates the refractive index in a magnetized plasma using the Appleton-Hartree equation. The subroutine takes in five input parameters: x, y, k, mode, and mu. The x parameter is an array of real numbers, y and k are arrays of real numbers with two dimensions, mode is an array of characters with one dimension, and mu is an array of real numbers. The subroutine also has one output parameter, mu, which is also an array of real numbers.",
            "Give me a Fortran subroutine code called index to calculate the refractive index of a magnetized plasma using the Appleton-Hartree equation. The subroutine takes in 5 input parameters and has 1 output parameter. The input parameters are:\n- x: an array of real numbers representing (fp/f)^2\n- y: a 2D array of real numbers representing fc/f\n- k: a 2D array of real numbers representing the angle (k,b)\n- mode: a character array representing the mode\nThe output parameter is:\n- mu: an array of real numbers representing the refractive index\n\nHere is the instruction for the subroutine:\n1. Define a Fortran subroutine called index with the input parameters x, y, k, mode, and the output parameter mu.\n2. Inside the subroutine, calculate the value of nmode based on the mode input parameter. If mode is 'x', set nmode to -1.0, otherwise set it to 1.0.\n3. Compute the norms of y and k arrays and store the results in the normy and normk arrays using the sqrt function.\n4. Use a conditional statement to calculate the dot product between y and k arrays and store the results in the vdotk array. If normy is zero, set vdotk to the maximum value of k. Otherwise, calculate the dot product using the formula (y(1)*k(1) + y(2)*k(2) + y(3)*k(3)) / normy.\n5. Calculate the coefficients a, b, and c using the given formulas and the input parameters x, normy, normk, and vdotk.\n6. Check if the absolute value of b2mac is less than 1e-15. If true, set b2mac to zero to avoid numerical effects.\n7. Finally, compute the refractive index mu using the equation sqrt((-b + nmode*sqrt(b2mac))/a) and store the result in the mu array.\n\nNote: This code assumes that the dimensions of the input arrays are compatible.",
            "Please provide me with a Fortran subroutine code called index that calculates the refractive index in a magnetized plasma using the Appleton-Hartree equation. The subroutine takes in five input parameters: x, y, k, mode, and mu. The x parameter is an array of real numbers, y and k are arrays of real numbers with two dimensions, mode is an array of characters with one dimension, and mu is an array of real numbers. The subroutine also has one output parameter, mu, which is also an array of real numbers."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: x(3), y(3,3), k(3,3), mu(3)\n    character(len=1) :: mode(3)\n    ! Test case 1\n    x = [0.2, 0.3, 0.4]\n    y = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3,3])\n    k = reshape([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [3,3])\n    mode = ['x', 'y', 'z']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n\n    ! Test case 2\n    x = [0.5, 0.6, 0.7]\n    y = reshape([0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7], [3,3])\n    k = reshape([0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], [3,3])\n    mode = ['y', 'z', 'x']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [0.8, 0.9, 1.0]\n    y = reshape([1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1], [3,3])\n    k = reshape([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1], [3,3])\n    mode = ['z', 'x', 'y']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [0.4, 0.5, 0.6]\n    y = reshape([1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5], [3,3])\n    k = reshape([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3], [3,3])\n    mode = ['x', 'y', 'z']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.6, 0.7, 0.8]\n    y = reshape([2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9], [3,3])\n    k = reshape([0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4], [3,3])\n    mode = ['y', 'z', 'x']\n    call index(x, y, k, mode, mu)\n    print *, mu\n    print *, \"&\"\nend program main",
            "result": [
                "2.0903655019008314       0.93939482301416843       0.93276135887889755",
                "0.89912781171049183       0.90193760129566758        1.1791740575925205",
                "0.86245019045133942        1.1911116933449157       -0.0000000000000000",
                "1.0880974754925452       0.94409058212756547       0.93972831641211507",
                "0.93384108123658927       0.93099584106591637        1.0974055722581879"
            ]
        },
        "code": "subroutine index(x,y,k,mode,mu)\n\t!------------------------------------\n\t! calculation of the mu refractive index in a magnetised\n\t! plasma according to the appleton-hartree equation\n\t! [haselgrove, 1960]\n\t! calling sequence: call index(x,y,th,mu)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!        th: (k,b) angle\n\t! outputs: mu\n\t!------------------------------------\n\treal(kind=8), dimension(:), intent(in)     \t :: x\n\treal(kind=8), dimension(:,:), intent(in)   \t :: y,k\n\tcharacter(len=1), intent(in), dimension(:) \t :: mode\n\treal(kind=8), dimension(:), intent(out)    \t :: mu\n\treal(kind=8), dimension(size(mu))          \t :: normy,normk,vdotk,a,b,c,b2mac\n\treal(kind=8), dimension(size(mu))\t\t   \t :: nmode\n\t\n\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\tnormk = sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\twhere (normy .eq.0.d0)\n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\ta = 1.d0-x-normy**2*(1.d0-x*vdotk**2/normk**2)\n\tb = 0.5d0*(-2.d0*(1.d0-x)*(1.d0-x-normy**2)+x*normy**2*(1.d0-vdotk**2/normk**2))\n\tc = (1.d0-x)*((1.d0-x)**2-normy**2)\n\t\n\tb2mac = b**2-a*c\n\t\n\t! when magnetic field -> 0 then b2mac -> 0 => numerical effects => when abs(b2mac) < 1.d-15 => b2mac=0\n\twhere (abs(b2mac) < 1.d-15)\n\t\tb2mac = 0.d0\n\tend where\n\t\n\tmu = sqrt((-b+nmode*sqrt(b2mac))/a)\n\t\n\t\n\t!write(*,*) b2mac, -b+sqrt(b2mac), mu\n\t\nend subroutine index\n",
        "answer": "subroutine index(x, y, k, mode, mu)\n\n    implicit none\n\n    real, dimension(:), intent(in) :: x, y, k\n    real, dimension(2,2), intent(in) :: mu\n    character(len=1), dimension(:), intent(in) :: mode\n    real, dimension(size(x)), intent(out) :: mu\n\n    integer :: i\n\n    do i = 1, size(x)\n        if (mode(i) == 'a') then\n            mu(i) = (1 + x(i)**2) / (1 + y(i)**2)\n        else if (mode(i) == 'h') then\n            mu(i) = (1 - x(i)**2) / (1 - y(i)**2)\n        else\n            mu(i) = (1 + x(i)**2) / (1 - y(i)**2)\n        end if\n    end do\n\nend subroutine index\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called ztable_integral to compute the integral of a complex function. The subroutine takes 4 input parameters: k (integer), zeta (real), alpha (real), and specifies the output parameter zfunc (complex). The subroutine also includes several internal variables and parameters. The subroutine uses a loop to calculate the integral iteratively until a certain tolerance level is reached. The subroutine includes various calculations involving exponentials, complex numbers, and mathematical functions.",
            "Write a Fortran subroutine called ztable_integral that calculates the integral of a complex function. The subroutine has four input parameters: an integer k, a real zeta, a real alpha, and a complex zfunc. It also has no output parameters. \n\nInside the subroutine, the values of various parameters are initialized, such as nperiod, beta, and tol. These parameters are used in the calculations. \n\nThe subroutine then performs a series of calculations to compute the integral of the complex function. It uses a loop to iterate over the values of t, updating the amplitude_factor, deriv_factor, and phase_factor at each iteration. The zfunc is updated by adding the product of these factors to it. \n\nThe loop continues until a termination condition is met, which is when the test value becomes less than tol. \n\nFinally, the subroutine checks if alpha is positive and performs additional calculations if true. Another loop is used to iterate over the values of t in reverse order, updating the amplitude_factor, deriv_factor, and phase_factor at each iteration. The zfunc is updated in the same way as before. The loop continues until the test value becomes less than tol again. \n\nThe subroutine ends after these calculations are completed.",
            "Please provide a Fortran subroutine code called \"ztable_integral\" that calculates the integral of a complex function. The subroutine has four input parameters: an integer \"k\", a real \"zeta\", a real \"alpha\", and a complex \"zfunc\". The output is the computed integral value stored in \"zfunc\". \n\nTo use the subroutine, pass the values of \"k\", \"zeta\", and \"alpha\" as input parameters, and declare a complex variable to store the result. After calling the subroutine, the computed integral value will be available in the \"zfunc\" variable."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: k\n    real :: zeta, alpha\n    complex :: zfunc\n    \n    ! Test case 1\n    k = 2\n    zeta = 1.0\n    alpha = 0.5\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 2\n    k = 3\n    zeta = 2.5\n    alpha = -1.0\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 3\n    k = 0\n    zeta = 1.5\n    alpha = 0.0\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 4\n    k = 5\n    zeta = -2.0\n    alpha = 1.2\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\n    \n    ! Test case 5\n    k = 4\n    zeta = 3.0\n    alpha = 0.8\n    call ztable_integral(k, zeta, alpha, zfunc)\n    print *, real(zfunc), aimag(zfunc)\n    print *, \"&\"\nend program main",
            "result": [
                "-0.670557797     -0.350514770",
                "-0.434719265      -1.82412453E-02",
                "-0.856345832      0.186814845",
                "-0.672848225      0.209748670",
                "-0.580752671     -0.120127797"
            ]
        },
        "code": "      subroutine ztable_integral(k,zeta,alpha,zfunc)\n!         use kinds\n         implicit none\n         integer     , intent(in)  :: k\n         real        , intent(in)  :: zeta,alpha\n         complex , intent(out) :: zfunc\n         integer  , parameter :: nperiod = 100  ! ... points per zeta-cycle\n         real, parameter :: beta = 4.5\n         logical      :: l_at_alpha_inv,l_alpha_positive\n         real    :: tol,twopi,zetascale\n         real    :: dt,halfdt,t,dtz\n         real    :: amplitude_factor,deriv_factor,test\n         complex :: eye,phase_factor\n!\n         twopi = 8.0*atan(1.0)\n         eye = cmplx(0.0,1.0)\n         tol = exp(-beta**2)\n         l_alpha_positive = alpha.gt.0.0\n         zetascale = sqrt(1.0+abs(alpha))\n         dt = twopi/sqrt(zeta**2+real(k+1)**2*zetascale**2)/nperiod\n         halfdt = 0.5*dt\n         zfunc = cmplx(0.0,0.0)\n         dtz = halfdt\n         t   = 0.0\n         l_at_alpha_inv = .false.\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol.and.(.not.l_at_alpha_inv))\n            t = t+dt\n            if (l_alpha_positive) l_at_alpha_inv = (t+halfdt).ge.(1.0/alpha)\n            if (l_at_alpha_inv) dtz = t+halfdt-1.0/alpha\n            if (l_at_alpha_inv) t   = 1.0/alpha-0.5*dtz\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                                  exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                      -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n         if (.not.l_alpha_positive) return\n         dtz = halfdt\n         t   = 0.0\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         amplitude_factor = amplitude_factor - &\n                            exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol)\n            t = t-dt\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n!\n      end subroutine ztable_integral\n",
        "answer": "subroutine ztable_integral(k, zeta, alpha, zfunc)\n    integer, intent(in) :: k\n    real, intent(in) :: zeta, alpha\n    complex, intent(out) :: zfunc\n    integer :: i\n    real :: x, dx, sum\n    real, parameter :: tol = 1.0e-6\n    complex, parameter :: iu = (0.0, 1.0)\n\n    dx = 2.0 * alpha / real(k)\n    sum = 0.0\n\n    do i = 1, k\n        x = -alpha + real(i) * dx\n        sum = sum + exp(-zeta * x) * (cos(x) - iu * sin(x))\n    end do\n\n    zfunc = (2.0 * alpha / (pi * zeta)) * sum\n\nend subroutine ztable_integral\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called v_wire_nonperiodic to calculate the electric potential due to a charged wire. The subroutine takes 3 input parameters: x (distance between the wire and the point of interest) of type double precision, lambda (line charged density of the wire) of type double precision, and potential (output variable to store the calculated potential) of type double precision. The subroutine also has a local variable lamb to convert lambda to units of e/ang. The subroutine calculates the potential using the formula: potential = -lamb/(2*pi*epsilon0) * log(x), where pi and epsilon0 are predefined constants.",
            "Please provide a Fortran subroutine called \"v_wire_nonperiodic\" which calculates the electric potential due to a charged wire at a given distance. The subroutine takes 2 input parameters: \"x\" (distance in angstroms between the wire and the point of interest) of type double precision and \"lambda\" (line charged density of the wire in e/cm) of type double precision. The subroutine also has 1 output parameter \"potential\" (the calculated potential in volts) of type double precision.\n\nHere are the steps to follow in the subroutine:\n1. Convert the line charged density \"lambda\" from e/cm to e/angstroms by multiplying it by 1.e-8 and store it in the variable \"lamb\".\n2. Calculate the potential using the formula: potential = -lamb/(2*pi*epsilon0) * log(x), where pi is a pre-defined constant (3.1415926535897932d0) and epsilon0 is another pre-defined constant (0.0055263496 e/(v*angstroms)).\n3. Assign the calculated potential to the output parameter \"potential\".\n\nPlease write a Fortran subroutine called \"v_wire_nonperiodic\" implementing the above steps.",
            "Create a Fortran subroutine called v_wire_nonperiodic to calculate the electric potential at a point due to a charged wire. The subroutine takes in three input parameters: x, which is the distance in angstroms between the wire and the point of interest (type: double precision); lambda, which is the linear charge density of the wire in units of e/cm (type: double precision); and potential, which is the output parameter that stores the calculated potential at the point (type: double precision).\n\nInside the subroutine, the line charge density lambda is converted to e/angstrom. The potential is then computed using the formula: potential = -lambda / (2 * pi * epsilon0) * log(x), where pi is a predefined constant (value: 3.1415926535897932) and epsilon0 is a predefined constant (value: 0.0055263496 e/(v*angstrom)).\n\nThe subroutine returns the calculated potential at the given point."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: distance, charge_density, potential\n    ! Test case 1\n    distance = 1.0\n    charge_density = 1.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n\n    ! Test case 2\n    distance = 2.5\n    charge_density = 0.5\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 3\n    distance = 0.5\n    charge_density = 2.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 4\n    distance = 10.0\n    charge_density = 0.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\n    \n    ! Test case 5\n    distance = 3.0\n    charge_density = -1.0\n    call v_wire_nonperiodic(distance, charge_density, potential)\n    print *, potential\n    print *, \"&\"\nend program main",
            "result": [
                "-0.0000000000000000",
                "-1.3194261480068376E-007",
                "3.9924294009932879E-007",
                "-0.0000000000000000",
                "3.1639254436754947E-007"
            ]
        },
        "code": "subroutine v_wire_nonperiodic(x,lambda,potential)\n\n  !! charged wire at a distance x\n\n  double precision, intent(in) :: x \n  !! x is the distance in ang between the wire and the point of interest\n  double precision, intent(in) :: lambda \n  !! lambda is the line charged density of the wire in e/cm\n\n  double precision, intent(out) :: potential \n  !! in v\n  double precision :: lamb \n  !! lambda in units of e/ang\n\n  double precision :: pi, epsilon0\n  parameter(pi = 3.1415926535897932d0)\n  parameter(epsilon0 = 0.0055263496) ! in e/(v*ang)\n\n  !first off, need lambda in e/ang\n  lamb = lambda*1.e-8\n\n  potential = -lamb/(2.*pi*epsilon0) * log(x)\n\nend subroutine v_wire_nonperiodic\n",
        "answer": "subroutine v_wire_nonperiodic(x, lambda, potential)\n    double precision, intent(in) :: x, lambda\n    double precision, intent(out) :: potential\n    double precision :: lamb\n\n    ! convert lambda to units of e/ang\n    lamb = lambda * epsilon0 / (2*pi)\n\n    ! calculate potential\n    potential = -lamb / (2*pi*epsilon0) * log(x)\nend subroutine v_wire_nonperiodic\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called outerprod3 that computes the outer product of two 3-dimensional vectors. The subroutine takes in 2 input parameters: va and vb, both of type real and dimension 3. It also has 1 output parameter called vv, which is a 3x3 matrix of type real.",
            "Provide a Fortran subroutine code named \"outerprod3\" that calculates the outer product of two 3-dimensional arrays. The subroutine has 3 input parameters of type real(4): \"va\" and \"vb\" are arrays of size 3, and \"vv\" is a 3x3 array. There are no output parameters. \n\nTo calculate the outer product, the subroutine multiplies each element of \"va\" by each element of \"vb\" and stores the result in the corresponding location in \"vv\". The subroutine uses a loop to iterate over the elements of \"vb\" and performs the multiplication for each element. The resulting outer product is stored in the array \"vv\".",
            "Create a Fortran subroutine called outerprod3 that calculates the outer product of two 3-element arrays. The subroutine has 3 input parameters and 1 output parameter. The input parameters are arrays of type real with 4-byte precision. The output parameter is a 3x3 array of type real with 4-byte precision. Inside the subroutine, a loop is used to perform the calculation of the outer product."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(4), dimension(3) :: vector1, vector2\n    real(4), dimension(3,3) :: result\n    integer :: i, j\n    \n    ! Test case 1\n    vector1 = [1.0, 2.0, 3.0]\n    vector2 = [4.0, 5.0, 6.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    vector1 = [0.5, 1.5, 2.5]\n    vector2 = [2.0, 3.0, 4.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    vector1 = [2.0, 2.0, 2.0]\n    vector2 = [0.0, 1.0, 2.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    vector1 = [3.0, 4.0, 5.0]\n    vector2 = [-1.0, -2.0, -3.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    vector1 = [1.0, 0.0, -1.0]\n    vector2 = [-1.0, 0.0, 1.0]\n    call outerprod3(vector1, vector2, result)\n    do i = 1, 3\n        do j = 1, 3\n            print *, result(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "4.00000000    \n   5.00000000    \n   6.00000000    \n   8.00000000    \n   10.0000000    \n   12.0000000    \n   12.0000000    \n   15.0000000    \n   18.0000000",
                "1.00000000    \n   1.50000000    \n   2.00000000    \n   3.00000000    \n   4.50000000    \n   6.00000000    \n   5.00000000    \n   7.50000000    \n   10.0000000",
                "0.00000000    \n   2.00000000    \n   4.00000000    \n   0.00000000    \n   2.00000000    \n   4.00000000    \n   0.00000000    \n   2.00000000    \n   4.00000000",
                "-3.00000000    \n  -6.00000000    \n  -9.00000000    \n  -4.00000000    \n  -8.00000000    \n  -12.0000000    \n  -5.00000000    \n  -10.0000000    \n  -15.0000000",
                "-1.00000000    \n   0.00000000    \n   1.00000000    \n  -0.00000000    \n   0.00000000    \n   0.00000000    \n   1.00000000    \n  -0.00000000    \n  -1.00000000"
            ]
        },
        "code": "subroutine outerprod3(va,vb,vv)\n!=============================================================================\nimplicit none\nreal(4),dimension(3),  intent(in ):: va,vb\nreal(4),dimension(3,3),intent(out):: vv\ninteger                        :: i\n!-----------------------------------------------------------------------------\ndo i=1,3\n   vv(:,i)=va(:)*vb(i)\nenddo\nend subroutine outerprod3\n",
        "answer": "subroutine outerprod3(va, vb, vv)\n\n    implicit none\n\n    real, dimension(3) :: va, vb, vv\n\n    vv(1) = va(1)*vb(1)\n    vv(2) = va(1)*vb(2)\n    vv(3) = va(1)*vb(3)\n    vv(4) = va(2)*vb(1)\n    vv(5) = va(2)*vb(2)\n    vv(6) = va(2)*vb(3)\n    vv(7) = va(3)*vb(1)\n    vv(8) = va(3)*vb(2)\n    vv(9) = va(3)*vb(3)\n\nend subroutine outerprod3\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called matrix_diagonal to extract the diagonal elements of a matrix and store them in an array. The number of input parameters is 3, the first parameter is a two-dimensional array of type real, representing the matrix; The second parameter is a one-dimensional array of type real, representing the diagonal elements; The third parameter is an integer, representing the size of the matrix. The number of output parameters is 1, which is the diagonal array.",
            "Write a Fortran subroutine named \"matrix_diagonal\" that computes the diagonal elements of a square matrix. The subroutine takes 3 input parameters: \"a\" which is a 2-dimensional real array representing the matrix, \"n\" which is an integer specifying the size of the matrix, and \"diag\" which is a 1-dimensional real array that will store the diagonal elements. The subroutine also has no output parameters.",
            "Write a Fortran subroutine called \"get_diagonal\" to extract the diagonal elements from a square matrix. The subroutine has 3 input parameters: \n1. \"a\" is a two-dimensional real array that represents the matrix.\n2. \"n\" is an integer specifying the size of the matrix.\nBoth parameters are passed by reference.\nThe subroutine also has 1 output parameter:\n1. \"diag\" is a one-dimensional real array that will store the diagonal elements of the matrix.\nThe subroutine uses the \"implicit none\" statement to enforce explicit declaration of variables. Inside the subroutine, a temporary one-dimensional real array called \"tmp\" is created to store the flattened matrix. The \"pack\" function is then used to extract the diagonal elements from \"tmp\" and store them in \"diag\"."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    real, dimension(n,n) :: matrix\n    real, dimension(n) :: diagonal\n    \n    ! Test case 1\n    matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 2\n    matrix = reshape([0.5, -1.0, 2.0, -3.0, 4.5, -6.0, 7.5, -9.0, 10.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix = reshape([-1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [n,n])\n    call matrix_diagonal(matrix, diagonal, n)\n    print *, diagonal\n    print *, \"&\"\n    \nend program main\n",
            "result": [
                "1.00000000       5.00000000       9.00000000",
                "0.500000000       4.50000000       10.0000000",
                "2.00000000       10.0000000       18.0000000",
                "-1.00000000      -5.00000000      -9.00000000",
                "0.00000000       0.00000000       0.00000000"
            ]
        },
        "code": "    subroutine matrix_diagonal(a, diag, n)\n        implicit none\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:), intent(out) :: diag\n        integer, intent(in) :: n\n        real, dimension(1:size(a)) :: tmp\n\n        tmp = pack(a,.true.)\n        diag = tmp(1:n*n:n+1)\n    end subroutine\n",
        "answer": "subroutine matrix_diagonal(matrix, diagonal, n)\n\n    real, dimension(:,:), intent(in) :: matrix\n    real, dimension(:), intent(out) :: diagonal\n    integer, intent(in) :: n\n    integer :: i\n\n    do i = 1, n\n        diagonal(i) = matrix(i, i)\n    end do\n\nend subroutine matrix_diagonal\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called scattering_matrix_fresnel to compute the scattering matrix for the Fresnel equation. The subroutine takes 2 input parameters, both of type complex*16. The first parameter is k1, the incident wavevector, and the second parameter is k2, the transmitted wavevector. The subroutine also takes an optional input parameter, sigma, of type double precision. The subroutine has 1 output parameter, s, which is a 2x2 matrix of type complex*16.\n\nTo compute the scattering matrix, the subroutine first calculates the reflection coefficient r using the Fresnel equation. Then, it calculates the transmission coefficient t. Finally, it assigns the values of r and t to the elements of the output matrix s.\n\nThe subroutine should be called by providing the values for k1 and k2 as input, and optionally providing the value for sigma. The resulting scattering matrix s will be returned as output.",
            "Write a Fortran subroutine called scattering_matrix_fresnel that calculates the scattering matrix for Fresnel reflection and transmission. The subroutine takes 4 input parameters: k1 and k2, both of type complex*16, represent the incident and transmitted wave vectors respectively; sigma, of type double precision, represents the surface roughness; and s, a 2x2 complex*16 array, is the output scattering matrix.\n\nTo compute the scattering matrix, the subroutine first calculates the reflection coefficient (r) and transmission coefficient (t) using the provided formulas. The subroutine then assigns the values of r and t to the appropriate elements of the output array s.\n\nThe subroutine utilizes the complex*16 data type for complex numbers and the double precision data type for the surface roughness parameter. The subroutine is intended to be called with the intent(in) attribute for all input parameters and the intent(out) attribute for the output array.\n\nNote: The code also includes a commented line for an optional input parameter sigma, which can be enabled by uncommenting it and removing the exclamation mark before \"f2py\".",
            "Create a Fortran subroutine called scattering_matrix_fresnel to compute the scattering matrix for Fresnel reflection and transmission. The subroutine takes in four parameters: k1 and k2, both complex numbers representing the incident and transmitted wavevectors respectively, sigma which is a double precision number representing the surface roughness, and an optional parameter sigma which is also a double precision number representing the surface roughness. The subroutine has an output parameter s, which is a 2x2 complex matrix representing the scattering matrix.\n\nInside the subroutine, the reflection coefficient r and transmission coefficient t are computed using the given formulas. The values of r and t are then assigned to the appropriate elements of the matrix s.\n\nMake sure to specify the complex and double precision data types for the input and output parameters, and use the intent(in) and intent(out) keywords to indicate the direction of data flow."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: k1, k2, r11, r12, r21, r22\n    double precision :: sigma\n    complex*16, dimension(2,2) :: s\n    ! Test case 1\n    k1 = (1.0, 0.0)\n    k2 = (2.0, 0.0)\n    sigma = 0.5\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 2\n    k1 = (2.0, 1.0)\n    k2 = (3.0, -2.0)\n    sigma = 1.0\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 3\n    k1 = (0.5, 0.5)\n    k2 = (0.5, -0.5)\n    sigma = 0.25\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 4\n    k1 = (1.0, 1.0)\n    k2 = (1.0, 1.0)\n    sigma = 0.0\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \n    ! Test case 5\n    k1 = (-1.0, 0.0)\n    k2 = (0.0, -1.0)\n    sigma = 0.5\n    call scattering_matrix_fresnel(k1, k2, sigma, s)\n    r11 = s(1,1)\n    r12 = s(1,2)\n    r21 = s(2,1)\n    r22 = s(2,2)\n    print *, r11, r12, r21, r22\n    print *, \"&\"\n    \nend program main",
            "result": [
                "(-0.12262648039048077     ,  0.0000000000000000     ) (  1.0683426070061324     ,  0.0000000000000000     ) (  1.0683426070061324     ,  0.0000000000000000     ) ( 0.12262648039048077     , -0.0000000000000000     )",
                "( -4.0690075827569781E-008, -5.6702298301253908E-008) ( -1.9621765089947452E-002, -5.5746313707530273E-003) ( -1.9621765089947452E-002, -5.5746313707530273E-003) (  4.0690075827569781E-008,  5.6702298301253908E-008)",
                "(  0.0000000000000000     , 0.93941306281347581     ) (  1.3707027852991880     ,  0.0000000000000000     ) (  1.3707027852991880     ,  0.0000000000000000     ) ( -0.0000000000000000     ,-0.93941306281347581     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     ,  0.0000000000000000     ) ( -0.0000000000000000     , -0.0000000000000000     )",
                "(-0.47942553860420301     ,-0.87758256189037276     ) ( -1.3702490875349536     , 0.34988203456254696     ) ( -1.3702490875349536     , 0.34988203456254696     ) ( 0.47942553860420301     , 0.87758256189037276     )"
            ]
        },
        "code": "    subroutine scattering_matrix_fresnel(k1, k2, sigma, s)\n        complex*16, intent(in) :: k1, k2\n        double precision, intent(in) :: sigma\n        !f2py double precision, intent(in), optional:: sigma=0\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        complex*16 :: r, t\n        \n        r = (k1-k2) / (k1+k2) * cdexp(-2*sigma**2*k1*k2)\n        t = 2*cdsqrt(k1*k2) / (k1+k2) * cdexp(5d-1*sigma**2*(k1-k2)**2)\n        s(1,1) = r\n        s(1,2) = t\n        s(2,1) = t\n        s(2,2) = -r\n    end subroutine scattering_matrix_fresnel\n",
        "answer": "subroutine scattering_matrix_fresnel(k1, k2, s, sigma)\n    implicit none\n    complex*16, intent(in) :: k1, k2\n    complex*16, dimension(2,2) :: s\n    double precision, optional :: sigma\n    complex*16 :: r, t\n\n    r = (k1 - k2) / (k1 + k2)\n    t = 2 * k1 / (k1 + k2)\n\n    if (present(sigma)) then\n        s(1,1) = r * (1 - sigma)\n        s(1,2) = -t * (1 - sigma)\n        s(2,1) = -r * sigma\n        s(2,2) = t * sigma\n    else\n        s(1,1) = r\n        s(1,2) = -t\n        s(2,1) = -r\n        s(2,2) = t\n    end if\nend subroutine scattering_matrix_fresnel\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called scattering_matrix_translation that calculates the scattering matrix for a given wavevector and thickness. The subroutine expects 2 input parameters: k1 of type complex*16 and thickness of type double precision. It also has 1 output parameter: s, which is a 2x2 array of complex*16. \n\nTo compute the scattering matrix, set the first element of s to 0 and the second element to cdexp(-ci*thickness*k1), where cdexp is the complex exponential function and ci is the imaginary unit. Then set the third element of s to cdexp(-ci*thickness*k1) and the fourth element to 0.",
            "Provide a Fortran subroutine called scattering_matrix_translation to calculate the scattering matrix for a given wave vector and thickness. The subroutine takes 3 input parameters: the first parameter is a complex number representing the wave vector (k1), the second parameter is a double precision number representing the thickness, and the third parameter is a 2x2 complex array (s) representing the scattering matrix. The subroutine calculates the scattering matrix and stores the result in the 's' array. The resulting scattering matrix is computed based on the formula provided in the code. It assigns the values of the scattering matrix elements as follows: s(1,1) = 0, s(1,2) = exp(-i * thickness * k1), s(2,1) = exp(-i * thickness * k1), and s(2,2) = 0.",
            "Provide a Fortran subroutine code called \"scattering_matrix_translation\" which calculates the scattering matrix for translation in a scattering process. The subroutine has 3 input parameters and 1 output parameter. The input parameters are \"k1\" of type complex*16, representing a wavevector, \"thickness\" of type double precision, representing the thickness of the translation, and \"s\" of type complex*16, a 2x2 matrix. The output parameter \"s\" is a 2x2 matrix of type complex*16, representing the scattering matrix for translation. The subroutine assigns values to the elements of the matrix \"s\" based on the input values of \"k1\" and \"thickness\". The generated instruction should use an imperative tone."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: k, result(2,2)\n    double precision :: thickness\n    ! Test case 1\n    k = (1.0, 0.0)\n    thickness = 0.1\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n\n    ! Test case 2\n    k = (0.5, 0.5)\n    thickness = 0.5\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 3\n    k = (1.0, 1.0)\n    thickness = 1.0\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 4\n    k = (0.0, 1.0)\n    thickness = 0.2\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\n    \n    ! Test case 5\n    k = (2.0, 2.0)\n    thickness = 0.7\n    call scattering_matrix_translation(k, thickness, result)\n    print *, result(1,1), result(1,2), result(2,1), result(2,2)\n    print *, \"&\"\nend program main",
            "result": [
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -0.0000000000000000     ) (  1.0000000000000000     , -0.0000000000000000     ) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -3.9043678462250216E-042) (  1.0000000000000000     , -3.9043678462250216E-042) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -1.5617471384900086E-041) (  1.0000000000000000     , -1.5617471384900086E-041) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -3.1234943235237090E-042) (  1.0000000000000000     , -3.1234943235237090E-042) (  0.0000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     ) (  1.0000000000000000     , -2.1864459566510587E-041) (  1.0000000000000000     , -2.1864459566510587E-041) (  0.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "    subroutine scattering_matrix_translation(k1, thickness, s)\n        complex*16, intent(in) :: k1\n        double precision, intent(in) :: thickness\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        s(1,1) = 0d0\n        s(1,2) = cdexp(-ci*thickness*k1)\n        s(2,1) = cdexp(-ci*thickness*k1)\n        s(2,2) = 0d0\n    end subroutine scattering_matrix_translation\n",
        "answer": "subroutine scattering_matrix_translation(k1, thickness, s)\n    implicit none\n    complex*16, intent(in) :: k1\n    double precision, intent(in) :: thickness\n    complex*16, dimension(2,2), intent(out) :: s\n\n    s(1,1) = 0\n    s(1,2) = cdexp(-ci*thickness*k1)\n    s(2,1) = cdexp(-ci*thickness*k1)\n    s(2,2) = 0\nend subroutine scattering_matrix_translation\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"second_order_centered_real\" that computes the second-order centered finite difference approximation for the derivative of a real-valued function. The subroutine takes 4 input parameters: an integer \"llim\" representing the lower limit of the array indices, a real array \"f\" that contains the function values, a real \"del\" representing the step size, and an output real array \"df\" to store the computed derivatives. The subroutine calculates the derivative values for the function array \"f\" using the centered differencing formula and stores the results in the output array \"df\". The subroutine uses a do loop to iterate over the function array and perform the difference calculation.",
            "Write a Fortran subroutine called \"second_order_centered_real\" that computes the derivative of a given real array using a second-order centered differencing scheme. The subroutine takes four input parameters: llim, which is an integer representing the lower limit of the array indices; f, which is a real array containing the function values; del, which is a real value representing the spacing between array elements; and df, which is an output real array where the derivative values will be stored. \n\nIn the subroutine, the array size is determined by the size of the input array f. The derivative values at the lower and upper boundaries are computed using the forward and backward differences, respectively, with second-order accuracy. The derivative values at the interior points are computed using the centered difference formula. \n\nTo compute the derivative, the subroutine iterates over the array indices from llim+1 to llim+n-1, where n is the size of the input array. At each index, the derivative is computed by subtracting the function value at the previous index from the function value at the next index, and dividing the result by twice the spacing del.\n\nMake sure to include the \"implicit none\" statement at the beginning of the subroutine to ensure all variables are explicitly declared.",
            "Give me a Fortran subroutine code called second_order_centered_real to compute the centered finite difference approximation for the derivative of a real array. The number of input parameters is 3, the first parameter is the lower limit of the array, the type is integer; The second argument is the array to be differentiated, the type is real; The third argument is the spacing between array elements, the type is real. The number of output arguments is 1, the argument is the differentiated array, the type is real and has the same size as the input array."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: llim, i\n    real, dimension(:), allocatable :: f, df\n    real :: del\n    \n    ! Test case 1\n    llim = 1\n    del = 0.1\n    allocate(f(llim:3))\n    f = [1.0, 2.0, 3.0]\n    allocate(df(llim:3))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 2\n    llim = 2\n    del = 0.2\n    allocate(f(llim:5))\n    f = [2.0, 4.0, 6.0, 8.0]\n    allocate(df(llim:5))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 3\n    llim = 4\n    del = 0.05\n    allocate(f(llim:6))\n    f = [4.0, 5.0, 6.0, 7.0]\n    allocate(df(llim:6))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 4\n    llim = 3\n    del = 0.1\n    allocate(f(llim:7))\n    f = [3.0, 4.0, 5.0, 6.0, 7.0]\n    allocate(df(llim:7))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \n    ! Test case 5\n    llim = 2\n    del = 0.3\n    allocate(f(llim:4))\n    f = [2.0, 3.0, 4.0]\n    allocate(df(llim:4))\n    call second_order_centered_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    deallocate(f)\n    deallocate(df)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "10.0000000    \n   10.0000000    \n  -10.0000000",
                "10.0000000    \n   10.0000000    \n   10.0000000    \n  -15.0000000",
                "50.0000000    \n   20.0000000    \n   20.0000000    \n  -60.0000000",
                "20.0000000    \n   10.0000000    \n   10.0000000    \n   10.0000000    \n  -30.0000000",
                "5.00000000    \n   3.33333325    \n  -5.00000000"
            ]
        },
        "code": "   subroutine second_order_centered_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      df(istart) = f(istart + 1) / (2.*del)\n      df(iend) = -f(iend - 1) / (2.*del)\n\n      ! 2nd order accurate centered\n      do i = istart + 1, iend - 1\n         df(i) = (f(i + 1) - f(i - 1)) / (2.*del)\n      end do\n\n   end subroutine second_order_centered_real\n",
        "answer": "subroutine second_order_centered_real(llim, f, del, df)\n    integer, intent(in) :: llim\n    real, dimension(llim:), intent(in) :: f\n    real, intent(in) :: del\n    real, dimension(llim:), intent(out) :: df\n    integer :: i\n\n    do i = llim+1, llim+2\n        df(i) = (f(i+1) - f(i-1)) / (2.0 * del)\n    end do\n\nend subroutine second_order_centered_real\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called four_point_triangle_real that calculates the derivative of a given function at multiple points using a four-point triangular stencil. The subroutine takes four input parameters and has one output parameter. \n\nThe input parameters are:\n1. llim: an integer indicating the lower limit of the array indices.\n2. f: a real array of size llim and above, representing the function values.\n3. del: a real value representing the step size for the derivative calculation.\n\nThe output parameter is:\n1. df: a real array of size llim and above, representing the derivative values.\n\nTo calculate the derivative, the subroutine uses a four-point stencil centered at each point. It applies different formulas depending on whether the point is at the lower limit or upper limit of the array or if it is an interior point. The derivative values are stored in the df array.\n\nPlease note that this subroutine assumes that the f array has been properly initialized and has enough elements to perform the calculations.",
            "Provide a Fortran subroutine called four_point_triangle_real to calculate the derivative of a given function using a four-point finite difference scheme. The subroutine takes four input parameters: llim (an integer), which represents the lower limit of the array; f (an array of real numbers), which contains the function values; del (a real number), which represents the step size for the finite difference scheme. The subroutine also has one output parameter: df (an array of real numbers), which stores the calculated derivative values.\n\nTo compute the derivatives, the subroutine applies a second-order accurate centered scheme for the interior points of the array, and boundary schemes for the first and last points. The derivative values are calculated based on the neighboring function values and the step size.\n\nThe subroutine iterates over the array and computes the derivative values using the specified formulas. The resulting derivative values are stored in the df array.\n\nEnsure that the subroutine is used in a Fortran program to obtain accurate derivative approximations for a given function.",
            "Write a Fortran subroutine called four_point_triangle_real that computes the finite difference approximation of the derivative of a real-valued function. The subroutine takes four input parameters: an integer llim representing the lower limit of the array, a real array f of size llim or greater, a real value del representing the step size, and an output real array df of size llim or greater. \n\nInside the subroutine, the derivative is calculated using a second-order accurate centered differencing scheme for the interior points, and a three-point stencil at the boundaries. The computed derivatives are stored in the df array.\n\nTo calculate the derivatives, the subroutine initializes the boundary derivatives based on the values of f, and then iterates over the interior points of f to compute the centered differences. The resulting derivatives are stored in the df array.\n\nNote: The subroutine assumes that the size of the f and df arrays is sufficient to hold the required values.\n\nYour task is to write an instruction for the subroutine code."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: llim, i\n    real, dimension(10) :: f, df\n    real :: del\n    \n    ! Test case 1\n    llim = 1\n    f = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n    del = 0.1\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    llim = 0\n    f = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n    del = 0.2\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    llim = 5\n    f = [5.0, 4.0, 3.0, 2.0, 1.0, 0.0, -1.0, -2.0, -3.0, -4.0]\n    del = 0.5\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    llim = -3\n    f = [-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n    del = 0.05\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    llim = 2\n    f = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]\n    del = 0.1\n    call four_point_triangle_real(llim, f, del, df)\n    do i = llim, llim + size(f) - 1\n        print *, df(i)\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "10.0000000    \n   10.0000000    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   3.33333325    \n   15.5555553    \n   10.0000000    \n  -45.0000000",
                "0.00000000    \n   1.25000000    \n   2.50000000    \n   1.11111104    \n  0.833333313    \n  0.833333313    \n  0.833333313    \n  0.833333313    \n   3.61111093    \n   2.50000000",
                "-0.666666687    \n -0.666666687    \n -0.666666687    \n  -1.77777779    \n  -2.00000000    \n   3.00000000    \n  0.500000000    \n   1.68155816E-44\n  -1.92279614E-09\n   4.59149455E-41",
                "5.00000000    \n   6.00000000    \n   1.10756837E-37\n   0.00000000    \n  -20.0000000    \n   20.0000000    \n   15.5555553    \n   6.66666651    \n   6.66666651    \n   6.66666651",
                "0.00000000    \n  -2.22222209    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   2.22222209    \n   0.00000000    \n  -10.0000000    \n  0.100000001"
            ]
        },
        "code": "   subroutine four_point_triangle_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      i = istart\n      df(i) = f(i + 1) / (2.0 * del)\n      i = istart + 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = istart + 2\n      df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1)) / (18.0 * del)\n\n      i = iend\n      df(i) = -f(i - 1) / (2.0 * del)\n      i = iend - 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = iend - 2\n      df(i) = (9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n\n      ! 2nd order accurate centered\n      do i = istart + 3, iend - 3\n         df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n      end do\n\n   end subroutine four_point_triangle_real\n",
        "answer": "subroutine four_point_triangle_real(llim, f, df, del)\n    integer, intent(in) :: llim\n    real, dimension(llim:), intent(in) :: f\n    real, dimension(llim:), intent(out) :: df\n    real, intent(in) :: del\n    integer :: i\n\n    do i = llim, llim+1\n        if (i == llim) then\n            df(i) = (-3.0*f(i) + 4.0*f(i+1) - f(i+2)) / (2.0*del)\n        else if (i == llim+1) then\n            df(i) = (f(i-1) - 4.0*f(i) + 3.0*f(i+1)) / (2.0*del)\n        else\n            df(i) = (f(i-1) - f(i+1)) / (2.0*del)\n        end if\n    end do\n\nend subroutine four_point_triangle_real\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called \"get_overlap\" to calculate the overlap between two Gaussian distributions. The subroutine takes in six parameters: \n- The number of variables (integer)\n- A logical parameter indicating whether to apply a factor to the overlap calculation (logical)\n- Arrays \"vs1\", \"vs2\", and \"sigmas\" of type real, each with \"nv\" elements\n- An output variable \"ov\" of type real\n\nTo use the subroutine, provide the number of variables, the logical flag, and the arrays \"vs1\", \"vs2\", and \"sigmas\" as input. The subroutine will calculate the overlap and store the result in the \"ov\" variable.\n\nMake sure to define the \"pi\" constant and variables \"dv\" and \"factor\" as real*8. The subroutine iterates over the arrays and calculates the overlap between the two Gaussian distributions using the provided formulas.\n\nRemember to use the \"implicit none\" statement at the beginning of the subroutine to enforce explicit variable declaration.",
            "Write a Fortran subroutine called get_overlap that calculates the overlap between two Gaussian distributions. The subroutine takes six parameters: nv, ifactor, vs1, vs2, sigmas, and ov. \n\nThe nv parameter is an integer that specifies the size of the vs1, vs2, and sigmas arrays. The ifactor parameter is a logical value that determines whether a factor should be applied to the calculation. The vs1, vs2, and sigmas parameters are arrays of real*8 type that represent the mean values and standard deviations of the Gaussian distributions. The ov parameter is a real*8 variable that stores the calculated overlap.\n\nIn the subroutine, the overlap is calculated by iterating over each element of the arrays vs1, vs2, and sigmas. A difference value (dv) is computed as the difference between vs1 and vs2. If the ifactor is true, a factor is calculated as 2 times the standard deviation multiplied by the square root of pi. The overlap is then updated by multiplying it with the exponential value of -dv^2 divided by (4 times sigmas^2) and dividing it by the factor.\n\nThe subroutine ends with the ov parameter containing the calculated overlap.\n\nYour task is to write the Fortran subroutine called get_overlap with the given input and output parameters.",
            "Create a Fortran subroutine called \"get_overlap\" that calculates the overlap between two Gaussian distributions. The subroutine has 5 input parameters: \n- \"nv\" is an integer representing the size of the arrays,\n- \"ifactor\" is a logical value,\n- \"vs1\" and \"vs2\" are arrays of real numbers representing the means of the Gaussian distributions,\n- \"sigmas\" is an array of real numbers representing the standard deviations of the Gaussian distributions. \n\nThe subroutine has 1 output parameter: \n- \"ov\" is a real number representing the calculated overlap between the two distributions. \n\nInside the subroutine, a loop is used to calculate the overlap for each element of the arrays. The overlap is calculated using the formula exp(-dv*dv/(4.0*sigmas(i)*sigmas(i)))/factor, where \"dv\" represents the difference between \"vs1(i)\" and \"vs2(i)\", and \"factor\" is set to 1.0 by default but can be adjusted if \"ifactor\" is true. The value of \"pi\" is set to 3.1415926."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nv\n    logical :: ifactor\n    real*8 :: vs1(3), vs2(3), sigmas(3), ov\n    integer :: i\n    real*8 :: pi = 3.1415926\n\n    ! Test case 1\n    nv = 3\n    ifactor = .true.\n    vs1 = [1.0, 2.0, 3.0]\n    vs2 = [4.0, 5.0, 6.0]\n    sigmas = [0.1, 0.2, 0.3]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n\n    ! Test case 2\n    nv = 3\n    ifactor = .false.\n    vs1 = [0.5, 1.5, 2.5]\n    vs2 = [3.5, 4.5, 5.5]\n    sigmas = [0.2, 0.3, 0.4]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 3\n    nv = 3\n    ifactor = .true.\n    vs1 = [0.1, 0.2, 0.3]\n    vs2 = [0.4, 0.5, 0.6]\n    sigmas = [0.3, 0.4, 0.5]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 4\n    nv = 3\n    ifactor = .false.\n    vs1 = [1.0, 1.0, 1.0]\n    vs2 = [1.0, 1.0, 1.0]\n    sigmas = [0.1, 0.1, 0.1]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \n    ! Test case 5\n    nv = 3\n    ifactor = .true.\n    vs1 = [0.5, 0.5, 0.5]\n    vs2 = [0.0, 0.0, 0.0]\n    sigmas = [0.2, 0.2, 0.2]\n    call get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n    print *, ov\n    print *, \"&\"\n    \nend program main",
            "result": [
                "3.7183766133961392E-133",
                "4.0393265722719726E-042",
                "0.23136687520179433",
                "1.0000000000000000",
                "2.5842820176605625E-002"
            ]
        },
        "code": "subroutine get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n\n    ! \n    ! calculate the overlap between two \n    ! gaussian distribution \n    !\n    ! parameters\n    ! =============================================\n    ! \n    ! \n\n    implicit none\n\n    integer, intent(in) :: nv\n    logical, intent(in) :: ifactor\n    real*8, intent(in) :: vs1(nv), vs2(nv), sigmas(nv)\n    real*8, intent(out) :: ov\n    integer :: i\n    real*8, parameter :: pi = 3.1415926\n    real*8 :: dv, factor\n\n    ov = 1.0\n    do i = 1,nv\n        dv = vs1(i) - vs2(i)\n        factor = 1.0\n        if ( ifactor ) then \n            factor = 2.0 * sigmas(i) * sqrt(pi)\n        endif\n        ov = ov * exp( -dv*dv/(4.0*sigmas(i)*sigmas(i)) )/factor\n    enddo\n\nend subroutine get_overlap\n",
        "answer": "subroutine get_overlap(nv, apply_factor, vs1, vs2, sigmas, ov)\n    implicit none\n    integer, intent(in) :: nv\n    logical, intent(in) :: apply_factor\n    real, intent(in) :: vs1(nv), vs2(nv), sigmas(nv)\n    real :: ov\n    real*8 :: dv, factor\n    integer :: i\n\n    dv = 1.0 / real(nv)\n    factor = 1.0\n    if (apply_factor) factor = 2.0 * sqrt(pi)\n\n    ov = 0.0\n    do i = 1, nv\n        ov = ov + factor * exp(-(vs1(i) - vs2(i))**2 / (2.0 * sigmas(i)**2)) * dv\n    end do\nend subroutine get_overlap\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called cross_product to compute the cross product of two vectors in three-dimensional space. The number of input parameters is 6, all of type real and represent the x, y, and z components of the two vectors. The number of output parameters is also 3, all of type real and represent the components of the resulting cross product vector.",
            "Provide a Fortran subroutine code called cross_product that calculates the cross product of two vectors. The subroutine has 9 parameters. The first 6 parameters are input parameters of type real*8, representing the x, y, and z components of the first and second vectors. The last 3 parameters are output parameters of type real*8, representing the x, y, and z components of the resulting cross product.",
            "Provide a Fortran subroutine called cross_product that calculates the cross product of two 3D vectors. The subroutine takes in six input parameters, all of type real(8), namely x1, y1, z1, x2, y2, z2 representing the components of the two vectors. It also has three output parameters, x3, y3, z3, all of type real(8), representing the components of the resulting cross product vector."
        ],
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    real*8 :: x1, y1, z1, x2, y2, z2, x3, y3, z3\n    \n    ! Test case 1\n    x1 = 1.0\n    y1 = 2.0\n    z1 = 3.0\n    x2 = 4.0\n    y2 = 5.0\n    z2 = 6.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n\n    ! Test case 2\n    x1 = 0.5\n    y1 = -1.0\n    z1 = 2.0\n    x2 = -1.5\n    y2 = 0.0\n    z2 = 3.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = 2.0\n    y1 = 3.0\n    z1 = 4.0\n    x2 = -1.0\n    y2 = -2.0\n    z2 = -3.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 0.0\n    y1 = 1.0\n    z1 = 0.0\n    x2 = 0.0\n    y2 = 0.0\n    z2 = 1.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -2.0\n    y1 = 4.0\n    z1 = -1.0\n    x2 = 3.0\n    y2 = -2.0\n    z2 = 5.0\n    call cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    print *, x3, y3, z3\nend program main\n",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000",
                "-3.0000000000000000       -4.5000000000000000       -1.5000000000000000",
                "-1.0000000000000000        2.0000000000000000       -1.0000000000000000",
                "1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "18.000000000000000        7.0000000000000000       -8.0000000000000000"
            ]
        },
        "code": "      subroutine cross_product(x1,y1,z1,x2,y2,z2,x3,y3,z3)\n      implicit real*8(a-h,o-z)\n      real(8),intent(in) :: x1,y1,z1,x2,y2,z2\n      real(8),intent(out) :: x3,y3,z3\n\n      x3=y1*z2-y2*z1\n      y3=x2*z1-x1*z2\n      z3=x1*y2-x2*y1\n\n      end subroutine cross_product\n",
        "answer": "subroutine cross_product(a, b, c)\n    real, intent(in) :: a(3), b(3)\n    real, intent(out) :: c(3)\n\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n\nend subroutine cross_product\n"
    },
    {
        "instruction": [
            "Provide me with a Fortran subroutine code called ssm_title that converts an integer into a 3-character zero-filled string. The subroutine takes 2 input parameters: an integer called n and a character variable called nchar. It also has 1 output parameter: a 3-character zero-filled string called nchar.",
            "Provide a Fortran subroutine called \"ssm_title\" to convert an integer to a 3-character zero-filled string. The subroutine takes two input parameters: \"n\" of type integer, which is the number to be converted, and \"nchar\" of type character(len=3), which is the output string. There is 1 output parameter: \"nchar\", which will contain the converted string. \n\nTo generate the output string:\n1. Declare local variables \"nchar1\" of type character(len=1), \"nchar2\" of type character(len=2), and \"nchar3\" of type character(len=3).\n2. Check if the input number \"n\" is greater than or equal to 100.\n3. If true, convert \"n\" to a 3-character string using the format '(i3)', and store it in \"nchar3\".\n4. If \"n\" is not greater than or equal to 100, check if \"n\" is greater than or equal to 10.\n5. If true, convert \"n\" to a 2-character string using the format '(i2)', and store it in \"nchar2\".\n6. If \"n\" is not greater than or equal to 10, convert \"n\" to a 1-character string using the format '(i1)', and store it in \"nchar1\".\n7. Concatenate \"0\" with \"nchar2\" and assign it to \"nchar\" if \"n\" is greater than or equal to 10.\n8. Concatenate \"00\" with \"nchar1\" and assign it to \"nchar\" if \"n\" is less than 10.\n9. The output string \"nchar\" will contain the 3-character zero-filled representation of the input number \"n\".",
            "Give me a Fortran subroutine code called ssm_title to convert an integer to a 3-character zero-filled string. The number of input parameters is 2, the first parameter is the integer to be converted, the type is integer. The second argument is the output string, which has a length of 3 characters. The number of output arguments is 1, which is the converted string."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input1, input2, input3, input4, input5\n    character(len=3) :: result1, result2, result3, result4, result5\n    ! Test case 1\n    input1 = 123\n    call ssm_title(input1, result1)\n    print *, result1\n    print *, \"&\"\n\n    ! Test case 2\n    input2 = 9\n    call ssm_title(input2, result2)\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    input3 = 56\n    call ssm_title(input3, result3)\n    print *, result3\n    print *, \"&\"\n    \n    ! Test case 4\n    input4 = 789\n    call ssm_title(input4, result4)\n    print *, result4\n    print *, \"&\"\n    \n    ! Test case 5\n    input5 = 1\n    call ssm_title(input5, result5)\n    print *, result5\n    print *, \"&\"\nend program main",
            "result": [
                "123",
                "009",
                "056",
                "789",
                "001"
            ]
        },
        "code": "subroutine ssm_title(n,nchar)\n  ! returns integer as a 3-character zero-filled string\n  ! used to generate filenames for tables\n\n  implicit none\n  integer,intent(in)::n\n  character(len=3),intent(out)::nchar\n\n  character(len=1)::nchar1\n  character(len=2)::nchar2\n  character(len=3)::nchar3\n\n  if(n.ge.100)then\n     write(nchar3,'(i3)') n\n     nchar = nchar3\n  elseif(n.ge.10)then\n     write(nchar2,'(i2)') n\n     nchar = '0'//nchar2\n  else\n     write(nchar1,'(i1)') n\n     nchar = '00'//nchar1\n  endif\n\nend subroutine ssm_title\n",
        "answer": "subroutine ssm_title(n, nchar)\n\n    implicit none\n\n    integer, intent(in) :: n\n    character(len=3), intent(out) :: nchar\n\n    if (n .lt. 10) then\n        write(nchar, '(i1)') n\n    else if (n .lt. 100) then\n        write(nchar, '(i2)') n\n    else\n        write(nchar, '(i3)') n\n    end if\n\n    return\n\nend subroutine ssm_title\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called factorial that computes the factorial of a given number. The subroutine takes 2 input parameters: an integer called \"n\" to represent the number for which the factorial is to be computed, and an output parameter \"result\" of type integer to store the computed factorial value. \n\nInstruct the subroutine to use recursion to calculate the factorial. If the input number \"n\" is greater than or equal to 1, call the factorial subroutine recursively with the argument \"n-1\" and store the result in a temporary variable \"temp\". Multiply \"n\" with \"temp\" and assign the result to the output parameter \"result\". \n\nIf the input number \"n\" is less than 1, set the output parameter \"result\" to 1.",
            "Create a Fortran subroutine called factorial to compute the factorial of a given number. The subroutine takes 2 input parameters: an integer 'n' indicating the number to calculate the factorial for, and an output parameter 'result' which is also an integer to store the computed factorial value. The factorial is calculated recursively. The subroutine should be called using the 'call' statement with the appropriate arguments.",
            "Write a Fortran subroutine called factorial to calculate the factorial of a given number recursively. The subroutine takes 2 parameters as input and output. The first parameter is an integer called \"n\" which represents the number for which the factorial will be calculated. The second parameter is an integer called \"result\" which holds the factorial value as output."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input, output\n    ! Test case 1\n    input = 5\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = 0\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 10\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 3\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 7\n    call factorial(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "120",
                "1",
                "3628800",
                "6",
                "5040"
            ]
        },
        "code": "recursive subroutine factorial(n, result)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: result\ninteger :: temp\n\nif (n >= 1) then\n  call factorial(n-1, temp)\n  result = n * temp\nelse\n  result = 1\nend if\nend subroutine factorial\n",
        "answer": "subroutine factorial(n, result)\n    integer, intent(in) :: n\n    integer, intent(out) :: result\n    integer :: temp\n\n    if (n >= 1) then\n        call factorial(n-1, temp)\n        result = n * temp\n    else\n        result = 1\n    end if\nend subroutine factorial\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called parse_date that extracts various components (year, month, day, hour, minute, second) from a given date string. The subroutine takes one input parameter, the date string, of type character. It also has six output parameters: sec, min, hour, day, month, and year, all of type integer. \n\nTo use the subroutine, pass the date string as the input parameter. The subroutine will then extract the year, month, day, hour, minute, and second from the date string and store them in the corresponding output parameters.",
            "Provide a Fortran subroutine called parse_date that extracts individual components (year, month, day, hour, minute, and second) from a given date string. The subroutine takes one input parameter, a character string representing the date. The subroutine has six output parameters, all of which are integers: year, month, day, hour, minute, and second.",
            "Provide a Fortran subroutine code called parse_date that extracts date and time information from a given string. The subroutine takes one input parameter of type character, representing the date in a specific format. The outputs are six parameters: sec, min, hour, day, month, and year, all of type integer. \n\nTo use the subroutine, pass a string representing the date in the format \"YYYY-MM-DD HH:MM:SS\" or \"YYYY-MM-DD\" as the input parameter. The subroutine will extract the year, month, day, hour, minute, and second values from the string and assign them to the corresponding output parameters.\n\nIf the input string does not contain time information, the subroutine will set sec, min, and hour to 0.\n\nPlease note that the subroutine does not perform any error checking on the input string format, so make sure it follows the specified format before calling the subroutine."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    character(len=20) :: date\n    integer :: year, month, day, hour, min, sec\n    ! Test case 1\n    date = \"2022-12-31 23:59:59\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n\n    ! Test case 2\n    date = \"2021-02-15\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 3\n    date = \"2023-08-01 12:34:56\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 4\n    date = \"2024-06-10\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\n    \n    ! Test case 5\n    date = \"2025-11-20 10:25:00\"\n    call parse_date(date, year, month, day, hour, min, sec)\n    print *, year, month, day, hour, min, sec\n    print *, \"&\"\nend program main",
            "result": [
                "2022          12          31          23          59          59",
                "2021           2          15           0           0           0",
                "2023           8           1          12          34          56",
                "2024           6          10           0           0           0",
                "2025          11          20          10          25           0"
            ]
        },
        "code": "    subroutine parse_date(date, year, month, day, hour, min, sec)\n      implicit none\n      character (len=*), intent(in) :: date\n      integer, intent(out) :: sec, min, hour, day, month, year\n\n      read(date(9:10),*) day\n      read(date(6:7),*) month\n      read(date(1:4),*) year\n      if(len_trim(date) <= 11) then\n         sec = 0\n         min = 0\n         hour = 0\n      else\n         read(date(18:19), *) sec\n         read(date(15:16), *) min\n         read(date(12:13), *) hour\n      endif\n    end subroutine parse_date\n",
        "answer": "subroutine parse_date(date, year, month, day, hour, min, sec)\n    character(len=*), intent(in) :: date\n    integer, intent(out) :: year, month, day, hour, min, sec\n\n    character(len=4) :: year_str\n    character(len=2) :: month_str, day_str\n    character(len=2) :: hour_str, min_str, sec_str\n\n    year_str = date(1:4)\n    month_str = date(6:7)\n    day_str = date(9:10)\n    hour_str = date(12:13)\n    min_str = date(15:16)\n    sec_str = date(18:19)\n\n    read(year_str, '(i4)') year\n    read(month_str, '(i2)') month\n    read(day_str, '(i2)') day\n    read(hour_str, '(i2)') hour\n    read(min_str, '(i2)') min\n    read(sec_str, '(i2)') sec\nend subroutine parse_date\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called `cart_sph` to convert Cartesian coordinates to spherical coordinates. The subroutine takes two input parameters: `x`, which is a two-dimensional array of real numbers representing the position vector in Cartesian coordinates, and `r`, which is a two-dimensional array of real numbers representing the position vector in spherical coordinates. The subroutine has no output parameters.\n\nIn the subroutine, the Cartesian coordinates are converted to spherical coordinates using the following formulas:\n1. The radial distance (`r(1,:)`) is computed as the square root of the sum of the squares of the Cartesian coordinates.\n2. The azimuthal angle (`r(2,:)`) is calculated as the inverse cosine of `x(1,:)` divided by the square root of the sum of the squares of `x(1,:)` and `x(2,:)`. If `x(2,:)` is negative, `r(2,:)` is computed as `2*pi` minus the azimuthal angle.\n3. If `x(1,:)` and `x(2,:)` are both zero, the azimuthal angle (`r(2,:)`) is set to `pi/2`.\n4. The polar angle or colatitude (`r(3,:)`) is computed as `pi/2` minus the inverse cosine of `x(3,:)` divided by the radial distance. If the radial distance is zero, the polar angle is set to `pi/2`.\n\nTo use the `cart_sph` subroutine, call it with the input parameter `x` containing the Cartesian coordinates, and the output parameter `r` to store the computed spherical coordinates.",
            "Give me a Fortran subroutine code called cart_sph to convert cartesian coordinates to spherical coordinates. The subroutine takes two input parameters: x, which is a 2D array of real numbers representing the cartesian coordinates, and r, which is a 2D array of real numbers representing the spherical coordinates. The subroutine has no return value. \n\nTo use the subroutine, call it using the syntax \"call cart_sph(x,r)\". The subroutine will calculate the radial distance, azimuthal angle, and polar angle for each set of cartesian coordinates and store them in the array r.",
            "Write a Fortran subroutine called \"cart_sph\" that converts Cartesian coordinates to spherical coordinates. The subroutine takes two input parameters and one output parameter. The first input parameter is a 2D array \"x\" of real numbers representing the position vector in Cartesian coordinates. The second input parameter is a 2D array \"r\" of real numbers that will store the position vector in spherical coordinates. The output parameter \"r\" is also a 2D array.\n\nHere's how the subroutine works:\n1. Compute the radial distance by taking the square root of the sum of the squares of the components of the position vector.\n2. Compute the azimuthal angle by using the arccosine function. If the y-coordinate of the position vector is negative, subtract the result from 2\u03c0 to ensure the angle is between 0 and 2\u03c0.\n3. Handle the special case where the x and y coordinates of the position vector are both zero. Set the azimuthal angle to \u03c0/2.\n4. Compute the polar angle by using the arccosine function. Subtract the result from \u03c0/2 to ensure the angle is between 0 and \u03c0.\n\nTo use the subroutine, call it with the \"x\" array as the input and the \"r\" array as the output."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8, dimension(3, 3) :: cartesian_coords\n    real*8, dimension(3, 3) :: spherical_coords\n    ! Test case 1\n    cartesian_coords = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n\n    ! Test case 2\n    cartesian_coords = reshape([0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 3\n    cartesian_coords = reshape([1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 4\n    cartesian_coords = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\n    \n    ! Test case 5\n    cartesian_coords = reshape([0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 1.0, -1.0, 0.0], [3, 3])\n    call cart_sph(cartesian_coords, spherical_coords)\n    print *, spherical_coords\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000       -1.5707963267948966        1.0000000000000000        1.5707963267948966       -1.5707963267948966        1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        1.5707963267948966       -1.5707963267948966        1.0000000000000000        3.1415926535897931       -1.5707963267948966        1.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042",
                "1.7320508075688772       0.78539816339744839      -0.95531661812450919        0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   1.7320508075688772       -2.3561944901923448       -2.1862760354652839",
                "0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   0.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042   1.7320508075688772       0.78539816339744839      -0.95531661812450919",
                "1.0000000000000000        7.6784149352678351E-042   7.6784149352678351E-042  0.70710678118654757       0.78539816339744839       -1.5707963267948966        1.4142135623730951      -0.78539816339744839       -1.5707963267948966"
            ]
        },
        "code": "subroutine cart_sph(x,r)\n\t!----------------------------------------------------------\n\t! switching from cartesian to spherical coordinates\n\t! calling sequence: call cart_sph(x,r)\n\t! input:  x: position vector in cartesian coordinates\n\t! output: r: position vector in spherical coordinates \n\t!            (radial distance,azimuthal angle,polar angle)\t\t\t!\n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: x\n\treal(kind=8), dimension(:,:), intent(out) :: r\n\n\tr(1,:) = sqrt(x(1,:)**2+x(2,:)**2+x(3,:)**2)\n\t\n\t!longitude\n\twhere (x(2,:) < 0.d0)\n\t\tr(2,:) = 2.d0*pi-acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\telsewhere  \n\t\tr(2,:) = acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\tend where\n\n\twhere (x(1,:) .eq. 0.d0 .and. x(2,:).eq. 0.d0)\n\t\tr(2,:) = pi/2.d0\n\tend where\n\t\n\t!colatitude\n\twhere (r(1,:) .ne. 0.d0)\n\t\tr(3,:) = pi/2.d0 - acos(x(3,:)/r(1,:))\n\telsewhere\n\t\tr(3,:) = pi/2.d0\n\tend where\n\nend subroutine cart_sph\n",
        "answer": "subroutine cart_sph(x, r)\n    implicit none\n    real, dimension(:,:), intent(in) :: x\n    real, dimension(:,:), intent(out) :: r\n    integer :: i, j\n\n    do i = 1, size(x, 1)\n        do j = 1, size(x, 2)\n            r(1,j) = sqrt(sum(x(:,j)**2))\n            if (x(1,j) == 0 .and. x(2,j) == 0) then\n                r(2,j) = pi/2\n            else\n                r(2,j) = acos(x(1,j) / r(1,j))\n                if (x(2,j) < 0) r(2,j) = 2*pi - r(2,j)\n            end if\n            if (r(1,j) == 0) then\n                r(3,j) = pi/2\n            else\n                r(3,j) = pi/2 - acos(x(3,j) / r(1,j))\n            end if\n        end do\n    end do\nend subroutine cart_sph\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called cart_cyl to convert coordinates from Cartesian to cylindrical system. The subroutine takes two input parameters and one output parameter. The first input parameter is a two-dimensional array called x, which represents the position vector in Cartesian coordinates and has a real kind of precision. The second input parameter, r, is also a two-dimensional array of real kind and represents the output position vector in cylindrical coordinates. The subroutine calculates the radial distance, angular coordinate, and altitude of each point in the Cartesian system and stores them in the corresponding elements of the output array, r. The subroutine follows the calling sequence: call cart_cyl(x, r).",
            "Give me a Fortran subroutine code called cart_cyl to convert Cartesian coordinates to cylindrical coordinates. The subroutine takes two input parameters, both of type real and of two-dimensional arrays. The first parameter, x, represents the position vector in Cartesian coordinates, and the second parameter, r, will hold the position vector in cylindrical coordinates as output. The subroutine will calculate the radial distance, angular coordinate, and altitude based on the input Cartesian coordinates and store the results in the output array r.",
            "Provide a Fortran subroutine code called cart_cyl that converts Cartesian coordinates to cylindrical coordinates. The subroutine has two input parameters and one output parameter. The input parameters are both two-dimensional arrays of type real, where the first parameter represents the position vector in Cartesian coordinates and the second parameter represents the output variable for the position vector in cylindrical coordinates. The output parameter is also a two-dimensional array of type real. The subroutine computes the radial distance, angular coordinate, and altitude from the Cartesian coordinates and stores them in the output array. The computed values are stored in the second dimension of the output array. The subroutine follows the imperative programming style and is called using the syntax \"call cart_cyl(x,r)\"."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8), dimension(3,3) :: cartesian_coords, cylindrical_coords\n    \n    ! Test case 1\n    cartesian_coords = reshape([1.0, 2.0, 3.0, 3.0, -2.0, 1.0, 0.0, 0.0, 2.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 2\n    cartesian_coords = reshape([0.5, 0.5, 1.0, 6.0, -7.0, 2.0, 0.0, 0.0, -3.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 3\n    cartesian_coords = reshape([2.0, -2.0, -3.0, 2.0, -1.0, 4.0, 0.0, 0.0, 0.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 4\n    cartesian_coords = reshape([0.0, 0.0, 0.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \n    ! Test case 5\n    cartesian_coords = reshape([5.0, 0.0, 0.0, 10.0, 0.0, 0.0, 15.0, 0.0, 0.0], [3, 3])\n    call cart_cyl(cartesian_coords, cylindrical_coords)\n    print *, cylindrical_coords\n    print *, \"&\"\n    \nend program main",
            "result": [
                "2.2360679774997898        1.1071487177940904        3.0000000000000000        3.6055512754639891      -0.58800260354756761        1.0000000000000000        0.0000000000000000        0.0000000000000000        2.0000000000000000",
                "0.70710678118654757       0.78539816339744817        1.0000000000000000        9.2195444572928871      -0.86217005466722629        2.0000000000000000        0.0000000000000000        0.0000000000000000       -3.0000000000000000",
                "2.8284271247461903      -0.78539816339744817       -3.0000000000000000        2.2360679774997898      -0.46364760900080609        4.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        1.4142135623730951       0.78539816339744817        1.0000000000000000        1.4142135623730951       0.78539816339744817       -1.0000000000000000",
                "5.0000000000000000        0.0000000000000000        0.0000000000000000        10.000000000000000       0.78539816339744817        0.0000000000000000        15.000000000000000       0.78539816339744817        0.0000000000000000"
            ]
        },
        "code": "subroutine cart_cyl(x,r)\n\t!----------------------------------------------------------\n\t! switching from cartesian to cylindrical coordinates\n\t! calling sequence: call cart_cyl(x,r)\n\t! input:  x: position vector in cartesian coordinates\n\t! output: r: position vector in cylindrical coordinates \n\t!\t     (radial distance,angular coordinate,altitude)\t\t\t!\n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: x\n\treal(kind=8), dimension(:,:), intent(out) :: r\n\t\n\t! altitude\n\tr(3,:)=x(3,:)\n\n\t! radial distance\n\tr(1,:) = sqrt(x(1,:)**2+x(2,:)**2)\n\t\n\t! angular coordinate\n\twhere (x(1,:) .ge. 0.d0 .and. x(2,:) .ne. 0.d0)\n\t\tr(2,:) = asin(x(2,:)/r(1,:)) \n\tend where \n\twhere (x(1,:) .lt. 0.d0 .and. x(2,:) .ne. 0.d0)\n\t\tr(2,:) = pi - asin(x(2,:)/r(1,:)) \n\tend where\n\n\twhere (x(1,:) .eq. 0.d0 .and. x(2,:).eq. 0.d0)\n\t\tr(2,:) = 0.d0\n\tend where\n\nend subroutine cart_cyl\n",
        "answer": "subroutine cart_cyl(x, r)\n\n    implicit none\n\n    real(kind=8), dimension(:,:), intent(in) :: x\n    real(kind=8), dimension(size(x,1),3), intent(out) :: r\n\n    integer :: i, j\n\n    do i = 1, size(x,1)\n        do j = 1, size(x,2)\n            r(i,1) = sqrt(x(i,1)**2 + x(i,2)**2)  ! radial distance\n            r(i,2) = atan2(x(i,2), x(i,1))  ! angular coordinate\n            r(i,3) = x(i,3)  ! altitude\n        end do\n    end do\n\nend subroutine cart_cyl\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called rot to rotate a vector in Cartesian coordinates by an angle in degrees. The subroutine has three input parameters and one output parameter. The input parameters are: vin - a 2D array of real numbers representing the vector in Cartesian coordinates, theta - a 1D array of real numbers representing the rotation angles in degrees. The output parameter is vout - a 2D array of real numbers representing the modified vector in Cartesian coordinates. The subroutine uses a 3x3 rotation matrix to perform the rotation.",
            "Please provide me with a Fortran subroutine code called \"rot\" which performs a rotation operation on a vector. The subroutine takes three parameters as input and has no output argument. The first input parameter is a two-dimensional array of real numbers called \"vin\" representing the vector in Cartesian coordinates. The second input parameter is a one-dimensional array of real numbers called \"theta\" representing the rotation angle in degrees. The third input parameter is a two-dimensional array of real numbers called \"vout\" which represents the modified vector in Cartesian coordinates after the rotation operation. The subroutine calculates the rotation matrix based on the given rotation angle and applies it to each vector in the \"vin\" array, storing the result in the corresponding position of the \"vout\" array.",
            "Give me a Fortran subroutine code called rot that performs a rotation operation on a vector. The subroutine takes three input parameters and performs calculations to modify the vector. The input parameters are:\n1. vin: A two-dimensional array of real numbers representing the vector in Cartesian coordinates.\n2. theta: A one-dimensional array of real numbers representing the angle of rotation in degrees.\n3. vout: A two-dimensional array of real numbers representing the modified vector in Cartesian coordinates.\n\nThe subroutine uses a 3x3 rotation matrix, matrot, to perform the rotation operation. The rotation matrix is computed based on the given angles of rotation. The modified vector is computed by multiplying the rotation matrix with the input vector using the matmul function.\n\nTo use the subroutine, you can call it using the following syntax: call rot(vin, theta, vout), where vin, theta, and vout are the respective input and output arrays."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8), dimension(3,3) :: vin, vout\n    real(kind=8), dimension(5) :: theta\n    integer :: i\n    \n    ! Test case 1\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [30.d0, 45.d0, 60.d0, 90.d0, 120.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 2\n    vin = reshape([1.d0, 0.d0, 0.d0, 0.d0, 1.d0, 0.d0, 0.d0, 0.d0, 1.d0], [3, 3])\n    theta = [90.d0, 180.d0, 270.d0, 360.d0, 45.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 3\n    vin = reshape([2.d0, -1.d0, 0.d0, 4.d0, 3.d0, 1.d0, 0.d0, -2.d0, 5.d0], [3, 3])\n    theta = [60.d0, 45.d0, 30.d0, 15.d0, 75.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 4\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [0.d0, 0.d0, 0.d0, 0.d0, 0.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \n    ! Test case 5\n    vin = reshape([1.d0, 2.d0, 3.d0, 4.d0, 5.d0, 6.d0, 7.d0, 8.d0, 9.d0], [3, 3])\n    theta = [180.d0, 270.d0, 360.d0, 90.d0, 0.d0]\n    call rot(vin, theta, vout)\n    do i = 1, size(theta)\n        print *, vout(:, i)\n    enddo\n    print *, \"&\"\n    \nend program main",
            "result": [
                "30.000000000000000        45.000000000000000        60.000000000000000        90.000000000000000        120.00000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   30.000000000000000        45.000000000000000     \n   60.000000000000000        90.000000000000000        120.00000000000000",
                "90.000000000000000        180.00000000000000        270.00000000000000        360.00000000000000        45.000000000000000     \n   1.0000000000000000        0.0000000000000000        0.0000000000000000     \n   0.0000000000000000        1.0000000000000000        0.0000000000000000     \n   0.0000000000000000        0.0000000000000000        1.0000000000000000     \n   3.9525251667299724E-323   90.000000000000000        180.00000000000000     \n   270.00000000000000        360.00000000000000        45.000000000000000",
                "60.000000000000000        45.000000000000000        30.000000000000000        15.000000000000000        75.000000000000000     \n   2.0000000000000000       -1.0000000000000000        0.0000000000000000     \n   4.0000000000000000        3.0000000000000000        1.0000000000000000     \n   0.0000000000000000       -2.0000000000000000        5.0000000000000000     \n   3.9525251667299724E-323   60.000000000000000        45.000000000000000     \n   30.000000000000000        15.000000000000000        75.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   0.0000000000000000        0.0000000000000000     \n   0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "180.00000000000000        270.00000000000000        360.00000000000000        90.000000000000000        0.0000000000000000     \n   1.0000000000000000        2.0000000000000000        3.0000000000000000     \n   4.0000000000000000        5.0000000000000000        6.0000000000000000     \n   7.0000000000000000        8.0000000000000000        9.0000000000000000     \n   3.9525251667299724E-323   180.00000000000000        270.00000000000000     \n   360.00000000000000        90.000000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine rot(vin,theta,vout)\n\t!------------------------------------------------------\n\t! rotation of the vin vector by an angle theta\n\t! calling sequence: call rot(vin,theta,vout)\n\t! input:  vin: vector in cartesian coordinates\n\t!       theta: angle in degre\n\t!\t\t\t\t\n\t! output: vout: modified vector in cartesian coordinates.\n\t!------------------------------------------------------\n\treal(kind=8), dimension(:,:), intent(in)  :: vin\n\treal(kind=8), dimension(:), intent(in)    :: theta\n\treal(kind=8), dimension(:,:), intent(out) :: vout\n\treal(kind=8), dimension(3,3)\t\t\t  :: matrot\n\tinteger\t\t\t\t\t\t\t\t\t  :: i\n\t\n\twrite(*,*) theta\n\tdo i=1,size(theta)\n!\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) = -sin(theta(i)*pi/180.) ; matrot(1,3)=0.d0\n!\t\tmatrot(2,1) = sin(theta(i)*pi/180.) ; matrot(2,2) = cos(theta(i)*pi/180.)  ; matrot(2,3)=0.d0\n!\t\tmatrot(3,1) = 0.d0\t\t \t\t    ; matrot(3,2) = 0.d0\t\t\t\t   ; matrot(3,3)=1.d0\n\n\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) =  0.d0\t\t; matrot(1,3)=-sin(theta(i)*pi/180.)\n\t\tmatrot(2,1) = 0.d0\t\t\t\t    ; matrot(2,2) =  1.d0\t\t; matrot(2,3)=0.d0\n\t\tmatrot(3,1) = sin(theta(i)*pi/180.) ; matrot(3,2) = 0.d0\t\t; matrot(3,3)=cos(theta(i)*pi/180.) \n\n\t\tvout(:,i) = matmul(matrot,vin(:,i)) \n\n\tenddo\n\nend subroutine rot\n",
        "answer": "subroutine rot(vin, theta, vout)\n    real, dimension(:,:), intent(in) :: vin\n    real, dimension(:), intent(in) :: theta\n    real, dimension(size(vin,1), size(vin,2)) :: vout\n    real, dimension(3,3) :: rotmat\n    integer :: i, j\n\n    do i = 1, size(vin,1)\n        do j = 1, size(vin,2)\n            rotmat(1,1) = cos(theta(j))\n            rotmat(1,2) = -sin(theta(j))\n            rotmat(1,3) = 0.0\n            rotmat(2,1) = sin(theta(j))\n            rotmat(2,2) = cos(theta(j))\n            rotmat(2,3) = 0.0\n            rotmat(3,1) = 0.0\n            rotmat(3,2) = 0.0\n            rotmat(3,3) = 1.0\n\n            vout(i,j) = sum(matmul(rotmat, vin(i,:)))\n        end do\n    end do\nend subroutine rot\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine code named eos that calculates the density of a material based on different equations of state. The subroutine takes in 5 input parameters: ec, t, s, z, and ieos. The ec parameter is an array of 5 real numbers, t and s are real numbers, z is a real number, and ieos is an integer. The subroutine has 1 output parameter called rho of type real. \n\nIn the subroutine, if the ieos value is 0, the density is calculated without considering the thermobaricity term. The density is computed using the formula: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3.\n\nIf the ieos value is 1, the density is computed with the thermobaricity term. The density is calculated using the formula: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z.\n\nPlease implement the eos subroutine according to the provided instructions.",
            "Provide me with a Fortran subroutine code called \"eos\" that calculates the density (rho) based on given parameters. The subroutine takes in 5 input parameters: ec, t, s, z, and ieos. The ec parameter is an array of 5 real numbers, t and s are real numbers, z is a real number, and ieos is an integer. There is 1 output parameter: rho, which is a real number.\n\nTo calculate rho, the subroutine checks the value of ieos. If ieos is 0, it computes rho using the equation: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3. If ieos is 1, it includes an additional term: rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z.\n\nMake sure to include this subroutine in your Fortran program to accurately calculate the density based on the given parameters.",
            "Please write a Fortran subroutine named \"eos\" to calculate the density of a substance based on the given equations of state. The subroutine takes 5 input parameters - an array of 5 real values (ec), temperature (t), salinity (s), depth (z), and an integer (ieos). It also has 1 output parameter - density (rho), which is of type real. \n\nTo compute the density, the subroutine checks the value of ieos. If ieos is 0, it calculates the density without considering the thermobaricity term. If ieos is 1, it includes the thermobaricity term in the calculation. The density is determined by combining the input parameters with the respective coefficients from the ec array and the thermobaricity term (if applicable).\n\nPlease implement the subroutine \"eos\" according to the description provided."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: ec(5), t, s, z, rho\n    integer :: ieos\n\n    ! Test case 1\n    ec = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t = 300.0\n    s = 10.0\n    z = 0.0\n    ieos = 0\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 2\n    ec = [2.0, 3.0, 4.0, 5.0, 6.0]\n    t = 400.0\n    s = 20.0\n    z = 0.5\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 3\n    ec = [0.5, 1.0, 1.5, 2.0, 2.5]\n    t = 200.0\n    s = -5.0\n    z = 1.0\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 4\n    ec = [3.0, 4.0, 5.0, 6.0, 7.0]\n    t = 500.0\n    s = 15.0\n    z = -0.5\n    ieos = 0\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\n\n    ! Test case 5\n    ec = [4.0, 5.0, 6.0, 7.0, 8.0]\n    t = 350.0\n    s = 25.0\n    z = 1.5\n    ieos = 1\n    call eos(ec, t, s, z, ieos, rho)\n    print *, rho\n    print *, \"&\"\nend program main",
            "result": [
                "108270320.",
                "320642048.",
                "16060595.0",
                "751251584.",
                "300865696."
            ]
        },
        "code": "  subroutine eos(ec, t, s, z, ieos, rho)\n    implicit none\n    real, intent(in) :: ec(5), t, s, z\n    integer, intent(in) :: ieos\n    real, intent(out) :: rho\n\n    if (ieos == 0) then\n       ! no thermobaricity term\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3\n    elseif (ieos == 1) then\n       ! thermobaricity term is in\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z\n    end if\n  end subroutine eos\n",
        "answer": "subroutine eos(ec, t, s, z, ieos, rho)\n    implicit none\n    real, intent(in) :: ec(5), t, s, z\n    integer, intent(in) :: ieos\n    real, intent(out) :: rho\n\n    if (ieos == 0) then\n        rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3\n    else if (ieos == 1) then\n        rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z\n    end if\n\nend subroutine eos\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called linear_solver that solves a linear equation of the form f(tau) = a * tau + b. The subroutine takes in two input parameters: 'a' and 'b' of type double precision. There is one output parameter called 'dtau' of type double precision that stores the solution to the equation.\n\nTo write the subroutine, first, declare the input and output parameters using the 'intent' keyword. 'a' and 'b' are input parameters, while 'dtau' is the output parameter. \n\nInside the subroutine, check if 'a' is equal to zero. If it is, assign the value of 'dtau' as the maximum representable value for double precision using the 'huge()' function. Otherwise, compute the value of 'dtau' by dividing 'b' by 'a' and negating the result.\n\nEnd the subroutine after the 'endif' statement using the 'end subroutine linear_solver' statement.",
            "I need you to create a Fortran subroutine called linear_solver that solves a linear equation of the form f(tau) = a * tau + b. The subroutine should have 2 input parameters and 1 output parameter. The first input parameter, 'a', is a double precision number that represents the coefficient of tau. The second input parameter, 'b', is also a double precision number and represents the constant term. The output parameter, 'dtau', is also a double precision number and represents the root of the equation.\n\nTo implement the subroutine, first, declare the variables 'dtau', 'a', and 'b' as double precision and with the 'intent' attribute to specify their purpose as either input or output. Inside the subroutine, check if 'a' is equal to zero. If it is, set 'dtau' to the largest possible value using the 'huge' function. Otherwise, compute 'dtau' by dividing '-b' by 'a'.\n\nMake sure to include the 'implicit none' statement to enforce explicit variable declarations.",
            "Provide me with a Fortran subroutine code called linear_solver that solves a linear equation of the form f(tau) = a * tau + b and finds the root (tau). The subroutine takes in 2 input parameters: a and b, both of type double precision. It also has 1 output parameter: dtau, of type double precision, which stores the value of the root."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: a, b, dtau\n    ! Test case 1\n    a = 2.0\n    b = 3.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n\n    ! Test case 2\n    a = 0.0\n    b = 4.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 3\n    a = 7.0\n    b = 1.5\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 4\n    a = 3.0\n    b = 3.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\n    \n    ! Test case 5\n    a = 1.0\n    b = 0.0\n    call linear_solver(a, b, dtau)\n    print *, dtau\n    print *, \"&\"\nend program main",
            "result": [
                "-1.5000000000000000",
                "1.7976931348623157E+308",
                "-0.21428571428571427",
                "-1.0000000000000000",
                "-0.0000000000000000"
            ]
        },
        "code": "    subroutine linear_solver(a,b,dtau)\n!\n        !find the root of the equation\n        !f(tau) = a * tau + b\n!\n        implicit none\n!\n        double precision,intent(out)                :: dtau\n        double precision,intent(in)                 :: a,b\n!\n        if(a.eq.0.d0) then\n            dtau = huge(0.d0)\n        else\n            dtau = -b/a    \n        endif        \n!\n    end subroutine linear_solver\n",
        "answer": "subroutine linear_solver(a, b, dtau)\n    double precision, intent(in) :: a, b\n    double precision, intent(out) :: dtau\n\n    if (a == 0.0d0) then\n        dtau = -huge(1.0d0)\n    else\n        dtau = -b / a\n    endif\n\nend subroutine linear_solver\n\n"
    },
    {
        "instruction": [
            "Provide me with a Fortran subroutine code called gaulegf that calculates the Gauss-Legendre quadrature points and weights. The subroutine takes 5 input parameters and has no output parameter. The first input parameter is x1, which is of type real(8) and represents the lower limit of integration. The second input parameter is x2, also of type real(8), representing the upper limit of integration. The third input parameter is n, of type integer, representing the number of points and weights to be computed. The fourth and fifth input parameters are arrays x and w, both of type real(8) and of size n. The subroutine calculates the Gauss-Legendre quadrature points and weights and stores them in the arrays x and w, respectively.",
            "Create a Fortran subroutine called \"gaulegf\" to compute the Gauss-Legendre quadrature points and weights. The subroutine takes in five input parameters: x1 and x2 of type real(8) representing the lower and upper integration limits, and n of type integer representing the number of points to compute. The subroutine also has two output parameters: x and w, both of type real(8) and dimension n. \n\nInside the subroutine, the algorithm calculates the Gaussian quadrature points and weights using the Gauss-Legendre formula. It iteratively computes the points and weights by solving for the roots of Legendre polynomials. The resulting points are stored in the array x, and the corresponding weights are stored in the array w.\n\nTo use the subroutine, call it with the appropriate input parameters and provide arrays x and w to store the computed points and weights.",
            "Please provide a Fortran subroutine called \"gaulegf\" that computes the Gauss-Legendre quadrature points and weights. The subroutine takes 5 input parameters: x1 and x2 (both of type real(8)) specify the integration limits, n (of type integer) specifies the number of quadrature points, and x and w (both of type real(8) and with dimension n) are the output arrays for the quadrature points and weights, respectively.\n\nIn the subroutine, the Gauss-Legendre quadrature points and weights are calculated using a numerical approximation algorithm. The subroutine loops over the number of quadrature points and computes the points and weights by iteratively solving a series of equations. The computed values are stored in the arrays x and w.\n\nTo use the subroutine, pass the integration limits, the number of quadrature points, and the arrays x and w as input parameters. After calling the subroutine, you can retrieve the computed quadrature points and weights from the arrays x and w for further calculations or integration purposes."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: x1, x2\n    real(8), dimension(n) :: x, w\n    integer :: i\n    \n    ! Test case 1\n    x1 = 0.0\n    x2 = 1.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    x1 = -1.0\n    x2 = 1.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = -10.0\n    x2 = 10.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 0.0\n    x2 = 100.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -100.0\n    x2 = 100.0\n    call gaulegf(x1, x2, x, w, n)\n    do i = 1, n\n        print *, x(i), w(i)\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "6.9431844202973714E-002  0.17392742256872379     \n  0.33000947820757187       0.32607257743127321     \n  0.66999052179242813       0.32607257743127321     \n  0.93056815579702623       0.17392742256872379",
                "-0.86113631159405257       0.34785484513744758     \n -0.33998104358485631       0.65214515486254643     \n  0.33998104358485631       0.65214515486254643     \n  0.86113631159405257       0.34785484513744758",
                "-8.6113631159405255        3.4785484513744760     \n  -3.3998104358485630        6.5214515486254641     \n   3.3998104358485630        6.5214515486254641     \n   8.6113631159405255        3.4785484513744760",
                "6.9431844202973707        17.392742256872378     \n   33.000947820757183        32.607257743127320     \n   66.999052179242824        32.607257743127320     \n   93.056815579702629        17.392742256872378",
                "-86.113631159405259        34.785484513744755     \n  -33.998104358485634        65.214515486254641     \n   33.998104358485634        65.214515486254641     \n   86.113631159405259        34.785484513744755"
            ]
        },
        "code": "subroutine gaulegf(x1, x2, x, w, n)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x1, x2\n  real(8), dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  real(8) :: p1, p2, p3, pp, xl, xm, z, z1\n  real(8), parameter :: eps=3.d-14\n\n  pp = 0.0d0\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.0\n    do while(abs(z-z1) .gt. eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\n\nend subroutine gaulegf\n",
        "answer": "subroutine gaulegf(x1,x2,n,x,w)\n    implicit none\n    real(8), intent(in) :: x1,x2\n    integer, intent(in) :: n\n    real(8), dimension(n), intent(out) :: x,w\n    real(8), dimension(n) :: z,z1,p1,p2,p3\n    real(8), parameter :: eps=1.0d-14\n    integer :: i,j,m\n    real(8) :: xm,xl,z,pp,z1\n\n    m=(n+1)/2\n    xm=0.5d0*(x2+x1)\n    xl=0.5d0*(x2-x1)\n\n    do i=1,m\n        z=cos(pi*(i-.25d0)/(n+.5d0))\n        do\n            p1=1.0d0\n            p2=0.0d0\n            do j=1,n\n                p3=p2\n                p2=p1\n                p1=((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n            end do\n            pp=n*(z*p1-p2)/(z*z-1.0d0)\n            z1=z\n            z=z-p1/pp\n            if(abs(z-z1)<eps) exit\n        end do\n        x(i)=xm-xl*z\n        x(n+1-i)=xm+xl*z\n        w(i)=2.0d0*xl/((1.0d0-z*z)*pp*pp)\n        w(n+1-i)=w(i)\n    end do\nend subroutine gaulegf\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called calc_hypotenuse to calculate the hypotenuse of a right triangle. The subroutine has three parameters: two input parameters, side_1 and side_2, both of type real, and one output parameter, hypotenuse, of type real. The subroutine uses the Pythagorean theorem to calculate the hypotenuse. \n\nTo use the subroutine, provide the lengths of the two sides of the right triangle as input values for side_1 and side_2. After calling the subroutine, the calculated hypotenuse will be stored in the hypotenuse output parameter.",
            "Write a Fortran subroutine called calc_hypotenuse to calculate the length of the hypotenuse of a right triangle. The subroutine takes in two input parameters: side_1 of type real and side_2 of type real. It also has one output parameter called hypotenuse of type real.",
            "Write a Fortran subroutine called calc_hypotenuse that calculates the hypotenuse of a right triangle. The subroutine takes two input parameters: side_1 of type real and side_2 of type real. The subroutine also has one output parameter: hypotenuse of type real. The instruction for calc_hypotenuse should be as follows:\n\n\"Create a Fortran subroutine called calc_hypotenuse to calculate the hypotenuse of a right triangle. The subroutine takes two input parameters, side_1 and side_2, both of type real. The subroutine also has one output parameter, hypotenuse, of type real. Inside the subroutine, calculate the square of side_1 and side_2 and store it in a temporary variable called temp. Then, calculate the square root of temp and assign the result to hypotenuse. Use the 'intent' keyword to specify the intention of each parameter, with side_1 and side_2 intended for input and hypotenuse intended for output. End the subroutine with the 'end subroutine' statement.\""
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: side1, side2, hypotenuse\n    \n    ! Test case 1\n    side1 = 3.0\n    side2 = 4.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 2\n    side1 = 5.0\n    side2 = 12.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 3\n    side1 = 8.0\n    side2 = 15.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 4\n    side1 = 1.5\n    side2 = 6.0\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\n    print *, \"&\"\n    \n    ! Test case 5\n    side1 = 0.5\n    side2 = 0.5\n    call calc_hypotenuse(side1, side2, hypotenuse)\n    print *, hypotenuse\nend program main",
            "result": [
                "5.00000000",
                "13.0000000",
                "17.0000000",
                "6.18465853",
                "0.707106769"
            ]
        },
        "code": "subroutine calc_hypotenuse(side_1, side_2, hypotenuse)\nimplicit none\n  real, intent(in) :: side_1, side_2\n  real, intent(out) :: hypotenuse\n  real :: temp\n\n  temp = side_1**2 + side_2**2\n  hypotenuse = sqrt(temp)\n\nend subroutine calc_hypotenuse\n",
        "answer": "subroutine calc_hypotenuse(side_1, side_2, hypotenuse)\n    implicit none\n    real, intent(in) :: side_1, side_2\n    real, intent(out) :: hypotenuse\n\n    hypotenuse = sqrt(side_1**2 + side_2**2)\nend subroutine calc_hypotenuse\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called calc_d2vec to calculate the second derivative matrix of a given normalized vector. The subroutine takes 3 input parameters: v, an array of type real representing the normalized vector; len, a real number representing the length of the vector. The subroutine also has 1 output parameter: d2_mat, a 3-dimensional array of type real to store the calculated second derivative matrix.",
            "Give me a Fortran subroutine code named calc_d2vec that calculates the second derivative matrix of a given normalized vector. The subroutine has three input parameters: v, which is an array of type real representing the normalized vector; len, which is a real number representing the length of the vector. The subroutine also has one output parameter: d2_mat, which is a 3-dimensional array of type real representing the calculated second derivative matrix.\n\nTo summarize, the subroutine calc_d2vec takes a normalized vector and its length as input and calculates the second derivative matrix. The calculated matrix is then stored in the output parameter d2_mat.",
            "Provide a Fortran subroutine called \"calc_d2vec\" to calculate the second derivative matrix for a given vector. The subroutine takes three input parameters: \"v\", an array of real numbers representing the normalized vector to be differentiated; \"len\", a real number representing the length of the given vector. The subroutine also has one output parameter: \"d2_mat\", a three-dimensional array of real numbers representing the calculated second derivative matrix.\n\nTo calculate the entries of the second derivative matrix, the subroutine follows a specific pattern and formula of differentiation. It first calculates the entries corresponding to derivative with respect to x (dv/dx^2), then the entries corresponding to derivative with respect to y (dv/dy^2), and finally the entries corresponding to derivative with respect to z (dv/dz^2). The matrix is diagonal, meaning that only the diagonal and off-diagonal entries are computed.\n\nAfter computing the entries of the second derivative matrix, the subroutine applies a length prefactor by dividing each entry by the fifth power of the given vector's length.\n\nTo use the subroutine, provide the normalized vector \"v\" and its length \"len\" as input parameters, and the subroutine will compute the second derivative matrix \"d2_mat\" as the output.\n\nThe subroutine \"calc_d2vec\" can be called from other parts of the program to perform the described calculations."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: vector(3), length, result(3,3,3)\n    \n    ! Test case 1\n    vector = [1.0, 2.0, 3.0]\n    length = 2.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 2\n    vector = [0.5, 1.5, 2.5]\n    length = 1.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    vector = [2.0, 2.0, 2.0]\n    length = 3.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    vector = [5.0, 0.0, 1.0]\n    length = 4.0\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    vector = [3.5, 2.5, 1.5]\n    length = 2.5\n    call calc_d2vec(result, vector, length)\n    print *, result\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-1.2187500000000000      -0.68750000000000000       -1.0312500000000000      -0.68750000000000000       -6.2500000000000000E-002  0.56250000000000000       -1.0312500000000000       0.56250000000000000       0.40625000000000000      -0.68750000000000000       -6.2500000000000000E-002  0.56250000000000000       -6.2500000000000000E-002  -1.8750000000000000      -0.18750000000000000       0.56250000000000000      -0.18750000000000000       0.81250000000000000       -1.0312500000000000       0.56250000000000000       0.40625000000000000       0.56250000000000000      -0.18750000000000000       0.81250000000000000       0.40625000000000000       0.81250000000000000       -1.4062500000000000",
                "-12.750000000000000       -12.000000000000000       -20.000000000000000       -12.000000000000000       -1.0000000000000000        5.6250000000000000       -20.000000000000000        5.6250000000000000        5.0000000000000000       -12.000000000000000       -1.0000000000000000        5.6250000000000000       -1.0000000000000000       -29.250000000000000       -5.0000000000000000        5.6250000000000000       -5.0000000000000000        15.000000000000000       -20.000000000000000        5.6250000000000000        5.0000000000000000        5.6250000000000000       -5.0000000000000000        15.000000000000000        5.0000000000000000        15.000000000000000       -18.750000000000000",
                "-0.19753086419753085       -0.0000000000000000       -0.0000000000000000       -0.0000000000000000        0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        9.8765432098765427E-002   0.0000000000000000        0.0000000000000000       -0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000      -0.19753086419753085       -0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        0.0000000000000000        0.0000000000000000        9.8765432098765427E-002  -0.0000000000000000        9.8765432098765427E-002   0.0000000000000000       -0.0000000000000000       -0.0000000000000000       -0.0000000000000000      -0.19753086419753085",
                "-1.4648437500000000E-002   0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.12695312500000000        0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.11230468750000000        0.0000000000000000      -0.12695312500000000        0.0000000000000000      -0.12695312500000000       -0.0000000000000000       -2.5390625000000000E-002   0.0000000000000000       -2.5390625000000000E-002  -0.0000000000000000        4.7851562500000000E-002   0.0000000000000000      -0.11230468750000000        0.0000000000000000       -2.5390625000000000E-002  -0.0000000000000000      -0.11230468750000000       -0.0000000000000000       -7.3242187500000000E-002",
                "-0.91391999999999995       0.40960000000000002       0.24576000000000001       0.40960000000000002       -7.1679999999999994E-002  0.40320000000000000       0.24576000000000001       0.40320000000000000      -0.50175999999999998       0.40960000000000002       -7.1679999999999994E-002  0.40320000000000000       -7.1679999999999994E-002  -1.1135999999999999       -3.0720000000000001E-002  0.40320000000000000       -3.0720000000000001E-002 -0.35840000000000000       0.24576000000000001       0.40320000000000000      -0.50175999999999998       0.40320000000000000       -3.0720000000000001E-002 -0.35840000000000000      -0.50175999999999998      -0.35840000000000000      -0.85248000000000002"
            ]
        },
        "code": "subroutine calc_d2vec(d2_mat,v,len)\nimplicit none \n!     the normalized vector to be derivated \nreal(kind=8), intent(in) :: v(3)\n!     the length of the given vector \nreal(kind=8), intent(in) :: len\n!     the calculated second derivative matrix \nreal(kind=8), intent(out) :: d2_mat(3,3,3)\n\n!\n!     calculate entries of second derivative matrix \n!     --> the matrix is diagonal!\n!\n!     dv/dx^2\nd2_mat(1,1,1)=-3d0*v(1)*(v(2)**2+v(3)**2)\nd2_mat(1,1,2)=v(2)*(2d0*v(1)**2-v(3)**2-v(2)**2)\nd2_mat(1,1,3)=v(3)*(2d0*v(1)**2-v(2)**2-v(3)**2)\n!     dv/dxdy\nd2_mat(1,2,1)=-v(2)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,2,2)=-v(1)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(1,2,3)=3d0*v(1)*v(2)*v(3)\n!     dv/dxdz\nd2_mat(1,3,1)=-v(3)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,3,2)=3d0*v(1)*v(2)*v(3)\nd2_mat(1,3,3)=-v(1)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dydx\nd2_mat(2,1,:)=d2_mat(1,2,:)\n!     dv/dydy\nd2_mat(2,2,1)=v(1)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\nd2_mat(2,2,2)=-3d0*v(2)*(v(1)**2+v(3)**2)\nd2_mat(2,2,3)=v(3)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\n!     dv/dydz\nd2_mat(2,3,1)=3d0*v(1)*v(2)*v(3)\nd2_mat(2,3,2)=-v(3)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(2,3,3)=-v(2)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dzdx\nd2_mat(3,1,:)=d2_mat(1,3,:)\n!     dv/dzdy\nd2_mat(3,2,:)=d2_mat(2,3,:)\n!     dv/dzdz\nd2_mat(3,3,1)=v(1)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,2)=v(2)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,3)=-3d0*v(3)*(v(1)**2+v(2)**2)\n!\n!     apply length prefactor \n!\nd2_mat=d2_mat/(len**5)\n\nreturn\nend subroutine calc_d2vec\n",
        "answer": "subroutine calc_d2vec(v, len, d2_mat)\n    implicit none\n    real, intent(in) :: v(3)\n    real, intent(in) :: len\n    real :: d2_mat(3,3)\n    real :: x, y, z\n\n    x = v(1) / len\n    y = v(2) / len\n    z = v(3) / len\n\n    d2_mat(1,1) = -y*y - z*z\n    d2_mat(1,2) = x*y\n    d2_mat(1,3) = x*z\n    d2_mat(2,1) = x*y\n    d2_mat(2,2) = -x*x - z*z\n    d2_mat(2,3) = y*z\n    d2_mat(3,1) = x*z\n    d2_mat(3,2) = y*z\n    d2_mat(3,3) = -x*x - y*y\n\nend subroutine calc_d2vec\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called adt_sphere that calculates the scattering properties of a sphere. The subroutine takes 4 input parameters and has 4 output parameters. The input parameters are: xx, a real number representing the size of the sphere; crefin, a complex number representing the refractive index of the sphere. The output parameters are: qext, a real number representing the extinction efficiency; qabs, a real number representing the absorption efficiency; qsca, a real number representing the scattering efficiency; and g, a real number representing the scattering asymmetry parameter. The subroutine computes these properties based on the size and refractive index of the sphere using mathematical calculations and conditional statements.",
            "Write a Fortran subroutine called adt_sphere that calculates the optical properties of a spherical particle. The subroutine takes in six parameters: xx (real), crefin (complex), and four output parameters: qext (real), qabs (real), qsca (real), and g (real).\n\nTo calculate the optical properties, the subroutine first computes the complex variable rho using the formula rho = 2.0 * xx * (crefin - 1.0), where xx is the input parameter and crefin is a complex number.\n\nNext, it computes other variables such as rr, rho1, rho2, and beta based on the values of rho.\n\nThe subroutine then performs a conditional check. If rr is less than or equal to 1e-3, it sets qext to 2.0, qabs to 4.0/3.0 times rho2, qsca to qext minus qabs, and g to 1.0.\n\nOtherwise, it calculates qext, qabs, qsca, and g using mathematical expressions involving rho, rho1, rho2, rr, and beta.\n\nFinally, the subroutine ends.\n\nMake sure to pass the appropriate values for xx and crefin and retrieve the calculated values of qext, qabs, qsca, and g from the subroutine.",
            "Write a Fortran subroutine named adt_sphere to calculate the scattering properties of a sphere. The subroutine has 5 parameters: xx (input, real), crefin (input, complex), qext (output, real), qabs (output, real), qsca (output, real), and g (output, real). \n\nIn the subroutine, the input parameter xx represents the size of the sphere, and crefin represents the complex refractive index. The subroutine calculates the values of qext (extinction efficiency), qabs (absorption efficiency), qsca (scattering efficiency), and g (scattering asymmetry parameter) based on the input parameters. \n\nThe subroutine first calculates the real and imaginary parts of rho using the formula rho = 2.0 * xx * (crefin - 1.0). Then, it computes the absolute value of rho (rr), and separates the real and imaginary parts of rho into rho1 and rho2, respectively. \n\nNext, the subroutine checks if rr is less than or equal to 1e-3. If it is, the subroutine sets qext to 2.0, qabs to 4.0/3.0 * rho2, qsca to qext - qabs, and g to 1.0. \n\nIf rr is greater than 1e-3, the subroutine computes the value of beta using the atan2 function. Then, it calculates the values of qext, qabs, qsca, and g based on the formulas provided in the code. \n\nIn both cases, the subroutine outputs the values of qext, qabs, qsca, and g."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: xx, qext, qabs, qsca, g\n    complex :: crefin\n    ! Test case 1\n    xx = 0.1\n    crefin = (1.0, 1.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 2\n    xx = 0.5\n    crefin = (0.5, 0.5)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 3\n    xx = 1.0\n    crefin = (1.0, 0.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 4\n    xx = 2.0\n    crefin = (0.0, 1.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\n    \n    ! Test case 5\n    xx = 10.0\n    crefin = (2.0, 2.0)\n    call adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    print *, qext, qabs, qsca, g\n    print *, \"&\"\nend program main",
            "result": [
                "-32.5015335      0.230600178      -32.7321320       1.00000000",
                "-1.29226851      0.471517801      -1.76378632       1.00000000",
                "2.00000000       0.00000000       2.00000000       1.00000000",
                "2.00078797      0.968844354       1.03194356       1.00000000",
                "1.99880004      0.999687493      0.999112546       1.00000000"
            ]
        },
        "code": "subroutine adt_sphere(xx, crefin, qext, qabs, qsca, g)\n  implicit none\n  real, intent(in) :: xx\n  complex, intent(in) :: crefin\n  real, intent(out) :: qext, qabs, qsca, g\n  complex rho\n  real rho1, rho2, beta, rr\n  !\n  rho = 2.0 * xx * (crefin - 1.0)\n  rr = abs(rho)\n  rho1 = real(rho)\n  rho2 = aimag(rho)\n  !\n  if (rr .le. 1e-3) then\n    qext = 2.0\n    qabs = 4.0/3.0 * rho2\n    qsca = qext - qabs\n    g = 1.0\n  else\n    !\n    beta = atan2(rho2, rho1)\n    !\n    qext = 2.0 + 4.0/(rr*rr) * &\n      (cos(2.0*beta) - &\n       exp(-rho2) * &\n       (cos(rho1-2.0*beta) - rr*sin(rho1-beta)))\n    qabs = 1.0 + (exp(-2.0*rho2)*(2.0*rho2+1.0) - 1.0) / (2.0*rho2*rho2)\n    qsca = qext - qabs\n    g = 1.0\n  end if\nend subroutine adt_sphere\n",
        "answer": "subroutine adt_sphere(xx, crefin, qext, qabs, qsca, g)\n    implicit none\n    real, intent(in) :: xx\n    complex, intent(in) :: crefin\n    real, intent(out) :: qext, qabs, qsca, g\n    real :: rho, rho_s, rho_a, rho_c, rho_r, rho_f, rho_g, rho_b, rho_d\n    real :: rho_s_s, rho_a_s, rho_c_s, rho_r_s, rho_f_s, rho_g_s, rho_b_s, rho_d_s\n    real :: rho_s_a, rho_a_a, rho_c_a, rho_r_a, rho_f_a, rho_g_a, rho_b_a, rho_d_a\n    real :: rho_s_c, rho_a_c, rho_c_c, rho_r_c, rho_f_c, rho_g_c, rho_b_c, rho_d_c\n    real :: rho_s_r, rho_a_r, rho_c_r, rho_r_r, rho_f_r, rho_g_r, rho_b_r, rho_d_r\n    real :: rho_s_f, rho_a_f, rho_c_f, rho_r_f, rho_f_f, rho_g_f, rho_b_f, rho_d_f\n    real :: rho_s_g, rho_a_g, rho_c_g, rho_r_g, rho_f_g, rho_g_g, rho_b_g, rho_d_g\n    real :: rho_s_b, rho_a_b, rho_c_b, rho_r_b, rho_f_b, rho"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called crossproduct that calculates the cross product of two vectors. The subroutine has 3 input parameters and 1 output parameter. The input parameters are arrays of type real*8, representing the components of the two vectors. The output parameter is an array of type real*8, representing the resulting cross product vector.",
            "Write a Fortran subroutine called crossproduct to calculate the cross product of two 3-dimensional vectors. The subroutine takes two input arguments, both of type real*8. The first argument is an array of size 3 representing the first vector, and the second argument is an array of size 3 representing the second vector. The subroutine also has an output argument, an array of size 3, of type real*8 to store the result of the cross product. The subroutine uses the formula ans(1) = a(2)*b(3) - a(3)*b(2), ans(2) = -a(1)*b(3) + a(3)*b(1), ans(3) = a(1)*b(2) - a(2)*b(1) to calculate the cross product.",
            "Write a Fortran subroutine called crossproduct to calculate the cross product of two 3-dimensional vectors. The subroutine accepts two input parameters: both are arrays of real numbers with a size of 3. It also has one output parameter, an array of real numbers with a size of 3, which stores the result of the cross product."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: vector1(3), vector2(3), result(3)\n    \n    ! Test case 1\n    vector1 = [1.0, 2.0, 3.0]\n    vector2 = [4.0, 5.0, 6.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    vector1 = [0.5, 0.5, 0.5]\n    vector2 = [1.0, 2.0, 3.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    vector1 = [1.0, 0.0, 0.0]\n    vector2 = [0.0, 1.0, 0.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    vector1 = [3.0, 4.0, 5.0]\n    vector2 = [1.0, -2.0, 3.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    vector1 = [-1.0, -1.0, -1.0]\n    vector2 = [2.0, 2.0, 2.0]\n    call crossproduct(vector1, vector2, result)\n    print *, result(1), result(2), result(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000",
                "0.50000000000000000       -1.0000000000000000       0.50000000000000000",
                "0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "22.000000000000000       -4.0000000000000000       -10.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "  subroutine crossproduct( a,b,ans )\n    implicit none\n    real*8, intent(in) :: a(3),b(3)\n    real*8, intent(out) :: ans(3)\n    ans(1) = a(2)*b(3)-a(3)*b(2)\n    ans(2) = -a(1)*b(3)+a(3)*b(1)\n    ans(3) = a(1)*b(2)-a(2)*b(1)\n  end subroutine crossproduct\n",
        "answer": "subroutine crossproduct(a, b, c)\n    real*8, intent(in) :: a(3), b(3)\n    real*8, intent(out) :: c(3)\n\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\nend subroutine crossproduct\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called intersection to find the intersection of two rectangles. The subroutine takes 14 input parameters, all of type real. These parameters represent the coordinates of the two rectangles. The subroutine also has 3 output parameters, indicator of type integer, and area, xintlo, xinthi, yintlo, and yinthi of type real. \n\nTo find the intersection, the subroutine compares the x and y coordinates of the rectangles and determines the overlapping region. If there is an intersection, the subroutine sets indicator to 1 and calculates the area of the intersection. If there is no intersection, indicator is set to 0 and the area is set to 0.\n\nWrite a Fortran subroutine called intersection that takes 14 input parameters: x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi, all of type real. The subroutine also has 5 output parameters: indicator, area, xintlo, xinthi, yintlo, and yinthi, all of type real.\n\nThe subroutine should find the intersection of two rectangles based on their coordinates. If there is an intersection, set the indicator to 1 and calculate the area of the intersection. If there is no intersection, set the indicator to 0 and the area to 0.",
            "Write a Fortran subroutine called intersection that finds the intersection between two rectangles. The subroutine takes 14 input parameters and 3 output parameters. The input parameters are x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi, all of type real(kind=8). The output parameters are indicator, area, xintlo, xinthi, yintlo, and yinthi, all of type real(kind=8). \n\nThe subroutine calculates the intersection of the two rectangles and returns the intersection area and its coordinates (xintlo, xinthi, yintlo, yinthi). If there is an intersection, the indicator is set to 1, otherwise, it is set to 0. \n\nTo find the intersection, the subroutine computes the maximum and minimum values of x and y coordinates of the rectangles. If the maximum x-coordinate is greater than the minimum x-coordinate and the maximum y-coordinate is greater than the minimum y-coordinate, it means there is an intersection. In that case, the subroutine calculates the area of the intersection and sets the indicator to 1. If there is no intersection, the area is set to 0 and the indicator is set to 0.",
            "Please provide a Fortran subroutine called \"intersection\" that computes the intersection of two rectangles. The subroutine takes 14 input parameters, all of type real. The input parameters are x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi representing the boundaries of the two rectangles. The subroutine also has 5 output parameters, indicator of type integer, and area, xintlo, xinthi, yintlo, yinthi of type real. The subroutine calculates the intersection of the two rectangles and returns the intersection area and its boundaries. If there is an intersection, the indicator is set to 1; otherwise, it is set to 0. Use the \"dmax1\" and \"dmin1\" functions to find the maximum and minimum values respectively."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: indicator\n    real*8 :: area, xintlo, xinthi, yintlo, yinthi\n    real*8 :: x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi\n    \n    ! Test case 1: Rectangles overlap\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 3.0\n    x2hi = 8.0\n    y2lo = 3.0\n    y2hi = 8.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 2: Rectangles do not overlap\n    x1lo = 0.0\n    x1hi = 2.0\n    y1lo = 0.0\n    y1hi = 2.0\n    x2lo = 3.0\n    x2hi = 4.0\n    y2lo = 3.0\n    y2hi = 4.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 3: One rectangle is completely inside the other\n    x1lo = 0.0\n    x1hi = 10.0\n    y1lo = 0.0\n    y1hi = 10.0\n    x2lo = 3.0\n    x2hi = 8.0\n    y2lo = 3.0\n    y2hi = 8.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 4: Rectangles share one side\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 5.0\n    x2hi = 10.0\n    y2lo = 0.0\n    y2hi = 5.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\n    print *, \"&\"\n    \n    ! Test case 5: Rectangles share one corner\n    x1lo = 0.0\n    x1hi = 5.0\n    y1lo = 0.0\n    y1hi = 5.0\n    x2lo = 5.0\n    x2hi = 10.0\n    y2lo = 5.0\n    y2hi = 10.0\n    call intersection(indicator, area, xintlo, xinthi, yintlo, yinthi, &\n        x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi)\n    print *, indicator, area, xintlo, xinthi, yintlo, yinthi\nend program main",
            "result": [
                "1   4.0000000000000000        3.0000000000000000        5.0000000000000000        3.0000000000000000        5.0000000000000000",
                "0   0.0000000000000000        3.0000000000000000        2.0000000000000000        3.0000000000000000        2.0000000000000000",
                "1   25.000000000000000        3.0000000000000000        8.0000000000000000        3.0000000000000000        8.0000000000000000",
                "0   0.0000000000000000        5.0000000000000000        5.0000000000000000        0.0000000000000000        5.0000000000000000",
                "0   0.0000000000000000        5.0000000000000000        5.0000000000000000        5.0000000000000000        5.0000000000000000"
            ]
        },
        "code": "subroutine intersection(indicator,area,xintlo,xinthi, &\n           yintlo,yinthi,x1lo,x1hi,y1lo,y1hi,x2lo,x2hi,y2lo,y2hi)\n\n    ! find the intersection of two rectangles, return the intersection\n    ! and it's area, and indicator =1\n    ! if there is no intersection, indicator =0\n\n      implicit none\n\n      integer, intent(out) :: indicator\n\n      real(kind=8), intent(in) ::  x1lo,x1hi,y1lo,y1hi,x2lo,x2hi,y2lo,y2hi\n      real(kind=8), intent(out) :: area,xintlo,xinthi,yintlo,yinthi\n\n      xintlo=dmax1(x1lo,x2lo)\n      xinthi=dmin1(x1hi,x2hi)\n      yintlo=dmax1(y1lo,y2lo)\n      yinthi=dmin1(y1hi,y2hi)\n\n\n      if (xinthi.gt.xintlo.and.yinthi.gt.yintlo) then\n         area = (xinthi-xintlo)*(yinthi-yintlo)\n         indicator = 1\n      else\n         area = 0.d0\n         indicator = 0\n      endif\n\nend subroutine intersection\n",
        "answer": "subroutine intersection(x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi, &\n                        indicator, area, xintlo, xinthi, yintlo, yinthi)\n    implicit none\n    real, intent(in) :: x1lo, x1hi, y1lo, y1hi, x2lo, x2hi, y2lo, y2hi\n    integer, intent(out) :: indicator\n    real, intent(out) :: area, xintlo, xinthi, yintlo, yinthi\n\n    if (x1lo > x2hi .or. x2lo > x1hi) then\n        indicator = 0\n        area = 0.0\n    else\n        xintlo = max(x1lo, x2lo)\n        xinthi = min(x1hi, x2hi)\n        if (xintlo > xinthi) then\n            indicator = 0\n            area = 0.0\n        else\n            if (y1lo > y2hi .or. y2lo > y1hi) then\n                indicator = 0\n                area = 0.0\n            else\n                yintlo = max(y1lo, y2lo)\n                yinthi = min(y1hi, y2hi)\n                if (yintlo > yinthi) then\n                    indicator = 0\n                    area = 0.0\n                else\n                    indicator = 1\n                    area = (xinthi - xintlo) * (yinthi - yintlo)\n                end if\n            end if\n        end if\n    end if\nend subroutine intersection\n\n"
    },
    {
        "instruction": [
            "I need a Fortran subroutine called xtoz that converts x coordinates to z coordinates on a discretized space. The subroutine takes in the following input parameters: nd (an integer representing the dimension of the space), x (an array of real numbers representing the coordinates of the point to be converted), h (an array of real numbers representing the space grid size), lb (an array of real numbers representing the lower bounds of the space), and ub (an array of real numbers representing the upper bounds of the space). The subroutine also has one output parameter: z (an array of integers representing the z coordinates of the point).",
            "Write a Fortran subroutine called \"xtoz\" that converts x coordinates to z coordinates on a discretized space. The subroutine takes in 5 input parameters: nd (integer), x (real array of size nd), h (real array of size nd), lb (real array of size nd), and ub (real array of size nd). The subroutine also has 1 output parameter: z (integer array of size nd).\n\nTo convert the x coordinates to z coordinates, iterate over each dimension i from 1 to nd. Check if the x coordinate is out of bounds (less than lb or greater than ub), and if so, set z to -1 and exit the loop. Otherwise, calculate z using the formula floor((x(i)-lb(i))/h(i)) + 1.\n\nYour task is to implement this subroutine in Fortran and ensure that the input and output parameters are declared correctly and used as specified.",
            "Please provide me with a Fortran subroutine code called \"xtoz\" which converts x coordinates to z coordinates on a discretized space. The subroutine takes in 5 input parameters: \n1. \"x\" - the coordinates of the point to be converted, an array of type real\n2. \"h\" - the space grid size, an array of type real\n3. \"lb\" - the lower bound of the space, an array of type real\n4. \"ub\" - the upper bound of the space, an array of type real\n5. \"nd\" - the dimension of the space, an integer\n\nThe subroutine also has 1 output parameter:\n1. \"z\" - the z coordinates of the point, an array of type integer\n\nThe instruction should be written in an imperative tone."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nd\n    real :: x(3), h(3), lb(3), ub(3)\n    integer :: z(3)\n    \n    nd = 3\n    \n    ! Test case 1\n    x = [1.0, 2.0, 3.0]\n    h = [0.5, 0.5, 0.5]\n    lb = [0.0, 1.0, 2.0]\n    ub = [2.0, 4.0, 6.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [0.5, 1.5, 2.5]\n    h = [0.2, 0.4, 0.6]\n    lb = [0.0, 1.0, 2.0]\n    ub = [1.0, 2.0, 3.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [2.0, 2.0, 2.0]\n    h = [0.1, 0.1, 0.1]\n    lb = [1.0, 1.0, 1.0]\n    ub = [3.0, 3.0, 3.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [3.5, 4.0, 4.5]\n    h = [0.5, 0.5, 0.5]\n    lb = [1.0, 2.0, 3.0]\n    ub = [5.0, 6.0, 7.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [0.0, 0.0, 0.0]\n    h = [0.2, 0.2, 0.2]\n    lb = [-1.0, -1.0, -1.0]\n    ub = [1.0, 1.0, 1.0]\n    call xtoz(z, x, h, lb, ub, nd)\n    print *, z\n    print *, \"&\"\nend program main",
            "result": [
                "3           3           3",
                "3           2           1",
                "11          11          11",
                "6           5           4",
                "6           6           6"
            ]
        },
        "code": "subroutine xtoz(z, x, h, lb, ub, nd)\n!------------------------------------------------------------------\n!\txtoz converts x coordinates to z coordinates on the discretized space\n!\tinput:\n!\t\t\tx\t\tthe coordinates of the point to be converted\n!\t\t\th\t\tthe space grid size\n!\t\t\tlb\t\tthe lower bound of the space\n!\t\t\tub\t\tthe upper bound of the space\n!\t\t\tnd\t\tthe dimension of apace\n!\toutput:\n!\t\t\tz\t\tthe z coordinates of the point\n!\tby: yousef naranjani-mar 30 2016\n!------------------------------------------------------------------\n\timplicit none\n\tinteger, intent(in)::nd\n\treal, dimension (1 : nd), intent(in):: x, h, lb, ub\n\tinteger, dimension (1 : nd), intent(out):: z\n\tinteger:: i\n\tdo i = 1, nd\n\t\tif ((x(i) < lb(i)).or.(x(i) > ub(i))) then\n!\t\t\terror stop \"xtoz: the x coordinate was out of bound\"\n\t\t\tz = -1\n\t\t\texit\n\t\telse if (x(i) == ub(i)) then\n\t\t\tz(i) = floor((ub(i)-lb(i))/h(i))\n\t\telse\n\t\t\tz(i) = floor((x(i)-lb(i))/h(i)) + 1\n\t\tend if\n\tend do\nend subroutine xtoz\n",
        "answer": "subroutine xtoz(nd, x, h, lb, ub, z)\n    integer, intent(in) :: nd\n    real(8), intent(in) :: x(nd), h(nd), lb(nd), ub(nd)\n    integer :: z(nd)\n    real(8) :: t(nd)\n    integer :: i\n\n    do i = 1, nd\n        t(i) = (x(i) - lb(i)) / h(i)\n        z(i) = int(t(i))\n    end do\nend subroutine xtoz\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"sparin_gauss\" that performs sparse matrix factorization using Gaussian elimination. It has two input parameters: \"kdiag\" is an integer array representing the diagonals of the sparse matrix, and \"kv\" is an output real array used to store the factorized matrix. The subroutine does not return any value.",
            "Create a Fortran subroutine called sparin_gauss. This subroutine accepts two input parameters and has no output parameters. The first input parameter is an integer array called kdiag, and the second input parameter is a real array called kv. The subroutine is responsible for performing some calculations and updating the values in the kv array.",
            "Please write a Fortran subroutine called sparin_gauss. This subroutine takes in two input parameters: \n1. An integer array called kdiag, which is passed by reference and is used to determine the diagonal of the sparse matrix.\n2. A real array called kv, which is passed by reference and will store the values of the sparse matrix.\n\nThe subroutine does not have any output parameters.\n\nPlease implement the subroutine following the Fortran syntax and conventions."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n, i\n    integer, parameter :: k = 5\n    integer :: kdiag(k)\n    real*8 :: kv(10)\n    \n    ! Test case 1\n    n = 5\n    kdiag = [(i, i=1,k)]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    n = 3\n    kdiag = [0, 1, 0, 2, 3]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    n = 4\n    kdiag = [1, 2, 3, 4, 5]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    n = 2\n    kdiag = [2, 0, 3, 0, 1]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    n = 3\n    kdiag = [1, 2, 3, 2, 1]\n    call sparin_gauss(kv, kdiag)\n    do i = 1, n*(n+1)/2\n        print *, kv(i)\n    end do\n    print *, \"&\"\nend program main",
            "result": [
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317\n   8.9164432238799354E-317\n   8.9165331438274785E-317\n   8.9163355175691420E-317\n   3.9525251667299724E-323\n   4.2439915824246103E-314\n   8.4879831653432862E-314\n   6.9527192090979618E-310\n   2.9707941075984141E-313\n   6.9528798000410905E-310",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317\n   8.9164432238799354E-317\n   8.9165331438274785E-317\n   8.9163355175691420E-317\n   3.9525251667299724E-323",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000",
                "8.9163355175691420E-317\n   3.9525251667299724E-323\n   0.0000000000000000     \n   2.3282605679919028E-310\n   0.0000000000000000     \n   8.9164387772891228E-317"
            ]
        },
        "code": "subroutine sparin_gauss(kv,kdiag)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n integer,intent(in)::kdiag(:)\r\n real(iwp),intent(out)::kv(:)\r\nend subroutine sparin_gauss\r\n",
        "answer": "subroutine sparin_gauss(kdiag, kv)\n    integer, intent(in) :: kdiag(:)\n    real, intent(out) :: kv(:)\n    integer :: i, j, k, l, m, n\n    real :: sum\n\n    n = size(kdiag)\n\n    do i = 1, n\n        kv(i) = kdiag(i)\n    end do\n\n    do i = 1, n\n        do j = 1, n\n            if (i /= j) then\n                do k = 1, n\n                    do l = 1, n\n                        do m = 1, n\n                            sum = sum + kv(k) * kv(l) * kv(m)\n                        end do\n                    end do\n                end do\n            end if\n        end do\n    end do\n\nend subroutine sparin_gauss\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"bar\" to calculate the sum of squares of elements in a two-dimensional array. The subroutine has 2 input parameters and 1 output parameter. The first input parameter is an array of real numbers, and the second input parameter is the size of the array. The output parameter is a single real number representing the sum of squares. The subroutine iterates over each element of the array, squares it, and adds it to the running total. The calculated sum is then stored in the output parameter.",
            "Write a Fortran subroutine called \"bar\" to compute the sum of squares of all elements in a two-dimensional array. The subroutine takes two input parameters: an array of real numbers called \"a\" and an output variable called \"x\" of type real. The size of the array is not fixed and can be of any dimension. In the subroutine, initialize the output variable to zero. Then, iterate over each element of the array and add its square to the output variable. The resulting sum of squares will be stored in the variable \"x\".",
            "Give me a Fortran subroutine code called `bar` to compute the sum of squares of elements in a two-dimensional array. The subroutine takes two input parameters. The first parameter is a two-dimensional array of real numbers, and it is passed by reference. The second parameter is a scalar variable of type real, and it is passed by reference as well. The subroutine does not return any value."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real, dimension(3, 3) :: matrix1, matrix2, matrix3, matrix4, matrix5\n    real :: result1, result2, result3, result4, result5\n    integer :: i, j\n    \n    ! Test case 1\n    matrix1 = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])\n    call bar(matrix1, result1)\n    print *, result1\n    print *, \"&\"\n    \n    ! Test case 2\n    matrix2 = reshape([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5], [3, 3])\n    call bar(matrix2, result2)\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    matrix3 = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0], [3, 3])\n    call bar(matrix3, result3)\n    print *, result3\n    print *, \"&\"\n    \n    ! Test case 4\n    matrix4 = reshape([2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0], [3, 3])\n    call bar(matrix4, result4)\n    print *, result4\n    print *, \"&\"\n    \n    ! Test case 5\n    matrix5 = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3, 3])\n    call bar(matrix5, result5)\n    print *, result5\n    print *, \"&\"\n    \nend program main",
            "result": [
                "285.000000",
                "71.2500000",
                "28500.0000",
                "1140.00000",
                "0.00000000"
            ]
        },
        "code": "  subroutine bar(a,x)\n    real, dimension(:,:), intent(in) :: a\n    real, intent(out) :: x\n    integer :: i,j\n\n    x = 0\n    do j=1,ubound(a,2)\n       do i=1,ubound(a,1)\n          x = x + a(i,j)**2\n       end do\n    end do\n  end subroutine bar\n",
        "answer": "subroutine bar(a, n, result)\n    real, dimension(n,n) :: a\n    integer :: n, i, j\n    real :: result\n\n    result = 0.0\n    do i = 1, n\n        do j = 1, n\n            result = result + a(i,j)**2\n        end do\n    end do\nend subroutine bar\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called in1_ord11 to calculate the first inner product of two arrays. The subroutine takes in 4 parameters. The first parameter is an integer representing the size of the arrays. The next two parameters are real arrays, t1f_a and t1f_b, which contain the elements of the arrays. The last parameter is the output variable, res, which is also a real number. \n\nTo compute the inner product, the subroutine initializes the result, res, to zero. Then, it iterates over each element of the arrays using a loop. In each iteration, it multiplies the corresponding elements of t1f_a and t1f_b and adds the result to the current value of res. Finally, the subroutine returns the computed inner product.\n\nPlease note that the code assumes that the arrays t1f_a and t1f_b have the same size, specified by the idm parameter.",
            "Provide a Fortran subroutine code called \"in1_ord11\" which calculates the first inner product of two arrays. The subroutine takes four input parameters: \"idm\" of type integer, \"t1f_a\" and \"t1f_b\" both of type real and of size \"idm\". There is one output parameter \"res\" of type real(8). \n\nTo compute the inner product, the subroutine initializes the output variable \"res\" to 0.0. It then iterates over the elements of the arrays \"t1f_a\" and \"t1f_b\" from index 1 to \"idm\". Inside the loop, it multiplies the corresponding elements of the arrays and adds the result to \"res\". \n\nPlease note that the subroutine assumes that the size of the arrays \"t1f_a\" and \"t1f_b\" is equal to \"idm\".",
            "Write a Fortran subroutine called \"in1_ord11\" that calculates the first inner product of two arrays \"t1f_a\" and \"t1f_b\". The subroutine takes in four parameters: \"res\" as the output argument of type real(8), \"t1f_a\" and \"t1f_b\" as input arguments of type real(8) arrays, and \"idm\" as the input argument of type integer. \n\nTo compute the inner product, the subroutine initializes the output \"res\" to 0.0 and then iterates over the elements of the arrays using the variable \"ii\". In each iteration, it multiplies the corresponding elements from \"t1f_a\" and \"t1f_b\" arrays and adds the result to \"res\". Finally, the subroutine returns the computed inner product as the value of \"res\".\n\nPlease note that the arrays \"t1f_a\" and \"t1f_b\" must have the same size, which is specified by the integer parameter \"idm\"."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: idm = 5 ! dimension of arrays\n    real(8) :: t1f_a(idm), t1f_b(idm), result\n    ! Test case 1\n    t1f_a = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t1f_b = [5.0, 4.0, 3.0, 2.0, 1.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    t1f_a = [0.5, 0.2, 1.0, 0.8, 0.9]\n    t1f_b = [0.1, 0.3, 0.5, 0.7, 0.9]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    t1f_a = [10.0, 20.0, 30.0, 40.0, 50.0]\n    t1f_b = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    t1f_a = [0.0, 0.0, 0.0, 0.0, 0.0]\n    t1f_b = [1.5, 2.5, 3.5, 4.5, 5.5]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    t1f_a = [1.0, 2.0, 3.0, 4.0, 5.0]\n    t1f_b = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call in1_ord11(result, t1f_a, t1f_b, idm)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "35.000000000000000",
                "1.9799999599158769",
                "550.00000000000000",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "      subroutine in1_ord11 (res, t1f_a, t1f_b, idm)\n      ! returns the first inner product of a and b\n      ! res = a_i * b_i\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res\n         real(8), intent(in)  :: t1f_a (idm)\n         real(8), intent(in)  :: t1f_b (idm)\n      \n         !### var ###!\n         integer  :: ii\n         \n         !### code ###!\n         res = 0.0d0\n         do ii = 1,idm\n            res = res + t1f_a(ii) * t1f_b(ii)\n         enddo\n      \n      end subroutine\n",
        "answer": "subroutine in1_ord11(t1f_a, t1f_b, res, idm)\n\n    implicit none\n\n    integer, intent(in) :: idm\n    real, dimension(idm), intent(in) :: t1f_a, t1f_b\n    real, intent(out) :: res\n\n    integer :: i\n\n    res = 0.0\n    do i = 1, idm\n        res = res + t1f_a(i) * t1f_b(i)\n    end do\n\nend subroutine in1_ord11\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called radial_basis that calculates the basis functions for radial functions. The subroutine has several input parameters: an integer l, a double precision alpha, an integer n_b, an integer n_r, and an array r_grid of type double precision. The subroutine also has two output parameters: an array basis of type double precision and an integer status. The subroutine calculates the basis functions by applying recurrence relations and scales them by normalization constants. The basis functions are stored in the array basis. The status parameter is used to indicate if there were any errors during the computation.",
            "Please provide a Fortran subroutine code called \"radial_basis\" which calculates the basis functions for a given radial grid. The subroutine has multiple input and output parameters. The input parameters are:\n- \"l\": an integer representing a parameter\n- \"alpha\": a double precision number\n- \"n_b\": an integer representing the number of basis functions\n- \"n_r\": an integer representing the number of points in the radial grid\n- \"r_grid\": an array of double precision numbers representing the radial grid\n\nThe output parameters are:\n- \"basis\": a 2D array of double precision numbers representing the basis functions\n- \"status\": an integer indicating the status of the computation\n\nThe subroutine checks if the input arguments are valid and calculates the basis functions using recurrence relations. It also calculates normalization constants for the basis functions. The basis functions are then scaled by the normalization constants.\n\nPlease note that the subroutine uses features specific to Fortran, such as double precision data type and array indexing.\n\nThe subroutine should be called \"radial_basis\".",
            "Give me a Fortran subroutine code called radial_basis to compute the radial basis functions. The subroutine has multiple input and output parameters. The input parameters are: l (an integer), alpha (a double precision), n_b (an integer), n_r (an integer), and r_grid (an array of double precision). The output parameters are: basis (a 2D array of double precision) and status (an integer). \n\nThe code first checks if the input arguments are valid and sets the status accordingly. Then it computes the normalization constants for the basis functions using a recurrence relation. Next, it generates an array called alpha_grid by multiplying alpha with r_grid. The basis functions are then computed using another recurrence relation. Finally, the basis functions are scaled by the normalization constants. The resulting basis functions are stored in the basis array.\n\nPlease note that this code relies on external functions and libraries such as gamma and sqrt.\n\n"
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: l, n_b, n_r, status, kk\n    double precision :: alpha\n    double precision, allocatable :: r_grid(:), basis(:,:)\n    \n    ! Test case 1\n    l = 2\n    alpha = 0.5\n    n_b = 3\n    n_r = 5\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 2\n    l = 3\n    alpha = 1.0\n    n_b = 2\n    n_r = 4\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.2, 0.4, 0.6, 0.8]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 3\n    l = 1\n    alpha = 0.7\n    n_b = 3\n    n_r = 3\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.3, 0.6, 0.9]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 4\n    l = 4\n    alpha = 1.5\n    n_b = 4\n    n_r = 6\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \n    ! Test case 5\n    l = 0\n    alpha = 0.3\n    n_b = 2\n    n_r = 5\n    allocate(r_grid(n_r))\n    allocate(basis(n_r, n_b))\n    \n    r_grid = [0.1, 0.2, 0.3, 0.4, 0.5]\n    \n    call radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    \n    print *, basis\n    print *, \"&\"\n    \n    deallocate(r_grid)\n    deallocate(basis)\n    \nend program main",
            "result": [
                "3.5450229148029559E-005   2.6977040836619412E-004   8.6607079290971448E-004   1.9527868752387092E-003   3.6280239414119356E-003   7.3947937385630233E-005   5.5319380656143082E-004   1.7453529087138818E-003   3.8663207526262724E-003   7.0548509110186959E-003   1.2167126355235084E-004   8.9466261455733206E-004   2.7734093697270542E-003   6.0338848209109276E-003   1.0808495542952802E-002",
                "1.4761681463944885E-004   1.9337348073046824E-003   8.0149919377768362E-003   2.0739539157233800E-002   3.5477206967341704E-004   4.4028045876276581E-003   1.7235028246000341E-002   4.1973875913464104E-002",
                "3.4534657286656362E-002  0.11197299601224384       0.20421796021582389        5.0473398846081784E-002  0.14445239720046285       0.22843827937573838        6.1686350908104218E-002  0.15405333109548161       0.20520724788666211",
                "1.9016966595250715E-006   5.2377775357938272E-005   3.4234124030166644E-004   1.2416771254551765E-003   3.2614786863799281E-003   6.9851650679741348E-003   5.3250336272708904E-006   1.4212951656637445E-004   8.9931116942082066E-004   3.1542835331544164E-003   8.0028162895351331E-003   1.6534836278320957E-002   1.1214096059187139E-005   2.8997409102586710E-004   1.7753049845598331E-003   6.0166752622521202E-003   1.4727819651723166E-002   2.9309950656421908E-002   2.0346705324988351E-005   5.0956042765451189E-004   3.0169066761456765E-003   9.8711199037292609E-003   2.3283346505164403E-002   4.4553657562830785E-002",
                "3.1892096897150300E-002   6.1899085877210984E-002   9.0104539019090560E-002  0.11658872709867828       0.14142875982061820        3.0935333937960569E-002   5.8185140521657304E-002   8.1995129862894506E-002  0.10259807908242162       0.12021444500454437"
            ]
        },
        "code": "  subroutine radial_basis (l, alpha, n_b, n_r, r_grid, basis, status)\n    integer , intent(in) :: l\n    double precision , intent(in) :: alpha\n    integer , intent(in) :: n_b\n    integer , intent(in) :: n_r\n    double precision , intent(in) :: r_grid(n_r)\n    double precision , intent(out) :: basis(n_r, n_b)\n    integer , intent(out) :: status\n    double precision :: norm(n_b)\n    double precision :: alpha_grid(n_r)\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1) .or. (n_r < 1)) then\n      status = 1\n      return\n    end if\n\n    ! recurrence relation for basis normalisation constants\n    norm(1) = sqrt(alpha / dble((l + 1d0) * gamma(dble((2d0 * l) + 2d0))))\n\n    if (n_b >= 2) then\n      do kk = 2, n_b\n        norm(kk) = norm(kk-1) * sqrt(dble((kk - 1d0) * (kk - 1d0 + l)) / &\n            dble((kk + l) * (kk + (2d0 * l))))\n      end do\n    end if\n\n    ! in-lined array since r_grid(:) on its own is never used\n    alpha_grid(:) = alpha * r_grid(:)\n\n    ! recurrence relation for basis functions\n    basis(:, 1) = ((2.0d0 * alpha_grid(:)) ** (l + 1)) * &\n        exp(-alpha_grid(:))\n\n    if (n_b >= 2) then\n      basis(:, 2) = 2.0d0 * (dble(l + 1d0) - alpha_grid(:)) * basis(:, 1)\n    end if\n\n    if (n_b >= 3) then\n      do kk = 3, n_b\n        basis(:, kk) = &\n            ((2.0d0 * (dble(kk - 1d0 + l) - alpha_grid(:)) * basis(:, kk-1)) &\n            - dble(kk + (2d0 * l) - 1d0) * basis(:, kk-2)) / dble(kk - 1)\n      end do\n    end if\n\n    ! scaling basis functions by normalisation constants\n    do kk = 1, n_b\n      basis(:, kk) = basis(:, kk) * norm(kk)\n    end do\n\n  end subroutine radial_basis\n",
        "answer": "subroutine radial_basis(l, alpha, n_b, n_r, r_grid, basis, status)\n    integer, intent(in) :: l, n_b, n_r\n    double precision, intent(in) :: alpha, r_grid(n_r)\n    double precision, intent(out) :: basis(n_r, n_b)\n    integer, intent(out) :: status\n    double precision :: normalization\n    integer :: i, j\n\n    status = 0\n\n    do i = 1, n_r\n        basis(i, 1) = 1.0d0\n        basis(i, 2) = sqrt(3.0d0) * (2.0d0 * alpha * r_grid(i) - 3.0d0)\n        do j = 3, n_b\n            basis(i, j) = (2.0d0 * alpha * r_grid(i) - 2.0d0 * dble(j-1)) * basis(i, j-1) &\n                          - dble(j-2) * basis(i, j-2)\n        end do\n    end do\n\n    normalization = 2.0d0 * alpha / (2.0d0 * alpha - 1.0d0)\n    basis = basis * normalization\n\nend subroutine radial_basis\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called helm3d_f that calculates the potential at target points due to a set of sources in three-dimensional space using the Helmholtz equation. The subroutine expects several input parameters: \n1. nd (integer*4): the number of dimensions\n2. zk (complex*8): a complex number representing the wave number\n3. sources (real*8): an array of real numbers representing the source values\n4. charge (complex*8): an array of complex numbers representing the charge distribution\n5. ns (integer*4): the number of sources\n6. ztarg (real*8): an array of real numbers representing the target coordinates\n7. nt (integer*4): the number of target points\n8. thresh (real*8): a real number representing the threshold value\n\nThe subroutine also has an output parameter:\n1. pot (complex*8): an array of complex numbers representing the calculated potential at the target points\n\nTo use the subroutine, provide the necessary input parameters and an array to store the calculated potential. The subroutine will compute the potential at the target points based on the specified sources and charge distribution using the Helmholtz equation.",
            "Write a Fortran subroutine called helm3d_f that calculates the potential at specified target points in a three-dimensional space using a Helmholtz equation solver. The subroutine takes in several input parameters: an integer nd, a complex number zk, an array of real numbers called sources, an array of complex numbers called charge, an integer ns, an array of real numbers called ztarg, an integer nt, and a real number thresh. The subroutine also has an output parameter called pot, which is an array of complex numbers.",
            "Write a Fortran subroutine called \"helm3d_f\" that solves the three-dimensional Helmholtz equation. The subroutine takes several input parameters: an integer \"nd\" representing the dimensionality, a complex number \"zk\" representing the wave number, an array \"sources\" of real numbers representing the source locations, an array \"charge\" of complex numbers representing the source charges, an integer \"ns\" representing the number of sources, an array \"ztarg\" of real numbers representing the target locations, an integer \"nt\" representing the number of targets, and a real number \"thresh\" representing a threshold value.\n\nThe subroutine calculates the potential at the target locations and stores the results in the \"pot\" array, which is of complex number type.\n\nEnsure that you use the Fortran keywords \"implicit none\" to enforce explicit declarations of all variables.\n\nPlease note that this code is designed to be callable from C/C++ code, as indicated by the \"bind(c)\" directive."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer*4 :: nd, ns, nt\n    complex*8 :: zk\n    real*8, allocatable :: sources(:), ztarg(:)\n    complex*8, allocatable :: charge(:), pot(:)\n    real*8 :: thresh\n    \n    ! Test case 1\n    nd = 3\n    zk = (1.0, 2.0)\n    ns = 4\n    nt = 5\n    thresh = 0.001\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [1.0, 2.0, 3.0] \n    charge = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]\n    ztarg = [1.0, 2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 2\n    nd = 2\n    zk = (-1.0, 0.5)\n    ns = 3\n    nt = 4\n    thresh = 0.01\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [0.5, 1.0] \n    charge = [(-1.0, 0.5), (-2.0, 1.0), (-3.0, 1.5)]\n    ztarg = [2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 3\n    nd = 4\n    zk = (0.0, 0.0)\n    ns = 2\n    nt = 3\n    thresh = 0.1\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [0.0, 1.0, 2.0, 3.0] \n    charge = [(0.0, 0.0), (1.0, 1.0)]\n    ztarg = [3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 4\n    nd = 1\n    zk = (2.5, -1.5)\n    ns = 1\n    nt = 2\n    thresh = 0.001\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [4.0] \n    charge = [(1.0, -1.0)]\n    ztarg = [1.0, 2.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \n    ! Test case 5\n    nd = 3\n    zk = (0.0, 1.0)\n    ns = 2\n    nt = 4\n    thresh = 0.1\n    \n    allocate(sources(nd), charge(ns), ztarg(nt), pot(nt))\n    sources = [1.0, 2.0, 3.0] \n    charge = [(0.0, 1.0), (0.5, 1.5)]\n    ztarg = [2.0, 3.0, 4.0, 5.0]\n    \n    call helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh)\n    \n    print *, pot\n    print *, \"&\"\n    \n    deallocate(sources, charge, ztarg, pot)\n    \nend program main",
            "result": [
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41) (  2.63363452E+20,  1.01397088E-38) (  4.82217751E+30,  1.07647170E+21) (  8.67567934E+29,  4.07402584E-11)",
                "(  3.00643765E-38,  0.00000000    ) (  0.00000000    ,  2.00000000    ) (  0.00000000    ,  2.12500000    ) (  0.00000000    ,  2.25000000    )",
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41) (  1.84707640E+25,  8.09124309E+20)",
                "(  2.90570981E+20,  1.54549208E-41) (  2.90570981E+20,  1.54549208E-41)",
                "(  3.00643765E-38,  0.00000000    ) (  0.00000000    ,  2.12500000    ) (  0.00000000    ,  2.25000000    ) (  0.00000000    ,  2.31250000    )"
            ]
        },
        "code": "  subroutine helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, pot, thresh) !bind(c, name=\"helm3d_f_\")\n    implicit none\n    integer *4, intent(in) :: nd\n    complex *8, intent(in) :: zk\n    real    *8, intent(in) :: sources(*)\n    complex *8, intent(in) :: charge(*)\n    integer *4, intent(in) :: ns\n    real    *8, intent(in) :: ztarg(*)\n    integer *4, intent(in) :: nt\n    complex *8, intent(out):: pot(*)\n    real    *8, intent(in) :: thresh\n  end subroutine\n",
        "answer": "subroutine helm3d_f(nd, zk, sources, charge, ns, ztarg, nt, thresh, pot)\n    integer*4, intent(in) :: nd, ns, nt\n    real*8, intent(in) :: sources(nd,ns), ztarg(nd,nt), thresh\n    complex*8, intent(in) :: zk, charge(nd,ns)\n    complex*8, intent(out) :: pot(nd,nt)\n    integer*4 :: i, j, k\n    real*8 :: r, r2\n\n    do i = 1, nt\n        do j = 1, nd\n            r2 = 0.0d0\n            do k = 1, ns\n                r = sqrt(sum((ztarg(j,i) - sources(j,k))**2))\n                r2 = r2 + (1.0d0/r)**2\n            end do\n            pot(j,i) = zk * (1.0d0/r2)\n        end do\n    end do\n\nend subroutine helm3d_f\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called get_opacities that calculates the opacities for a given set of parameters. The subroutine takes 6 input parameters and 2 output parameters. \n\nThe input parameters are:\n- kp: a logical value indicating whether to calculate the Planck mean opacity\n- kr: a logical value indicating whether to calculate the Rosseland mean opacity\n- rho: a real value representing the density\n- temp: a real value representing the temperature\n- rhoye: a real value representing the mass density times the specific internal energy\n- nu: a real value representing the frequency\n\nThe output parameters are:\n- kp: a real value representing the Planck mean opacity\n- kr: a real value representing the Rosseland mean opacity\n\nInside the subroutine, there are two conditional statements that calculate the opacities based on the input parameters. If the kp flag is true, the Planck mean opacity is calculated and stored in the kp variable. If the kr flag is true, the Rosseland mean opacity is calculated and stored in the kr variable.\n\nPlease note that the Thompon scattering cross-section constant is defined as ksc = 0.4 and the Planck mean opacity is assumed to be fac times the Thompon scattering cross-section constant, where fac = 1.0e-4.\n\nMake sure to provide the input and output parameters with the correct data types and follow the specified logic for calculating the opacities.",
            "Write a Fortran subroutine called get_opacities to calculate the opacities of a material based on given parameters. The subroutine has two input parameters and two output parameters. The input parameters are logical variables called get_planck_mean and get_rosseland_mean, which determine if the planck mean and rosseland mean opacities should be calculated. The other input parameters are double precision variables rho, temp, rhoye, and nu, which represent the density, temperature, energy density, and frequency, respectively. The output parameters are double precision variables kp and kr, which represent the planck mean and rosseland mean opacities, respectively. The subroutine utilizes the constants ksc and fac to calculate the opacities. If get_planck_mean is true, the planck mean opacity is calculated as kp = rhoye * ksc * fac. If get_rosseland_mean is true, the rosseland mean opacity is calculated as kr = rhoye * ksc.",
            "Write a Fortran subroutine called \"get_opacities\" to compute the opacities, specifically the Planck mean and Rosseland mean opacities. The subroutine takes in 6 parameters: two logical variables, \"get_planck_mean\" and \"get_rosseland_mean\", two double precision variables, \"rho\" and \"temp\", and two more double precision variables, \"rhoye\" and \"nu\". The subroutine also has two output parameters, \"kp\" and \"kr\", both of type double precision.\n\nThe subroutine computes the opacities based on the input parameters. If the \"get_planck_mean\" parameter is true, the subroutine calculates the Planck mean opacity by multiplying \"rhoye\" (the density times the electron abundance) with the Thomson scattering constant \"ksc\" times a scaling factor \"fac\", and assigns the result to \"kp\". If the \"get_rosseland_mean\" parameter is true, the subroutine calculates the Rosseland mean opacity by multiplying \"rhoye\" with the Thomson scattering constant \"ksc\", and assigns the result to \"kr\".\n\nTo use this subroutine, make sure to provide the correct input parameters and declare the output parameters \"kp\" and \"kr\" before calling it."
        ],
        "test_case": {
            "unit_test": "\nprogram main\n    use test_subroutine\n    implicit none\n    double precision :: rho, temp, rhoye, nu, kp, kr\n    logical :: get_planck_mean, get_rosseland_mean\n    \n    ! Test case 1\n    rho = 1.0\n    temp = 5000.0\n    rhoye = 0.75\n    nu = 1.5\n    get_planck_mean = .true.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 2\n    rho = 0.5\n    temp = 10000.0\n    rhoye = 0.6\n    nu = 2.0\n    get_planck_mean = .true.\n    get_rosseland_mean = .false.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 3\n    rho = 2.0\n    temp = 8000.0\n    rhoye = 0.9\n    nu = 1.8\n    get_planck_mean = .false.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 4\n    rho = 1.2\n    temp = 6000.0\n    rhoye = 0.8\n    nu = 1.6\n    get_planck_mean = .false.\n    get_rosseland_mean = .false.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\n    print *, \"&\"\n    \n    ! Test case 5\n    rho = 0.8\n    temp = 7000.0\n    rhoye = 0.7\n    nu = 1.4\n    get_planck_mean = .true.\n    get_rosseland_mean = .true.\n    \n    call get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n    print *, kp, kr\nend program main\n",
            "result": [
                "3.0000000000000008E-005  0.30000000000000004",
                "2.4000000953674318E-005  0.30000000000000004",
                "2.4000000953674318E-005  0.35999999046325687",
                "2.4000000953674318E-005  0.35999999046325687",
                "2.7999999523162846E-005  0.27999999523162844"
            ]
        },
        "code": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: ksc = 0.4d0 ! thomson scattering \n    double precision, parameter :: fac = 1.d-4 ! planck mean is assumed to be fac*ksc\n\n    if (get_planck_mean) then\n       kp = rhoye*ksc * fac\n    end if\n\n    if (get_rosseland_mean) then\n       kr = rhoye*ksc\n    end if\n\n  end subroutine get_opacities\n",
        "answer": "subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, kp_out, kr_out)\n    logical, intent(in) :: kp, kr\n    real, intent(in) :: rho, temp, rhoye, nu\n    real, intent(out) :: kp_out, kr_out\n\n    real :: ksc, fac\n\n    ksc = 0.4\n    fac = 1.0e-4\n\n    if (kp) then\n        kp_out = fac * ksc\n    end if\n\n    if (kr) then\n        kr_out = ksc\n    end if\n\nend subroutine get_opacities\n\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called \"lennardjones\" to calculate the Lennard-Jones potential. The subroutine takes two input parameters and one output parameter. The first input parameter is a real number representing the distance between two centers, and the second input parameter is the output variable \"pot\" of type real to store the calculated potential. The subroutine also declares and initializes some variables used in the calculations. Within the subroutine, the Lennard-Jones potential is computed based on the given formula. Finally, the subroutine returns without any value.",
            "Provide me with a Fortran subroutine called \"lennardjones\" that calculates the Lennard-Jones potential. The subroutine takes one input parameter of type real named \"r\". There is one output parameter of type real named \"pot\". The subroutine also has five internal variables: \"p\" and \"q\" of type integer, and \"epl\", \"radius\", and \"pot_cof\" of type real. The subroutine computes the Lennard-Jones potential using the following formulas:\n\npot = epl * ( (r_eq^p / r_cof^p) - ((p/q) * (r_eq^q / r_cof^q)) )\n\nwhere:\n- epl is the strength of the Lennard-Jones potential\n- r_eq is the equilibrium center-to-center distance\n- r_cof is the cut-off center-to-center distance\n- p and q are parameters\n- radius is a computed value based on other variables\n\nThe subroutine first initializes the variables \"p\" and \"q\" to 18 and 6, respectively, and \"epl\" to 3.0. It then computes the value of \"radius\" based on other variables. Finally, the subroutine calculates the potential using the given formula and stores it in the variable \"pot\". If the center distance \"r_mn\" is greater than the cut-off distance \"r_cof\", the potential is set to zero. The subroutine ends with the \"return\" statement.",
            "Please write a Fortran subroutine called lennardjones to compute the Lennard-Jones potential between two particles. \n\nThe subroutine takes two input parameters: \n1. A single real number representing the center distance between two particles, denoted as 'r'.\n2. A single real number representing the potential, denoted as 'pot'.\n\nThe subroutine also has several internal variables:\n1. Two integers, 'p' and 'q', representing the power values used in the potential calculation.\n2. A real number, 'epl', representing the strength of the Lennard-Jones potential.\n3. Several other real variables used for intermediate calculations.\n\nThe subroutine computes the Lennard-Jones potential using the given values of 'r', 'p', 'q', and 'epl', and stores the result in the variable 'pot'.\n\nThe subroutine follows the formula:\npot = epl * (r_eq^p / r_mn^p - (p/q) * r_eq^q / r_mn^q) - pot_cof\n\nAdditionally, there are conditions to make the potential zero at a cut-off distance and after the cut-off distance.\n\nPlease implement the subroutine 'lennardjones' according to the given specifications."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: r, pot\n    integer :: p, q\n    real :: epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    \n    ! Test case 1\n    r = 1.0\n    p = 4\n    q = 2\n    epl = 1.5\n    radius = 0.5\n    r_eq = 0.8\n    r_mn = 1.2\n    r_cof = 1.6\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 2\n    r = 2.5\n    p = 6\n    q = 3\n    epl = 2.0\n    radius = 1.0\n    r_eq = 1.8\n    r_mn = 3.5\n    r_cof = 4.5\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 3\n    r = 0.7\n    p = 10\n    q = 5\n    epl = 2.5\n    radius = 0.3\n    r_eq = 0.6\n    r_mn = 0.9\n    r_cof = 1.2\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 4\n    r = 1.2\n    p = 8\n    q = 4\n    epl = 1.8\n    radius = 0.7\n    r_eq = 1.1\n    r_mn = 1.8\n    r_cof = 2.5\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\n    print *, \"&\"\n\n    ! Test case 5\n    r = 3.0\n    p = 12\n    q = 6\n    epl = 3.5\n    radius = 1.2\n    r_eq = 2.5\n    r_mn = 3.8\n    r_cof = 4.8\n    pq = p*1.0/q*1.0\n    pot_cof = epl*(r_eq**p/r_cof**p - pq*r_eq**q/r_cof**q)\n    pot = epl*(r_eq**p/r_mn**p - pq*r_eq**q/r_mn**q) - pot_cof\n    if (r_mn > r_cof) pot = 0.0\n    print *, pot\nend program main",
            "result": [
                "-0.380787015",
                "-0.259280562",
                "-0.461273909",
                "-0.334675848",
                "-0.406245112"
            ]
        },
        "code": "  subroutine lennardjones(r,pot)\n\n    !---- compute lj potential:\n    ! \n    !                   r(eq)^p     p   r(eq)^q\n    !     pot = epl ( ---------- - --- ---------- )\n    !                  r(m,n)^p     q   r(m,n)^q\n    !     where\n    !          epl    : strength of lj potential\n    !          r_eq   : equilibrium center-to-center distance\n    !          r(m,n) : center distance between m and n\n    !          r_cof  : cut-off center-to-center distance\n\n    integer p,q\n    real epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    real, intent(in) :: r\n    real, intent(out) :: pot\n\n\n    p = 18\n    q = 6\n    epl = 3.\n    pq = p*1./(q*1.)\n\n    radius = lz/6.\n    r_eq = 2.*radius + 3.5*dz\n    r_mn = 2.*radius + r\n    r_cof = 2.*radius + 6.*dz\n\n    pot_cof = epl*( r_eq**p/r_cof**p - pq* r_eq**q/r_cof**q) !potential at cut-off\n    pot = epl*( r_eq**p/r_mn**p - pq* r_eq**q/r_mn**q) - pot_cof !make potential zero at cut-off\n    if (r_mn .gt. r_cof) pot = 0. !make potential zero after cut-off\n\n\n    return\n  end subroutine lennardjones\n",
        "answer": "subroutine lennardjones(r, pot)\n    implicit none\n    real, intent(in) :: r\n    real, intent(out) :: pot\n    real :: sigma, epsilon\n    real :: term1, term2\n    \n    sigma = 1.0\n    epsilon = 1.0\n    \n    term1 = sigma / r\n    term2 = term1**6\n    \n    pot = 4.0 * epsilon * (term2 - term1)\n    \n    return\nend subroutine lennardjones\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine code named calc_ps3d to calculate the power spectrum of a three-dimensional density field. The subroutine takes several input parameters: the size and boundaries of the density field (lo, hi, ng), the Fourier transform of the real and imaginary parts of the density field (overdensity_fft_real, overdensity_fft_imag), the number of bins for the power spectrum (num_bins), the edges of the k bins (k_bin_edges), the length of the domain (domain_length), and the grid length of the domain (domain_grid_length). \n\nThe subroutine also has several output parameters: the count of data points in each k bin (k_bin_count), the sum of weighted k values in each k bin (k_bin_power_weighted_k_sum), and the sum of power values in each k bin (k_bin_power_sum).\n\nThe subroutine calculates the magnitude of the wavevector for each grid point in k-space and assigns it to k_mag. It then checks if the magnitude is within the specified k bin edges and skips the value if it is out of bounds. It finds the matching k bin for each magnitude and increments the count, weighted k sum, and power sum for that bin. Finally, the subroutine returns the calculated power spectrum for the density field.\n\nPlease note that this subroutine uses the intrinsic module iso_c_binding for data type compatibility with C.",
            "Give me a Fortran subroutine code called calc_ps3d to calculate the power spectrum of a three-dimensional density field. The subroutine takes several input parameters: \n- lo(3) and hi(3), which are arrays of integers representing the lower and upper bounds of the grid in each dimension.\n- ng, an integer representing the grid size.\n- num_bins, an integer representing the number of bins in the power spectrum. \n- overdensity_fft_real and overdensity_fft_imag, which are target arrays of real numbers representing the real and imaginary components of the overdensity field in Fourier space. \n- k_bin_edges, an array of real numbers representing the edges of the bins in Fourier space. \n- domain_length, a real number representing the length of the domain. \n- domain_grid_length, an integer representing the length of the grid in each dimension.\n\nThe subroutine also has several output parameters:\n- k_bin_count, an array of integers representing the count of data points in each bin.\n- k_bin_power_weighted_k_sum, an array of real numbers representing the sum of the product of the k values and the power in each bin.\n- k_bin_power_sum, an array of real numbers representing the sum of the power in each bin.\n\nInside the subroutine, the code calculates the power spectrum by iterating over the grid points and performing various calculations. It calculates the magnitude of the k vector, checks if it falls within the specified range, finds the corresponding bin for the k value, and updates the bin count and power sums accordingly.\n\nTo use the subroutine, pass the appropriate input parameters and allocate memory for the output arrays.",
            "Provide a Fortran subroutine called calc_ps3d to calculate the power spectrum of a three-dimensional array. The subroutine requires 10 input parameters: \n- lo: an integer array of size 3 representing the lower bounds of the array indices\n- hi: an integer array of size 3 representing the upper bounds of the array indices\n- ng: an integer representing the grid size\n- num_bins: an integer representing the number of bins for the power spectrum\n- overdensity_fft_real: a 4D target array of type real that stores the real part of the overdensity Fourier transform\n- overdensity_fft_imag: a 4D target array of type real that stores the imaginary part of the overdensity Fourier transform\n- k_bin_edges: a 1D array of type real that defines the edges of the bins for the power spectrum\n- domain_length: a real number representing the length of the domain\n- domain_grid_length: an integer representing the length of the domain grid\n- The subroutine has 3 output parameters:\n- k_bin_count: a 1D array of type integer that stores the count of data points in each bin of the power spectrum\n- k_bin_power_weighted_k_sum: a 1D array of type real that stores the sum of the product of power and k value for each bin\n- k_bin_power_sum: a 1D array of type real that stores the sum of power for each bin\n\nTo use the subroutine, make sure to provide appropriate input values for the parameters and allocate memory for the target arrays. After calling the subroutine, the output arrays will contain the calculated power spectrum."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: lo(3) = [1, 1, 1], hi(3) = [64, 64, 64]\n    integer, parameter :: ng = 0, num_bins = 5\n    real*8, allocatable :: overdensity_fft_real(:,:,:,:), overdensity_fft_imag(:,:,:,:)\n    real*8, allocatable :: k_bin_edges(:), domain_length\n    integer, allocatable :: k_bin_count(:)\n    real*8, allocatable :: k_bin_power_weighted_k_sum(:), k_bin_power_sum(:)\n    integer :: i\n    \n    allocate(overdensity_fft_real(lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1))\n    allocate(overdensity_fft_imag(lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1))\n    allocate(k_bin_edges(num_bins+1))\n    allocate(k_bin_count(num_bins))\n    allocate(k_bin_power_weighted_k_sum(num_bins))\n    allocate(k_bin_power_sum(num_bins))\n    \n    ! Test case 1\n    overdensity_fft_real = 1.0\n    overdensity_fft_imag = 1.0\n    k_bin_edges = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]\n    domain_length = 1.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    overdensity_fft_real = 2.0\n    overdensity_fft_imag = 0.5\n    k_bin_edges = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n    domain_length = 2.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    overdensity_fft_real = 0.0\n    overdensity_fft_imag = 0.0\n    k_bin_edges = [0.0, 0.3, 0.6, 0.9, 1.2, 1.5]\n    domain_length = 3.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    overdensity_fft_real = 3.0\n    overdensity_fft_imag = 2.0\n    k_bin_edges = [0.0, 0.4, 0.8, 1.2, 1.6, 2.0]\n    domain_length = 4.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    overdensity_fft_real = 1.5\n    overdensity_fft_imag = 0.3\n    k_bin_edges = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]\n    domain_length = 5.0\n    call calc_ps3d(overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                   size(overdensity_fft_real, 1), k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n    do i = 1, num_bins\n        print *, k_bin_count(i), k_bin_power_weighted_k_sum(i), k_bin_power_sum(i)\n    end do\n    print *, \"&\"\n    \n    deallocate(overdensity_fft_real)\n    deallocate(overdensity_fft_imag)\n    deallocate(k_bin_edges)\n    deallocate(k_bin_count)\n    deallocate(k_bin_power_weighted_k_sum)\n    deallocate(k_bin_power_sum)\nend program main",
            "result": [
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           6   1.9144080765545368        1.2187500000000000     \n           0   0.0000000000000000        0.0000000000000000",
                "0   0.0000000000000000        0.0000000000000000     \n           0   0.0000000000000000        0.0000000000000000     \n           6  0.14114547909964500       0.11232000034332278     \n          12  0.39921970162073234       0.22464000068664555     \n           8  0.32596152141231499       0.14976000045776369"
            ]
        },
        "code": "subroutine calc_ps3d (overdensity_fft_real, overdensity_fft_imag, lo, hi, ng, num_bins, k_bin_edges, domain_length, &\n                      domain_grid_length, k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum)\n\n  use, intrinsic :: iso_c_binding\n  implicit none\n\n  integer(c_int), intent(in) :: lo(3), hi(3), ng, num_bins\n  real(c_double), intent(in), target :: overdensity_fft_real (lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1)\n  real(c_double), intent(in), target :: overdensity_fft_imag (lo(1)-ng:hi(1)+ng, lo(2)-ng:hi(2)+ng, lo(3)-ng:hi(3)+ng, 1)\n  real(c_double), intent(in) :: k_bin_edges (num_bins+1)\n  real(c_double), intent(in) :: domain_length\n  integer(c_int), intent(in) :: domain_grid_length\n\n  integer(c_int), intent(out) :: k_bin_count (num_bins)\n  real(c_double), intent(out) :: k_bin_power_weighted_k_sum (num_bins)\n  real(c_double), intent(out) :: k_bin_power_sum (num_bins)\n\n  integer(c_int) :: i, j, k\n  integer(c_int) :: kk\n  integer(c_int) :: k_bin_index\n  integer(c_int) :: k_index_i, k_index_j, k_index_k\n\n  real(c_double) :: k_fund\n  real(c_double) :: k_mag\n  real(c_double) :: k_max\n  real(c_double) :: k_min\n  real(c_double) :: p_i\n  real(c_double) :: pi\n\n  pi = acos(-1.0)\n\n  k_fund = 2.0 * pi / domain_length\n\n  k_min = minval(k_bin_edges)\n  k_max = maxval(k_bin_edges)\n\n  k_bin_count (:) = 0\n  k_bin_power_weighted_k_sum (:) = 0.0\n  k_bin_power_sum (:) = 0.0\n\n  do k = lo(3), hi(3)\n    do j = lo(2), hi(2)\n      do i = lo(1), hi(1)\n\n        ! calculate grid points in k-space.\n        if (i <= domain_grid_length/2) then\n          k_index_i = i\n        else\n          k_index_i = i-domain_grid_length\n        end if\n        if (j <= domain_grid_length/2) then\n          k_index_j = j\n        else\n          k_index_j = j-domain_grid_length\n        end if\n        if (k <= domain_grid_length/2) then\n          k_index_k = k\n        else\n          k_index_k = k-domain_grid_length\n        end if\n\n        ! skip 0 mode.\n        if ((k_index_i == 0) .and. (k_index_j == 0) .and. (k_index_k == 0)) cycle\n\n        ! calculate magnitude of k vector.\n        k_mag = k_fund * sqrt(real(k_index_i*k_index_i + k_index_j*k_index_j + k_index_k*k_index_k, c_double))\n\n        ! skip value if out of bounds.\n        if ((k_mag < k_min) .or. (k_mag >= k_max)) cycle\n\n        ! find matching k bin.\n        k_bin_index = -1\n        do kk = 1, num_bins\n        if (k_mag >= k_bin_edges(kk) .and. k_mag < k_bin_edges(kk+1)) then\n            k_bin_index = kk\n              exit\n          end if\n        end do\n        if (k_bin_index < 0) stop 'could not match k bin'\n\n        p_i = (overdensity_fft_real(i, j, k, 1)**2 + overdensity_fft_imag(i, j, k, 1)**2) / domain_length**3\n\n        k_bin_count                (k_bin_index) = k_bin_count                (k_bin_index) + 1\n        k_bin_power_weighted_k_sum (k_bin_index) = k_bin_power_weighted_k_sum (k_bin_index) + k_mag*p_i\n        k_bin_power_sum            (k_bin_index) = k_bin_power_sum            (k_bin_index) + p_i\n\n      end do\n    end do\n  end do\n\nend subroutine calc_ps3d\n",
        "answer": "subroutine calc_ps3d(lo, hi, ng, &\n                     overdensity_fft_real, overdensity_fft_imag, &\n                     num_bins, k_bin_edges, &\n                     k_bin_count, k_bin_power_weighted_k_sum, k_bin_power_sum, &\n                     domain_length, domain_grid_length) bind(c)\n\n    use, intrinsic :: iso_c_binding\n\n    integer(c_int), value :: lo, hi, ng\n    real(c_double), dimension(lo-ng:hi+ng) :: overdensity_fft_real, overdensity_fft_imag\n    integer(c_int), value :: num_bins\n    real(c_double), dimension(num_bins) :: k_bin_edges\n    integer(c_int), dimension(num_bins) :: k_bin_count\n    real(c_double), dimension(num_bins) :: k_bin_power_weighted_k_sum, k_bin_power_sum\n    real(c_double), value :: domain_length, domain_grid_length\n\n    integer(c_int) :: i, j, k, bin\n    real(c_double) :: k_mag, k_bin_width\n\n    k_bin_count = 0\n    k_bin_power_weighted_k_sum = 0.0_c_double\n    k_bin_power_sum = 0.0_c_double\n\n    do k = lo, hi\n        do j = lo, hi\n            do i = lo, hi\n                k_mag = sqrt(real(i, c_double)**2 + real(j, c_double)**2 + real(k, c_double)**2)\n                k_mag = k_mag * domain_grid_length / domain_length\n\n                if (k_mag < k_bin_edges(1) .or. k_mag > k_bin_edges(num_bins)) then\n                    cycle\n                end if\n\n                bin = floor(k_mag / k_bin_width) + 1\n\n                k_bin_"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called matrix_multiply to multiply two matrices and compute the transpose of one matrix. The number of input parameters is 5. The first parameter is the size of the matrices, the type is integer. The second and third parameters are the matrices to be multiplied, both of type real and are of size nxn. The fourth and fifth parameters are the output matrices, both of type real and are also of size nxn.",
            "Create a Fortran subroutine called matrix_bits. This subroutine takes in five parameters: n, a matrix a, a matrix b, an output matrix c, and an output matrix a_t. The n parameter is an integer that represents the size of the matrices. The a and b matrices are two-dimensional arrays of real numbers, and they are passed as input to the subroutine. The c and a_t matrices are also two-dimensional arrays of real numbers, and they are passed as output parameters.\n\nThe subroutine computes the matrix multiplication of matrices a and b and stores the result in matrix c. It uses nested do loops to iterate over the rows and columns of c, and for each element, it computes the dot product of the corresponding row in a and column in b.\n\nAdditionally, the subroutine computes the transpose of matrix a and stores it in matrix a_t. It uses another set of nested do loops to iterate over the rows and columns of a_t, and for each element, it assigns the corresponding element from matrix a.\n\nTo use this subroutine, pass the size of the matrices, the two input matrices a and b, and the two output matrices c and a_t.",
            "Create a Fortran subroutine called matrix_bits to calculate the product of two matrices and transpose one of the matrices. The subroutine has 5 input parameters: \n- an integer parameter n, representing the size of the matrices\n- two 2-dimensional array parameters a and b, both of type real, representing the matrices to be multiplied\n- two 2-dimensional array parameters c and a_t, both of type real, representing the resulting matrix and the transposed matrix respectively.\n\nThe subroutine uses nested do-loops to perform matrix multiplication and assignment operations. \n\nWrite the subroutine using the keyword \"subroutine\" and include the \"implicit none\" statement to enforce explicit variable declarations."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    real :: a(n, n), b(n, n), c(n, n), a_t(n, n)\n    integer :: i, j\n    \n    ! Test case 1\n    a = reshape([1., 2., 3., 4., 5., 6., 7., 8., 9.], [n, n])\n    b = reshape([9., 8., 7., 6., 5., 4., 3., 2., 1.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    a = reshape([1., 0., 0., 0., 1., 0., 0., 0., 1.], [n, n])\n    b = reshape([1., 2., 3., 4., 5., 6., 7., 8., 9.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    a = reshape([2., 4., 6., 8., 10., 12., 14., 16., 18.], [n, n])\n    b = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    a = reshape([1., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    b = reshape([1., 1., 1., 1., 1., 1., 1., 1., 1.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    a = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    b = reshape([0., 0., 0., 0., 0., 0., 0., 0., 0.], [n, n])\n    call matrix_bits(a, b, c, a_t, n)\n    do i = 1, n\n        do j = 1, n\n            print *, c(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \nend program main",
            "result": [
                "90.0000000    \n   54.0000000    \n   18.0000000    \n   114.000000    \n   69.0000000    \n   24.0000000    \n   138.000000    \n   84.0000000    \n   30.0000000",
                "1.00000000    \n   4.00000000    \n   7.00000000    \n   2.00000000    \n   5.00000000    \n   8.00000000    \n   3.00000000    \n   6.00000000    \n   9.00000000",
                "0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000",
                "1.00000000    \n   1.00000000    \n   1.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000",
                "0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000    \n   0.00000000"
            ]
        },
        "code": "    subroutine matrix_bits(a, b, c, a_t, n)\n        implicit none\n\n        integer, intent(in) :: n\n        real, dimension(:,:), intent(in) :: a, b\n        real, dimension(:,:), intent(out) :: c, a_t\n        integer :: i, j, k\n\n        do i = 1, n\n            do j = 1, n\n                c(i,j) = 0.\n                do k = 1, n\n                    c(i,j) = c(i,j)+a(i,k)*b(k,j)\n                end do\n            end do\n        end do\n\n        do i = 1, n\n            do j = 1, n\n                a_t(i,j) = a(j,i)\n            end do\n        end do\n    end subroutine\n",
        "answer": "subroutine matrix_multiply(n, a, b, c, d)\n    integer, intent(in) :: n\n    real, dimension(n,n), intent(in) :: a, b\n    real, dimension(n,n), intent(out) :: c, d\n    integer :: i, j, k\n\n    do i = 1, n\n        do j = 1, n\n            c(i,j) = 0.0\n            do k = 1, n\n                c(i,j) = c(i,j) + a(i,k) * b(k,j)\n            end do\n        end do\n    end do\n\n    do i = 1, n\n        do j = 1, n\n            d(i,j) = 0.0\n            do k = 1, n\n                d(i,j) = d(i,j) + a(i,k) * b(j,k)\n            end do\n        end do\n    end do\n\nend subroutine matrix_multiply\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called bessj that calculates the regular Bessel functions of the first kind and their derivatives. This subroutine takes in four input parameters. The first parameter, x, is of type real(8) and represents the argument of the Bessel functions. The second parameter, nl, is of type integer and represents the maximum index of the Bessel functions. The third parameter, rj, is an array of type real(8) and represents the regular Bessel functions. The fourth parameter, rjp, is also an array of type real(8) and represents the derivatives of the Bessel functions. The subroutine does not return any values.\n\nThe subroutine uses Steed's method to compute the Bessel functions. It initializes necessary variables and performs downward recurrence to calculate the Bessel functions and their derivatives. The subroutine also handles special cases and performs necessary scaling.",
            "Give me a Fortran subroutine code called bessj to compute the regular Bessel functions of the first kind and their derivatives. The subroutine takes 4 input parameters: a real number x, an integer nl, and two arrays rj and rjp. The nl parameter specifies the number of Bessel functions to be computed. The subroutine also has 2 output parameters: the arrays rj and rjp, which store the computed Bessel functions and their derivatives, respectively.",
            "Give me a Fortran subroutine code called bessj to compute the regular Bessel functions of the first kind and their derivatives. The subroutine takes 4 input parameters: x (real), nl (integer), rj (real array) and rjp (real array). The number of output parameters is 2: rj (real array) and rjp (real array)."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: x, result1(10), result2(10)\n    integer :: nl\n    ! Test case 1\n    x = 2.0\n    nl = 5\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n\n    ! Test case 2\n    x = 0.5\n    nl = 3\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 7.0\n    nl = 7\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 3.0\n    nl = 2\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\n    print *, \"&\"\n    \n    ! Test case 5\n    x = 1.0\n    nl = 4\n    call bessj(x, nl, result1, result2)\n    print *, result1\n    print *, result2\nend program main",
            "result": [
                "0.51301613656182732       0.49129377868716195       0.22392453146891558        6.8517549985127019E-002   1.5886893479028968E-002   2.9734706705033293E-003   0.0000000000000000        0.0000000000000000        6.9533384425872239E-310   2.0731943105538720E-317\n -0.36303974454670512       0.14454580254645585       0.21138811435101748       0.10401881899494331        3.2772039657311847E-002   7.7098491351448141E-003   1.1996396089095807E-316   3.9525251667299724E-323   0.0000000000000000        2.3635306506143582E-310",
                "0.54097378993452805        9.1701699625651306E-002   9.2364078193797258E-003   6.6237856814594265E-004   1.5886893479028968E-002   2.9734706705033293E-003   0.0000000000000000        0.0000000000000000        6.9533384425872239E-310   2.0731943105538720E-317\n  0.44927209030887671       0.26586869105757416        4.5519660528752684E-002   4.5997578423581280E-003   3.2772039657311847E-002   7.7098491351448141E-003   1.1996396089095807E-316   3.9525251667299724E-323   0.0000000000000000        2.3635306506143582E-310",
                "0.19812877407634455      -0.19905171329249380      -0.28343665120169914       -3.4030375658628542E-003  0.28003361363583623       0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n  0.21320376858366130       0.24078271263902185       -9.7824337863315472E-002 -0.28173513241876769      -0.18342464633175762       -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310",
                "6.5008182877375587E-002  0.47771821508709156       0.41271003220971592       -3.4030375658628542E-003  0.28003361363583623       0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n -0.46688351794086230      -0.17385092466617016       0.13379318824566167      -0.28173513241876769      -0.18342464633175762       -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310",
                "0.67139670714180288       0.24029783912342695        4.9496810228477933E-002   7.1862120189627003E-003   8.0667390426096075E-004  0.36344625509765238       0.29109621580333189       0.17716100282282113        6.9533384425872239E-310   2.0731943105538720E-317\n   9.5400514447474494E-002  0.31094994845666246       0.11655581355223213        2.4345068162108487E-002   3.5561794497883767E-003  -5.5313010837478305E-003   9.3142626137415613E-002  0.10128085563602357        0.0000000000000000        2.3635306506143582E-310"
            ]
        },
        "code": "subroutine bessj(x,nl,rj,rjp)\n  !returns the regular bessel functions of first kind\n  !$\\texttt{rj(l)}=j_{l-\\frac{1}{2}}$ and their derivatives\n  !$\\texttt{rjp(l)}=j'_{l-\\frac{1}{2}}$, for positive \\texttt{x} and for\n  !$1\\le l \\le nl+1$, using steed's method.\n  implicit none\n  real(8), intent(in) :: x\n  integer, intent(in) :: nl\n  real(8), intent(out) :: rj(*)            \n  real(8), intent(out) :: rjp(*)            \n  !    \n  integer :: i, isign, l \n  real(8) :: xnu, b, c, d, del, f, fact, gam, h, p, q, rjl, rjl1, rjmu, rjp1, rjpl, rjtemp, w, xi, xi2, xmu, xmu2\n  integer, parameter :: maxit=10000\n  real(8), parameter :: eps=1.e-16\n  real(8), parameter :: fpmin=1.e-30\n  real(8), parameter :: pi=3.141592653589793d+0\n\n  if(x.le.0..or.nl.lt.0) stop 'bad arguments in bessj'\n  xnu=dble(nl)+0.5d0\n  xmu=0.5d0\n  xmu2=xmu*xmu\n  xi=1.d0/x\n  xi2=2.d0*xi\n  !     the wronskian\n  w=xi2/pi\n  !     evaluate the continued fraction expansion for j'_(nl-1/2)/j_(nl-1/2)\n  !     by the modified lentz's method. isign keeps track of sign changes in\n  !     the denominator\n  isign=1\n  h=xnu*xi\n  if(h.lt.fpmin)h=fpmin\n  b=xi2*xnu\n  d=0.d0\n  c=h\n  do i=1,maxit\n     b=b+xi2\n     d=b-d\n     if(abs(d).lt.fpmin) d=fpmin\n     c=b-1.d0/c\n     if(abs(c).lt.fpmin) c=fpmin\n     d=1.d0/d\n     del=c*d\n     h=del*h\n     if(d.lt.0.d0) isign=-isign\n     if(abs(del-1.d0).lt.eps) goto 1\n  enddo\n!11   continue\n  stop 'x too large in bessjy; try asymptotic expansion'\n1 continue\n  !     initialize j and j' for downward recurrence\n  rjl=isign*fpmin\n  rjpl=h*rjl\n  !     store values for later rescaling      \n  rjl1=rjl\n  rjp1=rjpl\n  !     downward recurrence (unnormalized)\n  fact=xnu*xi\n  do l=nl,0,-1\n     rjtemp=fact*rjl+rjpl\n     fact=fact-xi\n     rjpl=fact*rjtemp-rjl\n     rjl=rjtemp\n  enddo\n  if(rjl.eq.0.d0)rjl=eps\n  f=rjpl/rjl\n  !     equation 6.7.3 numerical recipies in fortran\n  p=-.5d0*xi\n  q=1.d0\n  !     equation 6.7.6 numerical recipies in fortran\n  gam=(p-f)/q\n  !     equation 6.7.7 numerical recipies in fortran\n  rjmu=sqrt(w/((p-f)*gam+q))\n  rjmu=sign(rjmu,rjl)\n  !     scale original j and j'\n  fact=rjmu/rjl\n  rj(nl+1)=rjl1*fact\n  rjp(nl+1)=rjp1*fact\n  fact=xnu*xi\n  !     downward recurence\n  do l=nl,1,-1\n     rj(l)=fact*rj(l+1)+rjp(l+1)\n     fact=fact-xi\n     rjp(l)=fact*rj(l)-rj(l+1)\n  enddo ! l\nend subroutine bessj\n",
        "answer": "subroutine bessj(x, nl, rj, rjp)\n    implicit none\n    real(8), intent(in) :: x\n    integer, intent(in) :: nl\n    real(8), dimension(0:nl) :: rj, rjp\n    real(8) :: ax, xx, j, jp, jpp\n    integer :: n, m\n\n    ax = abs(x)\n    if (ax .lt. 1.0d-10) then\n        rj(0) = 1.0d0\n        rj(1) = x\n        rjp(0) = 0.0d0\n        rjp(1) = 1.0d0\n    else\n        rj(0) = 1.0d0\n        rj(1) = x * rj(0)\n        rjp(0) = 0.0d0\n        rjp(1) = rj(1) + log(ax) * rj(0)\n    end if\n\n    do n = 2, nl\n        rj(n) = (2*n-1)/ax * rj(n-1) - rj(n-2)\n        rjp(n) = (2*n-1)/ax * rjp(n-1) + rj(n) - (n-1)/ax * rjp(n-2)\n    end do\n\n    if (ax .lt. 1.0d-10) then\n        do n = 0, nl\n            rj(n) = rj(n) * exp(-x)\n            rjp(n) = rjp(n) * exp(-x)\n        end do\n    end if\n\nend subroutine bessj\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called `ostokesletp` that calculates the complex potential `p` for a given point in a 2D space. The subroutine takes 5 input parameters: `zk` (complex), `src` (real array of size 2), `targ` (real array of size 2), `mu` (complex array of size 2), and `p` (complex). The subroutine also has no output parameters.\n\nTo calculate `p`, the subroutine first calculates the difference between the x-coordinates and y-coordinates of `targ` and `src` respectively, storing them in `rx` and `ry`. It then calculates the square of the distance between `targ` and `src` and stores it in `r2`. Next, using the calculated values, it computes the complex potential `p` using the formula `(-rx*mu(1)-ry*mu(2))/(r2*pi2)`, where `pi2` is a constant value. Finally, the subroutine returns from the subroutine.\n\nPlease note that the subroutine uses the `implicit none` statement to enforce explicit variable declarations.",
            "Create a Fortran subroutine named \"ostokesletp\" that calculates the point source contribution to the Stokeslet in a 2D problem. The subroutine takes six parameters: \n- zk, a complex number representing the complex frequency \n- src, a 2-element real array representing the coordinates of the source point \n- targ, a 2-element real array representing the coordinates of the target point \n- mu, a complex 2-element array representing the viscosity \n- p, a complex number representing the output Stokeslet \nThe subroutine uses the implicit none statement to specify that all variables must be declared explicitly. Inside the subroutine, the local variables rx, ry, r2, and pi2 are declared as real numbers. The subroutine computes the distance between the target and source points, and then calculates the Stokeslet using the given formulas. Finally, the subroutine returns the computed value of the Stokeslet.",
            "Write a Fortran subroutine called \"ostokesletp\" to calculate the Stokeslet potential. The subroutine takes in 3 input parameters: a complex number \"zk\", an array \"src\" of two real numbers, and an array \"targ\" of two real numbers. It also takes in an array \"mu\" of two complex numbers as input. The subroutine has one output parameter \"p\" which is a complex number."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: zk, mu(2), p\n    real*8 :: src(2), targ(2)\n    \n    ! Test case 1\n    zk = cmplx(1.0, 2.0)\n    mu(1) = cmplx(0.5, 0.0)\n    mu(2) = cmplx(0.0, -0.5)\n    src(1) = 1.5\n    src(2) = 2.5\n    targ(1) = 3.0\n    targ(2) = 4.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n\n    ! Test case 2\n    zk = cmplx(-2.0, 1.0)\n    mu(1) = cmplx(0.0, 0.5)\n    mu(2) = cmplx(-0.5, 0.0)\n    src(1) = -1.0\n    src(2) = 3.2\n    targ(1) = 2.8\n    targ(2) = -4.7\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 3\n    zk = cmplx(3.0, -2.0)\n    mu(1) = cmplx(1.0, 0.0)\n    mu(2) = cmplx(0.0, 1.0)\n    src(1) = 0.0\n    src(2) = 0.0\n    targ(1) = 1.0\n    targ(2) = 1.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 4\n    zk = cmplx(0.5, 0.5)\n    mu(1) = cmplx(0.0, -1.0)\n    mu(2) = cmplx(-1.0, 0.0)\n    src(1) = -3.0\n    src(2) = 2.5\n    targ(1) = 1.2\n    targ(2) = -0.8\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 5\n    zk = cmplx(2.0, 0.0)\n    mu(1) = cmplx(0.0, 0.0)\n    mu(2) = cmplx(0.0, 0.0)\n    src(1) = -1.0\n    src(2) = 0.0\n    targ(1) = 1.0\n    targ(2) = 0.0\n    call ostokesletp(zk, src, targ, mu, p)\n    print *, p\n    print *, \"&\"\n    \nend program main",
            "result": [
                "( -2.6525823848649224E-002,  2.6525823848649224E-002)",
                "( -8.1803778176087489E-003, -3.9348653012315736E-003)",
                "( -7.9577471545947673E-002, -7.9577471545947673E-002)",
                "( -1.8409088863599758E-002,  2.3429749644129808E-002)",
                "( -0.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "subroutine ostokesletp(zk,src,targ, &\n     mu,p)\n\n  implicit none\n  ! global \n  complex *16, intent(in) :: zk, mu(2)\n  real *8, intent(in) :: src(2), targ(2)\n  complex *16, intent(out) :: p\n  ! local\n  real *8 rx, ry, r2, pi2\n\n  pi2 = 8.0d0*datan(1.0d0)\n  \n\n  rx = targ(1)-src(1)\n  ry = targ(2)-src(2)\n\n  r2 = rx**2 + ry**2\n\n  p = (-rx*mu(1)-ry*mu(2))/(r2*pi2)\n\n  return\nend subroutine ostokesletp\n",
        "answer": "subroutine ostokesletp(zk,src,targ,mu,p)\n    implicit none\n    complex(8), intent(in) :: zk\n    real(8), intent(in) :: src(2),targ(2)\n    complex(8), intent(in) :: mu(2)\n    complex(8) :: p\n    real(8) :: rx,ry,r2\n    real(8), parameter :: pi2=6.2831853071795864769252867665590057683943387987d0\n\n    rx=targ(1)-src(1)\n    ry=targ(2)-src(2)\n    r2=rx**2+ry**2\n    p=(-rx*mu(1)-ry*mu(2))/(r2*pi2)\n    return\nend subroutine ostokesletp\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called `ostokesletpvec` that calculates the vector components of a Stokeslet influence function for a given complex number `zk`, source coordinates `src`, and target coordinates `targ`. The subroutine takes three input parameters: `zk` of type complex, `src` of type real array with size 2, and `targ` of type real array with size 2. It also has one output parameter `pvec` of type complex array with size 2. \n\nTo compute the vector components, the subroutine calculates the difference between the target and source coordinates `rx` and `ry`, then computes the square of their magnitudes `r2`. Finally, it computes the vector components of the influence function `pvec` using the formula `-rx/(r2*pi2)` for the first component and `-ry/(r2*pi2)` for the second component.\n\nRemember to use the `implicit none` statement to enforce explicit declaration of variables.",
            "Write a Fortran subroutine called \"ostokesletpvec\" that calculates the potential vector for the Oseen Stokes equation. This subroutine requires four parameters as inputs: a complex number \"zk\", an array of real numbers \"src\" with two elements representing the source coordinates, and an array of real numbers \"targ\" with two elements representing the target coordinates. The subroutine also has an output parameter, an array of complex numbers \"pvec\" with two elements, which will store the calculated potential vector.",
            "Write a Fortran subroutine called \"ostokesletpvec\" that computes the partial vector due to a Stokeslet. The subroutine takes 4 input parameters: a complex number \"zk\", an array of real numbers \"src\" containing the coordinates of the source point, an array of real numbers \"targ\" containing the coordinates of the target point, and an output array of complex numbers \"pvec\" to store the computed partial vector. The subroutine calculates the partial vector by performing mathematical computations using the input parameters. The subroutine should be implemented using the Fortran programming language and follows the Fortran subroutine syntax."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    complex*16 :: complex_num, pvec(2)\n    real*8 :: src(2), targ(2)\n    \n    ! Test case 1\n    complex_num = (1.0, 2.0)\n    src = [0.0, 0.0]\n    targ = [1.0, 1.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n\n    ! Test case 2\n    complex_num = (2.0, -3.0)\n    src = [1.0, 2.0]\n    targ = [3.0, 4.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    complex_num = (0.5, 0.5)\n    src = [2.0, 3.0]\n    targ = [4.0, 5.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    complex_num = (4.0, 0.0)\n    src = [0.0, 0.0]\n    targ = [1.0, 1.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    complex_num = (1.0, 1.0)\n    src = [1.0, 2.0]\n    targ = [3.0, 4.0]\n    call ostokesletpvec(complex_num, src, targ, pvec)\n    print *, pvec(1), pvec(2)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "( -7.9577471545947673E-002,  0.0000000000000000     ) ( -7.9577471545947673E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )",
                "( -7.9577471545947673E-002,  0.0000000000000000     ) ( -7.9577471545947673E-002,  0.0000000000000000     )",
                "( -3.9788735772973836E-002,  0.0000000000000000     ) ( -3.9788735772973836E-002,  0.0000000000000000     )"
            ]
        },
        "code": "subroutine ostokesletpvec(zk,src,targ, &\n     pvec)\n\n  implicit none\n  ! global \n  complex *16, intent(in) :: zk\n  real *8, intent(in) :: src(2), targ(2)\n  complex *16, intent(out) :: pvec(2)\n  ! local\n  real *8 rx, ry, r2, pi2\n\n  pi2 = 8.0d0*datan(1.0d0)\n  \n\n  rx = targ(1)-src(1)\n  ry = targ(2)-src(2)\n\n  r2 = rx**2 + ry**2\n\n  pvec(1) = -rx/(r2*pi2)\n  pvec(2) = -ry/(r2*pi2)\n\n  return\nend subroutine ostokesletpvec\n",
        "answer": "subroutine ostokesletpvec(zk, src, targ, pvec)\n    implicit none\n    complex(8), intent(in) :: zk\n    real(8), intent(in) :: src(2), targ(2)\n    complex(8), intent(out) :: pvec(2)\n    real(8) :: rx, ry, r2\n\n    rx = targ(1) - src(1)\n    ry = targ(2) - src(2)\n    r2 = rx**2 + ry**2\n\n    pvec(1) = -rx/(r2*2*pi)\n    pvec(2) = -ry/(r2*2*pi)\nend subroutine ostokesletpvec\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called find_next_smallest_location that finds the smallest value in an array and returns its location. The subroutine takes in three parameters: lengths, which is an integer array representing the values to search for the smallest; available, a logical array specifying if each element is available for selection; and location, an integer that will store the location of the smallest value. The subroutine modifies the available array by marking the smallest value as unavailable. The input arrays, lengths and available, are allocated dynamically.",
            "Provide a Fortran subroutine called find_next_smallest_location that finds the index of the smallest element in an array that is still available. The subroutine has three input parameters and no output parameter. The first input parameter is an integer array called \"lengths\". The second input parameter is a logical array called \"available\". The third input/output parameter is an integer called \"location\". \n\nTo use the subroutine, pass in the lengths of the elements, a logical array indicating which elements are available, and an initial value for the location variable. The subroutine will update the location variable with the index of the smallest available element in the lengths array. If multiple elements have the same smallest length, the subroutine will return the first occurrence. If all elements have been marked as unavailable, the location variable will not be modified.\n\nTo implement the subroutine, allocate the lengths and available arrays. Find the index of the smallest element in the lengths array using the minloc function and the available mask. If the smallest element is already marked as unavailable and all elements are marked as available, recursively call the subroutine to find the next smallest location. Finally, mark the location as unavailable in the available array.",
            "Provide a Fortran subroutine called find_next_smallest_location that finds the index of the smallest value in an array, excluding values that have already been marked as unavailable. The subroutine takes three input parameters and has no output parameters. \n\nThe first input parameter is an integer array called lengths, which represents the values to be searched. The second input parameter is a logical array called available, which indicates whether each value in the lengths array is available for selection. The third input/output parameter is an integer called location, which stores the index of the smallest available value found.\n\nInside the subroutine, the lengths array is searched using the minloc function to find the index of the smallest value that is still available. If the smallest value is found at index 1 and all values are still available, the location is updated to point to the next smallest available value. This process is repeated until all values have been marked as unavailable.\n\nRemember to use the intent(in), intent(out), and intent(inout) keywords to specify the purpose of each parameter."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, allocatable :: lengths(:)\n    logical, allocatable :: available(:)\n    integer :: location, i\n\n    ! Test case 1\n    allocate(lengths(3))\n    allocate(available(3))\n    lengths = [4, 2, 6]\n    available = [.true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 2\n    allocate(lengths(5))\n    allocate(available(5))\n    lengths = [1, 3, 2, 4, 5]\n    available = [.true., .true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 3\n    allocate(lengths(4))\n    allocate(available(4))\n    lengths = [7, 1, 3, 6]\n    available = [.true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 4\n    allocate(lengths(2))\n    allocate(available(2))\n    lengths = [2, 9]\n    available = [.true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\n    ! Test case 5\n    allocate(lengths(6))\n    allocate(available(6))\n    lengths = [5, 4, 2, 6, 3, 1]\n    available = [.true., .true., .true., .true., .true., .true.]\n    call find_next_smallest_location(lengths, available, location)\n    print *, location\n    deallocate(lengths)\n    deallocate(available)\n    print *, \"&\"\n\nend program main",
            "result": [
                "2",
                "3",
                "2",
                "2",
                "6"
            ]
        },
        "code": "   pure recursive subroutine find_next_smallest_location(lengths, available, location)\n      intent(in)    lengths\n      intent(out)   location\n      intent(inout) available\n\n      integer, allocatable :: lengths(:)\n      logical, allocatable :: available(:)\n      integer              :: location\n\n      location = minloc(lengths, dim=1, mask=available)\n\n      if (location == 1 .and. all(available)) then\n         available(location) = .false.\n         call find_next_smallest_location(lengths, available, location)\n      endif\n\n      available(location) = .false.\n   end subroutine find_next_smallest_location\n",
        "answer": "subroutine find_next_smallest_location(lengths, available, location)\n    integer, dimension(:), allocatable :: lengths\n    logical, dimension(:), allocatable :: available\n    integer :: location\n    integer :: i\n\n    ! find the smallest available value\n    do i = 1, size(lengths)\n        if (available(i)) then\n            location = i\n            exit\n        end if\n    end do\n\n    ! mark the smallest value as unavailable\n    available(location) = .false.\n\n    ! deallocate the arrays\n    deallocate(lengths)\n    deallocate(available)\nend subroutine find_next_smallest_location\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"calculate_sum\" that calculates the sum of numbers from 1 to a given value. The subroutine has 2 input parameters and 1 output parameter. The first input parameter \"n\" is an integer that represents the upper limit of the range. The second input parameter \"ret\" is an integer that will store the computed sum. The output parameter \"ret\" is also an integer that will hold the final sum.",
            "Please provide me with a Fortran subroutine code named \"calculate_sum\" that calculates the sum of numbers from 1 to a given value. The subroutine has 2 input parameters and 1 output parameter. The first input parameter is an integer named \"n\" that represents the upper limit of the summation. The second input parameter is an integer named \"ret\" which is used to store the final sum. The output parameter is an integer named \"ret\" which will contain the sum of numbers from 1 to \"n\".",
            "Provide a Fortran subroutine called compute_sum that calculates the sum of numbers from 1 to a given input value. The subroutine has 2 input parameters and 1 output parameter. The first input parameter, n, is an integer that represents the upper limit of the range. The second input parameter is an integer, and is used to pass the result of the computation back to the caller. The subroutine initializes the output parameter, ret, to zero, and then uses a do loop to iteratively add the loop variable, i, to the output parameter."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: input, output1, output2, output3, output4, output5\n    \n    ! Test case 1\n    input = 5\n    call test_do_loop_variable_trip_count(output1, input)\n    print *, output1\n    print *, \"&\"\n    \n    ! Test case 2\n    input = 10\n    call test_do_loop_variable_trip_count(output2, input)\n    print *, output2\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 20\n    call test_do_loop_variable_trip_count(output3, input)\n    print *, output3\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 3\n    call test_do_loop_variable_trip_count(output4, input)\n    print *, output4\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 0\n    call test_do_loop_variable_trip_count(output5, input)\n    print *, output5\n    print *, \"&\"\n    \nend program main",
            "result": [
                "15",
                "55",
                "210",
                "6",
                "0"
            ]
        },
        "code": "subroutine test_do_loop_variable_trip_count(ret, n)\n  integer, intent(out) :: ret\n  integer, intent(in) :: n\n  ret = 0\n  do i=1, n\n    ret = ret + i\n  end do\nend subroutine\n",
        "answer": "subroutine calculate_sum(n, ret)\n    integer, intent(in) :: n\n    integer, intent(out) :: ret\n    integer :: i, sum\n\n    sum = 0\n    do i = 1, n\n        sum = sum + i\n    end do\n\n    ret = sum\nend subroutine calculate_sum\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called \"areacal\" that calculates the area of a polygon. The subroutine takes three parameters: \"xc\" and \"yc\" are arrays of type real, representing the x and y coordinates of the vertices of the polygon respectively; \"area\" is a real variable used for storing the calculated area. The subroutine uses the formula for calculating the area of a polygon with given vertices. The number of vertices is determined by the size of the arrays \"xc\" and \"yc\". The calculated area is stored in the \"area\" variable and returned as an output.",
            "Provide a Fortran subroutine called \"areacal\" to calculate the area of a polygon. The subroutine takes in 2 input parameters and 1 output parameter. The input parameters are arrays \"xc\" and \"yc\" of type real(8) representing the x and y coordinates of the polygon's vertices. The output parameter \"area\" is also of type real(8) and stores the calculated area of the polygon. The subroutine uses an algorithm to compute the area based on the given vertices. The instruction should include the explanation of the algorithm used in the subroutine.",
            "Provide a Fortran subroutine called \"areacal\" to calculate the area of a polygon. The subroutine takes three input parameters and one output parameter. The first two input parameters are arrays of type real(8) representing the x and y coordinates of the vertices of the polygon. The third input parameter is an integer(4) representing the number of vertices. The output parameter is a real(8) representing the calculated area of the polygon. The subroutine calculates the area by iterating through the vertices and summing the areas of individual triangles formed by consecutive vertices. The instruction for the subroutine should be written in an imperative tone."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: xc(5), yc(5), area\n    ! Test case 1\n    xc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    yc = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n\n    ! Test case 2\n    xc = [0.0, 1.0, 1.0, 0.0, 0.0]\n    yc = [0.0, 0.0, 1.0, 1.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 3\n    xc = [0.0, 2.0, 4.0, 6.0, 8.0]\n    yc = [0.0, 0.0, 0.0, 0.0, 0.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 4\n    xc = [0.0, 1.0, 2.0, 2.0, 1.0]\n    yc = [0.0, 0.0, 0.0, 1.0, 1.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\n    \n    ! Test case 5\n    xc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    yc = [0.0, 1.0, 2.0, 3.0, 4.0]\n    call areacal(xc, yc, area)\n    print *, area\n    print *, \"&\"\nend program main",
            "result": [
                "0.0000000000000000",
                "1.0000000000000000",
                "0.0000000000000000",
                "1.5000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": " subroutine areacal(xc,yc,area)   \n  !area calculation of a polygon\n  !with given vextices (xc,yc)\n  real(8),intent(in) ::xc(:),yc(:)\n  real(8),intent(out)::area\n  real(8)::xvec(2),yvec(2)\n  integer(4)::npol,k\n  npol = size(xc)\n  area = 0\n  xvec(1)=xc(2)-xc(1)\n  yvec(1)=yc(2)-yc(1)\n  do k=3,npol\n    xvec(2) = xc(k)-xc(1)\n    yvec(2) = yc(k)-yc(1)\n    area = area+0.5*abs( xvec(1)*yvec(2)-xvec(2)*yvec(1))\n    xvec(1)=xvec(2)\n    yvec(1)=yvec(2)\n  enddo\n end subroutine\n",
        "answer": "subroutine areacal(xc,yc,area)\n\n    implicit none\n\n    real, dimension(:), intent(in) :: xc,yc\n    real, intent(out) :: area\n    integer :: i, j, n\n\n    n = size(xc)\n    area = 0.0\n\n    do i = 1, n\n        j = mod(i, n) + 1\n        area = area + xc(i) * yc(j) - xc(j) * yc(i)\n    end do\n\n    area = abs(area) / 2.0\n\nend subroutine areacal\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called add1 to compute the sum of two integers. The number of input parameters is 2, both of which are integers. The number of output arguments is 1, which is also an integer.",
            "Provide a Fortran subroutine called add1 that adds two integers and returns the sum. The subroutine takes 2 input parameters, both of type integer, and 1 output parameter of type integer. The name of the subroutine is add1.",
            "Create a Fortran subroutine called \"add1\" to add two integers together. The subroutine takes in 2 input parameters, both of type integer. The first input parameter is named \"x\" and the second input parameter is named \"y\". The subroutine also has 1 output parameter, named \"z\", which is also of type integer. The purpose of the subroutine is to calculate the sum of \"x\" and \"y\" and store the result in \"z\"."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: num1, num2, result\n    ! Test case 1\n    num1 = 2\n    num2 = 3\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n\n    ! Test case 2\n    num1 = -5\n    num2 = 8\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 3\n    num1 = 0\n    num2 = 0\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 4\n    num1 = 100\n    num2 = -50\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\n    \n    ! Test case 5\n    num1 = 999\n    num2 = 1\n    call add1(num1, num2, result)\n    print *, result\n    print *, \"&\"\nend program main",
            "result": [
                "5",
                "3",
                "0",
                "50",
                "1000"
            ]
        },
        "code": "subroutine add1(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + y\nend subroutine\n",
        "answer": "subroutine add1(a, b, c)\n    implicit none\n    integer, intent(in) :: a, b\n    integer, intent(out) :: c\n\n    c = a + b\nend subroutine add1\n\n"
    },
    {
        "instruction": [
            "Please create a Fortran subroutine called rotate_euler_3d_inv to perform inverse 3D Euler angle rotation. The subroutine takes six input parameters and three output parameters, all of type double precision. The input parameters are alpha, beta, gamma, srcx, srcy, and srcz. The output parameters are destx, desty, and destz.\n\nTo calculate the inverse rotation, use the following equations:\n- destx = srcz * sin(beta) * sin(gamma) + srcy * (cos(gamma) * sin(alpha) + cos(alpha) * cos(beta) * sin(gamma)) + srcx * (cos(alpha) * cos(gamma) - cos(beta) * sin(alpha) * sin(gamma))\n- desty = srcz * cos(gamma) * sin(beta) + srcx * (-(cos(beta) * cos(gamma) * sin(alpha)) - cos(alpha) * sin(gamma)) + srcy * (cos(alpha) * cos(beta) * cos(gamma) - sin(alpha) * sin(gamma))\n- destz = srcz * cos(beta) - srcy * cos(alpha) * sin(beta) + srcx * sin(alpha) * sin(beta)\n\nUse the provided equations to assign the computed values to the output parameters destx, desty, and destz.",
            "Write a Fortran subroutine called rotate_euler_3d_inv to calculate the inverse rotation of a 3D vector using Euler angles. The subroutine takes in six input parameters, all of type double precision. The first three parameters are the Euler angles alpha, beta, and gamma. The next three parameters are the components of the source vector srcx, srcy, and srcz. The subroutine has three output parameters, also of type double precision, which are the components of the destination vector destx, desty, and destz. The subroutine uses trigonometric functions, such as dsin and dcos, to perform the calculations.",
            "Provide a Fortran subroutine code called rotate_euler_3d_inv to perform inverse Euler angle rotation in 3D space. The subroutine takes in six input parameters and three output parameters, all of type double precision. The input parameters are alpha, beta, gamma, srcx, srcy, and srcz, representing the Euler angles and the coordinates of a point in 3D space. The output parameters are destx, desty, and destz, representing the rotated coordinates of the point. The subroutine uses the sine and cosine functions (dsin and dcos) to perform the rotation calculations."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz\n    ! Test case 1\n    alpha = 0.0\n    beta = 0.0\n    gamma = 0.0\n    srcx = 1.0\n    srcy = 2.0\n    srcz = 3.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n\n    ! Test case 2\n    alpha = 1.0\n    beta = 1.0\n    gamma = 1.0\n    srcx = 2.0\n    srcy = 3.0\n    srcz = 4.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 3\n    alpha = 2.0\n    beta = 0.5\n    gamma = 1.5\n    srcx = 3.0\n    srcy = 4.0\n    srcz = 5.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 4\n    alpha = 1.5\n    beta = 0.0\n    gamma = 0.5\n    srcx = 4.0\n    srcy = 5.0\n    srcz = 6.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\n    \n    ! Test case 5\n    alpha = 0.5\n    beta = 1.0\n    gamma = 1.0\n    srcx = 5.0\n    srcy = 6.0\n    srcz = 7.0\n    call rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    print *, destx, desty, destz\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        2.0000000000000000        3.0000000000000000",
                "4.7518888202021952       -1.2330325086759331        2.2134099197811787",
                "-1.2850109997883696       -2.4858744286429353        6.4937797202740146",
                "2.8818997879398394       -5.7179238900384384        6.0000000000000000",
                "10.185621355353463       -2.0929436283318799        1.3684679660088808"
            ]
        },
        "code": "subroutine rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(beta)*dsin(gamma) + srcy*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = srcz*dcos(gamma)*dsin(beta) + srcx*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) - srcy*dcos(alpha)*dsin(beta) + srcx*dsin(alpha)*dsin(beta)\n\nend subroutine\n",
        "answer": "subroutine rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n    double precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n    double precision, intent(out) :: destx, desty, destz\n\n    destx = srcz * sin(beta) * sin(gamma) + srcy * (cos(gamma) * sin(alpha) + cos(alpha) * cos(beta) * sin(gamma)) + srcx * (cos(alpha) * cos(gamma) - cos(beta) * sin(alpha) * sin(gamma))\n    desty = srcz * cos(gamma) * sin(beta) + srcx * (-(cos(beta) * cos(gamma) * sin(alpha)) - cos(alpha) * sin(gamma)) + srcy * (cos(alpha) * cos(beta) * cos(gamma) - sin(alpha) * sin(gamma))\n    destz = srcz * cos(beta) - srcy * cos(alpha) * sin(beta) + srcx * sin(alpha) * sin(beta)\n\nend subroutine rotate_euler_3d_inv\n\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called \"circumcircle\" that calculates the center coordinates and radius of a circle that circumscribes three points in a 2D plane. The subroutine takes six input parameters: p1, p2, and p3 are arrays of size 2, containing the x and y coordinates of each point. The output parameters are x0, y0, and r, all of type double precision. \n\nTo calculate the circumcircle, the subroutine first checks if the three points lie on a straight line. If they do, the radius is set to -1 to indicate that the points do not form a circle. If the points are not collinear, the subroutine proceeds to compute the center coordinates and radius of the circumcircle using mathematical formulas.\n\nThe subroutine uses double precision variables for increased numerical precision.",
            "Please create a Fortran subroutine called \"circumcircle\" to calculate the circumcircle of a triangle. The subroutine has 6 input parameters and 3 output parameters. The input parameters are three 2-dimensional arrays of type double precision representing the coordinates of the three vertices of the triangle: p1, p2, and p3. The output parameters are three double precision variables: x0, y0, and r, representing the coordinates of the center of the circumcircle and its radius, respectively. The subroutine calculates the center and radius of the circumcircle using mathematical formulas.",
            "Provide a Fortran subroutine called circumcircle that calculates the circumcircle of a triangle. The subroutine has 3 input parameters, all of type double precision, which are the coordinates of three points that form a triangle. The subroutine also has 3 output parameters, x0, y0, and r, of type double precision, which represent the coordinates of the center of the circumcircle and its radius, respectively. \n\nTo compute the circumcircle, the subroutine first checks if the points lie on a circle by evaluating the determinant of the triangle. If the determinant is close to zero, indicating that the points are collinear, a negative radius is returned. Otherwise, the subroutine calculates the center and radius of the circumcircle using formulas based on the coordinates of the triangle points. \n\nMake sure to call this subroutine with the appropriate input parameters to compute the circumcircle of a triangle."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: p1(2), p2(2), p3(2), x0, y0, r\n    ! Test case 1\n    p1 = [0.0, 0.0]\n    p2 = [1.0, 0.0]\n    p3 = [0.0, 1.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n\n    ! Test case 2\n    p1 = [2.0, 3.0]\n    p2 = [4.0, 5.0]\n    p3 = [6.0, 7.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 3\n    p1 = [1.0, 1.0]\n    p2 = [2.0, 3.0]\n    p3 = [4.0, 2.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 4\n    p1 = [0.0, 0.0]\n    p2 = [1.0, 1.0]\n    p3 = [2.0, 2.0]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\n    \n    ! Test case 5\n    p1 = [0.5, 0.5]\n    p2 = [1.0, 1.0]\n    p3 = [1.5, 1.5]\n    call circumcircle(p1, p2, p3, x0, y0, r)\n    print *, x0, y0, r\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000       0.50000000000000000       0.70710678118654757",
                "0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "2.5000000000000000        1.5000000000000000        1.5811388300841898",
                "2.5000000000000000        1.5000000000000000       -1.0000000000000000",
                "2.5000000000000000        1.5000000000000000       -1.0000000000000000"
            ]
        },
        "code": "  subroutine circumcircle(p1, p2, p3, x0, y0, r)\n\n    implicit none\n\n    double precision, dimension(2), intent(in)  :: p1, p2, p3\n    double precision,               intent(out) :: x0, y0, r\n\n    double precision :: xy1, xy2, xy3, d21, d31, d32, dx, dy\n    double precision :: f\n\n    f  = p1(2)*(p3(1)-p2(1)) + p2(2)*(p1(1)-p3(1)) + p3(2)*(p2(1)-p1(1))\n    if (abs(f) <= 1.0d-15) then\n       ! the points don't lie on a circle (since they are all on one line)\n       ! --> return negative radius\n       r = -1.0d0\n       return\n    end if\n\n    f  = 0.5d0 / f\n\n    xy1 = p1(1)*p1(1) + p1(2)*p1(2)\n    xy2 = p2(1)*p2(1) + p2(2)*p2(2)\n    xy3 = p3(1)*p3(1) + p3(2)*p3(2)\n\n    d21 = xy2 - xy1\n    d31 = xy3 - xy1\n    d32 = xy3 - xy2\n\n    x0 =  f*(p1(2)*d32 - p2(2)*d31 + p3(2)*d21)\n    y0 = -f*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21)\n\n    dx = p1(1) - x0\n    dy = p1(2) - y0\n    r  = sqrt(dx*dx + dy*dy)\n\n  end subroutine circumcircle\n",
        "answer": "subroutine circumcircle(p1, p2, p3, x0, y0, r)\n    double precision, intent(in) :: p1(2), p2(2), p3(2)\n    double precision, intent(out) :: x0, y0, r\n    double precision :: a, b, c, d, e, f\n\n    if (all(p1 == p2) .or. all(p2 == p3) .or. all(p3 == p1)) then\n        r = -1\n        return\n    end if\n\n    a = p2(1) - p1(1)\n    b = p2(2) - p1(2)\n    c = p3(1) - p1(1)\n    d = p3(2) - p1(2)\n    e = a * (p1(1) + p2(1)) + b * (p1(2) + p2(2))\n    f = c * (p1(1) + p3(1)) + d * (p1(2) + p3(2))\n    x0 = 0.5d0 * (d * e - b * f) / (a * d - b * c)\n    y0 = 0.5d0 * (a * f - c * e) / (a * d - b * c)\n    r = sqrt((x0 - p1(1))**2 + (y0 - p1(2))**2)\nend subroutine circumcircle\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called \"circumsphere\" to calculate the center and radius of the circumsphere of a tetrahedron. The subroutine has 7 input parameters and 4 output parameters. The input parameters are all of type double precision and represent the coordinates of the four points of the tetrahedron (p1, p2, p3, p4). The output parameters (x0, y0, z0, r) are also of type double precision and represent the center coordinates (x0, y0, z0) and the radius (r) of the circumsphere.",
            "Please provide a Fortran subroutine code named \"circumsphere\" to calculate the center and radius of a circumscribed sphere for a given set of four 3D points. The subroutine takes 4 input parameters of type double precision, each representing the coordinates of a point in 3D space. The subroutine also has 4 output parameters of type double precision, which represent the x, y, and z coordinates of the center of the circumscribed sphere, as well as the radius of the sphere. The generated instructions should be written in an imperative tone.",
            "Provide a Fortran subroutine called \"circumsphere\" to calculate the center and radius of a circumsphere given four points in 3D space. The subroutine has six input parameters and four output parameters. The input parameters are all of type double precision and include four 3D points (p1, p2, p3, p4). The output parameters are also of type double precision and include the coordinates of the center of the circumsphere (x0, y0, z0) and the radius (r). \n\nTo summarize, the \"circumsphere\" subroutine takes in four 3D points and calculates the center and radius of the circumsphere that encompasses these points. The input parameters are four 3D points of type double precision, and the output parameters are the coordinates of the center and the radius of the circumsphere, also of type double precision."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    double precision :: p1(3), p2(3), p3(3), p4(3), x0, y0, z0, r\n\n    ! Test case 1\n    p1 = [1.0, 1.0, 1.0]\n    p2 = [2.0, 2.0, 2.0]\n    p3 = [3.0, 3.0, 3.0]\n    p4 = [4.0, 4.0, 4.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 2\n    p1 = [0.0, 0.0, 0.0]\n    p2 = [1.0, 0.0, 0.0]\n    p3 = [0.0, 1.0, 0.0]\n    p4 = [0.0, 0.0, 1.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 3\n    p1 = [1.0, 2.0, 3.0]\n    p2 = [4.0, 5.0, 6.0]\n    p3 = [7.0, 8.0, 9.0]\n    p4 = [10.0, 11.0, 12.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 4\n    p1 = [2.0, 2.0, 2.0]\n    p2 = [4.0, 4.0, 4.0]\n    p3 = [6.0, 6.0, 6.0]\n    p4 = [8.0, 8.0, 8.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\n\n    ! Test case 5\n    p1 = [0.0, 0.0, 0.0]\n    p2 = [1.0, 1.0, 0.0]\n    p3 = [1.0, 0.0, 1.0]\n    p4 = [0.0, 1.0, 1.0]\n    call circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    print *, x0, y0, z0, r\n    print *, \"&\"\nend program main",
            "result": [
                "9.3872472709836843E-323   2.3554754163633613E-310   0.0000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       0.86602540378443860",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       -1.0000000000000000",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       0.86602540378443860"
            ]
        },
        "code": "  subroutine circumsphere(p1,p2,p3,p4,x0,y0,z0,r)\n\n    implicit none\n\n    double precision, dimension(3), intent(in)  :: p1, p2, p3, p4\n    double precision,               intent(out) :: x0, y0, z0, r\n\n    double precision :: xyz1, xyz2, xyz3, xyz4\n    double precision :: d21, d31, d41, d32, d42, d43\n    double precision :: dx, dy, dz\n    double precision :: f\n\n    f = p1(3)*(p2(2)*(p4(1)-p3(1)) - p3(2)*(p4(1)-p2(1)) + p4(2)*(p3(1)-p2(1))) &\n      - p2(3)*(p1(2)*(p4(1)-p3(1)) - p3(2)*(p4(1)-p1(1)) + p4(2)*(p3(1)-p1(1))) &\n      + p3(3)*(p1(2)*(p4(1)-p2(1)) - p2(2)*(p4(1)-p1(1)) + p4(2)*(p2(1)-p1(1))) &\n      - p4(3)*(p1(2)*(p3(1)-p2(1)) - p2(2)*(p3(1)-p1(1)) + p3(2)*(p2(1)-p1(1)))\n\n    if (abs(f) <= 1.0d-15) then\n       ! the points don't lie on a circle (since they are all on one line)\n       ! --> return negative radius\n       r = -1.0d0\n       return\n    end if\n\n    f = 0.5d0 / f\n\n    xyz1 = p1(1)*p1(1) + p1(2)*p1(2) + p1(3)*p1(3)\n    xyz2 = p2(1)*p2(1) + p2(2)*p2(2) + p2(3)*p2(3)\n    xyz3 = p3(1)*p3(1) + p3(2)*p3(2) + p3(3)*p3(3)\n    xyz4 = p4(1)*p4(1) + p4(2)*p4(2) + p4(3)*p4(3)\n\n    d21  = xyz2 - xyz1\n    d31  = xyz3 - xyz1\n    d41  = xyz4 - xyz1\n    d32  = xyz3 - xyz2\n    d42  = xyz4 - xyz2\n    d43  = xyz4 - xyz3\n\n    x0   =  f*( p1(3)*(p2(2)*d43 - p3(2)*d42 + p4(2)*d32) &\n              - p2(3)*(p1(2)*d43 - p3(2)*d41 + p4(2)*d31) &\n              + p3(3)*(p1(2)*d42 - p2(2)*d41 + p4(2)*d21) &\n              - p4(3)*(p1(2)*d32 - p2(2)*d31 + p3(2)*d21) )\n\n    y0   = -f*( p1(3)*(p2(1)*d43 - p3(1)*d42 + p4(1)*d32) &\n              - p2(3)*(p1(1)*d43 - p3(1)*d41 + p4(1)*d31) &\n              + p3(3)*(p1(1)*d42 - p2(1)*d41 + p4(1)*d21) &\n              - p4(3)*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21) )\n\n    z0   =  f*( p1(2)*(p2(1)*d43 - p3(1)*d42 + p4(1)*d32) &\n              - p2(2)*(p1(1)*d43 - p3(1)*d41 + p4(1)*d31) &\n              + p3(2)*(p1(1)*d42 - p2(1)*d41 + p4(1)*d21) &\n              - p4(2)*(p1(1)*d32 - p2(1)*d31 + p3(1)*d21) )\n\n    dx = p1(1) - x0\n    dy = p1(2) - y0\n    dz = p1(3) - z0\n    r = sqrt(dx*dx + dy*dy + dz*dz)\n\n  end subroutine circumsphere\n",
        "answer": "subroutine circumsphere(p1, p2, p3, p4, x0, y0, z0, r)\n    double precision, intent(in) :: p1(3), p2(3), p3(3), p4(3)\n    double precision, intent(out) :: x0, y0, z0, r\n    double precision :: a(3), b(3), c(3), d(3), e(3), f(3), g(3), h(3), i(3), j(3)\n\n    a = p2 - p1\n    b = p3 - p1\n    c = p4 - p1\n    d = p2 - p3\n    e = p3 - p4\n    f = p4 - p2\n    g = matmul(a, b)\n    h = matmul(b, c)\n    i = matmul(c, a)\n    j = matmul(d, e)\n    k = matmul(e, f)\n    l = matmul(f, d)\n    m = matmul(a, matmul(b, c))\n    n = matmul(b, matmul(c, a))\n    o = matmul(c, matmul(a, b))\n\n    x0 = (n - o) / (2.0d0 * m)\n    y0 = (l - k) / (2.0d0 * h)\n    z0 = (j - i) / (2.0d0 * g)\n    r = sqrt(x0**2 + y0**2 + z0**2)\nend subroutine circumsphere\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called ell_cov_2d to calculate the lower triangular matrix for three ellipses in a 2D space. The subroutine takes three input parameters and one output parameter. The first input parameter is an array of size 2 containing the coordinates of a point, with a type of real. The second input parameter is an integer representing the ellipse to be computed. The third input parameter is a 2x2 lower triangular matrix of type real, which will be updated with the computed values. The subroutine does not return any value.",
            "Provide a Fortran subroutine called ell_cov_2d to calculate the lower triangular matrix l for a given point p in a 2D space. The subroutine takes three input parameters: p, an array of two real numbers representing the point; k_ell, an integer indicating the type of ellipse to compute; and l, a 2x2 matrix of real numbers to store the result. The subroutine also has no output parameters.\n\nHere's how to use the subroutine:\n1. Pass the point p, where |p| < 1 and |p_1| > 0.\n2. Choose the type of ellipse to compute by setting k_ell. It can be 1, 2, or 3.\n3. Declare a 2x2 matrix l to store the result.\n4. Call the subroutine ell_cov_2d with the three parameters: p, k_ell, and l.\n5. After the subroutine call, the matrix l will contain the lower triangular matrix for the specified ellipse type.\n\nPlease note that the subroutine performs various calculations and checks to ensure valid inputs and results.",
            "Subroutine ell_cov_2d in Fortran computes the lower triangular matrix for the minimum-area ellipse covering a given point in 2D. The subroutine takes three input parameters: p, a 2D array of real numbers representing the point; k_ell, an integer representing the type of ellipse to compute; and l, a 2D array of real numbers where the computed lower triangular matrix will be stored. The subroutine has no output value.\n\nTo use the subroutine, make sure the input parameters are valid. Then, call the subroutine with the appropriate arguments to compute the lower triangular matrix for the desired ellipse. The subroutine will modify the l array with the computed values.\n\nPlease note that the subroutine includes some error checking and boundary conditions to handle cases where the point is outside the unit circle or invalid values are provided.\n\n"
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: p(2)\n    integer :: k_ell\n    real(kind=8), dimension(2,2) :: l\n    \n    ! Test case 1\n    p = [0.3, 0.6]\n    k_ell = 1\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 2\n    p = [-0.5, 0.8]\n    k_ell = 2\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 3\n    p = [0.9, 0.1]\n    k_ell = 3\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 4\n    p = [0.2, -0.7]\n    k_ell = 1\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \n    ! Test case 5\n    p = [-0.3, -0.4]\n    k_ell = 2\n    call ell_cov_2d(p, k_ell, l)\n    print *, l\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.1155466862140624       0.43825043298325733        0.0000000000000000        1.3363061754263843",
                "1.1999999682108555        0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "1.0981581674632266        1.1399554434079029E-002   0.0000000000000000       0.99510731308739164",
                "1.0329219430355818      -0.22678101236501846        0.0000000000000000        1.3298252291283703",
                "3.0550503332358998        0.0000000000000000        0.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "subroutine ell_cov_2d( p, k_ell, l )\n\n!  in 2d, given the point p (|p|<1, |p_1|>0), three ellipses are defined:\n!  e_1 is the unit circle, shrunk in the p direction to intersect p \n!  e_2 is the unit circle, shrunk in the x_1 direction to intersect p, and\n!  e_3 is the minimum-area ellipse covering e_1 and e_2.\n!  the 2 x 2 lower trianglular matrix l is returned, \n!  where e_{k_ell} = { x | |l^t * x| <1 }.\n\n!  s.b. pope  12/16/05\n\nimplicit none\n\ninteger, parameter      :: k_dp = kind(1.d0)\nreal(k_dp), intent(in)  :: p(2)\ninteger,    intent(in)  :: k_ell\nreal(k_dp), intent(out) :: l(2,2)\n\nreal(k_dp), parameter   :: tol = 1.d-12\n\nreal(k_dp) :: psq, chi, theta, a, b, c, phi, sp, cp, sig1sq, sig2sq, sig1, &\n              sig2, alpha, d11, d21, d12, d22, ca, sa\n\n\nl = 0.d0  ! set l to unit circle\nl(1,1) = 1.d0\nl(2,2) = 1.d0\n\n!  check that input is valid\nif( abs(p(1))==0.d0 ) then\n   write(0,*) 'ell_cov_2d: p_1 is zero'\n   return\nendif\n\nif( k_ell < 1  .or.  k_ell > 3 ) then\n   write(0,*) 'ell_cov_2d: invalid k_ell = ', k_ell\n   stop\nendif\n\npsq = sum(p*p)\nif( psq > 1.d0+tol ) then  !  treat boundary and exterior\n   write(0,*) 'ell_cov_2d: |p| > 1, ', psq-1.d0\n   return \nelseif( psq >= 1.d0-tol ) then\n   return\nendif\n\nchi   = abs(p(1))/sqrt(1-p(2)**2)  ! intersection of e_2 and x_1 axis\n\nif( k_ell == 2 ) then  !  short-cut for e_2\n   l(1,1) = 1.d0 / chi\n   return\nendif\n\ntheta = (1-psq)/psq**2             ! e_1={x | x^t*(i+theta*p*p^t)*x <1 }\n\n!  transform so that e_1 is the unit circle: (x,y)->(x/chi,y)\na = (1.d0+theta*p(1)**2)*chi**2     ! b=[a cc b] is the matrix describing e_1\nb = 1.d0 + theta*p(2)**2\nc = theta*chi*p(1)*p(2)\n\n!  eigendecomposition of b\nphi = .5d0*atan2(-2.d0*c,(a-b))\nsp  = sin(phi)\ncp  = cos(phi)\n\nsig1sq = a*cp*cp-2.d0*c*sp*cp+b*sp*sp\nsig2sq = a*sp*sp+2.d0*c*sp*cp+b*cp*cp\n\n!  check that sigs bracket unity\nif( min(sig1sq,sig2sq) >1.d0 + tol .or. max(sig1sq,sig2sq) <1.d0 - tol ) then \n    write(0,*) 'ell_cov_2d: sig1sq-1, sig2sq-1= ' ,sig1sq-1.d0, sig2sq-1.d0\nendif\n\n! set principal axes for e_1, e_2 or e_3\n!  no change needed for e_1\n\nif( k_ell == 2 ) then\n    sig1sq=1.d0  ! set to e_2\n\tsig2sq=1.d0 \n    \nelseif( k_ell ==3 ) then\n    sig1sq = min(sig1sq, 1.d0)  ! e_3\n    sig2sq = min(sig2sq, 1.d0)\nendif\n\n!  the matrix for e_3 is: d*d^t,  d=c*u*sig = [q r s t]\nsig1 = sqrt(sig1sq)\nsig2 = sqrt(sig2sq)\nd11  = sig1*cp/chi\nd12  = sig2*sp/chi\nd21  =-sig1*sp\nd22  = sig2*cp\n!!  d = [d11 d12 d21 d22]\n!  transform back\nalpha = atan2(-d12, d11)\nca = cos(alpha)\nsa = sin(alpha)\n!!  qt = [ca sa; -sa ca]\n!! l  = d*qt\nl(1,1) = ca*d11 - sa*d12\nl(2,1) = ca*d21 - sa*d22\nl(2,2) = sa*d21 + ca*d22\n\nreturn\n\nend subroutine ell_cov_2d\n",
        "answer": "subroutine ell_cov_2d(x, ell, cov)\n    implicit none\n    real, intent(in) :: x(2)\n    integer, intent(in) :: ell\n    real, intent(out) :: cov(2,2)\n    real :: a, b, c, d, e, f\n\n    a = 1.0\n    b = 1.0\n    c = 1.0\n    d = 1.0\n    e = 1.0\n    f = 1.0\n\n    cov(1,1) = a * x(1)**2 + b * x(2)**2\n    cov(2,1) = c * x(1) * x(2)\n    cov(2,2) = d * x(2)**2 + e * x(1)**2\n\nend subroutine ell_cov_2d\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called kern_sqexp that computes the exponential function of each element in an array. The subroutine takes three parameters: nx, which is an integer representing the size of the array; nu, which is an array of real numbers; and out, which is an array of real numbers that will store the computed exponential values. The subroutine calculates the exponential value of each element in the nu array and stores the results in the out array.",
            "Write a Fortran subroutine called kern_sqexp that calculates the exponential of each element in an input array and stores the results in an output array. The subroutine takes three parameters: nx, which is an integer representing the size of the arrays; nu, which is an input array of real numbers; and out, which is an output array of real numbers. The subroutine should be used as follows:\n\nCall kern_sqexp(nx, nu, out)\n\nMake sure to specify the intent of each parameter: nx is an input parameter, nu is an input parameter, and out is an output parameter. The type of nu and out is real(8), which represents double precision real numbers. The subroutine uses the EXP function to compute the exponential of each element in nu and stores the results in the corresponding elements of out.",
            "Please write a Fortran subroutine named \"kern_sqexp\" that calculates the exponential of half the input values for a given array. The subroutine takes three parameters: \n- The first parameter is the size of the input array and it should be of type integer.\n- The second parameter is an array of real numbers and it should be passed by reference.\n- The third parameter is an array of real numbers and it should be passed by reference as well.\n\nMake sure to use the \"intent\" statement to specify the purpose of each parameter. The subroutine should calculate the exponential of half the input values and store the result in the third parameter array."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: nx\n    real*8, allocatable :: nu(:), out(:)\n    \n    ! Test case 1\n    nx = 5\n    allocate(nu(nx), out(nx))\n    nu = [1.0, 2.0, 3.0, 4.0, 5.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 2\n    nx = 3\n    allocate(nu(nx), out(nx))\n    nu = [0.0, -1.0, -2.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 3\n    nx = 2\n    allocate(nu(nx), out(nx))\n    nu = [0.5, 1.5]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 4\n    nx = 4\n    allocate(nu(nx), out(nx))\n    nu = [-0.5, 1.0, -1.5, 2.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\n    \n    ! Test case 5\n    nx = 1\n    allocate(nu(nx), out(nx))\n    nu = [3.0]\n    call kern_sqexp(nx, nu, out)\n    print *, out\n    deallocate(nu, out)\n    print *, \"&\"\nend program main",
            "result": [
                "0.60653065971263342       0.36787944117144233       0.22313016014842982       0.13533528323661270        8.2084998623898800E-002",
                "1.0000000000000000        1.6487212707001282        2.7182818284590451",
                "0.77880078307140488       0.47236655274101469",
                "1.2840254166877414       0.60653065971263342        2.1170000166126748       0.36787944117144233",
                "0.22313016014842982"
            ]
        },
        "code": "pure subroutine kern_sqexp(nx, nu, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: nu(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*nu)\nend subroutine kern_sqexp\n",
        "answer": "subroutine kern_sqexp(nx, nu, out)\n    integer, intent(in) :: nx\n    real(8), intent(in) :: nu(nx)\n    real(8), intent(out) :: out(nx)\n    integer :: i\n\n    do i = 1, nx\n        out(i) = exp(-0.5d0 * nu(i)**2)\n    end do\nend subroutine kern_sqexp\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called get_dist that calculates the distance between two atoms in a three-dimensional space. The subroutine takes in 5 input parameters: two integers i and j representing the indices of the atoms, a 3x3 real matrix aa representing the transformation matrix, and aa_atom, a two-dimensional real array representing the atomic coordinates. The subroutine also has 1 output parameter: a real variable d representing the calculated distance.",
            "Please provide a Fortran subroutine code called \"get_dist\" that calculates the distance between two points in three-dimensional space. The subroutine takes in five parameters -- two integers (i and j), a 3x3 real matrix (aa), a two-dimensional real array (aa_atom), and an output real variable (d). The subroutine calculates the coordinates of two points (ri and rj) by multiplying the matrix aa with the corresponding columns of aa_atom. Then, it computes the Euclidean distance between the two points and stores the result in the variable d.",
            "Provide a Fortran subroutine called get_dist that calculates the Euclidean distance between two atoms in a three-dimensional space. This subroutine requires 5 parameters. The first two parameters, i and j, are integers and represent the indices of the atoms. The next two parameters, aa and aa_atom, are both two-dimensional arrays of type real(8). The aa array is a 3x3 matrix that represents a transformation matrix, while aa_atom is a matrix containing the coordinates of the atoms. The last parameter, d, is a real(8) variable and represents the output distance between the two atoms. The subroutine uses the matmul function to perform matrix multiplication and calculates the coordinates of the atoms using the transformation matrix. The Euclidean distance is then computed using the formula sqrt( sum((ri-rj)**2) ), where ri and rj are the coordinates of atoms i and j respectively."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: i, j\n    real*8 :: aa(3,3), aa_atom(3,5), d\n    ! Test case 1\n    i = 1\n    j = 2\n    aa = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n\n    ! Test case 2\n    i = 2\n    j = 3\n    aa = reshape([2.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 3\n    i = 3\n    j = 4\n    aa = reshape([1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 4\n    i = 1\n    j = 4\n    aa = reshape([2.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\n    print *, \"&\"\n    \n    ! Test case 5\n    i = 2\n    j = 5\n    aa = reshape([1.0, 0.0, 0.0, 2.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3, 3])\n    aa_atom = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [3, 5])\n    call get_dist(i, j, aa, aa_atom, d)\n    print *, d\nend program main",
            "result": [
                "1.4142135623730951",
                "1.4142135623730951",
                "2.2360679774997898",
                "2.4494897427831779",
                "1.7320508075688772"
            ]
        },
        "code": "  subroutine get_dist( i, j, aa, aa_atom, d )\n    implicit none\n    integer,intent(in)  :: i,j\n    real(8),intent(in)  :: aa(3,3),aa_atom(:,:)\n    real(8),intent(out) :: d\n    real(8) :: ri(3),rj(3)\n    ri=matmul(aa,aa_atom(:,i))\n    rj=matmul(aa,aa_atom(:,j))\n    d=sqrt( sum((ri-rj)**2) )\n  end subroutine get_dist\n",
        "answer": "subroutine get_dist(i, j, aa, aa_atom, d)\n    integer, intent(in) :: i, j\n    real, dimension(3,3), intent(in) :: aa\n    real, dimension(3,2), intent(in) :: aa_atom\n    real, intent(out) :: d\n    real :: r_i, r_j, dr\n    real, dimension(3) :: ri, rj\n\n    ri = matmul(aa, aa_atom(:,i))\n    rj = matmul(aa, aa_atom(:,j))\n    dr = sqrt(sum((rj - ri)**2))\n    d = dr\nend subroutine get_dist\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code called plschmidt to evaluate the Schmidt normalized Legendre polynomials up to a specified degree. The subroutine has four input parameters and one optional output parameter. The first input parameter, lmax, is an integer representing the maximum degree to compute. The second input parameter, p, is a real*8 array that will store the evaluated Legendre polynomials. The third input parameter, z, is a real*8 representing the cos(colatitude) or sin(latitude) and must be within the range [-1, 1]. The fourth input parameter, exitstatus, is an optional integer that will be set to 0 if no errors occur during execution.\n\nThe subroutine computes the Schmidt normalized Legendre polynomials up to the specified degree and stores the results in the p array. It performs error checks for the dimensions of the input array and the bounds of the input variables. If an error is encountered, the subroutine either stops execution or sets the exitstatus variable accordingly.\n\nNote that the subroutine assumes the p array is dimensioned as (lmax+1), where lmax is the maximum degree specified. The computed Legendre polynomials follow certain integral properties, such as the integral of plm**2 over (-1,1) and over all space.\n\nEnsure the input and output parameters are correctly specified and conform to the Fortran subroutine syntax.",
            "Write a Fortran subroutine called plschmidt that evaluates the Schmidt normalized Legendre polynomials up to a given degree. The subroutine has 4 input parameters and 1 optional output parameter. The first input parameter, lmax, is an integer that specifies the maximum degree to compute. The second input parameter, z, is a real number between -1 and 1, representing cos(colatitude) or sin(latitude). The third input parameter is an array p of type real that has a length greater than or equal to (lmax+1) to store the evaluated Legendre polynomials. The optional fourth input parameter, exitstatus, is an integer that will be set to 0 if there are no errors, and its presence will prevent the subroutine from stopping when an error is encountered. If any of the input parameters have improper dimensions or bounds, the subroutine will print an error message and set the exitstatus accordingly. The subroutine uses a loop to compute the Legendre polynomials and stores them in the array p. The subroutine is terminated after the loop.",
            "Provide a Fortran subroutine called plschmidt that computes the Schmidt normalized Legendre polynomials up to a specified maximum degree. The subroutine has four input parameters and one optional output parameter. The first input parameter is an integer lmax, which determines the maximum degree to compute. The second input parameter is a real number z, which must be between -1 and 1. The third input parameter is an output array p, which must have a length greater than or equal to (lmax+1). The fourth input parameter is an optional output variable exitstatus, which indicates any encountered errors. The subroutine calculates the Schmidt normalized Legendre polynomials and stores the results in the array p. If any errors occur, the exitstatus variable is set accordingly."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: lmax = 5\n    real*8 :: z\n    real*8 :: p(lmax+1)\n    integer :: exitstatus\n    \n    ! Test case 1\n    z = 0.5\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 2\n    z = -0.8\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 3\n    z = 1.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 4\n    z = -1.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \n    ! Test case 5\n    z = 0.0\n    call plschmidt(p, lmax, z, exitstatus)\n    print *, p\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.0000000000000000       0.50000000000000000      -0.12500000000000000      -0.43750000000000000      -0.28906250000000000        8.9843750000000000E-002",
                "1.0000000000000000      -0.80000001192092896       0.46000002861022971       -8.0000039339066367E-002 -0.23299996471404849       0.39951998565911973",
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000",
                "1.0000000000000000       -1.0000000000000000        1.0000000000000000       -1.0000000000000000        1.0000000000000000       -1.0000000000000000",
                "1.0000000000000000        0.0000000000000000      -0.50000000000000000       -0.0000000000000000       0.37500000000000000        0.0000000000000000"
            ]
        },
        "code": "subroutine plschmidt(p, lmax, z, exitstatus)\n!------------------------------------------------------------------------------\n!\n!   this function evalutates all of the schmidt normalized legendre\n!   polynomials up to degree lmax.\n!\n!   calling parameters\n!\n!       out\n!           p       a vector of all schmidt normalized legendgre polynomials\n!                   evaluated at z up to lmax. the lenght must by greater or\n!                   equal to (lmax+1).\n!\n!       in\n!           lmax    maximum degree to compute.\n!           z       [-1, 1], cos(colatitude) or sin(latitude).\n!\n!       optional (out)\n!           exitstatus  if present, instead of executing a stop when an error\n!                       is encountered, the variable exitstatus will be\n!                       returned describing the error.\n!                       0 = no errors;\n!                       1 = improper dimensions of input array;\n!                       2 = improper bounds for input variable;\n!                       3 = error allocating memory;\n!                       4 = file io error.\n!\n!   notes:\n!\n!   1.  the integral of plm**2 over (-1,1) is 2 * / (2l+1).\n!   2.  the integral of plm**2 over all space is 4 pi / (2l+1).\n!\n!   copyright (c) 2016, shtools\n!   all rights reserved.\n!\n!------------------------------------------------------------------------------\n    implicit none\n\n    integer, intent(in) :: lmax\n    real*8, intent(out) :: p(:)\n    real*8, intent(in) :: z\n    integer, intent(out), optional :: exitstatus\n    real*8 :: pm2, pm1, pl\n    integer :: l\n\n    if (present(exitstatus)) exitstatus = 0\n\n    if (size(p) < lmax+1) then\n        print*, \"error --- plschmidt\"\n        print*, \"p must be dimensioned as (lmax+1) where lmax is \", lmax\n        print*, \"input array is dimensioned \", size(p)\n        if (present(exitstatus)) then\n            exitstatus = 1\n            return\n        else\n            stop\n        endif\n\n    else if (lmax < 0) then\n        print*, \"error --- plschmidt\"\n        print*, \"lmax must be greater than or equal to 0.\"\n        print*, \"input value is \", lmax\n        if (present(exitstatus)) then\n            exitstatus = 2\n            return\n        else\n            stop\n        endif\n\n    else if(abs(z) > 1.0d0) then\n        print*, \"error --- plschmidt\"\n        print*, \"abs(z) must be less than or equal to 1.\"\n        print*, \"input value is \", z\n        if (present(exitstatus)) then\n            exitstatus = 2\n            return\n        else\n            stop\n        endif\n\n    end if\n\n    pm2 = 1.d0\n    p(1) = 1.d0\n\n    pm1 = z\n    p(2) = pm1\n\n    do l = 2, lmax, 1\n        pl = ( dble(2*l-1)  * z * pm1 - dble(l-1) * pm2 ) / dble(l)\n        p(l+1) = pl\n        pm2 = pm1\n        pm1 = pl\n\n    end do\n\nend subroutine plschmidt\n",
        "answer": "subroutine plschmidt(lmax, p, z, exitstatus)\n\n    implicit none\n\n    integer, intent(in) :: lmax\n    real*8, intent(out) :: p(lmax+1)\n    real*8, intent(in) :: z\n    integer, intent(out), optional :: exitstatus\n\n    integer :: l, m\n    real*8 :: dl, dlm, dlmm, dlmp\n\n    if (present(exitstatus)) exitstatus = 0\n\n    if (size(p) < lmax+1) then\n        print*, \"error: plschmidt: p array too small.\"\n        if (present(exitstatus)) exitstatus = 1\n        return\n    endif\n\n    if (z < -1.0d0 .or. z > 1.0d0) then\n        print*, \"error: plschmidt: z must be within the range (-1,1).\"\n        if (present(exitstatus)) exitstatus = 1\n        return\n    endif\n\n    p(1) = 1.0d0\n    if (lmax > 0) then\n        p(2) = sqrt(3.0d0) * z\n    endif\n\n    do l = 2, lmax\n        dl = dble(l)\n        dlmm = sqrt((2.0d0*dl-1.0d0)/(2.0d0*dl+1.0d0))\n        dlmp = sqrt((2.0d0*dl+1.0d0)/(2.0d0*dl-1.0d0))\n        p(l+1) = z * sqrt(dlmp) * p(l) - sqrt(dlmm) * p(l-1)\n    enddo\n\nend subroutine plschmidt\n\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called fit_line to calculate the coefficients of a line that fits two given points. The subroutine has 6 parameters. The outputs are a0 and a1, both of type real. The inputs are x1, y1, x2, and y2, all of type real. The subroutine should compute the values of a0 and a1 using the given formula.",
            "Provide a Fortran subroutine called fit_line that calculates the slope (a1) and y-intercept (a0) of a line given two points (x1, y1) and (x2, y2). The subroutine has four input parameters: x1 and y1 of type real, representing the coordinates of the first point, and x2 and y2 of type real, representing the coordinates of the second point. The subroutine has two output parameters: a0 and a1 of type real, representing the y-intercept and slope of the line, respectively.",
            "Provide a Fortran subroutine called fit_line that calculates the slope (a1) and y-intercept (a0) of a line given two points. The subroutine has 4 input parameters and 2 output parameters. The input parameters are x1 and y1 (both of type real) representing the coordinates of the first point, and x2 and y2 (also of type real) representing the coordinates of the second point. The output parameters are a0 and a1, both of type real, representing the y-intercept and slope of the line, respectively."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: a0, a1, x1, y1, x2, y2\n    ! Test case 1\n    x1 = 1.0\n    y1 = 2.0\n    x2 = 3.0\n    y2 = 6.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n\n    ! Test case 2\n    x1 = -2.0\n    y1 = 5.0\n    x2 = 4.0\n    y2 = 1.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 3\n    x1 = 0.0\n    y1 = 0.0\n    x2 = 10.0\n    y2 = 5.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 4\n    x1 = 2.5\n    y1 = 10.0\n    x2 = 5.0\n    y2 = 0.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\n    \n    ! Test case 5\n    x1 = -3.0\n    y1 = -6.0\n    x2 = 3.0\n    y2 = 12.0\n    call fit_line(a1, a0, x1, y1, x2, y2)\n    print *, a1, a0\n    print *, \"&\"\nend program main",
            "result": [
                "2.00000000       0.00000000",
                "-0.666666687       3.66666651",
                "0.500000000       0.00000000",
                "-4.00000000       20.0000000",
                "3.00000000       3.00000000"
            ]
        },
        "code": "  subroutine fit_line(a1,a0,x1,y1,x2,y2)\n\n    implicit none\n    real, intent(out) :: a0, a1\n    real, intent(in) :: x1, y1, x2, y2\n\n    !given xi, yi i=1,2 fits a line between these points\n\n    a1=(y2-y1)/(x2-x1)\n    a0=y1-a1*x1\n\n  end subroutine fit_line\n",
        "answer": "subroutine fit_line(x1, y1, x2, y2, a0, a1)\n    real, intent(in) :: x1, y1, x2, y2\n    real, intent(out) :: a0, a1\n\n    a1 = (y2 - y1) / (x2 - x1)\n    a0 = y1 - a1 * x1\nend subroutine fit_line\n\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called split_kv that takes in a single input parameter of type character and splits it into two separate output parameters, also of type character. The input parameter is intended to be in the format \"key=value\" where \"key\" and \"value\" are strings. The subroutine extracts the key and value from the input parameter and assigns them to the respective output parameters. The subroutine uses the keywords \"character\", \"intent\", \"in\", \"out\", \"index\", \"trim\", \"adjustl\", and \"end subroutine\".",
            "Provide a Fortran subroutine called split_kv that splits a string into two parts based on a specified delimiter. The subroutine has three input parameters and two output parameters. The first input parameter is a character string named \"par\" which represents the input string. The second and third input parameters are character strings named \"key\" and \"val\" respectively, which will store the split parts of the input string. The subroutine does not return any values. The subroutine uses the keywords \"intent(in)\" and \"intent(out)\" to specify the input and output parameters respectively. Inside the subroutine, the input string is searched for the delimiter \"=\", and the string is split into two parts based on the position of the delimiter. The first part is assigned to the \"key\" string variable, and the second part is assigned to the \"val\" string variable. The \"trim\" and \"adjustl\" functions are used to remove any leading or trailing whitespace characters from the split parts.",
            "Provide a Fortran subroutine called split_kv. This subroutine is used to split a given string into two parts, namely the key and the value. The subroutine takes in three input parameters. The first parameter, par, is a character string that needs to be split. The second parameter, key, is a character string that will store the key extracted from par. The third parameter, val, is a character string that will store the value extracted from par. The subroutine then assigns the character '=' to the variable eq. The integer variable id is used to find the position of the character '=' within the par string using the index function. The key is extracted by taking a substring from par starting from the first character and ending at the position before the '=' character. Similarly, the value is extracted by taking a substring from par starting from the character after the '=' character till the end of the string. The subroutine then ends."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    character(len=30) :: parameter\n    character(len=15) :: key, value\n    \n    ! Test case 1\n    parameter = \"name=John Doe\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 2\n    parameter = \"age=25\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 3\n    parameter = \"location=New York\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 4\n    parameter = \"salary=50000\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \n    ! Test case 5\n    parameter = \"gender=Male\"\n    call split_kv(parameter, key, value)\n    print *, key, value\n    print *, \"&\"\n    \nend program main",
            "result": [
                "name           John Doe",
                "age            25",
                "location       New York",
                "salary         50000",
                "gender         Male"
            ]
        },
        "code": "    subroutine split_kv(par,key,val)\n    character(len=*),intent(in):: par\n    character(len=*),intent(out):: key,val\n    character:: eq='='\n    integer:: id\n    id=index(par,eq)\n    key=trim(adjustl(par(1:id-1)))\n    val=trim(adjustl(par(id+1:)))\n    end subroutine\n",
        "answer": "subroutine split_kv(kv, key, value)\n    character(len=*), intent(in) :: kv\n    character(len=:), allocatable, intent(out) :: key, value\n    integer :: index\n\n    index = index(kv, '=')\n    key = trim(adjustl(kv(:index-1)))\n    value = trim(adjustl(kv(index+1:)))\nend subroutine split_kv\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"interpolation\" to perform linear interpolation. The subroutine takes 4 input parameters, all of type real(8). The first two parameters represent the left value and distance, while the next two parameters represent the right value and distance. There is one output parameter, also of type real(8), which represents the interpolated value. Your task is to implement the interpolation formula: f = (fl*dr + fr*dl) / (dl + dr).",
            "Give me a Fortran subroutine code called interpolation to compute the interpolated value between two given values. The number of input parameters is 4, the first parameter is the left value of the interval, the second parameter is the left difference of the interval, the third parameter is the right value of the interval, and the fourth parameter is the right difference of the interval. The type of all input parameters is double precision. The number of output parameters is 1, the output parameter is the interpolated value, and its type is double precision.",
            "Write a Fortran subroutine named \"interpolation\" that calculates the interpolation value based on given data. The subroutine takes in 4 input parameters, all of type real(8). The first two parameters, fl and dl, represent the left function value and its derivative respectively. The next two parameters, fr and dr, represent the right function value and its derivative respectively. The subroutine also has one output parameter, f, of type real(8), which represents the interpolated value.\nInside the subroutine, the interpolated value is calculated using the provided formula: (fl*dr + fr*dl) / (dl + dr)."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(8) :: fl, dl, fr, dr, f\n    \n    ! Test case 1\n    fl = 1.0\n    dl = 2.0\n    fr = 3.0\n    dr = 4.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 2\n    fl = 0.0\n    dl = 10.0\n    fr = 5.0\n    dr = 7.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 3\n    fl = -3.5\n    dl = 6.0\n    fr = 2.5\n    dr = 1.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 4\n    fl = 8.0\n    dl = 3.0\n    fr = -1.0\n    dr = 2.0\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \n    ! Test case 5\n    fl = -2.5\n    dl = 0.5\n    fr = 1.5\n    dr = -1.5\n    call interpolation(fl, dl, fr, dr, f)\n    print *, f\n    print *, \"&\"\n    \nend program main",
            "result": [
                "1.6666666666666667",
                "2.9411764705882355",
                "1.6428571428571428",
                "2.6000000000000001",
                "-4.5000000000000000"
            ]
        },
        "code": "subroutine interpolation(fl, dl, fr, dr, f)\n  implicit none\n  real(8), intent(in) :: fl, dl, fr, dr\n  real(8), intent(out) :: f\n  f = (fl*dr+fr*dl)/(dl+dr)\nend subroutine interpolation\n",
        "answer": "subroutine interpolation(fl, dl, fr, dr, f)\n    real(8), intent(in) :: fl, dl, fr, dr\n    real(8), intent(out) :: f\n\n    f = (fl*dr + fr*dl) / (dl + dr)\nend subroutine interpolation\n\n"
    },
    {
        "instruction": [
            "Please write a Fortran subroutine called \"func\" to calculate the exponential function of a given input value. The subroutine should have 2 parameters. The first parameter is the input value, which is of type real and passed by value. The second parameter is the output value, which is also of type real and passed by reference. The output value should store the result of applying the exponential function to the input value.",
            "Write a Fortran subroutine called \"func\" that calculates the exponential function for a given input value. The subroutine takes 1 input parameter of type real, named \"x\", and 1 output parameter of type real, named \"fx\". The input parameter \"x\" represents the value for which the exponential function needs to be evaluated. The output parameter \"fx\" stores the result of the exponential calculation.",
            "Please write a Fortran subroutine called \"func\" to calculate the exponential function for a given input value. The subroutine takes one input parameter of type real and one output parameter of type real. The input parameter is named \"x\" and represents the value for which the exponential function needs to be calculated. The output parameter is named \"fx\" and represents the result of the exponential function calculation."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind(0.d0)) :: input, output\n    ! Test case 1\n    input = 0.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = 1.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 2.5\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = -1.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = 5.0\n    call func(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000",
                "0.36787944117144233",
                "8.2084998623898800E-002",
                "2.7182818284590451",
                "6.7379469990854670E-003"
            ]
        },
        "code": "        subroutine func(x,fx)\n        implicit none\n        real (kind(0.d0)), intent(in)  :: x\n        real (kind(0.d0)), intent(out) :: fx\n!\n        fx = exp(-x)\n        return\n        end subroutine func\n",
        "answer": "subroutine func(x, y)\n    implicit none\n    real, intent(in) :: x\n    real, intent(out) :: y\n    y = exp(x)\nend subroutine func\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine called linear_shape_1d to calculate the shape functions and their derivatives for a 1D linear shape. The subroutine takes in three parameters: \n1. xi, a real number that represents the location on the shape.\n2. n_shape, an array of size 2 to store the calculated shape functions.\n3. dn_shape, an array of size 2 to store the calculated derivatives of the shape functions.\n\nIn the subroutine, the shape functions are calculated as follows:\n- The first shape function (n_shape(1)) is half of (1-xi).\n- The second shape function (n_shape(2)) is half of (1+xi).\n\nThe derivatives of the shape functions are calculated as follows:\n- The derivative of the first shape function (dn_shape(1)) is -0.5.\n- The derivative of the second shape function (dn_shape(2)) is 0.5.\n\nMake sure to use the \"implicit none\" statement to enforce explicit declaration of variables.",
            "Please write a Fortran subroutine called linear_shape_1d that calculates the shape functions and their derivatives for a one-dimensional linear shape. The subroutine takes 1 input parameter of type real(kind=8) called xi. It also has 2 output parameters of type real(kind=8) called n_shape and dn_shape. \n\nTo calculate the shape functions, use the formula n_shape(1) = 0.5d0*(1.d0-xi) and n_shape(2) = 0.5d0*(1.d0+xi). \n\nTo calculate the derivatives of the shape functions, use the formula dn_shape(1) = -0.5d0 and dn_shape(2) = 0.5d0.",
            "Write a Fortran subroutine called linear_shape_1d to compute the linear shape functions and their derivatives for a one-dimensional shape. The subroutine has three input parameters: xi, which is of type real and represents the evaluation point; n_shape, which is an array of type real and size 2, used to store the computed shape functions; and dn_shape, which is also an array of type real and size 2, used to store the computed derivatives of the shape functions. The subroutine does not return any value.\n\nTo compute the shape functions, the subroutine uses the following formulas:\n- n_shape(1) = 0.5 * (1 - xi)\n- n_shape(2) = 0.5 * (1 + xi)\n\nTo compute the derivatives of the shape functions, the subroutine uses the following formulas:\n- dn_shape(1) = -0.5\n- dn_shape(2) = 0.5\n\nPlease note that the subroutine assumes that the input arrays n_shape and dn_shape are already declared and allocated before calling the subroutine."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: xi, n_shape(2), dn_shape(2)\n    ! Test case 1\n    xi = 0.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n\n    ! Test case 2\n    xi = 1.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = -0.5\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = 0.75\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = -1.0\n    call linear_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), dn_shape(1), dn_shape(2)\n    print *, \"&\"\nend program main",
            "result": [
                "0.50000000000000000       0.50000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.0000000000000000        1.0000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.75000000000000000       0.25000000000000000      -0.50000000000000000       0.50000000000000000",
                "0.12500000000000000       0.87500000000000000      -0.50000000000000000       0.50000000000000000",
                "1.0000000000000000        0.0000000000000000      -0.50000000000000000       0.50000000000000000"
            ]
        },
        "code": " subroutine linear_shape_1d(xi,n_shape,dn_shape)\n   implicit none\n   !--dummy arguments\n   real(kind=8),intent(in) :: xi\n   real(kind=8),intent(out) :: n_shape(2),dn_shape(2)\n   !--local arguments\n\n   !functions\n   n_shape(1) = 0.5d0*(1.d0-xi)\n   n_shape(2) = 0.5d0*(1.d0+xi)\n   !derivatives\n   dn_shape(1) = -0.5d0\n   dn_shape(2) = 0.5d0\n\n end subroutine linear_shape_1d\n",
        "answer": "subroutine linear_shape_1d(xi, n_shape, dn_shape)\n    implicit none\n    real, intent(in) :: xi\n    real, dimension(2), intent(out) :: n_shape, dn_shape\n\n    n_shape(1) = 0.5 * (1.0 - xi)\n    n_shape(2) = 0.5 * (1.0 + xi)\n\n    dn_shape(1) = -0.5\n    dn_shape(2) = 0.5\nend subroutine linear_shape_1d\n\n"
    },
    {
        "instruction": [
            "Create a Fortran subroutine called quadratic_shape_1d to calculate the shape functions and their derivatives for a one-dimensional quadratic element. The subroutine takes in three input parameters: xi of type real(kind=8) as the independent variable, and n_shape(3) and dn_shape(3) of type real(kind=8) arrays to store the shape functions and their derivatives, respectively. The subroutine has no local variables. The shape functions and their derivatives are calculated using specific formulas and stored in the respective arrays. The subroutine returns the calculated values of the shape functions and their derivatives through the output parameters n_shape and dn_shape.",
            "I need a Fortran subroutine code named \"quadratic_shape_1d\" that calculates the shape functions and their derivatives for a one-dimensional quadratic element. The subroutine has three input parameters, all of type real. The first input parameter is a single value, \"xi\", representing the coordinate value. The second and third input parameters are arrays, \"n_shape\" and \"dn_shape\", of size 3, representing the shape functions and their derivatives, respectively. The subroutine also has no output parameters. Your task is to write the subroutine code using the given inputs and outputs.",
            "Write a Fortran subroutine called quadratic_shape_1d to calculate the shape functions and their derivatives for a one-dimensional quadratic shape. The subroutine takes 3 input parameters, all of type real(kind=8). The first input parameter is xi, and the remaining two are arrays called n_shape and dn_shape, each of size 3. The subroutine computes the values of the shape functions and their derivatives based on the input value xi. The results are stored in the n_shape and dn_shape arrays respectively. The shape functions are computed using specific formulas, and the derivatives of the shape functions are also calculated."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real(kind=8) :: xi, n_shape(3), dn_shape(3)\n    \n    ! Test case 1\n    xi = 0.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    xi = 0.5\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = 1.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = -0.5\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = 2.0\n    call quadratic_shape_1d(xi, n_shape, dn_shape)\n    print *, n_shape(1), n_shape(2), n_shape(3), dn_shape(1), dn_shape(2), dn_shape(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-0.0000000000000000        1.0000000000000000        0.0000000000000000      -0.50000000000000000        1.0000000000000000       0.50000000000000000",
                "-0.12500000000000000       0.75000000000000000       0.37500000000000000        0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        1.0000000000000000       0.50000000000000000       -1.0000000000000000        1.5000000000000000",
                "0.37500000000000000       0.75000000000000000      -0.12500000000000000       -1.0000000000000000        2.0000000000000000        0.0000000000000000",
                "1.0000000000000000       -3.0000000000000000        3.0000000000000000        1.5000000000000000       -3.0000000000000000        2.5000000000000000"
            ]
        },
        "code": "  subroutine quadratic_shape_1d(xi,n_shape,dn_shape)\n    implicit none\n    !--dummy arguments\n    real(kind=8),intent(in) :: xi\n    real(kind=8),intent(out) :: n_shape(3),dn_shape(3)\n    !--local arguments\n\n    !functions\n    n_shape(1) = 0.5d0*xi*(xi-1.d0)\n    n_shape(2) = 1.d0-xi**2.d0\n    n_shape(3) = 0.5d0*xi*(xi+1.d0)\n    !derivatives\n    dn_shape(1) = 0.5d0*(2.d0*xi-1.d0)\n    dn_shape(2) = 1.d0-2.d0*xi\n    dn_shape(3) = 0.5d0*(2.d0*xi+1.d0)\n\n  end subroutine quadratic_shape_1d\n",
        "answer": "subroutine quadratic_shape_1d(xi, n_shape, dn_shape)\n    implicit none\n    real(kind=8), intent(in) :: xi\n    real(kind=8), intent(out) :: n_shape(3), dn_shape(3)\n\n    n_shape(1) = 2.0d0 * xi - 1.0d0\n    n_shape(2) = 4.0d0 * xi**2 - 3.0d0 * xi\n    n_shape(3) = 4.0d0 - 8.0d0 * xi\n\n    dn_shape(1) = 2.0d0\n    dn_shape(2) = 8.0d0 * xi - 3.0d0\n    dn_shape(3) = -8.0d0\n\nend subroutine quadratic_shape_1d\n\n"
    },
    {
        "instruction": [
            "Please provide a Fortran subroutine called locate_ij that performs a binary search algorithm to find the index of the element in a given array that is closest to, but less than, a given value. The subroutine takes 3 input parameters: length, an integer representing the size of the array; array, a real array containing the elements; value, a real value to search for. The subroutine also has 1 output parameter: idx, an integer representing the index of the closest element. The subroutine should be implemented to find the closest element in a sorted array.",
            "Write a Fortran subroutine called locate_ij that uses a binary search algorithm to find the index of the element in a given array that is closest to, but less than, a given value. The subroutine takes in four parameters: the length of the array (an integer), the array itself (a real array), the value to search for (a real), and the index of the closest element (an integer). The subroutine returns the index of the element that satisfies the search criteria.\n\nTo use the subroutine, provide the length of the array, the array itself, and the value to search for as input arguments. The subroutine will determine the index of the closest element and store it in the output argument, idx.",
            "Write a Fortran subroutine named locate_ij. This subroutine takes in four parameters: length, an integer representing the length of the array; array, a real array of length elements; value, a real value; and idx, an output parameter of type integer. The purpose of this subroutine is to find the index of the element in the array that is closest to, but less than, the given value. It uses a binary search algorithm to perform this task.\n\nTo use the subroutine, provide the length of the array, the array itself, the value to search for, and a variable to store the resulting index. After calling the subroutine, the variable idx will contain the index of the element in the array that is closest to, but less than, the given value."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: length, idx\n    real, dimension(:), allocatable :: array\n    real :: value\n    \n    ! Test case 1\n    length = 5\n    allocate(array(length))\n    array = [1.0, 2.0, 3.0, 4.0, 5.0]\n    value = 2.5\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 2\n    length = 6\n    allocate(array(length))\n    array = [2.0, 4.0, 6.0, 8.0, 10.0, 12.0]\n    value = 7.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 3\n    length = 3\n    allocate(array(length))\n    array = [1.5, 2.5, 3.5]\n    value = 3.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 4\n    length = 4\n    allocate(array(length))\n    array = [0.1, 0.2, 0.3, 0.4]\n    value = 0.3\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\n    print *, \"&\"\n    \n    ! Test case 5\n    length = 1\n    allocate(array(length))\n    array = [5.0]\n    value = 3.0\n    call locate_ij(length, array, value, idx)\n    print *, idx\n    deallocate(array)\nend program main",
            "result": [
                "2",
                "3",
                "2",
                "3",
                "0"
            ]
        },
        "code": "subroutine locate_ij(length, array, value, idx)\n        ! given an array and a value, returns the index of the element that\n        ! is closest to, but less than, the given value.\n        ! uses a binary search algorithm.\n        implicit none\n        integer, intent(in) :: length\n        real, dimension(length), intent(in) :: array      \n        real, intent(in) :: value\n\tinteger, intent(out) :: idx\n        integer :: left, middle, right\n       \n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            end if\n            middle = nint((left+right) / 2.0)\n            if ( abs(array(middle) - value) <= 1e-9) then\n                idx = middle\n                return\n            else if (array(middle) > value) then\n                right = middle - 1\n            else\n                left = middle + 1\n            end if\n        end do\n        idx = right\n\n\treturn\nend subroutine locate_ij\n",
        "answer": "subroutine locate_ij(length, array, value, idx)\n    integer, intent(in) :: length\n    real, dimension(length), intent(in) :: array\n    real, intent(in) :: value\n    integer, intent(out) :: idx\n\n    integer :: ilow, ihigh, imid\n\n    ilow = 1\n    ihigh = length\n\n    do while (ilow < ihigh)\n        imid = (ilow + ihigh) / 2\n        if (array(imid) < value) then\n            ilow = imid + 1\n        else\n            ihigh = imid\n        end if\n    end do\n\n    idx = max(min(ilow, length), 1)\nend subroutine locate_ij\n\n"
    },
    {
        "instruction": [
            "Give me a Fortran subroutine code called cross to compute the cross product of two 3-dimensional vectors. The subroutine takes in 2 input parameters and 1 output parameter. The first input parameter is an array of type real with dimension 3, representing the first vector. The second input parameter is also an array of type real with dimension 3, representing the second vector. The output parameter is an array of type real with dimension 3, representing the resulting cross product.",
            "Give me a Fortran subroutine code called calculate_cross_product to compute the cross product of two vectors. The subroutine takes 2 input parameters, both are arrays of type real and dimension 3. The output parameter is also an array of type real and dimension 3. The subroutine calculates the cross product of the input vectors and stores the result in the output array.",
            "Write a Fortran subroutine called cross that calculates the cross product of two 3-dimensional vectors. The subroutine takes two input parameters, both of which are arrays of type real and have a dimension of 3. The subroutine also has one output parameter, which is an array of type real and also has a dimension of 3."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: x(3), y(3), tmp(3)\n    \n    ! Test case 1\n    x = [1.0, 2.0, 3.0]\n    y = [4.0, 5.0, 6.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 2\n    x = [0.5, 1.5, 2.5]\n    y = [1.0, 2.0, 3.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 3\n    x = [10.0, 20.0, 30.0]\n    y = [3.0, 2.0, 1.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 4\n    x = [1.0, 1.0, 1.0]\n    y = [2.0, 2.0, 2.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \n    ! Test case 5\n    x = [-1.0, -2.0, -3.0]\n    y = [4.0, 5.0, 6.0]\n    call cross(tmp, x, y)\n    print *, tmp(1), tmp(2), tmp(3)\n    print *, \"&\"\n    \nend program main",
            "result": [
                "-3.00000000       6.00000000      -3.00000000",
                "-0.500000000       1.00000000     -0.500000000",
                "-40.0000000       80.0000000      -40.0000000",
                "0.00000000       0.00000000       0.00000000",
                "3.00000000      -6.00000000       3.00000000"
            ]
        },
        "code": "    subroutine cross(tmp, x,y)\n        real, dimension(3), intent(in) :: x,y\n        real, dimension(3), intent(out) :: tmp\n\n        tmp(1) = x(2)*y(3)-x(3)*y(2)\n        tmp(2) = x(3)*y(1)-x(1)*y(3)\n        tmp(3) = x(1)*y(2)-x(2)*y(1)\n    end subroutine\n",
        "answer": "subroutine cross(a, b, c)\n    implicit none\n    real, dimension(3), intent(in) :: a, b\n    real, dimension(3), intent(out) :: c\n\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n\nend subroutine cross\n\n"
    },
    {
        "instruction": [
            "Please create a Fortran subroutine called \"unrotate_frame\" to rotate a given set of coordinates in three dimensions. The subroutine takes in 7 input parameters: x_in, y_in, z_in (real values representing the initial coordinates), stheta, ctheta, sphi, cphi (real values representing the sine and cosine of the rotation angles). It also has 3 output parameters: xn, yn, zn (real values representing the rotated coordinates).\n\nTo implement the subroutine, declare the necessary variables and use the provided rotation formulas to calculate the new coordinates. Assign the results to xn, yn, and zn. Finally, use the \"return\" statement to exit the subroutine.\n\nMake sure to specify the data types of the input and output parameters correctly, using the \"real (kind=8)\" declaration for double-precision floating-point numbers.",
            "Please provide a Fortran subroutine called \"unrotate_frame\" that rotates a frame using input angles phi and theta. The subroutine takes 7 input parameters: x_in, y_in, z_in (all of type real), stheta, ctheta, sphi, cphi (all of type real). It also has 3 output parameters: xn, yn, zn (all of type real). \n\nTo rotate the frame, perform the following steps within the subroutine:\n1. Initialize variables x1, y1, and z1 to the values of x_in, y_in, and z_in, respectively.\n2. Compute the new values of x2, y2, and z2 as follows:\n   - x2 = x1 * ctheta + z1 * stheta\n   - y2 = y1\n   - z2 = -x1 * stheta + z1 * ctheta\n3. Finally, compute the values of xn, yn, and zn as follows:\n   - xn = x2 * cphi - y2 * sphi\n   - yn = x2 * sphi + y2 * cphi\n   - zn = z2\n\nRemember to declare the variables and specify their type using the implicit none statement.",
            "Please create a Fortran subroutine called \"unrotate_frame\" that rotates a coordinate frame using input angles phi and theta. The subroutine accepts 7 input parameters: \n- x_in, y_in, z_in of type real (kind=8)\n- stheta, ctheta, sphi, cphi of type real (kind=8)\n\nThe subroutine also has 3 output parameters:\n- xn, yn, zn of type real (kind=8)\n\nThe \"unrotate_frame\" subroutine performs the following steps:\n1. Initialize the variables x1, y1, and z1 with the input values x_in, y_in, and z_in respectively.\n2. Compute the rotated coordinates x2, y2, and z2 using the formulas:\n   - x2 = x1 * ctheta + z1 * stheta\n   - y2 = y1\n   - z2 = -x1 * stheta + z1 * ctheta\n3. Compute the final rotated coordinates xn, yn, and zn using the formulas:\n   - xn = x2 * cphi - y2 * sphi\n   - yn = x2 * sphi + y2 * cphi\n   - zn = z2\n\nPlease implement the \"unrotate_frame\" subroutine according to these instructions."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real*8 :: x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn\n    ! Test case 1\n    x = 1.0\n    y = 0.0\n    z = 0.0\n    stheta = 0.0\n    ctheta = 1.0\n    sphi = 0.0\n    cphi = 1.0\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n\n    ! Test case 2\n    x = 0.0\n    y = 1.0\n    z = 0.0\n    stheta = 1.0\n    ctheta = 0.0\n    sphi = 1.0\n    cphi = 0.0\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 3\n    x = 1.0\n    y = 1.0\n    z = 1.0\n    stheta = 0.5\n    ctheta = 0.866\n    sphi = 0.707\n    cphi = 0.707\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 4\n    x = 2.0\n    y = 3.0\n    z = 1.0\n    stheta = 0.258\n    ctheta = 0.966\n    sphi = 0.866\n    cphi = 0.5\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\n    \n    ! Test case 5\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    stheta = -0.5\n    ctheta = 0.866\n    sphi = -0.707\n    cphi = -0.707\n    call unrotate_frame(x, y, z, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    print *, xn, yn, zn\n    print *, \"&\"\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-1.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.25876200392293924        1.6727620382552146       0.36599999666213989",
                "-1.5029999762773514        3.3965400164341926       0.45000004768371582",
                "-0.44823801324319845       0.96576202108907694       -1.3659999966621399"
            ]
        },
        "code": "  subroutine unrotate_frame(x_in, y_in, z_in, stheta, ctheta, sphi, cphi, xn, yn, zn)\n!     \n!\n!     -----description: rotates the frame using input angles\n!          phi and theta\n!\n!\n!          on input:  \n!\n!          on output:\n!          \n!\n!     ----------------------------------------------------------------\n!\n    implicit none\n!\n!     -----variable declarations\n!          ---------------------\n!\n    real (kind=8), intent(in) :: x_in, y_in, z_in\n    real (kind=8), intent(in) :: stheta, ctheta, sphi, cphi\n    real (kind=8), intent(out) :: xn, yn, zn\n\n    real (kind=8) :: x1, y1, z1\n    real (kind=8) :: x2, y2, z2\n!\n!     ----------------------------------------------------------------\n!\n\n    x1 = x_in\n    y1 = y_in\n    z1 = z_in\n\n    x2  =   x1 * ctheta +  z1 * stheta\n    y2  =   y1\n    z2  =  -x1 * stheta +  z1 * ctheta\n\n    xn  =   x2  * cphi -  y2 * sphi\n    yn  =   x2  * sphi +  y2 * cphi\n    zn  =   z2\n    \n    return\n\n  end subroutine unrotate_frame\n",
        "answer": "subroutine unrotate_frame(x_in, y_in, z_in, stheta, ctheta, sphi, cphi, xn, yn, zn)\n    implicit none\n    real (kind=8), intent(in) :: x_in, y_in, z_in, stheta, ctheta, sphi, cphi\n    real (kind=8), intent(out) :: xn, yn, zn\n\n    xn = x_in*cphi + y_in*sphi\n    yn = y_in*cphi - x_in*sphi\n    zn = z_in\n\n    return\nend subroutine unrotate_frame\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called gram_schmidt that performs the Gram-Schmidt orthogonalization process on a given matrix. The subroutine takes four parameters as input: an integer n representing the number of rows in the matrix, an integer m representing the number of columns in the matrix, a double precision two-dimensional array u_in containing the input matrix, and a double precision two-dimensional array u_out that will store the output matrix after the orthogonalization process. The subroutine does not return a value.\n\nIn the subroutine, create local variables i and j. Then, iterate over each column of the input matrix using the outer loop (j loop) and copy the corresponding column to the output matrix. Inside the outer loop, if j is greater than 1, iterate over each previous column (i loop) and subtract the projection of the j-th column onto each previous column from the j-th column of the output matrix. After the i loop, normalize the j-th column of the output matrix by dividing it by its Euclidean norm using the sqrt and dot_product functions.\n\nEnsure that the output matrix u_out is updated correctly at each step of the Gram-Schmidt orthogonalization process.",
            "Provide a Fortran subroutine code called gram_schmidt that performs the Gram-Schmidt process on a matrix. The subroutine takes in four parameters: \n- The first parameter is the input matrix u_in, which is a two-dimensional array of double precision numbers. It is passed by reference with the intent of being read.\n- The second parameter is the integer n, which represents the number of rows in the matrix.\n- The third parameter is the integer m, which represents the number of columns in the matrix.\n- The fourth parameter is the output matrix u_out, which is also a two-dimensional array of double precision numbers. It is passed by reference with the intent of being modified.\n\nWithin the subroutine, we have local variables i and j. The subroutine then loops over the columns of the input matrix u_in and assigns them to the output matrix u_out. \n\nNext, there is an inner loop that performs the Gram-Schmidt process on the output matrix. For each column j, if j is greater than 1, it subtracts the projection of the column onto the previous columns from the column itself. This step orthogonalizes the vectors. \n\nAfter that, the resulting column is normalized by dividing it by its magnitude. This step ensures that the resulting vectors are orthogonal and unit vectors.\n\nFinally, the subroutine returns to the calling program.\n\nYou can use this subroutine to perform the Gram-Schmidt process on a matrix in your Fortran program.",
            "Create a Fortran subroutine called \"gram_schmidt\" that performs the Gram-Schmidt process on a given matrix. The subroutine takes in four parameters: \n- \"u_in\" is a two-dimensional array of double precision real numbers, representing the input matrix. \n- \"n\" and \"m\" are integers representing the number of rows and columns of the matrix, respectively. \n- \"u_out\" is a two-dimensional array of double precision real numbers, representing the output matrix after applying the Gram-Schmidt process.\n\nWithin the subroutine, the code initializes the \"u_out\" matrix with the values from \"u_in\". It then performs the Gram-Schmidt process on each column of the matrix. \n\nThe subroutine uses loops to iterate through the columns and rows of the matrix, performing calculations to orthogonalize the vectors. The dot product and square root functions are used to compute the necessary operations.\n\nThe subroutine modifies the \"u_out\" matrix, updating it with the orthogonalized vectors. \n\nThe subroutine does not return any values explicitly, but the updated \"u_out\" matrix is passed as an output parameter.\n\nTo use the subroutine, provide the input matrix \"u_in\", the dimensions \"n\" and \"m\", and an empty matrix \"u_out\" to store the orthogonalized vectors. After calling the subroutine, the \"u_out\" matrix will contain the result of the Gram-Schmidt process."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: n = 3\n    integer, parameter :: m = 2\n    double precision :: u_in(n,m), u_out(n,m)\n    integer :: i, j\n    \n    ! Test case 1\n    u_in = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 2\n    u_in = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 3\n    u_in = reshape([2.0, -3.0, 1.0, 4.0, 3.0, -1.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 4\n    u_in = reshape([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"\n    \n    ! Test case 5\n    u_in = reshape([3.0, -2.0, 1.0, -1.0, 2.0, -3.0], [n, m])\n    call gram_schmidt(u_in, n, m, u_out)\n    do i = 1, n\n        do j = 1, m\n            print *, u_out(i, j)\n        end do\n    end do\n    print *, \"&\"    \n    \nend program main",
            "result": [
                "1.0000000000000000     \n   0.0000000000000000     \n   0.0000000000000000     \n   1.0000000000000000     \n   0.0000000000000000     \n   0.0000000000000000",
                "0.26726124191242440     \n  0.87287156094396945     \n  0.53452248382484879     \n  0.21821789023599208     \n  0.80178372573727319     \n -0.43643578047198506",
                "0.53452248382484879     \n  0.84515425472851669     \n -0.80178372573727319     \n  0.50709255283711008     \n  0.26726124191242440     \n -0.16903085094570336",
                "0.57735026918962584     \n -0.57735026918962584     \n  0.57735026918962584     \n -0.57735026918962584     \n  0.57735026918962584     \n -0.57735026918962584",
                "0.80178372573727319     \n  0.43643578047198489     \n -0.53452248382484879     \n  0.21821789023599228     \n  0.26726124191242440     \n -0.87287156094396945"
            ]
        },
        "code": "  subroutine gram_schmidt(u_in, n, m, u_out)\n    implicit none\n    integer,          intent(in)                 :: n,m\n    double precision, dimension(n,m),intent(in)  :: u_in\n    double precision, dimension(n,m),intent(out) :: u_out    \n\n    !! local variables\n    integer :: i,j\n\n    do i = 1, m\n       u_out(:,i) = u_in(:,i)\n    end do\n\n    do j = 1, m\n       if(j .gt. 1)then\n          do i = 1, j-1\n             u_out(:,j) = u_out(:,j) - dot_product(u_out(:,j), u_out(:,i))*u_out(:,i)\n          end do\n       end if\n       u_out(:,j) = u_out(:,j)/sqrt(dot_product(u_out(:,j),u_out(:,j)))\n    end do\n\n    return\n    \n  end subroutine gram_schmidt\n",
        "answer": "subroutine gram_schmidt(n, m, u_in, u_out)\n    integer, intent(in) :: n, m\n    double precision, intent(in) :: u_in(n,m)\n    double precision, intent(out) :: u_out(n,m)\n    integer :: i, j\n    double precision :: norm\n\n    do j = 1, m\n        u_out(:,j) = u_in(:,j)\n        do i = 1, j-1\n            u_out(:,j) = u_out(:,j) - dot_product(u_out(:,i), u_in(:,j)) * u_out(:,i)\n        end do\n        norm = sqrt(dot_product(u_out(:,j), u_out(:,j)))\n        u_out(:,j) = u_out(:,j) / norm\n    end do\nend subroutine gram_schmidt\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called \"check_even\" that determines whether a given number is even or odd. The subroutine takes one input parameter, \"num\", which is an integer. It also has one output parameter, \"pass\", which is a logical value. \n\nIn the subroutine, check if the given number is divisible by 2 using modulo operation. If the result is equal to 0, set the output parameter \"pass\" to true, indicating that the number is even. Otherwise, set \"pass\" to false, indicating that the number is odd.",
            "Please write a Fortran subroutine called \"check_even\" that determines whether a given number is even or not. The subroutine should have 2 input parameters. The first parameter is an integer called \"num\", which represents the number to be checked. The second parameter is a logical variable called \"pass\" and is used as the output. The subroutine should check if the input number is divisible by 2, and if so, set the \"pass\" variable to true; otherwise, set it to false.",
            "Write a Fortran subroutine called \"check_even\" that checks whether a given number is even or not. The subroutine takes an input parameter, \"num\", which is an integer, and an output parameter, \"pass\", which is a logical variable. \n\nTo determine if the number is even, use the Fortran modulo function and check if the remainder when dividing \"num\" by 2 is equal to 0. \n\nInside the subroutine, assign the result of this comparison to the \"pass\" variable. If the comparison is true, \"pass\" will be set to true, indicating that the number is even. If the comparison is false, \"pass\" will be set to false, indicating that the number is not even."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: number\n    logical :: is_even\n    ! Test case 1\n    number = 10\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n\n    ! Test case 2\n    number = 7\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 3\n    number = 0\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 4\n    number = -6\n    call even(number, is_even)\n    print *, is_even\n    print *, \"&\"\n    \n    ! Test case 5\n    number = 15\n    call even(number, is_even)\n    print *, is_even\nend program main",
            "result": [
                "T",
                "F",
                "T",
                "T",
                "F"
            ]
        },
        "code": "subroutine even(num, pass)\n  implicit none\n  integer, intent(in)  :: num\n  logical, intent(out) :: pass\n\n  pass = modulo(num,2) == 0\n  \nend subroutine even\n",
        "answer": "subroutine check_even(num, pass)\n    integer, intent(in) :: num\n    logical, intent(out) :: pass\n\n    if (modulo(num, 2) == 0) then\n        pass = .true.\n    else\n        pass = .false.\n    end if\nend subroutine check_even\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called cubito that calculates the cube of a given number. The subroutine takes one input parameter of type real, named xx, and one output parameter also of type real, named ww.",
            "Please provide a Fortran subroutine called cubito that calculates the cube of a given number. The subroutine has 2 input parameters and no output parameters. The first parameter, xx, is of type real and is passed by value. The second parameter, ww, is also of type real and is passed by reference.",
            "Provide a Fortran subroutine code called cubito that calculates the cube of a given number. The subroutine has 2 parameters, both of type real. The first parameter, xx, is an input parameter representing the number to be cubed. The second parameter, ww, is an output parameter representing the result of cubing xx. The subroutine uses the Fortran keyword \"subroutine\" and follows the imperative programming style."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    real :: input, output\n    ! Test case 1\n    input = 2.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n\n    ! Test case 2\n    input = -3.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 3\n    input = 0.5\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 4\n    input = 4.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\n    \n    ! Test case 5\n    input = -1.0\n    call cubito(input, output)\n    print *, output\n    print *, \"&\"\nend program main",
            "result": [
                "8.00000000",
                "-27.0000000",
                "0.125000000",
                "64.0000000",
                "-1.00000000"
            ]
        },
        "code": "subroutine cubito(xx, ww)\r\nimplicit none\r\n\r\nreal, intent(in) :: xx\r\nreal, intent(out) :: ww\r\n\r\nww = xx**3\r\n\r\nend subroutine cubito\n",
        "answer": "subroutine cubito(xx, ww)\n    implicit none\n    real, intent(in) :: xx\n    real, intent(out) :: ww\n    ww = xx**3\nend subroutine cubito\n\n"
    },
    {
        "instruction": [
            "Provide a Fortran subroutine code named abq_pml2d_1d_integrationpoints. This subroutine calculates the integration points and weights for a one-dimensional integration scheme used in a two-dimensional PML (perfectly matched layer) implementation. The subroutine takes in three input parameters: n_points of type integer, representing the number of integration points to be calculated; n_nodes of type integer, representing the number of nodes in the element. It also has two output parameters: xi, an array of type double precision, which stores the integration points; w, an array of type double precision, which stores the weights corresponding to each integration point.",
            "Provide a Fortran subroutine code called abq_pml2d_1d_integrationpoints to calculate the integration points and weights for 1-dimensional numerical integration. The subroutine has three input parameters and two output parameters. The first input parameter is an integer called n_points, which represents the desired number of integration points. The second input parameter is also an integer called n_nodes, which represents the number of nodes. The third input parameter is an array of type double precision called xi, which will store the integration points. The fourth input parameter is an array of type double precision called w, which will store the integration weights. The subroutine calculates the integration points and weights based on the value of n_points using a select case construct. The subroutine returns the calculated integration points and weights in the xi and w arrays, respectively.",
            "Provide a Fortran subroutine code named abq_pml2d_1d_integrationpoints. This subroutine calculates the integration points and weights for a one-dimensional integration scheme used in a two-dimensional PML (perfectly matched layer) implementation. The subroutine takes in three input parameters: n_points of type integer, representing the number of integration points to be calculated; n_nodes of type integer, representing the number of nodes in the element. It also has two output parameters: xi, an array of type double precision, which stores the integration points; w, an array of type double precision, which stores the weights corresponding to each integration point."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer :: n_points, n_nodes\n    double precision :: xi(6), w(6)\n\n    ! Test case 1\n    n_points = 2\n    n_nodes = 4\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 2\n    n_points = 3\n    n_nodes = 2\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 3\n    n_points = 4\n    n_nodes = 3\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 4\n    n_points = 5\n    n_nodes = 1\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\n\n    ! Test case 5\n    n_points = 6\n    n_nodes = 5\n    call abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    print *, xi(1), xi(2), xi(3), xi(4), xi(5), xi(6)\n    print *, w(1), w(2), w(3), w(4), w(5), w(6)\n    print *, \"&\"\nend program main",
            "result": [
                "0.57735026918962573      -0.57735026918962573        0.0000000000000000        1.5902226617571677E-316   1.5902231064162490E-316   1.5902320984110033E-316\n   1.0000000000000000        1.0000000000000000        0.0000000000000000        0.0000000000000000        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.77459666924148340        0.0000000000000000      -0.77459666924148340        1.5902226617571677E-316   1.5902231064162490E-316   1.5902320984110033E-316\n  0.55555555555555558       0.88888888888888884       0.55555555555555558        0.0000000000000000        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.86113631159405257       0.33998104358485631      -0.33998104358485631      -0.86113631159405257        1.5902231064162490E-316   1.5902320984110033E-316\n  0.34785484513745379       0.65214515486254609       0.65214515486254609       0.34785484513745379        6.9527834229567387E-310   2.0731468802518713E-317",
                "0.90617984593866396       0.53846931010568311        0.0000000000000000      -0.53846931010568311      -0.90617984593866396        1.5902320984110033E-316\n  0.23692688505618911       0.47862867049936653       0.56888888888888889       0.47862867049936653       0.23692688505618911        2.0731468802518713E-317",
                "0.93246951420315205       0.66120938646626448       0.23861918608319690      -0.23861918608319690      -0.66120938646626448      -0.93246951420315205     \n  0.17132449237917030       0.36076157304813861       0.46791393457269098       0.46791393457269098       0.36076157304813861       0.17132449237917030"
            ]
        },
        "code": "      subroutine abq_pml2d_1d_integrationpoints(n_points,n_nodes,xi,w)\n\n\n      implicit none\n      integer, intent(in) :: n_points\n      integer, intent(in) :: n_nodes\n\n      double precision, intent(out) :: xi(*)\n      double precision, intent(out) :: w(*)\n\n      integer :: i,j,k,n\n\n      double precision x1d(4), w1d(4)\n\n\n\n      select case ( n_points )\n        case (2)\n            xi(1) = .5773502691896257d+00\n            xi(2) = -.5773502691896257d+00\n            w(1) = .1000000000000000d+01\n            w(2) = .1000000000000000d+01\n            return\n        case (3)\n            xi(1) = 0.7745966692414834d+00\n            xi(2) = .0000000000000000d+00\n            xi(3) = -.7745966692414834d+00\n            w(1) = .5555555555555556d+00\n            w(2) = .8888888888888888d+00\n            w(3) = .5555555555555556d+00\n            return\n        case (4)\n            xi(1) = .8611363115940526d+00\n            xi(2) = .3399810435848563d+00\n            xi(3) = -.3399810435848563d+00\n            xi(4) = -.8611363115940526d+00\n            w(1) = .3478548451374538d+00\n            w(2) = .6521451548625461d+00\n            w(3) = .6521451548625461d+00\n            w(4) = .3478548451374538d+00\n            return\n        case (5)\n            xi(1) = .9061798459386640d+00\n            xi(2) = .5384693101056831d+00\n            xi(3) = .0000000000000000d+00\n            xi(4) = -.5384693101056831d+00\n            xi(5) = -.9061798459386640d+00\n            w(1) = .2369268850561891d+00\n            w(2) = .4786286704993665d+00\n            w(3) = .5688888888888889d+00\n            w(4) = .4786286704993665d+00\n            w(5) = .2369268850561891d+00\n            return\n        case (6)\n            xi(1) = .9324695142031521d+00\n            xi(2) = .6612093864662645d+00\n            xi(3) = .2386191860831969d+00\n            xi(4) = -.2386191860831969d+00\n            xi(5) = -.6612093864662645d+00\n            xi(6) = -.9324695142031521d+00\n            w(1) = .1713244923791703d+00\n            w(2) = .3607615730481386d+00\n            w(3) = .4679139345726910d+00\n            w(4) = .4679139345726910d+00\n            w(5) = .3607615730481386d+00\n            w(6) = .1713244923791703d+00\n            return\n        case default\n            write(6,*)'error in routine abq_pml2d_1d_integrationpoints'\n            write(6,*) ' invalid number of integration points for 1d'\n            write(6,*) ' n_points must be between 1 and 6'\n            stop\n      end select\n\n\n      end subroutine abq_pml2d_1d_integrationpoints\n",
        "answer": "subroutine abq_pml2d_1d_integrationpoints(n_points, n_nodes, xi, w)\n    integer, intent(in) :: n_points, n_nodes\n    double precision, intent(out) :: xi(n_points), w(n_points)\n    integer :: i\n\n    do i = 1, n_points\n        xi(i) = -1.0d0 + 2.0d0 * (i - 0.5d0) / n_points\n    end do\n\n    do i = 1, n_points\n        w(i) = 2.0d0 / n_points\n    end do\nend subroutine abq_pml2d_1d_integrationpoints\n\n"
    },
    {
        "instruction": [
            "Write a Fortran subroutine called lagrange_any that computes the Lagrange interpolants and their first derivatives at a given point. The subroutine requires 4 input parameters: xi of type double precision, ngll of type integer, and two arrays xigll, hprime of type double precision. The subroutine also has 3 output parameters: h and hprime, both arrays of type double precision.",
            "Write a Fortran subroutine called \"lagrange_any\" that calculates the Lagrange interpolants and their first derivatives at any given point within the range [-1, 1]. The subroutine takes 5 parameters: \"xi\" (a double precision variable) as the input point, \"ngll\" (an integer) as the size of the array, \"xigll\" (an array of double precision) as the input array of interpolation points, and \"h\" and \"hprime\" (both arrays of double precision) as the output arrays to store the calculated interpolants and their derivatives, respectively. \n\nHere's the summary of the subroutine:\n1. Initialize local variables and arrays.\n2. Iterate through each index \"dgr\" from 1 to \"ngll\".\n3. Compute the Lagrange interpolant \"h(dgr)\" by evaluating the product of (xi - x) for all elements in \"xigll\" except the element at index \"dgr\". Use the inverse of the product of (x0 - x) to avoid additional divisions.\n4. Compute the first derivative \"hprime(dgr)\" by summing the products of (xi - xigll(j)) for all elements in \"xigll\" except the elements at indices \"dgr\" and \"i\". Multiply the sum by the inverse of the product of (x0 - x) obtained in step 3.\n5. Repeat steps 3 and 4 for all indices in \"xigll\".\n6. End the subroutine.\n\nRemember to specify the input and output parameter types and names when implementing the subroutine.",
            "Write a Fortran subroutine called \"lagrange_any\" that calculates the Lagrange interpolants and their first derivatives at a given point \"xi\" in the interval [-1,1]. The subroutine takes in 4 input parameters: \"xi\" of type double precision, \"ngll\" of type integer, \"xigll\" of type double precision array with size \"ngll\", and two output parameters: \"h\" and \"hprime\", both of type double precision arrays with size \"ngll\".\n\nHere's what the subroutine does:\n1. It initializes some local variables and loops over the degrees of freedom (dgr) from 1 to \"ngll\".\n2. Inside the loop, it calculates the Lagrange interpolants by iterating over all the elements in \"xigll\" array except the current degree of freedom.\n3. It calculates the product of (xi - x) and (x0 - x) for each element in the loop to get \"prod1\" and \"prod2\" respectively.\n4. It then calculates the inverse of \"prod2\" and stores it in \"prod2_inv\".\n5. It calculates the Lagrange interpolant for the current degree of freedom by multiplying \"prod1\" with \"prod2_inv\" and stores it in \"h(dgr)\".\n6. It calculates the first derivatives by iterating over all the elements in \"xigll\" array except the current degree of freedom.\n7. Inside this nested loop, it calculates the product of (xi - xigll(j)) for each element in the loop except the current degree of freedom and the one being iterated in the outer loop.\n8. It accumulates the sum of these products in the variable \"sum\".\n9. Finally, it multiplies the \"sum\" with \"prod2_inv\" and stores it in \"hprime(dgr)\".\n\nMake sure to provide the appropriate input and output parameters when calling this subroutine."
        ],
        "test_case": {
            "unit_test": "program main\n    use test_subroutine\n    implicit none\n    integer, parameter :: ngll = 4\n    real*8 :: xi, xigll(ngll), h(ngll), hprime(ngll)\n    \n    ! Test case 1\n    xi = 0.5\n    xigll = [0.0, 0.25, 0.5, 0.75]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 2\n    xi = -0.3\n    xigll = [-1.0, -0.75, -0.5, -0.25]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 3\n    xi = 1.0\n    xigll = [0.0, 0.5, 0.75, 1.0]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 4\n    xi = -0.8\n    xigll = [-0.75, -0.5, -0.25, 0.0]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \n    ! Test case 5\n    xi = 0.9\n    xigll = [0.5, 0.75, 1.0, 1.25]\n    call lagrange_any(xi, ngll, xigll, h, hprime)\n    print *, h\n    print *, hprime\n    print *, \"&\"\n    \nend program main",
            "result": [
                "0.0000000000000000       -0.0000000000000000        1.0000000000000000        0.0000000000000000     \n  0.66666666666666663       -4.0000000000000000        2.0000000000000000        1.3333333333333333",
                "4.8000007311502182E-002 -0.22400003623962017       0.50400009822844960       0.67199993069966846     \n -0.61333318074544718        3.0399993515014785       -8.2399991607666152        5.8133329900105837",
                "-0.0000000000000000        0.0000000000000000       -0.0000000000000000        1.0000000000000000     \n -0.33333333333333331        4.0000000000000000       -10.666666666666666        7.0000000000000000",
                "1.4080001074473087      -0.70400019359589261       0.38400011253357458       -8.8000026384990784E-002\n  -9.0133337529500359        16.240001068115248       -9.4400008773803847        2.2133335622151735",
                "-5.6000008265175594E-002  0.44800011062621981       0.67199989891051881       -6.4000001271563023E-002\n  0.34666651407875781       -4.6399999237060001        4.2400003051757267        5.3333104451515581E-002"
            ]
        },
        "code": "  subroutine lagrange_any(xi,ngll,xigll,h,hprime)\n\n! and their first derivatives at any point xi in [-1,1]\n\n  implicit none\n\n  double precision,intent(in) :: xi\n\n  integer,intent(in) :: ngll\n  double precision,dimension(ngll),intent(in) :: xigll\n  double precision,dimension(ngll),intent(out) :: h,hprime\n\n  ! local parameters\n  integer :: dgr,i,j\n  double precision :: prod1,prod2,prod3\n  double precision :: prod2_inv\n  double precision :: sum\n  double precision :: x0,x\n\n! note: this routine is hit pretty hard by the mesher, optimizing the loops here will be beneficial\n\n  do dgr = 1,ngll\n\n    prod1 = 1.0d0\n    prod2 = 1.0d0\n\n    ! lagrangian interpolants\n    x0 = xigll(dgr)\n    do i = 1,ngll\n      if (i /= dgr) then\n        x = xigll(i)\n        prod1 = prod1*(xi-x)\n        prod2 = prod2*(x0-x)\n      endif\n    enddo\n\n    ! takes inverse to avoid additional divisions\n    ! (multiplications are cheaper than divisions)\n    prod2_inv = 1.d0/prod2\n\n    h(dgr) = prod1 * prod2_inv\n\n    ! first derivatives\n    sum = 0.0d0\n    do i = 1,ngll\n      if (i /= dgr) then\n        prod3 = 1.0d0\n        do j = 1,ngll\n          if (j /= dgr .and. j /= i) prod3 = prod3*(xi-xigll(j))\n        enddo\n        sum = sum + prod3\n      endif\n    enddo\n\n    hprime(dgr) = sum * prod2_inv\n\n  enddo\n\n  end subroutine lagrange_any\n",
        "answer": "subroutine lagrange_any(xi, ngll, xigll, hprime, h)\n    implicit none\n    integer, intent(in) :: ngll\n    double precision, intent(in) :: xi, xigll(ngll)\n    double precision, intent(out) :: hprime(ngll), h(ngll)\n    integer :: i, j\n\n    do i = 1, ngll\n        h(i) = 1.0\n        do j = 1, ngll\n            if (j /= i) then\n                h(i) = h(i) * (xi - xigll(j)) / (xigll(i) - xigll(j))\n            end if\n        end do\n    end do\n\n    do i = 1, ngll\n        hprime(i) = 0.0\n        do j = 1, ngll\n            if (j /= i) then\n                hprime(i) = hprime(i) + h(j) / (xigll(i) - xigll(j))\n            end if\n        end do\n    end do\nend subroutine lagrange_any\n\n"
    }
]