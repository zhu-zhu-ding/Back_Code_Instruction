[{"instruction": "Create a Fortran subroutine named core_guess to generate an initial guess for the Fock operator based on the core Hamiltonian. The subroutine takes 2 input parameters: an integer kf representing the basis set size, and a real*8 2D array hc representing the core Hamiltonian. It also has 1 output parameter: a real*8 2D array f representing the initial guess for the Fock operator.", "input": "", "output": "    subroutine core_guess(kf,hc,f)\n        ! ----------------------------\n        ! core hamiltonian\n        ! ----------------------------\n        !\n        ! source:\n        !   a. szabo and n. s. ostlund\n        !   modern quantum chemistry\n        !   dover\n        !   1996\n        !\n        !-----------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        ! initial guess: core hamiltonian\n        f = hc\n\n    end subroutine core_guess\n"}, {"instruction": "Write a Fortran subroutine named trisolve to solve a constant coefficient, periodic domain, tridiagonal linear system. The subroutine takes 5 input parameters: n (integer), a (real*8 array), b (real*8 array), c (real*8 array), and r (real*8 array). It also has 1 output parameter: x (real*8 array). \n\nThe subroutine uses forward and backward elimination sweeps to solve the tridiagonal linear system. It performs computations based on the values of a, b, c, and r arrays. The final solution is stored in the x array.\n\nYour task is to provide the implementation of the trisolve subroutine by filling in the necessary calculations and assignments.", "input": "", "output": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"}, {"instruction": "Write a Fortran subroutine called lin1db that performs linear interpolation on a one-dimensional bounded domain. The subroutine takes 4 input arguments: n (integer), xg (real*8 array), xd (real*8 array), and q (real*8 array). It also has 1 output argument, qnew (real*8 array).\n\nThe subroutine calculates the interpolation of the quantity q based on the given departure points xd and the grid points xg. It determines the indices of the departure points on the grid and computes the interpolation using the nearby grid points. The interpolated values are stored in the qnew array.\n\nTo use the subroutine, provide the number of grid points (n), the grid points (xg), the departure points (xd), and the quantity values (q). After the subroutine is called, the interpolated values will be stored in the qnew array.\n\nMake sure that the input and output arguments have the correct data types and dimensions to ensure proper execution of the subroutine.", "input": "", "output": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"}, {"instruction": "Write a Fortran subroutine named residual that calculates the residual for an elliptic problem. \n\nThe subroutine takes 10 input parameters: nx and ny (both integers), nnx and nny (both integers), ff (real*8 array of size nx by ny), rf (real*8 array of size nx by ny), a, b, c, and nu (all real*8). It also has 1 output parameter called resf (real*8 array of size nx by ny).\n\nThe subroutine computes the residual for the elliptic problem using the input parameters and stores the result in the resf array.\n\nTo compute the residual, the subroutine performs calculations for the first row, middle rows, and last row separately, using different formulas based on the values of a, b, c, and nu.\n\nThe subroutine uses loops to iterate over each element of the arrays and perform the necessary calculations.\n\nEnsure that the subroutine is properly implemented and that the indexes of the arrays are handled correctly to avoid out-of-bounds errors.\n\n", "input": "", "output": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}, {"instruction": "Write a Fortran subroutine named \"uvatphi\" that averages the values of \"u\" and \"v\" arrays on a C-grid and stores the results in \"up\" and \"vp\" arrays. The subroutine takes 4 input parameters: \"nx\" and \"ny\" of type integer, and \"u\" and \"v\" of type real*8. It also has 2 output parameters: \"up\" and \"vp\" of type real*8. \n\nWithin the subroutine, it is assumed that the polar values of \"v\" have been previously defined by calling a function named \"polar\". \n\nThe subroutine loops over the \"u\" and \"v\" arrays, averaging the values at each point and storing the results in \"up\" and \"vp\" arrays, respectively. \n\nMake sure to include the \"implicit none\" statement at the beginning of the subroutine to enforce explicit declaration of variables.", "input": "", "output": "subroutine uvatphi(nx,ny,u,v,up,vp)\n\n  ! to average u and v to phi points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: up(nx,ny), vp(nx,ny)\n\n  integer :: i, ip, j, jp\n\n  ! assume polar values of v have been defined by a previous\n  ! call to polar, e.g. within cgridave\n\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        ip = i+1\n        if ( i == nx ) ip = 1\n        up(i,j) = 0.5*(u(i,j) + u(ip,j))\n        vp(i,j) = 0.5*(v(i,j) + v(i,jp))\n     enddo\n  enddo\n\nend subroutine uvatphi\n"}, {"instruction": "Write a Fortran subroutine named sph2cart to convert geographical coordinates (latitude and longitude) to Cartesian coordinates. The subroutine takes 2 input parameters of type real (8) representing the latitude and longitude in radians. It also has 3 output parameters of type real (8) representing the Cartesian coordinates (x, y, and z) in the range -1 to 1, where x^2 + y^2 + z^2 = 1. The subroutine uses the cosine and sine functions from the Fortran standard library to perform the conversion.", "input": "", "output": "subroutine sph2cart (lon, lat, x, y, z )\n  !------------------------------------------------------------------------------------\n  ! sph2cart\n  !\n  !     transforms geographical coordinates (lat,lon) to cartesian coordinates.\n  !     similar to stripack's trans\n  !\n  !    input: lat, latitudes of the node in radians [-pi/2,pi/2]\n  !           lon, longitudes of the nodes in radians [-pi,pi]\n  !\n  !    output:  x, y, z, the coordinates in the range -1 to 1.\n  !                    x**2 + y**2 + z**2 = 1\n  !\n  !   p. peixoto 2015\n  !---------------------------------------------------------------------\n  real (8), intent(in) :: lon\n  real (8), intent(in) :: lat\n  real (8), intent(out) :: x\n  real (8), intent(out) :: y\n  real (8), intent(out) :: z\n  real (8):: coslat\n\n  coslat = dcos (lat)\n  x = coslat * dcos (lon)\n  y = coslat * dsin (lon)\n  z = dsin (lat)\n\n  return\nend subroutine sph2cart\n"}, {"instruction": "Create a Fortran subroutine named bondseek to analyze the spatial positions of particles and count the number of bonds within specified distance ranges. The number of input arguments is 4 with test_data types ['integer*4', 'real*8', 'real*8', 'real*8'], and the number of output arguments is 1 with test_data type ['integer*4'].", "input": "", "output": "subroutine bondseek(n,positions,r0,r1,bn)\n\n    implicit none\n\n    integer*4, intent(in)       :: n\n    real*8,    intent(in)       :: r0,r1\n    real*8,    intent(in)       :: positions(n,3)\n\n    integer*4 :: i,j,k\n    integer*4, intent(out) :: bn\n\n    real*8 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n\n    bn = 0\n\n    do i = 1, (n - 1)\n        xi = positions(i,1)\n        yi = positions(i,2)\n        zi = positions(i,3)\n        do j = 1, n\n            if (i .ge. j) cycle\n            xj = positions(j,1)\n            yj = positions(j,2)\n            zj = positions(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = sqrt(dx * dx + dy * dy + dz * dz)\n\n            if (mdl .ge. r0 .and. mdl .le. r1) bn = bn + 1\n\n        end do\n    end do\n    return\nend subroutine bondseek\n"}, {"instruction": "Create a Fortran subroutine named calc_xika to perform complex calculations for a scientific application. The subroutine has 9 input parameters of types ['integer', 'integer', 'integer', 'real(8), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1)', 'real(8), dimension(0:ncomp-1)', 'real(8), dimension(0:ncomp-1,0:nbeads-1)', 'real(8), dimension(0:nbeads-1,0:nsitemax-1)', 'real(8), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1)', 'real(8)'], and 2 output parameters of types ['real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)', 'real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)']. The subroutine performs a series of nested calculations involving the input arrays and returns the results in the output arrays.", "input": "", "output": "subroutine calc_xika(xika0,xi,rho,nui,nk,delta,obj_func,xika,ncomp,nbeads,nsitemax)\n    implicit none\n    integer,intent(in) :: ncomp, nbeads, nsitemax\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika0\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    real(8), intent(in) :: rho\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: obj_func\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: xika\n    integer :: i,k,a,j,l,b\n    \n    !initialize xika to 1.0\n    xika=1.0\n    \n    do i=0, ncomp-1\n        do k=0, nbeads-1\n            do a=0, nsitemax-1\n                do j=0, ncomp-1\n                    do l=0, nbeads-1\n                        do b=0, nsitemax-1\n                            xika(i,k,a)=xika(i,k,a) + (rho * xi(j) * nui(j,l) * nk(l,b) * xika0(j,l,b) * delta(i,j,k,l,a,b))\n                        enddo\n                    enddo\n                enddo\n            enddo\n        enddo\n    enddo\n    xika = (1.0/xika)\n    \n    obj_func = xika - xika0\n    \nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"analyt\" to calculate the seismic wave velocities and density at different depths based on the given medium type and the number of layers. The number of input parameters is 2, of type ['integer', 'integer']. The number of output parameters is 3, of types ['real     (kind=8)', 'complex  (kind=8)', 'complex  (kind=8)'].", "input": "", "output": "subroutine analyt( cp, cs, rho, medium, n1 )\r\n\r\n  !     munk profile\r\n\r\n  !     returns\r\n  !        cs, cp, rho at depths i*h i = 1, n\r\n  !        depths of interfaces\r\n\r\n  implicit none\r\n  integer,           intent(in)  :: medium, n1\r\n  real     (kind=8), intent(out) :: rho( * )\r\n  complex  (kind=8), intent(out) :: cp( * ), cs( * )\r\n  integer                        :: i, n\r\n  real     (kind=8), parameter   :: eps = 0.00737\r\n  real     (kind=8)              :: h, x, z\r\n\r\n  n = n1 - 1\r\n\r\n  select case ( medium )\r\n\r\n  case ( 1 )   ! the ocean\r\n     h = 5000.0 / n\r\n     do i = 1, n1\r\n        z = ( i - 1 ) * h\r\n        x = 2.0 * ( z - 1300.0 ) / 1300.0\r\n        cp(  i ) = 1500.0 * ( 1.0 + eps * ( x - 1.0 + exp( -x ) ) )\r\n        cs(  i ) = 0.0\r\n        rho( i ) = 1.0\r\n     end do\r\n     return\r\n\r\n  case ( 2 )   ! the fluid half-space\r\n     cp(  1 ) = 1551.91\r\n     cs(  1 ) = 0.0\r\n     rho( 1 ) = 1.0e20\r\n     return\r\n\r\n  case( 9 )  ! an elastic layer\r\n     h = 1000.0 / n\r\n     z = 5000.0\r\n\r\n     do i = 1,n+1\r\n        cp( i ) = 4700.0 + ( z - 5000.0 ) / 10.0\r\n        cs( i ) = 2000.0 + ( z - 5000.0 ) / 10.0\r\n        cp( i ) = 4700.0\r\n        cs( i ) = 2000.0\r\n        rho( i ) = 2.0\r\n        z = z + h\r\n     end do\r\n  end select\r\n\r\nend subroutine analyt\r\n"}, {"instruction": "Create a Fortran subroutine named \"insertionsort\" to perform the insertion sort algorithm on an array of integers. The subroutine will take 2 input parameters of type integer array and an additional input parameter of type integer to specify the size of the array. It will also have 1 output parameter of type integer array.", "input": "", "output": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"}, {"instruction": "Write a Fortran subroutine named \"blocksplitter\" to split a given number of rows into multiple intervals based on the specified number of threads and interval parameters. The subroutine should take 3 input parameters of type integer (inorows, ithreads, iparam) and 1 output parameter of type integer with the allocatable attribute (oblocks). The inorows is the total number of rows, ithreads is the number of threads, and iparam is the interval parameter. The oblocks array will store the start and end indices of each interval. Use the imperative tone in the instructions.", "input": "", "output": "  subroutine blocksplitter(inorows,ithreads,iparam,oblocks)\r\n    !tue, september 2014\r\n    !splits inorows into ithreads intervals.\r\n    !each interval will have a length of iparam*n, where n is a natural number.\r\n    !the result will be saved in oblocks, where oblocks(i,1) is the start of the i'th interval and oblocks(i,2) is the end of the interval\r\n    !io\r\n    !update 2015 tue\r\n    !fixed the case if inorows < ithreads\r\n    implicit none\r\n    integer,intent(in)                :: inorows,ithreads\r\n    integer,intent(in)                :: iparam\r\n    integer,intent(out),allocatable       :: oblocks(:,:)\r\n    !local vars\r\n    integer                           :: i\r\n    integer                           :: blocksize\r\n    \r\n    blocksize=max(inorows/ithreads,1) \r\n    blocksize =mod(iparam-mod(blocksize,iparam),iparam)+blocksize\r\n    allocate(oblocks(ithreads,2))\r\n    do i=1,ithreads\r\n        oblocks(i,1) = (i-1)*(blocksize)+1\r\n        oblocks(i,2) = min(i*blocksize,inorows)\r\n    end do     \r\n    print*,'blocks',oblocks\r\n  end subroutine blocksplitter  \r\n"}, {"instruction": "Create a Fortran subroutine named \"apply_bprecondition_blut\" to perform forward and backward block solve operations using block LUT matrix. The subroutine takes 5 input parameters: an integer array iblocks, a real*8 array irhs, a real*8 array iluvals, an integer array iluidxs, and an integer array iludiag. It also has 1 output parameter: a real*8 array ox. The subroutine should solve the system using the provided block LU matrix and store the result in the output array ox.", "input": "", "output": "subroutine apply_bprecondition_blut(iblocks, irhs, ox, iluvals, iluidxs, iludiag) \r\n    !tue november 2014\r\n    !this routine does a forward and backward block solve with the block lut matrix\r\n    !\r\n    !io\r\n    !\r\n    !iblocks                 -> the blocksplitting of the matrix\r\n    !irhs                    -> the righthandside we update our solution after\r\n    !ox                      -> the output solution\r\n    !iluvals,iluidxs,iludiag -> the block lu matrix where each block is a separate matrix stored in modfied sparse row format.\r\n\tinteger,intent(in),dimension(:,:) :: iblocks\r\n    real*8,intent(in),dimension(:)    :: irhs\r\n    real*8,intent(out),dimension(:)   ::  ox\r\n    real*8,intent(in),dimension(:,:)  :: iluvals\r\n    integer,intent(in),dimension(:,:) :: iluidxs, iludiag    \r\n    !local variables\r\n    integer             :: i,k,j,threads,m,tmp\r\n    \r\n    \r\n    threads=size(iblocks,1)\r\n!$omp parallel if(startopenmp(2)) default(none)  shared(iblocks,threads,irhs,ox,iluvals,iluidxs,iludiag) private(k,i,j,m,tmp)\r\n!$omp do schedule(static)\r\n    do k=1,threads\r\n        do i = iblocks(k,1),iblocks(k,2)\r\n           ox(i) = irhs(i)\r\n        end do\r\n!\r\n! forward solve (with u^t)\r\n!\r\n       tmp=iblocks(k,1)-1\r\n       m=0\r\n        do i = iblocks(k,1),iblocks(k,2)\r\n           m=m+1\r\n           ox(i) = ox(i) * iluvals(m,k)\r\n           do j=iludiag(m,k),iluidxs(m+1,k)-1\r\n              ox(tmp+iluidxs(j,k)) = ox(tmp+iluidxs(j,k)) - iluvals(j,k)* ox(i)\r\n           end do\r\n        end do\r\n!     \r\n!     backward solve (with l^t)\r\n!    \r\n      do i = iblocks(k,2),iblocks(k,1),-1\r\n       m=i-tmp\r\n\t   do j=iluidxs(m,k),iludiag(m,k)-1\r\n              ox(tmp+iluidxs(j,k)) = ox(tmp+iluidxs(j,k)) - iluvals(j,k)*ox(i)\r\n       end do\r\n      end do\r\n    end do\r\n!$omp end do\r\n!$omp end parallel      \r\nend subroutine apply_bprecondition_blut  \r\n"}, {"instruction": "Create a Fortran subroutine named coordinate3dp to calculate the coordinates of points in a 3D grid. The subroutine takes 3 input parameters of type integer, integer, and real(8) and produces 10 output parameters of type real(8). The input parameters represent the grid dimensions and grid spacing, while the output parameters store the coordinates of the grid points.", "input": "", "output": "  subroutine coordinate3dp(imax,jmax,ds0,xcol,zcol,xs1,xs2,xs3,xs4,zs1,zs2,zs3,zs4)\n    implicit none\n    integer,intent(in)::imax,jmax\n    real(8),intent(in)::ds0\n    real(8),intent(out)::xcol(:),zcol(:)\n    real(8),intent(out)::xs1(:),xs2(:),xs3(:),xs4(:),zs1(:),zs2(:),zs3(:),zs4(:)\n    real(8)::dx,dz\n    integer::i,j,k\n\n    dx=ds0\n    dz=ds0\n    do i=1,imax\n      do j=1,jmax\n        k=(i-1)*jmax+j\n        xcol(k)=(i-imax/2-0.5d0)*dx\n        zcol(k)=-(j-jmax/2-0.5d0)*dz\n        xs1(k)=xcol(k)+0.5d0*dx\n        xs2(k)=xcol(k)-0.5d0*dx\n        xs3(k)=xcol(k)-0.5d0*dx\n        xs4(k)=xcol(k)+0.5d0*dx\n        zs1(k)=zcol(k)+0.5d0*dz\n        zs2(k)=zcol(k)+0.5d0*dz\n        zs3(k)=zcol(k)-0.5d0*dz\n        zs4(k)=zcol(k)-0.5d0*dz\n      end do\n    end do\n    return\n  end subroutine coordinate3dp\n"}, {"instruction": "Create a Fortran subroutine named gauleg_ng to compute the Gaussian quadrature points and weights. The subroutine takes 4 input parameters of type integer, integer, real(ffp), and real(ffp), and 2 output parameters of type real(ffp). The input parameters correspond to the range of integration and the number of points, while the output parameters store the computed quadrature points and weights.", "input": "", "output": "subroutine gauleg_ng(x1,x2,x,w,n,nmax)\n\n   implicit none\n\n!  parameter argument\n\n   integer, parameter :: ffp = selected_real_kind(15)\n\n!  input/output\n\n      integer  , intent(in)  :: n,nmax\n      real(ffp), intent(in)  :: x1, x2\n      real(ffp), intent(out) :: x(nmax),w(nmax)\n\n      integer     :: i, m, j\n      real(ffp)   :: xm,xl,p1,p2,p3,pp,z,z1\n      real(ffp)   :: quant, rn, rj, pie, arg\n\n      real(ffp), parameter :: eps = 3.0d-14\n      real(ffp), parameter :: zero = 0.0_ffp\n      real(ffp), parameter :: one  = 1.0_ffp\n      real(ffp), parameter :: two  = 2.0_ffp\n      real(ffp), parameter :: half  = 0.5_ffp\n      real(ffp), parameter :: qtr   = 0.25_ffp\n\n      m=(n+1)/2\n      xm = half * (x2+x1)\n      xl = half * (x2-x1)\n      rn = real(n,ffp)\n      z1 = zero\n      pie = acos(-one)\n\n      do i=1,m\n            arg = ( real(i,ffp) - qtr ) / ( rn + half )\n!            z=cos(3.141592654d0*(i-.25d0)/(n+.5d0))\n            z  = cos ( pie * arg )\n            do while (abs(z-z1).gt.eps)\n                  p1=one\n                  p2=zero\n                  do j=1,n\n                        rj = real(j,ffp)\n                        p3=p2\n                        p2=p1\n                        p1= ( ( two*rj-one)*z*p2-(rj-one)*p3 ) / rj\n                        p1= ( ( two*rj-one)*z*p2-(rj-one)*p3 ) / rj\n                  enddo\n                  pp=rn*(z*p1-p2)/(z*z-one)\n                  z1=z\n                  z=z1-p1/pp\n            enddo\n            quant = two / ( ( one-z*z) * pp *pp )\n            x(i)     = xm - xl*z\n            x(n+1-i) = xm + xl*z\n            w(i)     = quant * xl\n            w(n+1-i) = w(i)\n      enddo\n      return\nend subroutine gauleg_ng\n"}, {"instruction": "Write a Fortran subroutine named firstpanel to extract information from an array. The subroutine takes 3 input parameters of type integer, and 2 output parameters of type integer. The input array panels has a dynamic size specified by ldpanels. The subroutine uses the values of ldpanels, ithd, and panels to calculate the values of j and np, which are then returned as output parameters. The subroutine should be used to extract specific information from the panels array and store it in the output variables j and np.", "input": "", "output": "subroutine firstpanel(panels,ldpanels,ithd,j,np)\r\n   implicit none\r\n\r\n   ! .. scalar arguements ..\r\n   integer, intent(in) :: ldpanels,ithd\r\n   integer, intent(out) :: j, np\r\n\r\n   ! .. array arguements ..\r\n   integer, intent(in) :: panels(ldpanels,*)\r\n\r\n   ! .. local scalars ..\r\n   integer :: ind\r\n\r\n   ind=ithd+1\r\n   j=panels(1,ind) !jfirst\r\n   np=panels(2,ind) !nfirst\r\n\r\nend subroutine firstpanel\r\n"}, {"instruction": "Create a Fortran subroutine named \"gregorian\" that takes a single input parameter of type real and returns three output parameters of type integer to convert the Julian date to Gregorian date.", "input": "", "output": "subroutine gregorian (julian, year, month, day)\n\nimplicit none\n\nreal,    intent(in)  :: julian\ninteger, intent(out) :: year, month, day\n\ninteger :: i, j, k, l, n\n\nl = julian + 68569\nn = 4*l/146097\nl = l - (146097*n+3)/4\ni = 4000*(l+1)/1461001\nl = l - 1461*i/4 + 31\nj = 80*l/2447\nk = l - 2447*j/80\nl = j/11\nj = j+2-12*l\ni = 100*(n-49) + i + l\n\nyear = i\nmonth = j\nday = k\n\nreturn\n\nend subroutine gregorian\n"}, {"instruction": "Write a Fortran subroutine named comp_correl that computes the correlation coefficient between two sets of data. The subroutine takes 2 input parameters: an integer 'n' representing the number of data points, and a 2D array 'ens' of size (2, n) containing the data points. The data points are of type double precision. The subroutine also has 1 output parameter named 'correl', which is of type double precision.", "input": "", "output": "subroutine comp_correl(ens, n, correl)\n \nimplicit none\n \ninteger, intent(in) :: n\ndouble precision, intent(in) :: ens(2, n)\ndouble precision, intent(out) :: correl\ndouble precision :: sum_x, sum_y, sum_xy, sum_x2, sum_y2\n\n\nsum_x = sum(ens(2, :))\nsum_y = sum(ens(1, :))\nsum_xy = sum(ens(2, :) * ens(1, :))\nsum_x2 = sum(ens(2, :) * ens(2, :))\n \n! computation of correlation \nsum_y2 = sum(ens(1, :) * ens(1, :))\n\ncorrel = (n * sum_xy - sum_x * sum_y) / &\n   sqrt((n * sum_x2 - sum_x**2) * (n * sum_y2 - sum_y**2))\n \nend subroutine comp_correl\n"}, {"instruction": "Write a Fortran subroutine named \"harmonicsr\" that calculates spherical harmonics for a given set of input parameters. The subroutine takes 2 input parameters: an integer value \"ll\" and a real array \"rvec\" of size 3. It also has 1 output parameter: a complex array \"y\" of size (ll + 1)^2. \n\nThe subroutine computes the spherical harmonics for each value of \"l\" and \"m\" using the input parameters \"ll\" and \"rvec\". The calculated values are stored in the output array \"y\". The subroutine uses various intermediate variables and operations such as complex numbers, trigonometric functions, and mathematical operations to perform the calculations.\n\nThe purpose of this subroutine is to provide an efficient and accurate method to compute spherical harmonics for a given set of input parameters.", "input": "", "output": "   pure subroutine harmonicsr(y, rvec, ll)\n\n      implicit none\n\n      integer  , intent(in)  :: ll\n      real  , intent(in)  :: rvec(3)\n      complex, intent(out) :: y((ll + 1)**2)\n      complex               :: c\n      real                    :: stheta, ctheta, sphi, cphi, r, rvec1(3)\n      integer                 :: l, m, lm\n      complex, parameter   :: img = (0.0, 1.0)\n\n      y(1) = 0.282094791773878\n      if (ll == 0) return\n\n      stheta = 0\n      ctheta = 0\n      sphi = 0\n      cphi = 0\n      r = norm2(rvec)\n      if (r > 1e-16) then\n         rvec1 = rvec/r\n         ctheta = rvec1(3)\n         stheta = sqrt(rvec1(1)**2 + rvec1(2)**2)\n         if (stheta > 1e-16) then\n            cphi = rvec1(1)/stheta\n            sphi = rvec1(2)/stheta\n         end if\n      else\n         y(2:) = 0.0\n         return\n      end if\n\n!     define y,l,-l and y,l,l\n      r = y(1)\n      c = 1\n      do l = 1, ll\n         r = r*stheta*sqrt(1.0 + 1.0/(2*l))\n         c = c*(cphi + img*sphi)\n         y(l**2 + 1) = r*conjg(c)  ! l,-l\n         y((l + 1)**2) = r*c*(-1)**l ! l,l\n      end do\n\n!     define y,l,-l+1 and y,l,l-1\n      y(3) = 0.48860251190292*ctheta\n      do l = 2, ll\n         r = sqrt(2.0*l + 1)*ctheta\n         y(l**2 + 2) = r*y((l - 1)**2 + 1) ! l,-l+1\n         y(l*(l + 2)) = r*y(l**2)       ! l,l-1\n      end do\n\n!     define y,l,m, |m|<l-1\n      do l = 2, ll\n         lm = l**2 + 2\n         do m = -l + 2, l - 2\n            lm = lm + 1\n            y(lm) = sqrt((2.0*l + 1)/(l + m)/(l - m))*( &\n                    sqrt(2.0*l - 1)*ctheta*y(lm - 2*l) - &\n                    sqrt((l + m - 1.0)*(l - m - 1)/(2*l - 3))*y(lm - 4*l + 2))\n         end do\n      end do\n\n   end subroutine harmonicsr\n"}, {"instruction": "Create a Fortran subroutine named \"ozphys_2015_init\" to initialize variables for error handling related to the \"oz_phys_2015\" logic. The subroutine takes 1 input parameter of type \"logical\" and 2 output parameters, one of type \"character(len=*)\" and the other of type \"integer\". \n\nIn the subroutine, first initialize the error handling variables. Then, check if the input parameter \"oz_phys_2015\" is false. If it is false, assign an error message to the \"errmsg\" parameter and set the \"errflg\" parameter to 1. Finally, return from the subroutine.", "input": "", "output": "      subroutine ozphys_2015_init(oz_phys_2015, errmsg, errflg)\n\n      implicit none\n      logical,          intent(in)  :: oz_phys_2015\n      character(len=*), intent(out) :: errmsg\n      integer,          intent(out) :: errflg\n\n      ! initialize ccpp error handling variables\n      errmsg = ''\n      errflg = 0\n\n      if (.not.oz_phys_2015) then\n        write (errmsg,'(*(a))') 'logic error: oz_phys_2015 == .false.'\n        errflg = 1\n        return\n      endif\n\n      end subroutine ozphys_2015_init\n"}, {"instruction": "Create a Fortran subroutine called sub_solve_quadratic_real128_equation to solve a quadratic equation with real128 precision. The subroutine takes 3 input arguments with the test_data type of ['real(kind = real128)', 'real(kind = real128)', 'real(kind = real128)'] and 2 output arguments with the test_data type of ['real(kind = real128)', 'real(kind = real128)']. The subroutine uses the if-else statement to check the sign of the second input argument. If it is greater than or equal to zero, it calculates the values of the output arguments using the quadratic formula with negative sign. Otherwise, it calculates the values using the quadratic formula with positive sign.", "input": "", "output": "pure subroutine sub_solve_quadratic_real128_equation(a, b, c, x1, x2)\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare inputs/outputs ...\n    real(kind = real128), intent(in)                                            :: a\n    real(kind = real128), intent(in)                                            :: b\n    real(kind = real128), intent(in)                                            :: c\n    real(kind = real128), intent(out)                                           :: x1\n    real(kind = real128), intent(out)                                           :: x2\n\n    ! check sign of b ...\n    if(b >= 0.0e0_real128)then\n        x1 = (-b - sqrt(b ** 2 - 4.0e0_real128 * a * c)) / (2.0e0_real128 * a)\n        x2 = (2.0e0_real128 * c) / (-b - sqrt(b ** 2 - 4.0e0_real128 * a * c))\n    else\n        x1 = (2.0e0_real128 * c) / (-b + sqrt(b ** 2 - 4.0e0_real128 * a * c))\n        x2 = (-b + sqrt(b ** 2 - 4.0e0_real128 * a * c)) / (2.0e0_real128 * a)\n    end if\nend subroutine sub_solve_quadratic_real128_equation\n"}, {"instruction": "Write a Fortran subroutine named make_array_logspace that generates a logarithmically spaced array of values between a start and end point. The number of input arguments is 3, with the test_data types as follows: ['integer', 'double precision', 'double precision']. The number of output arguments is 1, with the test_data type being ['double precision'].\n\nThe subroutine takes as input the dimension of the array, the start value, and the end value. It calculates the logarithmic spacing between these values and stores the resulting array in the output argument.\n\nIf the dimension is greater than 1, the subroutine computes the logarithmically spaced values using a loop and the formula 10**exp, where exp is incrementally adjusted based on the desired spacing. If the dimension is 1, the start value is directly assigned to the output array. If the dimension is less than 1, an error message is displayed.\n\nMake sure to use the appropriate Fortran keywords and syntax when implementing the subroutine.", "input": "", "output": "      subroutine make_array_logspace(a_start, a_end, dim, out)\n      implicit none\n      integer         , intent(in) :: dim\n      double precision, intent(in) :: a_start, a_end\n      double precision, intent(out):: out(dim)\n      integer                      :: i\n      double precision             :: du,u1,u2,exp\n      if (dim.gt.1) then\n         u1=log10(a_start)\n         u2=log10(a_end)      \n         du=(u2-u1)/float(dim-1)\n         exp=log10(a_start)\n         do i=1, dim\n            out(i)=10**exp\n            exp=exp+du\n         enddo\n      else if(dim.eq.1) then\n       out(1)=a_start\n      else if(dim.lt.1) then\n       write(*,'(a)',advance=\"no\") 'error! it is impossible create' \n       write(*,*) ' the log scaled array: dim is less than 1'\n       stop\n      endif\n      return\n    end subroutine make_array_logspace\n"}, {"instruction": "Create a Fortran subroutine named approx_norm1 that calculates an approximate norm of a 2D array. The subroutine has 1 input parameter of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8).", "input": "", "output": "    subroutine approx_norm1(a, anorm)\n\n    implicit none\n    real(kind=8), dimension(:,:), intent(in) :: a\n    real(kind=8), intent(out) :: anorm\n\n    anorm = -1.d0   ! this obviously isn't correct\n\n    end subroutine approx_norm1\n"}, {"instruction": "Write a Fortran subroutine named score that calculates the score based on a given guess and a secret number. The number of input arguments is 2 and the test_data type is ['character(*)', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].\n\nThe subroutine takes a guess as input, which is a string of characters representing a number, and an array of integers representing the secret number. It calculates two values, 'b' and 'c', which represent the number of correct digits in the correct positions ('b') and the number of correct digits in incorrect positions ('c').\n\nInside the subroutine, 'b' and 'c' are initialized to 0. It then iterates over each character in the guess and compares it to the corresponding digit in the secret number. If the digits match, 'b' is incremented. If the digits don't match, it searches for the digit in the secret number starting from the current position and moving three positions ahead. If it finds a match, 'c' is incremented and the loop is exited.\n\nThe subroutine does not have a return statement as the values of 'b' and 'c' are updated directly in the output parameters.\n\nUse this subroutine to determine the score of a guess in a game or any other scenario where you need to compare two numbers.", "input": "", "output": "  subroutine score(n, guess, b, c)\n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n\n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do\n      end if\n    end do\n\n end subroutine score\n"}, {"instruction": "Create a Fortran subroutine named \"mah\" that takes an integer input parameter and returns an integer output parameter. The purpose of the subroutine is to perform certain operations on arrays of real and complex numbers. The input parameter is of type 'integer' and the output parameter is also of type 'integer'.", "input": "", "output": "subroutine mah (i, c)\n  !\n  integer, intent(in) :: i\n  integer, intent(out) :: c\n  !\n  type mix_type\n     real(8), allocatable :: a(:)\n     complex(8), allocatable :: b(:)\n  end type mix_type\n  type(mix_type), allocatable, save :: t(:)\n  integer :: j, n=1024\n  !\n  if (i==0) then\n     allocate (t(1))\n     allocate (t(1)%a(n))\n     allocate (t(1)%b(n))\n     do j=1,n\n        t(1)%a(j) = j\n        t(1)%b(j) = n-j\n     end do\n  end if\n  c = sum( t(1)%a(:) ) + sum( t(1)%b(:) )\n  if ( i==2) then\n     deallocate (t(1)%b)\n     deallocate (t(1)%a)\n     deallocate (t)\n  end if\nend subroutine mah\n"}, {"instruction": "Write a Fortran subroutine named beam_mm to calculate the stiffness matrix of a beam element based on its length and material properties. The number of input arguments is 2 with the test_data type real(iwp) and the number of output arguments is 1 with the test_data type real(iwp).", "input": "", "output": "subroutine beam_mm(mm,fs,ell)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::fs,ell\n real(iwp),intent(out)::mm(:,:)\n real(iwp)::fac\n fac=(fs*ell)/420.0_iwp \n mm(1,1)=156.0_iwp*fac\n mm(3,3)=mm(1,1)\n mm(1,2)=22.0_iwp*ell*fac\n mm(2,1)=mm(1,2)\n mm(3,4)=-mm(1,2)\n mm(4,3)=mm(3,4)\n mm(1,3)=54.0_iwp*fac\n mm(3,1)=mm(1,3)\n mm(1,4)=-13.0_iwp*ell*fac\n mm(4,1)=mm(1,4)\n mm(2,3)=-mm(1,4)\n mm(3,2)=mm(2,3)\n mm(2,2)=4.0_iwp*(ell**2)*fac\n mm(4,4)=mm(2,2)\n mm(2,4)=-3.0_iwp*(ell**2)*fac\n mm(4,2)=mm(2,4)\nreturn\nend subroutine beam_mm  \n"}, {"instruction": "Write a Fortran subroutine named simp to perform numerical integration using Simpson's rule. The subroutine takes 3 input parameters of type integer, integer, and real(8) and 1 output parameter of type real(8).", "input": "", "output": "  subroutine simp(f,s,n,m)\n    implicit none\n    integer,intent(in)  :: n,m\n    real(8),intent(in)  :: f(n)\n    real(8),intent(out) :: s\n    real(8),allocatable :: g(:)\n    integer :: i,nmax\n    nmax=int(n/m)*m\n    do i=0,m\n       nmax=nmax+i ; if ( nmax>=n ) exit\n    end do\n    allocate( g(nmax) ) ; g(1:n)=f ; if ( nmax>n ) g(n+1:)=0.d0\n    select case(m)\n    case default\n       s = 0.5d0*(f(1)+f(n)) + sum(f(2:n-1))\n    case(2)\n       s=0.d0\n       do i=1,nmax-2,2\n          s = s + g(i) + 4.d0*g(i+1) + g(i+2)\n       end do\n       s=s/3.d0\n    case(4)\n       s=0.d0\n       do i=1,nmax-4,4\n          s=s+7*g(i)+32*g(i+1)+12*g(i+2)+32*g(i+3)+7*g(i+4)\n       end do\n       s=s*2.d0/45.d0\n    case(6)\n       s=0.d0\n       do i=1,nmax-6,6\n          s=s+41*g(i)+216*g(i+1)+27*g(i+2)+272*g(i+3) &\n               +27*g(i+4)+216*g(i+5)+41*g(i+6)\n       end do\n       s=s/140.d0\n    end select\n    deallocate( g )\n    return\n  end subroutine simp\n"}, {"instruction": "Write a Fortran subroutine named gram_real that performs Gram-Schmidt orthonormalization on a matrix of real numbers. The subroutine takes 3 input parameters of types integer, integer, and real(8) and 1 output parameter of type real(8). The input parameters represent the dimensions and the input matrix, while the output parameter represents the orthonormalized matrix.", "input": "", "output": "subroutine gram_real(m,n,mat_v,mat_v_out)\r\n  ! cited from \r\n  !http://park.itc.u-tokyo.ac.jp/kato-yusuke-lab/nagai/note_141009_lobpcg.pdf\r\n  implicit none\r\n  ! m : \u30d9\u30af\u30c8\u30eb\u306e\u6b21\u5143\r\n  ! n : \u30d9\u30af\u30c8\u30eb\u306e\u672c\u6570\r\n  integer,intent(in)::m,n\r\n  real(8),intent(in)::mat_v(1:m,1:n)\r\n  real(8),intent(out)::mat_v_out(1:m,1:n)\r\n  integer::i,j\r\n  real(8)::v(1:m),nai,vi(1:m),viold(1:m)\r\n  real(8)::norm\r\n  mat_v_out = mat_v\r\n  do i = 1,n\r\n      viold = mat_v_out(:,i)\r\n      do j = 1,i-1\r\n          nai = dot_product(mat_v_out(1:m,j),viold(1:m))\r\n          vi = viold - nai*mat_v_out(:,j)\r\n          viold = vi\r\n      end do\r\n      norm = sqrt(dble(dot_product(viold,viold)))\r\n      if(norm==0.0d0)then\r\n          ! debug right?\r\n          print *, \"error gram_real :: norm-zero\"\r\n          mat_v_out(j,j) =1.0d0\r\n          !\r\n          !stop\r\n          \r\n          !mat_v_out(:,j) = viold\r\n      else\r\n          mat_v_out(:,j) = viold/norm\r\n      endif\r\n  end do\r\n  return\r\nend subroutine gram_real\r\n"}, {"instruction": "Write a Fortran subroutine named alloc_array_return that takes an integer n_items as input and returns an array of strings. The input parameter is of type integer. The output parameter is a pointer to an array of strings, where each string has a length of 60 characters.", "input": "", "output": "    subroutine alloc_array_return(n_items, array)\n        integer, intent(in) :: n_items\n        character(60), dimension(:), pointer, intent(out) :: array\n        integer :: i\n\n        allocate(array(n_items))\n\n        do i = 1, n_items\n            write (array(i), \"(i8)\") i\n        end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named bsel to calculate the number of bonds detected in the specified cutoff for a set of coordinates. The subroutine takes 3 input parameters of type integer*4, real*8, and real*8, dimension(n,3). The output parameter is of type integer*8.", "input": "", "output": "subroutine bsel(n, vp, rcut, dimcouples)\n\n    implicit none\n    integer*4, intent(in)                  :: n\n    real*8,    intent(in)                  :: rcut\n    real*8,    intent(in) , dimension(n,3) :: vp\n    integer*8, intent(out)                 :: dimcouples\n\n    integer*4                              :: i,j\n    real*8                                 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n    real*8                                 :: rcutsq\n\n    rcutsq = rcut*rcut\n\n\n    do i = 1, (n - 1)\n        xi = vp(i,1)\n        yi = vp(i,2)\n        zi = vp(i,3)\n\n        do j = 1, n\n            if (i >= j) cycle\n\n            xj = vp(j,1)\n            yj = vp(j,2)\n            zj = vp(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = dx*dx + dy*dy + dz*dz\n            !mdl = int(mdl * 10.0**3) / 10.0**3\n\n            if (mdl > rcutsq) then\n                cycle\n            else\n                dimcouples = dimcouples + 1        \n            end if\n        end do\n    end do\n\n    print *,\"bonds detected in the specified cutoff:\",dimcouples\n\n    return\nend subroutine bsel\n"}, {"instruction": "Create a Fortran subroutine named find_root that computes the root of a function using the Newton-Raphson method. The subroutine takes 4 input parameters of type real, real, real, and integer, and 2 output parameters of type real and logical.", "input": "", "output": "subroutine find_root( f, xinit, tol, maxiter, result, success )\n\n    interface\n        real function f(x)\n            real, intent(in) :: x\n        end function f\n    end interface\n\n    real, intent(in)     :: xinit\n    real, intent(in)     :: tol\n    integer, intent(in)  :: maxiter\n    real, intent(out)    :: result\n    logical, intent(out) :: success\n\n    real                 :: eps = 1.0e-4\n    real                 :: fx1\n    real                 :: fx2\n    real                 :: fprime\n    real                 :: x\n    real                 :: xnew\n    integer              :: i\n\n    result  = 0.0\n    success = .false.\n\n    x = xinit\n    do i = 1,max(1,maxiter)\n        fx1    = f(x)\n        fx2    = f(x+eps)\n        write(*,*) i, fx1, fx2, eps\n        fprime = (fx2 - fx1) / eps\n\n        xnew   = x - fx1 / fprime\n\n        if ( abs(xnew-x) <= tol ) then\n            success = .true.\n            result  = xnew\n            exit\n        endif\n\n        x = xnew\n        write(*,*) i, x\n     enddo\n\nend subroutine find_root\n"}, {"instruction": "Write a Fortran subroutine named findnorm that calculates the Euclidean norm of a given vector. The subroutine takes 2 input parameters: an integer n and a real*8 array v1 of length n. It also has 1 output parameter, a real*8 variable norm, which stores the computed norm.", "input": "", "output": "  subroutine findnorm(norm,v1,n)\n\n    integer,intent(in) :: n\n    real*8,intent(in) :: v1(n)\n    real*8, intent(out) :: norm\n\n    integer :: i\n\n    norm=0.d0\n\n    do i=1,n\n       norm=norm+v1(i)*v1(i)\n    enddo\n\n    norm=sqrt(norm)\n\n  end subroutine findnorm\n"}, {"instruction": "Write a Fortran subroutine named innerproduct that computes the inner product of two vectors. The subroutine takes 3 input parameters of type integer, real*8, and real*8, representing the dimension of the vectors and the vectors themselves. It also has 1 output parameter of type real*8.", "input": "", "output": "  subroutine innerproduct(v1dotv2,v1,v2,n)\n\n    integer, intent(in) :: n\n    real*8, intent(in) :: v1(n),v2(n)\n    real*8, intent(out) :: v1dotv2\n\n    integer :: i\n\n    v1dotv2=0.d0\n\n    do i=1,n\n       v1dotv2=v1dotv2+v1(i)*v2(i)\n    enddo\n\n  end subroutine innerproduct\n"}, {"instruction": "Write a Fortran subroutine named \"extrap\" that takes an integer parameter \"m\" as input and returns an array \"xcof\" of double precision numbers with dimension (0:m) as output. \n\nThe purpose of this subroutine is to calculate extrapolation coefficients for a given degree \"m\". \n\nIn the subroutine, initialize each element of the \"xcof\" array to 1. Then, using nested do loops, calculate the extrapolation coefficients by multiplying the current element with the ratio of (m+1-j) to (k-j), where \"k\" and \"j\" are loop variables. \n\nEnsure that \"j\" is not equal to \"k\" to avoid division by zero. \n\nOnce all the calculations are done, the subroutine will return the \"xcof\" array containing the extrapolation coefficients.", "input": "", "output": "  subroutine extrap(xcof,m)\n!\n  integer, intent(in) :: m\n  double precision, dimension(0:m), intent(out) :: xcof\n!\n! return extrapolation coefficients for degree m\n!\n  integer :: k,j\n!\n  do k=0,m\n    xcof(k)=1.d0\n    do j=0,m\n      if (j /= k) then\n        xcof(k)=xcof(k)*dble(m+1-j)/dble(k-j)\n      end if\n    end do\n  end do \n!\n  end subroutine extrap  \n"}, {"instruction": "Write a Fortran subroutine called size_comp that calculates the maximum size between an input array and a fixed array. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter is an array of integers. The subroutine compares the sizes of the input array and a fixed array of size 5 and returns the maximum size.", "input": "", "output": "    subroutine size_comp(val, ret)\n        integer, intent(in) :: val(:)\n        integer, intent(out) :: ret\n        integer, dimension(5) :: fixed\n        ret = maxval([size(val), size(fixed)])\n    end subroutine size_comp\n"}, {"instruction": "Write a Fortran subroutine named \"plag_coeff\" that calculates the Lagrange polynomial coefficients for a given number of points. The subroutine takes four input parameters: npoi (integer) - the number of points, nder (integer) - the number of derivatives to compute, x (double precision) - the point where function and derivatives are evaluated, and xp (double precision, dimension(npoi)) - an array of points where the function is known. The subroutine also has one output parameter: coef (double precision, dimension(0:nder,npoi)) - an array of weights for the computation of the function and derivatives.\n\nThe subroutine first calculates the coefficients for the function using the Lagrange interpolation formula. Then, if nder is greater than 0, it allocates memory for a temporary array called \"dummy\". It computes the coefficients for the derivatives using nested loops and stores them in the coef array. Finally, it deallocates the memory for the \"dummy\" array.\n\nTo use the subroutine, pass the appropriate values for npoi, nder, x, and xp, and allocate the coef array before calling the subroutine.", "input": "", "output": "subroutine plag_coeff(npoi,nder,x,xp,coef)\n  !\n  ! npoi - number of points (determines the order of lagrange\n  ! polynomial\n  ! which is equal npoi-1)\n  ! nder - number of derivatives computed 0 - function only, 1 - first\n  ! derivative\n  ! x - actual point where function and derivatives are evaluated\n  ! xp(npoi) - array of points where function is known\n  ! coef(0:nder,npoi) - weights for computation of function and\n  ! derivatives,\n  ! f=sum(fun(1:npoi)*coef(0,1:npoi) gives the function value\n  ! df=sum(fun(1:npoi)*coef(1,1:npoi) gives the derivative value value\n  !\n  implicit none\n  !\n  integer, intent(in)                                :: npoi,nder\n  double precision, intent(in)                          :: x\n  double precision, dimension(npoi), intent(in)         :: xp\n  double precision, dimension(0:nder,npoi), intent(out) :: coef\n  double precision, dimension(:), allocatable           :: dummy\n  !\n  integer                                            :: i,k,j\n  double precision                                      :: fac\n  !\n  do i=1,npoi\n      coef(0,i)=1.d0\n      do k=1,npoi\n        if(k.eq.i) cycle\n        coef(0,i)=coef(0,i)*(x-xp(k))/(xp(i)-xp(k))\n      enddo\n  enddo\n  !\n  if(nder.eq.0) return\n  !\n  !$omp critical\n  allocate(dummy(npoi))\n  !$omp end critical\n  !\n  do i=1,npoi\n      dummy=1.d0\n      dummy(i)=0.d0\n      do k=1,npoi\n        if(k.eq.i) cycle\n        fac=(x-xp(k))/(xp(i)-xp(k))\n        do j=1,npoi\n            if(j.eq.k) then\n              dummy(j)=dummy(j)/(xp(i)-xp(k))\n            else\n              dummy(j)=dummy(j)*fac\n            endif\n        enddo\n      enddo\n      coef(1,i)=sum(dummy)\n  enddo\n  !\n  !$omp critical\n  deallocate(dummy)\n  !$omp end critical\n  !\n  return\nend subroutine plag_coeff\n"}, {"instruction": "Create a Fortran subroutine named \"spline\" that calculates the spline interpolation coefficients. The subroutine takes 4 input arguments: n (integer), gam (real), x (real array of size n), and y (real array of size n). It also has 1 output argument: y2 (real array of size n). \n\nInside the subroutine, allocate memory for an auxiliary array u of size n. Compute the initial value yp1 based on the first element of x and the value of gam. Calculate the first element of y2 as -0.5. \n\nThen, use a loop to calculate the elements of y2 and u. Compute the values of sig and p based on the neighboring elements of x and y. Update y2 and u using the formula provided in the code. \n\nFinally, assign a value of 0.0 to the last element of y2. Use another loop to update the remaining elements of y2 based on the values of y2 and u. \n\nDeallocate the memory assigned to u and return from the subroutine.\n\nMake sure to use imperative language to give clear instructions.", "input": "", "output": "subroutine spline(x,y,n,gam,y2)\nimplicit none\ninteger, intent(in) :: n\nreal, intent(in) :: gam\nreal, intent(in) :: x(n,1), y(n,1)\nreal, intent(out) :: y2(n,1)\ninteger :: i, k\n!real :: qn, un\nreal :: yp1\nreal :: p, sig\nreal, allocatable :: u(:,:)\nallocate(u(n,1))\nyp1 = x(1,1)**(-gam)\ny2(1,1)=-0.5\nu(1,1)=(3.0/(x(2,1)-x(1,1)))*((y(2,1)-y(1,1))/(x(2,1)-x(1,1))-yp1)\ndo i=2,n-1\n   sig = (x(i,1)-x(i-1,1))/(x(i+1,1)-x(i-1,1))\n   p = sig*y2(i-1,1)+2.0\n   y2(i,1) = (sig-1.0)/p\n   u(i,1) = (6.0*((y(i+1,1)-y(i,1))/(x(i+1,1)-x(i,1))-(y(i,1)-y(i-1,1))/(x(i,1)-x(i-1,1)))/(x(i+1,1)-x(i-1,1))-sig*u(i-1,1))/p\nend do\ny2(n,1) =0.0\ndo k=n-1,1,-1\n   y2(k,1) = y2(k,1)*y2(k+1,1)+u(k,1)\nend do\ndeallocate(u)\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named look_up_message_type to determine the observation type based on the message type input. The subroutine takes 1 input parameter of type character with length 6 and 1 output parameter of type character with variable length.", "input": "", "output": "subroutine look_up_message_type(msg_type, obstype)\n! find observation type from \n! http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_4.htm\n character(len=6), intent(in)  :: msg_type\n character(len=*), intent(out) :: obstype \n\nselect case (msg_type)\n  case ('adpupa')\n    obstype = 'radiosonde'   ! fixme: dropsonde, too.\n  case ('aircar')\n    obstype = 'acars'\n  case ('aircft')\n    obstype = 'aircraft'\n  case ('satwnd')\n    obstype = 'sat'\n  case ('proflr')\n    obstype = 'profiler'\n  case ('adpsfc')\n    obstype = 'metar'        ! fixme: synop, too.\n  case ('msonet')\n    obstype = 'land_sfc'\n  case ('sfcshp')\n    obstype = 'marine'\n  case ('gpsipw')\n    obstype = 'gps'\n  case ('qkswnd')\n    obstype = 'qkswnd'\n  case default\n    obstype = 'unknown'\nend select\n\nend subroutine look_up_message_type\n"}, {"instruction": "Create a Fortran subroutine named look_up_obs_type to determine the DART observation type based on the message type and GRIB type provided. The subroutine takes 2 input parameters of type character(len=*) and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine look_up_obs_type(msg_type, grib_type, dart_obs_type)\n character(len=*), intent(in)  :: msg_type\n integer,          intent(in)  :: grib_type\n integer,          intent(out) :: dart_obs_type\n\nselect case (msg_type)\n  case ('adpupa')\n     ! t, q, p, u, v, sst\n     select case(grib_type)\n        case (11)\n           dart_obs_type = radiosonde_temperature\n        case (12)\n           dart_obs_type = radiosonde_temperature\n        case default\n           dart_obs_type = -1\n      end select\n  case ('aircar')\n  case ('aircft')\n  case ('satwnd')\n  case ('proflr')\n  case ('vadwnd')\n  case ('satemp')\n  case ('adpsfc')\n  case ('sfcshp')\n  case ('sfcbog')\n  case ('spssmi')\n  case ('syndat')\n  case ('ers1da')\n  case ('goesnd')\n  case ('qkswnd')\n  case ('msonet')\n  case ('gpsipw')\n  case ('rassda')\n  case ('wdsatr')\n  case ('ascatw')\n  case default\n     print *, 'unknown message type: '//trim(msg_type)\nend select\n\nend subroutine look_up_obs_type\n"}, {"instruction": "Create a Fortran subroutine named make_gl_nw to compute the Gauss-Legendre nodes and weights for numerical integration. The subroutine takes 1 input parameter of type integer*4 and 2 output parameters of type real(dbp).", "input": "", "output": "      subroutine  make_gl_nw(ngp, xabsc, weig)\n\n      implicit none\n\n      integer, parameter :: dbp = selected_real_kind (15,307)\n      real(dbp) :: newv\n      real(dbp) :: eps, m_pi\n      parameter (eps=3.0d-15)               !eps is the relative precision\n      parameter (m_pi=3.141592654d0) \n      \n      integer*4  i, j, m\n      real(dbp)  p1, p2, p3, pp, z, z1\n      integer*4, intent(in) :: ngp            ! # of gauss points\n      real(dbp), intent(out) :: xabsc(ngp), weig(ngp)\n\n\n           m = (ngp + 1) / 2\n!* roots are symmetric in the interval - so only need to find half of them  */\n\n           do i = 1, m                                ! loop over the desired roots */\n\n                     z = cos( m_pi * (i-0.25d0) / (ngp+0.5d0) )\n!*   starting with the above approximation to the ith root,\n!*          we enter the main loop of refinement by newton's method   */\n\n100             p1 = 1.0d0\n                p2 = 0.0d0\n!*  loop up the recurrence relation to get the legendre\n!*  polynomial evaluated at z                 */\n\n                do j = 1, ngp\n                   p3 = p2\n                   p2 = p1\n                   p1 = ((2.0d0*j-1.0d0) * z * p2 - (j-1.0d0)*p3) / j\n                enddo\n\n!* p1 is now the desired legendre polynomial. we next compute pp,\n!* its derivative, by a standard relation involving also p2, the\n!* polynomial of one lower order.      */\n                pp = ngp*(z*p1-p2)/(z*z-1.0d0)\n                z1 = z\n                z = z1 - p1/pp             ! newton's method  */\n\n                if (dabs(z-z1) .gt. eps) goto  100\n\n              xabsc(i) =  - z                            ! roots will be bewteen -1.0 & 1.0 */\n              xabsc(ngp+1-i) =  + z                        ! and symmetric about the origin   */\n              weig(i) = 2.0d0/((1.0d0-z*z)*pp*pp)     ! compute the weight and its       */\n              weig(ngp+1-i) = weig(i)                 ! symmetric counterpart            */\n\n      end do     ! i loop\n\n   end subroutine make_gl_nw\n"}, {"instruction": "Write a Fortran subroutine named dccon0 to calculate the medium constants and fault-dip constants. The subroutine takes 1 input parameter of type real*8 and outputs 2 parameters of type real*8.", "input": "", "output": "subroutine  dccon0(dip,sd,cd)\n!*******************************************************************\n!*****   calculate medium constants and fault-dip constants    *****\n!*******************************************************************\n!\n!***** input\n!*****   dip   : dip-angle (degree)\n!***** output\n!*****   sd,cd : sin, cos of dip-angle\n    implicit none\n    real*8, intent(in) :: dip\n    real*8, intent(out) :: sd,cd\n\n    real*8, parameter :: f0=0.0d0, f1=1.0d0\n    real*8, parameter :: pi2=6.283185307179586d0\n    real*8, parameter :: eps=1.0d-6\n    real*8, parameter :: p18=pi2/360.d0\n!-----\n    sd=dsin(dip*p18)\n    cd=dcos(dip*p18)\n!### caution ### if cos(dip) is sufficiently small, it is set to zero\n    if(dabs(cd)<eps) then\n      cd=f0\n      if(sd>f0) sd= f1\n      if(sd<f0) sd=-f1\n    endif\n    return\nend subroutine dccon0\n"}, {"instruction": "Create a Fortran subroutine named math_singularity to compute the values of theta, alx, and ale based on the input parameters xi, et, q, r, kxi, and ket, where xi, et, q, r are real*8, and kxi, ket are integers. The computed values of theta, alx, and ale will be of type real*8.", "input": "", "output": "subroutine math_singularity(xi,et,q,r,kxi,ket,theta,alx,ale)\n!***** input\n!*****   xi,et,q : station coordinates in fault system\n!*****   kxi,ket : kxi=1, ket=1 means r+xi<eps, r+et<eps, respectively\n    implicit none\n    real*8, intent(in) :: xi,et,q,r\n    integer, intent(in) :: kxi,ket\n    real*8, intent(out) :: theta,alx,ale\n\n    ! p.1034 (i)\n    if(q==0.0d0) then\n      theta=0.0d0\n    else\n      theta=datan(xi*et/(q*r))\n    endif\n    ! p.1034 (iii)\n    if(kxi==1) then\n      alx=-dlog(r-xi)\n    else\n      alx=dlog(r+xi)\n    endif\n    ! p.1034 (iv)\n    if(ket==1) then\n      ale=-dlog(r-et)\n    else\n      ale=dlog(r+et)\n    endif\n\n    return\nend subroutine math_singularity\n"}, {"instruction": "Create a Fortran subroutine named assign_alpha. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8 array. The subroutine calculates 5 coefficients based on the input alpha value and stores them in the output array alp.", "input": "", "output": "subroutine assign_alpha(alpha,alp)\n!***** input\n!*****   alpha : medium constant  (lambda+myu)/(lambda+2*myu)\n!***** output\n!*****   alp   : coefficients related to alpha value\n    implicit none\n    real*8, intent(in) :: alpha\n    real*8, intent(out) :: alp(5)\n    alp(1)=(1.0d0-alpha)/2.0d0\n    alp(2)= alpha/2.0d0\n    alp(3)=(1.0d0-alpha)/alpha\n    alp(4)=1.0d0-alpha\n    alp(5)=alpha\n    return\nend subroutine assign_alpha\n"}, {"instruction": "Create a Fortran subroutine named varout that takes an array of 12 real*8 numbers as input and outputs 12 real*8 values: ux, uy, uz, uxx, uyx, uzx, uxy, uyy, uzy, uxz, uyz, and uzz. The input parameter is of type real*8 and the output parameters are of type real*8.", "input": "", "output": "subroutine varout(u,ux,uy,uz,uxx,uyx,uzx,uxy,uyy,uzy,uxz,uyz,uzz)\n    implicit none\n    real*8, intent(in) :: u(12)\n    real*8, intent(out) :: ux,uy,uz,uxx,uyx,uzx,uxy,uyy,uzy,uxz,uyz,uzz\n    ux=u(1)\n    uy=u(2)\n    uz=u(3)\n    uxx=u(4)\n    uyx=u(5)\n    uzx=u(6)\n    uxy=u(7)\n    uyy=u(8)\n    uzy=u(9)\n    uxz=u(10)\n    uyz=u(11)\n    uzz=u(12)\n    return\nend subroutine varout\n"}, {"instruction": "Create a Fortran subroutine named calc_nnz_csrab to calculate the number of non-zero elements in a compressed sparse row (CSR) matrix. The subroutine takes 6 input parameters of type integer: nrow, ncol, ia(*), ja(*), ib(*), jb(*), and one output parameter of type integer: nnz.", "input": "", "output": "    subroutine calc_nnz_csrab(nrow,ncol,ia,ja,ib,jb,nnz)\n    integer,intent(in)::nrow,ncol,ia(*),ja(*),ib(*),jb(*)\n    integer,intent(out)::nnz\n\n    integer i,j,j1,k,k1\n    logical lzero(ncol)\n\n    nnz=0\n    do i=1,nrow\n        lzero=.true.\n        do j1=ia(i),ia(i+1)-1\n            j=ja(j1)\n            do k1=ib(j),ib(j+1)-1\n                k=jb(k1)\n                if(lzero(k))then\n                    nnz=nnz+1\n                    lzero(k)=.false.\n                endif\n            enddo\n        enddo\n    enddo\n    return\n\n    end subroutine calc_nnz_csrab\n"}, {"instruction": "Create a Fortran subroutine named lockad to process logical input and output parameters. The subroutine takes 1 input parameter of type logical and returns 3 output parameters of type logical. The subroutine processes the input and sets the output parameters based on certain conditions.", "input": "", "output": "      subroutine lockad(closed, med, slut, expand)\n!...translated by pacific-sierra research 77to90  4.3e  14:44:54  12/27/06\n!...switches:\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      logical , intent(out) :: slut\n      logical , intent(in) :: expand\n      logical , intent(out) :: closed(15,0:10)\n      logical , intent(out) :: med(15,0:10)\n!-----------------------------------------------\n!   l o c a l   p a r a m e t e r s\n!-----------------------------------------------\n      integer, parameter :: fil_1 = 7\n      integer, parameter :: fil_2 = 8\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: i, j, n, l\n      character :: rad*1000\n      character, dimension(0:10) :: orb\n!-----------------------------------------------\n      data (orb(i),i=0,10)/ 's', 'p', 'd', 'f', 'g', 'h', 'i', 'k', 'l', 'm', &\n         'n'/\n      if (expand) then\n         read (fil_2, *, end=40)\n         read (fil_2, 100, end=40) rad\n      else\n         read (fil_1, *, end=40)\n         read (fil_1, 100, end=40) rad\n      endif\n      do n = 1, 15\n         closed(n,1:min(10,n-1)) = .false.\n      end do\n      l30: do i = 0, 205\n         j = i*5\n         n = ichar(rad(j+3:j+3)) - ichar('0')\n         if (n>=1 .and. n<=15) then\n            do l = 0, min(10,n - 1)\n               if (rad(j+4:j+4) /= orb(l)) cycle\n               closed(n,l) = .true.\n               cycle  l30\n            end do\n         else\n            exit  l30\n         endif\n      end do l30\n      if (expand) then\n         read (fil_2, *, end=40)\n         read (fil_2, 100, end=40) rad\n      else\n         read (fil_1, *, end=40)\n         read (fil_1, 100, end=40) rad\n      endif\n      do n = 1, 15\n         med(n,1:min(10,n-1)) = .false.\n      end do\n      l130: do i = 0, 205\n         j = i*5\n         n = ichar(rad(j+3:j+3)) - ichar('0')\n         if (n>=1 .and. n<=15) then\n            do l = 0, min(10,n - 1)\n               if (rad(j+4:j+4) /= orb(l)) cycle\n               med(n,l) = .true.\n               cycle  l130\n            end do\n         else\n            return\n         endif\n      end do l130\n\n      return\n   40 continue\n      slut = .true.\n      return\n  100 format(a)\n      return\n      end subroutine lockad\n"}, {"instruction": "Write a Fortran subroutine named kendallstau to calculate Kendall's tau, a measure of association between two datasets. The subroutine takes 3 input parameters of type integer, real, and real, representing the dimension of the data set, data set 1, and data set 2, and 1 output parameter of type real, representing the calculated Kendall's tau.", "input": "", "output": "  subroutine kendallstau(n,data1,data2,tau)\r\n    \r\n    !argument declaration\r\n    integer, intent(in) :: n          !<dimension of data set\r\n    real, intent(in)    :: data1(n)   !<data set 1\r\n    real, intent(in)    :: data2(n)   !<data set 2\r\n    real, intent(out)   :: tau        !<calculated kendalls tau\r\n    \r\n    !variable declarations\r\n    integer j,k       !loop variables\r\n    integer is,n1,n2  !number of pairs\r\n    real a1,a2,aa     !help variables\r\n    \r\n    if(n==0)return    !no data\r\n    n1=0\r\n    n2=0\r\n    is=0\r\n    do j=1,n-1\r\n      do k=j+1,n\r\n        a1=data1(j)-data1(k)\r\n        a2=data2(j)-data2(k)\r\n        aa=a1*a2\r\n        if(aa.ne.0.)then\r\n          n1=n1+1\r\n          n2=n2+1\r\n          if(aa.gt.0.)then\r\n            is=is+1\r\n          else\r\n            is=is-1\r\n          endif\r\n        else\r\n          if(a1.ne.0.)n1=n1+1\r\n          if(a2.ne.0.)n2=n2+1\r\n        endif\r\n      enddo\r\n    enddo\r\n    tau = real(is)/sqrt(real(n1)*real(n2))\r\n    \r\n  end subroutine kendallstau\r\n"}, {"instruction": "Create a Fortran subroutine named calculate_meanmedian_number_of_observations that takes 3 input parameters of type integer, real, and real, and 1 output parameter of type real. The subroutine calculates the number of areas with criteria based on the given criteria values and the missing value.", "input": "", "output": "  subroutine calculate_meanmedian_number_of_observations(dim,crit,miss,num)\r\n\r\n    !argument declarations\r\n    integer, intent(in)  :: dim    !<number of areas\r\n    real, intent(in)  :: crit(dim)  !<criteria value for areas\r\n    real, intent(in)  :: miss       !<missing value\r\n    real, intent(out) :: num    !<number of areas with criteria\r\n    \r\n    !local variables\r\n    integer isb\r\n    \r\n    num = 0.\r\n    do isb = 1,dim\r\n      if(crit(isb)/=miss) then\r\n        num = num + 1.\r\n      endif\r\n    enddo\r\n    \r\n  end subroutine calculate_meanmedian_number_of_observations\r\n"}, {"instruction": "Create a Fortran subroutine named com_time2ymdh that takes an 8-byte integer itime as input and returns four integers iy, im, id, and ih. The subroutine extracts the year, month, day, and hour from itime and assigns them to iy, im, id, and ih, respectively.", "input": "", "output": "subroutine com_time2ymdh(itime,iy,im,id,ih)\n  implicit none\n  integer(8),intent(in) :: itime\n  integer,intent(out) :: iy\n  integer,intent(out) :: im\n  integer,intent(out) :: id\n  integer,intent(out) :: ih\n\n  iy = int(  itime / 1000000 )\n  im = int( (itime-iy*1000000) / 10000 )\n  id = int( (itime-iy*1000000-im*10000) / 100 )\n  ih = int(  itime-iy*1000000-im*10000-id*100 )\n\n  return\nend subroutine com_time2ymdh\n"}, {"instruction": "Write a Fortran subroutine named com_ymdh2time to convert the date and hour components into a single time value. The subroutine should take 4 input parameters of type integer (iy, im, id, ih) and produce 1 output parameter of type integer(8) (itime).", "input": "", "output": "subroutine com_ymdh2time(iy,im,id,ih,itime)\n  implicit none\n  integer,intent(in) :: iy\n  integer,intent(in) :: im\n  integer,intent(in) :: id\n  integer,intent(in) :: ih\n  integer(8),intent(out) :: itime\n\n  itime=iy*1000000+im*10000+id*100+ih\n\n  return\nend subroutine com_ymdh2time\n"}, {"instruction": "Create a Fortran subroutine named setfouunit to assign units to different variables based on the given parameters. The subroutine takes 4 input parameters of types ['character(*)', 'integer', 'integer', 'integer'] and returns 1 output parameter of type ['character(*)'].", "input": "", "output": "subroutine setfouunit(founam, lsal, ltem, fconno, fouvarunit)\n    !\n    ! parameters\n    character(*), intent(in)  :: founam\n    integer     , intent(in)  :: lsal\n    integer     , intent(in)  :: ltem\n    integer     , intent(in)  :: fconno\n    character(*), intent(out) :: fouvarunit\n    !\n    ! body\n    select case (founam(:2))\n    case ('s1')\n       fouvarunit = 'm'\n    case ('u1', 'v1')\n       fouvarunit = 'm/s'\n    case ('ta')\n       fouvarunit = 'n/m2'\n    case ('r1')\n       if (fconno == ltem) then\n          fouvarunit = 'degrees_celsius'\n       elseif (fconno == lsal) then\n          fouvarunit = 'ppt'\n       else\n          fouvarunit = 'kg/m3'\n       endif\n    case default\n       fouvarunit = ''\n    end select \nend subroutine setfouunit\n"}, {"instruction": "Create a Fortran subroutine named load_matlab_mesh to read mesh data from a file. The subroutine should have 1 input parameter of type character(len=*) and 1 output parameter of type real(8), allocatable.", "input": "", "output": "    subroutine load_matlab_mesh(filename, mesh)\n        character(len=*), intent(in) :: filename\n        real(8), allocatable, intent(out) :: mesh(:, :)\n\n        integer :: n_points, n\n        integer, parameter :: file_id = 1\n\n        open(unit=file_id, file=filename, status=\"old\", action=\"read\")\n\n        read(file_id, *) n_points\n        allocate(mesh(n_points, 3))\n\n        ! format:\n        ! npoints\n        ! x1 y1 z1\n        ! x2 y2 z2\n        do n = 1, n_points\n            read(file_id,*) mesh(n, 1), mesh(n, 2), mesh(n, 3)\n        end do\n\n        close(file_id)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"diffuse\" to perform a diffusion simulation over a specified number of timesteps. The subroutine takes 7 input parameters of type integer and real(kind=8), and one output parameter of type real(kind=8) with dimensions nx and ny. The input parameters are timesteps, nx, ny, nu, dt, dx, dy, and the output parameter is u. The subroutine uses nested do-loops to update the values of u based on the diffusion equation and boundary conditions.", "input": "", "output": "subroutine diffuse(timesteps, u, nu, dt, dx, dy, nx, ny)\n    implicit none\n    integer, intent(in) :: nx, ny, timesteps\n    real(kind=8), intent(in) :: nu, dt, dx, dy\n    real(kind=8), intent(out), dimension(nx,ny) :: u\n    real(kind=8), dimension(nx,ny) :: un\n    integer :: i, j, time\n    real(kind=8) :: ydisip, xdisip, yderiv, xderiv\n    time = timesteps\n\n    do time = 1, time\n            un = u\n        \n            do j=2, nx-1\n                do i=2, ny-1\n                    xderiv = (nu * dt) / (dx**2)\n                    yderiv = (nu * dt) / (dy**2)\n                    xdisip = un(j,i+1) - (2 * un(j,i)) + un(j,i-1)\n                    ydisip = un(j+1,i) - (2 * un(j,i)) + un(j-1,i)\n                    \n                    u(j,i) = un(j,i) + (xderiv * xdisip) + (yderiv * ydisip)\n\n                    u(1,j) = 1\n                    u(nx,j) = 1\n                    u(i,1) = 1\n                    u(i,ny) = 1\n        \n                    u(1,1) = 1\n                    u(1,nx) = 1\n                    u(ny,1) = 1\n                    u(ny,nx) = 1\n                end do\n            end do\n        end do\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named linear_interp to perform 2-point linear interpolation. The subroutine takes 3 input parameters of type real*8 and 2 output parameters of type real*8 and integer. The input parameters represent the point where the function is needed and the 2 points from the tables. The output parameters represent the function value at the given point and an error indicator. The subroutine uses the selected_real_kind function and follows Fortran's implicit none convention.", "input": "", "output": "subroutine linear_interp(x,x_tables,f_tables,fx,ierr)\n! 2 points linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x ! point where function needed\n  real*8, intent(in) ::x_tables(2),f_tables(2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx\n\n  ierr=0\n  hx=(x_tables(2)-x_tables(1))\n  if(hx.eq.0.0_r8) then\n     ierr=1\n     return\n  endif\n  fx = f_tables(1)+(x-x_tables(1))/hx*(f_tables(2)-f_tables(1))\n  return\n  \nend subroutine linear_interp\n"}, {"instruction": "Create a Fortran subroutine named linear_interp_2d to perform a 2D linear interpolation. The subroutine takes 3 input parameters with the test_data type ['real*8', 'real*8', 'real*8'] and returns 2 output parameters with the test_data type ['real*8', 'integer']. The subroutine uses the imperative tone to compute the function value at a given point using 4 points 2D linear interpolation formula.", "input": "", "output": "subroutine linear_interp_2d(x,x_tables,f_tables,fx,ierr)\n! 4 points 2d linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x(2) ! point where function needed\n  real*8, intent(in) ::x_tables(4),f_tables(2,2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx1,hx2,pe,qn,pe1,qn1\n\n  ierr=0\n  hx1=(x_tables(2)-x_tables(1))\n  hx2=(x_tables(4)-x_tables(3))\n  if((hx1.eq.0.0_r8).or.(hx2.eq.0.0_r8)) then\n     ierr=1\n     return\n  endif\n  !pe=(e-e0)/(e1-e0)\n  pe=(x(1)-x_tables(1))/hx1\n  !qn=(n-n0)/(n1-n0)\n  qn=(x(2)-x_tables(3))/hx2\n  !1-pe=(e1-e)/(e1-e0)\n  pe1=1.0_r8 - pe\n  !1-qn=(n1-n)/(n1-n0)\n  qn1=1.0_r8 - qn\n  !four points linear extrapolation\n  fx = pe1*qn1*f_tables(1,1)+pe*qn1*f_tables(2,1)+qn*pe1*f_tables(1,2)+&\n       &pe*qn*f_tables(2,2)\n  return\n  \nend subroutine linear_interp_2d\n"}, {"instruction": "Create a Fortran subroutine named check_lu that calculates the LU decomposition check values. The subroutine takes one input parameter of type real(8) and outputs an array of three real(8) values. The input parameter is intent(in) and the output parameter is intent(out).", "input": "", "output": "  subroutine check_lu( check, t )\n    implicit none\n    real(8),intent(out) :: check(3)\n    real(8),intent(in)  :: t(:,:)\n    integer :: i,j\n    do j=1,size(t,2)\n    do i=1,size(t,1)\n       if ( i <  j ) check(1)=check(1)+abs( t(i,j) )\n       if ( j <  i ) check(2)=check(2)+abs( t(i,j) )\n       if ( i == j ) check(3)=check(3)+abs( t(i,j) )\n    end do\n    end do\n  end subroutine check_lu\n"}, {"instruction": "Write a Fortran subroutine named fill to fill a 2D array with random integer values. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "  subroutine fill(a,n)\n    integer, intent(out), dimension(:,:) :: a\n    integer, intent(in) :: n\n    real, dimension(size(a,1),size(a,2)) :: r\n    call random_number(r)\n    a = int(2*n*r-n)\n  end subroutine fill\n"}, {"instruction": "Create a Fortran subroutine named \"emul_cshift\" to perform circular shift operation on a 3D array. The subroutine should take 3 input parameters of type integer, dimension(:,:,:), integer, dimension(:,:), and integer, and 1 output parameter of type integer, dimension(:,:,:).\n", "input": "", "output": "  subroutine emul_cshift(a,sh_in,dim, c)\n    integer, dimension(:,:,:), intent(in) :: a\n    integer, dimension(:,:,:), intent(out) :: c\n    integer, dimension(:,:), intent(in) :: sh_in\n    integer, intent(in) :: dim\n    integer :: sh, rsh\n    integer :: s1, s2, s3, n, i\n    integer :: n1, n2, n3\n    n1 = size(a,1)\n    n2 = size(a,2)\n    n3 = size(a,3)\n    if (dim == 1) then\n       n = n1\n       do s2=1,n2\n          do s3=1,n3\n             sh = modulo(sh_in(s2,s3), n)\n             rsh = n - sh\n             do i=1,rsh\n                c(i,s2,s3) = a(i+sh,s2,s3)\n             end do\n             do i=rsh+1,n\n                c(i,s2,s3) = a(i-rsh,s2,s3)\n             end do\n          end do\n       end do\n    else if (dim == 2) then\n       n = n2\n       do s3=1,n3\n          do s1=1,n1\n             sh = modulo(sh_in(s1,s3),n)\n             rsh = n - sh\n             do i=1,rsh\n                c(s1,i,s3) = a(s1,i+sh,s3)\n             end do\n             do i=rsh+1,n\n                c(s1,i,s3) = a(s1,i-rsh,s3)\n             end do\n          end do\n       end do\n\n    else if (dim == 3) then\n       n = n3\n       do s2=1,n2\n          do s1=1,n1\n             sh = modulo(sh_in(s1,s2),n)\n             rsh = n - sh\n             do i=1,rsh\n                c(s1,s2,i) = a(s1,s2,i+sh)\n             end do\n             do i=rsh+1,n\n                c(s1,s2,i) = a(s1,s2,i-rsh)\n             end do\n          end do\n       end do\n    else\n       stop \"illegal dim\"\n    end if\n  end subroutine emul_cshift\n"}, {"instruction": "Create a Fortran subroutine named minmod that takes three input parameters of types integer, real, and real, and one output parameter of type real. The subroutine computes the minimum of the absolute values of corresponding elements from the input arrays a and b, and sets the result in the output array c.", "input": "", "output": "subroutine minmod(c,a,b,nnn)\n    implicit none\n    ! argument list\n    integer, intent(in)   :: nnn\n    real, intent(in)      :: a(nnn), b(nnn)\n    real, intent(out)     :: c(nnn)\n    ! local variables\n    integer :: i\n\n    do i = 1, nnn\n        if (a(i)*b(i) .le. 0.0) then\n            c(i) = 0.0\n        else\n            if( abs(a(i)) .lt. abs(b(i)) ) then\n                c(i) = a(i)\n            else\n                c(i) = b(i)\n            end if\n        end if\n    end do\n\nend subroutine minmod\n"}, {"instruction": "Create a Fortran subroutine named repeat_bounds to handle the boundary conditions for a given cell in a grid. The subroutine takes 4 input parameters of type integer, integer, real*8, and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine repeat_bounds(cell,delta,grid_max,ncell_max,position)\nimplicit none\ninteger, intent(in) :: cell, ncell_max\nreal*8, intent(in) :: delta, grid_max\nreal*8, intent(out) :: position\n\nif (cell.lt.1) then\n  position=grid_max-delta\nelseif (cell.gt.ncell_max) then\n  position=delta\nelse\n  print*,'error in repeat bounds'\nendif\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cdiff2d to calculate the central difference of a 2D field along the specified axis. The subroutine takes 4 input parameters of types integer, integer, integer, and real, and one output parameter of type real.", "input": "", "output": "subroutine cdiff2d(ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(ysize,xsize)\n      real, intent(out) :: output(ysize,xsize)\n      integer dd1, dd2\n      integer i, j\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==1) then !x\n         dd1 = 1\n      elseif (axis==0) then !y\n         dd2 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do j=1+dd2,ysize-dd2\n         do i=1+dd1,xsize-dd1\n            if ((field(j+dd2,i+dd1)>-999.0).and.(field(j-dd2,i-dd1)>-999.0)) then\n               output(j,i) = field(j+dd2,i+dd1) - field(j-dd2,i-dd1)\n            endif\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff2d\n"}, {"instruction": "Create a Fortran subroutine named cdiff3d to calculate the finite difference along a specified axis in a 3D field. The subroutine takes 5 input parameters of types integer, integer, integer, integer, and real, representing the size of the field in the z, y, and x dimensions, the axis along which to calculate the difference, and the field itself. It also has 1 output parameter of type real, representing the resulting difference field.", "input": "", "output": "subroutine cdiff3d(zsize, ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: zsize, ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(zsize,ysize,xsize)\n      real, intent(out) :: output(zsize,ysize,xsize)\n      integer dd1, dd2, dd3\n      integer i, j, z\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      dd3 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==2) then\n         dd1 = 1\n      elseif (axis==1) then\n         dd2 = 1\n      elseif (axis==0) then\n         dd3 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do z=1+dd3,zsize-dd3\n         do j=1+dd2,ysize-dd2\n            do i=1+dd1,xsize-dd1\n               if ((field(z+dd3,j+dd2,i+dd1)>-999.0).and.(field(z-dd3,j-dd2,i-dd1)>-999.0)) then\n                  output(z,j,i) = field(z+dd3,j+dd2,i+dd1) - field(z-dd3,j-dd2,i-dd1)\n               endif\n            enddo\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff3d\n"}, {"instruction": "Create a Fortran subroutine named cdiff4d to calculate the 4-dimensional central difference of a given field along a specified axis. The subroutine takes 6 input parameters of type integer and real: tsize, zsize, ysize, xsize, field, and axis. It also has 1 output parameter of type real: output. The subroutine uses imperative tone to perform the central difference calculations and updates the output array according to the specified axis.", "input": "", "output": "subroutine cdiff4d(tsize, zsize, ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: tsize, zsize, ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(tsize,zsize,ysize,xsize)\n      real, intent(out) :: output(tsize,zsize,ysize,xsize)\n      integer dd1, dd2, dd3, dd4\n      integer i, j, z, t\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      dd3 = 0\n      dd4 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==3) then\n         dd1 = 1\n      elseif (axis==2) then\n         dd2 = 1\n      elseif (axis==1) then\n         dd3 = 1\n      elseif (axis==0) then\n         dd4 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do t=1+dd4,tsize-dd4\n         do z=1+dd3,zsize-dd3\n            do j=1+dd2,ysize-dd2\n               do i=1+dd1,xsize-dd1\n                  if ((field(t+dd4,z+dd3,j+dd2,i+dd1)>-999.0).and.(field(t-dd4,z-dd3,j-dd2,i-dd1)>-999.0)) then\n                     output(t,z,j,i) = field(t+dd4,z+dd3,j+dd2,i+dd1) - field(t-dd4,z-dd3,j-dd2,i-dd1)\n                  endif\n               enddo\n            enddo\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff4d\n"}, {"instruction": "Create a Fortran subroutine named \"interp_vec\" that takes 3 input parameters of type real, dimension(:), real, and logical, and 4 output parameters of type integer, integer, real, and real. The subroutine is designed to perform vector interpolation and determine the indices and weights for interpolation.", "input": "", "output": "  subroutine interp_vec(locvec,locwant,periodic,loc1,loc2,wght1,wght2)\n  implicit none\n  real, intent(in), dimension(:) :: locvec\n  real, intent(in) :: locwant\n  logical, intent(in) :: periodic\n  integer, intent(out) :: loc1, loc2\n  real, intent(out) :: wght1, wght2\n  integer :: vsize, n\n  real :: locv1, locv2\n  vsize = size(locvec)\n  loc1 = -1\n  loc2 = -1\n  do n = 1, vsize-1\n    if ( locvec(n) <= locwant .and. locvec(n+1) > locwant ) then\n      loc1 = n\n      loc2 = n+1\n      locv1 = locvec(n)\n      locv2 = locvec(n+1)\n      exit\n    end if\n  end do\n  if ( loc1 < 0 .and. loc2 < 0 ) then\n    if ( periodic ) then\n      if ( locwant < locvec(1) ) then\n        loc1 = vsize\n        loc2 = 1\n        locv1 = locvec(vsize)-360.0\n        locv2 = locvec(1)\n      else\n        loc1 = vsize\n        loc2 = 1\n        locv1 = locvec(vsize)\n        locv2 = locvec(1)+360.0\n      end if\n    else\n      if ( locwant < locvec(1) ) then\n        loc1 = 1\n        loc2 = 1\n        locv1 = locvec(1)\n        locv2 = locvec(1)\n      else\n        loc1 = vsize\n        loc2 = vsize\n        locv1 = locvec(vsize)\n        locv2 = locvec(vsize)\n      end if\n    end if\n  end if\n  wght2 = (locwant-locv1) / (locv2-locv1)\n  wght1 = 1.0 - wght2\n  return\n  end subroutine interp_vec\n"}, {"instruction": "Create a Fortran subroutine named bezlin that takes two input arguments of type real arrays and one output argument of type real array. The input arrays a and b represent the start and end points of a line segment, while the output array p stores a set of points that lie on the line segment between a and b.", "input": "", "output": "  pure subroutine bezlin(a, b, p)\n    real, intent(in) :: a(:), b(:)\n    real, intent(out) :: p(:, :)\n    real :: dx(size(a))\n    integer :: i, j, n\n\n    dx = b - a\n    n = size(p, 2) - 1\n    do i = 0, n\n      j = i + 1\n      p(:, j) = dx * real(i) / n + a\n    end do\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named davis_etal_2008 to calculate the roughness length z_0 based on the input ustar. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real]. The subroutine uses the imperative tone.", "input": "", "output": "   subroutine davis_etal_2008(z_0,ustar)\n       implicit none\n       real, intent(in) :: ustar\n       real, intent(out) :: z_0\n       real :: zw, zn1, zn2\n       real, parameter :: g=9.81, ozo=1.59e-5\n       zw = min((ustar/1.06)**(0.3),1.0)\n       zn1 = 0.011*ustar*ustar/g + ozo\n       zn2 = 10.*exp(-9.5*ustar**(-.3333)) + &\n             0.11*1.5e-5/amax1(ustar,0.01)\n       z_0 = (1.0-zw) * zn1 + zw * zn2\n       z_0 = max( z_0, 1.27e-7)\n       z_0 = min( z_0, 2.85e-3)\n       return\n   end subroutine davis_etal_2008\n"}, {"instruction": "Create a Fortran subroutine named \"garratt_1992\" with 3 input parameters of type real and 2 output parameters of type real. The inputs are ren, z_0, and landsea, and the outputs are zt and zq. The subroutine calculates zt and zq based on the values of ren, z_0, and landsea, using conditional statements and mathematical operations. Remember to use the \"intent(in)\" and \"intent(out)\" attributes to specify the purpose of each parameter.", "input": "", "output": "   subroutine garratt_1992(zt,zq,z_0,ren,landsea)\n       implicit none\n       real, intent(in) :: ren, z_0,landsea\n       real, intent(out) :: zt,zq\n       real :: rq\n       real, parameter :: e=2.71828183\n       if (landsea-1.5 .gt. 0) then\n          zt = z_0*exp(2.0 - (2.48*(ren**0.25)))\n          zq = z_0*exp(2.0 - (2.28*(ren**0.25)))\n          zq = min( zq, 5.5e-5)\n          zq = max( zq, 2.0e-9)\n          zt = min( zt, 5.5e-5)\n          zt = max( zt, 2.0e-9)\n       else\n          zq = z_0/(e**2.)\n          zt = zq\n       endif\n       return\n    end subroutine garratt_1992\n"}, {"instruction": "Create a Fortran subroutine named fairall_2001, which takes 3 input arguments of type real and returns 2 output arguments of type real. The function calculates the values of zt and zq based on the input parameters ren, ustar, and visc. The calculated values are then constrained to a specific range before being returned.", "input": "", "output": "    subroutine fairall_2001(zt,zq,ren,ustar,visc)\n       implicit none\n       real, intent(in) :: ren,ustar,visc\n       real, intent(out) :: zt,zq\n       if (ren .le. 2.) then\n          zt = (5.5e-5)*(ren**(-0.60))\n          zq = 0.2*visc/max(ustar,0.1)\n       else\n          zt = (5.5e-5)*(ren**(-0.60))\n          zq = zt\n       endif\n       zt = min(zt,1.0e-4)\n       zt = max(zt,2.0e-9)\n       zq = min(zt,1.0e-4)\n       zq = max(zt,2.0e-9)\n       return\n    end subroutine fairall_2001\n"}, {"instruction": "Write a Fortran subroutine named yang_2008 that calculates the values of zt and zq based on the input parameters z_0, zt, zq, ustar, tstar, qst, ren, visc, and landsea. The number of input arguments is 7 and the test_data type is [real, real, real, real, real, real, real]. The number of output arguments is 2 and the test_data type is [real, real].", "input": "", "output": "    subroutine yang_2008(z_0,zt,zq,ustar,tstar,qst,ren,visc,landsea)\n       implicit none\n       real, intent(in) :: z_0, ren, ustar, tstar, qst, visc, landsea\n       real :: ht, tstar2\n       real, intent(out) :: zt,zq\n       real, parameter :: renc=350., beta=0.5, e=2.71828183\n       ht = renc*visc/max(ustar,0.01)\n       tstar2 = min(tstar, 0.0)\n       zt = ht * exp(-beta*(ustar**0.5)*(abs(tstar2)**1.0))\n       zq = zt\n       zt = min(zt, z_0/2.0)\n       zq = min(zq, z_0/2.0)\n       return\n    end subroutine yang_2008\n"}, {"instruction": "Create a Fortran subroutine named psi_beljaars_holtslag_1991 to calculate the Beljaars and Holtslag (1991) universal stability functions. The subroutine should take 1 input argument of type real and provide 2 output arguments of type real. The input parameter should represent the stability parameter zl. The first output parameter, psi_m, represents the momentum flux stability function, and the second output parameter, psi_h, represents the sensible heat flux stability function.", "input": "", "output": "    subroutine psi_beljaars_holtslag_1991(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: a=1., b=0.666, c=5., d=0.35\n       if (zl .lt. 0.) then\n          write(*,*)\"warning: universal stability functions from\"\n          write(*,*)\"        beljaars and holtslag (1991) should only\"\n          write(*,*)\"        be used in the stable regime!\"\n          psi_m = 0.\n          psi_h = 0.\n       else\n          psi_m = -(a*zl + b*(zl -(c/d))*exp(-d*zl) + (b*c/d))\n          psi_h = -((1.+.666*a*zl)**1.5 + &\n                  b*(zl - (c/d))*exp(-d*zl) + (b*c/d) -1.)\n       endif\n       return\n    end subroutine psi_beljaars_holtslag_1991\n"}, {"instruction": "Create a Fortran subroutine named psi_zilitinkevich_esau_2007 to calculate the Monin-Obukhov stability functions psi_m and psi_h based on the input stability parameter zl, which is a real number. The subroutine should have 1 input parameter of type real and 2 output parameters of type real. If zl is less than 0, the subroutine should issue a warning message and set both psi_m and psi_h to 0. Otherwise, it should calculate psi_m and psi_h based on the zl value using specific formulas.", "input": "", "output": "    subroutine psi_zilitinkevich_esau_2007(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: cm=3.0, ct=2.5\n       if (zl .lt. 0.) then\n          write(*,*)\"warning: universal stability function from\"\n          write(*,*)\"        zilitinkevich and esau (2007) should only\"\n          write(*,*)\"        be used in the stable regime!\"\n          psi_m = 0.\n          psi_h = 0.\n       else\n          psi_m = -cm*(zl**(5./6.))\n          psi_h = -ct*(zl**(4./5.))\n       endif\n       return\n    end subroutine psi_zilitinkevich_esau_2007\n"}, {"instruction": "Create a Fortran subroutine named psi_businger_1971 to calculate the Monin-Obukhov stability functions psi_m and psi_h based on the input stability parameter z/l. The subroutine has 1 input parameter of type real and 2 output parameters of type real.", "input": "", "output": "    subroutine psi_businger_1971(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real :: x, y\n       real, parameter :: pi180 = 3.14159265/180.\n       if (zl .lt. 0.) then\n          x = (1. - 15.0*zl)**0.25\n          y = (1. - 9.0*zl)**0.5\n          psi_m = log(((1.+x)/2.)**2.) + &\n                 &log((1.+x**2.)/2.) - &\n                 &2.0*atan(x) + pi180*90.\n          psi_h = 2.*log((1.+y)/2.)\n       else\n          psi_m = -4.7*zl\n          psi_h = -(4.7/0.74)*zl\n       endif\n       return\n    end subroutine psi_businger_1971\n"}, {"instruction": "Write a Fortran subroutine named psi_suselj_sood_2010 to calculate the values of psi_m and psi_h based on the value of zl. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type real. The input parameter represents zl, while the output parameters represent psi_m and psi_h, respectively. Use the provided mathematical expressions to calculate the values of psi_m and psi_h based on the value of zl.", "input": "", "output": "    subroutine psi_suselj_sood_2010(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: rfc=0.19, ric=0.183, phit=0.8\n       if (zl .gt. 0.) then\n          psi_m = -(zl/rfc + 1.1223*exp(1.-1.6666/zl))\n          psi_h = -(zl*ric/((rfc**2.)*5.) + 7.09*(zl**1.1091))\n       else\n          psi_m = 0.9904*log(1. - 14.264*zl)\n          psi_h = 1.0103*log(1. - 16.3066*zl)\n       endif\n       return\n    end subroutine psi_suselj_sood_2010\n"}, {"instruction": "Create a Fortran subroutine named \"li_etal_2010\" to calculate the stability parameter \"zl\" based on input parameters \"rib\", \"zaz0\", and \"z0zt\", which are real numbers. The subroutine takes 3 input parameters of type real and returns 1 output parameter of type real. ", "input": "", "output": "    subroutine li_etal_2010(zl, rib, zaz0, z0zt)\n       implicit none\n       real, intent(out) :: zl\n       real, intent(in) :: rib, zaz0, z0zt\n       real :: alfa, beta, zaz02, z0zt2\n       real, parameter :: au11=0.045, bu11=0.003, bu12=0.0059, &\n                          &bu21=-0.0828, bu22=0.8845, bu31=0.1739, &\n                          &bu32=-0.9213, bu33=-0.1057\n       real, parameter :: aw11=0.5738, aw12=-0.4399, aw21=-4.901,&\n                          &aw22=52.50, bw11=-0.0539, bw12=1.540, &\n                          &bw21=-0.669, bw22=-3.282\n       real, parameter :: as11=0.7529, as21=14.94, bs11=0.1569,&\n                          &bs21=-0.3091, bs22=-1.303\n       zaz02=zaz0\n       if (zaz0 .lt. 100.0) zaz02=100.\n       if (zaz0 .gt. 100000.0) zaz02=100000.\n       z0zt2=z0zt\n       if (z0zt .lt. 0.5) z0zt2=0.5\n       if (z0zt .gt. 100.0) z0zt2=100.\n       alfa = log(zaz02)\n       beta = log(z0zt2)\n       if (rib .le. 0.0) then\n          zl = au11*alfa*rib**2 + ( &\n               & (bu11*beta + bu12)*alfa**2 + &\n               & (bu21*beta + bu22)*alfa + &\n               & (bu31*beta**2 + bu32*beta + bu33))*rib\n          zl = max(zl,-15.)\n          zl = min(zl,0.)\n       elseif (rib .gt. 0.0 .and. rib .le. 0.2) then\n          zl = ((aw11*beta + aw12)*alfa + &\n             & (aw21*beta + aw22))*rib**2 + &\n             & ((bw11*beta + bw12)*alfa + &\n             & (bw21*beta + bw22))*rib\n          zl = min(zl,4.)\n          zl = max(zl,0.)\n       else\n          zl = (as11*alfa + as21)*rib + bs11*alfa + &\n             & bs21*beta + bs22\n          zl = min(zl,20.)\n          zl = max(zl,1.)\n       endif\n       return\n    end subroutine li_etal_2010\n"}, {"instruction": "Create a Fortran subroutine named assemble_system1 to assemble a linear system. It takes 1 input parameter of type integer. The output parameters are 3 arrays of type real(8).", "input": "", "output": "  subroutine assemble_system1(npts, a, b, x0)\n\n    implicit none\n\n    integer, intent(in)  :: npts\n    real(8), intent(out) :: a(npts,npts)\n    real(8), intent(out) :: b(npts)\n    real(8), intent(out) :: x0(npts)\n\n    integer :: m, n\n    integer :: i, j, k\n\n    ! zero all entries\n    a = 0.0d0\n\n    ! size of the linear system\n    m = npts ! nrows\n    n = npts ! ncols\n\n    ! assemble matrix\n    a(m,1) = 1.0d0\n    a(1,n) = 1.0d0\n    forall(i=1:m-1) a(i,i+1) = 1.0d0\n\n    ! assemble right hand side\n    b = 0.0d0\n    b(1) = 1.0d0\n\n    ! initial guess\n    x0 = 0.0d0\n\n  end subroutine assemble_system1\n"}, {"instruction": "Write a Fortran subroutine named msa to perform a two-dimensional Multiscale Shock Algorithm (MSA). The subroutine takes 5 input parameters of types integer, integer, real*8, real*8, and real*8 and 1 output parameter of type real*8.\n\nThe input parameters are x0 (input and output), n1 (integer), n2 (integer), y0 (real*8 array), x0 (real*8 array), and stepsize (real*8). The output parameter is x1 (real*8 array).\n\nThe subroutine calculates the updated values of x1 based on the input values of x0, y0, and stepsize using the Multiscale Shock Algorithm.", "input": "", "output": "    subroutine msa(x0,y0,x1,stepsize,n1,n2) ! two dimension msa\n    implicit none\n! x0 is input and also output\n    integer,intent(in)::n1,n2! two dimension\n    real*8,intent(in)::y0(n1,n2)\n    real*8,intent(in)::x0(n1,n2)\n    real*8,intent(out)::x1(n1,n2)\n    real*8,intent(in)::stepsize\n    integer:: i,j\n\n    x1=0.0\n    do i=1,n2\n      do j=1,n1\n        x1(j,i)=x0(j,i)+stepsize*(y0(j,i)-x0(j,i))\n      enddo \n    enddo \n    return \n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named nearsquare to find two nearest square numbers to the given integer n. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 2 and the test_data type is [integer, integer].", "input": "", "output": "    subroutine nearsquare(n, a, b)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: a, b\n\n        do a=ceiling(sqrt(n*1.0)),1,-1\n            b = n/a\n            if (a*b == n) exit\n        enddo\n    end subroutine nearsquare\n"}, {"instruction": "Create a Fortran subroutine named make_seeds to generate a sequence of random integer numbers. The subroutine takes 2 input parameters of type integer and returns an array of integer numbers with a specified length. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer,dimension(0:num)'].", "input": "", "output": "subroutine make_seeds(seed,iseeds,num)\n  implicit none\n  integer,intent(in):: num\n  integer,intent(in):: seed\n  integer,dimension(0:num),intent(out):: iseeds\n  integer:: i\n  integer,parameter:: ln = 1000\n  integer,dimension(0:ln-1):: iy\n  integer(kind=8),parameter:: aaa = z'ffffffff'\n\n  iy(0) = iand(seed,aaa)\n  iseeds = 0\n\n  do i=1,30\n   iy(i) = 1812433253 * ieor(iy(i-1),ishft(iy(i-1),-30))+i\n   iy(i) = iand(iy(i),aaa)\n  end do\n  do i=31,ln-1\n   iy(i) = ieor(iy(i-31),iy(i-13))\n  end do\n  do i=0,num\n   iseeds(i)=iy(ln-1-num+1+i)\n  end do\n\nend subroutine make_seeds\n"}, {"instruction": "Create a Fortran subroutine named make_output_filename, which takes two input parameters of type integer and character(len=*), and one output parameter of type character(len=*). The purpose of this subroutine is to generate an output filename based on the input id and fnbase. The output filename is constructed by appending \".dat\" and \".p_\" followed by the adjusted id to the fnbase.", "input": "", "output": "subroutine make_output_filename(datfname,id,fnbase)\n  implicit none\n  character(len=*),intent(out):: datfname\n  integer,intent(in):: id\n  character(len=*),intent(in):: fnbase\n  character(len=4),parameter:: dada = \".dat\"\n  character(len=10)::tail\n\n  write(tail,'(i4.4)') id\n  write(datfname,'(10a)') fnbase(1:len_trim(fnbase)),dada,\".p_\",adjustl(tail)\n\nend subroutine make_output_filename\n"}, {"instruction": "Write a Fortran subroutine named fibber that computes the most significant digits of a sum in a Fibonacci-like sequence. The subroutine should take 2 input parameters of type integer (kind=8) and produce 2 output parameters of type integer (kind=8).", "input": "", "output": "subroutine fibber(a,b,c,d)\n  ! compute most significant digits, fibonacci like.\n  implicit none\n  integer (kind=8), intent(in) :: a,b\n  integer (kind=8), intent(out) :: c,d\n  d = a + b\n  if (15 .lt. log10(float(d))) then\n    c = b/10\n    d = d/10\n  else\n    c = b\n  endif\nend subroutine fibber\n"}, {"instruction": "Create a Fortran subroutine named shift_mc_to_vc to shift data from a 2D array in single precision to a 2D array in double precision. The subroutine has 1 input parameter of type real, dimension( :, : ), and 1 output parameter of type double precision, dimension( :, : ). The subroutine should duplicate the input array into the output array and add an extra row and column of zeros at the end.", "input": "", "output": "  subroutine shift_mc_to_vc ( f_mc, f_vc )\n    implicit none\n\n    real, dimension( :, : ), intent(in) :: f_mc\n    double precision, dimension( :, : ), intent(out) :: f_vc\n    integer :: nlon, nlat\n\n    nlon = size( f_mc, 1)\n    nlat = size( f_mc, 2)\n\n    f_vc ( 1 : nlon, 1 : nlat ) = f_mc ( :, : )\n    f_vc ( nlon + 1, : ) = f_vc ( 1, : )\n    f_vc ( :, nlat + 1 ) = 0.0e0\n\n  end subroutine shift_mc_to_vc\n"}, {"instruction": "Create a Fortran subroutine named bar to perform the bar action. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is specified using the \"intent(in)\" attribute, and the output parameter is specified using the \"intent(out)\" attribute. The subroutine calculates the value of the output parameter by adding 100 to the input parameter and then subtracting 7.", "input": "", "output": "subroutine bar(a, b)\n\n!   performs the bar action\n\n    implicit none\n\n    integer, intent(in)  :: a\n    integer, intent(out) :: b\n\n    b = a + 100 - 7\n\nend subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named getgrid to generate a grid and Fourier frequencies for a 1D nonlinear Klein-Gordon equation simulation. The subroutine takes 3 input parameters of types integer(kind=4), real(kind=8), and real(kind=8), and returns 3 output parameters of types real(kind=8), complex(kind=8), and character*100.", "input": "", "output": "\tsubroutine getgrid(nx,lx,pi,name_config,x,kx)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! pseudospectral simulation of the 1d nonlinear klein-gordon equation\n\t!\n\t! u_{tt}-u_{xx}+u=es*u^3\n\t!\n\t! the boundary conditions are u(x=0)=u(2*lx*\\pi) \n\t!\n\t! input\n\t!\n\t! .. scalars ..\n\t!  nx\t\t\t\t= number of modes in x - power of 2 for fft\n\t!  pi\t\t\t\t= 3.142....\n\t!  lx\t\t\t\t= width of box in x direction\n\t! output\n\t!\n\t! .. vectors ..\n\t!  kx\t\t\t\t= fourier frequencies in x direction\n\t!  x\t\t\t\t= x locations\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t\t\t\t= loop counter in x direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n        implicit none\n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t        :: nx\n\treal(kind=8), intent(in)\t\t\t        :: lx,pi\n\treal(kind=8), dimension(1:nx), intent(out) \t        :: x\n\tcomplex(kind=8), dimension(1:nx/2 + 1), intent(out)\t:: kx\n\tcharacter*100, intent(out)\t\t\t        :: name_config\n\tinteger(kind=4)\t\t\t\t\t        :: i\n\t\t\n\tdo i=1,1+nx/2\n\t\tkx(i)= cmplx(0.0d0,1.0d0,kind(0d0))*real(i-1,kind(0d0))/lx  \t\t\t\n\tend do\n\tkx(1+nx/2)=0.0d0\n\t\t\n\tdo i=1,nx\n\t\tx(i)=(-1.0d0 + 2.0d0*real(i-1,kind(0d0))/real(nx,kind(0d0)))*pi*lx\n\tend do\n\t! save x grid points in text format\n\tname_config = 'xcoord.dat' \n\topen(unit=11,file=name_config,status=\"unknown\") \t\n\trewind(11)\n\tdo i=1,nx\n\t\twrite(11,*) x(i)\n\tend do\n\tclose(11)\n\t\n\tend subroutine getgrid\n"}, {"instruction": "Write a Fortran subroutine named get_sigini to compute the signature and original signature matrices based on the provided input data. The number of input arguments is 4 and the test_data type is [integer, integer, integer, integer]. The number of output arguments is 3 and the test_data type is [integer, integer, integer].", "input": "", "output": "subroutine get_sigini(cixdms, sigini, sigini_orig, sigind, sigind_orig, cixdm, maxdim)\n  implicit none\n  integer, intent(in)  :: sigind(maxdim,maxdim), sigind_orig(maxdim,maxdim), cixdm, maxdim\n  integer, intent(out) :: cixdms, sigini(cixdm,cixdm), sigini_orig(cixdm,cixdm)\n  ! locals\n  integer :: cind(cixdm), it, ip, iq, cini(cixdm)\n  \n  cixdms=0 ! real dimension, excluding states which must be projected out, because they are treated as non-correlated\n  cind=0   ! in most cases, cind(i)=i, however, when some states are projected out, cind points to smaller block\n  do ip=1,cixdm\n     it = sigind_orig(ip,ip)\n     if (it.gt.0) then\n        cixdms = cixdms + 1\n        cind(ip) = cixdms\n     endif\n  enddo\n     \n  do ip=1,cixdm\n     if (cind(ip).gt.0) cini(cind(ip))=ip\n  enddo\n  sigini=0\n  sigini_orig=0\n  do ip=1,cixdms\n     do iq=1,cixdms\n        sigini(ip,iq) = abs(sigind(cini(ip),cini(iq)))           \n        sigini_orig(ip,iq) = abs(sigind_orig(cini(ip),cini(iq))) \n     enddo\n  enddo\nend subroutine get_sigini\n"}, {"instruction": "Create a Fortran subroutine named gethighfrequency to approximate the values of a and c using the input complex numbers cc, the array of real numbers omega, and the integer n. The subroutine has 3 input parameters of type complex*16, real*8, and integer, and 2 output parameters of type real*8.", "input": "", "output": "subroutine gethighfrequency(a,c,cc,omega,n)\n  ! approximates cc ~  a/(i*om-c)\n  implicit none\n  real*8, intent(out)    :: a, c\n  complex*16, intent(in) :: cc(n)\n  real*8, intent(in)     :: omega(n)\n  integer, intent(in)    :: n\n  !print *, 'cc(n)=', cc(n)\n  if (abs(cc(n)).lt.1e-6) then\n     a=0.d0\n     c=1.d0\n  else\n     a = 1./aimag(1/(cc(n)*omega(n)))\n     c = -a*dble(1./cc(n))\n  endif\nend subroutine gethighfrequency\n"}, {"instruction": "Create a Fortran subroutine named binary_search to perform a binary search on a sorted integer array. The subroutine should take 4 input parameters of type integer (s, ls, le, list_s) and 2 output parameters of type integer (b, bmin).", "input": "", "output": "  subroutine binary_search(s,list_s,ls,le,b,bmin)\n    integer, intent(out) :: b, bmin\n    integer, intent(in) :: s,ls,le\n    integer, intent(in) :: list_s(le)\n    integer :: bmax\n    bmin = ls; bmax = le\n    do\n       b = bmin + (bmax-bmin)/2\n       if(s<list_s(b))then\n          bmax = b-1\n       else if(list_s(b)<s)then\n          bmin = b+1\n       else\n          bmin = b\n          return\n       end if\n       if(bmin>bmax)then\n          b = -1\n          return\n       end if\n    end do\n  end subroutine binary_search\n"}, {"instruction": "Create a Fortran subroutine named findstate to search for a specific integer value within a sorted integer array. The subroutine takes 3 input parameters of type integer: s, m, and list_s(m), and one output parameter of type integer, b.", "input": "", "output": "  subroutine findstate(s,list_s,b,m) \n    integer, intent(out) :: b\n    integer, intent(in) :: s, m, list_s(m)\n    integer :: bmin, bmax \n    bmin = 1; bmax = m\n    do\n      b = bmin + (bmax-bmin)/2\n      if(s < list_s(b))then\n        bmax = b-1\n      else if(s > list_s(b))then\n        bmin = b+1\n      else\n        return\n      end if\n      if(bmin>bmax)then\n        b = -1; return\n      end if\n    end do\n  end subroutine findstate\n"}, {"instruction": "Create a Fortran subroutine named getfilename that takes two input parameters of type character*128 and integer, and one output parameter of type character*132. This subroutine generates a filename based on the base name and the provided index. If the index is less than 10, the filename is constructed using a single-digit index. If the index is between 10 and 99, a two-digit index is used. If the index is between 100 and 999, a three-digit index is used. If the index is between 1000 and 9999, a four-digit index is used. The generated filename is then returned in the output parameter.", "input": "", "output": "subroutine getfilename(base_name,i,current_filename)\n\n  implicit none\n  character*128, intent(in) ::  base_name\n  character*132, intent(out) ::  current_filename\n  integer, intent(in) :: i \n\n  if (i < 10) then\n     write(current_filename,1000),trim(base_name),i\n  else if (i < 100) then\n     write(current_filename,1001),trim(base_name),i\n  else if (i < 1000) then\n     write(current_filename,1002),trim(base_name),i\n  else if (i < 10000) then\n     write(current_filename,1003),trim(base_name),i\n  else\n     print *,'error: index too large!'\n     stop\n  end if\n\n  current_filename = trim(current_filename)\n\n1000 format(a,i1)\n1001 format(a,i2)\n1002 format(a,i3)\n1003 format(a,i4)\n\nend subroutine getfilename\n"}, {"instruction": "Create a Fortran subroutine named use_analytic_function to calculate a value based on the input parameters. The subroutine takes 2 input parameters of type real(8) and one output parameter of type real(8). The input parameters are rr and cdd_coef, while the output parameter is d. This subroutine performs a series of calculations using the input parameters and stores the result in the output parameter.", "input": "", "output": "  subroutine use_analytic_function( rr, cdd_coef, d )\n    implicit none\n    real(8),intent(in)  :: rr, cdd_coef(:,:)\n    real(8),intent(out) :: d\n    real(8) :: a,b,c\n    integer :: i\n    d=0.0d0\n    do i=1,size(cdd_coef,2)\n       a=cdd_coef(1,i)\n       b=cdd_coef(2,i)\n       c=cdd_coef(3,i)\n       d=d+(a+b*rr)*exp(-c*rr)\n    end do\n  end subroutine use_analytic_function\n"}, {"instruction": "Write a Fortran subroutine named get_nearest_index to find the index of the element in the array \"rad\" that is closest to the value \"r\". The number of input arguments is 2 and the test_data type is ['real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  subroutine get_nearest_index( rad, r, ir )\n    implicit none\n    real(8),intent(in)  :: rad(:), r\n    integer,intent(out) :: ir\n    integer :: ir0,ir1\n    ir0=1\n    ir1=size( rad )\n1   if ( ir1 - ir0 > 1 ) then\n       ir = ( ir0 + ir1 )/2\n       if ( rad(ir) > r ) then\n          ir1=ir\n       else\n          ir0=ir\n       end if\n       goto 1\n    end if\n  end subroutine get_nearest_index\n"}, {"instruction": "Write a Fortran subroutine named loc_index that takes 2 input parameters of type integer array and 2 output parameters of type integer. The subroutine searches for a specific value within the integer array and returns the index and direction of the found value. Use the imperative tone and summarize the function of the code.", "input": "", "output": "        subroutine loc_index (pe, list, dir, ind)\n\n        integer, intent(in)  :: pe, list(0:)\n        integer, intent(out) :: dir, ind\n\n        logical :: found\n        integer :: n\n\n        found = .false.\n        n = 0\n        dir = -1\n        ind = -1\n        do while ((.not. found) .and. (n < list(0)))\n           n = n + 1\n           if (list(n) == pe) then\n              found = .true.\n              dir = list(n)\n              ind = n\n           end if\n        end do\n\n        end subroutine loc_index\n"}, {"instruction": "Create a Fortran subroutine named count_correct to compare two strings and count the number of correct letters. The subroutine should take 2 input parameters of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine count_correct(g, w, c)\n  implicit none\n  character(len=*), intent(in) :: g, w ! the user's guess and the secret word\n  integer, intent(out) :: c ! the number of correct letters\n  integer :: i\n  c = 0\n  do i = 1, len(w)\n    if (g(i:i) == w(i:i)) then\n      c = c + 1\n    end if\n  end do\n  end subroutine count_correct\n"}, {"instruction": "Create a Fortran subroutine named tria_getneighbourvertex to calculate the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes 3 input parameters of type integer: ivertex, ivt1, and ivt2. It also has 1 output parameter of type integer: ineighbour.", "input": "", "output": "  elemental subroutine tria_getneighbourvertex(ivertex,ivt1,ivt2,ineighbour)\n\n!<description>\n  ! calculates the vertex number of the neighbour vertex of a vertex on an\n  ! edge.\n  !\n  ! ivt1 and ivt2 are the vertex numbers of two vertices connected\n  ! by an edge. ivertex is either ivt1 or ivt2.\n  ! the result of this routine is the number of the neighbour vertex\n  ! of ivertex, i.e. if ivertex=ivt1, ineighbour=ivt2 and if\n  ! ivertex=ivt2, ineighbour=ivt1.\n!</description>\n\n!<input>\n  ! vertex number. either ivt1 or ivt2.\n  integer, intent(in) :: ivertex\n\n  ! vertex number of one vertex adjacent to an edge.\n  integer, intent(in) :: ivt1\n\n  ! vertex number of the other vertex adjacent to that edge.\n  integer, intent(in) :: ivt2\n!</input>\n\n!<output>\n  ! vertex number of the neighbour of ivertex.\n  integer, intent(out) :: ineighbour\n!</output>\n\n\n    ! note: directly implementing this formula into the program\n    ! code brings more speed :-)\n    ! but to have a reference not to forget the formula, we have\n    ! this routine...\n\n    ineighbour = ivt1 + ivt2 - ivertex\n\n  end subroutine tria_getneighbourvertex\n"}, {"instruction": "Create a Fortran subroutine named bl_clamp that performs bilinear interpolation within the interval [xlo, xhi]. The function takes 5 input parameters of type double precision (xlo, xhi, flo, fhi, x) and returns 1 output parameter of type double precision (f). The subroutine interpolates the values flo and fhi at x and assigns the result to f. If x is less than or equal to xlo, f is assigned the value of flo. If x is greater than or equal to xhi, f is assigned the value of fhi.", "input": "", "output": "  subroutine bl_clamp(xlo, xhi, flo, fhi, x, f)\n    \n    ! perform bilinear interpolation within the interval [xlo, xhi]\n    ! where the function values at the endpoints are defined by:\n    ! flo = f(xlo)\n    ! fhi = f(xhi)\n    ! returns f(x), the values flo and fhi interpolated at x\n    ! f(x) = flo if x <= xlo\n    ! f(x) = fhi if x >= xhi\n    double precision, intent(in)  :: xlo, xhi, flo, fhi, x\n    double precision, intent(out) :: f\n    if ( x .le. xlo ) then\n       f = flo\n    else if ( x .ge. xhi ) then\n       f = fhi\n    else\n       f = ( flo * ( xhi - x ) + fhi * ( x - xlo ) ) / ( xhi - xlo )\n    end if\n  end subroutine bl_clamp\n"}, {"instruction": "Provide a Fortran subroutine named sediment that calculates the new elevations for each mauza based on subsidence and deposition. The subroutine takes 9 input parameters: flooding (real), m_frfl (real array), m_elev (real array), p_frfl (real), elvband (integer array), nummz (integer), nbands (integer), t (integer), and p (integer). It also has 2 output parameters: elev_new (real array) and eband_new (integer array).\n\nInside the subroutine, the subsidence and deposition values are set. The subsidence rate is 0.02/12.0. The deposition value is initially set to 0.0 but can be uncommented and assigned a different value if a deposition scenario is considered. \n\nA loop iterates over the mauza (c) and checks if it is flooded based on the condition m_frfl(c) > 0.5 and flooding > 0.001. If true, the new elevation for the mauza is calculated by subtracting the subsidence and adding the deposition multiplied by p_frfl. If false, only the subsidence is subtracted from the current elevation.\n\nAnother loop iterates over the bands (b) and checks if the new elevation is lower than a specific elevation band. If true, the corresponding category value is assigned to eband_new. The category values are determined based on the order of the categories with category 10 being read in first. If the new elevation is greater than the lowest elevation band and this condition occurs for the first band (b=1), a message is written to the output.\n\nThe subroutine returns the updated elevations (elev_new) and the assigned category values (eband_new).", "input": "", "output": " subroutine sediment (flooding,m_frfl, m_elev, p_frfl, elvband, nummz,nbands, elev_new, eband_new,t,p)\r\n   !calculates new elevation for each mauza based on subsidence and deposition (if included)\r\n   implicit none\r\n   real, intent(in):: flooding, m_frfl(nummz), m_elev(nummz), p_frfl\r\n   integer, intent(in) :: elvband(nbands), nummz,nbands,t,p\r\n   real, intent(out) :: elev_new (nummz)\r\n   integer, intent(out) :: eband_new(nummz)\r\n   \r\n   real :: subs, deps\r\n   integer :: c, b\r\n   \r\n   subs=0.02/12.0   !subsidence of 2cm/yr (auerbach et al)\r\n   !deps=0.37    !deposition reported by auerbach with an average of 37 cm and as high as 60-70cm in the two years after the storm. turn on if using for deposition scenario\r\n   deps=0.0\r\n   \r\n   do c=1,nummz\r\n     if (m_frfl (c)>0.5 .and. flooding > 0.001) then       !mauza is flooded (frfl equal to 1. the 0.5 is arbitrary)\r\n       elev_new(c)= m_elev(c)-subs+ deps*p_frfl\r\n     else\r\n\t   elev_new(c)= m_elev(c)-subs     !subsidence only\r\n\t end if\r\n\t do b=1,nbands\r\n\t   if (elev_new(c) < elvband(b)) eband_new(c) = nbands+1-b !nbands+1-b to account for the order of the categories with category 10 read in first (ie b=1)\r\n\t   if (elev_new(c) > elvband(b) .and. b==1) write(*,*) 'new elevation greater than existing band'\r\n\t end do\r\n   end do\r\n    \r\n end subroutine sediment\n"}, {"instruction": "Write a Fortran subroutine named `moninshoc_init` to initialize variables used for error handling in a computational physics model. The subroutine takes 1 input argument of type `logical` and 2 output arguments of types `character(len=*)` and `integer`. \n\nThe subroutine first initializes the error message variable (`errmsg`) and the error flag variable (`errflg`). \n\nThen, it performs consistency checks on the input argument `do_shoc`. If `do_shoc` is `false`, it sets the error flag to 1 and writes an error message to `errmsg`, indicating a logic error. \n\nThe subroutine ends after the consistency checks.", "input": "", "output": "      subroutine moninshoc_init (do_shoc, errmsg, errflg)\n\n      implicit none\n      logical, intent(in) :: do_shoc\n      character(len=*), intent(out) :: errmsg\n      integer,          intent(out) :: errflg\n\n      ! initialize ccpp error handling variables\n      errmsg = ''\n      errflg = 0\n\n      ! consistency checks\n      if (.not. do_shoc) then\n        errflg = 1\n        write(errmsg,'(*(a))') 'logic error: do_shoc = .false.'\n       return\n      end if\n \n      end subroutine moninshoc_init\n"}, {"instruction": "Write a Fortran subroutine named \"sub\" that takes in an integer array \"a\" of length \"n\" as input and outputs an integer array \"b\" of the same length. The subroutine should copy the values from array \"a\" to array \"b\". The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    subroutine sub(n, a, b)\n    integer, intent(in) :: n\n    integer, intent(in) :: a(n)\n    integer, intent(out) :: b(n)\n    integer :: i\n    do i = 1, size(a)\n        b(i) = a(i)\n    end do\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named util__split that separates a given input buffer into multiple fields based on a specified separator. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The number of output arguments is 2 and the test_data type is ['integer', 'character(*), allocatable'].\n\nIn the subroutine, the input buffer and separator are provided as arguments. The subroutine counts the number of separator occurrences in the buffer and determines the number of separated fields. It allocates memory for an array to store the separated fields. Then, it iterates through the buffer, identifying the position of each separator and extracting the corresponding field. The separated fields are stored in the allocated array.\n\nTo summarize, the util__split subroutine takes an input buffer and a separator and splits the buffer into multiple fields. It returns the number of separated fields and an array containing the separated fields.", "input": "", "output": "  subroutine util__split(buf, sep, n, nm)\n    \n    character(*), intent(in)  :: buf  !< input buffer\n    character(*), intent(in)  :: sep  !< separator\n    integer,      intent(out) :: n    !< number of separated fields\n    !--\n    character(*), allocatable, intent(out) :: nm(:)  !< separated variables\n    integer :: i, j, k\n    !----\n    \n    ! count separator\n    n = 0\n    i = 1\n    j = 1\n    do\n      i = index(buf(j:), sep)\n      if( i == 0 ) exit\n      j = j + i\n      n = n + 1\n    end do\n    n = n + 1  !! #words = #separator + 1\n    allocate(nm(n))\n\n    i = 1\n    j = 1\n    do k=1, n-1\n      i = index(buf(j:), sep)\n      nm(k) = trim(adjustl(buf(j:i+j-2)))\n      j = j + i\n    end do\n    nm(n) = trim(adjustl(buf(j:)))\n\n  end subroutine util__split\n"}, {"instruction": "Write a Fortran subroutine named \"trans_rank_2\" that performs a rank-2 matrix transpose. The code takes a 2-dimensional real array as input, with the test_data type of ['real(8)']. The output is an allocatable 2-dimensional real array, with the test_data type of ['real(8),allocatable']. The subroutine uses the \"intent(in)\" keyword to specify that the input array is read-only. The subroutine allocates memory for the output array if it is not already allocated. Inside the subroutine, the transpose operation is performed by iterating over the elements of the input array and assigning them to the corresponding positions in the output array. The subroutine uses the \"integer\" keyword to declare the variables used for looping.", "input": "", "output": "   subroutine trans_rank_2(a,a_t)\r\n\t  real(8),intent(in)::a(:,:)\r\n\t  real(8),allocatable,intent(out)::a_t(:,:)\r\n\t  integer n,m,i,j\r\n\t  \r\n\t  n=size(a,1)\r\n\t  m=size(a,2)\r\n\t  if(.not. allocated(a_t) )allocate(a_t(m,n))\r\n\t  \r\n\t  do i=1,n\r\n\t\tdo j=1, m\r\n\t\t\ta_t(j,i)=a(i,j)\r\n\t\tenddo\r\n\t  enddo\r\n\t  \r\n   end subroutine trans_rank_2\r\n"}, {"instruction": "Create a Fortran subroutine named layout_procs to calculate the layout of processor grid given the total number of processors. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer.", "input": "", "output": "  subroutine layout_procs(n_procs, n_procs_row, n_procs_col)\n    integer, intent(in) :: n_procs\n    integer, intent(out) :: n_procs_row, n_procs_col\n\n    n_procs_row = int(sqrt(dble(n_procs + 1)))\n    do while (mod(n_procs, n_procs_row) /= 0)\n      n_procs_row = n_procs_row - 1\n    end do\n    n_procs_col = n_procs / n_procs_row\n  end subroutine layout_procs\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_v_l_1d to allocate memory for a 1D array. The subroutine should take 2 input parameters of type character(kind=c_char) and integer(c_size_t), and 2 output parameters of type type(c_ptr).", "input": "", "output": "    subroutine f_kokkos_allocate_v_l_1d(c_a, v_a, n_a, e0) &\n      & bind (c, name='c_kokkos_allocate_v_l_1d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type(c_ptr), intent(out) :: c_a\n      type(c_ptr), intent(out) :: v_a\n      character(kind=c_char), intent(in) :: n_a(*)\n      integer(c_size_t), intent(in) :: e0      \n    end subroutine f_kokkos_allocate_v_l_1d\n"}, {"instruction": "Create a Fortran subroutine named forward to perform a numerical simulation using the forward time, central space method for solving a partial differential equation. The subroutine takes 4 input parameters of type double precision and dimension, and 1 output parameter of type double precision and dimension. The input parameters are a (velocity), dx (spatial step size), dt (time step size), and u0 (initial vector). The output parameter is u (solution vector).", "input": "", "output": "  subroutine forward(u0,u,a,dx,dt)\n\n    ! eingabe:\n    ! u0 = ausgangsvektor\n    ! u = ausgabevektor\n    ! a = geschwindigkeit (>0)\n    ! dx = ortsschrittweite\n    ! dt = zeitschrittweite\n\n    double precision, intent(in)\t\t\t:: a, dx, dt\n    double precision, dimension(:), intent(out)\t\t:: u\n    double precision, dimension(:), intent(in)\t\t:: u0\n    integer\t\t\t\t\t\t:: i,j\n    double precision\t\t\t\t\t:: k1\n\n    ! hilfsvariable\n    k1 = a*dt/dx\n\n    ! berechne den loesungsvektor fuer alle ausser dem linken x (parallel)\n    forall(i=lbound(u0,1)+1:ubound(u0,1))\n       u(i) = u0(i)-k1*(u0(i)-u0(i-1))\n    end forall\n\n    ! berechne den loesungswert fuer das linke x\n    u(lbound(u0,1)) = u0(lbound(u0,1))+k1*u0(lbound(u0,1))\n\n  end subroutine forward\n"}, {"instruction": "Write a Fortran subroutine named dhaj to calculate the weights for expanding an equally sampled grid into spherical harmonics using the sampling theorem. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type real*8. The input parameter represents the number of samples in longitude and latitude, while the output parameter contains the weights.", "input": "", "output": "subroutine dhaj(n, aj)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n\n!\texpand an equally sampled grid into spherical harmonics by using\n!\tthe sampling theorem presented in driscoll and healy (1994).\n!\n!\tnote that the number of samples, n, must be even! also, a_j(1) = 0\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tn\tnumber of samples in longitude and latitude.\n!\t\tout\n!\t\t\taj\tvector of length n containing the weights.\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek (may, 2004)\n!\n!\tcopyright (c) 2005, 2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\tinteger, intent(in) ::\tn\n\treal*8, intent(out) ::\taj(:)\n\tinteger ::\t\tj, l\n\treal*8 ::\t\tsum1, pi\n\t\n\tpi = acos(-1.0d0)\n\t\n\taj = 0.0d0\n\t\n\tif (mod(n,2) /= 0) then\n\t\tprint*, \"error --- dh_aj\"\n\t\tprint*, \"the number of samples in the equi-dimensional grid must be even for use with shexpanddh\"\n\t\tprint*, \"input value of n is \", n\n\t\tstop\n\telseif (size(aj) < n) then\n\t\tprint*, \"error --- dh_aj\"\n\t\tprint*, \"the size of aj must be greater than or equal to n where n is \", n\n\t\tprint*, \"input array is dimensioned as \", size(aj)\n\t\tstop\n\tendif\n\t\n\tdo j=0, n-1\n\t\tsum1 = 0.0d0\n\t\t\n\t\tdo l=0, n/2 -1\n\t\t\tsum1 = sum1 + sin( dble(2*l+1) * pi * dble(j) / dble(n) ) / dble(2*l+1)\n\t\tenddo\n\t\n\t\taj(j+1) = sum1  * sin(pi * dble(j)/dble(n)) * sqrt(8.0d0) / dble(n)\n\t\n\tenddo\n\t\nend subroutine dhaj\n"}, {"instruction": "Write a Fortran subroutine named \"vmflow\" that calculates the von Mises flow stress. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The input parameters are stress and dsbar, and the output parameter is vmfl. Use the imperative tone when writing the subroutine.", "input": "", "output": "subroutine vmflow(stress,dsbar,vmfl)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::stress(:),dsbar\n real(iwp),intent(out)::vmfl(:)\n real(iwp)::sigm,onept5=1.5_iwp,two=2.0_iwp,d3=3.0_iwp\n sigm=(stress(1)+stress(2)+stress(4))/d3\n vmfl(1)=stress(1)-sigm\n vmfl(2)=stress(2)-sigm\n vmfl(3)=stress(3)*two \n vmfl(4)=stress(4)-sigm\n vmfl=vmfl*onept5/dsbar\nreturn\nend subroutine vmflow\n"}, {"instruction": "Create a Fortran subroutine named initialdata, which initializes and computes the initial solution for a three-dimensional wave equation. The subroutine takes 6 input parameters: nx, ny, nz (integer kind=4), x, y, z (real kind=8 arrays). It also has 2 output parameters: u, uold (complex kind=8 arrays of dimensions 1:nx, 1:ny, 1:nz).", "input": "", "output": "\tsubroutine initialdata(nx,ny,nz,x,y,z,u,uold)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! in 3 dimensions\n\t! u_{tt}-(u_{xx}+u_{yy}+u_{zz})+u=es*u^3+\n\t!\n\t! the boundary conditions are u(x=-lx*\\pi,y,z)=u(x=lx*\\pi,y,z), \n\t!\tu(x,y=-ly*\\pi,z)=u(x,y=ly*\\pi,z),u(x,y,z=-ly*\\pi)=u(x,y,z=ly*\\pi)\n\t! the initial condition is u=0.5*exp(-x^2-y^2-z^2)*sin(10*x+12*y)\n\t!\n\t! input\n\t!\n\t! .. parameters ..\n\t!  nx\t\t\t\t= number of modes in x - power of 2 for fft\n\t!  ny\t\t\t\t= number of modes in y - power of 2 for fft\n\t!  nz\t\t\t\t= number of modes in z - power of 2 for fft\n\t! .. vectors ..\n\t!  x\t\t\t\t= x locations\n\t!  y\t\t\t\t= y locations\n\t!  z\t\t\t\t= z locations\n\t!\n\t! output\n\t!\n\t! .. arrays ..\n\t!  u \t\t\t\t= initial solution\n\t!  uold \t\t\t= approximate solution based on time derivative of\n\t!\t\t\t\t\tinitial solution\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t\t\t\t= loop counter in x direction\n\t!  j\t\t\t\t= loop counter in y direction\n\t!  k\t\t\t\t= loop counter in z direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n\t! openmp library\n\tuse omp_lib\t\t \t   \n\timplicit none\t\t\t\t\t \n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t\t\t\t\t:: nx,ny,nz\n\treal(kind=8), dimension(1:nx), intent(in) \t\t\t:: x\n\treal(kind=8), dimension(1:ny), intent(in) \t\t\t:: y\n\treal(kind=8), dimension(1:nz), intent(in) \t\t\t:: z\n\tcomplex(kind=8), dimension(1:nx,1:ny,1:nz), intent(out)\t:: u,uold\n\tinteger(kind=4)\t\t\t\t\t\t\t\t\t\t:: i,j,k\n\t!$omp parallel do private(i,j) schedule(static)\n\tdo k=1,nz\n\t\tdo j=1,ny\n\t\t\tdo i=1,nx\n\t\t\t\tu(i,j,k)=0.5d0*exp(-1.0d0*(x(i)**2 +y(j)**2+z(k)**2))!*&\n\t\t\t\t\t!sin(10.0d0*x(i)+12.0d0*y(j))\n\t\t\tend do\n\t\tend do\n\tend do\n\t!$omp end parallel do\n\t!$omp parallel do private(i,j) schedule(static)\n\tdo k=1,nz\n\t\tdo j=1,ny\n\t\t\tdo i=1,nx\n\t\t\t\tuold(i,j,k)=0.5d0*exp(-1.0d0*(x(i)**2 +y(j)**2+z(k)**2))!*&\n\t\t\t\t\t!sin(10.0d0*x(i)+12.0d0*y(j))\n\t\t\tend do\n\t\tend do\n\tend do\n\t!$omp end parallel do\n\t\n\tend subroutine initialdata\n"}, {"instruction": "Create a Fortran subroutine named \"lf_omq\" that calculates various statistical parameters for a given set of input data. The subroutine should have 6 input parameters: an integer \"no_bins\", real*8 arrays \"om\" and \"q\" with dimensions (3, no_bins), a real*8 array \"sigma_data\" with dimension (no_bins), and real*8 arrays \"om_true\" and \"q_true\" with dimension (no_bins). The subroutine should also have 3 output parameters: real*8 arrays \"chi\" and \"chi2\" with dimension (3), and a single real*8 \"lf_q_sum\" value.\n", "input": "", "output": "subroutine lf_omq (no_bins,om,q,chi,chi2,lf_q_sum,om_true,q_true,sigma_data)\n\timplicit none\n\tinteger,intent(in) :: no_bins\n\treal*8,intent(in),dimension(3,no_bins) :: om,q\n\treal*8,intent(in),dimension(no_bins) ::sigma_data\n\treal*8,dimension(no_bins) :: q_sum\n\treal*8,intent(out),dimension(3) :: chi,chi2\n\treal*8,intent(out) :: lf_q_sum\n\tinteger :: i,t\n\treal*8,intent(in),dimension(no_bins) :: om_true,q_true\n\n\tchi = 0.0d0\n\tchi2 = 0.0d0\n\ndo t =1,3\n\tdo i = 3, (no_bins-2)\n\t\tchi(t) = chi(t) +  ( ((om(t,i)) - (om_true(i)))/(sigma_data(i))   )**2\n\tend do\n\tdo i = 3, (no_bins-2)\n\t\tchi2(t) = chi2(t) + (((q(t,i)) - (q_true(i)))/(sigma_data(i)) )**2  \n\tend do\nend do\n\n\tlf_q_sum = 0d0\n\tq_sum = sum(q,dim = 1)\n\tq_sum = (q_sum)/(3.0d0)\n\tdo i = 3, (no_bins-2)\n\t\tlf_q_sum = lf_q_sum + (((q_sum(i)) - (q_true(i)))/(sigma_data(i)) )**2  \n\tend do\n\n\nreturn\nend subroutine lf_omq\n"}, {"instruction": "Create a Fortran subroutine named reconstruction to perform a specific calculation related to cosmology. The subroutine takes 3 input parameters of type integer, real*8 array of dimension no_bins, and another real*8 array of dimension no_bins. It returns 2 output parameters, both being real*8 arrays of dimension no_bins. The subroutine calculates values for h and q based on the input arrays z and dm.", "input": "", "output": "subroutine reconstruction (no_bins,dm,z,h,q)\n implicit none\n\n  integer :: j\n  real*8 :: h0\n  integer,intent(in) :: no_bins\n  real*8,intent(in),dimension(no_bins):: z\n  real*8,intent(in),dimension(no_bins):: dm\n  real*8,dimension(no_bins):: l\n  real*8,intent(out),dimension(no_bins):: h,q!,om\n\n  h = 0.0d0;q = 0.0d0\n\n  do j = 1, no_bins\n\tl (j) = (1.0d0/3.0d10)*((10.0d0**((dm (j))/(5.0d0)))/(1.0d0 + z(j))) ! in mpc.s/km\n  end do\n\n  h (1) = (z(2)-z(1))/(l(2)-l(1))\n  do j = 2, (no_bins-1)\n\th (j) = (z(j+1)-z(j-1))/((l(j+1)-l(j-1)))\n  end do\n  h0 = ((-1.0*z(2))*((h(3)-h(2))/(z(3)-z(2))))+h(2)! by extrapolation i find h(z = 0) and then devide all values by that to get h(z) = h(z)/h(0)\n\n!\tdividing h(z) by h(z = 0)\n  do j = 2, (no_bins-1)\n\th (j) = h (j)/h0\n  end do\n\n\n\n  do j=3,(no_bins-2)\n\tq(j) = (( (1+z(j)) / (h(j))) * ((h(j+1)-h(j-1))/(z(j+1)-z(j-1)))) - 1.0d0\n  end do\n\n!  do j=3,(no_bins-2)\n!\tom(j) = (((h(j+1))**2)-((h(j-1))**2))/(((1.0d0+z(j+1))**3)-((1.0d0+z(j-1))**3)) \n!  end do\n\n\nreturn\nend subroutine reconstruction\n"}, {"instruction": "Create a Fortran subroutine named interpolate that takes 5 input parameters and 1 output parameter. The input parameters consist of two integers (no_data, no_bins) and three arrays of real*8 type (z, x, z_data), each with different dimensions. The output parameter is an array of real*8 type (y) with the dimension no_data. The subroutine interpolates values using the given data and stores the results in the array y.", "input": "", "output": "subroutine interpolate(no_data,no_bins,z,x,z_data,y)\n  implicit none\n\n  integer :: i,j\n  integer,intent(in) :: no_data,no_bins\n  real*8,intent(in),dimension(no_bins) :: z,x\n  real*8,intent(in),dimension(no_data) :: z_data\n  real*8,intent(out),dimension(no_data) :: y\n\n do j=1,no_bins\n\t   do i = 1, no_data\n\t\tif (z_data(i) .le. z(j+1) .and. z_data(i) .ge. z(j)) y(i) = ((z_data(i)-z(j))*((x(j+1)-x(j))/(z(j+1)-z(j))))+x(j)\n       end do\n end do\nreturn\nend subroutine interpolate\n"}, {"instruction": "Write a Fortran subroutine named linspace to generate a linearly spaced vector of real numbers between two given values. The number of input arguments is 3 and the test_data type is ['integer', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(n)'].", "input": "", "output": "  subroutine linspace(l, k, n, z)\n    implicit none\n!// argument declarations\n    integer, intent(in) :: n\n    real(kind=8), dimension(n), intent(out) :: z\n    real(kind=8), intent(in) :: l\n    real(kind=8), intent(in) :: k\n!// local variables\n    integer :: i\n    real(kind=8) :: d\n    d = (k-l)/(n-1)\n    z(1) = l\n    do i=2,n-1\n      z(i) = z(i-1) + d\n    end do\n    z(1) = l\n    z(n) = k\n    return\n  end subroutine linspace\n"}, {"instruction": "Create a Fortran subroutine named transpose2_d to transpose a 2D matrix and its derivative matrix. The subroutine takes 4 input parameters of type integer, integer, real(kind=8), and real(kind=8) and 2 output parameters of type real(kind=8) and real(kind=8).", "input": "", "output": "  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(in) :: mtxd(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    real(kind=8), intent(out) :: new_mtxd(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtxd(j, i) = mtxd(i, j)\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2_d\n"}, {"instruction": "Create a Fortran subroutine named transpose2 that takes 3 input parameters of type integer, integer, and real(kind=8) to represent the dimensions and elements of a matrix, and 1 output parameter of type real(kind=8) to store the transposed matrix. The subroutine transposes the input matrix and stores the result in the output parameter using nested do-loops.", "input": "", "output": "  subroutine transpose2(m, n, mtx, new_mtx)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2\n"}, {"instruction": "Create a Fortran subroutine named matmul2_d to perform matrix multiplication. It accepts 7 input parameters of types integer, integer, integer, real(kind=8), real(kind=8), real(kind=8), and real(kind=8). It also has 2 output parameters of type real(kind=8).", "input": "", "output": "  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(in) :: ad(m, n), bd(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    real(kind=8), intent(out) :: cd(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    cd = 0.0_8\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2_d\n"}, {"instruction": "Create a Fortran subroutine named matmul2 to perform matrix multiplication. The subroutine takes 5 input parameters: m, n, p of type integer, and arrays a and b of type real(kind=8). It also has 1 output parameter, array c of type real(kind=8). The subroutine multiplies the matrices a and b and stores the result in array c.", "input": "", "output": "  subroutine matmul2(m, n, p, a, b, c)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2\n"}, {"instruction": "Create a Fortran subroutine named dot to calculate the dot product of two 3-dimensional real arrays. The subroutine takes 2 input parameters of type real(kind=8) and intent(in) and 1 output parameter of type real(kind=8) and intent(out).", "input": "", "output": "  subroutine dot(a, b, dot_prod)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: dot_prod\n    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  end subroutine dot\n"}, {"instruction": "Write a Fortran subroutine named cross to calculate the cross product of two 3D vectors. The subroutine takes 2 input parameters of type real(kind=8) and intent(in) and 1 output parameter of type real(kind=8) and intent(out). The number of input arguments is 2 and the test_data type is ['real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "  subroutine cross(a, b, c)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: c(3)\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n  end subroutine cross\n"}, {"instruction": "Create a Fortran subroutine named mean_group to calculate the mean of groups based on the input data. The subroutine has 2 input parameters of type real(8) and integer, and 2 output parameters of type real(8) and integer.", "input": "", "output": "  subroutine mean_group(xn, mu, gk, numk)\n    implicit none\n\n    real(8),intent(in) :: xn(:, :)\n    real(8),intent(out) :: mu(:, :)\n    integer,intent(in) :: gk(:)\n    integer,intent(out) :: numk(:)\n    real(8) :: now\n    real(8) :: tmp\n    integer :: i\n    integer :: j\n\n    numk = 0\n    do j = 1, size(mu(1, :))\n       mu(:, j) = (/0d0, 0d0/)\n       do i = 1, size(xn(1, :))\n          if(gk(i) .eq. j) then\n             numk(j) = numk(j) + 1\n             mu(:, j) = mu(:, j) + xn(:, i)\n          end if\n       end do\n       mu(:, j) = mu(:, j)/numk(j)\n    end do\n\n  end subroutine mean_group\n"}, {"instruction": "Write a Fortran subroutine named initialdata to initialize the solution for a partial differential equation. The subroutine takes 4 input parameters of types integer(kind=4), real(kind=8) arrays of size nx, real(kind=8), and real(kind=8). It returns 2 output parameters of real(kind=8) arrays of size nx and real(kind=8) arrays of size nx.", "input": "", "output": "\tsubroutine initialdata(nx,dt,c,x,u,uold)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! in 1 dimensions\n\t! u_{tt}-u_{xx}+u=es*u^3\n\t!\n\t! the boundary conditions are u(x=-lx*\\pi)=u(x=lx*\\pi), \n\t! the initial condition is u=sqrt(2)*sech((x(i)-c*t)/sqrt(1-c**2)\n\t!\n\t! input\n\t!\n\t! .. parameters ..\n\t!  nx\t= number of modes in x - power of 2 for fft\n        !  dt   = timestep\n        !  c    = wavespeed\n\t! .. vectors ..\n\t!  x\t= x locations\n\t!\n\t! output\n\t!\n\t! .. arrays ..\n\t!  u \t= initial solution\n\t!  uold = approximate solution at previous timestep\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t= loop counter in x direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n\t! openmp library\n\t!use omp_lib\t\t \t   \n\timplicit none\t\t\t\t\t \n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t\t:: nx\n\treal(kind=8), dimension(1:nx), intent(in) \t\t:: x\n\treal(kind=8), dimension(1:nx), intent(out)\t\t:: u,uold\n\tinteger(kind=4)\t\t\t\t\t\t:: i\n        real(kind=8), intent(in)                                :: c,dt\n        real(kind=8)                                            :: t=0.0d0\n\tdo i=1,nx\n\t\tu(i)=sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2)))\n                !u(i)=sqrt(2.0d0)/cosh(x(i)+t)\n\tend do\n        t=-1.0d0*dt;\n\tdo i=1,nx\n\t\tuold(i)=sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2)))\n                !uold(i)=sqrt(2.0d0)/cosh(x(i)+t)\n\tend do\n\t\n\tend subroutine initialdata\n"}, {"instruction": "Create a Fortran subroutine named getlinestartendpts to calculate the endpoints of a line given the line direction and a distance. The subroutine takes 4 input parameters of type real*8: rpt (input line direction), vnx (input), vny (input), rdelta (input). It also returns 2 output parameters of type real*8: p1 (output points), p2 (output points).", "input": "", "output": "    subroutine getlinestartendpts(rpt,vnx,vny,rdelta,p1,p2)\n      implicit none\n      real*8 , intent(in)::vnx,vny,rdelta,rpt(2) !- input line direction\n      real*8 , intent(out)::p1(2),p2(2) !-output points\n      real*8 ::v1xv2 !- output intersection point\n      p1(1)=rpt(1)-rdelta*vnx\n      p1(2)=rpt(2)-rdelta*vny\n\n      p2(1)=rpt(1)+rdelta*vnx\n      p2(2)=rpt(2)+rdelta*vny\n\n    end subroutine getlinestartendpts\n"}, {"instruction": "Create a Fortran subroutine named getptonline that calculates the intersection point of a line and a point. The subroutine takes 3 input parameters of type real*8 and outputs 1 parameter of type real*8. The input parameters are rp1(2), rp2(2), and distratio, representing two points and a distance ratio. The output parameter is rptc(2), which represents the calculated intersection point.", "input": "", "output": "    subroutine getptonline(rp1,rp2,distratio,rptc)\n        implicit none\n        real*8 , intent(in)::rp1(2),rp2(2),distratio !- input line direction\n        real*8 , intent(out)::rptc(2) !-output points\n        real*8 ::v21(2) !- output intersection point\n\n        v21=rp2-rp1\n        rptc=rp1+distratio*v21\n\n    end subroutine getptonline\n"}, {"instruction": "Write a Fortran subroutine named eul2quat that converts Euler angles to a quaternion representation. The subroutine should have 1 input parameter of type real and intent(in), and 1 output parameter of type real and intent(out). The input parameter represents the Euler angles and the output parameter represents the quaternion. Use the given formula to compute the quaternion components based on the input Euler angles. Use the imperative tone and specify the number and type of input and output parameters clearly in the instructions.", "input": "", "output": "subroutine eul2quat(eul,q) \nreal, intent(in):: eul(3)\nreal, intent(out):: q(4)\nreal:: cy, sy, cp, sp, cr, sr\ncy = cos(eul(1)*.5);\nsy = sin(eul(1)*.5);\ncp = cos(eul(2)*.5);\nsp = sin(eul(2)*.5);\ncr = cos(eul(3)*.5);\nsr = sin(eul(3)*.5);\nq(1) = cy * cp * sr - sy * sp * cr\nq(2) = sy * cp * sr + cy * sp * cr\nq(3) = sy * cp * cr - cy * sp * sr\nq(4) = cy * cp * cr + sy * sp * sr\nend subroutine eul2quat\n"}, {"instruction": "Create a Fortran subroutine named quat2eul that takes in an array of 4 real numbers as input and outputs an array of 3 real numbers. The input array should represent a quaternion, and the output array should contain the corresponding Euler angles. Use the atan2 and asin functions to compute the Euler angles based on the quaternion input.", "input": "", "output": "subroutine quat2eul(q,eul) \nreal, intent(in):: q(4)\nreal, intent(out):: eul(3)\neul(1) = atan2(2.*(q(4)*q(3)+q(1)*q(2)), &\n\t1.-2.*(q(2)**2.+q(3)**2.))\neul(2) = asin(2.*(q(4)*q(2)-q(3)*q(1)))\neul(3) = atan2(2.*(q(4)*q(1)+q(2)*q(3)), &\n\t1.-2.*(q(1)**2.+q(2)**2.))\nend subroutine quat2eul\n"}, {"instruction": "Write a Fortran subroutine named mytest to transfer the first 8 bytes of a 16-byte character array into a real value. The number of input parameters is 1, of test_data type ['character(len=1), dimension(16)']. The number of output parameters is 1, of test_data type ['real(r8_)'].", "input": "", "output": "subroutine mytest(byte_array,val)\n  integer, parameter :: r8_ = selected_real_kind(15,307)  ! = real*8\n  character(len=1), dimension(16), intent(in) :: byte_array\n  real(r8_),intent(out) :: val\n  val = transfer(byte_array(1:8),val)    \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cholesky to perform the Cholesky decomposition on a symmetric positive-definite matrix. The subroutine takes 2 input parameters: an integer n and a real*8 matrix sst of size n x n. It returns 1 output parameter: a real*8 matrix s of size n x n.", "input": "", "output": "subroutine cholesky(sst, s, n)\n\n    integer, intent(in)  :: n\n    real*8, intent(in)   :: sst(n,n)\n    real*8, intent(out)   :: s(n,n)\n    real*8 :: d(n), l(n,n)\n\n    integer i,j,k\n\n    d = 0.d0\n    l = 0.d0\n    do i = 1,n\n        l(i,i)=1.\n        d(i)=sst(i,i)\n        do j=1,i-1\n            l(i,j)=sst(i,j);\n            do k=1,j-1\n                l(i,j)=l(i,j)-l(i,k)*l(j,k)*d(k)\n            end do\n            if (d(j).ne.0.) l(i,j)=l(i,j)/d(j)\n        end do\n        do k=1,i-1\n            d(i)=d(i)-l(i,k)*l(i,k)*d(k)\n        end do\n    end do\n    s=0.\n    do i=1,n\n        do j=1,i\n            if (d(j)>0.) s(i,j)=s(i,j)+l(i,j)*sqrt(d(j))\n        end do\n    end do\n\nend subroutine cholesky\n"}, {"instruction": "Create a Fortran subroutine named exp2reg that calculates the values of h and hder based on the input parameters r and damagepar. The number of input parameters is 2 with test_data type ['real*8', 'real*8'], and the number of output parameters is 2 with test_data type ['real*8 ', 'real*8 ']. The subroutine uses the features of Fortran and implements imperative logic to perform the calculations.", "input": "", "output": "subroutine exp2reg(h,hder,r,damagepar)\n\treal*8 , intent(out) :: h , hder\n\treal*8, intent(in) :: r , damagepar(:)\n\treal*8 :: r0, gf, lmu, beta\n\t\n\tr0 = damagepar(3)\n\tgf = damagepar(4)\n\tlmu = damagepar(5)\n\t\t\n\tbeta = 0.5*(-r0 + dsqrt((4.0d0*gf/lmu)-r0*r0))\n\twrite(0,*) beta\n\t\n\th = dexp(-(r- r0)/beta)*(1.0d0 - r/beta)\n\thder = - dexp(-(r-r0)/beta)*(2.0d0 - r/beta)/beta\n\t\n\t\t\n\twrite(0,*) r0,gf,lmu\n\t\n\tpause \n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named exp3dinf to calculate the value of h and hder based on the input parameters r and damagepar. The number of input parameters is 2, and their test_data type is ['real*8', 'real*8']. The number of output parameters is 2, and their test_data type is ['real*8 ', 'real*8 '].", "input": "", "output": "subroutine exp3dinf(h,hder,r,damagepar)\n\treal*8 , intent(out) :: h , hder\n\treal*8, intent(in) :: r , damagepar(:)\n\treal*8 :: r0, dinf, alpha, e\n\t\n\tr0 = damagepar(3)\n\talpha = damagepar(4)\n\tdinf = damagepar(5)\n\t\n\te = dexp(-alpha*(r- r0)/r0)\n\t\n\th = e*dinf*(1.0d0 - alpha*r/r0) + 1.0d0 - dinf\n\t\n\thder = - (alpha*e*dinf/r0)*(2.0d0 - alpha*r/r0)\n\t\n\twrite(0,*) r0,alpha, dinf\n\t\n\tpause \n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named compute_surface_tension to calculate the surface tension of a two-dimensional surface given surfactant concentration and specific parameters. The subroutine takes 3 input parameters of types integer, integer, and double precision array of dimension (nx, ny), and 1 output parameter of type double precision array of dimension (nx, ny).", "input": "", "output": "subroutine compute_surface_tension(nx, ny, surfactant, surface_tension)\n    implicit none\n    double precision :: beta, kappa, delta, mu, right_film_height\n    common /surfactant_config/ beta, kappa, delta, mu, right_film_height\n\n    integer, intent(in) :: nx, ny\n    double precision, dimension(nx, ny), intent(in) :: surfactant\n    double precision, dimension(nx, ny), intent(out) :: surface_tension\n\n    integer :: ix, iy\n\n    do iy = 1, ny\n        do ix = 1, nx\n            ! surface_tension(ix, iy) = (1.d0 + mu * surfactant(ix, iy))**(-3)\n            surface_tension(ix, iy) = 1.d0 - surfactant(ix, iy)\n        end do\n    end do\nend subroutine compute_surface_tension\n"}, {"instruction": "Create a Fortran subroutine named compute_surface_tension_d1 to calculate the first derivative of surface tension. The subroutine takes 3 input parameters: two integers (nx, ny) and a 2D array of double precision numbers (surfactant), and has 1 output parameter of a 2D array of double precision numbers (surface_tension_d1).", "input": "", "output": "subroutine compute_surface_tension_d1(nx, ny, surfactant, surface_tension_d1)\n    implicit none\n    double precision :: beta, kappa, delta, mu, right_film_height\n    common /surfactant_config/ beta, kappa, delta, mu, right_film_height\n\n    integer, intent(in) :: nx, ny\n    double precision, dimension(nx, ny), intent(in) :: surfactant\n    double precision, dimension(nx, ny), intent(out) :: surface_tension_d1\n\n    integer :: ix, iy\n\n    do iy = 1, ny\n        do ix = 1, nx\n            ! surface_tension_d1(ix, iy) = -3.d0 * mu * (1.d0 + mu * surfactant(ix, iy))**(-4)\n            surface_tension_d1(ix, iy) = -1.d0\n        end do\n    end do\nend subroutine compute_surface_tension_d1\n"}, {"instruction": "Create a Fortran subroutine named skipline that reads a specified number of lines from a formatted, sequentially accessed file in order to position the file marker. The subroutine has 2 input parameters of type integer and 1 output parameter of type character(len=*).", "input": "", "output": "subroutine skipline(iounit, record, lines)\n!  ========================================================================\n! |  reads a number of lines in a formatted, sequentially accessed file    |\n! |  to position the file marker.                                          |\n!  ========================================================================\n\n    implicit none\n\n    integer, intent(in) :: iounit\n    character(len=*), intent(out) :: record\n    integer, intent(in) :: lines\n    integer :: i, istat\n\n    do i = 1, lines\n      read(unit=iounit, fmt = \"(a)\", iostat=istat) record\n    end do\n\n    return\n\nend subroutine skipline\n"}, {"instruction": "Create a Fortran subroutine named t1 that takes an integer input parameter and returns an integer output parameter. The input parameter is declared with the intent(in) attribute, while the output parameter is declared with the intent(out) attribute. The function negates the input value and assigns it to the output parameter.", "input": "", "output": " subroutine t1(i,j) ! { dg-error \"redefine an intrinsic type assignment\" }\n   integer, intent(out)  :: i\n   integer, intent(in)  :: j\n   i=-j\n end subroutine t1\n"}, {"instruction": "Create a Fortran subroutine named readthirdpart_of_in1 to read and parse specific data from an input file. The subroutine takes 1 input parameter of type integer and returns 6 output parameters of type real*8, real*8, real*8, real*8, integer, and integer respectively. The subroutine reads certain lines from the input file referenced by fh_in1 and assigns values to itape, emin, emax, nband, sproj_limit, and eshift_iter based on the parsed data.", "input": "", "output": "subroutine readthirdpart_of_in1(itape,emin,emax,nband,sproj_limit,eshift_iter,fh_in1)\n  implicit none\n  real*8,  intent(out) :: emin, emax, sproj_limit, eshift_iter\n  integer, intent(out) :: itape, nband\n  integer, intent(in)  :: fh_in1\n  ! locals\n  character*80 :: line\n  integer      :: ios\n  real*8       :: test1, test2\n  \n  read(fh_in1,'(a)')line\n  nband=99999999\n  read(line(21:),*,iostat=ios) itape,emin,emax,nband  ! itape==klist unit ; emin==min_e ; emax==max_e ; nband==maximum number of bands\n  if (ios.ne.0) then\n     read(line(21:),*,iostat=ios) itape,emin,emax   ! maybe nbands is missing ; can be in two formats, either [int,real,real] or [int,real,real,it]\n  endif\n  read(fh_in1,'(a)',iostat=ios)line              ! maybe case.in1 contains also sproj_limit ?\n  if (ios.eq.0) then\n     read(line,*,iostat=ios) test1,test2   ! parse possible sproj_limit and eshift_iter\n     if (ios.ne.0) then                    ! did not find both numbers. maybe just one?\n        read(line,*,iostat=ios) test1\n        if (ios.ne.0) then\n           sproj_limit=1.0d-15\n           eshift_iter=0.d0\n        else\n           if(test1.gt.0.d0 .and. test1.lt.1.d-6) then\n              sproj_limit=test1\n              eshift_iter=0.d0\n           else if(abs(test1).lt.4.d0 .and. abs(test1).gt.1.d-6) then\n              sproj_limit=1.0d-15\n              eshift_iter=test1\n           else\n              sproj_limit=1.0d-15\n              eshift_iter=0.d0 \n           endif\n        endif\n     else\n        if(test1.gt.0.d0 .and. test1.lt.1.d-6) then\n           sproj_limit=test1\n           eshift_iter=0.d0\n           if(abs(test2).lt.4.d0 .and. abs(test2).gt.1.d-6) eshift_iter=test2\n        else if(abs(test1).lt.4.d0 .and. abs(test1).gt.1.d-6) then\n           sproj_limit=1.0d-15\n           eshift_iter=test1\n           if(test2.gt.0.d0 .and. test2.lt.1.d-6) sproj_limit=test2\n        else\n           sproj_limit=1.0d-15\n           eshift_iter=0.d0 \n        endif\n     endif\n  else\n     sproj_limit=1.0d-15   ! default value \n     eshift_iter=0.d0      ! default value\n  endif\n  !\nend subroutine readthirdpart_of_in1\n"}, {"instruction": "Write a Fortran subroutine named int_args_subr that takes three input integer arguments of kind 1, 2, and 4, and one output integer argument of kind 8. The subroutine calculates the sum of the input arguments and assigns the result to the output argument.", "input": "", "output": "subroutine int_args_subr(a,b,c,d)\n      integer(kind=1), intent(in) :: a\n      integer(kind=2), intent(in) :: b\n      integer(kind=4), intent(in) :: c\n      integer(kind=8), intent(out) :: d\n\n      d = a + b + c\n\nend subroutine int_args_subr\n"}, {"instruction": "Create a Fortran subroutine named inarea to determine whether a point is within the integral area. The subroutine takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "subroutine inarea(x, y, h)\n    ! judge whether the dot is in the integral area\n    real(8), intent(in) :: x, y\n    real(8), intent(out) :: h\n\n    h = 1.d0\nend subroutine inarea\n"}, {"instruction": "Create a Fortran subroutine named \"maxi\" to calculate the maximum value of a given real(8) vector. It takes 2 input parameters: an integer representing the length of the input vector and a real(8) vector. It has 1 output parameter of type real(8) to deliver the result. Use the imperative tone to define the subroutine.", "input": "", "output": "subroutine maxi(vect, vect_len, mm)\n!simple example for computing the maximum of a given vector\n!dec$ attributes dllexport,c,reference,alias:'maxi_' :: maxi\n    !the previous line is necessary for r to find the external function under its name\n\n    implicit none\n    !-------------------------------------------------------------------------------\n    !input\n    integer, intent(in)                     :: vect_len !length of input vector (needs to be specified explicitly)\n    real(8), intent(in), dimension(vect_len):: vect !actual vector\n    !-------------------------------------------------------------------------------\n    ! output\n    real(8), intent(out):: mm  !for delivering the result\n    !-------------------------------------------------------------------------------\n\n    !-------------------------------------------------------------------------------\n    ! code\n        mm = maxval(vect) \n    !-------------------------------------------------------------------------------\nend subroutine maxi\n"}, {"instruction": "Create a Fortran subroutine named mockweightinitmethod. This subroutine takes 1 input parameter of type real and 1 output parameter of type real. The input parameter is passed by reference using the \"intent(in)\" attribute and is an array of real numbers. The output parameter is passed by reference using the \"intent(out)\" attribute. The function initializes the output parameter \"weight\" with the value of the first element of the input array \"args\".", "input": "", "output": "        subroutine mockweightinitmethod(weight, args)\n            real, intent(out) :: weight\n            real, intent(in) :: args(0:)\n        \n            weight = args(0)\n\n        end subroutine mockweightinitmethod\n"}, {"instruction": "Write a Fortran subroutine named fopen that takes a file name as input and returns a unit number as output. The input parameter is of type character(len=*) and the output parameter is of type integer. The fopen subroutine checks if the file with the given name exists, and if it does, opens it with a new unit number for appending. If the file does not exist, it opens a new file with a new unit number for writing.", "input": "", "output": "            subroutine fopen(fname,u)\n            implicit none\n            character(len=*), intent(in) :: fname\n            integer, intent(out)         :: u\n            logical                      :: yes\n            inquire(file=fname,exist=yes)\n            if( yes ) then\n               open(newunit=u,file=fname,status=\"old\",action=\"write\",access=\"append\")\n            else\n               open(newunit=u,file=fname,status=\"new\",action=\"write\")\n            end if\n            end subroutine\n"}, {"instruction": "Create a Fortran subroutine named swigtm_fout_bool to convert an integer to a logical value. The subroutine takes 1 input parameter of type integer(kind=c_int) and returns 1 output parameter of type logical.", "input": "", "output": "subroutine swigtm_fout_bool(imout, fout)\n  use, intrinsic :: iso_c_binding\n  integer(kind=c_int), intent(in) :: imout\n  logical, intent(out) :: fout\n  fout = (imout /= 0)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sys_countparameters to determine the number of parameters in a given string. The input parameter is a string with a length of characters, and the output parameter is an integer representing the number of parameters in the string.", "input": "", "output": "  subroutine sys_countparameters (sstring,ntokens)\n  \n!<description>\n  ! returns the number of parameters in sstring\n!</description>\n\n!<input>\n  ! a string with parameters, e.g. \"0.1 0.2 0.3\",...\n  character(len=*), intent(in) :: sstring\n!</input>\n\n!<output>\n  ! number of parameters in sstring\n  integer, intent(out) :: ntokens\n!</output>\n\n\n    integer :: slen, istart\n    \n    ! if the string length is =0, finish.\n    ntokens = 0\n    \n    slen = len_trim(sstring)\n    if (slen .eq. 0) return\n    \n    ! find all substrings  \n    istart = 1\n    \n    do\n      ! cancel if nothing left.\n      if (istart .gt. slen) exit\n\n      ! skip whitespaces.\n      do while (istart .le. slen)\n        if (sstring(istart:istart) .eq. \" \") then\n          istart = istart + 1\n        else\n          exit\n        end if\n      end do\n      \n      ! cancel if we reached the string end\n      if (istart .gt. slen) exit\n      \n      ! end of the string?\n      do while (istart .le. slen)\n        if (sstring(istart:istart) .ne. \" \") then\n          istart = istart + 1\n        else\n          exit\n        end if\n      end do\n      \n      ! one more\n      ntokens = ntokens + 1\n      \n    end do\n    \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named converttocapital to convert a given character string to all capital letters. The subroutine takes 1 input parameter of type character(*) and returns 1 output parameter of type character(*).", "input": "", "output": "  subroutine converttocapital(cbuf,ckey)\n    implicit none\n    character(*),intent(in)  :: cbuf\n    character(*),intent(out) :: ckey\n    integer :: j,k,n\n    n=len_trim(cbuf)\n    ckey=\"\"\n    do j=1,n\n      k=iachar( cbuf(j:j) )\n      if ( k >= 97 ) k=k-32\n      ckey(j:j) = achar(k)\n    end do\n  end subroutine converttocapital\n"}, {"instruction": "Create a Fortran subroutine named split_date_char that takes a character input representing a date and splits it into individual components such as century_year, month, day, hour, minute, and second. The subroutine should have 1 input parameter of type character(len=19) and 6 output parameters of type integer.", "input": "", "output": "   subroutine split_date_char ( date , century_year , month , day , hour , minute , second )\n     \n      implicit none\n   \n      !  input data.\n   \n      character(len=19) , intent(in) :: date \n   \n      !  output data.\n   \n      integer , intent(out) :: century_year , month , day , hour , minute , second\n      \n      read(date,fmt='(    i4.4)') century_year\n      read(date,fmt='( 5x,i2.2)') month\n      read(date,fmt='( 8x,i2.2)') day\n      read(date,fmt='(11x,i2.2)') hour\n      read(date,fmt='(14x,i2.2)') minute\n      read(date,fmt='(17x,i2.2)') second\n   \n   end subroutine split_date_char\n"}, {"instruction": "Create a Fortran subroutine named func to calculate the differential equations of a dynamical system. The subroutine takes 5 input parameters of types integer and double precision, and returns 3 output parameters of type double precision.", "input": "", "output": " subroutine func(ndim,u,icp,par,ijac,f,dfdu,dfdp) \n!---------- ---- \n\n   implicit none\n   integer, intent(in) :: ndim, ijac, icp(*)\n   double precision, intent(in) :: u(ndim), par(*)\n   double precision, intent(out) :: f(ndim), dfdu(ndim,*), dfdp(ndim,*)\n\n   double precision x,y,z,xp,yp,zp,rmu,t,de,dm,rmc,de3,dm3\n\n   x  = u(1)        \n   y  = u(2) \n   z  = u(3) \n   xp = u(4) \n   yp = u(5) \n   zp = u(6) \n\n   rmu = par(2)\n   t   = par(11)\n\n   de  = sqrt((x+rmu)**2 + y**2 + z**2)\n   dm  = sqrt( (x-1+rmu)**2 + y**2 + z**2 )\n   rmc = 1 - rmu\n   de3 = 1./de**3\n   dm3 = 1./dm**3\n\n   f(1)= xp\n   f(2)= yp\n   f(3)= zp\n   f(4)= 2*yp + x - rmc*de3*(x+rmu) - rmu*dm3*(x-1+rmu) \n   f(5)=-2*xp + y - rmc*de3*y       - rmu*dm3*y        \n   f(6)=          - rmc*de3*z       - rmu*dm3*z       \n\n   f = t*f\n\n end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named \"bcnd\" to solve a boundary value problem. The subroutine takes 7 input parameters of types integer and double precision and returns 2 output parameters of type double precision. The function computes boundary conditions for a specific problem involving celestial mechanics. The subroutine calculates the boundary conditions based on the input parameters and stores the results in the output parameters.", "input": "", "output": " subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc)\n!---------- ----\n\n   implicit none\n   integer, intent(in) :: ndim, icp(*), nbc, ijac\n   double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n   double precision, intent(out) :: fb(nbc), dbc(nbc,*)\n\n   double precision eps,x,y,z,xp,yp,zp,rmu,de,dm,u,e\n   integer m\n\n   eps=par(6)\n!  par(25:30) are ustart and par(31:36) are vstart\n   m=min(nbc,ndim)\n   fb(1:m) =  u0(1:m) - ( par(25:25+m-1) + eps*par(31:31+m-1) )\n\n   fb(ndim+1:ndim+3) = u1(1:3) - par(21:23)\n\n   x  = u1(1)\n   y  = u1(2)\n   z  = u1(3)\n   xp = u1(4)\n   yp = u1(5)\n   zp = u1(6)\n\n   rmu = par(2)\n\n   de = sqrt((x+rmu)**2 + y**2 + z**2)\n   dm = sqrt( (x-1+rmu)**2 + y**2 + z**2 )\n\n   u = (x**2 + y**2)/2 + (1-rmu)/de + rmu/dm\n   e = (xp**2 + yp**2 + zp**2)/2 - u - rmu*(1-rmu)/2\n   fb(ndim+4) = par(3) - e\n\n end subroutine bcnd\n"}, {"instruction": "Write a Fortran subroutine named \"phixyzp\" to calculate the coordinates (ixp, iyp, izp) based on the input parameters is, ic, and level, which are integers. The subroutine returns the integers ixp, iyp, and izp as output parameters. The input parameters are is, ic, and level, while the output parameters are ixp, iyp, and izp.", "input": "", "output": "subroutine phixyzp(is,ic,ixp,iyp,izp,level)\n\n      implicit none\n\n      integer,intent(in) :: is,ic,level\n      integer,intent(out) :: ixp,iyp,izp\n! *** input is, ic and level and return ixp,iyp,iz\n! *** s: state (or kind) of curve segment\n! *** c: index in each segment from 0 to 7\n      integer icp\n      integer icstate(0:7,0:11)\n! *** define the order in each ph state in level 0 position ***\n      data icstate(0:7,0)/0,1,2,3,4,5,6,7/ &\n        ,icstate(0:7,1)/0,3,4,7,6,5,2,1/ &\n        ,icstate(0:7,2)/0,7,6,1,2,5,4,3/ &\n        ,icstate(0:7,3)/2,3,0,1,6,7,4,5/ &\n        ,icstate(0:7,4)/4,3,2,5,6,1,0,7/ &\n        ,icstate(0:7,5)/6,5,2,1,0,3,4,7/ &\n        ,icstate(0:7,6)/4,7,0,3,2,1,6,5/ &\n        ,icstate(0:7,7)/6,7,4,5,2,3,0,1/ &\n        ,icstate(0:7,8)/2,5,4,3,0,7,6,1/ &\n        ,icstate(0:7,9)/6,1,0,7,4,3,2,5/ &\n        ,icstate(0:7,10)/2,1,6,5,4,7,0,3/ &\n        ,icstate(0:7,11)/4,5,6,7,0,1,2,3/\n      integer ixind(0:7),iyind(0:7),izind(0:7)\n! *** ixp,iyp,izp value as a function of icp\n      data ixind/0,0,1,1,1,1,0,0/ &\n       ,iyind/0,0,0,0,1,1,1,1/ &\n       ,izind/0,1,1,0,0,1,1,0/\n\n      if(level.eq.1) then\n!        is=0\n        icp=ic\n      else\n        icp=icstate(ic,is)\n      endif\n      ixp=ixind(icp)\n      iyp=iyind(icp)\n      izp=izind(icp)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named producttrace3_ that calculates the product trace of two complex matrices. The subroutine takes 3 input parameters of type complex*16, complex*16, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine producttrace3_(c, a,b,ndim)\n  ! c(i) = sum_j a(j,i)*b(j,i)\n  implicit none\n  complex*16, intent(out):: c(ndim)\n  complex*16, intent(in) :: a(ndim,ndim), b(ndim,ndim)\n  integer, intent(in)    :: ndim\n  ! locals                                                                                                                                                                                                                                                                                    \n  integer :: i, j\n  complex*16 :: res\n  c=0\n  do i=1,ndim\n     res=0\n     do j=1,ndim\n        res = res + a(j,i)*b(j,i)\n     enddo\n     c(i) = res\n  enddo\nend subroutine producttrace3_\n"}, {"instruction": "Create a Fortran subroutine named calculate_factors to calculate the prime factors of an integer input. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer array with dynamic allocation. Ensure that the subroutine does not go over the maximum length of 1000 for the output array.", "input": "", "output": "subroutine calculate_factors(n, fac)\ninteger, intent(in) :: n\ninteger, intent(out), allocatable :: fac(:)\n! todo: add checks that we don't go over max_length below:\ninteger, parameter :: max_length = 1000\ninteger :: fac_tmp(max_length)\ninteger, parameter :: ntryh(4) = [3, 4, 2, 5]\ninteger :: nl, nf, i, j, ntry, ib, nq, nr\nif (n == 1) then\n    allocate(fac(1))\n    fac(1) = 1\n    return\nend if\nnl = n\nnf = 0\nj = 0\nntry = 0\ndo while (nl /= 1)\n    j = j+1\n    if (j <= 4) then\n        ntry = ntryh(j)\n    else\n        ntry = ntry+2\n    end if\n    ! divide by ntry as many times as we can:\n    do while (nl /= 1)\n        nq = nl/ntry\n        nr = nl-ntry*nq\n        if (nr /= 0) exit\n        nf = nf+1\n        fac_tmp(nf) = ntry\n        nl = nq\n        if (ntry == 2 .and. nf > 1) then\n            do i = 2, nf\n                ib = nf-i+2\n                fac_tmp(ib) = fac_tmp(ib-1)\n            end do\n            fac_tmp(1) = 2\n        end if\n    end do\nend do\nallocate(fac(nf))\nfac = fac_tmp(:nf)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two real input parameters and returns a real output parameter to compute the sum of the input values. The number of input parameters is 2 with the test_data type ['real', 'real'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "subroutine add(a, b, c)\nreal, intent(in) :: a, b\nreal, intent(out) :: c\nc = a + b\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"swigtm_fin_bool\" that takes a logical input parameter and returns an integer output parameter. The input parameter should be of type logical, and the output parameter should be of type integer with kind c_int. The subroutine should convert the logical input to an integer output, where true is represented as 1 and false is represented as 0.", "input": "", "output": "subroutine swigtm_fin_bool(finp, iminp)\n  use, intrinsic :: iso_c_binding\n  logical, intent(in) :: finp\n  integer(kind=c_int), intent(out) :: iminp\n  if (finp .eqv. .true.) then\n    iminp = 1\n  else\n    iminp = 0\n  end if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named itemwise_calc to perform element-wise calculations on an input array and store the results in an output array. The number of input parameters is 1, with the test_data type ['real*8, dimension(:)'], and the number of output parameters is 1, with the test_data type ['real*8, dimension(size(input))']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine itemwise_calc(input, output)\n\n  implicit none\n\n  real*8, dimension(:), intent(in) :: input\n  real*8, dimension(size(input)), intent(out) :: output\n  integer :: n\n\n  !$omp parallel do\n  do n = 1, size(input)\n    output(n) = (input(n) - 3) * (input(n) - 2) * (input(n) - 1) * input(n) * (input(n) + 1) * (input(n) + 2) * (input(n) + 3)\n  end do\n  !$omp end parallel do\n\n  return\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named f_strcpy to copy a given character string to another, with the length of the destination string adjusted to match the source string. The subroutine takes 1 input argument of type character(len=*) and 1 output argument of type character(len=*).", "input": "", "output": "  pure subroutine f_strcpy(dest,src)\n    implicit none\n    character(len=*), intent(out) :: dest\n    character(len=*), intent(in) :: src\n    !local variables\n    integer :: i,n\n    !dest=repeat(' ',len(dest))\n    n=min(len(src),len(dest))\n    do i=1,n\n       dest(i:i)=src(i:i)\n    end do\n    do i=n+1,len(dest)\n       dest(i:i)=' '\n    end do\n\n  end subroutine f_strcpy\n"}, {"instruction": "Write a Fortran subroutine named convert_f_char_ptr that takes an array of characters as input and converts it to a single character string. The input parameter is of type character, dimension(*), and intent(in). The output parameter is of type character(len=*), and intent(out).", "input": "", "output": "  subroutine convert_f_char_ptr(src,dest)\n    implicit none\n    character, dimension(*), intent(in) :: src\n    character(len=*), intent(out) :: dest\n    !local variables\n    integer :: i\n    dest(1:len(dest))=' '\n    seek_and_copy: do i=1,len(dest)\n       if (src(i)==char(0)) exit seek_and_copy\n       dest(i:i)=src(i)\n    end do seek_and_copy\n  end subroutine convert_f_char_ptr\n"}, {"instruction": "Write a Fortran subroutine named ppnd7 that implements the algorithm for producing the normal deviate z corresponding to a given lower tail area of p. The subroutine uses one input parameter of type real (sp) and two output parameters of type integer and real (sp).", "input": "", "output": "subroutine ppnd7 (p, normal_dev, ifault)\r\n\r\n! algorithm as241  appl. statist. (1988) vol. 37, no. 3, 477- 484.\r\n\r\n! produces the normal deviate z corresponding to a given lower tail area of p;\r\n! z is accurate to about 1 part in 10**7.\r\n\r\n! the hash sums below are the sums of the mantissas of the coefficients.\r\n! they are included for use in checking transcription.\r\n\r\n! this elf90-compatible version by alan miller - 20 august 1996\r\n\n\r\nimplicit none\r\ninteger, parameter  :: sp = selected_real_kind(6, 30)\r\n\r\nreal (sp), intent(in)   :: p\r\ninteger, intent(out)    :: ifault\r\nreal (sp), intent(out)  :: normal_dev\r\n\r\n! local variables\r\n\r\nreal (sp) :: zero = 0.0, one = 1.0, half = 0.5, split1 = 0.425,  &\r\n             split2 = 5.0, const1 = 0.180625, const2 = 1.6, q, r\r\n\r\n! coefficients for p close to 0.5\r\n\r\nreal (sp) :: a0 = 3.3871327179e+00, a1 = 5.0434271938e+01, &\r\n                   a2 = 1.5929113202e+02, a3 = 5.9109374720e+01, &\r\n                   b1 = 1.7895169469e+01, b2 = 7.8757757664e+01, &\r\n                   b3 = 6.7187563600e+01\r\n! hash sum ab          32.3184577772\r\n\r\n! coefficients for p not close to 0, 0.5 or 1.\r\n\r\nreal (sp) :: c0 = 1.4234372777e+00, c1 = 2.7568153900e+00, &\r\n             c2 = 1.3067284816e+00, c3 = 1.7023821103e-01, &\r\n             d1 = 7.3700164250e-01, d2 = 1.2021132975e-01\r\n! hash sum cd    15.7614929821\r\n\r\n! coefficients for p near 0 or 1.\r\n\r\nreal (sp) :: e0 = 6.6579051150e+00, e1 = 3.0812263860e+00, &\r\n             e2 = 4.2868294337e-01, e3 = 1.7337203997e-02, &\r\n             f1 = 2.4197894225e-01, f2 = 1.2258202635e-02\r\n! hash sum ef    19.4052910204\r\n\r\nifault = 0\r\nq = p - half\r\nif (abs(q) <= split1) then\r\n  r = const1 - q * q\r\n  normal_dev = q * (((a3 * r + a2) * r + a1) * r + a0) / &\r\n               (((b3 * r + b2) * r + b1) * r + one)\r\n  return\r\nelse\r\n  if (q < zero) then\r\n    r = p\r\n  else\r\n    r = one - p\r\n  end if\r\n  if (r <= zero) then\r\n    ifault = 1\r\n    normal_dev = zero\r\n    return\r\n  end if\r\n  r = sqrt(-log(r))\r\n  if (r <= split2) then\r\n    r = r - const2\r\n    normal_dev = (((c3 * r + c2) * r + c1) * r + c0) / ((d2 * r + d1) * r + one)\r\n  else\r\n    r = r - split2\r\n    normal_dev = (((e3 * r + e2) * r + e1) * r + e0) / ((f2 * r + f1) * r + one)\r\n  end if\r\n  if (q < zero) normal_dev = - normal_dev\r\n  return\r\nend if\r\nreturn\r\nend subroutine ppnd7\r\n"}, {"instruction": "Create a Fortran subroutine named inverse to calculate the inverse of a 3x3 matrix. The subroutine takes 1 input parameter of type real (kind=8) and 1 output parameter of type real (kind=8), both representing 3x3 matrices. Use the imperative tone to implement the inverse calculation.", "input": "", "output": "subroutine inverse(input,output)\n\n  implicit none \n  real (kind=8), intent(in) :: input(3,3)\n  real (kind=8), intent(out) :: output(3,3)\n  real (kind=8) :: determinant\n   \n  ! calculate the inverse of a 3x3 matrix\n   \n  determinant = -input(1,3)*input(2,2)*input(3,1)+input(1,2)*input(2,3)*input(3,1)+input(1,3)*input(2,1)*input(3,2)-&\n  input(1,1)*input(2,3)*input(3,2)-input(1,2)*input(2,1)*input(3,3)+input(1,1)*input(2,2)*input(3,3)\n\n  output(1,1) = (-input(2,3)*input(3,2)+input(2,2)*input(3,3)) / determinant\n  output(1,2) = (+input(1,3)*input(3,2)-input(1,2)*input(3,3)) / determinant\n  output(1,3) = (-input(1,3)*input(2,2)+input(1,2)*input(2,3)) / determinant\n\n  output(2,1) = (+input(2,3)*input(3,1)-input(2,1)*input(3,3)) / determinant\n  output(2,2) = (-input(1,3)*input(3,1)+input(1,1)*input(3,3)) / determinant\n  output(2,3) = (+input(1,3)*input(2,1)-input(1,1)*input(2,3)) / determinant\n\n  output(3,1) = (-input(2,2)*input(3,1)+input(2,1)*input(3,2)) / determinant\n  output(3,2) = (+input(1,2)*input(3,1)-input(1,1)*input(3,2)) / determinant\n  output(3,3) = (-input(1,2)*input(2,1)+input(1,1)*input(2,2)) / determinant\n\nend subroutine inverse\n"}, {"instruction": "Create a Fortran subroutine named m44inv to compute the inverse of a 4x4 matrix. The subroutine takes one input parameter of type double precision, dimension(4,4) and returns one output parameter of type double precision, dimension(4,4).", "input": "", "output": "subroutine m44inv (a, ainv)\n! http://web.hku.hk/~gdli/usefulfiles/matrix/m44inv_f90.txt\n  implicit none\n\n  double precision, dimension(4,4), intent(in)  :: a\n  double precision, dimension(4,4), intent(out) :: ainv\n\n  double precision :: det\n  double precision, dimension(4,4) :: cofactor\n\n\n  det =  a(1,1)*(a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)- &\n         a(3,3)*a(4,2)))-a(1,2)*(a(2,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+ &\n         a(2,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1)))+a(1,3)*(a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)- &\n         a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))-a(1,4)*(a(2,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+ &\n         a(2,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(2,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))\n\n  cofactor(1,1) = a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))\n  cofactor(1,2) = a(2,1)*(a(3,4)*a(4,3)-a(3,3)*a(4,4))+a(2,3)*(a(3,1)*a(4,4)-a(3,4)*a(4,1))+a(2,4)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))\n  cofactor(1,3) = a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1))\n  cofactor(1,4) = a(2,1)*(a(3,3)*a(4,2)-a(3,2)*a(4,3))+a(2,2)*(a(3,1)*a(4,3)-a(3,3)*a(4,1))+a(2,3)*(a(3,2)*a(4,1)-a(3,1)*a(4,2))\n  cofactor(2,1) = a(1,2)*(a(3,4)*a(4,3)-a(3,3)*a(4,4))+a(1,3)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(1,4)*(a(3,3)*a(4,2)-a(3,2)*a(4,3))\n  cofactor(2,2) = a(1,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(1,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+a(1,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1))\n  cofactor(2,3) = a(1,1)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(1,2)*(a(3,1)*a(4,4)-a(3,4)*a(4,1))+a(1,4)*(a(3,2)*a(4,1)-a(3,1)*a(4,2))\n  cofactor(2,4) = a(1,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+a(1,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(1,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1))\n  cofactor(3,1) = a(1,2)*(a(2,3)*a(4,4)-a(2,4)*a(4,3))+a(1,3)*(a(2,4)*a(4,2)-a(2,2)*a(4,4))+a(1,4)*(a(2,2)*a(4,3)-a(2,3)*a(4,2))\n  cofactor(3,2) = a(1,1)*(a(2,4)*a(4,3)-a(2,3)*a(4,4))+a(1,3)*(a(2,1)*a(4,4)-a(2,4)*a(4,1))+a(1,4)*(a(2,3)*a(4,1)-a(2,1)*a(4,3))\n  cofactor(3,3) = a(1,1)*(a(2,2)*a(4,4)-a(2,4)*a(4,2))+a(1,2)*(a(2,4)*a(4,1)-a(2,1)*a(4,4))+a(1,4)*(a(2,1)*a(4,2)-a(2,2)*a(4,1))\n  cofactor(3,4) = a(1,1)*(a(2,3)*a(4,2)-a(2,2)*a(4,3))+a(1,2)*(a(2,1)*a(4,3)-a(2,3)*a(4,1))+a(1,3)*(a(2,2)*a(4,1)-a(2,1)*a(4,2))\n  cofactor(4,1) = a(1,2)*(a(2,4)*a(3,3)-a(2,3)*a(3,4))+a(1,3)*(a(2,2)*a(3,4)-a(2,4)*a(3,2))+a(1,4)*(a(2,3)*a(3,2)-a(2,2)*a(3,3))\n  cofactor(4,2) = a(1,1)*(a(2,3)*a(3,4)-a(2,4)*a(3,3))+a(1,3)*(a(2,4)*a(3,1)-a(2,1)*a(3,4))+a(1,4)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\n  cofactor(4,3) = a(1,1)*(a(2,4)*a(3,2)-a(2,2)*a(3,4))+a(1,2)*(a(2,1)*a(3,4)-a(2,4)*a(3,1))+a(1,4)*(a(2,2)*a(3,1)-a(2,1)*a(3,2))\n  cofactor(4,4) = a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))+a(1,2)*(a(2,3)*a(3,1)-a(2,1)*a(3,3))+a(1,3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))\n\n  ainv = transpose(cofactor) / det\n\n  return\n\n  end subroutine m44inv\n"}, {"instruction": "Create a Fortran subroutine named uncell to convert a 3x3 matrix representing a crystallographic unit cell into its corresponding cell parameters. The input parameter is a 3x3 matrix of real numbers, and the output parameter is an array of 6 real numbers representing the cell parameters.", "input": "", "output": " subroutine uncell(rv,cell_0)\n! ======================\n! gulp\n! ======================\n  implicit none\n  real,intent(out)   :: cell_0(6)\n  real,intent(in)    :: rv(3,3)\n  integer            :: i,j\n  real               :: temp(6)\n  real               :: radtodeg\n  real, parameter    :: pi=acos(-1.0)\n  radtodeg=180.0/pi\n  do i = 1,3\n    temp(i) = 0.0\n    do j = 1,3\n      temp(i) = temp(i) + rv(j,i)**2\n    enddo\n    temp(i) = sqrt(temp(i))\n  enddo\n  cell_0(1) = abs(temp(1))\n  cell_0(2) = abs(temp(2))\n  cell_0(3) = abs(temp(3))\n  do i = 1,3\n    temp(3+i) = 0.0\n  enddo\n  do j = 1,3\n    temp(4) = temp(4) + rv(j,2)*rv(j,3)\n    temp(5) = temp(5) + rv(j,1)*rv(j,3)\n    temp(6) = temp(6) + rv(j,1)*rv(j,2)\n  enddo\n  temp(4) = temp(4)/(temp(2)*temp(3))\n  temp(5) = temp(5)/(temp(1)*temp(3))\n  temp(6) = temp(6)/(temp(1)*temp(2))\n  cell_0(4) = radtodeg*acos(temp(4))\n  cell_0(5) = radtodeg*acos(temp(5))\n  cell_0(6) = radtodeg*acos(temp(6))\n  do i=4,6\n     if (abs(cell_0(i) - 90.0 ).lt.0.00001) cell_0(i) = 90.0\n     if (abs(cell_0(i) - 120.0).lt.0.00001) cell_0(i) = 120.0\n  enddo\n  return\n end subroutine uncell\n"}, {"instruction": "Create a Fortran subroutine named check_isnew to check if a target integer is new in the input integer array. The subroutine takes 3 input parameters of type integer: inlist, n, and tgt. It also has 1 output parameter of type logical: isnew. The subroutine sets isnew to .true. initially and then iterates through the inlist to check if tgt is present. If tgt is found in inlist, isnew is set to .false. and the loop exits.", "input": "", "output": "subroutine check_isnew( inlist, n, tgt, isnew )\n    integer, intent(in) :: inlist(:), n, tgt\n    logical, intent(out) :: isnew\n    integer :: nctr\n\n    isnew = .true.\n    do nctr = 1, n\n        if (inlist(nctr).eq.tgt) then\n            isnew = .false.\n            exit\n        end if\n    end do\nend subroutine check_isnew\n"}, {"instruction": "Create a Fortran subroutine named random3 that generates a vector of normal (gaussian) random numbers with a mean of 0 and variance of 1. The subroutine takes 2 input parameters of type integer, n_var and n_ens, and has 1 output parameter of type real(8), work1(n_var,n_ens).", "input": "", "output": "subroutine random3(work1,n_var,n_ens)\r\n! returns a vector of normal (gaussian) random numbers n(mean=0,variance=1)\r\n!\r\n  implicit none\r\n  integer             :: i,j\r\n  integer,intent(in)  :: n_var,n_ens\r\n  real(8),intent(out) :: work1(n_var,n_ens)\r\n  real(8)             :: work2(n_var,n_ens)\r\n  real(8),parameter   :: pi = 3.141592653589d0\r\n!\r\n  do j=1,n_ens\r\n    call random_number(work1(1:n_var,j))  ! uniform random number between 0 and 1\r\n    call random_number(work2(1:n_var,j))\r\n  enddo\r\n!\r\n! box-muller's method\r\n  do j=1,n_ens\r\n  do i=1,n_var\r\n    work1(i,j)= dsqrt(-2.d0*dlog(work1(i,j)))*dcos(2.d0*pi*work2(i,j))\r\n  enddo\r\n  enddo\r\n!\r\nend subroutine random3\r\n"}, {"instruction": "Write a Fortran subroutine named put_1d_to_2d to rearrange a 1D array into a 2D array. The input parameter is a 1D real(8) array, and the output parameter is a 2D real(8) array.", "input": "", "output": "  subroutine put_1d_to_2d( tau, xin )\n    implicit none\n    real(8),intent(out) ::  tau(:,:)\n    real(8),intent(in)  :: xin(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          tau(j,i) = xin(k)\n       end do\n    end do\n  end subroutine put_1d_to_2d\n"}, {"instruction": "Create a Fortran subroutine named put_2d_to_1d to flatten a 2D array into a 1D array. The input parameter is a 2D array of real(8) type, and the output parameter is a 1D array of real(8) type.", "input": "", "output": "  subroutine put_2d_to_1d( tau, xout )\n    implicit none\n    real(8),intent(in)  :: tau(:,:)\n    real(8),intent(out) :: xout(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          xout(k) = tau(j,i)\n       end do\n    end do\n  end subroutine put_2d_to_1d\n"}, {"instruction": "Create a Fortran subroutine named constraint_func_distance to calculate the Euclidean distance between two 3D points and the difference between the calculated distance and a given reference distance. The subroutine takes 3 input parameters of type real(8) and returns 2 output parameters of type real(8). The input parameter types are ['real(8)', 'real(8)', 'real(8)'] and the output parameter types are ['real(8)', 'real(8)'].", "input": "", "output": "  subroutine constraint_func_distance( fd, d, d0, x, y )\n    implicit none\n    real(8),intent(in)  :: d0, x(3), y(3)\n    real(8),intent(out) :: d, fd\n    d  = sqrt( sum( (x-y)**2 ) )\n    fd = d - d0\n  end subroutine constraint_func_distance\n"}, {"instruction": "Create a Fortran subroutine named diff_func_distance that calculates the difference vector between two 3D points. The subroutine takes 2 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are r1 and r2, representing the 3D coordinates of two points. The output parameter is dr, which is an array of 6 real(8) values representing the components of the difference vector.", "input": "", "output": "  subroutine diff_func_distance( dr,r1,r2 )\n    implicit none\n    real(8),intent(out) :: dr(6)\n    real(8),intent(in) :: r1(3),r2(3)\n    real(8),parameter :: epsilon=1.d-12\n    real(8) :: r,x,y,z\n    x = r1(1) - r2(1)\n    y = r1(2) - r2(2)\n    z = r1(3) - r2(3)\n    r = sqrt( x*x + y*y + z*z )\n    if ( r < epsilon ) then\n       dr(1) = 0.0d0\n       dr(2) = 0.0d0\n       dr(3) = 0.0d0\n       dr(4) = 0.0d0\n       dr(5) = 0.0d0\n       dr(6) = 0.0d0\n    else\n       dr(1) =  x/r\n       dr(2) =  y/r\n       dr(3) =  z/r\n       dr(4) = -x/r\n       dr(5) = -y/r\n       dr(6) = -z/r\n    end if\n  end subroutine diff_func_distance\n"}, {"instruction": "Create a Fortran subroutine named rhs_eqns to calculate the right-hand side (r.h.s) of a system of ordinary differential equations. The subroutine will take 3 input parameters of type real(kind = 8) and 1 output parameter of type real(kind = 8).", "input": "", "output": "subroutine rhs_eqns(t, y0, rhs, gravity)\n\timplicit none\n\n\treal(kind = 8), intent(in) :: t, y0(4)\n\treal(kind = 8), intent(out) :: rhs(4)\n\treal(kind = 8) x, y, vx, vy\n\n\t! constants normalized\n\treal(kind = 8), intent(in) :: gravity\n\n\t! intialize vectors\n\tx = y0(1)\n\ty = y0(2)\n\tvx = y0(3)\n\tvy = y0(4)\n\n\t! r.h.s of x-position equations\n\trhs(1) = vx\n\n\t! r.h.s of y-position equations\n\trhs(2) = vy\n\n\t! r.h.s of x-velocity equations\n\trhs(3) = -gravity * x / (x**2 + y**2)**1.5d0\n\n\t! r.h.s of y-velocity equations\n\trhs(4) = -gravity * y / (x**2 + y**2)**1.5d0\nend subroutine rhs_eqns\n"}, {"instruction": "Create a Fortran subroutine named dlocate that takes in an array of double precision numbers, a single double precision number, and returns the index of the array where the given number should be inserted to maintain the ascending order. The number of input arguments is 2, with test_data types ['double precision, dimension(:)', 'double precision'], and the number of output arguments is 1 with a test_data type of ['integer'].", "input": "", "output": "      subroutine dlocate(xx,x,indx)\n      implicit none\n      double precision, dimension(:), intent(in) :: xx\n      double precision, intent(in) :: x\n      integer, intent(out) :: indx\n      integer :: n,jl,jm,ju\n      logical :: ascnd\n!      write(6,*) 'xx: ',xx,x,size(xx)\n      n=size(xx)\n      ascnd = (xx(n) >= xx(1))\n      jl=0\n      ju=n+1\n      do\n        if (ju-jl <= 1) exit\n        jm=(ju+jl)/2\n        if (ascnd .eqv. (x >= xx(jm))) then\n          jl=jm\n        else\n          ju=jm\n        end if\n      end do\n      if (x == xx(1)) then\n        indx=1\n      else if (x == xx(n)) then\n        indx=n-1\n      else\n        indx=jl\n      end if\n      end subroutine dlocate\n"}, {"instruction": "Create a Fortran subroutine named rmoi to calculate the total moment of inertia of a collection of atoms. The subroutine takes 4 input parameters: mass (real*8 array), xyz (real*8 2D array), atnum (integer array), natm (integer). It returns 1 output parameter: itot (real*8).", "input": "", "output": "subroutine rmoi(mass, xyz ,atnum , itot ,natm)\r\nimplicit none\r\nreal*8,intent(out) ::itot\r\nreal*8,intent(in) ::mass(:),xyz(:,:)\r\ninteger,intent(in) ::atnum(:) ,natm\r\nreal*8 :: tot, il, ir\r\ninteger ::iatm ,i\r\n\r\ntot=0\r\nil=0 \r\ndo iatm=1, natm\r\n    tot=(mass(iatm)*(xyz(iatm,1)**2+xyz(iatm,2)**2)+tot)\r\nend do\r\ndo i=1, natm \r\n    if (0/=atnum(i)) then\r\n        il=mass(atnum(i))*(xyz(atnum(i),1)**2+xyz(atnum(i),2)**2)+il\r\n    else \r\n        exit\r\n    end if\r\nend do\r\nir=tot-il\r\nitot=1/((1/il)+(1/ir))\r\n\r\nend subroutine rmoi\r\n"}, {"instruction": "Create a Fortran subroutine named str2int to convert a string to an integer and provide the status of the conversion. The subroutine has 1 input parameter of type character(len=*) and 2 output parameters of type integer.", "input": "", "output": "subroutine str2int(str, i, stat)\n    implicit none\n    ! arguments\n    character(len=*), intent(in) :: str\n    integer, intent(out)         :: i\n    integer, intent(out)         :: stat\n\n    read(str,*,iostat=stat) i\nend subroutine str2int\n"}, {"instruction": "Write a Fortran subroutine named ones_1d to initialize a one-dimensional array with ones. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type real(8), allocatable.", "input": "", "output": "  subroutine ones_1d(vec, n)\n    real(8), allocatable, intent(out) :: vec(:)\n    integer, intent(in) :: n\n    allocate(vec(n))\n    vec = 1.0d0\n  end subroutine ones_1d\n"}, {"instruction": "Write a Fortran subroutine named ones_2d that initializes a 2D array with ones. The subroutine takes 2 input parameters of type integer, and the test_data type is ['integer', 'integer']. It also has 1 output parameter of type real(8), allocatable, and the test_data type is ['real(8), allocatable'].", "input": "", "output": "  subroutine ones_2d(arr, m, n)\n    real(8), allocatable, intent(out) :: arr(:,:)\n    integer, intent(in) :: m, n\n    allocate(arr(m,n))\n    arr = 1.0d0\n  end subroutine ones_2d\n"}, {"instruction": "Create a Fortran subroutine named \"lnrf_frame_real\" to calculate the transformed velocities in a non-rotating frame from input parameters. The subroutine takes 6 input parameters of type real, dimension(:) and one output parameter of type real, dimension(size(r)). The subroutine also has 3 output parameters of type real, dimension(size(r)).", "input": "", "output": "        subroutine lnrf_frame_real(vr,vt,omega,r,a,th,vrl,vtl,vpl)\n        real, dimension(:), intent(in) :: vr,vt,omega,r,th\n        real, intent(in) :: a\n        real, dimension(size(r)), intent(out) :: vrl,vtl,vpl\n        real, dimension(size(r)) :: zero,d,ar,rho,enu,emu1, &\n         emu2,epsi,om,mu\n        zero=0d0\n        mu=cos(th)\n        d=r*r-2.*r+a*a\n        ar=(r*r+a*a)**2-a*a*d*(1.-mu*mu)\n        rho=r*r+a*a*mu*mu\n        enu=sqrt(d*rho/ar)\n        emu1=sqrt(rho/d)\n        emu2=sqrt(rho)\n        epsi=sqrt(1.-mu*mu)*sqrt(ar/rho)\n        om=2.*a*r/ar\n        vrl=emu1/enu*vr\n        vtl=emu2/enu*vt\n        vpl=epsi/enu*(omega-om)\n        vrl=merge(vrl,zero,d.gt.0d0)\n        vtl=merge(vtl,zero,d.gt.0d0)\n        vpl=merge(vpl,zero,d.gt.0d0)\n        end subroutine lnrf_frame_real\n"}, {"instruction": "Create a Fortran subroutine named fmkdke to calculate the stiffness matrices ke and kd based on given input matrices km, kp, and c, along with the parameter theta. The input parameters consist of 4 real(iwp) arrays: km, kp, c, and theta. The output parameters include 2 real(iwp) arrays: ke and kd.", "input": "", "output": "subroutine fmkdke(km,kp,c,ke,kd,theta)\n!\n\n! the 'elastic' stiffness km, fluid stiffness kp and coupling matrix c.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::km(:,:),kp(:,:),c(:,:),theta\n real(iwp),intent(out)::ke(:,:),kd(:,:)\n integer::ndof\n real::one=1.0_iwp\n ndof=size(km,1)\n ke(:ndof,:ndof)=theta*km\n ke(:ndof,ndof+1:)=theta*c\n ke(ndof+1:,:ndof)=theta*transpose(c)\n ke(ndof+1:,ndof+1:)=-theta**2*kp\n kd(:ndof,:ndof)=(theta-one)*km\n kd(:ndof,ndof+1:)=(theta-one)*c\n kd(ndof+1:,:ndof)=ke(ndof+1:,:ndof)\n kd(ndof+1:,ndof+1:)=theta*(one-theta)*kp\nreturn\nend subroutine fmkdke\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_qpw4p0 to calculate the global degrees of freedom of quadrilateral, piecewise linear p0 elements based on the input element indices and the number of vertices adjacent to each element. The subroutine takes 3 input parameters of type integer, dimension(:,:), integer, dimension(:), and integer, and 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "  subroutine dof_locglobunimult_qpw4p0(iverticesatelement, ielidx, idofglob, nvt)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be quadrilateral, piecewise linear\n  ! p0 elements.\n  ! a uniform grid is assumed, i.e. a grid completely discretised the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! an array with the number of vertices adjacent to each element of the\n  ! triangulation.\n  integer, dimension(:,:), intent(in) :: iverticesatelement\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n  ! total number of vertices\n  integer, intent(in) :: nvt\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s.\n      idofglob(1,i) = 4*(ielidx(i)-1)+1\n      idofglob(2,i) = 4*(ielidx(i)-1)+2\n      idofglob(3,i) = 4*(ielidx(i)-1)+3\n      idofglob(4,i) = 4*(ielidx(i)-1)+4\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_qpw4p1t to map the local degrees of freedom of quadrilateral, piecewise rotated linear nonconforming p1~ elements to their corresponding global degrees of freedom. The subroutine takes 3 input parameters of type ['integer, dimension(:,:)', 'integer, dimension(:)', 'integer'] and 1 output parameter of type ['integer, dimension(:,:)'].", "input": "", "output": "  subroutine dof_locglobunimult_qpw4p1t(iedgesatelement, ielidx, idofglob, nmt)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be quadrilateral, piecewise rotated\n  ! linear nonconforming p1~ elements.\n  ! a uniform grid is assumed, i.e. a grid completely discretised the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! an array with the number of edges adjacent on each element of the\n  ! triangulation.\n  integer, dimension(:,:), intent(in) :: iedgesatelement\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n  ! total number of edges\n  integer, intent(in) :: nmt\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s - which are simply the edge numbers.\n      idofglob(1:4,i) = iedgesatelement(1:4,ielidx(i))\n\n      ! plus 4 times the element, for the four inner edges\n      idofglob(5,i) = nmt + 4*(ielidx(i)-1) + 1\n      idofglob(6,i) = nmt + 4*(ielidx(i)-1) + 2\n      idofglob(7,i) = nmt + 4*(ielidx(i)-1) + 3\n      idofglob(8,i) = nmt + 4*(ielidx(i)-1) + 4\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_dgq22d to calculate the global degree of freedom numbers for a list of element indices. The input parameter is an array of element indices of type integer and dimension (:), and the output parameter is a 2D array of global degree of freedom numbers of type integer and dimension (:,:).", "input": "", "output": "  subroutine dof_locglobunimult_dgq22d(ielidx, idofglob)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be the dg q2.\n  ! a uniform grid is assumed, i.e. a grid completely discretised by the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s. every element gives 9 dof`s which are\n      ! not coupled to any other element\n      idofglob(1,i) = 1+9*(ielidx(i)-1)\n      idofglob(2,i) = 2+9*(ielidx(i)-1)\n      idofglob(3,i) = 3+9*(ielidx(i)-1)\n      idofglob(4,i) = 4+9*(ielidx(i)-1)\n      idofglob(5,i) = 5+9*(ielidx(i)-1)\n      idofglob(6,i) = 6+9*(ielidx(i)-1)\n      idofglob(7,i) = 7+9*(ielidx(i)-1)\n      idofglob(8,i) = 8+9*(ielidx(i)-1)\n      idofglob(9,i) = 9+9*(ielidx(i)-1)\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named y_gauleg to compute the positions for function evaluations and weights using the Gauss-Legendre quadrature method. The subroutine takes 3 input parameters of type integer, real, and real, and returns 2 output parameters of type real.", "input": "", "output": "subroutine y_gauleg(x1,x2,x,w,n)\n!-------------------------------------------------------------------\ninteger, intent(in) ::  n    ! number of intervals\nreal, intent(in)    ::  x1   ! lower limit of integration interval\nreal, intent(in)    ::  x2   ! upper limit of integration interval\nreal, intent(out)   ::  x(n) ! positions for function evaluations\nreal, intent(out)   ::  w(n) ! weights\n!\n!-----------------------------------------------------------------------\ndouble precision eps\nparameter (eps=3.d-14)\ninteger i,j,m\ndouble precision p1,p2,p3,pp,xl,xm,z,z1\n!-----------------------------------------------------------------------\n      m=(n+1)/2\n      xm=0.5d0*(x2+x1)\n      xl=0.5d0*(x2-x1)\n      do 12 i=1,m\n        z=cos(3.141592654d0*(i-.25d0)/(n+.5d0))\n1       continue\n          p1=1.d0\n          p2=0.d0\n          do 11 j=1,n\n            p3=p2\n            p2=p1\n            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j\n11        continue\n          pp=n*(z*p1-p2)/(z*z-1.d0)\n          z1=z\n\n          z=z1-p1/pp\n        if(abs(z-z1).gt.eps)goto 1\n        x(i)=xm-xl*z\n        x(n+1-i)=xm+xl*z\n        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)\n        w(n+1-i)=w(i)\n12    continue\n!\nreturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named legp to compute the associated Legendre polynomials and their derivatives. The subroutine takes 2 input parameters of type double precision and integer, and returns 2 output parameters of type double precision. The input parameters are x (cosine of the angle) and n (degree of the polynomial), while the output parameters are pn (Legendre polynomial) and pp (derivative of the Legendre polynomial).", "input": "", "output": "        subroutine legp(n, x, pn, pp) ! standard 3 terms rec for pn and dpn / d cth\n        implicit none\n        double precision, intent(in) :: x  ! cos(tht)\n        integer, intent(in) :: n\n        double precision, intent(out) :: pn, pp\n        double precision p2, p3\n        integer j\n        pn = 1.0d0\n        p2 = 0.0d0\n        do j=1,n\n            p3 = p2\n            p2 = pn\n            pn = ((2*j-1)*x*p2-(j-1)*p3)/j\n        end do\n        pp = n*(x*pn-p2)/(x*x-1)\n        end subroutine legp\n"}, {"instruction": "Create a Fortran subroutine named \"anbncn_jacobi\" to calculate the 3-terms recursion relation coefficients for Jacobi polynomials. The subroutine should take 3 input parameters of type integer, double precision, and double precision, and return 3 output parameters of type double precision.", "input": "", "output": "    subroutine anbncn_jacobi(a, b, lmax, an, bn, cn)\n        !returns 3-terms recursion relation coefficients for jacobi polynomials\n        ! ~0.1ms at most even for high lmax\n        implicit none\n        integer, intent(in) :: lmax\n        double precision, intent(in) :: a, b\n        double precision apb\n        integer il\n        double precision, intent(out):: an(0:lmax-1), bn(0:lmax-1), cn(0:lmax-1)\n        apb = a + b\n        cn(0) = 0.\n        an(0) = (1 + apb) / 2 * (2 + apb) / (1 + apb)\n        do il = 1, lmax - 1\n            an(il) = (2 * il + 1 + apb) / (2 * (il + 1)) * (2 * il + 2 + apb) / (il + 1 + apb)\n            cn(il) = (il + a) * (il + b) / (il + 1) * (2 * il + 2 + apb) / (il + 1 + apb) / (2 * il + apb)\n        end do\n        if (abs(a) == abs(b)) then\n            bn = 0.d0\n        else\n            do il = 0, lmax - 1\n              bn(il) = 0.5d0 * apb * (a - b) * (2 * il + 1 + apb) / (il + 1) / (2 * il + apb) / (il + 1 + apb)\n            end do\n        end if\n    end subroutine anbncn_jacobi\n"}, {"instruction": "Create a Fortran subroutine named bi_linear_coef to calculate the coefficients of a bi-linear interpolation. The subroutine takes 2 input parameters of type real, ys and zs, and 1 output parameter of type real, dimension(0:1,0:1), coef.", "input": "", "output": "  subroutine bi_linear_coef(ys,zs, coef)\n\n    real, intent(in) :: ys,zs\n    real, dimension(0:1,0:1), intent(out) :: coef\n\n    coef(0,0) = (1.-ys)*(1.-zs)\n    coef(0,1) = (1.-ys)*zs\n    coef(1,0) = ys*(1.-zs)\n    coef(1,1) = ys*zs\n\n    return\n  end subroutine bi_linear_coef\n"}, {"instruction": "Write a Fortran subroutine named running_avg that calculates the running average and standard deviation of a series of input values. The subroutine takes 2 input arguments of type real and logical. It returns 3 output arguments of type real, real, and integer.", "input": "", "output": "subroutine running_avg(x, avg, std_dev, nvals, reset)\nimplicit none\n\nreal, intent(in) :: x\nreal, intent(out) :: avg, std_dev\ninteger, intent(out) :: nvals\nlogical, intent(in) :: reset\ninteger, save :: n\nreal, save :: sum_x, sum_x2\n\ncalc_sums: if(reset) then\n  n       = 0\n  sum_x   = 0.\n  sum_x2  = 0.\n  avg     = 0.\n  std_dev = 0.\n  nvals   = 0\nelse\n  n      = n + 1\n  sum_x  = sum_x + x\n  sum_x2 = sum_x2 + x**2\n\n  avg = sum_x / real(n)\n\n  if (n >= 2) then\n    std_dev = sqrt((real(n) * sum_x2 - sum_x**2) &\n            / (real(n) * real(n-1)))\n  else\n    std_dev = 0.\n  end if\n\n  nvals = n\nend if calc_sums\nend subroutine running_avg\n"}, {"instruction": "Create a Fortran subroutine named parallel_reduce_i to perform parallel reduction operation. The subroutine takes 4 input arguments of type integer, with the first two being mandatory and the last two optional. Additionally, there is 1 output argument of type integer.", "input": "", "output": "  subroutine parallel_reduce_i(r, a, op, proc, comm)\n    integer, intent(in) :: a\n    integer, intent(in) :: op\n    integer, intent(in), optional :: proc, comm\n    integer, intent(out) :: r\n    r = a\n  end subroutine parallel_reduce_i\n"}, {"instruction": "Create a Fortran subroutine named get_freq_len to read data from a file and assign values to the output variables. The subroutine takes 1 input parameter of type character*2500 and 2 output parameters of type integer. The input parameter represents the file path, while the output parameters represent the frequency length and g length.", "input": "", "output": "subroutine get_freq_len(path,freq_len,g_len)\n\n  implicit none\n  ! i/o\n  character*2500, intent(in) :: path\n  integer, intent(out) :: freq_len, g_len\n\n  g_len = 1\n  open(unit=10,file=trim(adjustl(path))//'/opacities/lines/corr_k/h2o/kappa_g_info.dat')\n  read(10,*) freq_len, g_len\n  close(10)\n  freq_len = freq_len-1\n  ! g_len = g_len-2 ! for old 32 grid\n\nend subroutine get_freq_len\n"}, {"instruction": "Create a Fortran subroutine named get_freq to read frequency data from a file and calculate the average frequencies. The subroutine takes 2 input parameters of type character*1500 and integer, and 2 output parameters of type double precision and double precision. The subroutine reads the frequency data from the specified file path, performs calculations, and stores the results in the output arrays.", "input": "", "output": "subroutine get_freq(path,freq_len,freq,freq_use_ck)\n\n  implicit none\n  ! i/o\n  character*1500, intent(in) :: path\n  integer, intent(in) :: freq_len\n  double precision, intent(out) :: freq(freq_len), &\n       freq_use_ck(freq_len+1)\n  ! internal\n  integer :: i_freq, freq_len_use_ck\n  double precision :: buffer\n\n  ! because freqs fot c-k are stored as borders!\n  freq_len_use_ck = freq_len + 1\n  open(unit=10,file=trim(adjustl(path))//'/opacities/lines/corr_k/h2o/kappa_g_info.dat')\n  read(10,*)\n  do i_freq = 1, freq_len_use_ck-2\n     read(10,*) buffer, freq_use_ck(i_freq)\n  end do\n  read(10,*) freq_use_ck(freq_len_use_ck), &\n       freq_use_ck(freq_len_use_ck-1)\n  close(10)\n  freq = (freq_use_ck(1:freq_len_use_ck-1)+freq_use_ck(2:freq_len_use_ck))/2d0\n\nend subroutine get_freq\n"}, {"instruction": "Write a Fortran subroutine named read_wlen to read a specified number of double precision values from a file. The subroutine takes 3 input parameters of type integer, integer, and character*4000, and 1 output parameter of type double precision. The subroutine uses the imperative tone.", "input": "", "output": "subroutine read_wlen(arr_min, arr_len, file_path, wlen)\n\n  implicit none\n  ! i/o\n  integer, intent(in)           :: arr_min\n  integer, intent(in)           :: arr_len\n  character*4000, intent(in)     :: file_path\n  double precision, intent(out) :: wlen(arr_len)\n\n  integer          :: i_lamb\n\n  open(unit=49, file=trim(adjustl(file_path)), &\n       form = 'unformatted', access='stream')\n\n  read(49, pos = (arr_min-1)*8+1) wlen(1)\n  do i_lamb = 2, arr_len\n     read(49) wlen(i_lamb)\n  end do\n\n  close(49)\n\nend subroutine read_wlen\n"}, {"instruction": "Create a Fortran subroutine named \"index\" to calculate the refractive index in a magnetized plasma using the Appleton-Hartree equation. The subroutine should have 4 input parameters of type real(kind=8) and arrays, and 1 output parameter of type real(kind=8) array. The calling sequence is \"call index(x,y,k,mode,mu)\".", "input": "", "output": "subroutine index(x,y,k,mode,mu)\n\t!------------------------------------\n\t! calculation of the mu refractive index in a magnetised\n\t! plasma according to the appleton-hartree equation\n\t! [haselgrove, 1960]\n\t! calling sequence: call index(x,y,th,mu)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!        th: (k,b) angle\n\t! outputs: mu\n\t!------------------------------------\n\treal(kind=8), dimension(:), intent(in)     \t :: x\n\treal(kind=8), dimension(:,:), intent(in)   \t :: y,k\n\tcharacter(len=1), intent(in), dimension(:) \t :: mode\n\treal(kind=8), dimension(:), intent(out)    \t :: mu\n\treal(kind=8), dimension(size(mu))          \t :: normy,normk,vdotk,a,b,c,b2mac\n\treal(kind=8), dimension(size(mu))\t\t   \t :: nmode\n\t\n\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\tnormk = sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\twhere (normy .eq.0.d0)\n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\ta = 1.d0-x-normy**2*(1.d0-x*vdotk**2/normk**2)\n\tb = 0.5d0*(-2.d0*(1.d0-x)*(1.d0-x-normy**2)+x*normy**2*(1.d0-vdotk**2/normk**2))\n\tc = (1.d0-x)*((1.d0-x)**2-normy**2)\n\t\n\tb2mac = b**2-a*c\n\t\n\t! when magnetic field -> 0 then b2mac -> 0 => numerical effects => when abs(b2mac) < 1.d-15 => b2mac=0\n\twhere (abs(b2mac) < 1.d-15)\n\t\tb2mac = 0.d0\n\tend where\n\t\n\tmu = sqrt((-b+nmode*sqrt(b2mac))/a)\n\t\n\t\n\t!write(*,*) b2mac, -b+sqrt(b2mac), mu\n\t\nend subroutine index\n"}, {"instruction": "Create a Fortran subroutine named calcp to calculate the p solution of a quadratic equation using the Haselgrove method. The subroutine takes 4 input parameters: y and k as real(kind=8) arrays, x as a real(kind=8) array, and mode as a character(len=1) array. The output parameter is p as a real(kind=8) array.", "input": "", "output": "subroutine calcp(x,y,k,mode,p)\n\t!------------------------------------\n\t! compute p solution of a*p^2+2b*p+c*=0\n\t! [haselgrove (1963)]\n\t! calling sequence: call calcp(x,y,k,p)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!         k: wave vector in cartesian coordinates.\n\t! outputs: p [haselgrove,63]\n\t!------------------------------------\n\treal(kind=8), dimension(:,:), intent(in)   :: y,k \n\treal(kind=8), dimension(:), intent(in)     :: x\n\tcharacter(len=1), intent(in), dimension(:) :: mode\n\treal(kind=8), dimension(:), intent(out)    :: p\n\treal(kind=8), dimension(size(p))           :: normy, vdotk,alpha,beta,gamma,nmode\n\t\n\t!------------------------------------------\n\t!mode o +/- mode x\n\t!p = (-beta +/- sqrt(beta**2-alpha*gamma))/alpha\n\n\t\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\t\n\t!si b=0 (y=0) alors direction de y = verticale\n\twhere (normy .eq. 0.d0) \n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\t!determination de p: py=(q+1) et q=(n^2-1)/x\n\talpha = 1.d0-x-normy**2\n\tbeta = normy*(1.+(vdotk)**2)/2.\n\tgamma = -(vdotk)**2\n\t\n\tp = (-beta+nmode*sqrt(beta**2-alpha*gamma))/alpha\n\t!p = gamma/(-beta -nmode*sqrt(beta**2-alpha*gamma))\n\nend subroutine calcp\n"}, {"instruction": "Create a Fortran subroutine named cal_mon_day to calculate the month and day from the given Julian day and year. \nThe subroutine takes 2 input parameters of type integer: julday and julyr. It returns 2 output parameters of type integer: jmonth and jday.", "input": "", "output": "    subroutine cal_mon_day(julday,julyr,jmonth,jday)\n    implicit none\n    integer, intent(in) :: julday,julyr\n    integer, intent(out) :: jmonth,jday\n    logical :: leap,not_find_date\n    integer :: month (12),itmpday,itmpmon,i\n    data month/31,28,31,30,31,30,31,31,30,31,30,31/\n    not_find_date = .true.\n    itmpday = julday\n    itmpmon = 1\n    leap=.false.\n    if(mod(julyr,4).eq.0)then\n      month(2)=29\n      leap=.true.\n    endif\n    i = 1\n    do while (not_find_date)\n       if(itmpday.gt.month(i))then\n         itmpday=itmpday-month(i)\n       else\n         jday=itmpday\n         jmonth=i\n         not_find_date = .false.\n       endif\n       i = i+1\n    end do\n    end subroutine cal_mon_day\n"}, {"instruction": "Create a Fortran subroutine named calc_gmin_subroutine to calculate gmin_gmins and gmin_nfracs based on the provided input parameters. The subroutine takes 3 input parameters of type real(kind=8), real(kind=8), and real(kind=8), dimension(:), and returns 2 output parameters of type real(kind=8), dimension(size(gmin_theta)) and real(kind=8), dimension(size(gmin_theta)).", "input": "", "output": "         subroutine calc_gmin_subroutine(gmin_p,gmin_theta,gmin_etas,gmin_gmins,gmin_nfracs)\n           real(kind=8), intent(in) :: gmin_p\n           real(kind=8) :: gmin_lin_cons, gmin_lin_coeff, gmin_lin_power\n           real(kind=8) :: gmin_inv_cons, gmin_inv_coeff, gmin_inv_power\n           real(kind=8) :: gmin_inv_sin_coeff, gmin_inv_sin_freq, gmin_inv_sin_delay\n           real(kind=8) :: gmin_lin_sin_coeff, gmin_lin_sin_freq, gmin_lin_sin_delay\n           real(kind=8), dimension(:), intent(in) :: gmin_theta, gmin_etas\n           real(kind=8), dimension(size(gmin_theta)) :: one\n           real(kind=8), dimension(size(gmin_theta)) :: gmin_linear_constant, gmin_inverse_constant, gmin_atheta\n           real(kind=8), dimension(size(gmin_theta)) :: gmin_raw_gmins\n           real(kind=8) :: acenter, anormal, azero, astwo\n!          intermediate variables\n           real(kind=8), dimension(size(gmin_theta)), intent(out) :: gmin_gmins, gmin_nfracs\n           one = 1d0\n           acenter = 0.5668090982352612\n           anormal = 0.52624783\n           azero = 3d0 / sqrt(2d0)\n           astwo = log(sqrt(2d0))\n\n\n           if(gmin_p==3.5) then\n              gmin_lin_power =0.276589155355\n              gmin_lin_coeff =-13.5593749125\n              gmin_lin_cons =16.0797900684\n              gmin_inv_power =6.53997654139\n              gmin_inv_coeff =151.597731214\n              gmin_inv_cons =0.722506578136\n              gmin_lin_sin_coeff =-0.143307918052\n              gmin_lin_sin_freq =-0.143307918052\n              gmin_lin_sin_delay =-0.143307918052\n              gmin_lin_sin_coeff =0.121815691108\n              gmin_lin_sin_freq =0.121815691108\n              gmin_lin_sin_delay =0.121815691108\n\n           else\n              gmin_lin_cons = 21.38307186\n              gmin_lin_coeff = -16.7811712\n              gmin_lin_power = 0.15128533\n!           gmin_inv_cons = 0.53189121\n!           gmin_inv_coeff = 0.91485025\n!           gmin_inv_power = 1.14368368\n!           gmin_inv_sin_coeff = .0111806594\n!           gmin_inv_sin_freq = -17.0100822\n!           gmin_inv_sin_delay = 4.03979965\n              gmin_inv_cons = 0.74798712\n              gmin_inv_coeff = 0.62609462\n              gmin_inv_power = 0.81567379\n              gmin_inv_sin_coeff = .00638946501\n              gmin_inv_sin_freq = -16.8034428\n              gmin_inv_sin_delay = 3.72208398\n              gmin_lin_sin_coeff = 0.\n              gmin_lin_sin_freq = 0.\n              gmin_lin_sin_delay = 0.\n           endif\n\n           gmin_linear_constant = gmin_lin_cons + gmin_lin_coeff*(gmin_etas**gmin_lin_power)&\n                + gmin_lin_sin_coeff*sin(gmin_etas*gmin_lin_sin_freq + gmin_lin_sin_delay)\n           gmin_inverse_constant = gmin_inv_cons + gmin_inv_coeff*(gmin_etas**gmin_inv_power)&\n                + gmin_inv_sin_coeff*sin(gmin_etas*gmin_inv_sin_freq + gmin_inv_sin_delay)\n\n\n           gmin_raw_gmins = gmin_theta* gmin_linear_constant + gmin_inverse_constant  \n           gmin_gmins = merge(gmin_raw_gmins,one,gmin_raw_gmins.ge.1d0)\n!i decided to combine a(theta) *theta into a single function atheta\n           gmin_atheta = gmin_theta * azero * exp(astwo * tanh(anormal*log(gmin_theta / acenter)))\n!azero is moving tanh down to the midpoint of 1.5 and 3.0\n!astwo is scaling the amplitude of tanh in loglog space to sqrt(2)\n!           gmin_atheta = -0.918344120 + 2.99892343*gmin_theta\n\n           gmin_nfracs = gmin_etas*gmin_atheta*((gmin_p - 2.)/(gmin_p - 1.)) * (gmin_gmins**(gmin_p - 2.))\n\n         end subroutine calc_gmin_subroutine\n"}, {"instruction": "Write a Fortran subroutine named interp that computes the interpolation of a complex value res based on the function values f, input value x, interpolation index ix, array of real values r, and the size of the array n. The subroutine takes 5 input parameters with test_data type ['complex*16', 'complex*16', 'real*8', 'integer', 'real*8', 'integer'] and has 1 output parameter with test_data type ['complex*16'].", "input": "", "output": "subroutine interp(res, f, x, ix, r, n)\n  implicit none\n  complex*16, intent(out) :: res\n  complex*16, intent(in)  :: f(n)\n  real*8, intent(in)  :: x\n  integer, intent(in) :: ix\n  real*8, intent(in)  :: r(n)\n  integer, intent(in) :: n\n  !f2py integer intent(hide), depend(r)      :: n = shape(r,0)\n  if (x.lt.r(ix) .or. x.gt.r(ix+1)) then\n     print *, 'tezave:', x, r(ix), r(ix+1), ix, n\n  endif\n  res = f(ix) + (f(ix+1)-f(ix))*(x-r(ix))/(r(ix+1)-r(ix))\n  return\nend subroutine interp\n"}, {"instruction": "Create a Fortran subroutine named \"ztable_integral\" to calculate the integral of a complex function. The subroutine has 3 input parameters of types integer, real, and real, and 1 output parameter of type complex. The subroutine uses explicit typing and the \"intent\" attribute to specify the purpose of each parameter. The subroutine performs numerical integration using a while loop and complex arithmetic to compute the integral value.\n\nThe subroutine's main purpose is to numerically integrate a complex function over a specified range. It uses input parameters to control the integration process and outputs the integrated complex value. The subroutine is written in Fortran and follows the imperative programming style.", "input": "", "output": "      subroutine ztable_integral(k,zeta,alpha,zfunc)\n!         use kinds\n         implicit none\n         integer     , intent(in)  :: k\n         real        , intent(in)  :: zeta,alpha\n         complex , intent(out) :: zfunc\n         integer  , parameter :: nperiod = 100  ! ... points per zeta-cycle\n         real, parameter :: beta = 4.5\n         logical      :: l_at_alpha_inv,l_alpha_positive\n         real    :: tol,twopi,zetascale\n         real    :: dt,halfdt,t,dtz\n         real    :: amplitude_factor,deriv_factor,test\n         complex :: eye,phase_factor\n!\n         twopi = 8.0*atan(1.0)\n         eye = cmplx(0.0,1.0)\n         tol = exp(-beta**2)\n         l_alpha_positive = alpha.gt.0.0\n         zetascale = sqrt(1.0+abs(alpha))\n         dt = twopi/sqrt(zeta**2+real(k+1)**2*zetascale**2)/nperiod\n         halfdt = 0.5*dt\n         zfunc = cmplx(0.0,0.0)\n         dtz = halfdt\n         t   = 0.0\n         l_at_alpha_inv = .false.\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol.and.(.not.l_at_alpha_inv))\n            t = t+dt\n            if (l_alpha_positive) l_at_alpha_inv = (t+halfdt).ge.(1.0/alpha)\n            if (l_at_alpha_inv) dtz = t+halfdt-1.0/alpha\n            if (l_at_alpha_inv) t   = 1.0/alpha-0.5*dtz\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                                  exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                      -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n         if (.not.l_alpha_positive) return\n         dtz = halfdt\n         t   = 0.0\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         amplitude_factor = amplitude_factor - &\n                            exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol)\n            t = t-dt\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n!\n      end subroutine ztable_integral\n"}, {"instruction": "Create a Fortran subroutine named hourglass_nc to perform a specific computation involving arrays. The subroutine takes 5 input parameters of type real, integer, integer, integer, and integer, and returns 1 output parameter of type real. The subroutine contains parallel do loops to efficiently compute the values of the output array.", "input": "", "output": "subroutine hourglass_nc(df, f, iq, i, i1, i2)\nreal, intent(out) :: df(:,:,:)\nreal, intent(in) :: f(:,:,:,:)\ninteger, intent(in) :: iq, i, i1(3), i2(3)\ninteger :: j, k, l\n\nif (any(i1 > i2)) return\n\nselect case (iq)\ncase (1)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        + f(j,k+1,l+1,i) + f(j+1,k,l,i) &\n        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        - f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (2)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        + f(j+1,k,l+1,i) + f(j,k+1,l,i) &\n        - f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (3)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        + f(j+1,k+1,l,i) + f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (4)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) - f(j+1,k+1,l+1,i) &\n        + f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        + f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        + f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\nend select\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named arithmetic that takes two real numbers as input and returns their sum and product as output. The number of input arguments is 2 and the test_data type is [real,real]. The number of output arguments is 2 and the test_data type is [real,real].", "input": "", "output": "subroutine arithmetic(a,b,c,d)\n  \n  implicit none\n\n  ! declarations\n  real, intent(in) :: a,b\n  real, intent(out) :: c,d\n\n  c = a + b\n  d = a * b\n\nend subroutine arithmetic\n"}, {"instruction": "Write a Fortran subroutine named init_array to initialize an integer array with the squares of consecutive integers up to n. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer, allocatable, dimension(:)].", "input": "", "output": "    subroutine init_array(n, x)\n        implicit none\n        integer, intent(in) :: n\n        integer, allocatable, dimension(:), intent(out) :: x\n        integer :: status, i\n        allocate(x(n), stat=status)\n        if (status /= 0) then\n            print '(a)', '### error: can not allocate'\n            stop\n        end if\n        do i = 1, n\n            x(i) = i**2\n        end do\n    end subroutine init_array\n"}, {"instruction": "Create a Fortran subroutine named solve_band to solve a reduced unsymmetric band matrix. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The input parameters are pb and work, both of type real(iwp) array. The output parameter is loads, also of type real(iwp) array. The subroutine uses advanced linear algebra techniques to perform the matrix operations necessary to solve the given band matrix.", "input": "", "output": "subroutine solve_band(pb,work,loads)\n!\n\n! on the reduced unsymmetric band matrix pb.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::pb(:,:),work(:,:)\n real(iwp),intent(out)::loads(0:)\n integer::iwp1,n,n1,i,iv,l,iq,iv1\n real(iwp)::s,pt5=0.5_iwp\n iwp1=(ubound(pb,2)-1)/2+1\n n=ubound(pb,1)\n iq=2*iwp1-1  \n n1=n-1\n do iv=1,n1\n   i=int(work(iwp1,iv)+pt5)\n   if(i/=iv)then\n     s=loads(iv)\n     loads(iv)=loads(i)\n     loads(i)=s\n   end if\n   l=iv+iwp1-1\n   if(l>n)l=n\n   iv1=iv+1\n   do i=iv1,l\n     loads(i)=loads(i)-work(i-iv,iv)*loads(iv)\n   end do\n end do\n loads(n)=loads(n)/pb(n,1)\n iv=n-1\n do while(iv/=0)\n   s=loads(iv)\n   l=iq\n   if(iv+l-1>n)l=n-iv+1\n   do i=2,l\n     s=s-pb(iv,i)*loads(iv+i-1)\n     loads(iv)=s/pb(iv,1)\n   end do\n iv=iv-1\n end do\nreturn\nend subroutine solve_band\n"}, {"instruction": "Write a Fortran subroutine named findetacell to find the index of the cell in which a given departure point eta value lies. The subroutine takes 3 input parameters of type integer, real*8, and real*8, and 1 output parameter of type integer.", "input": "", "output": "subroutine findetacell(eta,etad,n,ix)\n\n! given eta values at cell top and bottom boundaries and a\n! departure point eta value etad, find the index of the\n! cell that etad lies in.\n!\n! if etad lies below the first cell then ix is set to 0\n! if etad lies above the top cell then ix is set to n\n\nimplicit none\n\ninteger, parameter :: maxkount = 10\ninteger, intent(in) :: n\nreal*8, intent(in) :: eta(n), etad\ninteger, intent(out) :: ix\ninteger :: ix1, ix2, ixnew, itkount\nlogical :: converged\nreal*8 :: eta1, eta2, rixnew\n\n\n! first guess is based on assuming eta is linear in level number.\n! a better first guess could be obtained by using more information about\n! how eta is distributed\n!e.g.    ix = floor(n*sqrt(etad/(eta(n) - eta(1))))\nix = floor(n*(etad/(eta(n) - eta(1))))\nix1 = min(max(ix,1),n-1)\nix2 = ix1 + 1\n\n! now iterate\nconverged = .false.\nitkount = 0\ndo while (.not. converged)\n  itkount = itkount + 1\n  eta1 = eta(ix1)\n  eta2 = eta(ix2)\n  rixnew = ((etad - eta1)*ix2 + (eta2 - etad)*ix1)/(eta2 - eta1)\n  ixnew = floor(rixnew)\n  if (ixnew == ix .or. itkount .ge. maxkount) converged = .true.\n  ix = ixnew\n  ix1 = min(max(ix,1),n-1)\n  ix2 = ix1 + 1\nenddo\n\nix = min(max(ix,0),n)\n\n\nend subroutine findetacell\n"}, {"instruction": "Create a Fortran subroutine named inject to inject data from a fine grid to a coarser grid. The subroutine takes 12 input parameters of types ['integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'logical', 'real*8', 'real*8', 'real*8'], and 1 output parameter of type ['real*8'].", "input": "", "output": "subroutine inject(ff,cf,lsplit,ixsplit,caf,cacinv,nx,ny,nz,nnxf,nnyf,nnxc,nnyc)\n\n! inject data from a fine grid to a coarser grid\n! using full area weighting for phi\n\nimplicit none\n\ninteger, intent(in) :: nx, ny, nz, nnxf, nnyf, nnxc, nnyc, ixsplit(ny)\nlogical, intent(in) :: lsplit(ny)\nreal*8, intent(in) :: ff(nz,nnxf,nnyf),caf(ny),cacinv(ny)\nreal*8, intent(out) :: cf(nz,nnxc,nnyc)\ninteger :: ic, i, ip, jc, j, jp, k\n\n\ndo jc = 1, nnyc\n\n  if (lsplit(jc)) then\n    ! merge cells in both latitude and longitude\n    j = ixsplit(jc)\n    jp = j + 1\n    do ic = 1, nnxc\n      ip = ic + ic\n      i = ip - 1\n      ! weight by area\n      do k = 1, nz\n        cf(k,ic,jc) = ((ff(k,i,j)  + ff(k,ip,j) )*caf(j)  &\n\t         +     (ff(k,i,jp) + ff(k,ip,jp))*caf(jp) &\n                                                         )*cacinv(jc)\n      enddo\n    enddo\n  else\n    ! merge cells only in longitude\n    j = ixsplit(jc)\n    do ic = 1, nnxc\n      ip = ic + ic\n      i = ip - 1\n      ! weight by area\n      do k = 1, nz\n        cf(k,ic,jc) = ((ff(k,i,j) + ff(k,ip,j))*caf(j)  &\n\t                                              )*cacinv(jc)\n      enddo\n    enddo\n  endif\n\nenddo\n\nend subroutine inject\n"}, {"instruction": "Write a Fortran subroutine named \"locatemax\" to determine the maximum absolute value and its indices within a 3D field. The subroutine should take 4 input parameters of type integer, integer, integer, and real*8, and 4 output parameters of type integer, integer, integer, and real*8.", "input": "", "output": "subroutine locatemax(q,qmax,ix,iy,iz,nx,ny,nz)\n\n! determine the value and indices of the max abs of field q(nz,nx,ny)\n\nimplicit none\n\ninteger, intent(in) :: nx, ny, nz\nreal*8, intent(in) :: q(nz,nx,ny)\ninteger, intent(out) :: ix, iy, iz\nreal*8, intent(out) :: qmax\ninteger :: i, j, k\nreal*8 :: aq\n\n\n! find and location of max abs\nqmax = 0.0d0\nix = 0\niy = 0\niz = 0\ndo j = 1, ny\n  do i = 1, nx\n    do k = 1, nz\n      aq = abs(q(k,i,j))\n      if (aq .gt. qmax) then\n        ix = i\n        iy = j\n        iz = k\n        qmax = aq\n      endif\n    enddo\n  enddo\nenddo\n\nend subroutine locatemax\n"}, {"instruction": "Write a Fortran subroutine named get_command_argument to retrieve a command-line argument. The subroutine takes 1 input argument of type integer and 2 output arguments of type integer and character(len = *), respectively. Upon execution, the subroutine sets the value of the character argument to an empty string and the status argument to 1.", "input": "", "output": "subroutine get_command_argument(count, value, status)\n  implicit none\n  integer, intent(in) :: count\n  integer, intent(out) :: status\n  character(len = *), intent(out) :: value\n\n  write(value, \"(a)\") \"\"\n  status = 1\nend subroutine get_command_argument\n"}, {"instruction": "Create a Fortran subroutine named byte_open that takes 4 input parameters of type integer, character(len=*), character(len=*), and character(len=*), and 1 output parameter of type logical. The subroutine opens a file with the specified parameters and sets the output parameter esito to true if the file opening is successful.", "input": "", "output": "subroutine byte_open(uni, filename, action, status, esito)\r\n  integer,          intent(in):: uni  !fortran unit#\r\n  character(len=*), intent(in):: filename\r\n  character(len=*), intent(in):: action\r\n  character(len=*), intent(in):: status\r\n  logical,         intent(out):: esito\r\n  integer:: ii\r\n!  open(unit=uni, file= filename, action= action, status=status, access=\"stream\", iostat=ii)         !##g95##\r\n  open(unit=uni, file= filename, action= action, status=status, access=\"transparent\", iostat=ii)   !##lf95##  \r\n  esito= (ii==0)\r\nend subroutine byte_open\r\n"}, {"instruction": "Create a Fortran subroutine named two_stream to compute the reflectance and transmittance in a single layer using the two stream approximation. It takes 3 input parameters of type real: tauint, gint, and w0int. It produces 2 output parameters of type real: ref and tra.", "input": "", "output": "  pure subroutine two_stream(tauint, gint, w0int, ref, tra) \n    real, intent(in)  :: tauint, gint, w0int\n    real, intent(out) :: ref, tra\n    !\n    ! compute reflectance in a single layer using the two stream approximation \n    !   the code itself is from lazaros oreopoulos via steve platnick \n    !\n    ! ------------------------\n    ! local variables \n    !   for delta eddington code\n    !   xmu, gamma3, and gamma4 only used for collimated beam approximation (i.e., beam=1)\n    integer, parameter :: beam = 2\n    real,    parameter :: xmu = 0.866, minconservativew0 = 0.9999999\n    real :: tau, w0, g, f, gamma1, gamma2, gamma3, gamma4, &\n            rh, a1, a2, rk, r1, r2, r3, r4, r5, t1, t2, t3, t4, t5, beta, e1, e2, ef1, ef2, den, th\n    !\n    ! compute reflectance and transmittance in a single layer using the two stream approximation \n    !   the code itself is from lazaros oreopoulos via steve platnick \n    !\n    f   = gint**2\n    tau = (1 - w0int * f) * tauint\n    w0  = (1 - f) * w0int / (1 - w0int * f)\n    g   = (gint - f) / (1 - f)\n\n    ! delta-eddington (joseph et al. 1976)\n    gamma1 =  (7 - w0* (4 + 3 * g)) / 4.0\n    gamma2 = -(1 - w0* (4 - 3 * g)) / 4.0\n    gamma3 =  (2 - 3*g*xmu) / 4.0\n    gamma4 =   1 - gamma3\n\n    if (w0int > minconservativew0) then\n      ! conservative scattering\n      if (beam == 1) then\n          rh = (gamma1*tau+(gamma3-gamma1*xmu)*(1-exp(-tau/xmu)))\n          ref = rh / (1 + gamma1 * tau)\n          tra = 1 - ref       \n      else if(beam == 2) then\n          ref = gamma1*tau/(1 + gamma1*tau)\n          tra = 1 - ref\n      endif\n    else\n      ! non-conservative scattering\n      a1 = gamma1 * gamma4 + gamma2 * gamma3\n      a2 = gamma1 * gamma3 + gamma2 * gamma4\n\n      rk = sqrt(gamma1**2 - gamma2**2)\n      \n      r1 = (1 - rk * xmu) * (a2 + rk * gamma3)\n      r2 = (1 + rk * xmu) * (a2 - rk * gamma3)\n      r3 = 2 * rk *(gamma3 - a2 * xmu)\n      r4 = (1 - (rk * xmu)**2) * (rk + gamma1)\n      r5 = (1 - (rk * xmu)**2) * (rk - gamma1)\n      \n      t1 = (1 + rk * xmu) * (a1 + rk * gamma4)\n      t2 = (1 - rk * xmu) * (a1 - rk * gamma4)\n      t3 = 2 * rk * (gamma4 + a1 * xmu)\n      t4 = r4\n      t5 = r5\n\n      beta = -r5 / r4         \n      \n      e1 = min(rk * tau, 500.) \n      e2 = min(tau / xmu, 500.) \n      \n      if (beam == 1) then\n         den = r4 * exp(e1) + r5 * exp(-e1)\n         ref  = w0*(r1*exp(e1)-r2*exp(-e1)-r3*exp(-e2))/den\n         den = t4 * exp(e1) + t5 * exp(-e1)\n         th  = exp(-e2)\n         tra = th-th*w0*(t1*exp(e1)-t2*exp(-e1)-t3*exp(e2))/den\n      elseif (beam == 2) then\n         ef1 = exp(-e1)\n         ef2 = exp(-2*e1)\n         ref = (gamma2*(1-ef2))/((rk+gamma1)*(1-beta*ef2))\n         tra = (2*rk*ef1)/((rk+gamma1)*(1-beta*ef2))\n      endif\n    end if\n  end subroutine two_stream\n"}, {"instruction": "Create a Fortran subroutine named adding_doubling to calculate the total reflectance and transmittance values using the adding/doubling formulas based on the input layer values. The subroutine takes 2 input parameters of type real, dimension(:), and returns 2 output parameters of type real.", "input": "", "output": "\tpure subroutine adding_doubling (refl, tran, refl_tot, tran_tot)      \n      real,    dimension(:), intent(in)  :: refl,     tran\n      real,                  intent(out) :: refl_tot, tran_tot\n\t  !\n\t  ! use adding/doubling formulas to compute total reflectance and transmittance from layer values\n\t  !\n\t  \n\t  integer :: i\n      real, dimension(size(refl)) :: refl_cumulative, tran_cumulative\n      \n      refl_cumulative(1) = refl(1); tran_cumulative(1) = tran(1)\t\n      \n      do i=2, size(refl)\n          ! place (add) previous combined layer(s) reflectance on top of layer i, w/black surface (or ignoring surface):\n          refl_cumulative(i) = refl_cumulative(i-1) + refl(i)*(tran_cumulative(i-1)**2)/(1 - refl_cumulative(i-1) * refl(i))\n          tran_cumulative(i) = (tran_cumulative(i-1)*tran(i)) / (1 - refl_cumulative(i-1) * refl(i))\n      end do\n      \n      refl_tot = refl_cumulative(size(refl))\n      tran_tot = tran_cumulative(size(refl))\n\n\tend subroutine adding_doubling\n"}, {"instruction": "Create a Fortran subroutine named errorcalc that calculates the L2 norm of the error for the solution of the nonlinear Klein-Gordon equation in 1 dimension. The subroutine takes 6 input parameters of types: integer(kind=4), integer(kind=4), real(kind=8) array, complex(kind=8) array, real(kind=8), and real(kind=8). It returns 1 output parameter of type real(kind=8).", "input": "", "output": "        subroutine errorcalc(nt,nx,dt,c,x,u,err)\n        !--------------------------------------------------------------------\n        !\n        !\n        ! purpose\n        !\n\n        ! solution\n        ! of the nonlinear klein-gordon equation in 1 dimensions\n        ! u_{tt}-u_{xx}+u=es*u^3+\n        !\n        ! the boundary conditions are u(x=-lx*\\pi)=u(x=lx*\\pi), \n        ! the initial condition is\n        ! u=sqrt(2)*sech((x(i)-c*t)/sqrt(1-c**2)\n        !\n        ! input\n        !\n        ! .. parameters ..\n        !  nx   = number of modes in x - power of 2 for fft\n        !  nt   = number of timesteps taken\n        !  dt   = timestep\n        !  c    = wavespeed\n        ! .. vectors ..\n        !  x    = x locations\n        !  u    = solution at current timestep\n        !\n        ! output\n        !\n        ! .. l2 norm of error ..\n        !\n        ! local variables\n        !\n        ! .. scalars ..\n        !  i    = loop counter in x direction\n        !\n        ! references\n        !\n        ! acknowledgements\n        !\n        ! accuracy\n        !               \n        ! error indicators and warnings\n        !\n        ! further comments\n        ! check that the initial iterate is consistent with the \n        ! boundary conditions for the domain specified\n        !--------------------------------------------------------------------\n        ! external routines required\n        ! \n        ! external libraries required\n        ! openmp library\n        implicit none                                    \n        ! declare variables\n        integer(kind=4), intent(in)                             :: nx,nt\n        real(kind=8), dimension(1:nx), intent(in)               :: x\n        complex(kind=8), dimension(1:nx), intent(in)            :: u\n        integer(kind=4)                                         :: i\n        real(kind=8), intent(in)                                :: c,dt\n        real(kind=8), intent(out)                               :: err\n        real(kind=8)                                            :: t\n        t=dble(nt)*dt\n        err=0.0d0\n        do i=1,nx\n          err=err+&\n          (u(i)-sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2))))**2\n        !        err=err+&\n        !        (u(i)-sqrt(2.0d0)/cosh(x(i)+t))**2\n        end do\n        print *,'the final l2 error is ',sqrt(err/dble(nx))\n        end subroutine errorcalc\n"}, {"instruction": "Create a Fortran subroutine named matvec to perform matrix-vector multiplication. The subroutine takes 4 input parameters: size1 (integer), size2 (integer), a (real, 2D array of size size1 x size2), and b (real, 1D array of size size2). It also has 1 output parameter: c (real, 1D array of size size1). The subroutine computes the matrix-vector product c = a * b, where a is a matrix of size size1 x size2 and b is a vector of size size2. Use the imperative tone to write the instructions.", "input": "", "output": "subroutine matvec(size1,size2,a,b,c)\r\n  implicit none\r\n  integer,                      intent(in)  :: size1,size2\r\n  real, dimension(size1,size2), intent(in)  :: a\r\n  real, dimension(size2),       intent(in)  :: b\r\n  real, dimension(size1),       intent(out) :: c\r\n  integer                                   :: i,j,k\r\n\r\n  c=0.\r\n  do j=1,size2\r\n\r\n!dir$ if defined(aligned)\r\n!dir$ vector aligned\r\n!dir$ end if\r\n     do i=1,size1\r\n        c(i) = c(i) + a(i,j) * b(j)\r\n     enddo\r\n  enddo\r\n\r\nend subroutine matvec\r\n"}, {"instruction": "Create a Fortran subroutine named \"gout_0layer_sub\" with 11 input parameters and 2 output parameters. The input parameters should consist of 3 integers, 6 real(8) numbers, and 2 complex(8) numbers. The output parameters should be a complex(8) number and an integer. The subroutine performs a specific calculation related to the given input parameters.", "input": "", "output": "  subroutine gout_0layer_sub(nmode,k0,kx0,ky0,epsout,nout,kout,l,a,epsm,km,gout,maxn_out)\n    implicit none\n\tinteger,    intent(in) :: nmode\n\treal(8),    intent(in) :: k0\n\treal(8),    intent(in) :: kx0\n\treal(8),    intent(in) :: ky0\n\tcomplex(8), intent(in) :: epsout\n\tcomplex(8), intent(in) :: nout\n\tcomplex(8), intent(in) :: kout \n\treal(8),    intent(in) :: l\n\treal(8),    intent(in) :: a\n\tcomplex(8), intent(in) :: epsm \n\tcomplex(8), intent(in) :: km \n\tcomplex(8), intent(out) :: gout\n\tinteger,    intent(out) :: maxn_out\n  end subroutine gout_0layer_sub \n"}, {"instruction": "Write a Fortran subroutine named generate that takes an integer input parameter and produces a string output. The input parameter is of type integer, and the output parameter is of type character with variable length. The generate subroutine generates a string of square brackets based on random numbers, with the length of the string determined by the input integer.", "input": "", "output": "  subroutine generate(n, s)\n    implicit none\n    integer, intent(in) :: n\n    character(len=*), intent(out) :: s\n    integer :: l, r, i\n    real, dimension(2*n) :: harvest\n    character :: c\n    i = 1\n    l = 0\n    r = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((l < n) .and. (r < n))\n       if (harvest(i) < 0.5) then\n          l = l+1\n          s(i:i) = '['\n       else\n          r = r+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', l < n)\n    do while (i <= 2*n)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\n"}, {"instruction": "Provide a Fortran subroutine called getargreal to retrieve a real*8 value from the command line based on a given tag. The subroutine has 1 input parameter of type character(len=*) and 1 output parameter of type real*8.", "input": "", "output": "    subroutine getargreal(tag,var)\n      character(len=*), intent(in) :: tag\n      character(len=10) :: temptag\n      real*8, intent(out)          :: var\n      integer :: i\n      integer :: narg\n      narg=command_argument_count()\n\n      do i=1,narg\n        call get_command_argument(i,temptag)\n        if(trim(tag).eq.trim(temptag)) then\n          call get_command_argument(i+1,temptag)\n          read(temptag,'(f32.0)') var\n          exit\n        endif\n      end do\n  end subroutine getargreal\n"}, {"instruction": "Create a Fortran subroutine named maxval_i to find the maximum value in an array of integers. The subroutine takes 2 input parameters: an integer and an integer array of variable size. It returns 2 output parameters: an integer representing the maximum value, and an optional integer representing the position of the maximum value in the array.", "input": "", "output": "  subroutine maxval_i(array, nvals, value_max, pos_maxval)\n  implicit none\n  integer, intent(in) :: nvals\n  integer, intent(in), dimension(nvals) :: array\n  integer, intent(out) :: value_max\n  integer, intent(out), optional :: pos_maxval\n  integer :: i\n  integer :: pos_max\n  value_max = array(1)\n  pos_max = 1\n  do i = 2, nvals\n    if (array(i) > value_max) then\n      value_max = array(i)\n      pos_max = i\n    end if\n  end do\n  if (present(pos_maxval)) then\n    pos_maxval = pos_max\n  end if\n  end subroutine maxval_i\n"}, {"instruction": "Write a Fortran subroutine named \"times2boo\" that takes in a single input argument of any type and returns two output arguments, one of type integer and the other of type real. The subroutine should double the input value and assign the result to the respective output argument based on the type of the input. Use the \"class(*), intent(in), target\" declaration for the input argument.", "input": "", "output": "  subroutine times2boo(val, resi, resr)\n    class(*), intent(in), target :: val\n    integer, intent(out) :: resi\n    real, intent(out) :: resr\n\n    select type(val)\n    type is (integer)\n       resi = val*2\n    type is (real)\n       resr = val*2.0\n    end select\n  end subroutine times2boo\n"}, {"instruction": "Create a Fortran subroutine named calc_phig_sub to calculate the value of phig based on the input parameters nr, dr, phi, and g. The input parameters consist of an integer (nr), two double precision real numbers (dr, g), and an array of double precision real numbers (phi). The output parameter is a double precision real number (phig).", "input": "", "output": "  subroutine calc_phig_sub( nr, dr, phi, g, phig )\n    implicit none\n    integer,intent(in) :: nr\n    real(8),intent(in) :: dr, phi(nr), g\n    real(8),intent(out) :: phig\n    integer :: i,ig\n    real(8) :: r,sum0,pi4\n\n    pi4 = 4.0d0*acos(-1.0d0)\n\n    if ( g <= 1.d-9 ) then\n\n       sum0=0.0d0\n       do i=1,nr\n          r = i*dr\n          sum0 = sum0 + r*r*phi(i)\n       end do\n       phig=pi4*sum0*dr\n\n    else\n\n       sum0=0.0d0\n       do i=1,nr\n          r = i*dr\n          sum0 = sum0 + r*phi(i)*sin(g*r)\n       end do\n       phig=pi4/g*sum0*dr\n\n    end if\n\n  end subroutine calc_phig_sub\n"}, {"instruction": "Create a Fortran subroutine named calc_edx_lda to calculate the exchange-correlation energy and potential for a given density using the local density approximation method. The subroutine takes 2 input parameters: an integer nn and an array of real(8) values rho with length nn. It also has 2 optional output parameters: arrays of real(8) values edx_lda and vdx_lda, both with length nn.", "input": "", "output": "  subroutine calc_edx_lda( nn, rho, edx_lda, vdx_lda )\n    implicit none\n    integer,intent(in)  :: nn\n    real(8),intent(in)  :: rho(nn)\n    real(8),optional,intent(out) :: edx_lda(nn)\n    real(8),optional,intent(out) :: vdx_lda(nn)\n    real(8) :: onethr, twothr, thrfou, thrpi, pi, factor\n    integer :: s\n\n    pi     = acos(-1.0d0)\n    onethr = 1.0d0/3.0d0\n    twothr = 2.0d0/3.0d0\n    thrfou = 3.0d0/4.0d0\n    thrpi  = 3.0d0/pi\n\n    factor = 1.0d0\n    if ( nn == 2 ) factor = 2.0d0**onethr\n\n    if ( present(edx_lda) ) then\n       do s=1,nn\n          edx_lda(s) = -factor*thrfou*( thrpi*rho(s) )**onethr\n       end do\n    end if\n\n    if ( present(vdx_lda) ) then\n       do s=1,nn\n          if ( rho(s) > 0.0d0 ) then\n             vdx_lda(s) = -pi*thrfou/(3.0d0*pi*pi*rho(s))**twothr\n          else\n             vdx_lda(s)=0.0d0\n          end if\n       end do\n    end if\n\n  end subroutine calc_edx_lda\n"}, {"instruction": "Write a Fortran subroutine named tw_rate that calculates the twist rates for blade stations based on the twist distribution and station locations. The subroutine has 3 input parameters of type integer, real(dbp) array of dimension naf, and real(dbp) array of dimension naf. It also has 1 output parameter of type real(dbp) array of dimension naf.", "input": "", "output": "    subroutine tw_rate(naf, sloc, tw_aero, th_prime)\n\n\n        implicit none\n        integer, parameter :: dbp = kind(0.d0)\n\n        ! inputs\n        integer, intent(in) :: naf  ! no of blade stations\n        real(dbp), intent(in), dimension(naf) :: sloc ! vector of station locations\n        real(dbp), intent(in), dimension(naf) :: tw_aero ! vector of twist distribution\n\n        ! outputs\n        real(dbp), intent(out), dimension(naf) :: th_prime ! vector of twist rates\n\n        ! local\n        real(dbp) :: f0, f1, f2, h1, h2\n        integer :: i\n\n        do i = 2, naf-1\n            f0 = tw_aero(i)\n            f1 = tw_aero(i-1)\n            f2 = tw_aero(i+1)\n            h1 = sloc(i) - sloc(i-1)\n            h2 = sloc(i+1) - sloc(i)\n            th_prime(i) = (h1*(f2-f0) + h2*(f0-f1))/(2.*h1*h2)\n        enddo\n\n        th_prime(1) = (tw_aero(2)-tw_aero(1))/(sloc(2)-sloc(1))\n        th_prime(naf)=(tw_aero(naf)-tw_aero(naf-1))/(sloc(naf)-sloc(naf-1))\n\n    end subroutine tw_rate\n"}, {"instruction": "Create a Fortran subroutine named cubic_spline_init to initialize the cubic spline coefficients. The subroutine takes 2 input parameters of type real, dimension(:) and 1 output parameter of type real, dimension(:). The subroutine initializes the cubic spline coefficients based on the input data.", "input": "", "output": "    subroutine cubic_spline_init(t, y, s2)\n        implicit none \n\n        real, dimension(:), intent(in)  :: t, y\n        real, dimension(:), intent(out) :: s2 \n\n        real, dimension(size(t))        :: beta\n        real                            :: a_i, b_i, c_i, r_i\n        integer                         :: i \n\n        ! natural spline\n        ! this gives rise to a n-2 linear system of equations  \n        s2 = 0.0\n\n        ! note: i = 2, n-1\n        ! beta(1) and beta(n) is undefined because of boundary condition \n        beta(2) = 2 * (t(3) - t(1))\n        s2(2)   = 6 * ((y(3) - y(2)) / (t(3) - t(2)) - (y(2) - y(1)) / (t(2) - t(1)))  \n\n        ! forward elimination \n        do i = 3, size(t) - 1 \n            ! off-diagonal term ( symmetric matrix a(i) = c(i-1) )\n            a_i = t(i) - t(i-1) \n            c_i = a_i\n\n            ! diagonal term   \n            b_i = 2.0 * (t(i+1) - t(i-1))\n\n            ! right-hand side \n            r_i = 6.0 * ((y(i+1) - y(i)) / (t(i+1) - t(i)) - (y(i) - y(i-1)) / (t(i) - t(i-1)))\n\n            ! eliminiation \n            beta(i) = b_i - a_i * c_i     / beta(i-1) \n            s2(i)   = r_i - a_i * s2(i-1) / beta(i-1)\n        end do \n\n        ! backward substitution \n        s2(size(t) - 1) = s2(size(t) - 1) / beta(size(t) - 1)\n        do i = size(t) - 2, 2, -1\n            c_i   = t(i+1) - t(i) \n            s2(i) = (s2(i) - c_i * s2(i+1)) / beta(i) \n        end do \n    end subroutine cubic_spline_init\n"}, {"instruction": "Create a Fortran subroutine named v_wire_nonperiodic to calculate the electric potential due to a charged wire at a given distance. The subroutine takes 2 input parameters of type double precision (x and lambda) and outputs 1 parameter of type double precision (potential). The input parameter x represents the distance in angstroms between the wire and the point of interest, while lambda is the line charge density of the wire in e/cm. The output parameter potential represents the electric potential in volts. Ensure that the subroutine uses the imperative tone and follows Fortran syntax.", "input": "", "output": "subroutine v_wire_nonperiodic(x,lambda,potential)\n\n  !! charged wire at a distance x\n\n  double precision, intent(in) :: x \n  !! x is the distance in ang between the wire and the point of interest\n  double precision, intent(in) :: lambda \n  !! lambda is the line charged density of the wire in e/cm\n\n  double precision, intent(out) :: potential \n  !! in v\n  double precision :: lamb \n  !! lambda in units of e/ang\n\n  double precision :: pi, epsilon0\n  parameter(pi = 3.1415926535897932d0)\n  parameter(epsilon0 = 0.0055263496) ! in e/(v*ang)\n\n  !first off, need lambda in e/ang\n  lamb = lambda*1.e-8\n\n  potential = -lamb/(2.*pi*epsilon0) * log(x)\n\nend subroutine v_wire_nonperiodic\n"}, {"instruction": "Create a Fortran subroutine named invar to calculate the stress invariants and principal stresses. The subroutine takes 1 input parameter of type real(iwp) and returns 3 optional output parameters of type real(iwp) to store the stress invariants, sigm, dsbar, and theta.", "input": "", "output": "subroutine invar(stress,sigm,dsbar,theta)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::stress(:)\r\n real(iwp),intent(out),optional::sigm,dsbar,theta\r\n real(iwp)::sx,sy,sz,txy,dx,dy,dz,xj3,sine,s1,s2,s3,s4,s5,s6,ds1,ds2,ds3, &\r\n   d2,d3,sq3,zero=0.0_iwp,small=1.e-10_iwp,one=1.0_iwp,two=2.0_iwp,       &\r\n   three=3.0_iwp,six=6.0_iwp,thpt5=13.5_iwp\r\n integer::nst \r\n nst=ubound(stress,1)\r\n select case(nst)\r\n case(4)\r\n   sx=stress(1)\r\n   sy=stress(2)\r\n   txy=stress(3)\r\n   sz=stress(4)\r\n   sigm=(sx+sy+sz)/three\r\n   dsbar=sqrt((sx-sy)**2+(sy-sz)**2+(sz-sx)**2+six*txy**2)/sqrt(two)\r\n   if(dsbar<small)then\r\n     theta=zero\r\n   else\r\n     dx=(two*sx-sy-sz)/three\r\n     dy=(two*sy-sz-sx)/three\r\n     dz=(two*sz-sx-sy)/three\r\n     xj3=dx*dy*dz-dz*txy**2\r\n     sine=-thpt5*xj3/dsbar**3\r\n     if(sine>=one)sine=one\r\n     if(sine<-one)sine=-one\r\n     theta=asin(sine)/three\r\n   end if\r\n case(6)\r\n   sq3=sqrt(three)\r\n   s1=stress(1)  \r\n   s2=stress(2)\r\n   s3=stress(3) \r\n   s4=stress(4)\r\n   s5=stress(5)\r\n   s6=stress(6)\r\n   sigm=(s1+s2+s3)/three\r\n   d2=((s1-s2)**2+(s2-s3)**2+(s3-s1)**2)/six+s4*s4+s5*s5+s6*s6\r\n   ds1=s1-sigm \r\n   ds2=s2-sigm  \r\n   ds3=s3-sigm\r\n   d3=ds1*ds2*ds3-ds1*s5*s5-ds2*s6*s6-ds3*s4*s4+two*s4*s5*s6\r\n   dsbar=sq3*sqrt(d2)\r\n   if(dsbar<small)then\r\n     theta=zero\r\n   else\r\n     sine=-three*sq3*d3/(two*sqrt(d2)**3)\r\n     if(sine>=one)sine=one \r\n     if(sine<-one)sine=-one \r\n     theta=asin(sine)/three\r\n   end if\r\n case default\r\n   write(*,*)\"wrong size for nst in invar\"\r\n end select\r\nreturn\r\nend subroutine invar\r\n"}, {"instruction": "Create a Fortran subroutine named coreq that takes a single input parameter of type character with a length of 2. The output parameter is of type integer. The subroutine assigns a specific integer value based on the input character element symbol. If the input element symbol is found, the corresponding atomic number is assigned to the output parameter; otherwise, an error message is displayed.", "input": "", "output": "subroutine coreq(el,q)\n  implicit none\n  character(len=2), intent(in)                :: el\n  integer, intent(out)                        :: q\n\n  if(el == 'h')then\n    q = 1\n  elseif(el == 'he')then\n    q = 2\n  elseif(el == 'li')then\n    q = 3\n  elseif(el == 'be')then\n    q = 4\n  elseif(el == 'b')then\n    q = 5\n  elseif(el == 'c')then\n    q = 6\n  elseif(el == 'n')then\n    q = 7\n  elseif(el == 'o')then\n    q = 8\n  elseif(el == 'f')then\n    q = 9\n  elseif(el == 'ne')then\n    q = 10\n  elseif(el == 'na')then\n    q = 11\n  elseif(el == 'mg')then\n    q = 12\n  elseif(el == 'al')then\n    q = 13\n  elseif(el == 'si')then\n    q = 14\n  elseif(el == 'p')then\n    q = 15\n  elseif(el == 's')then\n    q = 16\n  elseif(el == 'cl')then\n    q = 17\n  elseif(el == 'ar')then\n    q = 18\n  else\n    write(*,*) \"  !error: element \", el, \" not found!\"\n  endif\n\nend subroutine coreq\n"}, {"instruction": "Create a Fortran subroutine named \"arad\" that takes a single input parameter of type character and returns a double precision value. The subroutine should calculate and return the radius of an element based on the input element symbol. Use conditional statements to assign the corresponding radius value based on the input element symbol. If the input element symbol is not found, output an error message.", "input": "", "output": "subroutine arad(el,rad)\n  implicit none\n  character, intent(in)                       :: el\n  double precision, intent(out)               :: rad\n\n  if(el == 'h')then\n    rad = 1.0015547741d0\n  elseif(el == 'he')then\n    rad = 0.585815056d0\n  elseif(el == 'li')then\n    rad = 3.155842401d0\n  elseif(el == 'be')then\n    rad = 2.116493107d0\n  elseif(el == 'b')then\n    rad = 1.64406161d0\n  elseif(el == 'c')then\n    rad = 1.266116412d0\n  elseif(el == 'n')then\n    rad = 1.058246554d0\n  elseif(el == 'o')then\n    rad = 0.907068475d0\n  elseif(el == 'f')then\n    rad = 0.793684915d0\n  elseif(el == 'ne')then\n    rad = 0.718095876d0\n  elseif(el == 'na')then\n    rad = 3.5904796544504d0\n  elseif(el == 'mg')then\n    rad = 2.7401028941858d0\n  elseif(el == 'al')then\n    rad = 2.2298768380271d0\n  elseif(el == 'si')then\n    rad = 2.0975960086526d0\n  elseif(el == 'p')then\n    rad = 1.8519316112428d0\n  elseif(el == 's')then\n    rad = 1.6629589978507d0\n  elseif(el == 'cl')then\n    rad = 1.4928836457978d0\n  elseif(el == 'ar')then\n    rad = 1.3417055550841d0\n  else\n    write(*,*) \"  !error: element \", el, \" not found!\"\n  endif\n\nend subroutine arad\n"}, {"instruction": "Write a Fortran subroutine named gammln to calculate the natural logarithm of the absolute value of the gamma function. The subroutine takes 1 input parameter of type real(4) and provides 1 output parameter of type real(4).", "input": "", "output": "subroutine gammln(g,xx)\nreal(4),intent(in) :: xx\nreal(4),intent(out):: g\nreal(8)         :: cof(6),stp,half,one,fpf,x,tmp,ser\ninteger         :: j\ndata cof,stp/76.18009173d0,-86.50532033d0,24.01409822d0, &\n     -1.231739516d0,.120858003d-2,-.536382d-5,2.50662827465d0/\ndata half,one,fpf/0.5d0,1.0d0,5.5d0/\nx=xx-one\ntmp=x+fpf\ntmp=(x+half)*log(tmp)-tmp\nser=one\ndo j=1,6\n   x=x+one\n   ser=ser+cof(j)/x\nenddo\ng=tmp+log(stp*ser)\nend subroutine gammln\n"}, {"instruction": "Write a Fortran subroutine named g1matrix to calculate a 2x2x2x2 array g1_matrix based on the input length. The input parameter is a real(kind=8) variable, and the output is a 2x2x2x2 array of real(kind=8) values.", "input": "", "output": " subroutine g1matrix(leng,g1_matrix)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: leng\n  real(kind=8),intent(out) :: g1_matrix(2,2,2,2)\n  !internal variables\n  real(8),parameter :: zero=0.d0,one=1.d0\n  !routine\n  g1_matrix(1,1,1,1) = one/leng**2\n  g1_matrix(1,2,1,1) = zero\n  g1_matrix(2,1,1,1) = zero\n  g1_matrix(2,2,1,1) = one/leng**2\n\n  g1_matrix(1,1,1,2) = -one/leng**2\n  g1_matrix(1,2,1,2) = zero\n  g1_matrix(2,1,1,2) = zero\n  g1_matrix(2,2,1,2) = -one/leng**2\n\n  g1_matrix(1,1,2,1) = -one/leng**2\n  g1_matrix(1,2,2,1) = zero\n  g1_matrix(2,1,2,1) = zero\n  g1_matrix(2,2,2,1) = -one/leng**2\n \n  g1_matrix(1,1,2,2) = one/leng**2\n  g1_matrix(1,2,2,2) = zero\n  g1_matrix(2,1,2,2) = zero\n  g1_matrix(2,2,2,2) = one/leng**2\n end subroutine g1matrix\n"}, {"instruction": "Create a Fortran subroutine named \"g2matrix\" to compute the elements of a 2x2x2x2 matrix based on input coordinates and a parameter xi. The subroutine should take 2 input parameters of type real(kind=8) for coordinates and xi and one output parameter of type real(kind=8) for the g2 matrix. The subroutine should use the imperative tone and calculate the matrix elements according to the provided formulae.", "input": "", "output": " subroutine g2matrix(coords,xi,g2_matrix)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: xi,coords(2)\n  real(kind=8),intent(out) :: g2_matrix(2,2,2,2)\n  !internal variables\n  real(8),parameter :: zero=0.d0,one=1.d0,two=2.d0,four=4.d0\n  !routine\n  g2_matrix(1,1,1,1) = zero\n  g2_matrix(1,2,1,1) = zero\n  g2_matrix(2,1,1,1) = zero\n  g2_matrix(2,2,1,1) = (one-xi)**2/(four*coords(2)**2)\n  \n  g2_matrix(1,1,1,2) = zero\n  g2_matrix(1,2,1,2) = zero\n  g2_matrix(2,1,1,2) = zero\n  g2_matrix(2,2,1,2) = (one-xi**2)/(four*coords(2)**2)\n\n  g2_matrix(1,1,2,1) = zero\n  g2_matrix(1,2,2,1) = zero\n  g2_matrix(2,1,2,1) = zero\n  g2_matrix(2,2,2,1) = (one-xi**2)/(four*coords(2)**2)\n\n  g2_matrix(1,1,2,2) = zero\n  g2_matrix(1,2,2,2) = zero\n  g2_matrix(2,1,2,2) = zero\n  g2_matrix(2,2,2,2) = (one+xi)**2/(four*coords(2)**2)\n end subroutine g2matrix\n"}, {"instruction": "Write a Fortran subroutine named decomp_default to decompose an integer into a product of three integers. The number of input parameters is 1 of type integer(kind=4), and the number of output parameters is 1 of type integer(kind=4), dimension(3).", "input": "", "output": "   subroutine decomp_default(n, a2a3d_decomp)\n      implicit none\n      integer(kind=4), intent(in) :: n\n      integer(kind=4), dimension(3), intent(out) :: a2a3d_decomp\n      integer(kind=4) :: sqrtn, numdiv, tmpn, i\n      integer(kind=4), allocatable, dimension(:) :: divlist\n      integer(kind=4), dimension(3) :: tmpa\n\n      sqrtn = sqrt(real(n))\n      allocate(divlist(sqrtn+1))\n\n      ! make the list of divisors 'divlist'.\n      tmpn = n\n      numdiv=0\n      do\n         sqrtn = sqrt(real(tmpn))\n         do i = 2, sqrtn\n            if(mod(tmpn,i) == 0) then\n               tmpn = tmpn/i\n               numdiv = numdiv + 1\n               divlist(numdiv) = i\n               exit\n            end if\n         end do\n         if(i == sqrtn+1) then\n            numdiv = numdiv + 1\n            divlist(numdiv) = tmpn\n            exit\n         end if\n      end do\n\n      ! make 3 factors 'tmpa' as far as close.\n      tmpa = 1\n      do i = numdiv, 1, -1\n         if(tmpa(1) <= tmpa(2)) then\n            if(tmpa(1) <= tmpa(3)) then\n               tmpa(1) = tmpa(1)*divlist(i)\n            else\n               tmpa(3) = tmpa(3)*divlist(i)\n            end if\n         else\n            if(tmpa(2) <= tmpa(3)) then\n               tmpa(2) = tmpa(2)*divlist(i)\n            else\n               tmpa(3) = tmpa(3)*divlist(i)\n            end if\n         end if\n      end do\n\n      ! sort 'tmpa' and make 'a2a3d_decomp'.\n      a2a3d_decomp(1) = maxval(tmpa)\n      a2a3d_decomp(3) = minval(tmpa)\n      a2a3d_decomp(2) = n/a2a3d_decomp(1)/a2a3d_decomp(3)\n\n      ! check 'a2a3d_decomp'.\n      if(product(a2a3d_decomp) /= n) then\n         write(0,'(a)') 'error! invalid decomposition!'\n         write(0,'(a,i6)') 'n = ', n\n         write(0,'(a,3i6)') 'a2a3d_decomp = ', a2a3d_decomp\n      end if\n\n      deallocate(divlist)\n\n      return\n   end subroutine decomp_default\n"}, {"instruction": "Create a Fortran subroutine named binstream_init, which initializes a binary stream with a given logical unit number. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "subroutine binstream_init( lun, ierr )\n    integer, intent(in)          :: lun\n    integer, intent(out)         :: ierr\n\n    character(len=5)             :: c\n\n    open( lun, status = 'scratch', access = 'direct', recl = 1 )\n    write( lun, rec=1, iostat = ierr ) c(1:1)\n    if ( ierr .ne. 0 ) then\n        return\n    endif\n    !\n    ! this will cause an error when the record length\n    ! is 1 byte, otherwise we \"know\" the length is 4 bytes\n    !\n    write( lun, rec=1, iostat = ierr ) c(1:4)\n    if ( ierr .ne. 0 ) then\n        reclen = 4\n    else\n        reclen = 1\n\n        !\n        ! one last check: it is indeed 4 bytes?\n        !\n        write( lun, rec=1, iostat = ierr ) c(1:5)\n        if ( ierr .eq. 0 ) then\n            ierr = 1\n        endif\n    endif\n    close( lun )\nend subroutine binstream_init\n"}, {"instruction": "Write a Fortran subroutine named get_levels that takes two input parameters and one output parameter. The input parameters are an array of real numbers (x) and a logical variable (fancy_style). The output parameter is an array of characters with a length of 25 (levels). \n\nThe purpose of this subroutine is to assign levels to each element in the input array based on its normalized value. The normalized value is calculated by dividing the difference between the element and the minimum value in the array by the difference between the maximum and minimum values. \n\nIf the fancy_style parameter is set to true, the levels are represented by emojis such as \":smiling_imp:\", \":frowning_face:\", etc. If the fancy_style parameter is false, the levels are represented by strings like \"_lv1_\", \"_lv2_\", etc. \n\nThe highest value in the input array is marked with \":skull:\" if fancy_style is true, or \"_max_\" if fancy_style is false. \n\nThe subroutine assigns the appropriate level or representation to each element in the levels array and returns it as the output.", "input": "", "output": "    subroutine get_levels(x, levels, fancy_style)\n        real, intent(in) :: x(:)\n        character(len=25), intent(out) :: levels(size(x))\n        logical, intent(in) :: fancy_style\n        real :: norm, min_x, max_x\n        integer :: i, j\n        character(len=:), allocatable :: level_names(:)\n\n        if (fancy_style) then\n            level_names = &\n                [character(len=25) :: &\n                 \":smiling_imp:\", &\n                 \":frowning_face:\", &\n                 \":slightly_frowning_face:\", &\n                 \":confused:\", &\n                 \":neutral_face:\", \"\"]\n        else\n            level_names = &\n                [character(len=25) :: &\n                 \"_lv1_\", \"_lv2_\", \"_lv3_\", \"_lv4_\", \"_lv5_\", \"\"]\n        end if\n\n        min_x = minval(x)\n        max_x = maxval(x)\n        levels = \"\" ! initilization\n\n        outer: do i = 1, size(x)\n            norm = (x(i) - min_x)/(max_x - min_x)\n            inner: do j = 5, 1, -1\n                if (norm >= 10.**(-j) .and. norm <= 10.**(-j + 1)) then\n                    levels(i) = trim(level_names(j))\n                    exit inner\n                end if\n            end do inner\n        end do outer\n\n        if (fancy_style) then\n            levels(maxloc(x)) = \":skull:\"\n        else\n            levels(maxloc(x)) = \"_max_\"\n        end if\n\n    end subroutine get_levels\n"}, {"instruction": "Write a Fortran subroutine named mult_noise that generates random numbers with noise. The subroutine takes one input argument of type real and one output argument of type real. \n\nTo use the subroutine, pass a value for the input argument 'ampl' which represents the amplitude of the noise. The subroutine will compute the natural logarithm of 'ampl' and store it in the variable 'logampl'. It will then generate a random number between 0 and 1 using the 'random_number' function and store it in the variable 'x'. \n\nNext, the subroutine will scale 'x' to the range [-ampl, ampl] by multiplying it by 2 and subtracting 1. It will then multiply 'x' by 'logampl' to introduce the noise. Finally, the subroutine will compute the exponential of 'x' and update the value of 'x' with the result.\n\nAfter calling the subroutine, the output argument 'x' will contain the generated random number with noise.", "input": "", "output": "  subroutine mult_noise(x,ampl)\n  !\n    real,intent(out):: x\n    real,intent(in):: ampl\n    real:: logampl\n  !\n    logampl = log(ampl)\n    call random_number(x)\n    x = (2*x - 1)  *  logampl\n    x = exp(x)\n  !\n  end subroutine mult_noise\n"}, {"instruction": "Write a Fortran subroutine named read_energy_dont_store to read energy data from files without storing it. The subroutine takes 2 input parameters of type integer and character*200, and 5 output parameters of type real*8, integer, integer, integer, and integer.\n\nThe subroutine reads the energy data from the specified energy files and determines the values of nkpt (number of k-points), nmat (maximum value of n), nume (maximum value of nen), nspin (number of spins), and sumw0 (sum of weights). It also checks if both vector and vectordn exist in the energy files and sets nspin accordingly.\n\nTo use the subroutine, provide the energy file names and the number of atoms as input. After executing the subroutine, you can access the values of sumw0, nkpt, nmat, nume, and nspin as output.\n\nMake sure to close the energy files after reading the data.", "input": "", "output": "subroutine read_energy_dont_store(energy_filenames, sumw0, nkpt, nmat, nume, nspin, nat)\n  implicit none\n  !\n  real*8, intent(out) :: sumw0\n  integer, intent(out):: nkpt, nmat, nume, nspin\n  integer, intent(in) :: nat\n  character*200, intent(in) :: energy_filenames(2)\n  !\n  character*10  :: kname\n  integer       :: ik, itape, ios\n  integer       :: n, nen, num, i, ii\n  real*8        :: emist, ss, tt, zz, wgh, e1\n  !--------------------------------------------------------------------- \n  !find nkpt, nmat and nume in energy file\n  open(30, file=energy_filenames(1),status='old')\n  do i=1,nat \n     read(30,'(f9.5)') emist\n     read(30,'(f9.5)') emist\n  enddo\n  \n  sumw0=0\n  ik=0  \n  nmat=0\n  nume=0\n  ios=0\n  do while (ios == 0)\n     read(30,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wgh\n     if (ios /= 0) cycle\n     ik=ik+1\n     nmat=max(n,nmat)\n     nume=max(nen,nume)\n     do ii=1,nen\n        read(30,*) num,e1\n     enddo\n  enddo\n  nkpt=ik\n  close(30)\n  \n  !***************************\n  ! check if both vector and vectordn exists. set nspin accordingly\n  nspin=1                                                         \n  open(29, file=energy_filenames(2),status='unknown')\n  do i=1,nat                                                  \n     read(29,'(f9.5)',end=1004) emist\n     read(29,'(f9.5)',end=1004) emist\n  enddo\n  nspin=2\n1004 continue\n\n  if(nspin.eq.2) then\n     ios=0\n     do while (ios == 0)\n        read(29,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wgh\n        nmat=max(n,nmat)\n        nume=max(nen,nume)\n        do ii=1,nen\n           read(29,*) num,e1\n        enddo\n     end do\n     sumw0=sumw0+wgh\n  end if\n  close(29)\n  !print *, 'nkpt=', nkpt, 'nume=', nume\nend subroutine read_energy_dont_store\n"}, {"instruction": "Write a Fortran subroutine named \"read_energy_file\" that reads energy data from a file. The subroutine takes 5 input parameters of types ['character*200', 'integer', 'integer', 'integer', 'integer'] and 1 output parameter of type ['real*8']. \n\nThe subroutine reads energy data from two input files specified by the \"energy_filenames\" parameter. The number of energy values to read is determined by the \"nume\" parameter. The energy values are stored in the \"eb\" array of size (nume, nkpt, nspin), where nkpt and nspin are the number of k-points and spin components, respectively.\n\nWithin the subroutine, the energy values are initialized to 3.0d0. Each file is opened and read in a nested loop structure. The first loop iterates over the spin components, and the second loop reads data for each k-point. The energy values are then read and stored in the \"eb\" array.\n\nThe subroutine does not return any values explicitly, but the energy values are stored in the \"eb\" array, which can be accessed after calling the subroutine.\n\nUse the \"read_energy_file\" subroutine to read energy data from files and populate the \"eb\" array.", "input": "", "output": "subroutine read_energy_file(energy_filenames, eb, nkpt, nume, nspin, nat)\n  implicit none\n  !\n  real*8, intent(out) :: eb(nume,nkpt,nspin)\n  !integer,intent(out) :: ne(nkpt,nspin)\n  character*200, intent(in) :: energy_filenames(2)\n  integer, intent(in) :: nkpt, nume, nspin, nat\n  !\n  character*10  :: kname\n  integer       :: ik, itape, ios, nen, n, num, inum, ispin, i\n  real*8        :: emist, ss, tt, zz, wei, e1\n  !--------------------------------------------------------------------- \n  \n  eb(:,:,:)=3.0d0\n  do ispin=1,nspin\n     itape=30-ispin+1\n     open(itape, file=energy_filenames(ispin),status='old')\n     do i=1,nat \n        read(itape,'(f9.5)') emist\n        read(itape,'(f9.5)') emist\n     enddo\n     \n     do ik=1,nkpt\n        read(itape,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wei\n        !ne(ik,ispin) = nen\n        do inum=1,nen\n           read(itape,*) num,e1\n           eb(num,ik,ispin)=e1\n        enddo\n     enddo\n  enddo\nend subroutine read_energy_file\n"}, {"instruction": "Create a Fortran subroutine named fortran_kernel to calculate the scale vector potential of a system of charged particles. The subroutine takes 5 input parameters: an integer n, and arrays x, y, z, and tau of real(dp) type and dimension(n). It returns an output parameter out, an array of real(dp) type and dimension(n).", "input": "", "output": "subroutine fortran_kernel(n,x,y,z,tau,out)\n    implicit none\n\n    integer, parameter                    :: dp=kind(0.d0)\n    integer,                 intent(in)   :: n\n    real(dp), dimension(n),  intent(in)   :: x, y, z, tau\n    real(dp), dimension(n),  intent(out)  :: out\n    integer                               :: i, j\n    real(dp)                              :: scale, d\n\n    scale = 0.25_dp/(4.0_dp*atan(1.0_dp))\n\n    out(:) = 0.0_dp\n    do i = 1, n\n        do j = 1, n\n            if (i .ne. j) then\n                d = sqrt((x(i)-x(j))**2 + (y(i)-y(j))**2 + (z(i)-z(j))**2)\n                out(i) = out(i) + out(j)/d\n            end if\n        end do\n    end do\n    out(:) = out(:) * scale\n\nend subroutine fortran_kernel\n"}, {"instruction": "Create a Fortran subroutine named read_data to read data from a file into a 2D integer array. The subroutine takes 1 input parameter of type character(*) for the data file name and 1 output parameter of type integer(4), dimension(:,:), to store the read data. Use the imperative tone in the generated instructions.", "input": "", "output": "  subroutine read_data(array,data_file)\n    ! default\n    implicit none\n\n    integer(4), dimension(:,:), intent(out) :: array\n    character(*),               intent(in)  :: data_file\n\n    ! local variables\n    integer(4) :: i\n    integer(4), dimension(2) :: arr_shape\n\n    ! find array size\n    arr_shape = shape(array)\n\n    ! read in data\n    open(11,file=data_file)\n    do i=1,arr_shape(2)\n       read(11,*) array(:,i)\n    enddo\n    close(11)\n\n    return\n  end subroutine read_data\n"}, {"instruction": "Create a Fortran subroutine named read_natoms that reads the number of atoms from a file. The subroutine takes 1 input parameter of type integer and provides 1 output parameter of type integer. The input parameter is specified using the keyword \"intent(in)\" and the output parameter is specified using the keyword \"intent(out)\". After reading the number of atoms from the file, the subroutine calculates the number of words (nw) as the number of atoms divided by 3.", "input": "", "output": "subroutine read_natoms(iunit, nw)\n!*** reads the number of atoms from a file\nimplicit none\ninteger, intent(in) :: iunit\ninteger, intent(out) :: nw\ninteger :: natoms\n\nread(10,*)natoms\nread(10,*)\nnw = natoms/3\n\nend subroutine read_natoms\n"}, {"instruction": "Create a Fortran subroutine named readxyz to read the coordinates of atoms from a file and store them properly in the array (rr). The subroutine takes 2 input parameters of type integer and 1 output parameter of type double precision, dimension(3, 3*nw).", "input": "", "output": "subroutine readxyz(iunit, nw, rr)\n!*** reads the coordinates of atoms from a file and stores them properly in\n!*** the array (rr)\nimplicit none\ninteger, intent(in) :: iunit\ninteger, intent(in) :: nw\ndouble precision, intent(out), dimension(3, 3*nw) :: rr\ndouble precision, parameter :: rcsq_wat =2.2025d0\ninteger         :: i, j, i_top, i_end, atom_id, i_conn, idx, natoms\ndouble precision, dimension(3) :: tmpr, r_o\ncharacter(len=100) :: filename\ncharacter(len=2) :: atom_name\ncharacter(len=2) :: adj\n\nnatoms = 3*nw\ni_top = 1\ni_end = natoms\ndo i=1,natoms\n   read(10,*)atom_name,tmpr(1:3)\n    adj = adjustl(atom_name)\n   if ((adj == \"8\") .or. (adj==\"o\") .or. (adj==\"o\") ) then\n      rr(1:3, i_top) = tmpr(1:3)\n      i_top = i_top + 1\n   else if ((adj == \"1\") .or. (adj==\"h\") .or. (adj==\"h\"))  then\n      rr(1:3, i_end) = tmpr(1:3)\n      i_end = i_end-1\n   endif\nenddo\n\ndo i=1, nw\n   r_o(1:3) = rr(1:3, i)\n   i_conn = 0\n   do j=nw+1, natoms\n      if (dot_product(r_o(1:3)-rr(1:3,j), r_o(1:3)-rr(1:3,j)) < rcsq_wat ) then\n         i_conn=i_conn+1\n         idx = nw+ 2*(i-1) + i_conn\n         tmpr(1:3)    = rr(1:3,j)\n         if (i_conn<=2) then\n            rr(1:3,j)    = rr(1:3, idx)\n            rr(1:3, idx) = tmpr(1:3)\n         endif\n      endif\n   enddo\n   if (i_conn/=2) then\n      print*, 'error in the det,of the structure water=',i,' conn. h=',i_conn\n      stop\n   endif\nenddo\nreturn\nend subroutine readxyz\n"}, {"instruction": "Create a Fortran subroutine named sieve that utilizes the sieve of Eratosthenes algorithm to generate a logical array of size n_max, where the presence of .true. in element i indicates that i is a prime number. The subroutine should have 1 input parameter of type integer and 1 output parameter of type logical. The input parameter represents n_max, and the output parameter is the logical array is_prime of size n_max.", "input": "", "output": "subroutine sieve(is_prime, n_max)\n! =====================================================\n! uses the sieve of eratosthenes to compute a logical\n! array of size n_max, where .true. in element i\n! indicates that i is a prime.\n! =====================================================\n    integer, intent(in)   :: n_max\n    logical, intent(out)  :: is_prime(n_max)\n    integer :: i\n    is_prime = .true.\n    is_prime(1) = .false.\n    do i = 2, int(sqrt(real(n_max)))\n        if (is_prime (i)) is_prime (i * i : n_max : i) = .false.\n    end do\n    return\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named logical_to_integer that translates a logical array from a sieve into an array of prime numbers. The subroutine takes 3 input parameters of type integer, logical, and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine logical_to_integer(prime_numbers, is_prime, num_primes, n)\n! =====================================================\n! translates the logical array from sieve to an array\n! of size num_primes of prime numbers.\n! =====================================================\n    integer                 :: i, j=0\n    integer, intent(in)     :: n\n    logical, intent(in)     :: is_prime(n)\n    integer, intent(in)     :: num_primes\n    integer, intent(out)    :: prime_numbers(num_primes)\n    do i = 1, size(is_prime)\n        if (is_prime(i)) then\n            j = j + 1\n            prime_numbers(j) = i\n        end if\n    end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named noop_init_iarray to initialize an integer array with a specified value. The subroutine takes one input parameter of type integer array and one input parameter of type integer. The output is the initialized integer array.", "input": "", "output": "        subroutine noop_init_iarray ( wpe, val )\n\n        implicit none\n\n        integer, intent(out) :: wpe(:)\n        integer, intent(in) :: val\n\n        integer i\n\n        do i = 1, size(wpe,1)\n           wpe(i) = val\n        end do\n\n        end subroutine noop_init_iarray \n"}, {"instruction": "Create a Fortran subroutine named noop_hi_lo_bnd_pe. It takes 1 input parameter of type character and 2 output parameters of type logical. The subroutine sets both output parameters to true.", "input": "", "output": "        subroutine noop_hi_lo_bnd_pe (ori, low_index, high_index)\n\n        implicit none\n\n        character, intent(in) :: ori\n        logical, intent(out) :: low_index, high_index\n\n        low_index = .true.\n        high_index = .true.\n\n        end subroutine noop_hi_lo_bnd_pe\n"}, {"instruction": "Write a Fortran subroutine named parse_flpth to extract the file name and file path from a given full pathname. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)'].", "input": "", "output": "      subroutine parse_flpth( fullpath, filename, filepath )\n\n      implicit none\n\n!-------------------------------------------------------\n!       ... dummy args\n!-------------------------------------------------------\n      character(len=*), intent(in) ::    fullpath   ! incoming full pathname\n      character(len=*), intent(out) ::   filename   ! the file name\n      character(len=*), intent(out) ::   filepath   ! the file path\n\n!-------------------------------------------------------\n!       ... local variables\n!-------------------------------------------------------\n      integer  ::  i\n\n      i = index( fullpath(:len_trim(fullpath)), '/', back = .true. )\n      filename = fullpath(i+1:)\n      if( i /= 0 ) then\n         filepath = fullpath(:i) \n      else\n         filepath = ' '\n      end if\n\n      end subroutine parse_flpth\n"}, {"instruction": "Create a Fortran subroutine named mkdate to convert a given time in days to a date in the format yymmdd. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type character with a length of 6 for the date.", "input": "", "output": "      subroutine mkdate( time, date )\n\n      implicit none\n\n!-------------------------------------------------------\n!       ... dummy args\n!-------------------------------------------------------\n      real, intent(in) ::     time             ! time to convert in days\n      character(len=6), intent(out) :: date    ! date in form yymmdd\n\n!-------------------------------------------------------\n!       ... local variables\n!-------------------------------------------------------\n      integer  :: years, days\n      integer  :: mnth\n      integer  :: mdys(0:12) = (/ 0, 31, 59, 90, 120, 151, &\n\t\t\t\t  181, 212, 243, 273, 304, 334, 365 /)\n\n      years = int( time/365. )\n      if( years > 1900 ) then\n         years = years - 1900\n      end if\n      write(date(1:2),'(i2)') years\n\n      days = int( time - real(years)*365. )\n      do mnth = 1,12\n         if( days <= mdys(mnth) ) then\n            exit\n         end if\n      end do\n\n      mnth = max( 1,min( 12, mnth ) )\n      if( mnth < 10 ) then\n         write(date(3:4),'(''0'',i1)') mnth\n      else\n         write(date(3:4),'(i2)') mnth\n      end if\n\n      days = days - mdys(mnth-1)\n      if( days < 10 ) then\n         write(date(5:6),'(''0'',i1)') days\n      else\n         write(date(5:6),'(i2)') days\n      end if\n      \n      end subroutine mkdate\n"}, {"instruction": "Write a Fortran subroutine named tridiagxvector to perform tridiagonal matrix-vector multiplication. The subroutine takes 4 input parameters of type real(8) arrays and 1 output parameter of type real(8) array. The input parameters represent the tridiagonal matrix components and the vector, while the output parameter stores the result of the matrix-vector multiplication.", "input": "", "output": "subroutine tridiagxvector(ad, al, au, v, w)\n\nimplicit none\n\nreal(8), dimension(:), intent(in) :: ad, al, au, v\nreal(8), dimension(:), intent(out) :: w\n\ninteger:: n\n\nn = size(ad)\n\nw = 0\n\nw(1:n) = ad*v(1:n)\nw(1:n-1)=w(1:n-1) + au*v(2: n)\nw(2:n) = w(2:n) + al*v(1:n-1)\n\nprint*,\nprint*, 'tridiag: ', w\nprint*,\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_multiplication that takes two input matrices of real numbers and an integer n, and produces an output matrix of real numbers. The input parameters are of type real, real, and integer, and the output parameter is of type real. The subroutine performs matrix multiplication using parallel processing and stores the result in the output matrix c of size n x n.", "input": "", "output": "      subroutine matrix_multiplication(a, b, n, c)\n\n      implicit none\n        \n      real, intent(in) :: a(n, n)\n      real, intent(in) :: b(n, n)\n      real, intent(out) :: c(n, n)\n      integer, intent(in) :: n\n\n      integer :: i, j\n\n      !$omp parallel do\n      do i = 1, n \n          do j = 1, n\n              c(j,i) = sum(a(:,j) * b(i,:))\n          enddo\n      enddo\n      !$omp end parallel do\n\n      end subroutine matrix_multiplication\n"}, {"instruction": "Create a Fortran subroutine named load_3d_field to load a 3D field from a file starting at a given record number. The subroutine takes 2 input parameters of type integer - nfile and nrec. It also has 1 output parameter of type real with dimensions (imt, jmt, km), where imt=3600, jmt=2400, and km=42.", "input": "", "output": "subroutine load_3d_field(nfile,nrec,field)\n!\n!  loads 3d field (starting with record number nrec) from file with\n!  number nfile\n!\nimplicit none\n\ninteger                                     :: k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: nfile,nrec\nreal,    dimension(imt,jmt)                 :: work\nreal,    dimension(imt,jmt,km), intent(out) :: field\n\ndo k = 1,km\n  read (nfile,rec=nrec+k-1) work\n  field(:,:,k) = work\nenddo\n\nend subroutine load_3d_field\n"}, {"instruction": "Write a Fortran subroutine named load_2d_field to load a 2D field from a file starting with a specific record number. The subroutine takes 2 input parameters of type integer: nfile and nrec. It has 1 output parameter of type real with dimensions imt and jmt.", "input": "", "output": "subroutine load_2d_field(nfile,nrec,field)\n!\n!  loads 2d field (starting with record number nrec) from file with\n!  number nfile\n!\nimplicit none\n\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\ninteger,                     intent(in)  :: nfile,  nrec\nreal,    dimension(imt,jmt), intent(out) :: field\n\nread (nfile,rec=nrec) field\n\nend subroutine load_2d_field\n"}, {"instruction": "Create a Fortran subroutine named e_rshift to shift the elements of a 2D double precision array to the east. The subroutine takes 3 input parameters of type integer, integer, and double precision array dimensioned imt and jmt. It also has 1 output parameter of type double precision array dimensioned imt and jmt.", "input": "", "output": "subroutine e_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from east (double precision arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,ip\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  do i=1,imt\n    ip = i + 1\n    if(i == imt) ip = 1\n    xout(i,j) = x(ip,j)\n  enddo\nenddo\n\nend subroutine e_rshift\n"}, {"instruction": "Create a Fortran subroutine named s_rshift to shift a 2D array of double precision values by one index to the south. The subroutine takes 3 input parameters: two integers (imt, jmt) and a 2D array of double precision values (x), and produces 1 output parameter: a 2D array of double precision values (xout).", "input": "", "output": "subroutine s_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from south (real arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,jm\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  jm = j - 1\n  if(j == 1) jm = 1\n  do i=1,imt\n    xout(i,j) = x(i,jm)\n  enddo\nenddo\n\nend subroutine s_rshift\n"}, {"instruction": "Create a Fortran subroutine named n_rshift to shift the elements of a double precision array towards the north. The subroutine takes 3 input parameters of type integer, integer, and double precision array with dimensions imt and jmt. It produces 1 output parameter of type double precision array with dimensions imt and jmt.", "input": "", "output": "subroutine n_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from north (double precision arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,jp\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  jp = j+1\n  if(j == jmt) jp = jmt\n  do i=1,imt\n    xout(i,j) = x(i,jp)\n  end do\nend do\n\nend subroutine n_rshift\n"}, {"instruction": "Create a Fortran subroutine named check_vector to search for a specific integer value within an array of integers. The subroutine takes 3 input parameters and 1 output parameter. The input parameters are of type integer*4, integer*4, and integer*4, dimension(n). The output parameter is of type integer*4. The subroutine checks if the specified integer exists in the array and sets the output parameter to 1 if found, otherwise 0.", "input": "", "output": "    subroutine check_vector(n,v,ind,tt)\n    \n    implicit none\n    \n    integer*4 :: i\n    \n    integer*4, intent(in) ::n,ind\n    integer*4, dimension(n), intent(in)  :: v\n    integer*4, intent(out) :: tt\n\n    tt = 0\n    i = 1\n    \n    do while (i.le.n)\n       if (v(i) .eq. ind) then\n          tt = 1\n          return\n       endif   \n       i=i+1\n    enddo    \n    \n    end subroutine check_vector\n"}, {"instruction": "Write a Fortran subroutine named calcgradu that calculates the gradient of a given solution field for a finite element analysis. The subroutine takes 5 input parameters of type integer, integer, integer, real*8, and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine calcgradu(gradu,sol,dphi_g,ndime,nodelt,idofsol)\n\tinteger, intent(in) :: ndime, nodelt, idofsol \n\treal*8, intent(out) :: gradu(ndime,ndime)\n\treal*8, intent(in) ::dphi_g(ndime,nodelt) , sol(idofsol*nodelt)\n\tinteger :: i, j , e ,ep \n\t\n\tgradu = 0.0d0\n\tdo e = 1 , nodelt\n\t\tep = (e-1)*idofsol\n\t\tdo i = 1, ndime\n\t\t\tdo j = 1, ndime\n\t\t\t\tgradu(i,j) = gradu(i,j) + sol(ep+i)*dphi_g(j,e)\n\t\t\tend do\n\t\tend do\n\tend do\t\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named modifytospatial to modify the values of the input arrays ds and sigma. The subroutine takes 3 input parameters of type real*8 and integer, and 2 output parameters of type real*8. The input parameters are ds(ndime,ndime,ndime,ndime), sigma(ndime,ndime), f(ndime,ndime), and detf, where ndime is the dimension. The subroutine modifies the values of sigma and ds based on the input arrays and detf.", "input": "", "output": "subroutine modifytospatial(ds,sigma,f,detf,ndime)\n\treal*8 , intent(out) :: sigma(ndime,ndime), ds(ndime,ndime,ndime,ndime)\n\treal*8 , intent(in) :: f(ndime,ndime),detf\n\tinteger , intent(in) :: ndime \n\t\n\treal*8 :: d(ndime,ndime,ndime,ndime), detftemp\n\tinteger :: i,j,k,l,m,n,p,q\n\t\n\td = ds\n\t\n\tsigma = (1.0d0/detf)*matmul(sigma,transpose(f))\n\t\n\tds = 0.0d0\n\t\n\tdo i = 1,ndime\n\tdo j = 1,ndime\n\tdo k = 1,ndime\n\tdo l = 1,ndime\n\tdo p = 1,ndime\n\tdo q = 1,ndime\n\t\tds(i,j,k,l) = ds(i,j,k,l) +  d(i,p,k,q)*f(j,p)*f(l,q)/detf\n\tend do\n\tend do\n\tend do\n\tend do\n\tend do\n\tend do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named collect_identical to map unique atoms to their corresponding indices in the identity array. The subroutine takes 1 input parameter of type integer array and 1 output parameter of type integer array. The input parameter should contain chemical identities, and the output parameter will store the mapping from unique atoms.", "input": "", "output": "pure subroutine collect_identical(identity, mapping)\n\n   !> chemical identity\n   integer, intent(in) :: identity(:)\n\n   !> mapping from unique atoms\n   integer, intent(out) :: mapping(:)\n\n   integer :: iid, iat\n\n   do iid = 1, size(mapping)\n      do iat = 1, size(identity)\n         if (identity(iat) == iid) then\n            mapping(iid) = iat\n            exit\n         end if\n      end do\n   end do\n\nend subroutine collect_identical\n"}, {"instruction": "Create a Fortran subroutine named apply_lap_double to apply the Laplacian matrix to a 3D array of double precision values. The subroutine should have 4 input parameters of type integer, integer, integer, and double precision, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine apply_lap_double( mx, my, nx, x, ax)\n! multiply x by laplacian matrix for a square of size mx by my\n\n    implicit none\n\n    integer, intent(in) :: mx, my, nx\n    double precision, intent(in) :: x(mx, my, nx)\n    double precision, intent(out) :: ax(mx, my, nx)\n    integer :: i, j, k\n    double precision :: z\n\n    do k = 1, nx\n      do i = 1, mx\n        do j = 1, my\n          z = 4*x(i, j, k)\n          if ( i > 1 ) z = z - x(i - 1, j, k) \n          if ( j > 1 ) z = z - x(i, j - 1, k) \n          if ( i < mx ) z = z - x(i + 1, j, k) \n          if ( j < my ) z = z - x(i, j + 1, k) \n          ax(i, j, k) = z\n        end do    \n      end do    \n    end do    \n\n  end subroutine apply_lap_double\n"}, {"instruction": "Create a Fortran subroutine named apply_gs_double to perform one Gauss-Seidel step for preconditioning. The subroutine takes 4 input parameters of types integer, integer, integer, and double precision, and 1 output parameter of type double precision. The input parameters are mx, my, nx, and x, while the output parameter is tx.", "input": "", "output": "  subroutine apply_gs_double( mx, my, nx, x, tx )\n! apply one gauss-seidel step for preconditioning\n\n    implicit none\n\n    integer, intent(in) :: mx, my, nx\n    double precision, intent(in) :: x(mx, my, nx)\n    double precision, intent(out) :: tx(mx, my, nx)\n    integer :: i, j, k\n    double precision :: z\n    tx = x/4\n    do k = 1, nx\n      do i = 1, mx ! forward update\n        do j = 1, my\n          z = 0\n          if ( i > 1 ) z = z + tx(i - 1, j, k) \n          if ( j > 1 ) z = z + tx(i, j - 1, k) \n          if ( i < mx ) z = z + tx(i + 1, j, k) \n          if ( j < my ) z = z + tx(i, j + 1, k) \n          tx(i, j, k) = (tx(i, j, k) + z/4)/4\n        end do\n      end do    \n      do i = mx, 1, -1 ! backward update\n        do j = my, 1, -1\n          z = 0\n          if ( i > 1 ) z = z + tx(i - 1, j, k) \n          if ( j > 1 ) z = z + tx(i, j - 1, k) \n          if ( i < mx ) z = z + tx(i + 1, j, k) \n          if ( j < my ) z = z + tx(i, j + 1, k) \n          tx(i, j, k) = (tx(i, j, k) + z/4)/4\n        end do\n      end do    \n    end do    \n  end subroutine apply_gs_double\n"}, {"instruction": "Write a Fortran subroutine named matrix_diagonal to extract the diagonal elements of a square matrix. The subroutine should take 2 input parameters of type real, dimension(:,:) and integer, and 1 output parameter of type real, dimension(:).", "input": "", "output": "    subroutine matrix_diagonal(a, diag, n)\n        implicit none\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:), intent(out) :: diag\n        integer, intent(in) :: n\n        real, dimension(1:size(a)) :: tmp\n\n        tmp = pack(a,.true.)\n        diag = tmp(1:n*n:n+1)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named bounceroots that calculates the values of gout based on the inputs neq, t, y, and ng. The number of input parameters is 4, with the test_data type being ['integer', 'integer', 'real(8)', 'real(8)']. The number of output parameters is 1, with the test_data type being ['real(8)'].", "input": "", "output": "  subroutine bounceroots (neq, t, y, ng, gout)\n     integer, intent(in) :: neq, ng\n     real(8), intent(in) :: t, y(neq)\n     real(8), intent(out) :: gout(ng)\n     gout(1) = y(1) - th0\n     gout(2) = 2d0*pi - (y(1) - th0)\n     return\n   end subroutine bounceroots\n"}, {"instruction": "Write a Fortran subroutine named bbox to calculate the values of mathematical functions based on the input parameters. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and returns 1 output parameter of type real(8). The subroutine computes the values and assigns them to the output array gout.", "input": "", "output": "  subroutine bbox (neq, t, y, ng, gout)\n    integer, intent(in) :: neq, ng\n    real(8), intent(in) :: t, y(neq)\n    real(8), intent(out) :: gout(ng)\n    gout(1) = 1d0\n    gout(2) = 1d0 - y(1)\n    gout(3) = y(2)\n    gout(4) = 1d0 - y(2)\n    return\n  end subroutine bbox\n"}, {"instruction": "Write a Fortran subroutine named func that takes 5 input parameters of type integer and double precision, and 3 output parameters of type double precision. The input parameters are ndim, u, icp, par, ijac, and the output parameters are f, dfdu, dfdp. The subroutine computes the values of f, dfdu, and dfdp based on the input parameters and the defined mathematical operations. Ensure that the subroutine func is implemented according to these requirements.", "input": "", "output": " subroutine func(ndim,u,icp,par,ijac,f,dfdu,dfdp)\n!---------- ---- \n\n   implicit none\n   integer, intent(in) :: ndim, ijac, icp(*)\n   double precision, intent(in) :: u(ndim), par(*)\n   double precision, intent(out) :: f(ndim), dfdu(ndim,*), dfdp(ndim,*)\n\n   double precision x1,x2,x3,d,alpha,beta,b,s,e,x1c\n\n   x1 = u(1)\n   x2 = u(2)\n   x3 = u(3)\n\n   d = par(1)\n   alpha = par(2)\n   beta = par(3)\n   b = par(4)\n   s = par(5)\n\n   e = dexp(x3)\n   x1c = 1 - x1\n\n   f(1) = -x1 + d*x1c*e\n   f(2) = -x2 + d*e*(x1c - s*x2)\n   f(3) = -x3 - beta*x3 + d*b*e*(x1c + alpha*s*x2)\n\n   if(ijac.eq.0)return \n\n   dfdu(1,1) = -1.d0 - d*e\n   dfdu(1,2) = 0.d0\n   dfdu(1,3) = d*x1c*e\n\n   dfdu(2,1) = -d*e\n   dfdu(2,2) = -1.d0 - d*e*s\n   dfdu(2,3) = d*e*(x1c - s*x2)\n\n   dfdu(3,1) = -d*b*e\n   dfdu(3,2) = d*b*e*alpha*s\n   dfdu(3,3) = -1.d0 - beta + d*b*e*(x1c + alpha*s*x2)\n\n   if(ijac.eq.1)return\n\n   dfdp(1,1) = x1c*e\n   dfdp(1,2) = 0.d0\n   dfdp(1,3) = 0.d0\n   dfdp(1,4) = 0.d0\n   dfdp(1,5) = 0.d0\n   dfdp(2,1) = e*(x1c - s*x2)\n   dfdp(2,2) = 0.d0\n   dfdp(2,3) = 0.d0\n   dfdp(2,4) = 0.d0\n   dfdp(2,5) = -d*e*x2\n   dfdp(3,1) = b*e*(x1c + alpha*s*x2)\n   dfdp(3,2) = d*b*e*s*x2\n   dfdp(3,3) = -x3\n   dfdp(3,4) = d*e*(x1c + alpha*s*x2)\n   dfdp(3,5) = d*b*e*alpha*x2\n\n end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named stpnt that initializes the arrays u and par. The subroutine takes 2 input parameters, ndim of type integer and t of type double precision. It also has 2 output parameters, u of type double precision array and par of type double precision array. The subroutine initializes par(1:5) with the values (0.0, 1.0, 1.55, 8.0, 0.04) and sets u(1:3) to 0.", "input": "", "output": " subroutine stpnt(ndim,u,par,t) \n!---------- ----- \n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   par(1:5)=(/0.0,1.0,1.55,8.,0.04/)\n\n   u(1:3)=0.\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named \"c_f_string_chars\" to convert a C-style string (array of characters) to a Fortran-style string. The subroutine should take 1 input parameter of type character(len=1,kind=c_char) and produce 1 output parameter of type character(len=*).", "input": "", "output": "subroutine c_f_string_chars(c_string, f_string)\n    ! helper function\n    use iso_c_binding\n    implicit none\n    character(len=1,kind=c_char), intent(in) :: c_string(*)\n    character(len=*), intent(out) :: f_string\n    integer :: i\n    i=1\n    do while(c_string(i)/=c_null_char .and. i<=len(f_string))\n        f_string(i:i) = c_string(i)\n        i=i+1\n    end do\n    if (i<=len(f_string)) f_string(i:) = ' '\nend subroutine c_f_string_chars\n"}, {"instruction": "Write a Fortran subroutine named get_final_integer that takes in a character string and returns an integer. The input parameter is 1 of type character, and the output parameter is 1 of type integer. This subroutine extracts an integer from a string by locating the integer following a \":\" and converts it to an integer value.", "input": "", "output": "  subroutine get_final_integer(string,num)\n    implicit none\n    character,intent(in) :: string*(132)\n    integer,intent(out) :: num\n    integer :: ibeg,iend,nsign,ntemp\n    character :: sub_string*(40)\n\n    iend=len(string) !get the length of the string\n    ibeg=index(string,\":\")+1 !get location of integer in string, follows \":\"\n    sub_string = adjustl(string(ibeg:iend)) ! get the characters beyond \":\"\n    iend=len(sub_string) !length of the sub-string\n    if(sub_string(1:1).eq.'-')then !check for negative sign\n       nsign=-1\n       ibeg=2\n    else\n       nsign=1\n       ibeg=1\n    endif\n    read (sub_string(ibeg:iend), '(i10)' ) ntemp !get integer values\n    ntemp=ntemp*nsign !apply sign to number\n\n    num=ntemp !return the integer value\n\n  end subroutine get_final_integer\n"}, {"instruction": "Create a Fortran subroutine named calc_vectorlength that takes a 3x3 matrix of real(8) as input and computes the Euclidean length of each column. The input parameter is a 3x3 matrix of real(8), and the output parameter is a 1D array of real(8) containing the lengths of each column.", "input": "", "output": "  subroutine calc_vectorlength( aa, aal )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: aal(3)\n    aal(1) = sqrt( sum(aa(1:3,1)**2) )\n    aal(2) = sqrt( sum(aa(1:3,2)**2) )\n    aal(3) = sqrt( sum(aa(1:3,3)**2) )\n  end subroutine calc_vectorlength\n"}, {"instruction": "Create a Fortran subroutine named calc_volume_lattice to calculate the volume of a lattice defined by a 3x3 matrix. The subroutine takes one input parameter of type real(8) and one output parameter of type real(8).", "input": "", "output": "  subroutine calc_volume_lattice( aa, va )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: va\n    va = aa(1,1)*aa(2,2)*aa(3,3)+aa(1,2)*aa(2,3)*aa(3,1) &\n        +aa(1,3)*aa(2,1)*aa(3,2)-aa(1,3)*aa(2,2)*aa(3,1) &\n        -aa(1,2)*aa(2,1)*aa(3,3)-aa(1,1)*aa(2,3)*aa(3,2)\n  end subroutine calc_volume_lattice\n"}, {"instruction": "Write a Fortran subroutine named mat_vec_mult to perform matrix-vector multiplication. The subroutine takes 4 input parameters: m (integer), n (integer), a (2D integer array of dimension m x n), and b (integer array of size n). It produces 1 output parameter: ab (integer array of size m). The subroutine uses the matmul function to compute the matrix-vector product.", "input": "", "output": "  subroutine mat_vec_mult(m,n,a,b,ab)\n    integer, intent(in) :: m,n, b(n)\n    integer, intent(in), dimension(m,n) :: a\n    integer, intent(out) :: ab(m)\n    ab = matmul(a,b)\n  end subroutine mat_vec_mult\n"}, {"instruction": "Create a Fortran subroutine named parrat_amplitude to calculate the reflectivity of a multilayer system using the Parratt formalism. The subroutine should have 6 input parameters of types ['double precision, dimension(nq)', 'complex*16, dimension(nlayers)', 'double precision, dimension(nlayers)', 'double precision, dimension(nlayers)', 'integer', 'integer'], and 1 output parameter of type ['complex*16, dimension(nq)'].", "input": "", "output": "    subroutine parrat_amplitude(q, sld, sigma, thickness, nlayers, nq, refl)\n        double precision, intent(in), dimension(nq) :: q\n        complex*16, intent(in), dimension(nlayers) :: sld\n        double precision, intent(in), dimension(nlayers) :: sigma, thickness\n        integer, intent(in):: nlayers, nq\n        complex*16, intent(out), dimension(nq) :: refl\n\n        integer :: iq, ir\n        \n        double precision :: k0, k02\n        complex*16 :: ksub, kj, knext, rnext, p2, refl_val\n\n        !$omp parallel\n        !$omp do\n        do iq=1,nq\n            k0 = q(iq)/2d0\n            k02= k0**2\n            \n            ksub = cdsqrt(k02 - 4d0*pi*sld(1))\n            kj = cdsqrt(k02 - 4d0*pi*sld(2))\n            refl_val = (kj-ksub)/(kj+ksub) * cdexp(-2d0*ksub*kj*sigma(1)**2)\n            do ir=2, nlayers-1\n                knext = cdsqrt(k02 - 4d0*pi*sld(ir+1))\n                rnext = (knext-kj)/(knext+kj)*cdexp(-2d0*knext*kj*sigma(ir)**2)\n                p2 = cdexp(2d0*ci*thickness(ir)*kj)\n                refl_val = (rnext + refl_val*p2) / ( 1 + rnext*refl_val*p2)\n                kj = knext\n            end do\n            refl(iq) = refl_val\n        end do\n        !$omp end do\n        !$omp end parallel\n    end subroutine parrat_amplitude\n"}, {"instruction": "Write a Fortran subroutine named scattering_matrix_translation to compute the scattering matrix for a given wave vector and thickness. The subroutine takes 2 input parameters of type complex*16 and double precision, and 1 output parameter of type complex*16 with a dimension of 2x2.", "input": "", "output": "    subroutine scattering_matrix_translation(k1, thickness, s)\n        complex*16, intent(in) :: k1\n        double precision, intent(in) :: thickness\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        s(1,1) = 0d0\n        s(1,2) = cdexp(-ci*thickness*k1)\n        s(2,1) = cdexp(-ci*thickness*k1)\n        s(2,2) = 0d0\n    end subroutine scattering_matrix_translation\n"}, {"instruction": "Create a Fortran subroutine named connect_scattering_matrices that takes two input parameters of type complex*16, dimension(2,2) and intent(in), named s1 and s2. It also has one output parameter of type complex*16, dimension(2,2) and intent(out), named s. This subroutine is designed to compute scattering matrices and performs complex computations to connect the input scattering matrices s1 and s2 and store the result in the output scattering matrix s.", "input": "", "output": "    subroutine connect_scattering_matrices(s1, s2, s)\n        complex*16, dimension(2,2), intent(in) :: s1, s2\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        complex*16 :: nominator\n        nominator = 1d0/(1d0 - s1(2,2)*s2(1,1))\n        s(1,1) = s1(1,1) + s1(1,2)*s2(1,1)*s1(2,1)*nominator\n        s(2,2) = s2(2,2) + s2(2,1)*s1(2,2)*s2(1,2)*nominator\n        s(2,1) = s1(2,1)*s2(2,1)*nominator\n        s(1,2) = s1(1,2)*s2(1,2)*nominator\n    end subroutine connect_scattering_matrices\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_v_i32_3d to allocate a 3D array using Kokkos. The subroutine takes 4 input parameters of type (c_ptr), integer (c_int), and allocates 2 output parameters of type (c_ptr).", "input": "", "output": "    subroutine f_kokkos_allocate_v_i32_3d(c_a, v_a, n_a, e0, e1, e2) &\n      & bind (c, name='c_kokkos_allocate_v_i32_3d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type (c_ptr), intent(out) :: c_a\n      type (c_ptr), intent(out) :: v_a\n      type (c_ptr), intent(in) :: n_a\n      integer (c_int), intent(in) :: e0\n      integer (c_int), intent(in) :: e1\n      integer (c_int), intent(in) :: e2\n    end subroutine f_kokkos_allocate_v_i32_3d\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_dv_i64_3d to allocate a three-dimensional array. It takes 4 input parameters of type (c_ptr), integer (c_int), integer (c_int), integer (c_int), and 2 output parameters of type (c_ptr), type (c_ptr). Use the \"bind\" attribute to bind the subroutine to a specific name.", "input": "", "output": "    subroutine f_kokkos_allocate_dv_i64_3d(c_a, v_a, n_a, e0, e1, e2) &\n      & bind (c, name='c_kokkos_allocate_dv_i64_3d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type (c_ptr), intent(out) :: c_a\n      type (c_ptr), intent(out) :: v_a\n      type (c_ptr), intent(in) :: n_a\n      integer (c_int), intent(in) :: e0\n      integer (c_int), intent(in) :: e1\n      integer (c_int), intent(in) :: e2\n    end subroutine f_kokkos_allocate_dv_i64_3d\n"}, {"instruction": "Create a Fortran subroutine named size that takes in 3 input parameters of type integer (l, m, n) and returns 3 output parameters of type integer (nnodes, ntet, ntface). The subroutine computes the number of nodes, tetrahedra, and triangular faces based on the input dimensions l, m, and n.", "input": "", "output": "  subroutine size(l,m,n, nnodes, ntet, ntface)\n\n    integer, intent(in) :: l,m,n\n    integer, intent(out) :: nnodes, ntet, ntface\n\n    continue\n\n    nnodes = l*m*n\n    ntet = 6*(l-1)*(m-1)*(n-1)\n    ntface=4*(l-1)*(m-1)+4*(m-1)*(n-1)+4*(n-1)*(l-1)\n  end subroutine size\n"}, {"instruction": "Create a Fortran subroutine named tridiagonal to solve a tridiagonal linear system using forward and backward substitution. The subroutine takes 4 input parameters of type real, dimension(:), and intent(in) for the tridiagonal coefficients (a, b, c) and the right-hand side vector (r). It returns 1 output parameter of type real, dimension(:), and intent(out) for the solution vector (x). The subroutine utilizes forward elimination and backward substitution to solve the tridiagonal system.", "input": "", "output": "    subroutine tridiagonal(a, b, c, x, r) \n        implicit none \n\n        real, dimension(:), intent(in)  :: a, b, c, r\n        real, dimension(:), intent(out) :: x \n\n        real, dimension(:), allocatable :: beta\n        integer                         :: i, nsize\n\n        ! initialization \n        nsize = size(b)\n        allocate(beta(nsize))\n\n        beta(1) = b(1) \n        x(1)    = r(1) \n\n        ! forward elimination of x_i  \n        do i = 2, nsize \n            beta(i) = b(i) - a(i) * c(i-1) / beta(i-1)\n            x(i)    = r(i) - a(i) * x(i-1) / beta(i-1)\n        end do \n\n        ! backward substitution \n        x(nsize) = x(nsize) / beta(nsize) \n        do i = nsize - 1, 1, -1 \n            x(i) = (x(i) - c(i) * x(i+1)) / beta(i)\n        end do \n\n        deallocate(beta)\n    end subroutine tridiagonal \n"}, {"instruction": "Create a Fortran subroutine named copy_int that takes one input argument of any data type and one output argument of any data type. The input argument is of type class(*) and is passed by intent(in), while the output argument is of type class(*) and is passed by intent(out). If the input argument is of type integer, then the value of the input argument is assigned to the output argument.", "input": "", "output": "  subroutine copy_int(a,b)\n    class(*), intent(in) :: a\n    class(*), intent(out) :: b\n    select type(a); type is(integer) \n    select type(b); type is(integer)\n      b = a\n    end select; end select\n  end subroutine copy_int \n"}, {"instruction": "Write a Fortran subroutine named maxt to calculate the phi values based on the input eflux, ezer, ener, del, nbins, itail, fmono, and emono. The number of input arguments is 8 and the test_data type is ['integer', 'integer', 'real', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "  subroutine maxt (eflux,ezer,ener,del,nbins,itail,fmono,emono,phi)\n\n    implicit none\n\n    integer,intent(in) :: nbins, itail\n    real,intent(in) :: eflux, ezer, ener(nbins), del(nbins), fmono, emono\n    real,intent(out) :: phi(nbins)\n\n    integer :: k\n    real :: te, b, phimax, erat\n\n    te = 0.\n\n    if (ezer < 500.) then\n      b = 0.8*ezer\n    else\n      b = 0.1*ezer + 350.\n    endif\n\n    phimax = exp(-1.)\n\n    do k=1,nbins\n      erat = ener(k) / ezer\n      if (erat > 60.) erat = 60.\n      phi(k) = erat * exp(-erat)\n      if (itail > 0) phi(k) = phi(k) + 0.4*phimax*(ezer/ener(k))*exp(-ener(k)/b)\n      te = te + phi(k) * del(k) * ener(k) * 1.6022e-12\n    enddo\n\n    do k=1,nbins\n      phi(k) = phi(k) * eflux / te\n    enddo\n\n    if (fmono > 0.) then\n      do k=1,nbins\n        if (emono > ener(k)-del(k)/2. .and. emono < ener(k)+del(k)/2.) &\n          phi(k)=phi(k)+fmono/(1.6022e-12*del(k)*ener(k))\n      enddo\n    endif\n\n    return\n\n  end subroutine maxt\n"}, {"instruction": "Create a Fortran subroutine named mean_molecular_weight to calculate the mean molecular weight. The subroutine takes 2 input parameters of type real(8) in arrays x(21) and m(21), and 1 output parameter of type real(8) named mm.", "input": "", "output": "        subroutine mean_molecular_weight(x, m, mm)\n                real(8), intent(in) :: x(21), m(21)\n                real(8), intent(out) :: mm\n                integer :: i\n\n                mm = 0\n                do i = 1, size(x)\n                mm = mm + x(i) * m(i)\n                end do\n                mm = mm / 1000 ! translate to kilograms\n        end subroutine mean_molecular_weight\n"}, {"instruction": "Write a Fortran subroutine named zeta that takes 2 input parameters of type real(8) and a 3x3 matrix of real(8) and returns 1 output parameter of type real(8). The function computes the value of z as 1.d0 plus the product of delta and the element of ar at the 2nd row and 1st column.", "input": "", "output": "   subroutine zeta(delta, ar, z)\n      real(8), intent(in) :: delta, ar(3, 3)\n      real(8), intent(out) :: z\n      z = 1.d0 + delta * ar(2, 1)\n   end subroutine zeta\n"}, {"instruction": "Create a Fortran subroutine named isochoric_heat to calculate the isochoric specific heat. The subroutine takes 4 input parameters of type real(8) (tau, r, ao(3, 3), ar(3, 3)) and 1 output parameter of type real(8) (cv).", "input": "", "output": "   subroutine isochoric_heat(tau, r, ao, ar, cv)\n      real(8), intent(in) :: tau, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: cv\n\n      cv = - tau ** 2.d0 * (ao(3, 2) + ar(3, 2))\n      cv = cv * r\n   end subroutine isochoric_heat\n"}, {"instruction": "Create a Fortran subroutine named isobaric_heat to calculate the isobaric heat capacity. The subroutine takes 5 input parameters of type real(8) (delta, tau, r, ao(3, 3), ar(3, 3)) and 1 output parameter of type real(8) (cp).", "input": "", "output": "   subroutine isobaric_heat(delta, tau, r, ao, ar, cp)\n      real(8), intent(in) :: delta, tau, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: cp\n      real(8) :: up, down\n\n      up = (1.d0 + delta * ar(2, 1) - delta * tau * ar(3, 3)) ** 2.d0\n      down = 1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2.d0 * ar(3, 1)\n\n      cp = - tau ** 2.d0 * (ao(3, 2) + ar(3, 2)) + up / down\n      cp = cp * r\n   end subroutine isobaric_heat\n"}, {"instruction": "Create a Fortran subroutine named isothermal_thermal_coefficent to calculate the isothermal thermal coefficient. The subroutine takes 4 input parameters of type real(8) - delta, tau, rho, and an array ar(3,3), and returns 1 output parameter of type real(8) - delta_t.", "input": "", "output": "   subroutine isothermal_thermal_coefficent(delta, tau, rho, ar, delta_t)\n      real(8), intent(in) :: delta, ar(3, 3), tau, rho\n      real(8), intent(out) :: delta_t\n      real(8) :: up, down\n\n      up = 1.d0 + delta * ar(2, 1) - delta * tau * ar(3, 3)\n      down = 1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 1)\n\n      delta_t = (1.d0 - up / down) / rho\n   end subroutine isothermal_thermal_coefficent\n"}, {"instruction": "Create a Fortran subroutine named dp_drho to calculate the value of dpdrho based on the input parameters. The subroutine has 4 input parameters of type real(8), and they are t, delta, r, and ar (a 3x3 matrix of real(8)). It also has 1 output parameter of type real(8) for the dpdrho value.", "input": "", "output": "   subroutine dp_drho(t, delta, r, ar, dpdrho)\n      real(8), intent(in) :: delta, r, t\n      real(8), intent(out) :: dpdrho\n      real(8), dimension(3, 3), intent(in) :: ar\n\n      dpdrho = r * t * (1.d0 + 2.d0 * delta * ar(2, 1) + (delta ** 2) * ar(3, 1))\n\n   end subroutine dp_drho\n"}, {"instruction": "Create a Fortran subroutine named gibbs_free_energy to calculate the Gibbs free energy using the provided parameters. The subroutine takes 5 input parameters of type real(8) - delta, r, t, ao(3, 3), ar(3, 3), and has 1 output parameter of type real(8) - g.", "input": "", "output": "   subroutine gibbs_free_energy(delta, r, t, ao, ar, g)\n      real(8), intent(in) :: delta, r, t, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: g\n\n      g = (1.d0 + ao(1, 1) + ar(1, 1) + delta * ar(2, 1)) * r * t\n   end subroutine gibbs_free_energy\n"}, {"instruction": "Write a Fortran subroutine named joule_thomson_coeff to calculate the Joule-Thomson coefficient. The subroutine takes 6 input parameters of type real(8) (delta, tau, rho, r, ao(3, 3), ar(3, 3)) and returns 1 output parameter of type real(8) (jt).", "input": "", "output": "   subroutine joule_thomson_coeff(delta, tau, rho, r, ao, ar, jt)\n      real(8), intent(in) :: delta, tau, rho, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: jt\n      real(8) :: up, down_1, down_2\n\n      up = - (delta * ar(2, 1) + delta ** 2 * ar(3, 1) + delta * tau * ar(3, 3))\n      down_1 = (1.d0 + delta * ar(2, 1) - delta * tau * ar (3, 3)) ** 2\n      down_2 = - tau ** 2 * (ao(3, 2) + ar(3, 2)) * (1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 1))\n\n      jt = up / (down_1 + down_2) / (r * rho * 1000)\n\n   end subroutine joule_thomson_coeff\n"}, {"instruction": "Create a Fortran subroutine named isentropic_exponent to compute the isentropic exponent (k) based on the input parameters delta, tau, ao(3,3), and ar(3,3). The input parameters are of type real(8) and intent in, while the output parameter k is of type real(8) and intent out.", "input": "", "output": "   subroutine isentropic_exponent(delta, tau, ao, ar, k)\n      real(8), intent(in) :: delta, tau, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: k\n      real(8) :: up1, down1, up2, down2\n\n      up1 = 1.d0 + 2 * delta * ar(2, 1) + delta ** 2 * ar(3, 1)\n      down1 = 1.d0 + delta * ar(2, 1)\n      up2 = (1.d0 + delta * ar(2, 1) - delta * tau * ar(2, 3)) ** 2\n      down2 = tau ** 2 * (ao(3, 2) + ar(2, 2)) * (1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 2))\n\n      k = (up1 / down1) * (1.d0 - up2 / down2)\n   end subroutine isentropic_exponent\n"}, {"instruction": "Write a Fortran subroutine named second_thermal_virial_coeff to calculate the second thermal virial coefficient. The subroutine should take 2 input parameters of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "   subroutine second_thermal_virial_coeff(rho_r, ar, b)\n      real(8), intent(in) :: rho_r, ar(3, 3)\n      real(8), intent(out) :: b\n      real(8) :: delta\n\n      delta = 1d-15\n      b = ar(2, 1) / rho_r\n   end subroutine second_thermal_virial_coeff\n"}, {"instruction": "Write a Fortran subroutine named third_thermal_virial_coeff to calculate the third thermal virial coefficient. The subroutine takes 2 input parameters of type real(8) and an array of size 3x3. It returns 1 output parameter of type real(8).", "input": "", "output": "   subroutine third_thermal_virial_coeff(rho_r, ar, c)\n      real(8), intent(in) :: rho_r, ar(3, 3)\n      real(8), intent(out) :: c\n      real(8) :: delta\n\n      delta = 1d-15\n      c = ar(3, 1) / (rho_r ** 2)\n   end subroutine third_thermal_virial_coeff\n"}, {"instruction": "Write a Fortran subroutine named \"first_order_upwind_real\" to calculate the first-order upwind scheme for a given set of input data. The subroutine takes 4 input parameters of types integer, real array of dimension llim, real, and integer. It produces 1 output parameter of type real array of dimension llim.", "input": "", "output": "   subroutine first_order_upwind_real(llim, f, del, sgn, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n\n      if (sgn == -1) then\n         istart = llim\n         iend = llim + n - 1\n      else\n         istart = llim + n - 1\n         iend = llim\n      end if\n\n      ! zero bc, 1st order accurate upwind\n      df(istart) = -f(istart) * sgn / del\n      do i = istart - sgn, iend, -sgn\n         df(i) = sgn * (f(i + sgn) - f(i)) / del\n      end do\n\n   end subroutine first_order_upwind_real\n"}, {"instruction": "Create a Fortran subroutine named fifth_order_upwind_complex to perform 5th order upwind differencing on complex arrays. The subroutine takes 4 input parameters of types integer, complex array of dimension llim, real, and integer. It also has 1 output parameter of type complex array of dimension llim. The subroutine implements a 5th order accurate upwind differencing scheme for complex arrays using the provided input parameters.", "input": "", "output": "   subroutine fifth_order_upwind_complex(llim, f, del, sgn, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      if (sgn == -1) then\n         istart = llim\n         iend = llim + n - 1\n      else\n         istart = llim + n - 1\n         iend = llim\n      end if\n\n      ! zero bc, 1st order accurate upwind\n      df(istart) = -f(istart) * sgn / del\n      ! zero bc, 3rd order accurate upwind\n      i = istart - sgn\n      df(i) = -sgn * (2.*f(i - sgn) + 3.*f(i) - 6.*f(i + sgn)) / (6.*del)\n      ! zero bc, 5th order accurate upwind\n      i = istart - 2 * sgn\n      df(i) = -sgn * (-3.*f(i - 2 * sgn) + 30.*f(i - sgn) + 20.*f(i) - 60.*f(i + sgn) + 15.*f(i + 2 * sgn)) / (60.*del)\n\n      ! 1st order accurate upwind\n      df(iend) = sgn * (f(iend + sgn) - f(iend)) / del\n      ! 3rd order accurate upwind\n      df(iend + sgn) = -sgn * (2.*f(iend) + 3 * f(iend + sgn) - 6.*f(iend + 2 * sgn) + f(iend + 3 * sgn)) / (6.*del)\n\n      ! 5th order accurate upwind\n      do i = istart - 3 * sgn, iend + 2 * sgn, -sgn\n         df(i) = -sgn * (-3.*f(i - 2 * sgn) + 30.*f(i - sgn) + 20.*f(i) - 60.*f(i + sgn) + 15.*f(i + 2 * sgn) - 2.*f(i + 3 * sgn)) &\n                 / (60.*del)\n      end do\n\n   end subroutine fifth_order_upwind_complex\n"}, {"instruction": "Write a Fortran subroutine named third_order_upwind_zed that calculates the third order accurate upwind scheme for a given set of input parameters. The number of input parameters is 9 and the test_data types are ['integer', 'integer', 'integer', 'complex, dimension(llim:)', 'real', 'integer', 'logical', 'complex, dimension(:)', 'complex, dimension(:)']. The number of output parameters is 1 and the test_data type is ['complex, dimension(llim:)'].\n\nThe subroutine takes as input the lower limit (llim), current segment (iseg), total number of segments (nseg), function values (f), grid spacing (del), sign (sgn), left boundary values (fl), right boundary values (fr), and a logical value indicating periodicity (periodic). It calculates the third order accurate upwind scheme and stores the results in the output array df.\n\nThe subroutine first determines the upper limit (ulim) based on the size of the input array f. Depending on the sign value, it sweeps through the array either from more positive to more negative or vice versa. It handles the boundary conditions and computes the appropriate values for df based on the upwind scheme formula. Finally, it calculates the values for df using a loop and stores them in the output array.\n\nEnsure that all input and output arrays are properly dimensioned and initialized before calling this subroutine.", "input": "", "output": "   subroutine third_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df)\n\n      implicit none\n\n      integer, intent(in) :: llim, iseg, nseg\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      logical, intent(in) :: periodic\n      complex, dimension(:), intent(in) :: fl, fr\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, istart, iend, ulim\n\n      ulim = size(f) + llim - 1\n      ! if sgn > 0, then stream speed is negative\n      ! so sweep from more positive to more negative zed\n      if (sgn > 0) then\n         if (iseg == nseg .and. .not. periodic) then\n            i = ulim\n            df(i) = -f(i) / del\n            i = ulim - 1\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*f(i + 1)) / (6.*del)\n         else\n            i = ulim\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*fr(1) + fr(2)) / (6.*del)\n            i = ulim - 1\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*f(i + 1) + fr(1)) / (6.*del)\n         end if\n         if (iseg == 1 .and. .not. periodic) then\n            i = llim\n            df(i) = (f(i + 1) - f(i)) / del\n         else\n            i = llim\n            df(i) = -(2.*fl(2) + 3 * f(i) - 6.*f(i + 1) + f(i + 2)) / (6.*del)\n         end if\n         istart = ulim\n         iend = llim\n      else\n         if (iseg == 1 .and. .not. periodic) then\n            i = llim\n            df(i) = f(i) / del\n            i = llim + 1\n            df(i) = (2.*f(i + 1) + 3.*f(i) - 6.*f(i - 1)) / (6.*del)\n         else\n            i = llim\n            df(i) = (2.*f(i + 1) + 3 * f(i) - 6.*fl(2) + fl(1)) / (6.*del)\n            i = llim + 1\n            df(i) = (2.*f(i + 1) + 3 * f(i) - 6.*f(i - 1) + fl(2)) / (6.*del)\n         end if\n         if (iseg == nseg .and. .not. periodic) then\n            i = ulim\n            df(i) = (f(i) - f(i - 1)) / del\n         else\n            i = ulim\n            df(i) = (2.*fr(1) + 3 * f(i) - 6.*f(i - 1) + f(i - 2)) / (6.*del)\n         end if\n         istart = llim\n         iend = ulim\n      end if\n\n      ! 3rd order accurate upwind\n      do i = istart - 2 * sgn, iend + sgn, -sgn\n         df(i) = -sgn * (2.*f(i - sgn) + 3 * f(i) - 6.*f(i + sgn) + f(i + 2 * sgn)) / (6.*del)\n      end do\n\n   end subroutine third_order_upwind_zed\n"}, {"instruction": "Write a Fortran subroutine named second_order_centered_real that calculates the second-order centered difference approximation for the derivative of a real-valued function. The number of input parameters is 3, with types ['integer', 'real, dimension(llim:)', 'real']. The number of output parameters is 1, with type ['real, dimension(llim:)'].\n\nThe subroutine takes in an integer llim, which represents the lower limit of the array indices, an array f with indices ranging from llim to the size of f, and a real number del representing the spacing between the points in the function. It then calculates the derivative of the function and stores it in the array df, which also has indices ranging from llim to the size of df.\n\nThe subroutine first sets the derivative at the lower and upper limits to zero. Then, using a for loop, it calculates the derivative at the remaining points using the second-order centered difference approximation. The derivative at each point is computed as the difference between the neighboring points divided by twice the spacing del.\n\nMake sure to call this subroutine with the appropriate input and output arguments to calculate the derivative of a real-valued function using the second-order centered difference approximation.", "input": "", "output": "   subroutine second_order_centered_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      df(istart) = f(istart + 1) / (2.*del)\n      df(iend) = -f(iend - 1) / (2.*del)\n\n      ! 2nd order accurate centered\n      do i = istart + 1, iend - 1\n         df(i) = (f(i + 1) - f(i - 1)) / (2.*del)\n      end do\n\n   end subroutine second_order_centered_real\n"}, {"instruction": "Create a Fortran subroutine named d2_3pt_real to compute the second derivative of a real, one-dimensional array using a 3-point finite difference formula. The subroutine takes two input parameters of type real, dimension(:), and one output parameter of type real, dimension(:). The number of input arguments is 2 and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(:)'].", "input": "", "output": "   subroutine d2_3pt_real(f, d2f, dr)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: f\n      real, dimension(:), intent(in) :: dr\n      real, dimension(:), intent(out) :: d2f\n\n      real :: a, b, c, d\n      integer :: i, n\n\n      n = size(f)\n\n      do i = 2, n - 1\n         a = 2./(dr(i - 1) * (dr(i) + dr(i - 1)))\n         b = -2./(dr(i - 1) * dr(i))\n         c = 2./(dr(i) * (dr(i) + dr(i - 1)))\n         d2f(i) = a * f(i - 1) + b * f(i) + c * f(i + 1)\n      end do\n      i = 1\n      a = (6.*dr(1) + 4.*dr(2) + 2.*dr(3)) &\n          / (dr(1) * (dr(1) + dr(2)) * (dr(1) + dr(2) + dr(3)))\n      b = -(4.*(dr(1) + dr(2)) + 2.*dr(3)) &\n          / (dr(1) * dr(2) * (dr(2) + dr(3)))\n      c = (4.*dr(1) + 2.*(dr(2) + dr(3))) &\n          / ((dr(2) + dr(1)) * dr(2) * dr(3))\n      d = -(4.*dr(1) + 2.*dr(2)) &\n          / ((dr(3) + dr(2) + dr(1)) * (dr(3) + dr(2)) * dr(3))\n      d2f(i) = a * f(1) + b * f(2) + c * f(3) + d * f(4)\n      i = n\n      a = -(4.*dr(n - 1) + 2.*dr(n - 2)) &\n          / (dr(n - 3) * (dr(n - 3) + dr(n - 2)) * (dr(n - 3) + dr(n - 2) + dr(n - 1)))\n      b = (4.*dr(n - 1) + 2.*(dr(n - 2) + dr(n - 3))) &\n          / (dr(n - 3) * dr(n - 2) * (dr(n - 2) + dr(n - 1)))\n      c = -(4.*(dr(n - 1) + dr(n - 2)) + 2.*dr(n - 3)) &\n          / (dr(n - 1) * dr(n - 2) * (dr(n - 2) + dr(n - 3)))\n      d = (6.*dr(n - 1) + 4.*dr(n - 2) + 2.*dr(n - 3)) &\n          / (dr(n - 1) * (dr(n - 1) + dr(n - 2)) * (dr(n - 1) + dr(n - 2) + dr(n - 3)))\n      d2f(i) = a * f(n - 3) + b * f(n - 2) + c * f(n - 1) + d * f(n)\n\n!     ! flag -- this is a hack\n!     ! do not anticipate needing 2nd derivatives\n!     ! at first and last grid points\n!     d2f(1) = d2f(2)\n!     d2f(n) = d2f(n-1)\n\n   end subroutine d2_3pt_real\n"}, {"instruction": "Write a Fortran subroutine named countlen to determine the number of characters in a string before the first \"space\" character is encountered. The subroutine takes 1 input parameter of type character (len=*) and returns 1 output parameter of type integer.", "input": "", "output": "subroutine countlen(string, strlen)\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! \n! name: countlen\n!\n! purpose: this routine receives a fortran string, and returns the number of \n!    characters in the string before the first \"space\" is encountered. it \n!    considers ascii characters 33 to 126 to be valid characters, and ascii \n!    0 to 32, and 127 to be \"space\" characters.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! \n\n   implicit none\n\n   ! arguments\n   character (len=*), intent(in) :: string\n   integer, intent(out) :: strlen\n\n   ! local variables\n   integer :: i, len_str, aval\n   logical :: space\n\n   space = .false.\n   i = 1\n   len_str = len(string)\n   strlen = len_str\n   do while ((i .le. len_str) .and. (.not. space))\n      aval = ichar(string(i:i))\n      if ((aval .lt. 33) .or. (aval .gt. 126)) then\n         strlen = i - 1\n         space = .true.\n      end if\n      i = i + 1\n   end do\nend subroutine countlen\n"}, {"instruction": "Write a Fortran subroutine named createlist to generate an array of real numbers based on the start value, a specified increment (delta), and the number of elements (num). The input parameters include 3 arguments of type real, real, and integer, and the output parameter is an array of real numbers with a dimension of num.", "input": "", "output": "subroutine createlist(start, delta, num, array)\n  implicit none\n  ! parameter\n  real, intent(in)    :: start\n  real, intent(in)    :: delta\n  integer, intent(in) :: num\n  real, intent(out) ,dimension(num) :: array\n\n  ! local\n  integer :: i \n  do i =1, num\n    array(i) = start + (i-1)*delta\n  end do   \n\nend subroutine createlist\n"}, {"instruction": "Create a Fortran subroutine named readnew to read data from a file. The subroutine takes 3 input parameters of type character(len=*), integer, and integer, and 3 output parameters of type real, each with dimensions nx and ny. The function reads the data from the file specified by fname and assigns it to the output arrays lats, lons, and array. If the file opening fails, it stops the program and displays an error message.", "input": "", "output": "subroutine readnew(fname, nx, ny, lats, lons, array)\n  implicit none\n  ! calling\n  character(len=*),intent(in) :: fname\n  integer, intent(in)         :: nx\n  integer, intent(in)         :: ny\n  real, intent(out) ,dimension(nx, ny) :: lats\n  real, intent(out) ,dimension(nx, ny) :: lons\n  real, intent(out) ,dimension(nx, ny) :: array\n\n  ! local\n  character(200)    :: errormg ! the message of fail opening   \n  integer           :: ierror  ! flag for allocate \n  open(100,file=fname, form='unformatted', iostat=ierror, iomsg=errormg)\n       read(100) lats\n       read(100) lons\n       read(100) array\n  ! check if writing data is successfule. \n  if(ierror /= 0) then\n    write(*,*) errormg\n    stop\n  end if\n  close(100)\nend subroutine readnew\n"}, {"instruction": "Create a Fortran subroutine named ind to determine the indices of the lon and lat values in the lons and lats arrays, respectively. The subroutine takes 6 input parameters of types integer, integer, real array with dimension nx, real array with dimension ny, real, and real. It returns 2 output parameters of type integer.", "input": "", "output": "subroutine ind(nx, ny, lons, lats, lon, lat, ix, iy)\n  implicit none\n  ! calling\n  integer, intent(in)   :: nx\n  integer, intent(in)   :: ny\n  real, intent(in), dimension(nx) :: lons\n  real, intent(in), dimension(ny) :: lats  \n\n  real, intent(in)  ::  lon\n  real, intent(in)  ::  lat\n\n  integer, intent(out) :: ix\n  integer, intent(out) :: iy\n\n  ! local\n   integer :: i \n\n   ix=0\n   iy=0  \n   do i=1,nx-1\n      if ( lons(i)<= lon .and. lons(i+1)> lon  ) then\n        ix=i\n        exit \n      end if   \n   end do  \n\n   do i=1,ny-1\n      if ( lats(i)<= lat .and. lats(i+1)> lat  ) then\n        iy=i\n        exit \n      end if   \n   end do \nend subroutine  ind\n"}, {"instruction": "Create a Fortran subroutine named get_commandline_option to retrieve the position and number of arguments for a specified command from the command line. The subroutine takes 1 input parameter of type character(len=*), and provides 2 output parameters of type integer.", "input": "", "output": "subroutine get_commandline_option(cmd,pos,nargs)\n   character(len=*),intent(in) :: cmd\n   integer,intent(out) :: pos\n   integer,intent(out) :: nargs\n   character(len=len_trim(cmd)) :: buf\n   character(len=2) :: x\n   integer :: i,j,n,cmdlen\n   pos = 0\n   nargs = 0\n   cmdlen = len_trim(cmd)\n   n = command_argument_count()\n   do i=1,n\n      call get_command_argument(i,buf)\n      if(cmd(1:cmdlen)==buf(1:cmdlen)) then\n         pos = i\n         do j=i+1,n\n            call get_command_argument(j,x)\n            if(x(1:2)=='--') return\n            nargs = nargs + 1\n         end do\n      end if\n   end do\nend subroutine get_commandline_option\n"}, {"instruction": "Write a Fortran subroutine named split to separate a string into individual words. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters: an integer representing the number of words and an array of characters containing the individual words.", "input": "", "output": "subroutine split(str,n,items)\n   character(len=*),intent(in) :: str\n   integer,intent(out) :: n\n   character(len=*),intent(out) :: items(:)\n   character(len=len(str)) :: line\n   integer :: i,p,c,limit\n   n = 0\n   line = str\n   limit = size(items)\n   do i=1,limit\n      line = adjustl(line)\n      p = index(line,' ')\n      if(p == 1) then\n         exit\n      else if(p == 0) then\n         c = len(line)\n      else\n         c = p-1\n      end if\n      items(i) = line(1:c)\n      line(1:c) = repeat(' ',c)\n      n = n + 1\n   end do\nend subroutine split\n"}, {"instruction": "Create a Fortran subroutine named ising to perform the Ising model simulation. This subroutine takes 5 input parameters of types ['integer (kind=4)', 'integer (kind=4)', 'integer (kind=4)', 'integer (kind=4)', 'real (kind=8)'] and 3 output parameters of types ['real (kind=8)', 'real (kind=8)', 'real (kind=8)']. The subroutine initializes a lattice and performs the Ising model simulation for a specified number of Monte Carlo steps. The output parameters m, chi, and c represent the magnetization, susceptibility, and specific heat, respectively.", "input": "", "output": "    subroutine ising(l, t, next_i, prev_i, mcs, m, chi, c)\n    implicit none\n    integer (kind=4),intent(in) :: l, mcs, next_i(l), prev_i(l)\n    real (kind=8), intent(in) :: t\n    real (kind=8), intent(out) :: m, chi, c\n    integer (kind=4):: lattice(l,l), i,j,k, delta_e, no_of_probes\n    real (kind=8) :: boltzmann_factor(5), e=0.0d0, m_k=0.0d0, magnetizations = 0.0d0, magnetizations2 = 0.0d0, energies=0.0d0,&\n             energies2=0.0d0, r\n\n    no_of_probes=(mcs-30000)/100\n    lattice = 1\n    \n    do i=-8,8,4\n        boltzmann_factor(i/4 + 3) = exp(-i / t)\n    end do\n\n    magnetizations = 0.0d0\n    magnetizations2 = 0.0d0\n    energies = 0.0d0\n    energies2 = 0.0d0\n    do k=1, mcs\n        do j=1, l\n            do i=1, l\n                delta_e = 2 * lattice(i,j) * (lattice(next_i(i),j) + lattice(prev_i(i),j) + &\n                                                lattice(i,next_i(j)) + lattice(i, prev_i(j)))\n                if (delta_e <= 0) then\n                    lattice(i,j) = -lattice(i,j)\n                else\n                    call random_number(r) \n                    if (r <= boltzmann_factor(delta_e/4 + 3)) then\n                        lattice(i,j) = -lattice(i,j)\n                    end if\n                end if\n            end do\n        end do\n\n        if ((30000 < k) .and. (mod(k,100)==0)) then\n            m_k = 0.0d0\n            e = 0.0d0\n            do j=1,l\n                do i=1,l\n                    m_k = m_k + lattice(i,j)\n                    e = e + lattice(i,j) * (lattice(next_i(i),j) + lattice(i,next_i(j)))\n                end do\n            end do\n            m_k = abs(m_k / l**2)\n            magnetizations = magnetizations + m_k\n            magnetizations2 = magnetizations2 + m_k**2\n            energies = energies + e\n            energies2 = energies2 + e**2\n        end if\n    end do\n    m = magnetizations / no_of_probes\n    chi = l**2 / t * (magnetizations2 - magnetizations**2 / no_of_probes)/no_of_probes\n    c = (energies2 - energies**2 / no_of_probes)/no_of_probes / l**2 / t**2    \n    end subroutine ising\n"}, {"instruction": "Write a Fortran subroutine named array_out to initialize two arrays. The subroutine should take 2 input arguments of type integer and 2 output arguments of type integer and integer array of size ny. The subroutine initializes the array x with the value 20 and array y with the value 30.", "input": "", "output": "  subroutine array_out(nx,ny,x,y)\n    integer, intent(in) :: nx,ny\n    integer, intent(out) :: x(nx)\n    integer, dimension(ny), intent(out) :: y\n    x = 20\n    y = 30\n  end subroutine  array_out\n"}, {"instruction": "Create a Fortran subroutine named set_occupied_orbitals that takes two input parameters of type integer, \"state\" and \"n\", and one output parameter of type integer, \"ia\". The subroutine sets the occupied orbitals based on the state and the number of orbitals, and stores the result in the \"ia\" array.", "input": "", "output": "    subroutine set_occupied_orbitals(state,ia,n)\n    integer,intent(in)::state,n\n    integer,intent(out)::ia(n)\n\n    integer i,isum\n\n    ia=0; isum=0\n    do i=1,n\n        if(btest(state,i-1))then\n            isum=isum+1\n            ia(isum)=i\n        endif\n    enddo\n    return\n\n    end subroutine set_occupied_orbitals\n"}, {"instruction": "Write a Fortran subroutine named sum_empty_slots_fs that takes 3 input parameters of type integer: bs, m, and ilist(m), and 1 output parameter of type integer: sume. The subroutine calculates the sume by counting the number of empty slots in an array ilist based on the bit pattern specified by bs.", "input": "", "output": "    subroutine sum_empty_slots_fs(bs,m,ilist,sume)\n    integer,intent(in)::bs,m,ilist(m)\n    integer,intent(out)::sume\n\n    integer i\n\n    sume=0\n    do i=1,m\n        if(.not.btest(bs,ilist(i)-1))then\n            sume=sume+1\n        endif\n    enddo\n    return\n\n    end subroutine sum_empty_slots_fs\n"}, {"instruction": "Create a Fortran subroutine named chk_sum_first_empty_slots_fs to check the status of slots in a given array. The subroutine takes 4 input parameters of type integer (bs, m, ilist(m), mfirste) and 1 output parameter of type logical (lfirste). This subroutine checks if the first mfirste slots are empty and the remaining slots are occupied.", "input": "", "output": "    subroutine chk_sum_first_empty_slots_fs(bs,m,ilist,mfirste,lfirste)\n    integer,intent(in)::bs,m,ilist(m),mfirste\n    logical,intent(out)::lfirste\n\n    integer i\n\n    lfirste=.false.\n    ! first mfirste slots should be empty\n    do i=1,mfirste \n        if(btest(bs,ilist(i)-1))return\n    enddo\n    ! the remaining should be occupied.\n    do i=1+mfirste,m\n        if(.not.btest(bs,ilist(i)-1))return\n    enddo\n    lfirste=.true.\n    return\n\n    end subroutine chk_sum_first_empty_slots_fs\n"}, {"instruction": "Create a Fortran subroutine named chk_i_in_list to check if an integer value exists in a given list. The subroutine takes 3 input parameters of type integer: l, m, and list(m), and 1 output parameter of type logical: linls.", "input": "", "output": "    subroutine chk_i_in_list(l,m,list,linls)\n    integer,intent(in)::l,m,list(m)\n    logical,intent(out)::linls\n\n    integer i\n\n    linls=.false.\n    do i=1,m\n        if(l==list(i))then\n            linls=.true.\n            return\n        endif\n    enddo\n    return\n\n    end subroutine chk_i_in_list\n"}, {"instruction": "Create a Fortran subroutine named get_nf90_symbol that takes a single input parameter of type character(len=*) and returns a single output parameter of type integer. The subroutine sets the integer output parameter to -999.", "input": "", "output": "   subroutine get_nf90_symbol(sym_name, ivalue)\n      character(len=*),      intent(in)  :: sym_name\n      integer,               intent(out) :: ivalue\n      ivalue = -999\n   end subroutine get_nf90_symbol\n"}, {"instruction": "Write a Fortran subroutine named extract to search for a specific tag in a list of tags and corresponding real values. The subroutine takes 4 input parameters of type character (of any length), real, character (of length 16), and integer respectively. It also has 2 output parameters of type real and integer. The subroutine's function is to search for a specific tag in the list of tags and return the corresponding real value and an error indicator. If the tag is found, the real value is assigned to the rval parameter, and ierr is set to 0; otherwise, ierr is set to 1 and rval is set to 0.0.", "input": "", "output": "  subroutine extract(tag,rval,rarr,tags,ntags,ierr)    \n    \n    character(len=*), intent(in)  :: tag\n    real, intent(out) :: rval\n    real, intent(in)  :: rarr(:)\n    character(len=16), intent(in)  :: tags(:)\n    integer, intent(in)  :: ntags\n    integer, intent(out) :: ierr\n    logical :: matched\n    integer :: i\n    \n    ierr = 1\n    matched = .false.\n    rval = 0.0 ! default if not found\n    over_tags: do i=1,min(ntags,size(tags))\n       if (trim(tags(i))==trim(adjustl(tag))) then\n          if (size(rarr) >= i) then\n             rval = rarr(i)\n             matched = .true.\n          endif\n          exit over_tags  ! only match first occurrence\n       endif\n    enddo over_tags\n    if (matched) ierr = 0\n    if (ierr.ne.0) print \"(a)\", &\n         ' error: could not find '//trim(adjustl(tag))//' in header'\n  end subroutine extract\n"}, {"instruction": "Write a Fortran subroutine named basisfuns to compute the basis functions for a given parameter value. The subroutine takes 4 input parameters: i (integer), uu (real), p (integer), u (real array), and outputs n (real array).", "input": "", "output": "subroutine basisfuns(i,uu,p,u,n)\n  implicit none\n  integer(kind=4), intent(in) :: i, p\n  real   (kind=8), intent(in) :: uu, u(0:i+p)\n  real   (kind=8), intent(out):: n(0:p)\n  integer(kind=4) :: j, r\n  real   (kind=8) :: left(p), right(p), saved, temp\n  n(0) = 1\n  do j = 1, p\n     left(j)  = uu - u(i+1-j)\n     right(j) = u(i+j) - uu\n     saved = 0\n     do r = 0, j-1\n        temp = n(r) / (right(r+1) + left(j-r))\n        n(r) = saved + right(r+1) * temp\n        saved = left(j-r) * temp\n     end do\n     n(j) = saved\n  end do\nend subroutine basisfuns\n"}, {"instruction": "Create a Fortran subroutine named dersbasisfuns to compute the derivatives of the basis functions for B-spline curves. The subroutine takes 5 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'real   (kind=8)', 'real   (kind=8)'], and 1 output parameter of type ['real   (kind=8)'].", "input": "", "output": "subroutine dersbasisfuns(i,uu,p,n,u,ders)\n  implicit none\n  integer(kind=4), intent(in) :: i, p, n\n  real   (kind=8), intent(in) :: uu, u(0:i+p)\n  real   (kind=8), intent(out):: ders(0:p,0:n)\n  integer(kind=4) :: j, k, r, s1, s2, rk, pk, j1, j2\n  real   (kind=8) :: saved, temp, d\n  real   (kind=8) :: left(p), right(p)\n  real   (kind=8) :: ndu(0:p,0:p), a(0:1,0:p)\n  ndu(0,0) = 1\n  do j = 1, p\n     left(j)  = uu - u(i+1-j)\n     right(j) = u(i+j) - uu\n     saved = 0\n     do r = 0, j-1\n        ndu(j,r) = right(r+1) + left(j-r)\n        temp = ndu(r,j-1) / ndu(j,r)\n        ndu(r,j) = saved + right(r+1) * temp\n        saved = left(j-r) * temp\n     end do\n     ndu(j,j) = saved\n  end do\n  ders(:,0) = ndu(:,p)\n  do r = 0, p\n     s1 = 0; s2 = 1;\n     a(0,0) = 1\n     do k = 1, n\n        d = 0\n        rk = r-k; pk = p-k;\n        if (r >= k) then\n           a(s2,0) = a(s1,0) / ndu(pk+1,rk)\n           d =  a(s2,0) * ndu(rk,pk)\n        end if\n        if (rk > -1) then\n           j1 = 1\n        else\n           j1 = -rk\n        end if\n        if (r-1 <= pk) then\n           j2 = k-1\n        else\n           j2 = p-r\n        end if\n        do j = j1, j2\n           a(s2,j) = (a(s1,j) - a(s1,j-1)) / ndu(pk+1,rk+j)\n           d =  d + a(s2,j) * ndu(rk+j,pk)\n        end do\n        if (r <= pk) then\n           a(s2,k) = - a(s1,k-1) / ndu(pk+1,r)\n           d =  d + a(s2,k) * ndu(r,pk)\n        end if\n        ders(r,k) = d\n        j = s1; s1 = s2; s2 = j;\n     end do\n  end do\n  r = p\n  do k = 1, n\n     ders(:,k) = ders(:,k) * r\n     r = r * (p-k)\n  end do\nend subroutine dersbasisfuns\n"}, {"instruction": "Create a Fortran subroutine named insertknot that takes 9 input parameters of types integer(kind=4) and real(kind=8), and 2 output parameters of type real(kind=8). The purpose of the code is to insert a knot into a B-spline curve. The subroutine uses the imperative tone to define the process of inserting the knot and modifying the control points.", "input": "", "output": "subroutine insertknot(d,n,p,u,pw,uu,k,s,r,v,qw)\n  implicit none\n  integer(kind=4), intent(in)  :: d\n  integer(kind=4), intent(in)  :: n, p\n  real   (kind=8), intent(in)  :: u(0:n+p+1)\n  real   (kind=8), intent(in)  :: pw(d,0:n)\n  real   (kind=8), intent(in)  :: uu\n  integer(kind=4), intent(in)  :: k, s, r\n  real   (kind=8), intent(out) :: v(0:n+p+1+r)\n  real   (kind=8), intent(out) :: qw(d,0:n+r)\n  integer(kind=4) :: i, j, idx\n  real   (kind=8) :: alpha, rw(d,0:p)\n  ! load new knot vector\n  forall (i = 0:k) v(i) = u(i)\n  forall (i = 1:r) v(k+i) = uu\n  forall (i = k+1:n+p+1) v(i+r) = u(i)\n  ! save unaltered control points\n  forall (i = 0:k-p) qw(:,i)   = pw(:,i)\n  forall (i = k-s:n) qw(:,i+r) = pw(:,i)\n  forall (i = 0:p-s) rw(:,i)   = pw(:,k-p+i)\n  ! insert the knot r times\n  do j = 1, r\n     idx = k-p+j\n     do i = 0, p-j-s\n        alpha = (uu-u(idx+i))/(u(i+k+1)-u(idx+i))\n        rw(:,i) = alpha*rw(:,i+1)+(1-alpha)*rw(:,i)\n     end do\n     qw(:,idx) = rw(:,0)\n     qw(:,k+r-j-s) = rw(:,p-j-s)\n  end do\n  ! load remaining control points\n  idx = k-p+r\n  do i = idx+1, k-s-1\n     qw(:,i) = rw(:,i-idx)\n  end do\nend subroutine insertknot\n"}, {"instruction": "Create a Fortran subroutine named tensorprod1 that takes 2 input parameters: an integer (kind=4) named ina and a 2D array of real numbers (kind=8) named in with dimensions (ina,0:4). It also has 5 output parameters: n0, n1, n2 (optional), n3 (optional), and n4 (optional), all of type real (kind=8). The subroutine computes the tensor product of the input array in and assigns the results to the output parameters n0, n1, n2, n3, and n4 based on the presence of each optional parameter. Use the imperative tone to specify these requirements when creating the subroutine.", "input": "", "output": "subroutine tensorprod1(ina,in,n0,n1,n2,n3,n4)\n  implicit none\n  integer(kind=4), intent(in)  :: ina\n  real   (kind=8), intent(in)  :: in(ina,0:4)\n  real   (kind=8), intent(out) :: n0(  ina)\n  real   (kind=8), intent(out) :: n1(1,ina)\n  real   (kind=8), intent(out), optional :: n2(    1,1,ina)\n  real   (kind=8), intent(out), optional :: n3(  1,1,1,ina)\n  real   (kind=8), intent(out), optional :: n4(1,1,1,1,ina)\n  integer(kind=4)  :: ia\n  do ia=1,ina\n     n0(ia) = in(ia,0)\n  end do\n  do ia=1,ina\n     n1(1,ia) = in(ia,1)\n  end do\n  if (.not. present(n2)) return\n  do ia=1,ina\n     n2(1,1,ia) = in(ia,2)\n  end do\n  if (.not. present(n3)) return\n  do ia=1,ina\n     n3(1,1,1,ia) = in(ia,3)\n  end do\n  if (.not. present(n4)) return\n  do ia=1,ina\n     n4(1,1,1,1,ia) = in(ia,3)\n  end do\nend subroutine tensorprod1\n"}, {"instruction": "Create a Fortran subroutine named evaluate0 to copy the elements of an input array pw to an output array cw. The subroutine has 2 input parameters: an integer array d and a real array pw of length d, and 1 output parameter: a real array cw of length d. Use the imperative tone in your instructions.", "input": "", "output": "subroutine evaluate0(d,pw,cw)\n  integer(kind=4), intent(in)  :: d\n  real   (kind=8), intent(in)  :: pw(d)\n  real   (kind=8), intent(out) :: cw(d)\n  cw = pw\nend subroutine evaluate0\n"}, {"instruction": "Create a Fortran subroutine named getgrid to generate a grid in the specified domain. The subroutine takes 5 input parameters of types integer(kind=4), integer(kind=4), real(kind=8), real(kind=8), and real(kind=8) and returns 5 output parameters of types real(kind=8) of dimension(1:nx), real(kind=8) of dimension(1:ny), complex(kind=8) of dimension(1:nx), complex(kind=8) of dimension(1:ny), and character*100. The subroutine uses OpenMP for parallelization and saves the grid points in text format.", "input": "", "output": "subroutine getgrid(nx,ny,lx,ly,pi,name_config,x,y,kx,ky)\n  use omp_lib\n  implicit none\n  integer(kind=4), intent(in)                           :: nx,ny\n  real(kind=8), intent(in)                              :: lx,ly,pi\n  real(kind=8), dimension(1:nx), intent(out)            :: x\n  real(kind=8), dimension(1:ny), intent(out)            :: y\n  complex(kind=8), dimension(1:nx), intent(out)         :: kx\n  complex(kind=8), dimension(1:ny), intent(out)         :: ky\n  character*100, intent(out)                            :: name_config\n  integer(kind=4)                                       :: i,j\n  !$omp parallel do private(i) schedule(static)\n  do i=1,1+nx/2\n     kx(i)= cmplx(0.0d0,1.0d0)*real(i-1,kind(0d0))/lx\n  end do\n  !$omp end parallel do\n  kx(1+nx/2)=0.0d0\n  !$omp parallel do private(i) schedule(static)\n  do i = 1,nx/2 -1\n     kx(i+1+nx/2)=-kx(1-i+nx/2)\n  end do\n  !$omp end parallel do\n\n  !$omp parallel do private(i) schedule(static)\n  do i=1,nx\n     x(i)=(-1.0d0 + 2.0d0*real(i-1,kind(0d0))/real(nx,kind(0d0)))*pi*lx\n  end do\n  !$omp end parallel do\n  !$omp parallel do private(j) schedule(static)\n  do j=1,1+ny/2\n     ky(j)= cmplx(0.0d0,1.0d0)*real(j-1,kind(0d0))/ly\n  end do\n  !$omp end parallel do\n  ky(1+ny/2)=0.0d0\n  !$omp parallel do private(j) schedule(static)\n  do j = 1,ny/2 -1\n     ky(j+1+ny/2)=-ky(1-j+ny/2)\n  end do\n  !$omp end parallel do\n  !$omp parallel do private(j) schedule(static)\n  do j=1,ny\n     y(j)=(-1.0d0 + 2.0d0*real(j-1,kind(0d0))/real(ny,kind(0d0)))*pi*ly\n  end do\n  !$omp end parallel do\n  ! save x grid points in text format\n  name_config = 'xcoord.dat'\n  open(unit=11,file=name_config,status=\"unknown\")\n  rewind(11)\n  do i=1,nx\n     write(11,*) x(i)\n  end do\n  close(11)\n  ! save y grid points in text format\n  name_config = 'ycoord.dat'\n  open(unit=11,file=name_config,status=\"unknown\")\n  rewind(11)\n  do j=1,ny\n     write(11,*) y(j)\n  end do\n  close(11)\nend subroutine getgrid\n"}, {"instruction": "Write a Fortran subroutine named calcenergy to calculate the potential energy of a system consisting of atoms in a given dimensional space. The number of input parameters is 3, with test data types ['integer', 'integer', 'real(8), dimension(0:natom-1, 0:dim-1)']. The number of output parameters is 1, with the test data type ['real(8)'].", "input": "", "output": "subroutine calcenergy(pos, penergy, dim, natom)\r\n    implicit none\r\n    integer, intent(in) :: dim, natom\r\n    real(8), intent(in), dimension(0:natom-1, 0:dim-1) :: pos\r\n    real(8), intent(out) :: penergy\r\n    real(8), dimension(dim) :: rij, posi\r\n    real(8) :: d2, id2, id6, id12\r\n    real(8) :: alpha\r\n    integer :: i, j\r\n    !alpha varies with system size\r\n    alpha = 0.0001 * dble(natom)**(-2./3.)\r\n    penergy = 0.\r\n    do i = 0, natom - 1\r\n        !store pos(i,:) in a temporary array for faster access in j loop\r\n        posi = pos(i,:)\r\n        do j = i + 1, natom - 1\r\n            rij = pos(j,:) - posi\r\n            d2 = sum(rij * rij)\r\n            id2 = 1. / d2            !inverse squared distance\r\n            id6 = id2 * id2 * id2    !inverse sixth distance\r\n            id12 = id6 * id6         !inverse twelvth distance\r\n            penergy = penergy + 4. * (id12 - id6)\r\n        enddo\r\n        !compute the single-body term\r\n        penergy = penergy + alpha * sum(posi * posi)\r\n    enddo\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named loadx to calculate a table of x-values based on a given density code. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 2, with test_data type ['integer', 'real,dimension(:)']. The subroutine calculates the x-values based on the density code, with very dense values at the nose, less dense on the forward airfoil, and much less dense on the aft airfoil.", "input": "", "output": "subroutine loadx(dencode,nx,x)\r\n! ------------------------------------------------------------------------------\r\n! purpose -calculates a table of x-values to be used for the output.\r\n!   they are very dense at the nose, less dense on the forward airfoil\r\n!   and much less dense on the aft airfoil.\r\n\r\nimplicit none\r\n  integer,intent(in):: dencode   ! density code: 1=sparse; 2=medium; 3=dense\r\n  integer,intent(out):: nx\r\n  real,intent(out),dimension(:):: x\r\n\r\n  real,parameter,dimension(26):: coarse = (/ 0.0,0.005,0.0075,0.0125,       &\r\n    0.025,0.05,0.075,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,          &\r\n    0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.0 /)\r\n  real,parameter,dimension(64):: medium = (/ 0.0, 0.0002, 0.0005, 0.001,    &\r\n    0.0015,0.002,0.005,0.01,0.015,0.02,0.03,0.04,0.05,0.06,0.08,0.10,0.12,  &\r\n    0.14,0.16,0.18,0.20,0.22,0.24,0.26,0.28,0.30,0.32,0.34,0.36,0.38,0.40,  &\r\n    0.42,0.44,0.46,0.48,0.50,0.52,0.54,0.56,0.58,0.60,0.62,0.64,0.66,0.68,  &\r\n    0.70,0.72,0.74,0.76,0.78,0.80,0.82,0.84,0.86,0.88,0.90,0.92,0.94,0.96,  &\r\n    0.97,0.98,0.99,0.995,1.0 /)\r\n  real,parameter,dimension(98):: fine = (/ 0.0, 0.00005, 0.0001, 0.0002,    &\r\n    0.0003, 0.0004, 0.0005, 0.0006, 0.0008, 0.0010, 0.0012, 0.0014, 0.0016, &\r\n    0.0018,0.002,0.0025,0.003,0.0035,0.004,0.0045,0.005,0.006,0.007,0.008,  &\r\n    0.009, 0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.018,0.02,0.025,0.03,  &\r\n    0.035,0.04,0.045,0.05,0.055,0.06,0.07,0.08,0.09,0.10,0.12,              &\r\n    0.14,0.16,0.18,0.20,0.22,0.24,0.26,0.28,0.30,0.32,0.34,0.36,0.38,0.40,  &\r\n    0.42,0.44,0.46,0.48,0.50,0.52,0.54,0.56,0.58,0.60,0.62,0.64,0.66,0.68,  &\r\n    0.70,0.72,0.74,0.76,0.78,0.80,0.82,0.84,0.86,0.88,0.90,0.92,0.94,0.95,  &\r\n    0.96,0.97,0.975,0.98,0.985,0.99,0.995,0.999,1.0 /)\r\n!  integer:: k\r\n!----------------------------------------------------------------------------\r\n  select case (dencode)\r\n      case (2)\r\n        nx=size(medium)\r\n        x(1:nx)=medium\r\n      case (3)\r\n        nx=size(fine)\r\n        x(1:nx)=fine\r\n      case default    ! dencode=1 and anything else (probably an accident)\r\n        nx=size(coarse)\r\n        x(1:nx)=coarse\r\n  end select\r\n  return\r\nend subroutine loadx   ! -------------------------------------------------------\r\n"}, {"instruction": "Write a Fortran subroutine named meanline2 to calculate the displacement and slope of the NACA 2-digit mean line. The subroutine takes 3 input parameters of type real (cmax, xmaxc) and real array x. It returns 2 output parameters of type real arrays ym and ymp.", "input": "", "output": "subroutine meanline2(cmax,xmaxc,x,ym,ymp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute displacement and slope of the naca 2-digit mean line.\r\n! note - e.g., a naca mean line 64 has cmax=0.06 and xmax=0.4\r\n! ref - eq 6.4, p.114 of abbott and von doenhoff\r\n\r\nimplicit none\r\n\r\n  real,intent(in):: cmax   ! max. camber as fraction of chord\r\n  real,intent(in):: xmaxc  ! fraction of chord where the camber is max.\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: ym,ymp\r\n\r\n  integer:: k,n\r\n  real:: slope,slope1,slope2\r\n  real:: theta\r\n!-------------------------------------------------------------------------------\r\n  slope1=2.0*cmax/xmaxc\r\n  slope2=-2.0*cmax/(1.0-xmaxc)\r\n  n=size(x)\r\n  do k=1,n\r\n    if (x(k) < xmaxc) then\r\n      theta=x(k)/xmaxc\r\n      slope=slope1\r\n    else\r\n      theta=(1.0-x(k))/(1.0-xmaxc)\r\n      slope=slope2\r\n    end if\r\n    ym(k)=theta*(2.0-theta)\r\n    ymp(k)=slope*(1.0-theta)\r\n  end do\r\n\r\n  ym(1:n)=cmax*ym(1:n)\r\n  return \r\nend subroutine meanline2   ! ---------------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named meanline6m to compute the displacement and slope of a modified six-series mean line for use with the 6A-series airfoil profiles. The subroutine should take 2 input parameters of type real and real, dimension(:), and return 2 output parameters of type real, dimension(:), and real, dimension(:).", "input": "", "output": "subroutine meanline6m(cl,x,ym,ymp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the displacement and slope of a modified six-series mean \r\n!   line as designed for use with the 6a-series profiles.\r\n! ref - p.210 of naca report 903 (larry loftin).\r\n! note - a is not an input variable; it is always 0.8 for this mean line.\r\n\r\nimplicit none\r\n\r\n  real,intent(in):: cl   ! the design lift coefficient\r\n \r\n  real,intent(in),dimension(:):: x   ! fraction of chord\r\n  real,intent(out),dimension(:):: ym   ! y-coor of meanline\r\n  real,intent(out),dimension(:):: ymp   ! dy/dx of mean line\r\n\r\n  real,parameter:: a = 0.8   ! chordwise extent of uniform loading 0<=a<=1\r\n  real,parameter:: zero=0.0, one=1.0, two=2.0, half=0.5, fourth=0.25\r\n  real,parameter:: pi=3.141592654, twopi=two*pi, eps= 1e-7\r\n\r\n  real:: amx\r\n  real:: g,h\r\n  integer:: k,n\r\n  real:: oma\r\n  real:: omx\r\n  real:: term1,term2, term1p,term2p\r\n  real:: teslope\r\n  real:: xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  ym(1:n)=zero\r\n  ymp(1:n)=zero\r\n\r\n  oma=one-a\r\n  teslope=-0.24521*cl\r\n\r\n  do k=1,n\r\n    xx=x(k)\r\n\r\n    if (xx<eps) then\r\n      ym(k)=zero\r\n      ymp(k)=zero\r\n      cycle\r\n    end if\r\n\r\n    omx= one-xx\r\n    if (omx < eps) then\r\n      ym(k)=zero\r\n      ymp(k)=teslope\r\n      cycle\r\n    end if\r\n\r\n    g=-(a*a*(half*log(a)-fourth)+fourth)/oma\r\n    h=g+(half*oma*oma*log(oma)-fourth*oma*oma)/oma\r\n\r\n    amx= a-xx\r\n    if (abs(amx) < eps) then\r\n      term1=zero\r\n      term1p=zero\r\n    else\r\n      term1=amx*amx*(two*log(abs(amx))-one)\r\n      term1p=-amx*log(abs(amx))\r\n    end if\r\n\r\n    term2=omx*omx*(one-two*log(omx))\r\n    term2p=omx*log(omx)\r\n\r\n    ym(k)=fourth*(term1+term2)/oma - xx*log(xx) + g - h*xx\r\n    ymp(k)=(term1p+term2p)/oma - one - log(xx) - h\r\n  end do\r\n\r\n  ym(1:n)=ym(1:n)*cl*0.97948/(twopi*(a+one))\r\n  ymp(1:n)=ymp(1:n)*cl*0.97948/(twopi*(a+one))\r\n\r\n  do k=1,n   ! this is the special treatment...\r\n    if (x(k) > 0.86) then      \r\n      ym(k)=teslope*(x(k)-1.0)\r\n      ymp(k)=teslope\r\n    end if\r\n  end do\r\n\r\n  return\r\nend subroutine meanline6m  ! ---------------------------------------------------\r\n"}, {"instruction": "Write a Fortran subroutine named thickness4 that computes the values of y, dy/dx, and d2y/dx2 at each point of x. It takes 2 input parameters of type real and real, dimension(:), and 3 output parameters of type real, dimension(:), real, dimension(:), optional, and real, dimension(:), optional.", "input": "", "output": "subroutine thickness4(toc,x,y,yp,ypp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the values of y, dy/dx, d2y/dx2 at each point of x\r\n\r\nimplicit none\r\n  real,intent(in):: toc\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: y\r\n  real,intent(out),dimension(:),optional:: yp\r\n  real,intent(out),dimension(:),optional:: ypp\r\n\r\n  real,parameter:: a0 =  0.2969\r\n  real,parameter:: a1 = -0.1260\r\n  real,parameter:: a2 = -0.3516, a22=a2+a2\r\n  real,parameter:: a3 =  0.2843, a33=a3+a3+a3\r\n  real,parameter:: a4 = -0.1015, a42=a4+a4, a44=a42+a42\r\n  integer:: k,n\r\n  real:: srx,xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  if (present(yp))  yp(1)=1e22\r\n  if (present(ypp)) ypp(1)=-1e22\r\n  do k=1,n    ! based on t/c=0.2\r\n    xx=x(k)\r\n    if (xx==0.0) then\r\n      y(k)=0.0\r\n      if (present(yp))   yp(k)=1e22\r\n      if (present(ypp)) ypp(k)=1e22\r\n    else\r\n      srx=sqrt(xx)\r\n      y(k)=a0*srx+xx*(a1+xx*(a2+xx*(a3+xx*a4)))\r\n      if (present(yp)) &\r\n        yp(k)=0.5*a0/srx + a1 + xx*(a22+xx*(a33+xx*a44))\r\n      if (present(ypp)) &\r\n        ypp(k)=-0.25*a0/(srx*srx*srx) + a22 + 6.0*xx*(a3+xx*a42)\r\n    end if\r\n  end do\r\n\r\n  y(1:n)=(5.0*toc)*y(1:n)       ! convert to correct t/c\r\n  if (present(yp)) yp(1:n)=(5.0*toc)*yp(1:n)\r\n  if (present(ypp)) ypp(1:n)=(5.0*toc)*ypp(1:n)\r\n\r\n  return\r\nend subroutine thickness4   ! --------------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named thickness4sharpte to compute the values of y, dy/dx, and d2y/dx2 at each point of x using an equation that generates an airfoil similar to the four-digit airfoil profile with a sharp trailing edge. The subroutine must take 2 input parameters of type real and real, dimension (:), and have 3 output parameters of type real, dimension (:), real, dimension (:), optional, and real, dimension (:), optional.", "input": "", "output": "subroutine thickness4sharpte(toc,x,y,yp,ypp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the values of y, dy/dx, d2y/dx2 at each point of x\r\n!   the equation used gives an airfoil that is very similar to the four digit\r\n!   airfoil profile, but has a sharp trailing edge.\r\n!  this airfoil does not have any naca blessing, so it is strictly unofficial.\r\n!  lots of folks want to compute a four-digit section, but are using a theory\r\n!  that assumes a zero trailing edge.\r\n\r\nimplicit none\r\n  real,intent(in):: toc\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: y\r\n  real,intent(out),dimension(:),optional:: yp\r\n  real,intent(out),dimension(:),optional:: ypp\r\n\r\n  real,parameter:: a0 =  0.2969\r\n  real,parameter:: a1 = -0.1260\r\n  real,parameter:: a2 = -0.3516, a22=a2+a2\r\n  real,parameter:: a3 =  0.2843, a33=a3+a3+a3\r\n  real,parameter:: a4 = -0.1036, a42=a4+a4, a44=a42+a42   ! slightly changed\r\n  integer:: k,n\r\n  real:: srx,xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  if (present(yp))  yp(1)=1e22\r\n  if (present(ypp)) ypp(1)=-1e22\r\n  do k=1,n    ! based on t/c=0.2\r\n    xx=x(k)\r\n    if (xx==0.0) then\r\n      y(k)=0.0\r\n      if (present(yp))   yp(k)=1e22\r\n      if (present(ypp)) ypp(k)=1e22\r\n    else\r\n      srx=sqrt(xx)\r\n      y(k)=a0*srx+xx*(a1+xx*(a2+xx*(a3+xx*a4)))\r\n      if (present(yp)) &\r\n        yp(k)=0.5*a0/srx + a1 + xx*(a22+xx*(a33+xx*a44))\r\n      if (present(ypp)) &\r\n        ypp(k)=-0.25*a0/(srx*srx*srx) + a22 + 6.0*xx*(a3+xx*a42)\r\n    end if\r\n  end do\r\n\r\n  y(1:n)=(5.0*toc)*y(1:n)       ! convert to correct t/c\r\n  if (present(yp)) yp(1:n)=(5.0*toc)*yp(1:n)\r\n  if (present(ypp)) ypp(1:n)=(5.0*toc)*ypp(1:n)\r\n\r\n  return\r\nend subroutine thickness4sharpte   ! -------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_count to retrieve the count of global vectors based on the provided gvec_id and rank. The subroutine should have 2 input parameters of type integer (gvec_id and rank) and 1 output parameter of type integer (gvec_count).", "input": "", "output": "        subroutine sddk_get_gvec_count(gvec_id, rank, gvec_count)&\n            &bind(c, name=\"sddk_get_gvec_count\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(in)  :: rank\n            integer,                 intent(out) :: gvec_count\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_offset to retrieve the offset of a global vector given its ID and rank. The subroutine should have 2 input parameters of type integer, gvec_id and rank, and 1 output parameter of type integer, gvec_offset.", "input": "", "output": "        subroutine sddk_get_gvec_offset(gvec_id, rank, gvec_offset)&\n            &bind(c, name=\"sddk_get_gvec_offset\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(in)  :: rank\n            integer,                 intent(out) :: gvec_offset\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named num2ch that takes a real number as input and returns a character string representing the number. The input parameter is of type real, intent(in), and there is one output parameter of type character(len=*), intent(out).", "input": "", "output": "subroutine num2ch(r,ch)\n implicit none\n real, intent(in):: r\n character(len=*), intent(out):: ch\n integer:: i,n,n2,nl,nc,nzero\n\n ch='';  n=int(r+0.01)\n nc=3; if(n > 99) nc=3\n nl=10**(nc-1)\n nzero=ichar('0')\n do i=1,nc\n   n2=n/nl\n   ch(i:i)=char(nzero+n2)\n   n=n-n2*nl\n   nl=nl/10\n enddo\nend subroutine num2ch\n"}, {"instruction": "Create a Fortran subroutine named iargsort that takes 3 input parameters of type integer, and 1 output parameter of type integer. The subroutine returns the indices that would sort an array. The input array 'a' contains the numbers, and the output array 'b' contains the indices into the array 'a' that would sort it. The option parameter determines the sorting order: 0 for no action, 1 for ascending order with -1 at the end, and 2 for descending order with -1 pushed to the end.", "input": "", "output": "subroutine iargsort(n, a, b, option)\n    ! returns the indices that would sort an array.\n    integer, intent(in):: n, option\n    integer, intent(in) :: a(n)  ! array of numbers\n    integer, intent(out) :: b(n) ! indices into the array 'a' that sort it\n    !\n    ! example\n    ! iargsort([10, 9, 8, 7, 6])   ! returns [5, 4, 3, 2, 1]\n\n    integer :: i,imin                      ! indices: i, i of smallest\n    integer :: temp                        ! temporary\n    integer :: n1, a2(n), t(n), ic\n    a2 = a\n    do i = 1, n\n        b(i) = i\n    end do\n    do i = 1, n-1\n        ! find ith smallest in 'a'\n        imin = minloc(a2(i:),1) + i - 1\n\n        ! swap to position i in 'a' and 'b', if not already there\n        if (imin /= i) then\n            temp = a2(i)\n            a2(i) = a2(imin)\n            a2(imin) = temp\n            temp = b(i)\n            b(i) = b(imin)\n            b(imin) = temp\n        end if\n    end do\n    \n    ! 0: do nothing\n    ! 1: ascending & (-1 at end), 2: descending & (-1 pushed to end)\n    if (option .eq. 2) then\n        t(:) = b(:)\n        do i = 0,n-1\n            b(i+1) = t(n-i)\n        enddo\n    endif\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named ishare_node to check if any of the given edges share a common node. The subroutine takes 3 input parameters of type integer: nb, edge(2), edges(2,nb). It also has 1 output parameter of type logical: iok.", "input": "", "output": "subroutine ishare_node(edge, nb, edges, iok)\n    implicit none \n    integer, intent(in) :: nb\n    integer, intent(in) :: edge(2),edges(2,nb)\n    logical, intent(out) :: iok\n    integer :: e1,e2\n    e1 = edge(1)\n    e2 = edge(2)\n    iok = .false.\n    if ( any(edges.eq.e1) .or. any(edges.eq.e2) ) then\n        iok = .true.\n    endif\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named is_adjacent_edge to determine if an edge is adjacent to a given set of edges. The subroutine takes 5 input parameters of type integer: nb0, na, edge(2), edges(2,nb0), dsg(na,na), and produces 1 output parameter of type logical: iok.", "input": "", "output": "subroutine is_adjacent_edge(edge, nb0, edges, na, dsg, iok)\n    implicit none\n    integer, intent(in) :: nb0, na\n    integer, intent(in) :: edge(2), edges(2,nb0), dsg(na,na)\n    logical, intent(out) :: iok\n!   logical :: istat\n    integer :: ib,nb,i1,i2,j1,j2, dsi(4)\n    i1 = edge(1)\n    i2 = edge(2)\n    iok = .false.\n    nb = count(edges.gt.0)/2 !size(edges,2)\n    if (nb .eq. 0) stop \"#error: empty `edges?\"\n    !call ishare_node(edge,nb,edges,istat)\n    !if (.not. istat) then\n    do ib = 1,nb\n        j1 = edges(1,ib)\n        j2 = edges(2,ib)\n        dsi(1) = dsg(i1,j1)\n        dsi(2) = dsg(i2,j2)\n        dsi(3) = dsg(i1,j2)\n        dsi(4) = dsg(i2,j1)\n        if ( all(dsi.ge.1) .and. any(dsi.eq.1) ) then\n            iok = .true.\n            exit\n        endif\n    enddo\n    !endif\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named g2triu1d to convert a molecular graph represented as a square matrix 'g' of size 'n' to a one-dimensional upper triangular matrix 'gr' of size 'nr'. The subroutine takes 3 input arguments of type integer: 'n' (size of the square matrix), 'nr' (size of the upper triangular matrix), and 'g' (the square matrix representing the molecular graph). It produces 1 output argument of type integer: 'gr' (the one-dimensional upper triangular matrix).", "input": "", "output": "subroutine g2triu1d(n,g, nr,gr)\n    !\n    ! molecular graph to triu(g) concatenated to 1d\n    !\n    implicit none \n    integer, intent(in) :: n, nr\n    integer, intent(in) :: g(n,n)\n    integer, intent(out) :: gr(nr)\n    integer :: i,j,ic\n    ic = 0\n    do i = 1,n-1\n        do j = i+1,n\n            ic = ic + 1\n            gr(ic) = g(i,j)\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mindex that takes two input arrays of integers and one output array of integers.The number of input arguments is 2 and the test_data type is [integer, integer].The number of output arguments is 1 and the test_data type is [integer].The subroutine computes the multi-index from a single index based on the dimensions provided in the input arrays. If the output array is smaller than required, it is filled with -999.", "input": "", "output": " subroutine mindex(ind,n,i)\n  implicit none\n  integer,intent(in) :: ind, n(:)\n  integer,intent(out) :: i(:)\n  integer :: j\n  if(size(i).gt.size(n)+1)then;i=-999;return;endif\n  i(1)=ind-1\n  do j=2,size(i)\n   i(j)=i(j-1)/n(j-1)\n   i(j-1)=i(j-1)-i(j)*n(j-1)\n  enddo\n  i=i+1\n end subroutine\n"}, {"instruction": "Create a Fortran subroutine named h5md_lookup to perform a binary search on a sorted array. The subroutine takes 2 input parameters of type integer and an array of integers and 1 output parameter of type integer and 1 output parameter of type logical. The input array and the value to be searched for are the input parameters, and the index of the found element and a logical flag indicating success are the output parameters.", "input": "", "output": "  subroutine h5md_lookup(list, wish, idx, success)\n    implicit none\n    integer, intent(in) :: list(:), wish\n    integer, intent(out) :: idx\n    logical, intent(out) :: success\n\n    integer :: low, up, i\n    integer, allocatable :: order_check(:)    \n    \n    success = .false.\n\n    if (size(list) .eq. 1) then\n       if (list(1) .eq. wish) then\n          success = .true.\n          idx = 1\n       end if\n       return\n    end if\n\n    allocate(order_check(size(list)-1))\n    order_check = list(2:size(list))-list(1:size(list)-1)\n    low = minval(order_check)\n    deallocate(order_check)\n    if (low <= 0) then \n       write(*,*) 'nonordered or repeating list in lookup'\n       return\n    end if\n\n    if ( wish < list(1) .or. wish > list(size(list)) ) then\n       write(*,*) wish, ' out of range in lookup'\n       stop\n    end if\n\n    low = 1\n    up = size(list)\n    lookup_loop: do\n       \n       i = (low+up)/2\n       if (list(i) >= wish) then\n          up =i\n       else\n          low=i\n       end if\n       if ( up-low .eq. 1 ) then\n          if (list(up).eq.wish) i=up\n          if (list(low).eq.wish) i=low\n          exit lookup_loop\n       end if\n    end do lookup_loop\n  \n    if (list(i).eq.wish) success=.true.\n    idx = i\n    \n  end subroutine h5md_lookup\n"}, {"instruction": "Create a Fortran subroutine named count_etot to calculate the total energy. It takes 2 input parameters: an integer numl and a 2D integer array spin of size numl x numl. It has 1 output parameter of type real, which is the total energy etot.", "input": "", "output": "subroutine count_etot(numl,spin,etot)\nimplicit none\ninteger,intent(in)  :: numl\ninteger,dimension(numl,numl),intent(in)  :: spin\nreal,intent(out) :: etot\netot = sum(spin)\nend subroutine count_etot\n"}, {"instruction": "Create a Fortran subroutine named randint that generates an array of random integers. The subroutine takes 1 input parameter of type integer and returns an array of random integers with the same size as the input parameter. The input parameter should be specified using the intent(in) attribute and the output parameter using the intent(out) attribute.", "input": "", "output": "  subroutine randint(x,maxint)\n    implicit none\n    integer, intent(out) :: x(:)\n    integer, intent(in) :: maxint\n    real(8) :: r(size(x))\n    call random_number(r)\n    x = int(maxint*r)\n    return\n  end subroutine randint\n"}, {"instruction": "Create a Fortran subroutine named minmod_kolgan to calculate the minimum of two real(8) input parameters and store the result in a separate real(8) output parameter. The subroutine should have 2 input parameters of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine minmod_kolgan(a, b, c)\n  implicit none\n  real(8), intent(in) :: a, b\n  real(8), intent(out) :: c\n\n  if (a==0.0 .or. b==0.0) then\n    c = 0.0\n  else if (a>0.0 .and. b>0.0) then\n    c = min(a,b)\n  else if (a<0.0 .and. b<0.0) then\n    c = max(a,b)\n  else\n    c = 0.0\n  end if\n\nend subroutine minmod_kolgan\n"}, {"instruction": "Create a Fortran subroutine named linearperiodic to calculate the pressure at a given time based on periodic linear loading. The subroutine takes 3 input parameters of type real*8: time, dt, and loadpar. It also has 1 output parameter of type real*8: p.", "input": "", "output": "subroutine linearperiodic(p,time,dt,loadpar) ! periodic load, linear periodic\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t,pmax0, dpmax, pmin0, dpmin\n\t\n\treal*8 :: di, trel, p0, p1\n\tinteger :: i\n\t\n\tt = loadpar(1)\n\tpmax0 = loadpar(2)\n\tdpmax = loadpar(3)\n\tpmin0 = loadpar(4)\n\tdpmin = loadpar(5)\n\t\t\n\tdi = dint(time/t)\n\ttrel = time - di*t\n\ti = int(di)\n\t\n\tif(mod(i,2) == 0) then ! even number\n\t\tp0 = pmin0 + dpmin*di\n\t\tp1 = pmax0 + dpmax*(di+1.0d0)\n\telse ! odd number\n\t\tp0 = pmax0 + dpmax*di\n\t\tp1 = pmin0 + dpmin*(di+1.0d0)\n\tend if\n\t\t\n\tp = p0 + (p1 - p0)*trel/t\n\t\n\twrite(0,*) \"pressure=\", p\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linearpressure to calculate the pressure at a given time based on a flexible load condition. The subroutine takes 3 input parameters of type real*8: time, dt, and loadpar. It also has 1 output parameter of type real*8: p. The pressure is calculated based on the linear change in load between specified time intervals.", "input": "", "output": "subroutine linearpressure(p,time,dt,loadpar) ! flexible load\n\t! p(t0) = 0 , p(t1) = pmax, linearly\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t0,t1, pmax\n\t\n\tpmax = loadpar(1)\n\tt0 = loadpar(2)\n\tt1 = loadpar(3)\n\t\n\tif(time<t1) then\n\t\tp = (time-t0)*pmax/(t1-t0)\n\telse \n\t\tp = pmax\n\tend if\n\t\n\twrite(0,*) \"pressure=\", p\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named adaptative to calculate the value of p based on the input parameters time, dt, and loadpar. The input parameters are of type real*8 and intent(in), and the output parameter p is of type real*8 and intent(out).", "input": "", "output": "subroutine adaptative(p,time,dt,loadpar) \n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: tf,lf,tm,kmin,kini , den, a1, a2, a3\n\n\ttf = loadpar(1)\n\tlf = loadpar(2)\n\ttm = loadpar(3)\n\tkmin = loadpar(4)\n\tkini = loadpar(5)\n\t\n\tden = 3.0d0*(tm**2.0d0)*tf**2.0d0 - 2.0d0*tm*tf**3.0d0\n\ta2 = (3.0d0*(tm**2.0d0)*(lf-kini*tf) - (tf**3.0d0)*(kmin - kini))/den\n\ta3 = (-2.0d0*tm*(lf-kini*tf) + (tf**2.0d0)*(kmin - kini))/den\n\ta1 = kini\n\t\n\tp = a1*time + a2*time**2.0 + a3*time**3.0\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linearramppressure to calculate the pressure at a given time considering a linear variation over time. The subroutine should take 3 input parameters of type real*8 and output 1 parameter of type real*8. The input parameters represent time, time increment, and an array of load parameters, while the output parameter represents the calculated pressure.", "input": "", "output": "subroutine linearramppressure(p,time,dt,loadpar) ! flexible load\n\t! p(t0) = p0 , p(t1) = p1, linearly\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t0,t1, p0, p1\n\t\n\tp0 = loadpar(1)\n\tp1 = loadpar(2)\n\tt0 = loadpar(3)\n\tt1 = loadpar(4)\n\n\tif(time<t0) then\n\t\tp = p0\t\n\telse if(time<t1) then\n\t\tp = p0 + (time-t0)*(p1-p0)/(t1-t0)\n\telse \n\t\tp = p1\n\tend if\n\t\n\twrite(0,*) \"pressure=\", p, p0, p1, t0, t1\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named count_lines to read a file and count the total number of lines and the number of non-comment lines. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "    subroutine count_lines( lun, lines, noncommentlines )\n    implicit none\n    integer, intent(in) :: lun\n    integer, intent(out) :: lines, noncommentlines\n    integer, parameter :: maxlines = 5000 !maximum number allowed\n    integer :: i\n    character(len=80) :: inline, shiftline\n    logical :: opened\n\n    intrinsic adjustl\n\n    !make sure the file is open\n    inquire( lun, opened=opened )\n    if (.not. opened) then\n        write(*,*) \"file is not open in count_lines\"\n        stop\n    endif\n\n    !now start reading\n    lines = 0\n    noncommentlines = 0\n    do i = 1, maxlines\n        read( lun, '(a)', err=2, end=100 ) inline\n        lines = lines + 1\n        shiftline = adjustl( inline )\n        if ( shiftline(1:1) .ne. '#' ) noncommentlines = noncommentlines+1\n    enddo\n    go to 100\n\n2   write(*,*) \"error reading input file in count_lines\"\n    stop\n\n100 rewind lun\n    end subroutine count_lines\n"}, {"instruction": "Create a Fortran subroutine named calcular_soluciones to read real numbers from a file and store them in an array. The subroutine takes 3 input parameters of types character (len=*), integer, and integer, and 1 output parameter of type real.\n", "input": "", "output": "subroutine calcular_soluciones(file, unit, n, canswer)\n   implicit none\n   \n   character (len=*), intent(in) :: file\n   integer, intent(in) :: unit, n\n   real, intent(out) :: canswer(n)\n\n   real :: num\n   integer :: i\n\n   open (unit=unit,file=file,status='old', form='formatted')\n\n   do i=1, n\n      read (unit=unit, fmt='(e11.6)' ) num\n      canswer(i) = num \n   end do\n\n   close(unit=unit)\nend subroutine calcular_soluciones\n"}, {"instruction": "Create a Fortran subroutine named calcular_nota to calculate the score based on the comparison of answers provided. The subroutine takes 3 input parameters of types real, character (len=500), and integer, and 1 output parameter of type character (len=2).", "input": "", "output": "subroutine calcular_nota(canswer, line, n, cnota)\n   implicit none\n   \n   real, intent(in) :: canswer(n)\n   character (len=500), intent(in) :: line\n   integer, intent(in) :: n\n   character (len=2), intent(out) :: cnota\n\n   integer :: nota, i, j\n   real :: answer(n)\n   character (len=7) :: mantisa(n)\n   integer :: nmantisa(n)\n   character (len=3) :: exponente(n)\n   integer :: nexponente(n)\n\n   nota = 0\n   cnota = ''\n   j = 40\n\n   do i=1, n\n      mantisa(i) = line(j+1:j+7) !respuesta1\n      mantisa(i) = trim(mantisa(i)) // '0000000'\n      read(mantisa(i),'(i7)') nmantisa(i)\n      \n      exponente(i) = line(j+8:j+10)\n      read(exponente(i),'(i3)') nexponente(i)\n         \n      answer(i) = real(nmantisa(i))*(10**real(nexponente(i)))/(10**5)\n         \n      j=j+10\n      \n      if(abs((answer(i) - canswer(i))/canswer(i)) < 10.**(-4.) ) then\n         nota = nota + 1 \n      else \n         nota = nota\n      end if\n   end do\n\n   write(cnota, '(i2)') nota\n\nend subroutine calcular_nota\n"}, {"instruction": "Write a Fortran subroutine named gvec_to_fft_index to convert a general vector to Fast Fourier Transform (FFT) index. The subroutine takes 2 input parameters of type integer, g(3) and nfft(3), and 1 output parameter of type integer, idx(3). The subroutine performs operations to adjust the indices based on the values in the input vectors g and nfft.", "input": "", "output": "  subroutine gvec_to_fft_index(g,idx,nfft)\n    integer, intent(in) :: g(3), nfft(3)\n    integer, intent(out) :: idx(3)\n    ! no push/pop since called too frequently.\n    idx(1:3) = g(1:3) + 1\n    if (g(1) < 0) idx(1) = nfft(1) + idx(1)\n    if (g(2) < 0) idx(2) = nfft(2) + idx(2)\n    if (g(3) < 0) idx(3) = nfft(3) + idx(3)\n    return\n  end subroutine gvec_to_fft_index\n"}, {"instruction": "Create a Fortran subroutine named ssm_title that takes an integer input and returns a 3-character zero-filled string. The input parameter is of type integer, and the output parameter is of type character with a length of 3.", "input": "", "output": "subroutine ssm_title(n,nchar)\n  ! returns integer as a 3-character zero-filled string\n  ! used to generate filenames for tables\n\n  implicit none\n  integer,intent(in)::n\n  character(len=3),intent(out)::nchar\n\n  character(len=1)::nchar1\n  character(len=2)::nchar2\n  character(len=3)::nchar3\n\n  if(n.ge.100)then\n     write(nchar3,'(i3)') n\n     nchar = nchar3\n  elseif(n.ge.10)then\n     write(nchar2,'(i2)') n\n     nchar = '0'//nchar2\n  else\n     write(nchar1,'(i1)') n\n     nchar = '00'//nchar1\n  endif\n\nend subroutine ssm_title\n"}, {"instruction": "Create a Fortran subroutine named \"untaggerxy_2d\" to compute an unstaggered grid using a given horizontally staggered grid. The subroutine should have 5 input parameters of type integer and real: vin, nx, ny, onx, and ony. It should have 1 output parameter of type real: vout. The subroutine should perform linear interpolation based on the input parameters and produce the unstaggered grid in vout. Use the provided code as a reference to implement the subroutine.", "input": "", "output": "subroutine untaggerxy_2d(vin,nx,ny,onx,ony,vout)\n\n!==========================================================\n!  this routine computes a unstagger grid \n!  using a given horizontal stagger grid \n!\n!  input:\n!\tvin:    stagger data prepare to unstagger \t\n!\tnx:\tnumber of stagger grid in x \n!\tny:     number of stagger grid in y\t\n!       onx:    x grid point number after unstagger\n!       ony:    y grid point number after unstagger  \n!\n!  output:\n!\tvout:   data after unstagger\t\n!\n!==========================================================\n\n  implicit none\n\n  integer, intent(in) :: nx,ny,onx,ony\n  real, intent(in) ::    vin(nx,ny)\n  real, intent(out) ::   vout(onx,ony)\n\n  ! local variables:\n    \n    integer :: i,j\n    real :: vinx(onx,ony),viny(onx,ony),vinyy(nx,ony)\n\n  ! linear interpolation:\n  \n    if(nx /= onx .and. ny /= ony) then \n\n          do i=1,nx\n             do j=2,ny\n                   vinyy(i,j) = &\n                   0.5*(vin(i,j-1)+ vin(i,j))\n             enddo\n             vinyy(i,1) = &\n                   1.5*vin(i,1)-&\n                   0.5*vin(i,2)\n             vinyy(i,ony) = &\n                   1.5*vin(i,ny)-&\n                   0.5*vin(i,ny-1)\n          enddo\n\n          do j=1,ony\n             do i=2,nx\n                vinx(i,j) = &\n                0.5*(vinyy(i-1,j)+ vinyy(i,j))\n             enddo\n             vinx(1,j) = &\n                1.5*vinyy(1,j)-&\n                0.5*vinyy(2,j)\n             vinx(onx,j) = &\n                1.5*vinyy(nx,j)-&\n                0.5*vinyy(nx-1,j)\n          enddo\n\n        vout(1:onx,1:ony) = vinx(1:onx,1:ony) \n      \n    elseif(nx /= onx .and. ny == ony) then\n\n          do j=1,ony\n             do i=2,nx\n                vinx(i,j) = &\n                0.5*(vin(i-1,j)+ vin(i,j))\n             enddo\n             vinx(1,j) = &\n                1.5*vin(1,j)-&\n                0.5*vin(2,j)\n             vinx(onx,j) = &\n                1.5*vin(nx,j)-&\n                0.5*vin(nx-1,j)\n          enddo\n\n        vout(1:onx,1:ony) = vinx(1:onx,1:ony)\n\n    elseif(nx == onx .and. ny /= ony) then\n\n          do i=1,onx\n             do j=2,ny\n                   viny(i,j) = &\n                   0.5*(vin(i,j-1)+ vin(i,j))\n             enddo\n             viny(i,1) = &\n                   1.5*vin(i,1)-&\n                   0.5*vin(i,2)\n             viny(i,ony) = &\n                   1.5*vin(i,ny)-&\n                   0.5*vin(i,ny-1)\n          enddo\n \n        vout(1:onx,1:ony) = viny(1:onx,1:ony)\n\n    endif\n \nend subroutine untaggerxy_2d \n"}, {"instruction": "Write a Fortran subroutine named extra_2_east to extrapolate 2 extra east (or north) points of a curve with Akima's 1D method. The subroutine takes 8 input parameters of type real(8): x1, x2, x3, x4, x5, y1, y2, and y3. It returns 2 output parameters of type real(8): y4 and y5.", "input": "", "output": "   subroutine extra_2_east(x1, x2, x3, x4, x5, y1, y2, y3, y4, y5)\n      !!\n      !!============================================================================\n      !!\n      !! extrapolates 2 extra east (or north) points of a curve with akima's 1d method\n      !!\n      !! input  : x1, x2, x3, x4, x5, y1, y2, y3\n      !! output : y4, y5\n      !!\n      !!                       author : laurent brodeau, 2007\n      !!============================================================================\n      !!\n      !!\n      real(8), intent(in)  :: x1, x2, x3, x4, x5, y1, y2, y3\n      real(8), intent(out) :: y4, y5\n      !!\n      !! local :\n      real(8) :: a, b, c, d, alf, bet\n      !!\n      !!\n      a    = x2 - x1\n      b    = x3 - x2\n      c    = x4 - x3\n      d    = x5 - x4\n      !!\n      alf  = y2 - y1\n      bet  = y3 - y2\n      !!\n      if ( (a == 0.).or.(b == 0.).or.(c == 0.) ) then\n         y4 = y3 ; y5 = y3\n      else\n         y4   = c*(2*bet/b - alf/a) + y3\n         y5   = y4 + y4*d/c + bet*d/b - alf*d/a - y3*d/c\n      end if\n      !!\n      !!\n   end subroutine extra_2_east\n"}, {"instruction": "Write a Fortran subroutine named \"locate_point\" that locates a point on a 2D grid. The subroutine takes 4 input parameters of type real(8), real(8), real(8), dimension(:,:), and real(8), dimension(:,:). It returns 2 output parameters of type integer. The subroutine should check the input point against the grid and return the indices of the grid where the point is located.", "input": "", "output": "   subroutine locate_point(rlon_p, rlat_p, xlon, xlat, jxfnd, jyfnd)\n\n      implicit none\n\n      !!===========================================================\n      !!\n      !! input :\n      !! rlon_p, rlat_p : point to be located\n      !! xlon, xlat : 2d arrays contening long. and lat.\n      !!\n      !! output :\n      !! jx, jy     : location\n      !!\n      !!\n      !! l. brodeau, 2005\n      !!===========================================================\n\n      real(8),                 intent(in)  :: rlon_p, rlat_p\n      real(8), dimension(:,:), intent(in)  :: xlon, xlat\n      integer,                 intent(out) :: jxfnd, jyfnd\n\n      !! local :\n      real(8), parameter :: dr = 30.    !! avoid problem at 0. -> 360. for lon\n      real(8), dimension(4) :: v4x, v4y\n      integer :: nx, ny, ji, jj\n      real(8) :: min_x, max_x, min_y, max_y\n\n      nx = size(xlon,1)\n      ny = size(xlon,2)\n\n      jxfnd = -1  ; jyfnd = -1\n\n      do jj=1, ny-1\n         do ji=1, nx-1\n\n            v4x   = (/ xlon(ji,jj) , xlon(ji+1,jj) , xlon(ji+1,jj+1) , xlon(ji,jj+1) /)\n            v4y   = (/ xlat(ji,jj) , xlat(ji+1,jj) , xlat(ji+1,jj+1) , xlat(ji,jj+1) /)\n\n            min_x = minval(v4x)  ;  max_x = maxval(v4x)\n            min_y = minval(v4y)  ;  max_y = maxval(v4y)\n\n            if ( ((rlon_p >= min_x).and.(rlon_p <= max_x)) .and. ( (max_x-min_x) < dr)  ) then\n               if ( (rlat_p >= min_y).and.(rlat_p <= max_y) ) then\n                  jxfnd = ji  ; jyfnd = jj\n               end if\n            end if\n\n         end do\n      end do\n\n   end subroutine locate_point\n"}, {"instruction": "Write a Fortran subroutine named find_mode_4d that takes 5 input parameters of type integer and integer arrays of dimensions naxis1, naxis2, naxis3, naxis4, and an output parameter of type integer array of dimensions naxis2, naxis3, naxis4. The subroutine reduces the first dimension of a four-dimensional array to the mode of that dimension for slices spanning that dimension at each point in the remaining dimensions.", "input": "", "output": "subroutine find_mode_4d(array_in,array_out,naxis1,naxis2,naxis3,naxis4)\n\n!reduces the first dimension of a four dimensional array to the mode of that\n!dimension for slices spanning that dimension at each point in the remaining dimensions\n\nimplicit none\n\n!variables with intent in\n!dimensions of the input array\ninteger, intent(in) :: naxis1, naxis2, naxis3, naxis4\n!input array\ninteger, intent(in), dimension(naxis1,naxis2,naxis3,naxis4) :: array_in\n\n!variables with intent out\n!output array\ninteger, intent(out), dimension(naxis2,naxis3,naxis4) :: array_out\n\n!local variables\n!list of counts of unique values found in a slice\ninteger, allocatable, dimension(:) :: unique_nums\n!highest number in the input array\ninteger :: max_num\n!counters\ninteger :: i,j,k,l\n    !assuming all values are non-negative this (+1) is the maximum number of elements\n    !the list of unique values requires\n    max_num = maxval(array_in)\n    !create a static list of counts of unique values and initialize to zero\n    allocate(unique_nums(max_num+1))\n    unique_nums = 0\n    !iterate over each point in all the dimensions other than the first\n    do l = 1,naxis4\n        do k = 1,naxis3\n            do j = 1,naxis2\n                !iterate over a slice of the first dimension\n                do i = 1,naxis1\n                    !ignore negative values\n                    if (array_in(i,j,k,l) < 0) cycle\n                    !increment count for this value of this element, add offset of 1 as count\n                    !of the value zero is held in position 1\n                    unique_nums(array_in(i,j,k,l) + 1) = unique_nums(array_in(i,j,k,l) + 1) + 1\n                end do\n                !allocate the value of this point in the output array as the highest count found\n                !in the list of unique values and then reset the array to 0 for the next cycle\n                array_out(j,k,l) = maxloc(unique_nums,1) - 1\n                unique_nums = 0\n            end do\n        end do\n    end do\n    deallocate(unique_nums)\nend subroutine find_mode_4d\n"}, {"instruction": "Create a Fortran subroutine named fstring_split to split a string into tokens based on given delimiters. The subroutine takes 2 input parameters of type character(*) and 1 output parameter of type character(*), which is allocatable.", "input": "", "output": "\tsubroutine fstring_split( str, tokens, delimiters )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(*), allocatable, intent(out) :: tokens(:)\n\t\tcharacter(*), intent(in) :: delimiters\n\t\t\n\t\tinteger, allocatable :: postokenbegin(:), postokenend(:)\n\t\tlogical :: isdelimiter, isdelimiterprev\n\t\tinteger :: ntokens\n\t\tinteger :: i, j\n\t\t\n\t\tif( allocated(tokens) ) then\n\t\t\tdeallocate(tokens)\n\t\tend if\n\t\t\n\t\tif( len(trim(str)) == 0 ) then\n\t\t\tallocate( tokens(1) )\n\t\t\ttokens(1) = str\n\t\t\treturn\n\t\tend if\n\t\t\n\t\t! en el peor de los casos todos los caracteres son separadores\n\t\tallocate( postokenbegin(len(str)) )\n\t\tallocate( postokenend(len(str)) )\n\t\t\n\t\tpostokenbegin = 0\n\t\tpostokenend = 0\n\t\t\n\t\t!! scan\n\t\tntokens = 1\n\t\tisdelimiterprev = .true.\n\t\tdo i=1,len(str)\n! \t\t\twrite(*,\"(3a)\",advance=\"no\") str(i:i)\n\t\t\t\n\t\t\tisdelimiter = .false.\n\t\t\tdo j=1,len(delimiters)\n\t\t\t\tif( str(i:i) == delimiters(j:j) ) then\n\t\t\t\t\tisdelimiter = .true.\n\t\t\t\t\texit\n\t\t\t\tend if\n\t\t\tend do\n\t\t\t\n\t\t\tif( isdelimiter .and. .not. isdelimiterprev ) then\n\t\t\t\tpostokenend( ntokens ) = i-1\n\t\t\t\tntokens = ntokens + 1\n! \t\t\t\twrite(*,*) \"    e\"\n\t\t\telse if( .not. isdelimiter .and. isdelimiterprev ) then\n\t\t\t\tpostokenbegin( ntokens ) = i\n! \t\t\t\twrite(*,*) \"    b\"\n! \t\t\telse\n! \t\t\t\twrite(*,*) \"\"\n\t\t\tend if\n\t\t\t\n\t\t\tisdelimiterprev = isdelimiter\n\t\tend do\n\t\t\n\t\tif( postokenend(ntokens) == 0 .and. .not. isdelimiter ) then\n\t\t\tpostokenend( ntokens ) = len( str )\n\t\telse\n\t\t\tntokens = ntokens - 1 \n\t\tend if\n\t\t\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"ntokens = \", ntokens\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"  begin = \", postokenbegin\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"    end = \", postokenend\n\t\t\n\t\tallocate( tokens(ntokens) )\n\t\t\n\t\tdo i=1,ntokens\n\t\t\ttokens(i) = str( postokenbegin(i):postokenend(i) )\n\t\tend do\n\t\t\n\t\tdeallocate( postokenbegin )\n\t\tdeallocate( postokenend )\n\t\t\n\tend subroutine fstring_split\n"}, {"instruction": "Create a Fortran subroutine named calc_gammagas to calculate the ionization potential and ionization energy of a gas mixture based on the temperature of electrons and ions. The subroutine takes 2 input parameters of type real(8), dimension(:) for electron temperature (te) and ion temperature (ti), and 1 output parameter of type real(8), dimension(size(te)) for the ionization potential-energy ratio (gammagas).", "input": "", "output": "    subroutine calc_gammagas(te, ti, gammagas)\n        real(8), intent(in), dimension(:) :: te,ti\n        real(8), intent(out), dimension(size(te)) :: gammagas\n        real(8), dimension(size(te)) :: the, thi, dxe, dxi, lne,lni, ge, gi, tratio\n\n        the = te*1.68636949d-10  \n        thi = ti*9.1842553d-10 ! ac might need to account for non-hydrogen plasma eventually\n\n        dxe = 2.5*the\n        dxi = 2.5*thi\n        where(dxe.le.1d-8) ! ac hacky log1p function -- import better?\n           lne = dxe*(1d0-0.5*dxe + dxe*dxe/3.- 0.25*dxe*dxe*dxe)\n        elsewhere\n           lne = log(1d0+dxe)\n        end where\n\n        where(dxi.le.1d-8) ! ac hacky log1p function -- import better?\n           lni = dxi*(1d0-0.5*dxi + dxi*dxi/3. - 0.25*dxi*dxi*dxi)\n        elsewhere\n           lni = log(1d0+dxi)\n        end where\n\n        ge = 1 + the/(3*the - 0.6*lne)\n        gi = 1 + thi/(3*thi - 0.6*lni)\n\n        tratio = ti/te\n        gammagas = 1. + (1. + tratio) / (1./(ge-1.) + tratio/(gi-1.)) \n    end subroutine calc_gammagas\n"}, {"instruction": "Write a Fortran subroutine named jet2bl_r that takes an array of real numbers x1 as input, and returns an array of real numbers r as output. The input array x1 has an unspecified size and the output array r has the same size as x1. The subroutine computes the values of r using a specific mathematical formula involving the elements of x1.", "input": "", "output": "    subroutine jet2bl_r(x1, r) \n        real, intent(in), dimension(:) :: x1\n        real, intent(out), dimension(size(x1)) :: r\n        real, dimension(size(x1)) :: x1scl \n\n        !ac todo put in correct hyperexponential behavior for large-radius\n        if(rbrk.lt.rmax) then\n            write(6,*) 'current jetcoords code only supports grids with no hyperexponential (rbrk>=rmax)!'\n            call exit(-1)\n        end if\n        x1scl = x1min + x1*(x1max-x1min) ! scale from (0,1) range to (x1min,x1max) range\n        r = exp(dble(x1scl)) + r0 \n    end subroutine jet2bl_r\n"}, {"instruction": "Create a Fortran subroutine named best to identify the \"best\" element in an array of real numbers. The subroutine should take in an array of real numbers as input, with the test_data type ['real, target']. The subroutine should have one output parameter of type real, pointer, with the test_data type ['real, pointer'].", "input": "", "output": "  subroutine best(p, a)\n    real, pointer, intent(out) :: p\n    real, target, intent(in) :: a(:)\n    ! find the \"best\" element of a(i)\n    p => a(i)\n    return\n  end subroutine best\n"}, {"instruction": "Create a Fortran subroutine named fill_gaps, which fills gaps in time series data. The subroutine takes 7 input parameters of type double precision, double precision, double precision, integer*8, integer*8, double precision array of length ln, and double precision array of length ln. It also has 3 output parameters of type integer*8, double precision array of length ln+nmd*2, and double precision array of length ln+nmd*2.\n\nThe subroutine fills in time and data gaps based on specified time interval and tolerance. The counter variable keeps track of the number of gap-filled values.", "input": "", "output": "subroutine fill_gaps(time, dt, tol, ai, ln, nmd, fillval, tn, dn,counter)\n   double precision, intent(in) :: fillval, dt, tol\n   integer*8, intent(in) :: ln, nmd\n   integer*8, intent(out) :: counter\n   double precision, intent(in), dimension(ln) :: ai, time\n   double precision, intent(out), dimension(ln+nmd*2) :: tn, dn\n   integer*8 :: i\n   double precision :: del\n   counter = 0\n   do i=1,ln\n      del = time(i+1) - time(i)\n      if (abs(del-dt) <= tol) then\n         dn(counter) = ai(i)\n         tn(counter) = time(i)\n         counter = counter + 1\n      else\n         do while (abs(time(i+1) - tn(counter-1)) > dt+tol)\n            if (tn(counter-1)+dt > time(i+1)) then\n               exit\n            else\n               tn(counter) = tn(counter-1)+dt\n               dn(counter) = fillval\n               counter = counter + 1\n            endif\n         enddo\n      endif\n   enddo\nend subroutine fill_gaps\n"}, {"instruction": "Create a Fortran subroutine named factorial to calculate the factorial of a given integer. The subroutine should have 1 input parameter of type integer and 1 output parameter of type integer. The input parameter represents the integer for which the factorial is to be calculated, and the output parameter stores the result of the factorial calculation.", "input": "", "output": "recursive subroutine factorial(n, result)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: result\ninteger :: temp\n\nif (n >= 1) then\n  call factorial(n-1, temp)\n  result = n * temp\nelse\n  result = 1\nend if\nend subroutine factorial\n"}, {"instruction": "Write a Fortran subroutine named fillrotationmatrix that takes two input parameters of type real*8, denoted as ra and dec. It also has one output parameter of type real*8, with dimension (3,3), denoted as a. This subroutine is designed to compute and fill a 3x3 rotation matrix based on the input right ascension (ra) and declination (dec) values using trigonometric functions.", "input": "", "output": "    subroutine fillrotationmatrix(ra, dec, a)\n\n        real*8, intent(in) :: ra, &\n                              dec\n        real*8, dimension(3, 3), intent(out) :: a\n        a(1,1) = dcos(ra) * dcos(dec)  \n        a(2,1) = dsin(ra) * dcos(dec)  \n        a(3,1) = dsin(dec)        \n\n        a(1,2) = - dsin(ra)\n        a(2,2) = dcos(ra)\n        a(3,2) = 0.d0\n\n        a(1,3) = - dcos(ra)*dsin(dec)\n        a(2,3) = - dsin(ra)*dsin(dec)\n        a(3,3) = dcos(dec)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp_vec to calculate the squared exponential kernel function for vectors. The subroutine takes 4 input parameters: np (integer), ndim (integer), xa (real(8) array), xb (real(8) array), and produces 1 output parameter: out (real(8) array). The subroutine utilizes the features of Fortran and utilizes the imperative tone.", "input": "", "output": "subroutine kern_sqexp_vec(np, ndim, xa, xb, out)\n    integer, intent(in) :: np, ndim\n    real(8), intent(in) :: xa(np,ndim), xb(ndim)\n    real(8), intent(out) :: out(np)\n\n    integer :: ka\n\n    !$omp simd\n    do ka = 1, np\n        out(ka) = exp(-sum((xa(ka, :) - xb)**2/2d0))\n    end do\n\nend subroutine kern_sqexp_vec\n"}, {"instruction": "Write a Fortran subroutine named kern_sqexp_vec_t to calculate the squared exponential kernel between two sets of vectors. The subroutine takes 4 input parameters of types integer, integer, real(8) array, and real(8) array. It also has 1 output parameter of type real(8). The subroutine uses OpenMP SIMD directive for parallel execution.", "input": "", "output": "subroutine kern_sqexp_vec_t(np, ndim, xa, xb, out)\n  integer, intent(in) :: np, ndim\n  real(8), intent(in) :: xa(ndim, np), xb(ndim)\n  real(8), intent(out) :: out(np)\n\n  integer :: ka\n\n  !$omp simd\n  do ka = 1, np\n      out(ka) = exp(-sum((xa(:, ka) - xb)**2/2d0))\n  end do\n\nend subroutine kern_sqexp_vec_t\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp_1d to compute the squared exponential kernel for one-dimensional data. The subroutine should take 3 input parameters of types integer, real(8) array, and real(8), and 1 output parameter of type real(8) array.", "input": "", "output": "subroutine kern_sqexp_1d(np, xa, xb, out)\n    integer, intent(in) :: np\n    real(8), intent(in) :: xa(np), xb\n    real(8), intent(out) :: out(np)\n\n    out = exp(-(xa - xb)**2/2d0)\n\nend subroutine kern_sqexp_1d\n"}, {"instruction": "Create a Fortran subroutine named kern_one_1d that takes 3 input parameters: an integer np, an array of real(8) xa of length np, and a single real(8) value xb. It also has 1 output parameter, an array of real(8) out of length np. The subroutine initializes the out array to 1d0.", "input": "", "output": "subroutine kern_one_1d(np, xa, xb, out)\n  integer, intent(in) :: np\n  real(8), intent(in) :: xa(np), xb\n  real(8), intent(out) :: out(np)\n\n  out = 1d0\n\nend subroutine kern_one_1d\n"}, {"instruction": "Write a Fortran subroutine named kern_sqexp_vec2 to calculate the squared exponential kernel given two sets of input data. The number of input arguments is 4 and the test_data type is ['integer*4', 'integer*4', 'real*8, dimension(1:nd, 1:nx)', 'real*8, dimension(1:nd, 1:nx)']. The number of output arguments is 1 and the test_data type is ['real*8, dimension(1:nd, 1:nx)'].", "input": "", "output": "subroutine kern_sqexp_vec2(nd, nx, x0, x1, out)\nimplicit none\ninteger*4, intent(in) :: nd\ninteger*4, intent(in) :: nx\nreal*8, intent(in), dimension(1:nd, 1:nx) :: x0\nreal*8, intent(in), dimension(1:nd, 1:nx) :: x1\nreal*8, intent(out), dimension(1:nd, 1:nx) :: out\ninteger*4 :: kd\ninteger*4 :: kx\ndo kx = 1, nx\n   do kd = 1, nd\n      out(kd, kx) = exp(-0.5d0*(-x0(kd, kx) + x1(kd, kx))**2)\n   end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"mulkernel_loop32\" to perform matrix multiplication. The subroutine takes 2 input parameters of type real(8) and dimension (16,32) and real(8) and dimension (32,14). It has 1 output parameter of type real(8) and dimension (16,14). The subroutine multiplies and accumulates the elements of the input arrays to compute the elements of the output array.", "input": "", "output": "subroutine mulkernel_loop32(d, a, x)\n    real(8), dimension(16,32),  intent(in)  :: a\n    real(8), dimension(32,14),  intent(in)  :: x\n    real(8), dimension(16,14),  intent(out) :: d\n    integer                                 :: i\n\n    d(1:16,1)  = a(1:16,1) * x(1,1)\n    d(1:16,2)  = a(1:16,1) * x(1,2)\n    d(1:16,3)  = a(1:16,1) * x(1,3)\n    d(1:16,4)  = a(1:16,1) * x(1,4)\n    d(1:16,5)  = a(1:16,1) * x(1,5)\n    d(1:16,6)  = a(1:16,1) * x(1,6)\n    d(1:16,7)  = a(1:16,1) * x(1,7)\n    d(1:16,8)  = a(1:16,1) * x(1,8)\n    d(1:16,9)  = a(1:16,1) * x(1,9)\n    d(1:16,10) = a(1:16,1) * x(1,10)\n    d(1:16,11) = a(1:16,1) * x(1,11)\n    d(1:16,12) = a(1:16,1) * x(1,12)\n    d(1:16,13) = a(1:16,1) * x(1,13)\n    d(1:16,14) = a(1:16,1) * x(1,14)\n\n    do i = 2, 32\n        d(1:16,1)  = d(1:16,1)  + a(1:16,i) * x(i,1)\n        d(1:16,2)  = d(1:16,2)  + a(1:16,i) * x(i,2)\n        d(1:16,3)  = d(1:16,3)  + a(1:16,i) * x(i,3)\n        d(1:16,4)  = d(1:16,4)  + a(1:16,i) * x(i,4)\n        d(1:16,5)  = d(1:16,5)  + a(1:16,i) * x(i,5)\n        d(1:16,6)  = d(1:16,6)  + a(1:16,i) * x(i,6)\n        d(1:16,7)  = d(1:16,7)  + a(1:16,i) * x(i,7)\n        d(1:16,8)  = d(1:16,8)  + a(1:16,i) * x(i,8)\n        d(1:16,9)  = d(1:16,9)  + a(1:16,i) * x(i,9)\n        d(1:16,10) = d(1:16,10) + a(1:16,i) * x(i,10)\n        d(1:16,11) = d(1:16,11) + a(1:16,i) * x(i,11)\n        d(1:16,12) = d(1:16,12) + a(1:16,i) * x(i,12)\n        d(1:16,13) = d(1:16,13) + a(1:16,i) * x(i,13)\n        d(1:16,14) = d(1:16,14) + a(1:16,i) * x(i,14)\n    end do\n\nend subroutine mulkernel_loop32\n"}, {"instruction": "Create a Fortran subroutine named get_simsize that retrieves simulation size parameters and performs MPI sanity checks. The subroutine takes 1 input parameter of type integer, optional, and returns 3 output parameters of type integer. The subroutine is responsible for retrieving simulation size parameters from command line arguments and performing MPI sanity checks to ensure the input parameters are within valid ranges.", "input": "", "output": "subroutine get_simsize(lx1, lx2, lx3, nmpi)\n\ninteger, intent(out) :: lx1, lx2, lx3\ninteger, intent(in), optional :: nmpi\n\ninteger :: i, argc\ncharacter(9) :: buf\n\nlx1 = -1\nlx2 = -1\nlx3 = -1\n\nargc = command_argument_count()\nif(argc < 4) error stop \"must input at least: -lx lx1 lx2 lx3\"\n\ndo i = 1,argc-3\n\ncall get_command_argument(i, buf)\nselect case (buf)\n  case (\"-lx\")\n    call get_command_argument(i+1, buf)\n    read(buf, '(i9)') lx1\n    call get_command_argument(i+2, buf)\n    read(buf, '(i9)') lx2\n    call get_command_argument(i+3, buf)\n    read(buf, '(i9)') lx3\nend select\n\nend do\n\nif (any([lx1, lx2] < 1)) error stop \"must input -lx lx1 lx2 lx3\"\n\nif(.not.present(nmpi)) return\n\n!> mpi sanity check\nif (nmpi > lx2) error stop \"too many mpi workers\"\nif (modulo(lx2, nmpi) /= 0) error stop \"number of mpi workers must evenly divide problem size.\"\n\nend subroutine get_simsize\n"}, {"instruction": "Write a Fortran subroutine named set_displ to help in setting displacement and receive counts for an allgatherv operation for varying num. The subroutine takes 2 input parameters with test_data type ['integer', 'integer'] and 2 output parameters with test_data type ['integer, dimension(0:nprocs-1)', 'integer, dimension(0:nprocs-1)'].", "input": "", "output": "      subroutine set_displ(nprocs, num, rcnts, displ)\n!-----------------------------------------------------------------------\n!     helper function to set displacement and receive counts for an\n!     allgatherv operation for varying num\n!-----------------------------------------------------------------------\n      implicit none\n      integer, intent(in) :: nprocs, num\n      integer, dimension(0:nprocs-1), intent(out) :: displ, rcnts\n\n      integer :: n, offset\n\n      offset = 0 \n      do n = 0, nprocs-1\n         rcnts(n) = num\n         displ(n) = offset \n         offset = offset + num\n      end do\n\n      end subroutine set_displ\n"}, {"instruction": "Create a Fortran subroutine named insertionsort to sort an array of integers in ascending order. The subroutine takes 2 input parameters of type integer array and 1 output parameter of type integer array. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": " subroutine insertionsort( inarray, outarray, n )\n ! s/r insertionsort\n !\n !   sorts array from smallest to largest. \n ! =============================================================================================== !\n ! declarations\n   implicit none\n   integer, intent(in)  :: n\n   integer, intent(in)  :: inarray(1:n)\n   integer, intent(out) :: outarray(1:n)\n   ! local\n   integer :: i, j\n   integer :: temp\n\n    outarray = inarray\n\n    do i = 2,  n\n       j = i\n       do while( j > 1 .and. outarray(j-1) > outarray(j) )\n          !swap outarray(j) outarray(j-1)\n          temp          = outarray(j)\n          outarray(j)   = outarray(j-1)\n          outarray(j-1) = temp \n        \n          j = j-1\n       enddo\n    enddo\n\n end subroutine insertionsort\n"}, {"instruction": "Write a Fortran subroutine named modela_function to assign the value of an input real number to an output real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "subroutine modela_function(in_val, out_val)\n  real, intent(in) :: in_val\n  real, intent(out) :: out_val\n  out_val = in_val\n  print *, \"modela_function(\", in_val, \") = \", out_val\nend subroutine modela_function\n"}, {"instruction": "Create a Fortran subroutine named divvec. It takes 4 input parameters: neqns (integer), ndeg (integer), r (real(8) array), part (integer array). It also has 3 output parameters: r1 (real(8) array), r2 (real(8) array), rd (real(8) array). The subroutine divides the input vector r into three separate vectors r1, r2, and rd based on the values in the part array.", "input": "", "output": "subroutine divvec(neqns, ndeg, part, r, r1, r2, rd)\n\nimplicit none\n\ninteger, intent(in) :: neqns, ndeg\nreal(8), dimension(:), intent(in)  :: r    ! original right hand side vector\ninteger, dimension(:), intent(in)  :: part ! belonging of each element in large matrix\n\nreal(8), dimension(:), intent(out) :: r1\nreal(8), dimension(:), intent(out) :: r2\nreal(8), dimension(:), intent(out) :: rd\n\ninteger :: idx1, idx2, idxd, idxr\ninteger :: i\n\nidx1=1\nidx2=1\nidxd=1\nidxr=1\ndo i=1,neqns\n   if(part(i).eq.1) then\n     r1(idx1:idx1+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idx1=idx1+ndeg\n     idxr=idxr+ndeg\n   endif\n   if(part(i).eq.2) then\n     r2(idx2:idx2+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idx2=idx2+ndeg\n     idxr=idxr+ndeg\n   endif\n   if(part(i).eq.3) then\n     rd(idxd:idxd+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idxd=idxd+ndeg\n     idxr=idxr+ndeg\n   endif\nend do\n\nend subroutine divvec\n"}, {"instruction": "Write a Fortran subroutine named inv_3x3 to compute the inverse of a 3x3 matrix. The input parameter is a 3x3 real*8 matrix, and the output parameter is the inverse 3x3 real*8 matrix.", "input": "", "output": "subroutine inv_3x3(a,ainv)\n  implicit none\n  real*8, intent(in)  :: a(3,3)\n  real*8, intent(out) :: ainv(3,3)\n  ! locals\n  real*8 :: det\n  det = a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1) + a(1,3)*a(2,1)*a(3,2) &\n      - a(3,1)*a(2,2)*a(1,3) - a(1,1)*a(3,2)*a(2,3) - a(2,1)*a(1,2)*a(3,3)\n  ainv(1,1) =(   a(2,2) * a(3,3) - a(2,3) * a(3,2) ) / det\n  ainv(1,2) =( - a(1,2) * a(3,3) + a(1,3) * a(3,2) ) / det\n  ainv(1,3) =(   a(1,2) * a(2,3) - a(1,3) * a(2,2) ) / det\n  ainv(2,1) =( - a(2,1) * a(3,3) + a(2,3) * a(3,1) ) / det\n  ainv(2,2) =(   a(1,1) * a(3,3) - a(1,3) * a(3,1) ) / det\n  ainv(2,3) =( - a(1,1) * a(2,3) + a(1,3) * a(2,1) ) / det\n  ainv(3,1) =(   a(2,1) * a(3,2) - a(2,2) * a(3,1) ) / det\n  ainv(3,2) =( - a(1,1) * a(3,2) + a(1,2) * a(3,1) ) / det\n  ainv(3,3) =(   a(1,1) * a(2,2) - a(1,2) * a(2,1) ) / det\n  return\nend subroutine inv_3x3\n"}, {"instruction": "Create a Fortran subroutine named \"wtt2ttt\" to interpolate a real field from a wtt-grid to a ttt-grid. The subroutine takes 2 input parameters of type real, with dimensions (imt, jmt, km), and outputs 1 parameter of type real with the same dimensions.", "input": "", "output": "subroutine wtt2ttt(w_field,dzt,t_field)\n!\n!     interpolated real field from wtt-grid to ttt-grid\n!     interpolating between two w-levels\n!     t-point is located exactly in the middle of two w-points\n!     t_field(i,j,k) = w_field(i,j,k) + ( w_field(i,j,k+1) -\n!     w_field(i,j,k) ) &\n!                                       / dz(k) * dz(k) / 2\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt,km), intent(in)  :: dzt\nreal,    dimension(imt,jmt,km), intent(in)  :: w_field ! wtt\nreal,    dimension(imt,jmt,km), intent(out) :: t_field ! ttt\nreal,    parameter                          :: p5=0.5, c0=0.0, c3=3.0\n\ndo k = 1,km-1\n  do j = 1,jmt\n    do i = 1,imt\n      if ( dzt(i,j,k).ne.c0 ) then\n        t_field(i,j,k) = p5 * ( w_field(i,j,k) + w_field(i,j,k+1) )\n      endif\n    enddo !i\n  enddo !j\nenddo !k\n\n! bottom level\ndo j = 1,jmt\n  do i = 1,imt\n    if ( dzt(i,j,km).ne.c0 ) then\n      ! extrapolating to last level with gradient between last two\n      ! w-levels\n      ! t_field(i,j,km) = w_field(i,j,km) \n      !                 + (w_field(i,j,km)-w_field(i,j,km-1)) / dz(k) *\n      !                 dz(k)/2\n      !t_field(i,j,km) = p5 * (c3*w_field(i,j,km) - w_field(i,j,km-1) )\n      t_field(i,j,km) = p5 * w_field(i,j,km)\n    endif\n  enddo !i\nenddo !j\n\n!do k = 1,km\n!  call surf_int(1,1,imt,jmt,w_field(:,:,:),tarea,dzt(:,:,k),a)\n!  call surf_int(1,1,imt,jmt,t_field(:,:,k),tarea,dzt(:,:,k),b)\n!  write (*,*) k, ' wtt2ttt orig', a\n!  write (*,*) k, ' wtt2ttt new ', b\n!  write (*,*) k, ' wtt2ttt factor      ', b/a\n!enddo !k\nend subroutine wtt2ttt\n"}, {"instruction": "Create a Fortran subroutine named \"uu2tt\" to interpolate a real 2D field from uu-grid to tt-grid on t-depth levels. The subroutine should have 5 input parameters of type real, each of dimension (imt, jmt). The output parameter should be of type real, with dimension (imt, jmt). The subroutine will use imperative tone to execute the interpolation process based on the input parameters.", "input": "", "output": "subroutine uu2tt(dzt_k,dzu_k,tarea,uarea,field_k,new_field_k)\n!\n!     interpolates real 2d field from uu-grid to tt-grid on t-depth\n!     levels\n!\nimplicit none\n\n! input/output variables\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dzu_k,dzt_k\nreal,    dimension(imt,jmt), intent(in)  :: tarea,uarea\nreal,    dimension(imt,jmt), intent(in)  :: field_k     ! (t)uu\nreal,    dimension(imt,jmt), intent(out) :: new_field_k ! (t)tt\nreal,    parameter                       :: c0=0.0\n! southernmost gridpoints (j=1) on ttt-grid must be 0,\n! as there would not be uu gridpoints south of it otherwise\ndo j = 2, jmt\n  ! westernmost gridpoints\n  if ( dzt_k(1,j).ne.c0 ) then\n    new_field_k(1,j) = 0.25                                                    &\n                  * ( field_k(1  ,j  ) * uarea(1  ,j  ) * dzu_k(1  ,j  )       &\n                    + field_k(imt,j  ) * uarea(imt,j  ) * dzu_k(imt,j  )       &\n                    + field_k(1  ,j-1) * uarea(1  ,j-1) * dzu_k(1  ,j-1)       &\n                    + field_k(imt,j-1) * uarea(imt,j-1) * dzu_k(imt,j-1))      &\n                  / tarea(1,j) / dzt_k(1,j)\n  endif\n  ! most of the ocean\n  do i = 2,imt\n    if ( dzt_k(i,j).ne.c0 ) then\n      new_field_k(i,j) = 0.25                                                  &\n                   * ( field_k(i  ,j  ) * uarea(i  ,j  ) * dzu_k(i  ,j  )      &\n                     + field_k(i-1,j  ) * uarea(i-1,j  ) * dzu_k(i-1,j  )      &\n                     + field_k(i  ,j-1) * uarea(i  ,j-1) * dzu_k(i  ,j-1)      &\n                     + field_k(i-1,j-1) * uarea(i-1,j-1) * dzu_k(i-1,j-1) )    &\n                   / tarea(i,j) / dzt_k(i,j)\n    endif\n  enddo !i\nenddo !j\n\nend subroutine uu2tt\n"}, {"instruction": "Create a Fortran subroutine named box2invbox to calculate the inverse of a box matrix for a specified number of frames. The subroutine takes 2 input parameters: an integer representing the number of frames and a 3D array of double precision representing the box matrix. It produces 1 output parameter, which is a 3D array of double precision representing the inverse box matrix.", "input": "", "output": "  subroutine box2invbox (box,invbox,nframes)\n  \n    implicit none\n    integer,intent(in)::nframes\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes,3,3),intent(out)::invbox\n  \n    invbox=0.0d0\n  \n    invbox(:,1,1)=1.0d0/box(:,1,1)\n    invbox(:,2,2)=1.0d0/box(:,2,2)\n    invbox(:,3,3)=1.0d0/box(:,3,3)\n  \n    invbox(:,2,1)=-box(:,2,1)/(box(:,1,1)*box(:,2,2))\n    invbox(:,3,1)=(box(:,2,1)*box(:,3,2)-box(:,3,1)*box(:,2,2))/(box(:,1,1)*box(:,2,2)*box(:,3,3))\n    invbox(:,3,2)=-box(:,3,2)/(box(:,2,2)*box(:,3,3))\n  \n  end subroutine box2invbox\n"}, {"instruction": "Create a Fortran subroutine named box2cell to perform a transformation from box vectors to unit cell vectors. The subroutine takes 2 input parameters: an integer nframes and a 3D array of double-precision values of dimension (nframes,3,3). It produces 3 output parameters: a 3D array of double-precision values of dimension (nframes,3,3), a 1D array of double-precision values of dimension (nframes), and an integer ortho.", "input": "", "output": "  subroutine box2cell (box,cell,volume,ortho,nframes)\n  \n    implicit none\n    integer,intent(in)::nframes\n    integer::ii\n    double precision,dimension(nframes,3,3),intent(out)::cell\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes),intent(out)::volume\n    integer,intent(out)::ortho\n    double precision::x,y,z\n    double precision,parameter::fact_pi_div_180=1.745329251994329547437168059786927e-0002\n  \n    ortho=0\n    cell=0.0d0\n    volume=0.0d0\n  \n    do ii=1,nframes \n  \n      if ((box(ii,2,1)==0.0d0).and.(box(ii,3,1)==0.0d0).and.(box(ii,3,2)==0.0d0)) then\n         volume(ii)=box(ii,1,1)*box(ii,2,2)*box(ii,3,3)\n         cell(ii,1,1)=box(ii,1,1)\n         cell(ii,2,2)=box(ii,2,2)\n         cell(ii,3,3)=box(ii,3,3)\n         cell(ii,1,2)=90.0d0\n         cell(ii,1,3)=90.0d0\n         cell(ii,2,3)=90.0d0\n         ortho=1\n      else\n         volume(ii)=box(ii,1,1)*box(ii,2,2)*box(ii,3,3)\n         x=box(ii,1,1)\n         y=sqrt(box(ii,2,1)**2+box(ii,2,2)**2)\n         z=sqrt(box(ii,3,1)**2+box(ii,3,2)**2+box(ii,3,3)**2)\n         cell(ii,1,1)=x\n         cell(ii,2,2)=y\n         cell(ii,3,3)=z\n         cell(ii,2,3)=(acos(dot_product(box(ii,2,:),box(ii,1,:))/(x*y)))/fact_pi_div_180 ! gamma\n         cell(ii,1,3)=(acos(dot_product(box(ii,3,:),box(ii,1,:))/(x*z)))/fact_pi_div_180 ! beta\n         cell(ii,1,2)=(acos(dot_product(box(ii,3,:),box(ii,2,:))/(x*y)))/fact_pi_div_180 ! alpha\n      end if\n  \n    end do\n  \n  end subroutine box2cell\n"}, {"instruction": "Write a Fortran subroutine named suncor to calculate the solar declination, solar right ascension, and Greenwich Mean Sidereal Time (GST) based on the input parameters idate and ut. The number of input parameters is 2, and their data types are ['integer', 'real']. The subroutine has 3 output parameters, and their data types are ['real', 'real', 'real'].", "input": "", "output": "subroutine suncor (idate, ut, sdec, srasn, gst)\n\n  implicit none\n\n  integer,intent(in) :: idate\n  real,intent(in) :: ut\n  real,intent(out) :: sdec, srasn, gst\n\n  real,parameter :: pi=3.1415926536\n  real :: fday, dj, t, vl, g, slong, obliq, slp, sind, cosd\n  integer :: iyr, iday\n\n  fday=ut/86400.\n  iyr=idate/1000\n  iday=idate-iyr*1000\n\n! temporary y2k fix-up:\n! should work with either yyddd or yyyyddd format from 1950 to 2050.\n! note deteriorating accuracy after ~2050 anyway.\n! won't work after 2100 due to lack of a leap year.\n\n  if (iyr >= 1900) iyr=iyr-1900\n  if (iyr < 50) iyr=iyr+100\n\n  dj=365*iyr+(iyr-1)/4+iday+fday-0.5\n  t=dj/36525.\n  vl=amod(279.696678+.9856473354*dj,360.)\n  gst=amod(279.696678+.9856473354*dj+360.*fday+180.,360.) * pi/180.\n  g=amod(358.475845+.985600267*dj,360.) * pi/180.\n  slong=vl+(1.91946-.004789*t)*sin(g)+.020094*sin(2.*g)\n  obliq=(23.45229-0.0130125*t) *pi/180.\n  slp=(slong-.005686) * pi/180.\n  sind=sin(obliq)*sin(slp)\n  cosd=sqrt(1.-sind**2)\n  sdec=atan(sind/cosd)\n  srasn=pi-atan2(1./tan(obliq)*sind/cosd,-cos(slp)/cosd)\n\n  return\n\nend subroutine suncor\n"}, {"instruction": "Create a Fortran subroutine named get_vec_cross. The subroutine takes 3 input parameters: an integer m, an array of real numbers v1 with dimension m, and an array of real numbers v2 with dimension m. It has 1 output parameter: an array of real numbers cross with dimension m. The subroutine computes the cross product of the input vectors v1 and v2 and stores the result in the cross array.", "input": "", "output": "  subroutine get_vec_cross(v1, v2, m, cross)\n\n    integer,intent(in)::m\n    real(kind=4),intent(in),dimension(m)::v1,v2\n    real(kind=4),intent(out),dimension(m)::cross\n\n    cross(1)=v1(2)*v2(3)-v1(3)*v2(2)\n    cross(2)=v1(3)*v2(1)-v1(1)*v2(3)\n    cross(3)=v1(1)*v2(2)-v1(2)*v2(1)\n\n    return\n\n  end subroutine get_vec_cross\n"}, {"instruction": "Create a Fortran subroutine named get_vec_len to calculate the magnitude of a vector. The subroutine takes 2 input parameters: an integer m and a real array of dimension m. It has 1 output parameter of type real(kind=4) to store the calculated magnitude. Use the imperative tone to define the subroutine.", "input": "", "output": "  subroutine get_vec_len(vec,vec_len,m)\n\n    integer::i\n    integer,intent(in)::m\n    real(kind=4)::sum_value\n    real(kind=4),intent(in),dimension(m)::vec\n    real(kind=4),intent(out)::vec_len\n\n    sum_value=0.0\n    do i=1,m\n      sum_value=sum_value+vec(i)**2\n    end do\n    vec_len = sqrt(sum_value)\n\n    return\n\n  end subroutine get_vec_len\n"}, {"instruction": "Create a Fortran subroutine named norm_vec to normalize a vector by dividing each element by the Euclidean norm of the vector. The subroutine takes 2 input parameters: an integer m and a real array vec of dimension m. It also has 1 output parameter: a real array new_vec of dimension m.", "input": "", "output": "  subroutine norm_vec(vec,new_vec,m)\n\n    integer::i\n    integer,intent(in)::m\n    real(kind=4)::sum_value\n    real(kind=4),intent(in),dimension(m)::vec\n    real(kind=4),intent(out),dimension(m)::new_vec\n\n    sum_value = 0.0\n    do i=1,m\n      sum_value=sum_value+vec(i)**2\n    end do\n    do i=1,m\n      new_vec(i)=vec(i)/sqrt(sum_value)\n    end do\n\n    return\n\n  end subroutine norm_vec\n"}, {"instruction": "Create a Fortran subroutine named project_vec to compute the projection of vec_1 onto the basis of vec_2. The subroutine takes 3 input parameters: an integer m, a real array vec_1 of dimension m, and a real array vec_2 of dimension m. It returns 2 output parameters: a real value sign_value and a real array vec_1_proj_vec_2 of dimension m.", "input": "", "output": "  subroutine project_vec(vec_1,vec_2,m,vec_1_proj_vec_2,sign_value)\n  ! project vec_1 on the basis of vec_2\n\n    integer,intent(in)::m\n    real(kind=4)::a,b\n    real(kind=4),intent(out)::sign_value\n    real(kind=4),intent(in),dimension(m)::vec_1,vec_2\n    real(kind=4),intent(out),dimension(m)::vec_1_proj_vec_2\n\n    a=dot_product(vec_1,vec_2)\n    b=dot_product(vec_2,vec_2)\n    vec_1_proj_vec_2=a*vec_2/b\n\n    if ( a<0.0 ) then\n      sign_value=-1.0\n    else\n      sign_value=1.0\n    end if\n \n    return\n\n  end subroutine project_vec\n"}, {"instruction": "Create a Fortran subroutine named \"center_of_mass\" to calculate the center of mass of a system. The subroutine takes 4 input parameters: two integers (n and m), an array of real numbers of length n (mass), and a 2D array of real numbers with dimensions n and m (data_array). It outputs a single array of real numbers with length m (data_center).", "input": "", "output": "  subroutine center_of_mass(mass,data_array,data_center,n,m)\n\n    integer::i,j\n    integer,intent(in)::n,m\n    real(kind=4)::sum_value\n    real(kind=4)::sum_value_mass\n    real(kind=4),intent(in),dimension(n)::mass\n    real(kind=4),intent(in),dimension(n,m)::data_array\n    real(kind=4),intent(out),dimension(m)::data_center\n\n    sum_value_mass=0.0\n\n    do i=1,n\n      sum_value_mass=sum_value_mass+mass(i)\n    end do\n\n    do i=1,m\n      sum_value=0.0\n      do j=1,n\n        sum_value=sum_value+mass(j)*data_array(j,i)\n      end do\n      data_center(i)=sum_value/sum_value_mass\n    end do\n\n    return\n\n  end subroutine center_of_mass\n"}, {"instruction": "Create a Fortran subroutine named intersect to compare two arrays of integers of size 2 and return the result in an integer variable. The subroutine takes 2 input arguments of type integer, dimension(2), and 1 output argument of type integer.", "input": "", "output": "      subroutine intersect(a, b, i)\n        integer, dimension(2), intent(in) :: a, b\n        integer, intent(out) :: i\n\n        i = 1\n      end subroutine intersect\n"}, {"instruction": "Create a Fortran subroutine named log_check_file_exists to check if a file with the specified filename exists. The subroutine takes 1 input parameter of type character*76 and 1 output parameter of type integer. The subroutine uses the imperative tone to open the file and set the output parameter to indicate whether the file exists or not.", "input": "", "output": "subroutine log_check_file_exists(logfilename,fileexists)\n  integer, intent(out) :: fileexists\n  character*76, intent(in) :: logfilename\n  ! the status='old' keyword specifies that the file logfilename must\n  ! exist or iostat will return a code other than 0 (2 for absoft).\n  open(file=logfilename, unit=39, status='old', action='read', iostat=fileexists)\n  if ( fileexists == 0 ) then\n    ! the logfile already exists\n    close(39)\n  end if\nend subroutine log_check_file_exists\n"}, {"instruction": "Create a Fortran subroutine named log_create_file, which takes a character*76 input parameter logfilename and an integer output parameter createdfile. The subroutine opens a new log file using the provided filename and returns an integer indicating the status of the file creation. If the file is successfully created, it writes a log message with the filename, creation date, and time. If the file creation fails, it displays an error message.", "input": "", "output": "subroutine log_create_file(logfilename,createdfile)\n  integer, intent(out) :: createdfile\n  character*76, intent(in) :: logfilename\n  character*8               :: curr_date, curr_time\n  character*10              :: long_time, long_date\n\n  open(file=logfilename, unit=39, status='new', action='write', iostat=createdfile)\n  if ( createdfile == 0 ) then\n    call date_and_time(curr_date,long_time)\n    curr_time = long_time(1:2)//':'//long_time(3:4)//':'//long_time(5:6)\n    long_date = curr_date(5:6)//'/'//curr_date(7:8)//'/'//curr_date(1:4)\n    write (39,*) '# ', trim(logfilename), ' created on ', long_date, ' at ', trim(curr_time)\n    close(39)\n  else\n    print *,'[bestpred_log]: unable to create the log file ', logfilename\n  end if\nend subroutine log_create_file\n"}, {"instruction": "Create a Fortran subroutine named system_file_info to retrieve system information about a file. The subroutine takes 1 input parameter of type character*(*) for the file_name and 1 output parameter of type integer, which is optional, to store the file_size in bytes. If the file_size is not required or unknown, it defaults to 0.", "input": "", "output": "  subroutine system_file_info (file_name, file_size)\r\n\r\n    !-- get system information about a file.\r\n    !-- this version returns 0.\r\n    !-- 9 dec 92, richard maine.\r\n\r\n    !-------------------- interface.\r\n    character*(*), intent(in) :: file_name\r\n      !-- path name of the file.\r\n    integer, intent(out), optional :: file_size\r\n      !-- size of the file in bytes.\r\n      !-- 0 if unknown or if the file does not exist.\r\n\r\n    !-------------------- executable code.\r\n\r\n    if (present(file_size)) file_size = 0\r\n    return\r\n  end subroutine system_file_info\r\n"}, {"instruction": "Create a Fortran subroutine named decodehour to extract hour, minute, and second from a string representation of time. The subroutine takes 1 input parameter of type character(len=*) and returns 3 output parameters of type integer.", "input": "", "output": "    subroutine decodehour(stime, ihour, iminute, isecond)\n    \n        ! routine arguments\n        character(len=*), intent(in)    :: stime\n        integer, intent(out)            :: ihour\n        integer, intent(out)            :: iminute\n        integer, intent(out)            :: isecond\n        \n        ! locals\n        integer :: ilength\n        integer :: iretcode\n        \n        ! infer type of date from string length\n        ilength = len_trim(stime)\n        select case(ilength)\n        case(8)\n            ! hh:mm:ss\n            read(stime,\"(i2,1x,i2,1x,i2)\",iostat=iretcode) ihour, iminute, isecond\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            end if\n        case(5)\n            ! hh:mm\n            read(stime,\"(i2,1x,i2)\",iostat=iretcode) ihour, iminute\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            else\n                isecond = 0\n            end if\n        case(2)\n            ! hh\n            read(stime,\"(i2)\",iostat=iretcode) ihour\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            else\n                iminute = 0\n                isecond = 0\n            end if\n        case default\n            ihour   = -9999\n            iminute = -9999\n            isecond = -9999\n        end select\n        \n    end subroutine decodehour\n"}, {"instruction": "Create a Fortran subroutine named chartoascii that takes in an integer n, an array of characters chartxt, and outputs an array of integers inttxt. The subroutine converts each character in the input array to its corresponding ASCII value and stores it in the output array.", "input": "", "output": "  subroutine chartoascii(inttxt,chartxt,n)\n    implicit none\n    integer, intent(in) :: n !< dimension of integer and character array\n    integer, dimension(n), intent(out) :: inttxt !< integer array\n    character(len=n), intent(in) :: chartxt !< character array\n    ! locals\n    integer :: i\n\n    do i=1,n\n      inttxt(i) = ichar(chartxt(i:i))\n    enddo\n  end subroutine chartoascii\n"}, {"instruction": "Create a Fortran subroutine named get_size to read a file and retrieve the dimensions. The subroutine takes 1 input parameter of type character*255. It has 3 output parameters of type integer.", "input": "", "output": "    subroutine get_size(path,ncontrol, nintervals, nstates)\n        !define variables\n        character*255, intent(in) :: path    \n        integer,intent(out) :: nintervals, ncontrol, nstates\n        integer i, j\n        \n        !open first time just to get the dimensions\n        open(unit = 10, file = path, status = 'old', action = 'read')\n        read(10,*) ncontrol\n        read(10,*) nstates\n        read(10,*)\n        read(10,*) i, nintervals\n        close(10)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named get_data to read data from a file. The subroutine takes 4 input parameters of type character*255, integer, integer, and integer. It also has 2 output parameters of type integer and real. The subroutine opens a file specified by the input path, reads the control and data values, and assigns them to the output variables.", "input": "", "output": "    subroutine get_data(path,ncontrol, nintervals, nstates, control, data)\n        !define variables\n        character*255, intent(in) :: path \n        integer, intent(in) ::  nintervals, ncontrol, nstates\n        integer,intent(out) :: control(ncontrol)\n        real, intent(out) :: data(ncontrol,nstates,nintervals)\n        integer i, j,oe,z\n            \n        !open the file to read the data\n        open(unit = 10, file = path, status = 'old', action = 'read')\n        read(10,*) \n        read(10,*)     \n        do i =1,ncontrol\n            read(10,*)\n            read(10,*) control(i), oe\n            read(10,*) ((data(i,j,z), j = 1,nstates), z = 1,nintervals)        \n        enddo\n        close(10)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named parse_date to extract year, month, day, hour, minute, and second from a given date string. The number of input arguments is 1 and the test_data type is ['character (len=*)']. The number of output arguments is 6 and the test_data type is ['integer', 'integer', 'integer', 'integer', 'integer', 'integer'].", "input": "", "output": "    subroutine parse_date(date, year, month, day, hour, min, sec)\n      implicit none\n      character (len=*), intent(in) :: date\n      integer, intent(out) :: sec, min, hour, day, month, year\n\n      read(date(9:10),*) day\n      read(date(6:7),*) month\n      read(date(1:4),*) year\n      if(len_trim(date) <= 11) then\n         sec = 0\n         min = 0\n         hour = 0\n      else\n         read(date(18:19), *) sec\n         read(date(15:16), *) min\n         read(date(12:13), *) hour\n      endif\n    end subroutine parse_date\n"}, {"instruction": "Create a Fortran subroutine named calc_dxyz to calculate the grid cell volume at the drifter's location. The subroutine takes 9 input parameters of type integer, integer, integer, integer, integer, integer, real arrays of specified dimensions, and real(kind=8). The output is a single real(kind=8) value.\n\nThe subroutine uses the imperative tone and performs calculations based on the inputs to determine the volume of the drifter's grid cell. The volume is computed using the input grid space indices, time interpolation constant, grid index sizing constants, cell height, area of horizontal cell-walls, and time index parameters.\n\nEnsure the proper declaration and usage of the required input and output parameters within the subroutine.", "input": "", "output": "subroutine calc_dxyz(ib,jb,kb,rr,imt,jmt,km,dzt,dxdy,dxyz)\n!====================================================================\n! calculate the grid cell volume at the drifter's location\n!\n!  input:\n!    ib,jb,kb       : new position in grid space indices\n!    rr             : time interpolation constant between 0 and 1. controls how much\n!                   : of earlier time step is used in interpolation.\n!    imt,jmt,km     : grid index sizing constants in (x,y,z), are for \n!                     horizontal and vertical rho grid [scalar]\n!    dzt            : height of k-cells in 3 dim in meters on rho vertical grid. [imt,jmt,km]\n!    dxdy           : area of horizontal cell-walls [imt,jmt]\n!\n!  output:\n!    dxyz           : volume of drifter's grid cell\n!\n!  other parameters used in function:\n!    rg             : rg=1-rr for time interpolation between time steps. controls how much\n!                   : of later time step is used in interpolation.\n!    nsm=1,nsp=2    : time index. nsm picks out the earlier bounding time step and \n!                     nsp picks out the later bounding time step for interpolation.\n!\n!  notes:\n!    kmt: assuming zgrid3dt flag which includes free surface already, i think. other \n!         flags aren't set up in the allocations or in the input variables,\n!         for example, hs is not currently input since it is already included in \n!         the dzt.\n!====================================================================\n\nimplicit none\n\ninteger,        intent(in)                                      :: ib,jb,kb,km,jmt,imt\nreal(kind=8),   intent(in),     dimension(imt,jmt,km,2)         :: dzt\nreal(kind=8),   intent(in),     dimension(imt,jmt)              :: dxdy\nreal(kind=8),   intent(in)                                      :: rr\nreal(kind=8),   intent(out)                                     :: dxyz\nreal(kind=8)                                                    :: rg\ninteger                                                         :: nsm=1,nsp=2\n\n\nrg=1.d0-rr\n\n! t-box volume in m3\ndxyz=rg*dzt(ib,jb,kb,nsp)+rr*dzt(ib,jb,kb,nsm)\ndxyz=dxyz*dxdy(ib,jb)\n\nend subroutine calc_dxyz\n"}, {"instruction": "Write a Fortran subroutine named set_data_double that initializes an array with values equal to the rank of the array element. The subroutine takes 2 input parameters, both of type integer, and 1 output parameter of type double precision, with a dimension specified by the second input parameter.\n", "input": "", "output": "subroutine set_data_double ( data, rank, dim )\n!******************************************************************************\n!******************************************************************************\n\nimplicit none\n    integer, intent(in) :: rank, dim\n    double precision, dimension(dim), intent(out) :: data\n    integer i\n\n    do i = 1, dim\n       data(i) = rank \n    end do\n\n    return\n\nend subroutine set_data_double\n"}, {"instruction": "Create a Fortran subroutine named set_data_int that sets an array of integers to a specific value. The subroutine takes 2 input parameters of type integer and outputs an array of integers with a dimension specified by the second input parameter. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(dim)'].", "input": "", "output": "subroutine set_data_int ( data, rank, dim) \n!******************************************************************************\n!******************************************************************************\n\nimplicit none\n    integer, intent(in) :: rank, dim\n    integer, dimension(dim), intent(out) :: data\n    integer i\n\n    do i = 1, dim\n       data(i) = rank \n    end do\n\n    return\n\nend subroutine set_data_int\n"}, {"instruction": "Create a Fortran subroutine named model_pblhgt that takes 8 input parameters: 3 integers, 4 2D real arrays, and 1 3D real array. The output is a 2D real array. The subroutine's purpose is to generate planetary boundary layer heights using theta and surface temperature data in a terrain-following model coordinate system.", "input": "", "output": "subroutine model_pblhgt(theta,thsfc,psig,zsig,topo,nx,ny,nz,pblhgt)\n\n  !  coordinate model data.  adapted from the laps routine for \n  !  terrain-following model coordinates.\n\n  implicit none\n\n  integer, intent(in)   :: nx,ny,nz\n  real, intent(in)      :: theta(nx,ny,nz)\n  real, intent(in)      :: thsfc(nx,ny)\n  real, intent(in)      :: psig(nx,ny,nz)\n  real, intent(in)      :: zsig(nx,ny,nz)\n  real, intent(in)      :: topo(nx,ny)\n  real, intent(out)     :: pblhgt(nx,ny)\n\n  integer  :: i,j,k,ktop\n  real     :: thresh_k, topwgt, botwgt\n  logical  :: found_pbl_top\n  \n  print *, 'generating pbl height using theta and surface temp.'\n  loop_j:  do j = 1 , ny\n    loop_i:  do i = 1 , nx\n\n      ! compute threshold value that theta needs to exceed\n      ! to be above pbl.  we use surface theta plus an\n      ! additional 3k for slop.\n\n      thresh_k = thsfc(i,j) + 3.0  \n\n      ! now begin at the bottom and work our way up until\n      ! we find the first level with a theta exceeding the\n      ! threshold\n\n      found_pbl_top = .false.\n      loop_k: do k = 1 , nz\n \n        if (theta(i,j,k) .ge. thresh_k) then\n          ktop = k\n          found_pbl_top = .true.\n          exit loop_k\n        endif\n      enddo loop_k\n\n      ! if we did not find a good pbl, set pbl to first level\n      ! and print out some diagnostics\n      if (.not. found_pbl_top) then\n        print *, 'pbl height not found at i/j = ',i,j\n        print *, 'surface theta = ', thsfc(i,j)\n        print *, 'theta in the column:'\n        print *, 'pressure height  theta'\n        print *, '-------- ------- --------'\n        diag_loop: do k = 1,nz\n          print '(f8.0,f8.0,f8.2)',psig(i,j,k),zsig(i,j,k),theta(i,j,k)\n        enddo diag_loop\n        ktop = 1\n        pblhgt(i,j) = zsig(i,j,1) - topo(i,j)\n\n      else \n  \n        ! we found the top k-level bounding the pbl so interpolate\n        ! to the actual level\n \n        if (ktop .eq. 1) then\n          pblhgt(i,j) = zsig(i,j,1) - topo(i,j)\n        else\n          ! interpolate to get height at thresh_k\n          botwgt = ( (theta(i,j,ktop)-thresh_k) / &\n                     (theta(i,j,ktop)-theta(i,j,ktop-1)) )\n          topwgt = 1.0 - botwgt\n          pblhgt(i,j) = botwgt * zsig(i,j,ktop-1) + &\n                        topwgt * zsig(i,j,ktop) - topo(i,j)\n        endif\n      endif\n    enddo loop_i\n  enddo loop_j\n  return\nend subroutine model_pblhgt\n"}, {"instruction": "Create a Fortran subroutine named arr_distance that calculates the distances between a set of 3D points and a reference point. The subroutine takes 3 input parameters: an integer arr_length, a real array arr of dimensions (arr_length, 3), and a real array sc of dimension (3). It also has 1 output parameter: a real array dd of dimension (arr_length).", "input": "", "output": "subroutine arr_distance(sc, arr, arr_length, dd)\n\n  integer, intent(in) :: arr_length\n  real, dimension(arr_length, 3), intent(in) :: arr\n  real, dimension(3), intent(in) :: sc\n  real, dimension(arr_length), intent(out) :: dd\n  \n  dd = sqrt(sum((arr-spread(sc,1,arr_length))**2, 2))\n  \nend subroutine arr_distance\n"}, {"instruction": "Create a Fortran subroutine named set_from_string that takes two logical input parameters and one output parameter of type character(len=*). The input parameters are used to determine the value of the output string based on conditional statements.", "input": "", "output": "subroutine set_from_string(from_restart, single_file, from_string)\nlogical,          intent(in)  :: from_restart\nlogical,          intent(in)  :: single_file\ncharacter(len=*), intent(out) :: from_string\n\nif (from_restart) then\n   if (single_file) then\n      from_string = 'variable from input file'\n   else\n      from_string = 'restart file'\n   endif\nelse\n   from_string = 'from namelist'\nendif\n\nend subroutine set_from_string\n"}, {"instruction": "Write a Fortran subroutine named init_thread_topology to initialize the topology of a thread. The subroutine takes 4 input parameters of type integer: n, d, imore, and iless. It also has 1 output parameter of type integer: n3d. This subroutine computes the thread topology based on the input parameters and allocates the values to the output parameter n3d.", "input": "", "output": "  subroutine init_thread_topology(n, n3d, d, imore, iless)\n    implicit none\n    integer, intent(in) :: n, d, imore, iless\n    integer, intent(out) :: n3d(3)\n\n    integer, allocatable :: facs(:)\n    integer :: lfacs, f, nfac, rem, i, j, nmin, nmax\n    integer :: n2d(2)\n\n    if (d.eq.1) then\n       n3d = 1\n       n3d(imore) = n\n       return\n    end if\n\n    lfacs = int(log(dble(n))/log(2.d0))\n    allocate(facs(lfacs))\n    \n    nfac = 0\n    f = 2\n    rem = n\n    do while (rem .ne. 1)\n       if (mod(rem, f) .eq. 0) then\n          rem = rem/f\n          nfac = nfac+1\n          facs(nfac) = f\n       else\n          f = f + 1\n       end if\n    end do\n\n    if (d .eq. 3) then\n       n3d = 1\n       do i = nfac, 1, -1\n          j = minloc(n3d,1)\n          n3d(j) = n3d(j) * facs(i)\n       end do\n    else\n       n2d = 1\n       do i = nfac, 1, -1\n          j = minloc(n2d,1)\n          n2d(j) = n2d(j) * facs(i)\n       end do\n       n3d(1) = 1\n       n3d(2:3) = n2d\n    end if\n\n    nmin = minval(n3d)\n    nmax = maxval(n3d)\n\n    n3d = n / (nmin*nmax)\n    n3d(iless) = nmin\n    n3d(imore) = nmax\n\n    deallocate(facs)\n\n  end subroutine init_thread_topology\n"}, {"instruction": "Write a Fortran subroutine named split_domain to divide a given total size into n parts and calculate the size and start index for each part. The number of input parameters is 2 with test_data type ['integer', 'integer']. The number of output parameters is 2 with test_data type ['integer', 'integer'].", "input": "", "output": "  subroutine split_domain(totalsize, n, isize, start)\n    implicit none\n    integer, intent(in) :: totalsize, n\n    integer, intent(out) :: isize(n), start(n)\n    \n    integer :: i, iavg, ileft\n    \n    iavg = int(totalsize/n)\n    ileft = totalsize - iavg*n\n    \n    start(1) = 0\n    isize(1) = iavg\n    do i=2, n\n       start(i) = start(i-1) + isize(i-1)\n       if (ileft > 0) then\n          isize(i) = iavg + 1\n          ileft = ileft - 1\n       else\n          isize(i) = iavg\n       end if\n    end do\n    \n  end subroutine split_domain\n"}, {"instruction": "Create a Fortran subroutine named \"bkfilter\" to implement the Baxter and King (1999) band-pass filter. The subroutine takes 5 input parameters of type integer and real, and 2 output parameters of type real. The input parameters are n (length of data vector y), up (lower frequency), dn (higher frequency), k (number of leads and lags), and y (data vector). The output parameters are ybp (band pass filtered series) and yt (symmetric moving average representation of the band pass filter). Ensure the subroutine computes the band pass filter according to the provided algorithm.", "input": "", "output": "subroutine bkfilter(n, y, up, dn, k, ybp, yt)\r\n\r\n! aubhik 20.02.2005\r\n!\r\n! baxter and king (1999) band-pass filter\r\n!\r\n! y is a data vector of length n\r\n! ybp is the band pass filtered series, with 0.0 for the first and last k observations\r\n! n is the length of the data vector y\r\n! up is the lower frequency\r\n!\tfor example, the business cycle band will have up = 6 for quarterly data\r\n!\tand up = 1.5 for annual data\r\n! dn is the higher frequency\r\n!\tfor example, the business cycle band will have dn = 32 for quarterly data\r\n!\tand dn = 8 for annual data\r\n! k is the number of leads and lags used by the symmetric moving-average \r\n!\trepresentation of the band pass filter.  baxter and king (1999) find\r\n!\tthat k = 12 is a practical choice.\r\n! \r\n\n! bpf.m and filtk.m written by baxter and king (1999).  the band pass filter is \r\n! a moving average involving 2k+1 terms.  the weights are symmetric and calculated\r\n! in akvec.  \r\n\r\nimplicit none\r\n\r\ninteger n, up, dn, k\r\nreal y(n), ybp(n), yt(n)\r\n\r\ninteger j\r\nreal pi, omlbar, omubar, kr, kj, theta\r\nreal akvec(k+1), avec(2*k+1), tvec(2*k+1)\r\n\r\nintent(in):: n, up, dn, k, y\r\nintent(out):: ybp, yt\r\n\r\npi = 2.0*acos(0.0)\r\n\r\nomlbar = 2.0*pi/dble(dn)\r\nomubar = 2.0*pi/dble(up)\r\n\r\nakvec = 0.0\r\navec = 0.0\r\n\r\nkr = dble(k)\r\n\r\nakvec(1) = (omubar - omlbar)/pi\r\n\r\ndo j = 1, k\r\n    kj = dble(j)\r\n    akvec(j+1) = (dsin(dble(kj*omubar)) - dsin(dble(kj*omlbar)))/(kj*pi)\r\nend do\r\n\r\ntheta = akvec(1) + 2.0*sum(akvec(2:k+1))\r\ntheta = -1.0*(theta/(2.0*kr + 1.0))\r\n\r\nakvec = akvec + theta\r\n\r\navec(k+1) = akvec(1)\r\n\r\ndo j = 1, k\r\n    avec(k+1 - j) = akvec(j+1)\r\n    avec(k+1 + j) = akvec(j+1)\r\nend do\r\n\r\ndo j = 1, k*2+1\r\n    tvec(j) = 1.0 - avec(j)\r\nend do\r\n\r\nybp = 0.0\r\nyt = 0.0\r\n\r\ndo j = k + 1, n - k\r\n    ybp(j) = dot_product(avec, y(j - k: j + k))\r\n    yt(j) = dot_product(tvec, y(j - k: j + k))\r\nend do\r\n\r\nend subroutine bkfilter\r\n"}, {"instruction": "Create a Fortran subroutine named sph_cart to convert position vectors from spherical coordinates to cartesian coordinates. The input parameter is a 2D array of real numbers with kind=8 and dimensions defined by the size of the problem. The output parameter is also a 2D array of real numbers with kind=8 and dimensions defined by the size of the problem.", "input": "", "output": "subroutine sph_cart(r,x)\n\t!----------------------------------------------------------\n\t! switching from spherical to cartesian coordinates \n\t! calling sequence: call cart_sph(r,x)\n\t! input:  r: position vector in spherical coordinates\n\t!\t     (radial distance,azimuthal angle,polar angle)\t\n\t! output: x: position vector in cartesian coordinates \n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r\n\treal(kind=8), dimension(:,:), intent(out) :: x\n\n\tx(1,:) = r(1,:)*cos(r(3,:))*cos(r(2,:)) \n\tx(2,:) = r(1,:)*cos(r(3,:))*sin(r(2,:)) \n\tx(3,:) = r(1,:)*sin(r(3,:))\n\nend subroutine sph_cart\n"}, {"instruction": "Write a Fortran subroutine named cyl_cart to convert cylindrical coordinates to cartesian coordinates. The subroutine takes 1 input parameter of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8), dimension(:,:). The input parameter represents the position vector in cylindrical coordinates (radial distance, angular coordinate, altitude), and the output parameter represents the position vector in cartesian coordinates. Use the calling sequence call cyl_cart(r,x).", "input": "", "output": "subroutine cyl_cart(r,x)\n\t!----------------------------------------------------------\n\t! switching from cylindrical to cartesian coordinates\n\t! calling sequence: call cyl_cart(r,x)\n\t! input:  r: position vector in cylindrical coordinates \n\t!\t     (radial distance,angular coordinate,altitude)\n\t! output: x: position vector in cartesian coordinates \n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r\n\treal(kind=8), dimension(:,:), intent(out) :: x\n\n\tx(1,:) = r(1,:)*cos(r(2,:))\n\tx(2,:) = r(1,:)*sin(r(2,:)) \n\tx(3,:) = r(3,:)\n\nend subroutine cyl_cart\n"}, {"instruction": "Create a Fortran subroutine named cyl_cart_vect to convert a vector from cylindrical coordinates to Cartesian coordinates for a given position vector. The subroutine takes 2 input parameters of type real(kind=8), dimension(:,:), representing the vector and position in cylindrical coordinates, and 1 output parameter of type real(kind=8), dimension(:,:) representing the resulting vector in Cartesian coordinates. Use the calling sequence call cyl_cart_vect(vr,r,vx) to invoke the subroutine.", "input": "", "output": "subroutine cyl_cart_vect(vr,r,vx)\n\t!-------------------------------------------------------------------------------------\n\t! switching from cylindrical to cartesian coordinates for a vector at a point r\n\t! calling sequence: call cyl_cart_vect(vr,r,vx)\n\t! input: vr : vector in cylindrical coordinates\n\t!             (radial distance,angular coordinate,altitude)\n\t!         r : position vector in cylindrical coordinates\n\t!             (radial distance,angular coordinate,altitude)\n\t!\t\t\t\t\n\t! output: vx: vector in cartesian coordinates  (vx,vy,vz)\n\t!-------------------------------------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r,vr\n\treal(kind=8), dimension(:,:), intent(out) :: vx\n\t\n\tvx(1,:)=vr(1,:)*cos(r(2,:))-vr(2,:)*sin(r(2,:))\n\tvx(2,:)=vr(1,:)*sin(r(2,:))+vr(2,:)*cos(r(2,:))\n\tvx(3,:)=vr(3,:)\n\nend subroutine cyl_cart_vect\n"}, {"instruction": "Create a Fortran subroutine named \"weights_left_k8\" to compute weighted values. The subroutine takes 2 input parameters of type real(kind=8) and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine weights_left_k8(sigma, n, omega)\n\n    implicit none\n\n    real(kind=8), intent(in) :: sigma(n,0:7)\n    integer, intent(in) :: n\n    real(kind=8), intent(out) :: omega(n,1,0:7,2)\n    integer :: i\n    real(kind=8) :: accumulator\n\n    real(kind=8) :: omega0, omega1, omega2, omega3, omega4, omega5, omega6, omega7\n    do i=8, n-8\n       accumulator = 0.0\n       omega0 = +0.000155400155400155 / (1.e-36 + sigma(i,0)) / (1.e-36 + sigma(i,0))\n       accumulator = accumulator + omega0\n       omega1 = +0.0087024087024087 / (1.e-36 + sigma(i,1)) / (1.e-36 + sigma(i,1))\n       accumulator = accumulator + omega1\n       omega2 = +0.0913752913752914 / (1.e-36 + sigma(i,2)) / (1.e-36 + sigma(i,2))\n       accumulator = accumulator + omega2\n       omega3 = +0.304584304584305 / (1.e-36 + sigma(i,3)) / (1.e-36 + sigma(i,3))\n       accumulator = accumulator + omega3\n       omega4 = +0.380730380730381 / (1.e-36 + sigma(i,4)) / (1.e-36 + sigma(i,4))\n       accumulator = accumulator + omega4\n       omega5 = +0.182750582750583 / (1.e-36 + sigma(i,5)) / (1.e-36 + sigma(i,5))\n       accumulator = accumulator + omega5\n       omega6 = +0.0304584304584305 / (1.e-36 + sigma(i,6)) / (1.e-36 + sigma(i,6))\n       accumulator = accumulator + omega6\n       omega7 = +0.00124320124320124 / (1.e-36 + sigma(i,7)) / (1.e-36 + sigma(i,7))\n       accumulator = accumulator + omega7\n       omega0 = omega0 / accumulator\n       omega1 = omega1 / accumulator\n       omega2 = omega2 / accumulator\n       omega3 = omega3 / accumulator\n       omega4 = omega4 / accumulator\n       omega5 = omega5 / accumulator\n       omega6 = omega6 / accumulator\n       omega7 = omega7 / accumulator\n       omega(i,1,0,1) = omega0\n       omega(i,1,1,1) = omega1\n       omega(i,1,2,1) = omega2\n       omega(i,1,3,1) = omega3\n       omega(i,1,4,1) = omega4\n       omega(i,1,5,1) = omega5\n       omega(i,1,6,1) = omega6\n       omega(i,1,7,1) = omega7\n    end do\n  end subroutine weights_left_k8\n"}, {"instruction": "Create a Fortran subroutine named weights_left_k9 to calculate the omega values based on the given input sigma values. The subroutine should have 2 input parameters of type real(kind=8) and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine weights_left_k9(sigma, n, omega)\n\n    implicit none\n\n    real(kind=8), intent(in) :: sigma(n,0:8)\n    integer, intent(in) :: n\n    real(kind=8), intent(out) :: omega(n,1,0:8,2)\n    integer :: i\n    real(kind=8) :: accumulator\n\n    real(kind=8) :: omega0, omega1, omega2, omega3, omega4, omega5, omega6, omega7, omega8\n    do i=9, n-9\n       accumulator = 0.0\n       omega0 = +4.11353352529823e-05 / (1.e-36 + sigma(i,0)) / (1.e-36 + sigma(i,0))\n       accumulator = accumulator + omega0\n       omega1 = +0.00296174413821473 / (1.e-36 + sigma(i,1)) / (1.e-36 + sigma(i,1))\n       accumulator = accumulator + omega1\n       omega2 = +0.0414644179350062 / (1.e-36 + sigma(i,2)) / (1.e-36 + sigma(i,2))\n       accumulator = accumulator + omega2\n       omega3 = +0.193500617030029 / (1.e-36 + sigma(i,3)) / (1.e-36 + sigma(i,3))\n       accumulator = accumulator + omega3\n       omega4 = +0.362813656931304 / (1.e-36 + sigma(i,4)) / (1.e-36 + sigma(i,4))\n       accumulator = accumulator + omega4\n       omega5 = +0.290250925545043 / (1.e-36 + sigma(i,5)) / (1.e-36 + sigma(i,5))\n       accumulator = accumulator + omega5\n       omega6 = +0.0967503085150144 / (1.e-36 + sigma(i,6)) / (1.e-36 + sigma(i,6))\n       accumulator = accumulator + omega6\n       omega7 = +0.0118469765528589 / (1.e-36 + sigma(i,7)) / (1.e-36 + sigma(i,7))\n       accumulator = accumulator + omega7\n       omega8 = +0.000370218017276841 / (1.e-36 + sigma(i,8)) / (1.e-36 + sigma(i,8))\n       accumulator = accumulator + omega8\n       omega0 = omega0 / accumulator\n       omega1 = omega1 / accumulator\n       omega2 = omega2 / accumulator\n       omega3 = omega3 / accumulator\n       omega4 = omega4 / accumulator\n       omega5 = omega5 / accumulator\n       omega6 = omega6 / accumulator\n       omega7 = omega7 / accumulator\n       omega8 = omega8 / accumulator\n       omega(i,1,0,1) = omega0\n       omega(i,1,1,1) = omega1\n       omega(i,1,2,1) = omega2\n       omega(i,1,3,1) = omega3\n       omega(i,1,4,1) = omega4\n       omega(i,1,5,1) = omega5\n       omega(i,1,6,1) = omega6\n       omega(i,1,7,1) = omega7\n       omega(i,1,8,1) = omega8\n    end do\n  end subroutine weights_left_k9\n"}, {"instruction": "Create a Fortran subroutine named rotate that performs a rotation of a vector from the general Cartesian coordination system into a local one. The subroutine takes 2 input parameters of type real*8 (vector and rotmat) and 1 output parameter of type real*8 (rotvec).", "input": "", "output": "subroutine rotate(vector,rotmat,rotvec)\n  !                                                                       \n  !     rotate performs a rotation of the vector from the general         \n  !     cartesian coordination system into the  local one  of the         \n  !     jatom-th sphere.                                                  \n\n  !                                                                       \n  implicit none\n  real*8, intent(in) :: vector(3), rotmat(3,3)\n  real*8, intent(out):: rotvec(3)\n  !---------------------------------------------------------------------- \n  !\n  rotvec = matmul(rotmat,vector)\n  !do jcoord=1,3     ! 10                                                \n  !   dotpro=0.0d0                                                   \n  !   do j=1,3       ! 20\n  !      dotpro = dotpro + rotmat(jcoord,j)*vector(j)\n  !   enddo\n  !   rotvec(jcoord)=dotpro\n  !enddo !10   continue                                                          \n  return                                                            \nend subroutine rotate\n"}, {"instruction": "Create a Fortran subroutine named gasdv. It takes 5 input parameters with the test_data type of ['integer(4)', 'integer(8)', 'real(8)', 'real(8)', 'real(8)'], and 1 output parameter with the test_data type of ['real(8)']. The subroutine is used to perform a specific calculation related to gas dynamics using the provided input parameters and returns the result through the output parameter.", "input": "", "output": "     subroutine gasdv(numdim,eosinfo,eosparams,eosnondim,qin,dvin)\n       implicit none\n       integer(4), intent(in)  :: numdim\n       integer(8), intent(in)  :: eosinfo\n       real(8),    intent(in)  :: eosparams\n       real(8),    intent(in)  :: eosnondim\n       real(8),    intent(in)  :: qin\n       real(8),    intent(out) :: dvin\n     end subroutine gasdv\n"}, {"instruction": "Create a Fortran subroutine named get_temperature to receive a time value in days as input and return the corresponding temperature as output. The input parameter is of type real and intent(in), while the output parameter is of type real and intent(out).", "input": "", "output": "        subroutine get_temperature( time, temp )\r\n            implicit none\r\n            real, intent(in)  :: time  ! time in days\r\n            real, intent(out) :: temp  ! set temperature\r\n        end subroutine get_temperature\r\n"}, {"instruction": "Create a Fortran subroutine named room_program that takes in a real number as input to represent the time, and returns a real number as output to represent the room temperature. The input parameter should be marked as \"intent(in)\" and the output parameter should be marked as \"intent(out)\".", "input": "", "output": "subroutine room_program( time, temp )\r\n    real, intent(in)  :: time\r\n    real, intent(out) :: temp\r\n\r\n    real              :: tday\r\n\r\n    tday = 24.0 * mod(time, 1.0)  ! time of day\r\n\r\n    if ( tday < 7.0 .or. tday > 23.0 ) then\r\n        temp =  0.0 ! effectively no particular temperature set\r\n    else\r\n        temp = 19.0 ! keep the room temperature at an agreeable level\r\n    endif\r\nend subroutine room_program\r\n"}, {"instruction": "Write a Fortran subroutine named seasonal_temperature that takes a real input parameter time and returns a real output parameter temp. The subroutine calculates the temperature temp based on the input time using the formula temp = 15.0 - 15.0 * cos( time / 365.0 ).", "input": "", "output": "subroutine seasonal_temperature( time, temp )\r\n    real, intent(in)  :: time\r\n    real, intent(out) :: temp\r\n\r\n    real              :: tday\r\n\r\n    temp = 15.0 - 15.0 * cos( time / 365.0 )\r\nend subroutine seasonal_temperature\r\n"}, {"instruction": "Create a Fortran subroutine named matmult to perform matrix multiplication and back substitution. The subroutine takes 2 input parameters: an integer nvar and a 2D real array amat, and outputs a 1D real array rhs.", "input": "", "output": "  subroutine matmult(nvar, amat, rhs)\n    implicit none\n    integer, intent(in) :: nvar\n    real, intent(in) :: amat(:,:)\n    real, intent(out) :: rhs(:)\n\n    integer :: i, j\n\n    do i = 1, nvar-1\n       do j = i+1, nvar\n          rhs(j) = amat(i,i) * rhs(j) - amat(j,i) * rhs(i)\n       end do\n    end do\n\n    ! back substitution\n    rhs(nvar) = rhs(nvar) / amat(nvar,nvar)\n    do i = nvar-1, 1, -1\n       do j = i+1, nvar\n          rhs(i) = rhs(i) - amat(i,j) * rhs(j)\n       end do\n       rhs(i) = rhs(i) / amat(i,i)\n    end do\n  end subroutine matmult\n"}, {"instruction": "Create a Fortran subroutine named mpi_comm_size to retrieve the size of a specified communicator. The subroutine takes 1 input parameter of type integer and returns 2 output parameters, both of type integer.", "input": "", "output": "     subroutine mpi_comm_size(comm, size, ierror)\n       implicit none\n       integer, intent(in) :: comm\n       integer, intent(out) :: size\n       integer, intent(out) :: ierror\n     end subroutine mpi_comm_size\n"}, {"instruction": "Write a Fortran subroutine named linear_solver to find the root of the equation f(tau) = a * tau + b. The subroutine should have 2 input parameters of type double precision, denoted as a and b. It should also have 1 output parameter of type double precision, denoted as dtau.", "input": "", "output": "    subroutine linear_solver(a,b,dtau)\n!\n        !find the root of the equation\n        !f(tau) = a * tau + b\n!\n        implicit none\n!\n        double precision,intent(out)                :: dtau\n        double precision,intent(in)                 :: a,b\n!\n        if(a.eq.0.d0) then\n            dtau = huge(0.d0)\n        else\n            dtau = -b/a    \n        endif        \n!\n    end subroutine linear_solver\n"}, {"instruction": "Write a Fortran subroutine named init to initialize a 3D array with a given size and spacing. The subroutine takes 6 input parameters of type integer, integer, integer, real(kind=4), real(kind=4), real(kind=4) and 1 output parameter of type real(kind=4), dimension(:,:,:) to store the initialized 3D array.", "input": "", "output": "  subroutine init(nx, ny, nz, dx, dy, dz, f)\n    \n    integer,intent(in) :: nx, ny, nz\n    real(kind=4),intent(in) :: dx, dy, dz\n    real(kind=4),intent(out),dimension(:,:,:) :: f\n    real(kind=4) :: kx,ky,kz,x,y,z,pi\n    integer :: i,j,k\n\n    pi = acos(-1.0)\n    kx = 2.0*pi\n    ky = kx\n    kz = kx\n\n    do k = 1, nz\n       do j = 1, ny\n          do i = 1, nx\n\n             x = dx*(real(i-1) + 0.5)\n             y = dy*(real(j-1) + 0.5)\n             z = dz*(real(k-1) + 0.5)\n\n             f(i,j,k) = 0.125*(1.0 - cos(kx*x))*(1.0 - cos(ky*y))*(1.0 - cos(kz*z))\n\n          end do\n       end do\n    end do\n\n  end subroutine init\n"}, {"instruction": "Write a Fortran subroutine named read_2qgate_list to read data from a file. The subroutine takes 1 input argument of type character(*) and 4 output arguments of type integer. The allocatable integer array list_p is of size (:,:) and the other output integers are tq, nol, and nog. This subroutine reads data from the specified file and assigns values to the output parameters based on the data read.", "input": "", "output": "  subroutine read_2qgate_list(list_p,tq,nol,nog,ifile)\n    integer, allocatable, intent(out) :: list_p(:,:)\n    integer, intent(out) :: tq, nol, nog\n    character(*), intent(in) :: ifile\n    integer :: p1,p2,ln,i\n    open(10,file=ifile,action='read')\n    nog = 0\n    do \n       read(10,*,end=9) p1, p2, ln\n       nog = nog + 1\n    end do\n9   rewind(10)\n    allocate(list_p(3,nog))\n    do i = 1, nog\n       read(10,*) p1, p2, ln\n       list_p(1:3,i) = (/p1, p2, ln/)\n    end do \n    close(10)\n    nol = maxval(list_p(3,:))\n    tq = maxval(list_p(1:2,:))\n  end subroutine read_2qgate_list\n"}, {"instruction": "Create a Fortran subroutine named read_so4_theta_list to read data from a file and allocate memory to store the values. The subroutine has 2 input parameters of type integer and character(*), and 2 output parameters of type integer and real(8) array that is allocatable.", "input": "", "output": "  subroutine read_so4_theta_list(ths,noth,nol,ifile)\n    integer, intent(in) :: nol\n    character(*), intent(in) :: ifile\n    integer, intent(out) :: noth\n    real(8), allocatable, intent(out) :: ths(:,:)\n    real(8) :: th(6*nol)\n    integer :: i\n    open(10,file=ifile,action='read')\n    noth = 0\n    do \n       read(10,*,end=9) th\n       noth = noth + 1\n    end do\n9   rewind(10)\n    allocate(ths(6*nol,noth))\n    do i = 1, noth\n       read(10,*) th\n       ths(:,i) = th\n    end do \n    close(10)\n  end subroutine read_so4_theta_list\n"}, {"instruction": "Write a Fortran subroutine named triad that calculates the linear combination of two real arrays and a scalar value. The subroutine takes 3 input parameters of type real arrays and a single real scalar value. It produces 1 output parameter of a real array.", "input": "", "output": "    subroutine triad(a, b, scalar, c)\n    real, intent(in) :: a(:), b(:), scalar\n    real, intent(out) :: c(:)\n    integer :: n, i\n    n = size(a)\n    do concurrent (i = 1:n)\n        c(i) = a(i) + scalar * b(i)\n    end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calcenergy to calculate potential energy in a molecular system. The subroutine takes 6 input parameters: 3 integers, an array of real(8) with dimensions (0:natom-1, 0:dim-1), and 2 real(8) values. The output parameter is a single real(8) value. The subroutine uses the imperative tone to initialize variables, perform computations, and apply conditional checks to calculate potential energy based on the Lennard-Jones potential and harmonic bonding potential.", "input": "", "output": "subroutine calcenergy(pos, m, l, rc, penergy, dim, natom)\r\n    implicit none\r\n    integer, intent(in) :: m, dim, natom\r\n    real(8), intent(in), dimension(0:natom-1, 0:dim-1) :: pos\r\n    real(8), intent(in) :: l, rc\r\n    real(8), intent(out) :: penergy\r\n    real(8), parameter :: k = 3000., r0 = 1.\r\n    integer:: i, j\r\n    real(8) :: kfac, d2, sep, disp, shiftval, rc2, id6, id2, id12\r\n    real(8), dimension(dim) :: rij, posi\r\n    \r\n\r\n    !assign initially zeros to the force array and potential energy\r\n    penergy = 0.\r\n    rc2 = rc**2\r\n\r\n    !precompute constants such as lj shift value up here\r\n    kfac = k/2.\r\n    id6 = 1./rc**6\r\n    shiftval = 4*(id6**2 - id6)\r\n\r\n\r\n    do i=0, natom - 1\r\n        !store pos(i,:) in a temporary array for faster access in j looop\r\n        posi = pos(i,:)\r\n        do j = i+1, natom - 1\r\n            !compute initial rij\r\n            rij = pos(j,:) - posi\r\n            !apply minimum image convention\r\n            rij = rij - l*dnint(rij / l)\r\n\r\n            !do bonded calculation\r\n            if ( j == i+1 .and. mod(j, m)> 0) then\r\n                !compute scalar separation\r\n                sep = sqrt( sum( rij * rij ) )\r\n                !compute displacement relative to preferred separation\r\n                disp = sep - r0\r\n                !calculate energy\r\n                penergy = penergy + kfac * disp*disp\r\n            else   !do nonbonded calculation\r\n                !compute scalar distance\r\n                d2 = sum(rij*rij)\r\n                !check against cutoff\r\n                if ( d2 > rc2) then \r\n                    cycle\r\n                end if\r\n                id2 = 1./d2                 !inverse squared distance\r\n                id6 = id2 * id2 * id2       !inverse sixth distance\r\n                id12 = id6 * id6            !inverse twelfth distance\r\n                penergy = penergy + 4. * (id12 - id6) + shiftval\r\n\r\n                !end nonbonded calculation\r\n            endif\r\n        enddo\r\n    enddo\r\nend subroutine\r\n"}, {"instruction": "Write a Fortran subroutine named split_array to divide an array into segments for parallel processing. The subroutine takes 3 input parameters of type integer: numpoints, ncpu, and n. It returns 2 output parameters also of type integer: counts and displs. The subroutine calculates the counts and displacements for each segment based on the number of points, CPU count, and the segment index.", "input": "", "output": "      subroutine split_array(numpoints,n,ncpu,counts,displs)\n      implicit none\n      integer, intent(in) :: numpoints,ncpu,n\n      integer, intent(out) :: counts,displs\n\n      integer :: ratio, remainder, i\n\n      ratio = numpoints / ncpu\n      remainder = mod(numpoints,ncpu)\n\n      if(n < remainder) then\n         counts = ratio+1\n         displs = i*(ratio+1)\n      else\n         counts = ratio\n         displs = remainder*(ratio+1)+(i-remainder)*ratio\n      endif   \n      \n      end subroutine split_array\n"}, {"instruction": "Create a Fortran subroutine named polynomial_u_basis that generates powers of the input parameter u up to the power of n_g - 1. The subroutine takes 2 input parameters of type real and integer and returns 2 output parameters of type real and real (optional). If the optional output parameter dg_du is not provided, it will not be computed.", "input": "", "output": "subroutine polynomial_u_basis(u, n_g, g, dg_du)\n\n! generates powers of u, u**n where n ranges from 0 to n_g - 1\n\n\timplicit none\n\t\n\treal, intent(in) :: u\n\tinteger, intent(in) :: n_g\n\treal, intent(out) :: g(n_g)\n\treal, optional, intent(out) :: dg_du(n_g)\n\t\n\tinteger :: i\n\t\n\tg(1) = 1.\n\t\n\tdo i = 2, n_g\n\t\tg(i) = u * g(i-1)\n\tend do\n\t\n\tif (.not.present(dg_du))\treturn\n\t\n! derivatives\n\t\n\tdo i = 1, n_g\n\t\tdg_du(i) = (i-1) * g(i-1)\n\tend do\n\nend subroutine polynomial_u_basis\t\n"}, {"instruction": "Create a Fortran subroutine named cos_theta_basis to calculate the values of cos(n * theta) and its derivative with respect to theta. The subroutine takes 2 input parameters of type real and integer. The output consists of 2 parameters of type real and real (optional). If the optional output parameter is provided, the derivative of cos(n * theta) with respect to theta is also computed.", "input": "", "output": "subroutine cos_theta_basis(theta, n_cosn, cosn, dcosn_dtheta)\n\n! generates cos(n * theta) where n ranges from 0 to n_g-1\n\n\timplicit none\n\t\n\treal, intent(in) :: theta\n\tinteger, intent(in) :: n_cosn\n\treal, intent(out) :: cosn(n_cosn)\n\treal, optional, intent(out) :: dcosn_dtheta(n_cosn)\n\t\n\tinteger :: i\n\t\n\tcosn(1) = 1.\n\t\n\tdo i = 2, n_cosn\n\t\tcosn(i) = cos((i-1) * theta)\n\tend do\n\t\n\tif (.not.present(dcosn_dtheta))\treturn\n\t\n\tdcosn_dtheta(1) = 0.\n\t\n\tdo i = 2, n_cosn\n\t\tdcosn_dtheta(i) = -(i-1)*sin((i-1) * theta)\n\tend do\n\t\n\treturn\n\t\nend subroutine cos_theta_basis\t\n"}, {"instruction": "Write a Fortran subroutine named split_line to parse a line of text and extract the name and value separated by an equal sign. The input parameter is a character string (len=*), and the output parameters are two character strings (len=*) and an integer. The subroutine splits the input line into the name and value, and sets the status integer to 0 if successful, or 1 if no equal sign is found in the input line.", "input": "", "output": "    subroutine split_line(line, name, val, stat)\n        implicit none\n        character(len=*), intent(in) :: line\n        character(len=*), intent(out) :: name, val\n        integer, intent(out) :: stat\n        integer :: pos\n\n        pos = index(line, '=')\n        if (pos == 0) then\n            stat = 1\n        end if\n        name = line(:pos-1)\n        val = adjustl(line(pos+1:))\n        stat = 0\n    end subroutine split_line\n"}, {"instruction": "Create a Fortran subroutine named msh to generate a uniform mesh on the interval [0,1]. The subroutine should take 1 input parameter of type integer and produce 1 output parameter of type double precision.", "input": "", "output": "  subroutine msh(ntst,tm)\n\n! generates a uniform mesh on [0,1].\n\n    integer, intent(in) :: ntst\n    double precision, intent(out) :: tm(0:ntst)\n\n    integer j\n\n    do j=0,ntst\n       tm(j)=dble(j)/ntst\n    enddo\n\n  end subroutine msh\n"}, {"instruction": "Create a Fortran subroutine named cpnts to generate collocation points within the interval [0,1]. The subroutine takes 1 input parameter of type integer and outputs an array of double precision numbers.", "input": "", "output": "  subroutine cpnts(ncol,zm)\n\n! generates the collocation points with respect to [0,1].\n\n    integer, intent(in) :: ncol\n    double precision, intent(out) :: zm(ncol)\n\n    double precision, parameter :: &\n         c51 = .5d0*0.90617984593866399280d0, &\n         c52 = .5d0*0.53846931010568309104d0, &\n         c61 = .5d0*0.93246951420315202781d0, &\n         c62 = .5d0*0.66120938646626451366d0, &\n         c63 = .5d0*0.23861918608319690863d0, &\n         c71 = .5d0*0.949107991234275852452d0, &\n         c72 = .5d0*0.74153118559939443986d0, &\n         c73 = .5d0*0.40584515137739716690d0, &\n         r = 6.0d0/7.0d0\n\n    double precision c21,c31,c4,c41,c42\n\n    select case(ncol)\n       case(2)\n          c21 = .5d0/sqrt(3.0d0)\n          zm(1) = .5d0-c21\n          zm(2) = .5d0+c21\n       case(3)\n          c31 = .5d0*sqrt(0.6d0)\n          zm(1) = .5d0-c31\n          zm(2) = .5d0\n          zm(3) = .5d0+c31\n       case(4)\n          c4  = .5d0*sqrt(r**2-12.0d0/35.0d0)\n          c41 = .5d0*sqrt(3.0d0/7.0d0+c4)\n          c42 = .5d0*sqrt(3.0d0/7.0d0-c4)\n          zm(1) = .5d0-c41\n          zm(2) = .5d0-c42\n          zm(3) = .5d0+c42\n          zm(4) = .5d0+c41\n       case(5)\n          zm(:) = (/ .5d0-c51, .5d0-c52, .5d0, .5d0+c52, .5d0+c51 /)\n       case(6)\n          zm(:) = (/ .5d0-c61, .5d0-c62, .5d0-c63, &\n                     .5d0+c63, .5d0+c62, .5d0+c61 /)\n       case(7)\n          zm(:) = (/ .5d0-c71, .5d0-c72, .5d0-c73, .5d0, &\n                     .5d0+c73, .5d0+c72, .5d0+c71  /)\n    end select\n  end subroutine cpnts\n"}, {"instruction": "Create a Fortran subroutine named cntdif to generate the coefficients of the central difference formula for the nth derivative at uniformly spaced points. The subroutine takes 1 input parameter of type integer and outputs an array of integers. The input parameter represents the order of the derivative, and the output array stores the coefficients. Use the imperative tone to specify the subroutine name and its functionality.", "input": "", "output": "  subroutine cntdif(n,d)\n\n! generates the coefficients of the central difference formula for\n! nth derivative at uniformly spaced points\n!              0 = x  < x  < ... < x  = 1.\n!                   0    1          n\n    integer, intent(in) :: n\n    integer, intent(out) :: d(0:n)\n\n    integer i,k\n\n    d(0)=1\n    if(n.eq.0)return\n\n    do i=1,n\n       d(i)=0\n       do k=i,1,-1\n          d(k)=d(k-1)-d(k)\n       enddo\n       d(0)=-d(0)\n    enddo\n\n  end subroutine cntdif\n"}, {"instruction": "Create a Fortran subroutine named wint to generate weights for an integration formula based on polynomial interpolation at ncol+1 equally spaced points in the interval [0,1]. The subroutine takes 1 input argument of type integer and returns 1 output argument of type double precision.", "input": "", "output": "  subroutine wint(ncol,wi)\n\n! generates the weights for the integration formula based on polynomial\n! interpolation at ncol+1 equally spaced points in [0,1].\n\n    integer, intent(in) :: ncol\n    double precision, intent(out) :: wi(0:ncol)\n\n    double precision c\n\n    select case(ncol)\n    case(2)\n       c=1.d0/6.0d0\n       wi(0)=c\n       wi(1)=4.0d0*c\n       wi(2)=c\n    case(3)\n       c=1.d0/8.0d0\n       wi(0)=c\n       wi(1)=3.0d0*c\n       wi(2)=wi(1)\n       wi(3)=c\n    case(4)\n       c=1.d0/90.0d0\n       wi(0)=7.0d0*c\n       wi(1)=32.0d0*c\n       wi(2)=12.0d0*c\n       wi(3)=wi(1)\n       wi(4)=wi(0)\n    case(5)\n       wi(0)=19.0d0/288.0d0\n       wi(1)=25.0d0/96.0d0\n       wi(2)=25.0d0/144.0d0\n       wi(3)=wi(2)\n       wi(4)=wi(1)\n       wi(5)=wi(0)\n    case(6)\n       wi(0)=41.0d0/840.0d0\n       wi(1)=9.0d0/35.0d0\n       wi(2)=9.0d0/280.0d0\n       wi(3)=34.0d0/105.0d0\n       wi(4)=wi(2)\n       wi(5)=wi(1)\n       wi(6)=wi(0)\n    case(7)\n       wi(0)=751.0d0/17280.0d0\n       wi(1)=3577.0d0/17280.0d0\n       wi(2)=49.0d0/640.0d0\n       wi(3)=2989.0d0/17280.0d0\n       wi(4)=wi(3)\n       wi(5)=wi(2)\n       wi(6)=wi(1)\n       wi(7)=wi(0)\n    end select\n\n  end subroutine wint\n"}, {"instruction": "Please write a Fortran subroutine named intwts that generates weights for Lagrange interpolation. The subroutine takes 3 input parameters, which are an integer (n), a double precision number (z), and an array of double precision numbers (x) with a size of (0:n). The subroutine also has 1 output parameter, which is an array of double precision numbers (wts) with a size of (0:n). The purpose of this subroutine is to compute the weights that will be used in Lagrange interpolation. The weights are computed based on the given input values (n, z, and x) using nested loops and mathematical formulas.", "input": "", "output": "  subroutine intwts(n,z,x,wts)\n\n! generates weights for lagrange interpolation.\n\n    integer, intent(in) :: n\n    double precision, intent(in) :: z, x(0:n)\n    double precision, intent(out) :: wts(0:n)\n\n    integer ib,k\n    double precision p\n\n    do ib=0,n\n       p=1.d0\n       do k=0,n\n          if(k/=ib)then\n             p=p*( z-x(k) )/( x(ib)-x(k) )\n          endif\n       enddo\n       wts(ib)=p\n    enddo\n\n  end subroutine intwts\n"}, {"instruction": "Create a Fortran subroutine called cumtrapz that performs numerical integration using the trapezoidal rule on evenly spaced data. The subroutine takes in four input parameters: dx (real*8), z0 (real*8), n (integer), and y(n) (real*8 array). The output parameter is z(n) (real*8 array).\n\nTo use the subroutine, provide the desired spacing between data points (dx), the initial value for the cumulative integral (z0), the number of data points (n), and the array of data points (y). The subroutine will calculate the cumulative integral using the trapezoidal rule and store the result in the array z.\n\nEnsure that the input parameters dx, z0, and y(n) are of type real*8, and the input parameter n is of type integer. The output parameter z(n) should also be of type real*8.\n\nNote: The trapezoidal rule is a numerical integration method that approximates the integral of a function by dividing the area under the curve into trapezoids.", "input": "", "output": "subroutine cumtrapz(y,z,n,dx,z0) bind(c)\n! \u7b49\u95f4\u9694dx\u79bb\u6563\u6570\u636e\u68af\u5f62\u6cd5\u7d2f\u79ef\u6570\u503c\u79ef\u5206\uff0c\u7ed3\u679c\u4fdd\u5b58\u5728\u6570\u7ec4z\u4e2d\uff0c\u521d\u503c\u4e3az0\n\n    real*8, intent(in) :: dx, z0\n    integer, intent(in) :: n\n    real*8, intent(in) :: y(n)\n    real*8, intent(out) :: z(n)\n\n    integer :: i\n    real*8 :: r\n\n    z(1) = z0\n    r = 0.d0\n    do i = 2, n, 1\n        r = r + dx*(y(i)+y(i-1))*0.5\n        z(i) = z0 + r\n    end do\n    return\n\nend subroutine cumtrapz\n"}, {"instruction": "Write a Fortran subroutine named `fftfreqs` that calculates the frequency axis values for the discrete Fourier transform. The subroutine takes two input parameters: `nfft` of type integer, representing the size of the Fourier transform, and `fs` of type real(8), representing the sampling frequency. The subroutine also has one output parameter: `freqs` of type real(8) array, which stores the calculated frequency values.\n\nThe subroutine first calculates the Nyquist frequency (`fn`) by dividing the sampling frequency (`fs`) by 2. It then calculates the frequency resolution (`df`) by dividing the sampling frequency by the number of points in the Fourier transform (`nfft`). \n\nThe `freqs` array is initialized to zero. If the number of points in the Fourier transform is even, the subroutine computes the positive frequency values from 0 to `fn` and the negative frequency values from `-fn` to the second-to-last element of the `freqs` array. If the number of points in the Fourier transform is odd, the subroutine computes the positive frequency values from 0 to `fn` and the negative frequency values from `-fn` to the last element of the `freqs` array.\n\nThe subroutine returns the computed frequency values in the `freqs` array.", "input": "", "output": "subroutine fftfreqs(nfft,fs,freqs) bind(c)\n!dir$ attributes dllexport :: fftfreqs\n! \u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\u7684\u9891\u7387\u8f74\u523b\u5ea6\u503c\uff0cfs\u4e3a\u91c7\u6837\u9891\u7387\uff0c\u7ed3\u679c\u8bb0\u5f55\u5728\u6570\u7ec4freqs\u4e2d\n    integer, intent(in) :: nfft\n    real(8), intent(in) :: fs\n    real(8), intent(out) :: freqs(nfft)\n\n    real(8) :: fn, df\n    integer :: i, l\n\n    fn = 0.5d0*fs\n    df = fs/dble(nfft)\n    freqs = 0.0d0\n\n    if ( mod(nfft, 2) == 0 ) then\n        l = nfft/2-1\n        freqs(2:nfft/2) = [ ( (dble(i)*df), i=1,l ) ]\n        freqs(nfft/2+1:nfft) = [ ( -fn+(dble(i-1)*df), i=1,l+1 ) ]\n    else\n        l = (nfft+1)/2-1\n        freqs(2:(nfft+1)/2) = [ ( (dble(i)*df), i=1,l ) ]\n        freqs((nfft+1)/2+1:nfft) = [ ( -(dble(l-i+1)*df), i=1,l ) ]\n    end if\n\n    return\nend subroutine fftfreqs\n"}, {"instruction": "Write a Fortran subroutine named acc2vd that integrates acceleration to compute velocity and displacement. The subroutine takes 5 input parameters: dt (real(8)), v0 (real(8)), d0 (real(8)), n (integer(4)), and a (real(8) array of size n). It also has 2 output parameters: v (real(8) array of size n) and d (real(8) array of size n).\n\nInside the subroutine, the velocity and displacement are calculated using a numerical integration method. The initial velocity v0 and displacement d0 are assigned to the first elements of the v and d arrays. Then, a loop is executed from i=2 to n, where the velocity and displacement at each step are computed based on the previous values and the acceleration values in the a array.\n\nThe subroutine uses the midpoint rule to perform the integration, where the velocity (v) is updated by adding the average acceleration between two time steps multiplied by the time step (dt). Similarly, the displacement (d) is updated by adding the average velocity between two time steps multiplied by the time step (dt).\n\nFinally, the subroutine returns, and the updated velocity and displacement arrays are available for further processing.\n\nRemember to compile and link the subroutine accordingly to use it in your program.", "input": "", "output": "subroutine acc2vd(a,v,d,n,dt,v0,d0) bind(c)\n!dir$ attributes dllexport :: acc2vd\n! \u52a0\u901f\u5ea6\u79ef\u5206\u4e3a\u901f\u5ea6\u3001\u4f4d\u79fb\n    real(8), intent(in) :: dt,v0,d0\n    integer(4), intent(in) :: n\n    real(8), intent(in) :: a(n)\n    real(8), intent(out) :: v(n), d(n)\n\n    integer(4) :: i\n    real(8) :: vi, di\n\n    v(1) = v0\n    d(1) = d0\n\n    vi = 0.d0\n    di = 0.d0\n    do i = 2, n, 1\n        vi = vi + dt*(a(i)+a(i-1))*0.5\n        v(i) = v0 + vi\n        di = di + dt*(v(i)+v(i-1))*0.5\n        d(i) = d0 + di\n    end do\n    return\nend subroutine acc2vd\n"}, {"instruction": "Create a Fortran subroutine named error to calculate the relative errors between two arrays, y and y0, excluding the first and last elements. The number of input arguments is 3 with test_data types ['integer', 'real(8)', 'real(8)']. The number of output arguments is 2 with test_data types ['real(8)', 'real(8)'].", "input": "", "output": "subroutine error(y,y0,n,aerror,merror) bind(c)\n! \u8ba1\u7b97\u6570\u7ec4y\u548cy0\u7684\u76f8\u5bf9\u8bef\u5dee\uff08\u4e0d\u5305\u62ec\u9996\u5c3e\u5143\u7d20\uff09\uff0caerror \u4e3a\u5e73\u5747\u8bef\u5dee\uff0cmerror \u4e3a\u6700\u5927\u8bef\u5dee\n    integer, intent(in) :: n\n    real(8), intent(in) :: y(n), y0(n)\n    real(8), intent(out) :: aerror, merror\n\n    real(8), allocatable :: e(:)\n\n    allocate(e(n-2))\n\n    e = (y(2:n-1) - y0(2:n-1))/y0(2:n-1)\n\n    !aerror = sum(abs(e))/dble(n-2)\n    aerror = sqrt(sum(e*e)/dble(n-2))\n    merror = maxval(abs(e), dim=1)\n\n    deallocate(e)\n\nend subroutine error\n"}, {"instruction": "Create a Fortran subroutine named errora to calculate the relative errors between two arrays of real(8) numbers. The subroutine takes 3 input parameters of type integer, real(8) array, and real(8) array. It returns 2 output parameters of type real(8) for average error and maximum error.", "input": "", "output": "subroutine errora(y,y0,n,aerror,merror) bind(c)\n! \u8ba1\u7b97\u6570\u7ec4y\u548cy0\u7684\u76f8\u5bf9\u8bef\u5dee\uff08\u5305\u62ec\u6240\u6709\u5143\u7d20\uff09\uff0caerror \u4e3a\u5e73\u5747\u8bef\u5dee\uff0cmerror \u4e3a\u6700\u5927\u8bef\u5dee\n    integer, intent(in) :: n\n    real(8), intent(in) :: y(n), y0(n)\n    real(8), intent(out) :: aerror, merror\n\n    real(8), allocatable :: e(:)\n\n    allocate(e(n))\n\n    e = (y - y0)/y0\n\n    !aerror = sum(abs(e))/dble(n)\n    aerror = sqrt(sum(e*e)/dble(n))\n    merror = maxval(abs(e), dim=1)\n\n    deallocate(e)\n\nend subroutine errora\n"}, {"instruction": "Write a Fortran subroutine named fftpadding to perform zero-padding on a data sequence. The subroutine takes 3 input parameters of type integer, integer, and real*8, and 1 output parameter of type real*8. The input parameters represent the length of the input data, the desired length after padding, and the input data sequence. The output parameter represents the padded data sequence.", "input": "", "output": "subroutine fftpadding(in,out,n,nfft) bind(c)\n! \u6570\u636e\u5e8f\u5217\u540e\u8865\u96f6\n    integer, intent(in) :: n, nfft\n    real*8, intent(in) :: in(n)\n    real*8, intent(out) :: out(nfft)\n\n    out(1:n) = in(1:n)\n    out(n+1:nfft) = 0.d0\n\n    return\nend subroutine fftpadding\n"}, {"instruction": "Create a Fortran subroutine named \"newmark\" to perform Newmark's method for solving dynamic equilibrium equations. The subroutine should have 5 input parameters of types integer, real(8), real(8), real(8), and real(8), and 5 output parameters of types real(8), real(8), real(8), real(8), and integer. The subroutine computes and returns the values of \"spa\", \"spv\", \"spd\", \"spe\", and \"spi\" based on the input parameters \"acc\", \"n\", \"dt0\", \"zeta\", and \"p\".", "input": "", "output": "subroutine newmark(acc,n,dt0,zeta,p,spa,spi,spv,spd,spe) bind(c)\n\n    integer, intent(in) :: n\n    real(8), intent(in) :: dt0, zeta\n    real(8), intent(in) :: acc(n), p\n    real(8), intent(out) :: spa, spv, spd, spe\n    integer, intent(out) :: spi\n\n    real(8) :: rc(3),rl(3),ac,al,aa,ein,da\n    real(8) :: beta = 1.d0/4.d0, gamma = 0.5d0\n    real(8) :: k,c,w,keff,kinv,feff,dt,rvl\n    real(8) :: b1, b2, b3, b4, b5, b6, b7, b8\n    integer :: i,j,r\n\n    if ( dt0*mpr > p ) then\n        r  = ceiling(mpr*dt0/p)\n        dt = dt0/r\n    else\n        r = 1\n        dt = dt0\n    end if\n\n    b1 = 1.d0/(beta*dt*dt)\n    b2 = 1.d0/(beta*dt)\n    b3 = 1.d0/(beta*2.0d0)-1.d0\n    b4 = gamma/(beta*dt)\n    b5 = gamma/beta-1.d0\n    b6 = 0.5d0*dt*(gamma/beta-2.0d0)\n    b7 = dt*(1.0d0-gamma)\n    b8 = dt*gamma\n\n    w = two_pi/p\n    k = w**2.d0\n    c = 2.0d0*zeta*w\n    keff = k+b1+b4*c\n    kinv = 1.0d0/keff\n\n    !  initiation\n    rl = 0.d0\n    rc = 0.d0\n    spa = 0.0d0\n    spv = 0.0d0\n    spd = 0.0d0\n    spi = 0\n    ein = 0.0d0\n    al = 0.d0\n    rvl = 0.d0\n\n    !  computation of response\n    do i = 1,n,1\n\n        ac = acc(i)\n        da = (ac - al)/dble(r)\n\n        do j = 1, r, 1\n            ac = al + da*j\n            feff = ac+(b1*rl(1)+b2*rl(2)+b3*rl(3))&\n            +c*(b4*rl(1)+b5*rl(2)+b6*rl(3))\n            rc(1) = feff*kinv\n            rc(2) = b4*(rc(1)-rl(1))-b5*rl(2)-b6*rl(3)\n            rc(3) = ac-k*rc(1)-c*rc(2)\n            rl(1) = rc(1)\n            rl(2) = rc(2)\n            rl(3) = rc(3)\n        end do\n\n        ein = ein+0.5d0*dt0*(rvl*al+rc(2)*ac)\n        aa = -rc(3)+ac\n\n        if (abs(aa) > abs(spa)) then\n            spa=aa\n            spi=i\n        endif\n\n        if (abs(rc(2)) > abs(spv)) then\n            spv=rc(2)\n        endif\n\n        if (abs(rc(1)) > abs(spd)) then\n            spd=rc(1)\n        endif\n\n        al = ac\n        rvl = rc(2)\n\n    end do\n    spe = sqrt(2.d0*ein)\n    return\nend subroutine newmark\n"}, {"instruction": "Create a Fortran subroutine named rnmk with 5 input parameters of type integer, real(8), real(8), real(8), real(8) and 3 output parameters of type real(8), real(8), real(8). The subroutine computes the response of a dynamic system using the Newmark-beta method for structural dynamics. The input parameters represent acceleration, time step, damping ratio, load period, and load magnitude, while the output parameters represent the response acceleration, velocity, and displacement.", "input": "", "output": "subroutine rnmk(acc,n,dt0,zeta,p,ra,rv,rd) bind(c)\n!dir$ attributes dllexport :: rnmk\n    integer, intent(in) :: n\n    real(8), intent(in) :: dt0, zeta\n    real(8), intent(in) :: acc(n), p\n    real(8), intent(out) :: ra(n),rv(n),rd(n)\n\n    real(8) :: rc(3),rl(3),ac,al,aa,da\n    real(8) :: beta = 1.d0/4.d0, gamma = 0.5d0\n    real(8) :: k,c,w,keff,kinv,feff,dt,rvl\n    real(8) :: b1, b2, b3, b4, b5, b6, b7, b8\n    integer :: i,j,r\n\n    if ( dt0*mpr > p ) then\n        r  = ceiling(mpr*dt0/p)\n        dt = dt0/r\n    else\n        r = 1\n        dt = dt0\n    end if\n\n    b1 = 1.d0/(beta*dt*dt)\n    b2 = 1.d0/(beta*dt)\n    b3 = 1.d0/(beta*2.0d0)-1.d0\n    b4 = gamma/(beta*dt)\n    b5 = gamma/beta-1.d0\n    b6 = 0.5d0*dt*(gamma/beta-2.0d0)\n    b7 = dt*(1.0d0-gamma)\n    b8 = dt*gamma\n\n    w = two_pi/p\n    k = w**2.d0\n    c = 2.0d0*zeta*w\n    keff = k+b1+b4*c\n    kinv = 1.0d0/keff\n\n    !  initiation\n    rl = 0.d0\n    rc = 0.d0\n    ra = 0.d0\n    rv = 0.d0\n    rd = 0.d0\n    al = 0.d0\n\n    !  computation of response\n    do i = 1, n, 1\n\n        ac = acc(i)\n        da = (ac - al)/dble(r)\n\n        do j = 1, r, 1\n            ac = al + da*j\n            feff = ac+(b1*rl(1)+b2*rl(2)+b3*rl(3))&\n            +c*(b4*rl(1)+b5*rl(2)+b6*rl(3))\n            rc(1) = feff*kinv\n            rc(2) = b4*(rc(1)-rl(1))-b5*rl(2)-b6*rl(3)\n            rc(3) = ac-k*rc(1)-c*rc(2)\n            rl(1) = rc(1)\n            rl(2) = rc(2)\n            rl(3) = rc(3)\n        end do\n\n        ra(i) = -rc(3)+ac\n        rv(i) = -rc(2)\n        rd(i) = -rc(1)\n\n        al = ac\n\n    end do\n    return\nend subroutine rnmk\n"}, {"instruction": "Write a Fortran subroutine named energy that takes 9 input parameters of types integer and real(8) and 5 output parameters of type real(8). The input parameters are acc, n, dt, zeta, p, ra, rv, rd, and ku. The output parameters are ek, ez, es, eh, and ein. The subroutine calculates the energy values for a given system and updates the output parameters accordingly.", "input": "", "output": "subroutine energy(acc,n,dt,zeta,p,ra,rv,rd,ek,ez,es,eh,ein,ku) bind(c)\n!dir$ attributes dllexport :: energy\n    integer, intent(in) :: n\n    real(8), intent(in) :: acc(n), ra(n), rv(n), rd(n), ku(n)\n    real(8), intent(in) :: dt, zeta, p\n    real(8), intent(out) :: ek(n),ez(n),es(n),eh(n),ein(n)\n\n    integer :: i\n    real(8) :: w, fs(2), ea, c, ddsub(2)\n\n    w = two_pi/p\n    c = 2.d0*zeta*w\n\n    ek(1) = rv(1)*rv(1)*0.5d0\n    ez(1) = 0.5d0*dt*(0.d0+c*rv(1)*rv(1))\n    fs = [0.d0, -ra(1)-c*rv(1)]\n    ea = 0.5d0*dt*(0.d0+fs(2)*rv(1))\n    es(1) = fs(2)*fs(2)*0.5d0/(ku(1))\n    eh(1) = ea - es(1)\n    ein(1) = 0.5d0*dt*(0.d0-acc(1)*rv(1))\n!     bl(1) = ein(1) - ek(1) - ez(1) - ea\n\n    do i = 2, n, 1\n        ek(i) = rv(i)*rv(i)*0.5d0\n        ez(i) = ez(i-1) + 0.5d0*dt*c*(rv(i-1)*rv(i-1)+rv(i)*rv(i))\n\n        fs(1) = - ra(i-1) - c*rv(i-1)\n        fs(2) = - ra(i) - c*rv(i)\n        \n        if (fs(1)*fs(2)<0.d0) then\n            ddsub(1) = (0.d0-fs(1))/ku(i-1)\n            ddsub(2) = fs(2)/ku(i)\n            ea = ea + 0.5d0*ddsub(1)*(fs(1)+0.d0) + 0.5d0*ddsub(2)*(0.d0+fs(2))\n        else\n            ea = ea + 0.5d0*(rd(i)-rd(i-1))*(fs(1)+fs(2))\n        end if\n        \n        !ea = ea + 0.5d0*(rd(i)-rd(i-1))*(fs(1)+fs(2))\n        !ea = ea + 0.5d0*dt*(fs(1)*rv(i-1)+fs(2)*rv(i))\n        es(i) = fs(2)*fs(2)*0.5d0/(ku(i))\n        eh(i) = ea - es(i)\n\n        ein(i) = ein(i-1) - 0.5d0*dt*(acc(i-1)*rv(i-1)+acc(i)*rv(i))\n!         bl(i) = ein(i) - ek(i) - ez(i) - ea\n\n    end do\nend subroutine energy\n"}, {"instruction": "Write a Fortran subroutine named flat_double that takes a 2D array \"a\" of size n x m as input, and flattens it into a 1D array \"af\" of size n * m as output. The input parameters consist of two integers n and m, and a real(8) array a(n,m). The output parameter is a real(8) array af(n*m).", "input": "", "output": "subroutine flat_double(a,n,m,af)\n\n    integer, intent(in) :: n, m\n    real(8), intent(in) :: a(n,m)\n    real(8), intent(out) :: af(n*m)\n\n    integer :: i, j\n\n    do i = 1, n, 1\n        do j = 1, m, 1\n            af(n*(j-1)+i) = a(i,j)\n        end do\n    end do\n\nend subroutine flat_double\n"}, {"instruction": "Create a Fortran subroutine named repeat_double that takes in three input parameters: n and m of type integer, and a of type real(8). It also has one output parameter ar of type real(8). \n\nThe purpose of this subroutine is to repeat the elements of array a n times and store the result in array ar. The size of array ar is n*m. \n\nTo achieve this, iterate through the elements of a for m times and assign them to the corresponding positions in ar. The elements of a will be repeated n times in ar.\n\nProvide the required input and output parameters when calling this subroutine to perform the desired operation.", "input": "", "output": "subroutine repeat_double(a,n,m,ar)\n    integer, intent(in) :: n,m\n    real(8), intent(in) :: a(n)\n    real(8), intent(out) :: ar(n*m)\n\n    integer :: i\n\n    do i = 1, m, 1\n        ar((i-1)*n+1:(i-1)*n+n) = a\n    end do\n    \nend subroutine repeat_double\n"}, {"instruction": "Write a Fortran subroutine named \"wfunc\" that computes a waveform based on given parameters. The subroutine takes 5 input arguments of types ['integer', 'integer', 'real(8)', 'real(8)', 'real(8)'] and 1 output argument of type ['real(8)'].\n\nThe subroutine performs the following steps:\n1. Allocate memory for an array \"tmp2\" of size \"n\".\n2. Calculate the value of \"tm\" as the product of \"dt\" and \"itm-1\".\n3. Calculate the value of \"w\" as the quotient of \"two_pi\" and \"p\".\n4. Calculate the value of \"f\" as the reciprocal of \"p\".\n5. Calculate the value of \"tmp1\" as the square root of \"1.0\" minus the square of \"zeta\".\n6. Calculate the value of \"gamma\" using a formula involving \"f\" and \"tmp1\".\n7. Calculate the value of \"deltat\" as the arctangent of \"tmp1/zeta\" divided by the product of \"w\" and \"tmp1\".\n8. Fill the array \"tmp2\" with values calculated using a loop and store the results of the expression \"(dble(i-1)*dt-tm+deltat)\" for each index \"i\".\n9. Compute the waveform \"wf\" using the cosine and exponential functions applied to the array \"tmp2\".\n10. Deallocate the memory allocated for \"tmp2\".\n\nMake sure to include the necessary Fortran keywords and follow the specified data types for the input and output arguments.", "input": "", "output": "subroutine wfunc(n,dt,itm,p,zeta,wf) bind(c)\n\n    integer, intent(in) :: n, itm\n    real(8), intent(in) :: dt, p, zeta\n    real(8), intent(out) :: wf(n)\n\n    real(8) :: tm, w, f, tmp1, gamma, deltat\n    real(8), allocatable :: tmp2(:)\n    integer :: i\n\n    allocate(tmp2(n))\n\n    tm = dble(itm-1)*dt\n    w = two_pi/p\n    f = 1.d0/p\n\n    tmp1 = sqrt(1.d0-zeta**2)\n    gamma = 1.178d0*(f*tmp1)**(-0.93d0)\n    deltat = atan(tmp1/zeta)/(w*tmp1)\n\n    tmp2 = [ ( ( dble(i-1)*dt-tm+deltat ),i=1,n ) ]\n\n    wf = cos(w*tmp1*tmp2)*exp(-(tmp2/gamma)**2)\n\n    deallocate(tmp2)\n\n    return\nend subroutine wfunc\n"}, {"instruction": "Write a Fortran subroutine named num_to_g that takes two input arrays: num which is an array of integers and nf which is a 2D array of integers. The subroutine also has one output array named g, which is an array of integers. \n\nThe subroutine will perform a calculation where it assigns values to g based on the values in num and nf. The size of the arrays will be determined by the dimensions of num and nf. \n\nTo perform the calculation, the subroutine will iterate over the elements of num and for each element, it will use it to extract values from nf and assign them to consecutive elements of g. \n\nFinally, the subroutine will return the updated array g.", "input": "", "output": "subroutine num_to_g(num,nf,g)\r\n!\r\n\n!\r\n implicit none\r\n integer,intent(in)::num(:),nf(:,:)  \r\n integer,intent(out)::g(:)\r\n integer::i,k,nod,nodof \r\n nod=ubound(num,1) \r\n nodof=ubound(nf,1)\r\n do i=1,nod\r\n   k=i*nodof\r\n   g(k-nodof+1:k)=nf(:,num(i))\r\n end do\r\nreturn\r\nend subroutine num_to_g   \r\n"}, {"instruction": "Create a Fortran subroutine called selectedrealkind to calculate the value of a selected kind parameter for a real number. The subroutine takes two input arguments, both of type integer, and one output argument of type integer. The input arguments represent the precision and range values, while the output argument stores the calculated selected kind parameter.", "input": "", "output": "subroutine selectedrealkind(p, r, res)\n  implicit none\n\n  integer, intent(in) :: p, r\n  !f2py integer :: r=0\n  integer, intent(out) :: res\n  res = selected_real_kind(p, r)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named selectedintkind that takes an integer value as input and returns the corresponding kind value as output. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine selectedintkind(p, res)\n  implicit none\n\n  integer, intent(in) :: p\n  integer, intent(out) :: res\n  res = selected_int_kind(p)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"inarea\" that determines whether a given point (specified by its polar coordinates phi, rho, and z) lies within a specific integral area. The subroutine takes three input arguments of type real(8) - phi, rho, and z. It also has one output argument of type real(8) - h.\n\nTo determine if the point is within the integral area, the subroutine checks if the z-coordinate of the point lies between the lower and upper boundary of a cylindrical surface with a radius of 3. If z is within this range, h is set to 1. Otherwise, h is set to 0.\n\nEnsure that you specify the number and type of input and output parameters correctly in the instruction. The number of input parameters is 3, and their data types are real(8). The number of output parameters is 1, and its data type is real(8).", "input": "", "output": "subroutine inarea(phi, rho, z, h)\n    ! judge whether the dot is in the integral area\n    real(8), intent(in) :: phi, rho, z\n    real(8), intent(out) :: h\n\n    if ((z > -sqrt(9.d0 - rho**2)) .and. (z < sqrt(9.d0 - rho**2))) then\n        h = 1.d0\n    else\n        h = 0.d0\n    end if\nend subroutine inarea\n"}, {"instruction": "Write a Fortran subroutine named raz2 to perform a series of calculations based on the given input parameters. The number of input parameters is 10, and the test_data types are ['integer', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real', 'real', 'real, optional']. The number of output parameters is 3, and the test_data types are ['real, dimension(n+1)', 'real, dimension(n+1)', 'real'].\n\nThe purpose of this subroutine is to compute values for the arrays e and t, as well as the scalar variable mu, based on the given input parameters. The subroutine follows the imperative style of programming and contains a do loop for iterative calculations. Additionally, it supports the optional input parameter p0.\n\nPlease refer to the code for further details on the calculations performed by the subroutine.", "input": "", "output": "  pure subroutine raz2(n, w, c, phi, u, alpha, b, h, f, e, t, mu, p0)\n    integer, intent(in) :: n\n    real, dimension(n), intent(in) :: w, c, phi, u, alpha, b\n    real, intent(in) :: h(n+1), f\n    real, dimension(n+1), intent(out) :: e, t\n    real, intent(out) :: mu\n    real, optional, intent(in) :: p0\n    integer :: i, j\n    real :: phim, tana, tana2\n\n    e = 0\n    t = 0\n    if(present(p0)) then\n      e(1) = p0\n      t(1) = p0\n    end if\n\n    do i = 2, n + 1\n      j = i - 1\n      tana = tan(alpha(j))\n      tana2 = tana**2\n      phim = tan(phi(j)) / f\n      e(i) = 2. * t(j) * (tana - phim) + e(j) * (1. + 2. * tana * phim - tana2)&\n           + w(j) * b(j) / 3. * (h(i) + 2. * h(j)) * (tana - phim)&\n           - b(j) * (1. + tana2) * (c(j) / f - u(j) * phim)\n      e(i) = e(i) / (1. + tana2)\n      t(i) = (e(i) + e(j)) * tana - t(j) + w(j) * b(j) / 6. * (h(i) - h(j))\n    end do\n    mu = 1. - e(n+1) / maxval(e)\n  end subroutine\n"}, {"instruction": "Provide a Fortran subroutine named \"k2_short\" that calculates the thermal conductivity coefficient \"k\" based on several input parameters. The subroutine takes 12 input arguments of various types, including an integer, arrays of real*8 values, and individual real*8 values. The output argument is a single real*8 value. \n\nThe purpose of the subroutine is to compute the thermal conductivity coefficient by performing a series of calculations using the input parameters. These calculations involve mathematical operations, array manipulations, and allocation and deallocation of arrays. The subroutine uses temporary arrays and intermediate variables to store intermediate results. Finally, the computed \"k\" value is assigned to the output argument.\n\nEnsure that the subroutine is called with appropriate input arguments and that the output argument receives the calculated thermal conductivity coefficient \"k\".", "input": "", "output": "subroutine k2_short(p,nz,t,tc,tab,ts0,tgamair,tgamself,tnair,tn0,nol,k,imax)\n\n    implicit none\n\n    integer,intent(in) :: imax\n    real*8,dimension(imax),intent(in) :: ts0,tc,tgamair,tgamself,tnair,tn0,tab\n    real*8,intent(in) :: nz,nol,t,p\n    real*8,intent(out) :: k\n    real*8,parameter :: tref = 296.0,kb = 1.3806488e-16,pi = 3.141592653589793238462643383279 !cgs\n    real*8, allocatable :: tgama(:),tflor(:),tk(:), tref2,tmp(:)\n    real*8,parameter :: rpi = 1/pi\n\n    allocate(tgama(imax),tflor(imax),tk(imax), tmp(imax))\n\n\n\n    tref2 = tref/t\n    tmp = (nol-tn0) ** 2\n\n\n\n    tgama = p*(tref2**tnair)*(tgamair*(1-tc*tab)+tgamself*tc*tab)\n\n\n\n    tflor = rpi*tgama/((tgama**2)+tmp)\n\n\n\n    tk  = ts0*tflor*tc\n\n    k = sum(tk)*nz\n\n    deallocate(tgama,tflor,tk,tmp)\n\nend subroutine k2_short\n"}, {"instruction": "Create a Fortran subroutine named \"esat\" to calculate the saturation vapor pressure and its derivative over water and ice based on the given temperature. The number of input parameters is 1 with the test_data type ['real'], and the number of output parameters is 4 with the test_data type ['real', 'real', 'real', 'real'].", "input": "", "output": "  subroutine esat(t, esw, esi, desw, desi)\n!---------------------------------------------------------------------------------------------------\n! use polynomials to calculate saturation vapor pressure and derivative with\n! respect to temperature: over water when t > 0 c and over ice when t <= 0 c\n  implicit none\n!---------------------------------------------------------------------------------------------------\n! in\n\n  real, intent(in)  :: t              !temperature\n\n!out\n\n  real, intent(out) :: esw            !saturation vapor pressure over water (pa)\n  real, intent(out) :: esi            !saturation vapor pressure over ice (pa)\n  real, intent(out) :: desw           !d(esat)/dt over water (pa/k)\n  real, intent(out) :: desi           !d(esat)/dt over ice (pa/k)\n\n! local\n\n  real :: a0,a1,a2,a3,a4,a5,a6  !coefficients for esat over water\n  real :: b0,b1,b2,b3,b4,b5,b6  !coefficients for esat over ice\n  real :: c0,c1,c2,c3,c4,c5,c6  !coefficients for dsat over water\n  real :: d0,d1,d2,d3,d4,d5,d6  !coefficients for dsat over ice\n\n  parameter (a0=6.107799961    , a1=4.436518521e-01,  &\n             a2=1.428945805e-02, a3=2.650648471e-04,  &\n             a4=3.031240396e-06, a5=2.034080948e-08,  &\n             a6=6.136820929e-11)\n\n  parameter (b0=6.109177956    , b1=5.034698970e-01,  &\n             b2=1.886013408e-02, b3=4.176223716e-04,  &\n             b4=5.824720280e-06, b5=4.838803174e-08,  &\n             b6=1.838826904e-10)\n\n  parameter (c0= 4.438099984e-01, c1=2.857002636e-02,  &\n             c2= 7.938054040e-04, c3=1.215215065e-05,  &\n             c4= 1.036561403e-07, c5=3.532421810e-10,  &\n             c6=-7.090244804e-13)\n\n  parameter (d0=5.030305237e-01, d1=3.773255020e-02,  &\n             d2=1.267995369e-03, d3=2.477563108e-05,  &\n             d4=3.005693132e-07, d5=2.158542548e-09,  &\n             d6=7.131097725e-12)\n\n  esw  = 100.*(a0+t*(a1+t*(a2+t*(a3+t*(a4+t*(a5+t*a6))))))\n  esi  = 100.*(b0+t*(b1+t*(b2+t*(b3+t*(b4+t*(b5+t*b6))))))\n  desw = 100.*(c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6))))))\n  desi = 100.*(d0+t*(d1+t*(d2+t*(d3+t*(d4+t*(d5+t*d6))))))\n\n  end subroutine esat\n"}, {"instruction": "Create a Fortran subroutine named readpotential to read potential data from a file and store it in a 2D array. The subroutine takes 4 input parameters of type ['character*200', 'integer', 'integer', 'integer'] and 1 output parameter of type ['real*8'].", "input": "", "output": "subroutine readpotential(vr, filename, maxnr, nr, nat)\n!!! reading potential\n  real*8, intent(out)       :: vr(maxnr,nat)\n  character*200, intent(in) :: filename\n  integer, intent(in)       :: nat, maxnr, nr(nat)\n  !! temporary\n  integer :: jtape, iscf, idummy, j, jatom\n  !\n  jtape=18\n  open(jtape,file=filename,status='old')\n  read(jtape, '(50x,i2,//)') iscf\n\n  do jatom=1,nat\n     read(jtape,1980)\n     read(jtape,2000) idummy\n     read(jtape,2031)\n     read(jtape,2022)(vr(j,jatom),j=1,nr(jatom))\n     read(jtape,2031)\n     read(jtape,2030)\n  enddo\n  \n  vr(:,:)=vr(:,:)/2.0d0  ! to hartree's?\n  close(jtape)\n2022 format(3x,4e19.12)\n2000 format(16x,i2//)\n1980 format(3x)\n2031 format(/)\n2030 format(///)\nend subroutine readpotential\n"}, {"instruction": "Create a Fortran subroutine named iterate to solve a 1D partial differential equation using the iterative method. The subroutine takes 4 input parameters: n (integer), iters (integer), u0 (real(kind=8), dimension(0:n+1)), f (real(kind=8), dimension(0:n+1)), and produces 1 output parameter: u (real(kind=8), dimension(0:n+1)).", "input": "", "output": "subroutine iterate(u0,iters,f,u,n)\n    implicit none\n    integer, intent(in) :: n, iters\n    real(kind=8), dimension(0:n+1), intent(in) :: u0, f\n    real(kind=8), dimension(0:n+1), intent(out) :: u\n\n    ! local variables:\n    real(kind=8), dimension(:), allocatable :: uold\n    real(kind=8) :: dx\n    integer :: i, iter\n\n    ! allocate storage for boundary points too:\n    allocate(uold(0:n+1))\n\n    ! grid spacing:\n    dx = 1.d0 / (n+1.d0)\n\n    uold = u0\n\n    ! initialize boundary values of u:\n    u(0) = u0(0)\n    u(n+1) = u0(n+1)\n\n    ! take the iterations requested:\n    do iter=1,iters\n        do i=1,n\n            u(i) = 0.5d0*(uold(i-1) + uold(i+1) + dx**2*f(i))\n            enddo\n        uold = u\n        enddo\n\nend subroutine iterate\n"}, {"instruction": "Write a Fortran subroutine named double to double the input integer and store the result in the output integer. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "subroutine double(i,i2)\r\ninteger, intent(in)  :: i\r\ninteger, intent(out) :: i2\r\nprint*,\"entering double, i =\",i\r\ni2 = 2*i\r\nprint*,\"leaving double, i =\",i\r\nend subroutine double\r\n"}, {"instruction": "Create a Fortran subroutine named convert_c2s that converts Cartesian coordinates to spherical coordinates. The input parameter is a real*8 array xyz(3) representing (x, y, z) coordinates. The output parameter is a real*8 array rtp(3) representing (r, cos(t), phi) coordinates, where -pi<phi<pi.", "input": "", "output": "   subroutine convert_c2s(xyz,rtp)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!  convert cartesian to spherical coordinates\n!  input: xyz(3)=(x, y, z)\n!  output: rtp=(r, cos(t), phi), where -pi<phi<pi\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      real*8, intent(in) :: xyz(3)\n      real*8, intent(out):: rtp(3)\n\n      rtp=0d0\n  \n      rtp(1)=dsqrt(xyz(1)**2+xyz(2)**2+xyz(3)**2)\n      if(rtp(1) .eq. 0) return    \n      \n      rtp(2)=xyz(3)/rtp(1)\n      rtp(3)=datan2(xyz(2),xyz(1))\n\n   end subroutine convert_c2s\n"}, {"instruction": "Create a Fortran subroutine named \"shcilmtocindex\" that converts a 3D matrix of spherical harmonic coefficients into a 2D matrix indexed by a specific formula. The subroutine takes 2 input parameters of types real*8 and integer (optional) and produces 1 output parameter of type real*8. The input parameters are cilm and degmax, and the output parameter is cindex.", "input": "", "output": "subroutine shcilmtocindex(cilm, cindex, degmax)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis routine will convert a 3d matrix of spherical harmonics indexed as (i, l+1, m+1)\n!\tinto a 2d matrix that is indexed as (i, index) where index = l(l+1)/2+m+1.\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tcilm\tarray of spherical harmonic coefficients with dimensions \n!\t\t\t\t(2, lmax+1, lmax+1).\n!\t\tout\n!\t\t\tcindex\tarray of indexed spherical harmonic coefficnets with dimensions\n!\t\t\t\t(2, (lmax+1)*(lmax+2)/2).\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek 2004.\n!\n!\tcopyright (c) 2005-2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\treal*8, intent(in) :: cilm(:,:,:)\n\treal*8, intent(out) :: cindex(:,:)\n\tinteger, intent(in), optional ::\tdegmax\n\tinteger :: lmax, l, m, index\n\t\n\tif (present(degmax)) then\n\t\tlmax = degmax\n\t\tif (size(cilm(:,1,1)) < 2 .or. size(cilm(1,:,1)) < lmax + 1 .or. size(cilm(1,1,:)) < lmax+1 ) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cilm must be dimensioned as (2, degmax+1, degmax+1) where degmax is \", degmax\n\t\t\tprint*, \"input array is dimensioned \", size(cilm(:,1,1)), size(cilm(1,:,1)), size(cilm(1,1,:))\n\t\t\tstop\n\t\telseif (size(cindex(:,1)) < 2 .or. size(cindex(1,:)) < (lmax+1)*(lmax+2)/2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cindex must be dimensioned as (2, (degmax+1)*(degmax+2)/2) where degmax is \", degmax\n\t\t\tprint*, \"input array is dimensioned \", size(cindex(:,1)), size(cindex(1,:))\n\t\t\tstop\n\t\tendif\n\telse\n\t\tlmax = min(size(cilm(1,1,:)) - 1, size(cilm(1,:,1)) - 1)\n\t\tif (size(cilm(:,1,1)) < 2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cilm must be dimensioned as (2, *, *).\"\n\t\t\tprint*, \"input array is dimensioned \", size(cilm(:,1,1)), size(cilm(1,:,1)), size(cilm(1,1,:))\n\t\t\tstop\n\t\telseif (size(cindex(:,1)) < 2 .or. size(cindex(1,:)) <  (lmax+1)*(lmax+2)/2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cindex must be dimensioned as (2, (lmax+1)*(lmax+2)/2) where lmax is \", lmax\n\t\t\tstop\n\t\tendif\n\tendif\n\t\t\n\tdo l=0, lmax\n\t\tdo m=0, l\n\t\t\tindex = l*(l+1)/2+m+1\n\t\t\tcindex(1, index) = cilm(1,l+1,m+1)\n\t\t\tcindex(2, index) = cilm(2,l+1,m+1)\n\t\tenddo\n\tenddo\n\nend subroutine shcilmtocindex\n"}, {"instruction": "Write a Fortran subroutine named gaulegf to compute the abscissas and weights for the Gauss-Legendre quadrature. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and 2 output parameters of type real(8) arrays with dimension n.", "input": "", "output": "subroutine gaulegf(x1, x2, x, w, n)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x1, x2\n  real(8), dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  real(8) :: p1, p2, p3, pp, xl, xm, z, z1\n  real(8), parameter :: eps=3.d-14\n\n  pp = 0.0d0\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.0\n    do while(abs(z-z1) .gt. eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\n\nend subroutine gaulegf\n"}, {"instruction": "Create a Fortran subroutine named random_walk_fast_2d to generate a random walk on a 2D grid. The subroutine takes 7 input parameters of types integer, real, and real, and 2 output parameters of type real. The input parameters include step_size, phi, box_size, x_start, y_start, periodic, and length. The output parameters are x and y, representing the coordinates of the random walk simulation. The subroutine enforces periodic boundary conditions based on the value of the periodic parameter.", "input": "", "output": "subroutine random_walk_fast_2d(step_size, phi, box_size, x_start, y_start, periodic, length, x, y)\n    ! generates a random walk on a 2d grid.\n    !\n    ! parameters\n    ! ----------\n    ! step_size : float\n    !    a set of input step size values.\n    ! phi : array\n    !    random angles.\n    ! box_size : float\n    !    box size parameters.\n    ! x_start, y_start : float\n    !    starting x & y coordinates.\n    ! periodic : {0, 1}, int\n    !    0 = does not enforce periodic boundary conditions.\n    !    1 = enforces periodic boundary conditions.\n    ! length : int\n    !    length of the x & y coordinates.\n    !\n    ! returns\n    ! -------\n    ! x, y : array\n    !    the coordinates of the random walk simulation.\n\n    implicit none\n\n    integer, intent(in) :: length\n    real, intent(in) :: step_size(length), phi(length)\n    real, intent(in) :: box_size, x_start, y_start\n    integer, intent(in) :: periodic\n    real, intent(out) :: x(length+1), y(length+1)\n    integer :: i\n    real :: delta_x, delta_y, x_current, y_current\n\n    x(1) = x_start\n    y(1) = y_start\n\n    x_current = x_start\n    y_current = y_start\n\n    do i = 2, length+1\n\n        delta_x = step_size(i-1)*cos(phi(i-1))\n        delta_y = step_size(i-1)*sin(phi(i-1))\n\n        x_current = x_current + delta_x\n        y_current = y_current + delta_y\n\n        if (periodic == 1) then\n\n            do while (x_current < 0. .or. x_current > box_size)\n                if (x_current < 0.) then\n                    x_current = x_current + box_size\n                else if (x_current > box_size) then\n                    x_current = x_current - box_size\n                end if\n            end do\n\n            do while (y_current < 0. .or. y_current > box_size)\n                if (y_current < 0.) then\n                    y_current = y_current + box_size\n                else if (y_current > box_size) then\n                    y_current = y_current - box_size\n                end if\n            end do\n\n        end if\n\n        x(i) = x_current\n        y(i) = y_current\n\n    end do\n\nend subroutine random_walk_fast_2d\n"}, {"instruction": "Create a Fortran subroutine named make_banded_matrix to generate a banded matrix from the given row vector and dimensions. The number of input parameters is 3, with test_data types ['integer', 'integer', 'real(sp), dimension(m)']. The number of output parameters is 1, with test_data type ['real(sp), dimension(m, n)'].", "input": "", "output": "    pure subroutine make_banded_matrix(n, m, row, mat)        \n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n, m\n        real(sp), intent(in), dimension(m) :: row\n        real(sp), intent(out), dimension(m, n) :: mat\n\n        integer :: j, k, l, r\n\n        k = (m - 1) / 2\n        l = k + 1\n        r = n - k\n\n        ! fill left triangle part of band\n        do j = 1, k\n            mat(k + 2 - j + 0:, j) = row(k + 2 - j:)\n            mat(:k + 2 - j - 1, j) = 0 ! can be removed\n        end do\n\n        ! fill body\n        do j = l, r\n            mat(:, j) = row(:)\n        end do\n\n        ! fill right triangle part of band\n        do j = 1, k\n            mat(:m - j + 0, n - k + j) = row(:m - j)\n            mat(m - j + 1:, n - k + j) = 0 ! can be removed\n        end do\n    end subroutine make_banded_matrix\n"}, {"instruction": "Create a Fortran subroutine named divide_derivative_on_radius that takes 3 input parameters of type integer, integer, and real(sp), and 1 output parameter of type real(sp) with dimensions m and n. The subroutine computes the derivative of l1 with respect to the radius and stores the result in the output parameter. Use the imperative tone in your instructions.", "input": "", "output": "    pure subroutine divide_derivative_on_radius(n, m, h, l1)\n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n\n        integer, intent(in) :: m\n        real(sp), intent(in) :: h\n        real(sp), intent(out), dimension(m, n) :: l1\n\n        integer :: i, j, row\n\n        ! row k = i + j - k0: k = 0,1,2,...,n - 1, where k0: m = 2 k0 - 3. cause is sum (i + j) is invarian of row.\n        do i = 1, m\n            do j = 1, n\n                row = i + j - (m + 3) / 2\n\n                if (row > 0) then\n                    l1(i, j) = l1(i, j) / (row * h)\n                end if\n            end do\n        end do\n    end subroutine divide_derivative_on_radius\n"}, {"instruction": "Write a Fortran subroutine named \"revervoir\" to calculate the reservoir response using the given parameters. The subroutine should have 4 input parameters of types integer, real(sp) arrays of dimension n, real(sp) arrays of dimension 23, and real(sp) arrays of dimension n, and 1 output parameter of type real(sp) array of dimension n.", "input": "", "output": "    subroutine revervoir(pumping, coeffs, u_sqr, r, n)\n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n\n        real(sp), intent(in), dimension(n) :: pumping\n        real(sp), intent(in), dimension(23) :: coeffs\n        real(sp), intent(in), dimension(n) :: u_sqr\n        real(sp), intent(out), dimension(n) :: r ! actually n(r)\n\n        r = coeffs(12) * pumping  / (coeffs(13) + coeffs(14) * u_sqr)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gridinterpol to implement linear interpolation and extrapolation of observed data to the model grid. The input parameters include 6 arguments: 2 integers, 2 real arrays, and 2 integers. The output parameter is a real array.", "input": "", "output": "subroutine gridinterpol(n,cols,obs_z,obs_prof,nlev_,model_z,model_prof)\n!\n! !description:\n!\n\n!  be given on an arbitrary, but structured grid, are linearly interpolated and\n!  extrapolated to the actual (moving) model grid.\n!\n! !uses:\n   implicit none\n!\n! !input parameters:\n   !n    : number of vertical layers in observation data\n   !cols : number of profiles in obs. data\n   integer,  intent(in)                :: n,cols\n   real,     intent(in)                :: obs_z(n),obs_prof(n,cols)\n   !nlev_: number of vertical layers in model\n   integer,  intent(in)                :: nlev_\n   real,     intent(in)                :: model_z(nlev_)\n!\n! !output parameters:\n   real,     intent(out)               :: model_prof(nlev_,cols)\n!\n! !revision history:\n!  original author(s): karsten bolding & hans burchard\n!\n!eop\n!\n! !local variables:\n   integer                   :: i,j,ii\n   real                      :: rat\n!-----------------------------------------------------------------------\n!boc\n   model_prof(:,:) = 0d0\n!  set surface values to uppermost input value\n   do i=nlev_,1,-1\n      if(model_z(i) .ge. obs_z(n)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(n,j)\n         end do\n      end if\n   end do\n\n!  set bottom values to lowest input value\n   do i=1,nlev_\n      if(model_z(i) .le. obs_z(1)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(1,j)\n         end do\n      end if\n   end do\n\n!  interpolate inner values linearly\n   do i=1, nlev_, 1\n!   do i= nlev_, 1, -1\n      if ((model_z(i) .lt. obs_z(n)) .and. (model_z(i) .gt. obs_z(1))) then\n         ii=0\n224      ii=ii+1\n         !write(6,*) 'model_z(',i,') = ',model_z(i)\n         !write(6,*) 'obs_z(',ii,') = ',obs_z(ii)\n         if (obs_z(ii) .le. model_z(i)) goto 224\n\n         rat=(model_z(i)-obs_z(ii-1))/(obs_z(ii)-obs_z(ii-1))\n\n         do j=1,cols\n            model_prof(i,j)=(1d0-rat)*obs_prof(ii-1,j)+rat*obs_prof(ii,j)\n         enddo\n      endif\n   enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mean_molecular_weight to calculate the mean molecular weight. The subroutine takes 4 input parameters of type integer, real(8), real(8), real(8), and returns 2 output parameters of type real(8) and character(len=1000).", "input": "", "output": "subroutine mean_molecular_weight(nq, usol_layer, mass, background_mu, mubar, err)\n  implicit none\n  \n  integer, intent(in) :: nq\n  real(8), intent(in) :: usol_layer(nq)\n  real(8), intent(in) :: mass(nq)\n  real(8), intent(in) :: background_mu\n  \n  real(8), intent(out) :: mubar\n  character(len=1000), intent(out) :: err\n  integer :: j\n  real(8) :: f_background\n  err = \"\"\n\n  mubar = 0.d0\n  do j = 1, nq\n    mubar = mubar + usol_layer(j) * mass(j)\n  enddo\n  f_background = 1 - sum(usol_layer)\n  \n  if (f_background < 0.d0) then\n    err = \"mixing ratios sum to > 1.0. atmosphere is probably in a run-away state.\"\n    return\n  endif\n  \n  mubar = mubar + f_background * background_mu\n  \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named caldat to convert a Julian date to Gregorian date. The subroutine takes 1 input parameter of type integer and returns 3 output parameters, all of type integer.", "input": "", "output": "subroutine caldat(julian,year,month,day)\n\ninteger, intent(in)                     :: julian\ninteger, intent(out)                    :: year,month,day\n\n! ... local variables\n! ...\ninteger, parameter                      :: igreg=2299161\ninteger ja,jalpha,jb,jc,jd,je\n\nif (julian.ge.igreg) then\n  jalpha = int(((julian-1867216)-0.25d0)/36524.25d0)\n  ja = julian+1+jalpha-int(0.25d0*jalpha)\nelse\n  ja = julian\nendif\n\njb = ja + 1524\njc = int(6680.d0+((jb-2439870)-122.1d0)/365.25d0)\njd = 365*jc + int(0.25d0*jc)\nje = int((jb-jd)/30.6001d0)\nday = jb - jd - int(30.6001d0*je)\nmonth = je - 1\nif (month.gt.12) month = month-12\nyear = jc - 4715\nif (month.gt.2) year = year-1\nif (year.le.0) year = year-1\n\nend subroutine caldat\n"}, {"instruction": "Create a Fortran subroutine named calc_hypotenuse to calculate the length of the hypotenuse of a right-angled triangle. The subroutine takes 2 input parameters of type real, representing the lengths of the two sides, and has 1 output parameter of type real representing the length of the hypotenuse. Use the imperative tone in the instructions.", "input": "", "output": "subroutine calc_hypotenuse(side_1, side_2, hypotenuse)\nimplicit none\n  real, intent(in) :: side_1, side_2\n  real, intent(out) :: hypotenuse\n  real :: temp\n\n  temp = side_1**2 + side_2**2\n  hypotenuse = sqrt(temp)\n\nend subroutine calc_hypotenuse\n"}, {"instruction": "Create a Fortran subroutine named vonmises_dvec to calculate the von Mises norm of deviatoric stress or deviatoric strain given in Voigt notation. The subroutine takes 3 input parameters of types real array, character, and integer array, and 2 output parameters of types real array and real.", "input": "", "output": "    subroutine vonmises_dvec(a, m, ma, vm, an)\r\n    ! von mises norm of deviatoric stress or dev strain given in voigt notation\r\n    ! masked array ma\r\n        real(kind=8)    ::  a(5), an(5), vm, fvm\r\n        integer         ::  i, ma(5)\r\n        character(6)    ::  m\r\n\r\n        intent(in)      ::  a, m, ma\r\n        intent(out)     ::  vm, an\r\n\r\n        if (m == 'strain') then\r\n            fvm = sqrt(2.d0/3.d0)\r\n        elseif (m == 'stress') then\r\n            fvm = sqrt(3.d0/2.d0)\r\n        end if\r\n\r\n        an = 0.d0\r\n        forall (i=1:5, ma(i)==1) an(i) = a(i)\r\n\r\n        vm = fvm*sqrt(an(1)**2 + an(2)**2 + (-an(1)-an(2))**2 + 2.d0*an(3)**2 + 2.d0*an(4)**2 + 2.d0*an(5)**2)\r\n\r\n        an = a\r\n        forall (i=1:5, ma(i)==1) an(i) = an(i)/vm\r\n\r\n    end subroutine vonmises_dvec\r\n"}, {"instruction": "Write a Fortran subroutine named \"throw\" to simulate throwing multiple dice and store the results in an array. The subroutine takes 2 input parameters of type integer: \"sides\" and \"ndice\". It also has 1 output parameter of type integer array with dimension 2: \"dice_arr\". Inside the subroutine, use a function \"die\" to generate random numbers representing the dice throws.", "input": "", "output": "subroutine throw(dice_arr, sides, ndice)\nimplicit none\ninteger, dimension(2), intent(out) :: dice_arr\ninteger, intent(in) :: sides, ndice\ninteger :: i\n\ndo i = 1, ndice\n  dice_arr(i) = die()\nend do\n\ncontains\n  integer function die()\n  die = ceiling(rand() * sides)\n  end function die\nend subroutine throw\n"}, {"instruction": "Create a Fortran subroutine named computeetfromgw_max to calculate the maximum evapotranspiration from groundwater. The subroutine takes 5 input parameters of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "  subroutine computeetfromgw_max(depthtogw,sy,rootdepth,capillaryrise,area,etfromgw_max)\n    real(8),intent(in)  :: depthtogw(:),sy(:),rootdepth(:),capillaryrise(:),area(:,:)\n    real(8),intent(out) :: etfromgw_max(:,:)\n    \n    !local variables\n    integer :: indxelem,indxlu,nlanduse\n    real(8) :: rdgw,rsy,rrz,rrise,rintersect\n    \n    !initialize\n    nlanduse = size(rootdepth)\n    \n    !compute\n    do indxelem=1,size(depthtogw)\n        rdgw  = depthtogw(indxelem)\n        rrise = capillaryrise(indxelem) \n        rsy   = sy(indxelem)\n        do indxlu=1,nlanduse\n            !no et from gw if land use area is zero\n            if (area(indxlu,indxelem) .eq. 0.0) then\n                etfromgw_max(indxlu,indxelem) = 0.0\n                cycle\n            end if\n            \n            !root depth\n            rrz = rootdepth(indxlu)\n            \n            !gw is below root zone\n            if (rdgw .gt. rrz) then\n                !capillary rise does not reach into root zone\n                if (rrise+rrz .le. rdgw) then\n                    etfromgw_max(indxlu,indxelem) = 0.0\n                    \n                !capillary rise extends into root zone \n                else\n                    !there is no capillary rise\n                    if (rrise .eq. 0.0) then\n                        etfromgw_max(indxlu,indxelem) = 0.0\n                       \n                    !capillary rise does not exceed land surface\n                    elseif (rdgw .gt. rrise) then\n                        rintersect = rrz - rdgw + rrise\n                        etfromgw_max(indxlu,indxelem) = 0.5 * rintersect * rintersect * rsy / rrise\n                    \n                    !capillary rise exceeds land surface\n                    else\n                        etfromgw_max(indxlu,indxelem) = rrz * rsy * (0.5 * rrz + rrise - rdgw) / rrise\n                    end if\n                end if\n                \n            !gw is above root zone\n            else\n                !capillary rise does not exceed land surface\n                if (rdgw .gt. rrise) then\n                    etfromgw_max(indxlu,indxelem) = 0.5 * rrise * rsy + rsy * (rrz - rdgw)\n                    \n                !capillary rise exceeds land surface\n                else\n                    if (rrise .eq. 0.0) then\n                        etfromgw_max(indxlu,indxelem) = rsy * (rrz - rdgw)\n                    else\n                        etfromgw_max(indxlu,indxelem) = 0.5 * rsy * (2.0 * rrise * rrz - rdgw * rdgw) / rrise\n                    end if\n                end if\n            end if\n            \n        end do\n    end do\n    \n  end subroutine computeetfromgw_max\n"}, {"instruction": "Create a Fortran subroutine named get_dayno_from_monthday to calculate the number of days since the beginning of the year based on the given month day. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine get_dayno_from_monthday(datumin,daysamount)\r\n\r\n    !argument declarations\r\n    integer, intent(in)  :: datumin       !<month day (mmdd): 31st of january = 0131\r\n    integer, intent(out) :: daysamount    !<corresponding amount of days since beginning of year\r\n    \r\n    !local variables\r\n    integer month          !current month\r\n    integer day,feb        !current day and number of days in february\r\n\r\n    month = datumin/100\r\n    day = datumin - 100*month\r\n    feb = 28  !since no year, no leap year is assumed\r\n    select case (month)\r\n    case (1)\r\n      daysamount = day\r\n    case (2)\r\n      daysamount = 31 + day\r\n    case (3)\r\n      daysamount = 31 + feb + day\r\n    case (4)\r\n      daysamount = 62 + feb + day\r\n    case (5)\r\n      daysamount = 92 + feb + day\r\n    case (6)\r\n      daysamount = 123 + feb + day\r\n    case (7)\r\n      daysamount = 153 + feb + day\r\n    case (8)\r\n      daysamount = 184 + feb + day\r\n    case (9)\r\n      daysamount = 215 + feb + day\r\n    case (10)\r\n      daysamount = 245 + feb + day\r\n    case (11)\r\n      daysamount = 276 + feb + day\r\n    case (12)\r\n      daysamount = 306 + feb + day\r\n    case default\r\n      daysamount = 0\r\n    end select\r\n\r\n  end subroutine get_dayno_from_monthday\r\n"}, {"instruction": "Create a Fortran subroutine named \"parselogical\" to parse a character input into a logical variable. The input parameter is a single character string. The output parameters are two logical variables, with the second one being optional.", "input": "", "output": "        subroutine parselogical(dummy,ll,ok)\n    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    !*      parse dummy into a logical variable.\n            character(len=*),intent(in)         ::      dummy\n            logical,intent(out)                 ::      ll\n            logical,intent(out),optional        ::      ok\n            if (len_trim(dummy)==0) then\n                ll = .false.\n                if (present(ok)) ok = .false.\n            end if\n            ll = ( (trim(dummy)==\"t\") .or. (trim(dummy)==\"true\") .or. (trim(dummy)==\".true.\")    &\n                  .or. (trim(dummy)==\"t\") .or. (trim(dummy)==\"true\") .or. (trim(dummy)==\".true.\") )\n            if (present(ok)) then\n                if (ll) then\n                    ok = .true.\n                else\n                    ok = ( (trim(dummy)==\"f\") .or. (trim(dummy)==\"false\") .or. (trim(dummy)==\".false.\")    &\n                          .or. (trim(dummy)==\"f\") .or. (trim(dummy)==\"false\") .or. (trim(dummy)==\".false.\") )\n                end if\n            end if\n\n            return\n        end subroutine parselogical\n"}, {"instruction": "Create a Fortran subroutine named calc_d2vec that takes two input parameters of type real(kind=8) and one output parameter of type real(kind=8). The input parameters represent a vector and its length, and the output parameter represents a second derivative matrix. The subroutine calculates the entries of the second derivative matrix using the input vector and its length, and applies a length prefactor before returning the result.", "input": "", "output": "subroutine calc_d2vec(d2_mat,v,len)\nimplicit none \n!     the normalized vector to be derivated \nreal(kind=8), intent(in) :: v(3)\n!     the length of the given vector \nreal(kind=8), intent(in) :: len\n!     the calculated second derivative matrix \nreal(kind=8), intent(out) :: d2_mat(3,3,3)\n\n!\n!     calculate entries of second derivative matrix \n!     --> the matrix is diagonal!\n!\n!     dv/dx^2\nd2_mat(1,1,1)=-3d0*v(1)*(v(2)**2+v(3)**2)\nd2_mat(1,1,2)=v(2)*(2d0*v(1)**2-v(3)**2-v(2)**2)\nd2_mat(1,1,3)=v(3)*(2d0*v(1)**2-v(2)**2-v(3)**2)\n!     dv/dxdy\nd2_mat(1,2,1)=-v(2)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,2,2)=-v(1)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(1,2,3)=3d0*v(1)*v(2)*v(3)\n!     dv/dxdz\nd2_mat(1,3,1)=-v(3)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,3,2)=3d0*v(1)*v(2)*v(3)\nd2_mat(1,3,3)=-v(1)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dydx\nd2_mat(2,1,:)=d2_mat(1,2,:)\n!     dv/dydy\nd2_mat(2,2,1)=v(1)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\nd2_mat(2,2,2)=-3d0*v(2)*(v(1)**2+v(3)**2)\nd2_mat(2,2,3)=v(3)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\n!     dv/dydz\nd2_mat(2,3,1)=3d0*v(1)*v(2)*v(3)\nd2_mat(2,3,2)=-v(3)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(2,3,3)=-v(2)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dzdx\nd2_mat(3,1,:)=d2_mat(1,3,:)\n!     dv/dzdy\nd2_mat(3,2,:)=d2_mat(2,3,:)\n!     dv/dzdz\nd2_mat(3,3,1)=v(1)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,2)=v(2)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,3)=-3d0*v(3)*(v(1)**2+v(2)**2)\n!\n!     apply length prefactor \n!\nd2_mat=d2_mat/(len**5)\n\nreturn\nend subroutine calc_d2vec\n"}, {"instruction": "Create a Fortran subroutine named fcsr_ptrindices to generate pointer indices. The subroutine takes 3 input parameters of type integer: n, ndata, and an array xinds of size ndata. It produces 1 output parameter of type integer array of size n named ptr.", "input": "", "output": "subroutine fcsr_ptrindices(xinds,ptr,n,ndata)\n    implicit none\n    integer,intent(in) :: n,ndata\n    integer,intent(in),dimension(ndata) :: xinds\n    integer,intent(out),dimension(n) :: ptr\n    integer :: row,datai\n    \n    !f2py intent(in) :: n,ndata,xinds\n    !f2py intent(out) :: ptr\n    ptr(1)=0\n    datai=1\n    do row=2,n\n        if(xinds(datai)>=row-1) then\n            ptr(row)=datai-1\n        else\n            do while(xinds(datai)<row-1 .and. datai<=ndata)\n                datai=datai+1\n            enddo\n            ptr(row)=datai-1\n        endif\n    enddo\nend subroutine fcsr_ptrindices\n"}, {"instruction": "Create a Fortran subroutine named fget_tlu_seq1 with the following functionality:\n- Accepts 5 input parameters of types integer, integer, complex*16 array of size n, complex*16 array of size n-1, and complex*16 array of size n-1.\n- Returns 3 output parameters of types complex*16 array of size n-1, complex*16 array of size n-1, and complex*16 array of size n.\nThis subroutine performs a computation involving complex numbers and array manipulation based on the value of the \"which\" parameter.", "input": "", "output": "subroutine fget_tlu_seq1(al,bl,cl,ll,ul,hl,n,which)\n    implicit none\n    integer,intent(in) :: n,which\n    complex*16,intent(in),dimension(n) :: bl\n    complex*16,intent(in),dimension(n-1) :: al,cl\n    complex*16,intent(out),dimension(n-1) :: ll,ul\n    complex*16,intent(out),dimension(n) :: hl\n    complex*16 :: bi,hi,ui\n    integer :: i\n    \n    !f2py intent(in) :: n,p,which,al,bl,cl\n    !f2py intent(out) :: ll,ul,hl\n\n    select case(which)\n    case(1)\n        !sequence for i < j\n        ll=al\n        do i=1,n\n            bi=bl(i)\n            hi=bi\n            if(i/=1) then\n                hi=hi-ll(i-1)*ui\n            endif\n            hl(i)=hi\n            if(i/=n) then\n                ui=cl(i)/hi\n                ul(i)=ui\n            endif\n        enddo\n    case(2)\n        !sequence for i > j\n        ll=cl\n        do i=n,1,-1\n            hi=bl(i)\n            if(i/=n) then\n                hi=hi-ll(i)*ui\n            endif\n            hl(i)=hi\n            if(i/=1) then\n                ui=al(i-1)/hi\n                ul(i-1)=ui\n            endif\n        enddo\n    endselect\nend subroutine fget_tlu_seq1\n"}, {"instruction": "Create a Fortran subroutine named fget_uv that computes the values of ul and vl using complex arithmetic. It takes 4 input parameters: an integer n, and three complex arrays invdu, invdl, and cl of dimension n, n, and n-1 respectively. It returns two complex arrays ul and vl, both of dimension n.", "input": "", "output": "subroutine fget_uv(invdu,invdl,cl,ul,vl,n)\n    implicit none\n    integer,intent(in) :: n\n    complex*16,intent(in),dimension(n) :: invdu,invdl\n    complex*16,intent(in),dimension(n-1) :: cl\n    complex*16,intent(out),dimension(n) :: ul,vl\n    complex*16 :: ui,vi\n    integer :: i\n    \n    !f2py intent(in) :: n,invdu,invdl,cl\n    !f2py intent(out) :: ul,vl\n\n    !get vl\n    vi=1d0*invdu(1)\n    vl(1)=vi\n    do i=2,n\n        vi=-vi*cl(i-1)*invdu(i)\n        vl(i)=vi\n    enddo\n    !get ul\n    ui=invdl(n)/vl(n)\n    ul(n)=ui\n    do i=n-1,1,-1\n        ui=-ui*cl(i)*invdl(i)\n        ul(i)=ui\n    enddo\nend subroutine fget_uv\n"}, {"instruction": "Create a Fortran subroutine named pick_range to select a range of integers within a specified range. The subroutine takes 2 input parameters of type integer, and 2 output parameters of type integer. The input parameters are from and to, representing the range of integers to select from. The output parameters are start and finish, which represent the selected range of integers.", "input": "", "output": "subroutine pick_range(from,to,start,finish)\n  ! modified version of:\n  ! http://rosettacode.org/wiki/pick_random_element#fortran\n  integer, intent(in)  :: from, to\n  integer, intent(out) :: start, finish\n  integer, allocatable :: a(:)\n  integer :: k\n  real*8  :: r\n  allocate(a(to-from))\n  do k=1, to-from\n    a(k) = k+from\n  end do!k\n  call random_number(r)\n  start = a(int(r*(size(a))) + 1)\n  do\n    call random_number(r)\n    k = a(int(r*(size(a))) + 1)\n    if (k>start) then\n      finish = k\n      exit\n    elseif (k<start) then\n      finish = start\n      start = k\n      exit\n    end if\n  end do\nend subroutine pick_range\n"}, {"instruction": "Create a Fortran subroutine named roulettewheelselection to randomly select a parent from a population based on their fitness levels. The subroutine should take an array of real*8 values representing fitness levels as input and output an integer representing the selected parent.", "input": "", "output": "subroutine roulettewheelselection(fitnesses,p1)\n! chooses parent from the population by the fitness and weighting by the fitness it randomly chooses a parent.\n  real*8,  intent(in) :: fitnesses(:)\n  integer, intent(out):: p1\n  real*8 :: r, total, pick\n  integer :: popno, i\n  popno = size(fitnesses,1)\n  total = sum(fitnesses)\n  call random_number(r)\n  r=r*total\n  pick = 0.d0\n  do i=1,popno\n    pick = pick + fitnesses(i)\n    if (pick > r)  then\n      p1=i\n      goto 11\n    endif\n  end do!i\n11 continue\n  ! todo check\nend subroutine roulettewheelselection\n"}, {"instruction": "Write a Fortran subroutine named kurtosis that calculates the kurtosis of a three-dimensional array. The subroutine accepts 4 input parameters: 3 integers (nx, ny, nz) and a double precision array of dimension (nx, ny, nz). It returns 1 output parameter of type double precision.", "input": "", "output": "subroutine kurtosis(a,nx,ny,nz,krt)\n   integer, intent(in) :: nx, ny, nz\n   double precision, intent(out):: krt\n   double precision, dimension(nx,ny,nz), intent(in) :: a\n!f2py intent (in) nx,ny,nz\n!f2py intent (in) a\n!f2py intent (out) krt\n   double precision, dimension(nx,ny,nz) :: temp\n   double precision :: tmp, norm\n   norm=nx*ny*nz\n   tmp=sum(a)/norm; temp=a-tmp\n   tmp=sum(temp**2)/norm\n   krt=sum(temp**4)/(norm*tmp**2)\nend subroutine kurtosis\n"}, {"instruction": "Write a Fortran subroutine named roll_idx that takes 3 input parameters of type integer (x, nx, inc) and returns 1 output parameter of type integer (xx). The subroutine computes the value of xx based on the conditions specified in the code.", "input": "", "output": "subroutine roll_idx(x,nx,inc,xx)\n   integer, intent(in) :: x,nx,inc\n   integer, intent(out):: xx\n!f2py intent (in) x,nx,inc\n!f2py intent (out) xx\n   xx = merge(x+inc, x-nx+inc+1, (x .lt. nx-inc))\n!  if (x .lt. nx-inc) then \n!     xx=x+inc \n!  else \n!     xx=x-nx+inc+1\n!  endif\nend subroutine roll_idx\n"}, {"instruction": "Write a Fortran subroutine named read_obs to read observation data. The subroutine takes 3 input parameters of type integer and 5 output parameters consisting of 4 integers and an array of real numbers.", "input": "", "output": "      subroutine read_obs(n_count,un,nmax,yyyy,mm,dd,hh,vector)\n!\n\n!\n! **********************************************************************\n      implicit none\n\n!     global declarations:\n      integer, intent(in)  :: n_count\n      integer, intent(in)  :: un\n      integer, intent(in)  :: nmax\n      integer, intent(out) :: yyyy\n      integer, intent(out) :: mm\n      integer, intent(out) :: dd\n      integer, intent(out) :: hh\n      real,    intent(out) :: vector(nmax)\n\n!     local declarations:\n\n      character (len=256) :: heading\n\n!     content of routine:\n\n      vector = 0.0\n\n      if(n_count == 1)then\n        read(un,*) heading\n        read(un,*) yyyy,mm,dd,hh,vector\n      else\n        read(un,*) yyyy,mm,dd,hh,vector\n      end if !(n_count == 1)\n\n\n      end subroutine read_obs\n"}, {"instruction": "Write a Fortran subroutine named process that takes an array of real numbers a, an integer n, and outputs an array of real numbers b. The subroutine computes the exponential of the sine of each element in array a and stores the result in array b.", "input": "", "output": "subroutine process(a, b, n)\n\nreal, intent(in) :: a(:)\nreal, intent(out) :: b(:)\ninteger, intent(in) :: n\ninteger :: i\n\n!$acc parallel loop\ndo i = 1, n\n  b(i) = exp(sin(a(i)))\nenddo\n\nend subroutine process\n"}, {"instruction": "Write a Fortran subroutine named irand to generate an array of random integers. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer array.", "input": "", "output": " subroutine irand(maxi,ix)\n  integer,intent(in)  :: maxi\n  integer,intent(out) :: ix(:)\n  integer :: i,n\n  double precision,allocatable :: d(:)\n  n=size(ix)\n  allocate(d(n))\n  call random_number(d)\n  ix=int(d*maxi)+1\n  deallocate(d)\n return\n end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rep_char to replicate a single character c for n times and store the result in the variable out. The number of input parameters is 2, of type ['character(len=1)', 'integer'], and the number of output parameters is 1, of type ['character(len=n)'].", "input": "", "output": "    subroutine rep_char(c, n, out)\n        character(len=1), intent(in)  :: c\n        integer,          intent(in)  :: n\n        character(len=n), intent(out) :: out\n        integer                       :: i\n\n        do i = 1, n\n            out(i:i) = c(1:1)\n        end do\n    end subroutine rep_char\n"}, {"instruction": "Create a Fortran subroutine named trimw that removes leading whitespace from a given string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*). The output parameter contains the input string with leading whitespace removed.", "input": "", "output": "    subroutine trimw(str, out)\n        character(len=*), intent(in)  :: str\n        character(len=*), intent(out) :: out\n        integer                       :: i\n\n        do i = 1, len(str)\n            if (str(i:i) == ' ') then\n                cycle\n            else\n                exit\n            end if\n        end do\n\n        out = str(i:)\n    end subroutine trimw\n"}, {"instruction": "Create a Fortran subroutine named calc_fits to perform calculations for fitting a model to a set of images. The subroutine takes 8 input parameters of type integer and real, including arrays of various dimensions. It also has 2 output parameters, both of type real and with specific dimensions. The subroutine performs nested loops to compute the best fit for each pixel in the images based on the model and parameter values provided.", "input": "", "output": "subroutine calc_fits(images, model, parvals, n_vals, n_wlens, x, y, n_pars, results, all_fit)\n\nimplicit none\ninteger, intent(in) :: n_vals, n_wlens, x, y, n_pars\nreal, dimension(n_vals, n_pars), intent(in) :: parvals\nreal, dimension(n_vals, n_wlens), intent(in) :: model\nreal, dimension(n_wlens, x, y), intent(in) :: images\nreal, dimension(x, y, n_pars+1), intent(out) :: results\nreal, dimension(x, y, n_vals), intent(out) :: all_fit\n!real, dimension(n_vals), intent(out) :: all_fit\ninteger :: i, j, t, w\nreal :: error, total_error, this_fit, best_fit\n\n!print*, 'wtfishappening'\ndo j = 1, y\n  do i = 1, x\n    best_fit = 1e38 ! arbitrarily large number\n    do t = 1, n_vals\n      total_error = 0.0\n      do w = 1, n_wlens\n        error = abs(images(w,i,j) - model(t, w))\n        total_error = total_error + error\n      end do\n      this_fit = total_error / real(n_wlens)\n      all_fit(i, j, t) = this_fit\n      !if (j == 14 .and. i == 56) then\n      !!if (j == 14 .and. i == 186) then\n      !!if (j == 14 .and. i == 251) then\n      !  !print*, i, j, t, this_fit\n      !  all_fit(t) = this_fit\n      !end if\n      if (this_fit < best_fit) then\n        best_fit = this_fit\n        results(i, j, 1:n_pars) = parvals(t, :)\n        results(i, j, n_pars+1) = this_fit\n      end if\n    end do\n  end do\nend do\n\nend subroutine calc_fits\n"}, {"instruction": "Create a Fortran subroutine named chi2 to calculate the chi-squared value between the data and a sinusoidal model. The subroutine takes 5 input parameters of type double precision: t, y, err, t_ref, and max_pwr, and 1 output parameter of type double precision: chi2_out.", "input": "", "output": "subroutine chi2(t, y, err, t_ref, max_pwr, chi2_out)\n!   computes chi2 between data and a*coswt + b*sinwt c model\n    double precision, intent(in) :: t(:), y(:), err(:)\n    double precision, intent(in) :: max_pwr(5), t_ref\n    double precision, intent(out) :: chi2_out\n    double precision :: a, b, c, per, pi\n    integer :: i, n_pts\n    !pi def.\n    pi = acos(-1.0d0)\n    n_pts = size(t)\n    !model parameters\n    per = max_pwr(1)\n    a = max_pwr(3)\n    b = max_pwr(4)\n    c = max_pwr(5)\n\n    chi2_out = 0.0\n    do 97 i = 1, n_pts\n        chi2_out = chi2_out + &\n                  (1.0/(err(i)*err(i)))*(y(i) - (a*cos(2.0*pi*(t(i)-t_ref)/per) +  &\n                  b*sin(2.0*pi*(t(i)-t_ref)/per) + c))**2.0\n97  continue\n\nend subroutine chi2\n"}, {"instruction": "Create a Fortran subroutine named my_func, which takes an array of 3 complex numbers as input and returns an array of 2 complex numbers as output. The subroutine calculates the natural logarithm of the ratio of each input number to the complex expression (0d0,1d0) plus the square of the cosine of the next input number. Use the imperative tone when writing the instructions.", "input": "", "output": "    subroutine my_func(x, y)\n        implicit none\n        complex(kind=kind(0d0)), dimension(3), intent(in) :: x\n        complex(kind=kind(0d0)), dimension(2), intent(out) :: y\n\n        integer :: j\n        do j = 1, 2\n            y(j) = log(x(j) / ((0d0,1d0) + cos(x(j+1))**2))\n        end do\n    end subroutine my_func\n"}, {"instruction": "Write a Fortran subroutine named splint to perform cubic spline interpolation. The subroutine takes 5 input parameters of type integer, real, real array of dimension n, real array of dimension n, and real array of dimension n. The output parameter is of type real.", "input": "", "output": "  subroutine splint(xa,ya,y2a,n,x,y)\n\n    implicit none\n    integer, intent(in) :: n\n    real, intent(in) :: x\n    real, intent(in), dimension(n) :: xa, y2a, ya\n    real, intent(out) :: y\n    integer :: k,khi,klo\n    real :: a,b,h\n    \n    klo=1\n    khi=n\n    do\n       k=(khi+klo)/2\n       if(xa(k)>x)then\n          khi=k\n       else\n          klo=k\n       endif\n       if (khi-klo<=1) exit\n    end do\n    h=xa(khi)-xa(klo)\n    if (h==0.) then\n       write(*,*) 'bad xa input in splint'\n       stop\n    endif\n    a=(xa(khi)-x)/h\n    b=(x-xa(klo))/h\n    y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.\n    \n  end subroutine splint\n"}, {"instruction": "Create a Fortran subroutine named initialize_centroids to initialize the centroids for a clustering algorithm. The subroutine takes 4 input parameters: n_samples (integer), n_clusters (integer), n_features (integer), samples (real, 2D array). It has 1 output parameter: centroids (real, 2D array, dynamically allocated).", "input": "", "output": "    subroutine initialize_centroids(samples, centroids, n_samples, n_clusters, n_features)\n        integer, intent(in) :: n_samples, n_clusters, n_features\n        real, dimension(:, :), intent(in) :: samples\n        real, dimension(:, :), allocatable, intent(out) :: centroids\n        real, dimension(n_features) :: mini, maxi\n        integer :: current_centroid, current_feature\n        real :: random_num\n\n        allocate(centroids(n_clusters, n_features))\n\n        do current_feature = 1, n_features\n            mini(current_feature) = minval(samples(:, current_feature))\n            maxi(current_feature) = maxval(samples(:, current_feature))\n        end do\n\n        do current_centroid = 1, n_clusters\n            do current_feature = 1, n_features\n                call random_number(random_num)\n                centroids(current_centroid, current_feature) = &\n                    mini(current_feature) + (maxi(current_feature) + 1 - mini(current_feature)) * random_num\n            end do\n        end do\n    end subroutine initialize_centroids\n"}, {"instruction": "Create a Fortran subroutine named grid_radar to process radar data and compute the eth_out values for a given set of input parameters. The subroutine takes 10 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'real(kind=8)', 'real(kind=8), dimension(nx)', 'real(kind=8), dimension(ny)', 'real(kind=8), dimension(nyrad, nxrad)', 'real(kind=8), dimension(nyrad, nxrad)', 'real(kind=8), dimension(nyrad, nxrad)'] and outputs a single parameter of type ['real(kind=8), dimension(ny, nx)'].", "input": "", "output": "subroutine grid_radar(cloudtop, eth_out, xgrid, ygrid, xradar, yradar, theta3db, nx, ny, nxrad, nyrad)\n    implicit none\n    ! input variables\n    integer(kind=4), intent(in) :: nx, ny, nxrad, nyrad\n    real(kind=8), intent(in) :: theta3db\n    real(kind=8), intent(in), dimension(nx) :: xgrid\n    real(kind=8), intent(in), dimension(ny) :: ygrid\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: xradar\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: yradar\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: cloudtop\n    ! output variables\n    real(kind=8), intent(out), dimension(ny, nx) :: eth_out\n    \n    ! parameters\n    integer(kind=4) :: cnt\n    integer(kind=4) :: i, j, k, l\n    integer(kind=4) :: stx, sty, edx, edy\n    real(kind=8) :: xi, yi, xr, yr\n    real(kind=8) :: width, rmax\n    real(kind=8) :: zmax\n    \n    rmax = maxval(xradar)\n    \n    do i = 1, nx\n        do j = 1, ny\n            cnt = 0\n            zmax = 0.0\n            xi = xgrid(i)\n            yi = ygrid(j)                        \n            \n            if (xi ** 2 + yi ** 2 > rmax ** 2) then\n                continue\n            endif\n            \n            width = 0.5 * (sqrt(xi ** 2 + yi ** 2) * theta3db * 3.14 / 180.0)            \n      \n            do k = 1, nxrad\n                do l = 1, nyrad\n                    xr = xradar(l, k)\n                    yr = yradar(l, k)\n                    \n                    if ((xr >= xi - width).and.(xr < xi + width).and.(yr >= yi - width).and.(yr < yi + width)) then\n                        if (cloudtop(l, k) > 0) then\n                            zmax = zmax + cloudtop(l, k)\n                            cnt = cnt + 1\n                        endif\n                        continue\n                    endif\n                enddo\n            enddo\n            \n            eth_out(j, i) = zmax / cnt\n        enddo\n    enddo\n    \n    return\n    \nend subroutine grid_radar\n"}, {"instruction": "Write a Fortran subroutine named periodic_tdma_solver to solve a tridiagonal matrix equation of the form Ax = d where A is a tridiagonal matrix and d is a known vector. The number of input arguments is 5 with the test_data type as ['integer', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)']. The number of output arguments is 1 with the test_data type as ['double precision, dimension(1:n)'].", "input": "", "output": "subroutine periodic_tdma_solver(a,b,c,d,x,n)\n\timplicit none\n\tinteger, intent(in)::n\n\tdouble precision, intent(in), dimension(1:n)::a,b,c,d\n\tdouble precision, intent(out),dimension(1:n)::x\n\tdouble precision, allocatable,dimension(:) :: p , q , r , w , u , x1 \t\n\tinteger :: i,j\n\tdouble precision::sum1=0.0d0,maxerror\n\tcharacter(80)::str\n\tdouble precision, allocatable, dimension(:)::error\n\n\tallocate(p(2:n),q(1:n),r(1:n-2),w(1:n-2),u(1:n-1),x1(1:n),error(1:n))\n\n\tq(1) = b(1) \n\tw(1) = a(1) / b(1) \n\tu(1) = c(1) / b(1) \n\tr(1) = c(n) \n\tsum1 = r(1) * w(1) \n\n\tdo i = 2 , n-2\n\t  p(i) = a(i)                    \n\t  q(i) = b(i) - p(i) * u(i-1)    \n\t  u(i) = c(i) / q(i)             \n\t  w(i) = - p(i) * w(i-1) / q(i)  \n\t  r(i) = - r(i-1) * u(i-1)       \n\t  sum1  = sum1 + r(i) * w(i)       \n\tenddo\n\n\ti = n-1 \n\tp(i) = a(i) \n\tq(i) = b(i) - p(i) * u(i-1) \n\tu(i) = (c(i) - p(i) * w(i-1)) / q(i) \n\tp(n) = a(n) - r(n-2) * u(n-2) \n\tq(n) = b(n) - sum1 - p(n) * u(n-1) \n\tx1(1) = d(1) / q(1)  \n!  \n\tdo i = 2 , n-1\n\t  x1(i) = (d(i) - p(i) * x1(i-1)) / q(i)    \n\tenddo\n\tsum1 = 0.0d0 \n\tdo i = 1 , n-2 \n\t  sum1 = sum1 + r(i) * x1(i)    \n\tenddo \n\tx1(n) = (d(n) - sum1 - p(n) * x1(n-1)) / q(n)\n\tx(n) = x1(n)\n\t\n\tx(n-1) = x1(n-1) - u(n-1) * x(n)\n\n\tdo i = n-2 , 1 , -1\n\t  x(i) = x1(i) - u(i) * x(i+1) - w(i) * x(n)    \n\tenddo  \n\n\tdeallocate(x1,p,q,u,w,r,error)\n\nend subroutine periodic_tdma_solver\n"}, {"instruction": "Write a Fortran subroutine named adt_sphere to calculate the extinction efficiency, absorption efficiency, scattering efficiency, and asymmetry parameter of a spherical particle. The subroutine should have 2 input parameters of type real and complex, and 4 output parameters of type real.", "input": "", "output": "subroutine adt_sphere(xx, crefin, qext, qabs, qsca, g)\n  implicit none\n  real, intent(in) :: xx\n  complex, intent(in) :: crefin\n  real, intent(out) :: qext, qabs, qsca, g\n  complex rho\n  real rho1, rho2, beta, rr\n  !\n  rho = 2.0 * xx * (crefin - 1.0)\n  rr = abs(rho)\n  rho1 = real(rho)\n  rho2 = aimag(rho)\n  !\n  if (rr .le. 1e-3) then\n    qext = 2.0\n    qabs = 4.0/3.0 * rho2\n    qsca = qext - qabs\n    g = 1.0\n  else\n    !\n    beta = atan2(rho2, rho1)\n    !\n    qext = 2.0 + 4.0/(rr*rr) * &\n      (cos(2.0*beta) - &\n       exp(-rho2) * &\n       (cos(rho1-2.0*beta) - rr*sin(rho1-beta)))\n    qabs = 1.0 + (exp(-2.0*rho2)*(2.0*rho2+1.0) - 1.0) / (2.0*rho2*rho2)\n    qsca = qext - qabs\n    g = 1.0\n  end if\nend subroutine adt_sphere\n"}, {"instruction": "Create a Fortran subroutine named crossproduct to calculate the cross product of two 3D vectors. The subroutine should have 2 input parameters of type real*8, named a and b, and 1 output parameter of type real*8, named ans. The calculation should be performed as follows: ans(1) = a(2)*b(3) - a(3)*b(2), ans(2) = -a(1)*b(3) + a(3)*b(1), ans(3) = a(1)*b(2) - a(2)*b(1).", "input": "", "output": "  subroutine crossproduct( a,b,ans )\n    implicit none\n    real*8, intent(in) :: a(3),b(3)\n    real*8, intent(out) :: ans(3)\n    ans(1) = a(2)*b(3)-a(3)*b(2)\n    ans(2) = -a(1)*b(3)+a(3)*b(1)\n    ans(3) = a(1)*b(2)-a(2)*b(1)\n  end subroutine crossproduct\n"}, {"instruction": "Create a Fortran subroutine named vecmat to perform the multiplication of a vector with a matrix. The subroutine takes 4 input parameters: ndim1 (integer), ndim2 (integer), vec1 (double precision array), xmat (double precision 2D array), and 1 output parameter: vec2 (double precision array). The subroutine computes the elements of vec2 using the formula vec2(i) = vec1(j) * xmat(j,i) and sums over j.", "input": "", "output": "subroutine vecmat(vec1, ndim1, xmat, ndim2, vec2)\n  !***********************************************************************\n  !\n  ! multiplication vector * matrix\n  !\n  !\n  !    vec2(i)  =  vec1(j) * xmat(j,i) sum over j\n  !\n  !\n  !***********************************************************************\n  implicit none\n\n  integer, intent(in)           :: ndim1, ndim2\n  double precision, intent(in)  :: vec1(ndim1), xmat(ndim2,ndim1)\n  double precision, intent(out) :: vec2(ndim2)\n\n  integer :: i, j\n\n  vec2 = 0.d0\n\n  do i = 1, ndim1\n     do j = 1, ndim2\n\n        vec2(j) = vec2(j) + vec1(i) * xmat(j,i)\n\n     enddo\n  enddo\n\n  return\n  \nend subroutine vecmat\n"}, {"instruction": "Create a Fortran subroutine named qcheck to determine whether the sum of squares of the elements in a 4-element real array is greater than 1. The subroutine should take 1 input parameter of type real, dimension(4) and provide 1 output parameter of type logical. If the sum of squares is greater than 1, the output parameter should be set to false; otherwise, it should be set to true.", "input": "", "output": "  subroutine qcheck(ret, q)\n    logical, intent(out) :: ret\n    real, dimension(4), intent(in) :: q\n    real :: qout\n    qout = q(1)**2 + q(2)**2 + q(3)**2 + q(4)**2\n    if (qout > 1.0) then\n       ret = .false.\n    else\n       ret = .true.\n    end if\n  end subroutine qcheck\n"}, {"instruction": "Create a Fortran subroutine named symmetric_jaccard_kernel to calculate the symmetric Jaccard kernel matrix for a given set of vectors. The subroutine takes 2 input parameters of type integer and integer array, and 1 output parameter of type double precision array with dimensions n_items x n_items.", "input": "", "output": "subroutine symmetric_jaccard_kernel(n_items, vec1, kernel)\n\n    ! lengths = np.sum(vectors, axis=1)\n    ! shape = lengths.shape[0]\n    ! lengths = lengths.reshape((shape, 1))\n    !\n    ! kernel = np.dot(vectors, vectors.t)\n    ! kernel = kernel / (lengths + lengths.t - kernel)\n\n    implicit none\n\n    integer, intent(in) :: n_items\n    integer, intent(in), dimension(:,:) :: vec1\n    double precision, intent(out), dimension(n_items,n_items) :: kernel\n    integer :: i, j\n    double precision :: dp\n    integer, dimension(:), allocatable :: lengths\n\n    allocate(lengths(n_items))\n\n    !$omp parallel do\n    do i = 1, n_items\n        lengths(i) = sum(vec1(:,i))\n    end do\n    !$omp end parallel do\n\n    !$omp parallel do private(dp) schedule(dynamic)\n    do i = 1, n_items\n        do j = i, n_items\n\n            dp = dot_product(vec1(:,i), vec1(:,j))\n\n            kernel(i,j) = dp / (lengths(i) + lengths(j) - dp)\n            kernel(j,i) = kernel(i,j)\n\n        end do\n    end do\n    !$omp end parallel do\n\n    deallocate(lengths)\n\nend subroutine symmetric_jaccard_kernel\n"}, {"instruction": "Create a Fortran subroutine named getrunidfromschemid to extract the run ID from the given scheme ID. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "subroutine getrunidfromschemid(schemid, runid)\n    implicit none\n    !\n    ! arguments\n    character(*), intent(in)  :: schemid\n    character(*), intent(out) :: runid\n    !\n    ! locals\n    integer :: dotloc\n    integer :: slashloc\n    !\n    ! body\n    slashloc = max(  index(schemid, '/', back=.true.), &\n                   & index(schemid, '\\', back=.true.)   ) \n    dotloc   = index(schemid(slashloc+1:), '.mdf', back=.true.)\n    if (dotloc == 0) then\n       runid = trim(schemid(slashloc+1:))\n    else\n       runid = schemid(slashloc+1:slashloc+dotloc-1)\n    endif\nend subroutine getrunidfromschemid\n"}, {"instruction": "Write a Fortran subroutine named get_location_id_and_quantity_id that takes an integer exchange_item_id as input and returns two integers, location_id and quantity_id, as output. The exchange_item_id is divided by 1000 to obtain the location_id, and the quantity_id is obtained by taking the modulo of exchange_item_id with 1000. Use the imperative tone.", "input": "", "output": "subroutine get_location_id_and_quantity_id(exchange_item_id, location_id,quantity_id) \n    !arguments\n    integer, intent(in) :: exchange_item_id\n    integer, intent(out) :: location_id, quantity_id\n    \n    location_id  = exchange_item_id / 1000\n    quantity_id = mod(exchange_item_id, 1000)\n\nend subroutine get_location_id_and_quantity_id\n"}, {"instruction": "Create a Fortran subroutine named sistub to solve a system of linear equations using the forward substitution method. The subroutine takes 2 input parameters: a is a real, two-dimensional array and b is a real, one-dimensional array. It also has 1 output parameter: u, which is a real, one-dimensional array.", "input": "", "output": "subroutine sistub(a, b, u)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: u\n\ninteger :: n, i, j\n\nn = size(b)\n\nu = b\n\ndo i = n, 1, -1\n  u(i) = u(i)/a(i,i)\n  u(1:i-1) = u(1:i-1) - a(1:i-1, i)*u(i)\nend do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named initialize with 5 input parameters of types integer, integer, real*8, real*8, and real*8. The 4 output parameters are of type real*8, with dimensions nx and ny. The subroutine sets initial conditions for the variables u, v1, v2, and v3 based on the given mesh points and initial conditions.", "input": "", "output": "subroutine initialize(u,v1,v2,v3,c,dx,dy,nx,ny)\n  !===============================================================\n  ! description: \n  !    sets the initial conditions into u, v1, v2, v3.\n  !===============================================================\n  ! inclusions\n  implicit none\n\n  ! declarations\n  integer, intent(in)  :: nx, ny\n  real*8,  intent(in)  :: c, dx, dy\n  real*8, dimension(nx,ny), intent(out) :: u, v1, v2, v3\n  real*8 :: xspan_c(nx), xspan_h(nx), yspan_c(ny), yspan_h(ny)\n  real*8 :: x_c, x_h, y_c, y_h\n  integer :: i, j\n  \n  ! internals\n  \n  ! set mesh points\n  do i=1,nx\n     xspan_c(i) = dx/2.d0 + (i-1)*dx\n     xspan_h(i) = (i-1)*dx\n  end do\n\n  do j=1,ny\n     yspan_c(j) = dy/2.d0 + (j-1)*dy\n     yspan_h(j) = (j-1)*dy\n  end do\n\n\n  ! set initial condition for solution and derivatives\n  do j=1,ny\n\n     ! y locations\n     y_c = yspan_c(j)\n     y_h = yspan_h(j)\n\n     do i=1,nx\n\n        ! x locations\n        x_c = xspan_c(i)\n        x_h = xspan_h(i)\n\n        ! set initial conditions on u_x, u_y [gaussian blob]\n        !    u(0,x,y) = exp(-100*((x-1/3)^2+(y-1/2)^2))\n        !    c*u_x(0,x,y) = -200*c*(x-1/3)*exp(-100*((x-1/3)^2+(y-1/2)^2))\n        !    c*u_y(0,x,y) = -200*c*(y-1/2)*exp(-100*((x-1/3)^2+(y-1/2)^2))\n        u(i,j) = exp(-1.d2*((x_c-1.d0/3.d0)**2+(y_c-0.5d0)**2))\n        v1(i,j) = 0.d0\n        v2(i,j) = -2.d2*c*(x_h-1.d0/3.d0)*exp(-1.d2*((x_h-1.d0/3.d0)**2+(y_c-0.5d0)**2))\n        v3(i,j) = -2.d2*c*(y_h-0.5d0)*exp(-1.d2*((x_c-1.d0/3.d0)**2+(y_h-0.5d0)**2))\n\n     end do\n  end do\n  \n  return\n\n  ! end program\nend subroutine initialize\n"}, {"instruction": "Write a Fortran subroutine named find_varname to search for a variable name within a list of declarations. The subroutine takes 3 input parameters of type ['character(len=*), dimension(:)', 'character(len=*)', 'integer'] and 2 output parameters of type ['integer', 'integer']. The subroutine searches for the variable name within the declarations and returns the line index and decoration index where the variable is found.", "input": "", "output": "subroutine find_varname( declarations, varname, start, line_index, decoration_index )\n\n    character(len=*), dimension(:),intent(in) :: declarations\n    character(len=*), intent(in)              :: varname\n    integer, intent(in)                       :: start\n    integer, intent(out)                      :: line_index\n    integer, intent(out)                      :: decoration_index\n\n    integer :: i\n    integer :: j\n    integer :: k\n\n    line_index       = -1\n    decoration_index = -1\n\n\n    do i = start,size(declarations)\n        j = index( declarations(i), '::' )\n        do\n            k = index( declarations(i)(j:), trim(varname) )\n            if ( k > 0 ) then\n                j = j + k - 1\n                k = j + len_trim(varname)\n                if ( index( ',:',  declarations(i)(j-1:j-1) ) > 0 .and. &\n                     index( ',*( ', declarations(i)(k:k) )    > 0 ) then\n                    line_index       = i\n                    decoration_index = k\n                    if ( index( '*(', declarations(i)(k:k) ) <= 0 ) then\n                        decoration_index = -1 ! no particular decoration\n                    endif\n                    exit\n                else\n                    j = k + 1\n                endif\n            else\n                exit\n            endif\n        enddo\n        if ( line_index > 0 ) then\n            exit ! we are done\n        endif\n    enddo\nend subroutine find_varname\n"}, {"instruction": "Create a Fortran subroutine named tokenize to parse a text containing dimensions in the format \"length x width x height\". The subroutine takes 1 input parameter of type character(*) and returns 3 output parameters of type integer, representing the length, width, and height parsed from the input text.", "input": "", "output": "subroutine tokenize(text, length, width, height)\n    implicit none\n\n    character(*), intent(in) :: text\n    integer, intent(out) :: length, width, height\n    character(10) :: values(3)\n    integer :: pos1, pos2, n, i\n\n    pos1 = 1\n    pos2 = 0\n    n = 0\n\n    do\n        pos2 = index(text(pos1:), 'x')\n\n        if (pos2 == 0) then\n            n = n + 1\n            values(n) = text(pos1:)\n            exit\n        end if\n\n        n = n + 1\n        values(n) = text(pos1:pos1 + pos2 - 2)\n        pos1 = pos2 + pos1\n    end do\n\n    read (values(1), '(i10)') length\n    read (values(2), '(i10)') width\n    read (values(3), '(i10)') height\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named twosmallest to find the two smallest values among three input integers. The subroutine should take 3 input parameters of type integer and provide 2 output parameters of type integer.", "input": "", "output": "subroutine twosmallest(val1, val2, val3, small1, small2)\n    implicit none\n\n    integer, intent(in) :: val1, val2, val3\n    integer, intent(out) :: small1, small2\n    integer :: big\n\n    ! warning: ugly hack\n\n    big = max(val1, val2, val3)\n\n    if (big == val1) then\n        small1 = val2\n        small2 = val3\n    elseif (big == val2) then\n        small1 = val1\n        small2 = val3\n    else\n        small1 = val1\n        small2 = val2\n    end if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named significant_length to determine the length of the first word in a given character string. The subroutine takes 1 input parameter of type character(len = *) and produces 1 output parameter of type integer.", "input": "", "output": "      subroutine significant_length( str, n )\n\n        character(len = *), intent(in) :: str\n        integer, intent(out) :: n\n\n        integer :: i, l\n\n        n = 0\n        l = len(str)\n\n        do i = 1, l, 1\n            if( str(i:i) .eq. ' ' ) then\n                exit\n            endif\n            n = n + 1\n        end do\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named str2int to convert a given character string to an integer. The subroutine takes 1 input parameter of type character(len=*) and 2 output parameters of type integer.", "input": "", "output": "          elemental subroutine str2int(str,int,stat)\n          implicit none\n          ! arguments\n          character(len=*),intent(in) :: str\n          integer,intent(out)         :: int\n          integer,intent(out)         :: stat\n    \n          read(str,*,iostat=stat)  int\n          end subroutine str2int\n"}, {"instruction": "Create a Fortran subroutine named phase_space_avg to compute the mean of the phase-space. The subroutine takes 8 input parameters: 3 integers (ndim0, nx, ny), and 5 arrays of real numbers (xin, yin, arr, xout, yout). It also has 1 output parameter, which is a 2D array of real numbers (phase).", "input": "", "output": "subroutine phase_space_avg(xin, yin, arr, xout, yout, ndim0, nx, ny, phase)\n    ! compute the mean of the phase-space\n    implicit none\n    ! input vars\n    integer(kind=4), intent(in) :: ndim0, nx, ny  ! arrays dimension\n    real(kind=8), intent(in), dimension(ndim0) :: xin\n    real(kind=8), intent(in), dimension(ndim0) :: yin\n    real(kind=8), intent(in), dimension(ndim0) :: arr\n    real(kind=8), intent(in), dimension(nx) :: xout\n    real(kind=8), intent(in), dimension(ny) :: yout\n\n    ! output vars\n    real(kind=8), intent(out), dimension(ny, nx) :: phase\n\n    ! parameters\n    integer(kind=4) :: i, j, cnt\n    real(kind=8) :: dx, dy, total\n\n    dx = abs(xout(2) - xout(1)) / 2.0\n    dy = abs(yout(2) - yout(1)) / 2.0\n\n    do j = 1, ny\n        do i = 1, nx\n             cnt = count((xin >= xout(i) - dx).and. &\n                         (xin < xout(i) + dx).and. &\n                         (yin >= yout(j) - dy).and. &\n                         (yin < yout(j) + dy))\n\n            if (cnt.eq.0) then\n                continue\n            endif\n\n            total = sum(arr, mask=((xin >= xout(i) - dx).and. &\n                                   (xin < xout(i) + dx).and. &\n                                   (yin >= yout(j) - dy).and. &\n                                   (yin < yout(j) + dy)))\n\n            phase(j, i) = total / cnt\n       enddo\n    enddo\n    return\nend subroutine phase_space_avg\n"}, {"instruction": "Create a Fortran subroutine named intersection to find the intersection of two 2-dimensional integer arrays. The subroutine should have 2 input parameters of type integer, dimension(2) and intent(in), and 1 output parameter of type integer, dimension(2) and intent(out). The subroutine should use the imperative tone to perform the intersection operation.", "input": "", "output": "    pure subroutine intersection( a, b, c )\n    \n        integer, dimension(2), intent(in) :: a, b\n        integer, dimension(2), intent(out) :: c\n        \n        c(1) = max(a(1),b(1))\n        c(2) = min(a(2),b(2))\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named union to compare two arrays of two integers each and store the element-wise minimum and maximum of the input arrays into an output array. The number of input parameters is 2 with test_data types ['integer, dimension(2)', 'integer, dimension(2)'], and the number of output parameters is 1 with test_data type ['integer, dimension(2)'].", "input": "", "output": "    pure subroutine union( a, b, c ) \n    \n        integer, dimension(2), intent(in) :: a, b\n        integer, dimension(2), intent(out) :: c\n        \n        c(1) = min(a(1),b(1))\n        c(2) = max(a(2),b(2))\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named proma3 that evaluates a matrix-vector product adding over a. The subroutine takes 5 input parameters of types integer (kind=4), integer (kind=4), real (kind=8), real (kind=8), and logical(kind=4), and 1 output parameter of type real (kind=8).", "input": "", "output": "      subroutine proma3(a,b,c,n1,n3,zeros)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix-vector product adding over a\r\n!\r\n!           a(i) = b(i,k) * c(k)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n3\r\n      real (kind=8),intent(in) :: b(n1,n3), c(n3)\r\n      real (kind=8),intent(out) :: a(n1)\r\n      logical(kind=4),intent(in) :: zeros\r\n\r\n      if (zeros) then\r\n        a = matmul(b,c)\r\n      else\r\n        a = a + matmul(b,c)\r\n      end if\r\n      return\r\n\r\n      end subroutine proma3\r\n"}, {"instruction": "Create a Fortran subroutine named \"interp3\" to perform trilinear interpolation on a 3D array. The subroutine should have 10 input parameters with the test_data type ['integer', 'real', 'real'] and 1 output parameter with the test_data type ['real']. The input parameters are nx, ny, nz, a(nx, ny, nz), ix, iy, iz, dxi, dyi, dzi, and the output parameter is b. The subroutine should use the imperative tone and provide a brief summary of the trilinear interpolation process.", "input": "", "output": "pure subroutine interp3(a, ix, iy, iz, dxi, dyi, dzi, b, nx, ny, nz)\n  implicit none\n\n  integer, intent(in) :: nx, ny, nz\n  real, intent(in) :: a(nx, ny, nz)\n  integer, intent(in) :: ix, iy, iz\n  real, intent(in) :: dxi, dyi, dzi\n  real, intent(out) :: b\n  real :: x00, x01, x10, x11, y0, y1\n\n  x00 = a(ix, iy    , iz    ) + dxi * (a(ix + 1, iy    , iz    ) - a(ix, iy    , iz    ))\n  x10 = a(ix, iy + 1, iz    ) + dxi * (a(ix + 1, iy + 1, iz    ) - a(ix, iy + 1, iz    ))\n  x01 = a(ix, iy    , iz + 1) + dxi * (a(ix + 1, iy    , iz + 1) - a(ix, iy    , iz + 1))\n  x11 = a(ix, iy + 1, iz + 1) + dxi * (a(ix + 1, iy + 1, iz + 1) - a(ix, iy + 1, iz + 1))\n  y0 = x00 + dyi * (x10 - x00)\n  y1 = x01 + dyi * (x11 - x01)\n  b = y0 + dzi * (y1 - y0)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named xtoz to convert x coordinates to z coordinates on the discretized space. The subroutine takes 5 input parameters: nd (integer), x (real, dimension (1 : nd)), h (real, dimension (1 : nd)), lb (real, dimension (1 : nd)), ub (real, dimension (1 : nd)), and produces 1 output parameter: z (integer, dimension (1 : nd)).", "input": "", "output": "subroutine xtoz(z, x, h, lb, ub, nd)\n!------------------------------------------------------------------\n!\txtoz converts x coordinates to z coordinates on the discretized space\n!\tinput:\n!\t\t\tx\t\tthe coordinates of the point to be converted\n!\t\t\th\t\tthe space grid size\n!\t\t\tlb\t\tthe lower bound of the space\n!\t\t\tub\t\tthe upper bound of the space\n!\t\t\tnd\t\tthe dimension of apace\n!\toutput:\n!\t\t\tz\t\tthe z coordinates of the point\n!\tby: yousef naranjani-mar 30 2016\n!------------------------------------------------------------------\n\timplicit none\n\tinteger, intent(in)::nd\n\treal, dimension (1 : nd), intent(in):: x, h, lb, ub\n\tinteger, dimension (1 : nd), intent(out):: z\n\tinteger:: i\n\tdo i = 1, nd\n\t\tif ((x(i) < lb(i)).or.(x(i) > ub(i))) then\n!\t\t\terror stop \"xtoz: the x coordinate was out of bound\"\n\t\t\tz = -1\n\t\t\texit\n\t\telse if (x(i) == ub(i)) then\n\t\t\tz(i) = floor((ub(i)-lb(i))/h(i))\n\t\telse\n\t\t\tz(i) = floor((x(i)-lb(i))/h(i)) + 1\n\t\tend if\n\tend do\nend subroutine xtoz\n"}, {"instruction": "Create a Fortran subroutine named formatter that takes three input parameters of type character(*), integer, and integer, and one output parameter of type real*8. The subroutine reads data from a file specified by the filename and stores it in the arraydata with dimensions ny by nx.", "input": "", "output": "subroutine formatter(filename, nx, ny, arraydata)\n    implicit none\n    ! arguments\n    character(*), intent(in) :: filename\n    integer, intent(in) :: nx, ny\n    real*8, intent(out) :: arraydata(ny,nx)\n    ! local variables\n    integer ::i,j\n\n    ! read\n    open(11, file=trim(filename), status='old', action='read')\n    read(11,101) ((arraydata(i,j:j+9), j=1,nx,10), i=ny,1,-1)\n    close(11)\n101 format(10f8.2)\n    return\nend subroutine formatter\n"}, {"instruction": "Write a Fortran subroutine named \"fdiff\" to calculate the difference between two real numbers. The subroutine should take 2 input parameters of type real and 1 output parameter of type real. When using the subroutine, provide two real numbers as input, and the subroutine will return the difference as the output.", "input": "", "output": "    subroutine fdiff(a, b, res)\n        implicit none\n        real, intent(in)  :: a\n        real, intent(in)  :: b\n        real, intent(out) :: res\n        res = a - b\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named splinederiv to calculate the derivative of a given function using cubic spline interpolation. The subroutine takes 3 input parameters of type integer and real(kind=8), and one output parameter of type real(kind=8).", "input": "", "output": "subroutine splinederiv(x,s,dxds,n)\n\n  implicit none\n\n  ! input/output\n  integer ,intent(in) :: n\n  real(kind=8)   ,intent(in) :: x(n)\n  real(kind=8)   ,intent(in) :: s(n)\n  real(kind=8)   ,intent(out) :: dxds(n)\n\n  ! local\n  integer            :: i\n  \n  ! functions\n  real(kind=8)  :: alpha\n  alpha(i) = (s(i)-s(i-1))/(s(i+1) - s(i-1))\n\n  dxds(1) = 2*(x(2)-x(1)) - ( (1-alpha(2))*(x(2)-x(1)) + alpha(2)*(x(3)-x(2))*(s(2)-s(1))/(s(3)-s(2)))\n  dxds(n) = 2*(x(n)-x(n-1)) - (  (1-alpha(n-1))*(x(n-1)-x(n-2))*(s(n)-s(n-1))/(s(n-1)-s(n-2)) +alpha(n-1)*(x(n)-x(n-1)))\n\n  do i=2,n-1\n     dxds(i) = alpha(i)*(x(i+1)-x(i))+ (1-alpha(i))*(x(i)-x(i-1))\n  end do\n\n!dxds = 0\nend subroutine splinederiv\n"}, {"instruction": "Write a Fortran subroutine named set_optional that initializes an output integer value based on the input parameters. The subroutine takes 2 input parameters, one mandatory integer (idef) and one optional integer (iopt). The output is a single integer value. If the optional input (iopt) is provided, the output integer is set to the value of iopt; otherwise, it is set to the value of idef.", "input": "", "output": "elemental subroutine set_optional(i,idef,iopt)\n  integer, intent(out) :: i\n  integer, intent(in) :: idef\n  integer, intent(in), optional :: iopt\n  if (present(iopt)) then\n    i = iopt\n  else\n    i = idef\n  end if\n  end subroutine set_optional\n"}, {"instruction": "Write a Fortran subroutine named computeq to compute the value of q using the input arrays c and normal, and the integer ndime. The number of input arguments is 3 and the test_data type is [real*8, real*8, integer]. The number of output arguments is 1 and the test_data type is [real*8].", "input": "", "output": "subroutine computeq(q,c,normal,ndime)\n\treal*8 , intent(out) :: q(ndime,ndime)\n\treal*8 , intent(in) :: c(ndime,ndime,ndime,ndime), normal(ndime)\n\tinteger , intent(in) :: ndime\n\tinteger :: i,j,k,l\n\t\n\tq = 0.0d0\n\tdo i = 1 , ndime\n\tdo j = 1 , ndime\n\tdo k = 1 , ndime\n\tdo l = 1 , ndime\n\t\tq(i,k) = q(i,k) + c(i,j,k,l)*normal(j)*normal(l) \n\tend do\n\tend do\n\tend do\n\tend do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named herlang_mstep that calculates the alpha and rate values based on the given input data. The subroutine takes 5 input parameters of types integer, integer, double precision, double precision, and double precision. It also returns 2 output parameters of type double precision.", "input": "", "output": "  subroutine herlang_mstep(n, etotal, eb, ew, alpha, nshape, rate)\n    integer, intent(in) :: n\n    integer, intent(in) :: nshape(1:n)\n    double precision, intent(in) :: etotal, eb(1:n), ew(1:n)\n    double precision, intent(out) :: alpha(1:n), rate(1:n)\n\n    alpha(1:n) = eb(1:n) / etotal\n    rate(1:n) = nshape(1:n) * eb(1:n) / ew(1:n)\n\n  end subroutine herlang_mstep\n"}, {"instruction": "Create a Fortran subroutine named diis_b to compute the matrix b of the DIIS (Direct Inversion in the Iterative Subspace) algorithm. The subroutine takes 3 input parameters: two integers kf and steps, and a 2D real*8 array elist with dimensions (steps,kf*kf). It produces 1 output parameter: a 2D real*8 array b with dimensions (steps+1,steps+1).", "input": "", "output": "    subroutine diis_b(kf,elist,steps,b)\n        ! ----------------------------------------\n        ! compute matrix b of diis algorithm.\n        ! ----------------------------------------\n        !\n        ! source:\n        !   t. helgaker, p. j\u00f8rgensen and j. olsen\n        !   molecular electronic-structure theory\n        !   wiley\n        !   2000\n        !\n        ! ----------------------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                               ! basis set size\n        integer, intent(in) :: steps                            ! current scf iteration\n        real*8, dimension(steps,kf*kf), intent(in) :: elist     ! list of errors\n\n        ! intermediate variables\n        integer :: i, j\n\n        ! output\n        real*8, dimension(steps+1,steps+1), intent(out) :: b     ! matrix b\n\n        !call print_real_matrix(steps,kf*kf,elist)\n\n        do i = 1, steps ! rows of b\n            do j = 1, steps ! cols of b\n\n                b(i,j) = dot_product(elist(i,:),elist(j,:))\n\n            end do\n        end do\n\n        b(:,steps+1) = -1.0d0\n\n        b(steps+1,:) = -1.0d0\n\n        b(steps+1,steps+1) = 0.0d0\n\n    end subroutine diis_b\n"}, {"instruction": "Write a Fortran subroutine named iorderp to reorder an array of integers based on their values in ascending order. The subroutine takes 2 input parameters of type integer and 1 output parameter of type integer. The input parameters are arrays with the same number of elements, and the output parameter stores the reordered indices of the input array elements.", "input": "", "output": "   subroutine iorderp(pnt, iarr, n)\n\n      implicit none\n\n      integer, intent(in)  :: n\n      integer, intent(out) :: pnt(1:n)\n      integer, intent(in)  :: iarr(1:n)\n      integer                :: i, j, k\n\n      do i = 1, n\n         pnt(i) = i\n         do j = 1, i - 1\n            if (iarr(pnt(j)) > iarr(i)) then\n               do k = i, j + 1, -1\n                  pnt(k) = pnt(k - 1)\n               end do\n               pnt(j) = i\n               exit\n            end if\n         end do\n      end do\n\n   end subroutine iorderp\n"}, {"instruction": "Create a Fortran subroutine named \"rorderp\" that takes two input parameters: an integer \"n\" and a real array \"rarr\" of size \"n\". It also has one output parameter, an integer array \"pnt\" of size \"n\". The subroutine sorts the input real array \"rarr\" and returns the corresponding permutation indices in the \"pnt\" array.", "input": "", "output": "   subroutine rorderp(pnt, rarr, n)\n\n      implicit none\n\n      integer, intent(in)  :: n\n      integer, intent(out) :: pnt(1:n)\n      real, intent(in)  :: rarr(1:n)\n      integer                :: i, j, k\n\n      do i = 1, n\n         pnt(i) = i\n         do j = 1, i - 1\n            if (rarr(pnt(j)) > rarr(i)) then\n               do k = i, j + 1, -1\n                  pnt(k) = pnt(k - 1)\n               end do\n               pnt(j) = i\n               exit\n            end if\n         end do\n      end do\n\n   end subroutine rorderp\n"}, {"instruction": "Create a Fortran subroutine named \"maskactiv\" to calculate cloud activation based on the given input parameters. The subroutine should have 7 input parameters of types integer, integer, integer, real, real (optional), real (optional), and integer, and 1 output parameter of type logical.", "input": "", "output": "  subroutine maskactiv(act_mask,nx,ny,nz,mode,rh,rc,w)\n    implicit none\n    \n    integer, intent(in) :: nx,ny,nz\n    real, intent(in)    :: rh(nz,nx,ny)\n    real, optional, intent(in) :: rc(nz,nx,ny),w(nz,nx,ny)\n    \n    integer, intent(in) :: mode ! 1 = initialization; 2 = normal timestepping\n    \n    logical, intent(out) :: act_mask(nz,nx,ny)\n    \n    logical :: actmask_newcloud(nz,nx,ny)\n    logical :: actmask_oldcloud(nz,nx,ny)\n    logical :: cldmask(nz,nx,ny)\n    logical :: cldm1(nz,nx,ny),   & !inverse cloud mask offset downwards by one grid level\n         cldp1(nz,nx,ny),   & !inverse cloud mask offset upwards by one grid level\n         cldpm(nz,nx,ny)\n    \n    logical :: notused(nx,ny)\n    \n    integer :: k\n    \n    actmask_newcloud = .false.\n    actmask_oldcloud = .false.\n    cldm1 = .true.\n    cldp1 = .true.\n    cldpm = .true.\n    act_mask = .false.\n    \n    select case(mode)\n    case(1)\n       ! calculate cloud activation in all cloudy grid points for initialization\n       ! i.e. points with rh >= threshold\n       !zrh = rv/rs\n       act_mask = ( rh >= 1.000 )\n       \n    case(2)\n       \n       ! normal opperation\n       \n       if ( .not. (present(rc) )) stop 'maskactiv: invalid arguments'\n       \n       ! mask grid points just below cloud or where new cloud is expected to form\n       !\n       \n       cldmask(:,:,:) = ( rc(:,:,:) >= 1.e-5 )\n       \n       \n       ! check for the lowest point where rh > 1.\n       cldpm(:,:,:) = .false.\n       cldpm(1:nz-1,:,:) = ( rh(2:nz,:,:) > 1.000 )\n       \n       cldp1(:,:,:) = .true.\n       cldp1(2:nz,:,:) = ( .not. cldpm(1:nz-1,:,:) )\n       actmask_newcloud(:,:,:) = ( cldpm(:,:,:) .and. cldp1(:,:,:) ) .and. ( w(:,:,:) > 0. ) &\n            .and. (rc(:,:,:) < 5.e-5)\n       \n       ! base of existing cloud\n       cldpm(:,:,:) = .false.\n       cldpm(1:nz-1,:,:) = cldmask(2:nz,:,:)\n       \n       cldp1(:,:,:) = .true.\n       cldp1(2:nz,:,:) = ( .not. cldpm(1:nz-1,:,:) )\n       \n       ! take the lowest level of the two cases\n       \n       notused = .true.\n       do k = 2, nz-1\n          ! new cloud + no old cloud\n          act_mask(k,:,:) = merge( (actmask_oldcloud(k,:,:) .or. actmask_newcloud(k,:,:))  &\n               .and. cldp1(k,:,:), .false., notused(:,:))\n          notused(:,:) = notused(:,:) .and. .not. act_mask(k,:,:)\n          notused(:,:) = (rh(k,:,:) < 0.99 .or. notused(:,:))\n       end do\n       \n    end select\n    \n  end subroutine maskactiv\n"}, {"instruction": "Create a Fortran subroutine named getbinmassarray to obtain the mass array for a specific bin. It takes 4 input parameters of type integer, integer, integer, and real. The output parameter is of type real.", "input": "", "output": "  subroutine getbinmassarray(nb,ns,ib,mass,binmass)\n    implicit none\n    ! --------------------------------------------------\n    ! get the mass array for a specific bin (length ns)\n    ! --------------------------------------------------\n    integer, intent(in) :: ns,nb  ! number of species, number of bins\n    integer, intent(in) :: ib     ! target bin\n    real, intent(in) :: mass(ns*nb)\n    \n    real, intent(out) :: binmass(ns)\n    \n    binmass(:) = 0.\n    binmass(1:ns) = mass(ib:(ns-1)*nb+ib:nb)\n    \n  end subroutine getbinmassarray\n"}, {"instruction": "Write a Fortran subroutine named getbintotalmass to calculate the total mass inside a bin. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The function sums the mass inside the specified bin and returns the total mass.", "input": "", "output": "  subroutine getbintotalmass(nb,ns,ib,mass,totmass)\n    implicit none\n    ! ------------------------------------------------\n    ! get the total mass inside a bin, simply a sum\n    ! ------------------------------------------------\n    integer, intent(in) :: ns,nb   ! number of species, number of bins\n    integer, intent(in) :: ib      ! target bin\n    real, intent(in) :: mass(ns*nb)\n    \n    real, intent(out) :: totmass\n    \n    totmass = 0.\n    totmass = sum(mass(ib:(ns-1)*nb+ib:nb))\n    \n  end subroutine getbintotalmass\n"}, {"instruction": "Create a Fortran subroutine named simpletest to generate an n x n array filled with the value 1. The subroutine takes 3 input parameters of type integer (n, n2, n4) and has 1 output parameter of type real(8) with a dimension of n x n.", "input": "", "output": "subroutine simpletest(a,n, n2, n4)\n    ! testing out the f2py funcitonality\n    ! 1. create an nxn array and return it\n    ! 2. iterate on the array using update\n\n    implicit none\n    integer, intent(in) :: n, n2, n4\n    real(8), intent(out), dimension(n,n) :: a\n\n    a = 1\n    return\n    end subroutine simpletest\n"}, {"instruction": "Create a Fortran subroutine named \"func_zener\" that calculates the Zener function for a given set of input data. The subroutine takes 4 input parameters: an integer \"n\", a double precision \"x\", a double precision \"qref\", and a double precision array \"point\" of size n. It produces 1 output parameter, a double precision array \"afunc\" of size n.", "input": "", "output": "subroutine func_zener(x,afunc,n,qref,point)\n\n  implicit none\n\n  integer, intent(in) :: n\n  double precision, intent(in) :: x,qref\n  double precision, dimension(1:n), intent(in) :: point\n  double precision, dimension(1:n), intent(out) :: afunc\n\n  integer k\n  double precision num,deno\n\n  do k = 1,n\n    num  = x * (point(k) - x / qref)\n    deno = point(k) * point(k) + x * x\n    afunc(k) = num / deno\n  enddo\n\nend subroutine func_zener\n"}, {"instruction": "Create a Fortran subroutine named func_objective to calculate a numerical result based on input parameters. This subroutine takes 5 input parameters: n and nopt of type integer, freq and qref of type double precision, and x of type double precision array of dimension 1:nopt. The output parameter is res of type double precision. The subroutine performs a series of calculations using the input parameters to update the value of res.", "input": "", "output": "subroutine func_objective(x,res,freq,qref,n,nopt)\n\n  implicit none\n\n  integer, intent(in) :: n,nopt\n  double precision, intent(in) :: freq,qref\n  double precision, intent(out) :: res\n  double precision, dimension(1:nopt), intent(in) :: x\n\n  integer i\n  double precision num,deno\n\n  res = 0.d0\n  do i=1,n\n    num = x(n+i)*x(n+i)*freq*qref*(x(i)*x(i) - freq/qref)\n    deno = (x(i) ** 4.) + freq*freq\n    res = res + num/deno\n  enddo\n\nend subroutine func_objective\n"}, {"instruction": "Create a Fortran subroutine named poly_sizeof to determine the size in bytes of the elements in the input array. The input parameter should be of type class(*) and intent(in), while the output parameter should be of type integer and intent(out). The subroutine takes 1 input argument with the test_data type ['class(*)'] and produces 1 output argument with the test_data type ['integer'].", "input": "", "output": "  subroutine poly_sizeof(arg1,arg2)\n    class(*), intent(in) :: arg1(:,:)\n    integer, intent(out) :: arg2\n    arg2 = sizeof(arg1(1,1))\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named simplex_hilo to identify the highest, next highest, and lowest elements in an array, along with checking for convergence. The subroutine has 3 input parameters of types integer, double precision array, and double precision. It also has 4 output parameters of types integer, integer, integer, and logical.", "input": "", "output": "  subroutine simplex_hilo(ndim, y, ftol, ihi, inhi, ilo, conv)\n\n    implicit none\n\n    integer,                             intent(in)  :: ndim\n    double precision, dimension(ndim+1), intent(in)  :: y\n    double precision,                    intent(in)  :: ftol\n    integer,                             intent(out) :: ihi, inhi, ilo\n    logical,                             intent(out) :: conv\n\n    double precision                                 :: rtol\n    integer          :: i\n   \n    ilo = 1\n    if (y(1) > y(2)) then\n       ihi  = 1\n       inhi = 2\n    else\n       ihi  = 2\n       inhi = 1\n    end if\n    do i = 1, ndim + 1\n       if(y(i) <= y(ilo)) ilo = i\n       if(y(i) >  y(ihi)) then\n          inhi = ihi\n          ihi  = i\n       else if(y(i) > y(inhi)) then\n          if(i /= ihi) inhi = i\n       end if\n    end do\n    \n    ! check for convergence:\n!    rtol = 2.0d0*abs(y(ihi) - y(ilo))/( abs(y(ihi)) + abs(y(ilo)) )\n    rtol = abs(y(ihi) - y(ilo))\n    if (rtol <= ftol) then\n       conv = .true.\n    else\n       conv = .false.\n    end if\n\n  end subroutine simplex_hilo\n"}, {"instruction": "Write a Fortran subroutine named \"glob_to_axial\" that takes two input arrays of real numbers with kind \"iwp\" and one output real number with kind \"iwp\". The input arrays are named \"global\" and \"coord\", and the output variable is named \"axial\".", "input": "", "output": "subroutine glob_to_axial(axial,global,coord)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::global(:),coord(:,:)\r\n real(iwp),intent(out)::axial\r\nend subroutine glob_to_axial\r\n"}, {"instruction": "Create a Fortran subroutine named \"mocouf\" that takes 5 input parameters of type real(iwp) and returns 1 output parameter of type real(iwp). The inputs are phi, c, sigm, dsbar, and theta, while the output parameter is f.", "input": "", "output": "subroutine mocouf(phi,c,sigm,dsbar,theta,f)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::phi,c,sigm,dsbar,theta\r\n real(iwp),intent(out)::f\r\nend subroutine mocouf\r\n"}, {"instruction": "Create a Fortran subroutine named open_mm5v3 to open an mm5v3 file. It takes 1 input parameter of type character(len=255) and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine open_mm5v3 (fname, lun, status)\n    \n    ! opens an mm5v3 file\n\n    implicit none\n   \n    ! arguments\n\n    character(len=255),intent(in)          :: fname\n    integer, intent(out)                   :: lun\n    integer, intent(out)                   :: status\n\n    ! local variables\n\n    integer                                :: i\n    logical                                :: used\n\n    status = 0\n    \n    lun = -1\n    ! find an available unit number\n    find_lun: do i = 7,1023\n      inquire (unit=i, opened=used)\n      if(used) then\n        cycle find_lun\n      else\n        lun = i\n        exit find_lun\n      endif\n    enddo find_lun\n    if (lun .lt. 0) then\n      print '(a)', 'no available unit numbers!'\n      status = 1\n    else\n      open ( file=trim(fname), unit=lun, access='sequential', &\n             form='unformatted', status='unknown', iostat=status, &\n             position='rewind')\n    endif\n  end subroutine open_mm5v3\n"}, {"instruction": "Create a Fortran subroutine named make_terrain_file_name to generate a file name based on the MM5 data root and the domain number string. The subroutine takes 2 input parameters of type character(len=255) and character(len=1), and returns 1 output parameter of type character(len=255).", "input": "", "output": "   subroutine make_terrain_file_name(mm5_data_root, domain_num_str,file_name)\n    implicit none\n    character(len=255),intent(in)    :: mm5_data_root\n    character(len=1),intent(in)      :: domain_num_str\n    character(len=255),intent(out)   :: file_name\n\n    file_name = trim(mm5_data_root)//'/static/terrain_domain'//domain_num_str\n    return\n  end subroutine make_terrain_file_name\n"}, {"instruction": "Create a Fortran subroutine named \"get_opacities\" to calculate opacities. The subroutine should have 6 input parameters of types [logical, logical, double precision, double precision, double precision, double precision], and 2 output parameters of type [double precision, double precision].", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: const_kappa_p = 0.33d-4\n    double precision, parameter :: kappa_p_exp_m = 1.0d0\n    double precision, parameter :: kappa_p_exp_n = 0.0d0\n    double precision, parameter :: kappa_p_exp_p = 0.0d0\n    double precision, parameter :: const_kappa_r = 0.33d0\n    double precision, parameter :: kappa_r_exp_m = 1.0d0\n    double precision, parameter :: kappa_r_exp_n = 0.0d0\n    double precision, parameter :: kappa_r_exp_p = 0.0d0\n    double precision, parameter :: tiny = 1.d-50\n    double precision, parameter :: tfloor = 0.d0\n    double precision, parameter :: kfloor = 0.d0\n\n    double precision :: teff, nup_kpp, nup_kpr\n\n    nup_kpp = nu**kappa_p_exp_p\n    nup_kpr = nu**kappa_r_exp_p\n\n    teff = max(temp, tiny)\n    teff = teff + tfloor * exp(-teff / (tfloor + tiny))\n\n    if (get_planck_mean) then\n       kp = const_kappa_p * (rho**kappa_p_exp_m) * (teff**(-kappa_p_exp_n)) * nup_kpp\n    end if\n\n    if (get_rosseland_mean) then\n       kr = const_kappa_r * (rho**kappa_r_exp_m) * (teff**(-kappa_r_exp_n)) * nup_kpr\n       kr = max(kr, kfloor)\n    end if\n\n  end subroutine get_opacities\n"}, {"instruction": "Create a Fortran subroutine named prep_opacity. This subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer, double precision, and double precision respectively. The function of the code is to initialize the output parameters inu, er, and der to -1, 0.0, and 0.0 respectively.", "input": "", "output": "  subroutine prep_opacity(g, inu, er, der)\n    implicit none\n    integer, intent(in) :: g\n    integer, intent(out) :: inu\n    double precision, intent(out) :: er, der\n    inu = -1\n    er = 0.d0\n    der = 0.d0\n  end subroutine prep_opacity\n"}, {"instruction": "Create a Fortran subroutine named ranmean3 to compute the mean vector of an ensemble. The subroutine takes 3 input parameters of type integer, integer, and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine ranmean3(ens,ave,n_var,n_ens)\r\n! return ensemble mean vector\r\n!\r\n  implicit none \r\n  integer             :: j\r\n  integer,intent(in)  :: n_var,n_ens\r\n  real(8),intent(in)  :: ens(n_var,n_ens)\r\n  real(8),intent(out) :: ave(n_var)\r\n!\r\n  ave(:)=ens(:,1)\r\n  do j=2,n_ens\r\n    ave(:)=ave(:)+ens(:,j)\r\n  enddo\r\n  ave(:)=ave(:)/dble(n_ens)\r\n!\r\nend subroutine ranmean3\r\n"}, {"instruction": "Create a Fortran subroutine named make_weights to calculate the values of an array f based on the input azimuth and array m. The number of input arguments is 2, with the test_data type ['real', 'real, dimension(:)']. The number of output arguments is 1, with the test_data type ['real, dimension(:)']. Use sin and cos functions to compute intermediate values, and assign computed values to the elements of array f based on specific calculations.", "input": "", "output": "    pure subroutine make_weights( azimuth, m, f )\n    \n        real, intent(in) :: azimuth\n        real, intent(in), dimension(:) :: m    ! (6)\n        real, intent(out), dimension(:) :: f   ! (6)\n        \n        real :: sa, ca, s2a, c2a\n        \n        sa = sin(azimuth)\n        ca = cos(azimuth)\n        s2a = sin(2.*azimuth)\n        c2a = cos(2.*azimuth)\n        \n        f(1) = m(1)*ca**2 + m(2)*sa**2 + m(4)*s2a\n        f(2) = m(5)*ca + m(6)*sa\n        f(3) = m(3)\n        f(4) = 0.5*(m(2)-m(1))*s2a + m(4)*c2a\n        f(5) = m(6)*ca - m(5)*sa\n        f(6) = m(1)*sa**2 + m(2)*ca**2 - m(4)*s2a   ! needed by near field terms\n    \n    end subroutine \n"}, {"instruction": "Create a Fortran subroutine named gettrueij_periodictripole to compute the true indices for a periodic map based on the input indices and periodicity. The subroutine takes 4 input parameters of type integer: i, j, nx, and ny. It also has 2 output parameters of type integer: true_i and true_j.", "input": "", "output": " subroutine gettrueij_periodictripole( i, j, nx, ny, true_i, true_j )\n   implicit none\n   integer, intent(in)  :: i, j, nx, ny\n   integer, intent(out) :: true_i, true_j\n   ! local\n   integer :: dj\n\n      if( j > ny )then\n   \n         dj = j - ny\n         true_j = ny - (dj-1)\n         if( i == 0 .or. i == nx+1 )then\n            true_i = i\n         else \n            true_i = nx-(i-1)\n         endif\n   \n      else\n   \n         true_j = j\n          \n         ! taking care of the x-periodicity in the map\n         if( i < 1 )then\n            true_i = nx + i\n         elseif( i > nx )then\n            true_i = i-nx\n         else\n            true_i = i\n         endif\n   \n      endif\n   \n end subroutine gettrueij_periodictripole\n"}, {"instruction": "Create a Fortran subroutine named razero that initializes an array of double precision numbers with zeros. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type double precision array with dimension n.", "input": "", "output": "subroutine razero(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  double precision, dimension(n), intent(out) :: x\n  !local variables\n  integer :: i\n!$ logical :: within_openmp,omp_in_parallel,omp_get_nested\n\n!$    within_openmp=omp_in_parallel() .or. omp_get_nested()\n\n!$omp parallel if (.not. within_openmp .and. n > 128) shared(x,n) private(i)\n!$omp do\n      do i=1,n\n      x(i)=0.d0\n      end do\n!$omp enddo\n!$omp end parallel\n\nend subroutine razero\n"}, {"instruction": "Create a Fortran subroutine named razero_simple that sets all elements of an input real array to zero. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real(kind=4) array. The input parameter specifies the length of the array, and the output parameter stores the zeroed array.", "input": "", "output": "subroutine razero_simple(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  real(kind=4), intent(out) :: x(n)\n  !local variables\n  integer :: i,m\n  !!do i=1,n\n  !!   x(i)=0.e0\n  !!end do\n  m=mod(n,7)\n  if (m/=0) then\n      do i=1,m\n          x(i)=0.e0\n      end do\n      if (n<7) return\n  end if\n  m=m+1\n  do i=m,n,7\n      x(i+0)=0.e0\n      x(i+1)=0.e0\n      x(i+2)=0.e0\n      x(i+3)=0.e0\n      x(i+4)=0.e0\n      x(i+5)=0.e0\n      x(i+6)=0.e0\n  end do\nend subroutine razero_simple\n"}, {"instruction": "Create a Fortran subroutine named razero_integer to fill an integer array with zeros. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer array with the dimension specified by the input parameter.", "input": "", "output": "subroutine razero_integer(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  integer, dimension(n), intent(out) :: x\n  !local variables\n  integer :: i,m\n  !!do i=1,n\n  !!   x(i)=0\n  !!end do\n  m=mod(n,7)\n  if (m/=0) then\n      do i=1,m\n          x(i)=0\n      end do\n      if (n<7) return\n  end if\n  m=m+1\n  do i=m,n,7\n      x(i+0)=0\n      x(i+1)=0\n      x(i+2)=0\n      x(i+3)=0\n      x(i+4)=0\n      x(i+5)=0\n      x(i+6)=0\n  end do\nend subroutine razero_integer\n"}, {"instruction": "Create a Fortran subroutine named dscopy that performs a scaling operation on a vector. The subroutine takes 4 input parameters: n (integer), incx (integer), incy (integer), dx (real(kind=8), dimension(*)), and 1 output parameter: dy (real(kind=4), dimension(*)). This subroutine copies the scaled elements of vector dx to vector dy with specified increments incx and incy.", "input": "", "output": "subroutine dscopy(n,dx,incx,dy,incy)\n  implicit none\n  integer, intent(in) :: n,incx,incy\n  real(kind=8), dimension(*), intent(in) :: dx\n  real(kind=4), dimension(*), intent(out) :: dy\n  !local variables\n  integer :: i,ix,iy\n  \n  ix=1\n  iy=1\n  do i=1,n\n     dy(iy)=real(dx(ix),kind=4)\n     ix=ix+incx\n     iy=iy+incy\n  end do\n\nend subroutine dscopy\n"}, {"instruction": "Write a Fortran subroutine named nsymgauss to perform Gaussian elimination for solving a system of linear equations. The subroutine takes 4 input parameters of types integer, integer, real,dimension(neq,ib), and real,dimension(neq), and 1 output parameter of type real,dimension(neq). The subroutine uses forward elimination and backward substitution to solve the system of linear equations.", "input": "", "output": "subroutine nsymgauss(y,a,f,neq,ib)\n  implicit none\n  integer :: idiag,i,j,k,jend,kbgn,kend,ikc,jkc,iback,jc,kc\n  real :: fac\n  integer, intent(in) :: neq,ib\n  real,dimension(neq,ib) :: aa\n  real,dimension(neq) :: ff\n  real,dimension(neq,ib),intent(in) :: a\n  real,dimension(neq),intent(in) :: f\n  real,dimension(neq),intent(out) :: y\n\n! initialize matrices to overwrite\n  do i = 1,neq\n     do j = 1,ib\n        aa(i,j) = a(i,j)\n     end do\n     ff(i) = f(i)\n  end do\n\n! forward elimination\n  idiag = ((ib - 1)/2) + 1\n  do i = 1,neq-1\n     jend = neq\n     if (jend > (i+idiag-1)) jend = i+idiag-1\n     do j = i+1,jend\n        kc   = idiag - (j-i)\n        fac  = -aa(j,kc)/aa(i,idiag)\n        kbgn = i\n        kend = jend\n        do k = kbgn,kend\n           ikc = idiag + (k-i)\n           jkc = idiag + (k-j)\n           aa(j,jkc) = aa(j,jkc) + fac*aa(i,ikc)\n        end do\n        ff(j) = ff(j) + fac*ff(i)\n     end do\n  end do\n\n! backward substitution\n  y(neq) = ff(neq)/aa(neq,idiag)\n  do iback = 2,neq\n     i    = neq - iback + 1\n     jend = neq\n     if (jend > (i+(idiag-1))) jend = i+(idiag-1)\n     do j = i+1,jend\n        jc    = idiag + (j-i) \n        ff(i) = ff(i) - aa(i,jc)*y(j)\n     end do\n     y(i) = ff(i)/aa(i,idiag)\n  end do\nend subroutine nsymgauss\n"}, {"instruction": "Create a Fortran subroutine named coeff2 to calculate coefficient values based on input parameters. The subroutine takes 2 input parameters of type real and 2 output parameters of type real. The input parameters are u0 and b(4,3), and the output parameters are a(2,2,2) and d(4). The subroutine performs specific calculations involving the input parameters to compute the values of the output parameters. Use the imperative tone to write the instruction for this subroutine.", "input": "", "output": "      subroutine coeff2 ( u0,b,a,d )\n      implicit none\n      real, intent(in) :: u0\n      real, intent(in) :: b(4,3)\n      real, intent(out) :: a(2,2,2), d(4)\n      real :: fw1, fw2, fw3, fw4\n      fw1 = b(1,1) * b(1,2)\n      fw2 = b(2,1) * b(3,2)\n      fw3 = b(3,1) * b(2,2)\n      fw4 = b(4,1) * b(4,2)\n      a(2,2,1) = fw1 + fw2\n      a(2,1,1) = b(1,1) * b(2,2) + b(2,1) * b(4,2)\n      a(1,2,1) = b(3,1) * b(1,2) + b(4,1) * b(3,2)\n      a(1,1,1) = fw3 + fw4\n      a(2,2,2) = fw1 + fw3\n      a(2,1,2) = b(1,2) * b(2,1) + b(2,2) * b(4,1)\n      a(1,2,2) = b(3,2) * b(1,1) + b(4,2) * b(3,1)\n      a(1,1,2) = fw2 + fw4\n      d(1) = b(3,2) * b(4,3) + b(4,2) * b(3,3) + b(2,3) / u0\n      d(2) = b(1,2) * b(4,3) + b(2,2) * b(3,3) + b(1,3) / u0\n      d(3) = b(3,1) * b(1,3) + b(4,1) * b(2,3) + b(3,3) / u0\n      d(4) = b(1,1) * b(1,3) + b(2,1) * b(2,3) + b(4,3) / u0\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sec2time that converts the input number of seconds into hours, minutes, and seconds. The input parameter is of type integer. There are three output parameters, all of type integer, representing hours, minutes, and seconds, respectively.", "input": "", "output": "subroutine sec2time (isecs,hour,minute,second)\n\ninteger, intent(in)                      :: isecs\ninteger, intent(out)                     :: hour,minute,second\n\n! ... local variables\n! ...\ninteger irest\n\nsecond = mod(isecs,60)\nirest = (isecs-second)/60\nminute = mod(irest,60)\nhour = (irest-minute)/60\n\nend subroutine sec2time\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_coulomb_matrix to generate a Coulomb matrix based on the atomic charges and coordinates. The subroutine takes 3 input parameters of type double precision, dimension(:), double precision, dimension(:,:), and integer. It returns 1 output parameter of type double precision, dimension(((nmax + 1) * nmax) / 2).", "input": "", "output": "subroutine fgenerate_coulomb_matrix(atomic_charges, coordinates, nmax, cm)\n    \n    implicit none\n\n    double precision, dimension(:), intent(in) :: atomic_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n\n    integer, intent(in) :: nmax\n\n    double precision, dimension(((nmax + 1) * nmax) / 2), intent(out):: cm\n\n    double precision, allocatable, dimension(:) :: row_norms\n    double precision :: pair_norm\n    double precision :: huge_double\n\n    integer, allocatable, dimension(:) :: sorted_atoms\n\n    double precision, allocatable, dimension(:,:) :: pair_distance_matrix\n\n    integer :: i, j, m, n, idx\n    integer :: natoms\n\n    if (size(coordinates, dim=1) /= size(atomic_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(atomic_charges, dim=1), \"atom_types!\"\n        stop\n    else\n        natoms = size(atomic_charges, dim=1)\n    endif\n\n    ! allocate temporary\n    allocate(pair_distance_matrix(natoms,natoms))\n    allocate(row_norms(natoms))\n    allocate(sorted_atoms(natoms))\n\n    huge_double = huge(row_norms(1))\n\n    ! calculate row-2-norms and store pair-distances in pair_distance_matrix\n    row_norms = 0.0d0\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        pair_norm = 0.5d0 * atomic_charges(i) ** 2.4d0\n        row_norms(i) = row_norms(i) + pair_norm * pair_norm\n        pair_distance_matrix(i, i) = pair_norm\n    enddo\n    !$omp end parallel do\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        do j = i+1, natoms\n            pair_norm = atomic_charges(i) * atomic_charges(j) &\n                & / sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n\n            pair_distance_matrix(i, j) = pair_norm\n            pair_distance_matrix(j, i) = pair_norm\n            pair_norm = pair_norm * pair_norm\n            row_norms(j) = row_norms(j) + pair_norm\n            row_norms(i) = row_norms(i) + pair_norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    !generate sorted list of atom ids by row_norms - not really (easily) parallelizable\n    do i = 1, natoms\n        j = minloc(row_norms, dim=1)\n        sorted_atoms(natoms - i + 1) = j\n        row_norms(j) = huge_double\n    enddo\n\n    ! fill coulomb matrix according to sorted row-2-norms\n    cm = 0.0d0\n    !$omp parallel do private(idx, i, j)\n    do m = 1, natoms\n        i = sorted_atoms(m)\n        idx = (m*m+m)/2 - m\n        do n = 1, m\n            j = sorted_atoms(n)\n            cm(idx+n) = pair_distance_matrix(i, j)\n        enddo\n    enddo\n    !$omp end parallel do\n\n    ! clean up\n    deallocate(pair_distance_matrix)\n    deallocate(row_norms)\n    deallocate(sorted_atoms)\nend subroutine fgenerate_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named \"domaindecomp\" to perform domain decomposition on a mesh. The subroutine takes 2 input parameters of type integer: \"nelems\" and \"ndomains\". It also has 1 output parameter of type integer array with size (0:ndomains) named \"offsetelem\". The subroutine uses the imperative tone and implements the domain decomposition algorithm as described in the provided reference.", "input": "", "output": "  subroutine domaindecomp(nelems,ndomains,offsetelem)\n    ! from https://www.hopr-project.org/externals/meshformat.pdf, algorithm 4\n    implicit none\n    integer,intent(in) :: nelems\n    integer,intent(in) :: ndomains\n    integer,intent(out) :: offsetelem(0:ndomains)\n    ! local\n    integer :: nlocalelems\n    integer :: remainelems\n    integer :: idom\n\n    nlocalelems = nelems/ndomains\n    remainelems = nelems - nlocalelems*ndomains\n    do idom = 0,ndomains - 1\n      offsetelem(idom) = idom*nlocalelems + min(idom,remainelems)\n    end do\n    offsetelem(ndomains) = nelems\n\n  end subroutine domaindecomp\n"}, {"instruction": "Create a Fortran subroutine named elemtorank to find the domain containing a given element index. The subroutine takes 3 input parameters of type integer: ndomains, offsetelem(0:ndomains), elemid, and has 1 output parameter of type integer: domain.", "input": "", "output": "  subroutine elemtorank(ndomains,offsetelem,elemid,domain)\n    ! from https://www.hopr-project.org/externals/meshformat.pdf, algorithm 7\n    !   \"find domain containing element index\"\n    !\n    implicit none\n    integer,intent(in) :: ndomains\n    integer,intent(in) :: offsetelem(0:ndomains)\n    integer,intent(in) :: elemid\n    integer,intent(out) :: domain\n    ! local\n    integer :: maxsteps\n    integer :: low,up,mid\n    integer :: i\n\n    domain = 0\n    maxsteps = int(log10(real(ndomains))/log10(2.0)) + 1\n    low = 0\n    up = ndomains - 1\n\n    if (offsetelem(low) < elemid .and. elemid <= offsetelem(low + 1)) then\n      domain = low\n    elseif (offsetelem(up) < elemid .and. elemid <= offsetelem(up + 1)) then\n      domain = up\n    else\n      do i = 1,maxsteps\n        mid = (up - low)/2 + low\n        if (offsetelem(mid) < elemid .and. elemid <= offsetelem(mid + 1)) then\n          domain = mid\n          return\n        elseif (elemid > offsetelem(mid + 1)) then\n          low = mid + 1\n        else\n          up = mid\n        end if\n      end do\n    end if\n\n  end subroutine elemtorank\n"}, {"instruction": "Create a Fortran subroutine named initialize, which initializes two 2D arrays of real numbers with the specified dimensions. The subroutine takes 2 input parameters of type integer, 'm' and 'n', and provides 2 output parameters of type real(fp_kind),allocatable, 'a' and 'anew'. The subroutine allocates memory for the arrays based on the input dimensions and initializes them with specific values.", "input": "", "output": "    subroutine initialize(a, anew, m, n)\n      integer, parameter :: fp_kind=kind(1.0d0)\n      real(fp_kind),allocatable,intent(out)   :: a(:,:)\n      real(fp_kind),allocatable,intent(out)   :: anew(:,:)\n      integer,intent(in)          :: m, n\n\n      allocate ( a(0:n-1,0:m-1), anew(0:n-1,0:m-1) )\n\n      a    = 0.0_fp_kind\n      anew = 0.0_fp_kind\n\n      a(0,:)    = 1.0_fp_kind\n      anew(0,:) = 1.0_fp_kind\n    end subroutine initialize\n"}, {"instruction": "Create a Fortran subroutine named sum_across_tasks_int4 to store the value of the input integer as the output integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine sum_across_tasks_int4(addend, sum)\n integer, intent(in) :: addend\n integer, intent(out) :: sum\n\nsum = addend\n\nend subroutine sum_across_tasks_int4\n"}, {"instruction": "Create a Fortran subroutine named tallykey that takes a string as input and outputs an array of integers to count the occurrences of each character in the input string. The number of input parameters is 1 with the test_data type ['character(len=*)'], and the number of output parameters is 1 with the test_data type ['integer, dimension(256)'].", "input": "", "output": "  subroutine tallykey(s, counts)\n    character(len=*), intent(in) :: s\n    integer, dimension(256), intent(out) :: counts\n    integer :: i, j\n    counts = 0\n    do i=1,len(s)\n      j = iachar(s(i:i))\n      counts(j) = counts(j) + 1\n    end do\n  end subroutine tallykey\n"}, {"instruction": "Create a Fortran subroutine named \"mlf_initordefault_bool\" that initializes a logical variable based on the provided default value and an optional override value. The subroutine takes 2 input parameters of type logical and optional logical, and returns 1 output parameter of type logical.", "input": "", "output": "  pure subroutine mlf_initordefault_bool(var, def, opt)\n    logical, intent(out) :: var\n    logical, intent(in) :: def\n    logical, intent(in), optional :: opt\n    if(present(opt)) then\n      var = opt\n    else\n      var = def\n    endif\n  end subroutine mlf_initordefault_bool\n"}, {"instruction": "Create a Fortran subroutine named countfrequencyshape to calculate the count and maximum frequency, as well as a shape parameter. The subroutine should take 2 input parameters of type real*8 and integer, and return 3 output parameters of type integer, integer, and real*8.", "input": "", "output": "subroutine countfrequencyshape(n0_om, nom_max, beta, omega, nomega)\n  implicit none\n  integer, intent(out):: n0_om, nom_max\n  real*8,  intent(out):: beta\n  real*8,  intent(in) :: omega(nomega)\n  integer, intent(in) :: nomega\n  !\n  integer :: iom\n  real*8  :: pi\n  pi=acos(-1.0d0)\n  beta = pi/omega(1)\n  do iom=1,nomega\n     if (abs((omega(iom)*beta/pi+1)/2. - iom).gt.1e-1) exit\n  enddo\n  n0_om = iom-1\n  if (n0_om.eq.0) n0_om=1\n  nom_max = nint((omega(nomega)*beta/pi+1)/2.)\n\nend subroutine countfrequencyshape\n"}, {"instruction": "Create a Fortran subroutine named occ_mask_to_vec to convert a logical mask array into a vector of integers. The subroutine takes 1 input parameter of type logical and 1 output parameter of type integer, which is allocatable.", "input": "", "output": "    subroutine occ_mask_to_vec(omask, ovec)\n        logical, intent(in) :: omask(:, :)\n        integer, allocatable, intent(out) :: ovec(:)\n\n        if (allocated(ovec)) deallocate(ovec)\n        allocate(ovec(size(omask, 1)), source = 0)\n        where (omask(:, 1)) ovec = ovec + 1\n        where (omask(:, 2)) ovec = ovec + 2\n    end subroutine occ_mask_to_vec\n"}, {"instruction": "Create a Fortran subroutine named para_range that takes four input parameters of type integer(kind=4) and returns two output parameters of the same type. The input parameters are n1, n2, nprocs, and myrank. The output parameters are ista and iend. The subroutine calculates the range of indices to be processed by each processor in a parallel computation.", "input": "", "output": "subroutine para_range(n1, n2, nprocs, myrank, ista, iend)\n\n    implicit none\n\n    integer(kind=4), intent(in)     :: n1, n2, nprocs, myrank\n    integer(kind=4), intent(out)    :: ista, iend\n    integer(kind=4) :: iwork1, iwork2\n\n    iwork1 = (n2 - n1 + 1) / nprocs\n    iwork2 = mod(n2 - n1 + 1, nprocs)\n    ista = myrank * iwork1 + n1 + min(myrank, iwork2)\n    iend = ista + iwork1 - 1\n    if (iwork2 > myrank) iend = iend + 1\n\nend subroutine para_range\n"}, {"instruction": "Create a Fortran subroutine named \"bar\" that calculates the sum of squares of all elements in a 2D array. The subroutine should take 1 input parameter of type real, dimension(:,:), and 1 output parameter of type real.", "input": "", "output": "  subroutine bar(a,x)\n    real, dimension(:,:), intent(in) :: a\n    real, intent(out) :: x\n    integer :: i,j\n\n    x = 0\n    do j=1,ubound(a,2)\n       do i=1,ubound(a,1)\n          x = x + a(i,j)**2\n       end do\n    end do\n  end subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named def_ic that calculates the initial condition for a given value of x. The subroutine takes 1 input parameter of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameter represents the value of x. The output parameter represents the calculated initial condition u0. The subroutine uses the Fortran features such as implicit none, intent(in), and intent(out). The subroutine computes the initial condition using the equation u0 = (8.0d0/(dsqrt(2.0d0*pi)))*dexp(-x**2.0/2.0) where pi is a predefined constant.", "input": "", "output": "  subroutine def_ic(x,u0)\n    implicit none\n    real(kind=8), intent(in) :: x\n    real(kind=8), intent(out) :: u0\n    real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)\n\n    u0 = (8.0d0/(dsqrt(2.0d0*pi)))*dexp(-x**2.0/2.0)\n  end subroutine def_ic\n"}, {"instruction": "Write a Fortran subroutine named \"get_remap_pix_len\" that calculates the length of pixel mapping indices and weights. The subroutine takes six input parameters: two integers (grid1 and grid2), and four real numbers (x1min, x1max, x2min, x2max). The output parameter is an integer named \"pixlen\". \n\nHere's what the subroutine does:\n1. It calculates the box size for grid1 and grid2 by subtracting x1min from x1max, and x2min from x2max, respectively.\n2. It calculates the step size for grid1 and grid2 by dividing the box size by the number of grid points in each grid.\n3. It computes the length of pixel mapping indices and weights (pixlen) by dividing the step size of grid2 by the step size of grid1 and adding 2.\n\nYour task is to implement the subroutine \"get_remap_pix_len\" in Fortran.", "input": "", "output": "subroutine get_remap_pix_len(x1min, x1max, grid1, x2min, x2max, grid2, pixlen)\n  ! find pixel weight length.\n  !\n  ! parameters\n  ! ----------\n  ! x1min : float\n  !   minimum in grid 1.\n  ! x1max : float\n  !   maximum in grid 1.\n  ! grid1 : int\n  !   number of grid points in grid 1.\n  ! x2min : float\n  !   minimum in grid 2.\n  ! x2max : float\n  !   maximum in grid 2.\n  ! grid2 : int\n  !   number of grid points in grid 2\n  !\n  ! returns\n  ! -------\n  ! pixlen : int\n  !   length of pixel mapping indices and weights.\n\n  implicit none\n\n  ! parameter declarations\n\n  integer, parameter :: dp = kind(1.d0)\n\n  integer, intent(in) :: grid1, grid2\n  real(kind=dp), intent(in) :: x1min, x1max, x2min, x2max\n\n  real(kind=dp) :: boxsize1, boxsize2, dx1, dx2\n\n  integer, intent(out) :: pixlen\n\n  ! function\n\n  boxsize1 = x1max - x1min\n  boxsize2 = x2max - x2min\n\n  dx1 = boxsize1 / real(grid1)\n  dx2 = boxsize2 / real(grid2)\n\n  pixlen = int(floor(dx2/dx1)) + 2\n\nend subroutine get_remap_pix_len\n"}, {"instruction": "Write a Fortran subroutine named \"which_pix\" that determines the pixel corresponding to a given point on a grid. The subroutine takes three input parameters of type real(kind=dp): \"xmin\" represents the minimum value along the grid, \"dx\" is the pixel width, and \"x\" is the point for which we want to determine the pixel. The subroutine has one output parameter of type integer, named \"pix\", which represents the pixel the point corresponds to.", "input": "", "output": "subroutine which_pix(xmin, dx, x, pix)\n\n  ! find pixel along a defined grid.\n  !\n  ! parameters\n  ! ----------\n  ! xmin : float\n  !   minimum along the grid.\n  ! dx : float\n  !   pixel width.\n  ! x : float\n  !   a point for which we would like to determine\n  !\n  ! returns\n  ! -------\n  ! pix : int\n  !   the pixel the point corresponds to.\n\n  implicit none\n\n  ! parameter declarations\n\n  integer, parameter :: dp = kind(1.d0)\n\n  real(kind=dp), intent(in) :: xmin, dx, x\n  integer, intent(out) :: pix\n\n  ! function\n\n  pix = int(floor((x-xmin)/dx))\n\nend subroutine which_pix\n"}, {"instruction": "Write a Fortran subroutine named \"pix1dto2d\" that maps the pixel indices along the x and y axes onto a 2D grid. The subroutine takes in five input parameters: \"xpix\" and \"ypix\" (integer arrays representing the pixel indices along the x and y axes), \"xlen\" and \"ylen\" (integers representing the size of the xpix and ypix arrays), and \"ygrid\" (an integer representing the length of the y axis grid). The subroutine returns one output parameter \"pix\" (an integer array representing the 2D grid pixels). The purpose of the subroutine is to assign the appropriate values to the \"pix\" array based on the given x and y pixel indices. The subroutine uses nested do-loops to iterate over the x and y pixel indices and assigns the values to the \"pix\" array based on certain conditions.", "input": "", "output": "subroutine pix1dto2d(xpix, ypix, xlen, ylen, ygrid, pix)\n\n  ! maps pixels given along a single axis in x and y onto a 2d grid flattened.\n  !\n  ! parameters\n  ! ----------\n  ! xpix : int\n  !   pixel indices along the x axis grid.\n  ! ypix : int\n  !   pixel indices along the y axis grid.\n  ! xlen : int\n  !   size of the xpix.\n  ! ylen : int\n  !   size of the ypix.\n  ! ygrid : int\n  !   length of y axis grid.\n  !\n  ! returns\n  ! -------\n  ! pix : int\n  !   2d grid pixel.\n\n  implicit none\n\n  integer, intent(in) :: xlen, ylen, ygrid\n  integer, intent(in) :: xpix(xlen), ypix(ylen)\n  integer, intent(out) :: pix(xlen*ylen)\n\n  integer :: i, j, ii\n\n  ii = 1\n\n  do i = 1, xlen\n    do j = 1, ylen\n      if ((xpix(i) .ne. -1) .and. (ypix(j) .ne. -1)) then\n        pix(ii) = ypix(j) + ygrid*xpix(i)\n      else\n        pix(ii) = -1\n      end if\n      ii = ii + 1\n    end do\n  end do\n\nend subroutine pix1dto2d\n"}, {"instruction": "Create a Fortran subroutine named kpspl3 to calculate the values of a cubic spline at a given point. The subroutine takes 1 input parameter of type real(4) and produces 1 output parameter of type real(4). The input parameter 'kp' is an input value for the calculation, and the output parameter 'kpterms' is an array containing the computed spline values.", "input": "", "output": "subroutine kpspl3(kp, kpterms)\n\n    implicit none\n\n    real(4), intent(in)       :: kp\n    real(4), intent(out)      :: kpterms(0:2)\n\n    integer(4)                :: i, j\n    real(4)                   :: x, kpspl(0:6)\n    real(4), parameter        :: node(0:7)=(/-10., -8., 0., 2., 5., 8., 18., 20./)\n\n    x = max(kp, 0.0)\n    x = min(x,  8.0)\n\n    kpterms(0:2) = 0.0\n    do i = 0, 6\n      kpspl(i) = 0.0\n      if ((x .ge. node(i)) .and. (x .lt. node(i+1))) kpspl(i) = 1.0\n    enddo\n    do j = 2,3\n      do i = 0, 8-j-1\n        kpspl(i) = kpspl(i)   * (x - node(i))   / (node(i+j-1) - node(i)) &\n                 + kpspl(i+1) * (node(i+j) - x) / (node(i+j)   - node(i+1))\n      enddo\n    enddo\n    kpterms(0) = kpspl(0) + kpspl(1)\n    kpterms(1) = kpspl(2)\n    kpterms(2) = kpspl(3) + kpspl(4)\n\n    return\n\nend subroutine kpspl3\n"}, {"instruction": "Create a Fortran subroutine named extract3_6x1_t2f to extract a 3x3 matrix from a 6x1 vector. The input parameter is a real(8) array vfvec with 6 elements, and the output parameter is a real(8) array res with dimensions 3x3.", "input": "", "output": "      subroutine extract3_6x1_t2f (res, vfvec)\n      ! extracts a 6x1 vector: res(3x3) = vfvec(6) [3rd dimension]\n      !     vfvec          vector; dimension (6)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (3,3)\n         real(8), intent(in)  :: vfvec (6)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1,1) = vfvec(1)\n         res(2,1) = vfvec(4)\n         res(3,1) = vfvec(6)\n         \n         res(1,2) = vfvec(4)\n         res(2,2) = vfvec(2)\n         res(3,2) = vfvec(5)\n         \n         res(1,3) = vfvec(6)\n         res(2,3) = vfvec(5)\n         res(3,3) = vfvec(3)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named contract3_t2f_6x1 to contract a 3x3 tensor and store the result in an array. The subroutine takes one input parameter of type real(8) and outputs another parameter of the same type. The input parameter represents a 3x3 tensor, and the output parameter is an array of size 6. The code calculates the contracted elements of the tensor and assigns them to the output array.", "input": "", "output": "      subroutine contract3_t2f_6x1 (res, t2f)\n      ! contracts a 3x3 tensor: res(6) = t2f(3x3) [3rd dimension]\n      !     t2f            tensor 2nd order; dimension (dimxdim)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (6)\n         real(8), intent(in)  :: t2f (3,3)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1) = t2f(1,1)\n         res(2) = t2f(2,2)\n         res(3) = t2f(3,3)\n         res(4) = t2f(1,2)\n         res(5) = t2f(2,3)\n         res(6) = t2f(3,1)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named contract3_t4f_6x6 to contract a 3x3x3x3 tensor into a 6x6 result matrix. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type real(8).", "input": "", "output": "      subroutine contract3_t4f_6x6 (res, t4f)\n      ! contracts a 3x3x3x3 tensor: res(6x6) = t2f(3x3x3x3) [3rd dimension]\n      !     t4f            tensor 4th order; dimension (dimxdimxdimxdim)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (6,6)\n         real(8), intent(in)  :: t4f (3,3,3,3)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1,1) = t4f(1,1,1,1)\n         res(2,1) = t4f(2,2,1,1)\n         res(3,1) = t4f(3,3,1,1)\n         res(4,1) = t4f(1,2,1,1)\n         res(5,1) = t4f(2,3,1,1)\n         res(6,1) = t4f(3,1,1,1)\n         \n         res(1,2) = t4f(1,1,2,2)\n         res(2,2) = t4f(2,2,2,2)\n         res(3,2) = t4f(3,3,2,2)\n         res(4,2) = t4f(1,2,2,2)\n         res(5,2) = t4f(2,3,2,2)\n         res(6,2) = t4f(3,1,2,2)\n         \n         res(1,3) = t4f(1,1,3,3)\n         res(2,3) = t4f(2,2,3,3)\n         res(3,3) = t4f(3,3,3,3)\n         res(4,3) = t4f(1,2,3,3)\n         res(5,3) = t4f(2,3,3,3)\n         res(6,3) = t4f(3,1,3,3)\n         \n         res(1,4) = t4f(1,1,1,2)\n         res(2,4) = t4f(2,2,1,2)\n         res(3,4) = t4f(3,3,1,2)\n         res(4,4) = t4f(1,2,1,2)\n         res(5,4) = t4f(2,3,1,2)\n         res(6,4) = t4f(3,1,1,2)\n         \n         res(1,5) = t4f(1,1,2,3)\n         res(2,5) = t4f(2,2,2,3)\n         res(3,5) = t4f(3,3,2,3)\n         res(4,5) = t4f(1,2,2,3)\n         res(5,5) = t4f(2,3,2,3)\n         res(6,5) = t4f(3,1,2,3)\n         \n         res(1,6) = t4f(1,1,3,1)\n         res(2,6) = t4f(2,2,3,1)\n         res(3,6) = t4f(3,3,3,1)\n         res(4,6) = t4f(1,2,3,1)\n         res(5,6) = t4f(2,3,3,1)\n         res(6,6) = t4f(3,1,3,1)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"in1_ord21\" to calculate the first inner product of two matrices. The subroutine takes 3 input parameters: an integer \"idm\", a double precision array \"t2f_a\" of dimension \"idm x idm\", and a double precision array \"t1f_b\" of dimension \"idm\". It returns 1 output parameter, a double precision array \"res\" of dimension \"idm\".", "input": "", "output": "      subroutine in1_ord21 (res, t2f_a, t1f_b, idm)\n      ! returns the first inner product of a and b\n      ! res_i = a_ij * b_j\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t1f_b (idm)\n      \n         !### var ###!\n         integer  :: i,jj\n         real(8)  :: fsum\n         \n         !### code ###!\n         do i = 1,idm\n            \n            fsum = 0.0d0\n            do jj = 1,idm\n               fsum = fsum + t2f_a(i,jj) * t1f_b(jj)\n            enddo\n            res(i) = fsum\n            \n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named in1_ord22 to calculate the first inner product of two matrices. The subroutine takes 3 input parameters: an integer (idm), and two real(8) matrices (t2f_a and t2f_b), and returns a single real(8) matrix (res) as the output. The subroutine computes the inner product according to the formula res_ij = a_ik * b_kj using nested do-loops.", "input": "", "output": "      subroutine in1_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the first inner product of a and b\n      ! res_ij = a_ik * b_kj\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n      \n         !### var ###!\n         integer  :: i,j,kk\n         real(8)  :: fsum\n         \n         !### code ###!\n         do j = 1,idm\n            do i = 1,idm\n               \n               fsum = 0.0d0\n               do kk = 1,idm\n                  fsum = fsum + t2f_a(i,kk) * t2f_b(kk,j)\n               enddo\n               res(i,j) = fsum\n               \n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named in2_ord22 to calculate the second inner product of two matrices.The subroutine takes 3 input parameters of type integer, real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "      subroutine in2_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the second inner product of a and b\n      ! res = a_ij * b_ij\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n      \n         !### var ###!\n         integer  :: ii,jj\n         \n         !### code ###!\n         res = 0.0d0\n         do jj = 1,idm\n            do ii = 1,idm\n               res = res + t2f_a(ii,jj) * t2f_b(ii,jj)\n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named in2_ord24 that calculates the second inner product of two matrices. The number of input arguments is 3, where the first argument is an integer (idm), the second argument is a 2-dimensional real array (t2f_a) and the third argument is a 4-dimensional real array (t4f_b). The number of output arguments is 1, which is a 2-dimensional real array (res). \n\nThe subroutine computes the second inner product by multiplying corresponding elements from the two matrices and summing them up. The result is stored in the res array. The size of the matrices is determined by the idm input parameter.\n\nUse the provided code as a reference to implement the subroutine.", "input": "", "output": "      subroutine in2_ord24 (res, t2f_a, t4f_b, idm)\n      ! returns the second inner product of a and b\n      ! res_ij = a_kl * b_klij\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t4f_b (idm,idm,idm,idm)\n      \n         !### var ###!\n         integer  :: i,j,kk,ll\n         real(8)  :: fsum\n         \n         !### code ###!\n         do j = 1,idm\n            do i = 1,idm\n               \n               fsum = 0.0d0\n               do ll = 1,idm\n                  do kk = 1,idm\n                     fsum = fsum + t2f_a(kk,ll) * t4f_b(kk,ll,i,j)\n                  enddo\n               enddo\n               res(i,j) = fsum\n               \n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"dyad_ord22\" that calculates the outer/dyadic product of two matrices. The number of input arguments is 3 and the test_data types are ['integer', 'real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)']. This subroutine takes in two matrices, \"t2f_a\" and \"t2f_b\", with dimensions \"idm\" by \"idm\", and computes the outer product of these matrices, storing the result in the \"res\" matrix with dimensions \"idm\" by \"idm\" by \"idm\" by \"idm\".", "input": "", "output": "      subroutine dyad_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the outer/dyadic product of a and b\n      ! res_ijkl = a_ij * b_kl\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm,idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n         \n         !### var ###!\n         integer  :: i,j,k,l\n         \n         !### code ###!\n         do l = 1,idm\n            do k = 1,idm\n               do j = 1,idm\n                  do i = 1,idm\n                     res(i,j,k,l) = t2f_a(i,j) * t2f_b(k,l)\n                  enddo\n               enddo\n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named get_basis that takes an array of integers as input. The number of input arguments is 1 and the test_data type is ['integer']. It also has three output parameters, all of which are integer arrays that are dynamically allocated. The test_data type for these output parameters is ['integer, allocatable', 'integer, allocatable', 'integer, allocatable'].\n\nThe purpose of this subroutine is to calculate the basis for a given set of functions. It iterates over the input array and computes the total number of basis functions based on the values in the array. It then allocates memory for the three output arrays based on the calculated number of basis functions. \n\nInside the subroutine, it iterates over the input array again to populate the output arrays with the corresponding values. The 'nlist' array stores the index of the basis function, the 'llist' array stores the value of the angular momentum, and the 'mlist' array stores the value of the magnetic quantum number. \n\nMake sure to allocate memory for the output arrays before populating them and deallocate the memory after using the arrays to avoid memory leaks.", "input": "", "output": "subroutine get_basis(nbfl, nlist, llist, mlist)\ninteger, intent(in) :: nbfl(0:)\ninteger, allocatable, intent(out) :: nlist(:), llist(:), mlist(:)\ninteger :: i, n, l, m, a\na = 0\ndo l = 0, ubound(nbfl, 1)\n    a = a + nbfl(l) * (2*l+1)\nend do\nallocate(nlist(a), llist(a), mlist(a))\ni = 1\ndo l = 0, ubound(nbfl, 1)\n    do n = 1, nbfl(l)\n        do m = -l, l\n            nlist(i) = n\n            llist(i) = l\n            mlist(i) = m\n            i = i + 1\n        end do\n    end do\nend do\nend subroutine\n"}, {"instruction": "Provide a Fortran subroutine named readfirstpart_of_in1 to read and extract parameters from an input file. The number of input parameters is 2, both of type integer. The number of output parameters is 7, including three logical variables, two real*8 variables, and two integer variables. The purpose of this subroutine is to read and extract output-format parameters and other variables from the input file. The extracted values will be stored in the output variables for further processing in the program.", "input": "", "output": "subroutine readfirstpart_of_in1(prntwf, sprswf, wftape, efermi, nt, rkm, lnsmax, nslmax, lmax)\n  !        read output-format parameters\n  implicit none\n  logical, intent(out) :: prntwf, sprswf, wftape\n  real*8, intent(out)  :: efermi, rkm\n  integer, intent(out) :: lnsmax, nt\n  integer, intent(in)  :: nslmax, lmax\n  ! locals\n  character   :: line*80\n  character*5 :: modus\n  integer     :: nt1, i\n  read(5,'(a)') line\n  read(line,'(a5)') modus    ! beginning of case.in1\n  if (modus .eq. 'wfpri') then\n     prntwf = .true.\n     sprswf = .false.\n     wftape = .true.\n  elseif (modus .eq. 'wffil') then  ! default\n     prntwf = .false.\n     sprswf = .false.\n     wftape = .true.\n  elseif (modus .eq. 'enfil') then\n     prntwf = .false.\n     sprswf = .true.\n     wftape = .false.\n  else\n     prntwf = .false.\n     sprswf = .true.\n     wftape = .false.\n  endif\n  ! from the first line of case.in1 extracts the fermi energy\n  efermi=0.5d0\n  do i=6,70\n     if(line(i:i+1).eq.'ef') then\n        read(line(i+3:80),*,err=1234) efermi\n     endif\n  enddo\n1234 continue\n  !\n  !        read in r-mt times k-max (used to check convergence)\n  !\n  read(5,*) rkm, nt1, lnsmax   ! rkm==r-mt*k-max; nt1==max l in wf; lnsmax==v-nmt\n  if (lnsmax .eq. 0) lnsmax = 2\n  if (lnsmax .ge. nslmax) lnsmax = nslmax - 1  ! can not be larger than nslmax=5\n  if (nt1 .gt. 0)    nt = nt1 + 1\n  if (nt  .gt. lmax) nt = lmax                 ! can not be greated that lmax=13\n  ! nt is lmax+1 but updated to be compatible with case.in1 specified maximum l.\nend subroutine readfirstpart_of_in1\n"}, {"instruction": "Create a Fortran subroutine named \"radial_basis\" to calculate the basis functions for a given set of parameters. The number of input arguments is 5 and their types are ['integer', 'double precision', 'integer', 'integer', 'double precision']. The number of output arguments is 2 and their types are ['double precision', 'integer'].\n\nThe subroutine takes an integer value \"l\", a double precision value \"alpha\", an integer value \"n_b\", an integer value \"n_r\", and an array \"r_grid\" of double precision values with length \"n_r\" as input. It also outputs an array \"basis\" of double precision values with dimensions \"n_r\" by \"n_b\", and an integer value \"status\".\n\nThe subroutine first checks if the input arguments are valid and sets the \"status\" variable accordingly. If any of the conditions are not met, \"status\" is set to 1 and the subroutine returns.\n\nNext, the subroutine calculates the normalization constants for the basis functions using a recurrence relation and stores them in the array \"norm\".\n\nThen, an array \"alpha_grid\" is created by multiplying the values of \"alpha\" with the elements of \"r_grid\".\n\nThe basis functions are then calculated using another recurrence relation, and the results are stored in the array \"basis\".\n\nFinally, the basis functions are scaled by the corresponding normalization constants.\n\nOverall, the \"radial_basis\" subroutine calculates the basis functions for a given set of parameters using recurrence relations and normalization constants, and outputs the results in the \"basis\" array and the status of the calculation in the \"status\" variable.", "input": "", "output": "  subroutine radial_basis (l, alpha, n_b, n_r, r_grid, basis, status)\n    integer , intent(in) :: l\n    double precision , intent(in) :: alpha\n    integer , intent(in) :: n_b\n    integer , intent(in) :: n_r\n    double precision , intent(in) :: r_grid(n_r)\n    double precision , intent(out) :: basis(n_r, n_b)\n    integer , intent(out) :: status\n    double precision :: norm(n_b)\n    double precision :: alpha_grid(n_r)\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1) .or. (n_r < 1)) then\n      status = 1\n      return\n    end if\n\n    ! recurrence relation for basis normalisation constants\n    norm(1) = sqrt(alpha / dble((l + 1d0) * gamma(dble((2d0 * l) + 2d0))))\n\n    if (n_b >= 2) then\n      do kk = 2, n_b\n        norm(kk) = norm(kk-1) * sqrt(dble((kk - 1d0) * (kk - 1d0 + l)) / &\n            dble((kk + l) * (kk + (2d0 * l))))\n      end do\n    end if\n\n    ! in-lined array since r_grid(:) on its own is never used\n    alpha_grid(:) = alpha * r_grid(:)\n\n    ! recurrence relation for basis functions\n    basis(:, 1) = ((2.0d0 * alpha_grid(:)) ** (l + 1)) * &\n        exp(-alpha_grid(:))\n\n    if (n_b >= 2) then\n      basis(:, 2) = 2.0d0 * (dble(l + 1d0) - alpha_grid(:)) * basis(:, 1)\n    end if\n\n    if (n_b >= 3) then\n      do kk = 3, n_b\n        basis(:, kk) = &\n            ((2.0d0 * (dble(kk - 1d0 + l) - alpha_grid(:)) * basis(:, kk-1)) &\n            - dble(kk + (2d0 * l) - 1d0) * basis(:, kk-2)) / dble(kk - 1)\n      end do\n    end if\n\n    ! scaling basis functions by normalisation constants\n    do kk = 1, n_b\n      basis(:, kk) = basis(:, kk) * norm(kk)\n    end do\n\n  end subroutine radial_basis\n"}, {"instruction": "Write a Fortran subroutine named \"overlap_matrix\" that calculates the overlap matrix for a given size \"l\" and number of basis functions \"n_b\". The subroutine takes two input parameters of type integer, \"l\" and \"n_b\", and two output parameters of type double precision and integer, \"b\" and \"status\", respectively.\n\nThe subroutine first checks if the input arguments are valid. If either \"l\" is negative or \"n_b\" is less than 1, the \"status\" is set to 1 and the subroutine returns.\n\nNext, the subroutine initializes a square matrix \"b\" of size \"n_b\" by \"n_b\" to zero.\n\nThen, the subroutine calculates the elements of the tri-diagonal overlap matrix using a loop. The diagonal elements are set to 1, and the off-diagonal elements are computed based on a formula involving \"l\". The elements are symmetric, so the subroutine sets both the upper and lower triangular elements simultaneously.\n\nFinally, the subroutine sets the last element of the matrix to 1, which is not covered by the loop.\n\nOverall, the \"overlap_matrix\" subroutine takes two integer input parameters, \"l\" and \"n_b\", and outputs a double precision matrix \"b\" and an integer \"status\".", "input": "", "output": "  subroutine overlap_matrix(l, n_b, b, status)\n    integer , intent(in) :: l\n    integer , intent(in) :: n_b\n    double precision , intent(out) :: b(n_b, n_b)\n    integer , intent(out) :: status\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1)) then\n      status = 1\n      return\n    end if\n\n    ! initialise overlap matrix to zero\n    b(:, :) = 0.0d0\n\n    ! determine tri-diagonal overlap matrix elements\n    do kk = 1, n_b-1\n      b(kk, kk) = 1.0d0\n\n      b(kk, kk+1) = - 0.5d0 * sqrt(1 - &\n          (dble(l * (l + 1)) / dble((kk + l) * (kk + l + 1))))\n\n      b(kk+1, kk) = b(kk, kk+1)\n    end do\n\n    ! last term (not covered by loop)\n    b(n_b, n_b) = 1.0d0\n\n  end subroutine overlap_matrix\n"}, {"instruction": "Create a Fortran subroutine named potential_matrix to calculate the potential matrix for a given set of input parameters. The subroutine takes 3 input parameters of type integer, integer, and double precision, and 2 output parameters of type double precision and integer.", "input": "", "output": "  subroutine potential_matrix(l, alpha, n_b, v, status)\n    integer , intent(in) :: l\n    integer , intent(in) :: n_b\n    double precision , intent(in) :: alpha\n    double precision , intent(out) :: v(n_b, n_b)\n    integer , intent(out) :: status\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1)) then\n      status = 1\n      return\n    end if\n\n    ! initialise coulomb matrix to zero\n    v(:, :) = 0.0d0\n\n    ! determine diagonal coulomb matrix elements\n    do kk = 1, n_b\n      v(kk, kk) = - alpha / dble(kk + l)\n    end do\n\n  end subroutine potential_matrix\n"}, {"instruction": "Create a Fortran subroutine named primarypsf to calculate the point spread function for a given optical system. The subroutine takes 11 input parameters of types integer, integer, integer, real*8 arrays, real*8, and complex*16, and outputs a real*8 array.", "input": "", "output": "subroutine primarypsf(distortion,xdim,ydim,z,length,x0,n,wave,primfoc,r0,graze,psf)\n  !declarations\n  implicit none\n  integer, intent(in) :: xdim,ydim,n\n  real*8, intent(in), dimension(xdim,ydim) :: distortion\n  real*8, intent(in), dimension(ydim) :: z\n  real*8, intent(in), dimension(n) :: x0\n  real*8, intent(in), dimension(xdim) :: length\n  real*8, intent(in) :: wave,primfoc,r0,graze\n  complex*16 :: j,integrand\n  real*8, intent(out), dimension(n) :: psf\n  integer :: i,xi,yi\n  real*8 :: d2,lengthsum,dz,dummy,pi\n\n  !constants\n  j = (0.,1.)\n  lengthsum = sum(length)\n  dz = abs(z(2)-z(1))\n  pi = acos(-1.)\n\n  do i = 1,n\n    psf(i) = 0.\n    do xi = 1,xdim\n      !compute integral over axial dimension\n      integrand = 0.\n      !$omp parallel do reduction(+:integrand) private(d2)\n      do yi = 1,ydim\n        if (isnan(distortion(xi,yi)) .eqv. .false.) then\n          d2 = sqrt((distortion(xi,yi)-x0(i))**2 + (z(yi)+primfoc)**2)\n          integrand = integrand + exp(-2*j*pi*(d2-z(yi))/wave)*sqrt(distortion(xi,yi)/d2)\n          !print *, distortion(xi,yi), z(yi), d2, integrand\n          !read *, dummy\n        end if\n      end do\n      !$omp end parallel do\n      !add weighted integral to relevant observation point\n      !print *, integrand,abs(integrand)**2,x0(i)\n      psf(i) = psf(i) + abs(integrand)**2*sin(graze)*dz**2/wave/r0/lengthsum\n      !print *, psf(i)\n      !read *, dummy\n    end do\n\n  end do\n\nend subroutine primarypsf\n"}, {"instruction": "Create a Fortran subroutine named scatter_matrix that takes 4 input arguments of type integer, integer, integer, real(8) and 1 output argument of type real(8).The input parameters represent the dimensions of matrices and the matrices themselves, while the output parameter represents the scattered matrix. The subroutine initializes the output matrix to zero and then scatters the input matrix values into the appropriate locations within the output matrix based on the specified dimensions.", "input": "", "output": "subroutine scatter_matrix(a, b, ndim, n, m)\n    implicit none\n    integer, intent(in) :: n, m, ndim\n    real(8), intent(in) :: a(m, n)\n    real(8), intent(out) :: b(ndim*m, ndim*n)\n    integer i, j, k\n\n!    initialization to zero; otherwise random stuff is there...\n    b(:,:) = 0.0\n! looping style like in python:\n    do i=0,m-1\n        do j=0,n-1\n            do k=0,ndim-1\n                b(ndim*i+k+1,ndim*j+k+1) = a(i+1,j+1)\n            end do\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine called invert_3_by_3_matrix to invert a 3x3 matrix and compute its determinant. The subroutine takes 1 input parameter of type real(8) representing the 3x3 matrix, and provides 2 output parameters of type real(8) representing the inverted matrix and determinant, respectively.", "input": "", "output": "subroutine invert_3_by_3_matrix(a, a_inv, det)\n    ! invert the matrix a and compute the determinant\n    implicit none\n\n    real(8), intent(in) :: a(3,3)\n    real(8), intent(out) :: a_inv(3,3), det\n    real(8) :: a11, a12, a13, a21, a22, a23, a31, a32, a33\n    a11 = a(1,1)\n    a12 = a(1,2)\n    a13 = a(1,3)\n    a21 = a(2,1)\n    a22 = a(2,2)\n    a23 = a(2,3)\n    a31 = a(3,1)\n    a32 = a(3,2)\n    a33 = a(3,3)\n    det = a11*a22*a33 - a11*a23*a32 - a12*a21*a33 + a12*a23*a31 + a13*a21*a32 - a13*a22*a31\n    a_inv = reshape((/ a22*a33 - a23*a32, -a21*a33 + a23*a31, &\n                       a21*a32 - a22*a31, -a12*a33 + a13*a32, &\n                       a11*a33 - a13*a31, -a11*a32 + a12*a31, &\n                       a12*a23 - a13*a22, -a11*a23 + a13*a21, &\n                       a11*a22 - a12*a21 /), (/3,3/)) / det\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linip_arr to perform linear interpolation of time-dependent profiles. The subroutine takes 5 input parameters, which are of type integer, integer, real*8, real*8, and real*8, and 1 output parameter of type real*8. The purpose of the subroutine is to interpolate profiles at a chosen time based on the input time vector and ordinate values. The output interpolated profiles are computed and stored in the variable y.", "input": "", "output": "subroutine linip_arr(m, n, ts, ys, t, y)\n!\n!     linear interpolation of time dependent profiles.\n!     for times which are outside the bounds the profile is set to the last/first present time.\n!\n\n!     we don't care about whether a profile has previously been interpolated or not.\n!\n!     inputs:\n!     m                       number of ts-vector elements\n!     n                        number of used rho-vector elements\n!     ts\t                the time vector. values must be monotonically increasing.\n!     ys(rho, ts)          array of ordinate values.\n!     t\t                the time for which the ordinates shall be interpolated\n!\n!     output:\n!     y(rho)                 interpolated profiles at the chosen time\n!\n  implicit none\n\n  integer, intent(in)                 :: m\n  integer, intent(in)                 :: n\n  real*8, intent(in)                   :: ts(m)\n  real*8, intent(in)                   :: ys(n, m)\n\n  real*8, intent(in)                   :: t\n  real*8, intent(out)                :: y(n)\n\n  integer :: k, i\n\n  real*8 ::  ff\n\n  ! if only one time point has been given, then return the same/only value\n  if (m.eq.1) then\n     do i=1,n\n        y(i) = ys(i,1)\n     enddo\n     return\n  endif\n\n  ! if the requested time is greater than the maximum time provided, then use the last time\n  if (t.ge.ts(m)) then\n     do i=1,n\n        y(i) = ys(i,m)\n     enddo\n     return\n  endif\n\n  ! if the requested time is smaller than the minimum time provided, then use the first time\n  if (t.lt.ts(1)) then\n     do i=1,n\n        y(i) = ys(i,1)\n     enddo\n     return\n  endif\n\n  ! find time point in \"ts\" vector that is marginally larger than the requested \"t\"\n  k=0\n  do k=1,m+1\n     if (t < ts(k+1)) then\n        exit\n     endif\n  enddo\n\n  ff = (t - ts(k))/(ts(k+1) - ts(k))\n  do i=1,n\n     y(i) = ys(i,k)*(1.0d0 - ff) + ys(i,k+1)*ff\n  enddo\n\nend subroutine linip_arr\n"}, {"instruction": "Create a Fortran subroutine named heap_peek to access the k-th node of the heap. This subroutine takes 5 input parameters of type integer (kind=4) and one output parameter of type integer (kind=4), dimension(0:1). The input parameters are 'entr', 'cap', 'heap_length', 'heap', and 'indx', and the output parameter is 'node'.", "input": "", "output": "subroutine heap_peek( heap, indx,cap,heap_length,entr,node)\n  ! access the k-th node of the heap\n\n  integer (kind=4), intent(in) :: entr, cap\n  integer (kind=4), intent(in) :: heap_length\n  integer (kind=4), intent(in), dimension(0:1,0:cap-1) :: heap\n  integer (kind=4), intent(in), dimension(0:cap-1) :: indx\n  integer (kind=4), intent(out), dimension(0:1) :: node\n  if (entr < 0 .or. entr >= heap_length .or. heap_length > cap) then\n      write(*,*) \"error in peek\"\n      return\n  endif\n  node = heap(:,indx(entr))\nend subroutine heap_peek\n"}, {"instruction": "Create a Fortran subroutine named evaluate_dudt_vort to calculate the vorticity term of the given grid data. The subroutine takes 9 input parameters of type double precision and integer: dudt_vort, v, zeta, fu, xlow, xhigh, ylow, yhigh, layers, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine evaluate_dudt_vort(dudt_vort, v, zeta, fu, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dudt_vort(i, j) is evaluated at the centre of the left edge of the grid\n    ! box, the same place as u(i, j).\n    double precision, intent(out) :: dudt_vort(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: v(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: zeta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: fu(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dudt_vort = 0d0\n\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dudt_vort(i,j,k) = 0.25d0*(fu(i,j)+0.5d0*(zeta(i,j,k)+zeta(i,j+1,k))) &\n                *(v(i-1,j,k)+v(i,j,k)+v(i-1,j+1,k)+v(i,j+1,k)) ! vorticity term\n        end do\n      end do\n    end do\n\n    return\n  end subroutine evaluate_dudt_vort\n"}, {"instruction": "Write a Fortran subroutine named evaluate_dudt_bp to calculate the discrete derivative of a given variable and store the result in an output array. The input parameters include two 3D arrays of double precision type, and six integer variables, representing the boundaries and layers of the grid. The output is a 3D array of double precision type.", "input": "", "output": "  subroutine evaluate_dudt_bp(dudt_bp, b, dx, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dudt_bp(i, j) is evaluated at the centre of the left edge of the grid\n    ! box, the same place as u(i, j).\n    double precision, intent(out) :: dudt_bp(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: b(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: dx\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dudt_bp = 0d0\n\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dudt_bp(i,j,k) = - (b(i,j,k) - b(i-1,j,k))/dx ! bernoulli potential term\n        end do\n      end do\n    end do\n\n    return\n  end subroutine evaluate_dudt_bp\n"}, {"instruction": "Write a Fortran subroutine named evaluate_dvdt_vort to compute the vorticity tendency at the center of the bottom edge of a grid box. The subroutine takes 9 input parameters of type double precision and integer, and provides 1 output parameter of type double precision. The input parameters are u, zeta, fv, xlow, xhigh, ylow, yhigh, layers, and ol.", "input": "", "output": "  subroutine evaluate_dvdt_vort(dvdt_vort, u, zeta, fv, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dvdt_vort(i, j) is evaluated at the centre of the bottom edge of the\n    ! grid box, the same place as v(i, j)\n    double precision, intent(out) :: dvdt_vort(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: u(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: zeta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: fv(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dvdt_vort = 0d0\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dvdt_vort(i,j,k) = &\n              - 0.25d0*(fv(i,j)+0.5d0*(zeta(i,j,k)+zeta(i+1,j,k))) &\n                *(u(i,j-1,k)+u(i,j,k)+u(i+1,j-1,k)+u(i+1,j,k)) !vorticity term\n        end do\n      end do\n    end do\n\n\n    return\n  end subroutine evaluate_dvdt_vort\n"}, {"instruction": "Create a Fortran subroutine named array_sqrt to calculate the square root of each element in an input array and store the results in an output array. The subroutine takes 2 input parameters: an integer n and a real array of dimension n. It has 1 output parameter, a real array of dimension n.", "input": "", "output": "subroutine array_sqrt(n, a_in, a_out)\n\n  implicit none\n  integer, intent(in) :: n\n  real, dimension(n), intent(in)  :: a_in\n  real, dimension(n), intent(out) :: a_out\n\n  integer :: i\n\n  do i = 1, n\n     a_out(i) = sqrt(a_in(i))\n  end do\n\n  return\n\nend subroutine array_sqrt\n"}, {"instruction": "Create a Fortran subroutine named dinterp2dxy to perform bilinear interpolation of a three-dimensional array onto a two-dimensional array. The subroutine takes 6 input parameters of types integer, integer, integer, integer, real(kind=8) array with dimensions (nx,ny,nz), and real(kind=8) array with dimensions (2,nxy). It also has 1 output parameter of type real(kind=8) array with dimensions (nxy,nz). The subroutine uses parallel processing for the interpolation computation.", "input": "", "output": "subroutine dinterp2dxy(v3d, v2d, xy, nx, ny, nz, nxy)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: v2d\n\n    integer, intent(in) :: nx, ny, nz, nxy\n    real(kind=8), dimension(nx,ny,nz), intent(in) :: v3d\n    real(kind=8), dimension(nxy,nz), intent(out) :: v2d\n    real(kind=8), dimension(2,nxy), intent(in) :: xy\n\n! nclend\n\n    integer :: i, j, k, ij\n    real(kind=8) :: w11, w12, w21, w22, wx, wy\n\n    !$omp parallel do private(i,j,k,ij,w11,w12,w21,w22,wx,wy) &\n    !$omp schedule(runtime)\n    do ij = 1,nxy\n        i = max(1,min(nx-1,int(xy(1,ij)+1)))\n        j = max(1,min(ny-1,int(xy(2,ij)+1)))\n        wx = dble(i+1) - (xy(1,ij)+1)\n        wy = dble(j+1) - (xy(2,ij)+1)\n        w11 = wx*wy\n        w21 = (1.d0-wx)*wy\n        w12 = wx*(1.d0-wy)\n        w22 = (1.d0-wx)* (1.d0-wy)\n        do k = 1,nz\n            v2d(ij,k) = w11*v3d(i,j,k) + w21*v3d(i+1,j,k) + &\n            w12*v3d(i,j+1,k) + w22*v3d(i+1,j+1,k)\n        end do\n    end do\n    !$omp end parallel do\n\n    return\n\nend subroutine dinterp2dxy\n"}, {"instruction": "Create a Fortran subroutine named dinterp1d that performs one-dimensional interpolation. It takes 6 input parameters of types: integer, integer, real(kind=8) array of size nz_in, real(kind=8) array of size nz_in, real(kind=8) array of size nz_out, and real(kind=8). It returns 1 output parameter of type real(kind=8) array of size nz_out.", "input": "", "output": "subroutine dinterp1d(v_in, v_out, z_in, z_out, vmsg, nz_in, nz_out)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: v_out\n\n    integer, intent(in) :: nz_in, nz_out\n    real(kind=8), dimension(nz_in), intent(in) :: v_in, z_in\n    real(kind=8), dimension(nz_out), intent(in) :: z_out\n    real(kind=8), dimension(nz_out), intent(out) :: v_out\n    real(kind=8), intent(in) :: vmsg\n\n! nclend\n\n    integer :: kp,k,im,ip\n    logical :: interp\n    real(kind=8) :: height,w1,w2\n\n    ! does vertical coordinate increase of decrease with increasing k?\n    ! set offset appropriately\n\n    ip = 0\n    im = 1\n    if (z_in(1) .gt. z_in(nz_in)) then\n        ip = 1\n        im = 0\n    end if\n\n    !$omp parallel do private(kp, k, interp, height, w1, w2) &\n    !$omp firstprivate(ip, im) schedule(runtime)\n    do k = 1,nz_out\n        v_out(k) = vmsg\n\n        interp = .false.\n        kp = nz_in\n        height = z_out(k)\n\n        do while ((.not. interp) .and. (kp .ge. 2))\n            if (((z_in(kp-im) .le. height) .and. (z_in(kp-ip) .gt. height))) then\n                w2 = (height - z_in(kp-im))/(z_in(kp-ip) - z_in(kp-im))\n                w1 = 1.d0 - w2\n                v_out(k) = w1*v_in(kp-im) + w2*v_in(kp-ip)\n                interp = .true.\n            end if\n            kp = kp - 1\n        end do\n    end do\n    !$omp end parallel do\n\n    return\n\nend subroutine dinterp1d\n"}, {"instruction": "Create a Fortran subroutine named determinant that calculates the determinant of a 3x3 matrix. The subroutine takes 1 input parameter of type real(16), dimension(3, 3) and outputs 1 parameter of type real(16).", "input": "", "output": "subroutine determinant(face, deter_value)\n    real(16), dimension(3, 3), intent(in) :: face\n    real(16), intent(out) :: deter_value\n    deter_value=(face(1,1)*face(2,2)*face(3,3)+face(1,2)*face(2,3)*face(3,1)&\n            +face(1,3)*face(2,1)*face(3,2)&\n            -face(3,1)*face(2,2)*face(1,3)-face(2,1)*face(1,2)*face(3,3)&\n            -face(1,1)*face(3,2)*face(2,3))\n    return\nend subroutine determinant\n"}, {"instruction": "Create a Fortran subroutine named ricker_t that generates a Ricker wavelet in the time domain. The subroutine takes two input parameters of type real, f0 and dt, and one output parameter of type real, s.", "input": "", "output": "subroutine ricker_t(s, f0, dt)  ! ricker in time domain, peak freq f0 hz\n! fill the time trace s w/ ricker wavelet from time 0+\nreal, intent(out) :: s(:)\nreal, intent(in)  :: f0, dt\ninteger :: np, i, l\nreal, allocatable :: t(:), env(:)\nreal  ::  sm_ric,  sm_env\nnp = min(ceiling(1.23456789/(f0*dt)),  (size(s)-1)/2)\nl  = 2*np+1 \nallocate(t(l), env(l))\nt  = (/ (i, i=-np, np) /)\nt  = (t * (pi *f0 *dt) )**2\nenv     = exp(-t)   ! envelope\nsm_env  = sum(env)\ns(1:l)  = (1. - 2.*t)*env\nsm_ric  = sum(s(1:l))\ns(1:l)  = s(1:l) - sm_ric/sm_env * env ! 0-mean\ns(l+1:) = 0.\n#ifdef debug\n  write(*,*) 'lengths of source & ricker:', size(s), l\n#endif\ndeallocate(t, env)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_binfile_b2 to read binary data from a file. The subroutine takes 2 input parameters: filename of type character(len=*), and recn of type integer, which is optional. It has 1 output parameter, data, of type integer(1) array. The subroutine uses direct access to open, read, and close the file, and handles the case when the optional recn is not present. If an error occurs during reading, it stops and outputs a specific error message.", "input": "", "output": "subroutine read_binfile_b2(filename, data, recn)\ncharacter(len=*), intent(in) :: filename\ninteger(1), intent(out) :: data(:,:)\ninteger, intent(in), optional :: recn\ninteger  :: n\nn = 1\nif(present(recn))  n = recn\nif (n<=0)    n = 1\nopen(10, file=filename, access='direct', err=20, recl=size(data))\nread(10, rec=1) data\nclose(10)\nreturn\n20 stop '  read error read_binfile_b2'\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_binfile_i3 to read integer data from a binary file. The subroutine takes 1 input parameter of type character(len=*) for the filename and 1 output parameter of type integer array. Use the \"intent\" attribute to specify the input and output parameters. Inside the subroutine, open the file using direct access mode, read the data into the integer array, and then close the file. If there is a read error, stop the program with an error message.", "input": "", "output": "subroutine read_binfile_i3(filename, data)\ncharacter(len=*), intent(in) :: filename\ninteger, intent(out) :: data(:,:,:)\nopen(10, file=filename, access='direct', err=20, recl=i4*size(data))\nread(10, rec=1) data\nclose(10)\nreturn\n20 stop '  read error read_binfile_i3'\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_tex_i1 to read integer data from a formatted file and store it in an allocatable integer array. The subroutine takes 2 input parameters: a character array with unspecified length (fname) and an optional integer (n). It returns 1 output parameter, an allocatable integer array (a). If the optional parameter n is provided, the subroutine reads n rows from the file; otherwise, it determines the number of rows in the file.", "input": "", "output": "subroutine read_tex_i1(a, fname, n)\n integer,  allocatable,intent(out) :: a(:)\n character(len=*),     intent(in)  :: fname\n integer,  optional,   intent(in)  :: n\n integer               :: i, nr\n \n open(10, file=fname, form='formatted')\n ! determine # rows\n if (present(n)) then\n   nr = n\n else\n\t nr = 0\n\t do \n\t  read(10,*,end=99) i\n\t  nr = nr + 1\n\t end do\n\t 99  continue\n\t rewind(10)\n end if\n \n if (allocated(a)) then\n   i = size(a)\n   if (i /= nr) then\n     deallocate(a)\n\t allocate(a(nr))\n   end if\n else\n   allocate(a(nr))\n end if\n \n ! read in to a\n do i = 1, nr\n   read(10,*) a(i)\n end do\n close(10)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_fs_pendula to calculate the force on a pendulum. The subroutine takes 8 input parameters of types integer, integer, integer, real array, real, real array, real array, and real array. It also has 1 output parameter of type real array.", "input": "", "output": "    subroutine calc_fs_pendula(bc_flag, lowerbound, upperbound, u, g, m, k, l, fs)\n\n    implicit none\n\n    !! data dictionary\n    integer, intent(in) :: bc_flag\n    integer, intent(in) :: lowerbound\n    integer, intent(in) :: upperbound\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in) :: g\n    real, intent(in), dimension(2) :: m\n    real, intent(in), dimension(1) :: k\n    real, intent(in), dimension(1) :: l\n    real, intent(out), dimension(1) :: fs\n\n    if (bc_flag == 100) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) - k(1)*u(-1) + 2*k(1)*u(0) - k(1)*u(1)) \n    else if (bc_flag == 110) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) + k(1)*(u(0) - u(1)))\n    else if (bc_flag == 120) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) - k(1)*u(-1) + k(1)*u(0))\n    else if (bc_flag == 121) then\n        fs(1) = 0.\n    end if\n\n    end subroutine calc_fs_pendula\n"}, {"instruction": "Create a Fortran subroutine named calc_fs_phi4 to compute the value of fs based on different boundary conditions. The subroutine should have 5 input parameters of types integer, integer, integer, real array, and real array, and 1 output parameter of type real array.", "input": "", "output": "    subroutine calc_fs_phi4(bc_flag, lowerbound, upperbound, u, k, fs)\n\n    implicit none\n\n    ! data dictionary:\n    integer, intent(in) :: bc_flag ! boundary condition\n    integer, intent(in) :: lowerbound !\n    integer, intent(in) :: upperbound !\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in), dimension(5) :: k !\n    real, intent(out), dimension(1) :: fs !\n\n    ! calculation for fs\n    if (bc_flag == 100) then ! baseline, periodic\n        fs(1) = k(2) - k(1)*u(-1) + (2*k(1) + 2*k(3))*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3 - k(1)*u(1)\n    else if (bc_flag == 110) then ! baseline, left end free\n        fs(1) = k(2) + k(1)*u(0) + 2*k(3)*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3 - k(1)*u(1) \n    else if (bc_flag == 120) then ! baseline, right end free\n        fs(1) = k(2) - k(1)*u(-1) + (k(1) + 2*k(3))*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3\n    end if\n\n    end subroutine calc_fs_phi4\n"}, {"instruction": "Create a Fortran subroutine named calc_kthat_phi4 to calculate the kthat values for a specific physics problem. The subroutine takes 6 input parameters of types integer, integer, integer, real array, real array, and real scalar, and 1 output parameter of type real array. This subroutine computes the kthat values based on the provided boundary conditions, input parameters, and calculations using the given physics model.", "input": "", "output": "    subroutine calc_kthat_phi4(bc_flag, lowerbound, upperbound, u, k, a, kthat)\n\n    implicit none\n\n    ! data dictionary:\n    integer, intent(in) :: bc_flag ! boundary condition\n    integer, intent(in) :: lowerbound !\n    integer, intent(in) :: upperbound !\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in), dimension(5) :: k !\n    real, intent(in), dimension(1) :: a\n    real, intent(out), dimension(3) :: kthat !\n\n    kthat = 0.\n    if (bc_flag == 100) then ! baseline, periodic\n        kthat(1) = -k(1)\n        kthat(2) = 2*k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = -k(1)\n    else if (bc_flag == 110) then ! baseline, left end free\n        kthat(1) = 0.\n        kthat(2) = k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = -k(1)\n    else if (bc_flag == 120) then ! baseline, right end free\n        kthat(1) = -k(1)\n        kthat(2) = k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = 0.\n    end if\n\n    kthat(2) = kthat(2) + a(1)\n\n    end subroutine calc_kthat_phi4\n"}, {"instruction": "Write a Fortran subroutine named get_opacities that computes the opacities kp and kr based on the input parameters. The subroutine takes 6 input parameters of types logical, logical, double precision, double precision, double precision, and double precision. It also has 2 output parameters of type double precision. The subroutine calculates the opacities based on the values of get_planck_mean and get_rosseland_mean flags and the input values of rho, temp, rhoye, and nu.", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: ksc = 0.4d0 ! thomson scattering \n    double precision, parameter :: fac = 1.d-4 ! planck mean is assumed to be fac*ksc\n\n    if (get_planck_mean) then\n       kp = rhoye*ksc * fac\n    end if\n\n    if (get_rosseland_mean) then\n       kr = rhoye*ksc\n    end if\n\n  end subroutine get_opacities\n"}, {"instruction": "Create a Fortran subroutine named \"lennardjones\" to calculate the Lennard-Jones potential between two particles. The subroutine should take 1 input parameter of type real and provide 1 output parameter of type real. The input parameter represents the distance between the particles, and the output parameter represents the computed potential energy.", "input": "", "output": "  subroutine lennardjones(r,pot)\n\n    !---- compute lj potential:\n    ! \n    !                   r(eq)^p     p   r(eq)^q\n    !     pot = epl ( ---------- - --- ---------- )\n    !                  r(m,n)^p     q   r(m,n)^q\n    !     where\n    !          epl    : strength of lj potential\n    !          r_eq   : equilibrium center-to-center distance\n    !          r(m,n) : center distance between m and n\n    !          r_cof  : cut-off center-to-center distance\n\n    integer p,q\n    real epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    real, intent(in) :: r\n    real, intent(out) :: pot\n\n\n    p = 18\n    q = 6\n    epl = 3.\n    pq = p*1./(q*1.)\n\n    radius = lz/6.\n    r_eq = 2.*radius + 3.5*dz\n    r_mn = 2.*radius + r\n    r_cof = 2.*radius + 6.*dz\n\n    pot_cof = epl*( r_eq**p/r_cof**p - pq* r_eq**q/r_cof**q) !potential at cut-off\n    pot = epl*( r_eq**p/r_mn**p - pq* r_eq**q/r_mn**q) - pot_cof !make potential zero at cut-off\n    if (r_mn .gt. r_cof) pot = 0. !make potential zero after cut-off\n\n\n    return\n  end subroutine lennardjones\n"}, {"instruction": "Write a Fortran subroutine named version_parse to extract the major, minor, and patch numbers from a version string with the format \"i.j.k\". The subroutine should have 1 input parameter with the test_data type ['character(*)'], and 4 output parameters with the test_data type ['integer', 'integer', 'integer', 'integer'].", "input": "", "output": "  subroutine version_parse(str, major, minor, patch, ierr)\n    !--------------------------------------------------------------------------\n    !   \n    ! determine the major, minor and patch numbers from \n    ! a version string with the fmt \"i.j.k\"\n    ! \n    ! the ierr variable assumes the following values\n    !\n    ! ierr < 0     emtpy string\n    ! ierr = 0     no problem\n    ! ierr > 0     fatal error\n    !   \n    implicit none\n    character(*),     intent(in)    :: str \n    integer,          intent(out)   :: major, minor, patch, ierr\n    !\n    integer       :: i1, i2, length\n    integer       :: ierrtot\n    character(10) :: num(3)\n\n    !\n    major = 0\n    minor = 0\n    patch = 0\n\n    length = len_trim( str )\n    !\n    if ( length == 0 ) then\n       !\n       ierr = -1\n       return\n       !\n    endif\n\n    i1 = scan( str, \".\")\n    i2 = scan( str, \".\", back=.true.)\n    !\n    if ( i1 == 0 .or. i2 == 0 .or. i1 == i2 ) then\n       !\n       ierr = 1\n       return\n       !\n    endif\n    !\n    num(1) = str(    1 : i1-1 )\n    num(2) = str( i1+1 : i2-1 )\n    num(3) = str( i2+1 : )\n    !\n    ierrtot = 0\n    !\n    read( num(1), *, iostat=ierr ) major\n    if (ierr/=0) return\n    !\n    read( num(2), *, iostat=ierr ) minor\n    if (ierr/=0) return\n    !\n    read( num(3), *, iostat=ierr ) patch\n    if (ierr/=0) return\n    !\n  end subroutine version_parse\n"}, {"instruction": "Create a Fortran subroutine named print_occurences to calculate the occurrences of each integer in a 2D array of nuclear charges. The subroutine takes 1 input parameter of type integer, dimension(:,:) and produces 1 output parameter of type integer, dimension(120).", "input": "", "output": "subroutine print_occurences(nuclear_charges, occurences)\n\n    implicit none\n\n\n    integer, dimension(:,:), intent(in) :: nuclear_charges\n\n\n    integer, dimension(120), intent(out) :: occurences\n    integer, dimension(120) :: occurences_local\n\n    integer :: a, i\n\n    integer :: nm\n    integer :: na\n\n    integer :: q\n\n    occurences(:) = 0\n\n    na = size(nuclear_charges, dim=1)\n    nm = size(nuclear_charges, dim=2)\n\n    ! write (*,*) nm\n\n    do a = 1, nm\n\n        occurences_local = 0\n        do i = 1, na\n\n            q = nuclear_charges(i,a)\n\n            if (q < 1) then\n                exit\n            endif\n\n            occurences_local(q) = occurences_local(q) + 1\n\n        enddo\n        do i = 1, size(occurences)\n            occurences(i) = max(occurences(i), occurences_local(i))\n        enddo\n\n    enddo\n\n    ! do i = 1, size(occurences) \n\n    !     if (occurences(i) > 0) write (*,*) i, occurences(i)\n\n    ! enddo\n\n\n\nend subroutine print_occurences \n"}, {"instruction": "Create a Fortran subroutine named weight. It takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The subroutine computes the value of the standard normal probability density function at the input value x and assigns the result to the output parameter p.", "input": "", "output": "subroutine weight(x,p)\n    implicit none\n    real(8), parameter :: pi = acos(-1.d0)\n    real(8), intent(in) :: x\n    real(8), intent(out) :: p\n\n    p = exp(-x**2 / 2.d0) / sqrt(2.d0 * pi)\nend subroutine weight\n"}, {"instruction": "Create a Fortran subroutine named convertnmltojson that takes a character string filename as input and produces a dynamic character string output as output. The subroutine reads the namelist file specified by the filename and generates a JSON representation in the output string.", "input": "", "output": "  subroutine convertnmltojson(filename, output)\n    !> the name of the namelist file to read in.\n    character(len=*), intent(in) :: filename\n    !> the string representation of the json.\n    character(len=:), allocatable, intent(out) :: output\n\n    allocate(character(len=12) :: output)\n    output = '{\"value\": 3.0}'\n  end subroutine convertnmltojson\n"}, {"instruction": "Create a Fortran subroutine named bessj to calculate the regular Bessel functions of the first kind and their derivatives. The subroutine should take 2 input parameters of type real(8) and integer, and return 2 output parameters of type real(8). The subroutine uses Steed's method to compute the Bessel functions and their derivatives for positive x and for 1 \u2264 l \u2264 nl+1.", "input": "", "output": "subroutine bessj(x,nl,rj,rjp)\n  !returns the regular bessel functions of first kind\n  !$\\texttt{rj(l)}=j_{l-\\frac{1}{2}}$ and their derivatives\n  !$\\texttt{rjp(l)}=j'_{l-\\frac{1}{2}}$, for positive \\texttt{x} and for\n  !$1\\le l \\le nl+1$, using steed's method.\n  implicit none\n  real(8), intent(in) :: x\n  integer, intent(in) :: nl\n  real(8), intent(out) :: rj(*)            \n  real(8), intent(out) :: rjp(*)            \n  !    \n  integer :: i, isign, l \n  real(8) :: xnu, b, c, d, del, f, fact, gam, h, p, q, rjl, rjl1, rjmu, rjp1, rjpl, rjtemp, w, xi, xi2, xmu, xmu2\n  integer, parameter :: maxit=10000\n  real(8), parameter :: eps=1.e-16\n  real(8), parameter :: fpmin=1.e-30\n  real(8), parameter :: pi=3.141592653589793d+0\n\n  if(x.le.0..or.nl.lt.0) stop 'bad arguments in bessj'\n  xnu=dble(nl)+0.5d0\n  xmu=0.5d0\n  xmu2=xmu*xmu\n  xi=1.d0/x\n  xi2=2.d0*xi\n  !     the wronskian\n  w=xi2/pi\n  !     evaluate the continued fraction expansion for j'_(nl-1/2)/j_(nl-1/2)\n  !     by the modified lentz's method. isign keeps track of sign changes in\n  !     the denominator\n  isign=1\n  h=xnu*xi\n  if(h.lt.fpmin)h=fpmin\n  b=xi2*xnu\n  d=0.d0\n  c=h\n  do i=1,maxit\n     b=b+xi2\n     d=b-d\n     if(abs(d).lt.fpmin) d=fpmin\n     c=b-1.d0/c\n     if(abs(c).lt.fpmin) c=fpmin\n     d=1.d0/d\n     del=c*d\n     h=del*h\n     if(d.lt.0.d0) isign=-isign\n     if(abs(del-1.d0).lt.eps) goto 1\n  enddo\n!11   continue\n  stop 'x too large in bessjy; try asymptotic expansion'\n1 continue\n  !     initialize j and j' for downward recurrence\n  rjl=isign*fpmin\n  rjpl=h*rjl\n  !     store values for later rescaling      \n  rjl1=rjl\n  rjp1=rjpl\n  !     downward recurrence (unnormalized)\n  fact=xnu*xi\n  do l=nl,0,-1\n     rjtemp=fact*rjl+rjpl\n     fact=fact-xi\n     rjpl=fact*rjtemp-rjl\n     rjl=rjtemp\n  enddo\n  if(rjl.eq.0.d0)rjl=eps\n  f=rjpl/rjl\n  !     equation 6.7.3 numerical recipies in fortran\n  p=-.5d0*xi\n  q=1.d0\n  !     equation 6.7.6 numerical recipies in fortran\n  gam=(p-f)/q\n  !     equation 6.7.7 numerical recipies in fortran\n  rjmu=sqrt(w/((p-f)*gam+q))\n  rjmu=sign(rjmu,rjl)\n  !     scale original j and j'\n  fact=rjmu/rjl\n  rj(nl+1)=rjl1*fact\n  rjp(nl+1)=rjp1*fact\n  fact=xnu*xi\n  !     downward recurence\n  do l=nl,1,-1\n     rj(l)=fact*rj(l+1)+rjp(l+1)\n     fact=fact-xi\n     rjp(l)=fact*rj(l)-rj(l+1)\n  enddo ! l\nend subroutine bessj\n"}, {"instruction": "Create a Fortran subroutine named get_bottom_data to extract data from the lowest model level. The subroutine takes 3 input parameters of type real, dimension(:,:,:) named a and b, and an optional input parameter of type integer, dimension(:,:). It returns 2 output parameters of type real, dimension(:,:) named a_bot and b_bot. If the optional parameter k_bot is provided, it is used to determine the lowest model level; otherwise, the default lowest level is used.", "input": "", "output": " subroutine get_bottom_data ( a, b, a_bot, b_bot, k_bot ) \n\n!-------- extract data from the lowest model level ---------\n! a, b     = 3-d data fields\n! a_bot,\n!    b_bot = 2-d data fields containing data at lowest level\n! k_bot    = index of lowest model level (optional)\n!-----------------------------------------------------------\n\n  real   , intent(in) , dimension(:,:,:) :: a    , b\n  real   , intent(out), dimension(:,:)   :: a_bot, b_bot\n  integer, intent(in) , dimension(:,:), optional :: k_bot\n\n! returns the lowest level data (a_bot,b_bot) from 3d fields (a,b)\n\n  integer :: i, j, kb, kb_min\n    \n                      kb_min = size(a,3)\n  if (present(k_bot)) kb_min = minval (k_bot) \n\n  if ( kb_min == size(a,3) ) then\n          a_bot = a(:,:,kb_min)\n          b_bot = b(:,:,kb_min)\n  else\n       do j = 1, size(a,2)\n       do i = 1, size(a,1)\n          kb = k_bot(i,j)\n          a_bot(i,j) = a(i,j,kb)\n          b_bot(i,j) = b(i,j,kb)\n       enddo   \n       enddo   \n  endif\n\n end subroutine get_bottom_data\n"}, {"instruction": "Create a Fortran subroutine named create_output_filename that takes a character input parameter l2bname and returns a character output parameter ofname. The subroutine replaces the long extension in the l2b filename with 'obs_seq_out'.", "input": "", "output": "subroutine create_output_filename(l2bname, ofname)\n!-------------------------------------------------\n! the l2b filenames have a very long extension that\n! records when the data was published - not very interesting\n! for our purposes. replace with something dart-y.\ncharacter(len=*), intent(in)  :: l2bname\ncharacter(len=*), intent(out) :: ofname\n\ninteger :: i, strlen, extstart\n\nstrlen = len_trim(l2bname)\n\ndotloop : do i = strlen,1,-1\n   if (l2bname(i:i) == '.' ) then\n      extstart = i\n      exit dotloop\n   endif\nenddo dotloop\n\nofname = l2bname(1:extstart)//'obs_seq_out'\n\nend subroutine create_output_filename\n"}, {"instruction": "Write a Fortran subroutine named toy_vals to perform calculations related to toy values. The subroutine takes 3 input parameters of type real(kind=8), real(kind=8) array, and real(kind=8) array, and returns 2 output parameters of type real(kind=8) array and real(kind=8) array, all of size equal to the size of the array r.", "input": "", "output": "    subroutine toy_vals(a,mu,r,n,l)\n      real(kind=8), intent(in) :: a\n      real(kind=8), dimension(:), intent(in) :: r,mu\n      real(kind=8), dimension(size(r)), intent(out) :: n,l\n      real(kind=8), dimension(size(r)) :: rcyl,z,dist\n      real(kind=8) :: q\n      q=0.5\n      rcyl = r*sqrt(1.-mu**2.)\n      l=toy_l0/(1.+rcyl)*rcyl**(1.+q)\n      z=toy_h*mu\n!      l=0.; z=0.\n      dist=((r/10.)**2.+z**2.)\n      where(dist.lt.20.)\n         n=toy_n0*exp(-dist/2.)\n      elsewhere\n         n=0.\n      endwhere\n!      toy_omega = 1./(toy_r**(3./2.)+toy_a)\n     end subroutine toy_vals\n"}, {"instruction": "Create a Fortran subroutine named \"enexpr\" with 1 input parameter of type \"character (len = 6)\" to represent a term, and 1 output parameter of type \"logical\" to indicate if the operation is done.", "input": "", "output": "        subroutine enexpr (term, done)\n        integer nod, nwfd\n        parameter (nod = 220)\n        parameter (nwfd = 20)\n        character (len = 6), intent(in) :: term\n        logical, intent(out) :: done\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named search to assign a value to the output parameter nj of type integer. The subroutine takes one input parameter i of type integer.", "input": "", "output": "        subroutine search (nj, i)\n        integer nodi, nwfd\n        parameter (nod = 220)\n        parameter (nwfd = 20)\n        integer, intent(out) :: nj\n        integer, intent(in) :: i\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_particle_header to read the header information from a particle file. The subroutine takes 1 input parameter of type character(len=*) for the filename, and has 3 output parameters of type integer for nparts, ndim, and tmp_unit. Inside the subroutine, open the file specified by the filename, read the number of dimensions (ndim), the number of particles (nparts), and assign a new unit number to tmp_unit for reading the file.", "input": "", "output": "  subroutine read_particle_header (filename, ndim, nparts, tmp_unit)\n    character(len=*), intent(in) :: filename\n    integer, intent(out)         :: nparts, ndim, tmp_unit\n    open(newunit = tmp_unit, file=filename, status='old', form='unformatted')\n    read(tmp_unit) !ncpu\n    read(tmp_unit) ndim\n    read(tmp_unit) nparts\n  end subroutine read_particle_header\n"}, {"instruction": "Create a Fortran subroutine named read_particle_data to read particle data from a file and store it in the specified variables. The subroutine has 3 input parameters of type integer, and 6 output parameters consisting of arrays of various dimensions and data types. The input parameters are ndim, nparts, and tmp_unit, all of type integer. The output parameters are pos, vel, nstar, ids, m, and birth_date, with their respective data types and dimensions specified.", "input": "", "output": "  subroutine read_particle_data (ndim, nparts, tmp_unit, nstar, pos, vel, m, ids, birth_date)\n    integer, intent(in)                          :: ndim, nparts, tmp_unit\n    real(kind=8), dimension(ndim, nparts), intent(out) :: pos, vel\n    integer, intent(out)                         :: nstar\n    integer,      dimension(nparts), intent(out) :: ids\n    real(kind=8), dimension(nparts), intent(out) :: m\n    real(kind=4), dimension(nparts), intent(out) :: birth_date\n\n    real(kind=8), dimension(nparts) :: tmp\n\n    read(tmp_unit) ! ?\n    read(tmp_unit) nstar\n    read(tmp_unit) ! ?\n    read(tmp_unit) ! ?\n    read(tmp_unit) ! ?\n\n    read(tmp_unit) tmp\n    pos(1,:) = tmp\n    read(tmp_unit) tmp\n    pos(2,:) = tmp\n    read(tmp_unit) tmp\n    pos(3,:) = tmp\n    read(tmp_unit) tmp\n    vel(1,:) = tmp\n    read(tmp_unit) tmp\n    vel(2,:) = tmp\n    read(tmp_unit) tmp\n    vel(3,:) = tmp\n\n    read(tmp_unit) m\n\n    read(tmp_unit) ids\n\n    read(tmp_unit) birth_date\n    close(tmp_unit)\n  end subroutine read_particle_data\n"}, {"instruction": "Write a Fortran subroutine named read_list_header to read the header information from a file. The subroutine takes 1 input parameter of type character(len=*) and returns 3 output parameters of type integer.", "input": "", "output": "  subroutine read_list_header(filename, unit, lines, columns)\n    character(len=*), intent(in) :: filename\n    integer, intent(out)         :: unit, lines, columns\n\n    open(newunit=unit, file=filename, form='unformatted')\n    read(unit) lines, columns\n\n  end subroutine read_list_header\n"}, {"instruction": "Create a Fortran subroutine named \"rectangles\" that generates an array of real numbers representing the midpoints of rectangles. The subroutine should take 2 input arguments of type real * 8 and 1 output argument of type real * 8, dimension(:).", "input": "", "output": "  subroutine rectangles(x,x_min,dr)\n\t\timplicit none\n\t  real * 8, intent(out), dimension(:) :: x\n    real * 8, intent(in) :: dr,x_min\n    integer :: i1\n\t  do i1=1, size(x)\n      x(i1) = x_min + i1 * dr\n    end do\n\t  return\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"fmacat\" to perform matrix operations. The subroutine takes 1 input parameter of type real(iwp) and produces 1 output parameter of type real(iwp). The subroutine calculates the result by performing matrix multiplication and subtraction.", "input": "", "output": "subroutine fmacat(vmfl,acat)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::vmfl(:)\r\n real(iwp),intent(out)::acat(:,:)\r\n real(iwp)::temp(4,4),zero=0.0_iwp,pt5=0.5_iwp,one=1.0_iwp,three=3.0_iwp\r\n integer::i,j\r\n temp=zero\r\n temp(1,1)=one\r\n temp(1,2)=-pt5\r\n temp(1,4)=-pt5\r\n temp(2,1)=-pt5\r\n temp(2,2)=one\r\n temp(2,4)=-pt5\r\n temp(3,3)=three\r\n temp(4,1)=-pt5\r\n temp(4,2)=-pt5\r\n temp(4,4)=one\r\n do i=1,4\r\n   do j=1,4\r\n     acat(i,j)=vmfl(i)*vmfl(j)\r\n   end do\r\n end do\r\n acat=temp-acat\r\nreturn \r\nend subroutine fmacat\r\n"}, {"instruction": "Create a Fortran subroutine named autgetarg to retrieve a command-line argument based on the specified index. The subroutine takes 1 input argument of type integer and returns 1 output argument of type character with varying length.", "input": "", "output": "  subroutine autgetarg(number,value)\n    integer, intent(in) :: number\n    character(len=*), intent(out) :: value\n    call getarg(number,value)\n  end subroutine autgetarg\n"}, {"instruction": "Create a Fortran subroutine named coeffs that takes 7 input parameters of type double precision and value. The input parameters are mbh, mdot, r, alpha, rho, t, and h. It returns 2 output parameters of type double precision, a(3,1) and m(3,3).", "input": "", "output": "subroutine coeffs(mbh,mdot,r,alpha,rho,t,h,a,m) bind(c)\nimplicit none\ndouble precision, intent(in), value :: mbh,mdot,r,alpha,rho,t,h\ndouble precision, intent(out) :: a(3,1), m(3,3)\na(1, 1) = 902184.7d0*h**3*alpha*rho*sqrt(1/(mbh**2*r**3)) - 1.975034d+18 &\n      *mbh*mdot*(-1.732051d0*sqrt(1.0/r) + 1.0d0)\na(2, 1) = 2.081514d+14*h**4*alpha*rho**2*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0) - 0.0002268204d0*t**4\na(3, 1) = -5.154318d+9*h**2*rho*(1/(mbh**2*r**3))**1.0d0 + 2.521972d-15* &\n      t**4 + 1.650222d+8*t*rho\nm(1, 1) = 902184.7d0*h**3*alpha*sqrt(1/(mbh**2*r**3))\nm(2, 1) = 1.275968d+37*h**4*t**(-3.5d0)*alpha*rho**2*(1/(mbh**2*r**3))** &\n      1.5d0 + 4.163028d+14*h**4*alpha*rho*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0)\nm(3, 1) = -5.154318d+9*h**2*(1/(mbh**2*r**3))**1.0d0 + 1.650222d+8*t\nm(1, 2) = 0\nm(2, 2) = -4.465888d+37*h**4*t**(-4.5d0)*alpha*rho**3*(1/(mbh**2*r**3)) &\n      **1.5d0 - 0.0009072817d0*t**3\nm(3, 2) = 1.008789d-14*t**3 + 1.650222d+8*rho\nm(1, 3) = 2706554.0d0*h**2*alpha*rho*sqrt(1/(mbh**2*r**3))\nm(2, 3) = 8.326056d+14*h**3*alpha*rho**2*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0)\nm(3, 3) = -1.030864d+10*h*rho*(1/(mbh**2*r**3))**1.0d0\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_data to read data from a file. The subroutine takes 2 input parameters of type character(*) and integer. The input parameters are file_name and how_many. The subroutine has 1 output parameter.", "input": "", "output": "    subroutine read_data(file_name, raw_data, how_many)\n        implicit none\n\n        character(*), intent(in) :: file_name\n        integer, intent(in) :: how_many\n        real, dimension(:), allocatable, &\n            intent(out) :: raw_data\n        integer :: i\n\n        allocate(raw_data(how_many))\n        open(1,file=file_name,status='old')\n        do i = 1, how_many\n            read(1,*) raw_data(i)\n        end do\n        close(1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named test_do_loop_variable_trip_count to calculate the sum of integers from 1 to a given number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine test_do_loop_variable_trip_count(ret, n)\n  integer, intent(out) :: ret\n  integer, intent(in) :: n\n  ret = 0\n  do i=1, n\n    ret = ret + i\n  end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_comment to read a file until it finds an uncommented line. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer, which is optional. The input parameter represents the file unit to be read. If present, the optional output parameter will store any error that occurs during reading. Any commented lines in the file, which are either blank or start with '#', will be skipped during the reading process.", "input": "", "output": "    subroutine read_comment(funit, ierr)\n      ! read file until it finds uncommented line\n      ! commented lines are blank (empty) lines or lines whose first non-blank character is '#'\n      integer, intent(in):: funit\n      integer, intent(out), optional:: ierr\n      character(len=1):: line\n\n      line = '#'\n\n      if (present(ierr)) then\n\n        ! read until finding uncommented line or error is raised\n        ierr = 0\n        do while (line=='#' .and. ierr==0)\n          read(unit=funit, fmt=*, iostat=ierr) line\n        end do\n\n        ! if no error raised, get back to the previous record (in that case, the previous line)\n        if (ierr==0) then\n          backspace(unit=funit)\n        end if\n\n      else\n\n        ! read until finding uncommented line\n        do while (line=='#')\n          read(unit=funit, fmt=*) line\n        end do\n\n        ! get back to the previous record (in that case, the previous line)\n        backspace(unit=funit)\n\n      end if\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sd_to_hms\" that takes two input parameters of type integer: \"sd_day\" and \"sd_sec\". It should have three output parameters of type integer: \"hms_hour\", \"hms_min\", and \"hms_sec\". The subroutine should calculate and convert the input values representing a duration in days and seconds to the equivalent duration in hours, minutes, and seconds.", "input": "", "output": " subroutine sd_to_hms(sd_day, sd_sec, hms_hour, hms_min, hms_sec)\n    integer, intent(in)  :: sd_day\n    integer, intent(in)  :: sd_sec\n    integer, intent(out) :: hms_hour\n    integer, intent(out) :: hms_min\n    integer, intent(out) :: hms_sec\n\n    integer :: residual_secs\n    \n    residual_secs = (sd_day * day_to_sec) + sd_sec\n\n    ! note integer division\n    hms_hour      = residual_secs / hr_to_sec\n    residual_secs = residual_secs - (hms_hour * hr_to_sec)\n    hms_min       = residual_secs / min_to_sec\n    residual_secs = residual_secs - (hms_min * min_to_sec)\n    hms_sec       = residual_secs\n  end subroutine sd_to_hms\n"}, {"instruction": "Create a Fortran subroutine named setwordpositions to find the positions of a specific character within a given string. The subroutine takes 2 input parameters of type character(len=*) and character, and 1 output parameter of type integer, dimension(:,:). The input parameters are ['bigstring', 'solo'], and the output parameter is ['positions'].", "input": "", "output": "subroutine setwordpositions( bigstring, solo, positions )\ncharacter(len=*),        intent(in)  :: bigstring\ncharacter,               intent(in)  :: solo\ninteger, dimension(:,:), intent(out) :: positions\n\ninteger :: nwords\ninteger :: i, iword\n\nnwords = size(positions,1)\n\niword = 1 \npositions(iword,1) = 1\n\n! first, simply count up the number of delimiters \ndo i = 1,len_trim(bigstring)\n   if (bigstring(i:i) == solo) then\n      positions(iword,2) = i-1\n      iword = iword + 1\n      positions(iword,1) = i+1\n   endif\nenddo\npositions(iword,2) = len_trim(bigstring)\n\nif ( 0 == 99 ) then  ! test. passes with gfortran compiler\n   write(*,*)'there are ',nwords,' in this line: '\n   write(*,*)'[',trim(bigstring),']'\n   do i = 1,nwords\n      write(*,*)'word ',i,' is [',bigstring(positions(i,1):positions(i,2)),']'\n   enddo\nendif\n\nend subroutine setwordpositions\n"}, {"instruction": "Write a Fortran subroutine named copy_vec to copy the elements of one real array to another real array. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone in the instructions.", "input": "", "output": "  subroutine copy_vec(to, from)\n    real, intent(out) :: to(:)\n    real, intent(in) :: from(size(to))\n\n    integer :: i\n    do i = 1, size(to)\n      to(i) = from(i)\n    end do\n  end subroutine copy_vec\n"}, {"instruction": "Create a Fortran subroutine named dboard to simulate dart throwing. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type double precision. The input parameter represents the number of darts thrown, and the output parameter holds the estimated value of \u03c0 based on the darts landing within a unit circle.", "input": "", "output": "subroutine dboard(darts, dartsscore)\n  integer, intent(in)                    :: darts\n  double precision, intent(out)          :: dartsscore\n  double precision                       :: x_coord, y_coord\n  integer                                :: score, n\n\nscore = 0\ndo n = 1, darts\n  call random_number(x_coord)\n  call random_number(y_coord)\n\n  if ((x_coord**2 + y_coord**2) <= 1.0d0) then\n  score = score + 1\n  end if\nend do\n\ndartsscore = 4.0d0*score/darts\n\nend subroutine dboard\n"}, {"instruction": "Create a Fortran subroutine named qc_tit to perform quality control on brightness temperatures. The subroutine takes 5 input parameters of type integer, integer, real, real, and real, and 1 output parameter of type real. The function calculates the difference between tbb15m and tbb and assigns the result to the output parameter tit.", "input": "", "output": "      subroutine qc_tit(nlongitude,nlatitude,tbb,tbb15m,tit,missing_r)\n   ! ------------qc: step 4 ----\n   ! 11.2(zhuge and zou, jamc, 2016) for ahi chan14\n   ! cirrus water vapor test for ahi using ch14, ch14min before\n   ! ch12, ch12 for agri\n   implicit none\n    integer, intent(in):: nlongitude,nlatitude\n   real, intent(in) :: tbb(nlongitude,nlatitude)\n   real, intent(in) :: tbb15m(nlongitude,nlatitude)\n   real, intent(in) :: missing_r\n   real, intent(out) :: tit(nlongitude,nlatitude)\n   integer :: nstar, nend\n   integer :: i, j, ij, m \n\n   tit=tbb15m-tbb\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"areacal\" to calculate the area of a polygon given the vertices' coordinates (xc, yc). Define 2 input parameters of type real(8) for xc and yc, and 1 output parameter of type real(8) for the area.", "input": "", "output": " subroutine areacal(xc,yc,area)   \n  !area calculation of a polygon\n  !with given vextices (xc,yc)\n  real(8),intent(in) ::xc(:),yc(:)\n  real(8),intent(out)::area\n  real(8)::xvec(2),yvec(2)\n  integer(4)::npol,k\n  npol = size(xc)\n  area = 0\n  xvec(1)=xc(2)-xc(1)\n  yvec(1)=yc(2)-yc(1)\n  do k=3,npol\n    xvec(2) = xc(k)-xc(1)\n    yvec(2) = yc(k)-yc(1)\n    area = area+0.5*abs( xvec(1)*yvec(2)-xvec(2)*yvec(1))\n    xvec(1)=xvec(2)\n    yvec(1)=yvec(2)\n  enddo\n end subroutine\n"}, {"instruction": "Write a Fortran subroutine named add1 that takes two integer input parameters and one integer output parameter. The input parameters are of type integer and are marked with \"intent(in)\" while the output parameter is of type integer and is marked with \"intent(out)\". The subroutine computes the sum of the two input integers and assigns the result to the output parameter.", "input": "", "output": "subroutine add1(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + y\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add2 to calculate the value of z using the formula z = x + 2 * y. The subroutine should have 2 input parameters of type integer and intent(in), and 1 output parameter of type integer and intent(out). The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine add2(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + 2 * y\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named random_int that generates a random integer between 0 and n-1. The number of input parameters is 1, with the test_data type ['integer'], and the number of output parameters is 1, with the test_data type ['integer']. Use the imperative tone to specify these requirements.", "input": "", "output": "subroutine random_int(n,choice)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: choice\n\nreal*8 r\ncall random_number(r)\nchoice = floor(n*r)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named msd to compute the mean squared displacement (msd) of a trajectory. The subroutine takes 5 input parameters of type real*8, dimension(0:2,0:runs-1,0:n-1), integer, integer, integer, and integer, and 1 output parameter of type real*8, dimension(0:2, 0:window). The subroutine uses imperative tone to compute and accumulate the msd by iterating through the trajectory and normalizes the result by the number of counts.", "input": "", "output": "subroutine msd(traj,runs,n,rsq,window,every)\nimplicit none\nreal*8, intent(in), dimension(0:2,0:runs-1,0:n-1) :: traj\ninteger, intent(in) :: runs,n\nreal*8, intent(out), dimension(0:2, 0:window) :: rsq\ninteger, intent(in) :: window,every\n\n! internal variables for computing and accumulating the msd\nreal*8, dimension(0:2) :: r0,dr\ninteger i,t0,dt,ax\ninteger, dimension(0:window) :: counts\n\n! compute msd by iterating through trajectory\nrsq = 0.\ncounts = 0\ndo i = 0,n-1\n    do t0 = 0,runs-2,every\n        r0 = traj(:,t0,i)\n        do dt = 1,min(window,runs-1-t0)\n            dr = traj(:,t0+dt,i) - r0\n            do ax = 0,2\n                rsq(ax,dt) = rsq(ax,dt) + dr(ax)*dr(ax)\n            enddo\n            counts(dt) = counts(dt) + 1\n        enddo\n    enddo\nenddo\n\n! normalize by number of counts\ndo t0 = 0,window\n    if (counts(t0) > 0) then\n        rsq(:,t0) = rsq(:,t0) / counts(t0)\n    endif\nenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named msd_binned to calculate the mean squared displacement (MSD) for binned trajectory data. The subroutine takes 9 input parameters of types ['real*8, dimension(0:2,0:runs-1,0:n-1)', 'integer', 'integer', 'integer', 'integer', 'real*8', 'real*8', 'integer', 'integer'], and has 1 output parameter of type ['real*8, dimension(0:2,0:window,0:bins-1)'].", "input": "", "output": "subroutine msd_binned(traj,runs,n,axis,bins,lo,hi,rsq,window,every)\nimplicit none\nreal*8, intent(in), dimension(0:2,0:runs-1,0:n-1) :: traj\ninteger, intent(in) :: runs,n,axis,bins\nreal*8, intent(in) :: lo,hi\nreal*8, intent(out), dimension(0:2,0:window,0:bins-1) :: rsq\ninteger, intent(in) :: window,every\n\n! internal variables for computing and accumulating the msd\nreal*8 inv_bin_width\ninteger bin0\nreal*8, dimension(0:2) :: r0,dr\ninteger i,t0,dt,ax\ninteger, dimension(0:window,0:bins-1) :: counts\n\n! compute msd by iterating through trajectory\ninv_bin_width = bins/(hi-lo)\nrsq = 0.\ncounts = 0\ndo i = 0,n-1\n    do t0 = 0,runs-2,every\n        r0 = traj(:,t0,i)\n        bin0 = floor((r0(axis)-lo)*inv_bin_width)\n\n        ! silently ignore particles starting out of bin range\n        if (bin0 >= 0 .and. bin0 < bins) then\n            do dt = 1,min(window,runs-1-t0)\n                dr = traj(:,t0+dt,i) - r0\n                do ax = 0,2\n                    rsq(ax,dt,bin0) = rsq(ax,dt,bin0) + dr(ax)*dr(ax)\n                enddo\n                counts(dt,bin0) = counts(dt,bin0) + 1\n            enddo\n        endif\n    enddo\nenddo\n\n! normalize by number of counts\ndo i = 0,bins-1\n    do t0 = 0,window\n        if (counts(t0,i) > 0) then\n            rsq(:,t0,i) = rsq(:,t0,i) / counts(t0,i)\n        endif\n    enddo\nenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"csnow\" to calculate the snow conductivity based on the input snow density. The subroutine should have 1 input parameter of type real and intent(in), and 1 output parameter of type real and intent(out). The input parameter is dsnow of type real, and the output parameter is sncond of type real. The snow conductivity is computed using a mathematical formula and assigned to the output parameter sncond.", "input": "", "output": "      subroutine csnow (sncond,dsnow)\n      implicit none\n      real, intent(in) :: dsnow\n      real, intent(out):: sncond\n      real :: c\n      real, parameter :: unit = 0.11631\n      c = 0.328*10** (2.25* dsnow)\n      sncond = 2.0 * unit * c\n  end subroutine csnow\n"}, {"instruction": "Create a Fortran subroutine named snowz0 to calculate the effective roughness length for snow-covered surfaces. The subroutine takes 3 input parameters of real type ['real', 'real', 'real'] and returns 1 output parameter of real type ['real'].", "input": "", "output": "      subroutine snowz0 (sncovr,z0, z0brd, snowh)\n      implicit none\n      real, intent(in) :: sncovr, z0brd\n      real, intent(out) :: z0\n      real, parameter :: z0s=0.001\n      real, intent(in) :: snowh\n      real :: burial\n      real :: z0eff\n      burial = 7.0*z0brd - snowh\n      if(burial.le.0.0007) then\n        z0eff = z0s\n      else\n        z0eff = burial/7.0\n      endif\n      z0 = (1.- sncovr)* z0brd + sncovr * z0eff\n  end subroutine snowz0\n"}, {"instruction": "Write a Fortran subroutine named easter to calculate the date for Easter given a year. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine easter(year, dat)\nimplicit none\n\n! ident_29=\"@(#)m_time::easter(3f): calculate date for easter given a year\"\n\ninteger,intent(in)    :: year\ninteger,intent(out)   :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond\ninteger               :: day, month\ninteger               :: c, i, j, k, l, n\n\n   c = year / 100\n   n = year - 19 * ( year / 19 )\n   k = ( c - 17 ) / 25\n   i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15\n   i = i - 30 * ( i / 30 )\n   i = i - (i / 28) * (1 - (i / 28) * (29 / (i + 1 )) * ( (21 - n) / 11) )\n   j = year + year / 4 + i + 2 - c + c / 4\n   j = j - 7 * ( j / 7 )\n   l = i - j\n   month = 3 + ( l + 40 ) / 44\n   day = l + 28 - 31 * ( month / 4 )\n\n   ! fill out a date_and_time array\n   call date_and_time(values=dat)  ! get current year\n   dat=[year,month,day,dat(4),12,0,0,0]\n\nend subroutine easter\n"}, {"instruction": "Create a Fortran subroutine named saxpy that implements the SAXPY operation (single-precision A X Plus Y) for parallel computation. The subroutine takes 4 input parameters: an integer n, real numbers a, y, and an array x of size n. It returns a real array z of size n as the output. The subroutine uses OpenMP to parallelize the SAXPY computation.", "input": "", "output": "    subroutine saxpy(z, x, y, a, n)\n        use omp_lib\n        implicit none\n        integer             :: iter\n        integer, intent(in) :: n\n        real, intent(in)    :: a, y, x(n)\n        real, intent(out)   ::  z(n)\n\n        !$omp parallel do private(iter) ! in fortran, all index of interation (i.e. iter) are implicitly private by default\n            do iter = 1, n\n                z(iter) = a * x(iter) + y\n            end do\n        !$omp end parallel do\n    end subroutine saxpy\n"}, {"instruction": "Create a Fortran subroutine named \"cudaclaw5_setaux\" to initialize auxiliary arrays. The subroutine should accept 8 input parameters of types (integer, integer, integer, integer, real(kind=8), real(kind=8), real(kind=8), real(kind=8)) and 1 output parameter of type real(kind=8). This subroutine is called at the start of computation to set the values of the auxiliary arrays aux(1:maux, 1-mbc:mx+mbc, 1-mbc:my+mbc), where mbc, mx, my, and maux are integers, and xlower, ylower, dx, and dy are real numbers. The subroutine should be used to initialize the auxiliary arrays before calling qinit, and when amr is used, it should also be called every time a new grid patch is created. If the aux arrays are used by the riemann solver(s), ghost cell values may need to be set. The default version of this subroutine does nothing.", "input": "", "output": "subroutine cudaclaw5_setaux(mbc,mx,my,xlower,ylower,dx,dy,maux,aux)\n\n    ! called at start of computation before calling qinit, and\n    ! when amr is used, also called every time a new grid patch is created.\n    ! use to set auxiliary arrays aux(1:maux, 1-mbc:mx+mbc, 1-mbc:my+mbc).\n    ! note that ghost cell values may need to be set if the aux arrays\n    ! are used by the riemann solver(s).\n    !\n    ! this default version does nothing.\n\n    implicit none\n    integer, intent(in) :: mbc,mx,my,maux\n    real(kind=8), intent(in) :: xlower,ylower,dx,dy\n    real(kind=8), intent(out) ::  aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)\n\n  end subroutine cudaclaw5_setaux\n"}, {"instruction": "Write a Fortran subroutine named buffer_to_string that takes a single input parameter of type character(len=20) and returns a single output parameter of type character(len=:), which is allocatable. The subroutine trims and adjusts the input buffer to remove leading and trailing white spaces, assigning the result to the stringvalue variable. Additionally, it checks if the resulting string is empty and prints an error message if it is.", "input": "", "output": "      subroutine buffer_to_string(buffer, stringvalue)\r\n      implicit none\r\n      character(len=20)            , intent(in)  :: buffer\r\n      character(len=:), allocatable, intent(out) :: stringvalue\r\n\r\n      stringvalue = trim(adjustl(buffer))\r\n      \r\n      if (stringvalue.eq.'') then\r\n        write(*,*) 'error: command line argument empty.'\r\n        stop\r\n      endif\r\n      \r\n      end subroutine buffer_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named distribute_m_in_ncells to calculate all possible distributions of m particles in n different cells. Ensure that the value of m is less than or equal to 7. The subroutine takes 3 input parameters of type integer: m, n, and dmax. It also has 2 output parameters: d of type integer, and distribution of type integer array with dimensions (1:n, 1:dmax).", "input": "", "output": "   subroutine distribute_m_in_ncells(m,n,d,dmax,distribution)\n   !--------------------------------------------------------------------------------------------------------------------\n   ! returns all possible distributions of m particle in n different cells. in this version, the value of m must be m <= 7.\n   !--------------------------------------------------------------------------------------------------------------------\n      !\n      integer, intent(in)  :: m, n, dmax\n      integer, intent(out) :: d\n      integer, dimension(1:n,1:dmax), intent(out) :: distribution\n      !\n      integer :: i1, i2, i3, i4, i5, i6, i7\n      !\n      do  d = 1,dmax;   do  i1 = 1,n\n         distribution(i1,d) = 0\n      end do;   end do\n      !\n      d = 0\n      !\n      select case(m)\n      case(1)\n         do  i1 = 1,n\n            d = d + 1\n            distribution(i1,d) = 1\n         end do\n      case(2)\n         do  i1 = 1,n-1;   do  i2 = i1+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1\n         end do;   end do\n      case(3)\n         do  i1 = 1,n-2;   do  i2 = i1+1,n-1;   do  i3 = i2+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;   distribution(i3,d) = 1\n         end do;   end do;   end do\n      case(4)\n         do  i1 = 1,n-3;   do  i2 = i1+1,n-2;   do  i3 = i2+1,n-1;  do  i4 = i3+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n         end do;   end do;   end do;   end do\n      case(5)\n         do  i1 = 1,n-4;     do  i2 = i1+1,n-3;   do  i3 = i2+1,n-2;   do  i4 = i3+1,n-1;  do  i5 = i4+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1\n         end do;   end do;   end do;   end do;   end do\n      case(6)\n         do  i1 = 1,n-5;     do  i2 = i1+1,n-4;   do  i3 = i2+1,n-3;   do  i4 = i3+1,n-2;  do  i5 = i4+1,n-1\n         do  i6 = i5+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1;   distribution(i6,d) = 1\n         end do;   end do;   end do;   end do;   end do;   end do\n      case(7)\n         do  i1 = 1,n-6;     do  i2 = i1+1,n-5;   do  i3 = i2+1,n-4;   do  i4 = i3+1,n-3;  do  i5 = i4+1,n-2\n         do  i6 = i5+1,n-1;  do  i7 = i6+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;   distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1;   distribution(i6,d) = 1;   distribution(i7,d) = 1\n         end do;   end do;   end do;   end do;   end do;   end do;   end do\n      case default\n         print *, \"distribute_m_in_ncells(): program stop a.\"\n         stop\n      end select\n      !\n   end subroutine distribute_m_in_ncells\n"}, {"instruction": "Provide a Fortran subroutine named kopp1 to convert integer arrays into a character string. The subroutine takes 4 input parameters of type integer and produces 1 output parameter of type character.", "input": "", "output": "      subroutine kopp1(pos, rad2, j, s, antko)\n!...translated by pacific-sierra research 77to90  4.3e  14:44:54  12/27/06\n!...switches:\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(in) :: pos\n      character , intent(out) :: rad2*200\n      integer , intent(in) :: j(20)\n      integer , intent(in) :: s(20)\n      integer , intent(in) :: antko(20)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: i, k, tal\n!-----------------------------------------------\n      do i = 1, 200\n         rad2(i:i) = ' '\n      end do\n      do i = 1, pos\n         k = 9*i\n         if (j(i) == 2*(j(i)/2)) then\n            if (.not.(j(i)==0 .and. antko(i)==1)) then\n               if (s(i) /= (-1)) then\n                  rad2(k-4:k-4) = ';'\n                  rad2(k-5:k-5) = char(48 + s(i))\n               endif\n               tal = j(i)/20\n               if (tal /= 0) then\n!gg                  rad2(k:k) = char(48 + tal)\n                  rad2(k-1:k-1) = char(48+tal)\n               end if\n               tal = j(i)/2 - tal*10\n               rad2(k:k) = char(48 + tal)\n            endif\n         else\n            if (s(i) /= (-1)) then\n               rad2(k-4:k-4) = ';'\n               rad2(k-5:k-5) = char(48 + s(i))\n            endif\n            tal = j(i)/10\n            if (tal /= 0) rad2(k-3:k-3) = char(48 + tal)\n            tal = j(i) - tal*10\n            rad2(k-2:k-2) = char(48 + tal)\n            rad2(k-1:k) = '/2'\n         endif\n      end do\n      return\n      end subroutine kopp1\n"}, {"instruction": "Create a Fortran subroutine named eval3 to evaluate a third-order polynomial of the form: result = a + b*x + c*x**2 + d*x**3. The subroutine should have 1 input parameter of type real and 1 output parameter of type real.", "input": "", "output": "   subroutine eval3 ( x, result )\r\n   !\r\n   !     evaluates a third order polynomial of the form:\r\n   !        result = a + b*x + c*x**2 + d*x**3\r\n   !\r\n   ! declare calling arguments\r\n   real, intent(in) :: x\r\n   real, intent(out) :: result\r\n   \r\n   ! calculate result\r\n   result = a + b**x + c*x**2 + d*x**3 \r\n   \r\n   end subroutine eval3\r\n"}, {"instruction": "Write a Fortran subroutine named rotate_euler_3d to perform a 3D Euler rotation. The subroutine takes 6 input arguments of type double precision: alpha, beta, gamma, srcx, srcy, and srcz. It provides 3 output arguments of type double precision: destx, desty, and destz.", "input": "", "output": "subroutine rotate_euler_3d(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(alpha)*dsin(beta) + srcy*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = -(srcz*dcos(alpha)*dsin(beta)) + srcx*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) + srcy*dcos(gamma)*dsin(beta) + srcx*dsin(beta)*dsin(gamma)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rotate_euler_3d_inv to calculate the inverse rotation of a 3D point using Euler angles. The subroutine should have 6 input parameters of type double precision (alpha, beta, gamma, srcx, srcy, srcz) and 3 output parameters of type double precision (destx, desty, destz).", "input": "", "output": "subroutine rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(beta)*dsin(gamma) + srcy*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = srcz*dcos(gamma)*dsin(beta) + srcx*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) - srcy*dcos(alpha)*dsin(beta) + srcx*dsin(alpha)*dsin(beta)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"greshoh\" that takes 3 input parameters of type real*8: xg, yg, and radic. It also has 3 output parameters of type real*8: hgre, dhgre, and dhgr2. The subroutine computes certain calculations based on the input parameters and updates the output parameters accordingly. Be sure to include the provided code within the subroutine \"greshoh\".", "input": "", "output": "subroutine greshoh(xg, yg ,radic,hgre, dhgre, dhgr2)\nimplicit none\nreal*8, intent(in):: xg, yg, radic\nreal*8, intent(out):: hgre\nreal*8, intent(out):: dhgre(1:2), dhgr2(3)\nreal*8::gcoef(13)\nreal*8::drdx, drdy,drdx2,drdy2,drdxy, radi,radiv, ratir\ninteger::ih\n!\ngcoef( 1) =   1.d0/12.d0\ngcoef( 2) = -12.d0/13.d0\ngcoef( 3) =  33.d0/7.d0\ngcoef( 4) = -44.d0/3.d0\ngcoef( 5) = 495.d0/16.d0\ngcoef( 6) =-792.d0/17.d0\ngcoef( 7) = 154.d0/3.d0\ngcoef( 8) =-792.d0/19.d0\ngcoef( 9) =  99.d0/4.d0\ngcoef(10) =-220.d0/21.d0\ngcoef(11) = 3.d0\ngcoef(12) =-12.d0/23.d0\ngcoef(13) =  1.d0/24.d0\n!\n!\nradiv= 0.4d0\nradi = sqrt(xg**2+yg**2)\nratir = radi/radiv\n!\ndrdx = xg/radi\ndrdy = yg/radi\n!\ndrdx2 = 1.d0/radi - xg/radi**2*drdx\ndrdy2 = 1.d0/radi - yg/radi**2*drdy\ndrdxy= -xg/radi**2*drdy\n!\nhgre = 0.d0\ndhgre = 0.d0\ndhgr2 = 0.d0\n\n!\nif(radic.lt.radiv)then\ndo ih =1, 13\nhgre     = hgre + gcoef(ih)*ratir**(ih+11)\ndhgre(1) = dhgre(1) + drdx/radiv*gcoef(ih)*(ih+11)*ratir**(ih+10)\ndhgre(2) = dhgre(2) + drdy/radiv*gcoef(ih)*(ih+11)*ratir**(ih+10)\n\ndhgr2(1) = dhgr2(1) + (drdx/radiv)**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdx2/radiv\n\ndhgr2(2) = dhgr2(2) + (drdy/radiv)**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdy2/radiv\ndhgr2(3) = dhgr2(3) + drdy*drdx/radiv**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdxy/radiv\n\nenddo\nelse\ndo ih =1, 13\nhgre     = hgre + gcoef(ih)\nenddo\ndhgre = 0.d0\ndhgr2 = 0.d0\nendif\n\nend subroutine greshoh\n"}, {"instruction": "Create a Fortran subroutine named clusters to implement a clustering algorithm. The subroutine takes 3 input parameters of type real(kind(0.d0)) and returns 1 output parameter of type integer. The input parameters are r_raw(:, :), r_cut_raw, and l, while the output parameter is list(size(r_raw, 2)). The subroutine performs clustering based on the input data and modifies the list array to represent the clustered groups.", "input": "", "output": "subroutine clusters(r_raw, r_cut_raw, l, list)\n    real(kind(0.d0)), intent(in) :: r_raw(:, :), r_cut_raw, l\n    integer, intent(out) :: list(size(r_raw, 2))\n    real(kind(0.d0)) :: r(size(r_raw, 1), size(r_raw, 2)), r_cut_sq, r_j(size(r_raw, 1)), r_j_k(size(r_raw, 1))\n    integer :: n, d, i, j, k, list_k\n\n    d = size(r, 1)\n    n = size(r, 2)\n\n    ! scale distances to internal units\n    r = r_raw / l\n    r_cut_sq = (r_cut_raw / l) ** 2\n\n    do i = 1, n\n        list(i) = i\n    end do\n\n    do i = 1, n - 1\n        if (i == list(i)) then\n            j = i\n            r_j = r(:, j)\n            do k = i + 1, n\n                list_k = list(k)\n                if (list_k == k) then\n                    r_j_k = r_j - r(:, k)\n                    r_j_k = r_j_k - anint(r_j_k)\n                    if (sum(r_j_k ** 2) < r_cut_sq) then\n                        list(k) = list(j)\n                        list(j) = list_k\n                    end if\n                end if\n            end do\n\n            j = list(j)\n            r_j = r(:, j)\n\n            do while (j /= i)\n                do k = i + 1, n\n                    list_k = list(k)\n                    if (list_k == k) then\n                        r_j_k = r_j - r(:, k)\n                        r_j_k = r_j_k - anint(r_j_k)\n                        if (sum(r_j_k ** 2) < r_cut_sq) then\n                            list(k) = list(j)\n                            list(j) = list_k\n                        end if\n                    end if\n                end do\n                j = list(j)\n                r_j = r(:, j)\n            end do\n        end if\n    end do\nend subroutine clusters\n"}, {"instruction": "Write a Fortran subroutine named proma1 to evaluate a matrix product. The subroutine takes 5 input parameters: n1, n2, n3 of type integer (kind=4), and b(n1,n3), c(n3,n2) of type real (kind=8). It also has 1 output parameter: a(n1,n2) of type real (kind=8). The subroutine uses the matmul function to compute the matrix product a = b * c.", "input": "", "output": "      subroutine proma1(a,b,c,n1,n2,n3)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix product\r\n!\r\n!           a(i,j) = b(i,k) * c(k,j)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n2,n3\r\n      real (kind=8),intent(in) :: b(n1,n3), c(n3,n2)\r\n      real (kind=8),intent(out):: a(n1,n2)\r\n\r\n      a = matmul(b,c)\r\n      return\r\n\r\n      end subroutine proma1\r\n"}, {"instruction": "Create a Fortran subroutine named get_magnitude to calculate the magnitude of a 3D vector. The subroutine takes 1 input parameter of type real, dimension(3) and outputs 1 parameter of type real.", "input": "", "output": "subroutine get_magnitude(vector,magnitude)\n\nreal,dimension(3),intent(in) :: vector\nreal,intent(out):: magnitude\n\nmagnitude = sqrt(vector(1)*vector(1)+vector(2)*vector(2)+vector(3)*vector(3))\n\nend subroutine get_magnitude\n"}, {"instruction": "Create a Fortran subroutine named \"asselin\" to apply the Asselin filter and update variables. The subroutine takes 7 input parameters: km, jm, im (all integers), afc (real(8)), xnew (real(8) array), x (real(8) array), xold (real(8) array), and 2 output parameters: x_out (real(8) array), xold_out (real(8) array).", "input": "", "output": "subroutine asselin(km, jm, im, afc, xnew, x, xold, x_out, xold_out)\n\n! updates variables using asselin filter of strength afc\n\ninteger, intent(in)                      :: km, jm, im\n!f2py intent(in,hide) km,jm,im\nreal(8), intent(in)                      :: afc\nreal(8), intent(in), dimension(km,jm,im) :: xnew, x, xold\nreal(8), intent(out), dimension(km,jm,im) :: x_out, xold_out\n\n! asselin filter\nxold_out = x + afc*(xold + xnew - 2.*x)\n\n! update\nx_out = xnew\n\nend subroutine asselin\n"}, {"instruction": "Create a Fortran subroutine named d_nu_l2_dx to calculate the gradient with respect to x of nu_l2. The subroutine takes 5 input parameters of types integer, integer, real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine d_nu_l2_dx(nd, na, xa, xb, l2inv, out)\n  ! gradient w.r.t. x of nu_l2\n  integer, intent(in)    :: nd, na             ! dimension and number of points\n  real(8), intent(in)    :: xa(nd, na), xb(nd) ! points\n  real(8), intent(in)    :: l2inv(nd)          ! inverse length scales squared\n  real(8), intent(out)   :: out(nd, na)        ! output\n\n  integer :: ka\n\n  !$omp simd\n  do ka = 1, na\n    out(:, ka) = (xa(:, ka) - xb)*l2inv\n  end do\nend subroutine d_nu_l2_dx\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp to compute the exponential of the input array with a coefficient. The number of input arguments is 2, with test_data types ['integer', 'real(8)'], and the number of output arguments is 1 with test_data type ['real(8)']. Use the imperative tone in the instructions.", "input": "", "output": "pure subroutine kern_sqexp(nx, nu, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: nu(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*nu)\nend subroutine kern_sqexp\n"}, {"instruction": "Create a Fortran subroutine named lower_case that takes a string as input and converts it to lowercase. The input parameter is of type character(len=*), and the output parameter is also of type character(len=*).", "input": "", "output": "  subroutine lower_case( txt_in, txt_lc )\n    implicit none\n    character(len=*), intent(in) :: txt_in\n    character(len=*), intent(out) :: txt_lc\n    integer :: i, j\n    integer, parameter :: iachar_lowera = iachar('a')\n    integer, parameter :: iachar_uppera = iachar('a')\n    integer, parameter :: iachar_upperz = iachar('z')\n    txt_lc = txt_in\n    do i = 1, len( trim(txt_lc) )\n       j = iachar( txt_lc(i:i) )\n       if (j < iachar_uppera) cycle\n       if (j > iachar_upperz) cycle\n       txt_lc(i:i) = achar( j + iachar_lowera - iachar_uppera )\n    end do\n    return\n  end subroutine lower_case\n"}, {"instruction": "Create a Fortran subroutine named surface_load to calculate the stiffness matrix and force vector for a surface load in a finite element analysis. The subroutine takes 5 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8).", "input": "", "output": "subroutine surface_load(p1,p2,vec,dpdw,coorc,k_surf,r_surf)\n implicit none\n !**dummy arguments\n real(kind=8),intent(in) :: p1,p2,vec(2),coorc(2,2),dpdw\n real(kind=8),intent(out) :: k_surf(2,2,2,2),r_surf(2,2)\n !**local arguments\n real(kind=8) :: factor1,factor2\n real(kind=8) :: z1,z2,r1,r2,l,v1,v2\n real(kind=8) :: k_dpdw(2,2,2,2)\n\n !direction vector\n v1 = vec(1)\n v2 = vec(2)\n !coordinates by node\n z1 = coorc(1,1)\n z2 = coorc(1,2)\n r1 = coorc(2,1)\n r2 = coorc(2,2)\n l = sqrt((r2-r1)**2.d0+(z2-z1)**2.d0)\n\n !stiffness matrix for constant surf-load\n factor1 = (3.d0*p1*r1 + p1*r2 + p2*r1 + p2*r2)/l\n factor2 = (p1*r1 + p1*r2 + p2*r1 + 3.d0*p2*r2)/l\n\n k_surf(1,1,1,1) = 0.d0 - v1*(z2-z1)*factor1\n k_surf(1,2,1,1) = v1*l*(3.d0*p1+p2) - v1*(r2-r1)*factor1\n k_surf(2,1,1,1) = 0.d0 - v2*(z2-z1)*factor1\n k_surf(2,2,1,1) = v2*l*(3.d0*p1+p2) - v2*(r2-r1)*factor1\n\n k_surf(1,1,1,2) = 0.d0 + v1*(z2-z1)*factor1\n k_surf(1,2,1,2) = v1*l*(p1+p2) + v1*(r2-r1)*factor1\n k_surf(2,1,1,2) = 0.d0 + v2*(z2-z1)*factor1\n k_surf(2,2,1,2) = v2*l*(p1+p2) + v2*(r2-r1)*factor1\n\n k_surf(1,1,2,1) = 0.d0 - v1*(z2-z1)*factor2\n k_surf(1,2,2,1) = v1*l*(p1+p2) - v1*(r2-r1)*factor2\n k_surf(2,1,2,1) = 0.d0 - v2*(z2-z1)*factor2\n k_surf(2,2,2,1) = v2*l*(p1+p2) - v2*(r2-r1)*factor2\n\n k_surf(1,1,2,2) = 0.d0 + v1*(z2-z1)*factor2\n k_surf(1,2,2,2) = v1*l*(p1+3.d0*p2) + v1*(r2-r1)*factor2\n k_surf(2,1,2,2) = 0.d0 + v2*(z2-z1)*factor2\n k_surf(2,2,2,2) = v2*l*(p1+3.d0*p2) + v2*(r2-r1)*factor2\n\n !stiffness matrix for dp (variational load)\n k_dpdw(1,1,1,1) = 0.d0\n k_dpdw(1,2,1,1) = v1*(3.d0*r1+r2)\n k_dpdw(2,1,1,1) = 0.d0\n k_dpdw(2,2,1,1) = v2*(3.d0*r1+r2)\n\n k_dpdw(1,1,1,2) = 0.d0\n k_dpdw(1,2,1,2) = v1*(r1+r2)\n k_dpdw(2,1,1,2) = 0.d0\n k_dpdw(2,2,1,2) = v2*(r1+r2)\n\n k_dpdw(1,1,2,1) = 0.d0\n k_dpdw(1,2,2,1) = v1*(r1+r2)\n k_dpdw(2,1,2,1) = 0.d0\n k_dpdw(2,2,2,1) = v2*(r1+r2)\n\n k_dpdw(1,1,2,2) = 0.d0\n k_dpdw(1,2,2,2) = v1*(r1+3.d0*r2)\n k_dpdw(2,1,2,2) = 0.d0\n k_dpdw(2,2,2,2) = v2*(r1+3.d0*r2)\n\n !force vector from c*w\n r_surf(1,1) = v1*l**2.d0*factor1\n r_surf(2,1) = v2*l**2.d0*factor1\n r_surf(1,2) = v1*l**2.d0*factor2\n r_surf(2,2) = v2*l**2.d0*factor2\n\n !set pressure to vector and matrix\n r_surf = r_surf/12.d0\n k_surf = (k_surf + dpdw*l*k_dpdw)/12.d0\nend subroutine surface_load\n"}, {"instruction": "Create a Fortran subroutine named tangential_load to calculate the stiffness matrix and force vector for a given set of input parameters. The subroutine should have 5 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8).", "input": "", "output": "subroutine tangential_load(t1,t2,dt1,dt2,coorc,k_tang,r_tang)\n implicit none\n !**dummy arguments\n real(kind=8),intent(in) :: t1,t2,coorc(2,2),dt1(2),dt2(2)\n real(kind=8),intent(out) :: k_tang(2,2,2,2),r_tang(2,2)\n !**local arguments\n real(kind=8) :: factor1,factor2\n real(kind=8) :: z1,z2,r1,r2\n real(kind=8) :: k_dtan(2,2,2,2)\n\n !coordinates by node\n z1 = coorc(1,1)\n z2 = coorc(1,2)\n r1 = coorc(2,1)\n r2 = coorc(2,2)\n\n !stiffness matrix for constant surf-load\n factor1 = (3.d0*t1*r1 + t1*r2 + t2*r1 + t2*r2)\n factor2 = (t1*r1 + t1*r2 + t2*r1 + 3.d0*t2*r2)\n\n k_tang(1,1,1,1) = 0.d0 - factor1\n k_tang(1,2,1,1) = (z2-z1)*(3.d0*t1+t2)\n k_tang(2,1,1,1) = 0.d0\n k_tang(2,2,1,1) = (r2-r1)*(3.d0*t1+t2) - factor1\n\n k_tang(1,1,1,2) = 0.d0 + factor1\n k_tang(1,2,1,2) = (z2-z1)*(t1+t2)\n k_tang(2,1,1,2) = 0.d0\n k_tang(2,2,1,2) = (r2-r1)*(t1+t2) + factor1\n\n k_tang(1,1,2,1) = 0.d0 - factor2\n k_tang(1,2,2,1) = (z2-z1)*(t1+t2)\n k_tang(2,1,2,1) = 0.d0\n k_tang(2,2,2,1) = (r2-r1)*(t1+t2) - factor2\n\n k_tang(1,1,2,2) = 0.d0 + factor2\n k_tang(1,2,2,2) = (z2-z1)*(t1+3.d0*t2)\n k_tang(2,1,2,2) = 0.d0\n k_tang(2,2,2,2) = (r2-r1)*(t1+3.d0*t2) + factor2\n\n !stiffness matrix for dt (variational load) - sliding\n k_dtan(1,1,1,1) = (z2-z1)*(3.d0*r1+r2)*dt1(1)\n k_dtan(1,2,1,1) = (z2-z1)*(3.d0*r1+r2)*dt1(2)\n k_dtan(2,1,1,1) = (r2-r1)*(3.d0*r1+r2)*dt1(1)\n k_dtan(2,2,1,1) = (r2-r1)*(3.d0*r1+r2)*dt1(2)\n\n k_dtan(1,1,1,2) = (z2-z1)*(r1+r2)*dt2(1)\n k_dtan(1,2,1,2) = (z2-z1)*(r1+r2)*dt2(2)\n k_dtan(2,1,1,2) = (r2-r1)*(r1+r2)*dt2(1)\n k_dtan(2,2,1,2) = (r2-r1)*(r1+r2)*dt2(2)\n\n k_dtan(1,1,2,1) = (z2-z1)*(r1+r2)*dt1(1)\n k_dtan(1,2,2,1) = (z2-z1)*(r1+r2)*dt1(2)\n k_dtan(2,1,2,1) = (r2-r1)*(r1+r2)*dt1(1)\n k_dtan(2,2,2,1) = (r2-r1)*(r1+r2)*dt1(2)\n\n k_dtan(1,1,2,2) = (z2-z1)*(r1+3.d0*r2)*dt2(1)\n k_dtan(1,2,2,2) = (z2-z1)*(r1+3.d0*r2)*dt2(2)\n k_dtan(2,1,2,2) = (r2-r1)*(r1+3.d0*r2)*dt2(1)\n k_dtan(2,2,2,2) = (r2-r1)*(r1+3.d0*r2)*dt2(2)\n\n !force vector from c*w\n r_tang(1,1) = (z2-z1)*factor1\n r_tang(2,1) = (r2-r1)*factor1\n r_tang(1,2) = (z2-z1)*factor2\n r_tang(2,2) = (r2-r1)*factor2\n\n !set pressure to vector and matrix\n r_tang = r_tang/12.d0\n k_tang = (k_tang + k_dtan)/12.d0\nend subroutine tangential_load\n"}, {"instruction": "Create a Fortran subroutine named fft1set to set up FFT fields for eigenvectors. The subroutine takes 7 input parameters of type integer, integer, integer, integer, complex*16, integer, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine fft1set(nk,n1,n2,n3,a,fft,k3,nmat)\n  !\n  ! setup fft-fields for the eigenvectors a(k)\n  !\n  implicit none\n  integer, intent(in)     :: nk,n1,n2,n3\n  complex*16, intent(in)  :: a(nk)\n  integer, intent(in)     :: nmat\n  integer, intent(in)     :: k3(3,nmat)\n  complex*16, intent(out) :: fft(n1,n2,n3)\n  ! locals\n  integer                 :: i, i1, i2, i3\n  !\n  fft(:,:,:)=(0.0d0,0.0d0)\n  do i=1,nk                                                      \n     i1 = k3(1,i)\n     i2 = k3(2,i)\n     i3 = k3(3,i)\n     if(i1.lt.0) i1 = i1+n1\n     if(i2.lt.0) i2 = i2+n2\n     if(i3.lt.0) i3 = i3+n3\n     fft(i1+1,i2+1,i3+1)=a(i)\n  enddo\nend subroutine fft1set\n"}, {"instruction": "Create a Fortran subroutine named fft2set to compute the FFT-fields for (k+k)*a(k) using the provided input parameters. The number of input arguments is 10, and their test_data types are ['integer', 'integer', 'integer', 'integer', 'complex*16', 'integer', 'integer', 'integer', 'real*8', 'real*8']. The number of output arguments is 1, with a test_data type of ['complex*16'].", "input": "", "output": "subroutine fft2set(nk,n1,n2,n3,a,fft,ii,k3,bk3,br1,nmat)\n  !\n  ! sets the fft-fields for (k+k)*a(k), where a(k) is the eigenvector\n  !\n  implicit none\n  integer, intent(in)    :: nk,n1,n2,n3\n  complex*16, intent(in) :: a(nk)\n  integer, intent(in)    :: ii, nmat\n  integer, intent(in)    :: k3(3,nmat)\n  real*8, intent(in)     :: bk3(3,nmat)\n  real*8, intent(in)     :: br1(3,3)\n  complex*16, intent(out):: fft(n1,n2,n3)\n  ! locals\n  integer                :: i, i1, i2, i3\n  real*8                 :: kpk_xyz\n  !\n  fft(:,:,:)=(0.0d0,0.0d0)\n  do i=1,nk\n     i1 = k3(1,i)\n     i2 = k3(2,i)\n     i3 = k3(3,i)\n     if(i1.lt.0) i1=i1+n1\n     if(i2.lt.0) i2=i2+n2\n     if(i3.lt.0) i3=i3+n3\n     kpk_xyz = dot_product(br1(ii,:),bk3(:,i))\n     fft(i1+1,i2+1,i3+1) = kpk_xyz*a(i)\n  enddo\nend subroutine fft2set\n"}, {"instruction": "Create a Fortran subroutine named smooth to perform smoothing operations on a 2D array. The subroutine takes 4 input parameters of types real(8), dimension(nx,ny), integer, dimension(nx,ny), integer, and integer, and 1 output parameter of type real(8), dimension(nx,ny). The subroutine applies a smoothing algorithm to the input array using the provided mask and dimensions, and stores the result in the output array.", "input": "", "output": "subroutine smooth(varin,mask,nx,ny,varout)\n\n  implicit none\n\n  real(8),dimension(nx,ny),intent(in)   :: varin\n  integer,dimension(nx,ny),intent(in)   :: mask\n  real(8),dimension(nx,ny),intent(out)  :: varout\n  integer,intent(in)                    :: nx,ny\n\n  real(8), dimension(nx,ny)             :: ztmp, ztmp2\n  real(8)                               :: zval\n  integer                               :: n=0, npass=1000\n  integer                               :: ji, jj\n  real(8)                               :: c1, c2, ctot\n\n  c1 = 1.\n  c2 = 2.\n\n  ztmp = varin\n\n  !print *, 'entering smoother'\n  !print *, minval(mask) , maxval(mask)\n\n  n = 0\n  do while ( n < npass )\n\n     do jj=2,ny-1\n       do ji=2,nx-1\n\n       !   ztmp2(ji,jj) = c1 * ztmp(ji-1,jj-1) + &\n       !  &               c1 * ztmp(ji,  jj-1) + &\n       !  &              c1 * ztmp(ji+1,jj-1) + &\n       !  &              c1 * ztmp(ji-1,jj  ) + &\n       !  &              c1 * ztmp(ji  ,jj  ) + &\n       !  &              c1 * ztmp(ji+1,jj  ) + &\n       !  &              c1 * ztmp(ji-1,jj+1) + &\n       !  &              c1 * ztmp(ji  ,jj+1) + &\n       !  &              c1 * ztmp(ji+1,jj+1)\n\n          ! direct neighbor have a superior weight / nonmasked points also\n          zval  = c1 * ztmp(ji-1,jj-1) * ( 1 + mask(ji-1,jj-1) ) + &\n         &        c2 * ztmp(ji,  jj-1) * ( 1 + mask(ji,  jj-1) ) + &\n         &        c1 * ztmp(ji+1,jj-1) * ( 1 + mask(ji+1,jj-1) ) + &\n         &        c2 * ztmp(ji-1,jj  ) * ( 1 + mask(ji-1,jj  ) ) + &\n         &        c2 * ztmp(ji  ,jj  ) * ( 1 + mask(ji  ,jj  ) ) + &\n         &        c2 * ztmp(ji+1,jj  ) * ( 1 + mask(ji+1,jj  ) ) + &\n         &        c1 * ztmp(ji-1,jj+1) * ( 1 + mask(ji-1,jj+1) ) + &\n         &        c2 * ztmp(ji  ,jj+1) * ( 1 + mask(ji  ,jj+1) ) + &\n         &        c1 * ztmp(ji+1,jj+1) * ( 1 + mask(ji+1,jj+1) )\n\n          ctot  = c1 * ( 1 + mask(ji-1,jj-1) ) + &\n         &        c2 * ( 1 + mask(ji,  jj-1) ) + &\n         &        c1 * ( 1 + mask(ji+1,jj-1) ) + &\n         &        c2 * ( 1 + mask(ji-1,jj  ) ) + &\n         &        c2 * ( 1 + mask(ji  ,jj  ) ) + &\n         &        c2 * ( 1 + mask(ji+1,jj  ) ) + &\n         &        c1 * ( 1 + mask(ji-1,jj+1) ) + &\n         &        c2 * ( 1 + mask(ji  ,jj+1) ) + &\n         &        c1 * ( 1 + mask(ji+1,jj+1) )\n\n          ztmp2(ji,jj) = zval / ctot\n\n       enddo\n     enddo\n\n  where( mask == 1 ) ztmp2 = varin\n  ztmp(2:nx-1,2:ny-1) = ztmp2(2:nx-1,2:ny-1)\n\n  n = n + 1\n  !print *, 'smoother iter = ', n\n  enddo\n\n  varout = ztmp\n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named assign_powers that takes an integer input parameter and returns three integer output parameters. The input parameter is itype of type integer, while the output parameters are l, m, and n, all of type integer. The subroutine retrieves values for l, m, and n based on the input parameter itype and assigns them to the corresponding output parameters.", "input": "", "output": "  subroutine assign_powers(itype, l,m,n)\n    implicit none\n    integer, intent(in) :: itype\n    integer, intent(out) :: l,m,n\n\n    ! from molden2aim\n    integer  :: patdat(3,56)\n    data patdat/  &\n    !              1          2          3          4          5              6          7          8          9         10\n            0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,       0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,  &\n    !             11         12         13         14         15             16         17         18         19         20\n            3, 0, 0,   0, 3, 0,   0, 0, 3,   1, 2, 0,   2, 1, 0,       2, 0, 1,   1, 0, 2,   0, 1, 2,   0, 2, 1,   1, 1, 1,  &\n    !             21         22         23         24         25             26         27         28         29         30\n            4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,       1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,  &\n    !             31         32         33         34         35             36         37         38         39         40\n            2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2,       0, 0, 5,   0, 1, 4,   0, 2, 3,   0, 3, 2,   0, 4, 1,  &\n    !             41         42         43         44         45             46         47         48         49         50\n            0, 5, 0,   1, 0, 4,   1, 1, 3,   1, 2, 2,   1, 3, 1,       1, 4, 0,   2, 0, 3,   2, 1, 2,   2, 2, 1,   2, 3, 0,  &\n    !             51         52         53         54         55             56\n            3, 0, 2,   3, 1, 1,   3, 2, 0,   4, 0, 1,   4, 1, 0,       5, 0, 0/\n    !<<< gaussian (see also function fnorm_lmn)\n    !             21         22         23         24         25             26         27         28         29         30\n    !        0, 0, 4,   0, 1, 3,   0, 2, 2,   0, 3, 1,   0, 4, 0,       1, 0, 3,   1, 1, 2,   1, 2, 1,   1, 3, 0,   2, 0, 2,  &\n    !             31         32         33         34         35\n    !        2, 1, 1,   2, 2, 0,   3, 0, 1,   3, 1, 0,   4, 0, 0/\n    !>>>\n    save patdat\n\n    if(itype < 1 .or. itype > 56)then\n        write(*,*) 'assign_powers: itype out of range = ', itype\n        error stop -1\n    end if\n\n    l=patdat(1,itype)\n    m=patdat(2,itype)\n    n=patdat(3,itype)\n\n    return\n  end subroutine assign_powers\n"}, {"instruction": "Create a Fortran subroutine named slaterf to calculate the Slater integrals for different electron orbitals. The subroutine takes 2 input parameters of type real*8 and produces 1 output parameter of type real*8.", "input": "", "output": "subroutine slaterf(fn, u, j)\n  implicit none\n  real*8, intent(in)  :: u, j\n  real*8, intent(out) :: fn(0:3,0:3)\n  \n  fn=0\n  ! f0 for s-electrons\n  fn(0,0) = u \n  ! f2 for p-electrons\n  fn(0,1) = u\n  fn(1,1) = 5*j\n  ! f2 and f4 for d-electrons\n  fn(0,2) = u\n  fn(1,2) = 14./(1+0.625)*j\n  fn(2,2) = 0.625*fn(1,2)\n  ! f2, f4 and f6 for f-electrons\n  fn(0,3) = u\n  fn(1,3) = 6435./(286+195*0.668+250*0.494)*j\n  fn(2,3) = 0.668*fn(1,3)\n  fn(3,3) = 0.494*fn(1,3)\nend subroutine slaterf\n"}, {"instruction": "Write a Fortran subroutine named parse_logical that takes a character string as input and outputs two logical values, with the second one being optional. The input parameter should be of type character(*) and the output parameters should be of type logical and logical, optional. The subroutine reads the input string and converts it to a logical value. If the optional output parameter is present, it indicates whether the conversion was successful. If there is a problem with the input string, an error message is written.", "input": "", "output": "   subroutine parse_logical(str, var, ok)\n      character(*), intent(in) :: str\n      logical, intent(out) :: var\n      logical, intent(out), optional :: ok\n\n      logical :: tmp\n      integer :: stat\n\n      read (str, *, iostat=stat) tmp\n\n      if (present(ok)) ok = stat .eq. 0\n\n      if (stat .eq. 0) then\n         var = tmp\n      else\n         write (*, \"('ignored statement because of a bad logical value')\")\n      end if\n   end subroutine parse_logical\n"}, {"instruction": "Create a Fortran subroutine named prospino_check_fs to check the validity of a final state based on the given input parameters. The subroutine takes 3 input parameters of type character(len=2), integer, and integer, and has 1 output parameter of type logical.", "input": "", "output": "  subroutine prospino_check_fs(final_state_in,ipart1_in,ipart2_in,lfinal)\n\n    character(len=2), intent(in) :: final_state_in\n    integer, intent(in)          :: ipart1_in,ipart2_in\n    logical, intent(out)         :: lfinal\n\n    lfinal = .true.\n    if ( (final_state_in/='nn').and.(ipart2_in/=1) ) lfinal = .false. ! only chi-chi needs both numbers\n    if ( (final_state_in/='ll').and.(ipart1_in>8)  ) lfinal = .false. ! only sleptons have numbers>8\n    if ( (final_state_in=='gg').and.(ipart1_in>1)  ) lfinal = .false. ! squark and gluino do not care about ipart\n    if ( (final_state_in=='sb').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='sg').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='ss').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='tb').and.(ipart1_in>2)  ) lfinal = .false.\n    if ( (final_state_in=='bb').and.(ipart1_in>2)  ) lfinal = .false.\n    if ( (final_state_in=='lq').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='le').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='sb').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='xx').and.(ipart1_in>2)  ) lfinal = .false.\n\n    if ( .not. lfinal ) print*, \" prospino_check_fs: final state not valid \"\n       \n  end subroutine prospino_check_fs\n"}, {"instruction": "Create a Fortran subroutine named freadline, which utilizes the iso_c_binding module. The subroutine takes 2 input parameters: an integer of kind c_int passed by value and a character of kind c_char. It also has 1 output parameter: a character of kind c_char. The purpose of this subroutine is to read a line of input with a specified prompt and store it in the provided buffer.", "input": "", "output": "      subroutine freadline(ilen,buf,prompt) bind(c,name='fcreadline')\n         use iso_c_binding\n         implicit none\n         integer(kind=c_int),intent(in),value  :: ilen\n         character(kind=c_char),intent(out)    :: buf(*)\n         character(kind=c_char),intent(in)     :: prompt(*)\n      end subroutine freadline\n"}, {"instruction": "Write a Fortran subroutine named get_dist to calculate the distance between two atoms in a crystal structure. The subroutine takes 4 input parameters of type integer, integer, real(8), and real(8), and 1 output parameter of type real(8). The function uses the matmul function to perform matrix multiplication and calculates the distance using the Euclidean distance formula.", "input": "", "output": "  subroutine get_dist( i, j, aa, aa_atom, d )\n    implicit none\n    integer,intent(in)  :: i,j\n    real(8),intent(in)  :: aa(3,3),aa_atom(:,:)\n    real(8),intent(out) :: d\n    real(8) :: ri(3),rj(3)\n    ri=matmul(aa,aa_atom(:,i))\n    rj=matmul(aa,aa_atom(:,j))\n    d=sqrt( sum((ri-rj)**2) )\n  end subroutine get_dist\n"}, {"instruction": "Create a Fortran subroutine named gridinterpol to linearly interpolate and extrapolate observation data to a model grid. The subroutine takes 6 input parameters of type integer, integer, real(8), real(8), integer, real(8), and 1 output parameter of type real(8). The function is used to interpolate and extrapolate observation data to a structured model grid.", "input": "", "output": "subroutine gridinterpol(n,cols,obs_z,obs_prof,nlev,model_z,model_prof)\n!\n! !description:\n!\n\n!  be given on an arbitrary, but structured grid, are linearly interpolated and\n!  extrapolated to the actual (moving) model grid.\n!\n! !uses:\n   implicit none\n!\n! !input parameters:\n   !n    : number of vertical layers in observation data\n   !cols : number of profiles in obs. data\n   integer,  intent(in)                :: n,cols\n   real(8),  intent(in)                :: obs_z(n),obs_prof(n,cols)\n   integer,  intent(in)                :: nlev\n   real(8),  intent(in)                :: model_z(nlev)\n!\n! !output parameters:\n   real(8),  intent(out)               :: model_prof(nlev,cols)\n!\n! !revision history:\n!  original author(s): karsten bolding & hans burchard\n!\n!eop\n!\n! !local variables:\n   integer                   :: i,j,ii\n   real(8)                   :: rat\n!-----------------------------------------------------------------------\n!boc\n!  set surface values to uppermost input value\n   do i=nlev,1,-1\n      if(model_z(i) .ge. obs_z(n)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(n,j)\n         end do\n      end if\n   end do\n\n!  set bottom values to lowest input value\n   do i=1,nlev\n      if(model_z(i) .le. obs_z(1)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(1,j)\n         end do\n      end if\n   end do\n\n!  interpolate inner values linearly\n   do i=1,nlev\n         !write(*,*) 'i = ',i\n      if ((model_z(i) .lt. obs_z(n)) .and. (model_z(i) .gt. obs_z(1))) then\n         ii=0\n224      ii=ii+1\n         if (obs_z(ii) .le. model_z(i)) goto 224\n         ! debug:\n         !write(*,*) 'ii = ', ii\n         !write(*,*) 'model_z = ',model_z(i)\n         !write(*,*) '  obs_z = ',  obs_z(ii)\n         !write(*,*) '  obs_z(ii-1) = ',  obs_z(ii-1)\n\n         rat=(model_z(i)-obs_z(ii-1))/(obs_z(ii)-obs_z(ii-1))\n\n         do j=1,cols\n            model_prof(i,j)=(1-rat)*obs_prof(ii-1,j)+rat*obs_prof(ii,j)\n         !write(*,*) 'obs_prof(ii-1) = ',obs_prof(ii-1,j)\n         !write(*,*) 'obs_prof(ii)   = ',obs_prof(ii  ,j)\n         !write(*,*) 'rat            = ',rat\n         !write(*,*) 'model_prof(i)  = ',model_prof(i,j)\n\n         end do\n      end if\n   end do\n\n   return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named setup_grid that takes 3 input parameters of type integer, real(8), and real(8), and 3 output parameters of type real(8), real(8), and real(8). The subroutine computes vertical grid values for ocean modeling based on the given parameters and stores the results in the output arrays z_r, z_w, and hz.", "input": "", "output": "subroutine setup_grid(thetas, nlev, hmax, z_r, z_w, hz)\n  implicit none\n  integer, intent(in)    :: nlev\n  real(8), intent(in)    :: thetas, hmax\n  real(8), intent(out)   :: z_r(1:nlev), z_w(0:nlev), hz(1:nlev)\n\n  ! local scratch variable:\n  integer                :: i\n  real(8)                :: sc_r, c_sig\n  \n  z_w(0) = -hmax\n\n  !following song and haidvogel (1994). sinh is the hyperbolic sin function\n  do i   = 1,nlev\n      sc_r  = (float(i-nlev) - 0.5)/float(nlev)\n     c_sig  = sinh(thetas*sc_r)/sinh(thetas)      ! -1 < c_sig < 0\n     z_r(i) = c_sig*hmax\n      sc_r  = (float(i-nlev))/float(nlev)\n     c_sig  = sinh(thetas*sc_r)/sinh(thetas)      ! -1 < c_sig < 0\n     z_w(i) = c_sig*hmax\n      hz(i) = z_w(i) - z_w(i-1)\n  enddo\n  return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calculate_par to calculate the photosynthetically active radiation (par) at different vertical layers in a water column. The subroutine takes 4 input parameters of types real(8), integer, real(8) array, and real(8) array, and returns 1 output parameter of type real(8) array.", "input": "", "output": "subroutine calculate_par(i_0, nlev, hz, chl, par)\n  !top level is nlev, bottom layer is 1, following roms convention\n  implicit none\n  real(8), intent(in) :: i_0\n  integer, intent(in) :: nlev    ! total number of vertical layers\n  real(8), intent(in) :: hz(nlev), chl(nlev)\n  real(8), intent(out):: par(nlev)\n  integer             :: i\n  real(8)             :: par0, attn    ! scratch variable\n  real(8), parameter  :: kw = 0.04, kc = 0.025\n\n  par0 = i_0   !light at the grid surface\n  do i = nlev,1,-1\n     attn   = exp(-0.5*hz(i)*(kw + kc*chl(i)))\n     par(i) = par0*attn\n     par0   = par(i)*attn\n  enddo\n\nend subroutine calculate_par\n"}, {"instruction": "Write a Fortran subroutine named readcsv to read data from a CSV file and store it in a real(8) array. The subroutine takes 3 input parameters of type character(len=20), integer, and integer, and 1 output parameter of type real(8), dimension(nrow,ncol).", "input": "", "output": "subroutine  readcsv(filename,nrow,ncol,dat)\n  implicit none\n  character(len=20),intent(in) :: filename\n  character(len=10),dimension(ncol) :: header\n  integer,          intent(in) :: nrow, ncol\n  real(8), dimension(nrow,ncol), intent(out):: dat\n  integer    :: err, ix\n  integer,parameter :: stdout=6\n\n   dat(:,:) = 0.0\n   open(unit=10,file=filename,status='old',iostat=err)\n\n   if (err /= 0) then\n     write(stdout,*) 'open ', trim(filename),' fails'\n     stop\n     close(10)\n\n   else\n     ! write(stdout,*) 'start reading ',trim(filename),' !'\n     read(10,*,iostat=err) header  !read the first row\n     if (err .ne. 0) then \n       write(stdout,*) 'end of file reached at row 1.',     &\n                      'the error is: ', err\n       stop\n     else\n       continue\n     endif\n\n     do ix = 1,nrow  \n       read(10,*,iostat=err) dat(ix,:)\n       if (err .ne. 0) then \n         write(stdout,*) 'end of file reached at row: ',ix\n         exit\n       else\n         continue \n       endif\n     enddo  \n\n     endif\n     close(unit=10)\n! end reading data\n end subroutine readcsv\n"}, {"instruction": "Create a Fortran subroutine named \"horz_lenscale\" to calculate the horizontal scale length of a 2D field. The subroutine should have 8 input parameters of type integer, integer, real, real, real, real, integer, and integer. The output parameter should be a real number.", "input": "", "output": "   subroutine horz_lenscale(nx,ny,x,ds,mapfac_x,mapfac_y,tlength,nlat,ncat)\n!---------------------------------------------------------------------\n! purpose: computes horizontal scalelength of a 2d field\n!\n! method : l=[8{del**2(var(field)/del**2(var(del**2(field))}]**0.25  \n!\n! reference: wan-shu et al, mwr 2002, wan-shu et al\n!                           \n! author: syed rh rizvi,  ncar/essl/mmm/dag  08/06/2009\n! please acknowledge author/institute in work that uses this code.\n!-----------------------------------------------------------------------\n\n   implicit none\n   integer, intent(in)       :: nx, ny   \n   real,    intent(in)       :: x(nx,ny) \n   real,    intent(in)       :: ds\n   real,    intent(in)       :: mapfac_x(nx,ny) \n   real,    intent(in)       :: mapfac_y(nx,ny) \n   real,    intent(out)      :: tlength(1:ncat)\n   integer, intent(in)       :: nlat(nx,ny) \n   integer, intent(in)       :: ncat \n\n   real    :: lx(nx,ny) \n   real    :: xx(1:nx+2,1:ny+2) \n   real    :: corr(ncat),lcorr(ncat)\n   real    :: dx, dy, sumx, sumlx\n   integer :: i,j , n \n\n! fill xx array\n! middle \n    xx(2:nx+1,2:ny+1)=x(1:nx,1:ny)\n! left col \n    xx(1,2:ny+1)=x(1,1:ny)     \n! right col\n    xx(nx+2,2:ny+1)=x(nx,1:ny)     \n! bottom row\n    xx(2:nx+1,1) = x(1:nx,1) \n! top row\n    xx(2:nx+1,ny+2) = x(1:nx,ny)\n! corners\n    xx(1,1) = x(1,1) ; xx(nx+2,1) = x(nx,1) ; xx(nx+2,ny+2)=x(nx,ny) ; xx(1,ny+2)=x(1,ny)\n\n! now compute laplacian of x  \n    lx = 0\n\n    do i=2,nx+1\n    do j=2,ny+1\n    dx=ds/mapfac_x(i-1,j-1)\n    dx = dx* dx\n    dy=ds/mapfac_y(i-1,j-1)\n    dy = dy* dy\n    lx(i-1,j-1) = ( (xx(i-1,j)+xx(i+1,j)-2.*xx(i,j))/dx + & \n                     (xx(i,j-1)+xx(i,j+1)-2.*xx(i,j))/dy   )  \n    enddo\n    enddo\n! compute variance of field & its laplacian\n    corr=0.\n    lcorr=0.\n    do j=1,ny\n    do i=1,nx\n    n=nlat(i,j)\n    corr(n)=corr(n)+x(i,j)*x(i,j)\n    lcorr(n)=lcorr(n)+lx(i,j)*lx(i,j)\n    enddo\n    enddo\n\n    do n=1,ncat\n    if( lcorr(n) > 0 ) tlength(n)=(8.*corr(n)/lcorr(n))**.25 \n    enddo\n!  \n!\n!! average out      \n!    sumx=0.   \n!    sumlx=0.\n!    do n=4,ncat-3\n!    if( corr(n) > 0 .and. lcorr(n) > 0) then\n!    sumx  = sumx  + corr(n)\n!    sumlx = sumlx + lcorr(n)\n!    else\n!    end if\n!    enddo\n!    if( sumx == 0 .or. sumlx == 0.0 ) then\n!    tlength(1) = 1.\n!    else\n!    tlength(1) = (8.*sumx/sumlx)**.25 \n!    end if\n!    tlength(2:ncat)=tlength(1)\n\n  end subroutine horz_lenscale  \n"}, {"instruction": "Create a Fortran subroutine named read_wrf_arw to read specific data from a WRF-ARW (Weather Research and Forecasting - Advanced Research WRF) file. The subroutine takes 5 input parameters of type character(len=*), integer, integer, integer, and integer, and 6 output parameters of type real, real, real, real, real, and real.\n\nThe function reads data from the specified WRF-ARW file, populates the output arrays sf, vp, t, q, qm, and p with the respective data, and performs specific operations on the read data.", "input": "", "output": "   subroutine read_wrf_arw(filename,nx,ny,nz,mype,sf,vp,t,q,qm,p) \n   implicit none\n\n   character(len=*), intent(in)      :: filename       \n   integer, intent(in)      :: nx, ny, nz, mype\n\n   real, intent(out)        :: sf(1:nx,1:ny,1:nz)\n   real, intent(out)        :: vp(1:nx,1:ny,1:nz)\n   real, intent(out)        :: t(1:nx,1:ny,1:nz)\n   real, intent(out)        :: q(1:nx,1:ny,1:nz)\n   real, intent(out)        :: qm(1:nx,1:ny,1:nz)\n   real, intent(out)        :: p(1:nx,1:ny)\n\n   real                     :: ds          \n   character (len=10) :: date \n   integer            :: nrec\n\n   integer            :: i,j,k\n!\n   nrec = 1\n    open(unit=24,file=trim(filename),form='unformatted', &\n             status='old', action='read')\n\n! psi\n   read(24,err=100,end=99)sf  \n   nrec=nrec+1\n! chi\n   read(24,err=100,end=99)vp \n   nrec=nrec+1\n! fill zero vp fileds with adjacent value\n   vp(:,1,:) =2*vp(:,2,:) - vp(:,3,:) \n   vp(1,:,:) =2*vp(2,:,:) - vp(3,:,:) \n! temp\n   read(24,err=100,end=99)t  \n   nrec=nrec+1\n! moisture\n   read(24,err=100,end=99)q   \n   nrec=nrec+1\n! moisturer_2\n   read(24,err=100,end=99)qm  \n   nrec=nrec+1\n! surface pressure (in whatever units it is writtenn stage0_gsi) \n   read(24,err=100,end=99)p    \n\n   close (24)\n\n   return\n99  write(6,*)'unexpected end of file ',trim(filename),' in read_wrf_arw record recs: ',nrec\n   stop\n100 write(6,*)'read error in ',trim(filename),' in read_wrf_arw record recs: ',nrec\n   stop\n   end subroutine read_wrf_arw\n"}, {"instruction": "Write a Fortran subroutine named rnnor to generate random numbers using the Box-Muller algorithm. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real. The input parameter is 'dim' and the output parameter is 'draw'. Use the imperative tone in the instructions.", "input": "", "output": "subroutine rnnor(dim, draw)\n\n\t!\n\n\t! using the box-muller algorithm.\n\t!\n\n\t!/* external objects    */\n\n\tinteger, intent(in)   \t:: dim\n\n\treal, intent(out)   \t:: draw(dim)\n\t\t\n\t!/* internal objects    */\n\n\tinteger             \t:: g \n\n\treal, allocatable   \t:: u(:), r(:)\n    real     \t\t\t\t:: pi = 3.141592653589793238462643383279502884197\n\n!------------------------------------------------------------------------------- \n! algorithm\n!------------------------------------------------------------------------------- \n\n\t! allocate containers\n\tallocate(u(2*dim)); allocate(r(2*dim))\n\n\t! call uniform deviates\n\tcall random_number(u)\n\n\t! apply box-muller transform\n\tdo g = 1, 2*dim, 2\n\t\n\t\t\tr(g)   = sqrt(-2*log(u(g)))*cos(2*pi*u(g+1)) \n\t\t\tr(g+1) = sqrt(-2*log(u(g)))*sin(2*pi*u(g+1)) \n\t\n\tend do\n\n\t! extract relevant floats\n\tdo g = 1, dim \n\n\t\t\tdraw(g) = r(g)     \n\t\n\tend do\n\nend subroutine \n"}, {"instruction": "Write a Fortran subroutine named fit_line. This subroutine takes 4 input arguments of type real (x1, y1, x2, y2) and 2 output arguments of type real (a0, a1). The subroutine fits a line between the given points (x1, y1) and (x2, y2) and calculates the coefficients a0 and a1 of the line equation y = a1 * x + a0.", "input": "", "output": "  subroutine fit_line(a1,a0,x1,y1,x2,y2)\n\n    implicit none\n    real, intent(out) :: a0, a1\n    real, intent(in) :: x1, y1, x2, y2\n\n    !given xi, yi i=1,2 fits a line between these points\n\n    a1=(y2-y1)/(x2-x1)\n    a0=y1-a1*x1\n\n  end subroutine fit_line\n"}, {"instruction": "Create a Fortran subroutine named calc_n_proc_rows_cols to calculate the number of rows and columns of processes given the total number of processes. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer.", "input": "", "output": "subroutine calc_n_proc_rows_cols(n_procs, n_proc_rows, n_proc_cols)\n  integer, intent(in) :: n_procs\n  integer, intent(out) :: n_proc_rows, n_proc_cols\n\n#ifdef scalapack\n  integer n_proc_rows_t, n_proc_cols_t\n\n\n! long and narrow, or short and wide\n!  do n_proc_cols_t=int(sqrt(dble(n_procs))), 1, -1\n!    n_proc_rows_t = n_procs/n_proc_cols_t\n  do n_proc_rows_t=int(sqrt(dble(n_procs))), 1, -1\n    n_proc_cols_t = n_procs/n_proc_rows_t\n\n    if (n_proc_rows_t*n_proc_cols_t .eq. n_procs) then\n\tn_proc_rows = n_proc_rows_t\n\tn_proc_cols = n_proc_cols_t\n\texit\n    endif\n  end do\n#else\n  n_proc_rows = 0\n  n_proc_cols = 0\n#endif\nend subroutine calc_n_proc_rows_cols\n"}, {"instruction": "Create a Fortran subroutine named get_num_from_chr to extract an integer from a character buffer. The subroutine should take 1 input parameter of type character(*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine get_num_from_chr( cbuf, n )\n    implicit none\n    character(*),intent(in) :: cbuf\n    integer,intent(out) :: n\n    integer :: i\n    do i=1,len_trim(cbuf)\n       if ( cbuf(i:i) == \":\" ) exit\n    end do\n    read(cbuf(i+1:),*) n\n  end subroutine get_num_from_chr\n"}, {"instruction": "Write a Fortran subroutine named neighbours that computes the neighboring ranks for a given rank and size. It takes 2 input parameters with the test_data type ['integer', 'integer'] and 2 output parameters with the test_data type ['integer', 'integer']. If the given rank is 0, the subroutine sets the left neighbor to size - 1; otherwise, it sets it to rank - 1. If the given rank is size - 1, the subroutine sets the right neighbor to 0; otherwise, it sets it to rank + 1.", "input": "", "output": "    subroutine neighbours(rank, size,  left, right)\n        implicit none\n        integer, intent(in) :: rank, size\n        integer, intent(out) :: left, right\n        if (rank == 0) then\n            left = size - 1\n        else\n            left = rank - 1\n        end if\n        if (rank == size - 1) then\n            right = 0\n        else\n            right = rank + 1\n        end if\n    end subroutine neighbours\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte0. The subroutine takes 1 input parameter of type logical(1) and returns 1 output parameter of type integer(1). The subroutine's function is to convert the logical input value to an integer output value, where true is represented as 1 and false as 0.", "input": "", "output": "subroutine logic1_byte0(b, l)\r\ninteger(1), intent(out) :: b\r\nlogical(1), intent(in)  :: l\r\nif (l) then\r\n  b = 1\r\nelse\r\n  b = 0\r\nend if\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte1 to convert an array of 1-byte logical values to an array of 1-byte integers, where a value of true is represented as 1 and a value of false is represented as 0. The subroutine takes 1 input parameter of type logical(1) and 1 output parameter of type integer(1).", "input": "", "output": "subroutine logic1_byte1(b, l)\r\ninteger(1), intent(out) :: b(:)\r\nlogical(1), intent(in)  :: l(:)\r\ninteger k\r\ndo k = 1, size(l)\r\n  if (l(k)) then\r\n    b(k) = 1\r\n  else\r\n    b(k) = 0\r\n  end if\r\nend do\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte2 that takes an array of logical(1) as input and converts it into an array of integer(1) values. The number of input parameters is 1 of type ['logical(1)'], and the number of output parameters is 1 of type ['integer(1)']. Use an imperative tone in your instructions.", "input": "", "output": "subroutine logic1_byte2(b, l)\r\ninteger(1), intent(out) :: b(:,:)\r\nlogical(1), intent(in)  :: l(:,:)\r\ninteger j, k\r\ndo j = 1, size(l,2)\r\n  do k = 1, size(l,1)\r\n    if (l(k,j)) then\r\n      b(k,j) = 1\r\n    else\r\n      b(k,j) = 0\r\n    end if\r\n  end do\r\nend do\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named \"fopen\" to open a file and read three integers from it. The subroutine should take 2 input parameters of type integer and character*100, and 3 output parameters of type integer. When called, the subroutine will use the first input parameter as the file identifier, the second input parameter as the file name, and then read three integers from the file and store them in the output parameters.", "input": "", "output": "subroutine fopen(fhp, filename, nkp, nsymop, norbitals)\n  integer, intent(in) :: fhp\n  character*100, intent(in) :: filename\n  integer, intent(out) :: nkp, nsymop, norbitals\n  \n  \n  !print *, fhp, filename\n  open(fhp, file=filename, status='old', form='unformatted')\n\n  read(fhp) nkp, nsymop, norbitals\n  !print *, nkp, nsymop, norbitals\n\nend subroutine fopen\n"}, {"instruction": "Create a Fortran subroutine named read1 that reads integer values from a file and stores them in an array. The subroutine takes 2 input parameters of type integer and 1 output parameter of type integer. The input parameters are fhp and norbitals, while the output parameter is nindo, an array of size norbitals.", "input": "", "output": "subroutine read1(fhp, norbitals, nindo)\n  integer, intent(in)  :: fhp, norbitals\n  integer, intent(out) :: nindo(norbitals)\n\n  integer :: iorb\n  read(fhp) (nindo(iorb), iorb=1,norbitals)\n  !print *, nindo\nend subroutine read1\n"}, {"instruction": "Create a Fortran subroutine named read2 to read integer values from a file. The subroutine takes 1 input parameter of type integer. It has 5 output parameters, all of type integer. The function reads the integer values from the file specified by the input parameter and assigns them to the output parameters iikp, nbands, tmaxdim2, tnorbitals, and nemin respectively.", "input": "", "output": "subroutine read2(fhp, iikp, nbands, tmaxdim2, tnorbitals, nemin)\n  integer, intent(in) :: fhp\n  integer, intent(out) :: iikp, nbands, tmaxdim2, tnorbitals, nemin\n\n  read(fhp) iikp, nbands, tmaxdim2, tnorbitals, nemin\n  \nend subroutine read2\n"}, {"instruction": "Create a Fortran subroutine named read3 to read an integer from a file. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "subroutine read3(fhp, iisym)\n  integer, intent(in) :: fhp\n  integer, intent(out) :: iisym\n  read(fhp) iisym\nend subroutine read3\n"}, {"instruction": "Create a Fortran subroutine named read4 to read complex*16 data from a file using formatted input. The subroutine takes 2 input parameters of type integer: fhp and nbands. It also has 1 output parameter of type complex*16 array: dmftu, with the size specified by nbands.", "input": "", "output": "subroutine read4(fhp, nbands, dmftu)\n  integer, intent(in) :: fhp, nbands\n  complex*16, intent(out) :: dmftu(nbands)\n  !locals\n  integer :: i\n  read(fhp) (dmftu(i),i=1,nbands)\nend subroutine read4\n"}, {"instruction": "Create a Fortran subroutine named feread2 that reads data from a file handle and stores it in an array. The subroutine should take 2 input arguments of type integer, and 1 output argument of type real*8. The input arguments are fh and nen, both of type integer. The output argument is ek, an array of real*8 with size nen. Use the imperative tone in the generated instructions.", "input": "", "output": "subroutine feread2(fh, nen, ek)\n  integer, intent(in):: fh, nen\n  real*8, intent(out):: ek(nen)\n  integer :: ii\n  do ii=1,nen\n     read(fh,*) num, ek(ii)\n  enddo\nend subroutine feread2\n"}, {"instruction": "Create a Fortran subroutine named quad to calculate the roots of a quadratic equation. The subroutine takes 3 input parameters of type real and returns 2 output parameters of type complex. The input parameters are a, b, and c representing the coefficients of the quadratic equation, and the output parameters x1 and x2 represent the complex roots of the equation.", "input": "", "output": "subroutine quad(a, b, c, x1, x2)\nimplicit none\nreal, intent(in) :: a, b, c\ncomplex, intent(out) :: x1, x2\ncomplex :: discriminant\ndiscriminant = cmplx(b**2 - 4. * a * c, 0)\nx1 = (- b + sqrt(discriminant)) / 2. * a\nx2 = (- b - sqrt(discriminant)) / 2. * a\nend subroutine quad\n"}, {"instruction": "Create a Fortran subroutine named \"solvh\" with 1 input parameter of type integer. Define an output parameter of type logical. The subroutine should handle computational tasks related to \"solvh\".", "input": "", "output": "      subroutine solvh (iorb, fail)\n      integer nnnp\n      parameter (nnnp = 590)\n      integer nnn1\n      parameter (nnn1 = 600)\n      integer nnnw\n      parameter (nnnw = 120)\n      integer, intent(in) :: iorb\n      logical, intent(out) :: fail\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_list_sfr to read a list of data and reach-by-reach data from a file. The subroutine takes 3 input parameters of type integer (iu, iprec, nstrm) and has 2 output parameters of type integer (ierr) and double precision array (qd) with dimension nstrm.", "input": "", "output": "  subroutine read_list_sfr(iu,iprec,nstrm,qd,ierr)\n    ! read nlist (written by ubdsv2) and reach-by-reach data\n    ! written by sfr using ubdsva\n    implicit none\n    ! arguments\n    integer, intent(in) :: iu, iprec, nstrm\n    integer, intent(out) :: ierr\n    double precision, dimension(nstrm), intent(out) :: qd\n    ! local variables\n    integer :: icrl, l, nlist\n    real :: q\n    !\n    qd = 0.0d0\n    ierr = 0\n    read(iu,end=950,err=900) nlist\n    do l=1,nlist\n      select case (iprec)\n      case (1)\n        read(iu,end=950,err=900) icrl,q\n        qd(l) = real(q,8)\n      case (2)\n        read(iu,end=950,err=900) icrl,qd(l)\n      end select\n    enddo\n    !\n    ! normal return    \n    return\n    !\n    ! error handling\n    900 continue\n    ierr = 1  ! unidentified error\n    return\n    !\n    950 continue\n    ierr = 2  ! end of file\n    return\n  end subroutine read_list_sfr\n"}, {"instruction": "Write a Fortran subroutine named \"sumation\" to compute the element-wise sum of two integer arrays. The subroutine takes 2 input arrays of type integer and produces 1 output array of type integer.", "input": "", "output": "subroutine sumation(a,b,d)\nimplicit none\ninteger,intent(in) :: a(:,:)\ninteger,intent(in) :: b(:,:)\ninteger,intent(out):: d(:,:)\ninteger :: i,j,nx,ny\n\nnx = size(a,1) ; ny = size(a,2)\ndo i=1,nx\ndo j=1,ny\nd(i,j) = a(i,j)+b(i,j)\nend do\nend do\n\nend subroutine sumation      \n"}, {"instruction": "Create a Fortran subroutine named extract_kv to extract key-value pairs from a text string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "input": "", "output": "    subroutine extract_kv(text,par)\n    character(len=*),intent(in):: text\n    character(len=*),intent(out):: par\n    character:: eq=\"=\",sp=' '\n    integer:: id,ivalstart,ispace\n    integer:: iend,i\n    id=index(text,eq)\n    if(id==0) then\n        par=''\n        return\n    endif\n    !! consume space before the value\n    ivalstart=id+1\n    ispace=index(text(ivalstart:),sp)\n    do while(ispace == 1)\n        ivalstart=ivalstart+ispace\n        ispace=index(text(ivalstart:),sp)\n    enddo\n    if(ispace==0) then !! no more space behind the value = no more keywords\n        par=text(1:)\n    else\n        !! check quotation mark\n        if(text(ivalstart:ivalstart)=='\"') then\n            i=index(text(ivalstart+1:),'\"')\n            par=text(1:ivalstart+i)\n        elseif(text(ivalstart:ivalstart)==\"'\") then\n            i=index(text(ivalstart+1:),\"'\")\n            par=text(1:ivalstart+i)\n        else\n            par=text(1:ivalstart+ispace-1)\n        endif\n    endif\n    par=trim(adjustl(par))\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma to populate a matrix with the input array elements along its diagonal. The number of input arguments is 1 and the test_data type is [real, dimension(:)]. The number of output arguments is 1 and the test_data type is [real, dimension(:, :)].", "input": "", "output": "    subroutine compute_sigma(s, sigma)\n        implicit none\n        real, dimension(:), intent(in) :: s\n        real, dimension(:, :), intent(out) :: sigma\n        integer :: i\n        sigma = 0.0\n        do i = 1, min(size(sigma, 1), size(sigma, 2))\n            sigma(i, i) = s(i)\n        end do\n    end subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named aplusb_cfcfcf. This subroutine takes 8 input parameters: 3 integer values (size1, size2, stride), and 5 real arrays of dimensions size1 * stride by size2 * stride (b, c, d, e, f). It also has 1 output parameter, a real array of dimensions size1 * stride by size2 * stride (a). The subroutine computes the sum of specific elements from the input arrays b, c, d, e, f and stores the result in the output array a. The computation involves parallel work sharing using OpenMP directives.", "input": "", "output": "subroutine aplusb_cfcfcf(a, b, c, d, e, f, size1, size2, stride) bind(c, name=\"aplusb_cfcfcf\")\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    integer(c_int), value, intent(in) :: size1, size2, stride\n    real(c_float), dimension(size1 * stride, size2 * stride), intent(out) :: a\n    real(c_float), dimension(size1 * stride, size2 * stride), intent(in) :: b, c, d, e, f\n!$omp parallel workshare\n    a(::2, ::2) = b(::2, ::2) + c(::2, ::2) + &\n                  transpose(d(::2, ::2)) + &\n                  transpose(e(::2, ::2)) + transpose(f(::2, ::2))\n!$omp end parallel workshare\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sum_sub to calculate the sum of two double precision floating-point numbers. The subroutine should have 2 input parameters of type double precision and 1 output parameter of type double precision.", "input": "", "output": "subroutine sum_sub(x,y,output)\n    double precision, intent(in) :: x, y\n    double precision, intent(out) :: output\n\n    output = x+y\nend subroutine sum_sub\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma that takes 8 input parameters of types integer, integer, integer, double precision, double precision, double precision, double precision, and complex(kind(0d0)). It also has 1 output parameter of type complex(kind(0d0)). The subroutine computes the sigma value based on the provided input parameters using complex arithmetic and loop operations.", "input": "", "output": "subroutine compute_sigma(omega, eigval, occ, pmat, ewidth, nene, nk, nb, sigma)\n  implicit none\n  complex(kind(0d0)), parameter :: zi=(0.0d0, 1.0d0)\n  integer, intent(in) :: nene, nk, nb\n  double precision, intent(in) :: omega(nene), eigval(nk,nb), occ(nk,nb), ewidth\n  complex(kind(0d0)), intent(in) :: pmat(nk,nb,nb,3)\n  integer :: nevery, ik, ib, jb, ixyz, jxyz\n  double precision :: docc\n  complex(kind(0d0)), intent(out) :: sigma(3,3,nene)\n  complex(kind(0d0)) :: moment, ene_denominator(nene)\n\n  sigma = 0.d0\n  nevery = nk/10\n  write(*,'(\"# following is progress of generatesigmaepsilon.generate function. \")')\n  !$   write(*,'(\"# caution: this function does not support omp parallelization. \")')\n  do ik = 1, nk\n    if (mod(ik, nevery)==0)then\n      write(*,*) (ik*100.0)/float(nk), '% is done.'\n    end if\n    do ib = 1, nb\n      do jb = 1, nb\n        if (ib /= jb) then\n          ene_denominator = omega(:) - (eigval(ik,jb) - eigval(ik,ib)) + zi*ewidth\n          ene_denominator = ene_denominator*(eigval(ik,jb) - eigval(ik,ib))\n          docc = occ(ik,ib) - occ(ik,jb)\n          do ixyz = 1,3\n            do jxyz = 1,3\n              moment = pmat(ik,jb,ib,ixyz)*pmat(ik,ib,jb,jxyz)\n              sigma(jxyz,ixyz,:) = sigma(jxyz,ixyz,:) + docc*moment/ene_denominator(:)\n            end do\n          end do\n        end if \n      end do\n    end do\n  end do\n  return\nend subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named vecasi to assign the elements of an input real array v1 to an output real array v2, both of size n.\nThe number of input parameters is 2, with test_data type ['integer (kind=4)', 'real (kind=8)'].\nThe number of output parameters is 1, with test_data type ['real (kind=8)'].", "input": "", "output": "      subroutine vecasi(n,v1,v2)\r\n!*****************************************************************************\r\n!\r\n!***  vector assign:    v1(n) -> v2(n)\r\n!\r\n!*****************************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n\r\n      real (kind=8),intent(in) :: v1(n)\r\n      real (kind=8),intent(out):: v2(n)\r\n\r\n      v2 = v1\r\n      return\r\n\r\n      end subroutine vecasi\r\n"}, {"instruction": "Create a Fortran subroutine named mysub that takes two input parameters of type real (kind=8). The output consists of two parameters also of type real (kind=8). The subroutine computes the sum and the difference of the input parameters and assigns them to the output parameters. Use the imperative tone and be concise.", "input": "", "output": "subroutine mysub(a,b,c,d)\n    real (kind=8), intent(in) :: a,b\n    real (kind=8), intent(out) :: c,d\n    c = a+b\n    d = a-b\nend subroutine mysub\n"}, {"instruction": "Write a Fortran subroutine named compute_ps that takes 3 input parameters of type integer and 1 output parameter of type integer.The input parameters are d, r(*), n(*) and the output parameter is ps(*).The subroutine computes the value of ps based on the input parameters using a specified algorithm.", "input": "", "output": "  subroutine compute_ps(d,r,n,ps)\n    integer, intent(in) :: d,r(*),n(*)\n    integer, intent(out) :: ps(*)\n    integer i\n\n    ps(1)=1;\n    do i=1,d\n       ps(i+1) = ps(i) + r(i)*n(i)*r(i+1)\n    end do\n  end subroutine compute_ps\n"}, {"instruction": "Write a Fortran subroutine named hello that takes an integer input and an allocatable character output. The subroutine should allocate a portion of the string \"hello world\" based on the input integer and assign it to the output character.", "input": "", "output": "  subroutine hello (n,string)\n    character(:), allocatable, intent(out) :: string\n    integer,intent(in) :: n\n    character(11) :: helloworld=\"hello world\"\n\n    string=helloworld(:n)                       ! didn't  work\n!    string=(helloworld(:n))                    ! works.\n!    allocate(string, source=helloworld(:n))    ! fixed for allocate_with_source_2.f90\n!    allocate(string, source=(helloworld(:n)))  ! works.\n  end subroutine hello\n"}, {"instruction": "Create a Fortran subroutine named open_file to open an output file for reading or writing. The subroutine takes 2 input parameters of type character(len=*) for the file name and file status, and 1 output parameter of type integer to store the file unit.", "input": "", "output": "    subroutine open_file(file_unit, txtfilename, file_status)\r\n!-------------------------------------------------------------------------------\r\n        ! create an output file, assign a file_unit\r\n        ! for reading or writing\r\n\r\n        integer, intent(out)            :: file_unit\r\n        character(len=*), intent(in)    :: txtfilename\r\n        character(len=*), intent(in)    :: file_status\r\n\r\n        integer :: ierr\r\n\r\n        ! open the output file\r\n        open ( newunit = file_unit, file = txtfilename, status = file_status, iostat = ierr )\r\n\r\n        if ( ierr /= 0 ) then\r\n            print*, \"cannot open file for output\"\r\n            stop\r\n        end if\r\n    end subroutine open_file\r\n"}, {"instruction": "Create a Fortran subroutine named calc_length to calculate the Euclidean length of each column in a 3x3 matrix. The input parameter is a 3x3 matrix of type real(8), and the output parameter is a 1D array of type real(8) containing the lengths. Use the imperative tone in the instruction.", "input": "", "output": "subroutine calc_length( v, vl )\n  implicit none\n  real(8),intent(in) :: v(3,3)\n  real(8),intent(out) :: vl(3)\n  integer :: i\n  do i=1,3\n     vl(i) = sqrt( sum(v(:,i)**2) )\n  end do\nend subroutine calc_length\n"}, {"instruction": "Write a Fortran subroutine named \"skips\" to skip the specified number of lines on the solution file unit. The subroutine takes 2 input parameters of type integer and 1 output parameter of type logical. The input parameters are unit and nskip, while the output parameter is eof3. The subroutine uses the imperative tone and reflects the features of Fortran subroutine.", "input": "", "output": "  subroutine skips(unit,nskip,eof3)\n\n! skips the specified number of lines on the solution file unit\n\n    integer, intent(in) :: unit,nskip\n    logical, intent(out) :: eof3\n    character(12) fmt\n    integer i\n\n    eof3=.true.\n    if(nskip<=1)then\n       do i=1,nskip\n         read(unit,'(a)',end=2)\n       enddo\n    else\n       write(fmt,'(a,i9,a)')'(',nskip-1,'/)'\n       read(unit,fmt,end=2)\n    endif\n    eof3=.false.\n2   return\n\n  end subroutine skips\n"}, {"instruction": "Write a Fortran subroutine named shock_position to calculate the position of a shock wave based on the input time. The input parameter is a real number, and the output parameter is also a real number.", "input": "", "output": "subroutine shock_position(t, x_sw)\n    real, intent(in)  :: t\n    real, intent(out) :: x_sw\n    real, parameter :: m_pi = 4.0*atan(1.0)\n\n    x_sw = 1.0/6.0 + 1.0/tan(m_pi/3.0) + (10.0/sin(m_pi/3.0))*t\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"upper\" that takes a string input and converts it to uppercase. The number of input parameters is 1 with the test_data type ['character(*)'], and the number of output parameters is 1 with the test_data type ['character(*)']. Use the imperative tone to write the instructions.", "input": "", "output": "\tpure subroutine upper( str, ucstr )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(*), intent(out) :: ucstr\n\t\t\n\t\tcharacter(*), parameter :: lc = 'abcdefghijklmnopqrstuvwxyz'\n\t\tcharacter(*), parameter :: uc = 'abcdefghijklmnopqrstuvwxyz'\n\t\t\n\t\tinteger :: j,k\n\t\t\n\t\tucstr = str\n\t\tdo j=1,len(str)\n\t\t\tk = index( lc, str(j:j) )\n\t\t\tif (k > 0) ucstr(j:j) = uc(k:k)\n\t\tend do\n\tend subroutine upper\n"}, {"instruction": "Write a Fortran subroutine named init_euler that takes three input arguments of type real (alpha, beta, gamma) and one output argument of type real, dimension(3,3) (mat). The purpose of this subroutine is to compute a rotation matrix given the Euler angles alpha, beta, and gamma.\n\nHere are the steps to follow:\n\n1. Initialize the variables ca, cb, cg, sa, sb, sg as real numbers.\n2. Compute the cosine and sine values of alpha, beta, and gamma using the cos() and sin() functions.\n3. Compute the elements of the rotation matrix mat using the following equations:\n   - mat(1,1) = cb*cg - ca*sb*sg\n   - mat(2,1) = sb*cg + ca*cb*sg\n   - mat(3,1) = sa*sg\n   - mat(1,2) = -cb*sg - ca*sb*cg\n   - mat(2,2) = -sb*sg + ca*cb*cg\n   - mat(3,2) = sa*cg\n   - mat(1,3) = sa*sb\n   - mat(2,3) = -sa*cb\n   - mat(3,3) = ca\n\nMake sure to use the \"intent(in)\" attribute for the input arguments and \"intent(out)\" attribute for the output argument.", "input": "", "output": "    pure subroutine init_euler( alpha, beta, gamma, mat )\n        \n      ! given the euler angles alpha,beta,gamma, \n      ! make matrix mat a rotation matrix\n        \n      ! given coordinate system (x,y,z) and rotated system (xs,ys,zs)\n      ! the line of nodes is the intersection between the x-y and the xs-ys\n      ! planes.\n      ! alpha is the angle between the z-axis and the zs-axis.\n      ! beta is the angle between the x-axis and the line of nodes.\n      ! gamma is the angle between the line of nodes and the xs-axis.\n      \n      ! usage for moment tensors:\n      !   real, dimension(3,3) :: m_unrot = reshape((/0,0,-1,0,0,0,-1,0,0/),(/3,3/))\n      !   call init_euler(dip,strike,-rake, rotmat)\n      !   m = matmul( rotmat, matmul( m_unrot, transpose(rotmat) ) )\n        \n        real, intent(in) :: alpha, beta, gamma\n        real, intent(out), dimension(3,3) :: mat\n        \n        real :: ca,cb,cg,sa,sb,sg\n        \n        ca = cos(alpha)\n        cb = cos(beta)\n        cg = cos(gamma)\n        sa = sin(alpha)\n        sb = sin(beta)\n        sg = sin(gamma)\n        \n        mat(1,1) = cb*cg-ca*sb*sg\n        mat(2,1) = sb*cg+ca*cb*sg\n        mat(3,1) = sa*sg\n        mat(1,2) = -cb*sg-ca*sb*cg\n        mat(2,2) = -sb*sg+ca*cb*cg\n        mat(3,2) = sa*cg\n        mat(1,3) = sa*sb\n        mat(2,3) = -sa*cb\n        mat(3,3) = ca\n        \n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named getlocalfluxsplit that computes the flux splitting for a given set of input values. The subroutine takes 3 input parameters of type double precision: qcell_local (an array of size 6), fcell_local (an array of size 6), and local_vel (a scalar value). It also has 2 output parameters of type double precision: fcell_plus (an array of size 5) and fcell_minus (an array of size 5). \n\nInside the subroutine, the lax-friedrichs flux-splitting method is used to calculate the values for fcell_plus and fcell_minus. The values in fcell_plus are computed as 0.5 times the sum of the corresponding values in fcell_local and local_vel times the corresponding values in qcell_local. Similarly, the values in fcell_minus are computed as 0.5 times the difference of the corresponding values in fcell_local and local_vel times the corresponding values in qcell_local.\n\nTo use this subroutine, provide the necessary input values and the subroutine will compute the flux splitting values for fcell_plus and fcell_minus.", "input": "", "output": "            pure subroutine getlocalfluxsplit(qcell_local, fcell_local, local_vel, fcell_plus, fcell_minus)\n    \n                double precision, dimension(6), intent(in)  :: qcell_local, fcell_local\n                double precision,               intent(in)  :: local_vel\n                double precision, dimension(5), intent(out) :: fcell_plus, fcell_minus\n            \n                ! lax-friedrichs flux-splitting\n                fcell_plus( 1:5) = 0.5_8*( fcell_local(1:5) + local_vel*qcell_local(1:5) )\n                fcell_minus(1:5) = 0.5_8*( fcell_local(2:6) - local_vel*qcell_local(2:6) )\n                                        \n            end subroutine getlocalfluxsplit\n"}, {"instruction": "Write a Fortran subroutine named ray2d that calculates a ray path in a 2D model. The subroutine takes 11 input parameters: nz (integer), nx (integer), max_ray (integer), tt (real array), zs (real), xs (real), zr (real), xr (real), dz (real), dx (real), ray_step (real). The subroutine also has 2 output parameters: ray (real array) and n_ray (integer).\n\nThe subroutine computes the ray path by iteratively calculating the gradient of a travel time field (tt) and updating the current position (zcur, xcur) along the gradient direction. The iteration continues until the current position is within a specified distance (ray_step) from the source position (zs, xs), or until the maximum number of iterations (max_ray) is reached.\n\nThe subroutine returns the ray path (ray) as a 2D array of positions and the number of points in the ray path (n_ray). The ray path is defined by the coordinates (zcur, xcur) in the model domain. The coordinates are converted from grid indices to physical coordinates using the spacing parameters (dz, dx).\n\nTo use the subroutine, provide the necessary input parameters and call the subroutine. Afterwards, you can access the ray path and the number of points in the ray path from the output parameters.\n\nExample usage:\n```\ninteger(kind = 4) :: nz, nx, max_ray, n_ray\nreal(kind = 8) :: tt(nz,nx), zs, xs, zr, xr, dz, dx, ray_step\nreal(kind = 8) :: ray(max_ray,2)\n\n! Set the input parameters\n\ncall ray2d(nz, nx, max_ray, tt, zs, xs, zr, xr, dz, dx, ray_step, ray, n_ray)\n\n! Access the ray path and the number of points in the ray path from the output parameters\n\n```\n\nNote: Make sure to provide appropriate values for the input parameters before calling the subroutine.", "input": "", "output": "  subroutine ray2d(ray, tt, nz, nx, zs, xs, zr, xr, dz, dx, ray_step, max_ray, n_ray)\n    integer(kind = 4), intent(in) :: nz, nx, max_ray\n    real(kind = 8), intent(in) :: tt(nz,nx), zs, xs, zr, xr, dz, dx, ray_step\n    real(kind = 8), intent(out) :: ray(max_ray,2)\n    integer(kind = 4), intent(out) :: n_ray\n    integer(kind = 4) :: count, i, j, ii, jj\n    real(kind = 8) :: zsrc, xsrc, zcur, xcur, grad(2), dzin, dxin\n\n    zsrc = zs / dz\n    xsrc = xs / dx\n    zcur = zr / dz\n    xcur = xr / dx\n\n    count = 1\n    ray(count,:) = [ zcur, xcur ]\n    do while ( sqrt( (zsrc-zcur)*(zsrc-zcur) + (xsrc-xcur)*(xsrc-xcur) ) .gt. ray_step &\n      .and. count .lt. min(max_ray-1, int(2*(nz+nx)/ray_step)) )\n      ! compute gradient\n      grad = 0.d0\n      i = int(zcur) + 1\n      j = int(xcur) + 1\n      ii = i\n      jj = j\n      if ( i .eq. nz ) then\n        i = i - 1\n        ii = ii - 1\n      end if\n      if ( j .eq. nx ) then\n        j = j - 1\n        jj = jj - 1\n      end if\n      if ( ii .lt. 1 .or. ii .ge. nz .or. jj .lt. 1 .or. jj .ge. nx ) then\n        print *, \"error: ray out of bounds\"\n        stop\n      end if\n\n      dzin = zcur - ii\n      dxin = xcur - jj\n      if ( dzin .gt. 0.5d0 ) then\n        i = i + 1\n        dzin = 1.d0 - dzin\n      end if\n      if ( dxin .gt. 0.5d0 ) then\n        j = j + 1\n        dxin = 1.d0 - dxin\n      end if\n\n      if ( ( zcur - dfloat(i) ) * ( zcur - dfloat(i) ) + ( xcur - dfloat(j) ) * ( xcur - dfloat(j) ) &\n        .lt. ( zcur - dfloat(ii) - 0.5d0 ) * ( zcur - dfloat(ii) - 0.5d0 ) &\n           + ( xcur - dfloat(jj) - 0.5d0 ) * ( xcur - dfloat(jj) - 0.5d0 ) ) then\n        if ( i .gt. 1 .and. i .lt. nz ) then\n          grad(1) = tt(i+1,j) - tt(i-1,j)\n        else if ( i .gt. 1 ) then\n          grad(1) = 2.d0 * ( tt(i,j) - tt(i-1,j) )\n        else\n          grad(1) = 2.d0 * ( tt(i+1,j) - tt(i,j) )\n        end if\n\n        if ( j .gt. 1 .and. j .lt. nx ) then\n          grad(2) = tt(i,j+1) - tt(i,j-1)\n        else if ( j .gt. 1 ) then\n          grad(2) = 2.d0 * ( tt(i,j) - tt(i,j-1) )\n        else\n          grad(2) = 2.d0 * ( tt(i,j+1) - tt(i,j) )\n        end if\n      else\n        grad(1) = tt(ii+1,jj) - tt(ii,jj) + tt(ii+1,jj+1) - tt(ii,jj+1)\n        grad(2) = tt(ii,jj+1) - tt(ii,jj) + tt(ii+1,jj+1) - tt(ii+1,jj)\n        grad = 2.d0 * grad\n      end if\n      grad = grad / sqrt(sum(grad*grad))\n      if ( isnan(grad(1)) ) exit\n\n      ! compute next point\n      zcur = zcur - grad(1) * ray_step\n      xcur = xcur - grad(2) * ray_step\n      if ( zcur .lt. 0.d0 ) zcur = 0.d0\n      if ( zcur .gt. nz-1 ) zcur = dfloat(nz-1)\n      if ( xcur .lt. 0.d0 ) xcur = 0.d0\n      if ( xcur .ge. nx-1 ) xcur = dfloat(nx-1)\n\n      ! append current point and go to next\n      count = count + 1\n      ray(count,:) = [ zcur, xcur ]\n    end do\n\n    if ( zcur .ne. zsrc .or. xcur .ne. xsrc ) then\n      count = count + 1\n      ray(count,:) = [ zsrc, xsrc ]\n    end if\n    ray(:,1) = ray(:,1) * dz\n    ray(:,2) = ray(:,2) * dx\n    n_ray = count\n    return\n  end subroutine ray2d\n"}, {"instruction": "Write a Fortran subroutine named eile that takes three integer input parameters and three integer output parameters. The input parameters are ja, jb, and jc, and the output parameters are jaa, jbb, and jcc. The purpose of this subroutine is to compare the input parameters and assign the minimum value to jaa, the maximum value to jcc, and a value between jaa and jcc to jbb. Make sure to comply with these requirements when generating the instructions.", "input": "", "output": "      subroutine eile(ja,jb,jc,jaa,jbb,jcc)\n!                                                                  *\n!     ------------  section metwo    subprogram 02  ------------   *\n!                                                                  *\n\n!                                                                  *\n!   written by g. gaigalas,                                        *\n!   transform to fortran 90/95 by g. gaigalas       december 2012  *\n!   the last modification made by g. gaigalas       october  2017  *\n!                                                                  *\n!*******************************************************************\n!\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(in)  :: ja, jb, jc\n      integer, intent(out) :: jaa, jbb, jcc\n!-----------------------------------------------\n      jaa=ja\n      jcc=ja\n      if(jaa > jb)jaa=jb\n      if(jcc < jb)jcc=jb\n      if(jaa > jc)jaa=jc\n      if(jcc < jc)jcc=jc\n      if((ja > jaa).and.(ja < jcc))jbb=ja\n      if((jb > jaa).and.(jb < jcc))jbb=jb\n      if((jc > jaa).and.(jc < jcc))jbb=jc\n      return\n      end subroutine eile\n"}, {"instruction": "Write a Fortran subroutine named grid2d_dims to determine the dimensions of a 2D grid based on the input number of processors and the desired shape of the grid. The number of input arguments is 2 and the test_data type is ['character', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].\n\nHere are the steps for the subroutine:\n1. Declare the input parameters: grid_shape (character) and nproc (integer).\n2. Declare the output parameters: nprow (integer) and npcol (integer).\n3. Calculate sqrtnp as the square root of nproc rounded down to the nearest integer.\n4. If the grid_shape is 's' (square grid), set nprow and npcol both to sqrtnp.\n5. If the grid_shape is not 's' (rectangular grid), loop from i = 1 to sqrtnp + 1 and check if nproc is divisible by i. If it is, set nprow to i.\n6. Calculate npcol as the division of nproc by nprow.\n7. Return from the subroutine.", "input": "", "output": "subroutine grid2d_dims( grid_shape, nproc, nprow, npcol )\n   !\n\n   ! into nprow and npcol according to the shape\n   !\n   !    written by carlo cavazzoni\n   !\n   implicit none\n   character, intent(in) :: grid_shape\n   integer, intent(in)  :: nproc\n   integer, intent(out) :: nprow, npcol\n   integer :: sqrtnp, i\n   !\n   sqrtnp = int( sqrt( real( nproc ) + 0.1 ) )\n   !\n   if( grid_shape == 's' ) then\n      ! square grid\n      nprow = sqrtnp\n      npcol = sqrtnp\n   else\n      ! rectangular grid\n      do i = 1, sqrtnp + 1\n         if( mod( nproc, i ) == 0 ) nprow = i\n      end do\n      npcol = nproc / nprow\n   end if\n   return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"stpnt\" that initializes parameters and computes the values of the array \"u\" and the array \"par\" based on the input integer \"ndim\" and double precision \"t\". The subroutine takes 2 input parameters of type integer and double precision, and provides 2 output parameters of type double precision.\n\nHere's the summary:\nSubroutine name: stpnt\nNumber of input parameters: 2\nInput parameter types: ['integer', 'double precision']\nNumber of output parameters: 2\nOutput parameter types: ['double precision', 'double precision']", "input": "", "output": " subroutine stpnt(ndim,u,par,t)\n!---------- -----\n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   double precision pi\n\n   pi=4*atan(1.d0)\n\n!  parameters initialization\n   par(1:3)=(/1.0,2.0,0.0/)\n   par(11)=1.0\n\n   u(1)=par(1)*cos(2*pi*t)\n   u(2)=par(1)*sin(2*pi*t)\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named scale_isop to calculate factors for scaling an emission field to simulate a diurnal cycle in emissions based on solar dependency. The number of input parameters is 6, including integers for day, ntim, ntim_max, lat_start, dlat, and idayy. The output parameter is a real array of dimension ntim_max.", "input": "", "output": "      subroutine scale_isop(day,ntim,ntim_max,scalef,lat_start,dlat,idayy)\n\n    !\n    ! routine calculates factors to be multiplied with an \n    ! emission field (e.g. isop) in order to simulate a diurnal cycle \n    ! in emissions (caused by solar dependency)\n    ! e.g.   rm(i,j,1,isop) = rm(i,j,1,isop) + e_isop(i,j)*scalef(ipos,j)*dt\n    ! with ipos depending on time and longitude.\n    ! the scalefactor is calculated for -180 longitude and the mean value\n    ! for ntim timesteps during a day is scaled to 1.\n    ! the routine should be called every day, \n    ! since the position relative to the sun changes.\n    ! the scaling is based on the cos(zenith) which is 1 for \n    ! overhead sun and 0 at sunset.\n    ! for the polar night, the values are set to 1.0 (even distribution)\n    ! one thing is sure afterwards: we know that e_isop kg/s is added.\n\n!***********************************************************************\n\n    implicit none\n\n      ! in/out\n      integer, intent(in) :: day       !day number based on 365 days a year\n      integer, intent(in) :: ntim      !number of timesteps during one day\n      integer, intent(in) :: ntim_max  !maximum, used to declare array \n     !integer, intent(in) :: nlat      !number of latitudes\n      integer, intent(in) :: lat_start !southern edge of the domain (integer!)\n      real,    intent(in) :: dlat      !increment   (real!)\n      integer, intent(in)  :: idayy     !# days this year\n      real,dimension(ntim_max),intent(out) :: scalef  \n\n      ! local\n      real              :: pi,piby,obliq,deday,delta,dt,lon,hr,lat,houra,smm\n      integer           :: i\n\n \n         pi = acos(-1.0)\n         piby = pi/180.0\n         obliq = 23.45 * piby\n         deday = 4.88 + 2*pi/idayy  * day\n         delta = asin(sin(obliq)*sin(deday))\n         dt = 24./ntim   !timestep in hours\n         lon = -180.0*piby       !calculate for dateline\n         !do j=1,nlat   !over latitudes\n\n            hr =  - 0.5*dt   !shift half a interval back\n           !lat = (lat_start + (j-0.5)*dlat)*piby\n           lat = (lat_start + (1.0-0.5)*dlat)*piby\n            smm = 0.0\n            do i=1,ntim\n               hr = hr + dt\n               houra = lon - pi + hr * (2.*pi/24.)\n               scalef(i) = &\n                   max((sin(delta)*sin(lat)  + cos(delta)*cos(lat)*cos(houra)),0.0)\n               smm = smm+scalef(i)/ntim\n            end do\n            if ( smm > 1e-5 ) then \n              scalef(1:ntim) = scalef(1:ntim)/smm \n            else \n              scalef(1:ntim) = 1.0\n            end if\n\n         !end do\n\n       return\n\n! end of logical function leap\n      end subroutine scale_isop\n"}, {"instruction": "Create a Fortran subroutine named \"face_topo\" to compute the interface and junction face topology for a given set of node coordinates. The subroutine should have 3 input parameters: two integers (n, m) and a 3D array of real(8) (node_x). It should also have 6 output parameters: 3D arrays of real(8) (iface_x, iface_normal, iface_area) and 3D arrays of real(8) (jface_x, jface_normal, jface_area).", "input": "", "output": "subroutine face_topo(node_x, iface_x, iface_normal, iface_area, jface_x, jface_normal, jface_area, n, m)\n  implicit none\n  integer, intent(in) :: n,m\n  real(8), intent(in) :: node_x(n, m, 2)\n  real(8), intent(out) :: iface_x(n, m-1, 2), iface_normal(n, m-1, 2), iface_area(n, m-1)\n  real(8), intent(out) :: jface_x(n-1, m, 2), jface_normal(n-1, m, 2), jface_area(n-1, m)\n\n  iface_x(1:n,1:m-1,:) = 0.5*(node_x(1:n,1:m-1,:)+node_x(1:n,2:m,:))\n  iface_area(1:n,1:m-1) = norm2(node_x(1:n,1:m-1,:)-node_x(1:n,2:m,:), dim=3)\n  iface_normal(1:n,1:m-1,1) = (-node_x(1:n,1:m-1,2)+node_x(1:n,2:m,2))/iface_area(1:n,1:m-1)\n  iface_normal(1:n,1:m-1,2) = ( node_x(1:n,1:m-1,1)-node_x(1:n,2:m,1))/iface_area(1:n,1:m-1)\n\n\n  jface_x(1:n-1,1:m,:) = 0.5*(node_x(1:n-1,1:m,:)+node_x(2:n,1:m,:))\n  jface_area(1:n-1,1:m) = norm2(node_x(1:n-1,1:m,:)-node_x(2:n,1:m,:), dim=3)\n  jface_normal(1:n-1,1:m,1) = ( node_x(1:n-1,1:m,2)-node_x(2:n,1:m,2))/jface_area(1:n-1,1:m)\n  jface_normal(1:n-1,1:m,2) = (-node_x(1:n-1,1:m,1)+node_x(2:n,1:m,1))/jface_area(1:n-1,1:m)\n\nend subroutine face_topo\n"}, {"instruction": "Write a Fortran subroutine named jacobian_inverse that calculates the inverse of a 2x2 matrix. The subroutine takes one input parameter of type real(8) and intent(in) and one output parameter of type real(8) and intent(out). The input parameter represents the 2x2 matrix, and the output parameter stores the inverse of the matrix.", "input": "", "output": "subroutine jacobian_inverse(jacob, jacob_inv)\n  implicit none\n  real(8), intent(in) :: jacob(2,2)\n  real(8), intent(out) :: jacob_inv(2,2)\n  real(8) :: det\n  det = jacob(1,1)*jacob(2,2)-jacob(1,2)*jacob(2,1)\n  jacob_inv(1,:) = (/jacob(2,2), -jacob(1,2)/)/det\n  jacob_inv(2,:) = (/-jacob(2,1), jacob(1,1)/)/det\nend subroutine jacobian_inverse\n"}, {"instruction": "Create a Fortran subroutine named extrapolation that takes in 4 input parameters of type real(8) and outputs 1 parameter of type real(8). The function calculates the extrapolated value based on the input parameters f1, d1, f2, and d2 using the formula f = f1 + (f1 - f2) * d1 / d2.", "input": "", "output": "subroutine extrapolation(f1, d1, f2, d2, f)\n  implicit none\n  real(8), intent(in) :: f1, d1, f2, d2\n  real(8), intent(out) :: f\n  f = f1 +(f1-f2)*d1/d2\nend subroutine extrapolation\n"}, {"instruction": "Write a Fortran subroutine named \"p2f\" to perform a series of vector operations. The subroutine takes 3 input parameters of type real(8), named p(4), normal(2), and area. It also has 1 output parameter of type real(8) named f(4). The subroutine performs computations involving dot product, element-wise multiplication, and scalar multiplication.", "input": "", "output": "subroutine  p2f(p, normal, area, f)\n  implicit none\n  real(8), intent(in) :: p(4), normal(2), area\n  real(8), intent(out) :: f(4)\n  real(8) :: vn\n  vn = dot_product(normal, p(2:3))\n  f(1) = p(1)*vn\n  f(2) = f(1)*p(2)+p(4)*normal(1)\n  f(3) = f(1)*p(3)+p(4)*normal(2)\n  f(4) = f(1)*(p(4)/p(1)*3.5 + 0.5*(p(2)*p(2)+p(3)*p(3))) !rho*vn*(p/rho*(gamma/gamma-1) + 0.5*v*v)\n  f = f*area\nend subroutine p2f\n"}, {"instruction": "Create a Fortran subroutine named \"bc_outflow\" to handle the outflow boundary conditions in a computational fluid dynamics simulation. The subroutine takes 5 input parameters of type integer, integer, real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine bc_outflow(face_normal, icell_p, pressure_exit, opt, side_p, n)\n  implicit none\n  integer, intent(in) :: opt, n\n  real(8), intent(in) :: face_normal(n,2), icell_p(n,4), pressure_exit\n  real(8), intent(out) :: side_p(n,4)\n  real(8), parameter :: k = 1.4, km1 = 0.4, km1_inv = 2.5\n  real(8) :: a_in, vn_in, r_plus, a_bound, vn_bound, rho_bound, v_bound(2), p_bound = 0.0\n  integer :: i\n\n  if (opt==1) then\n    p_bound = pressure_exit\n  end if\n\n  do i=1,n\n    a_in = sqrt(k*icell_p(i,4)/icell_p(i,1))\n    vn_in = dot_product(face_normal(i,:), icell_p(i,2:3))\n    if (abs(vn_in) > a_in) then\n      side_p(i,:) = icell_p(i,:)\n    else\n      if (opt==2) then\n        p_bound = 0.5*(pressure_exit+icell_p(i,4))\n      end if\n      rho_bound = icell_p(i,1)*(p_bound/icell_p(i,4))**(1.0/k)\n      a_bound = sqrt(k*p_bound/rho_bound)\n      r_plus = vn_in + 2*a_in*km1_inv\n      vn_bound = r_plus - 2*a_bound*km1_inv\n      v_bound = icell_p(i,2:3) + (vn_bound-vn_in)*face_normal(i,:)\n\n      side_p(i,:) = (/ rho_bound, v_bound(1), v_bound(2), p_bound /)\n    end if\n  end do\n\nend subroutine bc_outflow\n"}, {"instruction": "Create a Fortran subroutine named \"misclosure_rho\" to calculate the sum of relative differences between corresponding elements in two 2D arrays. The subroutine should have 4 input parameters of type integer, integer, real(8), and real(8) for dimensions, previous array, current array, and the sum of differences respectively. It should also have 1 output parameter of type real(8) for the sum of differences. Use the imperative tone and ensure the correct understanding and representation of the subroutine functionality.", "input": "", "output": "subroutine misclosure_rho(cell_rho_prev, cell_rho, sum_dr, n, m)\n  implicit none\n  integer, intent(in) :: n, m\n  real(8), intent(in) :: cell_rho_prev(n, m), cell_rho(n, m)\n  real(8), intent(out) :: sum_dr\n  real(8) :: dr\n  integer :: i, j\n\n  sum_dr = 1.0e-16\n  do i=1,n\n    do j=1,m\n      if (cell_rho(i,j) == cell_rho_prev(i,j)) then\n        dr = 0.0\n      else\n        dr = abs(cell_rho(i,j)-cell_rho_prev(i,j))/min(cell_rho(i,j),cell_rho_prev(i,j))\n      end if\n      \n      sum_dr = sum_dr + dr\n    end do\n  end do\n  \nend subroutine misclosure_rho\n"}, {"instruction": "Write a Fortran subroutine named func to calculate the exponential function of a given real number. The subroutine takes 1 input parameter of type real (kind(0.d0)) and returns 1 output parameter of type real (kind(0.d0)).", "input": "", "output": "        subroutine func(x,fx)\n        implicit none\n        real (kind(0.d0)), intent(in)  :: x\n        real (kind(0.d0)), intent(out) :: fx\n!\n        fx = exp(-x)\n        return\n        end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named mem2d_gmatrix to calculate the 2D membrane strain-displacement matrix for a finite element. The subroutine takes 7 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8).", "input": "", "output": " subroutine mem2d_gmatrix(nfunc,dnds,u,du,cosd,coords,et,g1_m,g2_m)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: nfunc(2),dnds(2),u(2),du(2),cosd(2),coords(2)\n  real(kind=8),intent(in) :: et\n  real(kind=8),intent(out) :: g1_m(2,2,2,2),g2_m(2,2,2,2)\n  !internal variables\n  integer(kind=4) :: i1,i2\n  !routine\n  !cycle for g1_ij\n  do i1=1,2\n    do i2=1,2\n      g1_m(1,1,i1,i2) = dnds(i1)*dnds(i2)\n      g1_m(1,2,i1,i2) = 0.d0\n      g1_m(2,1,i1,i2) = 0.d0\n      g1_m(2,2,i1,i2) = dnds(i1)*dnds(i2)\n    end do\n  end do\n  !cycle for g2_ij\n  do i1=1,2\n    do i2=1,2\n      g2_m(1,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)**2.d0/coords(2)**2.d0\n      g2_m(1,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_m(2,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_m(2,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(2)**2.d0/coords(2)**2.d0\n    end do\n  end do\n\nend subroutine mem2d_gmatrix\n"}, {"instruction": "Create a Fortran subroutine named assemble_system to assemble a system of linear equations. The subroutine takes 4 input parameters: a logical value, two real(8) numbers, and an integer. The output consists of two real(8) arrays. The subroutine computes the matrix v and the right-hand side rhs based on the input parameters and problem parameters.", "input": "", "output": "  pure subroutine assemble_system(a, b, npts, v, rhs, sparse)\n\n    logical, intent(in)  :: sparse \n    real(8), intent(in)  :: a, b ! bound of domain\n    real(8), intent(out) :: v(:,:)\n    real(8), intent(out) :: rhs(:)\n    integer, intent(in)  :: npts ! number of points\n\n    ! local variables\n    real(8) :: aa, bb, cc\n    real(8) :: h    \n    integer :: m, n, i, j\n\n    real(8), parameter  :: l     = 1.0d0\n    real(8), parameter  :: gamma = 0.1d0\n    real(8), parameter  :: u     = 1.0d0\n\n    ! mesh spacing\n    h = (b-a)/dble(npts+1)\n\n    ! problem parameters\n    aa = -u/(2.0d0*h) - gamma/(h*h)\n    bb = 2.0d0*gamma/(h*h)\n    cc = u/(2.0d0*h) - gamma/(h*h)\n    \n    ! prepare matrix\n    v = 0.0d0\n    m = npts\n    n = npts\n    if (sparse .eqv. .true.) then           \n\n       v(1,:) = [0.0d0, bb, cc]\n       do concurrent(i=2:n-1)\n          v(i,:) = [aa, bb, cc]\n       end do\n       v(n,:) = [aa, bb, 0.0d0]\n       \n    else\n\n       do i = 1, m\n          do j = 1, n\n             if (i .eq. j-1) then\n                ! upper diagonal\n                v(i,j) = cc\n             else if (i .eq. j) then\n                ! diagonal\n                v(i,i) = bb                \n             else if (i .eq. j+1) then\n                ! lower diagonal\n                v(i,j) = aa\n             else\n             end if\n          end do\n       end do\n\n    end if\n\n    ! assemble the rhs\n    rhs = 0.0d0\n    rhs(1) = -aa*1.0d0\n    rhs(npts) = -cc*0.0d0\n\n  end subroutine assemble_system\n"}, {"instruction": "Create a Fortran subroutine named linear_shape_1d to calculate the linear shape functions and their derivatives for 1D elements. The subroutine takes 1 input parameter of type real(kind=8) and provides 2 output parameters of type real(kind=8) and real(kind=8) respectively.", "input": "", "output": " subroutine linear_shape_1d(xi,n_shape,dn_shape)\n   implicit none\n   !--dummy arguments\n   real(kind=8),intent(in) :: xi\n   real(kind=8),intent(out) :: n_shape(2),dn_shape(2)\n   !--local arguments\n\n   !functions\n   n_shape(1) = 0.5d0*(1.d0-xi)\n   n_shape(2) = 0.5d0*(1.d0+xi)\n   !derivatives\n   dn_shape(1) = -0.5d0\n   dn_shape(2) = 0.5d0\n\n end subroutine linear_shape_1d\n"}, {"instruction": "Create a Fortran subroutine named quadratic_shape_1d to calculate the shape functions and their derivatives for a 1D quadratic shape element. The subroutine should have 1 input parameter of type real(kind=8) and 2 output parameters of type real(kind=8) array.", "input": "", "output": "  subroutine quadratic_shape_1d(xi,n_shape,dn_shape)\n    implicit none\n    !--dummy arguments\n    real(kind=8),intent(in) :: xi\n    real(kind=8),intent(out) :: n_shape(3),dn_shape(3)\n    !--local arguments\n\n    !functions\n    n_shape(1) = 0.5d0*xi*(xi-1.d0)\n    n_shape(2) = 1.d0-xi**2.d0\n    n_shape(3) = 0.5d0*xi*(xi+1.d0)\n    !derivatives\n    dn_shape(1) = 0.5d0*(2.d0*xi-1.d0)\n    dn_shape(2) = 1.d0-2.d0*xi\n    dn_shape(3) = 0.5d0*(2.d0*xi+1.d0)\n\n  end subroutine quadratic_shape_1d\n"}, {"instruction": "Create a Fortran subroutine named fill_shift that fills a 2D integer array with a shifting sequence of numbers. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer array with a 2D dimension.", "input": "", "output": "  subroutine fill_shift(x, n)\n    integer, intent(out), dimension(:,:) :: x\n    integer, intent(in) :: n\n    integer :: n1, n2, s1, s2\n    integer :: v\n    v = -n - 1\n    n1 = size(x,1)\n    n2 = size(x,2)\n    do s2=1,n2\n       do s1=1,n1\n          x(s1,s2) = v\n          v = v + 1\n          if (v > n + 1) v = -n - 1\n       end do\n    end do\n  end subroutine fill_shift\n"}, {"instruction": "Write a Fortran subroutine named locate_ij to implement a binary search algorithm. The subroutine takes 3 input arguments of types integer, real array, and real. The output is a single integer. The subroutine searches for the index of the element in the array that is closest to, but less than, the given value.", "input": "", "output": "subroutine locate_ij(length, array, value, idx)\n        ! given an array and a value, returns the index of the element that\n        ! is closest to, but less than, the given value.\n        ! uses a binary search algorithm.\n        implicit none\n        integer, intent(in) :: length\n        real, dimension(length), intent(in) :: array      \n        real, intent(in) :: value\n\tinteger, intent(out) :: idx\n        integer :: left, middle, right\n       \n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            end if\n            middle = nint((left+right) / 2.0)\n            if ( abs(array(middle) - value) <= 1e-9) then\n                idx = middle\n                return\n            else if (array(middle) > value) then\n                right = middle - 1\n            else\n                left = middle + 1\n            end if\n        end do\n        idx = right\n\n\treturn\nend subroutine locate_ij\n"}, {"instruction": "Create a Fortran subroutine named interpolate that implements bilinear interpolation to estimate the value of a function at a specific point. The subroutine takes 7 input parameters of type real and integer arrays, and outputs a single real value. The input parameters consist of longitude and latitude arrays, a matrix of function samples on a regular grid, grid indices, and the coordinates of the point for which the value needs to be estimated.", "input": "", "output": "subroutine interpolate(lon, lat, f, x0, y0, i, j, value)\n        ! this function uses bilinear interpolation to estimate the value\n        ! of a function f at point (x0,y0) using the point grid (i, j), (i+1,j), (i,j+1) \n\n\t! in the limits (borders) the nearest-neighbor interpolation is used\n        ! f is assumed to be sampled on a regular grid, with the grid x values specified\n        ! by lon array and the grid y values specified by lat array\n        implicit none   \n\tinteger, parameter :: col = 1440, row = 721     \n        real, dimension(:), intent(in) :: lon(col), lat(row)\t\n        real, dimension(row, col), intent(in) :: f\n        integer, intent(in) :: i, j\n\treal, intent(in) :: x0, y0\n\tinteger :: ix, jy\n\treal, intent(out) :: value\n        real :: x1, x2, y1, y2, xy1, xy2\n\n\tix = i\n\tjy = j\n\tif ( ix == 0 .or. ix >= row .or. jy == 0 .or. jy >= col ) then\n\t\t! nearest-neighbor interpolation\n\t\tif ( ix == 0 ) ix = ix + 1\n\t\tif ( ix >= row ) ix = row\n\t\tif ( jy == 0 ) jy = jy + 1\n\t\tif ( jy >= col ) jy = col\n\t\tvalue = f(ix, jy)\n\telse\n\t\t! bilinear interpolation\n\t\tx1 = lon( jy )\n\t\tx2 = lon( jy + 1 )\n\t\ty1 = lat( ix )\n\t\ty2 = lat( ix + 1 )\t\t\n\t\txy1 = (x2 - x0)/(x2 - x1)*f(ix, jy) + (x0 - x1)/(x2 - x1)*f(ix, jy+1)\n\t\txy2 = (x2 - x0)/(x2 - x1)*f(ix+1, jy) + (x0 - x1)/(x2 - x1)*f(ix+1, jy+1)\n                value = (y2 - y0)/(y2 - y1)*xy1 + (y0 - y1)/(y2 - y1)*xy2\n\tend if  \n\n\treturn\nend subroutine interpolate\n"}, {"instruction": "Create a Fortran subroutine named integrate to calculate the area under a curve represented by a set of flux values. The subroutine takes 2 input parameters: an integer nwav and a character string fname, and produces 1 output parameter: a real array area of dimension 0 to 9.", "input": "", "output": "subroutine integrate(area,fname,nwav)\n\n        implicit none\n        !pythonic array indices ahead, from 0 to n-1.\n        integer (kind=4), intent(in) :: nwav\n        integer (kind=4) :: i,j,k\n        real (kind=8), dimension(0:nwav-1,0:10) :: flux\n        !f2py depend(nwav) flux\n        character (len=40), intent(in) :: fname\n        \n        real (kind=8), dimension(0:9) ,intent(out) :: area\n        real (kind=8) :: tmp\n\n        open(unit=7,file=fname,status=\"old\")\n        do j = 0, nwav-1\n            read(7,*) (flux(j,k),k=0,10)\n        enddo\n        close(7)\n        \n        area(:) = 0\n        do i = 0, 9\n            tmp = 0\n            do j = 0, nwav-2\n                tmp = (flux(j+1,0)-flux(j,0))*((flux(j+1,i+1)+flux(j,i+1))/2)\n                area(i) = area(i) + tmp\n            enddo\n            print *, i\n        enddo\n\nend subroutine  ! integrate\n"}, {"instruction": "Create a Fortran subroutine named \"euclidean_distance_matrix\" to compute the Euclidean distance matrix between two sets of samples. The subroutine should have 4 input parameters of type double precision, double precision, integer, and integer, and 1 output parameter of type double precision. The input parameters represent the sample sets and their dimensions, while the output parameter represents the resulting distance matrix. Use the imperative tone when defining the subroutine.", "input": "", "output": "      subroutine euclidean_distance_matrix(x, y, nsamples, nfeat, r)\n\n      implicit none\n  \n      double precision, intent(in) :: x(nfeat, nsamples)\n      double precision, intent(in) :: y(nfeat, nsamples)\n      integer, intent(in) :: nsamples\n      integer, intent(in) :: nfeat\n      double precision, intent(out) :: r(nsamples, nsamples)\n\n      integer :: i, j, k\n      double precision :: tmp\n  \n!$omp parallel do private (tmp)\n      do i = 1, nsamples\n          do j = 1, nsamples\n              tmp = 0.0\n              do k = 1, nfeat\n                  tmp = (x(k,i) - y(k,j))**2 + tmp\n              enddo\n              r(i,j) = tmp\n          enddo\n      enddo\n!$omp end parallel do\n  \n      end subroutine euclidean_distance_matrix\n"}, {"instruction": "Create a Fortran subroutine named createcolortable to generate a color table from the provided RGB data. The subroutine takes 1 input parameter of type integer array and 2 output parameters of type integer array and integer.", "input": "", "output": "   subroutine createcolortable(rgbdata, colortable, numcolors)\n      integer, intent(in)  :: rgbdata(:,:,:)\n      integer, intent(out) :: colortable(:,:)\n      integer, intent(out) :: numcolors \n      integer :: row, col\n      logical :: found\n      integer :: coloridx\n\n      numcolors = 0\n      do row=1, size(rgbdata,1)\n         do col=1, size(rgbdata,2)\n            found = .false.\n            do coloridx=1, numcolors\n               if (all(colortable(coloridx,1:3) == rgbdata(row,col,1:3))) then\n                  found = .true.\n                  exit \n               endif\n            enddo\n\n            if (.not. found) then\n               numcolors = numcolors+1\n               if (numcolors > size(colortable)) then\n                  print *, \"too many colors\"\n                  stop\n               endif\n               colortable(numcolors,1:3) = rgbdata(row,col,1:3)\n            endif\n         enddo\n      enddo\n   end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"cross\" to calculate the cross product of two 3-dimensional vectors. The subroutine should take 2 input parameters of type real, dimension(3) and intent(in) and 1 output parameter of type real, dimension(3) and intent(out).", "input": "", "output": "    subroutine cross(tmp, x,y)\n        real, dimension(3), intent(in) :: x,y\n        real, dimension(3), intent(out) :: tmp\n\n        tmp(1) = x(2)*y(3)-x(3)*y(2)\n        tmp(2) = x(3)*y(1)-x(1)*y(3)\n        tmp(3) = x(1)*y(2)-x(2)*y(1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gauss_coeff to calculate the abscissae of Gaussian quadrature points. It takes 1 input parameter of type integer and returns 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine gauss_coeff (m_qp, pt)\r\n\r\n    ! returns gaussian quadrature abscissae\r\n\r\n    integer,  intent(in)      :: m_qp      ! no. of gauss points in 1 dimension\r\n    real(kind=8), intent(out) :: pt (m_qp) ! abscissae of gauss points\r\n\r\n    integer,  parameter   :: nmax = 4 ! max. no. of points tabulated herein\r\n\r\n    ! local\r\n    integer :: n_gp\r\n\r\n    n_gp = m_qp\r\n    if ( n_gp > nmax ) then\r\n      n_gp = nmax\r\n      write (6, * ) 'warning, gauss_coeff used gauss = ', nmax\r\n    end if\r\n    if ( n_gp < 1 ) stop 'gauss = 0, no points in gauss_coeff'\r\n\r\n    if ( n_gp == 1 ) then\r\n      pt (1) = 0.000000000000000000000000d+00\r\n      return\r\n\r\n    elseif (n_gp == 2 ) then\r\n      pt (1) = - .577350269189625764509149d+00\r\n      pt (2) = 0.577350269189625764509149d+00\r\n      return\r\n\r\n    elseif (n_gp == 3 ) then\r\n      pt (1) = - .774596669241483377035835d+00\r\n      pt (2) = 0.000000000000000000000000d+00\r\n      pt (3) = 0.774596669241483377035835d+00\r\n      return\r\n\r\n    elseif (n_gp == 4 ) then\r\n      pt (1) = - .861136311594052575223946d+00\r\n      pt (2) = - .339981043584856264802666d+00\r\n      pt (3) = 0.339981043584856264802666d+00\r\n      pt (4) = 0.861136311594052575223946d+00\r\n      return\r\n    end if\r\n\r\n  end subroutine gauss_coeff\r\n"}, {"instruction": "Create a Fortran subroutine named \"dunavant_unit_triangle_rule\" to calculate the quadrature coordinates for the Dunavant quadrature rule for triangles in unit coordinates. The subroutine should take 1 input argument of type integer and output 1 argument of type real(kind=8).", "input": "", "output": "  subroutine dunavant_unit_triangle_rule (m_qp, pt)\r\n\r\n    ! dunavant quadrature rule for triangles in unit coordinates\r\n    ! (i.j.n.m.e. vol. 21, pp.1129-1148, 1985)\r\n\r\n    implicit none\r\n    integer,  intent(in)  :: m_qp             ! number of quadrature points\r\n    real(kind=8), intent(out) :: pt (2, m_qp) ! quadrature coordinates\r\n\r\n    real(kind=8) :: pt_1 (2, 1), pt_3 (2, 3), pt_4 (2, 4), pt_6 (2, 6)\r\n\r\n    data  pt_1   /                                          &\r\n     3.33333333333333333e-01_8,  3.33333333333333333e-01_8  /\r\n    data  pt_3   /                                          &\r\n     6.66666666666666667e-01_8,  1.66666666666666667e-01_8, &\r\n     1.66666666666666667e-01_8,  6.66666666666666667e-01_8, &\r\n     1.66666666666666667e-01_8,  1.66666666666666667e-01_8  /\r\n    data  pt_4   /                                          &\r\n     3.33333333333333333e-01_8,  3.33333333333333333e-01_8, &\r\n     6.00000000000000000e-01_8,  2.00000000000000000e-01_8, &\r\n     2.00000000000000000e-01_8,  6.00000000000000000e-01_8, &\r\n     2.00000000000000000e-01_8,  2.00000000000000000e-01_8  /\r\n    data  pt_6   /                                      &\r\n     1.081030181680700e-01_8,  4.459484909159650e-01_8, &\r\n     4.459484909159650e-01_8,  1.081030181680700e-01_8, &\r\n     4.459484909159650e-01_8,  4.459484909159650e-01_8, &\r\n     8.168475729804590e-01_8,  9.157621350977100e-02_8, &\r\n     9.157621350977100e-02_8,  8.168475729804590e-01_8, &\r\n     9.157621350977100e-02_8,  9.157621350977100e-02_8  /\r\n\r\n    select case (m_qp)\r\n      case ( 1) ;  pt = pt_1\r\n      case ( 3) ;  pt = pt_3\r\n      case ( 4) ;  pt = pt_4\r\n      case ( 6) ;  pt = pt_6\r\n      case default\r\n        print *,'warning: dunavant_unit_triangle_rule, invalid rule', m_qp\r\n        print *,'check if shape 2 is correct'\r\n        stop 'invalid rule dunavant_unit_triangle_rule'\r\n    end select\r\n\r\n  end subroutine dunavant_unit_triangle_rule\r\n"}, {"instruction": "Create a Fortran subroutine named shape_12_q to calculate the shape functions of a 12-node quadrilateral element. The subroutine should take 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8) array with 12 elements. The input parameters represent the local coordinates of a point, and the output parameter stores the element's shape functions.", "input": "", "output": "  subroutine shape_12_q (r, s, h)\r\n\r\n    ! shape functions of a 12-node quadrilateral\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s   ! local coords of pt\r\n    real(kind=8), intent(out) :: h (12) ! elem shape functions\r\n\r\n    real(kind=8), parameter :: f1 = 1.d0/32, f2 = 9.d0/32\r\n    real(kind=8) :: r_p, r_m, s_p, s_m, r2, s2\r\n\r\n    !  element sketch to right     4--11---7---3\r\n    !                              |           |\r\n    !  local coord of nodes:       8     s    10\r\n    !  1-(-1,-1)  3-(+1,+1)        |     .r    |\r\n    !                             12           6\r\n    !  sides of order 1, 2, or 3   |           |\r\n    !                              1---5---9---2\r\n\r\n    r_p = 1 + r ; r_m = 1 - r ; s_p = 1 + s ; s_m = 1 - s\r\n    r2 = r*r ; s2 = s*s\r\n    h ( 1) = f1*r_m*s_m*(-10 + 9*(r2 + s2))\r\n    h ( 2) = f1*r_p*s_m*(-10 + 9*(r2 + s2))\r\n    h ( 3) = f1*r_p*s_p*(-10 + 9*(r2 + s2))\r\n    h ( 4) = f1*r_m*s_p*(-10 + 9*(r2 + s2))\r\n    h ( 5) = f2*(1 - r2)*s_m*(1 - 3*r)\r\n    h ( 6) = f2*(1 - s2)*r_p*(1 - 3*s)\r\n    h ( 7) = f2*(1 - r2)*s_p*(1 + 3*r)\r\n    h ( 8) = f2*(1 - s2)*r_m*(1 + 3*s)\r\n    h ( 9) = f2*(1 - r2)*s_m*(1 + 3*r)\r\n    h (10) = f2*(1 - s2)*r_p*(1 + 3*s)\r\n    h (11) = f2*(1 - r2)*s_p*(1 - 3*r)\r\n    h (12) = f2*(1 - s2)*r_m*(1 - 3*s)\r\n\r\n  end subroutine shape_12_q\r\n"}, {"instruction": "Write a Fortran subroutine named shape_9_q to calculate the shape functions for a 9-noded quadrilateral element. The subroutine should take 2 input parameters of type real(kind=8) and output 1 parameter of type real(kind=8). The input parameters are local coordinates of a point (r, s), and the output parameter is an array of 9 element shape functions (h).", "input": "", "output": "  subroutine shape_9_q (r, s, h)\r\n\r\n    ! shape functions for 9-noded quad\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s  ! local coords of pt\r\n    real(kind=8), intent(out) :: h (9) ! elem shape functions\r\n    real(kind=8)              :: rp, rm, s_p, sm\r\n\r\n    !                               4-----7-----3\r\n    !  element sketch to right      |     s     |\r\n    !  1 (-1,-1)  3 (+1,+1)         |     .     |\r\n    !                               8     9..r  6\r\n    !                               |           |\r\n    !                               |           |\r\n    !                               1-----5-----2\r\n\r\n    rm = r - 1.d0 ; sm  = s - 1.d0\r\n    rp = r + 1.d0 ; s_p = s + 1.d0\r\n    h (1) = 0.25d0*s*sm*r*rm\r\n    h (2) = 0.25d0*s*sm*r*rp\r\n    h (3) = 0.25d0*s*s_p*r*rp\r\n    h (4) = 0.25d0*s*s_p*r*rm\r\n    h (5) = - 0.5d0*s*sm*rp*rm\r\n    h (6) = - 0.5d0*s_p*sm*r*rp\r\n    h (7) = - 0.5d0*s*s_p*rp*rm\r\n    h (8) = - 0.5d0*s_p*sm*r*rm\r\n    h (9) = s_p*sm*rp*rm\r\n\r\n  end subroutine shape_9_q\r\n"}, {"instruction": "Write a Fortran subroutine named shape_3_t to calculate the shape functions for a three-node unit triangle. The subroutine takes 2 input parameters of type real(kind=8) and outputs 1 parameter of type real(kind=8). The inputs are the local coordinates of the point, and the output is an array of shape functions.", "input": "", "output": "  subroutine shape_3_t (s, t, h)\r\n\r\n    ! shape functions for a three node unit triangle\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  ! local coordinates of the point\r\n    real(kind=8), intent(out) :: h (3) ! shape functions\r\n\r\n    ! nodal coords 1-(0,0)  2-(1,0)  3-(0,1)  1..2  0..s\r\n\r\n    h (1) = 1.d0 - s - t\r\n    h (2) = s\r\n    h (3) = t\r\n\r\n  end subroutine shape_3_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_4_p that calculates the shape functions of a 4-node tetrahedron element (pyramid). The subroutine takes 3 input parameters of type real(kind=8) and returns 1 output parameter of type real(kind=8). The input parameters are the coordinates (r, s, t) and the output parameter is an array h(4) containing the computed shape functions.", "input": "", "output": "  subroutine shape_4_p (r, s, t, h)\r\n\r\n    ! shape functions of a 4 node tetrahedron element (pyramid)\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s, t\r\n    real(kind=8), intent(out) :: h (4)\r\n\r\n    h (1) = 1.d0 - r - s - t\r\n    h (2) = r\r\n    h (3) = s\r\n    h (4) = t\r\n\r\n  end subroutine shape_4_p\r\n"}, {"instruction": "Create a Fortran subroutine named shape_4_q to calculate the shape functions of a 4-node parametric quad in natural coordinates. The subroutine should take 2 input parameters of type real(kind=8) and produce 1 output parameter of type real(kind=8). The input parameters represent the natural coordinates (r, s), and the output parameter represents the local interpolation functions (h) for the quad.", "input": "", "output": "  subroutine shape_4_q (r, s, h)\r\n  ! *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-*\r\n  ! shape functions of a 4 node parametric quad\r\n  !          in natural coordinates\r\n  ! *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-*\r\n\r\n   implicit none\r\n   real(kind=8), intent(in)  :: r, s\r\n   real(kind=8), intent(out) :: h (4)\r\n   real(kind=8)              :: rp, rm, s_p, sm\r\n\r\n  ! (r,s) = a point in the natural coords     4--3\r\n  ! h     = local interpolation functions     i  i\r\n  ! h(i)  = 0.25d0*(1+r*r(i))*(1+s*s(i))      i  i\r\n  ! r(i)  = local r-coordinate of node i      1--2\r\n  ! local coords, 1=(-1,-1)   3=(+1,+1)\r\n\r\n    rp = 1.d0 + r ; rm = 1.d0 - r\r\n    s_p = 1.d0 + s ; sm = 1.d0 - s\r\n    h (1) = 0.25d0*rm*sm\r\n    h (2) = 0.25d0*rp*sm\r\n    h (3) = 0.25d0*rp*s_p\r\n    h (4) = 0.25d0*rm*s_p\r\n\r\n  end subroutine shape_4_q\r\n"}, {"instruction": "Write a Fortran subroutine named \"shape_8_h\" to compute the shape functions of an 8-node parametric hexahedron based on the given local coordinates of a point. The subroutine takes 3 input parameters of type real(kind=8) for the local coordinates (r, s, t), and provides 1 output parameter of type real(kind=8) array with 8 elements for the element shape functions.", "input": "", "output": "  subroutine shape_8_h (r, s, t, h)\r\n\r\n    ! shape functions of 8 node parametric hexahedron\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s, t ! local coords of pt\r\n    real(kind=8), intent(out) :: h (8)   ! elem shape functions\r\n\r\n    real(kind=8)              :: rp, rm, s_p, sm, tp, tm\r\n\r\n    !                           !     r         3 *---------* 2\r\n    ! nodes ordered by rhr      !     |         / .        /|\r\n    ! about the r-axis          !     |        /  .       / |\r\n    !                           !     *---t   /   .      /  |\r\n    ! local coord:1=(1,1,1)     !   /        /    .     /   |\r\n    ! 4=(1,1,-1)  7=(-1,-1,-1)  !  /        /     .    /    |\r\n                                !  s       /     7*.../.....* 6\r\n    rp  = 1.d0 + r              !         /      .   /     /\r\n    rm  = 1.d0 - r              !       4 *---------*1    /\r\n    s_p = 1.d0 + s              !         |    .    |    /\r\n    sm  = 1.d0 - s              !         |   .     |   /\r\n    tp  = 1.d0 + t              !         |  .      |  /\r\n    tm  = 1.d0 - t              !         | .       | /\r\n                                !         |.        |/\r\n                                !       8 *---------* 5\r\n    h (1) = 0.125d0 * rp * s_p * tp\r\n    h (2) = 0.125d0 * rp * sm  * tp\r\n    h (3) = 0.125d0 * rp * sm  * tm\r\n    h (4) = 0.125d0 * rp * s_p * tm\r\n    h (5) = 0.125d0 * rm * s_p * tp\r\n    h (6) = 0.125d0 * rm * sm  * tp\r\n    h (7) = 0.125d0 * rm * sm  * tm\r\n    h (8) = 0.125d0 * rm * s_p * tm\r\n\r\n  end subroutine shape_8_h\r\n"}, {"instruction": "Create a Fortran subroutine named shape_6_t to calculate the shape functions for a six-node unit triangle. The subroutine has 2 input parameters of type real(kind=8) for local coordinates and 1 output parameter of type real(kind=8) array with 6 elements for the shape functions.", "input": "", "output": "  subroutine shape_6_t (s, t, h)\r\n\r\n    ! local shape functions for a six-node unit triangle\r\n    ! (quadratic triangular element)\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  !local coordinates of pt in unit triangle\r\n    real(kind=8), intent(out) :: h (6) !shape functions\r\n\r\n    !                       the nodal order:        3\r\n    !                                               6 5\r\n    !                                               1 4 2\r\n    ! nodal coords : 1-(0,0)   2-(1,0)   3-(0,1)\r\n    !                4-(0.5,0)  5-(0.5,0.5)  6-(0,0.5)\r\n\r\n    h (1) = 1.d0 - 3.d0*s - 3.d0*t + 2.d0*s*s + 4.d0*s*t + 2.d0*t*t\r\n    h (2) = 2.d0*s*s - s\r\n    h (3) = 2.d0*t*t - t\r\n    h (4) = 4.d0*(s - s*s - s*t)\r\n    h (5) = 4.d0*s*t\r\n    h (6) = 4.d0*(t - s*t - t*t)\r\n\r\n  end subroutine shape_6_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_10_t to calculate the shape functions for a 10-node (cubic) triangle. The subroutine should take 2 input parameters of type real(kind=8) for local coordinates and 1 output parameter of type real(kind=8) for the element shape functions.", "input": "", "output": "  subroutine shape_10_t (r, s, h)\r\n\r\n    ! shape functions for 10-node (cubic) triangle\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s   ! local coords of pt\r\n    real(kind=8), intent(out) :: h (10) ! elem shape functions\r\n    real(kind=8) :: t1, t2, t3, z\r\n\r\n    !    s\r\n    !    :\r\n    !    3\r\n    !    | \\\r\n    !    |   \\\r\n    !    6     8\r\n    !    |      \\\r\n    !    9   10   5\r\n    !    |          \\\r\n    !    1---4---7---2  ... r\r\n    !\r\n    ! 1@(0,0)  2@(1,0) 2@(0,1)\r\n\r\n    z  = 1.d0 - r - s\r\n    t1 = s * (3.d0 * s - 1.d0)\r\n    t2 = z * (3.d0 * z - 1.d0)\r\n    t3 = r * (3.d0 * r - 1.d0)\r\n    h (1 ) = 0.5d0 * t2 * (3.d0 * z - 2.d0)\r\n    h (2 ) = 0.5d0 * t3 * (3.d0 * r - 2.d0)\r\n    h (3 ) = 0.5d0 * t1 * (3.d0 * s - 2.d0)\r\n    h (4 ) = 4.5d0 * r * t2\r\n    h (5 ) = 4.5d0 * s * t3\r\n    h (6 ) = 4.5d0 * z * t1\r\n    h (7 ) = 4.5d0 * z * t3\r\n    h (8 ) = 4.5d0 * r * t1\r\n    h (9 ) = 4.5d0 * s * t2\r\n    h (10) = 27.d0 * s * z * r\r\n\r\n  end subroutine shape_10_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_8_q to calculate the shape functions of an 8-node parametric quadrilateral. The subroutine should have 2 input parameters of type real(kind=8) and intent(in), and 1 output parameter of type real(kind=8) and intent(out). The input parameters represent the local coordinates of a point, while the output parameter is an array containing the shape functions for the 8-node quadrilateral.", "input": "", "output": "  subroutine shape_8_q (s, t, h)\r\n\r\n    ! shape functions of 8 node parametric quadrilateral\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  ! local coordinates of point\r\n    real(kind=8), intent(out) :: h (8) ! elem shape function array\r\n\r\n    real(kind=8)              :: t_plus, t_less, s_plus, s_less\r\n\r\n    ! nodal order        4 - 7 - 3\r\n    !                    :   t   :\r\n    !                    8   *s  6\r\n    ! node 1 at (-1,-1)  :       :\r\n    ! node 3 at (1,1)    1 - 5 - 2\r\n\r\n    s_plus = 1.d0 + s ; s_less = 1.d0 - s\r\n    t_plus = 1.d0 + t ; t_less = 1.d0 - t\r\n    h (1) = 0.25d0*s_less*t_less*(s_less + t_less - 3.d0)\r\n    h (2) = 0.25d0*s_plus*t_less*(s_plus + t_less - 3.d0)\r\n    h (3) = 0.25d0*s_plus*t_plus*(s_plus + t_plus - 3.d0)\r\n    h (4) = 0.25d0*s_less*t_plus*(s_less + t_plus - 3.d0)\r\n    h (5) = 0.5d0*t_less*(1.d0 - s*s)\r\n    h (6) = 0.5d0*s_plus*(1.d0 - t*t)\r\n    h (7) = 0.5d0*t_plus*(1.d0 - s*s)\r\n    h (8) = 0.5d0*s_less*(1.d0 - t*t)\r\n\r\n  end subroutine shape_8_q\r\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_local_coulomb_matrix to compute the local Coulomb matrix based on the input nuclear charges, coordinates, number of atoms, and maximum quantum number. The number and type of input parameters are 4, with the test_data type ['double precision, dimension(:)', 'double precision, dimension(:,:)', 'integer', 'integer']. The number of output parameters is 1, with the test_data type ['double precision, dimension(natoms,(nmax + 1) * nmax / 2)'].", "input": "", "output": "subroutine fgenerate_local_coulomb_matrix(nuclear_charges, coordinates, natoms, nmax, cm)\n\n    implicit none\n\n    double precision, dimension(:), intent(in) :: nuclear_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n    integer,intent(in) :: natoms\n    integer, intent(in) :: nmax\n\n    double precision, dimension(natoms,(nmax + 1) * nmax / 2), intent(out):: cm\n    integer :: idx\n\n    double precision, dimension(natoms) :: row_norms\n    double precision :: pair_norm\n    double precision :: huge_double\n\n    integer, dimension(natoms) :: sorted_atoms\n    integer, dimension(natoms,natoms) :: sorted_atoms_all\n\n    double precision, dimension(natoms,natoms) :: pair_distance_matrix\n\n    integer i, j, m, n, k\n\n    if (size(coordinates, dim=1) /= size(nuclear_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(nuclear_charges, dim=1), \"atom_types!\"\n        stop\n    endif\n\n    huge_double = huge(row_norms(1))\n\n    ! calculate row-2-norms and store pair-distances in pair_distance_matrix\n    row_norms = 0.0d0\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        pair_norm = 0.5d0 * nuclear_charges(i) ** 2.4d0\n        row_norms(i) = row_norms(i) + pair_norm*pair_norm\n        pair_distance_matrix(i, i) = pair_norm\n    enddo\n    !$omp end parallel do\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        do j = i+1, natoms\n            pair_norm = nuclear_charges(i) * nuclear_charges(j) &\n                & / sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n\n            pair_distance_matrix(i, j) = pair_norm\n            pair_distance_matrix(j, i) = pair_norm\n            pair_norm = pair_norm * pair_norm\n            row_norms(j) = row_norms(j) + pair_norm\n            row_norms(i) = row_norms(i) + pair_norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    !generate sorted list of atom ids by row_norms - not really (easily) parallelizable\n    do i = 1, natoms\n        j = minloc(row_norms, dim=1)\n        sorted_atoms(natoms - i + 1) = j\n        row_norms(j) = huge_double\n    enddo\n\n    do k = 1, natoms\n        sorted_atoms_all(1, k)  = k\n        m = 0\n        do i = 1, natoms - 1\n            if (sorted_atoms(i) == k) then\n                m = 1\n            endif\n            sorted_atoms_all(i+1, k) = sorted_atoms(i + m)\n        enddo\n    enddo\n\n    ! fill coulomb matrix according to sorted row-2-norms\n    cm = 0.0d0\n    !$omp parallel do private(idx, i, j)\n    do k = 1, natoms\n        do m = 1, natoms\n            i = sorted_atoms_all(m, k)\n            idx = (m*m+m)/2 - m\n            do n = 1, m\n                j = sorted_atoms_all(n, k)\n                cm(k, idx+n) = pair_distance_matrix(i, j)\n            enddo\n        enddo\n    enddo\n    !$omp end parallel do\n\nend subroutine fgenerate_local_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_atomic_unsorted_coulomb_matrix that takes 5 input parameters of type ['double precision, dimension(:)', 'double precision, dimension(:,:)', 'integer', 'integer', 'double precision'], and 1 output parameter of type ['double precision, dimension(natoms,(nmax + 1) * nmax / 2)']. This subroutine generates an unsorted Coulomb matrix based on the input nuclear charges and coordinates of atoms. It performs calculations to fill the Coulomb matrix based on specified cutoff and maximum distance parameters.", "input": "", "output": "subroutine fgenerate_atomic_unsorted_coulomb_matrix(nuclear_charges, coordinates, natoms, nmax, cutoff, cm)\n\n    implicit none\n\n    double precision, dimension(:), intent(in) :: nuclear_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n    integer,intent(in) :: natoms\n    integer, intent(in) :: nmax\n    double precision, intent(in) :: cutoff\n\n    double precision, dimension(natoms,(nmax + 1) * nmax / 2), intent(out):: cm\n\n    integer :: idx\n\n    double precision :: norm\n\n    double precision, allocatable, dimension(:,:) :: distance_matrix\n\n    integer i, j, m, n, k\n\n\n    if (size(coordinates, dim=1) /= size(nuclear_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(nuclear_charges, dim=1), \"atom_types!\"\n        stop\n    endif\n    write(*,*) 1\n\n    ! allocate temporary\n    allocate(distance_matrix(natoms,natoms))\n\n    !$omp parallel do private(norm)\n    do i = 1, natoms\n        distance_matrix(i, i) = 0.0d0\n        do j = i+1, natoms\n            norm = sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n            distance_matrix(i, j) = norm\n            distance_matrix(j, i) = norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    write(*,*) 2\n\n    ! fill coulomb matrix\n    cm = 0.0d0\n\n    !$omp parallel do private(idx)\n    do k = 1, natoms\n        do i = 1, nmax\n            idx = (i*i+i)/2 - i\n            if (distance_matrix(k,i) < cutoff) then\n                do j = 1, i\n                    if (distance_matrix(k,j) < cutoff) then\n                        cm(k, idx+j) = distance_matrix(i, j)\n                    endif\n                enddo\n            endif\n        enddo\n    enddo\n    !$omp end parallel do\n    write(*,*) 3\n\n    ! clean up\n    deallocate(distance_matrix)\n\nend subroutine fgenerate_atomic_unsorted_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named unrotate_frame to perform a rotation of a 3D frame using input angles phi and theta. The subroutine has 7 input parameters of type real (kind=8) and 3 output parameters of type real (kind=8).", "input": "", "output": "  subroutine unrotate_frame(x_in, y_in, z_in, stheta, ctheta, sphi, cphi, xn, yn, zn)\n!     \n!\n!     -----description: rotates the frame using input angles\n!          phi and theta\n!\n!\n!          on input:  \n!\n!          on output:\n!          \n!\n!     ----------------------------------------------------------------\n!\n    implicit none\n!\n!     -----variable declarations\n!          ---------------------\n!\n    real (kind=8), intent(in) :: x_in, y_in, z_in\n    real (kind=8), intent(in) :: stheta, ctheta, sphi, cphi\n    real (kind=8), intent(out) :: xn, yn, zn\n\n    real (kind=8) :: x1, y1, z1\n    real (kind=8) :: x2, y2, z2\n!\n!     ----------------------------------------------------------------\n!\n\n    x1 = x_in\n    y1 = y_in\n    z1 = z_in\n\n    x2  =   x1 * ctheta +  z1 * stheta\n    y2  =   y1\n    z2  =  -x1 * stheta +  z1 * ctheta\n\n    xn  =   x2  * cphi -  y2 * sphi\n    yn  =   x2  * sphi +  y2 * cphi\n    zn  =   z2\n    \n    return\n\n  end subroutine unrotate_frame\n"}, {"instruction": "Write a Fortran subroutine named \"pwc\" to calculate the electrostatic energy and its derivatives for a given pair of densities. The subroutine takes 2 input parameters of type real(8) and returns 3 output parameters of type real(8).", "input": "", "output": "      subroutine pwc(rhoa,rhob,ec,dec_drhoa,dec_drhob)\n      implicit none\n      real(8),parameter :: pi=3.141592653589793d0\n      real(8),intent(in) :: rhoa,rhob\n      real(8),intent(out) :: ec,dec_drhoa,dec_drhob\n      real(8),parameter :: pec0=1d0,pec1=1d0,par=1d0\n      real(8),parameter :: aec0=0.031091d0,aec1=0.015545d0,aar=0.016887d0\n      real(8),parameter :: a1ec0=0.21370d0,a1ec1=0.20548d0,a1ar=0.11125d0\n      real(8),parameter :: b1ec0=7.5957d0,b1ec1=14.1189d0,b1ar=10.357d0\n      real(8),parameter :: b2ec0=3.5876d0,b2ec1=6.1977d0,b2ar=3.6231d0\n      real(8),parameter :: b3ec0=1.6382d0,b3ec1=3.3662d0,b3ar=0.88026d0\n      real(8),parameter :: b4ec0=0.49294d0,b4ec1=0.62517d0,b4ar=0.49671d0\n      real(8),parameter :: f2d=1.709921d0,eps=1d-15\n      real(8) rs,sqrs,zeta,fzeta,dfzeta,q0ec0,q0ec1,q0ar,q1ec0,q1ec1,q1ar\n      real(8) qdec0,qdec1,qdar,gec0,gec1,gar,dgec0,dgec1,dgar,decdrs,decdzeta\n\n      rs=(3d0/(4d0*pi*(rhoa+rhob)))**(1d0/3d0)\n      sqrs=sqrt(rs)\n      zeta=(rhoa-rhob)/(rhoa+rhob)\n      if(abs(zeta-1d0) < eps) zeta=1d0-eps\n      if(abs(zeta+1d0) < eps) zeta=-1d0+eps\n      fzeta=((1+zeta)**(4d0/3d0)+(1-zeta)**(4d0/3d0)-2)/(2d0**(4d0/3d0)-2d0)\n      dfzeta=4d0/3d0*((1+zeta)**(1d0/3d0)-(1-zeta)**(1d0/3d0))/(2d0**(4d0/3d0)-2d0)\n\n      q0ec0=-2*aec0*(1+a1ec0*rs)\n      q0ec1=-2*aec1*(1+a1ec1*rs)\n      q0ar =-2*aar *(1+a1ar *rs)\n      q1ec0=2*aec0*(b1ec0*sqrs+b2ec0*rs+b3ec0*rs*sqrs+b4ec0*rs**(pec0+1))\n      q1ec1=2*aec1*(b1ec1*sqrs+b2ec1*rs+b3ec1*rs*sqrs+b4ec1*rs**(pec1+1))\n      q1ar =2*aar *(b1ar *sqrs+b2ar *rs+b3ar *rs*sqrs+b4ar *rs**(par +1))\n      qdec0=aec0*(b1ec0/sqrs+2*b2ec0+3*b3ec0*sqrs+2*(pec0+1)*b4ec0*rs**pec0)\n      qdec1=aec1*(b1ec1/sqrs+2*b2ec1+3*b3ec1*sqrs+2*(pec1+1)*b4ec1*rs**pec1)\n      qdar =aar *(b1ar /sqrs+2*b2ar +3*b3ar *sqrs+2*(par +1)*b4ar *rs**par )\n      gec0=q0ec0*log(1+1d0/q1ec0)\n      gec1=q0ec1*log(1+1d0/q1ec1)\n      gar =q0ar *log(1+1d0/q1ar )\n      dgec0=-2*aec0*a1ec0*log(1+1d0/q1ec0)-q0ec0*qdec0/(q1ec0**2+q1ec0)\n      dgec1=-2*aec1*a1ec1*log(1+1d0/q1ec1)-q0ec1*qdec1/(q1ec1**2+q1ec1)\n      dgar =-2*aar *a1ar *log(1+1d0/q1ar )-q0ar *qdar /(q1ar **2+q1ar )\n\n      ec=gec0-gar*fzeta/f2d*(1-zeta**4)+(gec1-gec0)*fzeta*zeta**4\n      decdrs=dgec0*(1-fzeta*zeta**4)+dgec1*fzeta*zeta**4-dgar*fzeta/f2d*(1-zeta**4)\n      decdzeta=dfzeta*(-gar/f2d*(1-zeta**4)+(gec1-gec0)*zeta**4) &\n    &         +4*zeta**3*(fzeta*(gec1-gec0)+gar*fzeta/f2d)\n\n      dec_drhoa=(-rs/3*decdrs-(zeta-1)*decdzeta)/(rhoa+rhob)\n      dec_drhob=(-rs/3*decdrs-(zeta+1)*decdzeta)/(rhoa+rhob)\n\n      return\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gram_schmidt that performs the Gram-Schmidt process on a set of vectors. The subroutine takes 3 input parameters: two integers (n and m) and a 2D array of double precision numbers with dimensions (n, m). It also has 1 output parameter, a 2D array of double precision numbers with dimensions (n, m).", "input": "", "output": "  subroutine gram_schmidt(u_in, n, m, u_out)\n    implicit none\n    integer,          intent(in)                 :: n,m\n    double precision, dimension(n,m),intent(in)  :: u_in\n    double precision, dimension(n,m),intent(out) :: u_out    \n\n    !! local variables\n    integer :: i,j\n\n    do i = 1, m\n       u_out(:,i) = u_in(:,i)\n    end do\n\n    do j = 1, m\n       if(j .gt. 1)then\n          do i = 1, j-1\n             u_out(:,j) = u_out(:,j) - dot_product(u_out(:,j), u_out(:,i))*u_out(:,i)\n          end do\n       end if\n       u_out(:,j) = u_out(:,j)/sqrt(dot_product(u_out(:,j),u_out(:,j)))\n    end do\n\n    return\n    \n  end subroutine gram_schmidt\n"}, {"instruction": "Create a Fortran subroutine named h_candidate_matrix_size to compute the size of elemental matrices for h candidates based on the input parameters p and neigh. The input parameters consist of 2 integers. The output parameters consist of 4 integers representing nglobal, nprimary(2), nmate(2), and nsecondary(2).", "input": "", "output": "subroutine h_candidate_matrix_size(p,neigh,nglobal,nprimary,nmate,nsecondary)\n!          -----------------------\n\n!----------------------------------------------------\n! this routine computes the size of the elemental maticies of the children\n! of the primary (nprimary), the children of the mate (nmate), the secondary\n! elemental matrices, and global matrix for h candidates.\n!\n! this version is for the type i_h_patch which uses p (degree(elem)+1) for the\n! degree of all sides and interior of the children of the primary element, and\n! degree 1 for children of the mate and the secondary elements (the other two\n! neighbors of the primary).\n! temp assuming system_size is 1\n!----------------------------------------------------\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(in) :: p\ninteger, intent(in) :: neigh(3)\ninteger, intent(out) :: nglobal, nprimary(2), nmate(2), nsecondary(2)\n!----------------------------------------------------\n! local variables:\n\n!----------------------------------------------------\n! begin executable code\n\n! children of the primary are full p elements\n\nnprimary = ((p+1)*(p+2))/2\n\n! if the mate is the boundary, set the size to 0.  otherwise the children\n! have the 3 vertices plus one edge of degree p\n\nif (neigh(3) == boundary) then\n   nmate = 0\nelse\n   nmate = p + 2\nendif\n\n! the secondaries have the 3 vertices plus one edge of degree p.\n\nnsecondary = 0\nif (neigh(1) /= boundary) nsecondary(1) = p + 2\nif (neigh(2) /= boundary) nsecondary(2) = p + 2\n\n! global number: for simplicity in the numbering of the last (up to) 3 rows,\n! include the opposite vertex of the mate and all secondaries regardless of\n! whether they actually exist, and just make the missing ones a dirichlet\n! row with value 0 -- it will be decoupled and not affect anything.\n! see h_candidate_renum_primary for an explanation of the value.\n\nnglobal = (p+1)**2 + 3\n\nend subroutine h_candidate_matrix_size\n"}, {"instruction": "Create a Fortran subroutine named \"p_candidate_renum_primary\" to determine the renumbering from the elemental matrix to the global matrix for the p candidate linear system. The number of input parameters is 1, with the test_data type as ['integer']. The number of output parameters is 1, with the test_data type as ['integer'].", "input": "", "output": "subroutine p_candidate_renum_primary(renum,p)\n!          -------------------------\n\n!----------------------------------------------------\n! this routine determines the renumbering from the elemental matrix to the\n! global matrix for the p candidate linear system\n! temp only using first eigenvalue\n! temp assuming system size is 1\n!----------------------------------------------------\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(out) :: renum(:)\ninteger, intent(in) :: p\n!----------------------------------------------------\n! local variables:\n\ninteger :: i, k, current\n!----------------------------------------------------\n! begin executable code\n\n! the numbering of the elemental matrix is\n\n!                    1\n!                   / \\\n!                  /   \\\n!                 /     \\\n!                /       \\\n!    p+3..2p+1  /         \\  2p+2..3p\n!              /   3p+1    \\\n!             /     ..      \\\n!            / (p+1)(p+2)/2  \\\n!           /                 \\\n!          3-------------------2\n!                 4..p+2\n\n! the numbering of the global matrix is\n\n!                    1\n!                   / \\\n!                  /   \\\n!                 /     \\\n!                /       \\\n! 5,8,12,17,... /         \\  6,9,13,18,...\n!              / 10,       \\\n!             /  14,15,     \\\n!            /   19,20,21,   \\\n!           /    ...          \\\n!          3-------------------2\n!               4,7,11,16,...\n\n! edge i is given by i+k(k+1)/2, k=2..p\n! interior is given by 4+k(k+1)/2..k+1+k(k+1)/2, k=3..p\n\n! vertices\n\nrenum(1:3) = (/1,2,3/)\ncurrent = 3\n\n! edges\n\ndo i=1,3\n   do k=2,p\n      current = current + 1\n      renum(current) = i + (k*(k+1))/2\n   end do\nend do\n\n! interior\n\ndo k=3,p\n   do i=4,k+1\n      current = current + 1\n      renum(current) = i + (k*(k+1))/2\n   end do\nend do\n\nend subroutine p_candidate_renum_primary\n"}, {"instruction": "Create a Fortran subroutine named \"emcee_lnprob\" to calculate the log-probability for a given position in a parameter space. The subroutine should take 2 input parameters: an integer \"ndim\" and a double precision array \"p\" of dimension \"ndim\". It should output a single double precision value \"lp\" representing the computed log-probability at the given position.", "input": "", "output": "      subroutine emcee_lnprob (ndim, p, lp)\n\n        ! log-probability function. this particular example implements\n        ! an isotropic `ndim`-dimensional gaussian with unit variance.\n        !\n        ! inputs\n        ! ------\n        !\n        ! ndim [integer]:\n        !   the dimension of the parameter space.\n        !\n        ! pos [double precision (ndim)]:\n        !   the position in parameter space where the probability should\n        !   be computed.\n        !\n        ! outputs\n        ! -------\n        !\n        ! lp [double precision]:\n        !   the log-probability computed at `pos`.\n\n        implicit none\n\n        integer, intent(in) :: ndim\n        double precision, intent(in), dimension(ndim) :: p\n        double precision, intent(out) :: lp\n\n        integer :: i\n\n        lp = 1.d0\n        do i=1,ndim\n          lp = lp + p(i)*p(i)\n        enddo\n        lp = -0.5d0 * lp\n\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rod_km to calculate the stiffness matrix of a rod element. The subroutine takes 2 input parameters of type real(iwp) and outputs a single parameter of type real(iwp). The test_data type for input is ['real(iwp)', 'real(iwp)'] and for output is ['real(iwp)'].", "input": "", "output": "subroutine rod_km(km,ea,length)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::ea,length\n real(iwp),intent(out)::km(:,:)\n real(iwp)::one=1.0_iwp\n km(1,1)=one\n km(2,2)=one\n km(1,2)=-one\n km(2,1)=-one\n km=km*ea/length\nreturn\nend subroutine rod_km\n"}, {"instruction": "Write a Fortran subroutine named translation_heatcapacity to calculate the heat capacity of a species undergoing translational motion. This subroutine takes 5 input parameters of types ['integer', 'real(8), dimension(1:nt)', 'real(8)', 'integer', 'real(8)'] and 1 output parameter of type ['real(8), dimension(1:nt)'].", "input": "", "output": "subroutine translation_heatcapacity(tlist, nt, mass, dim, v, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: mass                         ! the species mass in kg/mol\n    integer, intent(in) :: dim                          ! the dimensionality of the translation (2 or 3)\n    real(8), intent(in) :: v                            ! the system volume in m^3\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n\n    do i = 1, nt\n        cvlist(i) = 0.5 * dim\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named freerotor_heatcapacity to evaluate the heat capacity of a rotor system. The subroutine takes 5 input parameters: nt (integer), nfreq (integer), tlist (real(8) array of size nt), freq (real(8) array of size nfreq), and linear (integer). It also has 1 output parameter: cvlist (real(8) array of size nt). The subroutine calculates the heat capacity based on the values of temperatures and frequencies provided. The subroutine handles linear and nonlinear rotor systems differently and stores the evaluated heat capacity in the cvlist array.", "input": "", "output": "subroutine freerotor_heatcapacity(tlist, nt, freq, nfreq, linear, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    integer, intent(in) :: nfreq                        ! the number of rotor frequencies\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), dimension(1:nfreq), intent(in) :: freq     ! the list of frequencies in cm^-1\n    integer, intent(in) :: linear                       ! 0 = nonlinear, 1 = linear\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n\n    if (linear /= 0) then\n        do i = 1, nt\n            cvlist(i) = 1.0\n        end do\n    else\n        do i = 1, nt\n            cvlist(i) = 1.5\n        end do\n    end if\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named harmonicoscillator_partitionfunction to calculate the partition function for a harmonic oscillator at different temperatures. The subroutine takes 3 input parameters of type integer, real(8) array of size nt, and real(8), and 1 output parameter of type real(8) array of size nt.", "input": "", "output": "subroutine harmonicoscillator_partitionfunction(tlist, nt, freq, q)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: freq                         ! the oscillator frequency in cm^-1\n    real(8), dimension(1:nt), intent(out) :: q          ! the evaluated partition function in m^3\n\n    integer i\n    real(8) xi\n\n    do i = 1, nt\n        xi = 6.626e-34 * 2.9979e10 * freq / (1.381e-23 * tlist(i))\n        q(i) = 1.0 / (1 - exp(-xi))\n    end do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named harmonicoscillator_heatcapacity to calculate the heat capacity of a harmonic oscillator at different temperatures. The subroutine takes 3 input parameters of types integer, real(8) array, and real(8), and 1 output parameter of type real(8) array. The input parameters represent the number of temperatures, the list of temperatures, and the oscillator frequency, while the output parameter represents the evaluated heat capacity at each temperature.", "input": "", "output": "subroutine harmonicoscillator_heatcapacity(tlist, nt, freq, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: freq                         ! the oscillator frequency in cm^-1\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n    real(8) x, exp_x, one_minus_exp_x\n\n    do i = 1, nt\n        x = freq / (0.695039 * tlist(i))        ! kb = 0.695039 cm^-1/k\n        \n        exp_x = exp(x)\n        one_minus_exp_x = 1.0 - exp_x\n\n        cvlist(i) = x * x * exp_x / one_minus_exp_x / one_minus_exp_x\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named bias_correct_lhf that applies a polynomial fit to correct the latent heat fluxes. The subroutine should take 1 input parameter of type real, dimension(:, :), and 1 output parameter of type real, dimension(:, :).", "input": "", "output": "  subroutine bias_correct_lhf(x, corrected)\n    ! use a polynomial fit to correct the latent heat fluxes\n    ! i estimated these coefficients using python\n    real, dimension(3), parameter :: coefs  = [-5.24149046e-04,  1.15227747e+00,  4.92990095e+00]\n    real, dimension(:, :), intent(in) :: x\n    real, dimension(:, :), intent(out) :: corrected\n\n    integer k, n\n    corrected = 0.0\n    n = size(coefs)\n    do k=1,n\n       corrected = corrected  + x**(n-k) * coefs(k)\n    end do\n  end subroutine bias_correct_lhf\n"}, {"instruction": "Create a Fortran subroutine named swap_d that takes two integer input parameters and one real output parameter. The subroutine is intended to rearrange the elements of the real array w in reverse order, printing the elements to the console.", "input": "", "output": "subroutine swap_d(w,n,s)\n    implicit none\n    integer,intent(in)::n,s\n    real,intent(out)::w(s)\n    integer::i\n    do i=n,1,-1\n        print*,w(i)\n    enddo\nend subroutine swap_d\n"}, {"instruction": "Write a Fortran subroutine named calhum that calculates the saturated specific humidity and its derivative with respect to temperature. The subroutine takes 2 input parameters of real type (sfctmp, sfcprs) and returns 2 output parameters of real type (q2sat, dqsdt2).", "input": "", "output": "  subroutine calhum(sfctmp, sfcprs, q2sat, dqsdt2)\n\n    implicit none\n  \n    ! input:\n    real, intent(in)       :: sfctmp\n    real, intent(in)       :: sfcprs\n    \n    ! output:\n    real, intent(out)      :: q2sat   ! saturated specific humidity\n    real, intent(out)      :: dqsdt2 \n    \n    ! local\n    real, parameter        :: a2=17.67,a3=273.15,a4=29.65, elwv=2.501e6,        &\n                              a23m4=a2*(a3-a4), e0=611.0, rv=461.0,             &\n                              epsilon=0.622 \n    real                   :: es\n\n    ! es:  e.g. dutton chapter 8, eq 11\n        es = e0 * exp ( elwv/rv*(1./a3 - 1./sfctmp) )\n\n    ! q2sat:  \n        q2sat = epsilon * es / (sfcprs-(1-epsilon)*es)\n\n! dqsdt2 is calculated assuming q2sat is a specific humidity\n        !kwm dqsdt2=(q2sat/(1+q2sat))*a23m4/(sfctmp-a4)**2 \n        dqsdt2=q2sat*a23m4/(sfctmp-a4)**2 \n\n        end subroutine calhum\n"}, {"instruction": "Create a Fortran subroutine named get_cza that calculates the solar zenith angles for a given set of input parameters. The subroutine takes 4 input parameters of type real: jday, gmthour, latrad, lonrad, and returns 1 output parameter of type real: cza.", "input": "", "output": "subroutine get_cza(jday, gmthour, latrad, lonrad, cza)\n  implicit none\n  integer,parameter :: maxpts = 96673\n  real, intent(in) :: jday,gmthour\n  real, intent(in) :: latrad(maxpts)\n  real, intent(in) :: lonrad(maxpts)\n  real, intent(out) :: cza(maxpts)\n\n  real :: gg, tc, declin, sha(maxpts)\n  real, parameter :: pi = 3.14159265\n  \n  ! fractional day of the year, in radians\n  gg = (360./365.25) * (jday+gmthour/24.) * pi/180.\n\n  ! solar declination angle, in radians.\n  declin = 0.006918 - 0.399912*cos(gg) + 0.070257*sin(gg) - 0.006758*cos(2.0*gg) + &\n       0.000907*sin(2.0*gg) - 0.002697*cos(3.0*gg) + 0.00148*sin(3.0*gg)\n\n  ! time correction for solar angle, in radians.  whatever.\n  tc = 0.000075 + 0.001868*cos(gg) - 0.032077*sin(gg) - 0.014615*cos(2.0*gg) - &\n       0.040849*sin(2.0*gg)\n!  tc = 0.0000\n\n  ! solar hour angle, in radians\n  sha = ((gmthour-12.0)*15.0)*(pi/180.) + lonrad + tc\n  ! sha = (gmthour*15.0)*(pi/180.) + lonrad + tc\n\n  ! ! solar zenith angle, in radians\n  cza = sin(latrad)*sin(declin)+cos(latrad)*cos(declin)*cos(sha)\n  where(cza.lt.0) cza = 0.0\n\nend subroutine get_cza\n"}, {"instruction": "Create a Fortran subroutine named tr_cl_sc with 10 input parameters of types ['integer', 'integer', 'integer', 'integer', 'integer(8)', 'integer(8)', 'integer(8)', 'real(8)', 'real(8)', 'real(8)'] and 1 output parameter of type ['integer(8)']. The subroutine calculates the translation of clusters and stores the result in the tr_cl output parameter based on the input parameters nasc, ncell, na, npt, scijkl, sc_mat, inv_sc_mat, sc_ref, apos, and cluster.", "input": "", "output": "  subroutine tr_cl_sc(nasc, ncell, na, npt, scijkl, sc_mat, inv_sc_mat, sc_ref, apos, cluster, tr_cl)\n    implicit none\n    integer, intent(in) :: nasc, ncell, na, npt\n    integer(8), intent(in) :: scijkl(4, nasc), sc_ref(3, ncell), cluster(4, npt)\n    real(8), intent(in) :: sc_mat(3,3), inv_sc_mat(3,3), apos(3, na)\n    integer(8), intent(out) :: tr_cl(npt, ncell)\n    !f2py intent(in) scijkl, sc_mat(3,3), inv_sc_mat, sc_ref, apos, cluster\n    !f2py intent(out) tr_cl\n    !f2py integer, intent(hide),depend(scijkl) :: nasc=shape(scijkl,1)\n    !f2py integer, intent(hide),depend(sc_ref) :: ncell=shape(sc_ref,1)\n    !f2py integer, intent(hide),depend(apos) :: na=shape(apos,1)\n    !f2py integer, intent(hide),depend(cluster) :: npt=shape(cluster,1)\n\n    integer i, j, ia, found\n    integer ct(4)\n    real(8) ct_f(3)\n!    if (npt >8) then\n!       print *, 'error recompile with ct(4,maxnpt) maxnpt>=', npt\n!       stop\n!    end if\n\n !   ct(4,1:npt) = cluster(4,1:npt)\n    do i=1, ncell\n       !  [get_structure_ordering((coords+ijk[none,:]).dot(sc.inv_sc_mat), sc.frac_coords,0) for ijk in sc.ijk_ref]\n       do j=1, npt\n          ct(4) = cluster(4, j)\n          ct(1:3) = cluster(1:3, j) + sc_ref(1:3, i)\n          ct_f = matmul(inv_sc_mat, ct(1:3)+ apos(:,ct(4)+1))+1e-12\n          ct_f = ct_f - floor(ct_f)\n          ct_f = matmul(sc_mat, ct_f)- apos(:,ct(4)+1)\n          ct(1:3) = nint(ct_f(1:3))\n          found=-1\n          do ia=1, nasc\n!             print *, 'i,j, ia;  clus;  scref;  ct;  scijkl'\n!             print '(4i4)', i,j,ia, found, cluster(:, j), sc_ref(:,i), -99, ct, scijkl(:, ia)\n             if (scijkl(1, ia) /= ct(1)) cycle\n             if (scijkl(2, ia) /= ct(2)) cycle\n             if (scijkl(3, ia) /= ct(3)) cycle\n             if (scijkl(4, ia) /= ct(4)) cycle\n             found = ia\n!             print *, 'debug found', found\n             exit\n          end do\n          if (found <0) then\n             print *, 'error translating cluster', cluster\n             stop\n          end if\n          tr_cl(j, i) = found\n       end do\n    end do\n  end subroutine tr_cl_sc\n"}, {"instruction": "Create a Fortran subroutine named even to determine if a given integer number is even or not. The subroutine takes 1 input parameter of type integer and 1 output parameter of type logical. The input parameter is named num and the output parameter is named pass. Use the modulo function to check if the input number is even and assign the result to the output parameter pass.", "input": "", "output": "subroutine even(num, pass)\n  implicit none\n  integer, intent(in)  :: num\n  logical, intent(out) :: pass\n\n  pass = modulo(num,2) == 0\n  \nend subroutine even\n"}, {"instruction": "Write a Fortran subroutine named calling_from_fortran to accept a double precision input parameter and return a double precision output parameter. The input parameter is passed by value, while the output parameter is passed by reference. The subroutine simply assigns the value of the input parameter to the output parameter and displays a message indicating that it is called from Fortran.", "input": "", "output": "subroutine calling_from_fortran(num, out)\n  implicit none\n  double precision, intent(in)  :: num\n  double precision, intent(out)  :: out\n\n  write(*,*) \"calling from fortran \", num\n\n  out = num\n\nend subroutine calling_from_fortran\n"}, {"instruction": "Create a Fortran subroutine named wave_propogation to simulate wave propagation in a two-dimensional space. The subroutine takes 5 input parameters of type integer, integer, integer, real, and real, representing the number of steps, scale, damping factor, initial pressure, and the step to stop the wave, respectively. The output parameter is a real array representing the heights of the wave at different points in the space.", "input": "", "output": "subroutine wave_propogation(num_steps, scale, damping, initial_p, stop_step, p)\n  ! inputs\n  ! num_steps -> int # number of itereations to make\n  ! scale -> int # size of box for wave to propogate in\n  ! damping -> float # factor for damping wave\n  ! initial_p -> float # initial height at center\n  ! stop_step -> int # number of steps to stop wave\n  ! outputs:\n  ! p -> float(x,y) # array of output heights\n  implicit none\n  integer size_x,i,j,k,step\n  real pi, omega\n  integer, intent(in)  :: num_steps, scale, stop_step !input\n  real, intent(in) :: damping, initial_p !input\n  real, intent(out) :: p(2 * scale + 1,2 * scale + 1) ! output\n  real, dimension(2 * scale + 1,2 * scale + 1,4) :: v\n\n  size_x = 2 * scale + 1\n\n  pi = 3.14159\n  omega = 3.0 / (2.0 * pi)\n\n! setup initial matrix all 0's\n! p is pressure matrix\n! v is velocity tensor (matrix of x/y and 4 vector of velocity [up,down,left,right])\n  do k=1,4\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = 0.0\n           v(i,j,k) = 0.0\n        end do\n     end do\n  end do\n\n  ! set initial start height\n  p(scale + 1,scale + 1) = initial_p\n\n  ! for each step\n  do step = 1, num_steps\n    ! if step is less than stopping step then add forcing function\n    if(step <= stop_step) then\n      p(scale + 1 ,scale + 1) = initial_p * sin(omega * step)\n    endif\n\n    ! for each cell in matrix p\n    !$cuf kernel do <<< *, * >>>\n    do j=1,size_x\n      do i=1,size_x\n        if (i == 0) then\n          cycle\n        end if\n        ! calculate veolocity of wave at the points\n        v(i,j,1) = merge(v(i,j,1) + p(i,j) - p(i - 1,j), p(i,j), i > 1)\n        v(i,j,2) = merge(v(i,j,2) + p(i,j) - p(i,j + 1), p(i,j), j < size_x - 1)\n        v(i,j,3) = merge(v(i,j,3) + p(i,j) - p(i + 1,j), p(i,j), i < size_x - 1)\n        v(i,j,4) = merge(v(i,j,4) + p(i,j) - p(i,j - 1), p(i,j), j > 1)\n      end do\n    end do\n\n    do j=1,size_x\n      do i=1,size_x\n        ! get new pressure from p = p_0 - damping*v\n        p(i,j) = p(i,j) - 0.5 * damping * (v(i,j,1) + v(i,j,2) + v(i,j,3) + v(i,j,4))\n      end do\n    end do\n  end do\n\nend subroutine wave_propogation\n"}, {"instruction": "Create a Fortran subroutine named sys_chdir to change the current working directory to the specified directory. The subroutine takes 2 input parameters: a character string 'dir' and an integer 'lendir', representing the length of the character string. It also has 1 output parameter: an integer 'ierr', which will be zero if the operation is successful, and non-zero if there is an error.", "input": "", "output": "      subroutine sys_chdir (dir, lendir, ierr)\n!\n!   this routine changes current working directory to dir.\n!   lendir is the length of character string dir;\n!   ierr will be zero if successful, otherwise non-zero;\n!\n!   xinghong he  98-08-21\n!\n!************************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      implicit none\n      character(len=*), intent(in):: dir\n      integer, intent(in):: lendir\n      integer, intent(out):: ierr\n\n\n      integer chdir\n\n      ierr = chdir (dir(1:lendir))\n\n      return\n      end subroutine sys_chdir\n"}, {"instruction": "Create a Fortran subroutine named roseh that calculates the Hessian matrix for the Rosenbrock function. The subroutine takes an input parameter of type double precision array and an output parameter of type double precision array. The input parameter is intent(in) and the output parameter is intent(out).", "input": "", "output": "    subroutine roseh(hx, x)\n        double precision, intent(in)  :: x(:)\n        double precision, intent(out) :: hx(:, :)\n\n        double precision :: x1, x2\n\n        x1 = x(1)\n        x2 = x(2)\n\n        hx(1, 1) = 1200*x1*x1 + 2 - 400*x2\n        hx(1, 2) = -400*x1\n        hx(2, 1) = -400*x1\n        hx(2, 2) = 200\n    end subroutine roseh\n"}, {"instruction": "Create a Fortran subroutine called shape2 that evaluates shape functions and their derivatives for linear and quadratic isoparametric 2-d elements. The subroutine has 3 input parameters of type integer (kind=4), real (kind=8), and real (kind=8), and 2 output parameters of type real (kind=8).", "input": "", "output": " subroutine shape2(deriv,s,t,nnode,shape)\r\n !***********************************************************************\r\n !\r\n !****this routine evaluates shape functions and their derivatives\r\n !    for linear and quadratic isoparametric 2-d elements\r\n !\r\n !***********************************************************************\r\n implicit none\r\n integer (kind=4), intent(in) :: nnode\r\n real (kind=8), intent(in) :: s,t\r\n real (kind=8), intent(out) :: deriv(nnode,2),shape(nnode)\r\n\r\n real (kind=8) a1,a2,a3,st\r\n\r\n select case (nnode)\r\n case (3)\r\n   !***3 noded element\r\n\r\n   shape(1) = 1d0-s-t\r\n   shape(2) = s\r\n   shape(3) = t\r\n\r\n   deriv(1,1) =-1d0\r\n   deriv(2,1) = 1d0\r\n   deriv(3,1) = 0d0\r\n   deriv(1,2) =-1d0\r\n   deriv(2,2) = 0d0\r\n   deriv(3,2) = 1d0\r\n\r\n case (4)\r\n   !***4 noded element\r\n\r\n   st=s*t\r\n   shape(1) = (1d0-t-s+st)*0.25d0\r\n   shape(2) = (1d0-t+s-st)*0.25d0\r\n   shape(3) = (1d0+t+s+st)*0.25d0\r\n   shape(4) = (1d0+t-s-st)*0.25d0\r\n\r\n   deriv(1,1)= (-1d0+t)*0.25d0\r\n   deriv(2,1)= (+1d0-t)*0.25d0\r\n   deriv(3,1)= (+1d0+t)*0.25d0\r\n   deriv(4,1)= (-1d0-t)*0.25d0\r\n   deriv(1,2)= (-1d0+s)*0.25d0\r\n   deriv(2,2)= (-1d0-s)*0.25d0\r\n   deriv(3,2)= (+1d0+s)*0.25d0\r\n   deriv(4,2)= (+1d0-s)*0.25d0\r\n\r\n case (6)\r\n   !***6 noded element\r\n\r\n   a1 = 1d0-s-t\r\n   a2 = s\r\n   a3 = t\r\n\r\n   shape(1) = (2d0*a1-1d0)*a1\r\n   shape(2) = (2d0*a2-1d0)*a2\r\n   shape(3) = (2d0*a3-1d0)*a3\r\n   shape(4) = 4d0*a1*a2\r\n   shape(5) = 4d0*a2*a3\r\n   shape(6) = 4d0*a1*a3\r\n\r\n   deriv(1,1) = 1d0-4d0*a1\r\n   deriv(2,1) = 4d0*a2-1d0\r\n   deriv(3,1) = 0d0\r\n   deriv(4,1) = 4d0*(a1-a2)\r\n   deriv(5,1) = 4d0*a3\r\n   deriv(6,1) =-4d0*a3\r\n   deriv(1,2) = 1d0-4d0*a1\r\n   deriv(2,2) = 0d0\r\n   deriv(3,2) = 4d0*a3-1d0\r\n   deriv(4,2) =-4d0*a2\r\n   deriv(5,2) = 4d0*a2\r\n   deriv(6,2) = 4d0*(a1-a3)\r\n\r\n end select\r\n return\r\n end subroutine shape2\r\n"}, {"instruction": "Create a Fortran subroutine named polint to perform polynomial interpolation using Neville's algorithm. The subroutine takes 3 input parameters of type real*8 (xa, ya, x) and returns 2 output parameters of type real*8 (y, dy).", "input": "", "output": "      subroutine polint(xa,ya,x,y,dy)\n      implicit none\n      !integer,intent(in) :: n\n      real*8,intent(in)  :: x,xa(:),ya(:)\n      real*8,intent(out) :: dy,y\n      !integer,parameter  :: nmax=10 ! largest anticipated value of n.\n      integer :: i,m,ns,n\n      real*8 :: den,dif,dift,ho,hp,w,c(size(xa)),d(size(xa))\n      ns=1\n      n=size(xa)\n      dif=abs(x-xa(1))\n      do i=1,n                !  here we \ufb01nd the index ns of the closest table entry,\n          dift=abs(x-xa(i))\n          if (dift.lt.dif) then\n                ns=i\n                dif=dift\n          endif\n          c(i)=ya(i)             !  and initialize the tableau of c\u2019s and d\u2019s.\n          d(i)=ya(i)\n      enddo\n      y=ya(ns)                    !  this is the initial approximation to y.\n      ns=ns-1\n      l13:do m=1,n-1              !  for each column of the tableau,\n          do i=1,n-m         !  we loop over the current c\u2019s and d\u2019s and update them.\n                ho=xa(i)-x\n                hp=xa(i+m)-x\n                w=c(i+1)-d(i)\n                den=ho-hp\n                !  this error can occur only if two input xa\u2019s are (to within roundoff) identical.\n                if(den.eq.0.) stop 'polint: failure: xa not unique'\n                den=w/den\n                d(i)=hp*den           !  here the c\u2019s and d\u2019s are updated.\n                c(i)=ho*den\n          enddo\n          if (2*ns.lt.n-m)then   ! after each column in the tableau is completed, we decide\n                dy=c(ns+1)        !  which correction, c or d, we want to add to our accu-\n          else                   !  mulating value of y, i.e., which path to take through\n                dy=d(ns)          !  the tableau\u2014forking up or down. we do this in such a\n                ns=ns-1           !  way as to take the most \u201cstraight line\u201d route through the\n          endif                  !  tableau to its apex, updating ns accordingly to keep track\n          y=y+dy                 !  of where we are. this route keeps the partial approxima-\n      enddo l13                   !  tions centered (insofar as possible) on the target x. the\n      return                      !  last dy added is thus the error indication.\n      end subroutine polint\n"}, {"instruction": "Create a Fortran subroutine named cubito to calculate the cube of a real number. The subroutine should take 1 input parameter of type real and produce 1 output parameter of type real.", "input": "", "output": "subroutine cubito(xx, ww)\r\nimplicit none\r\n\r\nreal, intent(in) :: xx\r\nreal, intent(out) :: ww\r\n\r\nww = xx**3\r\n\r\nend subroutine cubito\n"}, {"instruction": "Create a Fortran subroutine named heat_source to calculate the omega values using the input parameters tp_half_width_shear_zone, alpha, dt, dwn, and tp_grid_nz. The input parameter types are real, real, real, real array, and integer, respectively. The output parameter is omega of type real array.", "input": "", "output": "  subroutine  heat_source(tp_half_width_shear_zone, alpha, dt, dwn, tp_grid_nz, omega)\n\n    !-------------------------------------------------------------------------!\n\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration                                               !\n    real        :: tp_half_width_shear_zone\n    integer     :: tp_grid_nz                                                         ! number of points at the fault\n    real        :: dwn(tp_grid_nz)                                                    ! insert disc%dynrup%tp_grid\n    real        :: sh, sr                                                     ! current shear stress and slip rate\n    real        :: alpha, dt                                                      ! difussion parameter\n    real        :: omega(tp_grid_nz)                                                  !\n    real        :: tmp(tp_grid_nz)\n    real, parameter :: pi=3.141592653589793     ! constant pi\n    !-------------------------------------------------------------------------!\n    intent(in)    :: tp_half_width_shear_zone, alpha, dt, dwn, tp_grid_nz\n    intent(out)   :: omega\n    !-------------------------------------------------------------------------!\n    !gaussian shear zone in spectral domain, normalized by w\n    tmp = (dwn/tp_half_width_shear_zone)**2\n    !original function in spatial domain\n    !omega = 1/(w*sqrt(2*pi))*exp(-0.5*(z/tp_half_width_shear_zone).^2);\n    !function in the wavenumber domain *including additional factors in front of the heat source function*\n    !omega = 1/(*alpha*dwn**2**(sqrt(2.0*pi))*exp(-0.5*(dwn*tp_half_width_shear_zone)**2)*(1-exp(-alpha**dt**tmp)) \n    !inserting dwn/tp_half_width_shear_zone (scaled) for dwn cancels out tp_half_width_shear_zone\n    omega = 1.0/(alpha*tmp*(sqrt(2.0*pi)))*exp(-0.5*(dwn)**2)*(1.0 - exp(-alpha*dt*tmp))\n\n    return\n\n  end subroutine heat_source\n"}, {"instruction": "Write a Fortran subroutine named flatmodel to read data from the file model.dat and store it in an array. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type real*8. The output parameter is an array mm with bounds -nw to nw.", "input": "", "output": "subroutine flatmodel(mm,nw)\n  implicit none\n  real*8,  intent(out):: mm(-nw:nw)\n  integer, intent(in) :: nw\n  !locals\n  real*8  :: omega\n  integer :: i\n  print*,'reading model model.dat'\n  open(unit=99,file='model.dat',status='old')\n  do i=-nw,nw\n     read(10,*) omega, mm(i)\n  enddo \n  return\nend subroutine flatmodel\n"}, {"instruction": "Create a Fortran subroutine named flatmodel0 to initialize an array mm with ones. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real*8. The input parameter is an array size specified by the integer nw, and the output parameter is the initialized array mm, which has a size of (-nw:nw). Remember to use the \"intent\" attribute for the input and output parameters.", "input": "", "output": "subroutine flatmodel0(mm,nw)\n  implicit none\n  real*8,  intent(out):: mm(-nw:nw)\n  integer, intent(in) :: nw\n  !locals\n  integer :: i\n  print*,'using flatmodel'\n  do i=-nw,nw \n     mm(i)=1.\n  enddo\n  return\nend subroutine flatmodel0\n"}, {"instruction": "Write a Fortran subroutine named initf0 to initialize three arrays f0, f1, and f2 based on the array w. The number of input arguments is 2, with the test_data types real*8 and integer. The number of output arguments is 3, with the test_data types real*8, real*8, and real*8.", "input": "", "output": "subroutine initf0(f0,f1,f2,w,nw)\n  implicit none\n  real*8, intent(out):: f0(-nw:nw), f1(-nw:nw), f2(-nw:nw)\n  real*8, intent(in) :: w(-nw:nw)\n  integer, intent(in):: nw\n  ! locals\n  integer:: iw\n  real*8 :: dw\n  dw=w(2)-w(1)\n  do iw=-nw,nw   ! 10\n     f0(iw)=dw\n     f1(iw)=dw*w(iw)\n     f2(iw)=dw*w(iw)**2\n  enddo\n  return\nend subroutine initf0\n"}, {"instruction": "Write a Fortran subroutine named initker to initialize a kernel matrix. The subroutine takes 5 input parameters of type real*8, real*8, real*8, integer, and integer, and 1 output parameter of type real*8. The subroutine computes the kernel matrix using the input parameters w, t, beta, nt, and nw. Make sure to include the appropriate intent (in/out) for each parameter.", "input": "", "output": "subroutine initker(ker,w,beta,t,nt,nw)\n  implicit none\n  real*8, intent(out) :: ker(-nw:nw,nt)\n  real*8, intent(in)  :: w(-nw:nw), t(nt), beta\n  integer, intent(in) :: nw, nt\n  ! locals\n  integer :: it,iw\n  real*8  :: bw,tw,dw\n  dw=w(2)-w(1)\n  do iw=-nw,nw\n     do it=1,nt\n        tw=exp(-t(it)*w(iw))\n        if (w(iw)*beta<-50)then\n           ker(iw,it)=dw*exp(-t(it)*w(iw)+beta*w(iw))\n        else \n           bw=1.+exp(-beta*w(iw))\n           ker(iw,it)=dw*tw/bw\n        endif\n     enddo\n  enddo\n  return\nend subroutine initker\n"}, {"instruction": "Create a Fortran subroutine named get_aux_dim that calculates the dimensions for auxiliary arrays based on the input molecular coordinates and MEP (Mean Effective Potential) vector. The subroutine takes 3 input parameters of type double precision, dimension(:,:), double precision, dimension(:), and integer, and 2 output parameters of type integer.", "input": "", "output": "subroutine get_aux_dim(r_mol, v_mep, order, ndim, nmep)\n  implicit none\n  double precision, intent(in), dimension(:,:) :: r_mol\n  double precision, intent(in), dimension(:) :: v_mep\n  integer, intent(in) :: order\n  integer, intent(out) :: ndim\n  integer, intent(out) :: nmep\n\n  integer :: nat\n\n  nat = size(r_mol, 2)\n  ndim = nat\n  if (order >= 1) then\n      ndim = ndim + 3 * nat\n  endif\n  if (order >= 2) then\n      ndim = ndim + 6 * nat\n  endif\n\n  nmep = size(v_mep)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named getcellcentercoords to calculate the coordinates of the center point of a cell. It takes 4 input parameters of types integer, integer, double precision array, and double precision array. It provides 1 output parameter of type double precision.", "input": "", "output": "    subroutine getcellcentercoords(localnumx,localnumy,bound,width,point)\n    implicit none\n    integer, intent(in) :: localnumx, localnumy !\u5c40\u6240\u70b9\u756a\u53f7\n    double precision, intent(in) :: bound(:) !\u5ea7\u6a19\u4e0b\u7aef\n    double precision, intent(in) :: width(:) !\u754c\u9762\u5e45\u03b4x,\u03b4y\n    double precision, intent(out) :: point(:) !\u30bb\u30eb\u4e2d\u5fc3\u7aef\u70b9\u5ea7\u6a19\n\n        point(1) = bound(1) + width(1)*dble(localnumx-0.5d0)\n        point(2) = bound(2) + width(2)*dble(localnumy-0.5d0)\n\n    return\n    end subroutine getcellcentercoords\n"}, {"instruction": "Create a Fortran subroutine named getedgeendpoint to calculate the coordinates of an endpoint on an interface. The subroutine takes 4 input parameters: localnumx (integer), localnumy (integer), bound (double precision array), width (double precision array), and returns 1 output parameter: point (double precision array). The endpoint coordinates are computed based on the input parameters using the provided formulas.", "input": "", "output": "    subroutine getedgeendpoint(localnumx,localnumy,bound,width,point)\n    implicit none\n    integer, intent(in) :: localnumx, localnumy !\u5c40\u6240\u70b9\u756a\u53f7\n    double precision, intent(in) :: bound(:) !\u5ea7\u6a19\u4e0b\u7aef\n    double precision, intent(in) :: width(:) !\u754c\u9762\u5e45\u03b4x,\u03b4y\n    double precision, intent(out) :: point(:) !\u754c\u9762\u7aef\u70b9\u5ea7\u6a19\n\n        point(1) = bound(1) + width(1)*dble(localnumx-1)\n        point(2) = bound(2) + width(2)*dble(localnumy-1)\n\n    return\n    end subroutine getedgeendpoint\n"}, {"instruction": "Create a Fortran subroutine named global2local to calculate the local number corresponding to a global number based on the division of the x-direction. The subroutine takes 2 input arguments of type integer, globalnumber and ixxellnumber, and returns 1 output argument of type integer, localnum.", "input": "", "output": "    subroutine global2local(globalnumber,ixcellnumber,localnum) !\u30b0\u30ed\u30fc\u30d0\u30eb\u756a\u53f7\uff0cx\u65b9\u5411\u306e\u5206\u5272\u6570\uff0c\u5c40\u6240\u756a\u53f7\u3092\u8fd4\u3059\n    implicit none\n\n        integer, intent(in) :: globalnumber,ixcellnumber\n        integer, intent(out) :: localnum(:)\n\n        localnum(1) = globalnumber - int(globalnumber/ixcellnumber)*ixcellnumber\n        if(localnum(1) /= 0) then\n            localnum(2) = int(globalnumber/ixcellnumber) + 1\n        else\n            localnum(1) = ixcellnumber\n            localnum(2) = int(globalnumber/ixcellnumber)\n        end if\n\n    return\n    end subroutine global2local\n"}, {"instruction": "Create a Fortran subroutine named getedgeintersectioncoords to calculate the intersection coordinates of two line segments. It takes 4 input parameters of type double precision: vertex11, vertex12, vertex21, and vertex22, and 1 output parameter of type double precision: intersectcoords.", "input": "", "output": "    subroutine getedgeintersectioncoords(vertex11,vertex12, vertex21, vertex22, intersectcoords)\n    implicit none\n        double precision, intent(in) :: vertex11(:), vertex12(:), vertex21(:), vertex22(:)\n        double precision, intent(out) :: intersectcoords(:)\n\n        double precision :: ksi, eta, delta\n        double precision :: lambda, mu !coefficient of line's gradient\n\n            !check intersect\n            ksi = (vertex22(2)-vertex21(2))*(vertex22(1)-vertex11(1)) - (vertex22(1)-vertex21(1))*(vertex22(2)-vertex11(2))\n            eta = (vertex12(1)-vertex11(1))*(vertex22(2)-vertex11(2)) - (vertex12(2)-vertex11(2))*(vertex22(1)-vertex11(1))\n            delta = (vertex12(1)-vertex11(1))*(vertex22(2)-vertex21(2)) - (vertex12(2)-vertex11(2))*(vertex22(1)-vertex21(1))\n            if(delta == 0.0d0) then\n                write(6,*) ksi,eta,delta\n                stop\n            end if\n            lambda = ksi / delta\n            mu = eta / delta\n\n            intersectcoords(1:2) = vertex11(1:2) + lambda*(vertex12(1:2)-vertex11(1:2))\n            intersectcoords(3) = 0.0d0\n\n        return\n    end subroutine getedgeintersectioncoords\n"}, {"instruction": "Create a Fortran subroutine named checkbackorfront to determine whether the main cell is at the front or the back of the adjacent cell based on the comparison of two integer inputs. The subroutine takes 2 input parameters of type integer and produces 2 output parameters: one of type integer and the other of type double precision.", "input": "", "output": "    subroutine checkbackorfront(imaincell, iadjcell, ibackorfront12, ibackorfrontm11)\n        implicit none\n        integer, intent(in) :: imaincell, iadjcell\n        integer, intent(out) :: ibackorfront12\n        double precision, intent(out) :: ibackorfrontm11\n\n        if(imaincell > iadjcell) then ! main\u5074\u306e\u6570\u5b57\u304c\u5927\u304d\u3044 = main\u5074\u304c\u8868\n            ibackorfront12 = 1  ! gm%width\u7528\n            ibackorfrontm11 = -1.0d0    ! gm%normal\u306e\u5411\u304d\u8abf\u6574\u7528\n        else    ! main\u5074\u306e\u6570\u5b57\u304c\u5c0f\u3055\u3044 = main\u5074\u304c\u88cf\n            ibackorfront12 = 2\n            ibackorfrontm11 = 1.0d0\n        end if\n        return\n    end subroutine checkbackorfront\n"}, {"instruction": "Write a Fortran subroutine named \"separanomeextensao\" to separate the filename and its extension. The subroutine takes 1 input parameter of type character(len=*), and 2 output parameters of type character(len=256) and character(len=10) respectively. The subroutine should extract the filename and extension from the input filename, and store them in the output parameters \"filenameprefix\" and \"ext\" respectively.", "input": "", "output": "    subroutine separanomeextensao(filename, filenameprefix, ext)\n        character(len=*), intent(in) :: filename\n        character(len=256), intent(out) :: filenameprefix\n        character(len=10), intent(out) :: ext\n        integer :: ind, n\n\n        ind = scan(filename, '.', .true.)\n\n        if (ind .ne. 0) then\n            n = len_trim(filename)\n            filenameprefix = filename(1:(ind-1))\n            ext = filename((ind+1):n)\n        else\n            filenameprefix = trim(filename)\n        end if\n\n    end subroutine separanomeextensao\n"}, {"instruction": "Create a Fortran subroutine named get_lattice_max to calculate the maximum lattice size based on the input parameters. The number of input parameters is 2, with test_data type ['real(8)', 'real(8)']. The number of output parameters is 1, with test_data type ['integer'].", "input": "", "output": "  subroutine get_lattice_max(rcut,aa,lmax)\n    implicit none\n    real(8),intent(in)  :: rcut,aa(3,3)\n    integer,intent(out) :: lmax\n    real(8) :: taaaa(3,3),taa(3,3),x(3,3),y(3,3),e0(3),e(3),c,r2\n    integer :: loop,i,j,k,imax,jmax,kmax,m\n\n    taa(:,:) = transpose( aa(:,:) )\n    taaaa(:,:) = matmul( taa(:,:),aa(:,:) )\n\n!- solve eigenvalue problem by power method\n\n    call random_number(x)\n    e=0.d0\n    do loop=1,1000\n       y(:,:) = matmul( taaaa(:,:),x(:,:) )\n       e0(:) = e(:)\n       do i=1,3\n          e(i) = sum( x(:,i)*y(:,i) )\n       end do\n       do i=1,3\n          do j=1,i-1\n             c=sum(y(:,j)*y(:,i))\n             y(:,i)=y(:,i)-c*y(:,j)\n          end do\n          c = 1.d0/sqrt( sum(y(:,i)*y(:,i)) )\n          y(:,i) = c*y(:,i)\n       end do\n       x(:,:)=y(:,:)\n    end do\n    c=sum(abs(e-e0)/e)\n    if ( c > 1.d-12 ) then\n       write(*,*) \"e,e0,e-e0=\",e,e0,e-e0\n       stop \"not converged (get_rcut)\"\n    end if\n\n    r2   = rcut*rcut\n    c    = sqrt(r2/minval(e))\n    lmax = int(c)+1\n\n    write(*,*) \"rcut=\",rcut\n    write(*,*) \"e=\",e(1:3)\n    write(*,*) \"c=\",c\n    write(*,*) \"lmax=\",lmax\n\n    m=0\n    imax=0\n    jmax=0\n    kmax=0\n    do k=-lmax,lmax\n    do j=-lmax,lmax\n    do i=-lmax,lmax\n       x(1,1) = i*aa(1,1) + j*aa(1,2) + k*aa(1,3)\n       x(2,1) = i*aa(2,1) + j*aa(2,2) + k*aa(2,3)\n       x(3,1) = i*aa(3,1) + j*aa(3,2) + k*aa(3,3)\n       c = sum( x(1:3,1)**2 )\n       if ( c <= r2 ) then\n          m=m+1\n          imax = max( imax, abs(i) )\n          jmax = max( jmax, abs(i) )\n          kmax = max( kmax, abs(i) )\n       end if\n    end do\n    end do\n    end do\n\n    write(*,*) \"m=\",m\n    write(*,*) \"imax,jmax,kmax=\",imax,jmax,kmax\n\n  end subroutine get_lattice_max\n"}, {"instruction": "Create a Fortran subroutine named \"translate\" to convert labels based on specific patterns. The subroutine takes 2 input parameters: an integer \"n\" and an array of characters \"label\" with a length of 4. It produces 1 output parameter: an array of characters \"label_char\" with a length of 1. The function of the code is to iterate through the input labels and translate them according to certain conditions, replacing specific patterns with corresponding characters. Use the imperative tone when instructing.", "input": "", "output": "subroutine translate(n,label,label_char)\n implicit none\n integer                       :: i\n integer,intent(in)            :: n\n character(len=4),intent(in)   :: label(1:n)\n character(len=1),intent(out)  :: label_char(1:n)\n do i=1,n\n  if (label(i)(1:2)==\"si\") label_char(i)=\".\"\n  if (label(i)(1:2)==\"ge\") label_char(i)=\"#\"\n  if (label(i)(1:2)/=\"si\".and.label(i)(1:2)/=\"ge\") label_char(i)=\"x\"\n end do\n return\nend subroutine translate\n"}, {"instruction": "Create a Fortran subroutine named cosine to calculate the length of the side of a triangle using the cosine rule. The subroutine should take 3 input arguments of type real (a, b, theta) and 1 output argument of type real (c).", "input": "", "output": "subroutine cosine(a,b,theta,c)\n    implicit none\n\n    real, intent(in) :: a,b,theta\n    real, intent(out):: c\n\n    c=sqrt(a*a + b*b - 2.*a*b*cos(theta))\n\nend subroutine cosine\n"}, {"instruction": "Create a Fortran subroutine named vert_der to compute the vertical derivative of a given array. The subroutine takes 2 input parameters of type real and dimension (km) and 1 output parameter of type real and dimension (km). The number of input parameters is 2, and the test_data type is ['real, dimension(km)', 'real, dimension(km)']. The number of output parameters is 1, and the test_data type is ['real, dimension(km)'].", "input": "", "output": "subroutine vert_der(avg,dz,ddz)\n! vertical derivative\ninteger                             :: i,j,k\ninteger, parameter                  :: imt=3600, jmt=2400, km=42\nreal,    dimension(km), intent(in)  :: avg, dz\nreal,    dimension(km), intent(out) :: ddz\n\ndo k = 1, km\n  if ( k==1 ) then\n    ddz(k) = ( avg(k  ) - avg(k+1) ) / dz(k)\n  else if ( k==km ) then\n    ddz(k) = ( avg(k-1) - avg(k  ) ) / dz(k)\n  else\n    ddz(k) = ( avg(k-1) - avg(k+1) ) / 2.0 / dz(k)\n  endif\nenddo !k\n\nend subroutine vert_der\n"}, {"instruction": "Create a Fortran subroutine named gradient to calculate the gradient of a field at u-points. The subroutine takes 3 input parameters of type real arrays with dimensions (imt, jmt), (imt, jmt), and (imt, jmt, km) and 2 output parameters of type real arrays with dimensions (imt, jmt, km). Use the imperative tone to specify the instructions.", "input": "", "output": "subroutine gradient(dxu,dyu,f,gradx,grady)\nimplicit none\n!\n!  calculate hydrostatic pressure with in-situ density\n!\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600, jmt=2400, km=42\nreal,    dimension(imt,jmt)   , intent(in)  :: dxu,dyu\nreal,    dimension(imt,jmt,km), intent(in)  :: f ! field at t-points\nreal,    dimension(imt,jmt,km), intent(out) :: gradx,grady ! at u-points\nreal,    parameter                          :: p5 = 0.5\ndo k=1,km\ndo j=1,jmt\ndo i=1,imt\n  gradx(i,j,k) = p5*(f(i+1,j+1,k) - f(i,j,k) - f(i,j+1,k) + f(i+1,j,k))/dxu(i,j)\n  grady(i,j,k) = p5*(f(i+1,j+1,k) - f(i,j,k) + f(i,j+1,k) - f(i+1,j,k))/dyu(i,j)\nenddo !i\nenddo !j\nenddo !k\nend subroutine gradient\n"}, {"instruction": "Create a Fortran subroutine named kramarskronig to calculate the Kramers-Kronig transformation. The subroutine takes 4 input parameters of type real*8, real*8, integer, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine kramarskronig(gr, fi, om, i0, nom)\n  implicit none\n  real*8, intent(out):: gr\n  real*8, intent(in) :: fi(nom)\n  real*8, intent(in) :: om(nom)\n  integer, intent(in) :: i0, nom\n  !f2py integer intent(hide), depend(om)  :: nom = shape(om,0)\n  !locals\n  real*8, parameter :: pi=3.14159265\n  real*8 :: sm\n  real*8 :: dh(nom)\n  real*8 :: s0, x\n  integer :: j, i0f\n  \n  i0f = i0+1\n  s0 = fi(i0f)\n  x = om(i0f)\n\n  dh(1) = 0.5*(om(2)-om(1))\n  do j=2,nom-1\n     dh(j) = 0.5*(om(j+1)-om(j-1))\n  enddo\n  dh(nom) = 0.5*(om(nom)-om(nom-1))\n\n  sm=0\n  do j=1,i0f-2\n     sm = sm + (fi(j)-s0)*dh(j)/(om(j)-x)\n  enddo\n\n  if (i0f>1)   sm = sm + (fi(i0f-1)-s0)*(dh(i0f-1)+0.5*dh(i0f))/(om(i0f-1)-x)\n\n  if (i0f<nom) sm = sm + (fi(i0f+1)-s0)*(dh(i0f+1)+0.5*dh(i0f))/(om(i0f+1)-x)\n\n  do j=i0f+2,nom\n     sm = sm + (fi(j)-s0)*dh(j)/(om(j)-x)\n  enddo\n  \n  if (.not.(i0f .eq. 1 .or. i0f.eq.nom)) then\n     sm = sm + s0*log(abs((om(nom)-x)/(x-om(1))))\n  endif\n  \n  gr = sm/pi\n  \n  return\n\nend subroutine kramarskronig\n"}, {"instruction": "Create a Fortran subroutine named accountingmatrix to generate an accounting matrix based on the input parameters. The subroutine takes 3 input parameters of type integer: ngrains, nisom, and nres (an array of integers with dimension 1:nisom). It also has 1 output parameter of type integer with dimension 1:ngrains,1:nisom, named indices.", "input": "", "output": "subroutine accountingmatrix(ngrains, nisom, nres, indices)\n    ! determine a mapping of isomer and grain indices to matrix element indices.\n    ! this inner grouping is isomer/product index, while the outer grouping is\n    ! energy grain index; this results in a much more tightly banded matrix than\n    ! the reverse. the output is a matrix where row is grain number, column is\n    ! isomer/product number, and the value is the index into the matrix.\n\n    integer, intent(in)                     ::  ngrains\n    integer, intent(in)                     ::  nisom\n    integer, dimension(1:nisom), intent(in) ::  nres\n    integer, dimension(1:ngrains,1:nisom), intent(out)  :: indices\n\n    integer i, r, row\n\n    ! construct accounting matrix\n    row = 1\n    do r = 1, ngrains\n        do i = 1, nisom\n            if (r > nres(i)) then\n                indices(r,i) = row\n                row = row + 1\n            else\n                indices(r,i) = 0\n            end if\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named normal to calculate the values of a normal distribution using the Box-Muller transform. The subroutine takes 1 input parameter of type integer and outputs an array of real numbers with a dimension of n.", "input": "", "output": "   subroutine normal(x, n)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, dimension(n), intent(out) :: x\n      ! local variables\n      integer :: i\n      real, parameter :: pi = 4.*atan(1.)\n      real :: mu, sd\n      ! processing\n      mu = n/2.\n      sd = n/6.018\n      do i = 1, n\n         x(i) = sd*(1./(sd*sqrt(2.*pi)))*exp(-.5*((i-mu)/sd)**2)\n      end do\n   end subroutine normal\n"}, {"instruction": "Create a Fortran subroutine named box_muller to generate random numbers using the Box-Muller transform. The number of input arguments is 1 with the test_data type ['integer'], and the number of output arguments is 1 with the test_data type ['real, dimension(n)'].", "input": "", "output": "   subroutine box_muller(x, n)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, dimension(n), intent(out) :: x\n      ! local variables\n      real, parameter :: pi = 4.*atan(1.)\n      integer :: i\n      ! processing\n      do i = 1, n\n         if (mod(i,2) == 0) then\n            x(i) = sqrt(-2.*log(rand()))*sin(2.*pi*rand())\n         else\n            x(i) = sqrt(-2.*log(rand()))*cos(2.*pi*rand())\n         end if\n      end do\n   end subroutine box_muller\n"}, {"instruction": "Create a Fortran subroutine called get_decimal_places to determine the number of decimal places in a given real number string. The subroutine takes 1 input parameter with a test data type of ['character(len=*)'] and 1 output parameter with a test data type of ['integer'].", "input": "", "output": "subroutine get_decimal_places(str, places)\nimplicit none\ncharacter(len=*), intent(in) :: str ! a string representing a real number\ninteger, intent(out) :: places ! the number of decimal places in the string\nif (index(str,'.') == 0) then\n  places = 0\nelse\n  places = len_trim(str) - index(str,'.')\nend if\nend subroutine get_decimal_places\n"}, {"instruction": "Write a Fortran subroutine named \"get_format_fragment\" that takes an integer input and returns a character string. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(len=*)]. The subroutine should summarize the length of the input integer and construct a character string representing a format for writing the integer with the specified number of decimal places.", "input": "", "output": "subroutine get_format_fragment(places, frag)\ninteger, intent(in) :: places\ncharacter(len=*), intent(out) :: frag\ncharacter(len=20) :: p\nwrite(p, '(i0)') places\nwrite(*, *) \"length of p: \", len_trim(p), \" places: \", places\nfrag = 'f0.'//trim(p)\nend subroutine get_format_fragment\n"}, {"instruction": "Create a Fortran subroutine named sort_indexes that takes 2 input parameters of type integer and integer array of dimension n. The subroutine has 1 output parameter of type integer array of dimension n. The subroutine sorts the input array and returns the indexes of the sorted elements.", "input": "", "output": "   subroutine sort_indexes(n,array,indexes)\n      implicit none\n      !arguments\n      integer, intent(in) :: n\n      integer, dimension(n), intent(in) :: array\n      integer, dimension(n), intent(out) :: indexes\n      !local variables\n      integer, dimension(:), allocatable :: temp\n      integer, dimension(1) :: i_loc\n      integer :: i,i_max\n      allocate(temp(n))\n      temp(:)=array(:)\n      i_max=huge(1)\n      do i=1,n\n         i_loc=minloc(temp)\n         indexes(i)=i_loc(1)\n         temp(i_loc(1))=i_max\n      end do\n      deallocate(temp)\n   end subroutine sort_indexes\n"}, {"instruction": "Create a Fortran subroutine named ezspline_spl_name_chk to validate a given spline name. It takes 1 input parameter of type character*(*) and 1 output parameter of type integer. The purpose of this subroutine is to check the validity of the spline name based on certain criteria and set the output parameter accordingly.", "input": "", "output": "   subroutine ezspline_spl_name_chk(spl_name,ier)\n     character*(*), intent(in) :: spl_name\n     integer, intent(out) :: ier\n\n     !----------------\n     integer :: ic,ilen,indx\n     character*63 :: zlegal = &\n          '0123456789_abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'\n     !----------------\n     ier=0\n\n     ilen = len(trim(spl_name))\n\n     if(ilen.le.0) then\n        ier=50\n     else if(ilen.gt.20) then\n        ier=51\n     else\n        indx=index(zlegal,spl_name(1:1))\n        if(indx.le.10) then\n           ier=52\n        else\n           do ic=2,ilen\n              indx=index(zlegal,spl_name(ic:ic))\n              if(indx.le.0) ier=52\n           enddo\n        endif\n     endif\n\n   end subroutine ezspline_spl_name_chk\n"}, {"instruction": "Create a Fortran subroutine named interpolate_calculatespace that takes in two input parameters of type integer array and one input parameter of type integer. It also has one output parameter of type integer array. This subroutine calculates the dimensions of a new space based on the input dimensions and interpolation factor.", "input": "", "output": "  subroutine interpolate_calculatespace(odims, interpfactor, fdims)\n\n    integer, intent(in) :: odims(4)\n    integer, intent(in) :: interpfactor\n    integer, intent(out):: fdims(4)\n\n    fdims(1) = odims(1)\n    fdims(3) = odims(3)\n    fdims(2) = odims(2) + (odims(2) - odims(1)) * interpfactor\n    fdims(4) = odims(4) + (odims(4) - odims(3)) * interpfactor\n\n  end subroutine interpolate_calculatespace\n"}, {"instruction": "Create a Fortran subroutine named \"eye_d1\" to generate an identity matrix of size n. The input parameter is an integer (n), and the output parameter is an array of real(8) numbers (a).", "input": "", "output": " subroutine eye_d1(a,n)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: a(:)\n    integer :: i\n    a(1:n*n) = 0d0\n    forall(i = 1:n) a(i+(i-1)*n) = 1d0\n end subroutine eye_d1\n"}, {"instruction": "Create a Fortran subroutine named print_incremented to increment an input integer by 1 and assign the result to an output integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine print_incremented(x,y)\n  integer, intent(in) :: x\n  integer, intent(out) :: y\n  \n  print *, x + 1\n  y = x * 2\n\nend subroutine print_incremented\n"}, {"instruction": "Create a Fortran subroutine named extractvar to extract variables from one table to another and potentially duplicate and change their order. The subroutine takes 5 input parameters of types integer, integer, integer, integer, and real. It also has 2 output parameters of types integer and real.", "input": "", "output": "subroutine extractvar(table, maxdat, nvar, newtable, nvariables, varindex, error)\n    ! extracts variables from one table to other\n    ! you can also duplicate and change order\n    integer,   intent(out) ::   error\n    integer , intent(in):: maxdat, nvar, nvariables, varindex(nvariables)\n    real, intent(in) :: table(maxdat,nvar)\n\n    real, intent(out) :: newtable (maxdat, nvariables)\n    \n    integer :: i,j,k\n    \n    error = 0\n    \n    !check that variables exist\n    do i=1,nvariables\n        if (varindex(i)>nvar) then\n            error = i\n            return\n        end if\n    end do\n    \n    ! copy data from one file to other\n        \n    do i = 1, maxdat\n        do j=1, nvariables\n            k= varindex(j)\n            newtable(i,j) = table(i,k)\n        end do\n    end do\n   \n\n    \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named copy_array that takes an array of real*8 numbers as input and copies it to an output array of the same size. The input parameter is of type real*8, dimension(:) and the output parameter is of type real*8, dimension(size(input)). The subroutine should use the \"intent(in)\" attribute for the input parameter and the \"intent(out)\" attribute for the output parameter.", "input": "", "output": "subroutine copy_array(input, output)\n\n  implicit none\n\n  real*8, dimension(:), intent(in) :: input\n  real*8, dimension(size(input)), intent(out) :: output\n  !, allocatable\n  integer :: n\n\n  !allocate(output(size(input)))\n\n  do n = 1, size(input)\n    output(n) = input(n)\n  end do\n\n  return\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named cross_product to calculate the cross product of two 3-dimensional vectors. The number of input parameters is 2, the test_data type is ['real, dimension(3)', 'real, dimension(3)']. The number of output parameters is 1, the test_data type is ['real, dimension(3)'].", "input": "", "output": "subroutine cross_product(a,b,c)\n!\n!  classic cross product: a x b = c\n!\n   real, dimension(3), intent(in)  :: a, b\n   real, dimension(3), intent(out) :: c\n   \n   c(1) = a(2)*b(3) - a(3)*b(2)\n   c(2) = a(3)*b(1) - a(1)*b(3)\n   c(3) = a(1)*b(2) - a(2)*b(1)\n\nend subroutine cross_product\n"}, {"instruction": "Create a Fortran subroutine named interp_bilinear to perform bilinear interpolation using the given input parameters. The subroutine takes 3 input parameters of types real*8, real*8, and real*4, dimension(2,2), and 1 output parameter of type real*8. The purpose of the subroutine is to compute the bilinear interpolation based on the input parameters di, dj, and var, and then store the result in the output parameter velp.", "input": "", "output": "subroutine interp_bilinear(di,dj,var,velp)\n    !== give 4 corner points of a square, interpolate point values inside\n    !== di is the distance of the particle to the left face\n    !== dj is the distance of the particle to the southern face\n\n    implicit none\n    real*8, intent(in) :: di,dj\n    real*4, intent(in), dimension( 2, 2 ) :: var\n    real*8, intent(out) :: velp\n    real*8 :: i1,i4\n\n    ! calcuate the bilinear interpolation\n    i1 = (var(2,1) - var(1,1))*di + var(1,1)\n    i4 = (var(2,2) - var(1,2))*di + var(1,2)\n    velp = (i4 - i1)*dj + i1\n\nend subroutine interp_bilinear\n"}, {"instruction": "Write a Fortran subroutine named modelb_function2 to calculate a new value based on the input value. The subroutine takes 1 input argument of type real and provides 2 output arguments of type real. The input argument is marked as intent(in) and the output arguments are marked as intent(out). Ensure that the input value is greater than 2 for valid results. Upon execution, the subroutine copies the input value and then calculates the square of the input value multiplied by 2. The results are printed to the standard output.", "input": "", "output": "subroutine modelb_function2(in_val, in_val_copy, out_val)\n  ! only valid if in_val > 2\n  real, intent(in) :: in_val\n  real, intent(out) :: in_val_copy\n  real, intent(out) :: out_val\n  in_val_copy = in_val\n  out_val = 2 * (in_val**2)\n  print *, \"modelb_function2(\", in_val, \") = \", out_val\nend subroutine modelb_function2\n"}, {"instruction": "Create a Fortran subroutine named \"weight_from_stress_tensor\" to calculate the weight associated with each node for balancing the activity in each subdomain and minimizing activity between subdomains. The subroutine takes 4 input parameters of type integer, integer, integer, and real, representing nsnapshot, ndim, nonods, and ct respectively. It outputs a single real value wnod.", "input": "", "output": "      subroutine weight_from_stress_tensor( wnod, ct, nsnapshot, ndim, nonods )\n! calculate wnod the weight associated with each node for trying to \n! balance the activity in each subdomain and minimize activity between subdomains. \n! it does this by caclulating the reynolds stresses and taking the maximim of them. \n! nonods = no of nodes in fem mesh\n! ndim= no of dimensions e.g. for 3d problems =3. \n! nsnapshot = no of snapshots. \n! ct contains the velocity snapshots and of form: ct(isnapshot, u,v,w) \n      implicit none\n      integer, intent(in) :: nsnapshot, ndim, nonods\n      real, intent(out) :: wnod(nonods)\n      real, intent(in) :: ct(nsnapshot, nonods*ndim) \n! local variables\n! a and b define the form of the expoential used to form the wnod from the reynolds stresses. \n      real a,b\n      parameter( a=0.05, b=0.0019183 )\n      real vel_mean(ndim), reynolds(ndim),  max_reynolds\n      integer nod,idim\n      real, allocatable :: vel_snap(:,:)\n      print ct, nsnapshot, ndim, nonods\n      allocate(vel_snap(ndim, nsnapshot) )\n\n      do nod=1,nonods\n         do idim=1,ndim\n            vel_snap(idim,:) = ct(:,(idim-1)*nonods + nod)\n            vel_mean(idim) = sum(vel_snap(idim,:) )/ real(nsnapshot) \n            reynolds(idim) = sum((vel_snap(idim,:) - vel_mean(idim))**2 )/ real(nsnapshot)\n         end do\n         max_reynolds = maxval( reynolds(:) )\n         wnod(nod) = (1./b) * log( max_reynolds/a + 1.0) \n      end do\n      end subroutine weight_from_stress_tensor\n"}, {"instruction": "Write a Fortran subroutine named upper_bc_rebin that takes 5 input parameters of type integer, integer, real, real, and real, and 1 output parameter of type real. This subroutine performs a rebinning operation using the upper boundary condition method. Use the imperative tone to define the purpose of the code and its parameters.", "input": "", "output": "  subroutine upper_bc_rebin( nsrc, ntrg, src_x, trg_x, src, trg )\n    implicit none\n    integer, intent(in) :: nsrc\n    integer, intent(in) :: ntrg\n    real, intent(in) :: src_x(nsrc+1)\n    real, intent(in) :: trg_x(ntrg+1)\n    real, intent(in) :: src(nsrc)\n    real, intent(out) :: trg(ntrg)\n    integer :: i, l\n    integer :: si, si1\n    integer :: sil, siu\n    real :: y\n    real :: sl, su\n    real :: tl, tu\n    do i = 1,ntrg\n       tl = trg_x(i)\n       if( tl < src_x(nsrc+1) ) then\n          do sil = 1,nsrc+1\n             if( tl <= src_x(sil) ) then\n                exit\n             end if\n          end do\n          tu = trg_x(i+1)\n          do siu = 1,nsrc+1\n             if( tu <= src_x(siu) ) then\n                exit\n             end if\n          end do\n          y = 0.\n          sil = max( sil,2 )\n          siu = min( siu,nsrc+1 )\n          do si = sil,siu\n             si1 = si - 1\n             sl = max( tl,src_x(si1) )\n             su = min( tu,src_x(si) )\n             y = y + (su - sl)*src(si1)\n          end do\n          trg(i) = y/(trg_x(i+1) - trg_x(i))\n       else\n          trg(i) = 0.\n       end if\n    end do\n  end subroutine upper_bc_rebin\n"}, {"instruction": "Write a Fortran subroutine named fdot to perform matrix multiplication. The subroutine takes 5 input parameters of types integer, integer, integer, real, and real. The output parameter is of type real. The subroutine computes the matrix product of mtx1 and mtx2 and stores the result in the ans array of size (l,n).", "input": "", "output": "subroutine fdot(mtx1,mtx2,ans,l,m,n)\n\n    implicit none\n    integer, intent(in) :: l,m,n\n    real, intent(in) :: mtx1(l,m)\n    real, intent(in) :: mtx2(m,n)\n    real, intent(out) :: ans(l,n)\n\n    ans =  matmul(mtx1,mtx2)\n\nend subroutine fdot \n"}, {"instruction": "Create a Fortran subroutine named getconstraints to calculate the maximum and minimum values of parameters based on input salinity, temperature, and dissolved oxygen. The number of input parameters is 3 with test_data type ['double precision', 'double precision', 'double precision'], and the number of output parameters is 6 with test_data type ['double precision', 'double precision', 'double precision', 'double precision', 'double precision', 'double precision'].", "input": "", "output": "  subroutine getconstraints(s,t,o,maxsalt,minsalt,maxtemp,mintemp,maxdo,mindo)\r\n    implicit none\r\n\r\n    double precision, intent(in) :: s,t,o\r\n    double precision, intent(out):: maxsalt,minsalt,maxtemp,mintemp,maxdo,mindo\r\n\r\n    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    !  atlantic sturgeon dissolved oxygen code\r\n    !    -if not using, please comment out\r\n\r\n   ! double precision :: dotps,tk,doml,domg,dotmg,dotmmol\r\n\r\n    !atlantic sturgeon do calculation\r\n    !calculate do threshold in percent sat using mortality equation with set\r\n    !mortality of .0625 (.5 per 6 hr)\r\n    !dotps =  ( (log(log(.0625)/log(.99)) - (dble(.4)*(s-dble(10.3))))/dble(.8) &\r\n      !         -t+dble(18.9) )/dble(-.3)+dble(72.3)\r\n    !calculate 100% do saturation at t(kelvin) and s\r\n    !tk = dble(273.15)+t\r\n    !doml = exp(dble(-173.4292)+(dble(249.6339)*(dble(100)/tk))                 &\r\n     !      +(dble(143.3483)*log(tk/dble(100)))+(dble(-21.8492)*(tk/dble(100))) &\r\n      !     +s*(dble(-0.033096)+dble(0.014259)*(tk/dble(100))                   &\r\n       !    +(dble(-0.0017)*(tk/dble(100))**2)))\r\n    !convert do in ml to mg using standard pressure\r\n    !domg = ((dble(760)/tk)*dble(0.513))*doml\r\n    !convert do threshold in percent sat to mg\r\n    !dotmg = (dotps*domg)/dble(100)\r\n    !convert do threshold in mg to mmole/m^3\r\n    !dotmmol = (dotmg/dble(32))*dble(1000)\r\n\r\n    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n    !for each of the following you may either:\r\n    !  set a specific value such as:\r\n    !    maxsalt = 22\r\n    !    minsalt = 14\r\n    !  or specify an equation to calculate the value based on other factors,\r\n    !  such as:\r\n    !    maxtemp = dble(0.0735)*s + dble(36.5)\r\n    !    mintemp = dble(0.0484)*s + dble(5.1548)\r\n    !      where s = salinity\r\n    !\r\n    !  notes:\r\n    !    putting dble() around numbers (as demonstrated above) ensures that \r\n    !      calculations are made in double precision\r\n    !\r\n    !    if no constraint is desired for a particular value below, use a\r\n    !      a really large value such as 9999.999 (positive or negative, \r\n    !      dependent on max or min) to ensure nothing is constrained\r\n    !\r\n    !    when writing an equation below based on other factors:\r\n    !      s = salinity, t = temperature, o = dissolved oxygen\r\n\r\n    maxsalt =  36\r\n\r\n    minsalt =   5\r\n\r\n    maxtemp =  35\r\n\r\n    mintemp =  8\r\n\r\n    maxdo   =  100000.0\r\n\r\n    mindo   =  159.375\r\n\r\n\r\n  end subroutine getconstraints\r\n"}, {"instruction": "Create a Fortran subroutine named solar to calculate the daily-average flux of solar radiation at the top of the atmosphere. The subroutine takes 3 input parameters of type real: tyear, csol, and lats. It also has 1 output parameter of type real: topsr.", "input": "", "output": "    subroutine solar(tyear, csol, lats, topsr)\n        ! average daily flux of solar radiation, from hartmann (1994)\n\n        real, intent(in) :: tyear\n        real, intent(in) :: csol\n        real, intent(in) :: lats(:)\n        real, intent(out) :: topsr(size(lats))\n\n        integer :: nlat, j\n        real :: clat(size(lats)), slat(size(lats))\n        real :: ca1, ca2, ca3, cdecl, ch0, csolp, decl, fdis, h0, alpha, pigr, sa1\n        real :: sa2, sa3, sdecl, sh0, tdecl\n\n        nlat = size(lats)\n\n        ! compute cosine and sine of latitude\n        clat = cos(lats*pi/180.0)\n        slat = sin(lats*pi/180.0)\n\n        ! 1. compute declination angle and earth-sun distance factor\n        pigr  = 2.0*asin(1.0)\n        alpha = 2.0*pigr*tyear\n\n        ca1 = cos(alpha)\n        sa1 = sin(alpha)\n        ca2 = ca1*ca1-sa1*sa1\n        sa2 = 2.*sa1*ca1\n        ca3 = ca1*ca2-sa1*sa2\n        sa3 = sa1*ca2+sa2*ca1\n\n        decl = 0.006918 - 0.399912*ca1 + 0.070257*sa1 - 0.006758*ca2 + 0.000907*sa2&\n            & - 0.002697*ca3 + 0.001480*sa3\n\n        fdis = 1.000110 + 0.034221*ca1 + 0.001280*sa1 + 0.000719*ca2 + 0.000077*sa2\n\n        cdecl = cos(decl)\n        sdecl = sin(decl)\n        tdecl = sdecl/cdecl\n\n        ! 2. compute daily-average insolation at the atm. top\n        csolp = csol/pigr\n\n        do j = 1, nlat\n            ch0 = min(1.0, max(-1.0, -tdecl*slat(j)/clat(j)))\n            h0  = acos(ch0)\n            sh0 = sin(h0)\n\n            topsr(j) = csolp*fdis*(h0*slat(j)*sdecl + sh0*clat(j)*cdecl)\n        end do\n    end subroutine solar\n"}, {"instruction": "Create a Fortran subroutine named set_true_solution to calculate the components of a true solution based on the input parameters x, y, and t. The input parameters are of type double precision, and the output parameter is a double precision array of dimension 2.", "input": "", "output": "subroutine set_true_solution(x, y, t, components)\n\n    implicit none\n\n    double precision, intent(in) :: x, y, t\n    double precision, dimension(2), intent(out) :: components\n    \n    double precision :: t0, tau, rho\n    parameter(t0 = 1.d0)\n    \n    tau = t + t0\n    rho = sqrt(x**2 + y**2) / tau**.25d0\n\n    components(1) = 2.d0 * rho**2\n    components(2) = -1.d0 / (8.d0 * tau**.5d0) * log(rho)\n\nend subroutine set_true_solution\n"}, {"instruction": "Create a Fortran subroutine named rotandtrans_rmsd to perform rotation and translation of coordinates based on given transformation parameters. The subroutine takes 5 input parameters of types integer, double precision array of dimension 3, double precision array of dimension 3, double precision array of dimension 3x3, and double precision array of dimension dim_coors*3. It produces 1 output parameter of type double precision array of dimension dim_coors*3.", "input": "", "output": "  subroutine rotandtrans_rmsd(center_orig,u,center_ref,coors,dim_coors,new_coors)\n\n    implicit none\n\n    integer,intent(in)::dim_coors\n    double precision,dimension(3),intent(in)::center_orig,center_ref\n    double precision,dimension(3,3),intent(in)::u\n    double precision,dimension(dim_coors,3),intent(in)::coors\n\n    double precision,dimension(dim_coors,3),intent(out)::new_coors\n\n    integer::ii\n\n    do ii=1,dim_coors\n       new_coors(ii,:)=matmul(transpose(u(:,:)),coors(ii,:)-center_orig)+center_ref\n    end do\n\n  end subroutine rotandtrans_rmsd\n"}, {"instruction": "Write a Fortran subroutine named r4datamapping1d to map a 1D array of real(4) data from one range to another. The subroutine takes 3 input parameters of type real(4) - olddata, newdatamin, and newdatamax, and 1 output parameter of type real(4) - newdata. The subroutine uses the imperative tone.", "input": "", "output": " subroutine r4datamapping1d(olddata,newdatamin,newdatamax,newdata)\n  implicit none\n  real(4), intent(in)     :: olddata(:)\n  real(4), intent(out)    :: newdata(:)\n  real(4), intent(in)     :: newdatamax,newdatamin\n  real(4)                 :: olddatamax,olddatamin\n\n  integer(4)              :: matdims1d(1)\n  integer(4)              :: id1\n\n  matdims1d=size(olddata)\n\n  olddatamin=minval(olddata)\n  olddatamax=maxval(olddata)\n\n  do id1=1,matdims1d(1)\n   newdata(id1)=newdatamin+(newdatamax-newdatamin)*((olddata(id1)-olddatamin)/(olddatamax-olddatamin))\n  end do\n\n  return\n end subroutine r4datamapping1d\n"}, {"instruction": "Define a Fortran subroutine named r4datamapping3d to map the values from a 3D array to a new range. The subroutine takes 3 input parameters of type real(4) for olddata, newdatamin, and newdatamax. It also has 1 output parameter of type real(4) for newdata. The subroutine uses the imperative tone and should be well-documented.", "input": "", "output": " subroutine r4datamapping3d(olddata,newdatamin,newdatamax,newdata)\n  implicit none\n  real(4), intent(in)     :: olddata(:,:,:)\n  real(4), intent(out)    :: newdata(:,:,:)\n  real(4), intent(in)     :: newdatamax,newdatamin\n  real(4)                 :: olddatamax,olddatamin\n\n  integer(4)              :: matdims3d(3)\n  integer(4)              :: id1,id2,id3\n\n  matdims3d=shape(olddata)\n\n  olddatamin=minval(olddata)\n  olddatamax=maxval(olddata)\n\n  do id1=1,matdims3d(1)\n   do id2=1,matdims3d(2)\n    do id3=1,matdims3d(3)\n     newdata(id1,id2,id3)=newdatamin+(newdatamax-newdatamin)*((olddata(id1,id2,id3)-olddatamin)/(olddatamax-olddatamin))\n    end do\n   end do\n  end do\n\n  return\n end subroutine r4datamapping3d\n"}, {"instruction": "Create a Fortran subroutine named \"wave_propogation\" to simulate wave propagation using the Finite Difference Time Domain (FDTD) method. The subroutine takes 5 input parameters of types integer, integer, integer, real, and real, representing num_steps, scale, stop_step, damping, and initial_p respectively. It also has one output parameter of type real, representing the wave field array p. The subroutine simulates the propagation of a wave through a 2D grid over a specified number of time steps using the FDTD method.", "input": "", "output": "subroutine wave_propogation(num_steps, scale, damping, initial_p, stop_step, p)\n  implicit none\n  integer size_x,size_y,i,j,k,step\n  real pi, omega\n  integer, intent(in)  :: num_steps, scale, stop_step !input\n  real, intent(in) :: damping, initial_p !input\n  real, intent(out) :: p(2 * scale + 1,2 * scale + 1) ! output\n  real, dimension(2 * scale + 1,2 * scale + 1,4) :: v\n\n  size_x = 2 * scale + 1\n  size_y = 2 * scale + 1\n\n  pi = 3.14159\n  omega = 3.0 / (2.0 * pi)\n\n  do k=1,4\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = 0.0\n           v(i,j,k) = 0.0\n        end do\n     end do\n  end do\n\n  p(scale,scale) = initial_p\n\n  do step = 1,num_steps\n     if(step <= stop_step) then\n        p(scale,scale) = initial_p * sin(omega * step)\n     endif\n\n     do j=1,size_x\n        do i=1,size_x\n           v(i,j,1) = merge(v(i,j,1) + p(i,j) - p(i - 1,j), p(i,j), i > 1)\n           v(i,j,2) = merge(v(i,j,2) + p(i,j) - p(i,j + 1), p(i,j), j < size_x - 1)\n           v(i,j,3) = merge(v(i,j,3) + p(i,j) - p(i + 1,j), p(i,j), i < size_y - 1)\n           v(i,j,4) = merge(v(i,j,4) + p(i,j) - p(i,j - 1), p(i,j), j > 1)\n        end do\n     end do\n\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = p(i,j) - 0.5 * damping * (v(i,j,1) + v(i,j,2) + v(i,j,3) + v(i,j,4))\n        end do\n     end do\n  end do\n\nend subroutine wave_propogation\n"}, {"instruction": "Create a Fortran subroutine named a1 to assign the value of an input integer to an output integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer]. Use the imperative tone in the instruction.", "input": "", "output": "  subroutine a1(x,y)\n    integer, intent(in) :: x\n    integer, intent(out) :: y\n    y=x\n  end subroutine a1\n"}, {"instruction": "Create a Fortran subroutine named spectralinterpolate that takes 3 input parameters: two integers (n_in, n_out) and an array of double precision numbers (data_in), and produces 1 output parameter of type double precision (data_out). The function spectrally interpolates the input data_in of length n_in to generate the data_out of length n_out using spectral interpolation techniques.", "input": "", "output": "subroutine spectralinterpolate(n_in,n_out,data_in,data_out)\n\n  ! take data, data_in of length n_in and spectrally interpolate to\n  ! get data_out of length n_out\n  implicit none\n  integer, intent(in) :: n_in,n_out\n  double precision, intent(in) ::  data_in(n_in) \n  double precision, intent(out) ::  data_out(n_out)\n  double precision :: t_out(n_out)\n  complex*16 :: x(n_in)\n  double precision :: ix,rx,pi\n  integer :: n_break,k,n\n\n  pi = 3.14159265358979\n  ! generate the dft of the input data...\n  x(:) = cmplx(0.0,0.0)\n  do k=0,n_in-1\n     do n=0,n_in-1\n        x(k+1) = x(k+1) + cmplx(data_in(n+1),0)* &\n             exp(-2*cmplx(pi,0)*cmplx(0,1)*cmplx(k,0)*cmplx(n,0)/cmplx(n_in,0))\n     end do\n  end do\n\n  ! generate the output time:\n  do n=1,n_out\n     t_out(n) = 2*pi*(dble(n)-1)/(n_out)\n  end do\n\n  data_out(:) = 0.0\n  ! now do the spectral interpolation\n  n_break = (n_in-1)/2\n  do n=1,n_out\n     do k=0,n_break\n        rx = real(x(k+1))\n        ix = aimag(x(k+1))\n        data_out(n) = data_out(n) + &\n             rx*cos(k*t_out(n)) - ix*sin(k*t_out(n))\n       \n     end do\n     do k=n_break+1,n_in-1\n        rx = real(x(k+1))\n        ix = aimag(x(k+1))\n        data_out(n) = data_out(n) + &\n             rx*cos((n_in-k)*t_out(n)) + ix*sin((n_in-k)*t_out(n))\n     end do\n  end do\n  data_out = data_out * (1/dble(n_in))\n\nend subroutine spectralinterpolate\n"}, {"instruction": "Create a Fortran subroutine named errp to calculate the weighted error in a polynomial fit. The subroutine takes 5 input parameters: an integer*4, and four real*8 arrays. It also has 1 output parameter of type real*8. The subroutine should compute the error based on the input data and polynomial fit coefficients.", "input": "", "output": "      subroutine errp(nt,p,x,w,c,error)\n      implicit real*8(a-h,o-z)\n\n      integer*4, intent(in)  :: nt\n      real*8,    intent(in)  :: w(nt),p(nt),x(nt),c(4,1)\n      real*8,    intent(out) :: error \n      \n      error = 0d0\n\n      do i=1,nt\n        pfit = c(1,1)*x(i)+c(2,1)*x(i)**2+c(3,1)*x(i)**3+c(4,1)\n        error = error + (p(i)-pfit)**2*w(i)\n      enddo\n      \n\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named p_fill_upcorn that takes 6 input parameters of types integer, integer, integer, integer, integer, real(kind=8) array of dimensions md1 and md3. It also has 1 output parameter of type real(kind=8) array of dimensions 2, lot, and n3. The subroutine fills the output array zw using the values from input array zf according to the specified logic.", "input": "", "output": "subroutine p_fill_upcorn(md1,md3,lot,nfft,n3,zf,zw)\n  implicit none\n  integer, intent(in) :: md1,md3,lot,nfft,n3\n  real(kind=8), dimension(md1,md3), intent(in) :: zf\n  real(kind=8), dimension(2,lot,n3), intent(out) :: zw\n  !local variables\n  integer :: i1,i3\n\n  do i3=1,n3\n     do i1=1,nfft\n      zw(1,i1,i3)=zf(i1,i3)\n      zw(2,i1,i3)=0.d0\n     end do\n  end do\n\nend subroutine p_fill_upcorn\n"}, {"instruction": "Create a Fortran subroutine named to_mass_grid to transform a grid of input real numbers into a mass grid. The subroutine takes one input parameter of type real, dimension(:,:), and one output parameter of type real, dimension(:,:).", "input": "", "output": "subroutine to_mass_grid( xi, xo )\n\nreal, intent(in),  dimension(:,:) :: xi\nreal, intent(out), dimension(:,:) :: xo\n\ninteger :: ixi, jxi, ixo, jxo\n\nixi = size( xi, 1 )\njxi = size( xi, 2 )\nixo = size( xo, 1 )\njxo = size( xo, 2 )\n\nif( ixi == (ixo+1) ) then\n  xo(:,:) =  0.5*( xi(1:ixi-1,:) + xi(2:ixi,:) )\nelse if( jxi == (jxo+1) ) then\n  xo(:,:) =  0.5*( xi(:,1:jxi-1) + xi(:,2:jxi) )\nelse\n  print *, ' *** error in transformation to mass grid'\n  stop\nendif\n\nend subroutine to_mass_grid\n"}, {"instruction": "Create a Fortran subroutine named comp_wind to calculate the wind speed from the u and v components. The subroutine takes 2 input parameters of type real, each with a 2D array dimension. It has 1 output parameter of type real with a 2D array dimension.", "input": "", "output": "subroutine comp_wind( uu, vv, wind )\n\nreal, intent(in),  dimension(:,:) :: uu, vv\nreal, intent(out), dimension(:,:) :: wind\n\nwind(:,:) = uu(:,:)*uu(:,:) + vv(:,:)*vv(:,:)\nwind(:,:) = sqrt( wind(:,:) )\n\nend subroutine comp_wind\n"}, {"instruction": "Create a Fortran subroutine named comp_psl that calculates the sea level pressure (psl) using the surface pressure (psfc), surface temperature (tsfc), and surface height (zsfc) as input. The input parameters are of type real and dimension(:,:), and there are three input parameters in total. The output parameter psl is also of type real and dimension(:,:).", "input": "", "output": "subroutine comp_psl( psfc, tsfc, zsfc, psl )\n\n real, parameter :: rgas   = 0.2870e3\n real, parameter :: grav   = 9.806\n real, parameter :: grexp  = grav / rgas\n\nreal, intent(in),  dimension(:,:) :: psfc, tsfc, zsfc\nreal, intent(out), dimension(:,:) :: psl\n\n psl(:,:) = psfc(:,:) * exp( grexp * zsfc(:,:) / tsfc(:,:) )\n\nend subroutine comp_psl\n"}, {"instruction": "Create a Fortran subroutine named check_for_value_4d that takes 6 input parameters of types integer, integer, integer, integer, integer array of dimensions (naxis1,naxis2,naxis3,naxis4), and integer. It also has 1 output parameter of type integer array of dimensions (naxis2,naxis3,naxis4). The subroutine reduces the first dimension of a 4D array to a specified value if that value is present in a slice of the array spanning the last dimension; otherwise, it reduces it to 0.", "input": "", "output": "subroutine check_for_value_4d(array_in,array_out,value,naxis1,naxis2,naxis3,naxis4)\n\n!reduces the first dimension of a 4d array to value if that value is present in a slice of the array\n!spanning the last dimension, otherwise to 0\n\nimplicit none\n\n!variables with intent in\n!dimensions of the input array\ninteger, intent(in) :: naxis1, naxis2, naxis3, naxis4\n!input array\ninteger, intent(in), dimension(naxis1,naxis2,naxis3,naxis4) :: array_in\n!value to check for in the first dimension and reduce to if found\ninteger, intent(in) :: value\n\n!variables with intent out\n!output array\ninteger, intent(out), dimension(naxis2,naxis3,naxis4) :: array_out\n\n!local variables\n!a point in the slice across the first dimension that has the value\n!being search for has been found\nlogical :: value_found\n!loop counters\ninteger :: i,j,k,l\n    value_found = .false.\n    !loop over other dimensions\n    do l = 1,naxis4\n        do k = 1,naxis3\n            do j = 1,naxis2\n                !loop over first dimension\n                do i = 1,naxis1\n                    if (array_in(i,j,k,l) == value) value_found = .true.\n                end do\n                !if a value was found set it in the reduce array appropriately or\n                !otherwise set zero\n                if (value_found) then\n                    array_out(j,k,l) = value\n                    value_found = .false.\n                else\n                    array_out(j,k,l) = 0\n                end if\n            end do\n        end do\n    end do\nend subroutine check_for_value_4d\n"}, {"instruction": "Write a Fortran subroutine named trend_rhomax_srk to calculate the maximum molar density based on the composition array provided as input. The subroutine should have 1 input parameter of type real, dimension(:), and intent(in) and 1 output parameter of type real.", "input": "", "output": "    subroutine trend_rhomax_srk(x,rhomax)\n      implicit none\n      real, dimension(:), intent(in)  :: x      !< composition\n      real,               intent(out) :: rhomax !< maximum molar density\n    end subroutine trend_rhomax_srk\n"}, {"instruction": "Create a Fortran subroutine named trend_zfac to calculate the compressibility factor and its differentials with respect to temperature, pressure, and composition. The subroutine takes 3 input parameters of real type (temperature, density, composition array), and provides 4 output parameters of real type (zfac, dzdt, dzdp, dzdx). The last 3 output parameters are optional.", "input": "", "output": "    subroutine trend_zfac(t, rho, x, zfac, dzdt, dzdp, dzdx)\n      implicit none\n      ! input:\n      real,   intent(in)          :: t        !< temperature (k)\n      real,   intent(in)          :: rho      !< density (mol/m^3)\n      real,   intent(in)          :: x(:)     !< composition (mol/mol)\n      ! output:\n      real,   intent(out)         :: zfac     !< compressibility factor (-)\n      real, optional, intent(out) :: dzdt     !< zfac diff. wrt. temperature\n      real, optional, intent(out) :: dzdp     !< zfac diff. wrt. pressure\n      real, optional, intent(out) :: dzdx(:)  !< zfac diff. wrt. composition\n    end subroutine trend_zfac\n"}, {"instruction": "Write a Fortran subroutine named f_routine that calculates the nth Fibonacci number using the input parameter m of type integer. The subroutine has 1 input parameter of type integer and 1 output parameter of type integer(kind=16).", "input": "", "output": "subroutine f_routine(m, fnumber)\n   integer, intent(in) :: m\n   integer(kind=16), intent(out) :: fnumber\n   integer(kind=16), dimension(2) :: last_two\n   integer :: i\n\n   last_two = (/ 1, 1 /)\n   do i = 0, m\n      if ((i .eq. 0) .or. (i .eq. 1)) then\n         fnumber = 1\n      else \n         fnumber = last_two(1) + last_two(2)\n         if (mod(i,2) .eq. 0) then\n            last_two(1) = fnumber\n         else if (mod(i,2) .ne. 0) then\n            last_two(2) = fnumber\n         end if\n      end if\n   end do\n\nend subroutine f_routine\n"}, {"instruction": "Write a Fortran subroutine named copycstr to convert a null-terminated byte array to a character array. The subroutine takes 1 input parameter with the test_data type ['byte, dimension(*)'] and 1 output parameter with the test_data type ['character*(*)']. Use the imperative tone in the instructions.", "input": "", "output": "    subroutine copycstr( cstr, fstr )\n      byte, dimension(*), intent(in)  :: cstr\n      character*(*), intent(out) :: fstr\n\n        integer i\n        ! scan up to the terminating null\n        i = 1\n        do while( cstr(i) .ne. 0 )\n          fstr(i:i) = char(cstr(i))\n          i = i + 1\n        end do\n        ! pad the rest with blanks\n        do while( i .le. len(fstr) )\n          fstr(i:i) = ' '\n          i = i + 1\n        end do\n    end subroutine copycstr\n"}, {"instruction": "Create a Fortran subroutine named intplt2, which implements a second-order interpolation scheme to calculate the interpolated value based on the given position and input grid values. The subroutine takes 3 input parameters of type real: p (position), x (positions of 2 grid points), and vin (input grid values). It produces 1 output parameter of type real: vout (interpolated value). Ensure the subroutine handles overlap grid points and performs the interpolation accurately.", "input": "", "output": "subroutine intplt2(p,x,vin,vout)\n\n!==========================================================\n!  this routine interpolates a value using a second order\n!  scheme.\n!\n!  input:\n!\tp: position where to interpolate;\n!\tx: positions of 2 grid points;\n!\tvin: input grid values;\n!  output:\n!\tvout: interpolated value;\n!\n!  reference: intpl2.doc on mac notebook.\n!\n!  history:\n!\tjul. 2006 by yuanfu xie.\n!==========================================================\n\n  implicit none\n\n  real, intent(in) :: p,x(2),vin(2)\n  real, intent(out) :: vout\n\n  integer :: i,j\n  real :: e(2),r,b,c\n\n  ! check the 4 grid points:\n  do i=1,2\n    do j=1,2\n      if ((i .ne. j) .and. &\n        (abs(x(i)-x(j)) .lt. 1.0e-5*x(i) ) ) then\n        print*,'intplt2: there are overlap gridpoints, stop'\n\tstop\n      endif\n    enddo\n  enddo\n\n  do i=1,2\n    if (abs(p-x(i)) .lt. 1.0e-5*maxval(x) ) then\n      e = 0.0\n      e(i) = 1.0\n      goto 1\n    endif\n  enddo\n\n  ! e2:\n  e(2) = (p-x(1))/(x(2)-x(1))\n\n  ! e1:\n  e(1) = 1.0-e(2)\n\n1 continue\n\n  ! interpolate:\n  vout = 0.0\n  do i=1,2\n    vout = vout+e(i)*vin(i)\n  enddo\n\nend subroutine intplt2\n"}, {"instruction": "Write a Fortran subroutine named operatorspinflip that implements a spin-flip operation on a lattice site. The subroutine takes 2 input parameters of type integer and returns 2 output parameters: one of type integer and one of type logical. The logical output parameter indicates whether the operation resulted in a valid state.", "input": "", "output": "    subroutine operatorspinflip(site,basisfunc,newbasisfunc, valid)\n        ! flips the spins between the given site and the next\n        ! periodic boundary conditions are used\n        ! valid is false if operator gives the empty state\n        integer,intent(in) :: site\n        integer,intent(in) :: basisfunc\n        integer,intent(out) :: newbasisfunc\n        logical,intent(out) :: valid\n        integer :: sitenext \n        valid  = .true.\n        sitenext = mod(site + 1, numsites)\n        newbasisfunc = basisfunc\n        if (btest(basisfunc,site) .and. .not. btest(basisfunc,sitenext) )then\n            newbasisfunc =  ibclr(newbasisfunc,site)\n            newbasisfunc = ibset(newbasisfunc,sitenext)\n            return\n        endif\n        if (.not. btest(basisfunc,site) .and.  btest(basisfunc,sitenext) )then\n            newbasisfunc =  ibset(newbasisfunc,site)\n            newbasisfunc = ibclr(newbasisfunc,sitenext)\n            return\n        endif\n        valid = .false.\n\n    end subroutine operatorspinflip\n"}, {"instruction": "Create a Fortran subroutine named tri_num that takes an integer input parameter and returns a logical output parameter. The input parameter should be of type integer, and the output parameter should be of type logical. The subroutine checks if the input integer is a triangular number and sets the output parameter accordingly.", "input": "", "output": "    subroutine tri_num(n, is_tri_num)\n        integer, intent(in) :: n\n        logical, intent(out) :: is_tri_num(n)\n        integer :: i\n\n        is_tri_num = .false.\n\n        i = 1\n        do while (i*(i + 1)/2 <= n)\n            is_tri_num(i*(i + 1)/2) = .true.\n            i = i + 1\n        end do\n    end subroutine tri_num\n"}, {"instruction": "Write a Fortran subroutine named check_remeshed to compare two arrays and determine if they are equal. The subroutine takes 4 input parameters of type integer, integer, double precision array, and double precision array. The output is a single integer. If the arrays are not equal in length or content, the output will be set to -1; otherwise, it will be set to 0. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes for input and output parameters, respectively.", "input": "", "output": "      subroutine check_remeshed(nz, nz_orig, dq, dq_orig, ierr)\n         implicit none\n         integer, intent(in) :: nz, nz_orig\n         double precision, intent(in) :: dq(nz), dq_orig(nz_orig)\n         integer, intent(out) :: ierr\n         integer :: i\n         if (nz .ne. nz_orig) then\n            ierr = -1\n            return\n         end if\n         do i = 1, nz\n            if (dq(i) .ne. dq_orig(i)) then\n               ierr = -1\n               return\n            end if\n         end do\n         ierr = 0\n      end subroutine check_remeshed\n"}, {"instruction": "Create a Fortran subroutine named \"vector_separation\" to calculate the vector separating two atoms using the minimum image convention. The subroutine takes 4 input parameters of types ['double precision, dimension(3,3)', 'double precision, dimension(3,3)', 'double precision, dimension(3)', 'double precision, dimension(3)'] and returns 2 output parameters of types ['double precision, dimension(3)', 'double precision'].", "input": "", "output": "         subroutine vector_separation(cell_h, cell_ih, ri, rj, rij, r2)\n            ! calculates the vector separating two atoms.\n            !\n            ! note that minimum image convention is used, so only the image of\n            ! atom j that is the shortest distance from atom i is considered.\n            !\n            ! also note that while this may not work if the simulation\n            ! box is highly skewed from orthorhombic, as\n            ! in this case it is possible to return a distance less than the\n            ! nearest neighbour distance. however, this will not be of \n            ! importance unless the cut-off radius is more than half the \n            ! width of the shortest face-face distance of the simulation box,\n            ! which should never be the case.\n            !\n            ! args:\n            !    cell_h: the simulation box cell vector matrix.\n            !    cell_ih: the inverse of the simulation box cell vector matrix.\n            !    ri: the position vector of atom i.\n            !    rj: the position vector of atom j\n            !    rij: the vector separating atoms i and j.\n            !    r2: the square of the distance between atoms i and j.\n\n            double precision, dimension(3,3), intent(in) :: cell_h\n            double precision, dimension(3,3), intent(in) :: cell_ih\n            double precision, dimension(3), intent(in) :: ri\n            double precision, dimension(3), intent(in) :: rj\n            double precision, dimension(3), intent(out) :: rij \n            double precision, intent(out) :: r2\n\n            integer k\n            double precision, dimension(3) :: sij  \n            ! the separation in a basis where the simulation box  \n            ! is a unit cube.\n                                                   \n            sij = matmul(cell_ih, ri - rj)\n            do k = 1, 3\n               ! finds the smallest separation of all the images of atom i and j\n               sij(k) = sij(k) - dnint(sij(k)) \n            enddo\n            rij = matmul(cell_h, sij)\n            r2 = dot_product(rij,rij)\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named tracer_source_sink to calculate the source and sink of a tracer field based on the input flux, damping, pressure, and density fields. The number of input arguments is 5 with the test_data type ['real', 'real', 'real', 'real', 'integer, optional'], and the number of output arguments is 1 with the test_data type ['real'].", "input": "", "output": " subroutine tracer_source_sink ( flux, damp, p_half, r, rdt, kbot )\n\n!-----------------------------------------------------------------------\n      real, intent(in)  :: flux, damp, p_half(:,:,:), r(:,:,:)\n      real, intent(out) :: rdt(:,:,:)\n   integer, intent(in), optional :: kbot(:,:)\n!-----------------------------------------------------------------------\n      real, dimension(size(r,1),size(r,2),size(r,3)) :: source, sink\n      real, dimension(size(r,1),size(r,2))           :: pmass\n\n      integer :: i, j, kb\n      real    :: rdamp\n!-----------------------------------------------------------------------\n\n      rdamp = damp\n      if (rdamp < 0.) rdamp = -86400.*rdamp   ! convert days to seconds\n      if (rdamp > 0.) rdamp = 1./rdamp\n\n!------------ simple surface source and global sink --------------------\n\n      source(:,:,:)=0.0\n\n   if (present(kbot)) then\n      do j=1,size(r,2)\n      do i=1,size(r,1)\n         kb = kbot(i,j)\n         pmass (i,j)    = p_half(i,j,kb+1) - p_half(i,j,kb)\n         source(i,j,kb) = flux/pmass(i,j)\n      enddo\n      enddo\n   else\n         kb = size(r,3)\n         pmass (:,:)    = p_half(:,:,kb+1) - p_half(:,:,kb)\n         source(:,:,kb) = flux/pmass(:,:)\n   endif\n\n     sink(:,:,:) = rdamp*r(:,:,:)\n     rdt(:,:,:) = source(:,:,:)-sink(:,:,:)\n\n!-----------------------------------------------------------------------\n\n end subroutine tracer_source_sink\n"}, {"instruction": "Create a Fortran subroutine named \"adios_init\" to initialize the ADIOS configuration. It should take 2 input parameters of type ['character(*)', 'integer'] and 1 output parameter of type ['integer'].", "input": "", "output": "        subroutine adios_init (config, comm, err)\n            implicit none\n            character(*),   intent(in)  :: config\n            integer,        intent(in)  :: comm\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_init_noxml to initialize the ADIOS library without using an XML configuration file. It takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "        subroutine adios_init_noxml (comm, err)\n            implicit none\n            integer,        intent(in)  :: comm\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios_set_transform\" to set a transformation method for a variable. The subroutine should take 2 input parameters of type integer*8 and character(*), and 1 output parameter of type integer.", "input": "", "output": "        subroutine adios_set_transform (var_id, transform_method, err)\n            implicit none\n            integer*8,      intent(in)  :: var_id\n            character(*),   intent(in)  :: transform_method\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_select_method that takes 4 input parameters of type integer*8, character(*), character(*), and character(*), and 1 output parameter of type integer. This subroutine is designed to select a method with specified parameters for a given group and base path.", "input": "", "output": "        subroutine adios_select_method (group_id, method, parameters, base_path, err)\n            implicit none\n            integer*8,      intent(in)  :: group_id\n            character(*),   intent(in)  :: method\n            character(*),   intent(in)  :: parameters\n            character(*),   intent(in)  :: base_path\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cels_from_fahr to convert the temperature from Fahrenheit to Celsius. The subroutine takes 1 input parameter of type real and 1 output parameter of type real. The input parameter represents the temperature in Fahrenheit, and the output parameter will hold the converted temperature in Celsius.", "input": "", "output": "   subroutine cels_from_fahr(degrees_fahr,degrees_cels)\n   real, intent(in)  :: degrees_fahr\n   real, intent(out) :: degrees_cels\n   degrees_cels = (degrees_fahr-32)/1.8\n   end subroutine cels_from_fahr\n"}, {"instruction": "Write a Fortran subroutine named getwrd that extracts a specific word from a given line of text. The subroutine takes 2 input parameters of type integer and character(len=100) and 1 output parameter of type character(len=100). The subroutine should find the word specified by the integer input wrdnum in the input line and return it as output.", "input": "", "output": "subroutine getwrd(line,wrd,wrdnum)\n!========================================================================================\n\n!==== character string.                                                              ====\n!====    by adam siade                                                               ====\n!========================================================================================\n!========================================================================================\n  \n  implicit none\n  \n! specifications:\n!----------------------------------------------------------------------------------------\n  integer,intent(in)::wrdnum\n  integer::i,j,k\n  \n  character(len=100),intent(in)::line\n  character(len=100),intent(out)::wrd\n!----------------------------------------------------------------------------------------\n\n  wrd = ' '\n  !\n  i = 0\n  j = 1\n  k = 0\n  !\n  do\n    !\n    i = i + 1\n    !\n    if (line(i:i) /= ' ') then\n      !\n      if (j == wrdnum) then\n        !\n        do\n          !\n          k = k + 1\n          !\n          wrd(k:k) = line(i:i)\n          !\n          i = i + 1\n          !\n          if (line(i:i) == ' ') exit\n          !\n        end do\n        !\n      else\n        !\n        j = j + 1\n        !\n        do\n          !\n          i = i + 1\n          !\n          if (line(i:i) == ' ') exit\n          !\n        end do\n        !        \n      end if\n      !\n    end if\n    !\n    if (k > 0) exit\n    !\n  end do\n  \nend subroutine getwrd\n"}, {"instruction": "Create a Fortran subroutine named \"load_div\" to perform a specific operation. The subroutine should have 3 input parameters of type integer, where the third parameter is optional. It should also have 4 output parameters, where the first two are optional integers, and the last two are optional allocatable integer arrays. The subroutine must allocate memory for the optional arrays if they are present.", "input": "", "output": "  subroutine load_div( m, np, me, m0, m1, ir_out, id_out )\n    implicit none\n    integer,intent(in) :: m, np\n    integer,optional,intent(in)  :: me\n    integer,optional,intent(out) :: m0, m1\n    integer,allocatable,optional,intent(out) :: ir_out(:), id_out(:)\n    integer,allocatable :: ir(:)\n    integer :: i,ip\n    allocate( ir(0:np-1) ) ; ir=0\n    do i=1,m\n       ip=mod(i-1,np)\n       ir(ip)=ir(ip)+1\n    end do\n    if ( present(me) .and. present(m0) .and. present(m1) ) then\n       m0 = sum( ir(0:me) ) - ir(me) + 1\n       m1 = m0 + ir(me) - 1\n    end if\n    if ( present(ir_out) .and. present(id_out) ) then\n       if ( allocated(ir_out) ) deallocate(ir_out)\n       if ( allocated(id_out) ) deallocate(id_out)\n       allocate( ir_out(0:np-1) ); ir_out=0\n       allocate( id_out(0:np-1) ); id_out=0\n       ir_out=ir\n       do ip=0,np-1\n          id_out(ip) = sum(ir_out(0:ip)) - ir_out(ip)\n       end do\n    end if\n    deallocate( ir )\n  end subroutine load_div\n"}, {"instruction": "Create a Fortran subroutine named check_mpi to search for a given integer value within an array of integers. The subroutine takes 3 input parameters of type integer*4 and an array of integers. It also has 2 output parameters of type integer*4.", "input": "", "output": "    subroutine check_mpi(n,v,ind,tt,pos)\n    \n    implicit none\n    \n    integer*4 :: i, ne\n    integer*4, intent(in) ::n,ind\n    integer*4, dimension(0:n), intent(in)  :: v\n    integer*4, intent(out) :: tt, pos\n    \n\n    tt = 0\n    pos = - 1\n    i = 1\n    ne = v(0) - 1\n    \n      \n    do while (i.le.ne)\n       if (v(v(i-1)) .eq. ind) then\n          tt = 1\n          pos = i\n          return\n       endif   \n       i=i+1\n       \n    enddo    \n    \n    end subroutine check_mpi\n"}, {"instruction": "Write a Fortran subroutine named get_rep_indices to generate a vector of indices based on the given starting value i0, final value i1, and number of values to skip nrep. The number of input parameters is 3, the test_data type is ['integer', 'integer', 'integer'], and the number of output parameters is 1, the test_data type is ['integer, allocatable'].", "input": "", "output": "    subroutine get_rep_indices(ii,i0,i1,nrep)\n        ! given starting value i0 and final value i1, \n        ! and number of values to skip nrep, generate \n        ! an vector of indices ii. \n        ! eg, i0 = 1, i1 = 36, nrep = 12\n        ! => ii = [1,13,25]\n        ! eg, i0 = 2, i1 = 36, nrep = 12\n        ! => ii = [2,14,26]\n        \n        implicit none \n\n        integer, allocatable, intent(out) :: ii(:) \n        integer, intent(in) :: i0 \n        integer, intent(in) :: i1 \n        integer, intent(in) :: nrep \n\n        ! local variables   \n        integer :: i, ni, ntot \n        integer :: jj(10000)\n\n        ni = i1-i0+1 \n\n        jj = 0  \n\n        do i = 1, ni\n            jj(i) = i0 + nrep*(i-1) \n            if (jj(i) .gt. i1) then \n                jj(i) = 0\n                exit \n            end if \n        end do \n\n        ntot = count(jj .gt. 0)\n        if (allocated(ii)) deallocate(ii)\n        allocate(ii(ntot)) \n\n        ii = jj(1:ntot) \n\n        return \n\n    end subroutine get_rep_indices\n"}, {"instruction": "Write a Fortran subroutine named \"get_num_from_string\" to extract an integer from a character buffer based on a specific string pattern. The subroutine takes 2 input parameters of type character(*), representing the buffer and the string pattern to search for. It also includes 1 output parameter of type integer to store the extracted integer.", "input": "", "output": "  subroutine get_num_from_string( buf, str, n )\n    implicit none\n    character(*),intent(in) :: buf, str\n    integer,intent(out) :: n\n    integer :: i, j, l, len_str\n    character(8) :: str_out\n    l = index( buf, str )\n    if ( l /= 0 ) then\n       len_str = len_trim( adjustl(str) )\n       i=l+len_str+1\n       j=index( buf(i:), '\"' ) + i - 2\n       str_out = buf(i:j)\n       read(str_out,*) n\n    end if\n  end subroutine get_num_from_string\n"}, {"instruction": "Create a Fortran subroutine named read_global_int to read integer data from a file and store it in a 3D array. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type integer, dimension(:,:,:).\n", "input": "", "output": "subroutine read_global_int(filename,bufint,kmax)\n  character(*), intent(in) :: filename\n  integer, dimension(:,:,:), intent(out) :: bufint\n  integer, intent(in) :: kmax\n  integer, parameter :: fid=20\n  logical   :: ex\n  integer*8 :: mx, ny, lz, reclen\n  logical :: dodebug = .false.\n\n  mx = size(bufint,1)\n  ny = size(bufint,2)\n  lz = min(size(bufint,3),kmax)\n  reclen = mx * ny * lz * reclen_mult\n\n  inquire (file=trim(filename), exist=ex)\n  if (ex) then\n    open (unit=fid, file=trim(filename), status='old', access='direct', form='unformatted', recl=reclen)\n    read (fid,rec=1) bufint(:,:,1:kmax)\n    close (fid)\n    write (6, '( ''read_ncoda_intfile:: finished reading integer file: '',a)' ) trim(filename)\n  else\n    write (6, '( ''read_ncoda_intfile:: integer file missing: '',  a)' ) trim(filename)\n    stop(\"read_ncoda_intfile:: exiting...\")\n  endif\n\n  if (dodebug) then\n    print *, \"max(bufint) = \", maxval(bufint)\n    print *, \"min(bufint) = \", minval(bufint)\n    print *, \"avg(bufint) = \", sum(bufint)/(mx*ny*lz)\n    print *, \"maxloc(bufint) = \", maxloc(bufint)\n    print *, \"minloc(bufint) = \", minloc(bufint)\n  endif\n\nend subroutine read_global_int\n"}, {"instruction": "Write a Fortran subroutine named read_global that reads data from a binary file and populates a 3D real array with the contents. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type real, dimension(:,:,:).", "input": "", "output": "subroutine read_global(filename,buf4,kmax)\n  character(*), intent(in) :: filename\n  real, dimension(:,:,:), intent(out) :: buf4\n  integer, intent(in) :: kmax\n  integer*8 :: mx,ny,lz\n  integer*8 :: reclen\n  logical :: ex\n  integer :: fid = 23\n  logical :: dodebug = .false.\n\n  mx = size(buf4,1)\n  ny = size(buf4,2)\n  lz = min(size(buf4,3),kmax)\n  reclen = mx * ny * lz * reclen_mult\n\n  if (dodebug) then\n    write(6,*) \"mx     = \", mx\n    write(6,*) \"ny     = \", ny\n    write(6,*) \"lz     = \", lz\n    write(6,*) \"_mult  = \", reclen_mult\n    write(6,*) \"mx * ny * lz * reclen_mult = \", mx * ny * lz * reclen_mult\n    write(6,*) \"reclen = \", reclen\n  endif\n\n  inquire (file=trim(filename), exist=ex)\n  if (ex) then\n    if (dodebug) write(6,*) \"read_global: opening file: \", trim(filename)\n    if (dodebug) write(6,*) \"with reclen: \", reclen\n    open (unit=fid, file=trim(filename), status='old', access='direct', form='unformatted', recl=reclen)\n    ! this may take a long time, so output a note of what is happening...\n    write (6, *) 'read_global:: reading background file: ', trim(filename)\n    read (fid,rec=1) buf4(:,:,1:kmax)\n    close (fid)\n    write (6, *) 'read_global:: finished reading background file: ', trim(filename)\n  else\n    write (6, *) 'read_global:: global background file missing: ', trim(filename)\n    stop(\"merge_tiles.f90:: exiting...\")\n  endif\n\n  if (dodebug) then\n    print *, \"max(buf4) = \", maxval(buf4)\n    print *, \"min(buf4) = \", minval(buf4)\n    print *, \"avg(buf4) = \", sum(buf4)/(mx*ny*lz)\n    print *, \"maxloc(buf4) = \", maxloc(buf4)\n    print *, \"minloc(buf4) = \", minloc(buf4)\n  endif\n\nend subroutine read_global\n"}, {"instruction": "Create a Fortran subroutine named decode to decode a string based on a simple encoding scheme. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "subroutine decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"abcdefghijklmnopqrstuvwxyz\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named intweight1t to calculate the weights at each corner of a tetrahedron based on the input eigenenergies and the Fermi energy. The number of input parameters is 2, with test_data type ['real*8', 'real*8'], representing the eigenenergies at the corners of the tetrahedron and the Fermi energy. The number of output parameters is 1, with test_data type ['real*8'], representing the weights at each corner.", "input": "", "output": "subroutine intweight1t(w, et,ef)\n\n  ! the energies have to be given in increasing energy order.     \n  implicit none\n  real*8, intent(out):: w(4) ! weight at each corner\n  real*8, intent(in) :: et(4) ! eigenenergies at the corners of the tetrahedron.\n  real*8, intent(in) :: ef    ! fermi energy.\n  ! locals\n  integer :: index, i\n  real*8  :: c1,c2,c3,vo4\n  real*8  :: f31,f41,f32,f42\n  real*8  :: e31,e41,e32,e42\n  if( et(4) <= ef) then  ! all energies above ef\n     index = 4\n  else\n     index=0\n     do i=1,4             ! how many corners of tetrahedra below ef\n        if( et(i) <= ef) index = index + 1\n     enddo\n  endif\n  vo4 = 1.0d0/4.0d0\n  select case(index)\n  case(0)          ! all states are unoccupied\n     w(:) = 0.0d0\n  case(1)          ! only the lowest energy is occupied.\n     do i=2,4\n        w(i) = (ef-et(1))/(et(i)-et(1))\n     enddo\n     c1 = w(2) * w(3) * w(4)\n     w(2) = c1 * w(2)\n     w(3) = c1 * w(3)\n     w(4) = c1 * w(4)\n     w(1) = 4.0d0 * c1 - w(2) - w(3) - w(4)\n  case(2)         ! the two lower energies are occupied\n     f31 = (ef-et(1))/(et(3)-et(1))\n     f41 = (ef-et(1))/(et(4)-et(1))\n     f32 = (ef-et(2))/(et(3)-et(2))\n     f42 = (ef-et(2))/(et(4)-et(2))\n     e31 = (et(3)-ef)/(et(3)-et(1))\n     e41 = (et(4)-ef)/(et(4)-et(1))\n     e32 = (et(3)-ef)/(et(3)-et(2))\n     e42 = (et(4)-ef)/(et(4)-et(2))\n     c1 = f41 * f31\n     c2 = f41 * f32 * e31\n     c3 = f42 * f32 * e41\n     w(1) =  c1 + (c1+c2)*e31 + (c1+c2+c3)*e41 \n     w(2) =  c1+c2+c3 + (c2+c3)*e32 + c3*e42 \n     w(3) =  (c1+c2)*f31 + (c2+c3)*f32 \n     w(4) =  (c1+c2+c3)*f41 + c3*f31 \n  case(3)        ! only the highest energy is unoccupied\n     do i=1,3\n        w(i) = (et(4)-ef)/(et(4)-et(i))\n     enddo\n     c1   = w(1) * w(2) * w(3) \n     w(4) = 1.0d0 - c1 * (4.0d0 - w(1)-w(2)-w(3))\n     w(1) = 1.0d0 - c1 * w(1)\n     w(2) = 1.0d0 - c1 * w(2)\n     w(3) = 1.0d0 - c1 * w(3)\n  case(4)        ! all states are occupied\n     w(:) = 1.d0\n  end select\n  w(:) = w(:)*vo4\nend subroutine intweight1t\n"}, {"instruction": "Create a Fortran subroutine named ksurf to calculate the weight at each corner of a tetrahedron based on the energies provided. The subroutine takes 2 input parameters of type real*8, et(4) and ef, and 1 output parameter of type real*8, wgh(4). Ensure that the energies are given in increasing energy order.", "input": "", "output": "subroutine ksurf(wgh, et, ef)\n\n  ! k-mesh, the area of the fermi surface inside the tetrahedron is calculated\n  ! which is the essential item to decide the weight of the integration over\n  ! each vertex.\n  ! the energies have to be given in increasing energy order.\n  implicit none\n  real*8, intent(out) :: wgh(4)    ! the weight at each corner\n  real*8, intent(in)  :: et(4)     ! the band energies or energy difference at k\n  real*8, intent(in)  :: ef        ! the energy or energy differnce surface\n  !\n  integer :: i, indx  ! indx=number of nodes below ef\n  real*8  :: delta21, delta31, delta41, delta32, delta42, delta43  ! energy differences       \n  real*8  :: deles1, deles2, deles3, deles4 ! ef-eo(i) \n  real*8  :: den0         ! denominators\n  real*8  :: num0, num1   ! numerators\n  real*8  :: wt           ! total weight\n  !\n  wgh(:) = 0.0d0\n  if ( ef < et(1) ) then\n     indx=0\n  else\n     indx=1\n     do i=2,4\n        if( et(i) <= ef) indx = indx + 1\n     enddo\n  endif\n  select case(indx)\n  case(0,4) \n     continue\n  case(1) ! only et(1)< ef, one triangle\n     deles1  =  ef - et(1)\n     delta21 = et(2)-et(1)\n     delta31 = et(3)-et(1)\n     delta41 = et(4)-et(1)\n     den0 = 6.0d0*delta21*delta31*delta41\n     num0 = deles1*deles1\n     ! total wgh\n     wt = 3.0d0*num0/den0\n     num1 = num0*deles1\n     wgh(2) = num1/(delta21*den0)\n     wgh(3) = num1/(delta31*den0)\n     wgh(4) = num1/(delta41*den0)\n     wgh(1) = wt - wgh(2) - wgh(3) - wgh(4)\n  case(2) ! et(1)<et(2)<ef, two triangles\n     deles1  =  ef  - et(1)\n     deles2  =  ef  - et(2)\n     deles3  = et(3) - ef\n     deles4  = et(4) - ef\n     delta21 = et(2) - et(1)\n     delta31 = et(3) - et(1)\n     delta41 = et(4) - et(1)\n     delta32 = et(3) - et(2)\n     delta42 = et(4) - et(2)\n     delta43 = et(4) - et(3)\n     ! total wgh          \n     num0 = deles1*deles3 / (6.0d0*delta31*delta32*delta41)\n     num1 = deles2*deles4 / (6.0d0*delta32*delta41*delta42)\n     wt = 3.0d0 * (num0 + num1)\n     !\n     wgh(2) = deles3/delta32 * num0   + (deles3*delta42+deles2*delta31)/(delta41*delta42) * num1\n     wgh(3) = (deles1*delta32+deles2*delta31)/(delta31*delta32) * num0 + deles2/(delta32) * num1\n     wgh(4) = deles1/(delta41) * num0 + (deles1*delta42+deles2*delta41)/(delta41*delta42) * num1\n     wgh(1) = wt - wgh(2)-wgh(3)-wgh(4)\n  case(3) ! ee(1), ee(2) and ee(3) < efer, one triangle.\n     deles4  = et(4) - ef\n     delta41 = et(4) - et(1)\n     delta42 = et(4) - et(2)\n     delta43 = et(4) - et(3)\n     den0 = 6.0d0*delta41*delta42*delta43\n     if ( den0 < 1.0e-12) then\n        write(6,*)'error in ksurf: flat band'\n        write(6,*) et\n        stop 'flat band'\n     endif\n     num0 = deles4*deles4\n     ! total wgh\n     wt   = num0* 3.0d0/den0\n     num1 = num0*deles4/den0\n     wgh(1) = num1/delta41\n     wgh(2) = num1/delta42\n     wgh(3) = num1/delta43\n     wgh(4) = wt - wgh(1)-wgh(2)-wgh(3)\n  end select\nend subroutine ksurf\n"}, {"instruction": "Write a Fortran subroutine named rank that takes an integer array nproc3 as input and returns two output parameters: ip (integer) and ip3 (integer array). The subroutine should copy the values from nproc3 to ip3 and set ip to 0.", "input": "", "output": "subroutine rank(ip, ip3, nproc3)\ninteger, intent(out) :: ip, ip3(3)\ninteger, intent(in) :: nproc3(3)\nip = 0\nip3 = nproc3\nip3 = 0\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"rreduce1\" to perform reduction operations on an input array based on the specified operation. The subroutine should have 2 input parameters of type real and character(*), and 1 output parameter of type real.", "input": "", "output": "subroutine rreduce1(f1out, f1, op)\nreal, intent(out) :: f1out(:)\nreal, intent(in) :: f1(:)\ncharacter(*), intent(in) :: op\ncharacter :: a\na = op(1:1)\nf1out = f1\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named rreduce2 that takes two input arguments: an array of real numbers f2 and a character string op. The output is an array of real numbers f2out. The subroutine should copy the values of f2 to f2out. The number of input arguments is 2 and the test_data type is [real, character(*)]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "subroutine rreduce2(f2out, f2, op)\nreal, intent(out) :: f2out(:,:)\nreal, intent(in) :: f2(:,:)\ncharacter(*), intent(in) :: op\ncharacter :: a\na = op(1:1)\nf2out = f2\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named sub to initialize an integer array with a value of 1. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine sub(key,a)\n    integer, intent(out)    :: a(:) \n    character(*),intent(in) :: key\n    a = 1   \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_pmtanh to calculate the hyperbolic tangent of the product of two double precision numbers. The subroutine takes 2 input parameters of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "subroutine calc_pmtanh(pm,seg,pmtanh)\n\n      implicit none\n\n      !i/o\n      double precision, intent(in) :: pm,seg\n      double precision, intent(out) :: pmtanh\n\n      !locals\n\n\n      pmtanh = seg*(0.5*(tanh(40.0*(pm-0.90))+1.0))\n      !pmtanh = 0.8*seg*(0.5*(tanh(40.0*(pm-0.98))+1.0))\n\n      return\n\n   end subroutine calc_pmtanh\n"}, {"instruction": "Write a Fortran subroutine named findfactor to calculate the factors of a given integer. The input parameter is an integer. The output parameters are an integer array and an integer representing the number of factors.", "input": "", "output": "  subroutine findfactor(num, factors, nfact)\n    \n    implicit none\n\n    integer, intent(in) :: num\n    integer, intent(out), dimension(*) :: factors\n    integer, intent(out) :: nfact\n    integer :: i, m\n\n    ! find the factors <= sqrt(num)\n    m = int(sqrt(real(num)))\n    nfact = 1\n    do i=1,m\n       if (num/i*i == num) then\n          factors(nfact) = i\n          nfact = nfact + 1\n       end if\n    end do\n    nfact = nfact - 1\n\n    ! derive those > sqrt(num)\n    if (factors(nfact)**2/=num) then\n       do i=nfact+1, 2*nfact\n          factors(i) = num / factors(2*nfact-i+1)\n       end do\n       nfact = nfact * 2\n    else\n       do i=nfact+1, 2*nfact-1\n          factors(i) = num / factors(2*nfact-i)\n       end do\n       nfact = nfact * 2 - 1\n    endif\n       \n    return\n\n  end subroutine findfactor\n"}, {"instruction": "Create a Fortran subroutine named \"calculateepspeq\" to calculate the equivalent plastic shear strain. The subroutine takes 1 input parameter of type 'double precision, dimension(6)' and provides 1 output parameter of type 'double precision'.", "input": "", "output": "\tsubroutine calculateepspeq(epsp,epspeq)\n      !**********************************************************************\n      !\n      ! calculation of the equivalent plastic shear strain\n      !\n      !**********************************************************************\n\n      implicit none\n\n      !local variables\n      double precision:: epspm, c1, c2\n      double precision, dimension(3) :: epsdev\n      !in variables\n      double precision, intent(in), dimension(6) :: epsp\n      !out variables\n      double precision, intent(out) :: epspeq\n\n      !epspeq = ((2/3)ep:ep)^(1/2), ep is the deviatoric plastic strain\n\n      epspm = (1.0d0/3.0d0) * (epsp(1) + epsp(2) + epsp(3))\n      epsdev(1) = epsp(1)-epspm\n      epsdev(2) = epsp(2)-epspm\n      epsdev(3) = epsp(3)-epspm\n      c1 = 2.0d0/3.0d0\n      c2 = c1 * 0.5d0\n\n      epspeq = sqrt(c1*epsdev(1)*epsdev(1) + c1*epsdev(2)*epsdev(2) +  c1*epsdev(3)*epsdev(3) + &\n                     c2*epsp(4)*epsp(4) + c2*epsp(5)*epsp(5) + c2*epsp(6)*epsp(6))\n\n\tend subroutine calculateepspeq\n"}, {"instruction": "Create a Fortran subroutine named distribute_proc to distribute a given data length among a specified number of processes, and calculate the start, end, and size for each process. The number of input parameters is 3, of type integer, representing the data length, number of processes, and process coordinate. The number of output parameters is 3, of type integer, representing the start index, end index, and size for the specified process.", "input": "", "output": "  subroutine distribute_proc(ndatalen,numproc,pcoord,st,en,sz)\n    implicit none\n    integer,intent(in) ::ndatalen,numproc,pcoord\n    integer,intent(out)::st,en,sz\n\n    ! locals\n    integer:: i,size1,nl,nu\n    integer,dimension(:),allocatable::starr,enarr,szarr \n\n    allocate(starr(0:numproc-1),enarr(0:numproc-1),szarr(0:numproc-1))\n    size1=ndatalen/numproc\n    nu = ndatalen-size1 * numproc\n    nl = numproc -nu\n    starr(0)= 1\n    szarr(0)= size1\n    enarr(0)= size1\n    do i=1,nl-1\n     starr(i)= starr(i-1) + size1\n     szarr(i)= size1\n     enarr(i)= enarr(i-1) + size1\n    end do\n    size1 = size1 + 1\n    do i=nl,numproc-1\n     starr(i) = enarr(i-1) + 1\n     szarr(i) = size1\n     enarr(i) = enarr(i-1) + size1\n    end do\n    enarr(numproc-1)= ndatalen \n    szarr(numproc-1)= ndatalen-starr(numproc-1)+1\n\n    st=starr(pcoord);en=enarr(pcoord);sz=szarr(pcoord)\n    deallocate(starr,enarr,szarr)\n  end subroutine distribute_proc\n"}, {"instruction": "Write a Fortran subroutine named get_guess that takes in the number of pegs as an integer input and outputs an array of integers representing the user's color choices for each peg. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(num_pegs)'].", "input": "", "output": "subroutine get_guess(num_pegs, guess)\r\n\tinteger, intent(in)                       :: num_pegs\r\n\tinteger, dimension(num_pegs), intent(out) :: guess\r\n\tinteger                                   :: i, selected\r\n\r\n\r\n\twrite(*, \"(a,i2,a)\"), '1. '//achar(27)//'[1;', red, 'mred'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '2. '//achar(27)//'[1;', green,&\r\n\t                      &'mgreen'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '3. '//achar(27)//'[1;', yellow,&\r\n\t                      &'myellow'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '4. '//achar(27)//'[1;', blue,&\r\n\t                      &'mblue'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '5. '//achar(27)//'[1;', purple,&\r\n\t                      &'mpurple'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '6. '//achar(27)//'[1;', cyan,&\r\n\t                      &'mcyan'//achar(27)//'[0m'\r\n\r\n\ti=1\r\n\tdo\r\n\t\tif (i > num_pegs) exit\r\n\t\twrite(*, '(a, i0)'), 'pick colour for peg #', i\r\n\t\tread(*,*), selected\r\n\t\tselect case(selected)\r\n\t\t\tcase(1)\r\n\t\t\t\tguess(i) = red\r\n\t\t\tcase(2)\r\n\t\t\t\tguess(i) = green\r\n\t\t\tcase(3)\r\n\t\t\t\tguess(i) = yellow\r\n\t\t\tcase(4)\r\n\t\t\t\tguess(i) = blue\r\n\t\t\tcase(5)\r\n\t\t\t\tguess(i) = purple\r\n\t\t\tcase(6)\r\n\t\t\t\tguess(i) = cyan\r\n\t\t\tcase default\r\n\t\t\t\twrite(*, '(i0, a)'), selected,' is an invalid choice.'\r\n\t\t\t\ti = i - 1\r\n\t\tend select\r\n\r\n\t\ti = i + 1\r\n\tend do\r\nend subroutine get_guess\r\n"}, {"instruction": "Create a Fortran subroutine named geteos to compute thermodynamic properties such as pressure and sound speed based on the material properties and state variables. The subroutine takes 7 input parameters of type ['integer', 'integer', 'integer', 'real*8', 'real*8', 'real*8', 'real*8'] and returns 2 output parameters of type ['real*8', 'real*8'].", "input": "", "output": "subroutine geteos(nmatel,ncase,gamlg,rho, eintl, rhoi, pres, sd ,ielem)\n!\nimplicit none\ninteger, intent(in):: nmatel, ncase,ielem\nreal*8,  intent(in):: gamlg,rho, eintl,rhoi\nreal*8, intent(out):: pres,sd\n\n\nreal*8::presh, enrgh, eta\nreal*8::dphdeta,dehdeta,detadrho\nreal*8::dphdrho, sd2\nreal*8::s0,c0,gmodu\nreal*8::eps\n!\neps =1d-6\n!\nselect case (nmatel)\n\n!...idea gas\ncase(1)\n!...pres\npres = max(eps, (gamlg-1.d0)*rho*eintl)\n!...sound speed\nsd = sqrt(gamlg*pres/rho)\n\n!...solid\ncase(2)\n\n if(ncase.eq.1)then\n  s0 = 1.34d0\n  c0 = 0.533d0\n  gmodu = 0.286d0\n\n elseif(ncase.eq.2)then\n  s0 = 1.124d0\n  c0 = 1.287d0\n  gmodu = 1.5111d0\n\n elseif(ncase.eq.3)then\n s0 = 1.338d0\n c0 = 0.533d0\n gmodu = 0.276d0\n elseif(ncase.eq.104)then\n s0 = 1.124d0\n c0 = 1.287d0\n gmodu = 1.5111d0\n\n endif\n\n!...\neta = 1.d0-rhoi/rho\n\n!...hugniout pressure and energy\npresh = rhoi*c0**2*eta/(1.d0-s0*eta)**2\nenrgh = eta*presh/2.d0/rhoi\n\n!...pressure\npres = presh + gamlg*rho*(eintl-enrgh)\n\n!...sound speed\ndetadrho = rhoi/rho**2\ndphdeta  = rhoi*c0**2*(1.d0/(1.d0-s0*eta)**2 + 2.d0*eta*s0/(1.d0-s0*eta)**3)\ndehdeta   = .5d0/rhoi*(presh+eta*dphdeta)\nsd2      = dphdeta*detadrho + gamlg*(eintl-enrgh) - gamlg*dehdeta*detadrho + gamlg*pres/rho\nsd2      = sd2 + 4.d0/3.d0*gmodu/rho\n\nsd = sqrt(sd2)\n!\nif(ielem.eq.-1)then\n print*,'ieleminside',rhoi,rho,eta,c0,s0\n print*,'ielem2',presh,enrgh,eintl,pres\n print*,'ielem3',detadrho,dphdeta,dehdeta,sd2\n print*,'ielem4',dphdeta*detadrho, gamlg*(eintl-enrgh),gamlg*dehdeta*detadrho ,gamlg*pres/rho,&\n4.d0/3.d0*gmodu/rho\nendif\n!\nend select\n!\nend subroutine geteos\n"}, {"instruction": "Create a Fortran subroutine named factors_mt to calculate the factors using the given inputs. The subroutine takes 3 input parameters of type real, dimension(5), real, and returns 1 output parameter of type real, dimension(5).", "input": "", "output": "    pure subroutine factors_mt( matfac, radpat, r, factors )\n        \n        real, intent(in), dimension(5)  :: matfac, radpat\n        real, intent(in)                :: r\n        real, intent(out), dimension(5) :: factors\n        \n        factors(1) = matfac(1)*radpat(1)/r**4\n        factors(2) = matfac(2)*radpat(2)/r**2\n        factors(3) = matfac(3)*radpat(3)/r**2\n        factors(4) = matfac(4)*radpat(4)/r\n        factors(5) = matfac(5)*radpat(5)/r\n        \n    end subroutine factors_mt\n"}, {"instruction": "Create a Fortran subroutine named factors_sf to calculate factors based on the input parameters matfac, radpat, and r. The input parameters are of type real, dimension(3), real, dimension(3), and real respectively. The output parameter factors is of type real, dimension(3).", "input": "", "output": "    pure subroutine factors_sf( matfac, radpat, r, factors )\n    \n        real, intent(in), dimension(3)  :: matfac, radpat\n        real, intent(in)                :: r\n        real, intent(out), dimension(3) :: factors\n        \n        factors(1) = matfac(1)*radpat(1)/r**3\n        factors(2) = matfac(2)*radpat(2)/r\n        factors(3) = matfac(3)*radpat(3)/r\n        \n    end subroutine factors_sf\n"}, {"instruction": "Create a Fortran subroutine named make_direction_cosine to calculate the direction cosines and the magnitude of a given 3D coordinate vector.\nThe number of input arguments is 1, and the test_data type is ['real, dimension(3)'].\nThe number of output arguments is 2, and the test_data type is ['real, dimension(3)', 'real'].", "input": "", "output": "    pure subroutine make_direction_cosine( coord, gamma, r)\n            \n        real, intent(in), dimension(3)    :: coord\n        real, intent(out), dimension(3)   :: gamma\n        real, intent(out)                 :: r\n\n        ! make direction cosines and r\n        \n        ! n,e,z(down)=coord(1),coord(2),coord(3) \n        r=sqrt(coord(1)**2+coord(2)**2+coord(3)**2)\n\n        ! gamma(i)=dr/dx(i)=cos(r,x(i))=coord(i)/r\n        gamma(:)=coord(:)/r\n        \n    end subroutine make_direction_cosine\n"}, {"instruction": "Create a Fortran subroutine named \"rp1\" to solve 1D Euler equations using the HLL approximate Riemann solver. The subroutine takes 10 input parameters: maxmx, meqn, mwaves, maux, mbc, mx (all integers), ql and qr (double precision arrays of dimension [meqn, 1-mbc:maxmx+mbc]), auxl and auxr (double precision arrays of dimension [maux, 1-mbc:maxmx+mbc]). The subroutine returns 4 output parameters: wave (double precision array of dimension [meqn, mwaves, 1-mbc:maxmx+mbc]), amdq (double precision array of dimension [meqn, 1-mbc:maxmx+mbc]), apdq (double precision array of dimension [meqn, 1-mbc:maxmx+mbc]), and s (double precision array of dimension [mwaves, 1-mbc:maxmx+mbc]).", "input": "", "output": "subroutine rp1(maxmx,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,wave,s,amdq,apdq)\n! =========================================================\n\n! solve riemann problems for the 1d euler equations using the hlle\n! approximate riemann solver.\n\n! waves: 2\n! equations: 3\n\n! conserved quantities:\n!       1 density\n!       2 momentum\n!       3 energy\n\n    implicit none\n\n    integer, intent(in) :: maxmx, meqn, mwaves, mbc, mx, maux\n    double precision, dimension(meqn,1-mbc:maxmx+mbc), intent(in) :: ql, qr\n    double precision, dimension(maux,1-mbc:maxmx+mbc), intent(in) :: auxl, auxr\n    double precision, dimension(meqn, mwaves, 1-mbc:maxmx+mbc), intent(out) :: wave\n    double precision, dimension(meqn, 1-mbc:maxmx+mbc), intent(out) :: amdq, apdq\n    double precision, dimension(mwaves, 1-mbc:maxmx+mbc), intent(out) :: s\n\n    double precision :: u_l, u_r, c_l, c_r, u_hat, c_hat\n    double precision :: p_l, p_r, h_l, h_r, rhsqrt_l, rhsqrt_r\n    double precision :: rhsq2, h_hat, gamma, gamma1, e_l, e_r\n    double precision :: rho_m, rhou_m, e_m, s1, s2\n    integer :: m, i, mw\n\n    common /cparam/  gamma\n\n    gamma1 = gamma - 1.d0\n\n    do i=2-mbc,mx+mbc\n        ! velocity\n        u_l = qr(2,i-1) / qr(1,i-1)\n        u_r = ql(2,i  ) / ql(1,i  )\n        ! pressure\n        p_l = gamma1 * (qr(3,i-1) - qr(1,i-1)*u_l**2/2.d0)\n        p_r = gamma1 * (ql(3,i  ) - ql(1,i  )*u_r**2/2.d0)\n        ! enthalpy\n        h_l = (qr(3,i-1) + p_l) / qr(1,i-1)\n        h_r = (ql(3,i  ) + p_l) / ql(1,i  )\n        ! sound speed\n        c_l = dsqrt(gamma1*h_l-u_l**2/2.)\n        c_r = dsqrt(gamma1*h_r-u_r**2/2.)\n\n        e_l = qr(3,i-1)\n        e_r = ql(3,i  )\n\n\n        rhsqrt_l = dsqrt(qr(1,i-1))\n        rhsqrt_r = dsqrt(ql(1,i))\n        rhsq2 = rhsqrt_l + rhsqrt_r\n        u_hat = (qr(2,i-1)/rhsqrt_l + ql(2,i)/rhsqrt_r) / rhsq2\n        h_hat = (((qr(3,i-1)+p_l)/rhsqrt_l + (ql(3,i)+p_r)/rhsqrt_r)) / rhsq2\n        c_hat = dsqrt(gamma1*(h_hat - .5d0*u_hat**2))\n\n        s1 = min(u_l - c_l, u_hat - c_hat)\n        s2 = max(u_r + c_r, u_hat + c_hat)\n        rho_m = (ql(2,i) - qr(2,i-1) - s2*ql(1,i) + s1*qr(1,i-1))/(s1-s2)\n        rhou_m = (ql(1,i)*u_r**2 - qr(1,i-1)*u_l**2 + p_r - p_l - s2*ql(2,i) + s1*qr(2,i-1))/(s1-s2)\n        e_m = ( u_r*(e_r+p_r) - u_l*(e_l+p_l) -s2*e_r + s1*e_l)/(s1-s2)\n\n        wave(1,1,i) = rho_m - qr(1,i-1)\n        wave(2,1,i) = rhou_m - qr(2,i-1)\n        wave(3,1,i) = e_m - qr(3,i-1)\n        s(1,i) = s1\n    \n        wave(1,2,i) = ql(1,i) - rho_m\n        wave(2,2,i) = ql(2,i) - rhou_m\n        wave(3,2,i) = ql(3,i) - e_m\n        s(2,i) = s2\n\n    end do \n\n    do m=1,3\n        do i=2-mbc, mx+mbc\n            amdq(m,i) = 0.d0\n            apdq(m,i) = 0.d0\n            do mw=1,mwaves\n                if (s(mw,i) < 0.d0) then\n                    amdq(m,i) = amdq(m,i) + s(mw,i)*wave(m,mw,i)\n                else\n                    apdq(m,i) = apdq(m,i) + s(mw,i)*wave(m,mw,i)\n                endif\n            end do\n        end do\n    end do\n\nend subroutine rp1\n"}, {"instruction": "Create a Fortran subroutine named diagv to extract the diagonal elements of a matrix and store them in a vector. The subroutine takes 1 input parameter of type real(8), dimension(:, :) and outputs 1 parameter of type real(8), dimension(size(m, 1)). Ensure that there is no error handling for dimension mismatch.", "input": "", "output": "subroutine diagv(m, v)\n    real(8), intent(in), dimension(:, :) :: m\n    integer :: i\n    real(8), intent(out), dimension(size(m, 1)) :: v\n    ! note: no error handling of dimension mismatch\n    v = [(m(i, i), i = 1, size(m, 1))]\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named build_hdate that takes an integer array containing time specifications as input and produces a character string representing the date in the format \"yyyy-mm-dd hh:mm:ss\" as output. The input parameter consists of 6 integers, while the output parameter is a character string of unspecified length.", "input": "", "output": "   subroutine build_hdate(hdate, time)\n\n! purpose:\n!      from the year, month, day, hour, minute, and second values,\n!      creates a 19-character string representing the date, in the\n!      format:  \"yyyy-mm-dd hh:mm:ss\"\n\n! input:\n      integer, intent(in) :: time(6) ! all time specs in it\n! output:\n      character*(*), intent(out) :: hdate ! 'yyyy-mm-dd hh:mm:ss'\n\n! local:\n      integer iyr     ! year (e.g., 1997, 2001)\n      integer imo     ! month (01 - 12)\n      integer idy     ! day of the month (01 - 31)\n      integer ihr     ! hour (00-23)\n      integer imi     ! minute (00-59)\n      integer isc     ! second (00-59)\n!\n!      integer i  ! loop counter.\n      integer hlen ! length of hdate string\n\n      hlen = len(hdate)\n      iyr = time(1)\n      imo = time(2)\n      idy = time(3)\n      ihr = time(4)\n      imi = time(5)\n      isc = time(6)\n\n      if (hlen.eq.19) then\n         write(hdate,19) iyr, imo, idy, ihr, imi, isc\n 19      format(i4,'-',i2.2,'-',i2.2,'_',i2.2,':',i2.2,':',i2.2)\n\n      elseif (hlen.eq.16) then\n         write(hdate,16) iyr, imo, idy, ihr, imi\n 16      format(i4,'-',i2.2,'-',i2.2,'_',i2.2,':',i2.2)\n\n      elseif (hlen.eq.13) then\n         write(hdate,13) iyr, imo, idy, ihr\n 13      format(i4,'-',i2.2,'-',i2.2,'_',i2.2)\n\n      elseif (hlen.eq.10) then\n         write(hdate,10) iyr, imo, idy, ihr\n 10      format(i4,i2.2,i2.2,i2.2)\n      endif\n\n      return\n      end subroutine build_hdate\n"}, {"instruction": "Create a Fortran subroutine named get_diffs_wind to calculate the differences, absolute differences, and squared differences of wind components. The subroutine takes 8 input parameters of type real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:), integer, integer, integer, and real. It returns 3 output parameters of type real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:).", "input": "", "output": "  subroutine get_diffs_wind(u1, v1, u2,v2,diff, absdiff, sqdiff, nx, ny, nz, missing)\n    \n    real, intent(in), dimension(:,:,:)             :: u1, u2, v1, v2\n    real, intent(out), dimension(:,:,:)            :: diff, absdiff, sqdiff\n    integer, intent(in)                            :: nx, ny, nz\n    integer                                        :: i,j,k\n    real, intent(in)                               :: missing\n    real                                           :: u, v\n\n    do k = 1, nz\n    do j = 1, ny\n    do i = 1, nx\n       if ( u1(i,j,k) /= missing .and. v1(i,j,k) /= missing .and. &\n            u2(i,j,k) /= missing .and. v2(i,j,k) /= missing ) then\n         u  = u1(i,j,k) - u2(i,j,k) \n         v  = v1(i,j,k) - v2(i,j,k) \n         diff(i,j,k)   = u + v\n         absdiff(i,j,k)   = abs(u) + abs (v)                \n         sqdiff(i,j,k) = u*u + v*v\n       else\n         diff(i,j,k)   = missing \n         absdiff(i,j,k)   = missing \n         sqdiff(i,j,k) = missing\n       endif\n    enddo\n    enddo\n    enddo\n\n  end subroutine get_diffs_wind \n"}, {"instruction": "Write a Fortran subroutine named domain_average to calculate the average profile and the count of non-missing values in a 3D domain. The subroutine should take 6 input parameters of types integer, integer, integer, integer, real array of 3 dimensions, and real. It should also return 2 output parameters of types integer array and real array.", "input": "", "output": "  subroutine domain_average(var, avg_prof, counter, nx, ny, nz, missing,isq)\n\n  integer, intent(in)                                 :: nx,ny,nz,isq\n  real, intent(in), dimension(:,:,:)                  :: var\n  integer, intent(out), dimension(:)                  :: counter\n  real, intent(out), dimension(:)                     :: avg_prof\n  real, intent(in)                                    :: missing\n\n  integer                                             :: i,j,k,icount\n  real                                                :: dsum, dmiss\n  integer                                             :: imiss\n\n!9999\n!hui: set dmiss value consistent with plot script\n!  dmiss = -9999.999\n  dmiss = -99.99\n  imiss = -99\n  do k = 1, nz\n     icount = 0\n     dsum = 0\n     do j = 1, ny\n     do i = 1, nx\n         if ( var(i,j,k) /= missing ) then\n            icount = icount + 1\n            dsum = dsum + var(i,j,k)\n         endif\n     enddo\n     enddo   \n     avg_prof(k) = dmiss\n!hui     counter(k) = 0\n     counter(k) = imiss\n     if (icount /= 0 ) then\n        counter(k) = icount\n        if ( isq .eq. 0 ) then\n          avg_prof(k) = dsum /float(icount)\n        else\n          avg_prof(k) = sqrt(dsum /float(icount))\n        endif\n      endif\n  enddo\n\n  end subroutine domain_average\n"}, {"instruction": "Write a Fortran subroutine named alpha to compute the area of intersection between two circles of radii rb and rs separated by a distance s. The number of input arguments is 3 and the test_data type is ['real(8)', 'real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)'].", "input": "", "output": " subroutine alpha(rb,rs,s,alph)\n ! computes area of intersection (alpha) between two circles \n ! of radii r and r separated by distance s.\n\n implicit none\n real(8), intent(in) :: rb, rs, s\n real(8) :: kap0, kap1, kap2\n real(8), intent(out) :: alph\n     \n kap0 = dacos( (s**2 + rs**2 - rb**2)/(2.0d0*s*rs) )\n kap1 = dacos( (s**2 + rb**2 - rs**2)/(2.0d0*s*rb) )\n kap2 = dsqrt(0.25d0*(4.0d0*s**2*rb**2 - (rb**2+s**2-rs**2)**2))\n \n alph = rs**2*kap0 + rb**2*kap1 - kap2\n\n end subroutine alpha\n"}, {"instruction": "Create a Fortran subroutine named pmpir_add_error_string_f08 to add an error message string to the error code. The subroutine takes 2 input parameters of type integer and character with variable length, and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine pmpir_add_error_string_f08(errorcode, string, ierror)\n        implicit none\n        integer, intent(in) :: errorcode\n        character(len=*), intent(in) :: string\n        integer, optional, intent(out) :: ierror\n    end subroutine pmpir_add_error_string_f08\n"}, {"instruction": "Create a Fortran subroutine named pmpir_error_class_f08. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer and integer (optional). The purpose of this subroutine is to determine the error class based on the error code provided.", "input": "", "output": "    subroutine pmpir_error_class_f08(errorcode, errorclass, ierror)\n        implicit none\n        integer, intent(in) :: errorcode\n        integer, intent(out) :: errorclass\n        integer, optional, intent(out) :: ierror\n    end subroutine pmpir_error_class_f08\n"}, {"instruction": "Create a Fortran subroutine named load_climatology to load climatology data from files.The subroutine has 4 input parameters of type integer, integer, integer, and logical, and 2 output parameters of type real and real.", "input": "", "output": "    subroutine load_climatology ( yearday, nx, ny, is_leap, clim_taux, clim_tauy)\n      ! input/output data\n      integer, intent(in)  :: yearday, nx, ny\n      logical, intent(in)  :: is_leap\n      real   , intent(out) :: clim_taux(nx,ny), clim_tauy(nx,ny)\n      integer              :: clim_tauid\n    \n      ! climatology data\n      character (len = *), parameter :: clim_base_taux = &\n      \"/data/datos/ascat/data_l4_clim/clim_taux_blend_1992-2010_365.dat\"\n      character (len = *), parameter :: clim_base_tauy = &\n      \"/data/datos/ascat/data_l4_clim/clim_tauy_blend_1992-2010_365.dat\"\n      character (len = :), allocatable :: clim_file_taux\n      character (len = :), allocatable :: clim_file_tauy\n      \n      if ( is_leap .eqv. .true. ) then\n        clim_file_taux = clim_base_taux(:len(clim_base_taux)-7) //\"366.dat\"\n        clim_file_tauy = clim_base_tauy(:len(clim_base_tauy)-7) //\"366.dat\"\n      else\n        clim_file_taux = clim_base_taux\n        clim_file_tauy = clim_base_tauy\n      end if\n      write(*,'(a,1x,a,/)') \"loading climatology from file: \", clim_file_taux\n      write(*,'(a,1x,a,/)') \"loading climatology from file: \", clim_file_tauy\n    \n      open(newunit=clim_tauid, file=clim_file_taux, form=\"unformatted\", &\n            access=\"direct\", recl=nx*ny*4, &\n            status=\"old\", convert=\"big_endian\")\n      read(unit=clim_tauid, rec=yearday) clim_taux\n      close(unit=clim_tauid)\n    \n      open(newunit=clim_tauid, file=clim_file_tauy, form=\"unformatted\", &\n            access=\"direct\", recl=nx*ny*4, &\n            status=\"old\", convert=\"big_endian\")\n      read(unit=clim_tauid, rec=yearday) clim_tauy\n      close(unit=clim_tauid)\n    \n    end subroutine load_climatology\n"}, {"instruction": "Write a Fortran subroutine named put_ch to append a character string to the current record of the default unit. The subroutine has 1 input parameter of type character(len=*) and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_ch(string, iostat)\n\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a character string to the current record of\n! the default unit\n\n        if (present(iostat)) then\n            write (unit=*, fmt=\"(a)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=*, fmt=\"(a)\", advance=\"no\") string\n        end if\n\n! finish\n\n    end subroutine put_ch\n"}, {"instruction": "Create a Fortran subroutine named put_unit_ch with 2 input parameters of type integer and character(len=*), and 1 output parameter of type integer, which is optional. This subroutine appends a character string to the current record of the specified unit. If the optional iostat parameter is present, it writes the string to the specified unit, and if not present, it writes the string to the specified unit without advancing to the next record.", "input": "", "output": "    subroutine put_unit_ch(unit, string, iostat)\n\n        integer, intent(in)            :: unit\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a character string to the current record of\n! the specified unit\n\n        if (present(iostat)) then\n            write (unit=unit, fmt=\"(a)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=unit, fmt=\"(a)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_unit_ch\n"}, {"instruction": "Create a Fortran subroutine named put_line_ch to append a varying string to the current record of the default unit, terminating the record. The subroutine takes 1 input parameter of type character(len=*) and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_ch(string, iostat)\n\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a varying string to the current record of\n! the default unit, terminating the record\n\n        if (present(iostat)) then\n            write (unit=*, fmt=\"(a,/)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=*, fmt=\"(a,/)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_line_ch\n"}, {"instruction": "Create a Fortran subroutine named put_line_unit_ch that appends a varying string to the current record of the specified unit. The subroutine takes 2 input parameters of type integer and character(len=*), and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_unit_ch(unit, string, iostat)\n\n        integer, intent(in)            :: unit\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a varying string to the current record of\n! the specified unit, terminating the record\n\n        if (present(iostat)) then\n            write (unit=unit, fmt=\"(a,/)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=unit, fmt=\"(a,/)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_line_unit_ch\n"}, {"instruction": "Create a Fortran subroutine named shape9 to calculate gauss points, weights, shape functions, and derivatives for one-dimensional elements (beams and 2-d shells). The subroutine takes 2 input parameters of type integer (kind=4) and returns 4 output parameters of type real (kind=8), real (kind=8), real (kind=8), and real (kind=8) to store the weights, positions of gauss points, shape functions, and derivatives, respectively.", "input": "", "output": " subroutine shape9(weigh,posgp,shape,deriv,nnode,ngaus)\r\n !***********************************************************************\r\n !\r\n !     gauss points, weights, shape functions and derivatives for\r\n !     one-dimensinal elements (beams and 2-d shells)\r\n !***********************************************************************\r\n implicit none\r\n integer (kind=4), intent(in) :: nnode,ngaus\r\n real (kind=8), intent(out) :: weigh(:),posgp(:),shape(:,:),deriv(:,:)\r\n\r\n !     gauss points weight and possitions\r\n\r\n select case (ngaus)\r\n case(1)\r\n   weigh(1) =  2d0\r\n   posgp(1) =  0d0\r\n   select case (nnode)\r\n   case(2) !   two nodes, one gauss point\r\n     shape(1,1) =  0.5d0\r\n     shape(2,1) =  0.5d0\r\n     deriv(1,1) = -0.5d0\r\n     deriv(2,1) =  0.5d0\r\n   end select\r\n case(2)\r\n   weigh(1:2) =  1d0\r\n   posgp(1) = -1d0/sqrt(3d0)\r\n   posgp(2) =  1d0/sqrt(3d0)\r\n   select case (nnode)\r\n   case (2) !     two nodes, two gauss points\r\n     shape(1,1) =  0.5d0*(1d0-posgp(1))\r\n     shape(2,1) =  0.5d0*(1d0+posgp(1))\r\n     shape(1,2) =  0.5d0*(1d0-posgp(2))\r\n     shape(2,2) =  0.5d0*(1d0+posgp(2))\r\n     deriv(1,1) = -0.5d0\r\n     deriv(2,1) =  0.5d0\r\n     deriv(1,2) = -0.5d0\r\n     deriv(2,2) =  0.5d0\r\n   case (3)  !     three nodes, two gauss points\r\n     shape(1,1) = -0.5d0*(1d0-posgp(1))*posgp(1)\r\n     shape(2,1) =  1d0-posgp(1)**2\r\n     shape(3,1) =  0.5d0*(1d0+posgp(1))*posgp(1)\r\n     shape(1,2) = -0.5d0*(1d0-posgp(2))*posgp(2)\r\n     shape(2,2) =  1d0-posgp(2)**2\r\n     shape(3,2) =  0.5d0*(1d0+posgp(2))*posgp(2)\r\n     deriv(1,1) =  posgp(1)-0.5d0\r\n     deriv(2,1) = -posgp(1)*2d0\r\n     deriv(3,1) =  posgp(1)+0.5d0\r\n     deriv(1,2) =  posgp(2)-0.5d0\r\n     deriv(2,2) = -posgp(2)*2d0\r\n     deriv(3,2) =  posgp(2)+0.5d0\r\n   end select\r\n\r\n case(3)     !three gauss points\r\n   weigh(1) =  5d0/9d0\r\n   weigh(2) =  8d0/9d0\r\n   weigh(3) =  5d0/9d0\r\n   posgp(1) = -0.774596669241483d0\r\n   posgp(2) =  0d0\r\n   posgp(3) =  0.774596669241483d0\r\n   select case (nnode)\r\n   case (3)  !     three nodes, three gauss points\r\n     shape(1,1) = -0.5d0*(1d0-posgp(1))*posgp(1)\r\n     shape(2,1) =  1d0-posgp(1)**2\r\n     shape(3,1) =  0.5d0*(1d0+posgp(1))*posgp(1)\r\n     shape(1,2) = -0.5d0*(1d0-posgp(2))*posgp(2)\r\n     shape(2,2) =  1d0-posgp(2)**2\r\n     shape(3,2) =  0.5d0*(1d0+posgp(2))*posgp(2)\r\n     shape(1,3) = -0.5d0*(1d0-posgp(3))*posgp(3)\r\n     shape(2,3) =  1d0-posgp(3)**2\r\n     shape(3,3) =  0.5d0*(1d0+posgp(3))*posgp(3)\r\n     deriv(1,1) =  posgp(1)-0.5d0\r\n     deriv(2,1) = -posgp(1)*2d0\r\n     deriv(3,1) =  posgp(1)+0.5d0\r\n     deriv(1,2) =  posgp(2)-0.5d0\r\n     deriv(2,2) = -posgp(2)*2d0\r\n     deriv(3,2) =  posgp(2)+0.5d0\r\n     deriv(1,3) =  posgp(3)-0.5d0\r\n     deriv(2,3) = -posgp(3)*2d0\r\n     deriv(3,3) =  posgp(3)+0.5d0\r\n   end select\r\n end select\r\n return\r\n end subroutine shape9\r\n"}, {"instruction": "Create a Fortran subroutine named adios2_stringc2f to convert a C-style string to a Fortran-style string. The subroutine takes 2 input parameters of type character*(*) and integer, and 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    subroutine adios2_stringc2f(c_string, length, f_string)\n        character*(*), intent(in) :: c_string\n        integer, intent(in) :: length\n        character(len=:), allocatable, intent(out) :: f_string\n\n        if (allocated(f_string)) deallocate (f_string)\n        if (length > 0) then\n            allocate (character(length) :: f_string)\n            f_string = c_string(1:length)\n        end if\n\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named adios2_typec2f to convert a given integer representing an ADIOS2 type from C-style to Fortran-style. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The subroutine maps the input C-style integer to the equivalent Fortran-style integer and assigns the result to the output parameter.", "input": "", "output": "    subroutine adios2_typec2f(c_type, f_type)\n        integer, intent(in) :: c_type\n        integer, intent(out) :: f_type\n\n        integer :: i\n\n        f_type = adios2_type_unknown\n\n        do i = -1, 11\n            if (c_type == i) then\n                f_type = c_type\n                exit\n            end if\n        end do\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rowk that calculates the values for an array r based on the indices n and k. The number of input parameters is 2 with the test_data type ['integer', 'integer'], and the number of output parameters is 1 with the test_data type ['real (dp)']. The subroutine utilizes the selected_real_kind(14, 60) kind for real numbers.", "input": "", "output": "subroutine rowk(n, k, r)\r\n\r\nimplicit none\r\ninteger, parameter  :: dp = selected_real_kind(14, 60)\r\ninteger, intent(in)     :: n, k\r\nreal (dp), intent(out)  :: r(:)\r\n\r\ninteger    :: i\r\nreal (dp)  :: temp\r\n\r\nr(k) = 1.0_dp\r\nif (k > 1) then\r\n  temp = 1.0_dp\r\n  do i = 1, k-1\r\n    temp = 0.99_dp * temp\r\n    r(k-i) = temp\r\n  end do\r\nend if\r\n\r\nif (k < n) then\r\n  temp = 1.0_dp\r\n  do i = 1, n-k\r\n    temp = 0.99_dp * temp\r\n    r(k+i) = temp\r\n  end do\r\nend if\r\n\r\nreturn\r\nend subroutine rowk\r\n"}, {"instruction": "Create a Fortran subroutine named getprimefactor to find the smallest prime factor of a given integer input. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "subroutine getprimefactor(dim,myfactor)\n  implicit none\n  integer, intent(in) :: dim\n  integer, intent(out) :: myfactor\n  integer :: iprime\n  integer, parameter :: numprimes=31\n  integer, parameter :: primelist(numprimes)=&\n       (/  2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,&\n          73, 79, 83, 89, 97,101,103,107,109,113,127 /)  ! no need to go remotely this high\n\n  myfactor=dim\n  do iprime=1,numprimes\n     if (mod(dim,primelist(iprime)).eq.0) then\n        myfactor=primelist(iprime)\n        return\n     endif\n  enddo\nend subroutine getprimefactor\n"}, {"instruction": "Create a Fortran subroutine named gettwiddlesmall to calculate the twiddle factors for a given dimension. The subroutine takes 2 input parameters of type integer and produces 1 output parameter of type complex*16. The input parameters are the dimensions dim1 and dim2.", "input": "", "output": "subroutine gettwiddlesmall(twiddlefacs,dim1,dim2)\n  implicit none\n  integer, intent(in) :: dim1,dim2\n  complex*16, intent(out) :: twiddlefacs(dim1)\n  complex*16 :: phi\n  integer :: k1, itwiddle(dim1)\n  real*8, parameter :: pi=3.14159265358979323846264338327950d0\n  phi=exp((0d0,-2d0) * pi / (dim1*dim2))\n  do k1=1,dim1\n     itwiddle(k1)=(k1-1)\n  enddo\n  twiddlefacs(:)=phi**itwiddle(:)\nend subroutine gettwiddlesmall\n"}, {"instruction": "Write a Fortran subroutine named cdate to convert a Julian day number to a calendar date. The subroutine should have 1 input parameter of type integer and 3 output parameters of type integer. The input parameter represents the Julian day number, and the output parameters represent the year, month, and day of the corresponding calendar date.", "input": "", "output": " subroutine cdate(jd,yyyy,mm,dd)\n!====given a julian day number, nnnnnnnn, yyyy,mm,dd are returned as the\n!         calendar date. jd = nnnnnnnn is the julian date from an epoch\n!         in the very distant past.  see cacm 1968 11(10):657,\n!         letter to the editor by fliegel and van flandern.\n!    example call cdate(2440588, yyyy, mm, dd) returns 1970 1 1 .\n\n integer,intent(in)  ::  jd\n integer,intent(out) ::  yyyy,mm,dd\n integer l\n\n l = jd + 68569\n n = 4*l/146097\n l = l - (146097*n + 3)/4\n yyyy = 4000*(l+1)/1461001\n l = l - 1461*yyyy/4 + 31\n mm = 80*l/2447\n dd = l - 2447*mm/80\n l = mm/11\n mm = mm + 2 - 12*l\n yyyy = 100*(n-49) + yyyy + l\n return\n end subroutine cdate\n"}, {"instruction": "Write a Fortran subroutine named conversion to convert a given number into year, month, and day. The subroutine takes 1 input parameter of type integer and 3 output parameters of type integer.", "input": "", "output": "   subroutine  conversion(number, year, month, day)\n   implicit  none\n\n   integer, intent(in)  :: number\n   integer, intent(out) :: year, month, day\n\n   year  = number / 10000\n   month = mod(number, 10000) / 100\n   day   = mod(number, 100)\n   end subroutine  conversion\n"}, {"instruction": "Create a Fortran subroutine named smear2 to calculate the values of ts1 and ts2 based on the input parameters drsq, pol12, and a, which are all of type double precision. The subroutine has 3 input parameters and 2 output parameters, all of which are of type double precision.", "input": "", "output": "subroutine smear2(drsq, pol12, a, ts1, ts2)\nimplicit none\ndouble precision, intent(in) :: drsq, pol12, a\ndouble precision, intent(out) :: ts1, ts2\ndouble precision :: dd,dri,drsqi,aa, ra,ra3,exp1\n\ndd = dsqrt(drsq)\ndri = 1.d0/dd\ndrsqi = dri*dri\n\naa = (pol12)**(1.d0/6.d0)\nra = dd/aa\nra3 = ra**3\nexp1 = dexp(-a*ra3)\nts1 = (1.d0 -exp1)*dri*drsqi\nts2 = (ts1 - exp1*a/aa**3) *drsqi\nend subroutine smear2\n"}, {"instruction": "Create a Fortran subroutine named split_za that takes an integer input parameter and returns two integer output parameters. The input parameter should be of type integer, and the two output parameters should also be of type integer. The subroutine should divide the input integer by 1000 and assign the quotient to one output parameter and the remainder to the other output parameter.", "input": "", "output": "        subroutine split_za(za, z, a)\n            implicit none\n            integer, intent(in):: za\n            integer, intent(out):: z, a\n            z = za / 1000\n            a = za - z*1000\n            return\n        end subroutine split_za\n"}, {"instruction": "Write a Fortran subroutine named `boulac_length` to calculate the boundary layer length scales. The subroutine takes 6 input parameters: 2 integers (`kts`, `kte`), and 4 real arrays of dimensions `kts:kte` and `kts:kte+1` as specified. It also returns 2 real arrays of dimensions `kts:kte`. The subroutine computes the boundary layer length scales based on the input data and the algorithm provided in the code.", "input": "", "output": "  subroutine boulac_length(kts,kte,zw,dz,qtke,theta,lb1,lb2)\n     integer, intent(in) :: kts,kte\n     real, dimension(kts:kte), intent(in) :: qtke,dz,theta\n     real, dimension(kts:kte), intent(out) :: lb1,lb2\n     real, dimension(kts:kte+1), intent(in) :: zw\n     integer :: iz, izz, found\n     real, dimension(kts:kte) :: dlu,dld\n     real, parameter :: lmax=2000.\n     real :: dzt, zup, beta, zup_inf, bbb, tl, zdo, zdo_sup, zzz\n     do iz=kts,kte\n        zup=0.\n        dlu(iz)=zw(kte+1)-zw(iz)-dz(iz)/2.\n        zzz=0.\n        zup_inf=0.\n        beta=g/theta(iz)\n        if (iz .lt. kte) then\n          found = 0\n          izz=iz\n          do while (found .eq. 0)\n            if (izz .lt. kte) then\n              dzt=dz(izz)\n              zup=zup-beta*theta(iz)*dzt\n              zup=zup+beta*(theta(izz+1)+theta(izz))*dzt/2.\n              zzz=zzz+dzt\n              if (qtke(iz).lt.zup .and. qtke(iz).ge.zup_inf) then\n                 bbb=(theta(izz+1)-theta(izz))/dzt\n                 if (bbb .ne. 0.) then\n                    tl=(-beta*(theta(izz)-theta(iz)) + &\n                      & sqrt( max(0.,(beta*(theta(izz)-theta(iz)))**2. + &\n                      & 2.*bbb*beta*(qtke(iz)-zup_inf))))/bbb/beta\n                 else\n                    if (theta(izz) .ne. theta(iz))then\n                       tl=(qtke(iz)-zup_inf)/(beta*(theta(izz)-theta(iz)))\n                    else\n                       tl=0.\n                    endif\n                 endif\n                 dlu(iz)=zzz-dzt+tl\n                 found =1\n              endif\n              zup_inf=zup\n              izz=izz+1\n             else\n              found = 1\n            endif\n          enddo\n        endif\n        zdo=0.\n        zdo_sup=0.\n        dld(iz)=zw(iz)\n        zzz=0.\n        if (iz .gt. kts) then\n          found = 0\n          izz=iz\n          do while (found .eq. 0)\n            if (izz .gt. kts) then\n              dzt=dz(izz-1)\n              zdo=zdo+beta*theta(iz)*dzt\n              zdo=zdo-beta*(theta(izz-1)+theta(izz))*dzt/2.\n              zzz=zzz+dzt\n              if (qtke(iz).lt.zdo .and. qtke(iz).ge.zdo_sup) then\n                 bbb=(theta(izz)-theta(izz-1))/dzt\n                 if (bbb .ne. 0.) then\n                    tl=(beta*(theta(izz)-theta(iz))+ &\n                      & sqrt( max(0.,(beta*(theta(izz)-theta(iz)))**2. + &\n                      & 2.*bbb*beta*(qtke(iz)-zdo_sup))))/bbb/beta\n                 else\n                    if (theta(izz) .ne. theta(iz)) then\n                       tl=(qtke(iz)-zdo_sup)/(beta*(theta(izz)-theta(iz)))\n                    else\n                       tl=0.\n                    endif\n                 endif\n                 dld(iz)=zzz-dzt+tl\n                 found = 1\n              endif\n              zdo_sup=zdo\n              izz=izz-1\n            else\n              found = 1\n            endif\n          enddo\n        endif\n        dld(iz) = min(dld(iz),zw(iz+1))\n        lb1(iz) = min(dlu(iz),dld(iz))\n        lb2(iz) = sqrt(dlu(iz)*dld(iz))\n        lb1(iz) = lb1(iz)/(1. + (lb1(iz)/lmax))\n        lb2(iz) = lb2(iz)/(1. + (lb2(iz)/lmax))\n        if (iz .eq. kte) then\n           lb1(kte) = lb1(kte-1)\n           lb2(kte) = lb2(kte-1)\n        endif\n     enddo\n  end subroutine boulac_length\n"}, {"instruction": "Create a Fortran subroutine named get_indices to find all the indices of a matching character in a given string. The subroutine takes 2 input parameters of type character(len=*) and 2 output parameters of type integer and integer, optional.", "input": "", "output": "   subroutine get_indices( match_strng, string, match_cnt, match_ndx )\n!------------------------------------------------------------------\n!     get all indices of match char in string\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n   integer, intent(out) :: match_cnt\n   integer, optional, intent(out) :: match_ndx(:)\n   character(len=*), intent(in) :: match_strng\n   character(len=*), intent(in) :: string\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n   integer :: pos, ndx\n   logical :: set_ndx\n\n   if( present( match_ndx ) ) then\n     set_ndx = .true.\n   else\n     set_ndx = .false.\n   endif\n   ndx       = 0\n   match_cnt = 0\n   do\n     pos = index( string(ndx+1:), match_strng )\n     if( pos == 0 ) then\n       exit\n     endif\n     ndx       = ndx + pos \n     match_cnt = match_cnt + 1 \n     if( set_ndx ) then\n       match_ndx(match_cnt) = ndx\n     endif\n   end do\n\n   end subroutine get_indices\n"}, {"instruction": "Write a Fortran subroutine named wrf2mz_time to convert a WRF time string to the Mozart date and second format. The subroutine takes 1 input argument of type character(len=*) and 2 output arguments of type integer.", "input": "", "output": "       subroutine wrf2mz_time( wrf_time, ncdate, ncsec )\n!------------------------------------------------------------------\n!     convert wrf time string to mozart date,sec format\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n       character(len=*), intent(in) :: wrf_time\n       integer, intent(out)         :: ncdate\n       integer, intent(out)         :: ncsec\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n      integer :: year, month, day\n      integer :: hour, minute, second\n      integer :: date_time_sep\n      integer :: nstring\n      integer :: istat\n\n      nstring = len( wrf_time )\n      date_time_sep = index( wrf_time, '_' )\n      if( date_time_sep < 1 .or. date_time_sep >= nstring ) then\n         write(*,*) 'wrf2mz_time: wrf date ',wrf_time(:nstring),' is invalid'\n      end if\n!------------------------------------------------------------------\n!     read year, month and day\n!------------------------------------------------------------------\n       read(wrf_time(:date_time_sep-1),'(i4,1x,i2,1x,i2)',iostat=istat) year, month, day\n       if( istat /= 0 ) then\n         write(*,*) 'wrf2mz_time: failed to read year,month,day; iostat = ',istat\n       end if\n       read(wrf_time(date_time_sep+1:nstring),'(i2,1x,i2,1x,i2)',iostat=istat) hour, minute, second\n       if( istat /= 0 ) then\n         write(*,*) 'wrf2mz_time: failed to read hour,minute,second; iostat = ',istat\n       end if\n       ncdate = 100*(year*100 + month) + day\n       ncsec  = 60*(60*hour + minute) + second\n\n      end subroutine wrf2mz_time\n"}, {"instruction": "Write a Fortran subroutine named mz2wrf_time to convert the WRF time string to a Mozart date and seconds format. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=*)'].", "input": "", "output": "      subroutine mz2wrf_time( wrf_time, ncdate, ncsec )\n!------------------------------------------------------------------\n!     convert wrf time string to mozart date,sec format\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n       character(len=*), intent(out) :: wrf_time\n       integer, intent(in)           :: ncdate\n       integer, intent(in)           :: ncsec\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n      integer :: year, month, day\n      integer :: hour, minute, second\n      integer :: nstring\n      integer :: istat\n      character(len=3) :: numa\n\n      wrf_time = ' '\n      year  = ncdate/10000\n      month = mod( ncdate,10000 )/100\n      day   = mod( ncdate,100)\n      write(wrf_time,'(i4,''-'')',iostat=istat) year\n      write(numa,'(i3)') 100+month\n      wrf_time(6:8) = numa(2:3) // '-'\n      write(numa,'(i3)') 100+day\n      wrf_time(9:11) = numa(2:3) // '_'\n      hour   = ncsec/3600\n      minute = (ncsec - hour*3600)/60\n      second = ncsec - 60*(hour*60 + minute)\n      write(numa,'(i3)') 100+hour\n      wrf_time(12:14) = numa(2:3) // ':'\n      write(numa,'(i3)') 100+minute\n      wrf_time(15:17) = numa(2:3) // ':'\n      write(numa,'(i3)') 100+second\n      wrf_time(18:19) = numa(2:3)\n\n      end subroutine mz2wrf_time\n"}, {"instruction": "Write a Fortran subroutine named \"upcase\" to convert a given input string to uppercase. The number of input parameters for this subroutine is 1, and the test_data type is ['character(len=*)']. The number of output parameters is 1, and the test_data type is ['character(len=*)'].", "input": "", "output": "   subroutine upcase( in_string, out_string )\n!------------------------------------------------------------------\n!  convert string to upper case\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!  dummy arguments\n!------------------------------------------------------------------\n   character(len=*), intent(in)  :: in_string\n   character(len=*), intent(out) :: out_string\n\n!------------------------------------------------------------------\n!  local variables\n!------------------------------------------------------------------\n   integer :: incr\n   integer :: m\n\n   incr = ichar( 'a' ) - ichar( 'a' )\n   out_string(:) = ' '\n   do m = 1,min(len(in_string),len(out_string))\n     if( lge( in_string(m:m),'a' ) .and. lle( in_string(m:m),'z' ) ) then\n       out_string(m:m) = char( ichar( in_string(m:m) ) + incr )\n     else\n       out_string(m:m) = in_string(m:m)\n     endif\n   end do\n\n   end subroutine upcase\n"}, {"instruction": "Create a Fortran subroutine named forpar to analyze the parent-child relationships in a tree structure. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are neqns and parent(*), while the output parameters are nstop and nch(*). The subroutine calculates the number of children for each parent node and identifies the node at which the tree structure stops.", "input": "", "output": "  subroutine forpar(neqns,parent,nch,nstop)\n    implicit none\n    !------\n    integer, intent(in):: neqns\n    integer, intent(in):: parent(*)\n    integer, intent(out):: nstop\n    integer, intent(out):: nch(*)\n    !------\n    integer:: i\n    integer:: idens\n    integer:: ii\n\n    nch(1:neqns) = 0\n    nch(neqns+1) = 0\n    do i = 1, neqns\n      ii = parent(i)\n      nch(ii) = nch(ii) + 1\n    enddo\n    do i = neqns, 1, -1\n      if ( nch(i)/=1 ) exit\n    enddo\n\n    idens = 0\n    if ( idens==1 ) then\n      nstop = i\n    else\n      nstop = neqns + 1\n    endif\n  end subroutine forpar\n"}, {"instruction": "Write a Fortran subroutine named bringu to perform a specific operation related to permutations and integer arrays. This subroutine takes 4 input parameters of type integer: izz, neqns, zpiv, and parent. It also has 3 output parameters of type integer: irr, iperm, and invp.", "input": "", "output": "  subroutine bringu(zpiv,iperm,invp,parent,izz,neqns,irr)\n    implicit none\n    !------\n    integer, intent(in):: izz\n    integer, intent(in):: neqns\n    integer, intent(in):: zpiv(*)\n    integer, intent(in):: parent(*)\n    integer, intent(out):: irr\n    integer, intent(out):: iperm(*)\n    integer, intent(out):: invp(*)\n    !------\n    integer:: i\n    integer:: ib\n    integer:: ib0\n    integer:: ibp\n    integer:: idbg\n    integer:: izzp\n\n    idbg = 0\n    irr = 0\n    ib0 = invp(izz)\n    ib = ib0\n    do while ( ib>0 )\n      ibp = parent(ib)\n      izzp = iperm(ibp)\n      if ( zpiv(izzp)==0 ) then\n        invp(izz) = ibp\n        invp(izzp) = ib0\n        iperm(ibp) = izz\n        iperm(ib0) = izzp\n        if ( idbg/=0 ) then\n          do i = 1, neqns\n            if ( invp(iperm(i))/=i .or. iperm(invp(i))/=i) then\n              write (6,*) 'permutation error'\n              stop\n            endif\n          enddo\n          return\n        endif\n        return\n      else\n        ib = ibp\n      endif\n    enddo\n    irr = 1\n  end subroutine bringu\n"}, {"instruction": "Create a Fortran subroutine named \"addrx\" that takes 9 input parameters of type integer and real(kind=8), and 4 output parameters of type integer and real(kind=8). The function should perform a series of computations involving the input parameters and assign values to the output parameters based on the logic implemented in the subroutine.", "input": "", "output": "  subroutine addrx(i,j,aij,invp,xlnzr,colno,diag,zln,dsln,nstop,ndeg,ndeg2l,ir)\n    implicit none\n    !------\n    integer, intent(in):: i\n    integer, intent(in):: j\n    integer, intent(in):: ndeg\n    integer, intent(in):: ndeg2l\n    integer, intent(in):: nstop\n    integer, intent(in):: invp(*)\n    integer, intent(in):: xlnzr(*)\n    integer, intent(in):: colno(*)\n    real(kind=8), intent(in):: aij(ndeg,ndeg)\n    integer, intent(out):: ir\n    real(kind=8), intent(out):: zln(ndeg,ndeg,*)\n    real(kind=8), intent(out):: diag(ndeg2l,*)\n    real(kind=8), intent(out):: dsln(ndeg,ndeg,*)\n    !------\n    integer:: i0\n    integer:: ii\n    integer:: itrans\n    integer:: j0\n    integer:: jj\n    integer:: k\n    integer:: ke\n    integer:: ks\n    integer:: l\n    integer:: m\n    integer:: n\n    integer, parameter:: idbg = 0\n\n    ir = 0\n    ii = invp(i)\n    jj = invp(j)\n    if ( idbg/=0 ) write (6,*) ii, jj, aij\n    if ( ii==jj ) then\n      l = 0\n      do n = 1, ndeg\n        do m = 1, n\n          l = l + 1\n          diag(l,ii) = aij(n,m)\n        enddo\n      enddo\n      return\n    endif\n    itrans = 0\n    if ( jj>ii ) then\n      k = jj\n      jj = ii\n      ii = k\n      itrans = 1\n    endif\n    if ( jj>=nstop ) then\n      i0 = ii - nstop\n      j0 = jj - nstop + 1\n      k = i0*(i0-1)/2 + j0\n      if ( itrans==0 ) then\n        do m = 1, ndeg\n          dsln(1:ndeg,m,k) = aij(1:ndeg,m)\n        enddo\n      else\n        do m = 1, ndeg\n          dsln(1:ndeg,m,k) = aij(m,1:ndeg)\n        enddo\n      endif\n      return\n    endif\n    ks = xlnzr(ii)\n    ke = xlnzr(ii+1) - 1\n    do k = ks, ke\n      if ( colno(k)==jj ) then\n        if ( itrans==0 ) then\n          do m = 1, ndeg\n            zln(1:ndeg,m,k) = aij(1:ndeg,m)\n          enddo\n        else\n          do m = 1, ndeg\n            zln(1:ndeg,m,k) = aij(m,1:ndeg)\n          enddo\n        endif\n        return\n      endif\n    enddo\n    ir = 20\n  end subroutine addrx\n"}, {"instruction": "Create a Fortran subroutine named d2dot to compute the dot product of two 4xN matrices A and B, and store the result in a 4x1 matrix T. The subroutine should take 3 input parameters of type integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine d2dot(t,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(4,*)\n    real(kind=8), intent(in):: b(4,*)\n    real(kind=8), intent(out):: t(4)\n    !------\n    integer:: jj\n\n    t(1:4) = 0.0d0\n\n    do jj = 1, n\n      t(1) = t(1) + a(1,jj)*b(1,jj) + a(3,jj)*b(3,jj)\n      t(2) = t(2) + a(2,jj)*b(1,jj) + a(4,jj)*b(3,jj)\n      t(3) = t(3) + a(1,jj)*b(2,jj) + a(3,jj)*b(4,jj)\n      t(4) = t(4) + a(2,jj)*b(2,jj) + a(4,jj)*b(4,jj)\n    enddo\n  end subroutine d2dot\n"}, {"instruction": "Create a Fortran subroutine named d2sdot that performs a dot product calculation. The subroutine takes 3 input parameters: an integer n, and two arrays of real(kind=8) type, a(2,*) and b(4,*). It also has 1 output parameter, an array of real(kind=8) type, wi(2).", "input": "", "output": "  subroutine d2sdot(wi,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(2,*)\n    real(kind=8), intent(in):: b(4,*)\n    real(kind=8), intent(out):: wi(2)\n    !------\n    integer:: jj\n\n    do jj = 1, n\n      wi(1) = wi(1) - a(1,jj)*b(1,jj) - a(2,jj)*b(3,jj)\n      wi(2) = wi(2) - a(1,jj)*b(2,jj) - a(2,jj)*b(4,jj)\n    enddo\n  end subroutine d2sdot\n"}, {"instruction": "Create a Fortran subroutine named d3sdot to calculate the dot product of two 3-dimensional vectors. The subroutine takes 3 input parameters of types integer, real(kind=8) and real(kind=8), and 1 output parameter of type real(kind=8). The subroutine uses the imperative tone and the features of Fortran subroutine.", "input": "", "output": "  subroutine d3sdot(wi,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(3,*)\n    real(kind=8), intent(in):: b(9,*)\n    real(kind=8), intent(out):: wi(3)\n    !------\n    integer:: jj\n\n    do jj = 1, n\n      wi(1) = wi(1) - a(1,jj)*b(1,jj) - a(2,jj)*b(4,jj) - a(3,jj)*b(7,jj)\n      wi(2) = wi(2) - a(1,jj)*b(2,jj) - a(2,jj)*b(5,jj) - a(3,jj)*b(8,jj)\n      wi(3) = wi(3) - a(1,jj)*b(3,jj) - a(2,jj)*b(6,jj) - a(3,jj)*b(9,jj)\n    enddo\n  end subroutine d3sdot\n"}, {"instruction": "Create a Fortran subroutine named dxdot that performs matrix multiplication. It takes 4 input parameters of types integer, integer, real(kind=8), real(kind=8) and 1 output parameter of type real(kind=8). The subroutine computes the matrix product of two input matrices and stores the result in the output matrix. Use the imperative tone to define the subroutine and its parameters.", "input": "", "output": "  subroutine dxdot(ndeg,t,a,b,l)\n    implicit none\n    !------\n    integer, intent(in):: l\n    integer, intent(in):: ndeg\n    real(kind=8), intent(in):: a(ndeg,ndeg,*)\n    real(kind=8), intent(in):: b(ndeg,ndeg,*)\n    real(kind=8), intent(out):: t(ndeg,ndeg)\n    !------\n    integer:: jj\n    integer:: k\n    integer:: m\n    integer:: n\n\n    do n = 1, ndeg\n      do m = 1, ndeg\n        t(n,m) = 0.0d0\n        do k = 1, ndeg\n          do jj = 1, l\n            t(n,m) = t(n,m) + a(n,k,jj)*b(m,k,jj)\n          enddo\n        enddo\n      enddo\n    enddo\n  end subroutine dxdot\n"}, {"instruction": "Create a Fortran subroutine named inv22 to perform matrix operations. The subroutine takes 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameters are diag(3) and zz(4), and the output parameter is zln(4). The subroutine calculates specific operations on the input parameters and assigns the results to the output parameter.", "input": "", "output": "  subroutine inv22(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(3)\n    real(kind=8), intent(in):: zz(4)\n    real(kind=8), intent(out):: zln(4)\n    !------\n    zln(3) = zz(3) - zz(1)*diag(2)\n    zln(1) = zz(1)*diag(1)\n    zln(3) = zln(3)*diag(3)\n    zln(1) = zln(1) - zln(3)*diag(2)\n\n    zln(4) = zz(4) - zz(2)*diag(2)\n    zln(2) = zz(2)*diag(1)\n    zln(4) = zln(4)*diag(3)\n    zln(2) = zln(2) - zln(4)*diag(2)\n  end subroutine inv22\n"}, {"instruction": "Write a Fortran subroutine named inv33 to perform matrix inversion and compute the resulting matrix. The number of input arguments is 2, and the test_data type is ['real(kind=8)', 'real(kind=8)']. The number of output arguments is 1, and the test_data type is ['real(kind=8)'].", "input": "", "output": "  subroutine inv33(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(6)\n    real(kind=8), intent(in):: zz(9)\n    real(kind=8), intent(out):: zln(9)\n    !------\n    zln(4) = zz(4) - zz(1)*diag(2)\n    zln(7) = zz(7) - zz(1)*diag(4) - zln(4)*diag(5)\n    zln(1) = zz(1)*diag(1)\n    zln(4) = zln(4)*diag(3)\n    zln(7) = zln(7)*diag(6)\n    zln(4) = zln(4) - zln(7)*diag(5)\n    zln(1) = zln(1) - zln(4)*diag(2) - zln(7)*diag(4)\n\n    zln(5) = zz(5) - zz(2)*diag(2)\n    zln(8) = zz(8) - zz(2)*diag(4) - zln(5)*diag(5)\n    zln(2) = zz(2)*diag(1)\n    zln(5) = zln(5)*diag(3)\n    zln(8) = zln(8)*diag(6)\n    zln(5) = zln(5) - zln(8)*diag(5)\n    zln(2) = zln(2) - zln(5)*diag(2) - zln(8)*diag(4)\n\n    zln(6) = zz(6) - zz(3)*diag(2)\n    zln(9) = zz(9) - zz(3)*diag(4) - zln(6)*diag(5)\n    zln(3) = zz(3)*diag(1)\n    zln(6) = zln(6)*diag(3)\n    zln(9) = zln(9)*diag(6)\n    zln(6) = zln(6) - zln(9)*diag(5)\n    zln(3) = zln(3) - zln(6)*diag(2) - zln(9)*diag(4)\n  end subroutine inv33\n"}, {"instruction": "Create a Fortran subroutine named \"inv66\" to compute a certain matrix operation. The subroutine should take 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameters are \"diag(21)\" and \"zz(36)\", and the output parameter is \"zln(36)\". The subroutine involves matrix calculations and uses the imperative tone.", "input": "", "output": "  subroutine inv66(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(21)\n    real(kind=8), intent(in):: zz(36)\n    real(kind=8), intent(out):: zln(36)\n    !------\n    integer:: i\n\n    do i = 0, 5\n      zln(i+7) = zz(i+7) - zz(i+1)*diag(2)\n      zln(i+13) = zz(i+13) - zz(i+1)*diag(4) - zln(i+7)*diag(5)\n      zln(i+19) = zz(i+19) - zz(i+1)*diag(7) - zln(i+7)*diag(8) - zln(i+13)*diag(9)\n      zln(i+25) = zz(i+25) - zz(i+1)*diag(11) - zln(i+7)*diag(12) - zln(i+13)*diag(13)&\n        - zln(i+19)*diag(14)\n      zln(i+31) = zz(i+31) - zz(i+1)*diag(16) - zln(i+7)*diag(17) - zln(i+13)*diag(18)&\n        - zln(i+19)*diag(19) - zln(i+25)*diag(20)\n      zln(i+1) = zz(i+1)*diag(1)\n      zln(i+7) = zln(i+7)*diag(3)\n      zln(i+13) = zln(i+13)*diag(6)\n      zln(i+19) = zln(i+19)*diag(10)\n      zln(i+25) = zln(i+25)*diag(15)\n      zln(i+31) = zln(i+31)*diag(21)\n      zln(i+25) = zln(i+25) - zln(i+31)*diag(20)\n      zln(i+19) = zln(i+19) - zln(i+31)*diag(19) - zln(i+25)*diag(14)\n      zln(i+13) = zln(i+13) - zln(i+31)*diag(18) - zln(i+25)*diag(13)- zln(i+19)*diag(9)\n      zln(i+7) = zln(i+7) - zln(i+31)*diag(17) - zln(i+25)*diag(12)- zln(i+19)*diag(8)&\n        - zln(i+13)*diag(5)\n      zln(i+1) = zln(i+1) - zln(i+31)*diag(16) - zln(i+25)*diag(11)- zln(i+19)*diag(7)&\n        - zln(i+13)*diag(4) - zln(i+7)*diag(2)\n    enddo\n  end subroutine inv66\n"}, {"instruction": "Create a Fortran subroutine named invxx to perform a matrix inversion calculation. The subroutine takes 3 input parameters of types integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine invxx(zln,zz,diag,ndeg)\n    implicit none\n    !------\n    integer, intent(in):: ndeg\n    real(kind=8), intent(in):: diag(*)\n    real(kind=8), intent(in):: zz(ndeg,ndeg)\n    real(kind=8), intent(out):: zln(ndeg,ndeg)\n    !------\n    integer:: joc\n    integer:: l\n    integer:: loc1\n    integer:: m\n    integer:: n\n\n    zln = zz\n    do l = 1, ndeg, 2\n      joc = 0\n      do m = 1, ndeg - 1\n        joc = joc + m\n        loc1 = joc + m\n        do n = m + 1, ndeg\n          zln(l,n) = zln(l,n) - zln(l,m)*diag(loc1)\n          zln(l+1,n) = zln(l+1,n) - zln(l+1,m)*diag(loc1)\n          loc1 = loc1 + n\n        enddo\n      enddo\n      joc = 0\n      do m = 1, ndeg\n        joc = joc + m\n        zln(l,m) = zln(l,m)*diag(joc)\n        zln(l+1,m) = zln(l+1,m)*diag(joc)\n      enddo\n      do n = ndeg, 2, -1\n        joc = joc - 1\n        do m = n - 1, 1, -1\n          zln(l,m) = zln(l,m) - zln(l,n)*diag(joc)\n          zln(l+1,m) = zln(l+1,m) - zln(l+1,n)*diag(joc)\n          joc = joc - 1\n        enddo\n      enddo\n    enddo\n  end subroutine invxx\n"}, {"instruction": "Write a Fortran subroutine named qmdot to perform a specific graph operation. The subroutine takes 6 input parameters of type integer, which are rchsze, root, marker, rchset, nbrhd, and xadj. It also has 1 output parameter of type integer, which is adjncy. The subroutine performs a series of computations and modifications on the input data to generate the output adjncy.", "input": "", "output": "  subroutine qmdot(root,xadj,adjncy,marker,rchsze,rchset,nbrhd)\n    implicit none\n    !------\n    integer, intent(in):: rchsze\n    integer, intent(in):: root\n    integer, intent(in):: marker(*)\n    integer, intent(in):: rchset(*)\n    integer, intent(in):: nbrhd(*)\n    integer, intent(in):: xadj(*)\n    integer, intent(out):: adjncy(*)\n    !------\n    integer:: inhd\n    integer:: irch\n    integer:: j\n    integer:: jstrt\n    integer:: jstop\n    integer:: link\n    integer:: nabor\n    integer:: node\n\n    irch = 0\n    inhd = 0\n    node = root\n    100 jstrt = xadj(node)\n    jstop = xadj(node+1) - 2\n    if ( jstop>=jstrt ) then\n      do j = jstrt, jstop\n        irch = irch + 1\n        adjncy(j) = rchset(irch)\n        if ( irch>=rchsze ) goto 200\n      enddo\n    endif\n    link = adjncy(jstop+1)\n    node = -link\n    if ( link>=0 ) then\n      inhd = inhd + 1\n      node = nbrhd(inhd)\n      adjncy(jstop+1) = -node\n    endif\n    goto 100\n\n    200 adjncy(j+1) = 0\n    do irch = 1, rchsze\n      node = rchset(irch)\n      if ( marker(node)>=0 ) then\n        jstrt = xadj(node)\n        jstop = xadj(node+1) - 1\n        do j = jstrt, jstop\n          nabor = adjncy(j)\n          if ( marker(nabor)<0 ) then\n            adjncy(j) = root\n            exit\n          endif\n        enddo\n      endif\n    enddo\n  end subroutine qmdot\n"}, {"instruction": "Write a Fortran subroutine named qqsort to perform an in-place quicksort algorithm on an array of integers.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine qqsort(iw,ik)\n    implicit none\n    !------\n    integer, intent(in):: ik\n    integer, intent(out):: iw(*)\n    !------\n    integer:: itemp\n    integer:: l\n    integer:: m\n\n    if ( ik<=1 ) return\n    do l = 1, ik - 1\n      do m = l + 1, ik\n        if ( iw(l)>=iw(m) ) then\n          itemp = iw(l)\n          iw(l) = iw(m)\n          iw(m) = itemp\n        endif\n      enddo\n    enddo\n  end subroutine qqsort\n"}, {"instruction": "Create a Fortran subroutine named v2prod to perform vector-vector multiplication for arrays of real numbers. The subroutine takes 3 input parameters of type integer, real(kind=8), and real(kind=8) and 1 output parameter of type real(kind=8). The subroutine calculates the vector-vector product for each element in the arrays and stores the result in the output array.", "input": "", "output": "  subroutine v2prod(a,b,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(4,n)\n    real(kind=8), intent(in):: b(3,n)\n    real(kind=8), intent(out):: c(4,n)\n    !------\n    integer:: i\n\n    do i = 1, n\n      c(3,i) = a(3,i) - a(1,i)*b(2,i)\n      c(1,i) = a(1,i)*b(1,i)\n      c(3,i) = c(3,i)*b(3,i)\n      c(1,i) = c(1,i) - c(3,i)*b(2,i)\n\n      c(4,i) = a(4,i) - a(2,i)*b(2,i)\n      c(2,i) = a(2,i)*b(1,i)\n      c(4,i) = c(4,i)*b(3,i)\n      c(2,i) = c(2,i) - c(4,i)*b(2,i)\n    enddo\n  end subroutine v2prod\n"}, {"instruction": "Write a Fortran subroutine named \"vlcpy\" to copy the transpose of a real(kind=8) array \"b\" to another real(kind=8) array \"a\". The number of input arguments is 2, with test_data types ['integer', 'real(kind=8)']. The number of output arguments is 1 with test_data type ['real(kind=8)'].", "input": "", "output": "  subroutine vlcpy(a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: b(n,n)\n    real(kind=8), intent(out):: a(n,n)\n    !------\n    integer:: i\n\n    do i = 1, n\n      a(1:n,i) = b(i,1:n)\n    enddo\n  end subroutine vlcpy\n"}, {"instruction": "Write a Fortran subroutine named vcopy that copies the values from an array \"a\" to another array \"c\" of the same size. The number of input arguments is 2, with test_data types ['integer', 'real(kind=8)']. The number of output arguments is 1, with a test_data type of ['real(kind=8)'].", "input": "", "output": "  subroutine vcopy(a,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(n)\n    real(kind=8), intent(out):: c(n)\n    !------\n    c = a\n  end subroutine vcopy\n"}, {"instruction": "Write a Fortran subroutine named vprod to perform element-wise vector multiplication of two input arrays and store the result in a third array. The number of input arguments is 3 and the test_data type is [integer, real(kind=8), real(kind=8)]. The number of output arguments is 1 and the test_data type is [real(kind=8)].", "input": "", "output": "  subroutine vprod(a,b,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(n)\n    real(kind=8), intent(in):: b(n)\n    real(kind=8), intent(out):: c(n)\n    !------\n    c(1:n) = a(1:n)*b(1:n)\n  end subroutine vprod\n"}, {"instruction": "Create a Fortran subroutine named \"blacs_get\" to retrieve a value based on the context and a specified parameter. The subroutine should have 2 input parameters of type integer, named \"icontxt\" and \"what\", and 1 output parameter of type integer named \"val\".", "input": "", "output": "     subroutine blacs_get(icontxt, what, val)\n       implicit none\n       integer, intent(in)  :: icontxt\n       integer, intent(in)  :: what\n       integer, intent(out) :: val\n     end subroutine blacs_get\n"}, {"instruction": "Create a Fortran subroutine named dvbes1 that calculates the derivatives of the Bessel functions. The subroutine has 4 input parameters of type integer, real*8, real*8, and an array of real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine dvbes1(fj,dj,sm,ri,nt)\n  implicit none\n  !        arguments\n  integer, intent(in) :: nt\n  real*8, intent(in)  :: ri, sm, fj(nt)\n  real*8, intent(out) :: dj(nt)\n  !..................................................................\n  !   calculate the derivatives of the bessel functions\n  !      dj = dfj/dx where x = sm*ri\n  !                                        d.d.koelling\n  !..................................................................\n  !   local parameters\n  real*8, parameter :: zup = 1.0d-5\n  !        local scalars\n  integer            l, lm\n  double precision   q2, q3, x\n  !\n  x = sm*ri\n  if (x .gt. zup) then\n     q2 = -1.d0/x\n     q3 = q2\n     dj(1) = -fj(2)\n     lm = 1\n     do l = 2, nt\n        q3 = q3 + q2\n        dj(l) = fj(lm) + q3*fj(l)\n        lm = lm + 1\n     enddo\n  else\n     dj(1) = 0.d0\n     dj(2) = 1.0d+0/3.0d+0\n     do l = 3, nt\n        dj(l) = 0.d0\n     enddo\n  endif\n  !\n  return\nend subroutine dvbes1\n"}, {"instruction": "Create a Fortran subroutine named toto1 that takes an integer input argument and returns an integer output. This subroutine doubles the value of the input integer and assigns it to the output integer.", "input": "", "output": "  elemental subroutine toto1 (x, y)\n    integer, intent(out) :: x\n    integer, intent(in)  :: y\n    x = y + y\n  end subroutine toto1\n"}, {"instruction": "Create a Fortran subroutine named toto2 to perform the addition of 1 to each element of an input 2D integer array. The subroutine should have 1 input parameter with the type integer, dimension(:,:), and intent(in), and 1 output parameter with the type integer, dimension(:,:), and intent(out).", "input": "", "output": "  subroutine toto2 (x, y)\n    integer, dimension(:,:), intent(out) :: x\n    integer, dimension(:,:), intent(in)  :: y\n    x = y + 1\n  end subroutine toto2\n"}, {"instruction": "Create a Fortran subroutine named cutoff_cos to calculate the value and derivatives of a cutoff cosine function. The subroutine takes 3 input parameters of type double precision: x, r0, and rc. It returns 4 output parameters of type double precision: y, dy, d2y, and d3y.", "input": "", "output": "  subroutine cutoff_cos(x, r0, rc, y, dy, d2y, d3y)\n\n    implicit none\n\n    double precision, intent(in)  :: x, r0, rc\n    double precision, intent(out) :: y, dy, d2y, d3y\n\n    double precision,   parameter :: pi = 3.14159265358979d0\n\n    double precision :: a, a2\n\n    if (x<r0) then\n       y   = 1.0d0\n       dy  = 0.0d0\n       d2y = 0.0d0\n       d3y = 0.0d0\n    else if (x>rc) then\n       y   = 0.0d0\n       dy  = 0.0d0\n       d2y = 0.0d0\n       d3y = 0.0d0\n    else\n       a   = pi/(rc-r0)\n       a2  = a*a\n       y   =  0.5d0*(cos((x-r0)*a) + 1.0d0)\n       dy  =  0.5d0*sin((x-r0)*a)*a\n       d2y = -(y - 0.5d0)*a2\n       d3y = -dy*a2\n    end if\n\n  end subroutine cutoff_cos\n"}, {"instruction": "Create a Fortran subroutine named correlation to compute the cross-correlation function between two input arrays. The subroutine takes 6 input parameters and 2 output parameters. The input parameters consist of two integer*8, one double precision, and two arrays of double precision with dimensions nt and nlag. The output parameters are two arrays of double precision with dimension nlag.", "input": "", "output": "subroutine correlation(a,b,nt,lags,nlag,dt,r,cr)\n  !use ieee_arithmetic\n   implicit none\n   integer*8, intent(in) :: nt, nlag\n   double precision, intent(in) :: dt\n   integer*8, intent(in), dimension(nlag) :: lags\n   double precision, intent(in), dimension(nt) :: a,b\n   double precision, intent(out), dimension(nlag) :: r,cr\n   double precision :: aav, bav\n   integer*8 :: i,k,l,cnt\n   \n   do k=1,nlag\n      l=lags(k)\n      cr(k)=0; aav=0; bav=0; cnt=nt-l\n      do i=1,nt-l\n        !if (ieee_is_nan(a(i)) .and. ieee_is_nan(b(i+l)) then\n         if (isnan(a(i)) .or. isnan(b(i+l))) then\n            cnt=cnt-1\n           !continue\n         else\n            cr(k) = cr(k)+a(i)*b(i+l)\n            aav = aav+a(i)\n            bav = bav+b(i+l)\n!           cnt=cnt+1\n         endif\n      enddo\n      r(k)  = l*dt\n      cr(k) = (cr(k)*cnt - aav*bav)/cnt**2\n   enddo\n!  cr = cr/cr(1)\nend subroutine correlation\n"}, {"instruction": "Write a Fortran subroutine named cjday that calculates the Julian day from the given month and day. The subroutine takes 2 input parameters of type integer (month and day) and 1 output parameter of type integer (jday).", "input": "", "output": " subroutine cjday( month, day, jday )\n implicit none\n\n integer, intent(in)    :: month, day\n integer, intent(out)   :: jday\n integer, dimension(12) :: ndays = (/ 31,28,31,30,31,30, &\n                                      31,31,30,31,30,31 /)\n                  jday = day\n  if( month > 1 ) jday = jday + sum( ndays(1:month-1) ) \n\n  end subroutine cjday\n"}, {"instruction": "Write a Fortran subroutine named rz_3 to calculate the 3x3 rotation matrix around the z-axis. The input parameter is a real*8 scalar value, and the output parameter is a real*8 3x3 matrix.", "input": "", "output": "subroutine rz_3(r, psi)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: psi\n  !\n  r(1,1)=cos(psi); r(1,2)=-sin(psi); r(1,3)=0\n  r(2,1)=sin(psi); r(2,2)=cos(psi); r(2,3)=0\n  r(3,1)=0; r(3,2)=0; r(3,3)=1\nend subroutine rz_3\n"}, {"instruction": "Create a Fortran subroutine named \"ry_3\" to calculate the 3x3 rotation matrix about the y-axis based on the input angle. The subroutine should accept 1 input parameter of type real*8 and return 1 output parameter of type real*8.", "input": "", "output": "subroutine ry_3(r,the)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: the\n  !\n  r(1,1)=cos(the); r(1,2)=0.0; r(1,3)=sin(the)\n  r(2,1)=0.0; r(2,2)=1.0; r(2,3)=0.0\n  r(3,1)=-sin(the); r(3,2)=0.0; r(3,3)=cos(the)\nend subroutine ry_3\n"}, {"instruction": "Create a Fortran subroutine named rx_3 that calculates a 3x3 rotation matrix based on the input angle phi. The subroutine takes 1 input parameter of type real*8 and returns a 3x3 matrix of type real*8.", "input": "", "output": "subroutine rx_3(r, phi)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: phi\n  !\n  r(1,1)=1.0; r(1,2)=0.0; r(1,3)=0.0\n  r(2,1)=0.0; r(2,2)=cos(phi); r(2,3)=-sin(phi)\n  r(3,1)=0.0; r(3,2)=sin(phi); r(3,3)=cos(phi)\nend subroutine rx_3\n"}, {"instruction": "Create a Fortran subroutine named rz_2 to compute a 2x2 complex matrix based on a real*8 input value. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type complex*16.", "input": "", "output": "subroutine rz_2(r, psi)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: psi\n  ! locals\n  complex*16 :: i\n  i = (0,1)\n  r(1,1)=exp(psi/2.*i); r(1,2)=0.0;\n  r(2,1)=0.0;  r(2,2)=exp(-psi/2.*i)\nend subroutine rz_2\n"}, {"instruction": "Create a Fortran subroutine named \"ry_2\" to calculate a 2x2 complex matrix based on the input angle value. The subroutine should take 1 input parameter of type real*8 and 1 output parameter of type complex*16.", "input": "", "output": "subroutine ry_2(r, the)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: the\n  ! \n  r(1,1)=cos(the/2.); r(1,2)=sin(the/2.)\n  r(2,1)=-sin(the/2.); r(2,2)=cos(the/2.)\nend subroutine ry_2\n"}, {"instruction": "Write a Fortran subroutine named rx_2 to compute a 2x2 rotation matrix using the given angle phi. The input parameter is phi of type real*8. The output parameter is r, a 2x2 matrix of type complex*16.", "input": "", "output": "subroutine rx_2(r, phi)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: phi\n  ! locals\n  complex*16 :: i\n  i = (0,1)\n  r(1,1)=cos(phi/2.);  r(1,2)=sin(phi/2.)*i\n  r(2,1)=sin(phi/2.)*i; r(2,2)=cos(phi/2.)\nend subroutine rx_2\n"}, {"instruction": "Create a Fortran subroutine named angles_zyz2 to calculate three Euler angles (a1, a2, a3) based on a given 3x3 rotation matrix u. The input parameter is a real*8 array u(3,3), and the output parameters are real*8 variables a1, a2, and a3. Ensure that the subroutine generates proper rotations only and computes the Euler angles using the given rotation matrix.", "input": "", "output": "subroutine angles_zyz2(a1,a2,a3,u)\n  ! routine gets rotation matrix u -- (only proper rotations are allowed)\n  ! it returns three euler angles (a1,a2,a3), which generate rotation u by\n  ! u = rz(a3)*ry(a2)*rz(a1)\n  implicit none\n  real*8, intent(out):: a1,a2,a3\n  real*8, intent(in) :: u(3,3)\n  ! locals\n  real*8 :: sy\n  sy = sqrt(u(3,2)**2 + u(3,1)**2)\n  if (sy .gt. 1e-6) then\n    a1 = -atan2( u(3,2),  u(3,1));\n    a2 = -atan2( sy,      u(3,3));\n    a3 = -atan2( u(2,3), -u(1,3));\n else\n    a1 = -atan2(-u(2,1),  u(2,2));\n    a2 = -atan2( sy,      u(3,3));\n    a3 = 0.0;\n  endif\nend subroutine angles_zyz2\n"}, {"instruction": "Create a Fortran subroutine named angles_zyz that computes three Euler angles (a1, a2, a3) based on the given rotation matrix u. The number of input arguments is 1 with the test_data type ['real*8'], and the number of output arguments is 3 with the test_data type ['real*8', 'real*8', 'real*8']. The subroutine should handle proper rotations and generate the rotation matrix u using the Euler angles according to the equation: u = rz(a3)*ry(a2)*rz(a1).", "input": "", "output": "subroutine angles_zyz(a1,a2,a3,u)\n  ! routine gets rotation matrix u -- (only proper rotations are allowed)\n  ! it returns three euler angles (a1,a2,a3), which generate rotation u by\n  ! u = rz(a3)*ry(a2)*rz(a1)\n  implicit none\n  real*8, intent(out):: a1,a2,a3\n  real*8, intent(in) :: u(3,3)\n  ! locals\n  real*8 :: pi, sy\n  pi = acos(-1.0d0)\n  sy = sqrt(u(3,2)**2 +  u(3,1)**2)\n  if (sy .gt. 1e-6) then\n     a1 = pi-atan2( u(3,2), u(3,1))\n     a2 = atan2(sy,      u(3,3))\n     a3 = pi-atan2(u(2,3), -u(1,3))\n  else \n     a1 = pi-atan2(-u(2,1), u(2,2))\n     a2 = atan2(sy,      u(3,3))\n     a3 = pi\n  endif\nend subroutine angles_zyz\n"}, {"instruction": "Create a Fortran subroutine named table1_ to generate a subtraction table for the (i-1)'s row. The subroutine has 3 input parameters of type integer (ma, mb, mc) and 2 output parameters of type integer (n, num). The generated table is populated based on the values of the input parameters, and the size and content of the table vary depending on the combinations of input values.", "input": "", "output": "        subroutine table1_(ma,mb,mc,n,num)\n          ! get the subtration table for the (i-1)'s row.\n          implicit none\n          integer,intent(in)::ma,mb,mc\n          integer,intent(out)::n,num(:,:)\n          num(:,:)=0\n          if (ma/=0.and.mb/=0.and.mc/=0) then\n            n=4\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/0,1,0/)\n            num(:,3)=(/1,-1,1/)\n            num(:,4)=(/1,0,0/)\n          else if (ma/=0.and.mb/=0.and.mc==0) then\n            n=2\n            num(:,1)=(/0,1,0/)\n            num(:,2)=(/1,0,0/)\n          else if (ma/=0.and.mb==0.and.mc/=0) then\n            n=3\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/1,-1,1/)\n            num(:,3)=(/1,0,0/)\n          else if (ma==0.and.mb/=0.and.mc/=0) then\n            n=2\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/0,1,0/)\n          else if (ma/=0.and.mb==0.and.mc==0) then\n            n=1\n            num(:,1)=(/1,0,0/)\n          else if (ma==0.and.mb/=0.and.mc==0) then\n            n=1\n            num(:,1)=(/0,1,0/)\n          else if (ma==0.and.mb==0.and.mc/=0) then\n            n=1\n            num(:,1)=(/0,0,1/)\n          else\n            write(*,'(\"error: unclassified: ci.ndim_()\")')\n            stop 1\n          end if\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dday that takes one input parameter of type real and produces four output parameters of type real. The input parameter represents a year, and the subroutine computes the day of the week for January 1st of that year. The output parameters represent the values of c, r, anchor, and dd, which are intermediate values used in the computation.", "input": "", "output": "subroutine dday(yr, c, r, anchor, dd)\n  implicit none\n  real, intent(in)   :: yr  \n  real, intent(out)  :: c, r, dd, anchor\n\n  c = floor(yr / 100)\n  r = mod(c, 4.0)\n  anchor = 5 * mod(r, 7.0) + 2 ! 2? tuesday\n  dd = mod(floor(yr/12) + mod(yr, 12.0) + floor(mod(yr, 12.0) / 4), 7.0) + anchor\n\nend subroutine dday\n"}, {"instruction": "Create a Fortran subroutine named sym_gauss_seidel to solve a symmetric system of linear equations using the Gauss-Seidel method. The subroutine takes 7 input parameters: n (integer), nnz (integer), irows (integer array of dimension nnz), icols (integer array of dimension nnz), vals (real array of kind=8 and dimension nnz), b (real array of kind=8 and dimension n), n_iter (integer). It returns 1 output parameter: x (real array of kind=8 and dimension n).", "input": "", "output": "  subroutine sym_gauss_seidel(irows,icols,vals,b,n,nnz,x, n_iter)\n    integer, intent(in) :: n, nnz\n    integer, intent(in), dimension(nnz) :: irows, icols\n    real(kind=8), intent(in), dimension(nnz) :: vals\n    real(kind=8), intent(in), dimension(n) :: b\n    real(kind=8), intent(out), dimension(n) :: x\n    integer,intent(in) ::  n_iter\n    \n    integer :: i,k\n    real(kind=8) :: diag\n\n    x = 0.0\n    \n    do it=1,n_iter\n\n       ! forward iteration\n       k=1\n       do i=1,n\n          ! calculate x[i]\n          x(i) = b(i)\n          do while (k<=nnz .and. irows(k)==i)\n             j=icols(k) ! column index\n             if (i==j) then\n                diag = vals(k) ! diagonal\n             else\n                x(i) = x(i) - x(j)*vals(k)\n             end if\n             k = k+1\n          end do\n          x(i) = x(i) / diag\n       end do\n\n       ! backward iteration\n       k=nnz\n       do i=n,1,-1\n          ! calculate x[i]\n          x(i) = b(i)\n          do while (k>0 .and. irows(k)==i)\n             j=icols(k) ! column index\n             if (i==j) then\n                diag = vals(k) ! diagonal\n             else\n                x(i) = x(i) - x(j)*vals(k)\n             end if\n             k = k-1\n          end do\n          x(i) = x(i) / diag\n       end do\n\n    end do\n  \n  end subroutine sym_gauss_seidel\n"}, {"instruction": "Create a Fortran subroutine named split_ to split a string using a specified delimiter. The subroutine takes 3 input parameters of types character(len=1), character(len=*), and integer, and 2 output parameters of types character(len=*) and integer. The subroutine splits the input string based on the specified delimiter and returns the list of split strings along with the number of splits.", "input": "", "output": "    subroutine split_ ( tok, str, mlist, list, nlist )\n    implicit none\n    character(len=1), intent(in)  :: tok  ! delimitter\n    character(len=*), intent(in)  :: str  ! string\n    integer,          intent(in)  :: mlist\n    character(len=*), intent(out) :: list(mlist)\n    integer,          intent(out) :: nlist\n\n    integer i, l, n, j\n\n    i = 1\n    l = len_trim(str)\n    nlist = 0\n    do n = 1, mlist\n       j = index(trim(str(i:)),tok) - 1\n       if ( j < 1 ) then\n            nlist = nlist + 1\n            list(nlist) = str(i:)\n            exit\n       end if\n       nlist = nlist + 1\n       list(nlist) = str(i:i+j-1)\n       i = i + j + 1\n       if ( i > l ) then\n            exit\n       endif\n    end do\n\n    end subroutine split_\n"}, {"instruction": "Create a Fortran subroutine named cmp_datestr that compares two date strings in the format \"YYYYMMDDHHMMSS\" and sets the output integer parameter icmp based on the comparison result. The subroutine has 2 input parameters of type character (len=14) and 1 output parameter of type integer.", "input": "", "output": "subroutine cmp_datestr(date1, date2, icmp)\n\n   implicit none\n\n   ! arguments\n   character (len=14), intent(in) :: date1, date2\n   integer, intent(out) :: icmp\n\n   ! local variables\n   integer :: yyyy1, yyyy2\n   integer :: mm1, mm2\n   integer :: dd1, dd2\n   integer :: hh1, hh2\n   integer :: min1, min2\n   integer :: sec1, sec2\n\n   read(date1(1:4), '(i4)') yyyy1\n   read(date1(5:6), '(i2)') mm1\n   read(date1(7:8), '(i2)') dd1\n   read(date1(9:10), '(i2)') hh1\n   read(date1(11:12), '(i2)') min1\n   read(date1(13:14), '(i2)') sec1\n\n   read(date2(1:4), '(i4)') yyyy2\n   read(date2(5:6), '(i2)') mm2\n   read(date2(7:8), '(i2)') dd2\n   read(date2(9:10), '(i2)') hh2\n   read(date2(11:12), '(i2)') min2\n   read(date2(13:14), '(i2)') sec2\n\n   if (yyyy1 > yyyy2) then\n      icmp = 1\n      return\n   else if (yyyy1 < yyyy2) then\n      icmp = -1\n      return\n   end if\n\n   if (mm1 > mm2) then\n      icmp = 1\n      return\n   else if (mm1 < mm2) then\n      icmp = -1\n      return\n   end if\n\n   if (dd1 > dd2) then\n      icmp = 1\n      return\n   else if (dd1 < dd2) then\n      icmp = -1\n      return\n   end if\n\n   if (hh1 > hh2) then\n      icmp = 1\n      return\n   else if (hh1 < hh2) then\n      icmp = -1\n      return\n   end if\n\n   if (min1 > min2) then\n      icmp = 1\n      return\n   else if (min1 < min2) then\n      icmp = -1\n      return\n   end if\n\n   if (sec1 > sec2) then\n      icmp = 1\n      return\n   else if (sec1 < sec2) then\n      icmp = -1\n      return\n   end if\n\n   icmp = 0\n   return\n\nend subroutine cmp_datestr\n"}, {"instruction": "Write a Fortran subroutine named \"create_array\" to generate a 2D array of real(8) numbers based on the input integer \"n\". The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real(8), dimension(n,3)']. The subroutine calculates the sum of the row and column indices and assigns the result to the corresponding elements of the output array.", "input": "", "output": "subroutine create_array(a, n)\n    integer, intent(in) :: n\n    real(8), dimension(n,3), intent(out) :: a\n    do i = 1, n\n        do j = 1, n\n            a(i,j) = i+j\n        enddo\n    enddo\nend subroutine create_array\n"}, {"instruction": "Write a Fortran subroutine named n_tg to calculate the value of n using the provided formula. The subroutine should have 2 input parameters of type real representing t (in keV) and g, and 1 output parameter of type real representing n (in 1/cc). Use the imperative tone in your instructions.", "input": "", "output": "      subroutine n_tg(t, g, n)\n      implicit none        \n        real, intent(in)  :: t  ! kev\n        real, intent(in)  :: g  ! \n        real, intent(out) :: n  ! 1/cc\n        real, parameter   :: coeff=6.1216e-15\n        n=((g/coeff)**2)*(t**3) ! 1/cc\n      end subroutine n_tg\n"}, {"instruction": "Create a Fortran subroutine named n_tze that takes two input parameters of type real, labeled as t and ze, and one output parameter of type real, labeled as n. The subroutine calculates the value of n using the formula n = ze * (t ** 1.5) / coeff, where coeff is a predefined real parameter.", "input": "", "output": "      subroutine n_tze(t, ze, n)\n      implicit none        \n        real, intent(in)  :: t  ! kev\n        real, intent(in)  :: ze ! \n        real, intent(out) :: n  ! 1/cc\n        real, parameter   :: coeff=5.2359e-27\n        n=ze*(t**1.5)/coeff ! 1/cc\n      end subroutine n_tze\n"}, {"instruction": "Write a Fortran subroutine named eigv that calculates stable eigenvalues and eigenvectors based on the input parameters. The subroutine takes 2 input parameters of type integer and double precision, and returns 2 output parameters of type double precision.", "input": "", "output": "      subroutine eigv(ndim,par,v1,v2) \n!     ---------- ---- \n\n      implicit none\n      integer, intent(in) :: ndim\n      double precision, intent(in) :: par(*)\n      double precision, intent(out) :: v1(ndim),v2(ndim)\n      logical, save :: ifirst = .true.\n\n      double precision e,ss\n\n! stable eigenvalue/vector 1\n       v1(1)= 0.\n       v1(2)= 0.\n       v1(3)= 1./2.66667\n\n! stable eigenvalue/vector 2\n       e=-(11+sqrt(1201.d0))/2\n       v2(1)=1+e\n       v2(2)=par(1)\n       v2(3)= 0.\n       ss=sqrt(v2(1)**2+v2(2)**2)\n       v2(1)=v2(1)/(ss*22.8277)\n       v2(2)=v2(2)/(ss*22.8277)\n       if(ifirst)then\n         write(10,*)v2(1),v2(2)\n         ifirst=.false.\n       endif\n\n      end subroutine eigv\n"}, {"instruction": "Create a Fortran subroutine named str_to_int to convert a string to an integer. The subroutine takes 1 input parameter of type character (len=*), and 2 output parameters of type integer.", "input": "", "output": "        subroutine str_to_int(str, int, stat)\n            implicit none\n            ! arguments\n            character (len=*), intent(in) :: str\n            integer, intent(out)          :: int\n            integer, intent(out)          :: stat\n\n            read(str, *, iostat=stat) int\n        end subroutine str_to_int\n"}, {"instruction": "Create a Fortran subroutine named mxv that performs a matrix-vector multiplication. This subroutine takes 4 input parameters of types integer, integer, real*8, and real*8, and 1 output parameter of type real*8. The inputs correspond to the dimensions of the matrix, the matrix itself, and the vector. The output is the resulting vector after the multiplication.", "input": "", "output": "      subroutine mxv(m,n,aa,bb,cc)\n      implicit none\n      integer, intent(in) :: m,n\n      real*8, intent(in) :: aa(m,n),bb(n)\n      real*8, intent(out) :: cc(m)\n\n      integer :: i,j\n\n!$omp parallel default(shared) private(i,j)\n!$omp workshare\n      cc(:)=0\n!$omp end workshare\n\n!array reduction - each thread takes a chunk of j and do array sum (1:m)\n!$omp do reduction(+: cc)\n      do j=1,n\n!        do i=1,m\n        cc(1:m)=cc(1:m)+aa(1:m,j)*bb(j)\n!        enddo !i\n      enddo !j\n!$omp end parallel\n\n      end subroutine mxv\n"}, {"instruction": "Create a Fortran subroutine named split_n_tasks to divide a range of numbers into subranges for parallel processing. The subroutine takes 4 input parameters of type integer: n, iproc, nproc, and an optional llim. It also has 2 output parameters of type integer: lo and hi.\n\nThe subroutine splits the range of numbers represented by n into subranges for parallel tasks. The iproc parameter represents the rank of the current task, nproc is the total number of tasks, and llim is an optional lower limit. The subroutine calculates the lower (lo) and upper (hi) bounds of the subrange that the current task should process based on its rank and the total number of tasks. If llim is provided, it is used as the lower limit; otherwise, the default lower limit is 1.", "input": "", "output": "   subroutine split_n_tasks(n, iproc, nproc, lo, hi, llim)\n\n      implicit none\n\n      integer, intent(in) :: n, iproc, nproc\n      integer, intent(out) :: lo, hi\n      integer, optional, intent(in) :: llim\n\n      integer :: n_div, n_mod, llim_local\n\n      llim_local = 1\n      if (present(llim)) llim_local = llim\n\n      n_div = n / nproc\n      n_mod = mod(n, nproc)\n\n      lo = iproc * n_div + min(iproc, n_mod) + llim_local\n      hi = lo + n_div - 1\n      if (iproc < n_mod) hi = hi + 1\n\n   end subroutine split_n_tasks\n"}, {"instruction": "Create a Fortran subroutine named \"form\" to determine the format for displaying a real number. The subroutine should take 1 input argument of type real and provide 1 output argument of type character with allocatable length.", "input": "", "output": "  subroutine form(r, fmt)\n  implicit none\n  real, intent(in) :: r\n  character(len=:), intent(out), allocatable :: fmt\n  if ((r > 9999999 .or. r < -999999) .or. (abs(r) < 0.01)) then\n    fmt = \"es12.5\"\n  else\n    fmt = \"f12.4\"\n  end if\n  fmt = '('//fmt//')'\n  !99999999.9999\n\n  end subroutine form\n"}, {"instruction": "Create a Fortran subroutine named find_current_time that takes 5 input parameters of type integer (iunit, year, month, day, cbh_binary_flag) and 1 output parameter of type integer (iret). This subroutine reads input data from a file and compares it with the provided date values until a match is found. If the end of the file is reached, it prints an error message. If there is a reading error, it sets iret to the error code.", "input": "", "output": "      subroutine find_current_time(iunit, year, month, day, iret, cbh_binary_flag)\n! argument\n      integer, intent(in) :: iunit, year, month, day, cbh_binary_flag\n      integer, intent(out) :: iret\n! local variables\n      integer :: yr, mo, dy\n!***********************************************************************\n      iret = 0\n      do\n        if ( cbh_binary_flag==0 ) then\n          read ( iunit, *, iostat=iret ) yr, mo, dy\n        else\n          read ( iunit, iostat=iret ) yr, mo, dy\n        endif\n        if ( iret==-1 ) print *, 'error, end-of-file found reading input file for date:', year, month, day\n        if ( iret/=0 ) return\n        if ( yr==year .and. mo==month .and. dy==day ) exit\n      enddo\n      backspace iunit\n      end subroutine find_current_time\n"}, {"instruction": "Write a Fortran subroutine named find_current_file_time to find the current time of a file. The subroutine takes 4 input parameters of type integer (iunit, year, month, day) and returns 3 output parameters of type integer (year_file, month_file, day_file).", "input": "", "output": "      subroutine find_current_file_time(iunit, year, month, day, year_file, month_file, day_file)\n! argument\n      integer, intent(in) :: iunit, year, month, day\n      integer, intent(out) :: year_file, month_file, day_file\n! local variables\n      integer :: i, ios\n!***********************************************************************\n! find first value for simulation time period\n      read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n      if ( ios/=0 ) then\n        year_file = 0\n        month_file = 0\n        day_file = 0\n        return\n      endif\n      if ( year_file<year ) then\n        i = 0\n        do while ( i==0 )\n          read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n          if ( ios/=0 ) then\n            year_file = 0\n            month_file = 0\n            day_file = 0\n            return\n          endif\n          if ( year_file>=year ) i = 1\n        enddo\n      endif\n      if ( year_file==year ) then\n        if ( month_file<month ) then\n          i = 0\n          do while ( i==0 )\n            read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n            if ( ios/=0 ) then\n              year_file = 0\n              month_file = 0\n              day_file = 0\n              return\n            endif\n            if ( month_file>=month ) i = 1\n          enddo\n        endif\n        if ( month_file==month ) then\n          if ( day_file<day ) then\n            i = 0\n            do while ( i==0 )\n              read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n              if ( ios/=0 ) then\n                year_file = 0\n                month_file = 0\n                day_file = 0\n                return\n              endif\n              if ( day_file>=day ) i = 1\n            enddo\n          endif\n        endif\n      endif\n      backspace iunit\n      end subroutine find_current_file_time\n"}, {"instruction": "Create a Fortran subroutine named \"is_eof\" to check whether the end of a file has been reached. The subroutine should take 1 input parameter of type integer and provide 3 output parameters, all of type integer.", "input": "", "output": "      subroutine is_eof(iunit, next_yr, next_mo, next_day)\n      implicit none\n! arguments\n      integer, intent(in) :: iunit\n      integer, intent(out) :: next_yr, next_mo, next_day\n! local variables\n      integer :: ios, i\n      character(len=80) :: dum\n!*******************************************************************************\n      next_yr = 0\n      next_mo = 0\n      next_day = 0\n      i = 0\n      do while ( i==0 )\n        read ( iunit, '(a)', iostat=ios ) dum\n        if ( ios/=0 ) return\n        if ( dum(:2)/='//' ) i = 1\n      enddo\n      read ( dum, *, iostat=ios ) next_yr, next_mo, next_day\n      if ( ios/=0 ) then\n        next_yr = 0\n        next_mo = 0\n        next_day = 0\n      else\n        backspace iunit\n      endif\n      end subroutine is_eof\n"}, {"instruction": "Create a Fortran subroutine named atmosphere to calculate the properties of the 1976 standard atmosphere up to 86 km. The subroutine takes 1 input parameter of type real and returns 3 output parameters of type real to provide the density, pressure, and temperature at a given geometric altitude in kilometers.", "input": "", "output": "       subroutine atmosphere(alt, sigma, delta, theta)\n!   -------------------------------------------------------------------------\n! purpose - compute the properties of the 1976 standard atmosphere to 86 km.\n! author - ralph carmichael, public domain aeronautical software\n! note - if alt > 86, the values returned will not be correct, but they will\n!   not be too far removed from the correct values for density.\n!   the reference document does not use the terms pressure and temperature\n!   above 86 km.\n       implicit none\n!============================================================================\n!     a r g u m e n t s                                                     |\n!============================================================================\n       real,intent(in)::  alt  ! geometric altitude, km.\n       real,intent(out):: sigma! density/sea-level standard density\n       real,intent(out):: delta! pressure/sea-level standard pressure\n       real,intent(out):: theta! temperature/sea-level standard temperature\n!============================================================================\n!     l o c a l   c o n s t a n t s                                         |\n!============================================================================\n       real,parameter:: rearth = 6369.0 ! radius of the earth (km)\n       real,parameter:: gmr = 34.163195 ! gas constant\n       integer,parameter:: ntab=8! number of entries in the defining tables\n!============================================================================\n!     l o c a l   v a r i a b l e s                                         |\n!============================================================================\n       integer:: i,j,k    ! counters\n       real:: h           ! geopotential altitude (km)\n       real:: tgrad, tbase! temperature gradient and base temp of this layer\n       real:: tlocal      ! local temperature\n       real:: deltah      ! height above base of this layer\n!============================================================================\n!     l o c a l   a r r a y s   ( 1 9 7 6   s t d.  a t m o s p h e r e )   |\n!============================================================================\n       real,dimension(ntab),parameter:: htab= (/0.0, 11.0, 20.0, 32.0, 47.0, 51.0, 71.0,84.852/)\n       real,dimension(ntab),parameter:: ttab=  (/288.15, 216.65, 216.65, 228.65, 270.65, 270.65, 214.65, 186.946/)\n       real,dimension(ntab),parameter:: ptab=  (/1.0, 2.233611e-1, &\n5.403295e-2, 8.5666784e-3, 1.0945601e-3, 6.6063531e-4, 3.9046834e-5, 3.68501e-6/)\n       real,dimension(ntab),parameter:: gtab=  (/-6.5, 0.0, 1.0, 2.8, 0.0, -2.8, -2.0, 0.0/)\n!----------------------------------------------------------------------------\n       h=alt*rearth/(alt+rearth)! convert geometric to geopotential altitude\n\n       i=1\n       j=ntab                     ! setting up for=binary search\n       do\n       k=(i+j)/2                                             \n       if (h < htab(k)) then\n        j=k\n       else\n        i=k\n       end if\n       if (j <= i+1) exit\n       end do\n\n       tgrad=gtab(i)              ! i will be in 1...ntab-1\n       tbase=ttab(i)\n       deltah=h-htab(i)\n       tlocal=tbase+tgrad*deltah\n       theta=tlocal/ttab(1)            ! temperature ratio\n\n       if (tgrad == 0.0) then        ! pressure ratio\n         delta=ptab(i)*exp(-gmr*deltah/tbase)\n       else\n         delta=ptab(i)*(tbase/tlocal)**(gmr/tgrad)\n       end if\n\n       sigma=delta/theta            ! density ratio\n       return\n       end subroutine atmosphere \n"}, {"instruction": "Create a Fortran subroutine named acf to calculate the autocorrelation function of molecular dynamics simulation data. The subroutine takes 4 input parameters of type integer, integer, integer, and real(8), and 1 output parameter of type real(8). The input parameters correspond to the number of molecules, the number of time steps, the time step interval for computing the autocorrelation function, and the molecular dynamics simulation data. The output parameter stores the computed autocorrelation function values.", "input": "", "output": "subroutine acf(v_center,molecule,nstep,tau_step,vv_acf)\n    implicit none\n    integer,intent(in) ::molecule,nstep,tau_step\n    real(8),intent(in) ::v_center(molecule,3,nstep)\n    real(8),intent(out) ::vv_acf(tau_step,molecule)\n    integer ::it,it0,it0max,itau\n    real(8)::uacf(0:tau_step,molecule),nacf(0:tau_step,molecule)\n    integer ::i\n    uacf(:,:)=0.d0\n    nacf(:,:)=0.d0\n\n    do i=1,molecule\n        do it0=1,nstep\n            it0max=min(nstep,it0+tau_step)\n            do it=it0,it0max\n                itau=it-it0\n                uacf(itau,i)=uacf(itau,i)+dot_product(v_center(i,:,it0),v_center(i,:,it))\n                nacf(itau,i)=nacf(itau,i)+1d0\n            enddo\n        enddo\n    enddo\n\n    do i=1,molecule\n        do it=0,tau_step\n            vv_acf(it,i)=uacf(it,i)/nacf(it,i)\n        enddo\n    enddo\n    return\nend subroutine acf\n"}, {"instruction": "Create a Fortran subroutine named \"vol\" to calculate the variable \"psi\" based on the input parameters \"invc\" and \"matpar\". The subroutine should have 2 input parameters of type real*8, represented as \"invc(:)\" and \"matpar\", and 1 output parameter of type real*8, represented as \"psi\".", "input": "", "output": "subroutine vol(psi,invc,matpar)\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar\n\treal*8 :: c1,i3, j\n\tc1 = matpar ! kappa\n\n\tj = dsqrt(invc(3)) ! j\n\t\n\tpsi = c1*(j - 1.0d0)**2.0d0\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mooneyrivlin that computes the strain energy function psi based on the input parameters invc and matpar. The number of input arguments is 2 with the test_data type ['real*8 ', 'real*8 '], and the number of output arguments is 1 with the test_data type ['real*8 ']. Use the imperative tone to implement the subroutine.", "input": "", "output": "subroutine mooneyrivlin(psi,invc,matpar)\n !mooney rivlin bathe, k.j., finite element procedures, pp.592; see also 6.4 pp.561\n !crisfield m.a. vol ii, chap 13, pp 62. see also, section 10.3 pp 07 \n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(2)\n\treal*8 :: c1,c2,i1bar,i2bar,j,ri33\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\ti2bar = ri33*ri33*invc(2) ! i2bar\n\tpsi = c1*(i1bar-3.0d0) + c2*(i2bar-3.0d0)\n\treturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named fsub to compute the square of each element in the input array x and store the results in the output array f. The input parameter is an array of real numbers with kind=8 and variable size, while the output parameter is an array of real numbers with kind=8 and the same size as the input array.", "input": "", "output": "subroutine fsub(x,f)\n  ! compute f(x) = x**2 for all elements of the array x. \n  implicit none\n  real(kind=8), dimension(:), intent(in) :: x\n  real(kind=8), dimension(size(x)), intent(out) :: f\n  f = x**2\nend subroutine fsub\n"}, {"instruction": "Create a Fortran subroutine named harmonic_forces to calculate the forces and potential energy in a harmonic potential. The subroutine takes 4 input parameters of type real(8), real(8), real(8), dimension(2), real(8), dimension(2) and produces 3 output parameters of type real(8), dimension(2), real(8), dimension(2), real(8).", "input": "", "output": "subroutine harmonic_forces(k, r_eq, x, y, fx, fy, potential_energy)\n   implicit none\n   real(8), intent(in) :: k, r_eq\n   real(8), dimension(2), intent(in) :: x, y\n   real(8), dimension(2), intent(out) :: fx, fy\n   real(8), intent(out) :: potential_energy\n   real(8) :: r, delta_x, delta_y\n\n   delta_x = x(1) - x(2)\n   delta_y = y(1) - y(2)\n   r = delta_x**2 + delta_y**2\n   r = dsqrt(r)\n\n   fx(1) = - k * delta_x * (r - r_eq) / r\n   fx(2) = - fx(1)\n   fy(1) = - k * delta_y * (r - r_eq) / r\n   fy(2) = - fy(1)\n\n   potential_energy = 0.5d0 * k * (r - r_eq)**2\nend subroutine harmonic_forces\n"}, {"instruction": "Create a Fortran subroutine named identity_encryption that takes a raw password as input and outputs the password and its actual length. The input parameter is a character string with variable length, and the output parameters are two character strings with variable length and an integer, respectively.", "input": "", "output": "subroutine identity_encryption( raw_password, password, actual_length )\n    character(len=*), intent(in)  :: raw_password\n    character(len=*), intent(out) :: password\n    integer, intent(out)          :: actual_length\n\n    actual_length = len(raw_password)\n    password      = raw_password\n\nend subroutine identity_encryption\n"}, {"instruction": "Create a Fortran subroutine named default_encryption to perform a simple encryption technique on a given raw password. The subroutine will take 1 input argument of type character with variable length and provide 2 output arguments; one of type character with variable length and the other of type integer.", "input": "", "output": "subroutine default_encryption( raw_password, password, actual_length )\n    character(len=*), intent(in)  :: raw_password\n    character(len=*), intent(out) :: password\n    integer, intent(out)          :: actual_length\n\n    integer                       :: i\n    integer                       :: ch\n\n    actual_length = len(raw_password)\n    password      = ' '\n\n    !\n    ! use a rot13-like transformation\n    !\n    do i = 1,len(raw_password)\n        ch = iachar(raw_password(i:i))\n\n        if ( ch > 27 ) then\n            if ( ch < 128 ) then\n                ch = 155 - ch\n            else\n                ch = 383 - ch\n            endif\n        endif\n\n        password(i:i) = achar(ch)\n    enddo\nend subroutine default_encryption\n"}, {"instruction": "Write a Fortran subroutine named load_scale_values to read scale values from a file. The subroutine takes 2 input parameters of type ['character(len=*)', 'integer'], and 1 output parameter of type ['real(8)']. The subroutine reads scale values from the specified file based on the number of inputs and stores them in the scale_values array. Use the imperative tone in your instructions.", "input": "", "output": "subroutine load_scale_values(filename, num_inputs, scale_values)\n        character(len=*), intent(in) :: filename\n        integer, intent(in) :: num_inputs\n        real(8), intent(out) :: scale_values(num_inputs, 2)\n        character(len=40) :: row_name\n        integer :: isu, i\n        isu = 2\n        open(isu, file=filename, access=\"sequential\", form=\"formatted\")\n        read(isu, \"(a)\")\n        do i=1, num_inputs\n            read(isu, *) row_name, scale_values(i, 1), scale_values(i, 2)\n        end do\n        close(isu)\n    end subroutine load_scale_values\n"}, {"instruction": "Write a Fortran subroutine named br_newton to solve a nonlinear equation using the Newton-Raphson method. The subroutine takes 1 input parameter of type real(8) and provides 1 output parameter of type real(8).", "input": "", "output": "  subroutine br_newton(rhs,x_s)\n    implicit none\n    real(8),intent(in) :: rhs\n    real(8),intent(out) :: x_s\n    integer iter\n    real(8) :: xmin,xmax,x,fx,dfx\n\n  ! find xmax\n    xmin=0d0\n    x=1d0\n    do\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      if(fx < 0) then\n        xmax=x\n        exit\n      endif\n      x=x*2\n    enddo\n  ! bi-section\n    do\n      x=0.5d0*(xmin+xmax)\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      if(fx < 0) then\n        xmax=x\n      else\n        xmin=x\n      endif\n      if(xmax-xmin < 1d-4) exit\n    enddo\n  ! newton-raphson\n    do iter=1,5\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      dfx=(1-2d0/3d0*x)*exp(-2d0/3d0*x)/rhs-1d0\n      x=x-fx/dfx\n    enddo\n    x_s=x\n    return\n  end subroutine br_newton\n"}, {"instruction": "Create a Fortran subroutine named southwellbin to perform a Southwell reconstruction algorithm for wavefront sensing. The subroutine takes 8 input parameters of type integer and real*8, and 3 output parameters of type real*8. The input parameters include arrays for x, y, l, m, the dimensions xdim and ydim, and the binsize. The output parameters are arrays for xang, yang, and phase.\n\nThe subroutine implements parallel processing using OpenMP directives for efficient computation. The algorithm involves binning the input data and accumulating the values based on the bin location. It then normalizes the xang and yang arrays and sets invalid pixels to 100.\n\nOverall, the subroutine performs wavefront sensing reconstruction using the Southwell algorithm and is designed for high-performance parallel processing.", "input": "", "output": "subroutine southwellbin(x,y,l,m,num,binsize,xang,yang,phase,xdim,ydim)\n  !declarations\n  implicit none\n  integer, intent(in) :: num,xdim,ydim\n  real*8, intent(in) :: x(num),y(num),l(num),m(num),binsize\n  real*8, intent(out) :: xang(xdim,ydim),yang(xdim,ydim),phase(xdim,ydim)\n  integer :: i,j,xb,yb,accum(xdim,ydim)\n\n  !accum(:,:) = 0\n  do i=1,xdim\n    do j=1,ydim\n      accum(i,j) = 0\n    end do\n  end do\n\n  !loop through rays\n  !$omp parallel do private(xb,yb)\n  do i=1,num\n    !figure out proper bin\n    if (mod(xdim,2)==0) then\n      xb = floor(x(i)/binsize) + xdim/2 + 1 + 1\n    else\n      xb = floor((x(i)+binsize/2)/binsize) + (xdim-1)/2 + 1\n    end if\n    if (mod(ydim,2)==0) then\n      yb = floor(y(i)/binsize) + ydim/2 + 1 + 1\n    else\n      yb = floor((y(i)+binsize/2)/binsize) + (ydim-1)/2 + 1\n    end if\n    !add l and m to proper array\n    xang(xb,yb) = xang(xb,yb) + l(i)\n    yang(xb,yb) = yang(xb,yb) + m(i)\n    !accumulate total number of rays in wfs bin\n    accum(xb,yb) = accum(xb,yb) + 1\n  end do\n  !$omp end parallel do\n\n  !normalize xang and yang\n  !set invalid pixels to 100.\n  !$omp parallel do\n  do i=1,xdim\n    do j=1,ydim\n      if (accum(i,j)==0) then\n        phase(i,j) = 100.\n        xang(i,j) = 100.\n        yang(i,j) = 100.\n      else\n        xang(i,j) = tan(asin(xang(i,j)/accum(i,j)))\n        yang(i,j) = tan(asin(yang(i,j)/accum(i,j)))\n      end if\n    end do\n  end do\n  !$omp end parallel do\n\nend subroutine southwellbin\n"}, {"instruction": "Create a Fortran subroutine named \"bisectionsimple\" to perform a bisection search on an array. The subroutine takes 3 input parameters of type integer, real, and real, and 2 output parameters of type integer. The input parameters are ntheta, theta, and thetaarray, while the output parameters are ianglow and ianghi. This subroutine performs a binary search on the thetaarray to find the indices ianglow and ianghi that enclose the given value theta.", "input": "", "output": "subroutine bisectionsimple(theta,thetaarray,ntheta,ianglow, ianghi)\n\t\n\t\tinteger,intent(in)::ntheta\n\t\treal,intent(in)::theta,thetaarray(1:ntheta)\n\t\tinteger,intent(out)::ianglow, ianghi\n\t\n\t\tinteger:: iang\n\t\n\n\t\tianglow = 1\n\t\tianghi = ntheta\n\n\t\tdo\n\t\t\tif((ianghi - ianglow) == 1)exit\n\t\t\tiang = (ianghi + ianglow)/2\n\t\t\tif(thetaarray(iang) < theta)then\n\t\t\t\tianglow = iang\n\t\t\telse\n\t\t\t\tianghi = iang\n\t\t\tendif\n\t\tenddo\n\n\t\tif (ianglow < 1) ianglow = 1\n\t\tif (ianghi < 1) ianghi = 1\n\t\tif (ianghi > ntheta) ianghi = ntheta\n\t\tif (ianglow > ntheta) ianglow = ntheta\n\nend subroutine bisectionsimple\n"}, {"instruction": "Create a Fortran subroutine named calch20nablashape to calculate the natural coordinate derivatives of the shape functions. This subroutine takes 3 input parameters of type real (fxi, feta, fzeta) and 1 output parameter of type real (fads).", "input": "", "output": "subroutine calch20nablashape(fxi, feta, fzeta, fads)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fads(60)\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam\n\n! main routine\n\tfxip = (1d0 + fxi)\n\tfetap = (1d0 + feta)\n\tfzetap = (1d0 + fzeta)\n\tfxim = (1d0 - fxi)\n\tfetam = (1d0 - feta)\n\tfzetam = (1d0 - fzeta)\n\n! calculation of natural coordinate derivatives of the shape functions\n! corresponding to fxi\n\tfads(1) = 0.125d0 * fetam * fzetam * (2d0 * fxi + feta + fzeta + 1d0) \n\tfads(2) = 0.125d0 * fetam * fzetam * (2d0 * fxi - feta - fzeta - 1d0) \n\tfads(3) = 0.125d0 * fetap * fzetam * (2d0 * fxi + feta - fzeta - 1d0) \n\tfads(4) = 0.125d0 * fetap * fzetam * (2d0 * fxi - feta + fzeta + 1d0) \n\tfads(5) = 0.125d0 * fetam * fzetap * (2d0 * fxi + feta - fzeta + 1d0) \n\tfads(6) = 0.125d0 * fetam * fzetap * (2d0 * fxi - feta + fzeta - 1d0) \n\tfads(7) = 0.125d0 * fetap * fzetap * (2d0 * fxi + feta + fzeta - 1d0) \n\tfads(8) = 0.125d0 * fetap * fzetap * (2d0 * fxi - feta - fzeta + 1d0) \n\tfads(9) = -0.5d0 * fxi * fetam * fzetam\n\tfads(10) = 0.25d0 * fetam * fetap * fzetam \n\tfads(11) = -0.5d0 * fxi * fetap * fzetam \n\tfads(12) = -0.25d0 * fetam * fetap * fzetam \n\tfads(13) = -0.5d0 * fxi * fetam * fzetap \n\tfads(14) = 0.25d0 * fetam * fetap * fzetap \n\tfads(15) = -0.5d0 * fxi * fetap * fzetap \n\tfads(16) = -0.25d0 * fetam * fetap * fzetap \n\tfads(17) = -0.25d0 * fetam * fzetap * fzetam \n\tfads(18) = 0.25d0 * fetam * fzetap * fzetam\n\tfads(19) = 0.25d0 * fetap * fzetap * fzetam \n\tfads(20) = -0.25d0 * fetap * fzetap * fzetam\n\n! corresponding to feta\n\tfads(21) = 0.125d0 * fxim * fzetam * (fxi + 2d0 * feta + fzeta + 1d0) \n\tfads(22) = 0.125d0 * fxip * fzetam * (-fxi + 2d0 * feta + fzeta + 1d0) \n\tfads(23) = 0.125d0 * fxip * fzetam * (fxi + 2d0 * feta - fzeta - 1d0) \n\tfads(24) = 0.125d0 * fxim * fzetam * (-fxi + 2d0 * feta - fzeta - 1d0) \n\tfads(25) = 0.125d0 * fxim * fzetap * (fxi + 2d0 * feta - fzeta + 1d0) \n\tfads(26) = 0.125d0 * fxip * fzetap * (-fxi + 2d0 * feta - fzeta + 1d0) \n\tfads(27) = 0.125d0 * fxip * fzetap * (fxi + 2d0 * feta + fzeta - 1d0) \n\tfads(28) = 0.125d0 * fxim * fzetap * (-fxi + 2d0 * feta + fzeta - 1d0) \n\tfads(29) = -0.25d0 * fxip * fxim * fzetam\n\tfads(30) = -0.5d0 * fxip * feta * fzetam \n\tfads(31) = 0.25d0 * fxim * fxip * fzetam \n\tfads(32) = -0.5d0 * fxim * feta * fzetam \n\tfads(33) = -0.25d0 * fxip * fxim * fzetap \n\tfads(34) = -0.5d0 * feta * fxip * fzetap \n\tfads(35) = 0.25d0 * fxim * fxip * fzetap \n\tfads(36) = -0.5d0 * fxim * feta * fzetap \n\tfads(37) = -0.25d0 * fxim * fzetap * fzetam \n\tfads(38) = -0.25d0 * fxip * fzetap * fzetam \n\tfads(39) = 0.25d0 * fxip * fzetap * fzetam \n\tfads(40) = 0.25d0 * fxim * fzetap * fzetam\n\n! corresponding to fzeta\n\tfads(41) = 0.125d0 * fxim * fetam * (fxi + feta + 2d0 * fzeta + 1d0) \n\tfads(42) = 0.125d0 * fxip * fetam * (-fxi + feta + 2d0 * fzeta + 1d0) \n\tfads(43) = 0.125d0 * fxip * fetap * (-fxi - feta + 2d0 * fzeta + 1d0) \n\tfads(44) = 0.125d0 * fxim * fetap * (fxi - feta + 2d0 * fzeta + 1d0) \n\tfads(45) = 0.125d0 * fxim * fetam * (-fxi - feta + 2d0 * fzeta - 1d0) \n\tfads(46) = 0.125d0 * fxip * fetam * (fxi - feta + 2d0 * fzeta - 1d0) \n\tfads(47) = 0.125d0 * fxip * fetap * (fxi + feta + 2d0 * fzeta - 1d0) \n\tfads(48) = 0.125d0 * fxim * fetap * (-fxi + feta + 2d0 * fzeta - 1d0) \n\tfads(49) = -0.25d0 * fxip * fxim * fetam \n\tfads(50) = -0.25d0 * fxip * fetap * fetam \n\tfads(51) = -0.25d0 * fxim * fxip * fetap \n\tfads(52) = -0.25d0 * fxim * fetap * fetam\n\tfads(53) = 0.25d0 * fxip * fxim * fetam \n\tfads(54) = 0.25d0 * fxip * fetap * fetam \n\tfads(55) = 0.25d0 * fxim * fxip * fetap \n\tfads(56) = 0.25d0 * fxim * fetam * fetap \n\tfads(57) = -0.5d0 * fxim * fetam * fzeta \n\tfads(58) = -0.5d0 * fxip * fetam * fzeta \n\tfads(59) = -0.5d0 * fxip * fetap * fzeta \n\tfads(60) = -0.5d0 * fxim * fetap * fzeta\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20shape to calculate the 20 shape functions based on the input values fxi, feta, and fzeta, which are real numbers. The output will be stored in the array fas, which is also a real number array of size 20.", "input": "", "output": "subroutine calch20shape(fxi, feta, fzeta, fas)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fas(20)\n\treal, parameter :: fsqc125 = 0.5d0\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam, &\n\t\tfxi2, feta2, fzeta2\n\n! main routine\n\tfxip = (1d0 + fxi) * fsqc125\n\tfetap = (1d0 + feta) * fsqc125\n\tfzetap = (1d0 + fzeta) * fsqc125\n\tfxim = (1d0 - fxi) * fsqc125\n\tfetam = (1d0 - feta) * fsqc125\n\tfzetam = (1d0 - fzeta) * fsqc125\n\tfxi2 = (1d0 - fxi * fxi)\n\tfeta2 = (1d0 - feta * feta)\n\tfzeta2 = (1d0 - fzeta * fzeta)\n\n\tfas(1) = fxim * fetam * fzetam * (-fxi - feta - fzeta - 2d0)\n\tfas(2) = fxip * fetam * fzetam * (fxi - feta - fzeta - 2d0)\n\tfas(3) = fxip * fetap * fzetam * (fxi + feta - fzeta - 2d0)\n\tfas(4) = fxim * fetap * fzetam * (-fxi + feta - fzeta - 2d0)\n\tfas(5) = fxim * fetam * fzetap * (-fxi - feta + fzeta - 2d0)\n\tfas(6) = fxip * fetam * fzetap * (fxi - feta + fzeta - 2d0)\n\tfas(7) = fxip * fetap * fzetap * (fxi + feta + fzeta - 2d0)\n\tfas(8) = fxim * fetap * fzetap * (-fxi + feta + fzeta - 2d0)\n\tfas(9) = fxi2 * fetam * fzetam\n\tfas(10) = feta2 * fxip * fzetam\n\tfas(11) = fxi2 * fetap * fzetam\n\tfas(12) = feta2 * fxim * fzetam\n\tfas(13) = fxi2 * fetam * fzetap\n\tfas(14) = feta2 * fxip * fzetap\n\tfas(15) = fxi2 * fetap * fzetap\n\tfas(16) = feta2 * fxim * fzetap\n\tfas(17) = fzeta2 * fxim * fetam\n\tfas(18) = fzeta2 * fxip * fetam\n\tfas(19) = fzeta2 * fxip * fetap\n\tfas(20) = fzeta2 * fxim * fetap\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"calch20k\" that takes 4 input parameters of type integer, real, real, and real, and 1 output parameter of type real. The subroutine calculates the stiffness matrix based on the input parameters and updates the output parameter with the result.", "input": "", "output": "subroutine calch20k(iint, fae, fab, faweight, fak)\n  !dec$ attributes dllexport::calch20k\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fab(6, 60, iint ** 3), fae(6, 6, iint ** 3)\n\treal, intent(out) :: fak(1830)\n\treal :: faeb(6), fstiff\n\tinteger :: i, j, k, m, ks, ix, iy, iz\n\n! main routine \n! calculate stiffness matrix\n\tm = 0\n\tdo i = 1, 1830\n\t\tfak(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tks = 0\n\t\t\t\tdo i = 1, 60\n\t\t\t\t\tfaeb(1) = fae(1, 1, m) * fab(1, i, m) + fae(1, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(1, 3, m) * fab(3, i, m) + fae(1, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(1, 5, m) * fab(5, i, m) + fae(1, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(2) = fae(2, 1, m) * fab(1, i, m) + fae(2, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(2, 3, m) * fab(3, i, m) + fae(2, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(2, 5, m) * fab(5, i, m) + fae(2, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(3) = fae(3, 1, m) * fab(1, i, m) + fae(3, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(3, 3, m) * fab(3, i, m) + fae(3, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(3, 5, m) * fab(5, i, m) + fae(3, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(4) = fae(4, 1, m) * fab(1, i, m) + fae(4, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(4, 3, m) * fab(3, i, m) + fae(4, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(4, 5, m) * fab(5, i, m) + fae(4, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(5) = fae(5, 1, m) * fab(1, i, m) + fae(5, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(5, 3, m) * fab(3, i, m) + fae(5, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(5, 5, m) * fab(5, i, m) + fae(5, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(6) = fae(6, 1, m) * fab(1, i, m) + fae(6, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(6, 3, m) * fab(3, i, m) + fae(6, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(6, 5, m) * fab(5, i, m) + fae(6, 6, m) * fab(6, i, m)\n\t\t\t\t\tdo j = i, 60\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tfstiff = fab(1, j, m) * faeb(1) + fab(2, j, m) * faeb(2) + &\n\t\t\t\t\t\t\tfab(3, j, m) * faeb(3) + fab(4, j, m) * faeb(4) + &\n\t\t\t\t\t\t\tfab(5, j, m) * faeb(5) + fab(6, j, m) * faeb(6)\n\t\t\t\t\t\tfak(ks) = fak(ks) + fstiff * faweight(m)\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20strains that takes 3 input parameters of type integer, real array, and real array, and 1 output parameter of type real array. The subroutine calculates strains using matrix multiplication and stores the result in the output parameter.", "input": "", "output": "subroutine calch20strains(iint, fab, fau, fastrains)\n  !dec$ attributes dllexport::calch20strains\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: fab(6, 60, iint ** 3), fau(60)\n\treal, intent(out) :: fastrains(6, iint ** 3)\n\tinteger :: m\n\n! main routine \n\tdo m = 1, iint ** 3\n\t\tfastrains(:, m) = matmul(fab(:, :, m), fau)\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20stresses to calculate the stresses based on the strains and the elasticity matrix. The subroutine takes 3 input parameters of type integer, real, and real, and 1 output parameter of type real.", "input": "", "output": "subroutine calch20stresses(iint, fae, fastrains, fastresses)\n\timplicit none\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: fae(6, 6), fastrains(6, iint ** 3)\n\treal, intent(out) :: fastresses(6, iint ** 3)\n\tinteger :: m\n\n! main routine \n\tdo m = 1, iint ** 3\n\t\tfastresses(:, m) = matmul(fae, fastrains(:, m))\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20forces to calculate forces based on input data. The subroutine takes 4 input parameters of type integer, real, real, and real, and 1 output parameter of type real. The subroutine uses an iterative process to calculate the forces and stiffness matrix.", "input": "", "output": "subroutine calch20forces(iint, fab, faweight, fastresses, faforces)\n  !dec$ attributes dllexport::calch20forces\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fab(6, 60, iint ** 3), fastresses(6, iint ** 3)\n\treal, intent(out) :: faforces(60)\n\tinteger :: m, ix, iy, iz\n\n! main routine \n! calculate stiffness matrix\n\tm = 0\n\tdo ix = 1, 60\n\t\tfaforces(ix) = 0.\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n\t\t\t\tfaforces = faforces + faweight(m) * matmul(transpose(fab(:, :, m)), fastresses(:, m))\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named tv2t that takes two 3D arrays of real numbers, tv and qv, as input and calculates the array t as output. The number of input arguments is 2 and the test_data type is [real, real]. The number of output arguments is 1 and the test_data type is [real]. The subroutine uses the formula t=tv/(1.d0+zvir*qv) to perform the calculation.", "input": "", "output": "    subroutine tv2t (tv,qv,t)\n\n    real,intent(in) :: tv(:,:,:), qv(:,:,:)\n    real,intent(out) :: t(:,:,:)\n\n    t=tv/(1.d0+zvir*qv)\n\n    end subroutine tv2t\n"}, {"instruction": "Create a Fortran subroutine named \"t2tv\" that calculates the virtual temperature (tv) using the input temperature (t) and specific humidity (qv). The input parameters consist of two 3D arrays of real numbers, t(:,:,:) and qv(:,:,:), and the output parameter is a 3D array of real numbers, tv(:,:,:).", "input": "", "output": "    subroutine t2tv (t,qv,tv)\n\n    real,intent(in) :: t(:,:,:), qv(:,:,:)\n    real,intent(out) :: tv(:,:,:)\n\n    tv=t*(1.d0+zvir*qv)\n\n    end subroutine t2tv\n"}, {"instruction": "Write a Fortran subroutine named t2tv_tl to calculate the virtual potential temperature from temperature and water vapor mixing ratio. The subroutine takes 4 input arguments of type real, which are t, qv, t_tl, and qv_tl, and 1 output argument of type real, which is tv_tl.", "input": "", "output": "    subroutine t2tv_tl (t,qv,t_tl,qv_tl,tv_tl)\n\n    real,intent(in) :: t   (:,:,:), qv   (:,:,:)\n    real,intent(in) :: t_tl(:,:,:), qv_tl(:,:,:)\n    real,intent(out) :: tv_tl(:,:,:)\n\n    tv_tl=t_tl*(1.d0+zvir*qv)+zvir*t*qv_tl\n\n    end subroutine t2tv_tl\n"}, {"instruction": "Create a Fortran subroutine named t2tv_ad that takes 3 input parameters of type real (t, qv, tv_ad) and 1 output parameter of type real (t_ad). The subroutine computes the value of t_ad using the formula t_ad = tv_ad / (1.d0 + zvir * qv).", "input": "", "output": "    subroutine t2tv_ad (t,qv,tv_ad,t_ad)\n\n    real,intent(in) :: t    (:,:,:), qv(:,:,:)\n    real,intent(in) :: tv_ad(:,:,:)\n    real,intent(out) :: t_ad(:,:,:)\n\n    t_ad=tv_ad/(1.d0+zvir*qv)\n!   q_ad=tv_tl/(zvir*t)\n\n    end subroutine t2tv_ad\n"}, {"instruction": "Create a Fortran subroutine named fci to perform a financial calculation. The subroutine takes 6 input parameters: two integers (n, nrow), and four real numbers (ret, rf, sav, galfa). It produces 1 output parameter of type real (capinc).", "input": "", "output": "subroutine fci(sav,nrow,galfa,n,ret,rf,capinc)\nimplicit none\ninteger, intent(in) :: n, nrow\nreal, intent(in) :: ret, rf\nreal, intent(in) :: sav(nrow,1), galfa(n,1)\nreal, intent(out) :: capinc(nrow,n)\nreal, allocatable :: rp(:,:), ones(:,:)\ninteger :: ind1, ind2\nallocate (rp(n,1), ones(n,1))\nones=1.0\ndo ind1=1,nrow\n   rp = ret*galfa+rf*(ones-galfa)\n   do ind2=1,n\n      capinc(ind1,ind2) = sav(ind1,1)*rp(ind2,1)\n   end do\nend do\ndeallocate(rp,ones)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mpi_comm_create to create a new communicator from an existing group of processes. The subroutine should take 1 input argument of type integer and 3 output arguments of type integer. The input argument represents the existing communicator mpi_comm_world, and the output arguments represent the new communicator mpi_comm, the new group mpi_group, and the error status ierr.", "input": "", "output": "subroutine  mpi_comm_create(mpi_comm_world,mpi_group,mpi_comm,ierr)\n  implicit none\n  integer, intent(in) :: mpi_comm_world\n  integer, intent(out) :: mpi_group,mpi_comm,ierr\n  mpi_group=1\n  mpi_comm=1\n  ierr=mpi_comm_world*0\nend subroutine mpi_comm_create\n"}, {"instruction": "Write a Fortran subroutine named \"mpi_comm_get_attr\" that takes two integer input parameters and returns three output parameters. The input parameters are \"comm\" and \"comm_keyval\" of type integer. The output parameters are \"flag\" of type logical, \"attribute_val\" of type integer(kind=8), and \"ierr\" of type integer. The subroutine should calculate the value of \"attribute_val\" as 1, set \"ierr\" as the product of \"comm\" and \"comm_keyval\" multiplied by 0, and set \"flag\" as true if \"comm_keyval\" is equal to 1.", "input": "", "output": "subroutine  mpi_comm_get_attr(comm,comm_keyval,attribute_val,flag,ierr)\n  implicit none\n  integer, intent(in) :: comm, comm_keyval\n  logical, intent(out) :: flag\n  !integer(kind=mpi_address_kind), intent(out) :: attribute_val\n  integer(kind=8), intent(out) :: attribute_val\n  integer, intent(out) :: ierr\n  attribute_val=1\n  ierr=comm*comm_keyval*0\n  flag=(comm_keyval==1)\nend subroutine mpi_comm_get_attr\n"}, {"instruction": "Write a Fortran subroutine named mpi_comm_size that takes an integer input parameter mpi_comm_world and returns two output parameters nproc and ierr, both integers. The subroutine sets nproc to 1 and ierr to the result of mpi_comm_world multiplied by 0.", "input": "", "output": "subroutine  mpi_comm_size(mpi_comm_world,nproc,ierr)\n  implicit none\n  integer, intent(in) :: mpi_comm_world\n  integer, intent(out) :: nproc,ierr\n  nproc=1\n  ierr=mpi_comm_world*0\nend subroutine mpi_comm_size\n"}, {"instruction": "Write a Fortran subroutine named mpi_group_incl that takes 3 input parameters of type integer (group, n, nranks) and 2 output parameters of type integer (newgroup, ierr). The subroutine calculates the size of nranks and assigns it to newgroup, and sets ierr to the product of group and 0.", "input": "", "output": "subroutine  mpi_group_incl(group,n,nranks,newgroup,ierr)\n  implicit none\n  integer, intent(in) :: group,n\n  integer, intent(in) :: nranks(n)\n  integer, intent(out) :: newgroup,ierr\n  newgroup=size(nranks)\n  ierr=group*0\nend subroutine mpi_group_incl\n"}, {"instruction": "Create a Fortran subroutine named mpi_test with one input parameter of type integer and two output parameters of type integer. The input parameter is intent(in) and the output parameters are intent(out). The function sets the flag to 1 plus 0 times the input request and mpi_status to 1.", "input": "", "output": "subroutine mpi_test(request,flag,mpi_status)\n  implicit none\n  integer, intent(in) :: request\n  integer, intent(out) :: flag\n  integer, intent(out) :: mpi_status\n  flag = 1 + 0*request\n  mpi_status = 1\nend subroutine mpi_test\n"}, {"instruction": "Create a Fortran subroutine named mpi_wait that takes an integer input parameter request and returns an integer output parameter mpi_status. The subroutine sets the value of mpi_status to 1 added to 0 multiplied by the value of request.", "input": "", "output": "subroutine mpi_wait(request,mpi_status)\n  implicit none\n  integer, intent(in) :: request\n  integer, intent(out) :: mpi_status\n  mpi_status = 1 + 0*request\nend subroutine mpi_wait\n"}, {"instruction": "Write a Fortran subroutine named cube_mean that takes three real numbers as input and computes their mean after summing them and then multiplying the mean by 3. The number of input arguments is 3 with the test_data type of ['real', 'real', 'real'], and the number of output arguments is 1 with the test_data type of ['real'].", "input": "", "output": "subroutine  cube_mean(x, y, z, r) \n\treal, intent(in) :: x\n\treal, intent(in) :: y\n\treal, intent(in) :: z\n\treal, intent(out) :: r\n\n\tr=x+y+z\n\tr = r / (3)\n\tr = r * (3)\n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named integrate_trapz to perform trapezoidal integration. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The input parameters are f, x, and n, representing the function values, corresponding x-coordinates, and the number of data points, respectively. The output parameter res stores the result of the integration.", "input": "", "output": "subroutine integrate_trapz(res, f, x, n)\n  implicit none\n  real*8,  intent(out) :: res\n  real*8,  intent(in)  :: f(n), x(n)\n  integer, intent(in)  :: n\n  !\n  integer :: i\n  res = f(1)*0.5*(x(2)-x(1)) + f(n)*0.5*(x(n)-x(n-1))\n  do i=2,n-1\n     res = res + f(i)*0.5*(x(i+1)-x(i-1))\n  enddo\nend subroutine integrate_trapz\n"}, {"instruction": "Create a Fortran subroutine named setrotmat that sets up the forward rotation matrix and reverse matrix based on the given azimuth, dip, and tilt angles. The number of input arguments is 3, and their types are ['real(kind=8)', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 2, and their types are ['real(kind=8), dimension(3,3)', 'real(kind=8), dimension(3,3)'].", "input": "", "output": "  subroutine setrotmat(azm,dip,tilt,forwardrotmat,reverserotmat)\r\n!-----------------------------------------------------------------------\r\n!  \r\n!        sets up the forward rotation matrix and reverse matrix\r\n!\r\n! (c) jared deutsch, 2014\r\n!-----------------------------------------------------------------------\r\n  implicit none\r\n  real(kind=8), parameter :: pi = 4*atan(1.0d0)\r\n  real(kind=8), intent(in) :: azm,dip,tilt\r\n  real(kind=8), dimension(3,3) :: azmrotmat,diprotmat,tiltrotmat\r\n  real(kind=8), dimension(3,3), intent(out) :: forwardrotmat,reverserotmat\r\n  real(kind=8) :: angle\r\n\r\n! get the angle to rotate about the z axis in radians\r\n  angle = (90d0-azm)*pi/180d0\r\n! rotation matrix for azimuth correction\r\n  azmrotmat = 0d0\r\n  azmrotmat(3,3) = 1d0\r\n  azmrotmat(1,1) = cos(angle)\r\n  azmrotmat(1,2) = -1d0*sin(angle)\r\n  azmrotmat(2,1) = sin(angle)\r\n  azmrotmat(2,2) = cos(angle)\r\n\r\n! get the angle to rotate about the new x' axis\r\n  angle = -1d0*(dip)*pi/180d0\r\n! rotation matrix for dip correction\r\n  diprotmat = 0d0\r\n  diprotmat(2,2) = 1d0\r\n  diprotmat(1,1) = cos(angle)\r\n  diprotmat(1,3) = sin(angle)\r\n  diprotmat(3,1) = -1d0*sin(angle)\r\n  diprotmat(3,3) = cos(angle)\r\n\r\n! get the angle to rotate about the new y' axis\r\n  angle = -1d0*(tilt)*pi/180d0\r\n! rotation matrix for tilt correction\r\n  tiltrotmat = 0d0\r\n  tiltrotmat(1,1) = 1d0\r\n  tiltrotmat(2,2) = cos(angle)\r\n  tiltrotmat(2,3) = sin(angle)\r\n  tiltrotmat(3,2) = -1d0*sin(angle)\r\n  tiltrotmat(3,3) = cos(angle)\r\n\r\n! complete forward rotation matrix is the product of these 2 matrices\r\n  forwardrotmat = matmul(matmul(azmrotmat,diprotmat),tiltrotmat)\r\n! reverse rotation matrix is the transpose of the forward matrix\r\n! as these matrices are orthogonal\r\n  reverserotmat = transpose(forwardrotmat)\r\n  end subroutine setrotmat\r\n"}, {"instruction": "Create a Fortran subroutine named get_ind to calculate the index of an element in a multi-dimensional array based on its linear index and the size of each dimension. The subroutine takes 3 input parameters of type integer: i (linear index), n (array dimensions), and d (number of dimensions). It also has 1 output parameter of type integer: ind (array of indices).", "input": "", "output": "  subroutine get_ind(i,ind,n,d)\n    integer, intent(in) :: d\n\n    integer, intent(in) :: n(d)\n    integer, intent(out) :: ind(d)\n    integer, intent(in) :: i\n    integer j\n    j = i\n    do k=1,d\n       !print *,'inside get_ind loop,j=',j\n       !print *,'inside get_ind loop,n=',n\n       ind(k) = mod(j-1,n(k))+1\n       j=(j-ind(k))/n(k)+1\n    end do\n   !print *,'get_ind called, i=',i\n   !print *,'get_ind called, d=',d\n   !print *,'get_ind called, ind=',ind\n\n  end subroutine get_ind\n"}, {"instruction": "Create a Fortran subroutine named \"trussquang\" to calculate the value of \"psi\" based on the input parameters \"i4\" and \"matpar\". The input parameters should be of type real*8, and \"i4\" is an input while \"matpar\" is an array of real*8. The output parameter \"psi\" should also be of type real*8.", "input": "", "output": "subroutine trussquang(psi,i4,matpar) ! see javier bonet\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: i4, matpar(:) ! matpar is only the material coeficient, a0 was splitted\n\treal*8 :: e\n\te = matpar(1) !\n\t\t\t\n\tpsi = (e/8.0d0)*(i4-1.0d0)**2.0d0 \n\t\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named mandelbrot_set to calculate the Mandelbrot set. The subroutine takes 4 input parameters of type integer, integer, complex array of dimension(n, n), and another complex array of dimension(n, n). It also has 1 output parameter of type complex array of dimension(n, n). The subroutine uses the imperative tone to iterate through the calculations to generate the Mandelbrot set.", "input": "", "output": "    subroutine mandelbrot_set(z, c, n, n_iter, z_f)\n        implicit none\n        integer, intent(in) :: n, n_iter\n        complex, intent(in), dimension(n, n) :: z, c\n        complex, intent(out), dimension(n, n) :: z_f\n        integer :: i\n        z_f = z\n        do i=1, n_iter\n            z_f = z_f**2 + c\n        end do\n    end subroutine mandelbrot_set\n"}, {"instruction": "Create a Fortran subroutine named d2_trans to transpose a double precision 2D array. The function takes one input parameter of type double precision and produces one output parameter of type double precision. The subroutine transposes the input array and stores the result in the output array.", "input": "", "output": " subroutine d2_trans(a,b)\n  implicit none\n  double precision,intent(in) :: a(:,:)\n  double precision,intent(out):: b(:,:)\n  character(len=*),parameter :: subnam='d2_trans'\n  integer :: i,j, m,n\n  m=size(a,1); n=size(a,2)\n  if(size(b,1).ne.n .or. size(b,2).ne.m)then\n   write(*,*)subnam,': size mismatch: a[',shape(a),'] b[',shape(b),']'\n   stop\n  end if\n  if(m.gt.n)then\n!$omp parallel do shared(a,b)\n   do j=1,n\n    b(j,:)=a(:,j)\n   end do\n!$omp end parallel do\n  else\n!$omp parallel do shared(a,b)\n   do i=1,m\n    b(:,i)=a(i,:)\n   end do\n!$omp end parallel do\n  end if\n  return\n end subroutine\n"}, {"instruction": "Create a Fortran subroutine named extrema_get to obtain extrema information from a module. The subroutine takes 2 input parameters of type integer. It returns 5 output parameters: real arrays of kind=8 with dimensions ndim by npeak and ndim by npeak, a real array of kind=8 with dimension npeak, and two integer arrays, each with dimension npeak. The subroutine copies the extrema information from module variables mod_peaks, mod_eigvect, mod_eigvals, mod_peak_type, and mod_index to the respective output parameters.", "input": "", "output": "  subroutine extrema_get(ndim, npeak, index, peakpos, eigvectors, eigvalues, peaktype)\n    integer, intent(in) :: ndim, npeak\n    real(kind=8), intent(out), dimension(ndim, npeak) :: peakpos\n    real(kind=8), intent(out), dimension(ndim, npeak) :: eigvectors\n    real(kind=8), intent(out), dimension(npeak)       :: eigvalues\n    integer, intent(out), dimension(npeak)        :: peaktype, index\n\n    peakpos    = mod_peaks\n    eigvectors = mod_eigvect\n    eigvalues  = mod_eigvals\n    peaktype   = mod_peak_type\n    index      = mod_index\n\n  end subroutine extrema_get\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_jacobian\" to compute the Jacobian in advective form based on the Arakawa method. The subroutine should have 6 input parameters of type integer, integer, real, real, real arrays, and a real 2D array, and 1 output parameter of a real 2D array.", "input": "", "output": "subroutine arakawa_jacobian(im, jm, dx, dy, a_bc, b_bc, jacobian)\n\n! computes jacobian j(a,b) in advective form\n! see arakawa (1966) j. comp. phys. vol 1, 119-143\n! ** note: input fields must be \"framed\" with boundary conds.\n!          jacobian computed in internal points only.\n\nimplicit none\n\ninteger, intent(in)                           :: im, jm\nreal,    intent(in)                           :: dx, dy\nreal,    intent(in), dimension(0:im+1,0:jm+1) :: a_bc,b_bc\n\nreal, intent(out), dimension(im,jm) :: jacobian\n\n! local variables:\ninteger :: i,j\nreal, dimension(im,jm) :: p1,p2,p3,p4,p5,p6,p7,p8\nreal, dimension(im,jm) :: q1,q2,q3,q4,q5,q6,q7,q8\n\n!   6 --- 2 --- 5\n!   |     |     |\n!   |     |     |\n!   3 --- 0 --- 1\n!   |     |     |\n!   |     |     |\n!   7 --- 4 --- 8\n\ni= 1 ; j= 0 ; p1 = a_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j= 1 ; p2 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 0 ; p3 = a_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j=-1 ; p4 = a_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j= 1 ; p5 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 1 ; p6 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j=-1 ; p7 = a_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j=-1 ; p8 = a_bc(1+i:im+i,1+j:jm+j)\n\ni= 1 ; j= 0 ; q1 = b_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j= 1 ; q2 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 0 ; q3 = b_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j=-1 ; q4 = b_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j= 1 ; q5 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 1 ; q6 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j=-1 ; q7 = b_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j=-1 ; q8 = b_bc(1+i:im+i,1+j:jm+j)\n\njacobian = (p1-p3)*(q2-q4) - (p2-p4)*(q1-q3)  +                & ! j++\n           q2*(p5-p6) - q4*(p8-p7) - q1*(p5-p8) + q3*(p6-p7) + & ! jx+\n           p1*(q5-q8) - p3*(q6-q7) - p2*(q5-q6) + p4*(q8-q7)     ! j+x\n\njacobian = jacobian/12./dx/dy\n\nend subroutine arakawa_jacobian\n"}, {"instruction": "Create a Fortran subroutine named v2vcosphii that takes in 4 input parameters: two integers (jm and km), and two arrays of real numbers of dimensions jm by km (cosphi and v). It outputs a single array of real numbers of dimensions 0 to jm by km (vcosphii). The subroutine interpolates the product of v and cosphi onto cell boundaries and assigns the result to vcosphii.", "input": "", "output": "subroutine v2vcosphii(jm, km, cosphi, v, vcosphii)\n\n! \nimplicit none\n\n! in\ninteger, intent(in)                 :: jm,km\nreal, intent(in),  dimension(jm,km) :: cosphi,v\n\n! out\nreal, intent(out), dimension(0:jm,km) :: vcosphii\n\n! local\ninteger :: j\n\n! interpolate vcosphi onto cell boundaries \nvcosphii=0.\ndo j=1,jm-1\n  vcosphii(j,:) = ( v(j,:)*cosphi(j,:) + v(j+1,:)*cosphi(j+1,:) )/2.\nenddo\n\nend subroutine v2vcosphii\n"}, {"instruction": "Write a Fortran subroutine named vcosphii2wi that calculates the vertical velocity component 'wi' based on the input parameters. The subroutine takes 7 input parameters of types integer, real, and real arrays of various dimensions, and returns 1 output parameter of type real array.", "input": "", "output": "subroutine vcosphii2wi(jm, km, a, dphi, dp, cosphi, vcosphii, wi)\n\n! \nimplicit none\n\n! in\ninteger, intent(in)                  :: jm,km\nreal, intent(in)                     :: a,dphi,dp\nreal, intent(in), dimension(jm,km)   :: cosphi\nreal, intent(in), dimension(0:jm,km) :: vcosphii\n\n! out\nreal, intent(out), dimension(jm,0:km) :: wi\n\n! local\ninteger :: j,k\nreal :: rdy\nreal, dimension(jm,km)      :: vcosphi_y\n\nrdy=1./dphi/a\n\n! integrate continuity eqn from top down to get w\nvcosphi_y = ( vcosphii(1:jm,:) - vcosphii(0:jm-1,:) )/cosphi*rdy\nwi=0.\ndo k=1,km-1\n  wi(:,k) = wi(:,k-1) - vcosphi_y(:,k)*dp   \nenddo\n\nend subroutine vcosphii2wi\n"}, {"instruction": "Create a Fortran subroutine named \"setfemtype\" to determine the finite element type based on the given femtype input parameter. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer. The output parameters are nodg, porder, ngp, isimplex, and ibubble. The main purpose of this subroutine is to set the values of these 5 parameters based on the input femtype.", "input": "", "output": "\tsubroutine setfemtype(femtype,nodg,porder,ngp,isimplex,ibubble)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg,porder,ngp,isimplex,ibubble\n\t\t\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tngp = 4\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(3) !! quadratic triangle with 3 gauss points\n\t\t\t\tngp = 3\n\t\t\t\tnodg = 6\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\n\t\t\tcase(4) !! quadratic quadrangle with 9 gauss points\n\t\t\t\tngp = 16\n\t\t\t\tnodg = 9\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\t\n\n\t\t\tcase(5) !! linear line with 1 gauss points\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 2\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(6) !! linear tetrahedra\n\t\t\t\tngp = 4 !! just 1 or 3\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(7) !! point\n\t\t\t\tngp = 1 !! just 1 or 3\n\t\t\t\tnodg = 1\n\t\t\t\tporder = 0\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(8) !! quadratic line with 2 gauss points\n\t\t\t\tngp = 2\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\t\t\n\tend subroutine \n"}, {"instruction": "Subroutine ohc_merid_adv is a Fortran subroutine that calculates the meridional advection at a specific latitude. The subroutine takes 7 input parameters of types integer and real arrays and produces 3 output parameters of type real arrays.\n\nThe input parameters include imin, imax, lat, dxt, temp, vvel, and dzt. The output parameters are adv, adv_i, and adv_k. The adv parameter stores the meridional advection at each grid point, adv_i stores the zonal-integrated meridional advection, and adv_k stores the depth-integrated meridional advection.\n\nThe subroutine calculates the meridional advection based on the temperature, vertical velocity, and grid information using nested do-loops and array operations.\n\nEnsure that the input and output parameters are correctly assigned before and after calling the subroutine ohc_merid_adv.", "input": "", "output": "subroutine ohc_merid_adv(imin,imax,lat,temp,vvel,dzt,dxt,adv,adv_k,adv_i)\n! merdional advection at latitude lat\n! northward flux through northern face of t-cell(i,lat)\n! adv       in [j/m^2/s]\n! adv_k/i   in [j/m/s]\n\ninteger                                         :: i,k\ninteger,                            intent(in)  :: imin,imax,lat\ninteger, parameter                              :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt),        intent(in)  :: dxt\nreal,    dimension(imt,jmt,km),     intent(in)  :: temp, vvel, dzt\nreal,    dimension(imax-imin+1,km), intent(out) :: adv\nreal,    dimension(km),             intent(out) :: adv_i ! zonal-int\nreal,    dimension(imax-imin+1),    intent(out) :: adv_k ! depth-int\nreal,    parameter                              :: rho0=4.1/3.996*1000, c=3996.0\n\ndo k=1,km\n  do i=imin,imax\n    adv(i-imin+1,k) = (temp(i,lat+1,k)-temp(i,lat,k))                          &\n                    * (vvel(i-1,lat,k)+vvel(i,lat,k))/2                        &  \n                    * rho0 * c\n  enddo !i\nenddo !k\n\nadv_k(:) = 0.0\ndo k=1,km\n  adv_k(:) = adv_k(:) +  adv(:,k)*dzt(imin:imax,lat,k)\nenddo !k\n\nadv_i(:) = 0.0\ndo i=imin,imax\n  adv_i(:) = adv_i(:) + adv(i-imin+1,:)*dxt(i,lat)\nenddo !i\n\nend subroutine ohc_merid_adv\n"}, {"instruction": "Write a Fortran subroutine named io_error_message to handle error messages. It takes 2 input parameters of type character(*) and integer, and 1 output parameter of type character(*).", "input": "", "output": "  subroutine io_error_message(routine,ierr,str)\n\n    !use mpi\n\n    implicit none\n\n    character(*),intent(in) :: routine\n    integer,intent(in) :: ierr\n    character(*),intent(out) :: str\n\n    !select case(ierr)\n    !case(mpi_err_io)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_io'\n    !case(mpi_err_no_space)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_no_space'\n    !case(mpi_err_no_such_file)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_no_such_file'\n    !case default\n    write(str,'(a,i6)') 'problem with ' // trim(routine) // ': ierr=',ierr\n    !end select\n\n  end subroutine io_error_message\n"}, {"instruction": "Create a Fortran subroutine named foo2 that takes an integer input and returns a character string of length equal to the input integer. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 1, and the test_data type is ['character(len=*)'].", "input": "", "output": "subroutine foo2(s, n)\n  character(len=*), intent(out) :: s\n  integer, intent(in) :: n\n  !f2py character(f2py_len=n), depend(n) :: s\n  s = \"123456789a123456789b\"(1:n)\nend subroutine foo2\n"}, {"instruction": "Write a Fortran subroutine named \"ff\" to define the nonlinear term. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and 1 output parameter of type double precision.", "input": "", "output": "      subroutine ff(ne,u,par,f) \n!     ---------- -- \n!     define the nonlinear term\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(in) :: u(ne),par(*)\n      double precision, intent(out) :: f(ne)\n\n      double precision x,y,a,b\n\n        x=u(1)\n        y=u(2)\n        a=par(1)\n        b=par(2)\n\n        f(1)= x**2*y - (b+1)*x + a\n        f(2)=-x**2*y + b*x\n\n      end subroutine ff\n"}, {"instruction": "Create a Fortran subroutine named setdc. This subroutine sets the diffusion constants based on the input parameters. It takes 2 input parameters of type integer and double precision, and 1 output parameter of type double precision.", "input": "", "output": "      subroutine setdc(ne,dc,par) \n!     ---------- ----- \n!     set the diffusion constants (constant, or in terms of par)\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(out) :: dc(ne)\n      double precision, intent(in) :: par(*)\n\n        dc(1)=par(3)/par(5)**2\n        dc(2)=par(4)/par(5)**2\n\n      end subroutine setdc\n"}, {"instruction": "Create a Fortran subroutine named setbc which sets the boundary values to be fixed in time. The subroutine takes 2 input parameters of type integer and double precision, and 2 output parameters of type double precision.", "input": "", "output": "      subroutine setbc(ne,par,u0,u1) \n!     ---------- ----- \n! set the boundary values (to be kept fixed in time)\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(in) :: par(*)\n      double precision, intent(out) :: u0(ne),u1(ne)\n\n      double precision a,b\n\n        a=par(1)\n        b=par(2)\n\n        u0(1)=a\n        u0(2)=b/a\n        u1(1)=a\n        u1(2)=b/a\n\n\n      end subroutine setbc\n"}, {"instruction": "Create a Fortran subroutine named solve_leqs to solve a system of linear equations represented by a matrix. The subroutine takes 2 input parameters: an integer n and a real(kind(1d0)),dimension(n,n) array 'a'. It produces 2 output parameters: a real(kind(1d0)),dimension(n) array 'sol' and a logical 'triv'.", "input": "", "output": "  subroutine solve_leqs(n,a,sol,triv)\n    ! solve the linear equations ax=0\n    ! return a minimal solution,i.e.,in x the number of nonzero element is samllest but not 0\n    implicit none\n    integer,intent(in)::n\n    real(kind(1d0)),dimension(n,n),intent(in)::a\n    real(kind(1d0)),dimension(n,n)::b\n    integer,dimension(n)::iexchange\n    integer::i,j,inow,k,iswap,izero\n    real(kind(1d0)),parameter::eps=1d-10\n    real(kind(1d0)),dimension(n),intent(out)::sol\n    real(kind(1d0)),dimension(n)::row,coloum\n    real(kind(1d0))::maxv,temp\n    logical,intent(out)::triv\n    logical::allzero\n    ! make matrix a to be upper triangular\n    b(1:n,1:n)=a(1:n,1:n)\n    maxv=maxval(abs(b(1:n,1:n)))\n    if(maxv.lt.eps)then\n       ! a trivial solution\n       sol(1)=1d0\n       sol(2:n)=0d0\n       triv=.false.\n       return\n    endif\n    do i=1,n\n       iexchange(i)=i\n    enddo\n    inow=1\n    izero=0\n    do i=1,n\n       allzero=.true.\n       do j=inow,n\n          if(abs(b(j,inow))/maxv.gt.eps)then\n             allzero=.false.\n             if(j.ne.inow)then\n                row(1:n)=b(inow,1:n)\n                b(inow,1:n)=b(j,1:n)\n                b(j,1:n)=row(1:n)\n             endif\n             exit\n          endif\n       enddo\n       if(.not.allzero)then\n          do j=inow+1,n\n             if(inow+1.le.n)then\n                b(j,inow+1:n)=b(j,inow+1:n)-b(inow,inow+1:n)*b(j,inow)/b(inow,inow)\n             endif\n             b(j,inow)=0d0\n          enddo\n          inow=inow+1\n       else\n          ! the coloum is zero, put it to the end\n          coloum(1:n)=b(1:n,inow)\n          izero=izero+1\n          iswap=iexchange(n)\n          iexchange(n)=iexchange(inow)\n          do j=inow+1,n\n             b(1:n,j-1)=b(1:n,j)\n             if(j.ne.n)then\n                iexchange(j-1)=iexchange(j)\n             else\n                iexchange(j-1)=iswap\n             endif\n          enddo\n          b(1:n,n)=coloum(1:n)\n       endif\n!       print *,i\n!       do j=1,n\n!          write(*,*)b(j,1:n)\n!       enddo\n    enddo\n!    do i=1,n\n!       write(*,*)b(i,1:n)\n!    enddo\n!    write(*,*)\"================\"\n    if(izero.gt.0)then\n       sol(iexchange(n))=1d0\n       do inow=1,n-1\n          i=n-inow\n          if(abs(b(i,i))/maxv.lt.eps)then\n             sol(iexchange(i))=0d0\n          else\n             temp=0d0\n             do j=i+1,n\n                temp=temp-b(i,j)*sol(iexchange(j))\n             enddo\n             sol(iexchange(i))=temp/b(i,i)\n          endif\n       enddo\n       triv=.false.\n    else\n       sol(1:n)=0d0\n       triv=.true.\n    endif\n    return\n  end subroutine solve_leqs\n"}, {"instruction": "Write a Fortran subroutine named solve_cleqs to solve a system of complex linear equations of the form ax=0 and return a minimal solution. The subroutine takes 2 input parameters: an integer n and a complex array a of dimension (n, n). It also has 2 output parameters: a complex array sol of dimension (n) and a logical triv.\n", "input": "", "output": "  subroutine solve_cleqs(n,a,sol,triv)\n    ! solve the complex linear equations ax=0\n    ! return a minimal solution,i.e.,in x the number of nonzero element is samllest but not 0\n    implicit none\n    integer,intent(in)::n\n    complex(kind(1d0)),dimension(n,n),intent(in)::a\n    complex(kind(1d0)),dimension(n,n)::b\n    integer,dimension(n)::iexchange\n    integer::i,j,inow,k,iswap,izero\n    real(kind(1d0)),parameter::eps=1d-10\n    complex(kind(1d0)),dimension(n),intent(out)::sol\n    complex(kind(1d0)),dimension(n)::row,coloum\n    real(kind(1d0))::maxv\n    complex(kind(1d0))::temp\n    logical,intent(out)::triv\n    logical::allzero\n    ! make matrix a to be upper triangular\n    b(1:n,1:n)=a(1:n,1:n)\n    maxv=maxval(abs(b(1:n,1:n)))\n    if(maxv.lt.eps)then\n       ! a trivial solution\n       sol(1)=dcmplx(1d0)\n       sol(2:n)=dcmplx(0d0)\n       triv=.false.\n       return\n    endif\n    do i=1,n\n       iexchange(i)=i\n    enddo\n    inow=1\n    izero=0\n    do i=1,n\n       allzero=.true.\n       do j=inow,n\n          if(abs(b(j,inow))/maxv.gt.eps)then\n             allzero=.false.\n             if(j.ne.inow)then\n                row(1:n)=b(inow,1:n)\n                b(inow,1:n)=b(j,1:n)\n                b(j,1:n)=row(1:n)\n             endif\n             exit\n          endif\n       enddo\n       if(.not.allzero)then\n          do j=inow+1,n\n             if(inow+1.le.n)then\n                b(j,inow+1:n)=b(j,inow+1:n)-b(inow,inow+1:n)*b(j,inow)/b(inow,inow)\n             endif\n             b(j,inow)=0d0\n          enddo\n          inow=inow+1\n       else\n          ! the coloum is zero, put it to the end\n          coloum(1:n)=b(1:n,inow)\n          izero=izero+1\n          iswap=iexchange(n)\n          iexchange(n)=iexchange(inow)\n          do j=inow+1,n\n             b(1:n,j-1)=b(1:n,j)\n             if(j.ne.n)then\n                iexchange(j-1)=iexchange(j)\n             else\n                iexchange(j-1)=iswap\n             endif\n          enddo\n          b(1:n,n)=coloum(1:n)\n       endif\n    enddo\n    if(izero.gt.0)then\n       sol(iexchange(n))=dcmplx(1d0)\n       do inow=1,n-1\n          i=n-inow\n          if(abs(b(i,i))/maxv.lt.eps)then\n             sol(iexchange(i))=dcmplx(0d0)\n          else\n             temp=dcmplx(0d0)\n             do j=i+1,n\n                temp=temp-b(i,j)*sol(iexchange(j))\n             enddo\n             sol(iexchange(i))=temp/b(i,i)\n          endif\n       enddo\n       triv=.false.\n    else\n       sol(1:n)=dcmplx(0d0)\n       triv=.true.\n    endif\n    return\n  end subroutine solve_cleqs\n"}, {"instruction": "Create a Fortran subroutine named getl1ptr which takes in an input parameter of type logical, dimension(:), pointer and returns an output parameter of type integer(kind=8).", "input": "", "output": "     subroutine getl1ptr(array,iadd)\n       implicit none\n       logical, dimension(:), pointer, intent(in) :: array\n       integer(kind=8), intent(out) :: iadd\n     end subroutine getl1ptr\n"}, {"instruction": "Write a Fortran subroutine named sszipfmt that takes a character string 'fmt' as input and produces a modified format string 'fmt1' as output. The input parameter 'fmt' has the test_data type ['character(*)'], and the output parameter 'fmt1' has the test_data type ['character(*)']. Use the imperative tone in the instructions.", "input": "", "output": "  pure subroutine sszipfmt(fmt, fmt1)\n    ! set fmt1 to '(ss,'//removeblanks(fmt)//')'. caller is responsible that\n    ! fmt1 has sufficient length.\n    character(*), intent(in) :: fmt\n    character(*), intent(out) :: fmt1\n    integer i,j\n    fmt1 = '(ss,'\n    j = 5\n    do i = 1,len(fmt)\n      if (fmt(i:i) /= ' ') then\n        fmt1(j:j) = fmt(i:i)\n        j = j+1\n      endif\n    enddo\n    fmt1(j:j) = ')'\n  end subroutine sszipfmt\n"}, {"instruction": "Create a Fortran subroutine named gen_pat that generates a sparsity pattern from row storage. It takes 3 input parameters of type integer, named order, rp, and ci, and 1 output parameter of type logical named pattern. The subroutine should be called using the imperative tone.", "input": "", "output": "      subroutine gen_pat( order, pattern, rp, ci )\n!----------------------------------------------------------------\n!\t... generate sparsity pattern from row storage\n!----------------------------------------------------------------\n\n      implicit none\n!----------------------------------------------------------------\n!\t... dummy args\n!----------------------------------------------------------------\n      integer, intent(in) :: order\n      integer, intent(in) :: rp(order+1)\n      integer, intent(in) :: ci(*)\n      logical, intent(out) :: pattern(order,order)\n\n!----------------------------------------------------------------\n!\t... local variables\n!----------------------------------------------------------------\n      integer :: i, row\n\n      pattern = .false.\n      do i = 1,order\n\t do row = rp(i),rp(i+1)-1\n\t    pattern(i,ci(row)) = .true.\n\t end do\n      end do\n\n      end subroutine gen_pat\n"}, {"instruction": "Create a Fortran subroutine named \"znot_m_v1\" to calculate the roughness scale for momentum based on the reference level wind. The subroutine takes 1 input parameter of type real and produces 1 output parameter of type real.", "input": "", "output": "  subroutine znot_m_v1(uref,znotm)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znotm(meter):   roughness scale for momentum\n! author      :  biju thomas on 02/07/2014\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm\n    real             :: bs0, bs1, bs2, bs3, bs4, bs5, bs6\n    real             :: cf0, cf1, cf2, cf3, cf4, cf5, cf6\n\n\n    bs0 = -8.367276172397277e-12\n    bs1 = 1.7398510865876079e-09\n    bs2 = -1.331896578363359e-07\n    bs3 = 4.507055294438727e-06\n    bs4 = -6.508676881906914e-05\n    bs5 = 0.00044745137674732834\n    bs6 = -0.0010745704660847233\n\n    cf0 = 2.1151080765239772e-13\n    cf1 = -3.2260663894433345e-11\n    cf2 = -3.329705958751961e-10\n    cf3 = 1.7648562021709124e-07\n    cf4 = 7.107636825694182e-06\n    cf5 = -0.0013914681964973246\n    cf6 = 0.0406766967657759\n\n\n    if ( uref .le. 5.0 ) then\n      znotm = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    elseif (uref .gt. 5.0 .and. uref .lt. 10.0) then\n      znotm =.00000235*(uref**2 - 25 ) + 3.805129199617346e-05\n    elseif ( uref .ge. 10.0  .and. uref .lt. 60.0) then\n      znotm = bs6 + bs5*uref + bs4*uref**2 + bs3*uref**3 + bs2*uref**4 +  &\n              bs1*uref**5 + bs0*uref**6\n    else\n      znotm = cf6 + cf5*uref + cf4*uref**2 + cf3*uref**3 + cf2*uref**4 +  &\n              cf1*uref**5 + cf0*uref**6\n\n    end if\n\n  end subroutine znot_m_v1\n"}, {"instruction": "Create a Fortran subroutine named znot_m_v0 to calculate the roughness scale for momentum based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_m_v0(uref,znotm)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znotm(meter):   roughness scale for momentum\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm \n    real             :: yz, y1, y2, y3, y4\n\n    yz =  0.0001344\n    y1 =  3.015e-05\n    y2 =  1.517e-06\n    y3 = -3.567e-08\n    y4 =  2.046e-10\n\n    if ( uref .lt. 12.5 ) then\n       znotm  = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    else if ( uref .ge. 12.5 .and. uref .lt. 30.0 ) then\n       znotm = (0.0739793 * uref -0.58)/1000.0\n    else\n       znotm = yz + uref*y1 + uref**2*y2 + uref**3*y3 + uref**4*y4\n    end if\n\n  end subroutine znot_m_v0\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v1 to calculate the roughness scale for temperature/moisture based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_t_v1(uref,znott)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znott(meter):   roughness scale for temperature/moisture\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znott\n    real             :: to0, to1, to2, to3\n    real             :: tr0, tr1, tr2, tr3\n    real             :: tn0, tn1, tn2, tn3, tn4, tn5\n    real             :: ta0, ta1, ta2, ta3, ta4, ta5, ta6\n    real             :: tt0, tt1, tt2, tt3, tt4, tt5, tt6, tt7\n\n\n    tr0 = 6.451939325286488e-08\n    tr1 = -7.306388137342143e-07\n    tr2 = -1.3709065148333262e-05\n    tr3 = 0.00019109962089098182\n\n    to0 = 1.4379320027061375e-08\n    to1 = -2.0674525898850674e-07\n    to2 = -6.8950970846611e-06\n    to3 = 0.00012199648268521026\n\n    tn0 = 1.4023940955902878e-10\n    tn1 = -1.4752557214976321e-08\n    tn2 = 5.90998487691812e-07\n    tn3 = -1.0920804077770066e-05\n    tn4 = 8.898205876940546e-05\n    tn5 = -0.00021123340439418298\n\n    tt0 = 1.92409564131838e-12\n    tt1 = -5.765467086754962e-10\n    tt2 = 7.276979099726975e-08\n    tt3 = -5.002261599293387e-06\n    tt4 = 0.00020220445539973736\n    tt5 = -0.0048088230565883\n    tt6 = 0.0623468551971189\n    tt7 = -0.34019193746967424\n\n    ta0 = -1.7787470700719361e-10\n    ta1 = 4.4691736529848764e-08\n    ta2 = -3.0261975348463414e-06\n    ta3 = -0.00011680322286017206\n    ta4 = 0.024449377821884846\n    ta5 = -1.1228628619105638\n    ta6 = 17.358026773905973\n\n    if ( uref .le. 7.0 ) then\n      znott = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    elseif ( uref  .ge. 7.0 .and. uref .lt. 12.5 ) then\n      znott =  tr3 + tr2*uref + tr1*uref**2 + tr0*uref**3\n    elseif ( uref  .ge. 12.5 .and. uref .lt. 15.0 ) then\n      znott =  to3 + to2*uref + to1*uref**2 + to0*uref**3\n    elseif ( uref .ge. 15.0  .and. uref .lt. 30.0) then\n      znott =  tn5 + tn4*uref + tn3*uref**2 + tn2*uref**3 + tn1*uref**4 +   &\n                                                       tn0*uref**5\n    elseif ( uref .ge. 30.0  .and. uref .lt. 60.0) then\n      znott = tt7 + tt6*uref + tt5*uref**2  + tt4*uref**3 + tt3*uref**4 +   &\n             tt2*uref**5 + tt1*uref**6 + tt0*uref**7\n    else\n      znott =  ta6 + ta5*uref + ta4*uref**2  + ta3*uref**3 + ta2*uref**4 +  &\n              ta1*uref**5 + ta0*uref**6\n    end if\n\n  end subroutine znot_t_v1\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v0 to calculate the roughness scale for temperature/moisture based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_t_v0(uref,znott)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znott(meter):   roughness scale for temperature/moisture\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znott \n\n    if ( uref .lt. 7.0 ) then\n       znott = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    else\n       znott = (0.2375*exp(-0.5250*uref) + 0.0025*exp(-0.0211*uref))*0.01\n    end if\n\n  end subroutine znot_t_v0\n"}, {"instruction": "Create a Fortran subroutine named \"znot_t_v2\" to calculate the value of \"znott\" based on the input \"uu\". The input parameter is a real number, and the output parameter is also a real number. The subroutine uses coefficients to compute \"znott\" based on the value of \"uu\". The computation involves conditional statements to assign the appropriate value to \"znott\" based on the range of \"uu\". Make sure to incorporate the provided coefficients and ensure the correct handling of different ranges of \"uu\".", "input": "", "output": "  subroutine znot_t_v2(uu,znott)\n  implicit none\n\n! uu in mks\n! znott in m\n! biju thomas on 02/12/2015\n!\n\n    real, intent(in) :: uu\n    real, intent(out):: znott\n    real             :: ta0, ta1, ta2, ta3, ta4, ta5, ta6\n    real             :: tb0, tb1, tb2, tb3, tb4, tb5, tb6\n    real             :: tt0, tt1, tt2, tt3, tt4, tt5, tt6\n\n    ta0 = 2.51715926619e-09\n    ta1 = -1.66917514012e-07\n    ta2 = 4.57345863551e-06\n    ta3 = -6.64883696932e-05\n    ta4 = 0.00054390175125\n    ta5 = -0.00239645231325\n    ta6 = 0.00453024927761\n\n\n    tb0 = -1.72935914649e-14\n    tb1 = 2.50587455802e-12\n    tb2 = -7.90109676541e-11\n    tb3 = -4.40976353607e-09\n    tb4 = 3.68968179733e-07\n    tb5 = -9.43728336756e-06\n    tb6 = 8.90731312383e-05\n\n    tt0 = 4.68042680888e-14\n    tt1 = -1.98125754931e-11\n    tt2 = 3.41357133496e-09\n    tt3 = -3.05130605309e-07\n    tt4 = 1.48243563819e-05\n    tt5 = -0.000367207751936\n    tt6 = 0.00357204479347\n\n    if ( uu .le. 7.0 ) then\n       znott = (0.0185 / 9.8*(7.59e-4*uu**2+2.46e-2*uu)**2)\n    elseif ( uu  .ge. 7.0 .and. uu .lt. 15. ) then\n       znott = ta6 + ta5*uu + ta4*uu**2  + ta3*uu**3 + ta2*uu**4 +     &\n               ta1*uu**5 + ta0*uu**6\n    elseif ( uu .ge. 15.0  .and. uu .lt. 60.0) then\n       znott = tb6 + tb5*uu + tb4*uu**2 + tb3*uu**3 + tb2*uu**4 +      & \n               tb1*uu**5 + tb0*uu**6\n    else\n       znott = tt6 + tt5*uu + tt4*uu**2  + tt3*uu**3 + tt2*uu**4 +    &\n               tt1*uu**5 + tt0*uu**6\n    end if\n\n  end subroutine znot_t_v2\n"}, {"instruction": "Create a Fortran subroutine named znot_m_v6 to calculate the aerodynamical roughness over water with the input of 10-m wind speed. The number of input parameters is 1 with the test_data type ['real'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "  subroutine znot_m_v6(uref,znotm)\n  implicit none\n! calculate areodynamical roughness over water with input 10-m wind\n! for low-to-moderate winds, try to match the cd-u10 relationship from coare v3.5 (edson et al. 2013)\n! for high winds, try to fit available observational data\n!\n! bin liu, noaa/ncep/emc 2017\n! \n! uref(m/s)   :   wind speed at 10-m height\n! znotm(meter):   areodynamical roughness scale over water\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm\n    real             :: p13, p12, p11, p10\n    real             :: p25, p24, p23, p22, p21, p20\n    real             :: p35, p34, p33, p32, p31, p30\n    real             :: p40\n\n    p13 = -1.296521881682694e-02\n    p12 =  2.855780863283819e-01\n    p11 = -1.597898515251717e+00\n    p10 = -8.396975715683501e+00\n\n    p25 =  3.790846746036765e-10\n    p24 =  3.281964357650687e-09\n    p23 =  1.962282433562894e-07\n    p22 = -1.240239171056262e-06\n    p21 =  1.739759082358234e-07\n    p20 =  2.147264020369413e-05\n\n    p35 =  1.840430200185075e-07\n    p34 = -2.793849676757154e-05\n    p33 =  1.735308193700643e-03\n    p32 = -6.139315534216305e-02\n    p31 =  1.255457892775006e+00\n    p30 = -1.663993561652530e+01\n\n    p40 =  4.579369142033410e-04\n\n    if (uref >= 0.0 .and.  uref <= 6.5 ) then\n      znotm = exp( p10 + p11*uref + p12*uref**2 + p13*uref**3)\n    elseif (uref > 6.5 .and. uref <= 15.7) then\n      znotm = p25*uref**5 + p24*uref**4 + p23*uref**3 + p22*uref**2 + p21*uref + p20\n    elseif (uref > 15.7 .and. uref <= 53.0) then\n      znotm = exp( p35*uref**5 + p34*uref**4 + p33*uref**3 + p32*uref**2 + p31*uref + p30 )\n    elseif ( uref > 53.0) then\n      znotm = p40\n    else\n      print*, 'wrong input uref value:',uref\n    endif\n\n  end subroutine znot_m_v6\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v6 to calculate the scalar roughness over water with the input of 10-meter wind speed. The subroutine accepts 1 input parameter of type real and outputs 1 parameter of type real.", "input": "", "output": "  subroutine znot_t_v6(uref,znott)\n  implicit none\n! calculate scalar roughness over water with input 10-m wind\n! for low-to-moderate winds, try to match the ck-u10 relationship from coare algorithm\n! for high winds, try to retain the ck-u10 relationship of fy2015 hwrf\n!\n! bin liu, noaa/ncep/emc 2017\n!\n! uref(m/s)   :   wind speed at 10-m height\n! znott(meter):   scalar roughness scale over water\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znott\n\n    real             :: p00\n    real             :: p15, p14, p13, p12, p11, p10\n    real             :: p25, p24, p23, p22, p21, p20\n    real             :: p35, p34, p33, p32, p31, p30\n    real             :: p45, p44, p43, p42, p41, p40\n    real             :: p56, p55, p54, p53, p52, p51, p50\n    real             :: p60\n\n    p00 =  1.100000000000000e-04\n\n    p15 = -9.144581627678278e-10\n    p14 =  7.020346616456421e-08\n    p13 = -2.155602086883837e-06\n    p12 =  3.333848806567684e-05\n    p11 = -2.628501274963990e-04\n    p10 =  8.634221567969181e-04\n\n    p25 = -8.654513012535990e-12\n    p24 =  1.232380050058077e-09\n    p23 = -6.837922749505057e-08\n    p22 =  1.871407733439947e-06\n    p21 = -2.552246987137160e-05\n    p20 =  1.428968311457630e-04\n\n    p35 =  3.207515102100162e-12\n    p34 = -2.945761895342535e-10\n    p33 =  8.788972147364181e-09\n    p32 = -3.814457439412957e-08\n    p31 = -2.448983648874671e-06\n    p30 =  3.436721779020359e-05\n\n    p45 = -3.530687797132211e-11\n    p44 =  3.939867958963747e-09\n    p43 = -1.227668406985956e-08\n    p42 = -1.367469811838390e-05\n    p41 =  5.988240863928883e-04\n    p40 = -7.746288511324971e-03\n\n    p56 = -1.187982453329086e-13\n    p55 =  4.801984186231693e-11\n    p54 = -8.049200462388188e-09\n    p53 =  7.169872601310186e-07\n    p52 = -3.581694433758150e-05\n    p51 =  9.503919224192534e-04\n    p50 = -1.036679430885215e-02\n\n    p60 =  4.751256171799112e-05\n\n    if (uref >= 0.0 .and. uref < 5.9 ) then\n      znott = p00\n    elseif (uref >= 5.9 .and. uref <= 15.4) then\n      znott = p15*uref**5 + p14*uref**4 + p13*uref**3 + p12*uref**2 + p11*uref + p10\n    elseif (uref > 15.4 .and. uref <= 21.6) then\n      znott = p25*uref**5 + p24*uref**4 + p23*uref**3 + p22*uref**2 + p21*uref + p20\n    elseif (uref > 21.6 .and. uref <= 42.2) then\n      znott = p35*uref**5 + p34*uref**4 + p33*uref**3 + p32*uref**2 + p31*uref + p30\n    elseif ( uref > 42.2 .and. uref <= 53.3) then\n      znott = p45*uref**5 + p44*uref**4 + p43*uref**3 + p42*uref**2 + p41*uref + p40\n    elseif ( uref > 53.3 .and. uref <= 80.0) then\n      znott = p56*uref**6 + p55*uref**5 + p54*uref**4 + p53*uref**3 + p52*uref**2 + p51*uref + p50\n    elseif ( uref > 80.0) then\n      znott = p60\n    else\n      print*, 'wrong input uref value:',uref\n    endif\n\n  end subroutine znot_t_v6\n"}, {"instruction": "Create a Fortran subroutine named get_sat_info to extract information from an observation name. The subroutine takes 1 input parameter of type character(len=*), and returns 4 output parameters of type integer, integer, integer, and integer (optional). The subroutine uses the imperative tone to retrieve the platform, satellite ID, sensor ID, and channel index from the input observation name.", "input": "", "output": "subroutine get_sat_info(ob_name,platform_id,satellite_id,sensor_id,ichan)\n\n   implicit none\n\n   character(len=*),  intent(in)  :: ob_name\n   integer,           intent(out) :: platform_id, satellite_id, sensor_id\n   integer, optional, intent(out) :: ichan\n   character(len=5)               :: platform, sensor\n   integer                        :: strlen, dashloc1, dashloc2, dashloc3\n\n   strlen = len_trim(ob_name)\n\n   ! retrieve platform name\n   dashloc1 = index(ob_name,\"-\")\n   platform = ob_name(1:dashloc1-1)\n   select case (platform)\n   case ('noaa')\n      platform_id = 1\n   case ('eos')\n      platform_id = 9\n   case ('dmsp')\n      platform_id = 2\n   case ('metop')\n      platform_id = 10\n   case default\n      write(0,*)' unrecognized platform ',platform\n      stop\n   end select\n\n   ! retrieve satellite id\n   dashloc2 = index(ob_name(dashloc1+1:strlen),\"-\")\n   read(ob_name(dashloc1+1:dashloc1+dashloc2-1),'(i3)') satellite_id\n\n   ! retrieve sensor name\n   if ( present(ichan) ) then\n      dashloc3 = index(ob_name,\"-\",.true.)\n      sensor = ob_name(dashloc1+dashloc2+1:dashloc3-1)\n   else\n      sensor = ob_name(dashloc1+dashloc2+1:)\n   end if\n   select case (sensor)\n   case ('amsua')\n      sensor_id = 3\n   case ('amsub')\n      sensor_id = 4\n   case ('mhs')\n      sensor_id = 15\n   case ('airs')\n      sensor_id = 11\n   case ('ssmis')\n      sensor_id = 10\n   case default\n      write(0,*)' unrecognized sensor ',sensor\n      stop\n   end select\n\n   if ( present(ichan) ) then\n      ! retrieve channel index\n      read(ob_name(dashloc3+1:),'(i4)') ichan\n   end if\n\nend subroutine get_sat_info\n"}, {"instruction": "Create a Fortran subroutine named findmaxinarray to find the maximum sum of consecutive elements in a real(8) array. The subroutine takes 1 input parameter of type real(8) array and returns 3 output parameters of type integer(4), integer(4), and real(8).", "input": "", "output": "     subroutine findmaxinarray(a, ans, up, down)\n     implicit none\n     \n     real(8), intent(in), dimension(:) :: a\n     integer(4), intent(out) :: up, down\n     real(8), intent(out) :: ans\n     real(8) :: cur, sum, min_sum\n     integer(4) :: min_pos, i\n\n     ans = a(1)\n     up = 1\n     down = 1\n     sum = 0d0\n     min_sum = 0d0\n     min_pos = 0\n\n     do i = 1, size(a)\n               \n          sum = sum + a(i)\n          cur = sum - min_sum\n                    \n          if (cur .gt. ans) then\n               \n               ans = cur\n               up = min_pos + 1\n               down = i\n                \n          endif\n         \n          if (sum .lt. min_sum) then\n                    \n               min_sum = sum\n               min_pos = i\n                    \n          endif\n\n     enddo\n\n     end subroutine findmaxinarray\n"}, {"instruction": "Create a Fortran subroutine named get_counts_2d to calculate the number of points in each cell of a 2D grid. The subroutine takes 6 input parameters of types integer, integer, integer, real, real, real, and returns 1 output parameter of type real.", "input": "", "output": "subroutine get_counts_2d(x, y, dx, length, length_of_grid, length_of_points, counts)\n    ! gets the density and average parameter in a cell.\n    !\n    ! parameters\n    ! ----------\n    ! x, y : array\n    !    the positions of points.\n    ! dx : float\n    !    the size of each cell in each axis.\n    ! length : int\n    !    the length along a single axis of the grid.\n    ! length_of_points : int\n    !    length of the x and y coordinates.\n    ! length_of_grid : int\n    !    length of the x and y grid.\n    !\n    ! returns\n    ! -------\n    ! counts : array\n    !    the number of points in each cell.\n\n    implicit none\n\n    integer, intent(in) :: length, length_of_points, length_of_grid\n    real, intent(in) :: x(length_of_points), y(length_of_points), dx\n    real, intent(out) :: counts(length_of_grid)\n\n    integer :: i, x_index, y_index, index\n\n    do i = 1, length_of_grid\n        counts(i) = 0.\n    end do\n\n\n    do i = 1, length_of_points\n        x_index = floor(x(i) / dx)\n        y_index = floor(y(i) / dx)\n        if (x_index .eq. length) then\n            x_index = x_index - 1\n        end if\n        if (y_index .eq. length) then\n            y_index = y_index - 1\n        end if\n        index = length * x_index + y_index + 1\n        counts(index) = counts(index) + 1.\n    end do\n\nend subroutine get_counts_2d\n"}, {"instruction": "Write a Fortran subroutine named \"emc\" that calculates the equilibrium moisture content (EMC) based on temperature and relative humidity. The subroutine takes two input parameters, \"tempfh\" of type real and \"rh\" of type real, representing the temperature in Fahrenheit and relative humidity in percentage, respectively. It also has one output parameter, \"remc\" of type real, which stores the calculated EMC value.\n\nInside the subroutine, the EMC is calculated based on different conditions. If the relative humidity is less than 10%, the EMC is computed using the formula remc = 0.03229 + 0.281073 * rh - 0.000578 * tempfh * rh. If the relative humidity is between 10% and 50%, the EMC is calculated with the formula remc = 2.22749 + 0.160107 * rh - 0.014784 * tempfh. And if the relative humidity is greater than 50%, the EMC is determined using the formula remc = 21.0606 + 0.005565 * rh^2 - 0.00035 * rh * tempfh - 0.483199 * rh.\n\nEnsure that the subroutine is declared using the \"subroutine\" keyword and specify the input and output parameters accordingly.", "input": "", "output": "subroutine emc(tempfh, rh, remc)\n    real, intent(in)  :: tempfh  !< temperature [fahrenheit]\n    real, intent(in)  :: rh      !< relative humidity [%]\n    real, intent(out) :: remc\n\n  if ( rh .lt. 10) then\n     remc=0.03229+0.281073*rh-0.000578*tempfh*rh\n  else if ( rh .lt. 50) then\n     remc=2.22749+0.160107*rh-0.014784*tempfh\n  else\n     remc=21.0606+0.005565*rh**2-0.00035*rh*tempfh-0.483199*rh\n  endif\nend subroutine emc\n"}, {"instruction": "Create a Fortran subroutine named \"kwet\" that computes the \"rkwet\" factor based on the given moisture content and increment values. The subroutine takes two input parameters, both of type real, namely \"mc1000\" and \"increment\". It also has one output parameter, of type real, named \"rkwet\". \n\nThe purpose of this subroutine is to calculate the \"rkwet\" factor, which depends on the slow evolving moisture content. If the \"mc1000\" value is greater than 25, the \"rkwet\" factor is set to 1.0. If the \"mc1000\" value is between 10 and 25, the \"rkwet\" factor is calculated using the formula (0.0333 * mc1000 + 0.1675). If the \"mc1000\" value is less than or equal to 10, the \"rkwet\" factor is set to 0.5.\n\nAfter calculating the \"rkwet\" factor based on the \"mc1000\" value, the subroutine checks if the increment in moisture content is negative. If it is, the \"rkwet\" factor is overwritten and set to 1.0.\n\nThis subroutine follows the features of Fortran, where input parameters are declared as \"intent(in)\" and output parameters are declared as \"intent(out)\".", "input": "", "output": "subroutine kwet(mc1000,increment,rkwet)\n\n  real, intent(in)    :: mc1000,increment\n  real, intent(out) :: rkwet\n\n ! the kwet factor just depends on the slow evolving moisture content\n  !\n\n if (mc1000 .gt. 25 )then\n    rkwet=1.0\n else if (mc1000 .gt. 10)then\n    rkwet=(0.0333*mc1000 +0.1675)\n else\n    rkwet=0.5\n end if\n !overwrite the above if the increment in moisture content is negative\n\n if (increment  .le.  0) rkwet=1.0\nend subroutine kwet\n"}, {"instruction": "Write a Fortran subroutine named \"fermi\" that computes the Fermi function for a given set of input values. The number of input arguments is 2, where the first argument is an array of real numbers with precision of 8 bytes and intent \"in\", and the second argument is an integer indicating the number of elements in the array. The number of output arguments is 1, which is an array of real numbers with precision of 8 bytes and intent \"out\". The subroutine calculates the Fermi function for each element in the input array using the formula 1/(exp(x)+1) and stores the results in the output array. Use a do loop to iterate over each element in the arrays.", "input": "", "output": "subroutine fermi(y, x, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  integer,intent(in)  :: n\n  do i=1,n\n     y(i) = 1.d0/(exp(x(i))+1.d0)\n  end do\nend subroutine fermi\n"}, {"instruction": "Write a Fortran subroutine named gauss that calculates the Gaussian distribution for an array of input values. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The input parameters are 'x', 's', and 'n', representing an array of values, the standard deviation, and the size of the array, respectively. The output parameter is 'y', which is an array of the same size as 'x' and stores the calculated Gaussian distribution values. The subroutine uses the Gaussian distribution formula to compute the values and stores them in the 'y' array.", "input": "", "output": "subroutine gauss(y, x, s, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  real*8, intent(in)  :: s\n  integer,intent(in)  :: n\n  !\n  real*8, parameter :: sr2pi = 2.506628274631d0\n  do i=1,n\n     y(i) = 1.d0/(s*sr2pi)*exp(-x(i)*x(i)/(2.d0*s*s))\n  enddo\nend subroutine gauss\n"}, {"instruction": "Create a Fortran subroutine called cfermi to calculate the Fermi function for a given set of input values. The subroutine takes in two input parameters, an array of 8-byte real numbers called x, and an integer n which represents the size of the array. It also has an output parameter, an array of 8-byte real numbers called y. The subroutine uses an iterative loop to perform the Fermi function calculation for each element in the input array. If an element in the input array is greater than 10, the corresponding element in the output array is set to 0. If an element in the input array is less than -10, the corresponding element in the output array is set to 1. For all other elements, the corresponding element in the output array is calculated using the equation 1 / (exp(x) + 1).", "input": "", "output": "subroutine cfermi(y, x, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  integer,intent(in)  :: n\n  do i=1,n\n     if (x(i)>10.) then\n        y(i) = 0.d0\n     else if (x(i) < -10.d0) then\n        y(i) = 1.d0\n     else\n        y(i) = 1.d0/(exp(x(i))+1.d0)\n     endif\n  end do\nend subroutine cfermi\n"}, {"instruction": "Create a Fortran subroutine named cgauss that calculates the Gaussian function values for the given set of input values. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The subroutine computes the Gaussian function values based on the input parameters and stores the results in the output parameter array.", "input": "", "output": "subroutine cgauss(y, x, s, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  real*8, intent(in)  :: s\n  integer,intent(in)  :: n\n  !\n  real*8, parameter :: sr2pi = 2.506628274631\n  do i=1,n\n     if ( abs(x(i))>10.d0*s) then\n        y(i) = 0.d0\n     else\n        y(i) = 1.d0/(s*sr2pi)*exp(-x(i)*x(i)/(2*s*s))\n     endif\n  end do\nend subroutine cgauss\n"}, {"instruction": "Create a Fortran subroutine named fr_convolution to compute the convolution of given input arrays. The subroutine takes 6 input parameters of types integer, integer, real*8, real*8, real*8, and complex*16, and returns 1 output parameter of type complex*16.", "input": "", "output": "subroutine fr_convolution(res, iom, enk, mwm, omega, womeg, nom)\n  !  we are computing  \n  !       sigma(iom) = -1/beta \\sum_{iom} mwm[iom]/(iom-eps+iom)\n  !   because mwm[-iom]=mwm[iom] and at t=0, we can rewrite\n  !       sigma(iom) = 1/pi integrate[ mwm[om]*(eps-iom)/((eps-iom)^2 + om^2) , {om,0,infinity} ]\n  !   finally, we notice that\n  !                         integrate[ 1/((eps-iom)^2 + om^2) , {om,0,infinity} ] = pi*sign(eps)/(2*(eps-iom))\n  !   therefore\n  !       sigma(iom) = (eps-iom)/pi integrate[ (mwm[om]-mwm[iom])/((eps-iom)^2 + om^2) , {om,0,infinity} ] + mwm[iom] * sign(eps)/2\n  !\n  complex*16, intent(out) :: res\n  integer,    intent(in)  :: iom, nom\n  real*8,     intent(in)  :: enk\n  real*8,     intent(in)  :: omega(nom), womeg(nom)\n  complex*16, intent(in)  :: mwm(nom)\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  complex*16 :: eps_om, eps_om2, sc0\n  integer    :: i\n  \n  eps_om = cmplx(enk, -omega(iom), 8)\n  eps_om2 = eps_om * eps_om\n  sc0 = 0.d0\n  do i=1,nom\n     if (i==iom) cycle\n     sc0 = sc0 + (mwm(i)-mwm(iom)) * womeg(i) / (omega(i)**2 + eps_om2)\n  enddo\n  res = eps_om*sc0/pi\n  if (abs(mwm(iom))>1e-16) then\n     res = res + mwm(iom)/pi * atan(omega(nom)/eps_om) !0.5d0*pi*sign(1.d0, enk)\n  endif\nend subroutine fr_convolution\n"}, {"instruction": "Create a Fortran subroutine named set_indexing to calculate the starting and ending indices for both the southern and northern hemispheres based on the given input parameters. The subroutine takes 5 input parameters of type integer: nlpf, jsg, jeg, js, je. It also returns 4 output parameters of type integer: jss, jes, jsn, jen. The subroutine should be designed to adjust the end index for zero length, and to calculate the southern and northern hemisphere indices based on the input parameters provided.", "input": "", "output": " subroutine set_indexing (nlpf, jsg, jeg, js, je, jss, jes, jsn, jen)\n\n   integer, intent(in)  :: nlpf, jsg, jeg, js,  je\n   integer, intent(out) ::       jss, jes, jsn, jen\n\n   integer :: nlpf_s, nlpf_n\n\n!  note: nlpf_s = jes-jss+1\n!        nlpf_n = jen-jsn+1\n\n!     ----- starting/ending local indices -----\n!     ----- adjust end index for zero length ----\n\n!     --- southern hemisphere ---\n\n      jss    = max (jsg, js)\n      jes    = min (jsg+nlpf-1, je)\n      nlpf_s = max (0, jes - jss + 1)\n      jes    = jss + nlpf_s - 1\n\n!     --- northern hemisphere ---\n\n      jsn    = max (jeg-nlpf+1, js)\n      jen    = min (jeg, je)\n      nlpf_n = max (0, jen - jsn + 1)\n      jen    = jsn + nlpf_n - 1\n\n end subroutine set_indexing\n"}, {"instruction": "Write a Fortran subroutine named set_zonal_balance that calculates the zonal balance for a given set of 2D arrays. The subroutine takes 3 input parameters of type integer: nlev, pelist2d(:,:), nlpf2d(:,:). It also has 1 output parameter of type integer: nlpf(0:).", "input": "", "output": " subroutine set_zonal_balance (nlev, pelist2d, nlpf2d, nlpf)\n  integer, intent(in)  :: nlev, pelist2d(:,:), nlpf2d(:,:)\n  integer, intent(out) :: nlpf(0:)\n\n  integer, dimension(size(nlpf2d,1)) :: nlpf2d_zonal\n  integer :: i, j, remain\n\n! the returned value is the number of zonal rows on each processor\n! initialize this value to zero\n    nlpf = 0\n\n    do j=1,size(nlpf2d,2)\n!      skip pe rows with no filter rows\n       if (nlpf2d(1,j) == 0) cycle\n\n       nlpf2d_zonal(:) = (nlpf2d(1,j)*nlev)/size(nlpf2d,1)\n       remain = nlpf2d(1,j)*nlev - sum(nlpf2d_zonal(:))\n       do i=1,size(nlpf2d,1)\n         if (remain == 0) exit\n         nlpf2d_zonal(i) = nlpf2d_zonal(i) + 1\n         remain = remain - 1\n       enddo\n\n!      return 1-dimensinal structure\n       do i=1,size(nlpf2d,1)\n         nlpf(pelist2d(i,j)) = nlpf2d_zonal(i)\n       enddo\n    enddo\n\n end subroutine set_zonal_balance\n"}, {"instruction": "Create a Fortran subroutine named p_density to calculate the density matrix from the optimized coefficients. The subroutine takes 3 input parameters of type integer, integer, and real*8, dimension(kf,kf) and 1 output parameter of type real*8, dimension(kf,kf).", "input": "", "output": "        subroutine p_density(kf,ne,c,p)\n            ! ----------------------------------------------------------\n            ! compute the density matrix from the optimized coefficients\n            ! ----------------------------------------------------------\n            !\n            ! source:\n            !   szabo and ostlund\n            !   modern quantum chemistry\n            !   doever\n            !   1989\n            !\n            ! -----------------------------------------------------------\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf                           ! number of basis functions\n            integer, intent(in) :: ne                           ! number of electrons\n            real*8, dimension(kf,kf), intent(in) :: c           ! coefficients matrix\n\n            ! intermediate variables\n            integer :: i, j, k                                  ! loop coefficients\n\n            ! output\n            real*8, dimension(kf,kf), intent(out) :: p          ! density matrix\n\n            p(:,:) = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    do k = 1, ne / 2 ! todo only in rhf\n                        p(i,j) = p(i,j) + 2.0d0 * c(i,k) * c(j,k)\n                    end do\n                end do\n            end do\n\n        end subroutine p_density\n"}, {"instruction": "Create a Fortran subroutine named partition_task to partition a 2D domain for parallel processing. The subroutine takes 3 input arguments of type integer: nprocs, m, and n. It also has 1 output argument of type integer array with dimensions (2, 2, nprocs). The subroutine partitions the domain based on the number of processes (nprocs) along the m and n dimensions, and stores the partition indices in the output array.", "input": "", "output": "subroutine partition_task(nprocs, m, n, end_indx)\n    implicit none\n\n    ! external variables\n    integer, intent(in)  :: nprocs\n    integer, intent(in)  :: m\n    integer, intent(in)  :: n\n    integer, intent(out) :: end_indx(2, 2, nprocs)\n\n    ! local variables\n    integer :: step\n    integer :: i\n\n    end_indx = 0\n    ! nprocs <= m, n\n    step = m / nprocs\n    do i=1,nprocs-1\n        end_indx(1,1,i) = (i-1)*step+1\n        end_indx(2,1,i) =     i*step\n    enddo \n    end_indx(1,1,nprocs) = (nprocs-1)*step+1\n    end_indx(2,1,nprocs) = m\n\n    step = n / nprocs\n    do i=1,nprocs-1\n        end_indx(1,2,i) = (i-1)*step+1\n        end_indx(2,2,i) =     i*step\n    enddo \n    end_indx(1,2,nprocs) = (nprocs-1)*step+1\n    end_indx(2,2,nprocs) = n\n\n    return\nend subroutine partition_task \n"}, {"instruction": "Create a Fortran subroutine named stddev to calculate the mean and standard deviation of an array. The subroutine takes 2 input parameters of type real, dimension(:) and real, optional, and 2 output parameters of type real.", "input": "", "output": "  subroutine stddev(array,arith_mean,std_deviation,missing)\n    ! compute the mean and standard deviation of an array\n    real, dimension(:), intent(in)   :: array\n    real,               intent(out)  :: arith_mean\n    real,               intent(out)  :: std_deviation\n    real, optional,     intent(in)   :: missing\n\n    real                             :: sqr_sum\n    integer                          :: nelems\n\n       if (present(missing)) then\n          nelems=count(array .ne. missing)\n          arith_mean=sum(array,mask=array .ne. missing)/float(nelems)\n          sqr_sum=sum(array**2,mask=array .ne. missing)\n       else\n          nelems=size(array)\n          arith_mean=sum(array)/float(nelems)\n          sqr_sum=sum(array**2)\n       endif\n\n       if ( nelems == 0 ) then\n          std_deviation=0.0\n          return\n       endif\n\n       !sample standard deviation\n       std_deviation=sqrt((sqr_sum-nelems*arith_mean**2)/(nelems-1))\n\n  end subroutine stddev\n"}, {"instruction": "Create a Fortran subroutine named evenbounds to calculate the minimum and maximum integer values within certain bounds. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are n and m, and the output parameters are kmin and kmax.", "input": "", "output": "   subroutine evenbounds( n, m, kmin, kmax )\n\n      implicit none\n      integer, intent(in) :: n, m\n      integer, intent(out) :: kmin, kmax\n\n      ! local variables\n      real, dimension(3) :: btab\n\n      btab = (/ 0.0, real(m)/2.0, -real(m)/2.0 /)\n      kmin = ceiling( maxval( btab ) )\n\n      btab = (/ real(n)/2.0, real(n)-real(m)/2.0, real(n)+real(m)/2.0 /)\n      kmax = floor( minval( btab ) )\n\n   end subroutine\n"}, {"instruction": "Write a Fortran subroutine named oddbounds to calculate the minimum and maximum values based on the input integer parameters n and m. The subroutine has 2 input parameters of type integer, and 2 output parameters of type integer.", "input": "", "output": "   subroutine oddbounds( n, m, kmin, kmax )\n\n      implicit none\n      integer, intent(in) :: n, m\n      integer, intent(out) :: kmin, kmax\n\n      ! local variables\n      real btab(3)\n\n      btab = (/ 0.0, -real(m+1)/2.0, real(m-1)/2.0 /)\n      kmin = ceiling( maxval( btab ) )\n\n      btab = (/ real(n-1)/2.0, real(n)-real(m+1)/2.0, real(n)+real(m-1)/2.0 /)\n      kmax = floor( minval( btab ) )\n\n   end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gaussian to generate an array of normally distributed random numbers using the Box-Muller transform. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "  subroutine gaussian(output, mu, sigma, k, seed)\n    integer, intent(in) :: k, seed\n    real(8), intent(in) :: mu, sigma\n    real(8), intent(out) :: output(k)\n\n    integer :: i, n\n    real(8) :: r, theta\n    real(8), dimension(:), allocatable :: temp\n    integer(4), dimension(:), allocatable :: seed_arr\n\n    ! get random seed array size and fill seed_arr with provided seed\n    call random_seed(size = n)\n    allocate(seed_arr(n))\n    seed_arr = seed\n    call random_seed(put = seed_arr)\n\n    ! create 2k random numbers uniformly from [0,1]\n    if(allocated(temp)) then\n       deallocate(temp)\n    end if\n    allocate(temp(k*2))\n    call random_number(temp)\n\n    ! use box-muller transfrom to create normally distributed variables\n    do i = 1, k\n       r = (-2.0 * log(temp(2*i-1)))**0.5\n       theta = 2 * 3.1415926 * temp(2*i)\n       output(i) = mu + sigma * r * sin(theta)\n    end do\n  end subroutine gaussian\n"}, {"instruction": "Create a Fortran subroutine named recenter_velocities to recenter the velocities of particles. The subroutine takes 5 input parameters: 2 integers (nstep, nat), 2 real*8 arrays (masses, velocities) of dimension nat, and 1 integer array (factors) of dimension nat. It also has 1 output parameter: a real*8 array (velocities_) of dimension (nstep, nat, 3).", "input": "", "output": "subroutine recenter_velocities(velocities, masses, factors, velocities_, nstep, nat)\n    implicit none\n    ! make the center of mass velocity disappear\n    integer, intent(in)                             ::  nstep, nat\n    real*8, intent(in), dimension(nat)              :: masses\n    integer, intent(in), dimension(nat)             :: factors\n    real*8, intent(in),  dimension(nstep, nat, 3)   :: velocities\n    real*8, intent(out), dimension(nstep, nat, 3)   :: velocities_\n    integer                                         :: iat, istep, ipol\n    real*8, dimension(nat)                          :: rel_masses\n    real*8, dimension(3)                            :: com\n    real*8                                          :: m\n\n    do iat=1, nat\n        rel_masses(iat) = dble(factors(iat)) * masses(iat)\n    end do\n\n    m = sum(rel_masses)\n    rel_masses(:) = rel_masses(:) / m\n\n    do istep=1, nstep\n        com(1:3) = 0.d0\n        do iat=1, nat\n            do ipol=1, 3\n                com(ipol) = com(ipol) + rel_masses(iat)*velocities(istep, iat, ipol)\n            end do\n        end do\n\n        do iat=1, nat\n            do ipol=1, 3\n                velocities_(istep, iat, ipol) = velocities(istep, iat, ipol)  - com(ipol)\n            end do\n        end do\n    end do\n\nend subroutine recenter_velocities\n"}, {"instruction": "Create a Fortran subroutine named str_match to find the matching delimiter in a given string. The subroutine takes 2 input parameters of type character(len=*) and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine str_match(str, ipos, imatch)\r\n    !! this routine finds the delimiter in string `str` that matches the delimiter\r\n    !! in position `ipos` of `str`. the argument `imatch` contains the position of\r\n    !! the matching delimiter. allowable delimiters are (), [], {}, <>.\r\n    \r\n    character(len=*), intent(in) :: str\r\n    integer,          intent(in) :: ipos\r\n    integer,         intent(out) :: imatch\r\n    character(len=1) :: delim1\r\n    character(len=1) :: delim2\r\n    character(len=1) :: ch\r\n    integer :: lenstr\r\n    integer :: istart\r\n    integer :: iend\r\n    integer :: inc\r\n    integer :: idelim2\r\n    integer :: isum\r\n    integer :: i\r\n    \r\n    lenstr = len_trim(str)\r\n\r\n    delim1 = str(ipos:ipos)\r\n\r\n    select case(delim1)\r\n        case('(')\r\n            idelim2=iachar(delim1)+1\r\n            istart=ipos+1\r\n            iend=lenstr\r\n            inc=1\r\n        case(')')\r\n            idelim2=iachar(delim1)-1\r\n            istart=ipos-1\r\n            iend=1\r\n            inc=-1\r\n        case('[','{','<')\r\n            idelim2=iachar(delim1)+2\r\n            istart=ipos+1\r\n            iend=lenstr\r\n            inc=1\r\n        case(']','}','>')\r\n            idelim2=iachar(delim1)-2\r\n            istart=ipos-1\r\n            iend=1\r\n            inc=-1\r\n        case default\r\n            write(*,*) delim1,' is not a valid delimiter'\r\n            return\r\n    end select\r\n\r\n    if (istart < 1 .or. istart > lenstr) then\r\n        write(*,*) delim1,' has no matching delimiter'\r\n        return\r\n    end if\r\n    delim2=achar(idelim2) ! matching delimiter\r\n    \r\n    isum = 1\r\n    do i = istart, iend, inc\r\n        ch=str(i:i)\r\n        if (ch /= delim1 .and. ch /= delim2) cycle\r\n        if (ch == delim1) isum = isum+1\r\n        if (ch == delim2) isum = isum-1\r\n        if (isum == 0) exit\r\n    end do\r\n\r\n    if(isum /= 0) then\r\n        write(*,*) delim1,' has no matching delimiter'\r\n        return\r\n    end if   \r\n\r\n    imatch = i\r\n    \r\n    end subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named space_to_underbar that takes a single input parameter of type character (len=*) and returns a single output parameter of type character (len=*). The subroutine replaces spaces in the input string with underscores and assigns the modified string to the output parameter.", "input": "", "output": "    subroutine space_to_underbar(str, name)\n      character (len=*), intent(in) :: str\n      character (len=*), intent(out) :: name\n      integer :: i, len\n      len = len_trim(str)\n      name = ''\n      do i=1,len\n         if (str(i:i) == ' ') then\n            name(i:i) = '_'\n         else\n            name(i:i) = str(i:i)\n         end if\n      end do\n    end subroutine space_to_underbar\n"}, {"instruction": "Create a Fortran subroutine named \"dvbes12\" to calculate the derivatives of the Bessel functions. The subroutine should have 4 input parameters of type real*8, real*8, real*8, and integer, and one output parameter of type real*8. The subroutine is responsible for computing the derivatives according to specified calculations and logic.", "input": "", "output": "subroutine dvbes12(fj,dj,sm,ri,nt)                                 \n  !-----x----x----x----x----x----x----x----x----x----x----x----x----x----x\n  !-----x calculate the derivatives of the bessel functions.   x----x----x\n  !-----x   dj=dfj/dx where x=sm*ri                                 x----x\n  !-----x                    d.d.koelling                      x----x----x\n  !-----x----x----x----x----x----x----x----x----x----x----x----x----x----x\n  implicit none\n  real*8, intent(in) :: fj(*)                                          \n  real*8, intent(out):: dj(*)\n  real*8, intent(in) :: sm\n  real*8, intent(in) :: ri\n  integer, intent(in):: nt\n  ! locals\n  integer :: l, lm\n  real*8  :: q2, q3, x\n  real*8, parameter :: zup = 1.0d-5\n  x=sm\n  if (x.le.zup) then\n     dj(1)=0.d0\n     dj(2)=1.0/3.d0\n     do l=3,nt                                                      \n        dj(l)=0.d0\n     enddo\n     return\n  end if\n  q2=-1.d0/x                                                         \n  q3=q2                                                             \n  dj(1)=-fj(2)                                                      \n  lm=1                                                              \n  do l=2,nt                                                      \n     q3=q3+q2                                                          \n     dj(l)=fj(lm)+q3*fj(l)                                             \n     lm=lm+1                                                           \n  enddo\n  return                                                            \nend subroutine dvbes12\n"}, {"instruction": "Create a Fortran subroutine named optimal_gridmap to solve the division of a rectangle into discrete grids, ensuring that the number of regions is equal to or greater than the specified minimum. The subroutine takes 2 input parameters of type integer, representing the dimensions of the rectangle and the minimum number of parts, and 1 output parameter of type integer representing the optimal division of the rectangle into regions.", "input": "", "output": "    subroutine optimal_gridmap( rect, min_parts, ticks )\n    ! solves division of a rectangle with rect(1)*rect(2)\n    ! discrete grids into ticks(1)*ticks(2) (>= min_parts)\n    ! regions so that the length of borders is minimal\n    implicit none\n    integer, intent(in)  :: rect(2), min_parts\n    integer, intent(out) :: ticks(2)\n    integer              :: q, qx, qy, nbx, nby,&\n                            length, least \n    ticks = [ min_parts, min_parts ]\n    least = sum(rect)*min_parts\n    do qx = 1, min_parts\n        do qy = 1, min_parts\n            q = qx*qy\n            if( q>=min_parts .and. q-qx<min_parts .and. &\n                           q-qy<min_parts .and. &\n                       qx<=rect(1) .and. qy<=rect(2) ) then\n               if( qx==1 ) then\n                  nbx = 0\n               else\n                  nbx = qx\n               end if\n               if( qy==1 ) then\n                  nby = 0\n               else\n                  nby = qy\n               end if\n               length = nbx*rect(2)+nby*rect(1)\n               if( length<least ) then\n                  least = length\n                  ticks = [qx, qy]\n               end if\n            end if\n        end do\n    end do\n    end subroutine optimal_gridmap\n"}, {"instruction": "Create a Fortran subroutine named cmdprs_dequotestd to remove all quotation marks from a given input string. The subroutine takes 1 input parameter of type character(len=*) and 2 output parameters of type character(len=*) and integer (optional).", "input": "", "output": "  elemental subroutine cmdprs_dequotestd (ssource,sdest,ilength)\n  !<description>\n    ! remove all quotation marks from a string.\n  !</description>\n  \n  !<input>\n    ! a source string.\n    character(len=*), intent(in) :: ssource\n  !</input>\n  \n  !<output>\n    ! destination string. non-escaped quotation marks are removed.\n    character(len=*), intent(out) :: sdest\n    \n    ! optional: length of the string\n    integer, intent(out), optional :: ilength\n  !</output>\n  \n    character(len=len(ssource)) :: stemp\n    integer :: i, idest, ilen\n    character :: squotechar, scurrentchar\n    logical :: bescape\n    \n    ! copy the string, remove leading/trailing spaces.\n    stemp = trim(ssource)\n    \n    ! initialise destination\n    sdest = \"\"\n    \n    ! loop through the string. copy characters.\n    ! replace quotation marks.\n    i = 1\n    idest = 0\n    bescape = .false.\n    squotechar = ' '\n    ilen = len_trim(stemp)\n    do\n      if (i .gt. ilen) exit\n      \n      ! get the current character.\n      scurrentchar = stemp(i:i)\n      \n      if (bescape) then\n      \n        ! switch off escape mode.\n        bescape = .false.\n        \n      else\n        \n        if (scurrentchar .eq. \"\\\") then\n        \n          ! take the next character as it is.\n          bescape = .true.\n          \n          ! ignore the escape char.\n          i = i+1\n          cycle\n        \n        else if ((scurrentchar .eq. \"'\") .or. (scurrentchar .eq. \"\"\"\")) then\n          \n          ! start quoting or stop it. only the current quote char\n          ! triggers off the quoting.\n          if (squotechar .eq. scurrentchar) then\n            squotechar = \" \"\n          else\n            squotechar = scurrentchar\n          end if\n          \n          ! ignore the quotation char.\n          i = i+1\n          cycle\n          \n        end if\n      end if\n\n      ! copy the character and go to the next char.\n      idest = idest+1\n      sdest(idest:idest) = scurrentchar\n\n      i = i+1\n    end do\n    \n    ! from the destination, take the actual substring.\n    if (present(ilength)) then\n      ilength = idest\n    end if\n    \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_selection_auto that takes a character array as input and returns an 8-byte integer. The input parameter is of type character(*) and is designated as intent(in). The output parameter is of type integer*8 and is designated as intent(out). This subroutine is designed to provide an automatic selection based on the provided hints.", "input": "", "output": "        subroutine adios_selection_auto (sel, hints)\n            implicit none\n            integer*8,      intent(out)          :: sel\n            character(*),   intent(in)           :: hints\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios_get_attr_int2\" that retrieves an integer attribute from a file. The subroutine should take 2 input parameters of type integer*8 and character(*), and 2 output parameters of type integer*2 and integer.", "input": "", "output": "        subroutine adios_get_attr_int2 (fp, attrname, attr, err)\n            implicit none\n            integer*8,      intent(in)  :: fp\n            character(*),   intent(in)  :: attrname\n            integer*2,      intent(out) :: attr\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named mergearrayint that combines two input integer arrays into a single output array. The subroutine should take 2 input parameters of type integer array and an additional output parameter of type integer array that is allocatable.", "input": "", "output": "subroutine mergearrayint(a,b,c)\n    integer,intent(in)::a(:,:)\n    integer,intent(in)::b(:,:)\n    integer,allocatable,intent(out)::c(:,:)\n    integer i,j,an,am,bn,bm\n\n    if(allocated(c)) deallocate(c)\n    an=size(a,1)\n    am=size(a,2)\n\n    bn=size(b,1)\n    bm=size(b,2)\n\n    if(am/=bm)then\n        print *, \"error :: mergearray, size(a,2)/= size(b,2)\"\n        return\n    endif\n    allocate(c(an+bn,am) )\n    do i=1,an\n        c(i,:)=a(i,:)\n    enddo\n    do i=1,bn\n        c(i+an,:)=b(i,:)\n    enddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20u8pproperties to calculate various properties related to fluid flow through porous media. The subroutine takes 6 input parameters of type real: fperm, fporosity, fporea, fks, fkf, and fap(8), and produces 4 output parameters of type real: faxw(8), fasw(8), faqinv(8), and fapermeability(8).", "input": "", "output": "subroutine calch20u8pproperties(fperm, fporosity, fporea, fks, fkf, fap, faxw, fasw, faqinv, fapermeability)\n\timplicit none\n\treal, intent(in) :: fperm, fporosity, fporea, fks, fkf, fap(8)\n\treal, intent(out) :: faxw(8), fasw(8), faqinv(8), fapermeability(8)\n\n! main routine \n\tfaxw = 1.\n\tfasw = 1.\n\tfaqinv = 0. + fporosity * fasw / fkf + (fporea - fporosity) * faxw / fks\n\tfapermeability = fperm\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20u8ph to calculate stress-strain equations and stiffness matrix based on the given input parameters. The number of input arguments is 5 and the test_data type is ['integer', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "subroutine calch20u8ph(iint, fapermeability, fas, fab, faweight, fah)\n  !dec$ attributes dllexport::calch20u8ph\n\timplicit none\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fas(8, iint ** 3), fab(6, 24, iint ** 3), fapermeability(8)\n\treal, intent(out) :: fah(36)\n\treal :: fstiff, fterm, fpermeability\n\tinteger :: i, j, k, m, ks, ix, iy, iz, ir1, ir2, ir3, ic\n\n! main routine \n! calculate stress-strain equations\n! calculate stiffness matrix\n\tm = 0\n\tdo i = 1, 36\n\t\tfah(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tfpermeability = 0.\n\t\t\t\tdo j = 1, 8\n\t\t\t\t\tfpermeability = fpermeability + fapermeability(j) * fas(j, m)\n\t\t\t\tend do\n\t\t\t\tks = 0\n\t\t\t\tfterm = faweight(m) * fpermeability\n\t\t\t\tdo i = 1, 8\n\t\t\t\t\tir1 = 3 * (i - 1) + 1\n\t\t\t\t\tir2 = ir1 + 1\n\t\t\t\t\tir3 = ir1 + 2\n\t\t\t\t\tdo j = i, 8\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tic = 3 * (j - 1) + 1\n\t\t\t\t\t\tfstiff = fab(1, ic, m) * fab(1, ir1, m) + fab(2, ic + 1, m) * fab(2, ir2, m) + &\n\t\t\t\t\t\t\tfab(3, ic + 2, m) * fab(3, ir3, m)\n\t\t\t\t\t\tfah(ks) = fah(ks) + fstiff * fterm\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20u8ps that calculates the element stiffness matrix for a given set of inputs. The number of input arguments is 4 and the test_data type is ['integer', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].\n\nThe subroutine takes an integer value, a real array of size 8, a real array of size iint cubed, and a real array of size 8 by iint cubed as input. It calculates the element stiffness matrix and stores it in a real array of size 36.\n\nThe main routine initializes the output array to zero and then iterates over the input arrays to calculate and accumulate the element stiffness values. The calculations involve multiplying the elements of the input arrays and updating the corresponding elements of the output array.\n\nThe subroutine does not have any explicit return statement and does not return any values. The output is stored directly in the output array provided as an argument.\n\nPlease note that there are commented lines in the code that are not executed. They can be uncommented to write the output to a file.\n", "input": "", "output": "subroutine calch20u8ps(iint, faxwdivq, fas, faweight, fam)\n  !dec$ attributes dllexport::calch20u8ps\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faxwdivq(8), faweight(iint ** 3), fas(8, iint ** 3)\n\treal, intent(out) :: fam(36)\n\tinteger :: i, j, m, ks, ix, iy, iz\n\treal :: fterm, fxwdivq\n\n! main routine\n\tm = 0\n\tdo i = 1, 36\n\t\tfam(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tfxwdivq = 0.\n\t\t\t\tdo j = 1, 8\n\t\t\t\t\tfxwdivq = fxwdivq + faxwdivq(j) * fas(j, m)\n\t\t\t\tend do\n\t\t\t\tks = 0\n\t\t\t\tfterm = faweight(m) * fxwdivq\n\t\t\t\tdo i = 1, 8\n\t\t\t\t\tdo j = i, 8\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tfam(ks) = fam(ks) + fterm * fas(i, m) * fas(j, m)\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\n\n!\topen(100, file = 'd:\\ganal\\ganalf\\mass3.txt', status = 'new')\n!\tdo i = 1, 300\n!\t\twrite(100, 999) (i), fam(i)\n!\tenddo\n!\tclose(100)\n999 format (i5, f10.5)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"calch20u8pforcesfromporesh\" to calculate the global forces in a finite element analysis. The subroutine takes 3 input parameters: an array of integers named \"pieqlm\" with a size of 1, an array of real numbers named \"pfelementh\" with a size of 36, and an array of real numbers named \"pfp\" with a size of 8. It also has 1 output parameter: an array of real numbers named \"pfglobalforces\" with a size of 1.\n\nInside the subroutine, the local forces vector \"flocalforces\" is initialized to zero. Then, the skyline element matrix \"pfelementh\" is multiplied with the vector \"pfp\" and the result is stored in \"flocalforces\". \n\nNext, the subroutine updates the global loads vector \"pfglobalforces\" by adding the corresponding elements of \"flocalforces\" based on the values in the \"pieqlm\" array.\n\nThe subroutine utilizes implicit typing and operates with a mix of integer and real data types.", "input": "", "output": "subroutine calch20u8pforcesfromporesh(pieqlm, pfelementh, pfp, pfglobalforces)\n\timplicit none\n\n\tinteger, intent(in) :: pieqlm(1)\n\treal, intent(in) :: pfelementh(36), pfp(8)\n\treal, intent(out) :: pfglobalforces(1)\n\n\tinteger :: i, j, irow, iaccr, itemp, idatapos\n\treal :: flocalforces(8)\n\n! main function\n! initialize local forces vector\n\tflocalforces(1) = 0d0\n\tflocalforces(2) = 0d0\n\tflocalforces(3) = 0d0\n\tflocalforces(4) = 0d0\n\tflocalforces(5) = 0d0\n\tflocalforces(6) = 0d0\n\tflocalforces(7) = 0d0\n\tflocalforces(8) = 0d0\n\n! multiply skyline element h with vector pfp and store to flocalforces\n\tidatapos = 1\n\tdo i = 1, 8\n\t\tflocalforces(i) = flocalforces(i) + pfelementh(idatapos) * pfp(i)\n\t\tidatapos = idatapos + 1\n\t\tdo j = i + 1, 8\n\t\t\tflocalforces(i) = flocalforces(i) + pfelementh(idatapos) * pfp(j)\n\t\t\tflocalforces(j) = flocalforces(j) + pfelementh(idatapos) * pfp(i)\n\t\t\tidatapos = idatapos + 1\n\t\tend do\n\tend do\n\n! update the global loads vector (pfglobalforces)\n\titemp = pieqlm(1)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(1)\n\titemp = pieqlm(2)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(2)\n\titemp = pieqlm(3)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(3)\n\titemp = pieqlm(4)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(4)\n\titemp = pieqlm(5)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(5)\n\titemp = pieqlm(6)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(6)\n\titemp = pieqlm(7)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(7)\n\titemp = pieqlm(8)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(8)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named xderiv that performs a numerical differentiation operation on a 2D array of variables. The subroutine takes in four input parameters: nx and ny (both integers), rkx (a 1D array of double precision numbers), and var (a 2D array of double precision numbers). It also has one output parameter, der, which is a 2D array of double precision numbers.\n\nThe subroutine calculates the derivative of the variable array var with respect to the wavenumber ky. It uses the values in the rkx array as multipliers for the differentiation operation. The differentiation is carried out by multiplying each element of var with the corresponding element in rkx and storing the result in the der array.\n\nWithin the subroutine, some additional calculations are performed. The variables nwx, nxp2, kx, ky, dkx, and kxc are declared as integers. The value of nwx is calculated as half of nx. The value of nxp2 is calculated as nx plus 2. The differentiation operation is then carried out in a loop over ky and kx values, where the derivatives are calculated and stored in the der array.\n\nIf the value of nx is an even number, an additional loop is executed to set the derivatives at kxc equal to zero.\n\nIn summary, the xderiv subroutine performs numerical differentiation on a 2D array of variables using wavenumber multiplication. It takes in four input parameters and returns the derivative array as the output parameter.", "input": "", "output": "        subroutine xderiv(nx, ny, rkx, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rkx(nx), var(nx, ny)\n            double precision, intent(out) :: der(nx, ny)\n            integer                       :: nwx, nxp2, kx, ky, dkx, kxc\n\n            nwx = nx / 2\n            nxp2 = nx + 2\n            !carry out differentiation by wavenumber multiplication:\n            do ky = 1, ny\n                der(1, ky) = zero\n                do kx = 2, nx - nwx\n                    dkx = 2 * (kx - 1)\n                    kxc = nxp2 - kx\n                    der(kx,  ky) = -rkx(dkx) * var(kxc, ky)\n                    der(kxc, ky) =  rkx(dkx) * var(kx , ky)\n                enddo\n            enddo\n\n            if (mod(nx, 2) .eq. 0) then\n                kxc = nwx + 1\n                do ky = 1, ny\n                    der(kxc, ky) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"yderiv\" that performs differentiation using wavenumber multiplication. The subroutine takes in four input parameters: \"nx\" and \"ny\" of type integer, \"rky\" of type double precision with dimension ny, and \"var\" of type double precision with dimension nx by ny. It also has one output parameter \"der\" of type double precision with dimension nx by ny.\n\nInside the subroutine, the variables \"nwy\", \"nyp2\", \"kx\", \"ky\", \"kyc\", and \"fac\" are declared. The subroutine first calculates the value of \"nwy\" as ny divided by 2, and \"nyp2\" as ny plus 2.\n\nThen, the subroutine performs the differentiation by wavenumber multiplication. It initializes the array \"der\" with zeros for the first row.\n\nNext, it uses nested do-loops to iterate through the values of \"ky\" from 2 to ny minus \"nwy\". For each \"ky\" value, it calculates the corresponding \"kyc\" value as \"nyp2\" minus \"ky\", and sets \"fac\" as the value of \"rky\" at index 2 times (\"ky\" minus 1).\n\nInside the innermost do-loop, for each \"kx\" value from 1 to nx, the subroutine assigns the negative value of \"fac\" multiplied by \"var\" at indices \"kx\" and \"kyc\" to \"der\" at indices \"kx\" and \"ky\". It also assigns the positive value of \"fac\" multiplied by \"var\" at indices \"kx\" and \"ky\" to \"der\" at indices \"kx\" and \"kyc\".\n\nAfter the nested do-loops, if the value of \"ny\" is even (determined using the modulo operator), the subroutine initializes the elements of \"der\" at index \"kx\" and \"nwy\" plus 1 to zero for each \"kx\" value from 1 to nx.\n\nThis subroutine performs differentiation using wavenumber multiplication and calculates the derivatives of the input array \"var\" with respect to the wavenumbers.", "input": "", "output": "        subroutine yderiv(nx, ny, rky, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rky(ny), var(nx, ny)\n            double precision, intent(out) :: der(nx, ny)\n            integer                       :: nwy, nyp2, kx, ky, kyc\n            double precision              :: fac\n\n            nwy = ny / 2\n            nyp2 = ny + 2\n            !carry out differentiation by wavenumber multiplication:\n            do kx = 1, nx\n                der(kx, 1) = zero\n            enddo\n\n            do ky = 2, ny - nwy\n                kyc = nyp2 - ky\n                fac = rky(2 * (ky - 1))\n                do kx = 1, nx\n                    der(kx,  ky) = -fac * var(kx, kyc)\n                    der(kx, kyc) =  fac * var(kx , ky)\n                enddo\n            enddo\n\n            if (mod(ny, 2) .eq. 0) then\n                kyc = nwy + 1\n                do kx = 1, nx\n                    der(kx, kyc) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named yderiv_fs that performs differentiation by wavenumber multiplication. The subroutine takes four input parameters: nx and ny of integer type, rky of double precision type with size ny, and var of double precision type with size nx by ny. It also has one output parameter: der of double precision type with size nx by 0:ny.\n\nIn the subroutine, set der(kx, 0) and der(kx, ny) to zero for all kx from 1 to nx. Then, for each ky from 1 to ny-1, compute der(kx, ky) by multiplying rky(ky) with var(kx, ky) for all kx from 1 to nx.\n\nEnsure that the subroutine is implemented using the do loop construct to iterate over kx and ky.\n\nUse this subroutine when you need to perform differentiation by wavenumber multiplication in your Fortran program.", "input": "", "output": "        subroutine yderiv_fs(nx, ny, rky, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rky(ny), var(nx, ny)\n            double precision, intent(out) :: der(nx, 0:ny)\n            integer                       :: kx, ky\n\n            !carry out differentiation by wavenumber multiplication:\n            do kx = 1, nx\n                der(kx, 0) = zero\n                !the above implies the mean value of der for every kx is zero.\n                der(kx, ny) = zero\n                !der = 0 when ky = ny since var = 0 when ky = ny.\n            enddo\n            do ky = 1, ny - 1\n                do kx = 1, nx\n                    der(kx, ky) = rky(ky) * var(kx, ky)\n                enddo\n            enddo\n        end subroutine\n"}, {"instruction": "Implement a Fortran subroutine named radtrans_rhs_form that calculates the right-hand side (RHS) of a radiation transport equation. The subroutine takes 4 input parameters: an integer neq, an array j of real numbers with dimension neq, an array k of real numbers with dimension 1+neq*(neq-1)/2, and an array i of real numbers with dimension neq. It also has 1 output parameter: an array didlam of real numbers with dimension neq. \n\nThe purpose of the subroutine is to compute the RHS by subtracting the product of k and i from j for each element in the arrays. The computation is performed element-wise, and the results are stored in the array didlam.\n\nPlease note that the code includes a commented section (denoted by \"!\") which checks for a condition \"is_linear_stokes==1\". This condition is currently commented out and does not affect the functionality of the code.", "input": "", "output": "      subroutine radtrans_rhs_form(neq,j,k,didlam,i)\n        integer, intent(in) :: neq\n        real(kind=8), intent(in), dimension(neq) :: j\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(neq) :: didlam\n        real(kind=8), intent(in), dimension(neq) :: i\n      !         write(6,*) 'rhs: ',is_linear_stokes,size(i),size(k),size(j)\n!        if (is_linear_stokes==1) then\n           didlam(1)=j(1)-(k(1)*i(1)+k(2)*i(2)+k(3)*i(3)+k(4)*i(4))\n           didlam(2)=j(2)-(k(2)*i(1)+k(1)*i(2)+k(7)*i(3)-k(6)*i(4))\n           didlam(3)=j(3)-(k(3)*i(1)-k(7)*i(2)+k(1)*i(3)+k(5)*i(4))\n           didlam(4)=j(4)-(k(4)*i(1)+k(6)*i(2)-k(5)*i(3)+k(1)*i(4))\n!        endif\n      end subroutine radtrans_rhs_form\n"}, {"instruction": "Create a Fortran subroutine named radtrans_jac_form to calculate the Jacobian matrix for a radiation transfer problem. The subroutine takes 4 input parameters: 2 integers (neq, nrowpd) and 2 real arrays of kind=8 (j and k). It outputs a real array of kind=8 with dimensions nrowpd and neq (pd).", "input": "", "output": "      subroutine radtrans_jac_form(neq,j,k,nrowpd,pd)\n        integer, intent(in) :: neq, nrowpd\n        real(kind=8), intent(in), dimension(neq) :: j\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(nrowpd,neq) :: pd\n        !      write(6,*) 'jac: ',nrowpd,neq,size(k)\n!        if (is_linear_stokes==1) then\n           pd(1,1)=k(1)\n           pd(1,2)=k(2)\n           pd(1,3)=k(3)\n           pd(1,4)=k(4)\n           pd(2,1)=k(2)\n           pd(2,2)=k(1)\n           pd(2,3)=k(7)\n           pd(2,4)=-k(6)\n           pd(3,1)=k(3)\n           pd(3,2)=-k(7)\n           pd(3,3)=k(1)\n           pd(3,4)=k(5)\n           pd(4,1)=k(4)\n           pd(4,2)=k(6)\n           pd(4,3)=-k(5)\n           pd(4,4)=k(1)\n           pd=-1d0*pd\n!        endif\n!         write(6,*) 'pd: ',pd\n        return\n      end subroutine radtrans_jac_form\n"}, {"instruction": "Create a Fortran subroutine named radtrans_jac_form_sph to calculate the Jacobian matrix for a specific radiation transfer problem. The subroutine takes 5 input parameters of types integer, integer, real(kind=8) arrays of dimension neq, real(kind=8) arrays of dimension neq, and real(kind=8) arrays of dimension 1+neq*(neq-1)/2, and outputs a real(kind=8) array of dimension nrowpd by neq.", "input": "", "output": "      subroutine radtrans_jac_form_sph(neq,j,k,i,nrowpd,pd)\n        integer, intent(in) :: neq, nrowpd\n        real(kind=8), intent(in), dimension(neq) :: j,i\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(nrowpd,neq) :: pd\n        real(kind=8) :: cphi,sphi,cpsi,spsi\n        !      write(6,*) 'jac: ',nrowpd,neq,size(k)\n!        if (is_linear_stokes==1) then\n        cphi=cos(i(3)); sphi=sin(i(3)); cpsi=cos(i(4)); spsi=sin(i(4))\n        pd(1,1)=-k(1)\n        pd(1,2)=-cphi*spsi*k(2)-sphi*spsi*k(3)-cpsi*k(4)\n        pd(1,3)=-i(2)*(-sphi*spsi*k(2)+cphi*spsi*k(3))\n        pd(1,4)=-i(2)*(cphi*cpsi*k(2)+cpsi*sphi*k(3)-spsi*k(4))\n        pd(2,1)=pd(1,2)\n        pd(2,2)=-k(1)\n        pd(2,3)=i(1)*spsi*(sphi*k(2)-cphi*k(3))+spsi*(cphi*j(3)-sphi*j(2))\n        pd(2,4)=-i(1)*cpsi*(cphi*k(2)+sphi*k(3))+cpsi*(cphi*j(2)+sphi*j(3))-spsi*(j(4)-i(1)*k(4))\n!        pd(3,1)=1d0/i(2)*(sphi/spsi*k(2)-cphi/spsi*k(3))\n        pd(3,1)=1d0/spsi/i(2)*(sphi*k(2)-cphi*k(3))\n!        pd(3,2)=(-cphi*cpsi/spsi*k(5)-cpsi/spsi*sphi*k(6)+k(7))/i(2)-(-cphi/spsi*(i(1)*k(3)-& \n!             j(3)+i(2)*cpsi*k(5))-1d0/spsi*sphi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6))+i(2)*k(7))/i(2)**2.\n        pd(3,2)=1d0/spsi/i(2)**2d0*(cphi*(i(1)*k(3)-j(3))+sphi*(j(2)-i(1)*k(2)))\n!        pd(3,3)=(1d0/spsi*sphi*(i(1)*k(3)-j(3)+i(2)*cpsi*k(5))-cphi/spsi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6)))/i(2)\n        pd(3,3)=1d0/i(2)/spsi*(sphi*(i(1)*k(3)-j(3))+cphi*(i(1)*k(2)-j(2)))+1d0/spsi*(sphi*k(5)-cphi*k(6))\n!        pd(3,4)=(i(2)*cphi*k(5)+cphi*cpsi/spsi/spsi*(i(1)*k(3)-j(3)+i(2)*cpsi*k(5))+i(2)*sphi*k(6)+ &\n!             cpsi/spsi/spsi*sphi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6)))/i(2)\n        pd(3,4)=cpsi/spsi/spsi/i(2)*(cphi*(i(1)*k(3)-j(3))-sphi*(i(1)*k(2)-j(2)))+1d0/spsi/spsi*(cphi*k(5)+sphi*k(6))\n        pd(4,1)=(-cphi*cpsi*k(2)-cpsi*sphi*k(3)+spsi*k(4))/i(2)        \n!        pd(4,2)=(-sphi*k(5)+cphi*k(6))/i(2)-(-i(1)*cphi*cpsi*k(2)+spsi*(i(1)*k(4)-j(4))-sphi*(i(1)*cpsi*k(3) &\n!             -cpsi*j(3)+i(2)*k(5))+cphi*(cpsi*j(2)+i(2)*k(6)))/i(2)**2d0\n        pd(4,2)=1d0/i(2)**2d0*(cphi*cpsi*(i(1)*k(2)-j(2))-spsi*(i(1)*k(4)-j(4))+sphi*cpsi*(i(1)*k(3)-j(3)))\n!        pd(4,3)=(i(1)*cpsi*sphi*k(2)-cphi*(i(1)*cpsi*k(3)-cpsi*j(3)+i(2)*k(5))-sphi*(cpsi*j(2)+i(2)*k(6)))/i(2)\n        pd(4,3)=1d0/i(2)*(cpsi*sphi*(i(1)*k(2)-j(2))-cpsi*cphi*(i(1)*k(3)-j(3)))-cphi*k(5)-sphi*k(6)\n!        pd(4,4)=(i(1)*cphi*spsi*k(2)-cphi*spsi*j(2)-sphi*(-i(1)*spsi*k(3)+spsi*j(3))+cpsi*(i(1)*k(4)-j(4)))/i(2)\n        pd(4,4)=1d0/i(2)*(cphi*spsi*(i(1)*k(2)-j(2))+sphi*spsi*(i(1)*k(3)-j(3))+cpsi*(i(1)*k(4)-j(4)))\n!           pd=-1d0*pd\n!        endif\n!         write(6,*) 'pd: ',pd\n        return\n      end subroutine radtrans_jac_form_sph\n"}, {"instruction": "Create a Fortran subroutine named calc_delo_p_single that takes in 5 input parameters of type real(kind=8) and dimension, and outputs 1 parameter of type real(kind=8) and dimension. The input parameters are imatrix (4x4 array), f, g, sp (4-element array), and sp1 (4-element array). The subroutine calculates the value of p using matrix multiplication and arithmetic operations.", "input": "", "output": "      subroutine calc_delo_p_single(imatrix,f,g,sp,sp1,p)\n        real(kind=8), dimension(4,4), intent(in) :: imatrix\n        real(kind=8), intent(in) :: f,g\n        real(kind=8), intent(in), dimension(4) :: sp,sp1\n        real(kind=8), intent(out), dimension(4) :: p\n        p = matmul(imatrix,(f-g)*sp+g*sp1)\n      end subroutine calc_delo_p_single\n"}, {"instruction": "Write a Fortran subroutine named calc_delo_q_single that takes 6 input parameters of the following types: real(kind=8), dimension(4,4), real(kind=8), dimension(4,4), real(kind=8), dimension(4,4), real(kind=8), real(kind=8), real(kind=8). It also has 1 output parameter of type real(kind=8), dimension(4,4). The subroutine computes the matrix multiplication of imatrix and the difference between identity times e and g times kp1. Ensure that the subroutine is defined using Fortran syntax and features.", "input": "", "output": "      subroutine calc_delo_q_single(imatrix,e,f,g,kp1,identity,q)\n        real(kind=8), dimension(4,4), intent(in) :: imatrix,kp1,identity\n        real(kind=8), intent(in) :: e,f,g\n        real(kind=8), dimension(4,4), intent(out) :: q\n        q = matmul(imatrix,identity*e-g*kp1)\n      end subroutine calc_delo_q_single\n"}, {"instruction": "Create a Fortran subroutine named \"icount_this_\" to count the number of non-zero elements in an array. The input parameter is an array of integers, and the output parameter is the count of non-zero elements, both of type integer.", "input": "", "output": "      subroutine icount_this_ ( indx, n )\n      implicit none\n      integer, intent(in)  :: indx(:)\n      integer, intent(out) :: n\n      integer  i,m\n      m=size(indx,1)\n      n=0\n      do i = 1, m\n         if(indx(i)/=0) n=n+1 \n      enddo\n      end subroutine icount_this_\n"}, {"instruction": "Create a Fortran subroutine named submatrix_smdim to calculate the submatrix dimension based on the input metadim, meta, col, and cols. The subroutine takes 4 input parameters of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "        subroutine submatrix_smdim(metadim,meta,col,cols,smdim)\n        implicit none\n        integer(4),intent(in)   :: metadim,col,cols\n        integer(4),intent(in)   :: meta(metadim,metadim)\n        integer(4),intent(out)   :: smdim\n        integer(4)    :: map(metadim),j\n        integer(4)    :: imap(metadim),is,js,ib,jb,a,b,i,iatom,jatom\n        real(8)       :: svar\n        logical(4)  :: file_exists\n        character(len=100) :: str\n        character(len=100) :: arg\n\n        smdim=0\n        do i=1,metadim\n          do j=col,col+cols-1\n            if(meta(i,j).eq.1)then\n              smdim=smdim+1\n              exit\n            endif\n          enddo\n        enddo\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named getdays to calculate the total number of days from the given year and month. The subroutine should take 2 input parameters of type integer(kind=4) for year (yr) and month (mon), and 1 output parameter of type integer(kind=4) for the total number of days (days).", "input": "", "output": "  subroutine getdays(yr,mon,days)\n\n    !! global namespace\n    integer(kind=4), intent(in)  :: yr\n    integer(kind=4), intent(in)  :: mon\n    integer(kind=4), intent(out) :: days\n\n    !! local namespace\n    integer(kind=4) :: i\n    integer(kind=4) :: cyear\n    integer(kind=4) :: nextlp\n    integer(kind=4) :: yrdiff\n    integer(kind=4), parameter    :: baseyr = 1850\n    integer(kind=4), parameter    :: frstlp = 1852\n    integer(kind=4), dimension(4) :: mon30 = (/4,6,9,11/)\n    integer(kind=4), dimension(7) :: mon31 = (/1,3,5,7,8,10,12/)\n\n    !! make sure some things are cool\n    if (yr < 1850) then\n       stop \"calmod: error: date must be at least 1850.\"\n    end if\n\n    if (mon < 1 .or. mon > 12) then\n       stop \"calmod: error: number of month must be between 1-12.\"\n    end if\n    \n    days = 0\n    yrdiff = yr - baseyr\n    nextlp = frstlp\n    \n    !! first get the number of yearly days\n    do i = 1,yrdiff\n       if (cyear == nextlp) then\n          days = days + 366\n          nextlp = nextlp + 4\n       else\n          days = days + 365\n       end if\n       cyear = baseyr + i\n    end do\n\n    !! now get the number of days from months (not the last)\n    do i = 1,mon-1\n       if (any(mon30 == i)) then\n          days = days + 30\n       else if (any(mon31 == i)) then\n          days = days + 31\n       else if (i == 2) then\n          if (cyear == nextlp) then\n             days = days + 29\n          else\n             days = days + 28\n          end if\n       end if\n    end do\n             \n    return\n    \n  end subroutine getdays\n"}, {"instruction": "Create a Fortran subroutine named rtname to generate a file name for a restart file based on the given id number. The input parameter is of type integer, and the output parameter is of type character with a length of 80.", "input": "", "output": "subroutine rtname(id,fname)\n!\n! this sub creates a file name for a restart file\n!\nimplicit none\n!\ninteger, intent(in) :: id\ncharacter(len=80), intent(out) :: fname\n!\n! create the file name based on the id number\n!\nif(id.lt.   10.and.id.ge.   0) write(fname,1) id\nif(id.lt.  100.and.id.ge.  10) write(fname,2) id\nif(id.lt. 1000.and.id.ge. 100) write(fname,3) id\nif(id.lt.10000.and.id.ge.1000) write(fname,4) id\n!\n! format statements\n!\n1 format('output.lag.000',i1,'.vtu')\n2 format('output.lag.00' ,i2,'.vtu')\n3 format('output.lag.0'  ,i3,'.vtu')\n4 format('output.lag.'   ,i4,'.vtu')\n!\nreturn\n!\nend subroutine rtname\n"}, {"instruction": "Create a Fortran subroutine named \"simplex_projection\" to perform simplex projection on a vector. The subroutine takes 3 input parameters: an integer, a real*8, and a real*8 array of dimension n. The output parameter is a real*8 array of dimension n. The subroutine computes the simplex projection of the input vector and modifies the input vector in place to produce the output.", "input": "", "output": "    subroutine simplex_projection(x,z,d,n)\n    implicit none\n    integer,intent(in)::n\n    real*8,parameter::project_eps = 0.0\n    real*8,intent(in)::d\n    integer,dimension(n)::isselect\n    real*8,dimension(n),intent(in)::z\n    real*8,dimension(n),intent(out)::x\n    real*8::pivot\n    real*8:: sum_k,get_sum\n    real*8,dimension(n)::tempz\n    integer::i,now,pre,counter\n    logical st,loop\n    real*8 dnor\n    integer,dimension(n)::set_i\n    x=0.0\n    pivot=(sum(z)-d)/n\n    loop =  .true.\n    isselect = 1\n    counter = 0\n    do while(loop)\n        pre = sum(isselect)\n        isselect = 0\n        tempz=0\n        do i=1,n\n            if(z(i)>pivot+project_eps) then \n                isselect(i) = 1\n                tempz(i) = z(i)\n            end if\n        end do\n        pivot = (sum(tempz)-1+(n-sum(isselect))*project_eps)/sum(isselect)\n        if (sum(isselect).eq.pre) then \n            loop = .false.\n        else\n            loop = .true.\n        end if\n        counter=counter+1\n        if (counter>100) then \n            write(*,*)  \"warning: the projection method and can not get of loop\"\n            pause\n        end if \n    end do \n    do i =1, n\n        x(i) = max(z(i)-pivot,project_eps)\n    end do\n    return \n\n!     do i=1,n\n!     !\tx(i)=z(i)+(d-sum(z(:)))/(n*1.0)\n!         x(i)=z(i)+(d-get_sum(z(1:n),n))/(n*1.0)\n!     end do \n\t\t\n! 10\tset_i=0\n!     st=.true.\n!     sum_k=0.0\n!     do i=1,n\n!         !if (x(i)>0.0) then\n!         if (x(i) > project_eps) then\n!             set_i(i) = 1\n!             sum_k = sum_k + x(i)\n!         endif \n!         !if (x(i)<0.0) then \n!         if (x(i) < project_eps) then \n!             st =.false.\n!             sum_k = sum_k + project_eps\n!         end if \n!     end do\n!     if (st) then\n!         return\n!     end if \n!     dnor = (sum(set_i(:))*1d0)\n!     do i = 1,n\n!         if (set_i(i)==0) then \n!              !x(i)=0.0\n!             x(i) = project_eps\n!         else if (set_i(i) == 1) then \n!             x(i) = x(i) + (d-sum_k)/dnor\n!         end if \n!     end do \n!     go to 10 \n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named mpas_cross_product_in_r3 that calculates the cross product of two 3D vectors. The subroutine takes 2 input parameters of type real (kind=rkind) representing the two input vectors and 1 output parameter of type real (kind=rkind) representing the resulting cross product vector.", "input": "", "output": "subroutine mpas_cross_product_in_r3(p_1,p_2,p_out)!{{{\n  integer, parameter :: rkind  = selected_real_kind(12)\n  real (kind=rkind), intent(in) :: p_1 (3) !< input: vector 1\n  real (kind=rkind), intent(in) :: p_2 (3) !< input: vector 2\n  real (kind=rkind), intent(out) :: p_out (3) !< output: cross product of vector 1 and vector 2\n\n  p_out(1) = p_1(2)*p_2(3)-p_1(3)*p_2(2)\n  p_out(2) = p_1(3)*p_2(1)-p_1(1)*p_2(3)\n  p_out(3) = p_1(1)*p_2(2)-p_1(2)*p_2(1)\nend subroutine mpas_cross_product_in_r3!}}}\n"}, {"instruction": "Create a Fortran subroutine named compare_sp to compare two arrays of real numbers. The subroutine takes three input parameters of types real, allocatable, real, allocatable, and real, optional. It also has two output parameters of types integer and real.", "input": "", "output": "    subroutine compare_sp(ref, chk, diffcount, maxabsdiff, tol)\n    real, allocatable, intent(in)       :: ref(:), chk(:)\n    integer, intent(out)                :: diffcount\n    real, intent(out)                   :: maxabsdiff\n    real, optional, intent(in)          :: tol\n    \n    integer                             :: i, n\n    real                                :: wtol, diff\n    \n    diffcount = 0\n    maxabsdiff = 0.\n    n = size(ref, 1)\n    \n    if (n /= size(chk, 1)) then\n        diffcount = -1\n        return\n    end if\n    \n    wtol = tolerance\n    if (present(tol)) wtol = tol\n    \n    do i = 1, n\n        diff = abs(ref(i) - chk(i))\n        if (diff > wtol) then \n            diffcount = diffcount + 1\n            maxabsdiff = max(maxabsdiff, diff)\n        end if\n    end do\n    \n    end subroutine compare_sp\n"}, {"instruction": "Create a Fortran subroutine named chebydiff to perform Chebyshev differentiation in space using recursion. The subroutine should have 2 input parameters of type integer and double precision array with dimensions (0:nd-1), and 1 output parameter of double precision array with dimensions (0:nd-1). The subroutine should implement the Chebyshev differentiation algorithm as described in the code.", "input": "", "output": "  subroutine chebydiff(a,da,nd)\r\n!\r\n! differentiate in chebyshev space using the recursion\r\n!\r\n! t_{n+1}'   t_{n-1}'\r\n! -------  - -------    = 2t_n\r\n!  n+1         n-1 \r\n!\r\n  integer, intent(in) :: nd\r\n  double precision, dimension(0:nd-1), intent(in) :: a\r\n  double precision, dimension(0:nd-1), intent(out) :: da\r\n  integer :: k \r\n!\r\n  da=0.d0\r\n  da(nd-2)=dble(2*(nd-1))*a(nd-1)\r\n  do k=nd-3,1,-1\r\n    da(k)=dble(2*(k+1))*a(k+1)+da(k+2)\r\n  end do \r\n  da(0)=a(1)+da(2)/2.d0 \r\n!\r\n  end subroutine chebydiff \r\n"}, {"instruction": "Create a Fortran subroutine named i3da to perform integration in s, u, and v using trapezoid in s, u and a quadrature rule with weights wq in v. The number of input arguments is 5 with test_data types ['integer', 'integer', 'integer', 'double precision, dimension(0:ns-1,0:nu-1,0:nv)', 'double precision, dimension(0:nv)']. The number of output arguments is 1 with test_data type ['double precision'].", "input": "", "output": "  subroutine i3da(f,intf,wq,ns,nu,nv) \r\n!\r\n! integrate in s,u,v - trapezoid in s,u and a quadrature rule with\r\n! weights wq in v \r\n!\r\n  integer, intent(in) :: ns,nu,nv\r\n  double precision, dimension(0:ns-1,0:nu-1,0:nv), intent(in) :: f\r\n  double precision, intent(out) :: intf  \r\n  double precision, dimension(0:nv), intent(in) :: wq\r\n  double precision :: hs,hu\r\n  integer :: ks,ku,kv\r\n!\r\n  hs=2.d0*pi/dble(ns)\r\n  hu=2.d0*pi/dble(nu)\r\n  intf=0.d0\r\n  do kv=0,nv\r\n    do ku=0,nu-1\r\n      do ks=0,ns-1\r\n        intf=intf+wq(kv)*f(ks,ku,kv)\r\n      end do\r\n    end do\r\n  end do\r\n!\r\n  intf=intf*hs*hu\r\n!\r\n  end subroutine i3da\r\n"}, {"instruction": "Create a Fortran subroutine named legendrep to evaluate the standard Legendre polynomial of degrees 0 to n. The subroutine takes 3 input parameters, with the test_data types ['integer', 'integer', 'double precision, dimension(m)'], and 1 output parameter with the test_data type ['double precision, dimension(m,0:n)']. Use the imperative tone in your implementation.", "input": "", "output": "  subroutine legendrep(p,x,n,m)\r\n!\r\n! evaluate the standard legendre polynomial of degrees 0:n\r\n!\r\n  integer, intent(in) :: n,m\r\n  double precision, dimension(m), intent(in) :: x\r\n  double precision, dimension(m,0:n), intent(out) :: p\r\n  integer :: k,j\r\n!\r\n  do j=1,m\r\n    p(j,0)=1.d0\r\n  end do\r\n!\r\n  if (n > 0) then\r\n!\r\n  do j=1,m\r\n    p(j,1)=x(j)\r\n  end do\r\n!\r\n  if (n > 1) then\r\n!\r\n  do k=2,n\r\n    do j=1,m\r\n      p(j,k)=(dble(2*k-1)*x(j)*p(j,k-1)-dble(k-1)*p(j,k-2))/dble(k)\r\n    end do\r\n  end do\r\n!\r\n  end if\r\n!\r\n  end if\r\n!\r\n  end subroutine legendrep \r\n"}, {"instruction": "Create a Fortran subroutine named simple_function. It takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter s is used to compute the output parameter res, which is the result of multiplying s by 10.", "input": "", "output": "subroutine simple_function(s,res)\n  implicit none\n  integer, intent(in) :: s   ! s is an input parameter\n                             ! it cannot be modified\n  integer,intent(out) :: res ! res is an output parameter\n\n  res = 10*s\nend subroutine simple_function\n"}, {"instruction": "Create a Fortran subroutine named invtranspose to calculate the inverse transpose of a 4x4 matrix. The subroutine takes 1 input parameter of type double precision. It returns 2 output parameters, one of type double precision and one of type logical.", "input": "", "output": "    subroutine invtranspose(m, minv, ok_flag)\n\n        implicit none\n\n        double precision, intent(in)  :: m(4,4)\n        double precision, intent(out) :: minv(4,4)\n        logical,          intent(out) :: ok_flag\n\n        double precision, parameter :: eps = 1.0d-10\n        double precision            :: det, cofactor(4,4)\n\n\n        det =  m(1,1)*(m(2,2)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(2,4)*(m(3,2)*m(4,3)- &\n               m(3,3)*m(4,2)))-m(1,2)*(m(2,1)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+ &\n               m(2,4)*(m(3,1)*m(4,3)-m(3,3)*m(4,1)))+m(1,3)*(m(2,1)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(2,2)*(m(3,4)*m(4,1)- &\n               m(3,1)*m(4,4))+m(2,4)*(m(3,1)*m(4,2)-m(3,2)*m(4,1)))-m(1,4)*(m(2,1)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))+ &\n               m(2,2)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))+m(2,3)*(m(3,1)*m(4,2)-m(3,2)*m(4,1)))\n\n        if(abs(det) <= eps)then\n            minv = 0.0d0\n            ok_flag = .false.\n            return\n        end if\n\n    cofactor(1,1) = m(2,2)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(2,4)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))\n    cofactor(1,2) = m(2,1)*(m(3,4)*m(4,3)-m(3,3)*m(4,4))+m(2,3)*(m(3,1)*m(4,4)-m(3,4)*m(4,1))+m(2,4)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))\n    cofactor(1,3) = m(2,1)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(2,2)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+m(2,4)*(m(3,1)*m(4,2)-m(3,2)*m(4,1))\n    cofactor(1,4) = m(2,1)*(m(3,3)*m(4,2)-m(3,2)*m(4,3))+m(2,2)*(m(3,1)*m(4,3)-m(3,3)*m(4,1))+m(2,3)*(m(3,2)*m(4,1)-m(3,1)*m(4,2))\n    cofactor(2,1) = m(1,2)*(m(3,4)*m(4,3)-m(3,3)*m(4,4))+m(1,3)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(1,4)*(m(3,3)*m(4,2)-m(3,2)*m(4,3))\n    cofactor(2,2) = m(1,1)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(1,3)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+m(1,4)*(m(3,1)*m(4,3)-m(3,3)*m(4,1))\n    cofactor(2,3) = m(1,1)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(1,2)*(m(3,1)*m(4,4)-m(3,4)*m(4,1))+m(1,4)*(m(3,2)*m(4,1)-m(3,1)*m(4,2))\n    cofactor(2,4) = m(1,1)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))+m(1,2)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))+m(1,3)*(m(3,1)*m(4,2)-m(3,2)*m(4,1))\n    cofactor(3,1) = m(1,2)*(m(2,3)*m(4,4)-m(2,4)*m(4,3))+m(1,3)*(m(2,4)*m(4,2)-m(2,2)*m(4,4))+m(1,4)*(m(2,2)*m(4,3)-m(2,3)*m(4,2))\n    cofactor(3,2) = m(1,1)*(m(2,4)*m(4,3)-m(2,3)*m(4,4))+m(1,3)*(m(2,1)*m(4,4)-m(2,4)*m(4,1))+m(1,4)*(m(2,3)*m(4,1)-m(2,1)*m(4,3))\n    cofactor(3,3) = m(1,1)*(m(2,2)*m(4,4)-m(2,4)*m(4,2))+m(1,2)*(m(2,4)*m(4,1)-m(2,1)*m(4,4))+m(1,4)*(m(2,1)*m(4,2)-m(2,2)*m(4,1))\n    cofactor(3,4) = m(1,1)*(m(2,3)*m(4,2)-m(2,2)*m(4,3))+m(1,2)*(m(2,1)*m(4,3)-m(2,3)*m(4,1))+m(1,3)*(m(2,2)*m(4,1)-m(2,1)*m(4,2))\n    cofactor(4,1) = m(1,2)*(m(2,4)*m(3,3)-m(2,3)*m(3,4))+m(1,3)*(m(2,2)*m(3,4)-m(2,4)*m(3,2))+m(1,4)*(m(2,3)*m(3,2)-m(2,2)*m(3,3))\n    cofactor(4,2) = m(1,1)*(m(2,3)*m(3,4)-m(2,4)*m(3,3))+m(1,3)*(m(2,4)*m(3,1)-m(2,1)*m(3,4))+m(1,4)*(m(2,1)*m(3,3)-m(2,3)*m(3,1))\n    cofactor(4,3) = m(1,1)*(m(2,4)*m(3,2)-m(2,2)*m(3,4))+m(1,2)*(m(2,1)*m(3,4)-m(2,4)*m(3,1))+m(1,4)*(m(2,2)*m(3,1)-m(2,1)*m(3,2))\n    cofactor(4,4) = m(1,1)*(m(2,2)*m(3,3)-m(2,3)*m(3,2))+m(1,2)*(m(2,3)*m(3,1)-m(2,1)*m(3,3))+m(1,3)*(m(2,1)*m(3,2)-m(2,2)*m(3,1))\n\n        minv = transpose(cofactor) / det\n\n        ok_flag = .true.\n\n    end subroutine invtranspose\n"}, {"instruction": "Create a Fortran subroutine named pix2ang_ring to calculate the theta and phi coordinates of the nominal pixel center for a given pixel number in the ring scheme, based on the map resolution parameter nside. The subroutine takes 2 input parameters of type integer(kind=4) and returns 2 output parameters of type real(kind=8). The subroutine utilizes conditional statements to determine the pixel location and then computes the corresponding theta and phi coordinates. The subroutine concludes by setting theta to halfpi minus the computed value.", "input": "", "output": "  subroutine pix2ang_ring(nside, ipix, phi, theta)\n    !=======================================================================\n    !     renders theta and phi coordinates of the nominal pixel center\n    !     for the pixel number ipix (ring scheme)\n    !     given the map resolution parameter nside\n    !=======================================================================\n    integer(kind=4), intent(in) :: ipix, nside\n    real(kind=8), intent(out) ::  theta, phi\n\n    integer(kind=4) ::  nl2, nl4, npix, ncap, iring, iphi, ip, ipix1\n    real(kind=8) ::  fodd, hip, fihip\n    !-----------------------------------------------------------------------\n    if (nside<1 .or. nside>ns_max) stop \"nside out of range\"\n    npix = 12*nside**2       ! total number of points\n    if (ipix <0 .or. ipix>npix-1) stop \"ipix out of range\"\n\n    ipix1 = ipix + 1 ! in {1, npix}\n    nl2 = 2*nside\n    ncap = 2*nside*(nside-1) ! points in each polar cap, =0 for nside =1\n\n    if (ipix1 <= ncap) then ! north polar cap -------------\n\n       hip   = ipix1*0.5_8\n       fihip = aint ( hip , kind=8)\n       iring = int( sqrt( hip - sqrt(fihip) ) ) + 1 ! counted from north pole\n       iphi  = ipix1 - 2*iring*(iring - 1)\n\n       theta = acos( 1.0_8 - iring**2 / (3.0_8*nside**2) )\n       phi   = (real(iphi,8) - 0.5_8) * pi/(2.0_8*iring)\n\n    elseif (ipix1 <= nl2*(5*nside+1)) then ! equatorial region ------\n\n       ip    = ipix1 - ncap - 1\n       nl4   = 4*nside\n       iring = int( ip / nl4 ) + nside ! counted from north pole\n       iphi  = modulo(ip,nl4) + 1\n\n       fodd  = 0.5_8 * (1 + modulo(iring+nside,2))  ! 1 if iring+nside is odd, 1/2 otherwise\n       theta = acos( (nl2 - iring) / (1.5_8*nside) )\n       phi   = (real(iphi,8) - fodd) * pi /(2.0_8*nside)\n\n    else ! south polar cap -----------------------------------\n\n       ip    = npix - ipix1 + 1\n       hip   = ip*0.5_8\n       fihip = aint ( hip , kind=8)\n       iring = int( sqrt( hip - sqrt(fihip) ) ) + 1     ! counted from south pole\n       iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1))\n\n       theta = acos( -1.0_8 + iring**2 / (3.0_8*nside**2) )\n       phi   = (real(iphi,8) - 0.5_8) * pi/(2.0_8*iring)\n\n    endif\n    \n\ttheta=halfpi-theta \n\n    return\n  end subroutine pix2ang_ring ! pix2ang_ring\n"}, {"instruction": "Create a Fortran subroutine named conv_hist3d to compute a 3D histogram from input data. The subroutine takes 3 input parameters: a 2D array of real numbers, an optional 1D array of real numbers, and an integer. It produces 2 output parameters: a 3D array of real numbers and an optional 2D array of real numbers.", "input": "", "output": "  subroutine conv_hist3d(data, nbin, weights, hist, edges)\n    real(kind=8), dimension(:,:), intent(in) :: data !! data(ndim, nparts)\n    real(kind=8), dimension(size(data, 2)), &\n         intent(in), optional            :: weights ! weights(nparts)\n    integer, intent(in)                  :: nbin\n\n    real(kind=8), dimension(nbin, nbin, nbin), intent(out)    :: hist\n    real(kind=8), dimension(3, nbin+1), intent(out), optional :: edges\n\n    real(kind=8), dimension(3) :: maxis, minis, spans\n\n    integer :: i, j, k, part_i, ndim, nparts\n\n    ! get the dimensions\n    ndim = size(data, 1)\n    nparts = size(data, 2)\n    ! compute the edges\n    maxis = maxval(data, 2)\n    minis = minval(data, 2)\n    spans = maxis - minis\n\n    do i = 1, nbin + 1\n       edges(:, i) = minis + (maxis - minis) * (i-1) / nbin\n    end do\n    print*, minis, maxis\n\n    print*, nparts\n    ! project the data onto the edges\n    do part_i = 1, nparts\n       ! get the position in the grid\n       i = floor((data(1, part_i) - minis(1)) * nbin / spans(1)) + 1\n       j = floor((data(2, part_i) - minis(2)) * (nbin * 1d0) / spans(2)) + 1\n       k = floor((data(3, part_i) - minis(3)) * nbin / spans(3)) + 1\n\n       ! because of rounding errors, the maxima aren't well found,\n       ! fix that\n       if (data(1, part_i) == maxis(1)) i = nbin\n       if (data(2, part_i) == maxis(2)) j = nbin\n       if (data(3, part_i) == maxis(3)) k = nbin\n\n       ! print*, i,j,k\n       ! todo: linear approximation of density\n       ! increment the histogram\n       if ((i <= 0) .or. (i > nbin) .or. (j <= 0) .or. (j > nbin) .or.&\n            (k <= 0) .or. (k > nbin)) then\n          print*, 'dafuk ?!'\n          print*, (data(:, part_i) - maxis) == 0\n          print*, i, j, k\n       end if\n\n       if (present(weights)) then\n          hist(i, j, k) = hist(i, j, k) + weights(part_i)\n       else\n          hist(i, j, k) = hist(i, j, k) + 1\n       end if\n    end do\n\n    print*, nparts, ndim\n  end subroutine conv_hist3d\n"}, {"instruction": "Create a Fortran subroutine named conv_density to calculate the density distribution of particles in a 3D space. The subroutine takes 2 input parameters: data of type real(kind=8), dimension(:,:), and nbin of type integer. It has 2 output parameters: dens of type real(kind=8), dimension(nbin, nbin, nbin), and edges of type real(kind=8), dimension(3, nbin+1), which is optional.", "input": "", "output": "  subroutine conv_density(data, nbin, dens, edges)\n    real(kind=8), dimension(:,:), intent(in) :: data !! data(ndim, nparts)\n    integer, intent(in)                      :: nbin\n\n    real(kind=8), dimension(nbin, nbin, nbin), intent(out)   :: dens\n    real(kind=8), dimension(3, nbin+1), intent(out), optional:: edges\n\n    real(kind=8), dimension(3) :: maxis, minis, spans\n\n    integer :: i, j, k, part_i, ndim, nparts, i0, j0, k0, imax, jmax, kmax, imin, jmin, kmin\n    real(kind=8) :: ri, rj, rk\n\n    ! get the dimensions\n    ndim = size(data, 1)\n    nparts = size(data, 2)\n    ! compute the bins\n    maxis = maxval(data, 2)\n    minis = minval(data, 2)\n\n    spans = (maxis - minis)\n\n    do i = 1, nbin + 1\n       edges(:, i) = minis + spans * (i-1) / nbin\n    end do\n\n    ! project the data onto the bins\n    do part_i = 1, nparts\n       ! get the position in the grid\n       ri = (data(1, part_i) - minis(1)) * nbin / spans(1) + 0.5\n       rj = (data(2, part_i) - minis(2)) * nbin / spans(2) + 0.5\n       rk = (data(3, part_i) - minis(3)) * nbin / spans(3) + 0.5\n\n       ! the max and min are actually only half in leftmost/rightmost bin\n       ! so the min has ri =  0.5\n       ! and the max has ri = nbin + 0.5\n\n       i0 = floor(ri)\n       j0 = floor(rj)\n       k0 = floor(rk)\n\n       imin = max(1, i0)\n       jmin = max(1, j0)\n       kmin = max(1, k0)\n\n       imax = min(nbin, i0 + 1)\n       jmax = min(nbin, j0 + 1)\n       kmax = min(nbin, k0 + 1)\n\n       do k = kmin, kmax\n          do j = jmin, jmax\n             do i = imin, imax\n                ! add the proportion of the particle in the box\n                dens(i, j, k) = dens(i, j, k) + abs((ri - i)*(rj - j)*(rk - k))\n             end do\n          end do\n       end do\n    end do\n\n    ! convert the number density into a mass density (assuming uniform mass)\n    ! todo: don't assume uniform mass\n    dens = dens * nbin**3 / product(maxis-minis)\n\n  end subroutine conv_density\n"}, {"instruction": "Write a Fortran subroutine named findisi to calculate the interspike intervals from a given set of input data. The input parameter is of type real*8 and intent(in), while the output parameter is of type real*8, allocatable and intent(out).", "input": "", "output": "    subroutine findisi(x, isi)\n        real*8, intent(in) :: x(:)\n        real*8, allocatable, intent(out) :: isi(:)\n        real*8, allocatable :: isidata(:)\n        integer :: i, k, iplus, crosscounter\n        real*8 :: t1, t2, ts, tsa\n\n        t1 = 0\n        t2 = 0\n        ts = 0\n        tsa = 0\n        crosscounter = 0\n        n = size(x, 1) - 1\n        allocate(isidata(1:n)) ! alocando n valores para os isi\n        i = 1\n        do while (x(i) > 0.0d0) ! garantindo que o loop principal come\u00e7ara com x(i)<0\n            i = i + 1\n        end do\n        k = 1\n        do while (i <= n) ! loop principal\n            iplus = i + 1\n            if (x(i) * x(iplus) < 0) then ! cruzou o eixo x = 0\n                if (modulo(crosscounter,2) == 0) then ! como come\u00e7ou abaixo de x = 0, crosscounter par significa subindo\n                    t1 = (dble(i) + dble(iplus)) / 2.0d0\n                else ! crosscounter impar significa descendo\n                    t2 = (dble(i) + dble(iplus)) / 2.0d0\n                    ts = (t1 + t2) / 2.0d0\n                    isidata(k) = ts - tsa\n                    tsa = ts\n                    k = k + 1\n                end if\n                crosscounter = crosscounter + 1\n            end if\n            i = i + 1\n        end do\n        k = k - 1 ! k = total de isi encontraldos\n        allocate(isi(1:(k-1)))\n        isi = isidata(2:k)\n    end subroutine findisi\n"}, {"instruction": "Create a Fortran subroutine named evalk to evaluate a function based on the input parameter. The subroutine takes 1 input parameter of type real(kind=8) and 1 output parameter of type real(kind=8). If the input parameter is greater than or equal to 0, the output parameter is set to 1.0; otherwise, the output parameter is computed based on a specific formula.", "input": "", "output": "subroutine evalk (p, k)\n  real(kind=8), intent(in)  :: p\n  real(kind=8), intent(out) :: k\n  if (p >= 0.0) then\n     k = 1.0\n  else\n     k = 1.0/(1+p**2)\n  end if\nend subroutine evalk\n"}, {"instruction": "Create a Fortran subroutine named proma4 that computes the product of two matrices. It takes 5 input parameters: three 4-byte integers (n1, n2, n3), and two double-precision real arrays (b and c), and produces one output parameter, a double-precision real array a. The subroutine evaluates the matrix product a = b * c where a, b, and c are matrices of appropriate dimensions.", "input": "", "output": "      subroutine proma4(a,b,c,n1,n2,n3)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix product\r\n!                                            t\r\n!           a(i,j) = b(k,i) * c(k,j)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n2,n3\r\n      real (kind=8),intent(in) :: b(1:n3,1:n1), c(1:n3,1:n3)\r\n      real (kind=8),intent(out) :: a(1:n1,1:n3)\r\n\r\n      a(1:n1,1:n2) = matmul( transpose(b(1:n3,1:n1)), c(1:n3,1:n2) )\r\n      return\r\n\r\n      end subroutine proma4\r\n"}, {"instruction": "Create a Fortran subroutine named get_vdw_ref_params to retrieve van der Waals reference parameters for a given chemical element and rank. The subroutine takes 2 input parameters of type character*8 and integer, and returns 3 output parameters of type real*8. The subroutine calculates and assigns the van der Waals reference parameters based on the provided chemical element and rank. If the default parameters are not available for the given element, a warning message is displayed.", "input": "", "output": "  subroutine get_vdw_ref_params(element, c6, r0, alpha0, rank)\n\n    implicit none\n\n    character*8, intent(in) :: element\n    integer, intent(in) :: rank\n    real*8, intent(out) :: c6, r0, alpha0\n    real*8 :: hartree = 27.211386024367243d0, bohr = 0.5291772105638411d0\n\n    c6 = 0.d0\n    r0 =  0.d0\n    alpha0 = 0.d0\n\n!   these should be in the correct units (enegy in ev, distances in angstrom)\n\n\n    if( element == \"h\" )then\n!     this is the value provided by vasp, for which they give \"private comm.\"\n!     as reference in the ts implementation paper:\n      r0 = 1.64d0\n!     these values are given by chu and dalgarno (j chem phys 121, 4083 [2004])\n      alpha0 = 4.5d0 * bohr**3\n      c6 = 6.5d0 * hartree * bohr**6\n    else if( element == \"c\" )then\n!     this is the value provided by vasp, for which they give \"private comm.\"\n!     as reference in the ts implementation paper:\n      r0 = 1.900d0\n!     this is the one given by grimme (j comput chem 27, 1787 [2006]):\n!      r0 = 1.452d0\n!     these values are given by chu and dalgarno (j chem phys 121, 4083 [2004])\n      alpha0 = 12.d0 * bohr**3\n      c6 = 46.6d0 * hartree * bohr**6\n    else\n      if( rank == 0 )then\n        write(*,*)'                                       |'\n        write(*,*)'warning: default vdw reference parame- |'\n        write(*,*)'ters not available for element:        |'\n        write(*,*)'                                       |'\n        write(*,'(1x,a8,a)') element, '                               |'\n        write(*,*)'                                       |'\n        write(*,*)'you can safely disregard this warning  |'\n        write(*,*)'if your potential does not use van der |'\n        write(*,*)'waals corrections. otherwise, or if you|'\n        write(*,*)'want to overrride the defaults, you    |'\n        write(*,*)'need to provide your own definitions of|'\n        write(*,*)'vdw_c6_ref, vdw_r0_ref and             |'\n        write(*,*)'vdw_alpha0_ref in the input file.      |'\n        write(*,*)'                                       |'\n        write(*,*)'.......................................|'\n      end if\n    end if\n\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named direct to calculate the observer distance and directivity angles for a given set of input parameters. The subroutine takes 9 input parameters of type integer, real(dp), and real(dp) arrays of dimension n, and returns 3 output parameters, each of type real(dp) arrays of dimension n.", "input": "", "output": "subroutine direct(n,xt,yt,zt,c,c1,d,hub,beta,r,theta_e,phi_e)\r\n  implicit none\r\n  integer, parameter :: dp = kind(0.d0)\r\n  ! in\r\n  integer, intent(in) :: n\r\n  real(dp), intent(in) :: xt,yt,zt,hub,beta\r\n  real(dp), dimension(n), intent(in) :: c,c1,d\r\n  ! out\r\n  real(dp), dimension(n), intent(out) :: r,theta_e,phi_e\r\n  ! local\r\n  integer :: i,sign\r\n  real(dp) :: pi,xo,yo,zo,xs,zs,xe_d,ze_d,theta,xe,ze,phi_er\r\n  real(dp), dimension(n) :: c2\r\n  intrinsic sin\r\n  intrinsic cos\r\n  intrinsic atan2\r\n  intrinsic sqrt\r\n  intrinsic abs\r\n  ! constants\r\n  pi = 3.1415926535897932_dp\r\n\r\n  ! distance from pitch-axis to trailing edge\r\n  c2(1:n) = c(1:n)-c1(1:n)\r\n\r\n  ! calculating observer location from hub\r\n  xo = xt ! lateral direction\r\n  yo = yt ! downstream direction\r\n  zo = zt-hub ! height direction\r\n\r\n  do i=1,n\r\n    ! calculating trailing edge position from hub\r\n    xs = sin(beta)*d(i)-cos(beta)*c2(i)\r\n    zs = cos(beta)*d(i)+sin(beta)*c2(i)\r\n\r\n    ! calculating observer position from trailing edge\r\n    xe_d = xo-xs\r\n    ze_d = zo-zs\r\n\r\n    ! rotating observer position with repsect to beta\r\n    theta = pi-beta\r\n    xe = cos(theta)*xe_d+sin(theta)*ze_d\r\n    ze = -sin(theta)*xe_d+cos(theta)*ze_d\r\n\r\n    ! calculating observer distance and directivity angles\r\n    r(i) = sqrt(yo**2+xe**2+ze**2)\r\n    theta_e(i) = atan2(sqrt(yo**2+ze**2),xe)\r\n    phi_e(i) = atan2(yo,ze)\r\n\r\n    ! quadratic smoothing when phi_e is close to 0 or 180 degrees\r\n    if (abs(phi_e(i)) < 5.0_dp*pi/180.0_dp) then\r\n      if (phi_e(i) >= 0.0_dp) then\r\n        sign = 1\r\n      else\r\n        sign = -1\r\n      end if\r\n      phi_er = abs(phi_e(i))*180.0_dp/pi\r\n      phi_er = 0.1_dp*phi_er**2+2.5_dp\r\n      phi_e(i) = sign*phi_er*pi/180.0_dp\r\n    else if (abs(phi_e(i)) > 175.0_dp*pi/180.0_dp) then\r\n      if (phi_e(i) >= 0.0_dp) then\r\n        sign = 1\r\n      else\r\n        sign = -1\r\n      end if\r\n      phi_er = abs(phi_e(i))*180.0_dp/pi\r\n      phi_er = -0.1_dp*(phi_er-180.0_dp)**2+177.5_dp\r\n      phi_e(i) = sign*phi_er*pi/180.0_dp\r\n    end if\r\n\r\n  end do\r\n\r\nend subroutine direct\r\n"}, {"instruction": "Write a Fortran subroutine named easter to calculate the date of Easter (Sunday) using the algorithm by J.-M. Oudin (1940) and reprinted in the explanatory supplement to the astronomical almanac. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer.", "input": "", "output": "subroutine easter(year, day, month)\r\n! u.s. naval observatory astronomical applications department\r\n\r\n!            the date of easter (sunday)\r\n\r\n! the algorithm is due to j.-m. oudin (1940) and is reprinted in the explanatory\r\n! supplement to the astronomical almanac, ed. p. k. seidelmann (1992).\r\n! see chapter 12, \"calendars\", by l. e. doggett.\r\n\r\n! the following are dates of easter from 1980 to 2024:\r\n\r\n! 1980  april  6        1995  april 16        2010  april  4\r\n! 1981  april 19        1996  april  7        2011  april 24\r\n! 1982  april 11        1997  march 30        2012  april  8\r\n! 1983  april  3        1998  april 12        2013  march 31\r\n! 1984  april 22        1999  april  4        2014  april 20\r\n! 1985  april  7        2000  april 23        2015  april  5\r\n! 1986  march 30        2001  april 15        2016  march 27\r\n! 1987  april 19        2002  march 31        2017  april 16\r\n! 1988  april  3        2003  april 20        2018  april  1\r\n! 1989  march 26        2004  april 11        2019  april 21\r\n! 1990  april 15        2005  march 27        2020  april 12\r\n! 1991  march 31        2006  april 16        2021  april  4\r\n! 1992  april 19        2007  april  8        2022  april 17\r\n! 1993  april 11        2008  march 23        2023  april  9\r\n! 1994  april  3        2009  april 12        2024  march 31\r\n\r\n! n.b. the date of easter for the eastern orthodox church may be different.\r\n\r\n! this code assembled by alan miller\r\n! reference web site:\r\n! http://aa.usno.navy.mil/faq/docs/easter.html\r\n! latest revision 8 april 2002\r\n\r\nimplicit none\r\ninteger, intent(in)   :: year\r\ninteger, intent(out)  :: day, month\r\n\r\n! local variables\r\ninteger  :: c, i, j, k, l, n\r\n\r\nc = year / 100\r\nn = year - 19 * ( year / 19 )\r\nk = ( c - 17 ) / 25\r\ni = c - c / 4 - ( c - k ) / 3 + 19 * n + 15\r\ni = i - 30 * ( i / 30 )\r\ni = i - (i / 28) * (1 - (i / 28) * (29 / (i + 1 )) * ( (21 - n) / 11) )\r\nj = year + year / 4 + i + 2 - c + c / 4\r\nj = j - 7 * ( j / 7 )\r\nl = i - j\r\nmonth = 3 + ( l + 40 ) / 44\r\nday = l + 28 - 31 * ( month / 4 )\r\n\r\nreturn\r\nend subroutine easter\r\n"}, {"instruction": "Write a Fortran subroutine named vcd to calculate the values of zvcd based on the input arrays zz and zmaj. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 1 output parameter of type real. The subroutine should be intended to be used imperatively.", "input": "", "output": "    subroutine vcd(zz,zmaj,zvcd,jmax,nmaj)\n\n      implicit none\n\n      integer,intent(in) :: jmax,nmaj\n      real,intent(in) :: zz(jmax), zmaj(nmaj,jmax)\n\n      real,intent(out) :: zvcd(nmaj,jmax)\n\n      integer :: i, j\n      real :: rat\n\n      do i=1,nmaj\n        zvcd(i,jmax) =   zmaj(i,jmax) &\n                       * (zz(jmax)-zz(jmax-1)) &\n                       / alog(zmaj(i,jmax-1)/zmaj(i,jmax))\n        do j=jmax-1,1,-1\n          rat = zmaj(i,j+1) / zmaj(i,j)\n          zvcd(i,j) = zvcd(i,j+1)+zmaj(i,j)*(zz(j)-zz(j+1))/alog(rat)*(1.-rat)\n        enddo\n      enddo\n\n      return\n\n    end subroutine vcd\n"}, {"instruction": "Create a Fortran subroutine named \"a\" that takes two integer input parameters. The input parameters should be declared using the \"intent(in)\" attribute. The subroutine should have one output parameter of type integer, declared using the \"intent(out)\" attribute.", "input": "", "output": "subroutine a(x, y, o)\nimplicit none\n  ! these are input args\n        integer, intent(in) :: x, y ! <- we describe them here\ninteger, intent(out) :: o\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named short_wave_radiation to calculate shortwave radiation values based on given atmospheric and location parameters. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type real: sro and sron.", "input": "", "output": "  subroutine short_wave_radiation(cld,sro,sron) \n    ! ************************************************************************\n    ! **                 s h o r t  w a v e  r a d i a t i o n              **\n    ! **                      from ce-qual-w2 (ver 3.1)                     **\n    ! ************************************************************************\n\n    ! ******* type declaration\n    real, intent(in)    ::  cld \n    real, intent(out)   :: sro, sron\n    integer   :: iday \n    real      :: jday\n    real      :: standard, thour, pmc1, eqtnew, h, decl, sinal, a0, cld10\n  \n    ! ******* input conversions\n    cld10 = cld*10.                ! *** convert from 0-1 (efdc) to 0-10 (w2)\n\n    ! ******* shortwave radiation\n    standard = 15.0*int(ds_long/15.0)\n\n    ! *** day of the year\n    thour    = (timeday-int(timeday))*24.0\n    iday     =  timeday-int(timeday/365.)*365.\n    iday     =  iday+int(int(timeday/365.)/4.)\n    jday     = real(iday)\n    pmc1     = (2.*pi*(jday-1.))/365.\n    eqtnew   =  0.170*sin(4.*pi*(jday-80.)/373.)-0.129*sin(2.*pi*(jday-8.)/355.)\n    h     = 0.2618*(thour-(ds_long-standard)*0.066667+eqtnew-12.0)\n    decl =  0.006918-0.399912*cos(pmc1)  +0.070257*sin(pmc1)-0.006758*cos(2*pmc1)+0.000907*sin(2*pmc1)-0.002697*cos(3*pmc1)+0.001480*sin(3*pmc1)\n    sinal = sin(ds_lat*.017453)*sin(decl)+cos(ds_lat*.017453)*cos(decl)*cos(h)\n    a0    = 57.2958*asin(sinal)\n    \n    if( a0 > 0.0 )then\n      sro  = 2.044*a0+0.1296*a0**2-1.941e-3*a0**3+7.591e-6*a0**4\n      sro  = (1.0-0.0065*cld10**2)*sro*24.0\n      sro  = sro*btu_ft2_day_to_w_m2\n      sron = sro*(1.-refl)                    ! *** adjust for surface reflection\n    else\n      sro  = 0.0\n      sron = 0.0\n    end if\n       \n    return\n    \n  end subroutine short_wave_radiation\n"}, {"instruction": "Write a Fortran subroutine named equilibrium_temperature that takes 4 real input parameters (wspd, td, tair, sron) and returns 2 real output parameters (et, cshe). The subroutine computes the equilibrium temperature and heat exchange coefficient using various conversions and calculations.", "input": "", "output": "  subroutine equilibrium_temperature(wspd, td, tair, sron, et, cshe) \n    !************************************************************************\n    !**             e q u i l i b r i u m  t e m p e r a t u r e           **\n    !**                      from ce-qual-w2 (ver 3.1)                     **\n    !************************************************************************\n\n    ! ******* type declaration\n    real, intent(in)    :: wspd, td, tair, sron \n    real, intent(out)   :: et, cshe\n    real      :: tdew_f, tair_f, wind_2m \n    real      :: wind_mph\n    real      :: sro_br, tstar, beta, fw, ra, etp\n  \n    integer :: j  \n\n    ! ******* input conversions\n\n    ! ******* british units\n    tdew_f   = td*1.8+32.0\n    tair_f   = tair*1.8+32.0\n    wind_mph = wspd*mps_to_mph\n    wind_2m  = wind_mph         ! *** ee7.3 and later apply correction to all winds\n    wind_2m = max(wind_2m, 1.)  ! pmc - apply a minumum to allow surface heat exchange even with calm conditions\n\n    ! *** sron should already be adjusted for shading & reflection\n    sro_br   = sron*w_m2_to_btu_ft2_day \n\n    ! ******* equilibrium temperature and heat exchange coefficient\n    \n    et    = tdew_f\n    tstar = (et+tdew_f)*0.5\n    beta  = 0.255-(8.5e-3*tstar)+(2.04e-4*tstar*tstar)\n    fw    = w_m2_to_btu_ft2_day*afw+bconv*bfw*wind_2m**cfw\n    cshe  = 15.7+(0.26+beta)*fw\n    ra    = 3.1872e-08*(tair_f+459.67)**4\n    etp   = (sro_br+ra-1801.0)/cshe+(cshe-15.7)*(0.26*tair_f+beta*tdew_f)/(cshe*(0.26+beta))\n    j     = 0\n    do while (abs(etp-et) > 0.05 .and. j < 10)\n      et    = etp\n      tstar = (et+tdew_f)*0.5\n      beta  = 0.255-(8.5e-3*tstar)+(2.04e-4*tstar*tstar)\n      cshe  = 15.7+(0.26+beta)*fw\n      etp   = (sro_br+ra-1801.0)/cshe+(cshe-15.7)*(0.26*tair_f+beta*tdew_f)/(cshe*(0.26+beta))\n      j     = j+1\n    end do\n\n    ! ******* si units\n\n    ! *** rhowcpi = 1/rho/cp = 0.2393e-6\n    et   = (et-32.0)*5.0/9.0                 ! *** deg c\n    cshe = cshe*flux_br_to_flux_si*rhowcpi   ! *** m/s\n\n  end subroutine equilibrium_temperature\n"}, {"instruction": "Create a Fortran subroutine named \"boolfromfile\" that reads logical values from a file specified by the input parameter \"filename\" of type character(len=80) and stores them in the output array \"x\" of type logical(kind=4). The subroutine should read up to 20000 logical values from the file and store them in the output array \"x\".", "input": "", "output": "subroutine boolfromfile(filename,x)\n  implicit none\n  character(len=80), intent(in) :: filename   ! input\n  logical(kind=4), intent(out)  :: x(20000)   ! output\n\n  integer :: nrows=20000\n  integer :: i\n\n  open(unit=11, file=filename, action=\"read\")\n  do  i = 1, nrows\n    read(11,*)  x(i)\n  end do\n  close(unit=11)\n\nend subroutine boolfromfile\n"}, {"instruction": "Create a Fortran subroutine named how_many_extra_history_header_items to determine the number of additional history header items based on the given IDs. The subroutine takes 2 input parameters of type integer, id and id_extra. It returns 1 output parameter of type integer, num_cols.", "input": "", "output": "      subroutine how_many_extra_history_header_items(id, id_extra, num_cols)\n      integer, intent(in) :: id, id_extra\n      integer, intent(out) :: num_cols\n      num_cols=0\n      end subroutine how_many_extra_history_header_items\n"}, {"instruction": "Create a Fortran subroutine named load_div. This subroutine takes 2 input parameters of type integer, and 2 output parameters of type integer. The function calculates the values of ir_out and id_out arrays based on the input parameters m and np using a set of mathematical operations.", "input": "", "output": "  subroutine load_div( m, np, ir_out, id_out )\n    implicit none\n    integer,intent(in) :: m, np\n    integer,intent(out) :: ir_out(0:np-1),id_out(0:np-1)\n    integer :: i,ip\n    ir_out=0.0d0\n    do i=1,m\n       ip=mod(i-1,np)\n       ir_out(ip)=ir_out(ip)+1\n    end do\n    do ip=0,np-1\n       id_out(ip)=sum(ir_out(0:ip))-ir_out(ip)\n    end do\n  end subroutine load_div\n"}, {"instruction": "Create a Fortran subroutine named t_times2, which takes one input parameter of type integer and one output parameter of type integer. The subroutine multiplies the input parameter by 2 and assigns the result to the output parameter.", "input": "", "output": "    subroutine t_times2(v_in, v_out) bind(c, name='t_times2')\n        integer, intent(in) :: v_in\n        integer, intent(out) :: v_out\n        !\n        v_out=v_in*2\n    end subroutine t_times2\n"}, {"instruction": "Write a Fortran subroutine named copystring to copy a portion of a character string into another character string. The subroutine takes 2 input arguments of type character(len=*) and integer, and 1 output argument of type character(len=*).", "input": "", "output": " subroutine copystring(oldstring,newstring,lenstring)\n \n!***********************************************************************\n!     \n\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification march 2015\n!     \n!***********************************************************************\n  \n  implicit none\n  \n  character(len=*), intent(in) :: oldstring\n  character(len=*), intent(out) :: newstring\n  integer, intent(in) :: lenstring\n  \n  integer :: i\n  \n  do i=1,lenstring\n    newstring(i:i)=oldstring(i:i)\n  enddo\n  \n  return\n  \n end subroutine copystring\n"}, {"instruction": "Create a Fortran subroutine named hexagonally_close_packed to generate coordinates for a hexagonally close-packed structure. The subroutine takes 6 input parameters of types ['integer', 'integer', 'integer', 'real(8)', 'real(8)', 'logical'] and 3 output parameters of type ['real(8)', 'real(8)', 'real(8)']. The purpose of the subroutine is to calculate the coordinates of the atoms in a hexagonally close-packed structure based on the input parameters.", "input": "", "output": "subroutine hexagonally_close_packed(nx, ny, nz, a, d, center, xs, ys, zs)\n  integer, intent(in) :: nx, ny, nz\n  real(8), intent(in) :: a, d\n  logical, intent(in) :: center\n  real(8), intent(out) :: xs(nx, ny, nz), ys(nx, ny, nz), zs(nx, ny, nz)\n  integer :: i\n  real(8) :: h !< the distance between adjacent rows in the same layer\n  real(8) :: m !< the distance between corresponding rows in adjacent\n               !< layers.\n  xs = 0.0\n  ys = 0.0\n  zs = 0.0\n  !! first create coordinates, then center.\n  !! create first row in first layer\n  xs(:, 1, 1) = [(i * a, i = 0, nx - 1)]\n  !! create other rows in the first layer\n  do i = 3, ny, 2\n     xs(:, i, 1) = xs(:, 1, 1)\n  end do\n  do i = 2, ny, 2\n     xs(:, i, 1) = xs(:, 1, 1) + 0.5 * a\n  end do\n\n  h = sqrt(3.0) / 2 * a\n  do i = 1, ny\n     ys(:, i, 1) = (i - 1) * h\n  end do\n\n  !! add distances between layers\n  do i = 1, nz\n     zs(:, :, i) = (i - 1) * d\n  end do\n\n  !! for every other layer, x and y are the same.\n  !! odd layers:\n  do i = 1, nz, 2\n     xs(:, :, i) = xs(:, :, 1)\n     ys(:, :, i) = ys(:, :, 1)\n  end do\n  m = a / (2 * sqrt(3.0))\n  !! even layers:\n  do i = 2, nz, 2\n     xs(:, :, i) = xs(:, :, 1) + 0.5 * a\n     ys(:, :, i) = ys(:, :, 1) + m\n  end do\n  if (center) then\n     xs = xs - maxval(xs) / 2.0\n     ys = ys - maxval(ys) / 2.0\n     zs = zs - maxval(zs) / 2.0\n  end if\nend subroutine hexagonally_close_packed\n"}, {"instruction": "Create a Fortran subroutine named random_integer to generate a random integer within a specified range. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine random_integer(nrange,irand)\n  implicit none\n  integer, intent(in) :: nrange\n  integer, intent(out) :: irand\n  !local variables\n  real(kind=4) :: tt\n  \n  call random_number(tt)\n\n  irand=nint(tt*real(nrange,kind=4))\n\nend subroutine random_integer\n"}, {"instruction": "Create a Fortran subroutine named exptaylor to calculate the exponential function using Taylor series expansion. The subroutine takes 2 input parameters of type real (kind=8) and integer. It returns 2 output parameters of type real (kind=8) and integer.", "input": "", "output": "subroutine exptaylor(x,nmax,y,nterms)\n!====================================\n    implicit none\n\n    real (kind=8), intent(in) :: x\n    integer, intent(in) :: nmax\n    real (kind=8), intent(out) :: y\n    integer, intent(out) :: nterms\n\n    ! local variables:\n    real (kind=8) :: term, partial_sum\n    integer :: j\n\n    term = 1.\n    partial_sum = term\n\n    do j=1,nmax\n        ! j'th term is  x**j / j!  which is the previous term times x/j:\n        term = term*x/j   \n        ! add this term to the partial sum:\n        partial_sum = partial_sum + term   \n        if (abs(term) < 1.d-16*partial_sum) exit\n        enddo\n     nterms = j       ! number of terms used\n     y = partial_sum  ! this is the value returned\nend subroutine exptaylor\n"}, {"instruction": "Create a Fortran subroutine named read_pgm to read a PGM file and store the image data into an allocatable integer array. The subroutine takes 1 input parameter of type character(len=*) for the filename and 1 output parameter of type integer,allocatable for the image data.", "input": "", "output": "subroutine read_pgm(filename,img)\nimplicit none\ncharacter(len=*), intent(in)       :: filename\n  integer,allocatable, intent(out) :: img(:,:)\n  \n  integer             :: nx, ny, nmax, err\n! read a pgm file\n! do not need to save what i read as i won't use this information\n  open(10, file=filename)\n  read(10,*) \n  read(10,*) \n  read(10,*) nx,ny\n  allocate(img(nx,ny), stat=err)\n  if (err /= 0) stop\n  read(10,*) nmax\n  read(10,*) img\n  close(10)\nend subroutine read_pgm\n"}, {"instruction": "Write a Fortran subroutine named compress_pgm to compress a PGM image by reducing its size.The subroutine takes 2 input arguments of type integer and allocates 1 output argument of type integer, allocatable.The input arguments are img and step, and the output argument is small.", "input": "", "output": "subroutine compress_pgm(img,step, small)\nimplicit none\n  integer, intent(in)               :: img(:,:)\n  integer, intent(in)               :: step\n  integer, allocatable, intent(out) :: small(:,:)\n  \n  integer                           :: nx,ny, nxs, nys, err\n  \n  ! size of main image\n  nx = size(img,1)\n  ny = size(img,2)\n  ! compute size of the reduced image (small)\n  nxs = size(img(1:nx:step,:),1)\n  nys = size(img(:,1:ny:step),2)\n  \n  allocate(small(nxs,nys), stat=err)\n  if (err /= 0) stop \"error when allocatin small\"\n  \n  small(:,:) = img(1:nx:step,1:ny:step)\n  \nend subroutine compress_pgm\n"}, {"instruction": "Create a Fortran subroutine named smsv to find and count the prime numbers less than or equal to a given integer n. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 2, and the test_data type is ['integer, dimension(:)', 'integer'].", "input": "", "output": "      subroutine smsv(n, parr, cnt)\n         ! find and count the prime nos. <= n\n         ! dummy arguments\n         integer, intent(in) :: n\n         integer, intent(out), dimension(:) :: parr\n         integer, intent(out) :: cnt\n         ! local data\n         integer :: i, j\n         logical, dimension(n) :: sv\n         ! processing\n         sv(1) = .false.\n         sv(2:) = .true.\n         do i = 2, int(sqrt(real(n)))\n            do j = i*i, n, i\n               sv(j) = .false.\n            end do\n         end do\n         cnt = 0\n         do i = 2, n\n            if (sv(i)) then\n               cnt = cnt+1\n               parr(cnt) = i\n            end if\n         end do\n      end subroutine smsv\n"}, {"instruction": "Create a Fortran subroutine called \"cmpseg\" to compute the segmented sieve of Eratosthenes. The subroutine takes 4 input parameters of type integer and integer array, and 1 output parameter of type logical array. The input parameters are lo, hi, n, and p (an array of size n), and the output parameter is s (an array of size hi-lo+1).", "input": "", "output": "      subroutine cmpseg(lo, hi, n, p, s)\n         ! dummy argumentes\n         integer, intent(in) :: lo, hi, n\n         integer, intent(in), dimension(n) :: p\n         logical, intent(out), dimension(hi-lo+1) :: s\n         ! local data\n         integer :: i, j, k\n         ! processing\n         s = .true.\n         do i = 1, n\n            j = (lo/p(i))*p(i)\n            !j = lo-mod(lo, p(i))\n            if (j < lo) j = j+p(i)\n            do k = j, hi, p(i)\n               s(k-lo+1) = .false.\n            end do\n         end do\n      end subroutine cmpseg\n"}, {"instruction": "Write a Fortran subroutine named \"ciarlet\" to compute the inelasticity based on the given input parameters. The number of input parameters is 2 with data type ['real*8 ', 'real*8 '], and the number of output parameters is 1 with data type ['real*8 '].", "input": "", "output": "subroutine ciarlet(psi,invc,matpar) !! page 259, computation inelasticity\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(:)\n\treal*8 :: e, nu , lambda, mu, j, i1\n\t\n\te = matpar(1) \n\tnu = matpar(2)\n \n\tlambda = e*nu/((1.0d0 + nu)*(1.0d0 - 2.0d0*nu))\n\tmu = 0.5d0*e/(1.0d0 + nu)\n\t\n\tj = dsqrt(invc(3)) ! j\n\ti1 = invc(1)\n\t\n\tpsi = 0.25d0*(j*j-1.0d0) - (0.5d0*lambda + mu)*dlog(j) + 0.5d0*mu*(i1 - 3.0d0)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrixregularisation to perform matrix regularization. The subroutine takes 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are invc(:) and matpar(4), while the output parameter is psi. The subroutine computes the value of psi based on the provided input parameters and the defined calculations.", "input": "", "output": "subroutine matrixregularisation(psi,invc,matpar) \n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(4)\n!~  \treal*8 :: c1,c2, c3,c4, i1, j\n!~ \tc1 = matpar(1) \n!~ \tc2 = matpar(2) \n!~ \tc3 = matpar(3) \n!~ \tc4 = matpar(4) \n\t\n!~ \ti1 = invc(1)\n!~ \tj = dsqrt(invc(3))\n\t\n!~ \tif(j>c4) then\n!~ \t\tj = c4\n!~ \tend if \n\n!~ \tif(i1>c3) then\n!~ \t\ti1 = c3\n!~ \tend if \n\t\n!~ \tpsi = c1*(i1 - 3.0d0) + c2*( j*j - 1.0d0 - 2.0d0*dlog(j) )  \n\t\n\t\n\treal*8 :: c1,c2,i1bar,i2bar,j,ri33, c3, c4\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\tc3 = matpar(3)\n\tc4 = matpar(4)\n\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\ti2bar = ri33*ri33*invc(2) ! i2bar\n\n!~ \tif(i1bar > c2) then\n!~ \t\tc1 = 0.0d0\n!~ \tend if\n\n!~ \tif(j > c4) then\n!~ \t\tc3 = 0.0d0\n!~ \tend if\n\n!~ \tc1 = c1/(j**2.0d0)\n!~ \tc3 = c3/(j**2.0d0)\n\t\n\tc1 = c1/j\n\tc3 = c3/j\n\t\n\t\n\tpsi = c1*(i1bar-3.0d0) + c3*(j - 1.0d0)**2.0d0\n\t\nend subroutine \n"}, {"instruction": "Write a Fortran subroutine named mooneyrivlindpsi to calculate the derivatives of psi with respect to i1 and i2. The subroutine takes 2 input parameters of type real*8 and outputs an array of real*8. The input parameters are c and matpar, and the output parameter is dpsi.", "input": "", "output": "subroutine mooneyrivlindpsi(dpsi,c,matpar) ! derivatives of psi with respect to i1 and i2\n \timplicit none\n\treal*8 , intent(out) :: dpsi(:)\n\treal*8 , intent(in) :: c(:,:),matpar(2)\n\treal*8 :: c1,c2\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\tdpsi(1) = c1\n\tdpsi(2) = c2\n\treturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named deriv_x to calculate the first and second derivatives with respect to x, given a 2D array f and a 1D array x. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 2 optional output parameters of type real.", "input": "", "output": "    subroutine deriv_x ( x, f, i, j, dfdx, d2fdx2 )\n    \n        implicit none\n        \n        integer, intent(in) :: i, j\n        real, intent(in) :: f(:,:), x(:)\n        real, intent(out), optional :: dfdx, d2fdx2\n        real :: dx\n    \n        integer :: nx, ny\n    \n        nx    = size ( f, dim = 1 )\n        ny    = size ( f, dim = 2 )\n\n        ! 2d\n        if(nx/=1)then\n\n            if(i .ne. 1 .and. i .ne. nx)then\n\n                dx = ( (x(i)-x(i-1)) + (x(i+1)-x(i)) ) / 2\n                dfdx = (f(i+1, j) - f(i-1, j)) / (2.0 * dx)\n                d2fdx2 = (f(i+1, j) - 2.0 * f(i,j) + f(i-1, j)) / dx**2\n\n            endif\n            \n            if(i .eq. 1)then\n\n                dx = ( (x(i+2)-x(i+1)) + (x(i+1)-x(i)) ) / 2\n                dfdx = (f(i+1, j) - f(i, j)) / dx\n                d2fdx2 = (f(i+2, j) - 2.0 * f(i+1,j) + f(i, j)) / dx**2\n\n            endif\n            \n            if(i .eq. nx)then\n\n                dx = ( (x(i)-x(i-1)) + (x(i-1)-x(i-2)) ) / 2\n                dfdx = (f(i, j) - f(i-1, j)) / dx\n                d2fdx2 = (f(i, j) - 2.0 * f(i-1,j) + f(i-2, j)) / dx**2\n\n            endif\n        !1d\n        else\n\n            dfdx = 0 \n            d2fdx2 = 0 \n\n        endif\n    \n    end subroutine deriv_x\n"}, {"instruction": "Create a Fortran subroutine named deriv_y to compute the first and second derivative of the function f with respect to y. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 2 output parameters of type real, which are optional.", "input": "", "output": "    subroutine deriv_y ( y, f, i, j, dfdy, d2fdy2 )\n\n        implicit none\n\n        integer, intent(in) :: i, j\n        real, intent(in) :: f(:,:), y(:)\n        real, intent(out), optional :: dfdy, d2fdy2\n\n        real :: dy\n        integer :: nx, ny\n\n        nx    = size ( f, dim = 1 )\n        ny    = size ( f, dim = 2 )\n\n        !2d\n        if(ny/=1)then\n            if(j .ne. 1 .and. j .ne. ny)then\n\n                dy = ( (y(j)-y(j-1)) + (y(j+1)-y(j)) ) / 2\n                dfdy = (f(i, j+1) - f(i, j-1)) / (2.0 * dy)\n                d2fdy2 = (f(i, j+1) - 2.0 * f(i,j) + f(i, j-1)) / dy**2\n            endif\n\n            if(j .eq. 1)then\n                dy = ( (y(j+2)-y(j+1)) + (y(j+1)-y(j)) ) / 2\n                dfdy = (f(i, j+1) - f(i, j)) / dy\n                d2fdy2 = (f(i, j+2) - 2.0 * f(i,j+1) + f(i, j)) / dy**2\n            endif\n\n\n            if(j .eq. ny)then\n                dy = ( (y(j)-y(j-1)) + (y(j-1)-y(j-2)) ) / 2\n                dfdy = (f(i, j) - f(i, j-1)) / dy\n                d2fdy2 = (f(i, j) - 2.0 * f(i,j-1) + f(i, j-2)) / dy**2\n            endif\n\n        !1d\n        else\n\n            dfdy = 0 \n            d2fdy2 = 0 \n\n        endif\n\n      end subroutine deriv_y\n"}, {"instruction": "Create a Fortran subroutine named deriv_xy to calculate the second derivative of a 2D function with respect to x and y. The subroutine takes 5 input arguments of types integer, integer, real array, real array, and real array, and 1 optional output argument of type real.", "input": "", "output": "      subroutine deriv_xy ( x, y, f, i, j, d2fdxy)\n\n      implicit none\n\n      integer, intent(in) :: i, j\n      real, intent(in) :: f(:,:), x(:), y(:)\n      real, intent(out), optional :: d2fdxy\n\n      real :: dx, dy\n      integer :: nx, ny\n\n      nx    = size ( f, dim = 1 )\n      ny    = size ( f, dim = 2 )\n\n      d2fdxy = 0.0\n\n      if(nx/=1 .and. ny/=1)then\n\n        if (i /= 1 .and. i /= nx .and. &\n            j /= 1 .and. j /= ny) then\n\n            dx = ( (x(i)-x(i-1)) + (x(i+1)-x(i)) ) / 2\n            dy = ( (y(j)-y(j-1)) + (y(j+1)-y(j)) ) / 2\n\n           d2fdxy = (f(i+1,j+1) - f(i-1,j+1) - f(i+1,j-1) + f(i-1,j-1) ) &\n              / (4.0 * dx * dy)\n\n        endif\n\n      endif\n\n\n      end subroutine deriv_xy\n"}, {"instruction": "```fortran\n  ! Define a Fortran subroutine named gaussinte_w to compute the Gauss-Hermite nodes and weights.\n  ! The subroutine takes 2 input parameters: an integer n and an array of double precision eps, and 2 output parameters: arrays of double precision x and w.\n  ! The subroutine computes the nodes and weights for Gauss-Hermite quadrature using the input integer n and double precision eps.\n  ! The nodes are stored in the array x and the weights are stored in the array w.\n  ! The subroutine uses the imperative tone and reflects the features of Fortran subroutine.\n  subroutine gaussinte_w(n, x, w, eps)\n    integer, intent(in) :: n\n    double precision, intent(out) :: x(1:n), w(1:n)\n    double precision, intent(in) :: eps\n    ...\n  end subroutine gaussinte_w\n```", "input": "", "output": "  subroutine gaussinte_w(n, x, w, eps)\n    integer, intent(in) :: n\n    double precision, intent(out) :: x(1:n), w(1:n)\n    double precision, intent(in) :: eps\n\n    integer :: m, i, l\n    double precision :: npai, tmp, dt\n    double precision :: p0, p1, p2\n    double precision :: q0, q1, q2\n\n    select case (n)\n      case (1)\n        x(1) = 0.0d0\n        w(1) = 2.0d0\n        return\n      case (2)\n        x(1) = -sqrt(1.0d0/3.0d0)\n        w(1) = 1.0d0\n        x(2) = -x(1)\n        w(2) = w(1)\n        return\n      case (3)\n        x(1) = -sqrt(0.6d0)\n        w(1) = 5.0d0/9.0d0\n        x(2) = 0.0d0\n        w(2) = 8.0d0/9.0d0\n        x(3) = -x(1)\n        w(3) = w(1)\n        return\n    end select\n\n    m = n / 2\n    npai = pai / (dble(n) + 0.5d0)\n    do i = 1, m\n      tmp = cos((i - 0.25d0) * npai)\n      dt = tmp\n      do while (abs(dt) > abs(tmp) * eps)\n        p1 = tmp\n        p2 = (3.0d0 * tmp**2 - 1.0d0) * 0.5d0\n        q1 = 1.0d0\n        q2 = 3.0d0 * tmp\n        do l = 3, n\n          p0 = p1\n          p1 = p2\n          p2 = ((l + l - 1) * tmp * p1 - (l-1) * p0) / l\n          q0 = q1\n          q1 = q2\n          q2 = ((l + l - 1) * (tmp * q1 + p1) - (l-1) * q0) / l\n        end do\n        dt = p2 / q2\n        tmp = tmp - dt\n      end do\n      x(i) = tmp\n      w(i) = 2.0d0 / (n * p1 * q2)\n    end do\n\n    if (mod(n, 2) == 1) then\n      tmp = dble(n)\n      do i = 1, m\n        tmp = tmp * (0.5d0 - i) / dble(i)\n      end do\n      x(m+1) = 0.0d0\n      w(m+1) = 2.0d0 / tmp**2\n    end if\n\n    do i = 1, m\n      x(n+1-i) = x(i)\n      x(i) = -x(i) ! reverse order\n      w(n+1-i) = w(i)\n    end do\n  end subroutine gaussinte_w\n"}, {"instruction": "Create a Fortran subroutine named double_scalar_par_max to assign the input real(kind=8) value to the output real(kind=8) value. The number of input arguments is 1 with the test_data type ['real(kind=8)'], and the number of output arguments is 1 with the test_data type ['real(kind=8)']. Use the intent(in) attribute for the input parameter and the intent(out) attribute for the output parameter.", "input": "", "output": "  subroutine double_scalar_par_max(xxl,xxg)\n\n    real(kind=8), intent(out) :: xxg\n    real(kind=8), intent(in) :: xxl\n\n    xxg=xxl\n\n  end subroutine double_scalar_par_max\n"}, {"instruction": "Write a Fortran subroutine named double_scalar_par_sum to assign the value of the input real number to the output real number. The number of input arguments is 1 and the test_data type is real(kind=8). The number of output arguments is 1 and the test_data type is real(kind=8).", "input": "", "output": "  subroutine double_scalar_par_sum(xxl,xxg)\n\n    real(kind=8), intent(out) :: xxg\n    real(kind=8), intent(in) :: xxl\n\n    xxg=xxl\n\n  end subroutine double_scalar_par_sum\n"}, {"instruction": "Write a Fortran subroutine named double_array_par_sum that copies the elements of an input real(kind=8) array xxl to an output real(kind=8) array xxg. The number of input arguments is 2 and the test_data type is [integer, real(kind=8)]. The number of output arguments is 1 and the test_data type is [real(kind=8)].", "input": "", "output": "  subroutine double_array_par_sum(xxl,xxg,n)\n\n    integer, intent(in)::n\n    real(kind=8), intent(out) :: xxg(n)\n    real(kind=8), intent(in) :: xxl(n)\n\n    xxg=xxl\n\n  end subroutine double_array_par_sum\n"}, {"instruction": "Create a Fortran subroutine named dft to perform a Discrete Fourier Transform. The subroutine takes 2 input parameters of type integer and double precision and 1 output parameter of type double precision. The input parameters are m (integer) and f (array of double precision), and the output parameter is fhat (array of double precision). The subroutine calculates the Fourier transform of the input function f and stores the result in fhat, utilizing double precision arithmetic for accuracy. Make sure to include the intent attribute for input and output parameters as per the code provided.", "input": "", "output": "        subroutine dft(m, f, fhat)\r\n            integer,          intent(in)  :: m\r\n            double precision, intent(in)  :: f(m)       ! function in real space\r\n            double precision, intent(out) :: fhat(2*m)  ! function in fourier space\r\n            double precision              :: fac, arg\r\n            integer                       :: k, l\r\n            double precision              :: sfac       ! normalization factor\r\n\r\n            fhat = 0.d0\r\n            fac = twopi / dble(m)\r\n\r\n            do k = 0, m - 1\r\n                do l = 0, m - 1\r\n                    arg = fac * dble(k * l)\r\n                    fhat(k+1)   = fhat(k+1)   + f(l+1) * dcos(arg)\r\n                    fhat(k+1+m) = fhat(k+1+m) - f(l+1) * dsin(arg)\r\n                enddo\r\n            enddo\r\n\r\n            sfac = one / dsqrt(dble(m))\r\n\r\n            fhat = fhat * sfac\r\n\r\n        end subroutine dft\r\n"}, {"instruction": "Create a Fortran subroutine named calc that takes in 4 input parameters: nx (integer), ny (integer), a (2D array of real numbers), and b (2D array of real numbers). It also has 1 output parameter: c (2D array of real numbers). The subroutine performs a computation using the input arrays a and b, and stores the result in the array c. The computation involves adding the corresponding elements of arrays a and b to the elements of array c. The subroutine utilizes OpenACC directives for parallel processing.", "input": "", "output": "  subroutine calc(nx, ny, a, b, c)\n    implicit none\n    integer,intent(in) :: nx,ny\n    real(kind=4),dimension(:,:),intent(in)  :: a,b\n    real(kind=4),dimension(:,:),intent(out) :: c\n    integer :: i,j\n\n    !$acc kernels present(a,b,c)\n    !$acc loop independent\n    do j = 1,ny\n       !$acc loop independent\n       do i = 1,nx\n          c(i,j) = c(i,j) + a(i,j) + b(i,j)\n       end do\n    end do\n    !$acc end kernels\n\n  end subroutine calc\n"}, {"instruction": "Create a Fortran subroutine called init_cpu that initializes a 2D array 'a' with values of 1.0. The subroutine takes two input parameters of type integer, nx and ny, and one output parameter, a, which is a 2D array of real numbers.", "input": "", "output": "  subroutine init_cpu(nx, ny, a)\n    implicit none\n    integer,intent(in) :: nx,ny\n    real(kind=4),dimension(:,:),intent(out)  :: a\n    integer :: i,j\n\n    do j = 1, ny\n       do i = 1, nx\n          a(i,j) = 1.0\n       end do\n    end do\n  end subroutine init_cpu\n"}, {"instruction": "Create a Fortran subroutine named system__getenv to retrieve the value of the specified environment variable. The subroutine should have 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "  subroutine system__getenv( name, value )\n\n    character(*), intent(in)  :: name\n    character(*), intent(out) :: value\n    !----\n    \n    call get_environment_variable( name, value )\n    \n  end subroutine system__getenv\n"}, {"instruction": "Create a Fortran subroutine named \"strassen\" to perform matrix multiplication using the Strassen algorithm. The subroutine takes 3 input parameters of type integer, double precision, and double precision and 1 output parameter of type double precision.", "input": "", "output": "  recursive subroutine strassen (a, b, c, n)\n    integer, intent(in) :: n\n    double precision, intent(in) :: a(n,n), b(n,n)\n    double precision, intent(out) :: c(n,n)\n    double precision :: t(n/2,n/2,7)\n    integer :: k, l\n\n    if (iand (n,1) .ne. 0 .or. n < 64) then\n      c = matmul (a, b)\n      return\n    end if\n    k = n / 2\n    l = n / 2 + 1\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k) + a(l:,l:), b(:k,:k) + b(l:,l:), t(:,:,1), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,:k) + a(l:,l:), b(:k,:k), t(:,:,2), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k), b(:k,l:) - b(l:,l:), t(:,:,3), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,l:), b(l:,:k) - b(:k,:k), t(:,:,4), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k) + a(:k,l:), b(l:,l:), t(:,:,5), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,:k) - a(:k,:k), b(:k,:k) + b(:k,l:), t(:,:,6), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,l:) - a(l:,l:), b(l:,:k) + b(l:,l:), t(:,:,7), k)\n!$omp end task\n!$omp taskwait\n    c(:k,:k) = t(:,:,1) + t(:,:,4) - t(:,:,5) + t(:,:,7)\n    c(l:,:k) = t(:,:,2) + t(:,:,4)\n    c(:k,l:) = t(:,:,3) + t(:,:,5)\n    c(l:,l:) = t(:,:,1) - t(:,:,2) + t(:,:,3) + t(:,:,6)\n  end subroutine strassen\n"}, {"instruction": "Write a Fortran subroutine named `mop1_circles` that calculates fitness values for multiple objectives and violation count. The subroutine takes 3 input parameters of type integer, integer, and real and returns 2 output parameters of type real and integer. The input parameters are `nf` (number of fitness values), `np` (number of individuals), and `indv` (array of individuals). The output parameters are `fit` (array of fitness values) and `viol` (violation count). The subroutine computes fitness values for two objectives based on the input `indv` and assigns them to `fit`. It sets `viol` to 0.", "input": "", "output": "subroutine mop1_circles(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\tfit(1) = indv(1)**2 + indv(2)**2\n\tfit(2) = (indv(1)-2.0)**2 + (indv(2)-2.0)**2\n\tviol = 0\nend subroutine mop1_circles\n"}, {"instruction": "Create a Fortran subroutine named mop2_fonseca to calculate fitness and violation for a multi-objective optimization problem. The subroutine takes 3 input parameters: two integers nf and np, and an array of real numbers indv with size np. It returns 2 output parameters: an array of real numbers fit with size nf and an integer viol.", "input": "", "output": "subroutine mop2_fonseca(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\tfit(1) = 1-exp(-((indv(1)- 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(2) - 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(3) - 1.0/(3.0)**0.5)**2.0));\n\tfit(2) = 1-exp(-((indv(1)+ 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(2) + 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(3) + 1.0/(3.0)**0.5)**2.0));\n\tviol = 0\nend subroutine mop2_fonseca\n"}, {"instruction": "Create a Fortran subroutine named \"mop3_poloni\" to calculate the fitness and violation for a multi-objective optimization problem. The subroutine takes 3 input parameters of type integer, integer, and real and returns 2 output parameters of type real and integer. The subroutine performs computations using the input parameters and constants, and assigns the results to the output parameters.", "input": "", "output": "subroutine mop3_poloni(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: \ta1 = 0.873648562314064, &\t!= 0.5*sin(1)-2*cos(1)+sin(2)-1.5*cos(2)\n\t\t\ta2 = 2.748572443268639, &\t!=1.5*sin(1)-cos(1)+2*sin(2)-.5*cos(2)\n\t\t\tx, y ,b1, b2\n\t\n\tx = indv(1)\n\ty = indv(2)\n\tb1 = 0.5*sin(x) - 2.0*cos(x) + sin(y) - 1.5*cos(y)\n\tb2 = 1.5*sin(x) - cos(x) + 2.0*sin(y) - 0.5*cos(y)\n\n\tfit(1) = (1 + (a1-b1)**2 + (a2-b2)**2)\n\tfit(2) = ((x+3)**2 + (y+1)**2)\n\t\n\tviol = 0\nend subroutine mop3_poloni\n"}, {"instruction": "Create a Fortran subroutine named mop5_viennet to evaluate the Viennet multi-objective test problem. This subroutine takes 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer. The input parameters represent the number of functions and the number of decision variables, as well as the array of decision variables. The output parameters represent the array of objective function values and the violation count.", "input": "", "output": "subroutine mop5_viennet(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: x, y, temp\n\n\ty = indv(2)\n\tx = indv(1)\n\ttemp = x**2+y**2\n\t\n\tfit(1) = 0.5 * temp + sin(temp)\n\tfit(2) = (3.0*x-2.0*y+4.0)**2.0/8.0 + &\n\t\t\t (x-y+1.0)**2.0/27.0 + 15.0\n\tfit(3) = 1.0 / (temp+1.0) - 1.1*exp(-temp)\n\n\tviol = 0\nend subroutine mop5_viennet\n"}, {"instruction": "Create a Fortran subroutine named \"zdt3_10d\" to calculate the fitness and violation of a 10-dimensional problem. The subroutine should take 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer.", "input": "", "output": "subroutine zdt3_10d(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: r\n\tinteger::dims = 10, i\n\treal, parameter:: pi = 3.141592653589793\n\n\n\tfit(1) = indv(1)\n\t\n\tr = 0.0\n\t\n\tdo i = 2, dims\n\t\tr = r + indv(i)\n\tend do\n\t\n\tfit(2) = (1.0+9.0*r/(dims-1)) * &\n\t\t\t(1-sqrt(indv(1)/(1.0+9.0*r/(dims-1))) - &\n\t\t\t(indv(1)/(1.0+9.0*r/(dims-1)))*sin(10.0*pi*indv(1)));\n\n\tviol = 0\nend subroutine zdt3_10d\n"}, {"instruction": "Develop a Fortran subroutine named \"mop_c4_tanaka\" that takes 3 input arguments of type integer, integer, and real, and 2 output arguments of type real and integer. The subroutine computes the values of \"fit\" and \"viol\" based on the input \"indv\", \"nf\", and \"np\". Ensure that \"fit(1)\" and \"fit(2)\" are assigned values from \"indv(1)\" and \"indv(2)\" respectively. The \"viol\" variable is set to 0, and then updated to 1 if a certain condition involving \"indv(1)\" and \"indv(2)\" is met.", "input": "", "output": "subroutine mop_c4_tanaka(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: a, b\n\t\n\ta = 0.1\n\tb = 16.0\n\n\tfit(1) = indv(1)\n\tfit(2) = indv(2)\n\n\tviol = 0\n\tif (- indv(1)**2.0 - indv(2)**2.0 + 1.0 + &\n\t\ta * cos(b*atan(indv(1)/indv(2)))>0.0) viol = 1\nend subroutine \tmop_c4_tanaka\n"}, {"instruction": "Create a Fortran subroutine named c1 that takes an array of real numbers as input and returns the size of the array as an integer. The input parameter is of type real, dimension(:) and intent(in), and the output parameter is of type integer and intent(out).", "input": "", "output": "          subroutine c1(f,cs)\n            real, dimension(:), intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=size(f)\n          end subroutine c1\n"}, {"instruction": "Create a Fortran subroutine named c2 that takes a 2D array of real numbers as input and returns the size of the array as an integer. The input parameter is of type real, dimension(:,:), and is passed by intent(in). The output parameter is of type integer and is passed by intent(out).", "input": "", "output": "          subroutine c2(f,cs)\n            real, dimension(:,:), intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=size(f)\n          end subroutine c2\n"}, {"instruction": "Create a Fortran subroutine named \"cn\" to assign the value 0 to an integer output parameter \"cs\" based on a single real input parameter \"f\".", "input": "", "output": "          subroutine cn(f,cs)\n            real, intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=0\n          end subroutine cn\n"}, {"instruction": "Create a Fortran subroutine named niching_func_bound_cons to set boundary constraints for a given function. The subroutine takes 2 input parameters of type integer and outputs a double precision array of dimensions (dims,2). The subroutine uses a select case statement to assign specific boundary values based on the input 'func' and 'dims' values. Ensure proper initialization of the 'bounds' array within the subroutine for different function cases.", "input": "", "output": "      subroutine niching_func_bound_cons(func, dims, bounds)\n\n      implicit none\n\n      integer, intent(in):: func, dims\n      double precision, intent(out), dimension(dims,2):: bounds\n\n      select case(func)\n      case(10)\n       bounds(:,1)=0.0d0\n       bounds(:,2)=1.0d0\n      case(11,12)\n       bounds(:,1)=-6.0d0\n       bounds(:,2)=6.0d0\n      case(13,14,15,16,17,18)\n       bounds(:,1)=0.0d0\n       bounds(:,2)=2.0d0\n      case(20)\n       bounds(:,1)=-100.0d0\n       bounds(:,2)=100.0d0\n      case(21)\n       bounds(:,1)=0.5d0\n       bounds(:,2)=4.5d0\n      case(30:39)\n       bounds(:,1)=-dble(dims+1)\n       bounds(:,2)=dble(dims+1)\n      case default\n       bounds(:,1)=-dble(dims+1)\n       bounds(:,2)=dble(dims+1)\n      end select\n\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"cmmp\" with the following functionality: \n1. Accept 3 input parameters of type integer, integer, and double precision and 2 output parameters of type double precision. \n2. The subroutine computes objective value \"f\" and constraint values \"g\" based on the input values \"n\", \"j\", and \"x\". \n3. The objective value \"f\" is calculated as the sum of squares of the elements in the array \"x\". \n4. The constraint values \"g\" are computed based on the array \"x\" and other calculations using the input parameters.", "input": "", "output": "      subroutine cmmp(n, j, x, f, g)\n      implicit none\n!     from deb and saha, gecco2010\n      integer, intent(in):: n, j\n      double precision, intent(in):: x(n)\n      double precision, intent(out):: f, g(j)\n!     note: l not currently used\n      integer:: i, jj, ii, c\n      integer, allocatable, dimension(:):: cvec\n\n!     objective\n      f=0.0d0\n      do i=1,n\n        f=f+x(i)**2\n      end do\n\n!     constraints\n      allocate(cvec(j*n))\n      ii=0\n      do jj=1,j\n       do i=1,n\n         ii=ii+1\n         cvec(ii)=i\n       end do\n      end do\n      ii=1\n      do jj=1,j\n        ii=ii-1\n        g(jj)=0.0d0\n        do i=1,n\n            ii=ii+1\n            c=cvec(ii)\n            g(jj)=g(jj)+(dble(c)**2 * x(i)**2)\n        end do\n        g(jj)=n**2 - g(jj)\n      end do\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named empirical_relation to calculate the compressional velocity (vpz) and density (rhoz) based on the input shear velocity (vsz). The subroutine takes 1 input parameter of type real(c_float) and returns 2 output parameters of type real(c_float).", "input": "", "output": "subroutine empirical_relation(vsz,vpz,rhoz)bind(c,name=\"empirical_relation\")\n  use,intrinsic :: iso_c_binding\n\n  real(c_float), intent(in) ::  vsz\n  real(c_float),intent(out) ::vpz,rhoz\n\n  vpz=0.9409 + 2.0947*vsz - 0.8206*vsz**2+ &\n          0.2683*vsz**3 - 0.0251*vsz**4\n  rhoz=1.6612*vpz- 0.4721*vpz**2 + &\n          0.0671*vpz**3 - 0.0043*vpz**4 + & \n          0.000106*vpz**5\n  \nend subroutine empirical_relation\n"}, {"instruction": "Write a Fortran subroutine named hinitu to initialize the heap programs with the pointer array t(1) pointing to the top of the heap. The number of input arguments is 2, both of integer type. The number of output arguments is 2, both of integer type. The subroutine initializes the heap with the maximum number of nodes and the number of words per node. Upon completion, it sets the current number of nodes in the heap to 0 and updates the integer array of pointers to the heap nodes. The subroutine uses the imperative tone and Fortran features.", "input": "", "output": "subroutine hinitu(nmax, nwds, n, t)\r\n\r\n!     purpose:\r\n!       initialize the heap programs with t(1) pointing to the top of\r\n!       the heap.   it is called once, at the start.\r\n\r\n!     input:\r\n!     nmax = maximum number of nodes.\r\n!     nwds = number of words per node.\r\n\r\n!     output:\r\n!     n = 0 (to hold current number of nodes in heap)\r\n!     t = integer array of pointers to the heap nodes.\r\n\r\nimplicit none\r\ninteger, intent(in)  :: nmax, nwds\r\ninteger, intent(out) :: n, t(:)\r\n\r\n!     local variable.\r\n\r\ninteger :: i\r\n\r\ndo i = 1, nmax\r\n  t(i) = (i-1)*nwds + 1\r\nend do\r\nn = 0\r\nreturn\r\nend subroutine hinitu\r\n"}, {"instruction": "Create a Fortran subroutine named check_file that takes two input parameters of type integer, nfac and n, and one output parameter of type logical, file_exist. The subroutine checks for the existence of a file named \"file_chk\" and sets file_exist to true if a specific condition is met within the file.", "input": "", "output": "  subroutine check_file( nfac, n, file_exist )\n    implicit none\n    integer,intent(in) :: nfac, n\n    logical,intent(out) :: file_exist\n    integer,parameter :: u=80\n    character(8),parameter :: file_name=\"file_chk\"\n    integer,parameter :: ndata_max=10000\n    integer :: nfac_tmp, n_tmp, i\n    logical :: flag\n    file_exist=.false.\n    inquire( file=file_name, exist=flag )\n    if ( flag ) then\n       open(u,file=file_name,status=\"old\")\n       read(u,*) nfac_tmp\n       if ( nfac_tmp == nfac ) then\n          do i=1,ndata_max\n             read(u,*,end=10) n_tmp\n             if ( n_tmp == n ) then\n                file_exist = .true.\n                exit\n             end if\n          end do\n10        continue\n       end if\n       close(u)\n    end if\n  end subroutine check_file\n"}, {"instruction": "Create a Fortran subroutine named dist to calculate the minimum distance between two 3D points considering periodic boundary conditions. The subroutine takes 3 input parameters of type real(8) for x1, x2, and b, and 1 output parameter of type real(8) for the minimum distance.", "input": "", "output": "        subroutine dist(x1,x2,b,d)\n        implicit none\n        real(8),intent(in)    :: x1(3)\n        real(8),intent(in)    :: x2(3)\n        real(8),intent(in)    :: b(3)\n        real(8),intent(out)   :: d\n        real(8)               :: bd(3)\n        integer(4)    :: i,j,k\n\n        d=huge(d)\n        do i=-1,1\n          do j=-1,1\n            do k=-1,1\n              bd(1)=i*b(1)\n              bd(2)=j*b(2)\n              bd(3)=k*b(3)\n              d=min(d,sqrt(sum((x1-x2+bd)**2)))\n            enddo\n          enddo\n        enddo\n\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named submatrix_smdim_multi that calculates the dimension of a submatrix based on the input metadim, meta, and insm arrays. The number of input parameters is 3 with test_data type ['integer(4)', 'integer(4)', 'integer(4)'], and the number of output parameters is 1 with test_data type ['integer(4)'].", "input": "", "output": "        subroutine submatrix_smdim_multi(metadim,meta,insm,smdim)\n        implicit none\n        integer(4),intent(in)   :: metadim\n        integer(4),intent(in)   :: meta(metadim,metadim)\n        integer(4),intent(in)   :: insm(metadim)\n        integer(4),intent(out)   :: smdim\n        integer(4)    :: is,js,ib,jb,a,b,i,j,iatom,jatom\n\n        smdim=0\n        do i=1,metadim\n          do j=1,metadim\n            if(insm(j).eq.1)then\n              if(meta(i,j).eq.1)then\n                smdim=smdim+1\n                exit\n              endif\n            endif\n          enddo\n        enddo\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gsffmtnum to format a double precision value based on its size. The subroutine takes 1 input parameter of type double precision and returns 1 output parameter of type character(len=*).", "input": "", "output": "      subroutine gsffmtnum(val, strng)\n!     ******************************************************************\n!     format value based on value size\n!     ******************************************************************\n      implicit none\n      intrinsic abs, int\n! arguments\n      double precision, intent(in) :: val\n      character(len=*), intent(out) :: strng\n! local variables\n      double precision, parameter :: big = 1.0d07, small = 0.01d0\n      double precision :: absval\n!***********************************************************************\n      absval = abs(val)\n      if ( absval<1.0d-5 ) then\n!       write (strng, '(i18)') int(val)\n        strng = ' '\n      elseif ( absval>big .or. absval<small ) then\n        write (strng, '(1pd18.4)') val\n      else\n        write (strng, '(f18.2)') val\n      endif\n      end subroutine gsffmtnum\n"}, {"instruction": "Write a Fortran subroutine named bxv to compute the matrix-vector product y = b * v. The subroutine takes 4 input parameters: n (integer), k (integer), v (real(kind=8) array of dimension n), b (real(kind=8) array of dimension n x k). It produces 1 output parameter: y (real(kind=8) array of dimension n).", "input": "", "output": "    subroutine bxv(k, n, b, v, y)\n!=======================================================================\n!\n!   computes   y = b * v    where b is a symmetric, banded matrix,\n!   in lower-band storage mode,  and v, y are vectors.\n!\n!-----------------------------------------------------------------------\n!\n!   on entry\n!   --------\n!       k       the number of diagonals\n!       n       the order of the matrix\n!       b       the symmetric, banded matrix in column storage mode\n!       v       vector\n!\n!   on exit\n!   -------\n!       y       y = b*v\n!\n!-----------------------------------------------------------------------\n\n       implicit none\n\n       integer, intent(in) :: n, k\n       real(kind=8), dimension(n), intent(in) ::v\n       real(kind=8), dimension(n, k), intent(in) ::b\n       real(kind=8), dimension(n), intent(out) :: y\n\n       ! .. local variables\n\n       integer :: i, j, jp\n\n! ...   contribution from central diagonal (jp=k)\n\n       do i = 1, n\n          y(i) = b(i, k)*v(i)\n       end do\n\n! ...   off diagonal\n\n       do jp = 1, k - 1\n          do i = k - jp + 1, n\n             j = i - k + jp\n             y(i) = y(i) + b(i, jp)*v(j)             ! sub_diagonals\n             y(j) = y(j) + b(i, jp)*v(i)             ! super-diagonals\n          end do\n       end do\n\n    end subroutine bxv\n"}, {"instruction": "Create a Fortran subroutine named setup2 to set up the i-th row of an augmented regression matrix for a weighted least-squares fit of a quadratic function. The subroutine takes 9 input parameters of type real: xk, yk, fk, xi, yi, fi, s1, s2, r, and outputs 1 parameter of type real: row(6).", "input": "", "output": "subroutine setup2(xk,yk,fk,xi,yi,fi,s1,s2,r,row)\r\nreal, intent(in)   :: xk, yk, fk, xi, yi, fi, s1, s2, r\r\nreal, intent(out)  :: row(6)\r\n\r\n!***********************************************************\r\n\r\n!                                                robert renka\r\n!                                        univ. of north texas\r\n!                                              (817) 565-2767\r\n\r\n!   this routine sets up the i-th row of an augmented regression matrix for a\r\n! weighted least-squares fit of a quadratic function q(x,y) to a set of data\r\n! values f, where q(xk,yk) = fk.  the first 3 columns (quadratic terms) are\r\n! scaled by 1/s2 and the fourth and fifth columns (linear terms) are scaled\r\n! by 1/s1.  the weight is (r-d)/(r*d) if r > d and 0 if r <= d, where d\r\n! is the distance between nodes i and k.\r\n\r\n! on input --\r\n\r\n!        xk,yk,fk = coordinates and data value at node k -- interpolated by q.\r\n\r\n!        xi,yi,fi = coordinates and data value at node i.\r\n\r\n!        s1,s2 = reciprocals of the scale factors.\r\n\r\n!        r = radius of influence about node k defining the weight.\r\n\r\n!        row = array of length 6.\r\n\r\n! input parameters are not altered by this routine.\r\n\r\n! on output --\r\n\r\n!        row = vector containing a row of the augmented regression matrix.\r\n\r\n! modules required by setup2 -- none\r\n\r\n! intrinsic function called by setup2 -- sqrt\r\n\r\n!***********************************************************\r\n\r\nreal  :: d, dx, dy, dxsq, dysq, w, w1, w2\r\n\r\n! local parameters -\r\n\r\n! i =         do-loop index\r\n! dx =         xi - xk\r\n! dy =         yi - yk\r\n! dxsq = dx*dx\r\n! dysq = dy*dy\r\n! d =         distance between nodes k and i\r\n! w =         weight associated with the row\r\n! w1 =         w/s1\r\n! w2 =         w/s2\r\n\r\ndx = xi - xk\r\ndy = yi - yk\r\ndxsq = dx * dx\r\ndysq = dy * dy\r\nd = sqrt(dxsq+dysq)\r\nif (d > 0. .and. d < r) then\r\n  w = (r-d) / r / d\r\n  w1 = w / s1\r\n  w2 = w / s2\r\n  row(1) = dxsq * w2\r\n  row(2) = dx * dy * w2\r\n  row(3) = dysq * w2\r\n  row(4) = dx * w1\r\n  row(5) = dy * w1\r\n  row(6) = (fi-fk) * w\r\n  return\r\nend if\r\n\r\n! nodes k and i coincide or node i is outside of the radius of influence.\r\n!   set row to the zero vector.\r\n\r\nrow(1:6) = 0.\r\n\r\nreturn\r\nend subroutine setup2\r\n"}, {"instruction": "Write a Fortran subroutine named matrixinverse to compute the inverse of a square matrix. The subroutine takes 2 input arguments of type integer and real, and 1 output argument of type real. The input arguments are the size of the square matrix and the matrix itself, while the output argument is the inverse of the matrix. The subroutine utilizes forward elimination, row swapping, and back substitution algorithms to compute the inverse.", "input": "", "output": "subroutine matrixinverse(n, a, ia)\n        implicit none\n        ! argument list\n        integer, intent(in)   :: n\n        real, intent(in)  :: a(n,n)\n        real, intent(out) :: ia(n,n)\n        ! local variables\n        integer  :: i,j,ml(1)\n        real :: piv\n        real :: temp(2*n)\n        real :: c(2*n,n)\n\n        c(1:n,:)     = transpose(a)\n        c(n+1:2*n,:) = 0.0\n\n        do i = 1, n\n            c(n+i,i) = 1.0\n        end do\n\n        ! forward elimination and row swapping (if necessary)\n\n        do i = 1, n\n\n            ! if pivot element is zero, then swap rows\n\n            ml = maxloc(abs(c(i,i:n)))\n            j = i - 1 + ml(1)\n            temp   = c(:,j)\n            c(:,j) = c(:,i)\n            c(:,i) = temp\n\n            if (abs(c(i,i)) .le. 1.0e-15) then\n                print *, 'error. matrix is singular!'\n                do j = 1, n\n                    print *, a(j,:)\n                end do\n                stop\n            end if\n\n            piv    = 1.0/c(i,i)\n            c(:,i) = c(:,i)*piv\n\n            do j = i+1, n\n                c(:,j) = c(:,j) - c(i,j)*c(:,i)\n            end do\n        end do\n\n        ! back substitution\n\n        do i = n,1,-1\n            do j = i-1,1,-1\n                c(:,j) = c(:,j) - c(i,j)*c(:,i)\n            end do\n        end do\n\n        ia = transpose( c(n+1:2*n,:) )\n\nend subroutine matrixinverse\n"}, {"instruction": "Create a Fortran subroutine named matrix_exp to calculate the exponential of a matrix. The subroutine takes 4 input parameters of type integer, integer, integer, real*8 and 1 output parameter of type real*8. The input parameters are n, j, k, and m(n,n), while the output parameter is em(n,n).", "input": "", "output": "subroutine matrix_exp(m, n, j, k, em)\n    integer, intent(in)  :: n, j, k\n    real*8, intent(in)   :: m(n,n)\n    real*8, intent(out)   :: em(n,n)\n\n    real *8 :: tc(j+1), sm(n,n)\n    integer p, i\n    tc(1)=1\n    do i=1,j\n       tc(i+1)=tc(i)/dble(i)\n    enddo\n\n    !scale\n    sm=m*(1./2.**k)\n    em=0.\n    do i=1,n\n       em(i,i)=tc(j+1)\n    enddo\n\n    !taylor exp of scaled matrix\n    do p=j,1,-1\n       em=matmul(sm,em);\n       do i=1,n\n          em(i,i)=em(i,i)+tc(p)\n       enddo\n    enddo\n\n    !square\n    do p=1,k\n       em=matmul(em,em)\n    enddo\n\nend subroutine matrix_exp\n"}, {"instruction": "Create a Fortran subroutine named do_loop to assign the same real value to each element of a one-dimensional real array. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real, dimension(:)].", "input": "", "output": "subroutine do_loop( array, value )\n    real, dimension(:), intent(out) :: array\n    real, intent(in)                :: value\n\n    integer                         :: i\n\n    do i = 1,size(array)\n        array(i) = value\n    enddo\nend subroutine do_loop\n"}, {"instruction": "Create a Fortran subroutine named array_op. The subroutine takes 1 input parameter of type real and an output parameter of type real array. The input parameter is marked with intent(in) and the output parameter is marked with intent(out). The subroutine assigns the input value to all elements of the output array.", "input": "", "output": "subroutine array_op( array, value )\n    real, dimension(:), intent(out) :: array\n    real, intent(in)                :: value\n\n    array = value\nend subroutine array_op\n"}, {"instruction": "Create a Fortran subroutine named c_f_pointer_scalar that takes an integer pointer as input and an integer pointer as output. The function should assign the value of the input pointer to the output pointer using the \"=>\" pointer assignment.", "input": "", "output": "    subroutine c_f_pointer_scalar (cptr, fptr)\n\n        integer, pointer , intent(in):: cptr  ! use pointer of any type here\n        integer, pointer , intent(out):: fptr  ! use pointer of any type here\n\n        fptr => cptr\n    end subroutine c_f_pointer_scalar\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_aw_surface_derivative. It takes 4 input arguments of type integer: ia, l, io, and dm. It also has 1 output argument of type real(8) named deriv. This subroutine is meant to be bound to a C function named \"sirius_get_aw_surface_derivative\" and is used to compute the derivative of the augmented wave (AW) basis function on the surface.", "input": "", "output": "        subroutine sirius_get_aw_surface_derivative(ia, l, io, dm, deriv)&\n            &bind(c, name=\"sirius_get_aw_surface_derivative\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: l\n            integer,                 intent(in)  :: io\n            integer,                 intent(in)  :: dm\n            real(8),                 intent(out) :: deriv\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_find_fft_grid_size that calculates the grid size for fast Fourier transform (FFT) based on the given cutoff and lattice vectors. The subroutine takes 2 input parameters of type real(8) and returns 1 output parameter of type integer.", "input": "", "output": "        subroutine sirius_find_fft_grid_size(cutoff, lat_vec, grid_size)&\n            &bind(c, name=\"sirius_find_fft_grid_size\")\n            real(8),                 intent(in)  :: cutoff\n            real(8),                 intent(in)  :: lat_vec\n            integer,                 intent(out) :: grid_size\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sirius_get_band_energies\" that retrieves band energies for a specific k-point, spin, and kset. The subroutine should have 3 input parameters of type integer representing kset_id, ik, and ispn, and 1 output parameter of type real(8) to store the band energies. Use the \"bind\" attribute to ensure compatibility with C.", "input": "", "output": "        subroutine sirius_get_band_energies(kset_id, ik, ispn, band_energies)&\n            &bind(c, name=\"sirius_get_band_energies\")\n            integer,                 intent(in)  :: kset_id\n            integer,                 intent(in)  :: ik\n            integer,                 intent(in)  :: ispn\n            real(8),                 intent(out) :: band_energies\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_energy_fermi to retrieve the Fermi energy for a given k-point set. The subroutine should have 1 input parameter of type integer and 1 output parameter of type real(8). The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [real(8)]. Use the \"bind(c, name=\"sirius_get_energy_fermi\")\" directive to bind the subroutine to a C-compatible name.", "input": "", "output": "        subroutine sirius_get_energy_fermi(kset_id, efermi)&\n            &bind(c, name=\"sirius_get_energy_fermi\")\n            integer,                 intent(in) :: kset_id\n            real(8),                 intent(out) :: efermi\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_gvec_index to retrieve the index of a grid point in the g-vector data structure. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is marked as intent(in) and the output parameter is marked as intent(out).", "input": "", "output": "        subroutine sirius_get_gvec_index(gvec, ig)&\n            &bind(c, name=\"sirius_get_gvec_index\")\n            integer,                  intent(in)  :: gvec(3)\n            integer,                  intent(out) :: ig\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_global_kpoint_index that takes two input parameters of type integer, kset_id and ikloc, and one output parameter of type integer, ik. This subroutine is intended to retrieve the global index of a k-point specified by kset_id and ikloc. Use the bind(c, name=\"sirius_get_global_kpoint_index\") attribute for interoperability with C.", "input": "", "output": "        subroutine sirius_get_global_kpoint_index(kset_id, ikloc, ik)&\n            &bind(c, name=\"sirius_get_global_kpoint_index\")\n            integer,                  intent(in)  :: kset_id\n            integer,                  intent(in) :: ikloc\n            integer,                  intent(out)  :: ik\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_max_num_gkvec to retrieve the maximum number of G+k vectors for a given kset. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The name of the subroutine is sirius_get_max_num_gkvec.", "input": "", "output": "        subroutine sirius_get_max_num_gkvec(kset_id, max_num_gkvec)&\n            &bind(c, name=\"sirius_get_max_num_gkvec\")\n            integer,                 intent(in)  :: kset_id\n            integer,                 intent(out) :: max_num_gkvec\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sirius_get_aw_radial_function\" to retrieve the radial atomic wavefunction for a specific atom, angular momentum, and atomic orbital index. The subroutine should have 3 input parameters of type integer and 1 output parameter of type real(8).", "input": "", "output": "        subroutine sirius_get_aw_radial_function(ia, l, io, f)&\n            &bind(c, name=\"sirius_get_aw_radial_function\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: l\n            integer,                 intent(in)  :: io\n            real(8),                 intent(out) :: f\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_lo_radial_function to retrieve a specific radial function for a given atom and local orbital index. The subroutine should have 2 input parameters of type integer and 1 output parameter of type real(8).", "input": "", "output": "        subroutine sirius_get_lo_radial_function(ia, idxlo, f)&\n            &bind(c, name=\"sirius_get_lo_radial_function\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: idxlo\n            real(8),                 intent(out) :: f\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_beta_projectors_by_kp that takes 6 input parameters: kset_id (integer), vk (real(8)), npw (integer), gvec_k (integer), ld (integer), nkb (integer), and 1 output parameter: vkb (complex(8)). This subroutine is intended to be used with the \"sirius_get_beta_projectors_by_kp\" name in the C language.", "input": "", "output": "        subroutine sirius_get_beta_projectors_by_kp(kset_id, vk, npw, gvec_k, vkb, ld, nkb)&\n            &bind(c, name=\"sirius_get_beta_projectors_by_kp\")\n            integer,                  intent(in)  :: kset_id\n            real(8),                  intent(in)  :: vk\n            integer,                  intent(in)  :: npw\n            integer,                  intent(in)  :: gvec_k\n            complex(8),               intent(out) :: vkb\n            integer,                  intent(in)  :: ld\n            integer,                  intent(in)  :: nkb\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_num_beta_projectors to retrieve the number of beta projectors for a given label. The subroutine takes 1 input parameter of type character array and returns 1 output parameter of type integer. The name of the subroutine is sirius_get_num_beta_projectors.", "input": "", "output": "        subroutine sirius_get_num_beta_projectors(label, num_beta_projectors)&\n            &bind(c, name=\"sirius_get_num_beta_projectors\")\n            character, dimension(*),  intent(in)  :: label\n            integer,                  intent(out) :: num_beta_projectors\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_forces to retrieve forces for a given label. The subroutine should take 1 input parameter of type character array with intent in and 1 output parameter of type real(8) with intent out.", "input": "", "output": "        subroutine sirius_get_forces(label, forces)&\n            &bind(c, name=\"sirius_get_forces\")\n            character, dimension(*), intent(in)  :: label\n            real(8),                 intent(out) :: forces\n        end subroutine\n"}, {"instruction": "Provide a Fortran subroutine named sirius_get_stress_tensor that takes a character array as input and outputs a real(8) value. The input parameter should be of type character and of any size, while the output parameter should be of type real(8).", "input": "", "output": "        subroutine sirius_get_stress_tensor(label, s)&\n            &bind(c, name=\"sirius_get_stress_tensor\")\n            character, dimension(*), intent(in)  :: label\n            real(8),                 intent(out) :: s\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"angeul\" to transform a rotation matrix into Euler angles. The subroutine should have 2 input parameters of type real (kind=8) and logical, where the second parameter is optional. It should also have 1 output parameter of type real (kind=8). The subroutine calculates the Euler angles based on the rotation matrix and returns the angles in radians if the optional logical parameter is present.", "input": "", "output": " subroutine angeul( romtx, angls, rad )\r\n !*************************************************************************\r\n !\r\n !     transformation from rotation matrix to euler's angles\r\n !\r\n !              xg = r xn  : ang glob -> nodl\r\n !\r\n !     angls(1) : rotation about z axe to take x axis in x-y plane\r\n !     angls(2) : rotation about x axe to make z and z coincide\r\n !     angls(3) : rotation about z axe to make x-y coincide with x-y plane\r\n !\r\n !*************************************************************************\r\n implicit none\r\n !dummy arguments\r\n real (kind=8), intent(in) :: romtx(3,3)  !rotation matrix (t1,t2,t3)\r\n real (kind=8), intent(out) :: angls(3)   !euler angles\r\n logical, intent(in), optional :: rad     !if present angles returned in rads\r\n !local variables\r\n real (kind=8)  cosda,cosdg,sinda,sindg\r\n real (kind=8), parameter :: pid2  = 1.5707963267948966192313216916398, &   ! pid2 = atan(1d0)*2d0\r\n                             pi    = 3.1415926535897932384626433832795, &   ! pi   = 2d0*pid2\r\n                             facto = 57.295779513082320876798154814105, &   ! facto= 180d0/pi\r\n                             cuzer =1.0d-12\r\n\r\n\r\n if ( romtx(3,3) >= 1d0 ) then          !full positive proyection over z axis\r\n   angls(2) = 0d0                           !second angle is null\r\n else if ( romtx(3,3) <= -1d0) then     !full negative proyection over z axis\r\n   angls(2) = pi                            !second angle is pi\r\n else                                   ! an intermediate angle exist\r\n   angls(2) = acos( romtx(3,3) )            !compute angle\r\n end if\r\n if (angls(2) == 0d0) then              !if t3 is along z axis\r\n   angls(1) = 0d0                           !first angle is null\r\n else\r\n   if ( abs(romtx(2,3)) < cuzer ) then\r\n     if (romtx(1,3) > 0d0) then\r\n        angls(1) = pid2\r\n     else\r\n        angls(1) =-pid2\r\n     end if\r\n   else\r\n     angls(1) = atan( -romtx(1,3)/romtx(2,3) )\r\n     if (romtx(2,3) > 0d0 ) angls(1) = angls(1) + pi  !  cosine of beta negative\r\n   end if\r\n end if\r\n cosda = cos(angls(1))\r\n sinda = sin(angls(1))\r\n cosdg = romtx(1,1)*cosda + romtx(2,1)*sinda\r\n sindg =-romtx(1,2)*cosda - romtx(2,2)*sinda\r\n if (abs(cosdg) < cuzer) then\r\n   if (sindg > 0d0) then\r\n     angls(3) = pid2\r\n   else\r\n     angls(3) =-pid2\r\n   end if\r\n else\r\n   angls(3) = atan( sindg/cosdg )\r\n   if (cosdg < 0.0) angls(3) = angls(3) + pi      ! cosine negative\r\n end if\r\n\r\n ! if code rad is not used in calling\r\n if (.not.present (rad))  angls = angls*facto     ! change radians to degrees\r\n\r\n return\r\n end subroutine angeul\r\n"}, {"instruction": "Create a Fortran subroutine named init_deriv to initialize an array of wavenumbers based on the input domain length and number of wavenumbers. The subroutine takes 2 input parameters of type integer and double precision. It outputs an array of wavenumbers of type double precision. If the domain length is non-zero, the wavenumbers are calculated based on the domain length; otherwise, the subroutine terminates with an error message.", "input": "", "output": "        subroutine init_deriv(n, l, k)\n            integer,          intent(in)  :: n\n            double precision, intent(in)  :: l\n            double precision, intent(out) :: k(n)\n            double precision              :: sc\n            integer                       :: i\n\n            ! define wavenumber array:\n            if (l .ne. zero) then\n                ! define wavenumbers:\n                sc = pi / l\n                do i = 1, n\n                    k(i) = sc * dble(i)\n                enddo\n            else\n                ! catastrophic end to run if wave number definition fails:\n                write(*,*) '**********************************************'\n                write(*,*) ' wavenumber array definition not possible.'\n                write(*,*) ' domain length equal to zero not allowed.'\n                write(*,*) ' stopping...'\n                write(*,*) '**********************************************'\n                stop\n            endif\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named deriv to perform a differentiation operation using wavenumber multiplication. The subroutine takes 4 input parameters: two integers (m and n), an array of double precision numbers (k), and a 2D array of double precision numbers (var). It produces 1 output parameter of type double precision (der).", "input": "", "output": "        subroutine deriv(m, n, k, var, der)\n            integer,          intent(in)  :: m, n\n            double precision, intent(in)  :: k(n), var(m,n)\n            double precision, intent(out) :: der(m,n)\n            integer                       :: nw, np2, i, j, ic\n            double precision              :: ktmp\n\n            nw = n / 2\n            np2 = n + 2\n\n            ! carry out differentiation by wavenumber multiplication:\n            do j=1,m\n                der(j, 1) = zero\n            enddo\n\n            do i = 2, n - nw\n                ktmp = k(2*(i-1))\n                ic = np2 - i\n                do j = 1, m\n                    der(j, i) = -ktmp * var(j,ic)\n                    der(j,ic) =  ktmp * var(j ,i)\n                enddo\n            enddo\n\n            if (mod(n,2) == 0) then\n                ic=nw+1\n                do j = 1, m\n                    der(j,ic) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named struct_sizes to read structural information from a file. The subroutine takes 1 input parameter of type character*80. It has 8 output parameters of types integer, integer, integer, character*4, real*8, real*8, real*8, and real*8. The subroutine reads the structural information from the provided file and outputs the lattice parameters, atomic positions, and other relevant data.", "input": "", "output": "subroutine struct_sizes(nat,nsym,ndif,lattic,aa,bb,cc,alpha,structf)\n  implicit none\n  character*80, intent(in):: structf\n  integer, intent(out)    :: nat, nsym, ndif\n  character*4, intent(out):: lattic\n  real*8, intent(out)      :: aa,bb,cc,alpha(3)\n  !----------- local variables ---------------\n  character*4  :: irel,cform\n  character*80 :: title\n  character*10 :: aname\n  real*8       :: r0,rmt,zz,rotloc(3,3),pos(3)\n  integer      :: iord,ios,mult,jrj,iatnr,isplit,index,i,j,m,jatom\n\n  open(20,file=structf,status='old')\n  read (20,1000) title\n  read (20,1010) lattic,nat,cform,irel\n  read (20,1020) aa,bb,cc,alpha(1),alpha(2),alpha(3)\n\n  if(abs(alpha(1)).lt.1.d-5) alpha(1)=90.\n  if(abs(alpha(2)).lt.1.d-5) alpha(2)=90.\n  if(abs(alpha(3)).lt.1.d-5) alpha(3)=90.\n  \n  index=0\n  do jatom=1,nat\n     index=index+1\n     read(20,1030,iostat=ios) iatnr,( pos(j),j=1,3 ), mult,isplit \n     if(ios /= 0 ) then\n        write(6,*) iatnr,( pos(j),j=1,3 ), mult,isplit\n        write(6,*) 'error in struct file read'\n        stop\n     endif\n     if (mult .eq. 0) then\n        write (6,6000) jatom, index, mult\n        stop\n     endif\n     do m=1,mult-1                                     \n        index=index+1                                            \n        read(20,1031) iatnr,( pos(j),j=1,3)   ! pos -- position inside the unit cell read from case.struct\n     enddo\n     read(20,1050) aname,jrj,r0,rmt,zz ! zz-nuclear charge, jrj--number of radial data points\n     read(20,1051) ((rotloc(i,j),i=1,3),j=1,3)\n  enddo\n  ndif=index\n  read(20,1151) iord\n  nsym=iord\n\n  close(20)\n1000 format(a80)                                                       \n1010 format(a4,23x,i3,1x,a4,/,13x,a4,18x,a4)                                 \n1020 format(6f10.7,10x,f10.7)                                          \n1030 format(4x,i4,4x,f10.7,3x,f10.7,3x,f10.7,/,15x,i2,17x,i2)          \n1031 format(4x,i4,4x,f10.7,3x,f10.7,3x,f10.7)                          \n1050 format(a10,5x,i5,5x,f10.9,5x,f10.5,5x,f10.5)                      \n1051 format(20x,3f10.8)\n1151 format(i4)\n6000 format(///,3x,'error in struct-read : mult(jatom)=0 ...',/, 20x,'jatom=',i3,3x,'index=',i3,3x,'mult=',i3)\nend subroutine struct_sizes\n"}, {"instruction": "Create a Fortran subroutine named centroid to calculate the centroid of a set of points in a multi-dimensional space. The subroutine takes 3 input parameters: n (integer), dim (integer), pos (real(8) array of dimension n,dim), and returns 1 output parameter: ret (real(8) array of dimension dim).", "input": "", "output": "subroutine centroid(pos, ret, n, dim)\n    implicit none\n    integer, intent(in) :: n, dim\n    real(8), dimension(n,dim), intent(in) :: pos\n    real(8), dimension(dim), intent(out) :: ret\n    ret = sum(pos, 1) / real(n)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named crossprod3 to calculate the cross product of two vectors in 3-dimensional space. The subroutine takes 3 input parameters: an integer dim, and two real*8 arrays of dimension dim, r1 and r2. The output is a real*8 array of dimension dim, ret. If the input dimension is not 3, the subroutine prints an error message and stops.", "input": "", "output": "subroutine crossprod3(r1, r2, ret, dim)\n    integer, intent(in) :: dim\n    real(8), dimension(dim), intent(in) :: r1, r2\n    real(8), dimension(dim), intent(out) :: ret\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    ret(1) = r1(2)*r2(3) - r1(3)*r2(2)\n    ret(2) = r1(3)*r2(1) - r1(1)*r2(3)\n    ret(3) = r1(1)*r2(2) - r1(2)*r2(1)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named reimage to perform the re-imaging of positions within a periodic box. The subroutine takes 5 input parameters of types integer, integer, real(8) array with dimensions (npos, dim), real(8) array with dimensions (dim), and real(8) array with dimensions (dim). It also has 1 output parameter of type real(8) array with dimensions (npos, dim).", "input": "", "output": "subroutine reimage(pos, refpos, boxl, reimagedpos, npos, dim)\n    implicit none\n    integer, intent(in) :: npos, dim\n    real(8), dimension(npos, dim), intent(in) :: pos\n    real(8), dimension(dim), intent(in) :: refpos\n    real(8), dimension(dim), intent(in) :: boxl\n    real(8), dimension(npos, dim), intent(out) :: reimagedpos\n    integer :: i\n    real(8), dimension(dim) :: distvec, iboxl\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    do i = 1, npos\n        distvec = pos(i,:) - refpos\n        distvec = distvec - boxl * anint(distvec * iboxl)\n        reimagedpos(i,:) = refpos + distvec\n    enddo            \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named spherepoints to generate points on the surface of a sphere. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type real(8) with dimensions n by 3.", "input": "", "output": "subroutine spherepoints(n, points)\n    implicit none\n    integer, intent(in) :: n\n    real(8), dimension(n,3), intent(out) :: points\n    real(8) :: off, y, phi, r\n    real(8) :: inc \n    real(8), parameter :: pi = 3.1415926535897931d0 \n    integer :: k\n    inc = pi * (3. - sqrt(5.))\n    points = 0.\n    off = 2. / real(n)\n    do k = 1, n\n        y = real(k-1) * off - 1. + (off * 0.5)\n        r = sqrt(max(1. - y*y, 0.))\n        phi = real(k-1) * inc\n        points(k,1) = cos(phi)*r\n        points(k,2) = y\n        points(k,3) = sin(phi)*r\n    enddo\nend subroutine\n"}, {"instruction": "The subroutine named spheresurfaceareas is written in Fortran to calculate the surface areas of spheres and determine their exposure. The subroutine takes 8 input parameters and 2 output parameters. The input parameters are of the types integer, real(8) arrays, logical arrays, and real(8) scalars, while the output parameters are of the types real(8) arrays and logical arrays.", "input": "", "output": "subroutine spheresurfaceareas(pos, radii, points, nexp, boxl, areas, exposed, nsphere, npoints, dim)\n    implicit none\n    integer, intent(in) :: dim\n    real(8), dimension(nsphere, dim), intent(in) :: pos\n    real(8), dimension(nsphere), intent(in) :: radii\n    real(8), dimension(npoints, dim), intent(in) :: points\n    integer, intent(in) :: nexp\n    real(8), dimension(dim), intent(in) :: boxl\n    real(8), dimension(nsphere), intent(out) :: areas\n    logical, dimension(nsphere), intent(out) :: exposed\n    real(8), parameter :: pi = 3.141592653589d0 \n    integer, intent(in) :: nsphere, npoints\n    integer :: i, j, k\n    real(8), dimension(npoints,dim) :: thispoints\n    real(8) :: areaperpoint\n    real(8), dimension(nsphere) :: radiisq\n    real(8), dimension(dim) :: ipos, jpos\n    real(8), dimension(dim) :: distvec, iboxl\n    logical, dimension(npoints) :: tempexposed\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0) \n    areas = 0.\n    exposed = .false.\n    radiisq = radii*radii\n    do i = 1, nsphere\n        ipos = pos(i,:)\n        areaperpoint = 4.*pi*radii(i)**2 / real(npoints)\n        tempexposed = .true.\n        do k = 1, npoints\n            thispoints(k,:) = points(k,:) * radii(i) + ipos\n        enddo\n        do j = 1, nsphere\n            if (i == j) cycle\n            jpos = pos(j,:)\n            distvec = jpos - ipos \n            distvec = distvec - boxl * anint(distvec * iboxl)\n            jpos = ipos + distvec\n            if (.not. any(tempexposed)) exit\n            !first check if spheres are far from each other\n            if (sum((jpos-ipos)**2) > (radii(i) + radii(j))**2) cycle\n            do k = 1, npoints\n                if (.not. tempexposed(k)) cycle\n                if (sum((thispoints(k,:) - jpos)**2) < radiisq(j)) tempexposed(k) = .false.\n            enddo\n        enddo\n        areas(i) = areaperpoint * real(count(tempexposed))\n        if (count(tempexposed) >= nexp) exposed(i) = .true.\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named spherevolumes to calculate the volumes of spheres based on their positions and radii in a given grid. The subroutine takes 5 input parameters of types integer, real(8) arrays, real(8), and integer, and returns 1 output parameter of type real(8) array.", "input": "", "output": "subroutine spherevolumes(pos, radii, dx, volumes, nsphere, dim)\n    implicit none\n    integer, intent(in) :: dim\n    real(8), dimension(nsphere, dim), intent(in) :: pos\n    real(8), dimension(nsphere), intent(in) :: radii\n    real(8),  intent(in) :: dx\n    real(8), dimension(nsphere), intent(out) :: volumes\n    integer, intent(in) :: nsphere\n    real(8), dimension(nsphere) :: radiisq\n    real(8) :: mindistsq, distsq, dv\n    integer :: i,j\n    real(8), dimension(dim) :: pos2, minpos, maxpos\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    radiisq = radii*radii\n    volumes = 0.\n    dv = dx*dx*dx\n    minpos = (/minval(pos(:,1) - radii), minval(pos(:,2) - radii), minval(pos(:,3) - radii)/)\n    maxpos = (/maxval(pos(:,1) + radii), maxval(pos(:,2) + radii), maxval(pos(:,3) + radii)/)\n    maxpos = maxpos + dx * 0.5    \n    !first do a coarse grid check to see which spheres are where\n    pos2 = minpos\n    do while (all(pos2 < maxpos))\n        j = 0\n        mindistsq = huge(1.d0)\n        do i = 1, nsphere\n            distsq = sum((pos(i,:) - pos2)**2)\n            if (distsq < mindistsq .and. distsq < radiisq(i)) then\n                mindistsq = distsq\n                j = i\n            endif\n        enddo\n        if (j > 0) volumes(j) = volumes(j) + dv\n        pos2(1) = pos2(1) + dx\n        do i = 1, 2\n            if (pos2(i) >= maxpos(i)) then\n                pos2(i) = minpos(i)\n                pos2(i+1) = pos2(i+1) + dx\n            endif\n        enddo\n    enddo   \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named radialdist to calculate the radial distribution function (RDF) between two sets of 3D coordinates. The subroutine takes 8 input parameters: pos1 (real(8) array of dimension npos1 x 3), pos2 (real(8) array of dimension npos2 x 3), binwidth (real(8)), totbins (integer), bulkdens (real(8)), boxl (real(8) array of dimension 3), npos1 (integer), and npos2 (integer). It produces 1 output parameter: rdf (real(8) array of dimension totbins).", "input": "", "output": "subroutine radialdist(pos1, pos2, binwidth, totbins, bulkdens, boxl, rdf, npos1, npos2)\n    implicit none\n    real(8), dimension(npos1, 3), intent(in) :: pos1\n    real(8), dimension(npos2, 3), intent(in) :: pos2\n    real(8), intent(in) :: binwidth\n    integer, intent(in) :: totbins\n    ! total number of bins, so max bin value is totbins*binwidth; if larger ignored\n    real(8), intent(in) :: bulkdens\n    real(8), dimension(3), intent(in) :: boxl\n    real(8), dimension(totbins), intent(out) :: rdf\n    integer, intent(in) :: npos1, npos2\n    real(8), parameter :: pi = 3.141592653589d0\n    real(8), dimension(totbins) :: counts\n    real(8), dimension(3) :: ipos, jpos, iboxl, distvec\n    real(8) :: dist\n    integer :: nbin, i, j, k\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    counts = 0.\n    do i = 1, npos2\n        ipos = pos2(i,:)\n        do j = 1, npos1\n            jpos = pos1(j,:)\n            distvec = jpos - ipos\n            distvec = distvec - boxl * anint(distvec * iboxl)\n            dist = sqrt(sum(distvec**2))\n            ! place in correct bin\n            nbin = ceiling(dist / binwidth) ! bin i has all distances less than i but greater than i - 1\n            if (nbin <= totbins) then\n                counts(nbin) = counts(nbin) + 1.\n            endif\n            ! if beyond max of totbins*binwidth, just don't include\n        enddo\n    enddo\n    ! normalize counts correctly\n    do k = 1, totbins\n        rdf(k) = counts(k) / (npos1 * bulkdens * (4./3.) * pi * (binwidth**3) * ((k**3) - ((k-1)**3)))\n    enddo\n    ! gives g(r) for single snapshot... for whole trajectory, do for each frame and average\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named solventshells to determine the solvent shells around particles. The subroutine takes 6 input parameters of types real(8), dimension(npos1, 3), real(8), dimension(npos2, 3), real(8), real(8), integer, and integer. It also has 2 output parameters of types logical, dimension(npos2), and logical, dimension(npos2). The subroutine uses the imperative tone and its purpose is to compute solvent shells based on the positions and distances provided.", "input": "", "output": "subroutine solventshells(pos1, pos2, dist1, dist2, shell1, shell2, npos1, npos2)\n    implicit none\n    real(8), dimension(npos1, 3), intent(in) :: pos1\n    real(8), dimension(npos2, 3), intent(in) :: pos2\n    real(8), intent(in) :: dist1, dist2\n    logical, dimension(npos2), intent(out) :: shell1, shell2\n    integer, intent(in) :: npos1, npos2\n    real(8), dimension(npos1) :: tempdists\n    real(8), dimension(3) :: ipos, jpos\n    integer :: i, j\n    real(8) :: dist1sq, dist2sq\n    shell1 = .false.\n    shell2 = .false.\n    dist1sq = dist1*dist1\n    dist2sq = dist2*dist2\n    do i = 1, npos2\n        ipos = pos2(i,:)\n        tempdists = 0.\n        do j = 1, npos1\n            jpos = pos1(j,:)\n            tempdists(j) = sum((jpos - ipos)**2)\n        enddo\n        if (minval(tempdists) <= dist1sq) then\n            shell1(i) = .true.\n        else if (minval(tempdists) <= dist2sq) then\n            shell2(i) = .true.\n        endif\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"bbhbonds\" to calculate the number of hydrogen bonds between peptide acceptors and donors. The subroutine should have 6 input parameters of type real(8), dimension(npepacc, 3), real(8), dimension(npepdon, 3), real(8), real(8), and integer. It should also have 3 output parameters of type integer, integer, dimension(npepacc), and integer, dimension(npepdon).", "input": "", "output": "subroutine bbhbonds(pepacc, pepdon, distcut, angcut, nbonds, pepaccout, pepdonout, npepacc, npepdon)\n    implicit none\n    real(8), dimension(npepacc, 3), intent(in) :: pepacc\n    real(8), dimension(npepdon, 3), intent(in) :: pepdon\n    real(8), intent(in) :: distcut, angcut\n    integer, intent(out) :: nbonds\n    integer, dimension(npepacc), intent(out) :: pepaccout\n    integer, dimension(npepdon), intent(out) :: pepdonout\n    integer, intent(in) :: npepacc, npepdon\n    real(8) :: distcutsq, cosangcut\n    real(8), parameter :: pi = 3.1415926535897931d0\n    real(8), parameter :: radperdeg = pi / 180.d0\n    integer j, i\n    real(8), dimension(3) :: apos, bondvec1, heavypos, hpos, vecpep\n    real(8) :: bonddist1sq, cosang1\n    nbonds = 0\n    pepaccout = 0\n    pepdonout = 0\n    distcutsq = distcut * distcut\n    cosangcut = cos(angcut * radperdeg)\n    if (mod(npepdon, 2) /= 0) then\n        print *, \"peptide donor position array does not have length of a factor of 2.\"\n        stop\n    endif\n    ! loop over peptide donors (hydrogens with attached heavy atom 1 index behind!)\n    do i = 1, npepdon, 2\n        heavypos = pepdon(i,:)\n        hpos = pepdon(i+1,:)\n        ! loop over peptide acceptors\n        ! could be more efficient by excluding h attached to same heavy atom...\n        ! simpler this way, and ok because will register cosang1 of -1 and not be considered\n        do j = 1, npepacc\n            apos = pepacc(j,:)\n            bondvec1 = apos - hpos\n            bonddist1sq = sum(bondvec1**2)\n            if (bonddist1sq < distcutsq) then\n                vecpep = hpos - heavypos\n                cosang1 = dot_product(bondvec1, vecpep) / sqrt(bonddist1sq * sum(vecpep**2))\n                if (cosang1 > cosangcut) then\n                    nbonds = nbonds + 1\n                    pepdonout(i+1) = pepdonout(i+1) + 1\n                    pepaccout(j) = pepaccout(j) + 1\n                endif\n            endif\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named nearneighbors to determine the neighboring particles within a specified distance range. The subroutine takes 7 input parameters of type real(8), dimension(nsubpos, 3), real(8), dimension(npos, 3), real(8), dimension(3), real(8), real(8), integer, integer and 1 output parameter of type logical, dimension(nsubpos, npos).", "input": "", "output": "subroutine nearneighbors(subpos, pos, boxl, lowcut, highcut, nneighbors, nsubpos, npos)\n    implicit none\n    real(8), dimension(nsubpos, 3), intent(in) :: subpos\n    real(8), dimension(npos, 3), intent(in) :: pos\n    real(8), dimension(3), intent(in) :: boxl\n    real(8), intent(in) :: lowcut, highcut\n    integer, intent(in) :: nsubpos\n    integer, intent(in) :: npos\n    logical, dimension(nsubpos, npos), intent(out) :: nneighbors\n    integer :: i, j\n    real(8), dimension(3) :: iboxl\n    real(8), dimension(3) :: pos1, pos2, distvec\n    real(8) :: lowsq, highsq, distvecsq\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0) \n    lowsq = lowcut*lowcut\n    highsq = highcut*highcut\n    nneighbors = .false.\n    ! loop over all positions in subpos (may be subset of pos)\n    do i = 1, nsubpos\n        pos1 = subpos(i,:)\n        ! loop over all positions in pos\n        do j = 1, npos\n            pos2 = pos(j,:)\n            distvec = pos2 - pos1\n            ! must re-image individually to account for periodicity to be accurate\n            distvec  = distvec - boxl * anint(distvec * iboxl)\n            distvecsq = sum(distvec**2)\n            if ( (distvecsq > lowsq) .and. (distvecsq <= highsq) ) then\n                ! lower cut-off not included... lazy, really, but prevents including same atom\n                nneighbors(i,j) = .true.\n            endif\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"calcsd\" to calculate the squared displacement of coordinates. The subroutine takes 7 input parameters of the types real(8), dimension(npos, 3), real(8), dimension(nprevpos, 3), real(8), dimension(nrefpos, 3), real(8), dimension(3), integer, integer, integer. It also has 2 output parameters of the types real(8), dimension(npos, 3) and real(8), dimension(npos, 3).", "input": "", "output": "subroutine calcsd(pos, prevpos, refpos, boxl, allsd, newpos, npos, nprevpos, nrefpos)\n    implicit none\n    real(8), dimension(npos, 3), intent(in) :: pos\n    real(8), dimension(nprevpos, 3), intent(in) :: prevpos\n    real(8), dimension(nrefpos, 3), intent(in) :: refpos\n    real(8), dimension(3), intent(in) :: boxl\n    integer, intent(in) :: npos, nprevpos, nrefpos\n    real(8), dimension(npos, 3), intent(out) :: allsd\n    real(8), dimension(npos, 3), intent(out) :: newpos\n    real(8), dimension(3) :: iboxl, avec, distvec\n    integer :: i\n    ! first check if npos matches nrefpos, if not quit\n    if (npos /= nrefpos .or. nprevpos /= npos) then\n        print *, 'number of current and reference coordinates must match.', npos, nprevpos, nrefpos\n        stop\n    endif\n    ! set up imaging/unwrapping\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    ! loop over coordinates, calc squared displacement\n    do i = 1, npos\n        ! first unwrap to find new coordinate without pbcs\n        avec = pos(i,:) - prevpos(i,:)\n        avec = avec - boxl * anint(avec * iboxl)\n        newpos(i,:) = prevpos(i,:) + avec\n        ! now calculate squared displacement from reference\n        distvec = newpos(i,:) - refpos(i,:)\n        allsd(i,:) = distvec**2\n    enddo\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named binongrid to perform binning of spatial points into a 3D histogram. The number of input parameters is 8, consisting of real(8) and integer arrays, representing spatial coordinates and bin sizes. The number of output parameters is 1, an integer array representing the 3D histogram.", "input": "", "output": "subroutine binongrid(opos, xbins, ybins, zbins, outhist, nopos, nx, ny, nz)\n    implicit none\n    real(8), dimension(nopos, 3), intent(in) :: opos\n    real(8), dimension(nx), intent(in) :: xbins\n    real(8), dimension(ny), intent(in) :: ybins\n    real(8), dimension(nz), intent(in) :: zbins\n    integer, intent(in) :: nopos, nx, ny, nz\n    integer, dimension(nx-1, ny-1, nz-1), intent(out) :: outhist\n    real(8) :: binwidth, radsq, thisdistsq\n    integer :: thisxbin, thisybin, thiszbin\n    real(8), dimension(3) :: thisvec\n    integer :: i\n    ! find all bin widths - assumes uniform bins!\n    binwidth = xbins(2) - xbins(1)\n    ! also assumes all binwidths are the same in each dimension, i.e. have cubes\n    if (ybins(2) - ybins(1) /= binwidth .or. zbins(2) - zbins(1) /= binwidth) then\n        print *, 'must break volume into cubes. currently, bin-widths do not match.'\n        stop \n    endif\n    radsq = binwidth*binwidth/4.0d0\n    ! initiate outhist\n    outhist = 0\n    do i = 1, nopos\n        ! find x, y, and z bins - inclusive on left edge, exclusive on right\n        ! not considered if out of bin range\n        thisxbin = floor((opos(i,1) - xbins(1)) / binwidth) + 1\n        ! make sure actually in range of bins\n        if (thisxbin < 1 .or. thisxbin > (nx-1)) then\n            cycle\n        else\n            thisybin = floor((opos(i,2) - ybins(1)) / binwidth) + 1\n            if (thisybin < 1 .or. thisybin > (ny-1)) then\n                cycle\n            else\n                thiszbin = floor((opos(i,3) - zbins(1)) / binwidth) + 1\n                if (thiszbin < 1 .or. thiszbin > (nz-1)) then\n                    cycle\n                else\n                    ! add one to outhist if also in sphere within cube\n                    thisvec(1) = opos(i,1) - (xbins(thisxbin) + binwidth*0.5d0)\n                    thisvec(2) = opos(i,2) - (ybins(thisybin) + binwidth*0.5d0)\n                    thisvec(3) = opos(i,3) - (zbins(thiszbin) + binwidth*0.5d0)\n                    thisdistsq = sum(thisvec*thisvec)\n                    if (thisdistsq <= radsq) then\n                        outhist(thisxbin, thisybin, thiszbin) = outhist(thisxbin, thisybin, thiszbin) + 1\n                    else\n                        cycle\n                    endif\n                endif\n            endif\n        endif\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named distancemetric1b to calculate the distance metric between two 6-dimensional vectors. The subroutine should take 4 input parameters of type real(8) and dimension(6) for vec1, vec2, rsq, and sintw, and 1 output parameter of type real(8) for dist.", "input": "", "output": "subroutine distancemetric1b(vec1, vec2, rsq, sintw, dist)\n    implicit none\n    real(8), dimension(6), intent(in) :: vec1\n    real(8), dimension(6), intent(in) :: vec2\n    real(8), intent(in) :: rsq, sintw\n    real(8), intent(out) :: dist\n    real(8), dimension(6) :: diffs, dsqvec\n    diffs = (vec2 - vec1)*(vec2 - vec1)\n    dsqvec(1) = diffs(1)\n    dsqvec(2) = diffs(2)\n    dsqvec(3) = diffs(3)\n    dsqvec(4) = rsq*diffs(4)\n    dsqvec(5) = rsq*sin(vec2(4))*sin(vec1(4))*diffs(5)\n    dsqvec(6) = rsq*sintw*diffs(6)\n    dist = sqrt(sum(dsqvec))\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named distancemetric2b to calculate the distance metric between two 12-dimensional vectors. The subroutine takes 4 input parameters of type real(8) and dimension(12): vec1, vec2, rsq, and sintw. It also has 1 output parameter of type real(8) to store the calculated distance.", "input": "", "output": "subroutine distancemetric2b(vec1, vec2, rsq, sintw, dist)\n    implicit none\n    real(8), dimension(12), intent(in) :: vec1\n    real(8), dimension(12), intent(in) :: vec2\n    real(8), intent(in) :: rsq, sintw\n    real(8), intent(out) :: dist\n    real(8), dimension(12) :: diffs, dsqvec\n    diffs = (vec2 - vec1)*(vec2 - vec1)\n    dsqvec(1) = diffs(1)\n    dsqvec(2) = diffs(2)\n    dsqvec(3) = diffs(3)\n    dsqvec(4) = rsq*diffs(4)\n    dsqvec(5) = rsq*sin(vec2(4))*sin(vec1(4))*diffs(5)\n    dsqvec(6) = rsq*sintw*diffs(6)\n    dsqvec(7) = diffs(7)\n    dsqvec(8) = rsq*diffs(8)\n    dsqvec(9) = rsq*diffs(9)\n    dsqvec(10) = rsq*sin(vec2(9))*sin(vec1(9))*diffs(10)\n    dsqvec(11) = rsq*sintw*diffs(11)\n    dsqvec(12) = rsq*sintw*diffs(12)\n    dist = sqrt(sum(dsqvec))\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named vectorcrossproduct to calculate the cross product of two 3D vectors. The subroutine should take 2 input parameters of type real(kind=8) arrays, both of size 3, and 1 output parameter of type real(kind=8) array of size 3. The subroutine should compute the cross product of the input vectors and store the result in the output array.", "input": "", "output": "  subroutine vectorcrossproduct(v1,v2,y)\n\n    implicit none\n\n    real(kind=8), intent(in)  :: v1(3), v2(3)\n    real(kind=8), intent(out) :: y(3)\n\n    y(1) = v1(2)*v2(3) - v1(3)*v2(2)\n    y(2) = v1(3)*v2(1) - v1(1)*v2(3)\n    y(3) = v1(1)*v2(2) - v1(2)*v2(1)\n    \n  end subroutine vectorcrossproduct\n"}, {"instruction": "Create a Fortran subroutine named assemble_system_dirichlet to assemble a linear system for a Dirichlet boundary condition. The subroutine takes 4 input parameters of type real(8), real(8), integer, and logical, and 4 output parameters of type real(8), real(8), real(8) and real(8). The subroutine assembles a banded matrix, computes the right-hand side, and initializes the solution profile. If specified, it also constructs a preconditioner using a sine transform matrix and a diagonal matrix.", "input": "", "output": "  subroutine assemble_system_dirichlet(a, b, npts, v, rhs, u, p, ispreconditioned)\n\n    implicit none\n\n    real(8), intent(in)  :: a, b ! bounds of the domain\n    integer, intent(in)  :: npts ! number of interior points\n    real(8), intent(out) :: v(npts,npts) ! banded matrix\n    real(8), intent(out) :: rhs(npts)\n    real(8), intent(out) :: u(npts)\n    real(8), intent(out) :: p(npts,npts)\n    real(8) :: s(npts,npts), d(npts, npts)\n\n    real(8), parameter :: pi = 3.141592653589793d0\n    real(8)            :: h, alpha\n    integer            :: m, n\n    integer            :: i, j, k\n\n    logical, intent(in) :: ispreconditioned\n    \n    ! h = width / num_interior_pts + 1\n    h = (b-a)/dble(npts+1)\n    v = 0.0d0\n\n    ! size of the linear system = unknowns (interior nodes)\n    m = npts ! nrows\n    n = npts ! ncols\n\n    ! set the inner block\n    rows: do i = 1, m\n       cols: do j = 1, n\n          if (j .eq. i-1) then\n             ! lower triangle\n             v(j,i) = -1.0d0\n          else if (j .eq. i+1) then           \n             ! upper triangle\n             v(j,i) = -1.0d0\n          else if (j .eq. i) then           \n             ! diagonal\n             v(j,i) = 2.0d0\n          else\n             ! skip\n          end if\n       end do cols\n    end do rows\n\n    ! assemble the rhs\n    do i = 1, m\n       rhs(i) = h*h*(2.0d0*dble(i)*h - 0.5d0)\n    end do\n    rhs(1) = rhs(1) + 1.0d0\n    rhs(m) = rhs(m)\n\n    ! initial solution profile use sin function as a first guess\n    do i = 1, m\n       u(i) =  sin(dble(i)*h*pi)\n    end do\n\n    if (ispreconditioned .eqv. .true.) then\n       ! find the sine transform matrix\n       alpha = sqrt(2.0d0/dble(npts+1))\n       do j = 1, m\n          do k = 1, n\n             s(k,j) = alpha*sin(pi*dble(j*k)/dble(npts+1))\n          end do\n       end do\n\n       ! find the diagonal matrix\n       d = matmul(s, matmul(v, s))\n\n       ! invert the digonal matrix easily\n       do j = 1, m\n          d(j,j) = 1.0d0/d(j,j)\n       end do\n\n       ! define the preconditioner\n       p = matmul(s, matmul(d, s))\n    end if\n\nend subroutine assemble_system_dirichlet\n"}, {"instruction": "Write a Fortran subroutine named check_data_format to determine the format of the input data. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is the unit number for the input data, and the output parameter is the format indicator (1 for 4 data in one line, 0 for 3 data).", "input": "", "output": "subroutine check_data_format( unit, iformat )\n  implicit none\n  integer,intent(in) :: unit\n  integer,intent(out) :: iformat\n  character(100) :: ccc\n  character(1) :: b(4)\n  read(unit,'(a)') ccc\n  backspace(unit)\n  read(ccc,*,end=9) b\n  iformat=1 ! 4 data in one line\n  return\n9 iformat=0 ! 3 data\nend subroutine check_data_format\n"}, {"instruction": "Create a Fortran subroutine named mat_mul_1 to perform matrix multiplication. The subroutine takes 2 input parameters of type real*8, representing matrices mat_a and mat_b, and 1 output parameter of type real*8 representing the result matrix mat_c. The subroutine uses nested do-loops to compute the matrix multiplication.", "input": "", "output": "subroutine mat_mul_1(mat_a,mat_b,mat_c)\n\timplicit none\n\treal*8, intent(in):: mat_a(:,:), mat_b(:,:)\n\treal*8, intent(out) :: mat_c(:,:)\n\tinteger*4:: m,n,o,p,ii,jj,kk\n\treal*8:: cumulative\n\tinteger*4:: shape_a(2), shape_b(2)\n\t\n\tshape_a = shape(mat_a)\n\tshape_b = shape(mat_b)\n\tm = shape_a(1)\n\tn = shape_a(2)\n\to = shape_b(1)\n\tp = shape_b(2)\n\t\n\tdo ii = 1,m\n\t\tdo jj = 1, p\n\t\t\tcumulative = 0.d0\n\t\t\tdo kk = 1, n\n\t\t\t\tcumulative = cumulative + mat_a(ii,kk)*mat_b(kk,jj)\n\t\t\tend do\n\t\t\tmat_c(ii,jj) = cumulative\n\t\tend do\n\tend do\n\t\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named bcnd to handle boundary conditions for a differential equation system. The subroutine takes 7 input parameters of types integer and double precision, and 2 output parameters of type double precision. The purpose of the subroutine is to calculate boundary conditions for periodicity and Floquet eigenvalue/vector boundary relation. Use the imperative tone to implement this functionality.", "input": "", "output": " subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc)\n!---------- ----\n\n   implicit none\n   integer, intent(in) :: ndim, icp(*), nbc, ijac\n   double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n   double precision, intent(out) :: fb(nbc), dbc(nbc,*)\n\n   double precision fm\n\n! periodicity boundary conditions\n   fb(1:6) = u0(1:6) - u1(1:6)\n\n! floquet eigenvalue/vector boundary relation\n   fm = par(4)\n   fb(7:12) = u1(7:12) - fm*u0(7:12)\n\n end subroutine bcnd\n"}, {"instruction": "Create a Fortran subroutine named utility_cart_to_frac to convert from Cartesian to fractional coordinates. The subroutine takes 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are recip_lat(3,3) and cart(3), while the output parameter is frac(3).", "input": "", "output": "  subroutine utility_cart_to_frac(cart,frac,recip_lat)\n    !==================================================================!\n    !                                                                  !\n    !!  convert from cartesian to fractional coordinates\n    !                                                                  !\n    !===================================================================\n    implicit none\n\n    real*8, intent(in)  :: recip_lat(3,3)\n    real*8, intent(out) :: frac(3)\n    real*8, intent(in)  :: cart(3)\n\n    integer :: i\n\n    do i=1,3\n       frac(i)=recip_lat(i,1)*cart(1) + recip_lat(i,2)*cart(2) + recip_lat(i,3)*cart(3)\n    end do\n\n    frac=frac/(2.0*acos(-1.0))\n\n\n  end subroutine utility_cart_to_frac\n"}, {"instruction": "Create a Fortran subroutine named utility_frac_to_cart to convert fractional coordinates to Cartesian coordinates. The subroutine should have 2 input parameters of type real*8, representing the real_lat matrix and the fractional coordinates, and 1 output parameter of type real*8 for the Cartesian coordinates.", "input": "", "output": "  subroutine utility_frac_to_cart(frac,cart,real_lat)\n    !==================================================================!\n    !                                                                  !\n    !!  convert from fractional to cartesian coordinates\n    !                                                                  !\n    !===================================================================\n    implicit none\n\n    real*8, intent(in)  :: real_lat(3,3)\n    real*8, intent(in)  :: frac(3)\n    real*8, intent(out) :: cart(3)\n\n    integer :: i\n\n    do i=1,3\n       cart(i)=real_lat(i,1)*frac(1) + real_lat(i,2)*frac(2) + real_lat(i,3)*frac(3)\n    end do\n\n    return\n\n  end subroutine utility_frac_to_cart   \n"}, {"instruction": "Create a Fortran subroutine named \"mcnp_zaid\" to convert MPACT ZAID to MCNP ZAID and label. The subroutine must take 1 input parameter of type integer and have 2 output parameters, one of type integer and the other of type character with dynamic length. The subroutine should perform the conversion and generate a label based on the input ZAID.", "input": "", "output": "      subroutine mcnp_zaid(izinp, izaid, label)\n      implicit none\n\n      integer, intent(in)  :: izinp            ! mpact zaid\n      integer, intent(out) :: izaid            ! mcnp zaid\n      character(len=*), intent(out) :: label\n\n      integer :: isom, ia, ip\n\n      character(len=1) :: chisom    ! isomer character flag\n\n      character(len=2) :: element_name(100)\n      data element_name / &\n        'h ','he','li','be','b ','c ','n ','o ','f ','ne', &\n        'na','mg','al','si','p ','s ','cl','ar','k ','ca', &\n        'sc','ti','v ','cr','mn','fe','co','ni','cu','zn', &\n        'ga','ge','as','se','br','kr','rb','sr','y ','zr', &\n        'nb','mo','tc','ru','rh','pd','ag','cd','in','sn', &\n        'sb','te','i ','xe','cs','ba','la','ce','pr','nd', &\n        'pm','sm','eu','gd','tb','dy','ho','er','tm','yb', &\n        'lu','hf','ta','w ','re','os','ir','pt','au','hg', &\n        'tl','pb','bi','po','at','rn','fr','ra','ac','th', &\n        'pa','u ','np','pu','am','cm','bk','cf','es','fm' /\n\n!--- start\n\n      label=' '\n      chisom=' '\n\n!--- mpact zaid has an extra digit at the end for the isomer, like \"922350\"\n!--- and adds 500 to the atomic mass for fission products\n\n      izaid=izinp/10\n      isom=izinp-10*izaid   ! isomer flag\n\n      if (izaid.eq.8001) izaid=8016    ! special nomenclature for hydrogen in fuel flag\n\n      ip=izaid/1000         ! number of protons\n      ia=izaid - ip*1000    ! atomic mass\n      if (ia.gt.500) then\n        ia=ia-500           ! remove special mpact nomenclature\n        izaid=izaid-500     ! remove special mpact nomenclature\n      endif\n\n!  at this point zaid is \"clean\" with no special mpact or mcnp notation\n\n!  mpact isomers:\n!  224   47610 1    ag-110m  add 400 to isomer\n!  233   52627 1    te-127m  add 400 to isomer\n!  234   52629 1    te-129m  add 400 to isomer\n!  137   61648 1    pm-148m  add 400 to isomer\n!  178   95242 1    pm-242m  add 400 to stable nuclide!\n\n!--- put in mcnp notation, add 400 to *some* isomers\n\n      if (isom.gt.0) then\n!d      write (0,*) 'debug: isomer ', izaid\n        if (izaid.eq.47110 .or. izaid.eq.52127 .or. izaid.eq.52129 .or. izaid.eq.61148) then\n           izaid=izaid+400\n        elseif (izaid.eq.95242) then   ! do nothing\n           continue\n        else\n           write (*,*) 'zaid = izinp'\n           stop 'unknown isomer in mpact isotope list'\n        endif\n        chisom='m'\n      endif\n\n      if (isom.eq.0 .and. izaid.eq.95242) then\n        izaid=izaid+400   ! add 400 to stable isomer\n      endif\n\n!--- create label\n\n      write (label,'(2a,i0,a)') trim(element_name(ip)), '-', ia, chisom\n\n      return\n      end subroutine mcnp_zaid\n"}, {"instruction": "Create a Fortran subroutine named \"calc_hypotenuse\" that calculates the hypotenuse of a right triangle using the lengths of the other two sides. The subroutine should have 2 input parameters of type real representing the lengths of the two sides, and 1 output parameter of type real representing the length of the hypotenuse.", "input": "", "output": "subroutine calc_hypotenuse ( side_1, side_2, hypotenuse )\r\n!\r\n!  purpose:\r\n!    to calculate the hypotenuse of a right triangle from the two \r\n!    other sides.\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    11/18/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\nreal, intent(in) :: side_1        ! length of side 1 \r\nreal, intent(in) :: side_2        ! length of side 2 \r\nreal, intent(out) :: hypotenuse   ! length of hypotenuse\r\n\r\n! data dictionary: declare local variable types & definitions\r\nreal :: temp                      ! temporary variable\r\n\r\n! calculate hypotenuse\r\ntemp = side_1**2 + side_2**2\r\nhypotenuse = sqrt ( temp )\r\n\r\nend subroutine calc_hypotenuse\r\n"}, {"instruction": "Write a Fortran subroutine named irand to generate an array of random integers within a specified range. The number of input arguments is 3, and the test_data type is [integer, integer, integer]. The number of output arguments is 1, and the test_data type is [integer]. The subroutine should be named \"irand\".", "input": "", "output": "subroutine irand(randseq, n, low, high)\r\ninteger, intent(out)  :: randseq(:)\r\ninteger, intent(in)   :: n, low, high\r\n\r\nreal    :: ran(n)\r\n\r\ncall random_number(ran)\r\nrandseq = low + (high + 1 - low) * ran\r\n\r\nreturn\r\nend subroutine irand\r\n"}, {"instruction": "Create a Fortran subroutine named sys_mkdir to make a sub-directory under the current working directory. The subroutine takes 2 input parameters: dir of type character(len=*) and lendir of type integer. The output parameter ierr is of type integer. If successful, ierr will be zero; otherwise, it will be non-zero.", "input": "", "output": "      subroutine sys_mkdir (dir, lendir, ierr)\n!\n!   this routine makes a sub-dir under the current working directory.\n!   lendir is the length of character string dir;\n!   ierr will be zero if successful, otherwise non-zero;\n!   machine is an optional parameter specifying the name of the system\n!\n!   xinghong he  98-08-21\n!\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!\n!   function 'system' and execute_command_line commented out\n!cjb                                             jacek bieron 2018 june 18\n!\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n!     use mpi_c\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      character(len=*), intent(in):: dir\n      integer, intent(in):: lendir\n      integer, intent(out):: ierr\n      character(len=255) mkdir_error_message\n!      character(len=*), parameter::iam = 'sun'  ! soly for machine\n!      character(len=len_trim (iam)), optional, intent(out):: machine\n\n!     integer system\n\n      mkdir_error_message = \" no message passed from the shell \"\n      ierr = -999\n\n!cjb\n!     print*, dir(1:lendir)\n!     print*, dir(1:lendir)\n!\n      ierr = system ('mkdir -p -m 775 ' // dir(1:lendir))\n!cjb  use execute_command_line if function 'system' is not supported\n!     call execute_command_line ('mkdir -p -m 775 ' // dir(1:lendir), &\n!                         exitstat=ierr, cmdmsg=mkdir_error_message)\n      if (ierr.ne.0) then\n        print*, ' sys_mkdir error message = ', trim(mkdir_error_message)\n!               ' myid = ', myid\n      endif\n      return\n      end subroutine sys_mkdir\n"}, {"instruction": "Write a Fortran subroutine named invmat that computes the inverse of a real, square matrix. The subroutine takes 3 input parameters: two integers for the dimension and the size of the matrix, and a 2D array of double precision numbers representing the matrix. The subroutine returns the inverse of the matrix as a 2D array of double precision numbers.", "input": "", "output": "  subroutine invmat(al,ai,dimen,npar)\n  integer,intent(in)           :: npar,dimen\n  double precision,intent(in)  :: al(npar,npar)\n  double precision,intent(out) :: ai(npar,npar)\n  double precision             :: h(npar),p,q\n  integer                      :: i1,i2,k,i,j,k8,k9\n      \n\n    ai(1:dimen,1:dimen)=al(1:dimen,1:dimen)\n \n    do i1=1,dimen\n      k=dimen-i1+1\n      p=ai(1,1)\n      do i=2,dimen\n        q=ai(i,1)\n        h(i)=q/p\n        if(i.le.k) h(i)=-q/p\n        do j=2,i\n          k8=i-1\n          k9=j-1\n          ai(k8,k9)=ai(i,j)+q*h(j)\n        enddo \n      enddo \n      ai(dimen,dimen)=1.0/p\n      do i=2,dimen\n        k8=i-1\n        ai(dimen,k8)=h(i)\n      enddo \n   end do \n   do i=1,dimen\n     k8=i-1\n     do j=1,k8\n       ai(j,i)=ai(i,j)\n     enddo \n   enddo \n   return\n end subroutine invmat\n"}, {"instruction": "Create a Fortran subroutine named read_jacobi_matrix to read a matrix of double precision real numbers from a file. The subroutine takes 2 input parameters of type integer, enermax, and parmax, and 1 output parameter derj of type real(8) array with dimensions enermax and parmax. The subroutine reads the matrix from the file 'fort.12' and stores it in the derj array. Remember to use the imperative tone in the instructions.", "input": "", "output": "    subroutine read_jacobi_matrix(enermax,parmax,derj)\n\t  !\n      integer,intent(in)  :: enermax,parmax\n      real(8),intent(out) :: derj(enermax,parmax)\n      integer             :: ie,ipar\n      !\n      open(1, file='fort.12',status='old')\n      !\n      !derj(1,:) = 0 \n      !\n      do ie = 1,enermax \n        !\n        read(1,*)\n        !\n        do ipar = 1,parmax \n          !\n          read(1,*) derj(ie,ipar)\n          !    \n        enddo\n        !\n      enddo\n      !\n      close(1,status='keep')\n      !\n    end subroutine read_jacobi_matrix\n"}, {"instruction": "Create a Fortran subroutine named get_degree_for_index to calculate the degree of each node in a tree based on the given edge indices. Accept 4 input parameters of type integer: index1, index2, number_of_nodes, and number_of_edges. Provide 1 output parameter of type double precision named degree to store the computed degrees for each node.", "input": "", "output": "subroutine get_degree_for_index(index1, index2, number_of_nodes, number_of_edges, degree)\n    ! given the edge index this will compute the degree of each node.\n    !\n    ! parameters\n    ! ----------\n    ! index1, index2 : array\n    !    the index of the edges of a tree, where the '1' and '2' refer to the ends of each edge.\n    ! number_of_nodes : integer\n    !    the array integer length of the nodes used to construct the tree.\n    ! number_of_edges : integer\n    !    the array integer length of the edges forming the constructed tree.\n    !\n    ! returns\n    ! -------\n    ! degree : array\n    !    the degree for each node, i.e. the number of edges attached to each node.\u00df\n\n    implicit none\n\n    integer, intent(in) :: number_of_nodes, number_of_edges\n    integer, intent(in) :: index1(number_of_edges), index2(number_of_edges)\n    double precision, intent(out) :: degree(number_of_nodes)\n\n    integer :: i\n\n    do i = 1, number_of_nodes\n        degree(i) = 0.\n    end do\n\n    do i = 1, number_of_edges\n        degree(index1(i)+1) = degree(index1(i)+1) + 1.\n        degree(index2(i)+1) = degree(index2(i)+1) + 1.\n    end do\n\nend subroutine get_degree_for_index\n"}, {"instruction": "Create a Fortran subroutine named ppnd7. It takes 1 input parameter of type real (sp) and 2 output parameters of type integer and real (sp). The subroutine computes the inverse of the cumulative distribution function for a standard normal distribution. Use the selected_real_kind function to define the real (sp) data type within the subroutine.", "input": "", "output": "  subroutine ppnd7 (p, normal_dev, ifault)\r\n    implicit none\r\n    integer, parameter      :: sp = selected_real_kind(6, 30)\r\n    real (sp), intent(in)   :: p\r\n    integer, intent(out)    :: ifault\r\n    real (sp), intent(out)  :: normal_dev\r\n  end subroutine ppnd7\r\n"}, {"instruction": "Create a Fortran subroutine named maxval_i to find the maximum value and its position in an array of integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer, dimension(nvals)']. The number of output arguments is 2 and the test_data type is ['integer', 'integer, optional'].", "input": "", "output": "   subroutine maxval_i ( array, nvals, value_max, pos_maxval )\r\n   implicit none\r\n\r\n   ! list of calling arguments:\r\n   integer, intent(in) :: nvals                     ! # vals.\r\n   integer, intent(in), dimension(nvals) :: array   ! input data.\r\n   integer, intent(out) :: value_max                ! max value.\r\n   integer, intent(out), optional :: pos_maxval     ! position\r\n   \r\n   !  list of local variables:\r\n   integer :: i                            ! index\r\n   integer :: pos_max                      ! pos of max value\r\n\r\n   ! initialize the values to first value in array.\r\n   value_max = array(1)\r\n   pos_max = 1\r\n \r\n   ! find the extreme values in array(2) through array(nvals).\r\n   do i = 2, nvals\r\n      if ( array(i) > value_max ) then\r\n         value_max = array(i)\r\n         pos_max = i\r\n      end if\r\n   end do\r\n\r\n   ! report the results\r\n   if ( present(pos_maxval) ) then\r\n      pos_maxval = pos_max\r\n   end if\r\n\r\n   end subroutine maxval_i\r\n"}, {"instruction": "Create a Fortran subroutine named \"read_filename\" to read a string value from a file indicated by the file ID. The subroutine takes 1 input parameter of type integer (file_id) and 1 output parameter of type character with a length of 256 (val).", "input": "", "output": "subroutine read_filename(file_id, val)\n  integer, intent(in) :: file_id\n  character(len=256), intent(out) :: val\n\n  read(file_id, '(a)') val\n  val = adjustl(val)\nend subroutine read_filename\n"}, {"instruction": "Create a Fortran subroutine named set_frame that takes a character string as input and produces a framed version of the input string as output. The input parameter is of type 'character(*)' and the output parameter is of type 'character(:), allocatable, dimension(:)'.", "input": "", "output": "subroutine set_frame( text, frame )\n\n  character(*)                                          ,intent(in)     ::    text                            !< character string around which a frame is to be created\n  character(:)  ,allocatable    ,dimension(:)           ,intent(out)    ::    frame                           !< character string representing the framed text\n\n  integer                                                               ::    i\n  integer                                                               ::    maxlen                          ! maximum length of the output character string\n  integer                                                               ::    nlines                          ! number of lines of the frame including the text\n  integer       ,parameter                                              ::    nspace=2                        ! number of character used for spacing before and after the text in the frame\n  integer       ,parameter                                              ::    ntab=2                      ! number of character used for spacing before and after the text in the frame\n  character(*)  ,parameter                                              ::    char_frame='#'                  ! character used for the frame\n  character(3)                                                          ::    char_maxlen                     ! string representing the number of characters in the output string\n  character(3)                                                          ::    char_nspace                     ! string representing the number of blanc characters before and after the text message\n  character(3)                                                          ::    char_ntab\n  character(:)  ,allocatable                                            ::    string                          ! text to be framed (same tha input text but with no blanks at the begining and at the end)\n  character(:)  ,allocatable                                            ::    fmt_ext                         ! format for the external frame, ie. the upper and lower lines of the frame\n  character(:)  ,allocatable                                            ::    fmt_int                         ! format for the internal frame, ie. the text inside the frame\n\n  string        =       trim(adjustl(text))\n  nlines        =       3                                                                                       ! setting the number of lines to 3\n  maxlen        =       len(string) + 2 * (nspace + 1)                                                         ! number of characters in the output string including blanks and the framing characters\n  allocate( character(maxlen) :: frame(nlines) )                                                                ! allocation of dimension and length of the output string\n  write(char_maxlen,\"(i3)\") maxlen                                                                              ! interger-to-string convertion of the length of the output string\n  write(char_nspace,\"(i3)\") nspace                                                                              ! interger-to-string convertion of the number of blanks characters\n  write(char_ntab,\"(i3)\") ntab\n\n!   fmt_ext       =       \"(\" // char_ntab // \"x\" // char_maxlen // \"('\"// char_frame // \"'))\"                                        ! setting the format for the external frame, ie. the upper and lower lines of the frame\n!   fmt_int       =       \"(\" // char_ntab // \"x,'\"//char_frame//\"',\"//char_nspace//\"x,'\"//string//\"',\"//char_nspace//\"x,'\"//char_frame//\"')\"  ! setting the format for the internal frame, ie. the text inside the frame\n\n  fmt_ext       =       \"(\" // char_maxlen // \"('\"// char_frame // \"'))\"                                        ! setting the format for the external frame, ie. the upper and lower lines of the frame\n  fmt_int       =       \"('\"//char_frame//\"',\"//char_nspace//\"x,'\"//string//\"',\"//char_nspace//\"x,'\"//char_frame//\"')\"  ! setting the format for the internal frame, ie. the text inside the frame\n\n  write(frame(1),fmt_ext)                                                                                       ! writing the upper line of the frame\n  do i = 2,nlines-1                                                                                             ! loop on all internal lines\n    write(frame(i),fmt_int)                                                                                     ! writing the middle line of the frame\n  end do                                                                                                        ! end loop on\n  write(frame(nlines),fmt_ext)                                                                                  ! writing the lower line of the frame\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"materialvonmises\" to calculate the updated stresses, updated accumulated plastic strain, and the updated elastic constitutive matrix based on the Von Mises material model. The subroutine takes 4 input parameters of type real and returns 3 output parameters of type real.", "input": "", "output": "subroutine materialvonmises(afdstrains, fepsilonp, afstresses, afprops, afstressesnew, fepsilonpnew, afe)\n  !dec$ attributes dllexport::materialvonmises\n\timplicit none\n    real, intent(in) :: fepsilonp, afdstrains(6), afstresses(6), afprops(5)\n\treal, intent(out) :: afstressesnew(6), fepsilonpnew, afe(6, 6)\n\n\treal :: afstresseselastic(6), afdelastic(6, 6), afstressesdeviatoric(6)\n\tinteger :: k1, k2\n\treal :: ftemp1, ftemp2, ftemp3, fg, fdepsilonp, p_el, p_new, cj2_el, cj2_new\n\n! afprops(1)=e (young's modulus), afprops(2)=nu (poisson's ratio)\n! do not use nu=0.5 (incrompressible solid)\n! evaluate elastic constitutive matrix\n    afdelastic = 0.\n\tftemp1 = afprops(1) * (1. - afprops(2)) / (1. + afprops(2)) / (1. - 2. * afprops(2))\n\tftemp2 = afprops(1) * afprops(2) / (1. + afprops(2)) / (1. - 2. * afprops(2))\n\tftemp3 = afprops(1) / (1. + afprops(2)) / 2.\n\tafdelastic(1, 1) = ftemp1\n\tafdelastic(2, 2) = ftemp1\n\tafdelastic(3, 3) = ftemp1\n\tafdelastic(1, 2) = ftemp2\n\tafdelastic(1, 3) = ftemp2\n\tafdelastic(2, 1) = ftemp2\n\tafdelastic(2, 3) = ftemp2\n\tafdelastic(3, 1) = ftemp2\n\tafdelastic(3, 2) = ftemp2\n\tafdelastic(4, 4) = ftemp3\n\tafdelastic(5, 5) = ftemp3\n\tafdelastic(6, 6) = ftemp3\n\n! evaluate new afstresses tensor and state variable\n! calculate trial (elastic) afstresses state\n\tafstresseselastic = afstresses + matmul(afdelastic, afdstrains)\n! yield function <>0 ?\n! afprops(3)=sigma(y) (initial yield afstresses),\n! afprops(4)=h (hardening modulus for linear hardening)\n! fepsilonp(1)=epsilon(p)_bar (accumulated plastic strain)\n\tcj2_el = ((afstresseselastic(1) - afstresseselastic(2)) ** 2 + (afstresseselastic(2) - afstresseselastic(3)) ** 2 + &\n\t\t(afstresseselastic(3) - afstresseselastic(1)) ** 2) / 6. + afstresseselastic(4) ** 2 + afstresseselastic(5) ** 2 + &\n\t\tafstresseselastic(6) ** 2\n\tftemp1 = sqrt(3. * cj2_el) - (afprops(3) + afprops(4) * fepsilonp)\n\tif (ftemp1 <= 0.) then\n\t\tafstressesnew = afstresseselastic     ! no plastic correction needed\n\t\tafe = afdelastic       ! const. matrix = elastic const. matrix, no change to the accumulated plastic strain\n\telse\n! return mapping\n\t\tfg = afprops(1) / 2. / (1. + afprops(2))    ! fg = shear modulus\n\t\tfdepsilonp = ftemp1 / (3. * fg + afprops(4))\n\t\tfepsilonpnew = fepsilonp + fdepsilonp  ! update accumulated plastic strain\n\t\tftemp1 = fg * fdepsilonp * sqrt(3. / cj2_el)   ! 2. and 1/2. cancel out\n\t\tp_el = (afstresseselastic(1) + afstresseselastic(2) + afstresseselastic(3)) / 3.  ! p_el=mean afstresses (elastic)\n\t\tafstressesnew(1) = afstresseselastic(1) - ftemp1 * (afstresseselastic(1) - p_el)\n\t\tafstressesnew(2) = afstresseselastic(2) - ftemp1 * (afstresseselastic(2) - p_el)\n\t\tafstressesnew(3) = afstresseselastic(3) - ftemp1 * (afstresseselastic(3) - p_el)\n\t\tafstressesnew(4) = afstresseselastic(4) - ftemp1 * afstresseselastic(4)\n\t\tafstressesnew(5) = afstresseselastic(5) - ftemp1 * afstresseselastic(5)\n\t\tafstressesnew(6) = afstresseselastic(6) - ftemp1 * afstresseselastic(6)\n\n! create new jacobian\n\t\tp_new = (afstressesnew(1) + afstressesnew(2) + afstressesnew(3)) / 3.\n\t\tafstressesdeviatoric(1) = afstressesnew(1) - p_new\n\t\tafstressesdeviatoric(2) = afstressesnew(2) - p_new\n\t\tafstressesdeviatoric(3) = afstressesnew(3) - p_new\n\t\tafstressesdeviatoric(4) = afstressesnew(4)\n\t\tafstressesdeviatoric(5) = afstressesnew(5)\n\t\tafstressesdeviatoric(6) = afstressesnew(6)\n\n\t\tcj2_new = ((afstressesnew(1) - afstressesnew(2)) ** 2 + (afstressesnew(2) - afstressesnew(3)) ** 2 + &\n\t\t\t(afstressesnew(3) - afstressesnew(1)) ** 2 ) / 6. + afstressesnew(4) ** 2 + afstressesnew(5) ** 2 + &\n\t\t\tafstressesnew(6) ** 2\n\t\tftemp1 = 3. * fg * fg / (afprops(4) + 3. * fg) / cj2_new\n\t\tdo k1 = 1, 6\n\t\t\tdo k2 = 1, 6\n\t\t\t\tafe(k2, k1) = afdelastic(k2, k1) - ftemp1 * afstressesdeviatoric(k2) * afstressesdeviatoric(k1)\n\t\t\tend do\n\t\tend do\n!\t\tafe = afdelastic       ! const. matrix = elastic const. matrix, no change to the accumulated plastic strain\n\tend if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named `associate_neighbor_spin` that associates a pointer with a target variable. The subroutine takes 1 input parameter of type 'integer, target' and 1 output parameter of type 'integer, pointer'.", "input": "", "output": "  subroutine associate_neighbor_spin(ptr, spin)\n    integer, pointer, intent(out) :: ptr\n    integer, target , intent(in)  :: spin\n    ptr => spin\n  end subroutine associate_neighbor_spin\n"}, {"instruction": "Write a Fortran subroutine named hello_world to display the rank, size, and hostname for a parallel program. The subroutine takes 2 input arguments of type integer (size and rank) and 1 output argument of type character with variable length.", "input": "", "output": "  subroutine hello_world(size, rank, myhostname)\n    integer, intent(in) :: size, rank\n    character(len = *), intent(out) :: myhostname\n\n    integer :: stat\n    \n    myhostname = \"(no host name)\"\n#ifdef __intel_compiler\n    call get_environment_variable(\"computername\", myhostname)\n#else\n    stat = hostnm(myhostname)\n#endif\n    \n    write(*, *) \"hello world fortran rank:\", rank, \" size:\", size, &\n    & \"hostname:\", trim(myhostname)\n  \n  end subroutine hello_world\n"}, {"instruction": "Write a Fortran subroutine named linspace to generate an array of evenly spaced real(8) numbers. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and produces 1 output parameter of type real(8).", "input": "", "output": "subroutine linspace(n, first, last, a)\nimplicit none\n\n    integer:: i\n    integer, intent(in):: n\n    real(8), intent(in):: first, last\n    real(8), intent(out):: a(n)\n\n    if (n==1) then\n        a(1) = (first + last)/2.0d0\n\n    else\n        do i = 1, n\n\n            a(i) = ( real(n-i, kind=8)*first + real(i-1, kind=8)*last )/ &\n                   real(n-1,kind=8)\n        end do\n\n    end if\n\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named initial to initialize the values of h, uh, and vh based on the specified input parameters. The number of input arguments is 7 with test_data types as ['integer', 'integer', 'real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 3 with test_data types as ['real(8)', 'real(8)', 'real(8)'].", "input": "", "output": "subroutine initial(pi, nx, ny, x, y, h, uh, vh, x_length, y_length)\nimplicit none\n\n    integer, intent(in):: nx, ny\n\treal(8), intent(in):: x(nx), y(ny), pi, x_length, y_length\n\treal(8), intent(out):: h(nx,ny), uh(nx,ny), vh(nx,ny)\n\treal(8)::a, x0, y0, sx, sy\n\tinteger:: i, j\n\n    ! sine wave initial condition\n\n\t!h(1:nx, 1:ny) = 2.0d0 + sin(2*pi* x(1:nx))\n\n\t! dam break initial condition\n\t!h = 1.0d0\n\t!h(1:nx/2, :) = 3.0d0\n\n    ! gaussian function\n    a = 3.0d0\n    x0 = x_length/2.0d0\n    y0 = y_length/2.0d0\n    sx = 0.2d0\n    sy = 0.2d0\n\n    do j = 1, ny\n    do i = 1, nx\n        h(i,j) = a*exp(- ( (x(i)-x0)**2 /(2*sx**2) + (y(j)-y0)**2 /(2*sy**2) ) )\n    end do\n    end do\n\n\tuh(1:nx, 1:ny) = 0.0d0\n\tvh(1:nx, 1:ny) = 0.0d0\n\n\nreturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named split_str to parse a string and extract a label and a corresponding value. The subroutine takes 1 input parameter of type character *80 and 2 output parameters, one of type character *40 and the other of type real (kind=8).", "input": "", "output": "  subroutine split_str(str,label,val)\n    character *40, intent(out) :: label\n    character *80, intent(in) :: str \n    real (kind=8), intent(out) :: val \n    character strt\n    integer (kind=4) :: ind, slen\n\n    strt = str(1:1)\n\n    if(strt .eq. '!' .or. strt .eq. '#' .or. strt .eq. '/') then\n        label = '!'\n        val = 0\n        return\n    end if\n\n    ind = index(str,'=',.false.)\n\n    if(ind .eq. 0) then\n        label = '!'\n        val = 0\n    end if\n\n    label=str(1:ind-1)\n\n    slen = len_trim(str)\n    read(str(ind+1:slen),*)val\n\n  end subroutine split_str\n"}, {"instruction": "Write a Fortran subroutine named get_field to extract a specific field from an input string. The subroutine takes 2 input parameters of type character(*) and integer, and 3 output parameters of type character(*), integer, and character(*). The input string contains fields separated by one or more spaces, and the subroutine retrieves the nth field and stores it in the output string. Additionally, it returns an error code and message if there are any issues during the extraction process.", "input": "", "output": "subroutine get_field(str_in,str_out,n,err_n,err_msg)\n\n  ! takes an input string str_in in which\n  ! every field is separated one another by one or more spaces.\n  ! gets the n field and store it in str_out.\n\n  character(*), intent(in)  :: str_in\n  character(*), intent(out) :: str_out\n  integer,      intent(in)  :: n\n  integer,      intent(out) :: err_n         ! 0 on success, 1 otherwise\n  character(*), intent(out) :: err_msg       ! message set in case of failure\n  integer, parameter        :: success       = 0\n  integer, parameter        :: failure       = 1\n  integer                   :: i\n  integer                   :: current_field\n  integer                   :: start_field\n  integer                   :: end_field\n  character(1)              :: ch\n  character(3)              :: n_str\n  character(8)              :: istr1\n  character(8)              :: istr2\n  logical                   :: prev_space\n\n  if (n<1) then\n    err_n   = failure\n    err_msg = \"get_field: argument must be a non-zero positive integer\"\n    return\n  end if\n\n  start_field   = -1\n  end_field     = -1\n  current_field =  0\n  prev_space    = .true.\n  do i=1, len_trim(str_in)\n    ch = str_in(i:i)\n\n    if (ch==\" \") then\n      if ((prev_space.eqv..false.).and.(current_field==n)) then\n        end_field = i-1\n        exit\n      end if\n      prev_space = .true.\n    else\n      if (prev_space.eqv..true.) then\n        current_field = current_field+1\n        if (current_field==n) then\n          start_field = i\n        end if\n      end if\n\n      prev_space = .false.\n    end if\n  end do\n\n  if (start_field/=-1) then\n    if (end_field==-1) then\n      end_field = len_trim(str_in)\n    end if\n  else\n    write(n_str,'(i3)') n\n    n_str   = adjustl(n_str)\n    err_n   = failure\n    err_msg = \"get_field: cannot get field \"//trim(n_str)//&\n      &\" from string \"\"\"//trim(str_in)//\"\"\"\"\n    return\n  end if\n\n  if ((end_field-start_field+1)>len(str_out)) then\n    err_n   = failure\n    write(istr1,'(i8)') len(str_out)\n    istr1 = adjustl(istr1)\n    write(istr2,'(i8)') end_field-start_field+1\n    istr2 = adjustl(istr2)\n    err_msg = \"get_field: output string too small (\"//trim(istr1)//&\n      &\") to contain the field (\"//trim(istr2)//\")\"\n    return\n  end if\n\n  str_out = str_in(start_field:end_field)\n  err_n   = success\n\nend subroutine get_field\n"}, {"instruction": "Create a Fortran subroutine named gausspointsandweights to calculate the points and weights for the Gaussian quadrature. The subroutine takes 1 input parameter of type integer and 2 output parameters of type real*8, allocatable. The input parameter specifies the number of points and weights to be calculated.", "input": "", "output": "subroutine gausspointsandweights(x,w,npoints)\n\n\t\tinteger,intent(in) :: npoints\n\t\treal*8, allocatable, intent(out) :: w(:)\n\t\treal*8, allocatable, intent(out) :: x(:)\n\n\t\tallocate(w(npoints))\n\t\tallocate(x(npoints))\n\n\t\tif(npoints .eq. 1) then\n\t\t\tw(1)=2.0\n\t\t\tx(1)=0.0\n\t\tendif\n\n\t\tif(npoints .eq. 2) then\n\t\t\tw(1)=1.0\n\t\t\tw(2)=1.0\n\n\t\t\tx(1)=-1.0/sqrt(3.0)\n\t\t\tx(2)=1.0/sqrt(3.0)\n\t\tendif\n\n\t\tif(npoints .eq. 3) then\n\t\t\tw(1)=5.0/9.0\n\t\t\tw(2)=8.0/9.0\n\t\t\tw(3)=5.0/9.0\n\n\t\t\tx(1)=-sqrt(3.0/5.0)\n\t\t\tx(2)=0.0\n\t\t\tx(3)=sqrt(3.0/5.0)\n\t\tendif\n\n\t\tif(npoints .eq. 4) then\n\t\t\tw(1) = (18.0-sqrt(30.0))/36.0\n\t\t\tw(2) = (18.0+sqrt(30.0))/36.0\n\t\t\tw(3) = (18.0+sqrt(30.0))/36.0\n\t\t\tw(4) = (18.0-sqrt(30.0))/36.0\n\n\t\t\tx(1) = -sqrt((3.0+2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(2) = -sqrt((3.0-2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(3) =  sqrt((3.0-2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(4) =  sqrt((3.0+2.0*sqrt(6.0/5.0))/7.0)\n\t\tendif\n\nend subroutine gausspointsandweights\n"}, {"instruction": "Create a Fortran subroutine named gll_gen that generates Gauss-Lobatto-Legendre points and weights. It takes 1 input argument of type integer and 2 output arguments of type real*8, allocatable. The number of input arguments is 1, the test_data type is ['integer'], and the number of output arguments is 2, the test_data type is ['real*8,allocatable', 'real*8,allocatable'].", "input": "", "output": "subroutine gll_gen(x,w,n)\n\n      integer, intent(in) :: n\n      real*8,allocatable, intent(out) :: x(:),w(:)\n\n      real*8 :: dleg(n+1)\n      real*8 :: pi,tol,x_it,xold\n      integer :: maxit,n1,i,j,k\n\n      allocate(x(n+1))\n      allocate(w(n+1))\n\n      pi = acos(-1.)\n\n      tol = 1d-15\n\n      n1 = n+1\n\n      maxit = 1000   ! max iterations for newton-raphson\n  \n      x(1) = -1.d0\n      x(n1) = 1.d0\n \n      do i = 1, n+1\n\n        x_it = -cos(pi * float(i-1) / n) ! initial guess - chebyshev points\n\n        do j = 1, maxit \n\n    \t  xold = x_it\n          dleg(1) = 1.d0\n          dleg(2) = x_it\n\n\t  do k = 2,n  \n\n            dleg(k+1) = (  (2.d0*float(k) - 1.d0) * dleg(k) * x_it &\n                    - (float(k)-1.d0)*dleg(k-1) ) / float(k)\n          \n          enddo\n\n          x_it = x_it - ( x_it * dleg(n1) - dleg(n) ) / &\n                (float(n1) * dleg(n1) ) \n\n          if (abs(x_it - xold) .lt. tol) goto 10\n\n        enddo\n        write(*,*) 'max itertions reached'\n10      continue\n\n        x(i) = x_it\n        w(i) = 2.d0 / (float(n * n1) * dleg(n1)**2 )\n\n      enddo\n\n      return\n\nend subroutine gll_gen\n"}, {"instruction": "Create a Fortran subroutine named mergesort_indirect_i to perform an indirect mergesort on an array of integers. The subroutine takes one input parameter, an integer array of any size, and one output parameter, an integer array of the same size. The subroutine utilizes recursive and contains features to sort the array in ascending order using an indirect sorting method.", "input": "", "output": "  subroutine mergesort_indirect_i( array, iarray)\r\n    integer, dimension(:), intent(in) :: array\r\n    integer, dimension(:), intent(out) :: iarray\r\n\r\n    integer :: tmp((size(array)+1)/2)\r\n    integer :: i, n\r\n\r\n    n = size (array)\r\n    iarray = (/(i,i=1,n)/)\r\n    \r\n    call mg_sort_no_cmp(iarray, tmp)\r\n    \r\n  contains\r\n\r\n    recursive subroutine mg_sort_no_cmp(idx, tmp)\r\n      integer, intent(inout) :: idx(:) \r\n      integer                :: tmp(:)\r\n      \r\n      integer :: n, nh\r\n\r\n      n = size(idx)\r\n      \r\n      if (n .eq. 1) then\r\n\r\n         return\r\n\r\n      else if (n .eq. 2) then\r\n\r\n         if (array(idx(2)) < array(idx(1))) then\r\n            idx(1:2) = idx(2:1:-1)\r\n         end if\r\n\r\n      else\r\n\r\n         nh = (n+1)/2\r\n         call mg_sort_no_cmp(idx(1:nh),tmp)\r\n         call mg_sort_no_cmp(idx(nh+1:),tmp)\r\n         \r\n         if (array(idx(nh+1)) < array(idx(nh))) then\r\n            tmp(1:nh) = idx(1:nh)\r\n            call merge_no_cmp(tmp(1:nh), idx)\r\n         end if\r\n\r\n      end if\r\n\r\n      return\r\n    end subroutine mg_sort_no_cmp\r\n\r\n    subroutine merge_no_cmp(tmp, idx)\r\n      integer, intent(inout) :: idx(:)\r\n      integer, intent(in   ) :: tmp(:) \r\n      \r\n      integer :: n, nh, i, j, k\r\n\r\n      n = size(idx)\r\n      nh = size(tmp)\r\n\r\n      i=1 \r\n      j=nh+1 \r\n      k=1\r\n\r\n      do while (i .le. nh .and. j .le. n)\r\n         if (array(idx(j)) < array(tmp(i))) then\r\n            idx(k) = idx(j)\r\n            j = j+1\r\n         else\r\n            idx(k) = tmp(i)\r\n            i = i+1\r\n         end if\r\n         k = k+1\r\n      end do\r\n\r\n      if (i .le. nh) idx(k:) = tmp(i:nh)\r\n\r\n      return\r\n    end subroutine merge_no_cmp\r\n\r\n  end subroutine mergesort_indirect_i\r\n"}, {"instruction": "Create a Fortran subroutine named chan_pack that takes 5 input parameters of types integer, integer, integer, real, and integer, and 1 output parameter of type real. This subroutine packs elements from a 2D array based on a mask and stores the result in a 2D output array.", "input": "", "output": "subroutine chan_pack(varnd, mask, nstot, nt, var2d, ns)\n\n\timplicit none\n\n\t! external\n\t! --------\n\tinteger, intent(in)  :: nstot, nt, ns\n\treal,    intent(in)  :: varnd(nt,nstot)\n\tinteger, intent(in)  :: mask(nstot)\n\treal,    intent(out) :: var2d(ns,nt)\n\n\t! internal\n\t! --------\n\tinteger :: it\n\n\t! call to pack\n\t! ------------\n\tdo it = 1, nt\n\t\tvar2d(:,it) = pack(varnd(it,:), mask==1)\n\tend do\n\nend subroutine chan_pack\n"}, {"instruction": "Write a Fortran subroutine named load_array1d_character that reads character data from a specified input unit and dynamically allocates memory to store the data. The subroutine takes 1 input parameter of type integer and 1 output parameter of type character(*), allocatable.", "input": "", "output": "  subroutine load_array1d_character(iounit, val)\n    implicit none\n    integer, intent(in)       :: iounit\n    character(*),allocatable, intent(out) :: val(:)\n    logical :: f\n    integer :: lb1, ub1\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      allocate(val(lb1:ub1))\n      read(iounit) val(:)\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named load_array2d_real8 to read data from a specified input unit and allocate it to a 2D real(8) array. The subroutine takes 1 input parameter of type integer, representing the input unit. It also has 1 output parameter of type real(8) array that is allocatable.", "input": "", "output": "  subroutine load_array2d_real8(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    real(8), allocatable, intent(out) :: val(:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      allocate(val(lb1:ub1,lb2:ub2))\n      read(iounit) val(:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named load_array5d_real8 to read data from a specified unit and allocate a 5-dimensional array of real(8) values based on the read data. The subroutine takes 1 input parameter of type integer to specify the input unit, and outputs a real(8) allocatable 5-dimensional array.", "input": "", "output": "  subroutine load_array5d_real8(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    real(8), allocatable, intent(out) :: val(:,:,:,:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    integer :: lb3, ub3\n    integer :: lb4, ub4\n    integer :: lb5, ub5\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      read(iounit) lb3, ub3\n      read(iounit) lb4, ub4\n      read(iounit) lb5, ub5\n      allocate(val(lb1:ub1,lb2:ub2,lb3:ub3,lb4:ub4,lb5:ub5))\n      read(iounit) val(:,:,:,:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named load_array3d_integer to read 3D integer array data from a specified input unit. The subroutine takes 1 input parameter of type integer and allocates memory for the 3D integer array. The output is an allocatable 3D integer array.", "input": "", "output": "  subroutine load_array3d_integer(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    integer, allocatable, intent(out) :: val(:,:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    integer :: lb3, ub3\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      read(iounit) lb3, ub3\n      allocate(val(lb1:ub1,lb2:ub2,lb3:ub3))\n      read(iounit) val(:,:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named fpy_get_drange to determine the range of dimensionality for a set of files with specific prefixes and member names. The subroutine takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer, allocatable.", "input": "", "output": "  subroutine fpy_get_drange(drange, prefix, members)\n    integer, allocatable, intent(out) :: drange(:)\n    character(len=*), intent(in) :: prefix, members(:)\n\n    integer :: d, i, j, k\n    logical :: exists, memexists\n    character(len=:), allocatable :: catstr\n    character(50) :: istr\n    \n    !first, check the dimensionality of the range by checking for a member at the first position.\n    exists = .true.\n    memexists = .false.\n    i = 0\n    d = 0\n    catstr = ''\n\n    do while (i .lt. 7)\n       if (len(catstr) .gt. 0) then\n          catstr = catstr//'.1'\n       else\n          catstr = '1'\n       end if\n\n       memexists = .false.\n       j = 1\n       do while (j .le. size(members) .and. .not. memexists)\n          inquire(file=prefix//catstr//'-'//trim(members(j)), exist=memexists)\n          j = j+1\n       end do\n       \n       i = i + 1\n       if (memexists) then\n          d = i\n       end if\n    end do\n    if (d .eq. 0) return\n    allocate(drange(d))\n\n    do k=1, d\n       i = 1\n       exists = .true.\n       do while(exists)\n          write (istr, *) i\n          catstr = ''\n          \n          do j=1, k\n             if (len(catstr) .gt. 0) catstr = catstr//'.'\n             \n             if (j .lt. k) then\n                catstr = catstr//'1'\n             else\n                catstr = catstr//trim(adjustl(istr))\n             end if\n          end do\n          do j=k, d-1\n             catstr = catstr//'.1'\n          end do\n\n          memexists = .false.\n          j = 1\n          do while (j .le. size(members) .and. .not. memexists)\n             inquire(file=prefix//catstr//'-'//trim(members(j)), exist=memexists)\n             j = j+1\n          end do\n\n          exists = memexists\n          if (exists) then\n             i = i+1\n          else\n             i = i-1\n          end if\n       end do\n       drange(k) = i\n    end do    \n  end subroutine fpy_get_drange\n"}, {"instruction": "Write a Fortran subroutine named \"aslegf\" to compute the next associated Legendre function using a recursive relationship. The subroutine takes 6 input parameters of types integer, integer, integer, real*8, real*8, real*8, and outputs 1 parameter of type real*8. The subroutine computes the next associated Legendre function using the input parameters l, m, sgm, mu, plm1m, and plm, and stores the result in the output parameter plmp1.", "input": "", "output": "subroutine aslegf(l,m,sgm,mu,plm1m,plm,plmp1)\n\n! ---------------------------------------------\n!\n! uses a recursive relationship to compute the\n!  next associated legendre function\n!\n! ---------------------------------------------\n\nimplicit none\n\ninteger, intent(in) :: l, m, sgm\nreal*8, intent(in) :: mu, plm1m, plm\nreal*8, intent(out) :: plmp1\n\nplmp1 = (1.0/sqrt(1.0-mu**2))*((l-m+1)*sgm*mu*plm - (l+m-1)*plm1m)\n\nend subroutine aslegf\n"}, {"instruction": "Write a Fortran subroutine named z_getsettings to determine settings for tightly-packed chasing and aggressive deflation at the start and end. The subroutine takes 1 input parameter of type integer and returns 4 output parameters, all of which are of type integer.", "input": "", "output": "  subroutine z_getsettings(n,m,k,we,ws)\n  ! settings for tightly-packed chasing and aggressive\n  ! deflation at the start and end\n  !___________________________________________________________________________\n    integer, intent(in)             ::  n\n    integer, intent(out)            ::  m, k, we, ws\n\n    if (n .lt. ssth) then\n      k = 1\n      m = 1\n      we = 1\n      ws = 1\n    elseif (n .lt. 60) then\n      k = 4\n      m = 4\n      we = 6\n      ws = 2\n    elseif (n .lt. 180) then\n      k = 10\n      m = 10\n      we = 12\n      ws = 4\n    elseif (n .lt. 1001) then\n      k = 32\n      m = 32\n      we = 34\n      ws = 6\n    elseif (n .lt. 3000) then\n      k = 64\n      m = 64\n      we = 66\n      ws = 12\n    elseif (n .lt. 6000) then\n      k = 128\n      m = 128\n      we = 130\n      ws = 20\n    else\n      k = 256\n      m = 256\n      we = 266\n      ws = 28\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named search_bisec that performs a bisection search on an ascending array to find the indices that bracket a given value. The subroutine takes 2 input parameters of type real*8, and an integer array, and returns 2 output parameters of type integer.", "input": "", "output": "      subroutine search_bisec(v,x,lower,upper)\n!     -------------------------------------------------------------\n!     given value v; search an (**ascending order**)  array x(n) \n!     by bisection, returning the indices that bracket value v\n!     -------------------------------------------------------------\n      implicit none\n      real*8, intent(in):: v, x(:)\n      integer :: n,mid\n      integer, intent(out)::lower,upper\n\n      n=size(x)\n      upper=n\n      lower=1\n      \n      do while ((upper - lower) .gt. 1)\n         mid= (upper + lower)/2\n         if ( v .gt. x(mid)) then\n            upper=upper\n            lower=mid\n         else\n            upper=mid\n            lower=lower\n         endif\n      enddo\n\n      return\n      end subroutine \n"}, {"instruction": "Write a Fortran subroutine named \"bracket\" to identify the lower and upper bounds of a non-zero segment within an array. The subroutine takes 3 input arguments of type integer and 2 output arguments of type integer.", "input": "", "output": "    subroutine bracket(sig, ll, hh, llo, hho)\r\n      integer, intent(in) :: ll, hh\r\n      integer, intent(out) :: llo, hho\r\n      integer, intent(in)    :: sig(ll:hh)\r\n\r\n      llo = ll\r\n      hho = hh\r\n      do while ( sig(llo) == 0  .and.  hho-llo >= minwidth/blocking_factor )\r\n         llo = llo + 1\r\n      end do\r\n\r\n      do while ( sig(hho) ==  0  .and. hho-llo >= minwidth/blocking_factor )\r\n         hho = hho - 1\r\n      end do\r\n\r\n    end subroutine bracket\r\n"}, {"instruction": "Create a Fortran subroutine named check_uniqueness_ivec to check the uniqueness between elements of an integer array. The subroutine takes 2 input parameters of type integer: size_vec and ivec(size_vec), and 1 output parameter of type logical: is_unique.", "input": "", "output": "    subroutine check_uniqueness_ivec ( ivec,size_vec,is_unique )        !\n    ! check the uniqueness between integer array elements               !\n    !-------------------------------------------------------------------+\n  \n    implicit none\n    integer, intent(in)     :: size_vec\n    integer, intent(in)     :: ivec(size_vec)\n    logical, intent(out)    :: is_unique\n    \n    integer                 :: b_int,c_int\n    integer                 :: i,j\n    \n    is_unique = .true.\n    \n    baseloop: do i=1,size_vec-1\n        b_int = ivec(i)\n        do j=i+1,size_vec\n            c_int = ivec(j)\n            if ( c_int==b_int ) then\n                is_unique = .false. \n                exit baseloop\n            end if\n        end do\n    end do baseloop\n    \n    \n    end subroutine check_uniqueness_ivec\n"}, {"instruction": "Create a Fortran subroutine named index2e that takes two integer input parameters and returns one integer output parameter. This subroutine computes the one-dimensional index corresponding to the (i, j) position in a lower triangular matrix.", "input": "", "output": "subroutine index2e(i,j,ij)\n  implicit none\n  integer, intent(in)           :: i,j\n  integer, intent(out)          :: ij\n\n  if (i>j)then\n    ij = i*(i+1)/2 + j\n  else\n    ij = j*(j+1)/2 + i\n  endif\n\nend subroutine index2e\n"}, {"instruction": "Write a Fortran subroutine named decompose_1d to divide a one-dimensional array into segments for parallel processing. The subroutine takes 3 input arguments of type integer: total_n, rank, and num_process. It also has 1 output argument of type integer: local_n. The subroutine calculates the local_n, which represents the number of elements to be processed by the current process, based on the total_n and num_process. If the rank is less than the remainder of total_n divided by num_process, local_n is increased by 1.", "input": "", "output": "subroutine decompose_1d(total_n, local_n, rank, num_process)\n    implicit none\n    integer, intent(in) :: total_n, rank, num_process\n    integer, intent(out) :: local_n\n\n    local_n = total_n / num_process\n\n    if (rank < mod(total_n, num_process)) then\n        local_n = local_n + 1\n    endif\n\nend subroutine decompose_1d\n"}, {"instruction": "Write a Fortran subroutine named calcula_perfil to calculate the temperature profile in a furnace. The subroutine takes 7 input parameters of type real: ta, t1, t2, t3, r1, r2, r3. It also has 1 output parameter of type real array with dimension n.", "input": "", "output": "subroutine calcula_perfil(ta, t1, t2, t3, r1, r2, r3,t)\n    implicit none\n\n    real, intent(in) :: ta, t1, t2, t3, r1, r2, r3\n    integer, parameter :: n = 30   ! n\u00famero de elementos finitos\n    real, dimension(n), intent(out) :: t\n\n    real :: l, sor, dx, t_media, tn\n    integer :: p_n1, p_n2, p_n3, i, j ,k\n    real, dimension(n) :: fonte\n\n    l = 2.0         ! comprimento do forno em metros\n    sor = 1.85      ! par\u00e2metro sor\n    p_n1 = n/4      ! posi\u00e7\u00e3o do primeiro sensor de temperatura\n    p_n2 = n/2      ! segundo sensor\n    p_n3 = 3*n/4    ! terceiro sensor\n\n    dx = l/(n+1)\n    t_media = (2*ta + t1 + t2 + t3)/5\n\n    ! valores iniciais da temperatura\n    do i=1, n-1\n        t(i) = t_media\n    enddo\n    t(1) = ta   ! tempa ambiente nas pontas (direichilet)\n    t(n) = ta   ! tempa ambiente nas pontas (direichilet)\n\n    ! valores da fonte\n    do i=1, int(n/3)\n        fonte(i) = r1\n    enddo\n    do i=int(n/3)+1, int(2*n/3)\n        fonte(i) = r2\n    enddo\n    do i=int(2*n/3)+1, n\n        fonte(i) = r3\n    enddo\n\n\n    do j=1, 200\n        do i=2 , n-1\n            if (i == p_n1) then\n                t(i) = t1\n            else if (i == p_n2) then\n                t(i) = t2\n            else if (i == p_n3) then\n                t(i) = t3\n            else\n                tn = (t(i-1) + t(i+1))/2.0 +dx*dx*fonte(i)\n                t(i) = t(i) + sor*( tn - t(i) )\n            end if\n        enddo\n    enddo\n\nend subroutine calcula_perfil\n"}, {"instruction": "Create a Fortran subroutine named make_index_iter that takes two input integer arguments, mx_store and iter_present, and one output integer array argument, index_iter. This subroutine generates an index array based on the values of mx_store and iter_present. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  subroutine make_index_iter(mx_store, iter_present, index_iter)\n\n    implicit none\n\n    ! passed variables\n    integer, intent(in) :: mx_store\n    integer, intent(in) :: iter_present\n    integer, intent(out) :: index_iter(0:mx_store-1)\n\n    ! local variables\n    integer :: iter\n\n    index_iter(:) = 0\n    if(iter_present < mx_store) then\n       do iter = 0, iter_present-1\n          index_iter(iter)=iter_present-iter\n       enddo\n    else\n       do iter = 0, mx_store-1\n          index_iter(iter)=mod(iter_present-iter-1,mx_store)+1\n       enddo\n    endif\n    return\n  end subroutine make_index_iter\n"}, {"instruction": "Create a Fortran subroutine named rotmat that computes the Givens rotation matrix parameters c and s for given input values a and b. The subroutine takes 2 input arguments of type real*8 and returns 2 output arguments of type real*8.", "input": "", "output": "subroutine rotmat(a,b,c,s)\n\n!----------------------------------------------------\n!\n! compute the givens rotation matrix parameters c, s\n!  for given a, b\n!\n!----------------------------------------------------\n\nimplicit none\nreal*8, intent(in) :: a, b\nreal*8, intent(out) :: c, s\nreal*8 :: temp\n\nif (b == 0.0) then\n   c = 1.0\n   s = 0.0\nelse if (abs(b) > abs(a)) then\n   temp = a/b\n   s = 1.0/sqrt(1.0 + temp**2)\n   c = temp*s\nelse\n   temp = b/a\n   c = 1.0/sqrt(1.0 + temp**2)\n   s = temp*c\nend if\n\nreturn\nend subroutine rotmat\n"}, {"instruction": "Create a Fortran subroutine named get2dpbcwithmod to calculate the periodic boundary conditions for a 2D grid. The subroutine takes 2 input parameters of type integer and returns 4 output parameters of type integer.", "input": "", "output": "\tsubroutine get2dpbcwithmod(pos, lsze, r, u, l, d)\n\t  integer, intent(in) :: pos, lsze\n\t  integer :: lvol\n\t  integer, intent(out) :: r, u, l, d\n\t  lvol = lsze ** 2\n\t  u = pos - lsze\n\t  if(u .le. 0) then\n\t    u = lvol + u\n\t  endif\n\t  d = pos + lsze\n\t  if(d .gt. lvol) then\n\t    d = d - lvol\n\t  endif\n\t  r = pos + 1\n\t  if(mod(pos, lsze) .eq. 0) then\n\t    r = r - lsze\n\t  endif\n\t  l = pos - 1\n\t  if(mod(l, lsze) .eq. 0) then\n\t    l = l + lsze\n\t  endif\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named extremes that takes 2 input arguments: an integer n and an array of real numbers of length n. The subroutine has 4 optional output arguments: a real number representing the maximum value, an integer representing the position of the maximum value, a real number representing the minimum value, and an integer representing the position of the minimum value.", "input": "", "output": "  subroutine extremes(a, n, maxval, pos_maxval, minval, pos_minval)\n  implicit none\n  integer, intent(in) :: n\n  real, intent(in), dimension(n) :: a\n  real, intent(out), optional :: maxval\n  integer, intent(out), optional :: pos_maxval\n  real, intent(out), optional :: minval\n  integer, intent(out), optional :: pos_minval\n  integer :: i\n  real :: real_max\n  integer :: pos_max\n  real :: real_min\n  integer :: pos_min\n\n  real_max = a(1)\n  pos_max = 1\n  real_min = a(1)\n  pos_min = 1\n  do i = 2, n\n    if (a(i) > real_max) then\n      real_max = a(i)\n      pos_max = i\n    else if (a(i) < real_min) then\n      real_min = a(i)\n      pos_min = i\n    end if\n  end do\n\n  if (present(maxval)) then\n    maxval = real_max\n  end if\n  if (present(pos_maxval)) then\n    pos_maxval = pos_max\n  end if\n  if (present(minval)) then\n    minval =  real_min\n  end if\n  if (present(pos_minval)) then\n    pos_minval = pos_min\n  end if\n\n  end subroutine extremes\n"}, {"instruction": "Write a Fortran subroutine named fasta_string2seq to convert a string of characters representing a sequence according to a given alphabet into an array of integers representing the corresponding indices of the characters in the alphabet. The subroutine should have 2 input parameters of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine fasta_string2seq(alphabet, string,seq)\n    ! read a sequence, return an array of integer\n    character(len=*), intent(in)  :: alphabet\n    character(len=*), intent(in)  :: string\n    integer,          intent(out) :: seq(:)\n    integer :: i\n\n    seq = [(index(trim(alphabet), string(i:i)), i = 1, len_trim(string))]\n\n  end subroutine fasta_string2seq\n"}, {"instruction": "Create a Fortran subroutine named \"ordered_dithering3x3\" to perform ordered dithering on an input matrix of quantized values. The subroutine takes 3 input parameters of type integer, integer, and integer array of dimension (0:h-1, 0:l-1), and 1 output parameter of type integer array of dimension (0:3*h-1, 0:3*l-1). The subroutine implements an ordered dithering algorithm by mapping the quantized values to a 3x3 pattern and placing the corresponding pattern in the output array.", "input": "", "output": "    subroutine ordered_dithering3x3(quantized, h, l, returnparam)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: quantized\n      integer, dimension(0:3*h-1, 0:3*l-1), intent(out) :: returnparam\n\n      integer, dimension(3,3) :: selectedlevel\n      integer :: i, j, k, r, xs, xf, ys, yf\n      integer level\n\n      k = 0\n      r = 0\n\n      do i = 0, h-1\n        do j = 0, l-1\n          level = quantized(i,j)\n          select case (level)\n            case (1)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 0, 0, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case (2)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 0, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case(3)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case (4)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 1, 0 /)\n            case (5)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 0, 1, 0 /)\n            case(6)\n              selectedlevel(1,:) = (/ 0, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 0, 1 /)\n            case (7)\n              selectedlevel(1,:) = (/ 0, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 0 /)\n            case (8)\n              selectedlevel(1,:) = (/ 1, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 0 /)\n            case (9)\n              selectedlevel(1,:) = (/ 1, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 1 /)\n            case default\n              selectedlevel(1,:) = (/ 1, 1, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 1 /)\n          end select\n          xs = i + k\n          xf = xs + 3\n          ys = j + r\n          yf = ys + 3\n          returnparam(xs:xf, ys:yf) = selectedlevel\n          r = r + 2\n        end do\n          r = 0\n          k = k + 2\n      end do\n    end subroutine ordered_dithering3x3\n"}, {"instruction": "Write a Fortran subroutine named ordered_comb4_iterator to generate a binary matrix based on a masked matrix. The subroutine takes 3 input parameters of type integer, integer, and integer, dimension(0:h-1, 0:l-1), and 1 output parameter of type integer, dimension(0:h-1, 0:4*l-1).", "input": "", "output": "    subroutine ordered_comb4_iterator(masked, h, l, binary)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: masked\n      integer, dimension(0:h-1, 0:4*l-1), intent(out) :: binary\n\n      integer :: i, j, r\n      integer, dimension(0:15, 4) :: level\n\n      level(0, :) = (/ 0, 0, 0, 0 /)\n      level(1, :) = (/ 0, 0, 0, 1 /)\n      level(2, :) = (/ 0, 0, 1, 0 /)\n      level(3, :) = (/ 0, 0, 1, 1 /)\n      level(4, :) = (/ 0, 1, 0, 0 /)\n      level(5, :) = (/ 0, 1, 0, 1 /)\n      level(6, :) = (/ 0, 1, 1, 0 /)\n      level(7, :) = (/ 0, 1, 1, 1 /)\n      level(8, :) = (/ 1, 0, 0, 0 /)\n      level(9, :) = (/ 1, 0, 0, 1 /)\n      level(10, :) = (/ 1, 0, 1, 0 /)\n      level(11, :) = (/ 1, 0, 1, 1 /)\n      level(12, :) = (/ 1, 1, 0, 0 /)\n      level(13, :) = (/ 1, 1, 0, 1 /)\n      level(14, :) = (/ 1, 1, 1, 0 /)\n      level(15, :) = (/ 1, 1, 1, 1 /)\n\n      do i = 0, h - 1\n        r = 0\n        do j = 0, l - 1\n          binary(i, j+r:j+r+3) = level(masked(i, j), :)\n          r = r + 3\n        end do\n      end do\n    end subroutine ordered_comb4_iterator\n"}, {"instruction": "Write a Fortran subroutine named ordered_comb3_iterator to generate a new array based on the input array and parameters. The number of input arguments is 3 with the test_data type ['integer', 'integer', 'integer, dimension(0:h-1, 0:l-1)']. The number of output arguments is 1 with the test_data type ['integer, dimension(0:h-1, 0:3*l-1)'].", "input": "", "output": "    subroutine ordered_comb3_iterator(masked, h, l, returnparam)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: masked\n      integer, dimension(0:h-1, 0:3*l-1), intent(out) :: returnparam\n\n      integer :: i, j, r\n      integer, dimension(0:7, 3) :: level\n      integer, dimension(0:h-1, 0:3*l-1) :: binary\n\n      level(0, :) = (/ 0, 0, 0 /)\n      level(1, :) = (/ 0, 0, 1 /)\n      level(2, :) = (/ 0, 1, 0 /)\n      level(3, :) = (/ 0, 1, 1 /)\n      level(4, :) = (/ 1, 0, 0 /)\n      level(5, :) = (/ 1, 0, 1 /)\n      level(6, :) = (/ 1, 1, 0 /)\n      level(7, :) = (/ 1, 1, 1 /)\n      do i = 0, h - 1\n        r = 0\n        do j = 0, l - 1\n          binary(i, j+r:j+r+2) = level(masked(i, j), :)\n          r = r + 2\n        end do\n      end do\n      returnparam = binary\n    end subroutine ordered_comb3_iterator\n"}, {"instruction": "Create a Fortran subroutine named realise_iid that computes the realized shock of an iid process. The subroutine should have 3 input parameters of type integer, integer, and real(8) for agents, periods, and param_value respectively. The output parameter should be an integer array of dimension (agents, periods) for shocks.", "input": "", "output": "subroutine realise_iid(agents, periods, param_value, shocks)\n  ! computes the realised shock of an iid process\n\n  implicit none\n\n  integer, intent(in) :: agents, periods\n  integer :: ind_ag, ind_p\n  integer, dimension(agents, periods), intent(out) :: shocks\n  real(8), intent(in) :: param_value\n  real(8), dimension(agents, periods) :: aux_shocks\n\n  shocks = 0\n\n  call random_number(aux_shocks)\n\n  do ind_ag = 1, agents\n  do ind_p = 1, periods\n    if (aux_shocks(ind_ag,ind_p).le.param_value) then\n      shocks(ind_ag,ind_p) = 1\n    end if\n  end do\n  end do\nend subroutine realise_iid\n"}, {"instruction": "Create a Fortran subroutine named random_integers to generate a matrix of random integers. The subroutine takes 4 input parameters of type integer: rows, columns, lb, and ub. It also has 1 output parameter, an integer matrix of dimension (rows, columns). The subroutine utilizes the random_number function to populate an auxiliary real matrix and then converts the real values to integers within the specified range [lb, ub].", "input": "", "output": "subroutine random_integers(rows, columns, lb, ub, int_matrix)\n  ! returns a int_matrix(rows, columns) of random integer number numbers in [lb,ub]\n  integer, intent(in) :: rows, columns, lb, ub\n  integer, dimension(rows, columns), intent(out) :: int_matrix\n  real(8), dimension(rows, columns) :: aux_mat\n\n  call random_number(aux_mat)\n\n  int_matrix = lb + floor(real(ub+1-lb)*aux_mat)\nend subroutine random_integers\n"}, {"instruction": "Write a Fortran subroutine named linint to perform linear interpolation. The subroutine takes 4 input parameters: an integer (n), an array of double precision (xa), an array of double precision (ya), and a double precision (x). It produces 2 output parameters: both of double precision type (y, m).", "input": "", "output": "  subroutine linint(xa,ya,n,x,y,m)\r\n    implicit none\r\n    integer, intent(in) :: n\r\n    double precision, intent(in) :: xa(n),ya(n),x\r\n    double precision, intent(out) :: y,m\r\n\r\n    integer :: jlo,jhi,k\r\n    double precision :: b\r\n\r\n    jlo=1  \r\n    jhi=n\r\n\r\n    !determine which two xa location that x lies between\r\n    do\r\n      k=(jhi+jlo)/2\r\n\r\n      if(xa(k).gt.x)then\r\n        jhi=k\r\n      else\r\n        jlo=k\r\n      endif\r\n\r\n      if (jhi-jlo == 1) exit\r\n    enddo\r\n\r\n    !calculate the slope and intersect\r\n    m = ( ya(jlo) - ya(jhi) )/ ( xa(jlo) - xa(jhi) )\r\n    b = ya(jlo) - m*xa(jlo)\r\n\r\n    !linearly interpolate y\r\n    y = m*x + b\r\n\r\n    return\r\n\r\n  end subroutine linint\r\n"}, {"instruction": "Create a Fortran subroutine named assigncomplex. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The purpose of this subroutine is to assign the input real number to the output real variable.", "input": "", "output": "subroutine assigncomplex(realmat,complexf)\n  implicit none\n  real*8,intent(out) :: realmat\n  real*8,intent(in) :: complexf\n  realmat=complexf\nend subroutine assigncomplex\n"}, {"instruction": "Write a Fortran subroutine named assigncomplexmat to copy the values of a complex matrix to a real matrix. The subroutine takes 3 input arguments of types integer, integer, and real*8, and 1 output argument of type real*8.", "input": "", "output": "subroutine assigncomplexmat(realmat,complexf,m,n)\n  implicit none\n  integer,intent(in) :: n,m\n  real*8,intent(out) :: realmat(m,n)\n  real*8,intent(in) :: complexf(m,n)\n  realmat(:,:)=complexf(:,:)\nend subroutine assigncomplexmat\n"}, {"instruction": "Write a Fortran subroutine named assigncomplexvec that takes two input parameters of type integer and real*8, and one output parameter of type real*8. The input parameter m is of type integer and is used to specify the size of the arrays. The input parameter complexf is an array of real*8 values. The output parameter realmat is also an array of real*8 values and is assigned the values from the complexf array.", "input": "", "output": "subroutine assigncomplexvec(realmat,complexf,m)\n  implicit none\n  integer,intent(in) :: m\n  real*8,intent(out) :: realmat(m)\n  real*8,intent(in) :: complexf(m)\n  realmat(:)=complexf(:)\nend subroutine assigncomplexvec\n"}, {"instruction": "Create a Fortran subroutine named assignrealvec to copy the elements of a real*8 array into another real*8 array. The subroutine should take 2 input parameters of type integer and real*8, and 1 output parameter of type real*8. The input parameters are m (integer) and realmat (real*8 array), and the output parameter is complexf (real*8 array).", "input": "", "output": "subroutine assignrealvec(complexf,realmat,m)\n  implicit none\n  integer,intent(in) :: m\n  real*8,intent(in) :: realmat(m)\n  real*8,intent(out) :: complexf(m)\n  complexf(:)=realmat(:)\nend subroutine assignrealvec\n"}, {"instruction": "Create a Fortran subroutine named assigncomplexvec that takes two input parameters: an integer m and an array of complex*16 numbers complexf of length m. The subroutine outputs a 2xM real*8 matrix realmat. The first row of realmat contains the real parts of the complex numbers, and the second row contains the imaginary parts of the complex numbers.", "input": "", "output": "subroutine assigncomplexvec(realmat,complexf,m)\n  implicit none\n  integer,intent(in) :: m\n  complex*16,intent(in) :: complexf(m)\n  real*8,intent(out) :: realmat(2,m)\n  realmat(1,:)=real(complexf(:),8);  realmat(2,:)=imag(complexf(:))\nend subroutine assigncomplexvec\n"}, {"instruction": "Create a Fortran subroutine named assignrealvec. The subroutine takes 2 input arguments with test_data types ['integer', 'real*8'] and 1 output argument with a test_data type of ['complex*16']. The subroutine computes the complex values by adding the real parts of the input matrix with the product of the imaginary unit and the second row of the input matrix.", "input": "", "output": "subroutine assignrealvec(complexf,realmat,m)\n  implicit none\n  integer,intent(in) :: m\n  complex*16,intent(out) :: complexf(m)\n  real*8,intent(in) :: realmat(2,m)\n  complexf(:)=realmat(1,:)+realmat(2,:)*(0d0,1d0)\nend subroutine assignrealvec\n"}, {"instruction": "Create a Fortran subroutine named checkelementconvexity to determine the convexity of an element based on its vertices' coordinates and vertex indices. The subroutine takes 4 input parameters of type integer, integer array, real(8) array, and real(8) array, and returns 1 output parameter of type integer.", "input": "", "output": "  pure subroutine checkelementconvexity(nvertex,vertex,x,y,convexnode)\n    integer,intent(in)           :: nvertex,vertex(:)\n    real(8),intent(in)           :: x(:),y(:)\n    integer,intent(out)          :: convexnode\n\n    !local variables\n    integer :: indx,iff,ibb\n    real(8) :: crossproduct\n\n    !initialize\n    convexnode =  0\n\n    !if element is triangular it cannot be convex\n    if (nvertex .eq. 3) return\n\n    !check if element is convex\n    !walking along the cell faces in the counter-clockwise direction and generating vectors between vertices,\n    !if cross product of two vectors joining at a vertex is negative we are turning right (internal angle greater than 180),\n    !otherwise we are turning left (what we want)\n    do indx=1,4\n      iff=indx+1  ;  if (iff.gt.4) iff=1\n      ibb=indx-1  ;  if (ibb.lt.1) ibb=4\n      crossproduct =  (x(indx)-x(ibb))*(y(iff)-y(indx)) &\n                    + (y(ibb)-y(indx))*(x(iff)-x(indx))\n      if (crossproduct .le. 0.0) then\n        convexnode = vertex(indx)\n        exit\n      end if\n   end do\n\n  end subroutine checkelementconvexity\n"}, {"instruction": "Create a Fortran subroutine named \"recons_stencil\" that takes 2 input parameters of type integer and logical, and 3 output parameters of type integer. The subroutine's purpose is to generate stencil indices for a reconstruction procedure based on material interfaces. The input parameter \"ie\" represents the cell index, and \"matint_cell\" is a logical array indicating the presence of material interfaces around the cell. The output parameters \"lefte\", \"righte\", and \"skew\" represent the stencil indices for the left, right, and skew directions, respectively. The subroutine modifies these indices based on the presence of material interfaces and the cell index.", "input": "", "output": "subroutine recons_stencil(ie, matint_cell, lefte, righte, skew)\n\ninteger, intent(in) :: ie\nlogical, intent(in) :: matint_cell(-2:2)\n\ninteger, intent(out) :: lefte, righte, skew\n\n  ! 0. default central stencil\n  lefte = ie-1\n  righte = ie+1\n  skew = 0\n  ! only for interior cells, try to modify the limiting stencil according to\n  ! material interfaces\n  if ((ie.gt.1) .and. (ie.lt.imax)) then\n    ! 1. for material interface cells\n    if (matint_cell(0)) then\n      ! if this is the only material interface cell in the vicinity, diffuse\n      ! the interface\n      if (.not.matint_cell(-1) .and. .not.matint_cell(1)) then\n        lefte = ie-1\n        righte = ie+1\n        skew = 0\n      ! if the left cell is not an interface cell, extend stencil to right,\n      ! but only if the right cell is an interface cell\n      else if (.not.matint_cell(-1) .and. matint_cell(2)) then\n        lefte = ie+2\n        skew = 1\n      ! if the right cell is not an interface cell, extend stencil to left,\n      ! but only if the left cell is an interface cell\n      else if (.not.matint_cell(1) .and. matint_cell(-2)) then\n        righte = ie-2\n        skew = -1\n      end if\n    ! 2. for 'pure' cells\n    else\n      if (matint_cell(-1) .and. matint_cell(1)) then\n        lefte = ie-1\n        righte = ie+1\n        skew = 0\n      else if (matint_cell(-1) .and. .not.matint_cell(2)) then\n        lefte = ie+2\n        skew = 1\n      else if (matint_cell(1) .and. .not.matint_cell(-2)) then\n        righte = ie-2\n        skew = -1\n      end if\n    end if\n  end if\n\nend subroutine recons_stencil\n"}, {"instruction": "Write a Fortran subroutine named open_grib_f that opens a grib file for writing and returns the file unit number. The subroutine takes 1 input argument of type character(len=*) and returns 1 output argument of type integer.", "input": "", "output": "  subroutine open_grib_f(fname,funit)\n   \n    ! opens a grib file for writing and returns the funit\n    implicit none\n    character(len=*),intent(in)      :: fname\n    integer,intent(out)                :: funit\n    logical                            :: opened \n    unitloop: do funit=7,1023\n      inquire(unit=funit,opened=opened) \n      if (.not.opened) exit unitloop\n    enddo unitloop\n    open(file=fname,unit=funit,access='direct',form='unformatted',&\n         recl=1) \n    return\n  end subroutine open_grib_f\n"}, {"instruction": "Create a Fortran subroutine named equivalence_array1d that identifies the unique points in a given array based on a specified tolerance. The subroutine takes 4 input parameters of type integer, integer, double precision, and double precision. It also returns 2 output parameters of type integer and double precision. The input parameters are d0, d1, array, and tol, while the output parameters are npts and eq_array. The subroutine works by comparing points in the input array to identify unique points within the specified tolerance.", "input": "", "output": "subroutine equivalence_array1d(d0, d1, array, tol, npts, eq_array)\n    !> equivalence points of an array.\n    !> d0 - dimension 1 of array (number of points).\n    !> d1 - dimension 2 of array (3 for dehomogenized array,\n    !> 4 for homogeneous array).\n    !> array - input array.\n    !> tol - tolerance.\n    !> npts - number of unique points.\n    !> eq_array - array of unique points.\n    \n    !f2py intent(in) d0, d1, array, tol\n    !f2py intent(out) npts, eq_array\n    !f2py depend(d0, d1) array, eq_array\n    \n    ! input\n    integer, intent(in) :: d0, d1\n    double precision, intent(in) ::  tol\n    double precision, intent(in) :: array(d0, d1)\n    \n    ! output\n    integer, intent(out) :: npts\n    double precision, intent(out) :: eq_array(d0, d1)\n    \n    ! working\n    logical :: unique\n    integer :: i, j, k\n    double precision :: dist, v(d1)\n    \n    eq_array(:, :) = 0.0d0\n    eq_array(1, :) = array(1, :)\n    npts = 1\n    do i = 2, d0\n        unique = .true.\n        do j = 1, npts\n            v = eq_array(j, :) - array(i, :)\n            dist = 0.0d0\n            do k = 1, d1\n                dist = dist + v(k) * v(k)\n            end do\n            dist = dsqrt(dist)\n            if (dist .le. tol) then\n                unique = .false.\n                exit\n            end if\n        end do\n        if (unique .eqv. .true.) then\n            npts = npts + 1\n            eq_array(npts, :) = array(i, :)\n        end if\n    end do\nend subroutine equivalence_array1d\n"}, {"instruction": "Write a Fortran subroutine named tsort to perform a topological sort on a directed acyclic graph. The subroutine takes 3 input parameters of type integer, integer, and integer array of dimension nd, and returns 2 output parameters, one of type integer array of dimension nl, and another of type integer.", "input": "", "output": "subroutine tsort(nl,nd,idep,iord,no)\n\n  implicit none\n\n  integer,intent(in) :: nl\n  integer,intent(in) :: nd\n  integer,dimension(nd,2),intent(in) :: idep\n  integer,dimension(nl),intent(out) :: iord\n  integer,intent(out) :: no\n\n  integer :: i,j,k,il,ir,ipl,ipr,ipos(nl)\n\n  do i=1,nl\n    iord(i)=i\n    ipos(i)=i\n  end do\n  k=1\n  do\n    j=k\n    k=nl+1\n    do i=1,nd\n      il=idep(i,1)\n      ir=idep(i,2)\n      ipl=ipos(il)\n      ipr=ipos(ir)\n      if (il==ir .or. ipl>=k .or. ipl<j .or. ipr<j) cycle\n      k=k-1\n      ipos(iord(k))=ipl\n      ipos(il)=k\n      iord(ipl)=iord(k)\n      iord(k)=il\n    end do\n    if (k<=j) exit\n  end do\n  no=j-1\n\nend subroutine tsort\n"}, {"instruction": "Create a Fortran subroutine named arr_2_int_int32 to convert an array of integers into a single integer. The subroutine takes 1 input parameter of type integer array and returns 1 output parameter of type integer.", "input": "", "output": "    pure subroutine arr_2_int_int32(arr, n)\n        integer, intent(in) :: arr(:)\n        integer, intent(out) :: n\n        integer :: i, tmp, l\n\n        l = size(arr, dim=1)\n        tmp = 0\n\n        do i = 1, l\n            tmp = tmp*10 + arr(i)\n        end do\n\n        n = tmp\n    end subroutine arr_2_int_int32\n"}, {"instruction": "Create a Fortran subroutine named score_board to analyze a game board and compute the score based on specific rules. The subroutine takes 3 input parameters of type integer, dimension(100), integer, dimension(100,5,5), and integer, and 2 output parameters of type integer.", "input": "", "output": "      subroutine score_board(board, index, numbers, i, score)\n        integer, dimension(100), intent(in) :: numbers\n        integer, dimension(100,5,5), intent(in) :: board\n        integer, intent(in) :: index\n        integer, intent(out) :: i, score\n        integer, dimension(5,5) :: called\n        integer :: n\n\n        score = 0\n\n        do j = 1, 5\n           do k = 1, 5\n              called(j,k) = 0\n              score = score + board(index,j,k)\n           end do\n        end do\n\n        do i = 1, 100\n           n = numbers(i)\n           do j = 1, 5\n              do k = 1, 5\n                 if (board(index,j,k) == n) then\n                    called(j,k) = 1\n                    score = score - board(index,j,k)\n                    if (called(j,1) + called(j,2) + called(j,3) + called(j,4) + called(j,5) == 5) then\n                       print*, \"row\"\n                       return\n                    else if (called(1,k) + called(2,k) + called(3,k) + called(4,k) + called(5,k) == 5) then\n                       print*, \"col\"\n                       return\n                    end if\n                 end if\n              end do\n           end do\n        end do\n      end subroutine score_board\n"}, {"instruction": "Create a Fortran subroutine named snowalb_bats_glacier to calculate the snow albedo for a glacier surface. The subroutine takes 3 input parameters: an integer (nband), and two real numbers (cosz, fage). It returns 2 output parameters: two real arrays of size 2 (albsnd, albsni). The subroutine computes the snow albedo for direct and diffuse solar radiation based on the provided inputs.", "input": "", "output": "  subroutine snowalb_bats_glacier (nband,cosz,fage,albsnd,albsni)\n  implicit none\n  integer,intent(in) :: nband\n  real,intent(in) :: cosz\n  real,intent(in) :: fage\n  real, dimension(1:2),intent(out) :: albsnd\n  real, dimension(1:2),intent(out) :: albsni\n  real :: fzen\n  real :: cf1\n  real :: sl2\n  real :: sl1\n  real :: sl\n  real, parameter :: c1 = 0.2\n  real, parameter :: c2 = 0.5\n        albsnd(1: nband) = 0.\n        albsni(1: nband) = 0.\n        sl=2.0\n        sl1=1./sl\n        sl2=2.*sl\n        cf1=((1.+sl1)/(1.+sl2*cosz)-sl1)\n        fzen=amax1(cf1,0.)\n        albsni(1)=0.95*(1.-c1*fage)\n        albsni(2)=0.65*(1.-c2*fage)\n        albsnd(1)=albsni(1)+0.4*fzen*(1.-albsni(1))\n        albsnd(2)=albsni(2)+0.4*fzen*(1.-albsni(2))\n  end subroutine snowalb_bats_glacier\n"}, {"instruction": "Write a Fortran subroutine named ell_house to compute a Householder vector v and a beta value based on the input vector x. The number of input arguments is 2, with test_data types ['integer', 'real(kind(1.d0))']. The number of output arguments is 2, with test_data types ['real(kind(1.d0))', 'real(kind(1.d0))'].", "input": "", "output": "subroutine ell_house( n, x, v, beta )\n\n!  determine a householder vector v based on x.\n!  the orthogonal matrix p = i - beta * v * v^t has the\n!  property: px = |x| * e_1.\n\n!  from golub & van loan algorithm 5.1.1\n\ninteger, intent(in)           :: n\nreal(kind(1.d0)), intent(in)  :: x(n)\nreal(kind(1.d0)), intent(out) :: v(n), beta\n\nreal(kind(1.d0)) :: sigma, mu\n\nv    = 0.d0\nbeta = 0.d0\nif( n <= 1 ) return\n\nsigma  = sum( x(2:n)*x(2:n) )\nv(1)   = 1.d0\nv(2:n) = x(2:n)\n\nif( sigma == 0.d0 ) then\n   beta = 0.d0\nelse\n   mu = sqrt( x(1)**2 + sigma )\n   if( x(1) < 0.d0 ) then\n      v(1) = x(1) - mu\n   else\n      v(1) = -sigma / ( x(1) + mu )\n   endif\n\n   beta = 2.*v(1)**2 / (sigma+v(1)**2)\n   v    = v / v(1)\nendif\n\nreturn\n\nend subroutine ell_house\n"}, {"instruction": "Create a Fortran subroutine named getuniquearraycomponents to extract unique elements from an input integer array and store them in an allocatable integer array. The number of input parameters is 1 with the test_data type ['integer'], and the number of output parameters is 1 with the test_data type ['integer,allocatable'].", "input": "", "output": "  subroutine getuniquearraycomponents(arrayin,arrayout)\n    integer,intent(in)              :: arrayin(:)\n    integer,allocatable,intent(out) :: arrayout(:)\n    \n    !local variables\n    integer :: n,workarray(size(arrayin)),indx,ivalue\n    \n    !initialize\n    n            = 1\n    workarray(1) = arrayin(1)\n    do indx=2,size(arrayin)\n      ivalue = arrayin(indx)\n      if (.not. any(workarray(1:n) .eq. ivalue)) then\n        n = n + 1\n        workarray(n) = ivalue\n      end if\n    end do\n    \n    !allocate memory for return array and store data\n    allocate (arrayout(n))\n    arrayout = workarray(1:n)\n    \n  end subroutine getuniquearraycomponents\n"}, {"instruction": "Write a Fortran subroutine named convertid_to_index_scalar that takes two integer input parameters and one integer output parameter. The input parameters are id and allids(:), and the output parameter is index. The subroutine should find the index of the given id in the array allids and assign the index to the output parameter. If id is not found, the output parameter should be 0.", "input": "", "output": "  subroutine convertid_to_index_scalar(id,allids,index)\n    integer,intent(in)  :: id,allids(:)\n    integer,intent(out) :: index\n    \n    !local variables\n    integer :: indx\n    \n    !initialize\n    index = 0\n    \n    if (id .eq. 0) return\n    \n    do indx=1,size(allids)\n        if (id .eq. allids(indx)) then\n            index = indx\n            exit\n        end if\n    end do\n    \n  end subroutine convertid_to_index_scalar\n"}, {"instruction": "Create a Fortran subroutine named pw_integ to calculate the integral of the plane wave in the interstitials. The subroutine takes 9 input parameters of types: integer, real*8, real*8, real*8, integer, real*8, integer, integer, integer. There is 1 output parameter of type complex*16.", "input": "", "output": "subroutine pw_integ(ipwint, gind, glen, vmt, rmt, pos, mult, nk, nat, ndf)\n  ! this function calculated integral of the plane wave in the interstitials\n  ! for all vectors in gind array with length glen:\n  !  integrate[ exp(i g\\vr), {\\vr in interstitials}]\n  ! \n  ! we could use  function int1ipw from for_vxcnn.f90, which does the same thing, but for\n  ! a single vector\n  implicit none\n  complex*16, intent(out) :: ipwint(nk)\n  integer, intent(in)     :: gind(nk,3)\n  real*8, intent(in)      :: glen(nk)\n  real*8, intent(in)      :: vmt(nat)\n  real*8, intent(in)      :: rmt(nat)\n  integer, intent(in)     :: mult(nat)\n  real*8, intent(in)      :: pos(3,ndf)\n  integer, intent(in)     :: nk, nat, ndf\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  integer    :: ippw, i, idf, iat, ki(3), ieq\n  real*8     :: ak, x, j1, intmod!, pk\n  complex*16 :: integc\n  complex*16 :: phase, two_pi_i\n  two_pi_i = 2.0d0*pi*cmplx(0.d0,1.d0,8)\n  ipwint = 0\n  do ippw=1,nk\n     !i = indx(ippw)+1\n     i = ippw\n     ki = gind(i,:)  ! ki=(i0,i1,i2)\n     ak = glen(i)    ! ak=|kc|\n     !print *, ippw, i, ki, ak\n     if (ak < 1e-10) then\n        integc = 0\n        do iat=1,nat\n           integc = integc + vmt(iat)*mult(iat)\n        end do\n        ipwint(ippw) = 1.d0 - integc\n     else\n        integc = 0\n        idf = 0\n        do iat=1,nat\n           phase = 0\n           do ieq=1,mult(iat)\n              idf = idf + 1\n              !pk = dot_product(pos(:,idf),ki)*2.d0*pi\n              !phase = phase + dcmplx( cos(pk), sin(pk) )\n              phase = phase + exp(two_pi_i * dot_product(pos(:,idf),ki))\n           end do\n           x = ak * rmt(iat)                    ! kr[iat] = |kc|*rmt[iat]\n           j1 = (sin(x)/x-cos(x))/x             ! spherical_bessel == (sin(x)/x-cos(x))/x\n           intmod = vmt(iat) * 3*j1/x           ! intmod[iat] = j1*3*vmt/kr\n           integc = integc + intmod * phase\n        end do\n        ipwint(ippw) = -integc\n     end if\n  end do\nend subroutine pw_integ\n"}, {"instruction": "Create a Fortran subroutine named count_number_pw to calculate the number of plane waves and the number of plane waves within a certain range. The subroutine takes 4 input parameters of type integer, real*8, and real*8, and 2 output parameters of type integer.", "input": "", "output": "subroutine count_number_pw(npw2apw, ngindx, ng, kmax, gmax, br2)\n  implicit none\n  integer, intent(out) :: npw2apw, ngindx\n  integer, intent(in)  :: ng(3)\n  real*8,  intent(in)  :: br2(3,3)\n  real*8,  intent(in)  :: kmax, gmax\n  !\n  real*8  :: ki(3), kc(3), kk\n  integer :: i1, i2, i3\n  npw2apw = 0\n  ngindx = 0\n  do i1=-ng(1),ng(1)\n     do i2=-ng(2),ng(2)\n        do i3=-ng(3),ng(3)\n           ki(1) = i1\n           ki(2) = i2\n           ki(3) = i3\n           kc = matmul(br2,ki)\n           kk = sqrt(dot_product(kc,kc))\n           if ( kk < 2.*kmax+4) npw2apw = npw2apw + 1\n           if ( kk < gmax ) ngindx = ngindx + 1\n        enddo\n     enddo\n  enddo\nend subroutine count_number_pw\n"}, {"instruction": "Create a Fortran subroutine named getindices to determine the neighboring indices of a given index in an array. The subroutine takes 2 input parameters of type integer and returns 3 output parameters of type integer. The subroutine computes the previous, current, and next indices based on the given index and the size of the array.", "input": "", "output": "    subroutine getindices(idx, nx, xb, xc, xf)\n        implicit none\n        integer, intent(in) :: idx, nx\n        integer, intent(out) :: xb, xc, xf\n\n        if( idx == 1) then\n            xb = nx\n            xc = idx\n            xf = idx+1\n        else if(idx == nx) then\n            xb = idx-1\n            xc = idx\n            xf = 1\n        else\n            xb = idx-1\n            xc = idx\n            xf = idx+1\n        endif\n    end subroutine getindices\n"}, {"instruction": "Create a Fortran subroutine named string_out_assumed_len that takes an integer as input and returns two strings of assumed length as output. The input parameter is of type integer, and the output parameters are of type character(len=*). The function assigns the strings 'string a' and 'string b' to the output parameters s1 and s2, respectively.", "input": "", "output": "  subroutine string_out_assumed_len(s1,x,s2)\n    character(len=* ), intent(out) :: s1,s2\n    integer, intent(in) :: x ! dummy\n    s1 = 'string a'\n    s2 = 'string b'\n  end subroutine string_out_assumed_len\n"}, {"instruction": "Create a Fortran subroutine named \"choleskysolve\" to solve a system of linear equations using the Cholesky factorization method. The subroutine takes 3 input parameters of types integer, real(8) arrays of dimension n x n, and real(8) array of dimension n. It produces 1 output parameter of type real(8) array of dimension n.", "input": "", "output": "subroutine choleskysolve(n, l, b, x)\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n),   intent(in)  :: b\n   real(8), dimension(n),   intent(out) :: x\n\n   ! declare the local variables.\n   integer :: i, j\n\n   ! initialize.\n   x = b\n\n   ! solve l y = b using forward elimination.\n   do i = 1, n\n      do j = 1, i-1\n         x(i) = x(i) - l(i,j)*x(j)\n      end do\n      x(i) = x(i) / l(i,i)\n   end do\n\n   ! solve l' x = y using back substitution.\n   do i = n, 1, -1\n      do j = i+1, n\n         x(i) = x(i) - l(j,i)*x(j)\n      end do\n      x(i) = x(i) / l(i,i)\n   end do\nend subroutine choleskysolve\n"}, {"instruction": "Create a Fortran subroutine named choleskyinverse to calculate the inverse of a matrix using the Cholesky decomposition method. The subroutine takes 2 input parameters: an integer n and a real(8) matrix l of dimension n x n. It produces 1 output parameter: a real(8) matrix ainv of dimension n x n.", "input": "", "output": "subroutine choleskyinverse(n, l, ainv)\n\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n,n), intent(out) :: ainv\n\n   ! declare the local variables.\n   integer :: i, k\n   real(8), dimension(n,n) :: u\n\n   ! initialize.\n   u = transpose(l)\n\n   ! invert u in place.\n   do k = 1, n\n      u(k,k) = 1.0_8/u(k,k)\n\n      do i = 1, k-1\n         u(i,k) = -u(k,k) * dot_product( u(i,i:k-1), u(i:k-1, k) )\n      end do\n   end do\n\n   ! a = l l' = l u --> ainv = uinv linv = uinv (uinv)'\n   ainv = matmul(u, transpose(u))\n\nend subroutine choleskyinverse\n"}, {"instruction": "Create a Fortran subroutine named \"rspdinv\" that computes the inverse of a symmetric positive definite matrix using Cholesky decomposition. The subroutine takes 2 input parameters: an integer \"n\" and a real(8) 2D array \"l\" of size n x n. It produces 1 output parameter: a real(8) 2D array \"ainv\" of size n x n.", "input": "", "output": "subroutine rspdinv(n, l, ainv)\n\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n,n), intent(out) :: ainv\n\n   ! declare the local variables.\n   integer :: i, k\n   real(8), dimension(n,n) :: u\n\n   ! compute the cholesky decomposition.\n   ! call choleskydecomposition(n, a, l)\n   u = transpose(l)\n\n   ! invert u in place.\n   do k = 1, n\n      u(k,k) = 1.0_8/u(k,k)\n\n      do i = 1, k-1\n         u(i,k) = -u(k,k) * dot_product( u(i,i:k-1), u(i:k-1, k) )\n      end do\n   end do\n\n   ! a = l l' = l u --> ainv = uinv linv = uinv (uinv)'\n   ainv = matmul(u, transpose(u))\n\nend subroutine rspdinv\n"}, {"instruction": "Create a Fortran subroutine named bar that takes three input arguments of type real, dimension(3,3), real, dimension(3,3), and logical, dimension(3,3), and one output argument of type integer. The subroutine utilizes a do loop to compare elements of the input arrays and assigns a value to the output argument based on the comparison results.", "input": "", "output": "  subroutine bar(a,b,c, lo)\n    real, dimension(3,3), intent(in) :: a,b\n    logical, dimension(3,3), intent(in) :: lo\n    integer, intent(out) :: c\n    real, parameter :: acc = 1e-4\n    integer :: i,j\n    \n    c = 0\n    do i=1,3\n       if (any([abs(a(i,1) - b(i,1)) > acc,  &\n            (j==i+1,j=3,8)])) cycle\n       if (any([abs(a(i,2) - b(i,2)) > acc, &\n            abs(a(i,3) - b(i,3)) > acc, lo(i,:)])) cycle\n       c = c + i\n    end do\n  end subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named count_tree to read and process data from a file. The subroutine takes 2 input parameters of type character(len=256) and logical. It also has 4 output parameters of type integer. The subroutine reads data from the file specified by the input parameter, processes the data, and assigns the results to the output parameters flist_index, slist_index, n_halos_all, and nsteps.", "input": "", "output": "subroutine count_tree(fn, n_halos_all, flist_index, slist_index, nsteps, big_run)\n    implicit none\n    character(len=256), intent(in)::fn\n\n    integer::nfathers, nsons\n    integer, dimension(:), allocatable::nb_of_halos, nb_of_subhalos\n    integer, intent(out)::flist_index, slist_index, n_halos_all, nsteps\n\n    integer(kind=4)::i,j, nhals_now\n    logical, intent(in)::big_run\n\n    open(unit=1,file=fn,status='old',form='unformatted')\n\n    read(1)nsteps\n    allocate(nb_of_halos(1:nsteps))\n    allocate(nb_of_subhalos(1:nsteps))\n    read(1)nb_of_halos(1:nsteps),nb_of_subhalos(1:nsteps)\n\n    n_halos_all = sum(nb_of_halos) + sum(nb_of_subhalos)\n    read(1)!aexp_arr(1:nsteps)\n    read(1)!omega_t_arr(1:nsteps)\n    read(1)!age_univ_arr(1:nsteps)\n    flist_index=0\n    slist_index=0\n    do i=1,nsteps\n        nhals_now=nb_of_halos(i)+nb_of_subhalos(i)\n        do j=1,nhals_now\n            read(1)!id_tmp!i_arr(idx,2) !id!id\n            read(1)!i_arr(idx,3) !bushid\n            read(1)!i_arr(idx,4) !st\n            read(1)!i_arr(idx,5:9) ! hosts\n            read(1)!f_arr(idx,1) ! m\n            read(1)!macc ! macc alone is double\n            read(1)!f_arr(idx,3:5)!xp\n            read(1)!f_arr(idx,6:8)!vp\n            read(1)!f_arr(idx,9:11)!lp\n            read(1)!f_arr(idx,12:15)!abc\n            read(1)!f_arr(idx,16:18)!energy\n            read(1)!f_arr(idx,19)!spin\n            read(1)nfathers!nfathers\n            flist_index = flist_index + nfathers\n\n            read(1)!father id\n            read(1)!father mass\n            read(1)nsons\n            if (nsons .gt. 0) then\n                read(1)!id_tmp!son id\n                !write(*,*)id_tmp\n            endif\n            slist_index = slist_index + nsons\n            read(1)! (r,m,t)_vir, c_vel\n            read(1)! profile\n            if (.not. big_run) then\n                read(1)!id_tmp! particle id\n            endif\n\n        enddo\n    enddo\n    deallocate(nb_of_halos, nb_of_subhalos)\n    close(1)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named setnodg that takes an integer femtype as input and returns an integer nodg as output. The subroutine determines the number of degrees of freedom per node based on the femtype provided. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "\tsubroutine setnodg(femtype,nodg)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tnodg = 3\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tnodg = 4\n\t\t\tcase(3) !! linear quadrangle\n\t\t\t\tnodg = 3\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named setfemtype to determine the finite element type based on the input femtype. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer. The output parameters represent nodg, porder, ngp, isimplex, and ibubble respectively. The subroutine uses a select case statement to assign values to the output parameters based on the input femtype. If the femtype is not supported, the subroutine stops and displays an error message.", "input": "", "output": "\tsubroutine setfemtype(femtype,nodg,porder,ngp,isimplex,ibubble)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg,porder,ngp,isimplex,ibubble\n\t\t\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(3) !! linear triangle with 3 gauss points\n\t\t\t\tngp = 3\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\t\t\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named dcm_set that takes one input parameter of type real(8) and returns two output parameters, both of type real(8). This subroutine is designed to compute the direction cosine matrices cbe and ceb based on the input quaternion quat. Use this subroutine to perform the calculation.", "input": "", "output": "subroutine dcm_set(cbe,ceb,quat)\n  real(8),intent(in) :: quat(:)\n  real(8),intent(out) :: cbe(:,:),ceb(:,:)\n  \n  cbe(1,1) = quat(1)*quat(1) - quat(2)*quat(2) - quat(3)*quat(3) + quat(4)*quat(4)\n  cbe(2,1) = 2.0d0*(quat(1)*quat(2) + quat(3)*quat(4))\n  cbe(3,1) = 2.0d0*(quat(1)*quat(3) - quat(2)*quat(4))\n  cbe(1,2) = 2.0d0*(quat(1)*quat(2) - quat(3)*quat(4))\n  cbe(2,2) = quat(2)*quat(2) - quat(1)*quat(1) - quat(3)*quat(3) + quat(4)*quat(4)\n  cbe(3,2) = 2.0d0*(quat(2)*quat(3) + quat(1)*quat(4))\n  cbe(1,3) = 2.0d0*(quat(1)*quat(3) + quat(2)*quat(4))\n  cbe(2,3) = 2.0d0*(quat(2)*quat(3) - quat(1)*quat(4))\n  cbe(3,3) = quat(3)*quat(3) - quat(1)*quat(1) - quat(2)*quat(2) + quat(4)*quat(4)\n\n  ceb(1,1) = quat(1)*quat(1) - quat(2)*quat(2) - quat(3)*quat(3) + quat(4)*quat(4)\n  ceb(2,1) = 2.0d0*(quat(1)*quat(2) - quat(3)*quat(4))\n  ceb(3,1) = 2.0d0*(quat(1)*quat(3) + quat(2)*quat(4))\n  ceb(1,2) = 2.0d0*(quat(1)*quat(2) + quat(3)*quat(4))\n  ceb(2,2) = quat(2)*quat(2) - quat(1)*quat(1) - quat(3)*quat(3) + quat(4)*quat(4)\n  ceb(3,2) = 2.0d0*(quat(2)*quat(3) - quat(1)*quat(4))\n  ceb(1,3) = 2.0d0*(quat(1)*quat(3) - quat(2)*quat(4))\n  ceb(2,3) = 2.0d0*(quat(2)*quat(3) + quat(1)*quat(4))\n  ceb(3,3) = quat(3)*quat(3) - quat(1)*quat(1) - quat(2)*quat(2) + quat(4)*quat(4)\n  \nend subroutine dcm_set\n"}, {"instruction": "Create a Fortran subroutine named matsum to calculate the values of gr and gi. The subroutine takes 7 input parameters of type real*8, real*8, real*8, real*8, real*8, integer, and integer. It returns 2 output parameters of type real*8, real*8.", "input": "", "output": "subroutine matsum(gr, gi, en, iom, x0, dh, wb, nom, nx)\n  implicit none\n  real*8, intent(out) :: gr(nom), gi(nom)\n  real*8, intent(in)  :: en\n  real*8, intent(in)  :: iom(nom)\n  real*8, intent(in)  :: x0(nx)\n  real*8, intent(in)  :: dh(nx)\n  real*8, intent(in)  :: wb(nx)\n  integer, intent(in) :: nom, nx\n  !f2py integer intent(hide), depend(iom)  :: nom=shape(iom,0)\n  !f2py integer intent(hide), depend(x0)   :: nx=shape(x0,0)\n  !real*8 :: simps\n  real*8 :: omn, w1, sumr, sumi\n  integer :: n, k\n  \n  gr=0\n  gi=0\n  do n=1,nom\n     omn = iom(n)\n     sumr=0\n     sumi=0\n     do k=1,nx\n        w1 = wb(k)/(omn**2+(x0(k)+en)**2)\n        sumr = sumr + w1*(x0(k)+en)*dh(k)\n        sumi = sumi + w1*omn*dh(k)\n     enddo\n     gr(n) = -sumr\n     gi(n) = -sumi\n  enddo\nend subroutine matsum\n"}, {"instruction": "Create a Fortran subroutine named \"kramskron\" that takes 8 input parameters of type real*8, real*8, real*8, real*8, real*8, real*8, integer, integer and 1 output parameter of type complex*16. The subroutine calculates the kramers-kronig transformation based on the input parameters frc, om, f0, wb, x0, dhx, en, nom, and nx. Use an imperative tone to define the subroutine.", "input": "", "output": "subroutine kramskron(frc, om, f0, wb, x0, dhx, en, nom, nx)\n  implicit none\n  complex*16, intent(out) :: frc(nom)\n  real*8, intent(in)  :: om(nom)\n  real*8, intent(in)  :: f0(nom)\n  real*8, intent(in)  :: wb(nx)\n  real*8, intent(in)  :: x0(nx)\n  real*8, intent(in)  :: dhx(nx)\n  real*8, intent(in)  :: en\n  integer, intent(in) :: nom, nx\n  !f2py integer intent(hide), depend(om)  :: nom=shape(om,0)\n  !f2py integer intent(hide), depend(x0)  :: nx=shape(x0,0)\n  real*8, parameter :: pi = 3.14159\n  integer :: j, k\n  real*8  :: omj, wj, sums, fre, fri\n  \n  do j=1,nom\n     omj = om(j)\n     wj = f0(j)\n     sums=0\n     do k=1,nx\n        sums = sums + (wb(k)-wj)*dhx(k)/(omj-(x0(k)+en))\n     enddo\n     fre = sums - wj*log(abs((x0(nx)+en-omj)/(omj-x0(1)-en)))\n     fri = -pi*f0(j)\n     frc(j) = dcmplx(fre, fri)\n  enddo\nend subroutine kramskron\n"}, {"instruction": "Create a Fortran subroutine named fnamesnapshot to generate the name of a snapshot to be saved. The subroutine takes 4 input parameters of types character(len=*), integer, integer, and real*8, and produces 1 output parameter of type character(len=200). The subroutine constructs the snapshot name based on the input parameters, including the continent, population number, xmen value, and time.", "input": "", "output": "subroutine fnamesnapshot(continent,popno,xmen,t,output)\n  ! makes the name of the snapshot to save.\n  character(len=*),intent(in)  :: continent\n  character(len=200),intent(out) :: output\n  integer, intent(in) :: popno, t\n  real*8, intent(in)  :: xmen\n\n  write(output,\"(a)\") trim(continent)\n  write(output,\"(a,a,i6.6)\") trim(output), '_p', int(popno/1000.d0)\n  write(output,\"(a,a,f0.6)\") trim(output), '_x', xmen*1000.d0\n  write(output,\"(a,a,i6.6)\") trim(output), '_t', int(t/100.d0)\nend subroutine fnamesnapshot\n"}, {"instruction": "Create a Fortran subroutine named compute_mder_legacy that takes in 3 input parameters of types real*8, integer*8, and integer*8, and 3 output parameters of types integer*8, dimension(3*n), integer*8, dimension(3*n), and real*8, dimension(3*n). The subroutine calculates the derivative matrix and residual vector based on the input parameters using the finite difference method for a given value of s.", "input": "", "output": "subroutine compute_mder_legacy(s,n,der,i,j,f)\n  real*8, intent(in) :: s\n  integer*8, intent(in) :: n\n  integer*8, intent(in) :: der\n  integer*8, intent(out), dimension(3*n):: i\n  integer*8, intent(out), dimension(3*n):: j\n  real*8, intent(out), dimension(3*n):: f\n  integer*8 :: p\n  real*8 :: factor\n  if (der==0) then\n     factor=1;\n  else\n     factor=0;\n  end if\n  do p = 1, n\n     i(p) = p\n     j(p) = p\n     f(p) = 2.0*factor;\n  end do\n  do p = 1, n-1\n     i(n+p) = p\n     j(n+p) = p+1\n     f(n+p) = -1.0*factor;\n     i(2*n+p) = p+1\n     j(2*n+p) = p\n     f(2*n+p) = -1.0*factor;\n  end do\n  i(2*n)=n;\n  j(2*n)=1;\n  if (der == 0) then\n     f(2*n)=s*s*s;\n  else if (der == 1) then\n     f(2*n)=3*s*s;\n  else if (der == 2) then\n     f(2*n)=3*2*s;\n  else if (der == 3) then\n     f(2*n)=3*2;\n  else\n     f(2*n)=0;\n  end if\n  i(3*n)=1;\n  j(3*n)=n;\n  f(3*n)=-exp(s);\nend subroutine compute_mder_legacy\n"}, {"instruction": "Create a Fortran subroutine named createattributetypestring. It takes 1 input parameter of type integer and 1 output parameter of type character(len=256). The subroutine selects a string representing a specific attribute type based on the input integer value. The recognized attribute types are scalar, vector, tensor, matrix, tensor6, globalid, and notype. If the input integer does not match any recognized attribute type, a warning message is displayed.", "input": "", "output": "subroutine createattributetypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(200)\n   typestring = 'xdmf_attribute_type_scalar'\ncase(201)\n   typestring = 'xdmf_attribute_type_vector'\ncase(202)\n   typestring = 'xdmf_attribute_type_tensor'\ncase(203)\n   typestring = 'xdmf_attribute_type_matrix'\ncase(204)\n   typestring = 'xdmf_attribute_type_tensor6'\ncase(205)\n   typestring = 'xdmf_attribute_type_globalid'\ncase(206)\n   typestring = 'xdmf_attribute_type_notype'\ncase default\n   write(6,'(\"warning: unrecognized attribute type \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createattributetypestring\n"}, {"instruction": "Create a Fortran subroutine named createsettypestring that takes an integer input parameter and returns a character string of length 256. The input parameter is of type integer, and the output parameter is of type character(len=256). The subroutine is designed to select a string representation based on the value of the input parameter, and it handles unrecognized input values with a warning message.", "input": "", "output": "subroutine createsettypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(601)\n   typestring = 'xdmf_set_type_node'\ncase(602)\n   typestring = 'xdmf_set_type_cell'\ncase(603)\n   typestring = 'xdmf_set_type_face'\ncase(604)\n   typestring = 'xdmf_set_type_edge'      \ncase default\n   write(6,'(\"warning: unrecognized set type \",i0,\".\")') typeholder\nend select\n!----------------------------------------------------------------------\nend subroutine createsettypestring\n"}, {"instruction": "Create a Fortran subroutine named createattributecenterstring that takes an integer as input and returns a character string of length 256 as output. The input parameter is of type integer, and the output parameter is of type character. The subroutine selects a specific string based on the input integer value and assigns it to the output string. If the input integer does not match any specified cases, a warning message is printed.", "input": "", "output": "subroutine createattributecenterstring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(100)\n   typestring = 'xdmf_attribute_center_grid'\ncase(101)\n   typestring = 'xdmf_attribute_center_cell'\ncase(102)\n   typestring = 'xdmf_attribute_center_face'\ncase(103)\n   typestring = 'xdmf_attribute_center_edge'\ncase(104)\n   typestring = 'xdmf_attribute_center_node'\ncase default\n   write(6,'(\"warning: unrecognized attribute center \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createattributecenterstring\n"}, {"instruction": "Create a Fortran subroutine named createdatatypestring to convert an integer code representing a data type into a corresponding string. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type character(len=256).", "input": "", "output": "subroutine createdatatypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(0)\n   typestring = 'xdmf_array_type_int8'\ncase(1)\n   typestring = 'xdmf_array_type_int16'\ncase(2)\n   typestring = 'xdmf_array_type_int32'\ncase(3)\n   typestring = 'xdmf_array_type_int64'\ncase(4)\n   typestring = 'xdmf_array_type_uint8'\ncase(5)\n   typestring = 'xdmf_array_type_uint16'\ncase(6)\n   typestring = 'xdmf_array_type_uint32'\ncase(7)\n   typestring = 'xdmf_array_type_float32'\ncase(8)\n   typestring = 'xdmf_array_type_float64'\ncase default\n   write(6,'(\"warning: unrecognized data type \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createdatatypestring\n"}, {"instruction": "Create a Fortran subroutine named createtopologytypestring that takes an integer as input and returns a character string of length 256 as output. The subroutine maps the input integer to a corresponding XDMF topology type string and assigns it to the output parameter.", "input": "", "output": "subroutine createtopologytypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(500)\n   typestring = 'xdmf_topology_type_polyvertex'\ncase(501)\n   typestring = 'xdmf_topology_type_polyline'\ncase(502)\n   typestring = 'xdmf_topology_type_polygon'\ncase(503)\n   typestring = 'xdmf_topology_type_triangle'\ncase(504)\n   typestring = 'xdmf_topology_type_quadrilateral'\ncase(507)\n   typestring = 'xdmf_topology_type_wedge'\ncase(509)\n   typestring = 'xdmf_topology_type_edge_3'\ncase(510)\n   typestring = 'xdmf_topology_type_triangle_6'\ncase(511)\n   typestring = 'xdmf_topology_type_quadrilateral_8'\ncase(512)\n   typestring = 'xdmf_topology_type_quadrilateral_9'\ncase(515)\n   typestring = 'xdmf_topology_type_wedge_15'\ncase(516)\n   typestring = 'xdmf_topology_type_wedge_18'\ncase default\n   write(6,'(\"warning: unrecognized topology type \",i0,\".\")') typeholder\nend select\n!----------------------------------------------------------------------\nend subroutine createtopologytypestring\n"}, {"instruction": "Create a Fortran subroutine named dimensions_fft to calculate the dimensions and indices required for a real-to-complex Fast Fourier Transform (FFT). It takes 3 input parameters with integer test data types and produces 11 output parameters, all with integer test data types.", "input": "", "output": "subroutine dimensions_fft(n1,n2,n3,nd1,nd2,nd3,n1f,n3f,n1b,n3b,nd1f,nd3f,nd1b,nd3b)\n   implicit none\n   integer, intent(in)::n1,n2,n3\n   integer,intent(out)::nd1,nd2,nd3,n1f,n3f,n1b,n3b,nd1f,nd3f,nd1b,nd3b\n   ! array sizes for the real-to-complex fft: note that n1(there)=n1(here)+1\n   ! and the same for n2,n3.\n   nd1=n1+2\n   nd2=n2+2\n   nd3=n3+2\n   ! n1b>=n1f;   n3f>=n3b\n   n1f=(n1+2)/2 \n   n3f=(n3+1)/2+1\n\n   n1b=(n1+1)/2+1\n   n3b=(n3+2)/2\n\n   nd1f=n1f+1\n   nd3f=n3f+1\n\n   nd1b=n1b+1\n   nd3b=n3b+1\nend subroutine dimensions_fft\n"}, {"instruction": "Create a Fortran subroutine named logical_to_integer that takes a logical input and converts it to an integer output. The subroutine should have 1 input parameter of type logical and 1 output parameter of type integer.", "input": "", "output": "  subroutine logical_to_integer(integervar,logicalvar)\n    !-----------------------------------------------------------------------\n    logical     :: logicalvar\n    integer     :: integervar\n    !-----------------------------------------------------------------------\n    intent(in)  :: logicalvar\n    intent(out) :: integervar\n    !-----------------------------------------------------------------------\n    \n    if (logicalvar) then\n       integervar = 1\n    else\n       integervar = 0\n    end if\n    \n  end subroutine logical_to_integer\n"}, {"instruction": "Create a Fortran subroutine named integer_to_logical to convert an integer to a logical value. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type logical.", "input": "", "output": "  pure elemental subroutine integer_to_logical(logicalvar,integervar)\n    !-----------------------------------------------------------------------\n    logical     :: logicalvar\n    integer     :: integervar\n    !-----------------------------------------------------------------------\n    intent(in)  :: integervar\n    intent(out) :: logicalvar\n    !-----------------------------------------------------------------------\n    \n    if (integervar .eq. 0) then\n       logicalvar = .false.\n    else\n       logicalvar = .true.\n    end if\n    \n  end subroutine integer_to_logical\n"}, {"instruction": "Create a Fortran subroutine named findnodeinlist to search for a specified vertex number in a list of nodes. The subroutine takes 4 input arguments of integer type and 1 output argument of integer type. The input arguments are nodelist (an array of integers), vertexnr (an integer), counter (an integer), and size (an integer). The output argument is index (an integer). When the subroutine is called, it searches for the vertex number in the nodelist. If found, it returns the index of the node; otherwise, it returns -1.", "input": "", "output": "  subroutine findnodeinlist(index,nodelist,vertexnr,counter,size)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    integer                   :: index,size, vertexnr, counter\n    integer                   :: nodelist(size)\n    ! local variable declaration\n    integer                   :: inode\n    !--------------------------------------------------------------------------\n    intent(in)                :: nodelist,vertexnr,counter,size\n    intent(out)               :: index\n    !--------------------------------------------------------------------------\n    do inode = 1, counter\n       if(nodelist(inode).eq.vertexnr) then\n         ! node found in list, so return index\n         index = inode\n         return\n       endif\n    enddo\n    ! obviously the node has not been found, so return -1\n    index = -1\n  end subroutine findnodeinlist\n"}, {"instruction": "Write a Fortran subroutine named zerospolyo2 to calculate the roots of a second degree polynomial equation. The subroutine takes 1 input parameter of type real array and 1 output parameter of type real array. The input parameter represents the coefficients of the polynomial equation, while the output parameter stores the solutions to the equation.", "input": "", "output": "  subroutine zerospolyo2(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(3)\n    real                      :: solution(2)\n    ! local variable declaration\n    real                      :: a,b,c\n    real                      :: d\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    a = coefficients(1)\n    b = coefficients(2)\n    c = coefficients(3)\n    !\n    d = b**2-4*a*c\n    !\n    if(d.lt.0.) then\n        print *, ' d negative in zerospolyo2. no real roots found! '\n        print *, d\n        stop\n    endif\n    !\n    solution(1) = (-b-sqrt(d))/(2.*a)\n    solution(2) = (-b+sqrt(d))/(2.*a)\n    !\n  end subroutine zerospolyo2\n"}, {"instruction": "Create a Fortran subroutine named zerospolyo3 to calculate the roots of a third-degree polynomial equation. The input parameter is an array of real coefficients, and the output parameter is an array of complex solutions. The input parameters consist of 4 real numbers, and the output parameters consist of 3 complex numbers.", "input": "", "output": "  subroutine zerospolyo3(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(4)\n    complex                   :: solution(3)\n    ! local variable declaration\n    complex                   :: a,b,c,d\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    a = cmplx( coefficients(1), 0. )\n    b = cmplx( coefficients(2), 0. )\n    c = cmplx( coefficients(3), 0. )\n    d = cmplx( coefficients(4), 0. )\n    !\n    solution(1) = 1./a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a      &\n                  -c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/6.     & \n                  -2./3.*(3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)   &\n                  *sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)   &\n                  **(1./3.)-b/a/3.\n\n    solution(2) = -1/a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-     &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/12+    &\n                   (3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4* &\n                   c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.) &\n                   /3.-b/a/3+cmplx(0.,1./2.)*sqrt(3.)*(1/a*(36*c*b*a-108*d*a**2-  &\n                   8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2* &\n                   a**2+4*d*b**3)*a)**(1./3.)/6+2./3.*(3*c*a-b**2)/a/(36*c*b*a-   &\n                   108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-18*c*b*a &\n                   *d+27*d**2*a**2+4*d*b**3)*a)**(1./3.))\n\n    solution(3) = -1/a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-     &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/12.    &\n                   +(3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*       &\n                   sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)** &\n                   (1./3.)/3-b/a/3.+cmplx(0.,-1./2.)*sqrt(3.)*(1/a*(36*c*b*a-     &\n                   108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-         &\n                   18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/6+2./3.*(3*c*a-  &\n                   b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a- &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.))\n  end subroutine zerospolyo3\n"}, {"instruction": "Write a Fortran subroutine named \"zerospolyo4\" to find the real roots of a fourth-order polynomial equation. The subroutine takes an array of five real coefficients as input and outputs an array of four real solutions.", "input": "", "output": "  subroutine zerospolyo4(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(5)\n    real                      :: solution(4)\n    ! local variable declaration\n    real                      :: b,c,d,e\n    complex                   :: a3,b3,c3,d3\n    real                      :: a2,b2,c2,d2\n    real                      :: y,ap,am\n    complex                   :: s, sqrarg\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    ! normalized coefficients of the fourth order polynomial\n    !\n    b = coefficients(2)/coefficients(1)\n    c = coefficients(3)/coefficients(1)\n    d = coefficients(4)/coefficients(1)\n    e = coefficients(5)/coefficients(1)\n    !\n    ! coefficients of the auxilliary third order polynomial\n    !\n    a3 = cmplx(  8.             , 0. )\n    b3 = cmplx( -4.*c           , 0. )\n    c3 = cmplx( 2.*b*d-8*e      , 0. )\n    d3 = cmplx( e*(4*c-b*b)-d*d , 0. )\n    !\n    ! (any) real root of the aux. third order polynomial\n    !\n    s = 1./a3*(36*c3*b3*a3-108*d3*a3**2-8*b3**3+12*sqrt(3.)*sqrt(4*c3**3*a3      &\n        -c3**2*b3**2-18*c3*b3*a3*d3+27*d3**2*a3**2+4*d3*b3**3)*a3)**(1./3.)/6.     & \n        -2./3.*(3*c3*a3-b3**2)/a3/(36*c3*b3*a3-108*d3*a3**2-8*b3**3+12*sqrt(3.)   &\n        *sqrt(4*c3**3*a3-c3**2*b3**2-18*c3*b3*a3*d3+27*d3**2*a3**2+4*d3*b3**3)*a3)   &\n        **(1./3.)-b3/a3/3.\n    !\n    y = real(s)\n    if(abs(aimag(s)).gt.1e-6*abs(y)) then\n        print *, ' real root of aux. poly not real in zerospolyo4! '\n        print *, s\n        stop\n    endif\n    ! aux. variables a+/-\n    ap = sqrt(8.*y+b*b-4*c) \n    am = -ap\n    !\n    ! coefficients of an aux. second order polynomial which yields the final solution \n    !\n    a2 = 1.\n    b2 = 0.5*(b+ap)\n    c2 = y+(b*y-d)/ap\n    !\n    d2 = b2**2-4*a2*c2\n    !\n    if(d2.lt.0.) then\n        print *, ' d2 (using a+) negative in zerospolyo4. no real roots found! '\n        print *, d2\n        stop\n    endif\n    !\n    solution(1) = (-b2-sqrt(d2))/(2.*a2)\n    solution(2) = (-b2+sqrt(d2))/(2.*a2)\n    !\n    a2 = 1.\n    b2 = 0.5*(b+am)\n    c2 = y+(b*y-d)/am\n    !\n    d2 = b2**2-4*a2*c2\n    !\n    if(d2.lt.0.) then\n        print *, ' d2 (using a-) negative in zerospolyo4. no real roots found! '\n        print *, d2\n        stop\n    endif\n    !\n    solution(3) = (-b2-sqrt(d2))/(2.*a2)\n    solution(4) = (-b2+sqrt(d2))/(2.*a2)\n    !\n  end subroutine zerospolyo4\n"}, {"instruction": "Create a Fortran subroutine named matrixinverse2x2 that computes the inverse of a 2x2 matrix. The subroutine takes one input parameter of type real array (2,2) and one output parameter of type real array (2,2). The input parameter represents the original matrix and the output parameter stores the inverse of the matrix. Use the imperative tone in the instruction.", "input": "", "output": "  subroutine matrixinverse2x2(ia,a)\n    !--------------------------------------------------------------------------\n    \n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                        :: ia(2,2)\n    real                        :: a(2,2)\n    ! local variable declaration\n    real                        :: det\n    !--------------------------------------------------------------------------\n    intent(in)                  :: a\n    intent(out)                 :: ia\n    !--------------------------------------------------------------------------\n    !\n    det = a(1,1)*a(2,2)-a(2,1)*a(1,2) \n    \n    ia(1,1) =  a(2,2) / det;        ia(1,2) = -a(1,2) / det;\n    ia(2,1) = -a(2,1) / det;        ia(2,2) =  a(1,1) / det;\n    !\n  end subroutine matrixinverse2x2\n"}, {"instruction": "Create a Fortran subroutine named checkchargesize to read data from a file and perform calculations. The subroutine takes 3 input parameters of types character*100, integer, and integer, and returns 6 output parameters of type integer. The function reads data from a file, performs calculations, and assigns values to the output parameters.", "input": "", "output": "subroutine checkchargesize(file_clmsum,lmmaxx,lmax2,ncom,nrad,lmmax,lmmax1,jri,nat)\n  implicit none\n  character*100, intent(in) :: file_clmsum\n  integer, intent(out):: lmmaxx, lmax2, ncom, nrad\n  integer, intent(out):: lmmax(nat), lmmax1(nat)\n  integer, intent(in) :: jri(nat), nat\n  ! locals\n  real*8, allocatable :: clm(:)\n  integer :: iscf, j, jatom, l, m, lm1\n  \n  open(8, file=file_clmsum, status='old')\n  read(8,2044)  iscf\n  read(8,2043) lmmaxx\n  ncom=0\n  lmax2=0\n  nrad=0\n  do jatom=1,nat\n     nrad=max(nrad,jri(jatom))\n     allocate( clm(jri(jatom) ) )\n     read(8,2000) lmmax(jatom)\n     lmmax1(jatom)=lmmax(jatom)\n     ncom=max(ncom,lmmax1(jatom))\n     do lm1=1,lmmax(jatom)\n        read(8,2010) l,m\n        lmax2=max(lmax2,l)\n        if(m.ne.0) then\n           lmmax1(jatom)=lmmax1(jatom)+1\n           ncom=max(ncom,lmmax1(jatom))\n        endif\n        read(8,2021) ( clm(j), j=1,jri(jatom))\n        read(8,2031)\n     enddo\n     read(8,1980)\n     read(8,2030)\n     deallocate(clm)\n  enddo\n  close(8)\n1980 format(3x)\n2043 format(8x,i4,/)\n2044 format(49x,i3,/)\n2000 format(15x,i3,/,/)\n2010 format(15x,i3,5x,i2,/)\n2021 format(3x,4es19.12)\n2030 format(/,/,/)\n2031 format(/)\n!2071 format(3x,3i5,2es19.12)\nend subroutine checkchargesize\n"}, {"instruction": "Create a Fortran subroutine named read_config_file. The subroutine takes 1 input parameter of type character(*) and 3 output parameters of type integer. When called, the subroutine reads a configuration file specified by the input parameter and assigns the first, last, and k values from the file to the output parameters. If the values do not meet certain conditions, an error message is displayed and the program stops.", "input": "", "output": "   subroutine read_config_file(configfile, first, last, k)\n      character(*), intent(in)  :: configfile\n      integer,      intent(out) :: first, last, k\n\n      integer                   :: in\n\n      open (file=configfile, newunit=in)\n         read(in, *) first, last, k\n      close (in)\n\n      if (.not. (first <= last .and. (k < first .or. k > last))) then\n         write(*,*) 'incorrect settings'\n         stop\n      endif\n   end subroutine read_config_file\n"}, {"instruction": "Write a Fortran subroutine named read_points to read data from a file and store it in a 2D array. The subroutine takes 3 input parameters of types character(len=*), integer, and integer, and 1 output parameter of type real.", "input": "", "output": "    subroutine read_points(fname,rows,cols,points)\n        character(len=*), intent(in) :: fname\n        integer, intent(in) :: rows, cols\n        real, intent(out) :: points(cols,rows)\n        integer :: i,j,unit\n\n        open(newunit=unit,file=fname,status='old')\n\n        do i = 1, rows\n            read(unit,*) (points(j,i),j=1,cols)\n        end do\n\n        close(unit)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named trim_sub_name that extracts the name of a subroutine from a fully qualified subroutine name. The subroutine takes 1 input parameter of type character(len=*) and provides 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine trim_sub_name(sub_name, output)\n    character(len=*), intent(in)  :: sub_name\n    character(len=*), intent(out) :: output\n\n    integer :: ic, slash\n\n    slash = 0 ! if no slash, take whole name\n    do ic = 1, len(sub_name)\n      if(sub_name(ic:ic) == '/') slash = ic\n    enddo\n\n    if(slash >= len(sub_name) - 1) then\n      output = \"\"\n    else\n      output = sub_name(slash + 1:len(sub_name))\n    endif\n\n  end subroutine trim_sub_name\n"}, {"instruction": "Write a Fortran subroutine named inv_m to perform matrix inversion using Gauss-Jordan elimination. The subroutine takes 1 input parameter of type double precision and produces 1 output parameter of type double precision.", "input": "", "output": "recursive subroutine inv_m(a,inv_a)\n!   purpose: inverts a matrix (taken from fortran 90 cooper redwine).\nimplicit none\n\n    integer ::  n\n    double precision, intent(in)  :: a(:,:)\n    double precision, intent(out) :: inv_a(:,:) \n    double precision, allocatable :: temp(:)\n    double precision, allocatable :: c(:,:)\n    integer ::  i, j, m\n    \n    n = size(a,1) \n\tm = size(a,2) \n     \n    if (n/=m) then\n      write(*,*) 'error! matrix is not square. (inv_m)'\n    end if\n\n    allocate(c(n,2*n), temp(2*n))\n\tc(:,1:n) = a      \n\tc(:,n+1:2*n) = 0.0\n    do i=1,n\n      c(i,n+i) = 1.0\n    end do\n\n    ! gauss-jordan elimination\n\n    do j=1,n !loop over first n columns of matrix\n      \n      ! find row index m of element with largest magnitude\n      m = j  ! start on the diagonal\n      do i=j+1,n\n        if (abs(c(i,j)) > abs(c(m,j))) m = i\n      end do\n\n      ! exchange row m with row j\n      temp = c(j,:); c(j,:) = c(m,:); c(m,:) = temp\n\n      c(j,:) = c(j,:)/c(j,j)  ! divide row j by a(j,j)\n\n      do i=1,n  ! loop over each row of matrix\n         ! subtract a(i,j) times row j from row i\n         if (i/=j) c(i,:) = c(i,:)-c(i,j)*c(j,:)\n      end do\n      \n    end do\n    \n    inv_a = c(:,n+1:2*n)\n\t\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named \"rhs\" to compute the right-hand side of a system of differential equations. The subroutine should have 3 input parameters of type double precision, double precision, and logical. The output should consist of 2 arrays of double precision type.", "input": "", "output": "  subroutine rhs(u,par,f,jac,a)\n\n    implicit none\n    double precision, intent(in) :: u(3), par(*)\n    logical, intent(in) :: jac\n    double precision, intent(out) :: f(3), a(3,3)\n\n    double precision x, y, phi\n    double precision nu1, nu2, alpha, beta, omega, c, d, fp, s\n    double precision sphi, x2y2, cphinu, cphinu2\n\n    nu1 = par(1)\n    nu2 = par(2)\n    d = par(3)\n    fp = 4*atan(1.0d0)*d\n    alpha = -1\n    s = -1\n    c = 0\n    omega = 1\n    beta = 0\n\n    x = u(1)\n    y = u(2)\n    phi = u(3)\n\n    sphi = sin(phi)\n    x2y2 = x*x + y*y\n    cphinu = 2*cos(phi)+nu2\n    cphinu2 = cphinu*cphinu\n\n    f(1) = nu1*x - omega*y - (alpha*x - beta*y)*sphi - x2y2*x + d*cphinu2\n    f(2) = nu1*y + omega*x - (alpha*y + beta*x)*sphi - x2y2*y + fp*cphinu2\n    f(3) = nu2 + s*x2y2 + 2.0*cos(phi) + c*x2y2*x2y2\n\n    if(jac)then\n       a(1,1) = nu1 - alpha*sphi - 3*x**2 - y**2\n       a(1,2) = -omega + beta*sphi - 2*x*y\n       a(1,3) = -(alpha*x - beta*y)*cos(phi) - d*4*(2*cos(phi)+nu2)*sphi\n\n       a(2,1) = omega - beta*sphi - 2*x*y\n       a(2,2) = nu1 - alpha*sphi - 3*y**2 - x*x\n       a(2,3) = -(alpha*y + beta*x)*cos(phi) - fp*4*(2*cos(phi) + nu2)*sphi\n\n       a(3,1) = 2*s*x + 4*c*x2y2*x\n       a(3,2) = 2*s*y + 4*c*x2y2*y\n       a(3,3) = -2*sphi\n    endif\n\n  end subroutine rhs\n"}, {"instruction": "Create a Fortran subroutine named datesec that takes a single input parameter of type real(8) and outputs a single parameter of type real(8). The subroutine calculates the number of seconds since January 1, 1978, based on the input date and time values provided.", "input": "", "output": "subroutine datesec(idate, nsec)\n! *#* documentation block - start *#*\n\n!    1 january 1978 (refdate : in days)\n! => coder              : stelios flampouris (stylianos.flampouris@noaa.gov)\n! => abstract/flowchart :\n!\n! [yyyy,mm,dd]-->convert to julian days (jd)-->ndays=jd-refdate-->convert to\n! seconds (ndaysinsec)--> nsec=ndaysinsec+hh*3600+mn*60+ss\n!\n! => history log        :\n! 2016.03.08            : stelios flampouris\n!\n! => input arguments    : idate real array with size 6:\n!                         idate(1)=yyyy   !year\n!                         idate(2)=mm     !month\n!                         idate(3)=dd     !day\n!                         idate(4)=hh     !hour\n!                         idate(5)=mn     !minute\n!                         idate(6)=ss     !second\n!\n! => output arguments   : nsec integer number of seconds\n!\n! => attributes         : machine theia\n!\n! *#* documentation block - end *#*\n!\n   implicit none\n   real(8), intent(in) :: idate(6)\n   real(8), intent(out) :: nsec\n!\n! local parameters\n   real(8), parameter :: refdate = 2443510.\n   real(8) :: jd\n!\n! initializing variables\n   nsec = 0\n   !\n! convert idate(1:3) to jd\n   jd = idate(3) - 32075                                                       &\n                 + 1461 * ( idate(1) + 4800 + (idate(2) - 14) / 12) / 4        &\n                 +  367 * ( idate(2) - 2    - (idate(2) - 14) / 12 * 12) / 12  &\n                 -    3 * ((idate(1) + 4900 + (idate(2) - 14) / 12) / 100) / 4\n!\n! number of days from the reference days\n   jd = jd - refdate\n!\n! number of seconds\n   nsec = (jd* 86400) + (idate(4) * 3600) + (idate(5) * 60) + idate(6)\n!\nend subroutine datesec\n"}, {"instruction": "Create a Fortran subroutine named create_strike_dip_unit_vectors to calculate the strike and dip unit vectors based on a given fault normal vector. The subroutine takes 1 input parameter of type real array and returns 2 output parameters of type real array.", "input": "", "output": "  subroutine create_strike_dip_unit_vectors(n, strike_vector, dip_vector)\n    !> creates strike and dip unit vectors given a fautl normal vector\n    !-------------------------------------------------------------------------!\n    implicit none    \n    ! local variable declaration                                              !\n    real                            :: n(1:3)                                 !< normal vector to fault, pointing away from reference point\n    real                            :: strike_vector(1:3)                     !< strike vector\n    real                            :: dip_vector(1:3)                        !< dip vector\n    real                            :: norm                                   !< norm\n    !-------------------------------------------------------------------------!\n    intent(in)    :: n                                                        !\n    intent(out)   :: strike_vector, dip_vector                                !\n    !-------------------------------------------------------------------------!\n    strike_vector(1) = n(2)/sqrt(n(1)**2+n(2)**2)\n    strike_vector(2) = -n(1)/sqrt(n(1)**2+n(2)**2)\n    strike_vector(3) = 0.0d0\n   \n    dip_vector(1) = -strike_vector(2)*n(3)\n    dip_vector(2) = strike_vector(1)*n(3)\n    dip_vector(3) = strike_vector(2)*n(1) - strike_vector(1)*n(2)\n    norm = 1.0d0/sqrt(dip_vector(1)**2+dip_vector(2)**2+dip_vector(3)**2)\n    dip_vector(1) = dip_vector(1)*norm\n    dip_vector(2) = dip_vector(2)*norm\n    dip_vector(3) = dip_vector(3)*norm\n  end subroutine create_strike_dip_unit_vectors\n"}, {"instruction": "Write a Fortran subroutine named locate_mfmt to locate specific formatting patterns in a file. The subroutine takes 1 input parameter of type integer and returns 3 output parameters: 2 of type integer*2 and 1 of type integer*8, both with a dimension of 1000x2. The input parameter represents a file unit, and the output parameters store information about formatting patterns found in the file.", "input": "", "output": "    subroutine locate_mfmt(u, numsecs, mfmt_list, linerange)\n        implicit none\n        integer, intent(in) :: u\n        integer*2, intent(out) :: numsecs\n        integer*2, dimension(1000,2), intent(out) :: mfmt_list\n        integer*8, dimension(1000,2), intent(out) :: linerange\n\n        character(len=11), dimension(6) :: fields\n\n        integer :: linenr, startlinenr \n        integer*8 :: numrows \n        integer*2 :: az, mf, mt, lastmf, lastmt\n\n        mfmt_list(:,:) = 0\n        linerange(:,:) = 0\n\n        lastmf = 0\n        lastmt = 0\n        numsecs = 0\n        linenr = 0\n        rewind(u)\n        do while (1 == 1)\n            read(u, '(6a11,i4,i2,i3)', end=200) fields, az, mf, mt\n            numrows = numrows + 1\n            linenr = linenr + 1\n            if (lastmt /= mt) then\n                if (lastmt /= 0) then\n                    numsecs = numsecs + int(1,2)\n                    mfmt_list(numsecs,1) = lastmf\n                    mfmt_list(numsecs,2) = lastmt\n                    linerange(numsecs,1) = startlinenr\n                    linerange(numsecs,2) = numrows\n                end if\n\n                if (mt /= 0) then\n                    startlinenr = linenr\n                end if\n                numrows = 0\n            end if\n            lastmf = mf\n            lastmt = mt\n        end do\n        200 continue\n        rewind(u)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"fsub\" to compute the square of each element in the input array \"x\" of length \"n\" and store the results in the output array \"f\". The number of input parameters is 2, where the test_data types are ['integer', 'real(kind=8), dimension(n)']. The number of output parameters is 1, with the test_data type as ['real(kind=8), dimension(n)'].", "input": "", "output": "subroutine fsub(x,n,f)\n  ! compute f(x) = x**2 for all elements of the array x \n  ! of length n.\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), dimension(n), intent(in) :: x\n  real(kind=8), dimension(n), intent(out) :: f\n  f = x**2\nend subroutine fsub\n"}, {"instruction": "Create a Fortran subroutine named get_ang_coeffparams to calculate the total number of angular momentum quantum trips up to a specified maximum angular momentum value. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer. The input parameter represents the maximum angular momentum value (lmax), and the output parameter (tot_l_trips) holds the total number of angular momentum quantum trips.", "input": "", "output": "  subroutine get_ang_coeffparams(lmax,tot_l_trips)\n\n    implicit none\n\n    integer, intent(out) :: tot_l_trips\n    integer, intent(in) :: lmax\n    integer :: l,i,n_elements_l\n\n    !initialising n_elements_l value to nought\n    tot_l_trips = 0\n    n_elements_l = 0\n    do i = 0,lmax\n       n_elements_l = (i+1)*(i+2)/2\n       tot_l_trips = tot_l_trips + n_elements_l\n    enddo\n\n  end subroutine get_ang_coeffparams\n"}, {"instruction": "Create a Fortran subroutine named fix_signs to ensure that the values of m1dum and m2dum are within certain ranges based on the signs of m1 and m2. The subroutine should take 4 input parameters of type integer (l1, l2, m1, m2) and 4 output parameters of type integer (l1dum, l2dum, m1dum, m2dum). The subroutine should be designed to ensure that m1dum is greater than or equal to 0 and m2dum is less than 0, assuming that m1 and m2 initially have different signs.", "input": "", "output": "  subroutine fix_signs(l1,l2,m1,m2,l1dum,l2dum,m1dum,m2dum)\n    !routine to make sure m1dum.ge.0, m2dum.lt.0\n    !assumes that m1 and m2 differ in sign initially\n    integer, intent(in) :: l1,l2,m1,m2\n    integer, intent(out) :: l1dum,l2dum,m1dum,m2dum\n    if(m1.ge.0) then\n       l1dum = l1; l2dum = l2\n       m1dum = m1; m2dum = m2\n    else\n       l1dum = l2; l2dum = l1\n       m1dum = m2; m2dum = m1\n    endif\n       \n  end subroutine fix_signs\n"}, {"instruction": "Create a Fortran subroutine named dpfcalc to calculate pressure fields based on given input data. The subroutine requires 6 input parameters of type real(kind=8), dimension(mkzh,mix,mjy), real(kind=8), dimension(mix,mjy), integer, integer, integer, and 1 output parameter of type real(kind=8), dimension(mkzh,mix,mjy).", "input": "", "output": "subroutine dpfcalc(prs, sfp, pf, mix, mjy, mkzh, ter_follow)\n\n    real(kind=8), dimension(mkzh,mix,mjy), intent(in) :: prs\n    real(kind=8), dimension(mix,mjy), intent(in) :: sfp\n    real(kind=8), dimension(mkzh,mix,mjy), intent(out) :: pf\n    integer, intent(in) :: ter_follow,mix,mjy,mkzh\n\n    integer :: i,j,k\n    \n    !$omp parallel do collapse(3) schedule(runtime)\n    do j = 1,mjy\n        do i = 1,mix\n            do k = 1,mkzh\n                if (k .eq. mkzh) then\n                    ! terrain-following data\n                    if (ter_follow .eq. 1) then\n                        pf(k,i,j) = sfp(i,j)\n                    ! pressure-level data\n                    else\n                        pf(k,i,j) = .5d0 * (3.d0*prs(k,i,j) - prs(k-1,i,j))\n                    end if\n                else\n                    pf(k,i,j) = .5d0 * (prs(k+1,i,j) + prs(k,i,j))\n                end if\n            end do\n        end do\n    end do\n\n    !$omp end parallel do\n\n    return\n\nend subroutine dpfcalc\n"}, {"instruction": "Write a Fortran subroutine named str to convert an integer to a string. The subroutine takes 2 input parameters of type integer and 1 output parameter of type character with length n. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=n)'].", "input": "", "output": "subroutine str(i, s, n)\n    implicit none\n    character(len=n), intent(out) :: s\n    integer, intent(in) :: i,n\n    write (s, *) i\n    s = adjustl(s)\n    s = trim(s)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"convits\" to convert an integer into a string representation of its individual digits. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(len=6)'].", "input": "", "output": "subroutine convits(i, s)\n     implicit none\n     character(len=6), intent(out) ::s\n     integer, intent(in) :: i\n     character(len=1) :: units, tens, hun, taus, ttaus, htaus\n\n     htaus = char(i/100000+48)\n     ttaus = char(mod(i,100000)/10000 +48)\n     taus  = char(mod(i,10000)/1000 +48)\n     \n     hun   = char(mod(i,1000)/100 +48)\n     tens  = char(mod(i,100)/10 + 48)\n     units = char(mod(i,10) +48)\n\n     s = htaus//ttaus//taus//hun//tens//units\n\n     \n\n\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named slope_z to calculate the slope of a 3D array based on the input arrays r and dz, with optional limit and linear parameters. The number of input arguments is 4 and the test_data type is [real, dimension(:,:,:), real, dimension(:,:,:), logical, optional, logical, optional]. The number of output arguments is 1 and the test_data type is [real, dimension(:,:,:)].", "input": "", "output": " subroutine slope_z ( r, dz, slope, limit, linear )\n real, intent(in),  dimension(:,:,:) :: r, dz\n real, intent(out), dimension(:,:,:) :: slope\n logical, intent(in), optional :: limit, linear\n\n!real    :: grad(size(r,1),size(r,2),2:size(r,3))\n real    :: grad(2:size(r,3))\n real    :: rmin, rmax\n integer :: i, j, k, n\n logical :: limiters, dolinear\n\n  limiters = .true.\n  if (present(limit))  limiters = limit\n  dolinear = .true.\n  if (present(linear)) dolinear = linear\n\n  n = size(r,3)\n\n! compute slope (weighted for unequal levels)\n\n  do j = 1, size(r,2)\n  do i = 1, size(r,1)\n\n     do k = 2, n\n       grad(k) = (r(i,j,k)-r(i,j,k-1))/(dz(i,j,k)+dz(i,j,k-1))\n     enddo\n     if (dolinear) then\n         do k = 2, n-1\n           slope(i,j,k) = (grad(k+1)+grad(k))*dz(i,j,k)\n         enddo\n     else\n         do k = 2, n-1\n           slope(i,j,k) = (grad(k+1)*(2.*dz(i,j,k-1)+dz(i,j,k)) + &\n                           grad(k  )*(2.*dz(i,j,k+1)+dz(i,j,k)))  &\n                          *dz(i,j,k)/(dz(i,j,k-1)+dz(i,j,k)+dz(i,j,k+1))\n         enddo\n     endif\n     slope(i,j,1) = 2.*grad(2)*dz(i,j,1)\n     slope(i,j,n) = 2.*grad(n)*dz(i,j,n)\n\n   ! apply limiters to slope\n     if (limiters) then\n        do k = 1, n\n          if (k >= 2 .and. k <= n-1) then\n            rmin = min(r(i,j,k-1), r(i,j,k), r(i,j,k+1))\n            rmax = max(r(i,j,k-1), r(i,j,k), r(i,j,k+1))\n            slope(i,j,k) = sign(1.,slope(i,j,k)) *  &\n                   min( abs(slope(i,j,k)), 2.*(r(i,j,k)-rmin), 2.*(rmax-r(i,j,k)) )\n          else\n         !else if (k == 1) then               ! always slope=0\n         !  rmin = min(r(i,j,k), r(i,j,k+1))\n         !  rmax = max(r(i,j,k), r(i,j,k+1))\n         !else if (k == n) then\n         !  rmin = min(r(i,j,k-1), r(i,j,k))\n         !  rmax = max(r(i,j,k-1), r(i,j,k))\n            slope(i,j,k) = 0.\n          endif\n        enddo\n     endif\n\n  enddo\n  enddo\n\n end subroutine slope_z\n"}, {"instruction": "Write a Fortran subroutine named sub1 that takes an integer as input and returns an integer as output. The input parameter should be specified with the \"intent(in)\" attribute, and the output parameter should be specified with the \"intent(out)\" attribute. The subroutine should set the output parameter to the value 1.", "input": "", "output": "subroutine sub1(x1,x2)\ninteger, intent(in)  :: x1\ninteger, intent(out) :: x2\nx2 = 1\nend subroutine sub1\n"}, {"instruction": "Create a Fortran subroutine named basefun, which takes 3 input parameters of type double precision, integer, and double precision, and 2 output parameters of type double precision and integer. This subroutine is designed to find functions that are positive on a given x in the grid_x.", "input": "", "output": "subroutine basefun(grid_x,npx,x,vals,inds)\n\nimplicit none\n\n! functions that are positive on a given x in the grid_x\n\ndouble precision,intent(in) :: x\ninteger , intent(in):: npx\ndouble precision, intent(in) :: grid_x (npx)\ndouble precision, intent(out) ::vals(2)\ninteger ,intent(out) ::inds(2)\ninteger :: i,ju,jl,jm\n\nif(npx .lt. 2) then\n\n    inds(1)=1\n    inds(2)=1\n    vals(1)=1.0d0\n    vals(2)=0.0d0\n\n\nelse\n    jl=1     !\n    ju=npx   !\n\n    do\n\n        if (ju-jl<=1) exit\n            jm=(ju+jl)/2\n        if (x>=grid_x(jm)) then\n            jl=jm\n        else\n            ju=jm\n        endif\n\n    end do\n\n        i=jl+1\n        vals(2)=( x-grid_x(i-1) )/(grid_x(i)-grid_x(i-1))\n        !vals(1)=( grid_x(i)-x )/(grid_x(i)-grid_x(i-1))\n        vals(2)=max(0.0d0,min(1.0d0,vals(2)))\n        vals(1)=1.0d0-vals(2)\n        inds(2)=i\n        inds(1)=i-1\nendif\nend subroutine basefun\n"}, {"instruction": "Write a Fortran subroutine named f_c that calculates the damping function for dispersive interactions at short range. The subroutine takes one input parameter of type 'double precision' named r and two output parameters of type 'double precision' named long_range and long_range_diff. \n\nInside the subroutine, if the input value of r is greater than a predefined value rc_exp, set the value of long_range to 1.0 and long_range_diff to 0.0. Otherwise, calculate the value of dist_frac using the formula rc_exp/r - 1.0. \n\nThen, calculate the value of long_range by taking the exponential of -(dist_frac)**2 and calculate the value of long_range_diff using the formula 2.0*dist_frac*rc_exp*long_range/(r*r).", "input": "", "output": "         subroutine f_c(r, long_range, long_range_diff)\n            ! calculates the damping function for the dispersive interactions \n            ! at short range. \n            !\n            ! args:\n            !    r: the separation of the atoms.\n            !    long_range: the value of the damping function.\n            !    long_range_diff: the differential of the damping function \n            !       with respect to r.\n\n            double precision, intent(in) :: r\n            double precision, intent(out) :: long_range\n            double precision, intent(out) :: long_range_diff\n\n            double precision dist_frac\n\n            if (r > rc_exp) then\n               long_range = 1.0d0\n               long_range_diff = 0.0d0\n            else\n               dist_frac = rc_exp/r - 1.0d0\n               long_range = dexp(-(dist_frac)**2)\n               long_range_diff = 2.0d0*dist_frac*rc_exp*long_range/(r*r)\n            end if\n\n         end subroutine\n"}, {"instruction": "Write a Fortran subroutine named sg_longrange to calculate the long-range correction to the total potential and virial pressure. The subroutine takes 3 input parameters: rc (cut-off radius), natoms (number of atoms in the system), and volume (volume of the system box), all of type double precision and integer. It also has 2 output parameters: pot_lr (tail correction to the sg interaction potential) and vir_lr (tail correction to the sg virial pressure), both of type double precision.\n\nThe subroutine uses the tail correction formula from Martyna and Hughes (Journal of Chemical Physics, 110, 3275, 1999) with a sharp cut-off and no smoothing function. It assumes rc > rc_exp and neglects the contribution of the repulsive potential and the dispersion damping function in the long-range correction terms.\n\nInside the subroutine, the variables onr3, onr5, onr6, onr7, and prefactor are declared as double precision. The values of onr3, onr5, onr6, and onr7 are computed based on rc. The prefactor is calculated using tau, natoms, and volume.\n\nThe tail correction values for the sg interaction potential and virial pressure are computed using the prefactor and the calculated onr3, onr5, onr6, and onr7. The final values are assigned to pot_lr and vir_lr using the calculated values and constants c_6_int, c_8_int, c_9_int, and c_10_int.\n\nEnd the subroutine after assigning the values to pot_lr and vir_lr.\n\nMake sure to call this subroutine from the main program to calculate the long-range correction.", "input": "", "output": "         subroutine sg_longrange(rc, natoms, volume, pot_lr, vir_lr)\n            ! calculates the long range correction to the total potential and\n            ! virial pressure.\n            !\n            ! uses the tail correction for a sharp cut-off, with no smoothing\n            ! function, as derived in martyna and hughes, journal of chemical\n            ! physics, 110, 3275, (1999).\n            !\n            ! note that we will assume that rc > rc_exp, and that \n            ! exp(alpha - beta*rc - delta*rc**2) << 0, so we can neglect the\n            ! contribution of the repulsive potential and the dispersion \n            ! damping function in the long range correction terms.\n            !\n            ! args:\n            !    rc: the cut-off radius.\n            !    natoms: the number of atoms in the system.\n            !    volume: the volume of the system box.\n            !    pot_lr: the tail correction to the sg interaction potential.\n            !    vir_lr: the tail correction to the sg virial pressure.\n\n            double precision, intent(in) :: rc\n            integer, intent(in) :: natoms\n            double precision, intent(in) :: volume\n            double precision, intent(out) :: pot_lr\n            double precision, intent(out) :: vir_lr\n\n            double precision onr3, onr5, onr6, onr7, prefactor\n\n            onr3 = 1/(rc*rc*rc)\n            onr6 = onr3*onr3\n            onr5 = onr6*rc\n            onr7 = onr6/rc\n            prefactor = tau*natoms*natoms/volume\n\n            pot_lr = prefactor*(-c_6_int*onr3 - c_8_int*onr5 + c_9_int*onr6 - c_10_int*onr7)\n            vir_lr = prefactor*(-c_6*onr3 - c_8*onr5 + c_9*onr6 - c_10*onr7)/3 + pot_lr\n\n         end subroutine\n"}, {"instruction": "Write a Fortran subroutine called recfil1 that performs recursive filtering on an input array. The subroutine takes 4 input parameters: n (integer), nml (integer), x (real*8 array), and h (real*8 array). It also has 1 output parameter: y (real*8 array).\n\nThe purpose of this subroutine is to apply a recursive filter to the input array x and store the filtered values in the output array y. The filter coefficients are provided in the array h. The direction of filtering (forward or backward) is determined by the value of nml.\n\nTo implement the filtering, the subroutine initializes some variables and iterates over the input array x. At each iteration, it applies the recursive filter equation to compute the filtered value and stores it in the corresponding position of the output array y. The iteration direction is controlled by the value of nml.\n\nMake sure to call this subroutine with appropriate input and output arrays to perform recursive filtering on the data.\n\n", "input": "", "output": "subroutine recfil1(x, y, n, h, nml)\n  implicit none\n  integer, intent(in) :: n, nml\n  real*8, intent(in) :: x(n), h(4)\n  real*8, intent(out) :: y(n)\n\n  integer :: j, jd, i\n  real*8 :: a, aa, b, bb, u1, u2, u3, v1, v2, v3\n\n  if(nml .ge. 0) then\n    j = 1\n    jd = 1\n  else\n    j = n\n    jd = -1\n  endif\n\n  a = h(1)\n  aa = h(2)\n  b = h(3)\n  bb = h(4)\n  u1 = 0.0d0\n  u2 = 0.0d0\n  v1 = 0.0d0\n  v2 = 0.0d0\n\n  do i = 1, n\n    u3 = u2\n    u2 = u1\n    u1 = x(j)\n    v3 = v2\n    v2 = v1\n    v1 = u1 + a * u2 + aa * u3 - b * v2 - bb * v3\n    y(j) = v1\n    j = j + jd\n  enddo\n\n  return\nend subroutine recfil1\n"}, {"instruction": "Write a Fortran subroutine named spline that calculates the second derivatives of a set of data points using the spline interpolation method. The subroutine takes 5 input parameters: n (integer), x (real(8) array), y (real(8) array), yp1 (real(8)), and ypn (real(8)). The output parameter is y2 (real(8) array). \n\nThe subroutine begins by allocating memory for arrays a, b, c, and f. It then computes the differences between consecutive x-values and stores them in array a. It calculates the coefficients of the second derivative equations and stores them in arrays b and c. It calculates the right-hand side of the equations and stores them in array f. \n\nNext, it performs the Gaussian elimination method to solve the system of equations for the second derivatives. It updates arrays b and f iteratively using forward substitution. Finally, it calculates the values of the second derivatives and stores them in array y2.\n\nThe subroutine deallocates the memory and completes its execution.\n\nEnsure the test_data type for the input parameters is ['integer', 'real(8) array', 'real(8) array', 'real(8)', 'real(8)'], and for the output parameter is ['real(8) array'].", "input": "", "output": "  subroutine spline( x,y,n,yp1,ypn,y2 )\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: x(n),y(n),yp1,ypn\n    real(8),intent(out) :: y2(n)\n    real(8),allocatable :: a(:),b(:),c(:),f(:)\n    integer :: i\n    allocate( a(n), b(n), c(n), f(n) )\n    a=0.0d0 ; b=0.0d0 ; c=0.0d0 ; f=0.0d0\n    do i=2,n-1\n       a(i) = x(i) - x(i-1)\n    end do\n    do i=2,n-1\n       b(i) = ( x(i+1) - x(i-1) )*2.0d0\n    end do\n    do i=2,n-2\n       c(i) = x(i+1) - x(i)\n    end do\n    do i=2,n-1\n       f(i) = 6.0d0*( (y(i+1)-y(i))/(x(i+1)-x(i)) &\n                    - (y(i)-y(i-1))/(x(i)-x(i-1)) )\n    end do\n    do i=3,n-1\n       b(i) = b(i) - a(i)*c(i-1)/b(i-1)\n       f(i) = f(i) - a(i)*f(i-1)/b(i-1)\n    end do\n    y2(:)=0.0d0\n    y2(n-1) = f(n-1)/b(n-1)\n    do i=n-2,2,-1\n       y2(i) = ( f(i) - c(i)*y2(i+1) )/b(i)\n    end do\n    deallocate( f, c, b, a )\n  end subroutine spline\n"}, {"instruction": "Create a Fortran subroutine named \"rcopy\" that copies the elements of an input real array \"f\" to an output real array \"g\" of the same size. The number of input parameters is 2 with the test_data types ['real', 'integer'], and the number of output parameters is 1 with the test_data type as ['real'].", "input": "", "output": "subroutine rcopy(f, g, n)\nreal, intent(in) :: f(n)\nreal, intent(out) :: g(n)\ninteger, intent(in) :: n\ninteger :: i\n!$omp parallel do schedule(static) private(i)\ndo i = 1, n\n    g(i) = f(i)\nend do\n!$omp end parallel do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named tensor_norm to calculate the norm of a tensor based on the given input arrays and indices. The subroutine takes 5 input parameters of type real, real, integer, integer, and integer, and 1 output parameter of type real.", "input": "", "output": "subroutine tensor_norm(f, w1, w2, i1, i2, di)\nreal, intent(out) :: f(:,:,:)\nreal, intent(in) :: w1(:,:,:,:), w2(:,:,:,:)\ninteger, intent(in) :: i1(3), i2(3), di(3)\ninteger :: n(3), j, k, l\nn = (/size(f,1), size(f,2), size(f,3)/)\nif (any(i1 < 1 .or. i2 > n)) stop 'error in tensor_norm'\n!$omp parallel do schedule(static) private(j, k, l)\ndo l = i1(3), i2(3), di(3)\ndo k = i1(2), i2(2), di(2)\ndo j = i1(1), i2(1), di(1)\n    f(j,k,l) = &\n    ( w1(j,k,l,1) * w1(j,k,l,1) &\n    + w1(j,k,l,2) * w1(j,k,l,2) &\n    + w1(j,k,l,3) * w1(j,k,l,3) ) &\n    + 2.0 * &\n    ( w2(j,k,l,1) * w2(j,k,l,1) &\n    + w2(j,k,l,2) * w2(j,k,l,2) &\n    + w2(j,k,l,3) * w2(j,k,l,3) )\nend do\nend do\nend do\n!$omp end parallel do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named test0 that takes two input arrays, ix and e_x, of type real and integer, respectively, and returns an output array, esss, of type real. The subroutine assigns the elements of ix indexed by e_x to esss.", "input": "", "output": "subroutine test0(esss,ix, e_x)\n  real(kind=kind(1.0d0)), dimension(:), intent(out) :: esss\n  real(kind=kind(1.0d0)), dimension(:), intent(in) :: ix\n  integer(kind=kind(1)), dimension(:), intent(in) :: e_x\n  esss = ix(e_x)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named squares to calculate the square of a real number. The subroutine has 1 input parameter of type real with intent(in), and 1 output parameter of type real with intent(out).", "input": "", "output": "  subroutine squares(x, y)\n    real :: x, y\n    intent(in) :: x\n    intent(out) :: y\n    y = x * x\n  end subroutine squares\n"}, {"instruction": "Create a Fortran subroutine named findklistlength to determine the length of a k-point list in a file. The subroutine takes 1 input parameter of type integer. It has 3 output parameters consisting of 2 integers and 1 character array of length 67.", "input": "", "output": "subroutine findklistlength(itape,numkpt,errmsg,info)\n  implicit none\n  integer,      intent(in)  :: itape\n  integer,      intent(out) :: info, numkpt\n  character*67, intent(out) :: errmsg\n  ! locals\n  character*10 :: kname\n  integer :: kindex, ios, n_k_p\n  errmsg=''\n  if((itape.lt.1).or.(itape.gt.100)) then ! is itape valid unit?\n     info = 8\n     write (errmsg,'(\"invalid k-point file on unit \",i3)') itape\n     return\n  endif\n  !\n  n_k_p = 0\n  kindex = 0\n  do\n     kindex = kindex + 1\n     read (itape,'(a10)',iostat=ios) kname\n     if(ios.ne.0) then  ! something wrong....\n        info = 8\n        write (errmsg,'(\"invalid k-point file on unit \",i3)') itape\n        return\n     endif\n     if (kname .eq. 'end       ') then  ! reached the end\n        info = 0\n        numkpt = kindex - 1\n        rewind(itape)\n        return\n     endif\n     ! modification to for the k.p method: do not calculate lapw1 for those kpoints with kname=' kp '; these states will instead be calculated in lapwkp \n     if(kname(1:4).eq.' kp ') then\n        kindex=kindex-1  ! these points will instead be calculated in lapwkp\n        n_k_p = n_k_p+1\n     endif\n  end do\nend subroutine findklistlength\n"}, {"instruction": "Create a Fortran subroutine named readklist to read and process k-point data from a file. The subroutine takes 2 input parameters of type integer. It also has 8 output parameters consisting of character*10, real*8, real*8, real*8, real*8, character*3, character*67, and integer data types.", "input": "", "output": "subroutine readklist(itape,numkpt,kname,k3,weight,ipgr,e1,e2,errmsg,info)\n  implicit none\n  integer,      intent(in)  :: itape, numkpt\n  character*10, intent(out) :: kname(numkpt)\n  real*8,       intent(out) :: weight(numkpt), k3(3,numkpt) !sx(numkpt), sy(numkpt), sz(numkpt)\n  real*8,       intent(out) :: e1, e2\n  character*3,  intent(out) :: ipgr(numkpt)\n  character*67, intent(out) :: errmsg\n  integer,      intent(out) :: info\n  ! locals\n  integer :: kindex, ios, isx, isy, isz, idv\n  real*8  :: e1_, e2_\n  logical :: newform\n  !\n  weight(:)=0.0d0\n  k3(:,:)=0.d0\n  \n  if (numkpt.le.0) then\n     info = 8\n     write (errmsg,'(\"empty k-point file on unit \",i3)') itape\n     return\n  endif\n  \n  kindex = 1\n  read (itape,5101,iostat=ios) kname(kindex), isx, isy, isz, idv, weight(kindex), e1, e2, ipgr(kindex)\n  \n  if(ios==0) then   ! this is the new form of case.klist\n     newform=.true.\n  else              ! must be the old form of case.klist, which had smaller #digits\n     rewind(itape)\n     read (itape,5100,iostat=ios) kname(kindex), isx, isy, isz, idv,weight(kindex), e1, e2, ipgr(kindex)\n     if (ios.ne.0) then ! it is not even the old format. something wrong....\n        info = 8\n        write (errmsg,'(\"invalid k-point file (2) on unit \",i3)') itape\n        return\n     endif\n     newform=.false.\n  endif\n  if (kname(kindex) .eq. 'end       ') then  ! empty k-point file\n     info = 8\n     write (errmsg,'(\"empty k-point file on unit \",i3)') itape\n     return\n  endif\n\n  k3(1,kindex) = dble(isx)/dble(idv)\n  k3(2,kindex) = dble(isy)/dble(idv)\n  k3(3,kindex) = dble(isz)/dble(idv)\n  if(kname(kindex)(1:4).eq.' kp ') kindex=kindex-1  ! modification to for the k.p method\n  \n  do \n     kindex = kindex + 1\n     if(kindex.gt.numkpt) then\n        info=0\n        return\n     end if\n     !        read in k-point to be calculated and energy range\n     if(newform) then\n        read (itape,5101) kname(kindex), isx, isy, isz, idv,weight(kindex), e1_, e2_, ipgr(kindex)\n     else\n        read (itape,5100) kname(kindex), isx, isy, isz, idv,weight(kindex), e1_, e2_, ipgr(kindex)\n     endif\n     if (kname(kindex) .eq. 'end       ') then\n        info = 8\n        write (errmsg,'(\"reached the end of the k-point file on second reading \",i3)') itape\n        return\n     endif\n     k3(1,kindex) = dble(isx)/dble(idv)\n     k3(2,kindex) = dble(isy)/dble(idv)\n     k3(3,kindex) = dble(isz)/dble(idv)\n     if(kname(kindex)(1:4).eq.' kp ') kindex=kindex-1  ! modification to for the k.p method\n  end do\n  return\n5101 format(a10,4i10,3f5.2,a3)\n5100 format(a10,4i5,3f5.2,a3)\nend subroutine readklist\n"}, {"instruction": "Create a Fortran subroutine named \"lowcase\" to transform the uppercase letters in the input string \"str1\" into lowercase letters and store the result in the output string \"str2\". The number of input parameters is 1, with a test_data type of ['character (len=*)'], and the number of output parameters is 1, with a test_data type of ['character (len=*)'].", "input": "", "output": "  subroutine lowcase (str1, str2)\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    ! transform upper case letters in str1 into lower case letters, result is str2\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    implicit none\n    character (len=*),  intent(in) :: str1\n    character (len=*), intent(out) :: str2\n    integer                        :: j,k\n    character (len=*),   parameter :: lc = 'abcdefghijklmnopqrstuvwxyz'\n    character (len=*),   parameter :: uc = 'abcdefghijklmnopqrstuvwxyz'\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    str2 = str1\n    do j=1,len_trim(str1)\n       k = index(uc,str1(j:j))\n       if (k > 0) str2(j:j) = lc(k:k)\n    end do\n  end subroutine lowcase\n"}, {"instruction": "Write a Fortran subroutine named test2 with the purpose of adding two arrays and storing the result in another array. The subroutine takes 2 input arrays of real numbers, b and c, and 1 output array a. The number of input parameters is 2 with the test_data type ['real', 'real'], and the number of output parameters is 1 with the test_data type ['real']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine test2(a,b,c)\n  real, intent(out) :: a(:)\n  real, intent(in) :: b(:), c(:)\n a = b + c\nend subroutine test2\n"}, {"instruction": "Create a Fortran subroutine named quadtrafoxieta2xy to perform a coordinate transformation from local coordinates (xi, eta) to global coordinates (x, y) for a 4-node quadrilateral. The subroutine takes 4 input parameters of type real, representing the local coordinates (xi, eta) and the vertex coordinates (x, y). It also has 2 output parameters of type real, representing the transformed global coordinates (xp, yp).", "input": "", "output": "  subroutine quadtrafoxieta2xy(xp,yp,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xp, yp                              ! output: xp, yp       !\n    real        :: xi, eta                             ! input:  xi eta       !\n    real        :: x(4), y(4)                          ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i                                   ! loop index           ! \n    real        :: xiu, etau                           ! modified xi eta zeta !\n    real        :: l01xi, l01eta                       ! lagrangian polynomial!\n    real        :: l11xi, l11eta                       ! lagrangian polynomial!\n    real        :: sf(4)                               ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: xp,yp\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 4-node quadrilateral (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    !\n    ! compute shape functions of 4-node quadrilateral\n    !\n    sf(1) = l01xi * l01eta \n    sf(2) = l11xi * l01eta \n    sf(3) = l11xi * l11eta \n    sf(4) = l01xi * l11eta \n    !\n    ! coordinate transformation from xiu, etau to x, y\n    !\n    xp = 0.\n    yp = 0.\n    !\n    do i = 1,4\n        xp = xp + sf(i) * x(i)\n        yp = yp + sf(i) * y(i)\n    enddo\n    !\n  end subroutine quadtrafoxieta2xy\n"}, {"instruction": "Create a Fortran subroutine named tetratrafoxietazeta2xyz to calculate the coordinates of a point within a tetrahedron based on the barycentric coordinates xi, eta, and zeta. The subroutine takes 6 input parameters of type real (xp, yp, zp, xi, eta, zeta) and 3 output parameters of type real (x, y, z).", "input": "", "output": "  subroutine tetratrafoxietazeta2xyz(xp,yp,zp,xi,eta,zeta,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xp, yp, zp                          ! input:  xp, yp, zp   !\n    real        :: xi, eta, zeta                       ! output: xi eta zeta  !\n    real        :: x(4), y(4), z(4)                    ! vertex coordinates   !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z,xi,eta,zeta\n    intent(out) :: xp,yp,zp\n    !-------------------------------------------------------------------------!\n    !\n    xp = x(1) + (x(2)-x(1))*xi + (x(3)-x(1))*eta + (x(4)-x(1))*zeta\n    yp = y(1) + (y(2)-y(1))*xi + (y(3)-y(1))*eta + (y(4)-y(1))*zeta\n    zp = z(1) + (z(2)-z(1))*xi + (z(3)-z(1))*eta + (z(4)-z(1))*zeta \n    !\n  end subroutine tetratrafoxietazeta2xyz\n"}, {"instruction": "Create a Fortran subroutine named \"hexatrafoxietazetagrad\" to compute the gradient of a coordinate transformation from xi, eta, zeta to x, y, z for an 8-node hexahedron. The subroutine takes 6 input parameters of type real and 1 output parameter of type real.", "input": "", "output": "  subroutine hexatrafoxietazetagrad(grad,xi,eta,zeta,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(3,3)                           ! output:  grad        !\n    real        :: xi, eta, zeta                       ! input: xi eta zeta   !\n    real        :: x(8), y(8), z(8)                    ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i,j                                 ! loop index           ! \n    real        :: l01xi, l01eta, l01zeta              ! lagrangian polynomial!\n    real        :: l11xi, l11eta, l11zeta              ! lagrangian polynomial!\n    real        :: sf(8,0:3)                           ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z,xi,eta,zeta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 8-node hexahedron (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    l01zeta = 1-zeta\n    l11zeta =   zeta\n    !\n    ! compute the shape functions of an 8-node hexahedron\n    !\n    sf(1,0) = l01xi * l01eta * l01zeta\n    sf(2,0) = l11xi * l01eta * l01zeta\n    sf(3,0) = l01xi * l11eta * l01zeta\n    sf(4,0) = l11xi * l11eta * l01zeta\n    sf(5,0) = l01xi * l01eta * l11zeta\n    sf(6,0) = l11xi * l01eta * l11zeta\n    sf(7,0) = l01xi * l11eta * l11zeta\n    sf(8,0) = l11xi * l11eta * l11zeta\n    !\n    ! compute the xi-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,1) = (-1) * l01eta * l01zeta\n    sf(2,1) =        l01eta * l01zeta\n    sf(3,1) = (-1) * l11eta * l01zeta\n    sf(4,1) =        l11eta * l01zeta\n    sf(5,1) = (-1) * l01eta * l11zeta\n    sf(6,1) =        l01eta * l11zeta\n    sf(7,1) = (-1) * l11eta * l11zeta\n    sf(8,1) =        l11eta * l11zeta\n    !\n    ! compute the eta-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,2) = l01xi * (-1) * l01zeta\n    sf(2,2) = l11xi * (-1) * l01zeta\n    sf(3,2) = l01xi        * l01zeta\n    sf(4,2) = l11xi        * l01zeta\n    sf(5,2) = l01xi * (-1) * l11zeta\n    sf(6,2) = l11xi * (-1) * l11zeta\n    sf(7,2) = l01xi        * l11zeta\n    sf(8,2) = l11xi        * l11zeta\n    !\n    ! compute the zeta-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,3) = l01xi * l01eta * (-1)\n    sf(2,3) = l11xi * l01eta * (-1)\n    sf(3,3) = l01xi * l11eta * (-1)\n    sf(4,3) = l11xi * l11eta * (-1)\n    sf(5,3) = l01xi * l01eta  \n    sf(6,3) = l11xi * l01eta  \n    sf(7,3) = l01xi * l11eta  \n    sf(8,3) = l11xi * l11eta  \n    !\n    ! gradient of the coordinate transformation from xi, eta, zeta to x, y, z\n    !\n    grad(:,:) = 0.\n    !\n    do j = 1, 3\n     do i = 1,8\n        grad(1,j) = grad(1,j) + sf(i,j) * x(i)\n        grad(2,j) = grad(2,j) + sf(i,j) * y(i)\n        grad(3,j) = grad(3,j) + sf(i,j) * z(i)\n     enddo\n    enddo\n    !\n  end subroutine hexatrafoxietazetagrad\n"}, {"instruction": "Write a Fortran subroutine named tetratrafoxietazetagrad to calculate the gradient matrix of a tetrahedron defined by its vertex coordinates. The subroutine takes 3 input parameters of type real arrays x, y, and z for the vertex coordinates and provides an output parameter grad of type real 3x3 matrix representing the gradient matrix.", "input": "", "output": "  subroutine tetratrafoxietazetagrad(grad,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(3,3)                           ! output:  grad        !\n    real        :: x(4), y(4), z(4)                    ! vertex coordinates   !\n    ! local variable declaration\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    grad(1,1) = x(2)-x(1); grad(1,2) = x(3)-x(1); grad(1,3) = x(4)-x(1)\n    grad(2,1) = y(2)-y(1); grad(2,2) = y(3)-y(1); grad(2,3) = y(4)-y(1)\n    grad(3,1) = z(2)-z(1); grad(3,2) = z(3)-z(1); grad(3,3) = z(4)-z(1)\n    !\n  end subroutine tetratrafoxietazetagrad\n"}, {"instruction": "Provide a Fortran subroutine named quadtrafoxietagrad to calculate the gradient of a coordinate transformation from xi, eta to x, y. The subroutine takes 4 input parameters of type real and outputs 1 parameter of type real.", "input": "", "output": "  subroutine quadtrafoxietagrad(grad,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(2,2)                           ! output:  grad        !\n    real        :: xi, eta                             ! input: xi eta        !\n    real        :: x(4), y(4)                          ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i,j                                 ! loop index           ! \n    real        :: l01xi, l01eta                       ! lagrangian polynomial!\n    real        :: l11xi, l11eta                       ! lagrangian polynomial!\n    real        :: sf(4,0:2)                           ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 4-node square (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    !\n    ! compute the shape functions of an 4-node square\n    !\n    sf(1,0) = l01xi * l01eta\n    sf(2,0) = l11xi * l01eta\n    sf(3,0) = l11xi * l11eta\n    sf(4,0) = l01xi * l11eta\n    !\n    ! compute the xi-derivative of the shape functions of an 4-node square\n    !\n    sf(1,1) = (-1) * l01eta\n    sf(2,1) =        l01eta\n    sf(3,1) =        l11eta\n    sf(4,1) = (-1) * l11eta\n    !\n    ! compute the eta-derivative of the shape functions of an 4-node square\n    !\n    sf(1,2) = l01xi * (-1)\n    sf(2,2) = l11xi * (-1)\n    sf(3,2) = l11xi\n    sf(4,2) = l01xi\n    !\n    ! gradient of the coordinate transformation from xi, eta  to x, y \n    !\n    !         dx/dxi\n    ! | dx/dxi     dx/deta |\n    ! | dy/dxi     dy/deta |\n    !\n    grad(:,:) = 0.\n    !\n    do j = 1, 2\n     do i = 1,4\n        grad(1,j) = grad(1,j) + sf(i,j) * x(i)\n        grad(2,j) = grad(2,j) + sf(i,j) * y(i)\n     enddo\n    enddo\n    !\n  end subroutine quadtrafoxietagrad\n"}, {"instruction": "Write a Fortran subroutine named tritrafoxietagrad to calculate the gradient of a mapping from the parent element to the physical element. There are 4 input parameters of type real and 1 output parameter of type real. The input parameters are xi, eta, x(3), y(3), and the output parameter is grad(2,2).", "input": "", "output": "  subroutine tritrafoxietagrad(grad,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(2,2)                           ! output:  grad        !\n    real        :: xi, eta                             ! input: xi eta        !\n    real        :: x(3), y(3)                          ! vertex coordinates   !\n    ! local variable declaration\n     !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    !         dx/dxi\n    ! | dx/dxi     dx/deta |\n    ! | dy/dxi     dy/deta |\n    grad(1,1) = x(2)     - x(1)\n    grad(1,2) = x(3)     - x(1)\n    grad(2,1) = y(2)     - y(1)\n    grad(2,2) = y(3)     - y(1)\n\n  end subroutine tritrafoxietagrad\n"}, {"instruction": "Create a Fortran subroutine named tritrafochi2xieta to transform the chi value to xi and eta coordinates based on the given element orientation. The subroutine takes 3 input arguments of types real, real, and integer, and returns 2 output arguments of types real and real.", "input": "", "output": "  subroutine tritrafochi2xieta(xi,eta,chi,iside,ineighborside)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xi, eta                             ! output: xi eta       !\n    real        :: chi                                 ! input:  chi          !\n    integer     :: iside, ineighborside                ! element orientation  !\n    ! local variable declaration\n    real        :: chi1                                ! intermediate results !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: chi, iside, ineighborside\n    intent(out) :: xi,eta\n    !-------------------------------------------------------------------------!\n    !\n    select case(ineighborside)\n    ! inside the element itself\n    case(0) \n        select case(iside)\n        case(1)\n          xi   = chi\n          eta  = 0.\n        case(2)\n          xi   = 1.-chi\n          eta  = chi \n        case(3)\n          xi   = 0. \n          eta  = 1.-chi\n        end select\n        !\n        return\n    ! inside the neighbor\n    case(1)\n      chi1 = 1.-chi\n      xi   = chi1\n      eta  = 0.\n    case(2)\n      chi1 = 1.-chi\n      xi   = 1.-chi1\n      eta  = chi1 \n    case(3)\n      chi1 = 1.-chi\n      xi   = 0. \n      eta  = 1.-chi1\n    end select\n    !\n    return\n    !\n  end subroutine tritrafochi2xieta\n"}, {"instruction": "Create a Fortran subroutine named spacetimebasis to calculate the space and time degrees of freedom for a tensor-product approach based on the given space-time degree of freedom and the total number of degrees of freedom. The subroutine should have 2 input parameters of type integer and 2 output parameters of type integer. The input parameters are idegfrst and ndegfr, and the output parameters are idegfr_xi and idegfr_tau.", "input": "", "output": "  subroutine spacetimebasis(idegfr_xi,idegfr_tau,idegfrst,ndegfr)\n    !-------------------------------------------------------------------------!\n    \n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    integer         :: idegfr_xi,idegfr_tau,idegfrst,ndegfr\n    !-------------------------------------------------------------------------!\n    intent(in)      :: idegfrst,ndegfr\n    intent(out) :: idegfr_xi,idegfr_tau\n    !-------------------------------------------------------------------------!\n    ! input is the number of the space-time degree of freedom\n    ! output is the pair of numbers of the space and the time degrees of freedom\n    ! for the tensor-product approach\n    idegfr_tau = ceiling(real(idegfrst)/real(ndegfr))\n    idegfr_xi  = idegfrst - (ndegfr)*(idegfr_tau-1) \n  end subroutine spacetimebasis\n"}, {"instruction": "Define a Fortran subroutine named angle_vector_vector_2d to calculate the angle between two 2D vectors. The subroutine takes 2 input parameters of type real array for the vectors v1 and v2, and 1 output parameter of type real for the angle theta.", "input": "", "output": "  subroutine angle_vector_vector_2d(theta,v1,v2)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: theta                               ! output:  angle       !\n    real        :: v1(2), v2(2)                        ! input :  vectors     !\n    ! local variable declaration\n    real        :: v1_aux(2), v2_aux(2)                ! auxiliary vectors    !\n    real        :: v1_mod, v2_mod                      ! module of vectors    !\n    real        :: theta1, theta2                      ! angles to the x axe  !\n    real        :: cos_theta1, cos_theta2              ! cos(theta)           !\n    real, parameter :: pi=3.141592653589793            ! constant pi\n    !-------------------------------------------------------------------------!\n    intent(in)  :: v1,v2\n    intent(out) :: theta\n    !-------------------------------------------------------------------------!\n    !\n    ! normalize the vectors\n    v1_mod = sqrt(v1(1)**2+v1(2)**2);\n    v1_aux = v1 / v1_mod;\n    v2_mod = sqrt(v2(1)**2+v2(2)**2);\n    v2_aux = v2 / v2_mod;\n        \n    cos_theta1 = (v1(1));   ! cos(theta) of vector 1 respect to [1,0]\n    cos_theta2 = (v2(1));   ! cos(theta) of vector 2 respect to [1,0]\n    \n    theta1 = acos(cos_theta1);\n    theta2 = acos(cos_theta2);\n    \n    ! if the rotation is higher than (pi rad) 2*pi-theta\n    if (v1(2)<0) theta1 = 2*pi-theta1;\n    if (v2(2)<0) theta2 = 2*pi-theta2;\n    \n    theta = theta2-theta1;\n\n  end subroutine angle_vector_vector_2d\n"}, {"instruction": "Create a Fortran subroutine named mirror_p_atline to calculate the mirror point of a given point about a given line. The subroutine takes 3 input parameters of type real arrays and produces 1 output parameter of type real array.", "input": "", "output": "  subroutine mirror_p_atline(p_new,p_old,a,b)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: p_new(2)                                  ! output:  vector      !\n    real        :: p_old(2), a(2), b(2)                ! input :  vectors     !\n    ! local variable declaration\n    real        :: t,d(2)                              ! auxiliary vectors    !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: p_old, a, b\n    intent(out) :: p_new\n    !-------------------------------------------------------------------------!\n    !\n    ! mirror point at line               \n    \n    t    = ((p_old(1) - a(1)) * b(1) + (p_old(2) - a(2)) * b(2)) / (b(1)**2+b(2)**2)\n    d(1) = p_old(1) - a(1) - t*b(1)\n    d(2) = p_old(2) - a(2) - t*b(2)\n\n    p_new(1) = p_old(1) - 2*d(1)\n    p_new(2) = p_old(2) - 2*d(2)\n\n  end subroutine mirror_p_atline\n"}, {"instruction": "Create a Fortran subroutine named c_eval_ijkl to calculate a single real value based on the input integer values ishell, jshell, kshell, lshell, and ntint. The input parameters are of type integer(kind=c_int64_t) and the output parameter is a real value of kind=c_double.", "input": "", "output": "        subroutine c_eval_ijkl(ishell, jshell, kshell, lshell, tint, ntint) bind(c)\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int64_t), intent(in)::ishell\n            integer(kind=c_int64_t), intent(in)::jshell\n            integer(kind=c_int64_t), intent(in)::kshell\n            integer(kind=c_int64_t), intent(in)::lshell\n            real(kind=c_double), intent(out)::tint(1)\n            integer(kind=c_int64_t), intent(in)::ntint\n        end subroutine c_eval_ijkl\n"}, {"instruction": "Write a Fortran subroutine named c_get_overlap that takes an integer input parameter of kind c_int64_t and an array output parameter of real type with kind c_double. This subroutine is intended to be used in a C program, as indicated by the \"bind(c)\" attribute.", "input": "", "output": "        subroutine c_get_overlap(nbas, aooverlap) bind(c)\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int64_t), intent(in)::nbas\n            real(kind=c_double), intent(out)::aooverlap(1,1)\n        end subroutine c_get_overlap\n"}, {"instruction": "Create a Fortran subroutine named getspherepart to calculate the spherical partitions based on the provided inputs. The subroutine takes 2 input parameters of type integer, and 1 output parameter of type real*8.", "input": "", "output": "subroutine getspherepart(myid,numprocs,arange)\n!\ninteger, intent(in) :: myid\ninteger, intent(in) :: numprocs\nreal*8, intent(out) :: arange(4)\n!\ninteger :: i,nc,j,k\nreal*8 :: ap,thetap,delta,ai,a,thpolar\nreal*8, allocatable :: y(:)\ninteger, allocatable :: m(:)\nreal*8 :: pi\n!\n! begin\n!\npi=acos(-1.)\nap=4*pi/numprocs\n!\nthetap=asin(1-2.0/numprocs)\nthpolar=pi*0.5-thetap\n!\nnc=nint((pi-2*thpolar)/sqrt(ap))\ndelta=(pi-2*thpolar)/nc\n!\nallocate(y(nc),m(nc))\n!\ndo i=1,nc\n   ai=2*pi*(sin(thetap-(i-1)*delta)-sin(thetap-i*delta))\n   y(i)=ai/ap\nenddo\n!\na=0\ndo i=1,nc\n   m(i)=nint(y(i)+a)\n   a=a+(y(i)-m(i))\nenddo\n!\nk=1\nif (myid==k) then\n  arange(1)=thetap\n  arange(2)=pi*0.5\n  arange(3)=0.\n  arange(4)=2*pi\nendif\n!\ndo i=1,nc\n   do j=1,m(i)\n     k=k+1\n     if (myid==k) then\n        arange(1)=thetap-i*delta\n\tarange(2)=arange(1)+delta\n        arange(3)=(j-1)*2*pi/m(i)\n        arange(4)=arange(3)+2*pi/m(i)\n\treturn\n     endif\n   enddo\nenddo\n!\nk=numprocs\nif (myid==k) then\n  arange(1)=-pi*0.5\n  arange(2)=-thetap\n  arange(3)=0.\n  arange(4)=2*pi\nendif\n!\n!\nreturn\nend subroutine getspherepart\n"}, {"instruction": "Create a Fortran subroutine named \"stiff3\" to calculate the analytical stiffness matrix of a 3-node triangle in plane strain. The subroutine should take 3 input parameters of type real(iwp) and provide 1 output parameter of type real(iwp).", "input": "", "output": "subroutine stiff3(km,coord,ym,pr)\n implicit none\n!\n!      analytical stiffness matrix of a 3-node triangle in plane strain\n!\n integer,parameter::iwp=selected_real_kind(15)\n integer::i,j\n real(iwp),intent(in)::coord(3,2),ym,pr\n real(iwp),intent(out)::km(6,6)\n real(iwp)::x1,y1,x2,y2,x3,y3,cf\n real(iwp)::d1=1._iwp,d2=2._iwp,d3=3._iwp,d4=4._iwp,d5=5._iwp,d6=6._iwp\n x1=coord(1,1)\n y1=coord(1,2)\n x2=coord(2,1)\n y2=coord(2,2)\n x3=coord(3,1)\n y3=coord(3,2)\ncf=ym/(d1+pr)/(-d1+d2*pr)/(-x1*y2+x1*y3-x2*y3+y1*x2-y1*x3+y2*x3)/d4\n!-----------------------------------------------------------------------\n km(1,1)=(-d2*y2**2+d4*y2*y3-d2*y3**2+d2*pr*y2**2-d4*pr*y2*y3+            &\n   d2*pr*y3**2-x2**2+d2*x2**2*pr+d2*x2*x3-d4*x2*x3*pr-x3**2+d2*x3**2*pr)*cf\n km(1,2)=(x2-x3)*(y2-y3)*cf\n km(1,3)=-(d2*y2*y3-d2*y2*y1-d2*y3**2+d2*y3*y1-d2*pr*y2*y3+d2*pr*y2*y1+   &\n   d2*pr*y3**2-d2*pr*y3*y1-x2*x1+d2*x2*x1*pr+x2*x3-d2*x2*x3*pr+x3*x1-     &\n   d2*x3*x1*pr-x3**2+d2*x3**2*pr)*cf\n km(1,4)=-(d2*pr*x1*y2-d2*pr*x1*y3-d2*pr*y2*x3-x2*y3+d2*x2*y3*pr+y1*x2-   &\n   d2*y1*x2*pr+y3*x3-y1*x3+d2*y1*x3*pr)*cf\n km(1,5)=-(d2*y2*y1-d2*y2**2-d2*y3*y1+d2*y2*y3-d2*pr*y2*y1+d2*pr*y2**2+   &\n   d2*pr*y3*y1-d2*pr*y2*y3+x2*x1-d2*x2*x1*pr-x2**2+d2*x2**2*pr-x3*x1+     &\n   d2*x3*x1*pr+x2*x3-d2*x2*x3*pr)*cf\n km(1,6)=(d2*pr*x1*y2-d2*pr*x1*y3+d2*x2*y3*pr+y1*x2-d2*y1*x2*pr-y2*x2-    &\n   y1*x3+d2*y1*x3*pr+y2*x3-d2*pr*y2*x3)*cf\n!-----------------------------------------------------------------------\n km(2,2)=(-d2*x2**2+d4*x2*x3-d2*x3**2+d2*x2**2*pr-d4*x2*x3*pr+d2*x3**2*pr-&\n   y2**2+d2*pr*y2**2+d2*y2*y3-d4*pr*y2*y3-y3**2+d2*pr*y3**2)*cf\n km(2,3)=(d2*x2*y3*pr-d2*y1*x2*pr+d2*y1*x3*pr-x1*y2+d2*pr*x1*y2+y2*x3-    &\n   d2*pr*y2*x3+x1*y3-d2*pr*x1*y3-y3*x3)*cf\n km(2,4)=-(-d2*x2*x1+d2*x2*x3+d2*x3*x1-d2*x3**2+d2*x2*x1*pr-d2*x2*x3*pr-  &\n   d2*x3*x1*pr+d2*x3**2*pr+y2*y3-d2*pr*y2*y3-y2*y1+d2*pr*y2*y1-y3**2+     &\n   d2*pr*y3**2+y3*y1-d2*pr*y3*y1)*cf\n km(2,5)=(d2*y1*x2*pr-d2*y1*x3*pr+d2*pr*y2*x3+x1*y2-d2*pr*x1*y2-y2*x2-    &\n   x1*y3+d2*pr*x1*y3+x2*y3-d2*x2*y3*pr)*cf\n km(2,6)=(-d2*x2*x1+d2*x2**2+d2*x3*x1-d2*x2*x3+d2*x2*x1*pr-d2*x2**2*pr-   &\n   d2*x3*x1*pr+d2*x2*x3*pr-y2*y1+d2*pr*y2*y1+y2**2-d2*pr*y2**2+y3*y1-     &\n   d2*pr*y3*y1-y2*y3+d2*pr*y2*y3)*cf\n!-----------------------------------------------------------------------\n km(3,3)=(-d2*y3**2+d4*y3*y1-d2*y1**2+d2*pr*y3**2-d4*pr*y3*y1+d2*pr*y1**2-&\n   x1**2+d2*x1**2*pr+d2*x3*x1-d4*x3*x1*pr-x3**2+d2*x3**2*pr)*cf\n km(3,4)=(x1-x3)*(-y3+y1)*cf\n km(3,5)=-(d2*y3*y1-d2*y2*y3-d2*y1**2+d2*y2*y1-d2*pr*y3*y1+d2*pr*y2*y3+   &\n   d2*pr*y1**2-d2*pr*y2*y1-x1**2+d2*x1**2*pr+x2*x1-d2*x2*x1*pr+x3*x1-     &\n   d2*x3*x1*pr-x2*x3+d2*x2*x3*pr)*cf\n km(3,6)=-(-d2*pr*x1*y3+d2*x2*y3*pr-d2*y1*x2*pr+y1*x1-x1*y2+d2*pr*x1*y2-  &\n   y1*x3+d2*y1*x3*pr+y2*x3-d2*pr*y2*x3)*cf\n!-----------------------------------------------------------------------\n km(4,4)=(-d2*x1**2+d4*x3*x1-d2*x3**2+d2*x1**2*pr-d4*x3*x1*pr+d2*x3**2*pr-&\n   y3**2+d2*pr*y3**2+d2*y3*y1-d4*pr*y3*y1-y1**2+d2*pr*y1**2)*cf\n km(4,5)=(d2*pr*x1*y2+d2*y1*x3*pr-d2*pr*y2*x3+x1*y3-d2*pr*x1*y3-x2*y3+    &\n   d2*x2*y3*pr-y1*x1+y1*x2-d2*y1*x2*pr)*cf\n km(4,6)=-(-d2*x1**2+d2*x2*x1+d2*x3*x1-d2*x2*x3+d2*x1**2*pr-d2*x2*x1*pr-  &\n   d2*x3*x1*pr+d2*x2*x3*pr+y3*y1-d2*pr*y3*y1-y2*y3+d2*pr*y2*y3-y1**2+     &\n   d2*pr*y1**2+y2*y1-d2*pr*y2*y1)*cf\n!-----------------------------------------------------------------------\n km(5,5)=(-d2*y1**2+d4*y2*y1-d2*y2**2+d2*pr*y1**2-d4*pr*y2*y1+d2*pr*y2**2-&\n   x1**2+d2*x1**2*pr+d2*x2*x1-d4*x2*x1*pr-x2**2+d2*x2**2*pr)*cf\n km(5,6)=(x1-x2)*(y1-y2)*cf\n!-----------------------------------------------------------------------\n km(6,6)=(-d2*x1**2+d4*x2*x1-d2*x2**2+d2*x1**2*pr-d4*x2*x1*pr+d2*x2**2*pr-&\n   y1**2+d2*pr*y1**2+d2*y2*y1-d4*pr*y2*y1-y2**2+d2*pr*y2**2)*cf\n!-----------------------------lower triangle----------------------------\n km(2,1)=km(1,2)\n km(3,1)=km(1,3)\n km(3,2)=km(2,3)\n km(4,1)=km(1,4)\n km(4,2)=km(2,4)\n km(4,3)=km(3,4)\n km(5,1)=km(1,5)\n km(5,2)=km(2,5)\n km(5,3)=km(3,5)\n km(5,4)=km(4,5)\n km(6,1)=km(1,6)\n km(6,2)=km(2,6)\n km(6,3)=km(3,6)\n km(6,4)=km(4,6)\n km(6,5)=km(5,6)\nreturn\nend subroutine stiff3\n"}, {"instruction": "Create a Fortran subroutine named \"fmplat\" to calculate the second derivatives of a plate bending element. The subroutine takes 4 input parameters of type real(iwp), real(iwp), real(iwp), and integer, and returns 3 output parameters of type real(iwp), real(iwp), and real(iwp).", "input": "", "output": "subroutine fmplat(d2x,d2y,d2xy,points,aa,bb,i)\r\n!\r\n\n! plate bending elements.\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::points(:,:),aa,bb\r\n real(iwp),intent(out)::d2x(:),d2y(:),d2xy(:)\r\n integer,intent(in)::i\r\n real(iwp)::x,e,xp1,xp12,xp13,ep1,ep12,ep13,p1,q1,p2,q2,p3,q3,p4,q4,dp1,  &\r\n   dq1,dp2,dq2,dp3,dq3,dp4,dq4,d2p1,d2p2,d2p3,d2p4,d2q1,d2q2,d2q3,d2q4,   &\r\n   pt25=0.25_iwp,pt375=0.375_iwp,pt5=0.5_iwp,pt75=0.75_iwp,one=1.0_iwp,   &\r\n   opt5=1.5_iwp,d3=3.0_iwp\r\n x=points(i,1)\r\n e=points(i,2)\r\n xp1=x+one\r\n xp12=xp1*xp1\r\n xp13=xp12*xp1\r\n ep1=e+one\r\n ep12=ep1*ep1\r\n ep13=ep12*ep1\r\n p1=one-pt75*xp12+pt25*xp13\r\n q1=one-pt75*ep12+pt25*ep13\r\n p2=pt5*aa*xp1*(one-xp1+pt25*xp12)\r\n q2=pt5*bb*ep1*(one-ep1+pt25*ep12)\r\n p3=pt25*xp12*(d3-xp1)\r\n q3=pt25*ep12*(d3-ep1)\r\n p4=pt25*aa*xp12*(pt5*xp1-one)\r\n q4=pt25*bb*ep12*(pt5*ep1-one)\r\n dp1=opt5*xp1*(pt5*xp1-one)\r\n dq1=opt5*ep1*(pt5*ep1-one)\r\n dp2=aa*(pt5-xp1+pt375*xp12)\r\n dq2=bb*(pt5-ep1+pt375*ep12)\r\n dp3=opt5*xp1*(one-pt5*xp1)\r\n dq3=opt5*ep1*(one-pt5*ep1)\r\n dp4=pt5*aa*xp1*(pt75*xp1-one)\r\n dq4=pt5*bb*ep1*(pt75*ep1-one)\r\n d2p1=opt5*x\r\n d2p2=pt25*aa*(d3*x-one)\r\n d2p3=-d2p1\r\n d2p4=pt25*aa*(d3*x+one)\r\n d2q1=opt5*e\r\n d2q2=pt25*bb*(d3*e-one)\r\n d2q3=-d2q1\r\n d2q4=pt25*bb*(d3*e+one)\r\n d2x(1)=d2p1*q1\r\n d2x(2)=d2p2*q1\r\n d2x(3)=d2p1*q2\r\n d2x(4)=d2p2*q2\r\n d2x(5)=d2p1*q3\r\n d2x(6)=d2p2*q3\r\n d2x(7)=d2p1*q4\r\n d2x(8)=d2p2*q4\r\n d2x(9)=d2p3*q3\r\n d2x(10)=d2p4*q3\r\n d2x(11)=d2p3*q4\r\n d2x(12)=d2p4*q4\r\n d2x(13)=d2p3*q1\r\n d2x(14)=d2p4*q1\r\n d2x(15)=d2p3*q2\r\n d2x(16)=d2p4*q2\r\n d2y(1)=p1*d2q1\r\n d2y(2)=p2*d2q1\r\n d2y(3)=p1*d2q2\r\n d2y(4)=p2*d2q2\r\n d2y(5)=p1*d2q3\r\n d2y(6)=p2*d2q3\r\n d2y(7)=p1*d2q4\r\n d2y(8)=p2*d2q4\r\n d2y(9)=p3*d2q3\r\n d2y(10)=p4*d2q3\r\n d2y(11)=p3*d2q4\r\n d2y(12)=p4*d2q4\r\n d2y(13)=p3*d2q1\r\n d2y(14)=p4*d2q1\r\n d2y(15)=p3*d2q2\r\n d2y(16)=p4*d2q2\r\n d2xy(1)=dp1*dq1\r\n d2xy(2)=dp2*dq1\r\n d2xy(3)=dp1*dq2\r\n d2xy(4)=dp2*dq2\r\n d2xy(5)=dp1*dq3\r\n d2xy(6)=dp2*dq3\r\n d2xy(7)=dp1*dq4\r\n d2xy(8)=dp2*dq4\r\n d2xy(9)=dp3*dq3\r\n d2xy(10)=dp4*dq3\r\n d2xy(11)=dp3*dq4\r\n d2xy(12)=dp4*dq4\r\n d2xy(13)=dp3*dq1\r\n d2xy(14)=dp4*dq1\r\n d2xy(15)=dp3*dq2\r\n d2xy(16)=dp4*dq2\r\nreturn\r\nend subroutine fmplat\r\n"}, {"instruction": "Write a Fortran subroutine named simps that implements the Simpson's rule for numerical integration. The subroutine takes 2 input parameters of type real(8) and 1 output parameter of type real(8). The input parameters represent the grid spacing and the function values at equidistant points, while the output parameter represents the value of the integral.", "input": "", "output": "subroutine simps(dx, func,val)\n    implicit none\n    !!simps works on functions defined at equidistant values of x only\n\n    real(8), intent(in) :: dx      !the grid spacing\n    real(8), intent(in) :: func(:) !the function\n    real(8), intent(out):: val     !the value of the integral\n\n    integer :: n !length of func\n    integer :: i,end\n    real(8) :: endbit\n\n    n = size(func)\n\n    if (mod(n,2)==0) then\n        end =  n-1\n        endbit = (func(n)+func(n-1))*dx/2\n    else\n        end=n\n        endbit=0.d0\n    end if\n\n    val = sum(func(1:end-2:2) + func(3:end:2) + 4*func(2:end-1:2))\n    val = val*dx/3 + endbit\nend subroutine simps\n"}, {"instruction": "Write a Fortran subroutine named trapz to calculate the integral of a function with equidistant values of x. The subroutine takes 2 input arguments of type real(8) for grid spacing (dx) and the function values (func). It also has 1 output argument of type real(8) for the integral value (val). Ensure that the length of the func array is defined as n, and the subroutine uses the trapezoidal rule to compute the integral.", "input": "", "output": "subroutine trapz(dx,func,val)\n    implicit none\n    !!trapz works on functions defined at equidistant values of x only\n\n    real(8), intent(in) :: dx !the grid spacing\n    real(8), intent(in) :: func(:) !the function\n    real(8), intent(out) :: val !the value of the integral\n\n    integer :: n !length of func\n    integer :: i\n\n    val = func(1)+func(n)\n    do i=2,n-1\n        val = val + 2*func(i)\n    end do\n    val = val*dx/2\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named locpt to determine the position of a point relative to a polygonal path and calculate the winding number. The number of input arguments is 5 with the test_data type [real, real, real, real, integer]. The number of output arguments is 2 with the test_data type [integer, integer].", "input": "", "output": "subroutine locpt (x0, y0, x, y, n, l, m)\r\n!-----------------------------------------------------------------------\r\n! given a polygonal line connecting the vertices (x(i),y(i)) (i = 1,...,n)\r\n! taken in this order.  it is assumed that the polygonal path is a loop,\r\n! where (x(n),y(n)) = (x(1),y(1)) or there is an arc from (x(n),y(n)) to\r\n! (x(1),y(1)).  n.b. the polygon may cross itself any number of times.\r\n\r\n! (x0,y0) is an arbitrary point and l and m are variables.\r\n! on output, l and m are assigned the following values ...\r\n\r\n!    l = -1   if (x0,y0) is outside the polygonal path\r\n!    l =  0   if (x0,y0) lies on the polygonal path\r\n!    l =  1   if (x0,y0) is inside the polygonal path\r\n\r\n! m = 0 if (x0,y0) is on or outside the path.  if (x0,y0) is inside the\r\n! path then m is the winding number of the path around the point (x0,y0).\r\n\r\n! fortran 66 version by a.h. morris\r\n! converted to elf90 compatibility by alan miller, 15 february 1997\r\n\r\n!-----------------------\r\n\r\nimplicit none\r\nreal, intent(in)     :: x0, y0, x(:), y(:)\r\ninteger, intent(in)  :: n\r\ninteger, intent(out) :: l, m\r\n\r\n!     local variables\r\ninteger :: i, n0\r\nreal    :: angle, eps, pi, pi2, sum, theta, theta1, thetai, tol, u, v\r\n\r\n!     ****** eps is a machine dependent constant. eps is the\r\n!            smallest number such that 1.0 + eps > 1.0\r\n\r\neps = epsilon(1.0)\r\n\r\n!-----------------------------------------------------------------------\r\nn0 = n\r\nif (x(1) == x(n) .and. y(1) == y(n)) n0 = n - 1\r\npi = atan2(0.0, -1.0)\r\npi2 = 2.0*pi\r\ntol = 4.0*eps*pi\r\nl = -1\r\nm = 0\r\n\r\nu = x(1) - x0\r\nv = y(1) - y0\r\nif (u == 0.0 .and. v == 0.0) go to 20\r\nif (n0 < 2) return\r\ntheta1 = atan2(v, u)\r\n\r\nsum = 0.0\r\ntheta = theta1\r\ndo i = 2, n0\r\n  u = x(i) - x0\r\n  v = y(i) - y0\r\n  if (u == 0.0 .and. v == 0.0) go to 20\r\n  thetai = atan2(v, u)\r\n  \r\n  angle = abs(thetai - theta)\r\n  if (abs(angle - pi) < tol) go to 20\r\n  if (angle > pi) angle = angle - pi2\r\n  if (theta > thetai) angle = -angle\r\n  sum = sum + angle\r\n  theta = thetai\r\nend do\r\n\r\nangle = abs(theta1 - theta)\r\nif (abs(angle - pi) < tol) go to 20\r\nif (angle > pi) angle = angle - pi2\r\nif (theta > theta1) angle = -angle\r\nsum = sum + angle\r\n\r\n!     sum = 2*pi*m where m is the winding number\r\n\r\nm = abs(sum)/pi2 + 0.2\r\nif (m == 0) return\r\nl = 1\r\nif (sum < 0.0) m = -m\r\nreturn\r\n\r\n!     (x0, y0) is on the boundary of the path\r\n\r\n20 l = 0\r\nreturn\r\nend subroutine locpt\r\n"}, {"instruction": "Create a Fortran subroutine named get_cartesian_shell to calculate and return all the functions on the \"l\" cartesian shell. The subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer arrays with unspecified dimensions.", "input": "", "output": "subroutine get_cartesian_shell(l, lpower, mpower, npower)\n! returns all the functions on the \"l\" cartesian shell.\n! the cartesian shell is defined as (x^l, y^m, z^n) where the powers (l, m, n)\n! are given by all combinations of l,m,n <= l so that l+m+n=l. there\n! is exactly (l+1)(l+2)/2 such combinations.\n\n! uses the following ordering:\n! l = 0\n! lpower == [0]\n! mpower == [0]\n! npower == [0]\n! l = 1\n! lpower == [1, 0, 0]\n! mpower == [0, 1, 0]\n! npower == [0, 0, 1]\n! l = 2\n! lpower == [2, 1, 1, 0, 0, 0]\n! mpower == [0, 1, 0, 2, 1, 0]\n! npower == [0, 0, 1, 0, 1, 2]\n! l = 3\n! lpower == [3, 2, 2, 1, 1, 1, 0, 0, 0, 0]\n! mpower == [0, 1, 0, 2, 1, 0, 3, 2, 1, 0]\n! npower == [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]\n! ...\n\ninteger, intent(in) :: l  ! the gaussian orbital number\ninteger, intent(out), dimension(:) :: lpower, mpower, npower\n! the (l, m, n) powers. the arrays must have dimension (l+1)(l+2)/2\ninteger :: i, k, n\ni = 1\ndo k = 0, l\n    do n = 0, k\n        lpower(i) = l - k\n        mpower(i) = k - n\n        npower(i) = n\n        i = i + 1\n    end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two input arrays of real*8 type, vec1 and vec2, along with an integer n specifying the number of elements in the arrays. The subroutine outputs the sum of the arrays in vecout, also of real*8 type.", "input": "", "output": "subroutine add(vec1, vec2, vecout, n)\n  integer, intent(in) :: n\n  real*8, intent(in) :: vec1(n), vec2(n)\n  real*8, intent(out) :: vecout(n)\n  vecout = vec1+vec2\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named funcs_to_am to convert the number of functions to an integer representation. The number of input parameters is 1 of type integer(kind=8), and the number of output parameters is 1 of type integer(kind=8). If the input nfuncs is 1, the output am_i is 0; if nfuncs is 3, am_i is 1; if nfuncs is 5 or 6, am_i is 2; if nfuncs is 7 or 10, am_i is 3; otherwise, an error message is displayed.", "input": "", "output": "  subroutine funcs_to_am(nfuncs, am_i)\n    implicit none\n\n    integer(kind=8), intent(in) :: nfuncs\n    integer(kind=8), intent(out) :: am_i\n\n    if (nfuncs == 1) then\n       am_i = 0\n    else if (nfuncs == 3) then\n       am_i = 1\n    else if (nfuncs == 6 .or. nfuncs == 5) then\n       am_i = 2\n    else if (nfuncs == 10 .or. nfuncs == 7) then\n       am_i = 3\n    else\n       write(*,*) \"error in funcs to am conversion!\"\n       flush(6)\n       stop\n    end if\n\n  end subroutine funcs_to_am\n"}, {"instruction": "Create a Fortran subroutine named para_range that calculates the range of a parameter for parallel processing. The subroutine takes 4 input parameters of type integer (n1, n2, np, irank) and returns 2 output parameters of type integer (ista, iend).", "input": "", "output": " subroutine para_range(n1,n2,np,irank,ista,iend)\n      integer,intent(in) :: n1,n2,np,irank\n      integer,intent(out) :: ista,iend\t  \n      integer iwork1,iwork2\n\t  \n      iwork1 = (n2-n1+1)/np\n      iwork2 = mod(n2-n1+1,np)\n      ista=irank*iwork1+n1+min(irank,iwork2)\n      iend=ista+iwork1-1\n      if(iwork2.gt.irank) then\n        iend=iend+1\n      endif\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dist that calculates the distance matrix between sites based on their coordinates. The subroutine takes 3 input parameters: an integer n, and two arrays of real numbers with dimensions n by 3. It returns a single output parameter, an array of real numbers with dimensions n by n.", "input": "", "output": "subroutine dist(coord1,coord2,n,dist_matrix)\n\n! obtains the distance matrix between sites in pymatgen structure, used to \n! obtain a neighbour list for sites (and is faster than using the\n! python version in pymatgen)\n! args:\n!     coord1 ([[real,real,real],...]): array of site coords\n!     coord2 ([[real,real,real],...]): array of site coords\n!     n (int): number of elements in coord arrays\n! return:\n!     dist_matrix([n x n array of reals]): dist matrix for sites \n\nuse omp_lib\n\nimplicit none\n\ninteger, intent(in) :: n\n\nreal,dimension(n,3),intent(in) :: coord1,coord2\nreal,dimension(n,n),intent(out) :: dist_matrix\ninteger:: i,j\n\n!$omp parallel do private(i,j) shared(coord1,coord2,dist_matrix)\ndo i=1,n\n  do j=1,n\n     dist_matrix(i,j) = ((coord1(i,1)-coord2(j,1))* (coord1(i,1)-coord2(j,1))+&\n                        (coord1(i,2)-coord2(j,2))* (coord1(i,2)-coord2(j,2))+&\n                        (coord1(i,3)-coord2(j,3))* (coord1(i,3)-coord2(j,3)))**0.5\n  end do\nend do\n!$omp end parallel do\n\nend subroutine dist\n"}, {"instruction": "Write a Fortran subroutine named shift_index to shift the index of a site in the unit cell to the corresponding index in the 3x3x3 halo supercell. The subroutine takes 2 input parameters of type integer and integer array of dimension 3, and returns 1 output parameter of type integer.", "input": "", "output": "subroutine shift_index(index_n,shift,new_index)\n\n! shifts the index of a site in the unit cell to the corresponding\n! index in the 3x3x3 halo supercell.\n! used when getting neighbour list for supercell from unit cell neighbour list\n! \n! args:\n!    index_n (int): original index\n!    shift ([int,int,int]): shift to image for which to obatin index eg. [-1,-1,-1]\n!    \n! returns:\n!    new_index (int): index for image site in supercell\n\nimplicit none\n\ninteger, intent(in) :: index_n\ninteger, dimension(3), intent(in):: shift\ninteger, intent(out) :: new_index\n\ninteger::new_x,new_y,new_z\n\nnew_x = modulo((modulo(int(index_n/9),3)+shift(1)),3)\nnew_y = modulo((modulo(int(index_n/3),3)+shift(2)),3)\nnew_z = modulo((modulo(index_n,3)+shift(3)),3)\n\nnew_index = int(27*int(index_n/(27))+(modulo(new_x,3)*9+modulo(new_y,3)*3+modulo(new_z,3)))\nend subroutine shift_index\n"}, {"instruction": "Create a Fortran subroutine named gauss_jacobi to compute the Gauss-Jacobi quadrature nodes and weights for a given interval. The subroutine takes 2 input parameters of type real and provides 2 output parameters of type real. The subroutine uses an iterative method to compute the nodes and weights, ensuring convergence within a specified iteration limit.", "input": "", "output": "  subroutine gauss_jacobi(a,b,xes,weights) \n    use, intrinsic :: iso_fortran_env, only : error_unit\n    real,intent(in) :: a,b \n    real,intent(out):: xes(:),weights(size(xes))\n    integer,parameter :: dk=kind(1.d0)\n    integer :: it,i1,i2,m\n    real :: ab,a_b\n    real(dk) :: o1,o2,o3,q,d,y,yd,f\n    real(dk), parameter :: one=1.d0,two=2.d0,half=0.5d0,quart=0.25d0\n    real(dk), parameter :: pi=3.1415926535897932384626433832795028841971694d0\n    integer , parameter :: nt=20\n    character(len=38), parameter ::message='gauss-jacobi: iteration limit exeeded '\n    m=size(xes);ab=a+b;a_b=a-b;f=fexp();yd=two;it=1\n    do i1=1,m \n       y=cos((half*a + i1 - quart)/(half*(one + a + b) + m)*pi)\n       do it=1,nt\n          d = two + a+b \n          o1 = (a_b + d*y)*half; o2 = one\n          do i2=2,m \n             o3 = o2;o2=o1;d=a+b+2*i2 \n             o1 = (-o3*(two*(a + i2 - 1)*(b + i2 - 1)*d) + o2*((d - one) & \n                  & *(a*a - b*b + d*(d - two)*y)))/(2*i2*(i2 + a+b)*(d - two))\n          enddo\n          q = (m*(a - b - d*y)*o1 + two*(m + a)*(m + b)*o2)/ & \n               & (d*(one - y*y)); yd = y; y = yd - o1/q \n          if(converged())exit\n       enddo\n       xes(i1) = y ; weights(i1) = f*d*2.**(a+b)/(q*o2)                               \n       if(it>nt)write(error_unit,*)message\n    enddo\n    return\n  contains\n    logical function converged()\n      converged = (abs(y - yd)<epsilon(y)*one)\n    end function converged\n    real(dk) function fexp()\n      fexp = exp(log_gamma(a + m) + log_gamma(b + m) & \n           &   - log_gamma(m + one) - log_gamma(m + a + b + one))\n    end function fexp \n  end subroutine gauss_jacobi\n"}, {"instruction": "Write a Fortran subroutine named occupr to calculate the charge density based on a set of input variables. The subroutine takes 6 input parameters of types real*8, complex*16, real*8, real*8, integer, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine occupr(charge, mu, ek, omega, l, nbands, nomega)\n  implicit none\n  real*8, intent(out)    :: charge\n  real*8, intent(in)     :: mu\n  complex*16, intent(in) :: ek(nbands,nomega)\n  real*8, intent(in)     :: omega(nomega)\n  real*8, intent(in)     :: l\n  integer, intent(in)    :: nbands, nomega\n  !f2py integer intent(hide), depend(omega)  :: nomega=shape(omega,0)\n  !f2py integer intent(hide), depend(ek)     :: nbands=shape(ek,0)\n  ! local\n  real*8  :: wdens(nbands), w1, w2, pi\n  integer :: ip, iom\n  pi = acos(-1.0)\n  !print *, 'nbands=', nbands\n  !print *, 'nom=', nomega\n  !print *, 'pi=', pi\n  wdens=0\n  ! for the lowest frequency, integral from -infinity to (om_1+om2_2)/2\n  w1 = l\n  w2 = 0.5*(omega(2)+omega(1))\n  do ip=1,nbands\n     wdens(ip) = aimag(log(w2+mu-ek(ip,1))-log(w1+mu-ek(ip,1)))\n  enddo\n  ! the rest of the frequencies\n  do iom=2,nomega-1\n     w1 = 0.5*(omega(iom)+omega(iom-1))\n     w2 = 0.5*(omega(iom+1)+omega(iom))\n     if (omega(iom+1) .gt. 0.0) w2 = 0.0\n     do ip=1,nbands\n        wdens(ip) = wdens(ip) + aimag(log(w2+mu-ek(ip,iom))-log(w1+mu-ek(ip,iom)))\n     enddo\n     if (omega(iom+1) .gt. 0.0) exit\n  enddo\n  charge = sum(wdens)*(-1/pi)\n  return \nend subroutine occupr\n"}, {"instruction": "Create a Fortran subroutine named \"thetakr\" to calculate the (k,r) angle in radians. The subroutine should have 4 input parameters of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8), dimension(:).", "input": "", "output": "subroutine thetakr(k,v,y,vap,thkr)\n\t!-----------------------------------------------------\n\t! (k,r) angle computation\n\t! calling sequence: call thetakr(k,v,vap,thkr)\n\t! inputs:     k: wave vector in cartesian coordinates.\n\t!             v: position vector in cartesian coordinates at step n.\n\t!             y: magnetic vector\n\t!           vap: position vector in cartesian coordinates at step n+1\n\t! outputs: thkr: (k,r) angle in radian  \n\t!-----------------------------------------------------\n\treal(kind=8), dimension(:,:),intent(in) :: k,v,vap,y\n\treal(kind=8), dimension(:),intent(out)  :: thkr\n\treal(kind=8), dimension(3,size(thkr))\t:: d\n\treal(kind=8),dimension(size(thkr))      :: normv,normk,normy\n\t\n\td=vap-v\n\tnormv=sqrt(d(1,:)**2+d(2,:)**2+d(3,:)**2)\n\tnormk=sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\tnormy=sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\n\twhere ((normv .ne. 0) .and. (normy /= 0.d0))\n\t\tthkr=acos((k(1,:)*d(1,:)+k(2,:)*d(2,:)+k(3,:)*d(3,:))/(normv*normk)) \n\telsewhere\n\t\tthkr=0.d0\n\tend where\n\t\nend subroutine thetakr\n"}, {"instruction": "Create a Fortran subroutine named vphase to compute the phase velocity by taking the reciprocal of the input indices.The number of input arguments is 1 and the test_data type is [real(kind=8), dimension(:)].The number of output arguments is 1 and the test_data type is [real(kind=8), dimension(:)].", "input": "", "output": "subroutine vphase(mu,vp)\n\t!-----------------------------------------------------\n\t! phase velocity calculation\n\t!      vp = c/mu \n\t! calling sequence: call vphase(mu,vp)\n\t! inputs:     mu: indice\n\t! outputs:    vp: phase velocity\n\t!-----------------------------------------------------\n\treal(kind=8), dimension(:), intent(in) \t:: mu\n\treal(kind=8), dimension(:), intent(out) :: vp\n\t\n\tvp = 1.d0/mu\n\nend subroutine vphase\n"}, {"instruction": "Create a Fortran subroutine named fplasma to calculate the plasma frequency using the formula fp = f*sqrt(x). The subroutine takes 2 input parameters of type real(kind=8) and real(kind=8), dimension(:), and 1 output parameter of type real(kind=8), dimension(:). The calling sequence is: call fplasma(f, x, fp), where f is the wave frequency, x is (fp/f)^2, and fp is the plasma frequency.", "input": "", "output": "subroutine fplasma(f,x,fp)\n\t!-----------------------------------------------------\n\t! plasma frequency computation fp = f*sqrt(x)\n\t!\n\t! calling sequence: call fplasma(f,x,fp)\n\t! inputs:     f: wave frequency\n\t!             x: (fp/f)^2\n\t! outputs:   fp: plasma  frequency\n\t!-----------------------------------------------------\n\treal(kind=8), intent(in)  \t\t\t\t:: f\n\treal(kind=8), dimension(:), intent(in)  :: x\n\treal(kind=8), dimension(:), intent(out) :: fp\n\t\n\tfp(:) = f*sqrt(x(:))\n\nend subroutine fplasma\n"}, {"instruction": "Create a Fortran subroutine named fcyclo to compute the cyclotron frequency using the formula fc = f*norm(y). The subroutine takes 2 input parameters of type real(kind=8) and real(kind=8), dimension(:,:), and returns 1 output parameter of type real(kind=8), dimension(:).", "input": "", "output": "subroutine fcyclo(f,y,fc)\n\t!-----------------------------------------------------\n\t! cyclotron frequency calculation fc = f*norm(y)\n\t!\n\t! calling sequence: call fcyclo(f,x,fp)\n\t! inputs:     f: wave frequency\n\t!             y: fc/f\n\t! outputs:   fc: cyclotron frequency\n\t!-----------------------------------------------------\n\treal(kind=8), intent(in)  \t\t\t\t:: f\n\treal(kind=8), dimension(:,:), intent(in):: y\n\treal(kind=8), dimension(:), intent(out) :: fc\n\t\n\tfc(:) = f*sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\t\nend subroutine fcyclo\n"}, {"instruction": "Create a Fortran subroutine named weight_avg to compute the weighted average abundance estimate. The subroutine should have 3 input parameters of types integer(kind = 4), real(kind = 8), and real(kind = 8), and 2 output parameters of types real(kind = 8) and real(kind = 8). The subroutine should follow the guidelines for assessing marine mammal stocks and calculate the weighted average by considering the precision of each estimate.", "input": "", "output": "  subroutine weight_avg(n_yrs, n_hat, cv_n, n_avg, cv_avg)\n! ----------------------------------------------------------------------------------------\n! calculate a weighted average abundance estimate. \n! average is weighted by the precision (inverse of the variance) of each estimate.\n! methods follow nmfs (2005) pp. 12-13 \n!  nmfs. 2005. revisions to guidelines for assessing marine mammal stocks. 24 pp.\n!   available at: http://www.nmfs.noaa.gov/pr/pdfs/sars/gamms2005.pdf  \n! ----------------------------------------------------------------------------------------\n    integer(kind = 4), intent(in) :: n_yrs         ! number of years to average over\n    real(kind = 8), intent(in) :: n_hat(1:n_yrs)   ! vector of abundance (point) estimates\n    real(kind = 8), intent(in) :: cv_n(1:n_yrs)    ! vector of corresponding cvs\n    real(kind = 8) :: var_n(1:n_yrs)               ! variances of abundance estimates\n    real(kind = 8) :: weights_tmp(1:n_yrs)         ! inverse of the variances\n    real(kind = 8) :: weights(1:n_yrs)             ! relative precision\n    real(kind = 8) :: weights_sq(1:n_yrs)          ! square of the weights\n    real(kind = 8) :: weight_tot                   ! sum of weights\n    real(kind = 8) :: n_weighted(1:n_yrs)          ! weighted abundance estimates\n    real(kind = 8) :: weighted_var(1:n_yrs)\n    real(kind = 8) :: var_avg\n    real(kind = 8), intent(out) :: n_avg           ! weighted average abundance estimate\n    real(kind = 8), intent(out) :: cv_avg          ! cv of weighted average abundance estimate    \n    \n    var_n = cv_n * n_hat   ! sd of abundance estimates \n    var_n = var_n * var_n  ! variance of abundance estimates\n  \n    weights_tmp = 1.d0 / var_n    ! calculate precision of each abundance estimate (note, vector operation)\n    weight_tot = sum(weights_tmp) ! \n    weights = weights_tmp / weight_tot ! calculate vector of weights\n    \n    n_weighted = weights * n_hat\n    n_avg = sum(n_weighted)\n    \n    weights_sq = weights * weights\n    weighted_var = weights_sq * var_n\n    var_avg = sum(weighted_var)\n    cv_avg = sqrt(var_avg) / n_avg \n    \n    return\n  end subroutine weight_avg\n"}, {"instruction": "Create a Fortran subroutine named avg_n to calculate a weighted average abundance estimate. The subroutine takes 2 input parameters of type real(kind = 8) and outputs 2 parameters of type real(kind = 8).", "input": "", "output": "  subroutine avg_n(n_hat, cv_n, n_avg, cv_avg)\n! ----------------------------------------------------------------------------------------\n! calculate a weighted average abundance estimate. \n! average is weighted by precision (inverse of the variance) of each estimate.\n! methods follow nmfs (2005) pp. 12-13: \n!  nmfs. 2005. revisions to guidelines for assessing marine mammal stocks. \n!  available at: http://www.nmfs.noaa.gov/pr/pdfs/sars/gamms2005.pdf  \n! ----------------------------------------------------------------------------------------  \n    real(kind = 8), allocatable :: var_n(:)\n    real(kind = 8), allocatable :: n_weighted(:)\n    real(kind = 8) :: var_avg    \n    real(kind = 8), intent(out) :: n_avg, cv_avg\n    real(kind = 8) :: weights_tmp, weight_tot, weights, weights_sq, weighted_var\n    real(kind = 8), intent(in) :: n_hat(:), cv_n(:)\n    real(kind = 8), allocatable :: n_hat_tmp(:), cv_n_tmp(:)    \n    \n! debugging\n    n_hat_tmp = [100.d0, 0.d0, 0.d0, 150.d0, 0.d0, 0.d0, 0.d0, 200.d0]  \n    cv_n_tmp =  0.20d0\n    \n    print *, \"hello from `avg_n()`\"\n    print *, \"n_hat_tmp: \", n_hat_tmp\n    print *, \"cv_n_tmp : \", cv_n_tmp\n    stop    \n\n  end subroutine avg_n\n"}, {"instruction": "Create a Fortran subroutine named inxslist that takes 4 input parameters of type integer, character*( * ), integer, and character*( * ), and 1 output parameter of type integer. The subroutine performs a simple search for matching strings from the given string table and string list. The output parameter returns the pointers to the table.", "input": "", "output": "    subroutine inxslist(ntab,stab,nval,sval,indx)\n      implicit none\n      integer, intent(in)\t:: ntab\t\t! size of stab\n      character*(*), intent(in)\t:: stab(ntab)\t! a given string table\n      integer, intent(in)\t:: nval\t\t! size of sval\n      character*(*), intent(in)\t:: sval(nval)\t! a given string list\n      integer, intent(out)\t:: indx(nval)\t! pointers to the table\n\n!\n! !description:\n!\n! !examples:\n!\n! !bugs:\n!   inxslist() performs a simple searching with minimum consideration\n!   of efficiency as a scalar algorithm.  however, it might do well on\n!   a vector/multitask system, such as a cray c90/j90.\n!\n! !see also:\n!\n! !system routines:\n!\n! !files used:\n!\n! !revision history:\n! \t03jan96 - j. guo\t- programmed and added the prolog\n!_______________________________________________________________________\n\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n!   locals\n  integer iv,it\n!-----------------------------------------------------------------------\n  indx(1:nval)=0\n  do it=1,ntab\n    do iv=1,nval\n      if(sval(iv) == stab(it)) indx(iv)=it\n    end do\n  end do\n!_______________________________________________________________________\nend subroutine inxslist\n"}, {"instruction": "Create a Fortran subroutine named beam_gm that calculates the coefficients for a specific mathematical operation. The subroutine takes 1 input parameter of type real(iwp) and provides 1 output parameter of type real(iwp).", "input": "", "output": "subroutine beam_gm(gm,ell)\n! used in p46\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::ell\n real(iwp),intent(out)::gm(:,:)\n real(iwp)::pt1=0.1_iwp,opt2=1.2_iwp,two=2.0_iwp,d15=15.0_iwp,d30=30.0_iwp\n gm(1,1)=opt2/ell\n gm(1,2)=pt1\n gm(2,1)=pt1\n gm(1,3)=-opt2/ell\n gm(3,1)=-opt2/ell\n gm(1,4)=pt1\n gm(4,1)=pt1\n gm(2,2)=two*ell/d15\n gm(2,3)=-pt1\n gm(3,2)=-pt1\n gm(2,4)=-ell/d30\n gm(4,2)=-ell/d30\n gm(3,3)=opt2/ell\n gm(3,4)=-pt1\n gm(4,3)=-pt1\n gm(4,4)=two*ell/d15\nreturn\nend subroutine beam_gm\n"}, {"instruction": "Create a Fortran subroutine named foo to determine the lower bound of the first dimension of two arrays. The subroutine should have 2 input parameters of type integer, dimension(:) and integer, dimension(-2:), and 2 output parameters of type integer.", "input": "", "output": "  subroutine foo (a, b, one, m)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension (-2:), intent(in) :: b\n    integer, intent(out) :: one, m\n    one = lbound(a,1)\n    m = lbound(b,1)\n  end subroutine foo\n"}, {"instruction": "Create a Fortran subroutine named a_oio to calculate the pure compound ideal Helmholtz energy and its derivatives. The subroutine takes 6 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are rho, t, rho_c, t_c, n (dimension 7), and v (dimension 7). The output parameter is aoio, which is a 3x3 array of real(8) values.", "input": "", "output": "subroutine a_oio(rho, t, rho_c, t_c, n, v, aoio)\n   ! ideal gas energy\n   ! ----------------\n   ! calculate the pure compound ideal helmholtz enegry and its derivatives\n   !\n   ! input:\n   ! - rho (float): density\n   ! - t (float): temperature\n   ! - rho_c (float): critical density\n   ! - t_c (float): critical temperature\n   ! - n (dimension): n parameters\n   ! - v (dimension): v parameters\n   ! output:\n   ! - aoio: ideal gas helmholtz energy and its derivatives,\n   ! stoikuctured like:\n   ! --------------+------------------+------------------|\n   ! aoio          |     0            |    0             |\n   ! d(aoio)/dd    |     d(aoio)/dt   |    0             |\n   ! d2(aoio)/dd2  |     d2(aoio)/dt2 |    d2(aoio)/dddt |\n   ! ----------------------------------------------------|\n   real(8), intent(in) :: rho, t, rho_c, t_c\n   real(8), intent(in), dimension(7) :: n, v\n   real(8), intent(out) :: aoio(3, 3)\n   real(8) :: r, tr, dr, eps = 1d-10\n\n   r = 8.314510d0 / 8.314472d0\n\n   aoio = 0.d0\n   tr = t_c / t\n   dr = rho / rho_c\n\n   do k = 4, 7\n      if (v(k) > eps) then\n         if (k == 4 .or. k == 6) then\n            aoio(1, 1) = aoio(1, 1) + r * (n(k) * log(abs(dsinh(v(k) * tr))))\n            aoio(2, 2) = aoio(2, 2) + r * (n(k) * v(k) / dtanh(v(k) * tr))\n            aoio(3, 2) = aoio(3, 2) - r * (n(k) * v(k) ** 2 / dsinh(v(k) * tr) ** 2)\n         else\n            aoio(1, 1) = aoio(1, 1) - r * (n(k) * log(dcosh(v(k) * tr)))\n            aoio(2, 2) = aoio(2, 2) - r * (n(k) * v(k) * dtanh(v(k) * tr))\n            aoio(3, 2) = aoio(3, 2) - r * (n(k) * v(k) ** 2 / dcosh(v(k) * tr) ** 2)\n         end if\n      end if\n   end do\n\n   aoio(1, 1) = aoio(1, 1) + log(dr) + r * (n(1) + n(2) * tr + n(3) * log(tr))\n   aoio(2, 1) = 1.d0 / dr\n   aoio(3, 1) = - 1.d0 / dr ** 2\n   aoio(2, 2) = aoio(2, 2) + r * (n(2) + n(3) / tr)\n   aoio(3, 2) = aoio(3, 2) + r * (- n(3) * (t / t_c) ** 2)\n   aoio(3, 3) = 0.d0\nend subroutine a_oio\n"}, {"instruction": "Create a Fortran subroutine named a_oir to calculate the pure compound residual Helmholtz energy and its derivatives. The subroutine has 8 input parameters of type real(8), real(8), integer, integer, real(8) arrays of dimension 24, and integer arrays of dimension 24. The output parameter is a real(8) array of dimension 3x3.", "input": "", "output": "subroutine a_oir(delta, tau, kpol, kexp, n, d, t, c, aoir)\n   ! residual energy\n   ! ---------------\n   ! caculate the pure compound residual helmholtz energy and its derivatives\n   !\n   ! input:\n   ! - delta  (float)         : reduced density\n   ! - tau    (float)         : reduced temperature\n   ! - kpol   (integer)       : number of only polynomial parameters\n   ! - kexp   (integer)       : number of only exponential parameters\n   ! - n      (dimension)     : parameters n\n   ! - d      (dimension)     : parameters d\n   ! - t      (dimension)     : parameters t\n   ! - c      (dimension)     : parameters c\n   ! output:\n   ! - aoir: ideal gas helmholtz energy and its derivatives,\n   ! structured like:\n   ! ---------------+-------------------+-----------------|\n   ! aoir           |      0            |   0             |\n   ! d(aoir)/dd     |      d(aoir)/dt   |   0             |\n   ! d2(aoir)/dd2   |      d2(aoir)/dt2 |   d2(aoir)/dddt |\n   ! -----------------------------------------------------|\n   !\n\n   real(8), intent(in) :: delta, tau\n   integer, intent(in) :: kpol, kexp\n   real(8), dimension(24), intent(in) :: n, t\n   integer, dimension(24), intent(in) :: d, c\n   real(8), dimension(3, 3), intent(out) :: aoir\n   integer :: k\n\n   aoir = 0.d0\n   ! residual helmholtz energy\n   do k = 1, kpol\n        ! !write (0, *) k, n(k), d(k), t(k), c(k)\n      aoir(1, 1) = aoir(1, 1) + &\n                   n(k) * delta ** d(k) &\n                   * tau ** t(k)\n      aoir(2, 1) = aoir(2, 1) + n(k) * d(k) * delta ** (d(k) - 1) * tau ** (t(k))\n      aoir(2, 2) = aoir(2, 2) + &\n                   n(k) * t(k) * delta ** d(k) &\n                   * tau ** (t(k) - 1.d0)\n      aoir(3, 1) = aoir(3, 1) + &\n                   n(k) * d(k) * (d(k) - 1) * delta ** (d(k) - 2) * tau ** t(k)\n      aoir(3, 2) = aoir(3, 2) + &\n                   n(k) * t(k) * (t(k) - 1.d0) &\n                   * delta ** d(k) * tau ** (t(k) - 2.d0)\n      aoir(3, 3) = aoir(3, 3) + &\n                   n(k) * d(k) * t(k) &\n                   * delta ** (d(k) - 1) * tau ** (t(k) - 1.d0)\n   end do\n   do k = kpol + 1, kpol + kexp\n        ! !write (0, *) k, n(k), d(k), t(k), c(k)\n      aoir(1, 1) = aoir(1, 1) + &\n                   n(k) * delta ** d(k) &\n                   * tau ** t(k) &\n                   * exp(- delta ** c(k))\n      ! first derivative with reduced density\n      aoir(2, 1) = aoir(2, 1) + &\n                   n(k) * delta ** (d(k) - 1) &\n                   * (d(k) - c(k) * delta ** c(k)) &\n                   * tau ** t(k) * exp(- delta ** c(k))\n      ! first derivative with reduced temperature\n      aoir(2, 2) = aoir(2, 2) + &\n                   n(k) * t(k) * delta ** d(k) &\n                   * tau ** (t(k) - 1) &\n                   * exp(- delta ** c(k))\n      ! second derivative with reduced density\n      aoir(3, 1) = aoir(3, 1) + &\n                   n(k) * delta ** (d(k) - 2) * ( &\n                   (d(k) - c(k) * delta ** c(k)) &\n                   * (d(k) - 1 - c(k) * delta ** c(k)) &\n                   - c(k) ** 2 * delta ** c(k)) &\n                   * tau ** t(k) * exp(- delta ** c(k))\n      ! second derivative with reduced temperature\n      aoir(3, 2) = aoir(3, 2) + &\n                   n(k) * t(k) * (t(k) - 1.d0) &\n                   * delta ** d(k) * tau ** (t(k) - 2.d0) &\n                   * exp(- delta ** c(k))\n      ! second derivative with reduced temperature and density\n      aoir(3, 3) = aoir(3, 3) + &\n                   n(k) * t(k) * delta ** (d(k) - 1) &\n                   * (d(k) - c(k) * delta ** c(k)) &\n                   * tau ** (t(k) - 1.d0) * exp(- delta ** c(k))\n   end do\n\nend subroutine a_oir\n"}, {"instruction": "Write a Fortran subroutine named ftest that takes 3 input parameters of type integer, integer, and real (dp), and 1 output parameter of type real (dp). The subroutine computes a function value based on the input values and stores the result in the output parameter. The subroutine uses the imperative tone to instruct the computer to perform the calculations.", "input": "", "output": "subroutine ftest(ndim, z, nfun, f)\r\nimplicit none\r\ninteger, parameter     :: dp = selected_real_kind(15, 60)\r\ninteger, intent(in)    :: ndim, nfun\r\nreal (dp), intent(in)  :: z(:)\r\nreal (dp), intent(out) :: f(:)\r\n\r\n! local variables\r\ninteger   :: n\r\nreal (dp) :: sum\r\n\r\nsum = 0\r\ndo n = 1, ndim\r\n  sum = sum + n*z(n)**2\r\nend do\r\nf(1) = exp(-sum/2)\r\nf(2:nfun) = f(1) * z(1:nfun-1)\r\n\r\nreturn\r\nend subroutine ftest\r\n"}, {"instruction": "Create a Fortran subroutine named maxcheck that takes an array of 8-byte real numbers as input and returns the index of the maximum value as output. The subroutine should use the \"intent(in)\" attribute for the input array and the \"intent(out)\" attribute for the output integer.", "input": "", "output": "subroutine maxcheck(array,max)\n  real(8),intent(in) :: array(:)\n  integer,intent(out) :: max\n  integer :: i,arraysize\n  real(8) :: max_temp\n  \n  arraysize = size(array)\n  max_temp = 0.0d0\n  \n  do i = 1,arraysize\n    if (array(i) > max_temp) then\n      max_temp = array(i)\n      max = i\n    end if\n  end do\n  \nend subroutine maxcheck\n"}, {"instruction": "Write a Fortran subroutine named subtrace to perform a specific matrix operation. The subroutine takes 3 input parameters of type real(8), dimension(:,:), allocatable, integer, and integer, and 1 output parameter of type real(8), dimension(:,:), allocatable.", "input": "", "output": "  subroutine subtrace(red_dm,big_dm,bignsites,rednsites)\n   real(8),dimension(:,:),allocatable,intent(out) :: red_dm\n   real(8),dimension(:,:),allocatable,intent(in)  :: big_dm\n   integer                           ,intent(in)  :: bignsites\n   integer                           ,intent(in)  :: rednsites\n   integer         :: i,j,io,jo,iup,idw,jup,jdw\n   integer         :: iimpup,iimpdw,jimpup,jimpdw\n   integer         :: iredup,ireddw,jredup,jreddw\n   integer         :: itrup,itrdw,jtrup,jtrdw\n   integer         :: nbig,nred,dimbig,dimred\n   !\n   nbig=norb*bignsites\n   nred=norb*rednsites\n   !\n   dimbig = 4**nbig\n   dimred = 4**nred\n   !\n   if(size(big_dm(:,1))/=dimbig)stop \"error: nsites is not consistent with the given big_dm\"\n   !\n   allocate(red_dm(dimred,dimred)); red_dm=0.d0\n   !\n   do iup = 1,2**nbig\n      do idw = 1,2**nbig\n           i = iup + (idw-1)*2**nbig\n           iimpup = iup-1\n           iimpdw = idw-1\n           iredup = ibits(iimpup,0,nred)\n           ireddw = ibits(iimpdw,0,nred)\n           itrup  = ibits(iimpup,nred,nbig)\n           itrdw  = ibits(iimpdw,nred,nbig)\n           do jup = 1,2**nbig\n              do jdw = 1,2**nbig\n                    j = jup + (jdw-1)*2**nbig\n                    jimpup = jup-1\n                    jimpdw = jdw-1\n                    jredup = ibits(jimpup,0,nred)\n                    jreddw = ibits(jimpdw,0,nred)\n                    jtrup  = ibits(jimpup,nred,nbig)\n                    jtrdw  = ibits(jimpdw,nred,nbig)\n                    if(jtrup/=itrup.or.jtrdw/=itrdw)cycle\n                    io = (iredup+1) + ireddw*2**nred\n                    jo = (jredup+1) + jreddw*2**nred\n                    red_dm(io,jo) = red_dm(io,jo) + big_dm(i,j)\n              enddo\n           enddo\n      enddo\n   enddo\n   !\n end subroutine subtrace\n"}, {"instruction": "Create a Fortran subroutine named \"pdeeigenvalues\" to calculate the eigenvalues of a partial differential equation (PDE) system. The subroutine takes 2 input parameters of type real and 1 output parameter of type real. The input parameters are \"lambda\" and \"q\" of unspecified length, and \"nv\" of length 3. The output parameter is \"lambda\" of unspecified length.", "input": "", "output": "recursive subroutine pdeeigenvalues(lambda,q,nv)\n  use iso_c_binding\n  implicit none\n  integer, parameter             :: nvar = 59                           ! the number of variables of the pde system \n  type, bind(c) :: tequations\n      real(8)    :: ccz4e=0.1, ccz4ds=0.11, ccz4glmc = 0.75, ccz4glmd = 0.75 \n  end type tequations\n  type(tequations) :: eqn\n  real :: lambda(nvar), nv(3), q(nvar), tempa, tempb\n  intent(in)  :: q,nv\n  intent(out) :: lambda \n  ! local variables \n  real :: lam, mu, irho, vpr(3), cs,c0,uu,alpha\n#if defined(ccz4einstein)  \n    alpha = max( 1.0, exp(q(17)) )*max( 1.0, exp(q(55)) )/min( sqrt(q(1)), sqrt(q(4)), sqrt(q(6)) )     \n#else\n    alpha = 1.0 \n#endif\n    tempa = alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha )\n    tempb = dot_product(q(18:20),nv(:))\n    lambda = 0.0 \n    lambda(1) = -tempa-tempb \n    lambda(2) =  tempa-tempb\n    !lambda(1) = -alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha ) - dot_product(q(18:20),nv(:))   ! max( sqrt(2.0), eqn%ccz4e, eqn%ccz4ds ) + sqrt(sum(q(18:20)**2)) \n    !lambda(2) = +alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha ) - dot_product(q(18:20),nv(:))   ! max( sqrt(2.0), eqn%ccz4e, eqn%ccz4ds ) + sqrt(sum(q(18:20)**2)) \n    !\nend subroutine pdeeigenvalues\n"}, {"instruction": "Create a Fortran subroutine named set_real to convert a generic input argument to a real output argument. The subroutine takes 1 input parameter of type class(*) and 1 output parameter of type real. Ensure that the input argument is of real type, and if not, stop with an error message.", "input": "", "output": "subroutine set_real(x,y)\r\nclass(*), intent(in)  :: x\r\nreal    , intent(out) :: y\r\nselect type(x)\r\n   type is (real)\r\n      y = x\r\n   class default\r\n      error stop \"need x real in set_real, stopping\"\r\nend select\r\nend subroutine set_real\r\n"}, {"instruction": "Write a Fortran subroutine named random_uniform that generates a random number in the range specified by the input arguments. The number of input arguments is 2 and the test_data type is ['double precision ', 'double precision ']. The number of output arguments is 1 and the test_data type is ['double precision '].", "input": "", "output": "  subroutine random_uniform (a, b, x)\n    double precision , intent(in) :: a, b\n    double precision , intent(out) :: x\n    double precision :: r\n\n    call random_number(r)\n\n    x = (1 - r)*(b - a) + a\n\n  end subroutine random_uniform\n"}, {"instruction": "Create a Fortran subroutine named \"three\" that takes 3 real input parameters and 1 real output parameter. The input parameters are a, b, and c, while the output parameter is d. The subroutine computes the value of d as the result of the expression a divided by the difference between b and c. Ensure to use the \"intent(in)\" attribute for the input parameters and \"intent(out)\" for the output parameter in the subroutine.", "input": "", "output": "    subroutine three(a,b,c,d)\n    implicit none\n\t  real,intent(in) :: a,b,c\n\t  real,intent(out) :: d\n\t  \n\t  d = a/(b-c)\n\n    end subroutine three\n"}, {"instruction": "Create a Fortran subroutine named matrix_sym to perform matrix operations. It takes 5 input parameters: ni, nj, nq of type integer*4, mtlhs of type real*8, dimension(ni,nj), and rhs of type real*8, dimension(nq,ni). It returns 2 output parameters: mtsym of type real*8, dimension(nj,nj), and rhssym of type real*8, dimension(nq,nj). The subroutine calculates symmetric matrices and symmetric right-hand sides based on the input parameters.", "input": "", "output": "subroutine matrix_sym(ni, nj, nq, mtlhs, rhs, mtsym, rhssym)\n!\nimplicit none\n!\ninteger*4, intent(in)::ni, nj, nq\nreal*8, dimension(ni,nj), intent(in):: mtlhs\nreal*8, dimension(nq,ni),    intent(in):: rhs\nreal*8, dimension(nj,nj), intent(out):: mtsym\nreal*8, dimension(nq,nj),   intent(out):: rhssym\n\n!...local\n\ninteger:: im, jm,km, iq\n\n!...zero out\nmtsym  = 0.d0\nrhssym = 0.d0\n\n!...symmetry matrix\ndo im = 1, nj\ndo jm = 1, nj\ndo km = 1, ni\nmtsym(im, jm) = mtsym(im, jm) + mtlhs(km, im)*mtlhs(km, jm)\nenddo\nenddo\nenddo\n\n!...symmetry rhs\ndo iq = 1 ,nq\ndo im = 1, nj\ndo km = 1, ni\nrhssym(iq, im) = rhssym(iq, im) + mtlhs(km, im)*rhs(iq, km)\nenddo\nenddo\nenddo\n\nreturn\nend subroutine matrix_sym\n"}, {"instruction": "Create a Fortran subroutine named define_connect_tensor_2d to generate a 2D connectivity table for tensor-product order polynomial elements. The subroutine takes 4 input parameters of type integer: nex (number of elements in x direction), ney (number of elements in y direction), p (polynomial order of elements), ibc (boundary condition type). It also has 1 output parameter of type integer array which is allocatable: gn (global node number of the local nodes in each element).", "input": "", "output": "subroutine define_connect_tensor_2d(nex, ney, p, ibc, gn)\n! 2d connectivity table for tensor-product order p elements\ninteger, intent(in) :: nex, ney ! number of elements in x and y directions\ninteger, intent(in) :: p ! polynomial order of elements\n! boundary condition: 1 = neumann, 2 = dirichlet, 3 = periodic\ninteger, intent(in) :: ibc\n! gn(i, j, e) is the global node number of the local (i,j) node in e-th element\ninteger, allocatable, intent(out) :: gn(:, :, :)\ninteger :: nodes(nex*p+1, ney*p+1)\ninteger :: inode, ix, iy, iel, iex, iey\n! construct array of global nodes\n! 0 = no associated basis function as in e.g. dirichlet bcs\nnodes = 0\ninode = 0\ndo iy = 1, ney*p+1\n    do ix = 1, nex*p+1\n        if (ibc >= 2 .and. (ix == 1 .or. ix == nex*p+1 .or. &\n                            iy == 1 .or. iy == ney*p+1)) cycle\n        inode = inode + 1\n        nodes(ix, iy) = inode\n    end do\nend do\nif (ibc == 3) then\n    ! now we need to connect the basis functions on the opposite sites of the\n    ! boundary.\n    ! top-bottom sides\n    do ix = 2, nex*p\n        inode = inode + 1\n        nodes(ix, 1)       = inode\n        nodes(ix, ney*p+1) = inode\n    end do\n    ! left-right sides\n    do iy = 2, ney*p\n        inode = inode + 1\n        nodes(1, iy)       = inode\n        nodes(nex*p+1, iy) = inode\n    end do\n    ! corners\n    inode = inode + 1\n    nodes(1, 1)             = inode\n    nodes(1, ney*p+1)       = inode\n    nodes(nex*p+1, 1)       = inode\n    nodes(nex*p+1, ney*p+1) = inode\nend if\n! construct connectivity table of global nodes in each element\nallocate(gn(p+1, p+1, nex*ney))\niel = 0\ndo iex = 1, nex\n    do iey = 1, ney\n        iel = iel + 1 ! element number\n        ix = (iex-1)*p+1 ! lower left corner\n        iy = (iey-1)*p+1\n        ! get global node numbers in element\n        gn(:, :, iel) = nodes(ix:ix+p, iy:iy+p)\n    end do\nend do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named fib to calculate the first n Fibonacci numbers. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real']. Use the imperative tone in the instruction.", "input": "", "output": "pure subroutine fib(n, a)\n!! calculate first n fibonacci numbers\ninteger, intent(in) :: n\nreal, intent(out) :: a(n)\n\ninteger :: i\n\na(:2) = [0, 1]\n\ndo i = 3,n\n  a(i) = a(i-1) + a(i-2)\nenddo\n\nend subroutine fib\n"}, {"instruction": "Create a Fortran subroutine named get_element_by_charge to retrieve the chemical element symbol based on the input charge. The subroutine takes 1 input parameter of type integer, and returns 1 output parameter of type character (len=*).", "input": "", "output": "subroutine get_element_by_charge(charge, ostr)\n\timplicit none\n!\n\tinteger, intent(in) :: charge\n\tcharacter (len=*), intent(out) :: ostr\n\tinteger :: pos1, pos2, i\n\tcharacter (len=1000) :: elements = &\n\t\t\"h:he:li:be:b:c:n:o:f:ne:na:mg:al:si:p:s:cl:ar:\" // &\n\t\t\"k:ca:sc:ti:v:cr:mn:fe:co:ni:cu:zn:ga:ge:as:se:br:kr:\" // &\n\t\t\"rb:sr:y:zr:nb:mo:tc:ru:rh:pd:ag:cd:in:sn:sb:te:i:xe:\" // &\n\t\t\"cs:ba:la:ce:pr:nd:pm:sm:eu:gd:tb:dy:ho:er:tm:yb:lu:\"  // &\n\t\t\"hf:ta:w:re:os:ir:pt:au:hg:tl:pb:bi:po:at:rn:fr:ra:\"   // &\n\t\t\"ac:th:pa:u:np:pu:am:cm:bk:cf:es:fm:md:no:lr:\"         // &\n\t\t\"rf:db:sg:bh:hs:mt:ds:rg:cn:nh:fl:mc:lv:ts:og:xx\"\n!\n\ti = 0\n\tpos1 = 1\n\tostr = 'xx'\n\t\n\tif ( charge .eq. 0 ) then\n\t\treturn\n\tend if\n\t\n\tdo i = 1, 119\n\t\tpos2 = index(elements(pos1:), \":\")\n\t\tif ( pos2 .ne. 0 ) then\n\t\t\tostr = trim(adjustl(elements(pos1:pos1+pos2-2)))\n\t\t\tif ( i .eq. charge ) then\n\t\t\t\texit\n\t\t\tend if\n\t\t\tpos1 = pos1 + pos2 \n\t\telse\n\t\t\texit\n\t\tend if\n\tend do\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named hello_fortran that takes an integer and a real number as input arguments, and returns the sum of the two numbers as a real number. The input arguments are of type integer and real, and the output argument is of type real. Within the subroutine, it should display a message containing the received integer and real numbers, and then calculate the sum.", "input": "", "output": "subroutine hello_fortran(number, real_number, total_number)\n  implicit none\n  integer, intent(in)  :: number !input\n  real, intent(in) :: real_number !input\n  real, intent(out) :: total_number ! output\n\n  write(*,*) \"hello from fortran\"\n  write(*,*) \"you gave me the integer: \", number\n  write(*,*) \"you gave me the float: \", real_number\n\n  total_number = number + real_number\n\nend subroutine hello_fortran\n"}, {"instruction": "Create a Fortran subroutine named component2index_band to calculate the index corresponding to a set of four components in a four-dimensional array. The subroutine takes 5 input parameters of type integer (nbands, b1, b2, b3, b4) and returns 1 output parameter of type integer (ind).", "input": "", "output": "subroutine component2index_band(nbands, ind, b1, b2, b3, b4)\n  implicit none\n  integer,intent(in)  :: nbands\n  integer,intent(in)  :: b1, b2, b3, b4\n  integer,intent(out) :: ind\n\n  ind =  nbands**3*(b1-1) + nbands**2*(b2-1) + nbands*(b3-1) + b4\n\nend subroutine component2index_band\n"}, {"instruction": "Write a Fortran subroutine named index2component_band to convert an index to a set of four components. The subroutine takes 2 input parameters of type integer and returns 4 output parameters of type integer.", "input": "", "output": "subroutine index2component_band(nbands, ind, b1, b2, b3, b4)\n  implicit none\n  integer,intent(in)  :: nbands,ind\n  integer,intent(out) :: b1, b2, b3, b4\n  integer             :: tmp1, tmp2, tmp3, ind_tmp\n  integer             :: g1, g2, g3, g4\n\n  ! the proposed back conversion assumes the indices are\n  ! given form 0 to max-1\n  ind_tmp = ind - 1\n  tmp1 = nbands**3\n  tmp2 = nbands**2\n  tmp3 = nbands\n\n  b1 = ind_tmp/tmp1 + 1\n  b2 = (ind_tmp-tmp1*(b1-1))/tmp2 + 1\n  b3 = (ind_tmp-tmp1*(b1-1)-tmp2*(b2-1))/tmp3 + 1\n  b4 = (ind_tmp-tmp1*(b1-1)-tmp2*(b2-1)-tmp3*(b3-1)) + 1\n\nend subroutine index2component_band\n"}, {"instruction": "Write a Fortran subroutine named \"d_getsettings\" that takes an integer input parameter and returns four integer output parameters. The purpose of this subroutine is to determine the values of \"m\", \"k\", \"we\", and \"ws\" based on the value of the input parameter \"n\". \n\nThe subroutine uses an if-else statement to assign values to the output parameters according to specific conditions. If \"n\" is less than the value of \"ssth\", all output parameters are set to 1. If \"n\" is less than 150, the output parameters are set to specific values. Similar rules apply for different ranges of \"n\" values, with different values assigned to the output parameters.\n\nMake sure to declare the input parameter \"n\" as an integer and the output parameters \"m\", \"k\", \"we\", and \"ws\" as integers with the \"intent(in/out)\" attribute to specify their usage.", "input": "", "output": "  subroutine d_getsettings(n,m,k,we,ws)\n    integer, intent(in)             ::  n\n    integer, intent(out)            ::  m, k, we, ws\n\n    if (n .lt. ssth) then\n      k = 1\n      m = 1\n      we = 1\n      ws = 1\n    elseif (n .lt. 150) then\n      k = 4\n      m = 4\n      we = 6\n      ws = 4\n    elseif (n .lt. 250) then\n      k = 8\n      m = 8\n      we = 10\n      ws = 4\n    elseif (n .lt. 501) then\n      k = 16\n      m = 16\n      we = 18\n      ws = 6\n    elseif (n .lt. 1001) then\n      k = 32\n      m = 32\n      we = 34\n      ws = 10\n    elseif (n .lt. 3000) then\n      k = 64\n      m = 64\n      we = 66\n      ws = 16\n    elseif (n .lt. 6000) then\n      k = 128\n      m = 128\n      we = 130\n      ws = 32\n    else\n      k = 256\n      m = 256\n      we = 266\n      ws = 48\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named forward_euler to perform the forward Euler method for numerical integration. The subroutine takes three parameters as input: time_step (real(8)), n (integer), and vec (real(8), dimension(:)). The subroutine computes the values of vec using the forward Euler method and stores the results in vec. The number of input arguments is 2 and the test_data type is ['real(8)', 'integer']. The number of output arguments is 1 and the test_data type is ['real(8), dimension(:)'].", "input": "", "output": "    subroutine forward_euler(time_step, n, vec)\n        \n        implicit none\n        real(8), dimension(:), intent(out)   :: vec\n        real(8), intent(in)                  :: time_step\n        integer, intent(in)                  :: n\n        integer                              :: i\n\n        vec(1) = 1d0\n\n        do i=1, n-1\n        \n            vec(i+1) = vec(i) - 3d0 * vec(i) * time_step\n\n        end do\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine called open_file that takes a filename as input and returns an integer value. The filename should be of type character and have a length of 1024. The subroutine opens the file specified by the filename in \"old\" mode, with unformatted data and read access. The subroutine also checks for any errors that occur during the file opening process. If an error occurs, the subroutine will display an error message and stop the program execution.", "input": "", "output": "subroutine open_file(filename, unt)\n    implicit none\n    character(len=1024), intent(in) :: filename\n    integer, intent(out) :: unt\n    integer :: iost\n    open(unit=unt, file=trim(filename), status='old', form='unformatted', &\n         action='read', iostat=iost)\n    if (iost /= 0) then\n        write(*,*) \"open_file: error when opening file: '\", trim(filename), &\n                   \"' with iostat=\", iost\n        stop 1\n    end if\nend subroutine open_file\n"}, {"instruction": "Write a Fortran subroutine named stdheight_ml that calculates the standard atmospheric height at multiple levels. The subroutine takes 8 input parameters: an integer (nk), three arrays of double precision (p, t, td) with dimension nk, and four double precision values (ps, ts, tds, hin). It also has two output parameters: an array of double precision (h) with dimension nk and a single double precision value (hs).\n\nIn the subroutine, virtual temperatures are calculated at each level using the input temperature and dew point temperature. The height is then computed using the hyposometric equation, which relates temperature, pressure, and height. The calculations are performed for multiple levels, including a surface level.\n\nTo use the subroutine, provide the necessary input values and allocate the required memory for the output arrays. After calling the subroutine, the resulting heights will be stored in the array h, and the surface height will be stored in hs.\n\nMake sure to provide the correct data types and dimensions when using the subroutine.", "input": "", "output": "      subroutine stdheight_ml(p,t,td,ps,ts,tds,hin,nk,h,hs)\n      !f2py threadsafe\n      !f2py intent(out) :: h\n\n      implicit none\n      integer, intent(in) :: nk\n      integer :: k, nk_all, k_all\n      double precision, dimension(nk), intent(in) :: p,t,td\n      double precision, intent(in) :: ps,ts,tds\n      double precision, dimension(nk) :: tv\n      double precision :: tvs\n      double precision :: tin,tdin,e,w\n      double precision, intent(in) :: hin\n      double precision, dimension(nk), intent(out) :: h\n      double precision, intent(out) :: hs\n\n      double precision, parameter :: r=287.04\n      double precision, parameter :: g=-9.80665\n      !integer, parameter :: n = 10\n      double precision, parameter :: eps = 0.6219800858985514\n      !parameter (r=287.04,g=-9.80665)\n      !calculate virtual temperatures at the two levels and the mean of these two values.\n      !calculate height using the hyposometric equation  rdtvmean/g (ln(p1/p2)) = z2-z1\n\n      ! number of levels 3d + surface\n      nk_all = nk + 1\n\n      ! if surface level, use surface temperature\n      tin=ts+273.15\n      !w calculation starting from dewpoint\n      tdin = tds+273.15\n      !e = 6.112*exp((17.67*(tdin-273.15))/(tdin-29.65))\n      e = 6.112*exp((53.49-(6808/tdin)-5.09*log(tdin)))\n      w = eps*(e/(ps-e))\n      !alt w calculation starting from specific humidity\n      ! w = (qs/1000)/(1-(qs/1000))\n      !now calculate tv correctly:\n      tvs = tin*((w+eps)/(eps*(1+w)))\n      !old incorect tv\n      !tvs=tin/(1-0.379*(6.11*10*((7.5*tds)/ &\n      !(237.7+tds))/ps))\n      ! loop along vertical levels 3d = nk\n      do k = 1, nk\n        tin=t(k)+273.15\n        !calculate w for each layer\n        tdin = td(k)+273.15\n        ! e = 6.112*exp((17.67*(tdin-273.15))/(tdin-29.65))\n        e = 6.112*exp((53.49-(6808/tdin)-5.09*log(tdin)))\n\n        w=eps*(e/(p(k)-e))\n        !alt calc w each layer\n        ! w= (qs/1000)/(1-(qs/1000))\n        !calculate virtual temperatures for a surface + 3d element\n        tv(k) = tin*((w+eps)/(eps*(1+w)))\n        !incorrect old method\n        !tv(k)=tin/(1-0.379*(6.11*10*((7.5*td(k))/ &\n        !(237.7+td(k)))/p(k)))\n      enddo\n        !now integrate along the hypsometric equation\n\n      do k_all = 1, nk_all\n        k = k_all-1\n        ! for surface height, that is actually equal to hin (either topography or 2m)\n        if (k_all .eq. 1) then\n          hs=hin\n        elseif (k_all .eq. 2) then\n          ! for k = 2 it uses hs and tvs for the layer below\n          ! variables from 3d use k_all-1 as index\n          ! m = (tv(k)-tvs)/(log(p(k))-log(ps))\n          ! b = tvs-m*log(ps)\n          ! call trapz(m*x+b,log(ps),log(p(k)),tvp,n)\n          ! h(k)=hs-((r/g)*tvp)\n          ! original implementation assuming mean value theorem\n          h(k)=hs+((r*((tv(k)+tvs)/2)/g))*(log(p(k)/ps))\n        else\n          ! for k >= 3 it uses only 3d variables\n          ! variables from 3d use k-1 as index\n          ! m = (tv(k)-tv(k-1))/(log(p(k))-log(p(k-1)))\n          ! b = tv(k)-m*log(p(k))\n          ! call trapz(tv,log(p(k-1)),log(p(k)),tvp,n)\n          ! h(k) = h(k-1)+((r/g)*tvp)\n          h(k)=h(k-1)+((r*((tv(k)+tv(k-1))/2)/g))*(log(p(k)/p(k-1)))\n        endif\n      enddo\n\n      return\n      end subroutine stdheight_ml\n"}, {"instruction": "Provide a Fortran subroutine code named \"filesize\" that calculates the size of a file given its name. The subroutine takes one input parameter of type \"character(*)\" to represent the file name. It also has one output parameter of type \"integer\" to store the file size. \n\nThe subroutine uses the \"stat\" function to obtain the file size and returns -1 if there is an error. The subroutine also includes necessary declarations and checks the status of the \"stat\" function. \n\nMake sure to update the calling routines that use the file unit instead of the file name.", "input": "", "output": "   subroutine filesize ( filename, size )\n\n\n      ! this routine calls the routine stat to obtain the file size\n      ! corresponding to a file name or returns -1 on error.\n\n      ! mlb: warning!!!\n      ! the standard version of the routine uses the file unit instead of file name.\n      ! we need fix the routines that call this one.\n\n\n      ! argument declarations:\n\n   integer, intent(out)         :: size\n\n   character(*), intent(in)     :: filename\n\n\n      ! intrinsic declarations:\n\n   integer(kind=1)              :: stat\n\n\n      ! local declarations:\n\n   integer                      :: statarray(12)\n   integer                      :: status\n\n\n\n   status = stat( filename, statarray )\n\n   if ( status /= 0 ) then\n     size = -1\n   else\n     size = statarray(8)\n   end if\n\n\n   return\n   end subroutine filesize ! ( filename, size )\n"}, {"instruction": "Write a Fortran subroutine named findline that searches for a line of text within a given string. The subroutine takes 2 input parameters: an integer representing the maximum length of the string and a character string to search. It also has 1 output parameter: an integer indicating the location of the end of the string. The subroutine tries to break the line at a blank space, ensuring that the line length does not exceed the maximum length provided. The subroutine is not system-specific but is intended to be called by another subroutine called wrscr().", "input": "", "output": "   subroutine findline ( str , maxlen , strend )\n\n\n      ! this routine finds one line of text with a maximum length of maxlen from the str.\n      ! it tries to break the line at a blank.\n\n      ! this routine isn't system specific, but it is called by wrscr(), which is, so it must be here.\n\n\n   implicit                        none\n\n\n      ! argument declarations:\n\n   integer, intent(in)          :: maxlen                                       ! the maximum length of the string.\n   integer, intent(out)         :: strend                                       ! the location of the end of the string.\n\n   character(*), intent(in)     :: str                                          ! the string to search.\n\n\n      ! local declarations:\n\n   integer         ic\n\n\n\n   strend = maxlen\n\n   if ( len_trim( str ) > maxlen )  then\n\n      ic = index( str(1:maxlen), ' ', back = .true. ) ! find the last space in the line\n\n      if ( ic > 1 ) then ! we don't want to return just one character that's a space, or do we?\n\n         strend = ic-1    ! strend > 0\n         do while ( str(strend:strend) == ' ' )\n            strend = strend - 1\n            if ( strend <= 0 ) then  ! this occurs if everything before ic is a space\n               strend = ic\n               exit\n            endif\n         enddo\n\n      endif ! ic > 1\n\n   endif ! len_trim( str ) > maxlen\n\n\n   return\n   end subroutine findline ! ( str , maxlen , strend )\n"}, {"instruction": "Write a Fortran subroutine named get_command_argument that retrieves the value of a command-line argument based on its position. The subroutine takes 1 input parameter of type integer, which represents the desired argument number. It also has 3 output parameters: an optional integer parameter named length, which returns the length of the argument value, an optional integer parameter named status, which indicates the status of the subroutine, and an optional character parameter named value, which stores the value of the command-line argument.\n\nTo use the subroutine, call it with the desired argument number and provide the optional parameters to retrieve the corresponding values. The length parameter will return the length of the argument value, the status parameter will provide information about the success of the subroutine, and the value parameter will store the value of the command-line argument.\n\nNote that the maximum length permitted for an argument value is set to 500 characters.", "input": "", "output": "   subroutine get_command_argument ( number, value, length, status )\n\n\n      ! this routine returns the string associated with the numberth command-line argument.\n      ! it tries as best it can to mimic the fortran 2000 intrinsic function by the same name.\n\n\n      ! argument declarations.\n\n   integer, optional, intent(out)      :: length                                ! the length of the value of the environment variable.\n   integer, intent(in)                 :: number                                ! the number of the argument desired.\n   integer, optional, intent(out)      :: status                                ! the status indication what happened.\n\n   character(*), optional, intent(out) :: value                                 ! the command line argument.\n\n\n      ! local parameter declarations.\n\n   integer, parameter                  :: maxlen = 500                          ! the maximum length permitted for an environment variable value.\n\n\n      ! local declarations.\n\n   integer                             :: callstat                              ! the status of the intrinsic call.\n\n   character(maxlen)                   :: returnval                             ! the value that will be returned.\n\n\n\n      ! get the argument.\n\n   call getarg ( number, returnval )  !20110512 jm remove 3rd arg for linux port\n\n\n      ! load up the return values.\n\n   if ( present( value  ) )  value  = returnval\n   if ( present( length ) )  length = len_trim( returnval )\n   if ( present( status ) )  status = callstat\n\n\n   return\n   end subroutine get_command_argument ! ( number, value, length, status )\n"}, {"instruction": "Create a Fortran subroutine named ecmat to calculate the element-wise matrix multiplication. The subroutine takes 3 input parameters of type real(iwp), integer, and integer, and 1 output parameter of type real(iwp).", "input": "", "output": "subroutine ecmat(ecm,fun,ndof,nodof)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::fun(:)\r\n real(iwp),intent(out)::ecm(:,:)\r\n integer,intent(in)::nodof,ndof\r\n integer::nod,i,j\r\n real::nt(ndof,nodof),tn(nodof,ndof),zero=0.0_iwp\r\n nod=ndof/nodof\r\n nt=zero\r\n tn=zero\r\n do i=1,nod \r\n   do j=1,nodof\r\n     nt((i-1)*nodof+j,j)=fun(i)\r\n     tn(j,(i-1)*nodof+j)=fun(i)\r\n   end do\r\n end do\r\n ecm=matmul(nt,tn)\r\nreturn\r\nend subroutine ecmat\r\n"}, {"instruction": "Create a Fortran subroutine named getwords that takes 2 input parameters of type integer and character array and 1 output parameter of type character array. The subroutine extracts words from the given string based on spaces, tabs, commas, semicolons, single quotes, and double quotes.", "input": "", "output": "subroutine getwords ( line, words, numwords )\n\n    ! argument declarations.\n\n    integer, intent(in)          :: numwords                                     !< the number of words to look for.\n\n    character(*), intent(in)     :: line                                         !< the string to search.\n    character(*), intent(out)    :: words(numwords)                              !< the array of found words.\n\n\n        ! local declarations.\n\n    integer                      :: ch                                           ! character position within the string.\n    integer                      :: iw                                           ! word index.\n    integer                      :: nextwhite                                    ! the location of the next whitespace in the string.\n    character(1), parameter       :: tab      = char( 9 ) \n\n\n\n        ! let's prefill the array with blanks.\n\n    do iw=1,numwords\n        words(iw) = ' '\n    end do ! iw\n\n\n        ! let's make sure we have text on this line.\n\n    if ( len_trim( line ) == 0 )  return\n\n\n        ! parse words separated by any combination of spaces, tabs, commas,\n        ! semicolons, single quotes, and double quotes (\"whitespace\").\n\n    ch = 0\n    iw = 0\n\n    do\n\n        nextwhite = scan( line(ch+1:) , ' ,!;''\"'//tab )\n\n        if ( nextwhite > 1 )  then\n\n        iw        = iw + 1\n        words(iw) = line(ch+1:ch+nextwhite-1)\n\n        if ( iw == numwords )  exit\n\n        ch = ch + nextwhite\n\n        else if ( nextwhite == 1 )  then\n\n        ch = ch + 1\n\n        cycle\n\n        else\n\n        exit\n\n        end if\n\n    end do\n\n\n    return\nend subroutine getwords\n"}, {"instruction": "Create a Fortran subroutine named create_variable_mask to generate a logical mask based on a specified value in the input data. The subroutine takes 2 input parameters of type real, dimension(:,:,:), and real, and 1 output parameter of type logical, dimension(:,:), allocatable.", "input": "", "output": "    subroutine create_variable_mask(mask, input_data, mask_value)\n        implicit none\n        logical, dimension(:,:),   intent(out), allocatable  :: mask\n        real,    dimension(:,:,:), intent(in) :: input_data\n        real,                      intent(in) :: mask_value\n\n        integer :: nx, ny\n\n        nx = size(input_data, 2)\n        ny = size(input_data, 3)\n\n        allocate(mask(nx,ny))\n        mask = .true.\n        where(input_data(1,:,:) == mask_value) mask = .false.\n\n    end subroutine create_variable_mask\n"}, {"instruction": "Write a Fortran subroutine named laplace2_ext to perform the Laplacian operation on a 2D array. The subroutine takes one input parameter of type real and produces one output parameter of type real. The subroutine extends the boundary values from the inner region of the input array.", "input": "", "output": "subroutine laplace2_ext(b, a)  ! perform laplacian, then the boundary values are extended out from the inner\nreal,      intent(out) :: b(:,:)\nreal,      intent(in)  :: a(:,:)  ! same size\ninteger    :: nx, nz, ix, iz\nnx = size(a,1)\nnz = size(a,2)\n!$omp parallel do private(ix)   \ndo iz = 2, nz-1\n  do ix = 2, nx-1\n    b(ix,iz) = a(ix-1,iz) + a(ix+1,iz) + a(ix,iz-1) + a(ix,iz+1) - 4.*a(ix,iz)\n  end do\n  b(1, iz) = b(2,   iz)\n  b(nx,iz) = b(nx-1,iz)\nend do\nb(:,1) = b(:,   2)\nb(:,nz)= b(:,nz-1)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cumsum2d to compute the cumulative sum of a 2D array along a specified dimension. The subroutine takes 2 input parameters: a real array \"a\" and an optional integer \"kdim\" indicating the dimension along which the cumulative sum will be computed. It has 1 output parameter, a real array \"b\" which stores the cumulative sum. The subroutine uses imperative programming to calculate the cumulative sum based on the specified dimension.", "input": "", "output": "subroutine cumsum2d(b,a,kdim)\n! b <--cumulative sum a, along dimension kdim\nreal, intent(out) :: b(:,:)  ! same size as a, space pre-assigned\nreal, intent(in)  :: a(:,:)\ninteger, optional, intent(in) :: kdim ! default 1\ninteger  :: d, j,k, shp(2)\n\nd  = 1;  if(present(kdim))  d = kdim\nshp= shape(a)\n\nif (d==1) then\n  do k = 1, shp(2)\n    b(1,k) = a(1,k)\n    do j=2, shp(1)\n      b(j,k) = b(j-1,k) + a(j,k)\n    end do\n  end do\nelse\n b(:,1) = a(:,1)\n do k = 2, shp(2)\n   b(:,k) = b(:,k-1) + a(:,k)\n end do\nend if\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"binnedseriesnums\" that takes in an integer array \"s\" and an integer \"wintv\" as input and calculates the number of elements falling in each interval and the cumulative sum of the counts. The number of input arguments is 2, and the test_data type is ['integer', 'integer']. The number of output arguments is 2, with test_data type ['integer', 'integer, optional'].", "input": "", "output": "subroutine binnedseriesnums(s, wintv, nss, cmsm0)\n! s is a series\n! intervals are [1, wintv] [1+wintv, 2*wintv] [1+2*wintv, 3*wintv], ...\n! find how many series elements fall in each interval --> nss\n! cumulative sum of 'nss' starting @ 0                --> cmsm0.  \n!   is the displacement of each interval's stored s's relative to the beginning\ninteger, intent(in)  :: s(:), wintv\ninteger, intent(out) :: nss(:)       ! make sure enough length\ninteger, intent(out),   optional ::  cmsm0(:)  \ninteger  :: k, i, l\nl    = size(s)\nnss  = 0  ! init.\ndo k = 1, l\n  i  = (s(k)-1)/wintv + 1  ! find interval index\n  nss(i) = nss(i) + 1\nenddo\nif (present(cmsm0)) then\n  l = size(nss)\n  cmsm0(1) = 0\n  if (l < 2) return\n  cmsm0(2) = nss(1)\n  do k = 3, l\n    cmsm0(k) = cmsm0(k-1) + nss(k-1)\n  enddo\nendif\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named stripsmallprimefactors to factorize a given integer into its smallest prime factors and a remaining prime number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "subroutine stripsmallprimefactors(a, c, b)\n! a = c b, where c = 2^m 3^n 5^o 7^p, b is a prime number > 7\ninteger, intent(in)  :: a\ninteger, intent(out) :: c, b\ninteger  :: prm(4) = (/2,3,5,7/), i, p\nc = 1;  b = a\nouter: do i = 1, 4  ! go through the 4 smallest prime numbers\n  p = prm(i)\n  inner: do\n    if ( (b/p)*p == b ) then\n      b = b/p;  c = c*p\n    else\n      exit inner\n    endif\n  enddo inner \nenddo outer\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named find_indices that takes in an array of logical values and returns the indices of the true elements. The number of input parameters is 1 with the test_data type ['logical'], and the number of output parameters is 2 with the test_data type ['integer', 'integer'].", "input": "", "output": "subroutine find_indices(ind, nfound, crit)\n  integer, intent(out) :: ind(:),  nfound   ! nfound limited by size(ind)\n  logical, intent(in)  :: crit(:)\n  \n  integer  :: nind, k\n  nind = size(ind)\n  nfound = 0\n  do k = 1, size(crit)  ! prefer head\n    if(.not. crit(k)) cycle\n    nfound = nfound + 1\n    ind(nfound) = k\n    if (nfound==nind) exit\n  end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named grid_location that takes an integer input parameter and returns two integer output parameters. The input parameter represents a position in a grid, and the subroutine calculates the corresponding row (ix) and column (iy) indices of the grid.", "input": "", "output": "  subroutine grid_location(k,ix,iy)\r\n  integer, intent(in)  :: k\r\n  integer, intent(out) :: ix,iy\r\n  !\r\n  if(mod(k,ny)==0) then !right edge\r\n    ix=k/ny\r\n    iy=ny\r\n  else !general case\r\n    ix=k/ny+1\r\n    iy=k-(ix-1)*ny\r\n  endif\r\n  end subroutine grid_location\r\n"}, {"instruction": "Create a Fortran subroutine named vector_product to compute the vector product of two 3-dimensional vectors. It takes 2 input parameters of type real arrays, v1 and v2, and 1 output parameter of type real array, vp.", "input": "", "output": "subroutine vector_product(v1,v2,vp)\n\nimplicit none\n\n! passed variables\nreal,intent(in) :: v1(3)  !< first vector\nreal,intent(in) :: v2(3)  !< second vector\nreal,intent(out) :: vp(3) !< vector product\n\n! local variable\nreal :: r\n\n! vector product\nvp(1) = v1(2)*v2(3)-v1(3)*v2(2)\nvp(2) = v1(3)*v2(1)-v1(1)*v2(3)\nvp(3) = v1(1)*v2(2)-v1(2)*v2(1)\n\n! normalization\nr = sqrt(sum(vp**2))\nif (r>0.0) vp = vp/r\n\nend subroutine vector_product\n"}, {"instruction": "Write a Fortran subroutine named elmat to calculate the elasticity matrix for quadrilateral 4- or 8-node plane strain elements. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp) array.", "input": "", "output": "subroutine elmat(area,rho,emm)\r\n!\r\n\n! quadrilateral 4- or 8-node plane strain elements.\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::area,rho  \r\n real(iwp),intent(out)::emm(:,:)\r\n real(iwp)::zero=0.0_iwp,pt2=0.2_iwp,pt25=0.25_iwp\r\n integer::i,ndof\r\n ndof=ubound(emm,1)\r\n emm=zero\r\n select case(ndof)\r\n case(8) \r\n   do i=1,8\r\n     emm(i,i)=pt25*area*rho\r\n   end do\r\n case(16)\r\n   do i=1,16\r\n     emm(i,i)=pt2*area*rho\r\n   end do\r\n   do i=1,13,4\r\n     emm(i,i)=pt25*emm(3,3)\r\n   end do\r\n   do i=2,14,4\r\n     emm(i,i)=pt25*emm(3,3)\r\n   end do                     \r\n case default\r\n   write(*,*)\"wrong number of nodes for rectangular element\"\r\n end select\r\nreturn\r\nend subroutine elmat   \r\n"}, {"instruction": "Create a Fortran subroutine named f_interp1d that takes 6 input parameters: 2 integers, 3 arrays of real(kind=8) with dimensions nz_in, and 1 real(kind=8). The output parameter is an array of real(kind=8) with dimension nz_out. The subroutine calculates the interpolation of values from one vertical coordinate to another and returns the interpolated values in V_out.", "input": "", "output": "subroutine f_interp1d(v_in,z_in,z_out,vmsg,v_out,nz_in,nz_out)\n\n    implicit none\n\n    integer,intent(in) :: nz_in, nz_out\n    real(kind=8),dimension(nz_in),intent(in) :: v_in,z_in\n    real(kind=8),dimension(nz_out),intent(in) :: z_out\n    real(kind=8),dimension(nz_out),intent(out) :: v_out\n    real(kind=8),intent(in) :: vmsg\n\n    integer :: kp,k,im,ip\n    logical :: interp\n    real(kind=8) :: height,w1,w2\n\n    ! does vertical coordinate increase of decrease with increasing k?\n    ! set offset appropriately\n\n    ip = 0\n    im = 1\n    if (z_in(1).gt.z_in(nz_in)) then\n      ip = 1\n      im = 0\n    end if\n\n    do k = 1,nz_out\n      v_out(k) = vmsg\n\n      interp = .false.\n      kp = nz_in\n      height = z_out(k)\n\n      do while ((.not.interp) .and. (kp.ge.2))\n          if (((z_in(kp-im).le.height).and.(z_in(kp-ip).gt.height))) then\n              w2 = (height-z_in(kp-im))/(z_in(kp-ip)-z_in(kp-im))\n              w1 = 1.d0 - w2\n              v_out(k) = w1*v_in(kp-im) + w2*v_in(kp-ip)\n              interp = .true.\n          end if\n          kp = kp - 1\n      end do\n    end do\n\n    return\n\nend subroutine f_interp1d\n"}, {"instruction": "Create a Fortran subroutine named f_computetk to calculate the temperature in Kelvin. The subroutine takes 3 input parameters: an integer nx, an array of real(kind=8) values for pressure with dimension nx, and an array of real(kind=8) values for theta with dimension nx. It returns an array of real(kind=8) values for tk with dimension nx.", "input": "", "output": "subroutine f_computetk(pressure,theta,tk,nx)\n\n    implicit none\n\n    integer, intent(in) :: nx\n    real(kind=8) :: pi\n    real(kind=8), dimension(nx), intent(in) :: pressure\n    real(kind=8), dimension(nx), intent(in) :: theta\n    real(kind=8), dimension(nx), intent(out) :: tk\n\n    integer :: i\n    real(kind=8), parameter :: p1000mb=100000.d0, r_d=287.d0, cp=7.d0*r_d/2.d0\n\n    do i = 1,nx\n        pi = (pressure(i)/p1000mb)**(r_d/cp)\n        tk(i) = pi*theta(i)\n    end do\n\n    return\n\nend subroutine f_computetk\n"}, {"instruction": "Write a Fortran subroutine named f_computetd to calculate the dew point temperature from the input pressure and specific humidity. The subroutine takes 3 input parameters of type integer, real(kind=8) arrays of dimension nx, and returns 1 output parameter of type real(kind=8) array of dimension nx. The subroutine uses an iterative calculation to compute the dew point temperature based on the input pressure and specific humidity values.", "input": "", "output": "subroutine f_computetd(pressure,qv_in,td,nx)\n\n    implicit none\n\n    integer, intent(in) :: nx\n    real(kind=8),dimension(nx),intent(in) :: pressure\n    real(kind=8),dimension(nx),intent(in) :: qv_in\n    real(kind=8),dimension(nx),intent(out) :: td\n\n    real(kind=8) :: qv,tdc\n\n    integer :: i\n\n    do i = 1,nx\n      qv = dmax1(qv_in(i),0.d0)\n      ! vapor pressure\n      tdc = qv*pressure(i)/ (.622d0 + qv)\n\n      ! avoid problems near zero\n      tdc = dmax1(tdc,0.001d0)\n      td(i) = (243.5d0*log(tdc)-440.8d0)/ (19.48d0-log(tdc))\n    end do\n\n    return\n\nend subroutine f_computetd\n"}, {"instruction": "Create a Fortran subroutine named f_computeeth to calculate the equivalent potential temperature for atmospheric data. The subroutine takes 6 input parameters of type real(kind=8), dimension(miy,mjx,mkzh), real(kind=8), dimension(miy,mjx,mkzh), real(kind=8), dimension(miy,mjx,mkzh), integer, integer, and integer. It also has 1 output parameter of type real(kind=8), dimension(miy,mjx,mkzh).", "input": "", "output": "subroutine f_computeeth(qvp,tmk,prs,eth,miy,mjx,mkzh)\n\n    implicit none\n\n    ! input variables\n    ! qvapor [g/kg]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: qvp\n    ! temperature [k]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: tmk\n    ! full pressure (=p+pb) [hpa]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: prs\n    !\n    ! output variable\n    ! equivalent potential temperature [k]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(out) :: eth\n    ! sizes\n    integer,intent(in) :: miy,mjx,mkzh\n\n    ! local variables\n    real(kind=8) :: q\n    real(kind=8) :: t\n    real(kind=8) :: p\n    real(kind=8) :: e\n    real(kind=8) :: tlcl\n    integer :: i,j,k\n\n    ! parameters\n    real(kind=8),parameter :: eps = 0.622d0\n    real(kind=8),parameter :: rgas = 287.04d0\n    real(kind=8),parameter :: rgasmd = .608d0\n    real(kind=8),parameter :: cp = 1004.d0\n    real(kind=8),parameter :: cpmd = .887d0\n    real(kind=8),parameter :: gamma = rgas/cp\n    real(kind=8),parameter :: gammamd = rgasmd - cpmd\n    real(kind=8),parameter :: tlclc1 = 2840.d0\n    real(kind=8),parameter :: tlclc2 = 3.5d0\n    real(kind=8),parameter :: tlclc3 = 4.805d0\n    real(kind=8),parameter :: tlclc4 = 55.d0\n    real(kind=8),parameter :: thtecon1 = 3376.d0\n    real(kind=8),parameter :: thtecon2 = 2.54d0\n    real(kind=8),parameter :: thtecon3 = .81d0\n\n    do k = 1,mkzh\n      do j = 1,mjx\n          do i = 1,miy\n              q = max(qvp(i,j,k),1.d-15)\n              t = tmk(i,j,k)\n              p = prs(i,j,k)/100.\n              e = q*p / (eps+q)\n              tlcl = tlclc1 / (log(t**tlclc2/e)-tlclc3) + tlclc4\n              eth(i,j,k) = t * (1000.d0/p)**(gamma * (1.d0+gammamd*q))*&\n                        exp((thtecon1/tlcl-thtecon2)*q*(1.d0+thtecon3*q))\n          end do\n      end do\n    end do\n\n    return\n\nend subroutine f_computeeth\n"}, {"instruction": "Write a Fortran subroutine named rotatecoords to perform coordinate rotation. The number of input arguments is 6 with test_data type ['real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'integer'], and the number of output arguments is 2 with test_data type ['real(kind=8)', 'real(kind=8)']. The subroutine uses input coordinates, a reference point, and a rotation direction to calculate the rotated latitude and longitude coordinates.", "input": "", "output": "subroutine rotatecoords(ilat,ilon,olat,olon,lat_np,lon_np,lon_0,direction)\n\n    implicit none\n\n    real(kind=8),intent(in) :: ilat,ilon\n    real(kind=8),intent(out) :: olat,olon\n    real(kind=8),intent(in) :: lat_np,lon_np,lon_0\n    integer,intent(in) :: direction\n\n    !  >=0, default : computational -> geographical\n    !  < 0          : geographical  -> computational\n\n    real(kind=8) :: rlat,rlon\n    real(kind=8) :: phi_np,lam_np,lam_0,dlam\n    real(kind=8) :: sinphi,cosphi,coslam,sinlam\n    real(kind=8),parameter :: pi=3.141592653589793d0\n    real(kind=8),parameter :: rad_per_deg=pi/180.d0\n    real(kind=8),parameter :: deg_per_rad=180.d0/pi\n\n    !convert all angles to radians\n    phi_np = lat_np*rad_per_deg\n    lam_np = lon_np*rad_per_deg\n    lam_0 = lon_0*rad_per_deg\n    rlat = ilat*rad_per_deg\n    rlon = ilon*rad_per_deg\n\n    if (direction.lt.0) then\n    ! the equations are exactly the same except for one\n    ! small difference with respect to longitude ...\n      dlam = pi - lam_0\n    else\n      dlam = lam_np\n    end if\n\n    sinphi = cos(phi_np)*cos(rlat)*cos(rlon-dlam) + sin(phi_np)*sin(rlat)\n    cosphi = sqrt(1.d0-sinphi*sinphi)\n    coslam = sin(phi_np)*cos(rlat)*cos(rlon-dlam) - cos(phi_np)*sin(rlat)\n    sinlam = cos(rlat)*sin(rlon-dlam)\n\n    if (cosphi.ne.0.d0) then\n      coslam = coslam/cosphi\n      sinlam = sinlam/cosphi\n    end if\n\n    olat = deg_per_rad*asin(sinphi)\n    olon = deg_per_rad*(atan2(sinlam,coslam)-dlam-lam_0+lam_np)\n\n    return\n\nend subroutine rotatecoords\n"}, {"instruction": "Create a Fortran subroutine named lininterp to perform linear interpolation of the (x, y) data at specified points xi. The subroutine takes 5 input parameters of types integer, integer, double precision, double precision, and double precision, and 1 output parameter of type double precision. The subroutine requires x to be sorted in ascending order and extrapolates out of range. Use imperative tone while providing the instructions.", "input": "", "output": "subroutine lininterp (n,x,y,ni,xi,yi)\n!this does linear interpolation of (x,y) at points xi\n!requires x to be sorted in ascending order\n!extrapolates out of range\nimplicit none\ninteger, intent(in)\t\t:: n,ni\ndouble precision, intent(in)\t:: x(:),y(:),xi(:)\ndouble precision, intent(out)\t:: yi(:)\ndouble precision, dimension(ni)\t:: xl,xh,yl,yh\ninteger\t\t\t\t\t:: i,locl(ni)\n\n\ndo i = 1,ni\n\n\tlocl(i) = maxloc(x,1,mask=xi(i)>x)\n\t\n\tif (xi(i)<=x(1)) then\n\t\tlocl(i) = 1\n\tend if\n\n\tif (locl(i)>=n) then \n\t\tlocl(i) = n-1\n\tend if\n\n\n\txl(i) = x(locl(i))\n\txh(i) = x(locl(i)+1)\n\tyl(i) = y(locl(i))\n\tyh(i) = y(locl(i)+1)\n\t\n\tyi(i) = yl(i) + (xi(i)-xl(i))*((yh(i)-yl(i))/(xh(i)-xl(i)))\n\nend do\n\n\nend subroutine lininterp\n"}, {"instruction": "Create a Fortran subroutine named randomdiscrete to generate nout random draws from the integers 1 to nin using probabilities in pin. The number of input arguments is 3, and the test_data type is ['integer', 'integer', 'double precision']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "subroutine randomdiscrete(nout,xout,nin,pin)\n!generates nout random draws from the integers 1 to nin\n!using probabilities in pin\nimplicit none\ninteger, intent(in)\t\t\t:: nout,nin\ninteger,intent(out)\t\t:: xout(:)\ndouble precision, intent(in)  :: pin(:)\n\ninteger\t\t\t::i1,i2\ndouble precision      :: lran(nout)\n\n!if(sum(pin) .ne. 1.0) write(*,*) 'error in randomdiscrete: pin doesnt sum to 1.0'\n\ncall random_number(lran)\n\nxout(:) = 0\ndo i1 = 1,nout\n    if ( lran(i1) .le. pin(1) ) then\n        xout(i1) = 1\n    else\n        i2 = 2\n        do while (i2 .le. nin)\n            if ( (lran(i1) .le. sum(pin(1:i2)) ).and. (lran(i1) > sum(pin(1:i2-1)) ) ) then\n                xout(i1) = i2\n                i2 = nin+1\n            else\n                i2 = i2+1\n            end if\n        end do\n    end if\nend do\n\nend subroutine randomdiscrete\n"}, {"instruction": "Create a Fortran subroutine named discretedist that takes random numbers and a probability distribution over integers 1 to nin as input. It returns the corresponding values. The number of input arguments is 4 with test_data types ['integer', 'integer', 'double precision', 'double precision'], and the number of output arguments is 1 with test_data type ['integer'].", "input": "", "output": "subroutine discretedist(nout,xout,nin,pin,lran)\n!takes in random numbers and a prob dist over the integers 1 to nin\n!and returns the corresponding values\n!created 11/22/09 - ers\n\ninteger,    intent(out) :: xout(:)\ninteger,    intent(in)  :: nin,nout\ndouble precision,    intent(in)  :: pin(:)\ndouble precision, intent(in)  :: lran(:)\ninteger\t\t\t        :: i1,i2\n\nxout(:) = 0\ndo i1 = 1,nout\n    if ( lran(i1) .le. pin(1) ) then\n        xout(i1) = 1\n    else\n        i2 = 2\n        do while (i2 .le. nin)\n            if ( (lran(i1) .le. sum(pin(1:i2)) ).and. (lran(i1) > sum(pin(1:i2-1)) ) ) then\n                xout(i1) = i2\n                i2 = nin+1\n            else\n                i2 = i2+1\n            end if\n        end do\n    end if\nend do\n\nend subroutine discretedist\n"}, {"instruction": "Create a Fortran subroutine named discretedist1 that takes in an integer, an array of double precision, and a double precision number as input. It returns an integer value based on the random number and probability distribution over the integers 1 to nin. The number of input arguments is 3 and the test_data type is ['integer', 'double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine discretedist1(xout,nin,pin,lran)\n!takes in a random number and a prob dist over the integers 1 to nin\n!and returns the corresponding value\n\ninteger, intent(in)     :: nin\ninteger,intent(out)     :: xout\ndouble precision, intent(in)     :: pin(:),lran\ninteger                 :: i2\n\nxout = 0\nif ( lran .le. pin(1) ) then\n   xout = 1\nelse\n   i2 = 2\n   do while (i2 .le. nin)\n       if ( (lran .le. sum(pin(1:i2)) ).and. (lran > sum(pin(1:i2-1)) ) ) then\n           xout = i2\n           i2 = nin+1\n       else\n           i2 = i2+1\n       end if\n   end do\nend if\n\nend subroutine discretedist1\n"}, {"instruction": "Create a Fortran subroutine named rouwenhorst to perform the Rouwenhorst method for discretizing an AR(1) process. The subroutine takes 3 input parameters of types integer, double precision, and double precision, and provides 1 output parameter of type double precision.", "input": "", "output": "subroutine rouwenhorst(n,p,q,r)\nimplicit none\ninteger, intent(in)\t\t:: n\ndouble precision, intent(in)\t:: p,q\ndouble precision, intent(out)\t:: r(n,n)\ndouble precision\t\t\t\t:: x(n,n), y1(n,n), y2(n,n), y3(n,n), y4(n,n)\ninteger\t\t\t\t\t:: j,i\n\nx(1,1) = p\nx(1,2) = 1-p\nx(2,1) = 1-q\nx(2,2) = q\n\nif(n>2) then\ndo j = 2,n-1\n\ty1(:,:) = 0.0\n\ty2(:,:) = 0.0\n\ty3(:,:) = 0.0\n\ty4(:,:) = 0.0\n\ty1(1:j,1:j) = x(1:j,1:j)\n\ty2(1:j,2:j+1) = x(1:j,1:j)\n\ty3(2:j+1,1:j) = x(1:j,1:j)\n\ty4(2:j+1,2:j+1) = x(1:j,1:j)\n\tx = p*y1 + (1-p)*y2 + (1-q)*y3 + q*y4\n\tdo i = 2,j\n\t\tx(i,:) = x(i,:)/2.0\n\tend do\nend do\n\nend if\nr = x\n\nend subroutine rouwenhorst\n"}, {"instruction": "Create a Fortran subroutine named get_periodic_derivative to calculate the periodic derivative of a function. This subroutine takes 2 input parameters of type real, dimension(:) and 1 output parameter of type real, dimension(:). The subroutine extends the input function using periodicity and then computes the derivative using finite differences.", "input": "", "output": "   subroutine get_periodic_derivative(f, x, dfdx)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: f, x\n      real, dimension(:), intent(out) :: dfdx\n\n      integer :: i, n\n      real, dimension(:), allocatable :: fp\n\n      n = size(x)\n\n      allocate (fp(-1:n + 2))\n      ! extend f using periodicity, as these additional points\n      ! required near boundaries for finite differences\n      fp(1:n) = f\n      fp(-1:0) = f(n - 1:n)\n      fp(n + 1:n + 2) = f(1:2)\n\n      do i = 1, n\n         dfdx(i) = (0.25 * (fp(i - 2) - fp(i + 2)) + 2.0 * (fp(i + 1) - fp(i - 1))) / 3.0\n      end do\n\n      deallocate (fp)\n\n   end subroutine get_periodic_derivative\n"}, {"instruction": "Write a Fortran subroutine named \"legendre\" to compute the Legendre polynomials up to degree \"n\" for the given input array \"x\". The number of input parameters is 1, and the test_data type is ['real, dimension(:)']. The number of output parameters is 1, and the test_data type is ['real, dimension(:, 0:)']. Use an imperative tone in the instructions.", "input": "", "output": "   subroutine legendre(x, legp)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: x\n      real, dimension(:, 0:), intent(out) :: legp\n\n      integer :: n, idx\n\n      n = size(legp, 2) - 1\n\n      legp(:, 0) = 1.0\n      legp(:, 1) = x\n\n      do idx = 2, n\n         legp(:, idx) = ((2.*idx - 1.) * x * legp(:, idx - 1) + (1.-idx) * legp(:, idx - 2)) / idx\n      end do\n\n   end subroutine legendre\n"}, {"instruction": "Create a Fortran subroutine named legendre_transform to perform a Legendre transform using the provided Legendre polynomials and coefficients. The subroutine takes 2 input parameters of type real, dimension(:, 0:) and real, dimension(:), and 1 output parameter of type real, dimension(:).", "input": "", "output": "   subroutine legendre_transform(legp, coefs, func)\n\n      implicit none\n\n      real, dimension(:, 0:), intent(in) :: legp\n      real, dimension(:), intent(in) :: coefs\n      real, dimension(:), intent(out) :: func\n\n      integer :: i\n\n      func = 0.\n      do i = 1, size(coefs)\n         func = func + legp(:, i - 1) * coefs(i)\n      end do\n\n   end subroutine legendre_transform\n"}, {"instruction": "Create a Fortran subroutine named prod that calculates the product of two real numbers. The subroutine takes 2 input parameters of type real and returns 1 output parameter of type real.", "input": "", "output": "subroutine prod(x, y, result)\nimplicit none\n  real, intent(in) :: x, y\n  real, intent(out) :: result\n  result = x * y\nend subroutine prod\n"}, {"instruction": "Create a Fortran subroutine named \"sum\" to compute the sum of two real numbers. The subroutine should have 2 input parameters of type real, and 1 output parameter of type real. When invoked, the subroutine should calculate the sum of the input parameters and store the result in the output parameter.", "input": "", "output": "subroutine sum(x, y, result)\nimplicit none\n  real, intent(in) :: x, y\n  real, intent(out) :: result\n  result = x + y\nend subroutine sum\n"}, {"instruction": "Create a Fortran subroutine named get_basis to generate basis sets for quantum chemistry calculations. The subroutine takes 2 input parameters of type integer: nmax and lmax. It returns 3 output parameters of type integer, each of which is allocatable: nlist, llist, and mlist. The subroutine dynamically allocates memory for the arrays nlist, llist, and mlist based on the input parameters nmax and lmax, and populates these arrays with values representing the quantum numbers n, l, and m for quantum chemistry calculations.", "input": "", "output": "subroutine get_basis(nmax, lmax, nlist, llist, mlist)\ninteger, intent(in) :: nmax, lmax\ninteger, allocatable, intent(out) :: nlist(:), llist(:), mlist(:)\ninteger :: i, n, l, m, a\na = nmax * (lmax+1)**2\nallocate(nlist(a), llist(a), mlist(a))\ni = 1\ndo n = 1, nmax\n    do l = 0, lmax\n        do m = -l, l\n            nlist(i) = n\n            llist(i) = l\n            mlist(i) = m\n            i = i + 1\n        end do\n    end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named formke that assembles a stiffness matrix for a finite element problem. The subroutine takes 4 input parameters of type real(iwp) and produces 1 output parameter of type real(iwp). The input parameters are km (stiffness matrix), kp (pressure matrix), c (damping matrix), and theta. The output parameter is ke (assembled stiffness matrix). The subroutine uses the imperative tone to perform the assembly of the stiffness matrix based on the input parameters.", "input": "", "output": "subroutine formke(km,kp,c,ke,theta)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::km(:,:),kp(:,:),c(:,:),theta\n real(iwp),intent(out)::ke(:,:)\n integer::ndof\n ndof=ubound(km,1)\n ke(:ndof,:ndof)=km \n ke(:ndof,ndof+1:)=c\n ke(ndof+1:,:ndof)=transpose(c) \n ke(ndof+1:,ndof+1:)=-theta*kp\nreturn  \nend subroutine formke\n"}, {"instruction": "Create a Fortran subroutine named regres to perform a revised version of the algorithm as 75.4 from the applied statistics journal. The subroutine takes 4 input parameters of types integer, integer, real array, and real array, and returns 1 output parameter of type real. The subroutine implements a triangular system using the provided input parameters to calculate the beta coefficients.", "input": "", "output": "subroutine regres(np,nrbar,rbar,thetab,beta)\r\n\r\n!   algorithm as 154.4  appl. statist. (1980) vol.29, p.311\r\n\r\n!   revised version of algorithm as 75.4\r\n!   appl. statist. (1974) vol.23, p.448\r\n\n!   in the triangular system rbar and thetab.\r\n\r\ninteger, intent(in)  :: np\r\ninteger, intent(in)  :: nrbar\r\nreal, intent(in)     :: rbar(:)\r\nreal, intent(in)     :: thetab(:)\r\nreal, intent(out)    :: beta(:)\r\n\r\nreal     :: bi\r\ninteger  :: i, i1, im, ithisr, j, jm\r\n\r\nithisr = nrbar\r\nim = np\r\ndo  i = 1, np\r\n  bi = thetab(im)\r\n  if (im /= np) then\r\n    i1 = i - 1\r\n    jm = np\r\n    do  j = 1, i1\r\n      bi = bi - rbar(ithisr) * beta(jm)\r\n      ithisr = ithisr - 1\r\n      jm = jm - 1\r\n    end do\r\n  end if\r\n  beta(im) = bi\r\n  im = im - 1\r\nend do\r\n\r\nreturn\r\nend subroutine regres\r\n"}, {"instruction": "Create a Fortran subroutine named f that takes a single input of type real and returns a single output of type real. The subroutine calculates the product of the sine and cosine of the input value and assigns it to the output variable.", "input": "", "output": "  pure subroutine f(x,y)\n    real, intent(in) :: x\n    real, intent(out) :: y\n    y = sin(x)*cos(x)\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named fill_array to calculate the sum of an array of real numbers. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real. The input parameter represents the size of the array, and the output parameter holds the sum of the array values.", "input": "", "output": "subroutine fill_array( n, sumofvalues )\r\n    integer, intent(in) :: n\r\n    real, intent(out)   :: sumofvalues\r\n\r\n    real, dimension(n) :: array\r\n\r\n    array = 1.0\r\n\r\n    sumofvalues = sum(array)\r\nend subroutine fill_array\r\n"}, {"instruction": "Implement a Fortran subroutine named getgamma to calculate the gamma values based on given input parameters. The number of input arguments is 8, with the following test_data types: ['integer', 'integer', 'real(8), dimension(n)', 'real(8), dimension(m)', 'real(8), dimension(m)', 'integer, dimension(n,m)', 'real(8), dimension(m,m)', 'real(8)']. The number of output arguments is 1, with the test_data type: ['real(8), dimension(n)'].\n\nThe subroutine takes in the input parameters n, m, x, rk, qk, vk, amk, and t. The subroutine performs calculations based on these parameters to determine the gamma values, and stores them in the output parameter gamma1.\n\nTo execute the subroutine, call the subroutine getgamma and pass the necessary input parameters. The subroutine will then compute the gamma values and store them in the output parameter gamma1.", "input": "", "output": "subroutine getgamma(x, t, n, m, amk, vk, rk, qk, gamma1)\n    implicit none\n\n    integer, intent(in) :: n, m\n    real(8), dimension(n), intent(in) :: x\n    real(8), dimension(m), intent(in) :: rk, qk\n    integer, dimension(n,m), intent(in) :: vk\n    real(8), dimension(m,m), intent(in) ::amk\n    real(8), intent(in) :: t\n    real(8), dimension(n), intent(out) :: gamma1\n    integer :: ii, kk\n    real(8) :: sum_rx, sum_qx\n\n    real(8) :: r(n), q(n), e(m,n), beta(n,m), theta(m), s(m),l(n),j(n),ln_gamma_c(n), ln_gamma_r(n), tau(m,m)\n\n    tau = exp(-amk/t) \n\n    do ii=1,n\n        r(ii) = sum(vk(ii,:)*rk(:))\n        q(ii) = sum(vk(ii,:)*qk(:))\n    enddo\n\n    sum_rx = sum(x*r)\n    sum_qx = sum(x*q)\n\n    ! r, q\n    do ii=1,n \n        e(:, ii) = vk(ii,:)*qk(:)/q(ii)\n    enddo\n\n    ! beta\n    do ii=1, n\n        do kk=1, m\n            beta(ii,kk) = sum(e(:,ii)*tau(:,kk))\n        end do\n    end do\n\n    do kk=1,m\n        theta(kk) = sum(x*q*e(kk,:))\n    end do\n    theta = theta/sum_qx\n\n    do kk=1,m\n        s(kk) = sum(theta*tau(:,kk))\n    end do\n\n    j = r/sum_rx\n    l = q/sum_qx\n    ln_gamma_c = 1.0_8 - j + log(j) - 5.0_8*q*(1.-j/l+log(j/l))\n\n    do ii=1,n\n        ln_gamma_r(ii) = q(ii)*(1.0_8 - sum(theta*beta(ii,:)/s - e(:,ii)*log(beta(ii,:)/s)))\n    end do\n\n    gamma1 = exp(ln_gamma_c + ln_gamma_r)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named vdmul that performs element-wise multiplication of two arrays of real numbers. The number of input arguments is 3 and the test_data types are ['integer', 'real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(:)'].", "input": "", "output": "    subroutine vdmul(n, a, b, y)\n        integer, intent(in) :: n\n        real, dimension(:), intent(in) :: a, b\n        real, dimension(:), intent(out) :: y\n        integer :: ii\n        y = a * b\n    end subroutine vdmul\n"}, {"instruction": "Write a Fortran subroutine named vdtanh that calculates the hyperbolic tangent function for each element of a given input array and stores the results in an output array. The number of input parameters is 2, where the first parameter is an integer representing the size of the array, and the second parameter is a two-dimensional real array. The number of output parameters is 1, which is a two-dimensional real array as well.", "input": "", "output": "    subroutine vdtanh(n, a, y)\n        integer, intent(in) :: n\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:,:), intent(out) :: y\n        y = tanh(a)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named prime_factorization that computes the prime factorization of an input integer. The subroutine takes one input argument of type integer and one output argument of type integer array. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].\n\nIn the subroutine, the input integer is factorized into its prime factors and stored in the output integer array. The output array is initialized with zeros before the factorization process begins. The first element of the output array is set to 1. \n\nThe subroutine uses a nested loop to iteratively divide the input integer by prime numbers starting from 2. If a prime number is a factor of the input integer, the output array is updated to reflect the number of times that prime number appears as a factor. The loop continues until the input integer is reduced to 1.\n\nThe prime factorization is performed in-place, modifying the output integer array directly.", "input": "", "output": "  subroutine prime_factorization( n_in, ifact )\n    implicit none\n    integer,intent(in)  :: n_in\n    integer,intent(out) :: ifact(:)\n    integer :: n,i,j,m\n    ifact(:)=0\n    ifact(1)=1\n    n = n_in\n    m = n\n    loop_j : do j = 1, n_in\n      loop_i : do i = 2, n\n        if ( mod(m,i) == 0 ) then\n          m = m/i\n          ifact(i) = ifact(i) + 1\n          exit loop_i\n        else if ( i == n ) then\n          exit loop_j\n        end if\n      end do loop_i\n      n = m\n    end do loop_j\n  end subroutine prime_factorization\n"}, {"instruction": "Write a Fortran subroutine named get_a_dimensions that calculates the number and dimensions of orbitals based on input parameters. The number of input parameters is 4, with test_data types being ['integer', 'integer', 'integer', 'integer']. The number of output parameters is 3, with test_data types being ['integer', 'integer', 'integer'].\n\nThis subroutine takes in the following input parameters:\n- iso: an integer representing a value\n- natom: an integer representing the number of atoms\n- nl: an array of integers with size natom\n- ll: a 2D array of integers with size (natom, 4)\n\nThe subroutine calculates the following output parameters:\n- norbitals: an integer representing the number of orbitals\n- maxdim2: an integer representing the maximum dimension of orbitals\n- lmaxp: an integer representing the maximum value of l\n\nTo compute these values, the subroutine iterates over the atoms and their cases. For each case, it calculates the number of orbitals, the dimension, and the maximum value of l. The subroutine updates the output parameters accordingly.", "input": "", "output": "subroutine get_a_dimensions(norbitals, maxdim2, lmaxp, iso, natom, nl, ll)\n  implicit none\n  integer, intent(out) :: norbitals, maxdim2, lmaxp\n  integer, intent(in)  :: iso, natom, nl(natom), ll(natom,4) \n  ! locals\n  integer::  icase, lcase, l1, nind\n  norbitals=0 !-- number of atom/l cases, called orbitals -------------------------------------!\n  maxdim2=0\n  lmaxp=0\n  do icase=1,natom\n     do lcase=1,nl(icase)\n        norbitals = norbitals+1\n        l1 = ll(icase,lcase)\n        nind=(2*l1+1)*iso\n        maxdim2 = max(maxdim2, nind )\n        lmaxp = max(l1,lmaxp)\n     enddo\n  enddo\nend subroutine get_a_dimensions\n"}, {"instruction": "Write a Fortran subroutine named dircos that computes the direction cosines (a, b, c) based on the input inclination, declination, and azimuth angles. The number of input arguments is 3, and their data type is ['double precision', 'double precision', 'double precision']. The number of output arguments is also 3, and their data type is ['double precision', 'double precision', 'double precision']. The subroutine uses the Fortran keywords \"double precision\" and \"intent\" to specify the intention of the input and output arguments. The subroutine first converts the input angles from degrees to radians and then calculates the direction cosines (a, b, c) using trigonometric functions.", "input": "", "output": "subroutine dircos(incl, decl, azim, a, b, c)\n  double precision, intent(in) :: incl, decl, azim\n  double precision, intent(out) :: a, b, c\n\n  double precision :: xincl, xdecl, xazim\n\n  xincl = incl * d2rad\n  xdecl = decl * d2rad\n  xazim = azim * d2rad\n\n  a = dcos(xincl) * dcos(xdecl - xazim)\n  b = dcos(xincl) * dsin(xdecl - xazim)\n  c = dsin(xincl)\n\nend subroutine dircos\n"}, {"instruction": "Implement a Fortran subroutine named interpolate_2d to perform 2D interpolation. The subroutine takes 7 input parameters of type real(8), real(8), real(8), integer, integer, integer, and real(8) respectively. The input parameters are xp, x, y, fill_value, m, n_in, and n_out. The subroutine also has 1 output parameter of type real(8), named y_out. \n\nThe subroutine calculates the interpolated values for y_out based on the given input parameters using linear interpolation. The fill_value is used to initialize y_out. The subroutine iterates over each element of xp and finds the lower and upper indices in x that bound the value in xp. It then calculates the weight based on the difference between xp and x at those indices and performs the linear interpolation to compute the corresponding value in y_out. If xp matches any value in x, the corresponding value in y is assigned to y_out. \n\nTo use this subroutine, make sure to pass the appropriate input and output parameters as described.", "input": "", "output": "subroutine interpolate_2d(xp, x, y, y_out, fill_value, m, n_in, n_out)\n    implicit none\n    real(8), intent(in) :: xp(m, n_out), x(m, n_in), y(m, n_in)\n    integer, intent(in) :: m, n_in, n_out\n    real(8), intent(in) :: fill_value\n    real(8), intent(out) :: y_out(m, n_out)\n    ! locals\n    integer :: i, j, k\n    real(8) :: weight\n\n    y_out = fill_value\n\n    do i=1,m\n        do j=1,n_out\n            ! search for lower and upper indices\n            do k=1,n_in - 1\n                if  ((x(i, k) <= xp(i, j)) .and. (xp(i, j) < x(i, k+1))) then\n                    weight = (xp(i, j) - x(i, k))/(x(i, k + 1) - x(i, k))\n                    y_out(i, j) = y(i, k) * (1-weight) + y(i, k + 1) * weight\n                else if (x(i, k) == xp(i, j)) then\n                    y_out(i, j) = y(i, k)\n                else if (x(i, k + 1) == xp(i, j)) then\n                    y_out(i, j) = y(i, k + 1)\n                end if\n            end do\n        end do\n    end do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named lagrangian_polynomial_coeffs to compute the coefficients of a Lagrangian polynomial. The number of input arguments is 3: an integer npts, a real array x of dimension npts, and a real xs. The number of output arguments is 1: a real array coeffs of dimension npts.", "input": "", "output": "  subroutine lagrangian_polynomial_coeffs(npts, x, coeffs, xs)\r\n\r\n    implicit none\r\n\r\n    ! number of points to fit\r\n    integer(4), intent(in) :: npts\r\n\r\n    ! sample points to fit\r\n    real(8), dimension(npts), intent(in) :: x\r\n\r\n    ! computed coefficients\r\n    real(8), dimension(npts), intent(out) :: coeffs\r\n\r\n    ! point at which sample is taken\r\n    real(8), intent(in) :: xs\r\n\r\n    ! loop indices\r\n    integer(4) :: i, j\r\n    \r\n    ! compute the lagrangian polynomial coefficients\r\n    do i = 1, npts\r\n      coeffs(i) = 1.0d0\r\n      do j = 1, npts\r\n        if (i .eq. j) then\r\n          cycle\r\n        end if\r\n        coeffs(i) = coeffs(i) * (xs - x(j)) / (x(i) - x(j))\r\n      end do\r\n    end do\r\n\r\n  end subroutine lagrangian_polynomial_coeffs\r\n"}, {"instruction": "Create a Fortran subroutine named \"sddk_get_num_gvec\" that retrieves the number of g-vectors associated with a given g-vector id. The subroutine should take 1 input argument of type integer and provide 1 output argument of type integer to store the number of g-vectors. Use the imperative tone when defining the subroutine.", "input": "", "output": "        subroutine sddk_get_num_gvec(gvec_id, num_gvec)&\n            &bind(c, name=\"sddk_get_num_gvec\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: num_gvec\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_count_fft that takes in 1 input parameter of type integer and provides 1 output parameter of type integer. When called, this subroutine retrieves the g-vector count for Fast Fourier Transform (FFT) calculations based on the provided gvec_id.", "input": "", "output": "        subroutine sddk_get_gvec_count_fft(gvec_id, gvec_count)&\n            &bind(c, name=\"sddk_get_gvec_count_fft\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: gvec_count\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_offset_fft that takes 1 input parameter of type integer and 1 output parameter of type integer. This subroutine is intended to obtain the g-vector offset for fast Fourier transform (FFT) calculations.", "input": "", "output": "        subroutine sddk_get_gvec_offset_fft(gvec_id, gvec_offset)&\n            &bind(c, name=\"sddk_get_gvec_offset_fft\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: gvec_offset\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sddk_get_num_wave_functions\" to retrieve the number of wave functions for a given wave function ID. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "        subroutine sddk_get_num_wave_functions(wf_id, num_wf)&\n            &bind(c, name=\"sddk_get_num_wave_functions\")\n            integer,                 intent(in)  :: wf_id\n            integer,                 intent(out) :: num_wf\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_wave_functions_prime_ld with 1 input parameter of type integer and 1 output parameter of type integer. This subroutine is intended to retrieve the wave functions prime ld.", "input": "", "output": "        subroutine sddk_get_wave_functions_prime_ld(wf_id, ld)&\n            &bind(c, name=\"sddk_get_wave_functions_prime_ld\")\n            integer,                 intent(in)  :: wf_id\n            integer,                 intent(out) :: ld\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"gamma\" to calculate the gamma function for a real number input. The subroutine takes 1 input parameter of type real(kind(1d0)) and provides 1 output parameter of type real(kind(1d0)).", "input": "", "output": "  subroutine gamma(x,ga)\n!\n!       ================================================== \n!       purpose: compute gamma function \u00e2(x)  \n!       input :  x  --- argument of \u00e2(x)  \n!                       ( x is not equal to 0,-1,-2,\u00fa\u00fa\u00fa) \n!       output:  ga --- \u00e2(x)\n!       ==================================================  \n!    \n    implicit none\n    real(kind(1d0)),intent(in)::x\n    real(kind(1d0)),intent(out)::ga\n    real(kind(1d0)),dimension(26)::g\n    real(kind(1d0)),parameter::pi=3.141592653589793d0\n    real(kind(1d0))::z,r,gr\n    integer::m1,k,m\n    if (x.eq.int(x)) then\n       if (x.gt.0.0d0) then\n          ga=1.0d0\n          m1=x-1\n          do k=2,m1\n             ga=ga*k ! 10\n          enddo\n       else\n          ga=1.0d+300\n       endif\n    else\n       if (dabs(x).gt.1.0d0) then\n          z=dabs(x)\n          m=int(z)\n          r=1.0d0\n          do k=1,m\n             r=r*(z-k) ! 15\n          enddo\n          z=z-m\n       else\n          z=x\n       endif\n       g(1:26)=(/1.0d0,0.5772156649015329d0,&\n            -0.6558780715202538d0, -0.420026350340952d-1,&\n            0.1665386113822915d0,-.421977345555443d-1,&\n            -.96219715278770d-2, .72189432466630d-2,&\n            -.11651675918591d-2, -.2152416741149d-3,&\n            .1280502823882d-3, -.201348547807d-4,&\n            -.12504934821d-5, .11330272320d-5,&\n            -.2056338417d-6, .61160950d-8,&\n            .50020075d-8, -.11812746d-8,&\n            .1043427d-9, .77823d-11,&\n            -.36968d-11, .51d-12,&\n            -.206d-13, -.54d-14, .14d-14, .1d-15/)\n       gr=g(26)\n       do k=25,1,-1\n          gr=gr*z+g(k) ! 20\n       enddo\n       ga=1.0d0/(gr*z)\n       if (dabs(x).gt.1.0d0) then\n          ga=ga*r\n          if (x.lt.0.0d0) ga=-pi/(x*ga*dsin(pi*x))\n       endif\n    endif\n    return\n  end subroutine gamma\n"}, {"instruction": "Write a Fortran subroutine named \"psi\" to compute the Psi function. The subroutine takes 1 input argument of type real(kind(1d0)) and returns 1 output argument of the same type.", "input": "", "output": "  subroutine psi(x,ps)\n!\n!  ====================================== \n!      purpose: compute psi function\n!      input :  x  --- argument of psi(x) \n!      output:  ps --- psi(x)                                                                                                                                                                              \n! ======================================                                                                                                                                                              \n!\n    implicit none\n    real(kind(1d0)),intent(in)::x\n    real(kind(1d0)),intent(out)::ps\n    real(kind(1d0))::pi,el,s,xa\n    integer::n,k\n    real(kind(1d0))::a1,a2,a3,a4,a5,a6,a7,a8,x2\n    xa=dabs(x)\n    pi=3.141592653589793d0\n    el=.5772156649015329d0\n    s=0.0d0\n    if (x.eq.int(x).and.x.le.0.0) then\n       ps=1.0d+300\n       return\n    else if (xa.eq.int(xa)) then\n       n=xa\n       do k=1 ,n-1\n          s=s+1.0d0/k\n       enddo\n       ps=-el+s\n    else if (xa+.5.eq.int(xa+.5)) then\n       n=xa-.5\n       do k=1,n\n          s=s+1.0/(2.0d0*k-1.0d0) ! 20\n       enddo\n       ps=-el+2.0d0*s-1.386294361119891d0\n    else\n       if (xa.lt.10.0) then\n          n=10-int(xa)\n          do k=0,n-1\n             s=s+1.0d0/(xa+k)\n          enddo\n          xa=xa+n\n       endif\n       x2=1.0d0/(xa*xa)\n       a1=-.8333333333333d-01\n       a2=.83333333333333333d-02\n       a3=-.39682539682539683d-02\n       a4=.41666666666666667d-02\n       a5=-.75757575757575758d-02\n       a6=.21092796092796093d-01\n       a7=-.83333333333333333d-01\n       a8=.4432598039215686d0\n       ps=dlog(xa)-.5d0/xa+x2*(((((((a8*x2+a7)*x2+&\n            a6)*x2+a5)*x2+a4)*x2+a3)*x2+a2)*x2+a1)\n       ps=ps-s\n    endif\n    if (x.lt.0.0) ps=ps-pi*dcos(pi*x)/dsin(pi*x)-1.0d0/x\n    return\n  end subroutine psi\n"}, {"instruction": "Create a Fortran subroutine named feopen that opens a file specified by the input filename and reads data from it. The subroutine takes 3 input parameters of type integer, integer, and character*100, and 2 output parameters of type character*400.", "input": "", "output": "subroutine feopen(fh, filename, nat, parseline1, parseline2)\n  implicit none\n  integer, intent(in) :: fh, nat\n  character*100, intent(in) :: filename\n  character*400, intent(out) :: parseline1(nat), parseline2(nat)\n  ! locals\n  integer :: i\n  open(fh,file=filename,status='old',form='formatted')\n  do i=1,nat\n     read(fh,'(a)') parseline1(i)\n     read(fh,'(a)') parseline2(i)\n  enddo\nend subroutine feopen\n"}, {"instruction": "Write a Fortran subroutine named fewrite1 that takes 6 input parameters of types integer, integer, integer, real*8, real*8, and character*10, and 1 output parameter of type integer. The subroutine writes formatted data to a file handle. The input parameters are fh, k(3), kname, wgh, n0, nen, and the output parameter is ios.", "input": "", "output": "subroutine fewrite1(fh, k, kname, wgh, ios, n0, nen)\n  implicit none\n  integer, intent(in) :: fh, n0, nen\n  real*8, intent(in) :: k(3), wgh\n  character*10, intent(in) :: kname\n  integer, intent(out):: ios\n  !\n  write(fh,'(3e19.12,a10,2i6,f5.2)',iostat=ios) k(1),k(2),k(3),kname,n0,nen,wgh\nend subroutine fewrite1\n"}, {"instruction": "Create a Fortran subroutine named fvopen.The subroutine takes 3 input parameters of type integer, integer, and character*100, and 1 output parameter of type real*8. The purpose of the subroutine is to open a file specified by the filename, read data from the file, and store the read data into the elinear array.", "input": "", "output": "subroutine fvopen(fh, filename, nat,elinear)\n  implicit none\n  integer, intent(in) :: fh, nat\n  character*100, intent(in) :: filename\n  real*8, intent(out) :: elinear(2)\n  ! locals\n  integer :: i\n  !print *, filename\n  open(fh,file=filename,status='old',form='unformatted')\n  do i=1,nat\n     read(fh) elinear(1)  ! linearization energy\n     read(fh) elinear(2)  ! linearization energy for lo\n  enddo\nend subroutine fvopen\n"}, {"instruction": "Create a Fortran subroutine named fvwrite1 with the following functionality: It takes 6 input parameters of types integer, real*8, real*8, character*10, integer, and integer. It also has 1 output parameter of type integer. The subroutine writes the values of k(1), k(2), k(3), kname, n0, ne, and wgh to the file referenced by fh and stores the I/O status in the ios parameter.", "input": "", "output": "subroutine fvwrite1(fh, k, kname, wgh, n0, ne, ios)\n  integer, intent(in) :: fh\n  real*8, intent(in) :: k(3), wgh\n  character*10, intent(in) :: kname\n  integer, intent(in):: n0,ne\n  integer, intent(out):: ios\n  write(fh,iostat=ios) k(1),k(2),k(3),kname,n0,ne,wgh\nend subroutine fvwrite1\n"}, {"instruction": "Create a Fortran subroutine named \"extremes\" to find the maximum and minimum values in an array. The subroutine takes 2 input parameters with the types ['integer', 'real, dimension(n)'] and 4 output parameters with the types ['real, optional', 'integer, optional', 'real, optional', 'integer, optional']. This subroutine uses an imperative tone to declare the purpose and data dictionary, and it reports the results based on the optional output arguments.", "input": "", "output": "   subroutine extremes(a, n, maxval, pos_maxval, minval, pos_minval)\r\n   !\r\n   !  purpose:\r\n   !    to find the maximum and minimum values in an array, and \r\n\n   !    returns its output values in optional arguments.\r\n   !\r\n   !  record of revisions:\r\n   !       date       programmer          description of change\r\n   !       ====       ==========          =====================\r\n   !     12/08/06    s. j. chapman        original code\r\n   !\r\n   implicit none\r\n\r\n   ! data dictionary: declare calling parameter types & definitions\r\n   integer, intent(in) :: n                     ! # vals in array a\r\n   real, intent(in), dimension(n) :: a          ! input data.\r\n   real, intent(out), optional :: maxval        ! maximum value.\r\n   integer, intent(out), optional :: pos_maxval ! pos of maxval\r\n   real, intent(out), optional :: minval        ! minimum value.\r\n   integer, intent(out), optional :: pos_minval ! pos of minval\r\n   \r\n   ! data dictionary: declare local variable types & definitions\r\n   integer :: i                            ! index\r\n   real :: real_max                        ! max value\r\n   integer :: pos_max                      ! pos of max value\r\n   real :: real_min                        ! min value\r\n   integer :: pos_min                      ! pos of min value\r\n\r\n   ! initialize the values to first value in array.\r\n   real_max = a(1)\r\n   pos_max = 1\r\n   real_min = a(1)\r\n   pos_min = 1\r\n \r\n   ! find the extreme values in a(2) through a(n).\r\n   do i = 2, n\r\n      max: if ( a(i) > real_max ) then\r\n         real_max = a(i)\r\n         pos_max = i\r\n      end if max\r\n      min: if ( a(i) < real_min ) then\r\n         real_min = a(i)\r\n         pos_min = i\r\n      end if min\r\n   end do\r\n\r\n   ! report the results\r\n   if ( present(maxval) ) then\r\n      maxval = real_max\r\n   end if\r\n   if ( present(pos_maxval) ) then\r\n      pos_maxval = pos_max\r\n   end if\r\n   if ( present(minval) ) then\r\n      minval = real_min\r\n   end if\r\n   if ( present(pos_minval) ) then\r\n      pos_minval = pos_min\r\n   end if\r\n\r\n   end subroutine extremes\r\n"}, {"instruction": "Create a Fortran subroutine named hmc_tools_generic_setunit to search for an available unit within a specified range of unit numbers. The subroutine takes 2 input parameters of type integer (kind = 4) to define the minimum and maximum unit numbers to search, and 1 output parameter of type integer (kind = 4) to store the found unit number.", "input": "", "output": "    subroutine hmc_tools_generic_setunit(ifileunitmin, ifileunitmax, ifileunit)\n        \n        !------------------------------------------------------------------------------------------\n        ! variable(s) declaration \n        logical                         :: bisused\n        integer(kind = 4), intent(in)   :: ifileunitmin, ifileunitmax\n        integer(kind = 4), intent(out)  :: ifileunit\n        integer(kind = 4)               :: ifileunitinit\n        !------------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------------\n        ! search debug unit\n        do ifileunitinit = ifileunitmin, ifileunitmax\n            inquire(unit = ifileunitinit, opened = bisused)\n            if (.not. bisused) exit\n        end do\n        !------------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------------\n        ! pass to global variables\n        ifileunit = ifileunitinit\n        !------------------------------------------------------------------------------------------\n        \n    end subroutine hmc_tools_generic_setunit\n"}, {"instruction": "Create a Fortran subroutine named mpi_add_error_code_f08 to add error codes to an error class. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer and integer (optional).", "input": "", "output": "    subroutine mpi_add_error_code_f08(errorclass, errorcode, ierror)\n        implicit none\n        integer, intent(in) :: errorclass\n        integer, intent(out) :: errorcode\n        integer, optional, intent(out) :: ierror\n    end subroutine mpi_add_error_code_f08\n"}, {"instruction": "Create a Fortran subroutine named fitchk to compare two sets of real numbers representing functions. The subroutine takes 2 input parameters of type real arrays and 3 output parameters of type real. The purpose of this subroutine is to calculate the average, root mean square, and maximum difference between the elements of the input arrays f1 and f2.", "input": "", "output": "      subroutine fitchk(f1,f2,av,rms,dmx)\n!     ************************************************\n!     compare functions f1 and f2\n!     ************************************************\n      implicit none\n      real,intent(out):: av,dmx,rms\n      real,intent(in):: f1(:),f2(:)\n!     .. local scalars ..\n      real d\n      integer i\n\n      av = 0.\n      rms = 0.\n      dmx = 0.\n      do  i = 1,size(f1)\n         av = av + f1(i)\n         d = (f1(i)-f2(i))**2\n         dmx = max(d,dmx)\n         rms = rms + d\n      enddo\n      av = av/size(f1)\n      if (abs(av).lt.1.e-30) then\n         rms = 0.\n         dmx = 0.\n         return\n      end if\n      rms = sqrt(rms/size(f1))/av*100.\n      dmx = sqrt(dmx)/av*100.\n      end subroutine \n"}, {"instruction": "Create a Fortran subroutine named split_string to separate a string into substrings using a specified delimiter. The subroutine takes 2 input parameters of type character (len = *) and character, and 2 output parameters of type character (len = *) and integer.", "input": "", "output": "subroutine split_string(string, delimiter, substrings, substring_count)\r\n    implicit none\r\n\r\n    character (len = *), intent(in)  :: string\r\n    character,           intent(in)  :: delimiter\r\n    character (len = *), intent(out) :: substrings(*)\r\n    integer,             intent(out) :: substring_count\r\n\r\n    integer :: start_position, end_position\r\n\r\n\r\n    start_position  = 1\r\n    substring_count = 0\r\n\r\n    do\r\n        end_position = index(string(start_position:), delimiter)\r\n\r\n        substring_count = substring_count + 1\r\n\r\n        if (end_position == 0) then\r\n            substrings(substring_count) = string(start_position:)\r\n            exit\r\n        else\r\n            substrings(substring_count) = string(start_position : start_position + end_position - 2)\r\n            start_position = start_position + end_position\r\n        end if\r\n    end do\r\n\r\n\r\n    return\r\nend subroutine split_string\r\n"}, {"instruction": "Create a Fortran subroutine named mult that takes 3 input parameters: two integers and an array of real*8. The output parameter is an array of real*8. The subroutine calculates the square of each element in the input array and sums them up to produce the output array.", "input": "", "output": "subroutine mult(nx, ny, x, y)\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: x(nx)\n  real*8, intent(out) :: y(ny)\n\n  integer :: i, j\n\n  y(:) = 0.\n\n  do j=1,ny\n    do i=1,nx\n      y(j) = y(j) + x(i)**2\n    end do\n  end do\n\nend subroutine mult\n"}, {"instruction": "Create a Fortran subroutine named int_to_string that takes an integer argument and converts it into an equivalent string. The subroutine should have 1 input parameter with the test_data type ['integer'], and 1 output parameter with the test_data type ['character(len=*)'].", "input": "", "output": "  subroutine int_to_string(arg, str)\r\n    ! converts an integer argument into an equivalent string\r\n    implicit none\r\n    integer, intent(in) :: arg\r\n    character(len=*), intent(out) :: str\r\n    character(len=20) :: tmp   ! to prevent i/o errors\r\n    write(tmp, *) arg\r\n    str = adjustl(tmp)\r\n  end subroutine int_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named real_to_string to convert a real number into a string. The subroutine should take 1 input parameter of type real and produce 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine real_to_string(arg, str)\r\n    ! converts a real argument into a string\r\n    implicit none\r\n    real, intent(in) :: arg\r\n    character(len=*), intent(out) :: str\r\n    character(len=20) :: tmp   ! to prevent i/o errors\r\n    write(tmp, *) arg\r\n    str = adjustl(tmp)\r\n  end subroutine real_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named average to calculate the average of an array of real numbers. The subroutine should have 1 input parameter of type real, dimension(:) and intent(in), and 1 output parameter of type real and intent(out).", "input": "", "output": "\tsubroutine average(inp, avg)\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: avg\n\t  avg = sum(inp) / size(inp)\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"variance\" to calculate the variance of a set of real numbers. The subroutine must take an array of real numbers as input with the test_data type ['real, dimension(:)'] and provide the variance as output with the test_data type ['real'].", "input": "", "output": "\tsubroutine variance(inp, var)\n\t  real :: avg\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: var\n\t  avg = sum(inp) / size(inp)\n\t  var = sum((inp - avg) ** 2) / (size(inp) - 1)\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rawmoment to calculate the raw moment of a given array. The subroutine has 2 input parameters: an integer ord and a real array inp. The output parameter is a real value rwmmt.", "input": "", "output": "\tsubroutine rawmoment(inp, rwmmt, ord)\n\t  integer, intent(in) :: ord\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: rwmmt\n\t  rwmmt = sum(inp ** ord) / size(inp)\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named magneticf to compute the magnetic field vector in Cartesian coordinates. The subroutine takes 1 input parameter of type real(kind=8), dimension(:,:), and produces 1 output parameter of type real(kind=8), dimension(:,:). The subroutine uses the imperative tone to specify the calling sequence and describe the purpose of the inputs and outputs.", "input": "", "output": "subroutine magneticf(v,b)\n\t!----------------------------------------------------------\n\t! magnetic field computation.\n\t! calling sequence: call magneticf(v,b)\n\t! inputs:  v: position vector in cartesian coordinates\n\t! outputs: b: magnetic field vector in cartesian coordinate (tesla)\n\t!----------------------------------------------------------\n\treal(kind=8), dimension(:,:),intent(in)  :: v\n\treal(kind=8), dimension(:,:),intent(out) :: b\n\n\tb(1,:)=0. \n\tb(2,:)=0.\n\tb(3,:)=b0*(v(3,:)/z0b)**(-3)\n\nend subroutine magneticf\n"}, {"instruction": "Create a Fortran subroutine named trans_latlon to convert spherical coordinates (latitude and longitude) to another coordinate system. The subroutine takes 4 input parameters of type real (tph0d, tlm0d, tlm(:), tph(:)) and returns 2 output parameters of type real (alm(:,:), aph(:,:)).", "input": "", "output": "   subroutine trans_latlon (tph0d, tlm0d, tlm, tph, alm, aph)\n\n   real, intent(in)  :: tph0d, tlm0d, tlm(:), tph(:)\n   real, intent(out) :: alm(:,:), aph(:,:)\n\n   real :: dtr, pi, tph0, tlm0, stph0, ctph0, ttph0, cc, ee\n   real, dimension(size(tph)) :: stph, ctph\n   integer :: i, j\n\n!-----------------------------------------------------------------------\n\n    ! scalars\n      pi  = 2.*acos(0.0)\n      dtr  = pi/180.\n      tph0 = tph0d*dtr;  tlm0 = tlm0d*dtr\n      stph0 = sin(tph0); ctph0 = cos(tph0)\n      ttph0 = stph0/ctph0\n\n!     ------- compute actual lat and lon -------\n      stph = sin(tph)\n      ctph = cos(tph)\n      do j = 1, size(aph,2)\n      do i = 1, size(aph,1)\n         cc = ctph(j)*cos(tlm(i))\n         aph(i,j) = asin(ctph0*stph(j)+stph0*cc)\n         ee = cc/(ctph0*cos(aph(i,j))) - tan(aph(i,j))*ttph0\n         ee = min(ee,1.)\n         if (tlm(i) > pi) then\n             alm(i,j) = tlm0-acos(ee)\n         else\n             alm(i,j) = tlm0+acos(ee)\n         endif\n      enddo\n      enddo\n\n!-----------------------------------------------------------------------\n\nend subroutine trans_latlon\n"}, {"instruction": "Create a Fortran subroutine named find_inds_gxp to interpolate the values of an array x to the locations specified by array xv, and store the indices in arrays ix and iy. The subroutine takes 3 input parameters of type real(kind=8), dimension(:) and 2 output parameters of type integer, dimension(size(x)).", "input": "", "output": "      subroutine find_inds_gxp(x,p,xv,ix,iy)\n          real(kind=8), dimension(:), intent(in) :: x,p,xv\n          integer, dimension(size(x)) :: one, two, zero\n          integer, intent(out), dimension(size(x)) :: ix,iy\n          real(kind=8), dimension(size(x)) :: xx\n          integer :: nx\n          two=2; one=1; zero=0\n          nx=size(xv)\n          \n          ! first interpolate to g(x) locations for all p arrays:\n          xx=log(x); ix=int((xx-xv(1))/(xv(nx)-xv(1))*(nx))\n          ix = merge(merge(ix,one,ix.gt.one),nx-1,ix.lt.(nx-1))\n          iy = merge(merge(one,zero,p.gt.3.2d0),two,p.lt.5d0)\n      end subroutine find_inds_gxp\n"}, {"instruction": "Write a Fortran subroutine named ind2sub that calculates the subscripts corresponding to a linear index for an array with given dimensions. The subroutine takes 2 input parameters: an array of integers representing the dimensions of the array and an integer representing the linear index. It produces 1 output parameter: an array of integers representing the subscripts corresponding to the linear index.", "input": "", "output": "subroutine ind2sub(dims,ind,subs)\n    !+ calculate the subscripts `subs` into an array with dimensions `dims`\n    !+ given the corresponding linear index `ind`\n    integer, dimension(:), intent(in)  :: dims\n        !+ dimensions of array\n    integer, intent(in)                :: ind\n        !+ linear index\n    integer, dimension(:), intent(out) :: subs\n        !+ subscripts corresponding to the linear index\n\n    integer :: i, ndims, ind1, ind2\n\n    ind1=ind\n    ndims = size(dims)\n    do i=1,ndims-1\n        ind2 = (ind1-1)/dims(i) + 1\n        subs(i) = ind1 - dims(i)*(ind2-1)\n        ind1 = ind2\n    enddo\n    subs(ndims) = ind1\n\nend subroutine ind2sub\n"}, {"instruction": "Write a Fortran subroutine named time_average to compute the time-averaged flux over a given time interval. The subroutine takes 3 input parameters: an array of real numbers t, an integer it, and a 2D array of real numbers flx. It produces 1 output parameter: an array of real numbers flxavg.", "input": "", "output": "   subroutine time_average(t, it, flx, flxavg)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: t\n      integer, intent(in) :: it\n      real, dimension(:, :), intent(in) :: flx\n      real, dimension(:), intent(out) :: flxavg\n\n      integer :: i, nt\n\n      nt = size(t)\n\n      flxavg = 0.5 * (t(it + 1) - t(it)) * flx(:, it)\n      do i = it + 1, nt - 1\n         flxavg = flxavg + (t(i + 1) - t(i)) * flx(:, i)\n      end do\n      flxavg = flxavg + 0.5 * (t(nt) - t(nt - 1)) * flx(:, nt)\n\n      flxavg = flxavg / (t(nt) - t(it))\n\n   end subroutine time_average\n"}, {"instruction": "Create a Fortran subroutine named get_indices_of_cluster to retrieve the indices of points belonging to a specific cluster. The subroutine takes 2 input parameters of type 'integer, dimension(:)' and 'integer', and 1 output parameter of type 'integer, allocatable, dimension(:)'. Use the imperative tone in your instructions.", "input": "", "output": "    subroutine get_indices_of_cluster(cluster_list,points,i_cluster)\n        implicit none\n        integer, dimension(:), intent(in)                 :: cluster_list\n        integer, intent(out), allocatable, dimension(:)   :: points\n        integer, intent(in)                               :: i_cluster\n\n        integer :: nlive,npoints,j\n\n        nlive = count(cluster_list==i_cluster)\n\n        if(allocated(points)) deallocate(points)\n\n        allocate( points(nlive) )\n\n        npoints=0\n        do j=1,size(cluster_list)\n            if(cluster_list(j)==i_cluster) then\n                npoints = npoints+1\n                points(npoints) = j\n            end if\n        end do\n\n\n    end subroutine get_indices_of_cluster\n"}, {"instruction": "Write a Fortran subroutine named pw_rp to calculate the Riemann solver and the waves. The subroutine takes 7 input parameters of types integer and double precision, and 2 output parameters of type double precision.", "input": "", "output": "subroutine pw_rp(meqn,maux,mwaves,q_l,q_r,aux_l,aux_r,wave,s)\n\n    implicit none\n    integer, intent(in) :: meqn,maux,mwaves\n    double precision, intent(in) :: q_l(1:meqn), q_r(1:meqn)\n    double precision, intent(in) :: aux_l(1:maux), aux_r(1:maux)\n    double precision, intent(out) :: wave(1:meqn,1:mwaves),s(1:mwaves)\n    \n    integer :: p\n    \n    do p=1,mwaves\n        wave(:,p) = q_l(:) + q_r(:)\n        s(p) = (aux_l(p) + aux_r(p)) / 2.d0\n    enddo\n\nend subroutine pw_rp\n"}, {"instruction": "Write a Fortran subroutine named simp to implement Simpson's rule for numerical integration. The subroutine takes 3 input parameters of type real(8), integer(4), and integer(4), and 1 output parameter of type real(8). The input parameters are y, m, and n, while the output parameter is sum.", "input": "", "output": "subroutine simp(y,m,n,sum)\n    implicit none\n!\n!         simpson's rule\n!\n    real(8), intent(in) :: y\n    real(8), intent(out) :: sum\n    integer(4), intent(in) :: m,n\n    integer(4) :: k,k1,k2\n    dimension y(21)\n    sum=0.\n    k1=m+1\n    k2=n-1\n    do k=k1,k2,2\n        sum=sum+y(k-1)+4.*y(k)+y(k+1)\n    end do\n    sum=sum/3.\n    return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named vecpro to calculate the tridimensional vectorial product of two three-dimensional vectors, v1 and v2, and store the result in v3. The number of input parameters is 2 with the test_data type ['real(kind=8)', 'real(kind=8)'], and the number of output parameters is 1 with the test_data type ['real(kind=8)']. Use the imperative tone in your explanation.", "input": "", "output": "subroutine vecpro(v1,v2,v3)\r\n!*****************************************************************************\r\n!\r\n!**** tridimensional vectorial product of two vectors  v1 x v2 -> v3\r\n!\r\n!*****************************************************************************\r\nimplicit none\r\n\r\n  !--- dummy variables\r\n  real(kind=8),intent(in) :: v1(3), v2(3)\r\n  real(kind=8),intent(out):: v3(3)\r\n\r\n  v3(1) = v1(2)*v2(3) - v1(3)*v2(2)   !first component of vectorial product\r\n  v3(2) = v1(3)*v2(1) - v1(1)*v2(3)   !second component of vectorial product\r\n  v3(3) = v1(1)*v2(2) - v1(2)*v2(1)   !third component of vectorial product\r\n\r\nreturn\r\nend subroutine vecpro\r\n"}, {"instruction": "Write a Fortran subroutine named da_interpolate_3d to perform trilinear interpolation on a 3D field at a specified grid location. The subroutine takes 7 input arguments of type integer, integer, integer, real, real, real, and real, representing the grid dimensions, the x, y, z coordinates, and the 3D field to interpolate. It also takes 1 output argument of type real, representing the interpolated value at the specified location. Use the imperative tone while providing instructions for the subroutine.", "input": "", "output": "subroutine da_interpolate_3d( ni, nj, nk, x, y, z, field, h )\n\n   implicit none\n   integer, intent(in)   :: ni, nj, nk\n   real, intent(in)      :: x, y, z      !  grid location of point.\n   real, intent(in)      :: field(1:ni,1:nj,1:nk) ! field to interpolate.\n   real, intent(out)     :: h            ! interpolated value.\n\n   integer               :: ii, jj, kk   ! grid locators.\n   real                  :: dx, dy, dz   ! interpolation weights.\n   real                  :: h1, h2       ! interpolation values.\n   real                  :: h_below      ! 2d interp values.\n   real                  :: h_above      ! 2d interp values.\n\n   ii = int(x)\n   jj = int(y)\n   kk = int(z)\n\n   dx = x - real(ii)\n   dy = y - real(jj)\n   dz = z - real(kk)\n\n!  2d interpolation on layer below:\n   h1 = ( 1.0 - dx ) * field(ii,jj,kk)   + dx * field(ii+1,jj,kk)\n   h2 = ( 1.0 - dx ) * field(ii,jj+1,kk) + dx * field(ii+1,jj+1,kk)\n   h_below = ( 1.0 - dy ) * h1 + dy * h2\n\n!  2d interpolation on layer above:\n   h1 = ( 1.0 - dx ) * field(ii,jj,kk+1)   + dx * field(ii+1,jj,kk+1)\n   h2 = ( 1.0 - dx ) * field(ii,jj+1,kk+1) + dx * field(ii+1,jj+1,kk+1)\n   h_above = ( 1.0 - dy ) * h1 + dy * h2\n\n!  interpolation in vertical:\n   h = ( 1.0 - dz ) * h_below + dz * h_above\n\nend subroutine da_interpolate_3d\n"}, {"instruction": "Create a Fortran subroutine named compact_support to calculate the compactly-supported correlation based on the Gaspari and Cohn (1999) method. The subroutine takes 5 input parameters of type real: x1, x2, y1, y2, cov_loc_rad, and 1 output parameter of type real: corr.", "input": "", "output": "subroutine compact_support( x1, x2, y1, y2, cov_loc_rad, corr )\n\n!  compact support according to (4.10) of gaspari and cohn (1999).\n\n!  assumes r >=0.\n\n   implicit none\n\n   real, intent(in)     :: x1, x2         ! x values of two points.\n   real, intent(in)     :: y1, y2         ! y values of two points.\n   real, intent(in)     :: cov_loc_rad    ! cut-off correlation > 2c.\n   real, intent(out)    :: corr           ! compactly-supported correlation.\n\n   real                 :: z              ! distance between points.\n   real                 :: r              ! ratio.\n   real                 :: r2, r3, r4, r5 ! powers of r.\n\n   z = sqrt( ( x2 - x1 )**2 + ( y2 - y1)**2 )\n   r = z / cov_loc_rad\n\n   r2 = r * r\n   r3 = r2 * r\n   r4 = r3 * r\n   r5 = r4 * r\n\n   if ( r <= 1.0 ) then\n      corr = -0.25 * r5 + 0.5 * r4 + 0.625 * r3 - 5.0 * r2 / 3.0 + 1\n   else if ( r > 1.0 .and. r < 2.0 ) then\n      corr = r5 / 12.0 - 0.5 * r4 + 0.625 * r3 + 5.0 * r2 / 3.0 - &\n             5.0 * r + 4.0 - 2.0 / ( 3.0 * r )\n\n   else if ( r >= 2.0 ) then\n      corr = 0.0\n   end if\n\nend subroutine compact_support\n"}, {"instruction": "Create a Fortran subroutine named dmatinv3 to compute the inverse of a 3x3 matrix. The input parameter is a 3x3 double precision matrix, and the output parameters are a 3x3 double precision matrix and an integer representing the error status.", "input": "", "output": "    subroutine dmatinv3(a,b,ierr)\n         !! performs a direct calculation of the inverse of a 3\u00d73 matrix.\n         double precision,dimension(3,3), intent(in) :: a  !! matrix\n         double precision,dimension(3,3), intent(out) :: b(3,3)   !! inverse matrix\n         integer, intent(out) :: ierr\n         double precision             :: detinv\n!\n         !integer for error status (0 ... no error, 1 ... singular matrix)\n         ierr = 0\n!\n         !calculate the inverse determinant of the matrix\n         detinv = (a(1,1)*a(2,2)*a(3,3) - a(1,1)*a(2,3)*a(3,2)&\n                   - a(1,2)*a(2,1)*a(3,3) + a(1,2)*a(2,3)*a(3,1)&\n                   + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1))\n!\n         if(detinv.eq.0.d0) then\n           ierr = 1\n           b = 0.d0\n           print *,\"error in dmatinv3: matrix is singular - inverse matrix doesn't exist.\"\n           stop\n         endif\n!\n         detinv = 1/detinv\n!\n         ! calculate the inverse of the matrix\n         b(1,1) = +detinv * (a(2,2)*a(3,3) - a(2,3)*a(3,2))\n         b(2,1) = -detinv * (a(2,1)*a(3,3) - a(2,3)*a(3,1))\n         b(3,1) = +detinv * (a(2,1)*a(3,2) - a(2,2)*a(3,1))\n         b(1,2) = -detinv * (a(1,2)*a(3,3) - a(1,3)*a(3,2))\n         b(2,2) = +detinv * (a(1,1)*a(3,3) - a(1,3)*a(3,1))\n         b(3,2) = -detinv * (a(1,1)*a(3,2) - a(1,2)*a(3,1))\n         b(1,3) = +detinv * (a(1,2)*a(2,3) - a(1,3)*a(2,2))\n         b(2,3) = -detinv * (a(1,1)*a(2,3) - a(1,3)*a(2,1))\n         b(3,3) = +detinv * (a(1,1)*a(2,2) - a(1,2)*a(2,1))\n       end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch8nablashape to calculate the natural coordinate derivatives of the shape functions. The subroutine takes 3 input parameters of type real (fxi, feta, fzeta) and returns an output parameter of type real array with 24 elements (fads).", "input": "", "output": "subroutine calch8nablashape(fxi, feta, fzeta, fads)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fads(24)\n\treal, parameter :: fsq125 = 0.35355339059327376220042218105242\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam\n\n! main routine\n\tfxip = (1d0 + fxi) * fsq125\n\tfetap = (1d0 + feta) * fsq125\n\tfzetap = (1d0 + fzeta) * fsq125\n\tfxim = (1d0 - fxi) * fsq125\n\tfetam = (1d0 - feta) * fsq125\n\tfzetam = (1d0 - fzeta) * fsq125\n\n! calculation of natural coordinate derivatives of the shape functions\n! corresponding to xi\n\tfads(1) = - fetam * fzetam\n\tfads(2) = - fads(1)\n\tfads(3) = fetap * fzetam\n\tfads(4) = - fads(3)\n\tfads(5) = - fetam * fzetap\n\tfads(6) = - fads(5)\n\tfads(7) = fetap * fzetap\n\tfads(8) = - fads(7)\n! corresponding to eta\n    fads(9) = - fxim * fzetam\n    fads(10) = - fxip * fzetam\n    fads(11) = - fads(10)\n    fads(12) = - fads(9)\n\tfads(13) = - fxim * fzetap\n\tfads(14) = - fxip * fzetap\n\tfads(15) = - fads(14)\n\tfads(16) = - fads(13)\n! corresponding to zeta\n\tfads(17) = - fxim * fetam\n\tfads(18) = - fxip * fetam\n\tfads(19) = - fxip * fetap\n\tfads(20) = - fxim * fetap\n\tfads(21) = - fads(17)\n\tfads(22) = - fads(18)\n\tfads(23) = - fads(19)\n\tfads(24) = - fads(20)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"lonecelllocate\" that takes a 3D array of logical values as input and outputs another 3D array of logical values. The subroutine aims to identify and mark the lone cells within the input array based on specific conditions. The number of input arguments is 1, and the test_data type is ['logical, dimension(:,:,:)']. The number of output arguments is 1, and the test_data type is ['logical, dimension(:,:,:)'].", "input": "", "output": "    subroutine lonecelllocate( fail, lonecell )\n\n      logical, dimension(:,:,:), intent(in) :: fail\n      logical, dimension(:,:,:), intent(out) :: lonecell\n\n      integer :: i, j, k\n      logical, dimension(3,3,3) :: cornermask\n\n      cornermask = .false.\n      do k = 1, 3, 2\n        do j = 1, 3, 2\n          do i = 1, 3, 2\n            cornermask(i,j,k) = .true.\n          end do\n        end do\n      end do\n      \n      lonecell = .false. \n      do k = 2, size(fail, dim=3) - 1 \n        do j = 2, size(fail, dim=2) - 1\n          do i = 2, size(fail, dim=1) - 1\n\n            if ( .not.fail(i,j,k) ) cycle \n            if ( any( fail(i-1:i+1,j-1:j+1,k-1:k+1) .and. cornermask ) ) cycle\n            lonecell(i,j,k) = .true.\n\n            write(*,*) i,j,k \n\n          end do\n        end do\n      end do\n\n    end subroutine lonecelllocate\n"}, {"instruction": "Create a Fortran subroutine named weno5 to implement the Weighted Essentially Non-Oscillatory (WENO) scheme. The subroutine takes 4 input parameters of type integer and double precision, and 2 output parameters of type double precision. The subroutine calculates the left and right states using the WENO scheme for a given set of input data.", "input": "", "output": "subroutine weno5(q, ql, qr, num_eqn, maxnx, num_ghost)\n\n  implicit none\n\n  integer,          intent(in)  :: num_eqn, maxnx, num_ghost\n  double precision, intent(in)  :: q(num_eqn,maxnx+2*num_ghost)\n  double precision, intent(out) :: ql(num_eqn,maxnx+2*num_ghost), qr(num_eqn,maxnx+2*num_ghost)\n\n  integer :: i, m\n  double precision :: sigma0, &\nsigma1, &\nsigma2, &\nomega1, &\nomega5, &\nomega0, &\nomega4, &\nomega3, &\nomega2, &\nfr1, &\nfr5, &\nfr0, &\nfr4, &\nfr3, &\nfr2, &\nfs0, &\nfs1\n\n  do i = num_ghost-1, maxnx+num_ghost+1\n    do m = 1, num_eqn\n      sigma0 = 3.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      10.333333333333333333333333333333333d0*q(m,i+0)*q(m,i+1) + &\n      3.6666666666666666666666666666666667d0*q(m,i+0)*q(m,i+2) + &\n      8.3333333333333333333333333333333333d0*q(m,i+1)**2 - &\n      6.3333333333333333333333333333333333d0*q(m,i+1)*q(m,i+2) + &\n      1.3333333333333333333333333333333333d0*q(m,i+2)**2\nsigma1 = 4.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      4.3333333333333333333333333333333333d0*q(m,i+0)*q(m,i+1) - &\n      4.3333333333333333333333333333333333d0*q(m,i+0)*q(m,i-1) + &\n      1.3333333333333333333333333333333333d0*q(m,i+1)**2 + &\n      1.6666666666666666666666666666666667d0*q(m,i+1)*q(m,i-1) + &\n      1.3333333333333333333333333333333333d0*q(m,i-1)**2\nsigma2 = 3.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      10.333333333333333333333333333333333d0*q(m,i+0)*q(m,i-1) + &\n      3.6666666666666666666666666666666667d0*q(m,i+0)*q(m,i-2) + &\n      8.3333333333333333333333333333333333d0*q(m,i-1)**2 - &\n      6.3333333333333333333333333333333333d0*q(m,i-1)*q(m,i-2) + &\n      1.3333333333333333333333333333333333d0*q(m,i-2)**2\nomega0 = 0.1d0/(1.0e-36 + sigma0)**2\nomega1 = 0.6d0/(1.0e-36 + sigma1)**2\nomega2 = 0.3d0/(1.0e-36 + sigma2)**2\nomega3 = 0.3d0/(1.0e-36 + sigma0)**2\nomega4 = 0.6d0/(1.0e-36 + sigma1)**2\nomega5 = 0.1d0/(1.0e-36 + sigma2)**2\nfr0 = 1.8333333333333333333333333333333333d0*q(m,i+0) - &\n      1.1666666666666666666666666666666667d0*q(m,i+1) + &\n      0.33333333333333333333333333333333333d0*q(m,i+2)\nfr1 = 0.83333333333333333333333333333333333d0*q(m,i+0) - &\n      0.16666666666666666666666666666666667d0*q(m,i+1) + &\n      0.33333333333333333333333333333333333d0*q(m,i-1)\nfr2 = 0.33333333333333333333333333333333333d0*q(m,i+0) + &\n      0.83333333333333333333333333333333333d0*q(m,i-1) - &\n      0.16666666666666666666666666666666667d0*q(m,i-2)\nfr3 = 0.33333333333333333333333333333333333d0*q(m,i+0) + &\n      0.83333333333333333333333333333333333d0*q(m,i+1) - &\n      0.16666666666666666666666666666666667d0*q(m,i+2)\nfr4 = 0.83333333333333333333333333333333333d0*q(m,i+0) + &\n      0.33333333333333333333333333333333333d0*q(m,i+1) - &\n      0.16666666666666666666666666666666667d0*q(m,i-1)\nfr5 = 1.8333333333333333333333333333333333d0*q(m,i+0) - &\n      1.1666666666666666666666666666666667d0*q(m,i-1) + &\n      0.33333333333333333333333333333333333d0*q(m,i-2)\nfs0 = (fr0*omega0 + fr1*omega1 + fr2*omega2)/(omega0 + omega1 + omega2)\nfs1 = (fr3*omega3 + fr4*omega4 + fr5*omega5)/(omega3 + omega4 + omega5)\nql(m,i) = fs0\nqr(m,i) = fs1\n    end do\n  end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named readklist to read data from a file and store it in arrays. The subroutine takes 2 input parameters of type character*100 and integer, and 2 output parameters of type real*8 and integer. The input parameters are used to specify the file to be read and the number of k points. The output parameters store the weights and k vectors read from the file.", "input": "", "output": "subroutine readklist(fklist, nkpt, kvec, wgh)\n  implicit none\n  character*100, intent(in) :: fklist\n  integer, intent(in)       :: nkpt\n  real*8, intent(out)       :: wgh(nkpt)\n  integer, intent(out)      :: kvec(4,nkpt)\n  ! locals\n  integer      :: numkpt, ik, ios\n  character*10 :: kname\n  \n  open(14,file=fklist,status='old',form='formatted')\n  do ik=1,nkpt\n     read (14,'(a10,4i5,3f5.2,a3)',iostat=ios) kname, kvec(1,ik), kvec(2,ik), kvec(3,ik), kvec(4,ik), wgh(ik)\n     !print *, 'kname=', kname, 'kv=', kvec(1,ik), kvec(2,ik), kvec(3,ik), kvec(4,ik)\n     if (kname .eq. 'end       ' .or. ios.ne.0) then\n        print *, 'error in reading ', trim(fklist)\n        exit\n     endif\n  enddo\n  close(14)\nend subroutine readklist\n"}, {"instruction": "Create a Fortran subroutine named \"fobf\" to implement the Fast Ordering by Binary Descent (FOBF) algorithm. The subroutine should take 4 input parameters of types ['double precision, dimension(:,:)', 'integer', 'integer', 'integer'], and 1 output parameter of type ['integer, dimension(nmax)']. The subroutine should be programmed in the imperative tone.", "input": "", "output": "subroutine fobf(features, seed, nmax, nmem, final_ordering)\n\n    implicit none\n\n    double precision, dimension(:,:), intent(in) :: features\n    integer, intent(in) :: seed\n    integer, intent(in) :: nmax\n    integer, intent(in) :: nmem\n    integer, dimension(nmax), intent(out) :: final_ordering\n\n    integer, allocatable, dimension(:) :: ordering\n\n    integer :: nsamples, nfeatures\n    integer :: i, j, k, idx, n, m, p\n    double precision :: maxdist,  d, huge_double\n\n    nsamples = size(features,dim=1)\n    nfeatures = size(features, dim=2)\n\n    ! allocate temporary\n    allocate(ordering(nsamples))\n    huge_double = huge(1.0d0)\n\n    ! initialize the ordering\n    ordering = (/ (i, i = 1, nsamples) /)\n\n    ! the first item will be the seed\n    ordering(seed) = ordering(1)\n    ordering(1) = seed\n\n\n    ! todo: parallelise in some way, ie. threadlocking maxdist\n    ! do the actual algorithm\n    do i = 2, nmax\n        p = ordering(i)\n        maxdist = 0.0d0\n        idx = i\n        do j = i, nsamples\n            n = ordering(j)\n            d = huge_double\n            !$omp parallel do reduction(min:d) private(m)\n            do k = max(1, i - nmem), i-1\n                if (d <= maxdist) then\n                    cycle\n                endif\n                m = ordering(k)\n                d = min(sum((features(n,:) - features(m,:))**2),d)\n            enddo\n            !$omp end parallel do\n\n            ! having this outside the loop is somewhat faster\n            if (d > maxdist) then\n                idx = j\n                maxdist = d\n            endif\n        enddo\n\n        ordering(i) = ordering(idx)\n        ordering(idx) = p\n    enddo\n\n    ! generate output in python format\n    final_ordering = ordering(:nmax) -1\n\n    ! deallocate temporary\n    deallocate(ordering)\n\nend subroutine fobf\n"}, {"instruction": "Create a Fortran subroutine named getlinquadth to calculate the linear and quadratic transformations of the input latent vectors. The subroutine takes 3 input parameters of type real(kind=8) and outputs 2 parameters of type real(kind=8). The linear transformation is computed using matmul(lintheta,thpr), and the quadratic transformation is calculated using a loop over the rows of quadtheta and the matmul function.", "input": "", "output": "subroutine getlinquadth(lintheta,quadtheta,thpr,linth,quadth)\r\nimplicit none\r\n\r\n\r\nreal(kind=8),intent(in)::lintheta(:,:),quadtheta(:,:,:),thpr(:)\r\nreal(kind=8),intent(out)::linth(:),quadth(:,:)\r\n!\trow counts elements of the underlying latent vector.\r\ninteger::row\r\nlinth=matmul(lintheta,thpr)\r\ndo row=1,size(linth)\r\n\tquadth(row,:)=matmul(quadtheta(row,:,:),thpr)\r\nend do\r\nreturn\r\nend subroutine getlinquadth\n"}, {"instruction": "Write a Fortran subroutine named \"pzxc\" to calculate the exchange-correlation energy and its derivative with respect to density. The subroutine takes 1 input parameter of type real(8) and provides 2 output parameters of type real(8).", "input": "", "output": "  subroutine pzxc(trho,exc,dexc_drho)\n    implicit none\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gammau=-0.1423d0,beta1u=1.0529d0\n    real(8),parameter :: beta2u=0.3334d0,au=0.0311d0,bu=-0.048d0\n    real(8),parameter :: cu=0.002d0,du=-0.0116d0\n    real(8),parameter :: const = 0.75d0*(3d0/(2d0*pi))**(2d0/3d0)\n    real(8) :: ttrho,rs,rssq,rsln\n    real(8),intent(in) :: trho\n    real(8),intent(out) :: exc\n    real(8),intent(out) :: dexc_drho\n\n\n    ttrho=trho+1d-10\n    rs=(3d0/(4*pi*ttrho))**(1d0/3d0)\n    exc=-const/rs\n    dexc_drho=exc/(3*ttrho)\n    if (rs>1d0) then\n      rssq=sqrt(rs)\n      exc=exc+gammau/(1d0+beta1u*rssq+beta2u*rs)\n      dexc_drho=dexc_drho+gammau*(0.5d0*beta1u*rssq+beta2u*rs)/(3*ttrho)/(1+beta1u*rssq+beta2u*rs)**2\n    else\n      rsln=log(rs)\n      exc=exc+au*rsln+bu+cu*rs*rsln+du*rs\n      dexc_drho=dexc_drho-rs/(3*ttrho)*(au/rs+cu*(rsln+1)+du)\n    endif\n    return\n  end subroutine pzxc\n"}, {"instruction": "Write a Fortran subroutine named cycle_ints which takes an array of 64-bit integers as input and produces an array of 64-bit integers as output. The subroutine cycles through the input array and assigns the values to the output array in a circular manner.", "input": "", "output": "    subroutine cycle_ints(output, input)\n        integer(8), intent(in) :: input(:)\n        integer(8), intent(out) :: output(:)\n        integer :: i\n\n        do i = 1, size(output, 1)\n            output(i) = input(mod(i - 1, size(input, 1)) + 1)\n        end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named psm_to_tdsm_size_mt_eikonal to calculate the perfect number of grid points for a given psm based on specified maximum dx, dy and dt. The subroutine takes 4 input parameters of type real (sizex, sizey, maxdx, maxdy) and returns 2 output parameters of type integer (nx, ny).", "input": "", "output": "    subroutine psm_to_tdsm_size_mt_eikonal( sizex, sizey, maxdx, maxdy, nx, ny)\n    \n      ! given a psm, determine perfect number of grid points\n      ! based on wanted maxdx, maxdy and maxdt\n    \n        real, intent(in) :: sizex,sizey\n        real, intent(in) :: maxdx, maxdy\n        integer, intent(out) :: nx, ny\n  \n        nx = floor(sizex/maxdx) + 1\n      ! need at least 2 points to get partial deriv. depend on length\n        if (nx .le. 1) nx = 2\n      ! a line source may be made with width=0\n        if (sizex .eq. 0.) nx = 1\n        \n        ny = floor(sizey/maxdy) + 1\n      ! need at least 2 points to get partial deriv. depend on width\n        if (ny .le. 1) ny = 2\n      ! a point source (or simultaneous line source) may be made with length=0\n        if (sizey .eq. 0.) ny = 1\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named xeuc to calculate the Euclidean distance matrix for a set of data points. The subroutine should take 3 input parameters: two integers 'n' and 'd', and a 2D array 'x' of type double precision. Additionally, it should have one output parameter, a 2D array 'euclidean' of type double precision.", "input": "", "output": "      subroutine xeuc(n,d,x,euclidean)\n      implicit none\n      integer, intent(in):: n, d\n      double precision, intent(in):: x(n,d)\n      double precision, intent(out):: euclidean(n,n)\n      integer:: i, j, ii, k\n      double precision:: euc\n      do j=1,n\n        ii=0\n        do i=1,n\n          euc=0.0d0\n          do k=1,d\n            euc=euc+(x(i,k)-x(j,k))**2\n          end do\n          euc=sqrt(euc)\n          euclidean(i,j)=euc\n        end do\n      end do\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named readfields to read and reshape data from a file. The number of input arguments is 1 and the test_data type is ['integer(4)']. The number of output arguments is 2 and the test_data type is ['real(8)', 'real(8)'].", "input": "", "output": " subroutine readfields(timestp,lrfld,varmemsize)\n  implicit none\n  real(8), allocatable    :: torestart(:,:)\n  real(8),    intent(out) :: timestp\n  real(8),    intent(out)  :: lrfld(:,:,:,:)\n  integer(4), intent(in)  :: varmemsize\n  integer(4)              :: datalen,datasize\n  integer(4)              :: matdims(4)\n  integer(4)              :: ferror\n  integer(4)              :: icounter\n\n  matdims=shape(lrfld)\n  datalen=matdims(1)*matdims(2)*matdims(3)\n  datasize=(matdims(4)+1)*datalen*varmemsize\n\n  allocate(torestart(matdims(4)+1,datalen))\n\n  open(unit=1,file=\"restartdata.out\",status='old',form='unformatted',access='direct',iostat=ferror,recl=datasize)\n  read(1,rec=1) torestart\n  close(1)\n  do icounter=1,matdims(4)\n   lrfld(:,:,:,icounter)=reshape(torestart(icounter,:),(/matdims(1),matdims(2),matdims(3)/))\n  end do\n  timestp=torestart(matdims(4)+1,1)\n\n  return\n end subroutine readfields\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma that takes 3 input parameters of type real(kind=dp) array, integer, and integer. The subroutine will produce 1 output parameter of type real(kind=dp) allocatable array. The subroutine initializes the output array sigma with zeros, then populates the diagonal elements with the values from the input array s.", "input": "", "output": "    subroutine compute_sigma(s, nr_rows, nr_cols, sigma)\n        use, intrinsic :: iso_fortran_env, only : dp => real64\n        implicit none\n        real(kind=dp), dimension(:), intent(in) :: s\n        integer, intent(in) :: nr_rows, nr_cols\n        integer :: i, error\n        real(kind=dp), allocatable, dimension(:, :), intent(out) :: sigma\n        allocate(sigma(nr_rows, nr_cols), stat=error)\n        sigma = 0.0_dp\n        do i = 1, min(nr_rows, nr_cols)\n            sigma(i, i) = s(i)\n        end do\n    end subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named viral_4_eqn to solve a system of four differential equations representing the dynamics of a viral infection. The subroutine takes 11 input parameters of type real and integer, and returns 4 output parameters of type real. The function updates the values of time (t_new), infected individuals in two different stages (i1_new, i2_new), and viral load (v_new) after a specified number of time steps.\n\nThe input parameters are t, i1, i2, v, beta, k, delta_c, p, c, dt, and ntime, representing various parameters of the differential equations. The output parameters are t_new, i1_new, i2_new, and v_new, which represent the updated solution variables after the specified time steps.", "input": "", "output": "subroutine viral_4_eqn(t_new, i1_new, i2_new, v_new, t, i1, i2, v, beta, k, delta_c, p, c, dt, ntime)\n! python call looks like:\n!    t_new, i1_new, i2_new, v_new = viral_4_eqn(t, i1, i2, v, beta, k, delta_c, p, c, dt, ntime)\n\n! *******************************************************************************************\n\n! method and as such the time step size can not be too small e.g. 10 mins or dt = 10. * 60. = 600.\n! don't forget there needs to be a seed of an infected person in the e group.\n! have a look at eqn 2 of modeling-the-viral-dynamics-of-sars-cov-2-infect.pdf\n! *******************************************************************************************\n\n! t_new, i1_new, i2_new, v_new the calculated solution variables after ntime time steps output\n\n\n! dt = time step size\n! ntime = no of time steps\n\n   implicit none\n! dummy variables\n   real, intent(out) :: t_new, i1_new, i2_new, v_new\n   real, intent(in) :: t, i1, i2, v, beta, k, delta_c, p, c, dt\n   integer, intent(in) :: ntime\n\n! local variables\n   integer its, nits, itime ! no of non-linear iterations\n   real t_old, i1_old, i2_old, v_old ! previous time step values of t, i1, i2, v\n\n! execution\n   t_new = t; i1_new = i1; i2_new = i2; v_new = v\n   nits = 3\n\n   do itime = 1, ntime\n      t_old = t_new; i1_old = i1_new; i2_old = i2_new; v_old = v_new\n      \n      do its = 1, nits\n         t_new = t_old + dt * (-beta * v_new * t_new)\n         i1_new = i1_old + dt * (beta * v_new * t_new - k * i1_new)\n         i2_new = i2_old + dt * (k * i1_new - delta_c * i2_new) \n         v_new = v_old + dt * (p * i2_new - c * v_new)\n      end do ! do its = 1, nits\n   end do\n   return\nend subroutine viral_4_eqn\n"}, {"instruction": "Create a Fortran subroutine named trilinearinterpolationpolynomia to calculate trilinear interpolation polynomial coefficients. The subroutine takes one input argument of type real array with dimensions (0:1,0:1,0:1) and one output argument of the same type and dimensions. The input argument is marked as intent(in) and the output argument is marked as intent(out).", "input": "", "output": "subroutine trilinearinterpolationpolynomia(a,f)\r\n        !-------------------------------------------------------------------!\r\n        implicit none\r\n        !-------------------------------------------------------------------!\r\n        real                        :: a   (0:1,0:1,0:1)\r\n        real                        :: f   (0:1,0:1,0:1)\r\n        !-------------------------------------------------------------------!\r\n        intent(out)                 :: a\r\n        intent(in)                  :: f\r\n        !-------------------------------------------------------------------!\r\n        ! local variables\r\n        !-------------------------------------------------------------------!\r\n\r\n        a(0,0,0) =  f(0,0,0)\r\n        a(1,0,0) = -f(0,0,0)+f(1,0,0)\r\n        a(0,1,0) = -f(0,0,0)+f(0,1,0)\r\n        a(0,0,1) = -f(0,0,0)+f(0,0,1)\r\n        a(1,1,0) =  f(0,0,0)-f(0,1,0)-f(1,0,0)+f(1,1,0)\r\n        a(1,0,1) =  f(0,0,0)-f(0,0,1)-f(1,0,0)+f(1,0,1)\r\n        a(0,1,1) =  f(0,0,0)-f(0,0,1)-f(0,1,0)+f(0,1,1)\r\n        a(1,1,1) = -f(0,0,0)+f(1,0,0)+f(0,1,0)+f(0,0,1)-f(1,1,0)-f(1,0,1)-f(0,1,1)+f(1,1,1)\r\n\r\nend subroutine trilinearinterpolationpolynomia\r\n"}, {"instruction": "Write a Fortran subroutine named unmod to perform a modification on an input array of double precision values. The subroutine takes 2 input parameters of type integer and double precision array with a dimension of num_samples. It produces 1 output parameter of type double precision array with a dimension of num_samples. The subroutine modifies the input array based on certain calculations and stores the result in the output array.", "input": "", "output": "  subroutine unmod (x, x_mod, num_samples)\n  integer, intent(in) :: num_samples\n  double precision, dimension(num_samples), intent(in) :: x_mod\n  double precision, dimension(num_samples), intent(out) :: x\n    integer :: i\n    integer :: n\n    double precision :: ph_diff\n    n = 0\n    x = x_mod\n    do i = 2, num_samples\n      x(i) = x(i) + p * n\n      ph_diff = x(i) - x(i-1)\n      if (ph_diff > p2) then\n          n = n-1\n          x(i) = x(i) - p\n      else if (ph_diff < -p2) then\n          n = n+1\n          x(i) = x(i) + p\n      end if\n    end do\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named threshold_data that takes 4 input parameters: an array of double precision numbers of length num_samples, an integer num_samples, a double precision threshold, and an integer n_min. It also has 2 output parameters: an array of integers with dimensions num_samples by 2, and an integer num_segments. The subroutine segments the input data based on the threshold and n_min, and updates the segments array and num_segments accordingly.", "input": "", "output": "  subroutine threshold_data (x, num_samples, threshold, n_min, segments, num_segments)\n  double precision, dimension(num_samples), intent(in) :: x\n  integer, intent(in) :: num_samples\n  double precision, intent(in) :: threshold\n  integer, intent(in) :: n_min\n  integer, dimension(num_samples, 2), intent(out) :: segments\n  integer, intent(out) :: num_segments\n    integer :: n, n0\n    num_segments = 0\n    n0 = 1\n    do n = 1, num_samples\n      if (x(n) < threshold) then\n        if (n-n0 > n_min) then\n          num_segments = num_segments + 1\n          segments(num_segments, 1) = n0\n          segments(num_segments, 2) = n-1\n        end if\n        n0 = n\n      end if\n    end do\n    if (n-n0 > n_min) then\n      num_segments = num_segments + 1\n      segments(num_segments, 1) = n0\n      segments(num_segments, 2) = n-1\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"poincare_times_interpolate\" to calculate interpolated return times for a given set of phase values and discrete times. The subroutine takes 5 input parameters of types ['integer, dimension(num_crossings)', 'integer, dimension(num_crossings)', 'integer', 'double precision, dimension(num_samples)', 'integer'], and 2 output parameters of types ['double precision, dimension(num_crossings)', 'double precision, dimension(num_crossings)'].", "input": "", "output": "  subroutine poincare_times_interpolate (idx, ti, num_crossings, x, num_samples, idx_interp, ti_interp)\n\n  ! ti(i) is the discrete time between two crossings\n  ! idx(i) is the index of the step before 0\n  ! x is phase, x[idx(i)] > 0.0\n  ! times are the output where we will store the correct return times (= approx index)\n  ! n: number of approximate zeros that were found\n\n  integer, dimension(num_crossings), intent(in) :: idx, ti\n  integer, intent(in) :: num_crossings\n  double precision, dimension(num_samples), intent(in) :: x\n  integer, intent(in) :: num_samples\n  double precision, dimension(num_crossings), intent(out) :: idx_interp, ti_interp\n\n    integer :: i, j, j1, jj, jj1\n    double precision :: x_j, x_j1, x_jj, x_jj1\n    do i = 1, num_crossings\n      j   = idx(i)     ! index before crossing\n      j1  = idx(i)+1   ! index after crossing\n      jj  = j+ti(i)    ! index before return\n      jj1 = j+ti(i)+1  ! index after return\n\n      !! corresponding phases\n      ! before crossing are close to 'p'\n      x_j   = x(j)-p\n      x_jj  = x(jj)-p\n      ! after crossing are just above zero\n      x_j1  = x(j1)\n      x_jj1 = x(jj1)\n\n      idx_interp(i) = idx(i)- x_j/(x_j1-x_j)\n      ti_interp(i)  = ti(i) + x_j/(x_j1-x_j)-x_jj/(x_jj1-x_jj)\n    end do\n  end subroutine poincare_times_interpolate\n"}, {"instruction": "Create a Fortran subroutine named ini_var. It takes 1 input parameter of type integer and returns 3 output parameters, all of which are of type integer. The subroutine initializes the output parameters lbuf, mxl, and ntestb based on the input parameter lmax(2).", "input": "", "output": "      subroutine ini_var(lbuf, mxl, lmax, ntestb) \n!...translated by pacific-sierra research 77to90  4.3e  12:11:08  11/17/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(out) :: lbuf \n      integer , intent(out) :: mxl \n      integer , intent(out) :: ntestb \n      integer , intent(in) :: lmax(2) \n!-----------------------------------------------\n \n!mrg  lbuf = 96*1027\n      lbuf = 1 \n      mxl = max0(lmax(1),lmax(2)) - 1 \n!. define test level for biotrn : 0 => silence, 1=> just a bit\n!mrg  ntestb = 1\n      ntestb = 15 \n \n      return  \n      end subroutine ini_var \n"}, {"instruction": "Create a Fortran subroutine named set_ncf that takes 3 input arguments of type integer and 2 output arguments of type integer. The input arguments are ncfg, mcfg, and kcfg, and the output arguments are lcfg and ncf. Inside the subroutine, set lcfg to the value of ncfg, ncf(1) to the value of mcfg, and ncf(2) to the value of kcfg. Ensure that the subroutine uses the \"implicit none\" statement to enforce explicit variable declarations.", "input": "", "output": "      subroutine set_ncf(lcfg, ncfg, mcfg, kcfg, ncf) \n!...translated by pacific-sierra research 77to90  4.3e  12:11:08  11/17/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(out) :: lcfg \n      integer , intent(in) :: ncfg \n      integer , intent(in) :: mcfg \n      integer , intent(in) :: kcfg \n      integer , intent(out) :: ncf(2) \n!-----------------------------------------------\n!\n \n      lcfg = ncfg \n      ncf(1) = mcfg \n      ncf(2) = kcfg \n \n      return  \n      end subroutine set_ncf \n"}, {"instruction": "Create a Fortran subroutine named convert_day to convert the day of the year to the month and day. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are iyear and idoy, and the output parameters are imonth and iday.", "input": "", "output": "subroutine convert_day(iyear,idoy,imonth,iday)\n\n\n\n integer, intent(in)   :: iyear\n integer, intent(in)   :: idoy\n integer, intent(out)  :: imonth\n integer, intent(out)  :: iday\n\n integer :: t\n\n t = 0\n if(modulo(iyear, 4) == 0) t = 1\n\n if(modulo(iyear, 400) /= 0 .and. modulo(iyear, 100) == 0) t = 0\n\n iday = idoy\n if(idoy > 59+t) iday = iday + 2 - t\n imonth = ((iday+91)*100)/3055\n iday = (iday+91) - (imonth*3055)/100\n imonth = imonth - 2\n\n if(imonth >= 1 .and. imonth <= 12) return\n write(unit=*,fmt=\"(a,i11,a)\")  &\n \"$$calend: day of the year input =\",idoy,\" is out of range.\"\n stop\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named inrotm to calculate the initial nodal coordinate systems. The subroutine takes 1 input parameter of type real (kind=8) and outputs 1 parameter of the same type.", "input": "", "output": "subroutine inrotm(a,euler)\r\n!***************************************************************\r\n!     calculates the initial nodal coordinate systems\r\n!***************************************************************\r\nimplicit none\r\n\r\nreal (kind=8),intent(in) :: a(3)\r\nreal (kind=8),intent(out) :: euler(9)\r\n\r\nreal (kind=8) :: ca,cb,cg,sa,sb,sg\r\n\r\nif(all(a == 0) ) then\r\n\r\n  euler = (/ 1d0 , 0d0 , 0d0 ,  &\r\n             0d0 , 1d0 , 0d0 ,  &\r\n             0d0 , 0d0 , 1d0 /)\r\n\r\nelse\r\n\r\n  ca = cos(a(1))\r\n  sa = sin(a(1))\r\n  cb = cos(a(2))\r\n  sb = sin(a(2))\r\n  cg = cos(a(3))\r\n  sg = sin(a(3))\r\n\r\n  euler = (/   ca*cg - cb*sa*sg  , ca*cb*sg + cg*sa , sb*sg , &\r\n            - (ca*sg + cb*cg*sa) , ca*cb*cg - sa*sg , cg*sb , &\r\n                   sa*sb         ,      - ca*sb     ,   cb   /)\r\nend if\r\n\r\nreturn\r\nend subroutine inrotm\r\n"}, {"instruction": "Create a Fortran subroutine named \"blk_space\" to calculate the space requirements for the \"blktri\" function. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are \"n\" and \"m\", and the output parameters are \"irwk\" and \"icwk\". The subroutine computes the space requirements based on the values of \"n\" and \"m\" and assigns the results to \"irwk\" and \"icwk\". Use the imperative tone to instruct the creation of this subroutine.", "input": "", "output": "\tsubroutine blk_space(n,m,irwk,icwk)\n\n!       requirements (generous estimate) of blktri for n,m values\n\timplicit none\n\tinteger,intent(in) :: n,m\n\tinteger,intent(out) :: irwk,icwk\n\tinteger :: l,log2n\n!       compute nearest integer greater than or equal to\n!       log base 2 of n+1, i.e., log2n is smallest integer\n!       such that 2**log2n >= n+1\n\tlog2n = 1\n\tdo\n\t   log2n = log2n+1\n\t   if (n+1 <= 2**log2n) exit\n\tend do\n\tl = 2**(log2n+1)\n\tirwk = (log2n-2)*l+5+max0(2*n,6*m)+log2n+2*n\n\ticwk = ((log2n-2)*l+5+log2n)/2+3*m+n\n\treturn\n\tend subroutine blk_space\n"}, {"instruction": "Write a Fortran subroutine named gen_space to calculate the space required for a given pair of integers. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters are n and m, and the output parameter is irwk.", "input": "", "output": "\tsubroutine gen_space(n,m,irwk)\n\n!       requirement (generously) of genbun for the current n,m\n\timplicit none\n\tinteger,intent(in) :: n,m\n\tinteger,intent(out) :: irwk\n\tinteger :: log2n\n!       compute nearest integer greater than or equal to\n!       log base 2 of n+1, i.e., log2n is smallest integer\n!       such that 2**log2n >= n+1\n\tlog2n = 1\n\tdo\n\t   log2n = log2n+1\n\t   if (n+1 <= 2**log2n) exit\n\tend do\n\tirwk = 4*n + (10 + log2n)*m\n\treturn\n\tend subroutine gen_space\n"}, {"instruction": "Create a Fortran subroutine named \"parseline\" that takes a single input of type \"character (len=*)\" and two outputs of type \"character (len=len(line))\". The subroutine should parse the input line to extract keyword-value pairs separated by a colon. If a colon is found, the subroutine should extract the keyword and value, remove any control characters and comments, and return the parsed keyword and value as outputs. If no colon is found, the subroutine should set the keyword output to \"skip\". Remember to include the \"implicit none\" statement and declare all variables.", "input": "", "output": "      subroutine parseline(line,keyword,value)\n      implicit none\n      character (len=*),         intent(in)  :: line\n      character (len=len(line)), intent(out) :: keyword, value\n      character (len=len(line))              :: workingline\n      integer :: i, commentpos, colonpos\n\n!========================================================================!\n!  read keywords and values.                                             !\n!------------------------------------------------------------------------!\n! first, check to see if we have a colon to separate keyword from value  !\n! if there's no colon, we do not have a keyword:value pair.              !\n!========================================================================!\n\n      colonpos = index(line,':')\n      if (colonpos == 0) then\n        keyword = \"skip\"\n        return\n      end if\n\n\n!===============================================!\n!  replace all control characters with spaces.  !\n!===============================================!\n\n      workingline = line\n      do i = 1,len(line)\n       if(iachar(workingline(i:i)) <= 31) workingline(i:i) = ' '\n      end do\n\n\n!===========================================!\n!  keyword is everything before the colon,  !\n!  and value is everything after it.        !\n!===========================================!\n\n      keyword = workingline(1:colonpos-1)\n      value   = workingline(colonpos+1:)\n\n\n!==================================================================!\n!  for both keyword and value, delete everything after a comment.  !\n!==================================================================!\n\n      commentpos  = index(keyword,'!')\n      if(commentpos /= 0) keyword = keyword(1:commentpos-1)\n      commentpos  = index(value,'!')\n      if(commentpos /= 0) value = value(1:commentpos-1)\n\n\n!==================================================!\n!  if the keyword or value is blank, we can skip.  !\n!==================================================!\n\n      if(len_trim(keyword) == 0 .or. len_trim(value) == 0) keyword = \"skip\"\n      return\n      end subroutine parseline\n"}, {"instruction": "Create a Fortran subroutine named func_fort that takes an integer input parameter and returns a double precision output parameter. The subroutine calculates the value of the output parameter based on the input parameter using a do loop and mathematical operations.", "input": "", "output": "    subroutine func_fort(n,d)\n        integer, intent(in) :: n \n        double precision, intent(out) :: d\n        integer :: i\n        d = 0\n        do i=0, n-1\n            d = d + (mod(i,3) - 1) * i\n        end do\n    end subroutine func_fort\n"}, {"instruction": "Create a Fortran subroutine named fill_random that fills an array with random integers based on the specified size and maximum number. The subroutine takes 2 input parameters of type integer: msize and mnumber. It also has 1 output parameter of type integer: array.", "input": "", "output": "subroutine fill_random(msize, mnumber, array)\n    implicit none\n    ! variables\n    integer, intent(in) :: msize\n    integer, intent(in) :: mnumber\n    integer, intent(out) :: array(msize)\n    integer :: i\n\n    ! iterate through the array and fill with random integers capped at mnumber\n    do i = 1, msize\n        array(i) = modulo(irand(), mnumber+1)\n    end do\nend subroutine fill_random\n"}, {"instruction": "Create a Fortran subroutine named cosft_inv to compute the inverse discrete cosine transform (DCT) of a given set of coefficients. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 1 output parameter of type real. The input parameters are n_theta_max, n_theta, a(0:n_theta_max), and theta(n_theta_max), while the output parameter is f(n_theta_max). The subroutine uses the imperative tone and computes the DCT using the given input coefficients and angles.", "input": "", "output": "      subroutine cosft_inv(f, theta, a, n_theta_max, n_theta)\n\n      implicit none\n\n      integer, intent(in) :: n_theta_max, n_theta\n      real, intent(in) :: a(0: n_theta_max), theta(n_theta_max)\n\n      real, intent(out) :: f(n_theta_max)\n\n      integer n, i\n\n\n      do i = 1, n_theta\n         f(i) = 0.0\n         do n = 0, n_theta - 1\n            f(i) = f(i) + a(n) * cos(n * theta(i))\n         end do\n      end do\n\n      return\n\n      end subroutine cosft_inv\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp to calculate the exponential of the input array xdiff2, and store the results in the output array out. The subroutine takes 2 input parameters: an integer nx and a real(8) array xdiff2 of length nx. It also has 1 output parameter: a real(8) array out of length nx.", "input": "", "output": "subroutine kern_sqexp(nx, xdiff2, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: xdiff2(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*xdiff2)\nend subroutine kern_sqexp\n"}, {"instruction": "Create a Fortran subroutine named discretization_getnodelayer that calculates the node and layer index based on the global node number and the total number of nodes. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine discretization_getnodelayer(nnodes,gnode,inode,ilayer)\n    integer,intent(in)  :: nnodes,gnode\n    integer,intent(out) :: inode,ilayer\n    \n    inode = mod(gnode,nnodes)\n    if (inode .eq. 0) then\n      inode  = nnodes\n      ilayer = gnode/nnodes\n    else\n      ilayer = (gnode/nnodes) + 1\n    end if\n    \n  end subroutine discretization_getnodelayer\n"}, {"instruction": "Create a Fortran subroutine named write_den_header that takes two input parameters of type real*8 and integer, and one output parameter of type character. The subroutine writes the values of thistime and readprop to the header.", "input": "", "output": "subroutine write_den_header(header,thistime,readprop)\n  implicit none\n  character,intent(out) :: header*(*)\n  real*8,intent(in) :: thistime\n  integer,intent(in) :: readprop\n  write(header,*) thistime,readprop\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named write_spf_header that generates a header string based on the input parameters. The number of input parameters is 3 with test_data types ['real*8', 'integer', 'integer'], and the number of output parameters is 1 with a test_data type of ['character'].", "input": "", "output": "subroutine write_spf_header(header,thistime,readprop,ispf)\n  implicit none\n  character,intent(out) :: header*(*)\n  real*8,intent(in) :: thistime\n  integer,intent(in) :: readprop, ispf\n  write(header,*) thistime,readprop,ispf\nend subroutine write_spf_header\n"}, {"instruction": "Create a Fortran subroutine named read_den_header to read and parse the input header string. The subroutine takes 1 input parameter of type character and 2 output parameters of type real*8 and integer, respectively. Use the read statement to parse the header string and assign the values to the output parameters thistime and readprop.", "input": "", "output": "subroutine read_den_header(header,thistime,readprop)\n  implicit none\n  character,intent(in) :: header*(*)\n  real*8,intent(out) :: thistime\n  integer,intent(out) :: readprop\n  read(header,*) thistime,readprop\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_spf_header that takes a character input and returns three output parameters. The input parameter is of type character, and the output parameters are of type real*8, integer, and integer. This subroutine reads values from the input string and assigns them to the output parameters thistime, readprop, and ispf, respectively.", "input": "", "output": "subroutine read_spf_header(header,thistime,readprop,ispf)\n  implicit none\n  character,intent(in) :: header*(*)\n  real*8,intent(out) :: thistime\n  integer,intent(out) :: readprop, ispf\n  read(header,*) thistime,readprop,ispf\nend subroutine read_spf_header\n"}, {"instruction": "Write a Fortran subroutine named \"eile\" to determine the minimum, maximum, and median values among three input integers. The subroutine takes 3 input arguments of type integer and returns 3 output arguments of type integer. The subroutine should assign the minimum value to the first output argument, the maximum value to the second output argument, and the median value to the third output argument.", "input": "", "output": "      subroutine eile(ja, jb, jc, jaa, jbb, jcc) \n!...translated by pacific-sierra research 77to90  4.3e  10:10:27  11/16/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(in) :: ja \n      integer , intent(in) :: jb \n      integer , intent(in) :: jc \n      integer , intent(out) :: jaa \n      integer , intent(out) :: jbb \n      integer , intent(out) :: jcc \n!-----------------------------------------------\n      jaa = ja \n      jcc = ja \n      jaa = min0(jb,jaa) \n      jcc = max0(jb,jcc) \n      jaa = min0(jc,jaa) \n      jcc = max0(jc,jcc) \n      if (ja>jaa .and. ja<jcc) jbb = ja \n      if (jb>jaa .and. jb<jcc) jbb = jb \n      if (jc>jaa .and. jc<jcc) jbb = jc \n      return  \n      end subroutine eile \n"}, {"instruction": "Create a Fortran subroutine named minkowski_add_voxel to calculate the Minkowski functionals for a given lattice. The subroutine takes 7 input parameters of type integer, including an array of dimensions 0:lx-1, 0:ly-1, 0:lz-1. It also returns 4 output parameters, all of which are integers.", "input": "", "output": "subroutine minkowski_add_voxel(lattice,lx,ly,lz,jx,jy,jz,volume,surface,curvature,euler)\nimplicit none\ninteger, intent(in), dimension(0:lx-1,0:ly-1,0:lz-1) :: lattice\ninteger, intent(in) :: lx, ly, lz, jx, jy, jz\ninteger, intent(out) :: volume, surface, curvature, euler\n\ninteger, parameter :: volume_body = 1   ! (a*a*a, where a is lattice displacement)\ninteger, parameter :: surface_body = -6 ! (-6*a*a, open body)\ninteger, parameter :: surface_face = 2  ! (2*a*a, open face)\ninteger, parameter :: curv_body = 3     ! (3*a, open body)\ninteger, parameter :: curv_face = -2    ! (-2*a, open face)\ninteger, parameter :: curv_edge = 1     ! (a, open line)\ninteger, parameter :: euler_body = -1   ! (open body)\ninteger, parameter :: euler_face = 1    ! (open face)\ninteger, parameter :: euler_edge = -1   ! (open line)\ninteger, parameter :: euler_vertex = 1  ! (vertices)\n\ninteger nfaces, nedges, nvert\ninteger i0,j0,k0,jxi,jyi,jzi,jyj,jzj,jzk\ninteger kc1,kc2,kc3,kc7,kc1kc4kc5\n\n! accumulate faces, edges, vertices from adding pixel\nnfaces = 0\nnedges = 0\nnvert = 0\ndo i0 = -1,1,2\n    ! wrap offsets to account for periodic boundaries\n    jxi = modulo(jx+i0,lx)\n    jyi = modulo(jy+i0,ly)\n    jzi = modulo(jz+i0,lz)\n    kc1 = 1-lattice(jxi,jy,jz)\n    kc2 = 1-lattice(jx,jyi,jz)\n    kc3 = 1-lattice(jx,jy,jzi)\n    nfaces = nfaces + kc1 + kc2 + kc3 ! (b.5)\n    do j0 = -1,1,2\n        jyj = modulo(jy+j0,ly)\n        jzj = modulo(jz+j0,lz)\n        kc7 = 1-lattice(jx,jy,jzj)\n        kc1kc4kc5 = kc1*(1-lattice(jxi,jyj,jz))*(1-lattice(jx,jyj,jz))\n        nedges = nedges + kc1kc4kc5 + kc2*(1-lattice(jx,jyi,jzj))*kc7 + kc1*(1-lattice(jxi,jy,jzj))*kc7 ! (b.6)\n        if (kc1kc4kc5.ne.0) then ! whole term (b.7) evaluates to 0 otherwise\n            do k0 = -1,1,2\n                jzk = modulo(jz+k0,lz)\n                nvert = nvert + (1-lattice(jxi,jy,jzk))*(1-lattice(jxi,jyj,jzk))*(1-lattice(jx,jyj,jzk))*(1-lattice(jx,jy,jzk)) ! (b.7, without kc1kc4kc5)\n            end do !k0\n        end if\n    end do ! j0\nend do ! i0\n\nvolume = volume_body\nsurface = surface_body + surface_face*nfaces\ncurvature = curv_body + curv_face*nfaces + curv_edge*nedges\neuler = euler_body + euler_face*nfaces + euler_edge*nedges + euler_vertex*nvert\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named put_line_characters_with_unit to output a string to a specified unit. The subroutine takes 2 input parameters of type integer and character(len=*), and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_characters_with_unit(unit, string, iostat)\n        ! sec. 3.6.3\n        integer, intent(in) :: unit\n        character(len=*), intent(in) :: string\n        integer, optional, intent(out) :: iostat\n\n        if (present(iostat)) then\n            write(unit, fmt='(a,/)', advance='no', iostat=iostat) string\n        else\n            write(unit, fmt='(a,/)', advance='no') string\n        end if\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named test_simple_character. It takes 2 input parameters of type character, with the first parameter being an array and the second one being optional. The output is a character array of the same size as the input array. The subroutine assigns 'a' to each element of the output array and then assigns the corresponding element from the input array if the optional parameter is '1'; otherwise, it assigns a character based on the index.", "input": "", "output": "subroutine test_simple_character(a,c,b)\n  character, intent(in), dimension(:) :: a\n  character, intent(in), optional :: c\n  character, intent(out), dimension(size(a)) :: b\n  ! local\n  integer :: i\n  b(:) = 'a'\n  do i = 1, size(b)\n     if (present(c) .and. (c .eq. '1')) then\n        b(i) = a(i)\n     else\n        b(i) = char(mod(i,3))\n     end if\n  end do\nend subroutine test_simple_character\n"}, {"instruction": "Create a Fortran subroutine named k_star_func that takes a single input parameter of type real(dp) and returns a single output parameter of type real(dp). This subroutine calculates the wake spread parameter using the formula k_star_ust = 0.3837*ti_ust + 0.003678 based on the niayifar and porte agel (2015, 2016) model.", "input": "", "output": "subroutine k_star_func(ti_ust, k_star_ust)\n                                 \n    implicit none\n        \n    ! define precision to be the standard for a double precision ! on local system\n    integer, parameter :: dp = kind(0.d0)\n    \n    ! in\n    real(dp), intent(in) :: ti_ust\n    \n    ! out  \n    real(dp), intent(out) :: k_star_ust\n    \n    ! calculate wake spread parameter from niayifar and porte agel (2015, 2016)\n    k_star_ust = 0.3837*ti_ust+0.003678\n    \nend subroutine k_star_func\n"}, {"instruction": "Create a Fortran subroutine named vecprod to calculate the cross product of two 3-dimensional vectors. The subroutine should take 2 input parameters of type real*8 and intent(in), and 1 output parameter of type real*8 and intent(out). The number of input arguments is 2 and the test_data type is ['real*8', 'real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "subroutine vecprod(a,b,c)\n  implicit none\n  real*8, intent(out) :: c(3)\n  real*8, intent(in)  :: a(3), b(3)\n  c(1)=a(2)*b(3)-a(3)*b(2)\n  c(2)=a(3)*b(1)-a(1)*b(3)\n  c(3)=a(1)*b(2)-a(2)*b(1)\nend subroutine vecprod\n"}, {"instruction": "Write a Fortran subroutine named init_matrix to initialize a matrix with random double-precision values. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type double precision. The input parameters are n1 and n2, representing the dimensions of the matrix, and the output parameter is m, which is a 2D array of size n1 x n2. The subroutine utilizes the features of Fortran, including the subroutine keyword and the intent attribute for input and output parameters.", "input": "", "output": "  subroutine init_matrix(n1, n2, m)\n    integer, intent(in) :: n1, n2\n    double precision, intent(out) :: m(n1, n2)\n\n    integer, parameter :: s = 12345\n    integer :: seed_size\n    integer, allocatable :: seed(:)\n\n    call random_seed(size=seed_size)\n    allocate(seed(seed_size))\n    seed = s\n    call random_seed(put=seed)\n    call random_number(m)\n\n    deallocate(seed)\n  end subroutine init_matrix\n"}, {"instruction": "Write a Fortran subroutine named interpx_cf that takes 4 input parameters: dimx, dimy, dimz of type integer, and a1 of type real(8), dimension(dimx,dimy,dimz). It also has 1 output parameter campo_saida of type real(8), dimension(dimx+1,dimy,dimz). The subroutine computes the interpolation of the input data a1 along the x-axis and stores the result in campo_saida. Make sure to use the imperative tone and specify the types and dimensions of the input and output parameters in the instruction.", "input": "", "output": "subroutine interpx_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx+1,dimy,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=1,dimy\n  do i=2,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i-1,j,k))*0.5\n  enddo\n  i=1\n   !campo_saida(i,j,k)=2.*campo_saida(i+1,j,k)-campo_saida(i+2,j,k)\n   campo_saida(i,j,k)=campo_saida(i+1,j,k)\n  i=dimx+1\n   !campo_saida(i,j,k)=2.*campo_saida(i-1,j,k)-campo_saida(i-2,j,k)\n   campo_saida(i,j,k)=campo_saida(i-1,j,k)\n enddo\nenddo\n\nend subroutine interpx_cf\n"}, {"instruction": "Create a Fortran subroutine named interpx_fc that takes four input parameters: dimx, dimy, dimz of type integer, and a1 of type real(8), with a dimension of (dimx,dimy,dimz). It has one output parameter, campo_saida of type real(8) with a dimension of (dimx-1,dimy,dimz). The subroutine computes the average of adjacent elements along the x-axis of the input array a1 and stores the results in campo_saida using a face-centered to center-centered interpolation scheme.", "input": "", "output": "subroutine interpx_fc(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx-1,dimy,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=1,dimy\n  do i=1,dimx-1\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i+1,j,k))*0.5\n  enddo\n enddo\nenddo\n\n\nend subroutine interpx_fc\n"}, {"instruction": "Write a Fortran subroutine named interpy_cf to interpolate the values of a 3D array from the center to the face. The number of input arguments is 4 and the test_data type is [integer, integer, integer, real(8), dimension(dimx,dimy,dimz)]. The number of output arguments is 1 and the test_data type is [real(8), dimension(dimx,dimy+1,dimz)].", "input": "", "output": "subroutine interpy_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx,dimy+1,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=2,dimy\n  do i=1,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i,j-1,k))*0.5\n  enddo\n enddo\nenddo\ndo k=1,dimz\n do i=1,dimx\n  j=1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j+1,k)-campo_saida(i,j+2,k)\n   campo_saida(i,j,k)=campo_saida(i,j+1,k)\n  j=dimy+1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j-1,k)-campo_saida(i,j-2,k)\n   campo_saida(i,j,k)=campo_saida(i,j-1,k)\n enddo\nenddo\n\nend subroutine interpy_cf\n"}, {"instruction": "Write a Fortran subroutine named interpz_cf that takes 4 input arguments: dimx, dimy, dimz (integer), and a1 (real(8) array of dimension dimx,dimy,dimz). It produces 1 output argument: campo_saida (real(8) array of dimension dimx,dimy,dimz+1). The subroutine computes the interpolation of the input array a1 along the z-direction and stores the result in campo_saida. Remember to use the 'intent(in)' and 'intent(out)' attributes for input and output parameters, respectively.", "input": "", "output": "subroutine interpz_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx,dimy,dimz+1) :: campo_saida\n\n!a1=campo_entrada\ndo k=2,dimz\n do j=1,dimy\n  do i=1,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i,j,k-1))*0.5\n  enddo\n enddo\nenddo\ndo j=1,dimy\n do i=1,dimx\n  k=1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j,k+1)-campo_saida(i,j,k+2)\n   campo_saida(i,j,k)=campo_saida(i,j,k+1)                \n  k=dimz+1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j,k-1)-campo_saida(i,j,k-2)\n   campo_saida(i,j,k)=campo_saida(i,j,k-1)\n\n enddo\nenddo\n\nend subroutine interpz_cf\n"}, {"instruction": "Create a Fortran subroutine named getpropfromx_crit to calculate thermodynamic properties from the given composition. The subroutine takes 1 input parameter of type real and 4 output parameters of type real. The input parameter is x(4) and the output parameters are tc, vc, zc(2), and pc.", "input": "", "output": "  subroutine getpropfromx_crit(x,tc,vc,zc,pc)\n    real, intent(out) :: tc,vc,zc(2),pc\n    real, intent(in) :: x(4)\n    zc(1) = x(1)\n    zc(2) = max(0.0, 1.0 - zc(1))\n    tc = exp(x(2))\n    vc = exp(x(3))\n    pc = exp(x(4))\n  end subroutine getpropfromx_crit\n"}, {"instruction": "Write a Fortran subroutine named getpropfromx_llve to calculate properties from the input array xx. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 7 and the test_data type is [real, real, real, real, real, real, real].", "input": "", "output": "  subroutine getpropfromx_llve(xx,t,vx,vw,vy,x,w,y)\n    real, intent(out) :: t,vx,vw,vy,x(2),w(2),y(2)\n    real, intent(in) :: xx(10)\n    x(1:2) = exp(xx(1:2))\n    w(1:2) = exp(xx(3:4))\n    y(1:2) = exp(xx(5:6))\n    vx = exp(xx(7))\n    vw = exp(xx(8))\n    vy = exp(xx(9))\n    t = exp(xx(10))\n  end subroutine getpropfromx_llve\n"}, {"instruction": "Write a Fortran subroutine named setx_llve that takes 7 input real arguments (t, vx, vw, vy, x(2), w(2), y(2)) and 1 output real argument (xx(10)). The subroutine computes the natural logarithm of each input argument and assigns the results to the elements of the output array xx.", "input": "", "output": "  subroutine setx_llve(t,vx,vw,vy,x,w,y,xx)\n    real, intent(in) :: t,vx,vw,vy,x(2),w(2),y(2)\n    real, intent(out) :: xx(10)\n    xx(1:2) = log(x)\n    xx(3:4) = log(w)\n    xx(5:6) = log(y)\n    xx(7) = log(vx)\n    xx(8) = log(vw)\n    xx(9) = log(vy)\n    xx(10) = log(t)\n  end subroutine setx_llve\n"}, {"instruction": "Create a Fortran subroutine named copy_file to copy a single file from a source location to a destination location, overwriting the existing destination file if necessary. The subroutine should have 3 input parameters of type character(*), character(*), and logical (optional), and 1 output parameter of type integer (optional).", "input": "", "output": "subroutine copy_file(src, dest, overwrite, status)\n!! copy single file from src to dest\n!! overwrites existing destination file\ncharacter(*), intent(in) :: src, dest\nlogical, intent(in), optional :: overwrite\ninteger, intent(out), optional :: status\n\nif(present(status)) then\n  status = -1\n  return\nendif\n\nerror stop \"error:filesystem:fallback doesn't have copy_file\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mkdir to create a directory with parents if needed. The subroutine takes 1 input parameter of type character(*) and 1 optional output parameter of type integer. If the status output parameter is present, it will be assigned a value of -1. If the status parameter is not present, the subroutine will trigger an error stop with the message \"error:filesystem:fallback doesn't have mkdir\".", "input": "", "output": "subroutine mkdir(path, status)\n!! create a directory, with parents if needed\ncharacter(*), intent(in) :: path\ninteger, intent(out), optional :: status\n\nif(present(status)) then\n  status = -1\n  return\nendif\n\nerror stop \"error:filesystem:fallback doesn't have mkdir\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named create_symlink to handle the creation of a symbolic link. This subroutine takes 2 input arguments of type character, tgt and link. It also has an optional output argument of type integer. If the status argument is present, it will return -1. If the status argument is not present, it will trigger an error with the message \"filesystem:fallback doesn't have create_symlink\".", "input": "", "output": "subroutine create_symlink(tgt, link, status)\ncharacter(*), intent(in) :: tgt, link\ninteger, intent(out), optional :: status\nif (present(status)) then\n  status = -1\n  return\nendif\nerror stop \"filesystem:fallback doesn't have create_symlink\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named chmod_exe to set the owner executable bit for a regular file. The subroutine takes 1 input parameter of type character(*) to specify the file path. It also has 1 optional output parameter of type logical to indicate the success of the operation. If successful, the logical output parameter will be set to true; otherwise, the operation will result in an error.", "input": "", "output": "subroutine chmod_exe(path, ok)\n!! set owner executable bit for regular file\ncharacter(*), intent(in) :: path\nlogical, intent(out), optional :: ok\nerror stop \"filesystem:fallback doesn't have chmod_exe\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dcomputewspd to calculate the wind speed from the horizontal wind components. The subroutine takes 4 input parameters: two integers (nx and ny) and two 2D arrays of real(kind=8) type (u and v), and has 1 output parameter: a 2D array of real(kind=8) type (wspd). Remember to use the imperative tone in your instructions.", "input": "", "output": "subroutine dcomputewspd(wspd, u, v, nx, ny)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: wspd\n\n    integer, intent(in) :: nx, ny\n    real(kind=8), dimension(nx,ny), intent(out) :: wspd\n    real(kind=8), dimension(nx,ny), intent(in) :: u, v\n! nclend\n\n    integer i, j\n\n    !$omp parallel do collapse(2) schedule(runtime)\n    do j = 1,ny\n        do i = 1,nx\n            wspd(i,j) = sqrt(u(i,j)*u(i,j) + v(i,j)*v(i,j))\n        end do\n    end do\n    !$omp end parallel do\n\nend subroutine dcomputewspd\n"}, {"instruction": "Create a Fortran subroutine named \"openbinfile\" to open a binary output file. The subroutine should take 3 input arguments of type integer, integer, and character(*) and 1 output argument of type logical.", "input": "", "output": "   subroutine openbinfile ( un, outfile, reclen, error )\n\n\n      ! this routine opens a binary output file.\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the output file.\n   integer, intent(in)          :: reclen                                       ! length of binary record.\n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n   character(*), intent(in)     :: outfile                                      ! name of the output file.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n\n\n      ! open output file.  make sure it worked.\n\n!  open( un, file=trim( outfile ), status='unknown', form='binary' , access='sequential', recl=reclen , iostat=ios )\n   open( un, file=trim( outfile ), status='unknown', form='unformatted' , access='stream', iostat=ios )\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openbinfile ! ( un, outfile, reclen, error )\n"}, {"instruction": "Write a Fortran subroutine named openbininpfile to open a binary input file. The subroutine takes 2 input parameters of types integer and character(*), and 1 output parameter of type logical.", "input": "", "output": "   subroutine openbininpfile ( un, infile, error )\n\n\n      ! this routine opens a binary input file.\n\n   implicit                        none\n\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the input file.\n\n   character(*), intent(in)     :: infile                                       ! name of the input file.\n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n      ! note: do not explicitly declare the precision of this variable [as in\n      !       logical(1)] so that the statements using this variable work with\n      !       any compiler:\n\n\n      ! open input file.  make sure it worked.\n\n!  open( un, file=trim( infile ), status='old', form='binary', iostat=ios, action='read' )\n   open( un, file=trim( infile ), status='old', form='unformatted', access='stream', iostat=ios, action='read' )\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openbininpfile\n"}, {"instruction": "Create a Fortran subroutine named \"openunfinpbefile\" that opens a binary input file with data stored in big endian format. The subroutine should take 3 input parameters of type integer, character(*), and integer, and 1 output parameter of type logical. The input parameters correspond to the logical unit for the input file, the name of the input file, and the size of records in the input file in bytes. The output parameter is a flag indicating whether the open operation failed. Use the imperative tone.", "input": "", "output": "   subroutine openunfinpbefile ( un, infile, reclen, error )\n\n\n      ! this routine opens a binary input file with data stored in big endian format (created on a unix machine.)\n      ! data are stored in reclen-byte records.\n\n   implicit                        none\n\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the input file.\n\n   character(*), intent(in)     :: infile                                       ! name of the input file.\n\n   integer, intent(in)          :: reclen                                       ! size of records in the input file, in bytes. \n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n\n\n      ! open input file.  make sure it worked.\n\n   ! the non-standard convert keyword allows us to read unix binary files, whose bytes are in reverse order (i.e., stored in big endian format).\n\n   ! note: using reclen in bytes requires using the /assume:byterecl compiler option!\n\n   open ( un, file=trim( infile ), status='old', form='unformatted', access='direct', recl=reclen, iostat=ios, &\n                   action='read', convert='big_endian' )                         ! use this for pc systems.\n!                  action='read'  )                                              ! use this for unix systems.\n\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openunfinpbefile\n"}, {"instruction": "Create a Fortran subroutine named get_backward to calculate the backward pass in a neural network. The subroutine takes 7 input parameters of types integer and real*8 and 1 output parameter of type real*8. The input parameters are n_hid, n_obs, steps, mkh, mko, obs, and scaling, while the output parameter is backward. This subroutine computes the backward pass using the given inputs and stores the result in the backward parameter.", "input": "", "output": "subroutine get_backward(n_hid, n_obs, steps, mkh, mko, obs, scaling, backward)\n   implicit none\n   integer, intent(in) :: n_hid\n   integer, intent(in) :: n_obs\n   integer, intent(in) :: steps\n   real*8, intent(in)  :: mkh(n_hid, n_hid)\n   real*8, intent(in)  :: mko(n_obs, n_hid)\n   integer, intent(in) :: obs(steps)\n   real*8, intent(in)  :: scaling(steps)\n   real*8, intent(out) :: backward(steps, n_hid)\n\n   integer :: t\n   backward(steps, :) = scaling(steps)\n\n   do t = steps - 1, 1, -1\n      backward(t, :) = matmul(mko(obs(t+1), :) * backward(t+1, :), mkh) * scaling(t)\n   end do\n\nend subroutine get_backward\n"}, {"instruction": "Write a Fortran subroutine named transposebits that takes three input parameters, where the first two are integers and the third is an integer array. It also has one output parameter of type integer array. The subroutine transposes the bits of the input array elements and stores the result in the output array.", "input": "", "output": "  subroutine transposebits(nsrc, src, ndest, dest)\n    implicit none\n    ! passed parameters\n    integer, intent(in) :: nsrc, ndest\n    integer, dimension(:), intent(in) :: src\n    integer, dimension(:), intent(out) :: dest\n    ! local variables\n    ! src is going to be a small array, so just use automatic arrays\n    integer, dimension(nsrc) :: input ! copy of src\n    integer :: ii, jj, output\n    input = src\n    do ii = ndest, 1, -1\n       output = 0\n       do jj = 1, nsrc\n          output = ishft(output, 1) + mod(input(jj), 2)\n          input(jj) = ishft(input(jj), -1)\n       end do\n       dest(ii) = output\n    end do\n  end subroutine transposebits\n"}, {"instruction": "Create a Fortran subroutine named \"pzxc_sp\" to calculate the exchange-correlation energy and potential for a given density and spin density. The input parameters are two real(8) values for density (trho) and spin density (trho_s), and the output parameters are two real(8) values for the exchange-correlation energy (exc) and two real(8) values for the exchange-correlation potential (vxc_s). Ensure the subroutine utilizes the \"implicit none\" statement and parameter declarations for constants.", "input": "", "output": "  subroutine pzxc_sp(trho,trho_s,exc,vxc_s)\n    implicit none\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gammau=-0.1423d0,gammap=-0.0843d0\n    real(8),parameter :: beta1u=1.0529d0,beta2u=0.3334d0\n    real(8),parameter :: beta1p=1.3981d0,beta2p=0.2611d0\n    real(8),parameter :: au=0.0311d0,bu=-0.048d0\n    real(8),parameter :: cu=0.002d0,du=-0.0116d0\n    real(8),parameter :: ap=0.01555d0,bp=-0.0269d0\n    real(8),parameter :: cp=0.0007d0,dp=-0.0048d0\n    real(8),parameter :: const = 0.75d0*(3d0/(2d0*pi))**(2d0/3d0)\n    real(8) :: rs,cx\n    real(8) :: zeta,sf,dsf\n    real(8) :: ecu,ecp,vcu,vcp\n    real(8) :: sgnsigma(2)\n    integer :: js\n    real(8),intent(in) :: trho,trho_s(2)\n    real(8),intent(out) :: exc\n    real(8),intent(out) :: vxc_s(2)\n\n    sgnsigma(1)=1.d0\n    sgnsigma(2)=-1.d0\n    rs=(3.d0/(4.d0*pi*trho))**(1.d0/3.d0)\n\n    zeta=(trho_s(1)-trho_s(2))/trho\n    sf=((1.d0+zeta)**(4.d0/3.d0)+(1.d0-zeta)**(4.d0/3.d0)-2.d0)/(2.d0**(4.d0/3.d0)-2.d0)\n! dsf=d(smallf)/d(zeta)\n    dsf=4.d0/3.d0*((1.d0+zeta)**(1.d0/3.d0)-(1.d0-zeta)**(1.d0/3.d0))/(2.d0**(4.d0/3.d0)-2.d0)\n\n    cx=3.d0/4.d0*(3.d0/(2*pi))**(2.d0/3.d0)\n\n    exc=-cx/rs+(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*sf\n    do js=1,2\n      vxc_s(js)=exc-1.d0/3.d0*cx/rs+1.d0/3.d0*(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*sf &\n                             +(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*(sgnsigma(js)-zeta)*dsf\n    end do\n\n    if ( rs > 1.d0 ) then\n      ecu=gammau/(1.d0+beta1u*sqrt(rs)+beta2u*rs)\n      ecp=gammap/(1.d0+beta1p*sqrt(rs)+beta2p*rs)\n      vcu=gammau*(1.d0+7.d0/6.d0*beta1u*sqrt(rs)+4.d0/3.d0*beta2u*rs)/(1.d0+beta1u*sqrt(rs)+beta2u*rs)**2\n      vcp=gammap*(1.d0+7.d0/6.d0*beta1p*sqrt(rs)+4.d0/3.d0*beta2p*rs)/(1.d0+beta1p*sqrt(rs)+beta2p*rs)**2\n    else \n      ecu=au*log(rs)+bu+cu*rs*log(rs)+du*rs\n      ecp=ap*log(rs)+bp+cp*rs*log(rs)+dp*rs\n      vcu=au*log(rs)+(bu-au/3.d0)+2.d0/3.d0*cu*rs*log(rs)+(2.d0*du-cu)/3.d0*rs\n      vcp=ap*log(rs)+(bp-ap/3.d0)+2.d0/3.d0*cp*rs*log(rs)+(2.d0*dp-cp)/3.d0*rs\n    end if\n  \n    exc=exc+ecu+sf*(ecp-ecu)\n    do js=1,2\n      vxc_s(js)=vxc_s(js)+vcu+sf*(vcp-vcu)+(ecp-ecu)*(sgnsigma(js)-zeta)*dsf\n    end do\n\n    return\n  end subroutine pzxc_sp\n"}, {"instruction": "Write a Fortran subroutine named is_leap to determine whether a given year is a leap year. The subroutine has 1 input parameter of type integer and 1 output parameter of type logical.", "input": "", "output": "  subroutine is_leap(kyear,lyear)\n    !//---------------------------------------------------------------------\n    !// calculates whether kyear is a leap year.\n    !//\n    !// amund sovde haslerud, january 2017\n    !//---------------------------------------------------------------------\n    implicit none\n    !//---------------------------------------------------------------------\n    integer, intent(in) :: kyear\n    logical, intent(out) :: lyear\n    !//---------------------------------------------------------------------\n\n    !// new leap year calculation includes the special century years:\n    if (mod(kyear,4) .ne. 0) then\n       lyear = .false.\n    else if (mod(kyear,100) .ne. 0) then\n       lyear = .true.\n    else if (mod(kyear,400) .ne. 0) then\n       lyear = .false.\n    else\n       lyear = .true.\n    end if\n\n    !//---------------------------------------------------------------------\n  end subroutine is_leap\n"}, {"instruction": "Write a Fortran subroutine named lcm to calculate the least common multiple of two integers using the Euclidean algorithm for finding the greatest common divisor. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine lcm (nn1,nn2,lcm12)\n    !//---------------------------------------------------------------------\n    !// nlcm = least common multiple of n1 & n2 by euclidean algorithm for gcd\n    !//---------------------------------------------------------------------\n    implicit none\n    !//---------------------------------------------------------------------\n    !// input/output\n    integer, intent(in)  :: nn1, nn2\n    integer, intent(out) :: lcm12\n    !// locals\n    integer :: n1, n2, n3, gcd\n    !//---------------------------------------------------------------------\n\n    n1 = nn1\n    n2 = nn2\n    n3 = mod(n1, n2)\n    do while (n3.ne.0)\n       n1 = n2\n       n2 = n3\n       n3 = mod(n1, n2)\n    end do\n    gcd = n2\n    lcm12 = nn1*nn2/gcd\n\n    !//---------------------------------------------------------------------\n  end subroutine lcm\n"}, {"instruction": "Write a Fortran subroutine named dmkldm that takes one input argument of type integer and returns one output argument of type integer. The subroutine computes the value of lda based on the input argument m, which represents the leading dimension of a matrix. If m is less than 0, the subroutine returns without further computation. Otherwise, it calculates lda as m and adjusts lda to be a multiple of 8 if it's not already.", "input": "", "output": "pure subroutine dmkldm(m, lda)\n  implicit none\n\n  integer, intent(in) :: m\n  integer, intent(out) :: lda\n\n  integer :: r\n\n  lda = m\n  if (m .lt. 0) return\n\n  r = mod(lda, 8)\n  if (r .ne. 0) lda = lda + (8 - r)\nend subroutine dmkldm\n"}, {"instruction": "Write a Fortran subroutine named multiply to perform matrix-vector multiplication. The subroutine takes 2 input parameters of type real(8) - a 2D array 'a' and a 1D array 'b', and 1 output parameter of type real(8) - 1D array 'c'.", "input": "", "output": "     subroutine multiply(a,b,c)\n! \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u043d\u0430 \u0432\u0435\u043a\u0442\u043e\u0440 c[m]:=a[m,n]*b[n]\n\treal(8), intent(in)  :: a(:,:),b(:)\n\treal(8), intent(out) :: c(:)\n\tinteger m,n\n\tinteger i,k\n    real(8) :: t\n\n    m=size(a,dim=1);\tn=size(a,dim=2)\n\tif (size(b)/=n .or. size(c)/=m) then\n\t stop 'incompatible size in multiply'\n\tendif\n      \n      do i=1,m\n       t=0.0\n       do k=1,n\n        t=t+a(i,k)*b(k)\n       enddo\n       c(i)=t\n\tenddo\n\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named getskillspecs that takes an array of character strings as input and returns three arrays: one of character strings and two of logical values. The input parameter has a count of 1 and the data type is ['character(len=32)'], while the output parameters have a count of 3 and the data types are ['character(len=32)', 'logical', 'logical']. The subroutine summarizes skill specifications based on input data and assigns corresponding values to the output arrays.", "input": "", "output": "subroutine getskillspecs(factorname,skillname,rasch,raschslope1)\r\nimplicit none\r\ncharacter(len=32),intent(in)::factorname(:)\r\ncharacter(len=32),intent(out)::skillname(:)\r\nlogical,intent(out)::rasch(:),raschslope1(:)\r\n!\tbuffer is a character buffer\r\ncharacter(len=4)::buffer\r\n!\tskill_name is a skill name\r\ncharacter(len=32)::skill_name\r\n!\tio is an input flag.\r\n!\tskill counts skills.\r\ninteger::io,skill\r\n!\trasch_model is for a rasch-type model.\r\n!\trasch_slope_1 is for a rasch-type model with a slope parameter of 1.\r\n!\tif repeat_names, skill names are obtained from factor names.\r\n!\tskill_specs indicates that data are required on individual skills.\r\nlogical::rasch_model,rasch_slope_1,repeat_names,skill_specs\r\nnamelist/allskillspecs/rasch_model,rasch_slope_1,repeat_names,skill_specs\r\nnamelist/skillspecs/skill_name,rasch_model,rasch_slope_1\r\n!\tdefault names.\r\ndo skill=1,size(skillname)\r\n\twrite(buffer,'(i4)') skill\r\n\tskillname(skill)=trim(\"skill\"//adjustl(buffer))\r\nend do\r\n!\tdefaults\r\nrasch_model=.false.\r\nrasch_slope_1=.false.\r\nrepeat_names=.false.\r\nif(size(factorname)==size(skillname))repeat_names=.true.\r\nskill_specs=.false.\r\nread(*,nml=allskillspecs,iostat=io)\r\nif(io/=0)stop \"skill specifications cannot be read.\"\r\nrasch=rasch_model\r\nraschslope1=rasch_slope_1\r\nif(repeat_names)then\r\n\tskill=min(size(factorname),size(skillname))\r\n\tskillname(1:skill)=factorname(1:skill)\r\nend if\t\r\n!\tindividual skills.\r\nif(skill_specs)then\r\n\tdo skill=1,size(skillname)\r\n\t\trasch_model=rasch(skill)\r\n\t\trasch_slope_1=raschslope1(skill)\r\n\t\tskill_name=skillname(skill)\r\n\t\tread(*,nml=skillspecs,iostat=io)\r\n\t\tif(io/=0)stop \"skill specifications cannot be read.\"\r\n\t\trasch(skill)=rasch_model\r\n\t\traschslope1(skill)=rasch_slope_1\r\n\t\tskillname(skill)=skill_name\r\n\tend do\r\nend if\r\n!\traschslope1 implies rasch.\r\nrasch=rasch.or.raschslope1\r\nreturn\r\nend subroutine getskillspecs\r\n"}, {"instruction": "Write a Fortran subroutine named \"foo\" that takes an array of strings as input and assigns the second element of the array to an allocatable string. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=*), allocatable'].", "input": "", "output": "  subroutine foo (xx,yy)\n  character(len=*), intent(in)               :: xx(:)\n  character(len=*), intent(out), allocatable :: yy(:)\n  if (allocated (yy)) deallocate (yy)\n  allocate (yy(1))\n  yy = xx(2)\n  end subroutine foo\n"}, {"instruction": "Create a Fortran subroutine named calc_distance to calculate the distance vector, scalar distance, and truncated distance between particles i and j. The subroutine should have 5 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'real(kind=8),dimension(nd,np)', 'integer(kind=4)', 'integer(kind=4)'], and 3 output parameters of types ['real(kind=8),dimension(nd)', 'real(kind=8)', 'real(kind=8)'].", "input": "", "output": "subroutine calc_distance (np, nd, pos, i, j, rij, d, d2)\n!\n!  calculate distance vector, scalar distance and trucated distance\n!  between atoms i and j.\n!  the distance is truncated at pi/2\n!\n    implicit none\n    integer(kind=4),intent(in) :: np                ! number of particles\n    integer(kind=4),intent(in) :: nd                ! number of dimensions\n    real(kind=8),intent(in),dimension(nd,np) :: pos ! positions\n    integer(kind=4),intent(in) :: i                 ! index particle i\n    integer(kind=4),intent(in) :: j                 ! index particle j\n    real(kind=8),intent(out),dimension(nd) :: rij   ! distance vector\n    real(kind=8),intent(out) :: d                   ! distance\n    real(kind=8),intent(out) :: d2                  ! trucated distance\n\n    real ( kind = 8 ), parameter :: pi2 = 3.141592653589793d+00 / 2.0d+00\n\n    rij(1:nd) = pos(1:nd,i) - pos(1:nd,j)\n\n    d = sqrt ( sum ( rij(1:nd)**2 ) )\n\n    !  truncate the distance:\n    d2 = min ( d, pi2 )\nend subroutine calc_distance\n"}, {"instruction": "Create a Fortran subroutine named \"s\" that takes an integer input parameter and returns an integer output parameter. The input parameter should be declared with the \"intent(in)\" attribute, and the output parameter should be declared with the \"intent(out)\" attribute. The subroutine should calculate the sum of the input parameter and a predefined integer value, and then print the result. Finally, the subroutine should assign the value 77 to the output parameter.", "input": "", "output": "  subroutine s(j,k)\n    integer,intent(in)::j\n    integer,intent(out)::k\n    integer::i=1\n    print '(i0)',i+j\n    k=77\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sistupf\" to solve a system of linear equations using forward substitution. The subroutine takes 3 input parameters: a real 2D array \"a\", a real 1D array \"b\", and an integer 1D array \"l\". It also has 1 output parameter: a real 1D array \"u\".", "input": "", "output": "subroutine sistupf(a, b, l, u)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: u\n\ninteger, dimension(:), intent(in) :: l\n\ninteger :: ln, li\n\ninteger :: n, i, j, p\n\nn = size(b)\n\nln = l(n)\n\nu(n) = b(ln)/a(ln,n)\n\ndo i = n-1, 1, -1\n\n  li = l(i)\n  u(i) = b(li)\n  do j = i+1, n\n    u(i) = u(i) - a(li,j)*u(j)\n  enddo\n\n  u(i) = u(i)/a(li,i)\nenddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dq that takes three input arrays of type double precision and one output array of type double precision. The input arrays are dqx, gx, and cx, and the output array is dqx. The subroutine computes the values of dqx using the formulas provided in the code. Be sure to specify the intent of each input parameter as \"in\" and the output parameter as \"out.\"", "input": "", "output": "    subroutine dq(dqx, gx, cx, dcx)\n        double precision, intent(out) :: dqx(:)\n        double precision, intent(in)  :: gx(:)\n        double precision, intent(in)  :: cx(:)\n        double precision, intent(in)  :: dcx(:, :)\n        integer :: k, i\n\n        dqx(:) = gx(:)\n\n        do k = 1, m\n            do i = 1, n\n                dqx(i) = dqx(i) + cx(k)*dcx(k, i)/mu\n            end do\n        end do\n    end subroutine dq\n"}, {"instruction": "Write a Fortran subroutine named \"v\" to perform a specific computation. The subroutine takes one input parameter of type \"double precision\" and intent \"in\" and one output parameter of type \"double precision\" and intent \"out\". The input parameter is an array named \"dqx\" and the output parameter is an array named \"vx\". The subroutine computes the values of \"vx\" based on the values of \"dqx\" according to the provided logic.", "input": "", "output": "    subroutine v(vx, dqx)\n        double precision, intent(out) :: vx(:)\n        double precision, intent(in) :: dqx(:)\n        integer i\n\n        do i = 1, n\n            vx(i) = -dqx(i)\n        end do\n\n        do i = n+1, n+m\n            vx(i) = 0.d0\n        end do\n    end subroutine v\n"}, {"instruction": "Write a Fortran subroutine named moments that calculates the average and standard deviation of a dataset. The subroutine takes 3 input parameters of types integer, integer, and double precision array, and 2 output parameters of type double precision.", "input": "", "output": "      subroutine moments(imax, dat, n, ave, sdev)\n      implicit none\n! arguments\n      integer, intent(in) :: imax, n\n      double precision, dimension(imax), intent(in) :: dat\n      double precision, intent(out) :: sdev, ave\n! local variables\n      double precision :: var, s, p\n      integer :: j\n!***********************************************************************\n      sdev = 0.0d0\n      if ( n<2 ) then\n!        print *, 'n must be at least 2'\n!  markstro      stop\n         ave = dat(1)\n         return\n      endif\n      s = 0.0d0\n      do j = 1, n\n        s = s + dat(j)\n      enddo\n      ave = s/n\n      var = 0.0d0\n      do j = 1, n\n        s = dat(j) - ave\n        p = s*s\n        var = var + p\n      enddo\n      var = var/(n-1)\n      sdev = sqrt(var)\n      end subroutine moments\n"}, {"instruction": "Create a Fortran subroutine named pcl2pe to transfer the loop momenta q, q+p1, q+p1+p2, q+p1+p2+p3, etc., to p1, p2, p3, p4, etc. The number of input arguments is 2, and the test_data type is ['integer', 'real(kind(1d0)),dimension(nloopline,0:3)']. The number of output arguments is 1, and the test_data type is ['real(kind(1d0)),dimension(nloopline,0:3)']. Within the subroutine, the loop momenta are utilized to compute the values of p1, p2, p3, p4, etc.", "input": "", "output": "  subroutine pcl2pe(nloopline,pcl,pe)\n    ! transfer the loop momenta q,q+p1,q+p1+p2,q+p1+p2+p3,... \n    ! to p1,p2,p3,p4,... \n    implicit none\n    integer,intent(in)::nloopline\n    real(kind(1d0)),dimension(nloopline,0:3),intent(in)::pcl\n    real(kind(1d0)),dimension(nloopline,0:3),intent(out)::pe\n    integer::i\n    do i=1,nloopline-1\n       pe(i,0:3)=pcl(i+1,0:3)-pcl(i,0:3)\n    enddo\n    pe(nloopline,0:3)=pcl(1,0:3)-pcl(nloopline,0:3)\n    return\n  end subroutine pcl2pe\n"}, {"instruction": "Create a Fortran subroutine named coarsenfield to downsample a 2D field by averaging non-overlapping blocks of elements. The subroutine takes 2 input parameters of type real and integer, and 1 output parameter of type real.", "input": "", "output": "subroutine coarsenfield(field_src, field_dst, ratio)\n  real, intent(in) :: field_src(:,:)\n  real, intent(out) :: field_dst(:,:)\n  integer, intent(in) :: ratio\n\n  integer :: i,j\n  integer :: isub,jsub\n  integer :: im,jm\n\n  integer :: stride\n\n  real :: invnumpoints\n\n  invnumpoints = (1 / dble(ratio))**2\n  stride = ratio - 1\n\n  im = size(field_dst, dim=1)\n  jm = size(field_dst, dim=2)\n\n  ! loop over the coarse grid and average values from the fine grid:\n  do j = 1, jm\n    jsub = (j - 1) * ratio + 1\n    do i = 1, im\n      isub = (i - 1) * ratio + 1\n      field_dst(i,j) = sum(field_src(isub:isub+stride,jsub:jsub+stride)) * invnumpoints\n    end do\n  end do\n\nend subroutine coarsenfield\n"}, {"instruction": "Write a Fortran subroutine named getscales to read and generate scale values for a given range of scores. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 2 and the test_data type is [character(len=*), real(kind=8)]. The subroutine uses the namelist input/output feature and allocatable arrays for scalability.", "input": "", "output": "subroutine getscales(maxscore,minscore,numberscales,scalename,scale)\r\nimplicit none\r\ncharacter(len=*),intent(out)::scalename(:)\r\ninteger,intent(in)::maxscore,minscore,numberscales\r\nreal(kind=8),intent(out)::scale(numberscales,minscore:maxscore)\r\n!\tuse a buffer for counts.\r\ncharacter(len=4)::buffer\r\n!\tcopy of scalename.\r\ncharacter(len=32),allocatable::scalenames(:)\r\n!\ti is an index.\r\n!\tio is flag for input error.\r\ninteger::i,io\r\n!\tscalevalues are values of scale.\r\nreal(kind=8),allocatable::scalevalues(:,:)\r\nnamelist/scales/scalenames,scalevalues\r\nallocate(scalenames(numberscales),scalevalues(numberscales,minscore:maxscore),stat=io)\r\nif(io/=0)stop 'cannot allocate space for scales.'\r\ndo i=minscore,maxscore\r\n\tscalevalues(:,i)=i\r\nend do\r\ndo i=1,numberscales\r\n\twrite(buffer,'(i4)') i\r\n\tscalenames(i)='scale'//trim(adjustl(buffer))\r\nend do\r\nread(*,nml=scales,iostat=io)\r\nif(io/=0) stop 'unable to read scales.'\r\nscalename=scalenames\r\nscale=scalevalues\r\nreturn\r\nend subroutine getscales\r\n"}, {"instruction": "Create a Fortran subroutine named gen_random_numbers_complex to generate an array of complex numbers. The subroutine takes 1 input argument of type integer and produces 1 output argument of type complex(8).", "input": "", "output": "  subroutine gen_random_numbers_complex(n,rand)\n    integer,intent(in) :: n\n    complex(8),intent(out) :: rand(n)\n\n    integer :: i, seedsize\n    integer,allocatable :: seed(:)\n    integer :: zikoku\n    real(8) :: ransu(2*n)\n    \n    call system_clock(count=zikoku)\n    call random_seed(size=seedsize)\n    allocate(seed(seedsize))\n    seed=zikoku\n    call random_seed(put=seed)\n    call random_number(ransu)\n    deallocate(seed)\n    do i=1,n\n       !rand(i)=cmplx(ransu(2*i-1),ransu(2*i),kind(1.d0))\n       !rand(i)=1.d0\n       rand(i)=dble(i)\n    end do\n    \n  end subroutine gen_random_numbers_complex\n"}, {"instruction": "Create a Fortran subroutine named ascii_input to convert an integer to its corresponding ASCII character. The subroutine should take 1 input parameter of type integer(kind=2) and provide 1 output parameter of type character(len=2).", "input": "", "output": "      subroutine ascii_input(ascii,i)\r\n      implicit none\r\n      character(len=2), intent(out) :: ascii\r\n      integer(kind=2), intent(in) :: i\r\n\r\n      ascii = achar(i)\r\n      \r\n      end subroutine ascii_input\r\n"}, {"instruction": "Create a Fortran subroutine named \"latlon\" to convert latitude and longitude values. The subroutine takes 6 input parameters: 4 integers and 2 real numbers. The test_data type is ['integer(kind=4)', 'integer(kind=4)', 'real(kind=4)', 'real(kind=4)', 'real(kind=4)', 'real(kind=4)']. It returns 2 output parameters, both of type real(kind=8) and of dimension nlat and mlon respectively. The subroutine uses imperative tone to calculate the latitudes and longitudes and assigns them to the output parameters.", "input": "", "output": "    subroutine latlon(blat,blon,ydegr,xdegr,nlat,mlon,ylat,xlon)\n\n    implicit none\n\n    !! global namespace\n    integer(kind=4), intent(in) :: nlat\n    integer(kind=4), intent(in) :: mlon\n    real(kind=4),    intent(in) :: ydegr\n    real(kind=4),    intent(in) :: xdegr\n    real(kind=4),    intent(in) :: blat\n    real(kind=4),    intent(in) :: blon\n    real(kind=8),    dimension(nlat), intent(out)  :: ylat\n    real(kind=8),    dimension(mlon), intent(out)  :: xlon\n\n    !! local namespace\n    integer(kind=4)                                :: ilon\n    integer(kind=4)                                :: ilat\n\n    !! longitudes going from -180 to 180\n    do ilon = 1,mlon\n       xlon(ilon) = -blon + (ilon-1)*xdegr\n    end do\n  \n    !! latitudes going from 90 to -90\n    do ilat = 1,nlat\n       ylat(ilat) = blat - ilat*ydegr\n    end do\n\n    return\n    \n  end subroutine latlon\n"}, {"instruction": "Create a Fortran subroutine named modelb_function1 to calculate the square of the input real number and store it in one output parameter, while also copying the input value to another output parameter. The number of input parameters is 1 of type real, and the number of output parameters is 2 of type real.", "input": "", "output": "subroutine modelb_function1(in_val, in_val_copy, out_val)\n  ! only valid if in_val <= 2\n  real, intent(in) :: in_val\n  real, intent(out) :: in_val_copy\n  real, intent(out) :: out_val\n  in_val_copy = in_val\n  out_val = in_val**2\n  print *, \"modelb_function1(\", in_val, \") = \", out_val\nend subroutine modelb_function1\n"}, {"instruction": "Write a Fortran subroutine named get_fathers to retrieve the IDs and masses of the father halos. The subroutine takes 1 input parameter of type integer and outputs 2 parameters: an integer array of dimension nb_of_fathers and a real array of dimension nb_of_fathers.", "input": "", "output": "  subroutine get_fathers(nb_of_fathers, id_fathers, m_fathers)\n    integer, intent(in)                                 :: nb_of_fathers !> number of son of the halo\n    integer, dimension(nb_of_fathers), intent(out)      :: id_fathers     !> id of the father\n    real(kind=4), dimension(nb_of_fathers), intent(out) :: m_fathers      !> mass of the father\n\n    id_fathers = tmp_id_fathers\n    m_fathers = tmp_m_fathers\n  end subroutine get_fathers\n"}, {"instruction": "Create a Fortran subroutine named get_sons. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer array with a size determined by the input parameter. The input parameter represents the number of sons of a halo, and the output parameter contains the ids of the sons of the halo. Use the \"intent(in)\" and \"intent(out)\" keywords to specify the input and output parameters.", "input": "", "output": "  subroutine get_sons(nb_of_sons, id_sons)\n    integer, intent(in)                         :: nb_of_sons!> number of son of the halo\n    integer, dimension(nb_of_sons), intent(out) :: id_sons    !> ids of the son of the halo\n\n    id_sons = tmp_id_sons\n  end subroutine get_sons\n"}, {"instruction": "Create a Fortran subroutine named change_strings to modify input strings by appending 'a' to the end of each string. The subroutine takes 2 input parameters - an integer and a character array of dimension (2, n_strs). It produces 1 output parameter - a character array of dimension (2, n_strs).", "input": "", "output": "subroutine change_strings(strings, n_strs, out_strings)\r\n    implicit none\r\n\r\n    ! inputs\r\n    integer, intent(in) :: n_strs\r\n    character, intent(in), dimension(2,n_strs) :: strings\r\n    character, intent(out), dimension(2,n_strs) :: out_strings\r\n\r\n!f2py integer, intent(in) :: n_strs\r\n!f2py character, intent(in), dimension(2,n_strs) :: strings\r\n!f2py character, intent(out), dimension(2,n_strs) :: strings\r\n\r\n    ! misc.\r\n    integer*4 :: j\r\n\r\n\r\n    do j=1, n_strs\r\n        out_strings(1,j) = strings(1,j)\r\n        out_strings(2,j) = 'a'\r\n    end do\r\n\r\nend subroutine change_strings\r\n"}, {"instruction": "Create a Fortran subroutine named simul to solve a system of linear equations using the Gaussian elimination method. The subroutine takes 4 input parameters of types integer, real array of dimension (ndim,ndim), real array of dimension (ndim), and integer. It returns 2 output parameters of types real array of dimension (ndim) and integer.", "input": "", "output": "subroutine simul ( a, b, soln, ndim, n, error )\nimplicit none\n! data dictionary: declare calling parameter types & definitions\ninteger, intent(in) :: ndim\n! dimension of arrays a and b\nreal, intent(in), dimension(ndim,ndim) :: a\n! array of coefficients (n x n).\n! this array is of size ndim x\n! ndim, but only n x n of the\n! coefficients are being used.\nreal, intent(in), dimension(ndim) :: b\n! input: right-hand side of eqns.\nreal, intent(out), dimension(ndim) :: soln\n! output: solution vector.\ninteger, intent(in) :: n\n! number of equations to solve.\ninteger, intent(out) :: error\nreal, parameter :: epsilon = 1.0e-6 ! a \"small\" number for comparison\n! when determining singular eqns\n! data dictionary: declare local variable types & definitions\nreal, dimension(n,n) :: a1\n! copy of \"a\" which will be\n! destroyed during the solution\nreal :: factor\n! factor to multiply eqn irow by\n! before adding to eqn jrow\ninteger :: irow\n! number of the equation currently\n! being processed\ninteger :: ipeak\n! pointer to equation containing\n! maximum pivot value\ninteger :: jrow\n! number of the equation compared\n! to the current equation\nreal :: temp\n! scratch value\n\nreal, dimension(n) :: temp1\n! scratch array\n! make copies of arrays \"a\" and \"b\" for local use\na1 = a(1:n,1:n)\nsoln = b(1:n)\n! process n times to get all equations...\nmainloop: do irow = 1, n\n! find peak pivot for column irow in rows irow to n\nipeak = irow\nmax_pivot: do jrow = irow+1, n\nif (abs(a1(jrow,irow)) > abs(a1(ipeak,irow))) then\nipeak = jrow\nend if\nend do max_pivot\n! check for singular equations.\nsingular: if ( abs(a1(ipeak,irow)) < epsilon ) then\nerror = 1\nreturn\nend if singular\n! otherwise, if ipeak /= irow, swap equations irow & ipeak\nswap_eqn: if ( ipeak /= irow ) then\ntemp1 = a1(ipeak,1:n)\na1(ipeak,1:n) = a1(irow,1:n)\n! swap rows in a\na1(irow,1:n) = temp1\ntemp = soln(ipeak)\nsoln(ipeak) = soln(irow)\n! swap rows in b\nsoln(irow) = temp\nend if swap_eqn\n\n! multiply equation irow by -a1(jrow,irow)/a1(irow,irow),\n! and add it to eqn jrow (for all eqns except irow itself).\neliminate: do jrow = 1, n\nif ( jrow /= irow ) then\nfactor = -a1(jrow,irow)/a1(irow,irow)\na1(jrow,:) = a1(irow,1:n)*factor + a1(jrow,1:n)\nsoln(jrow) = soln(irow)*factor + soln(jrow)\nend if\nend do eliminate\nend do mainloop\n! end of main loop over all equations. all off-diagonal terms\n! are now zero. to get the final answer, we must divide\n! each equation by the coefficient of its on-diagonal term.\ndivide: do irow = 1, n\nsoln(irow) = soln(irow) / a1(irow,irow)\na1(irow,irow) = 1.\nend do divide\n! set error flag to 0 and return.\nerror = 0\nend subroutine simul\n"}, {"instruction": "Create a Fortran subroutine named spl_derivative_matrix to calculate the derivative matrix for a given set of knots and spline order. The subroutine takes 4 input parameters: n (integer), p (integer), knots (real(8) array), and normalize (optional logical). It outputs a matrix of real(8) values.", "input": "", "output": "  subroutine spl_derivative_matrix(n, p, knots, mat, normalize)\n  implicit none\n    integer,                 intent(in)  :: n\n    integer,                 intent(in)  :: p\n    real(8), dimension(:),   intent(in)  :: knots\n    real(8), dimension(:,:), intent(out) :: mat \n    logical, optional      , intent(in)  :: normalize\n    ! local\n    integer :: i\n    integer :: j \n    real(8) :: alpha\n    logical :: l_normalize\n\n    ! ...\n    l_normalize = .false.\n    if (present(normalize)) then\n      l_normalize = normalize\n    end if\n    ! ...\n\n    ! ...\n    mat = 0.0d0\n    ! ...\n\n    ! ...\n    i = 1\n    mat(i,i)   =  1.0d0 \n\n    if (.not. l_normalize) then\n      alpha      = p * 1.0d0 / (knots(i+p+1) - knots(i)) \n\n      mat(i,i)   =   alpha * mat(i,i)\n    end if\n    ! ...\n\n    ! ...\n    do i = 2, n \n      ! ...\n      mat(i,i)   =  1.0d0 \n      mat(i-1,i) = -1.0d0 \n      ! ...\n\n      ! ...\n      if (.not. l_normalize) then\n        alpha      = p * 1.0d0 / (knots(i+p+1) - knots(i)) \n\n        mat(i,i)   =   alpha * mat(i,i)\n        mat(i-1,i) = - alpha * mat(i-1,i) \n      end if\n      ! ...\n    end do\n    ! ...\n\n  end subroutine spl_derivative_matrix\n"}, {"instruction": "Create a Fortran subroutine named spl_compute_spans to calculate the spans of elements in a spline curve. The subroutine takes 3 input parameters of type integer, integer, and real(kind=8) array, and 1 output parameter of type integer array.", "input": "", "output": "  subroutine spl_compute_spans(p, n, knots, elements_spans)\n  implicit none\n    integer,                    intent(in)  :: n\n    integer,                    intent(in)  :: p\n    real(kind=8), dimension(:), intent(in)  :: knots\n    integer,      dimension(:), intent(out) :: elements_spans\n    ! local variables\n    integer :: i_element\n    integer :: i_knot\n    integer :: i_b\n    integer :: i_e\n\n    ! ...\n    elements_spans = -1 \n    ! ...\n\n    ! ...\n    i_b = lbound(knots, 1)\n    i_e = ubound(knots, 1)\n    ! ...\n\n    ! ...\n    i_element = 0\n    do i_knot = i_b, i_e - p - 1 \n      ! we check if the element has zero measure\n      if ( knots(i_knot) /= knots(i_knot + 1) ) then\n        i_element = i_element + 1\n        \n        elements_spans(i_element) = i_knot\n      end if\n    end do\n    ! ...\n     \n  end subroutine spl_compute_spans \n"}, {"instruction": "Create a Fortran subroutine named spl_construct_grid_from_knots to construct a grid from the given knots for spline interpolation. The subroutine takes 4 input parameters of type integer, integer, integer, and real(kind=8) array, and 1 output parameter of type real(kind=8) array.", "input": "", "output": "  subroutine spl_construct_grid_from_knots(p, n, n_elements, knots, grid)\n    implicit none\n    integer, intent(in)  :: p\n    integer, intent(in)  :: n\n    integer, intent(in)  :: n_elements\n    real(kind=8), dimension(:), intent(in)  :: knots\n    real(kind=8), dimension(:), intent(out) :: grid\n    ! local\n    integer :: i\n    integer :: i_b\n    integer :: i_e\n\n    ! ...\n    i_b = lbound(knots, 1)\n    i_e = ubound(knots, 1)\n    ! ...\n\n    ! ...\n    grid = 0.0\n    do i = i_b, i_b+n_elements, 1\n      grid(i) = knots(i + p)\n    end do\n    ! ...\n\n  end subroutine spl_construct_grid_from_knots\n"}, {"instruction": "Create a Fortran subroutine named spl_construct_quadrature_grid to calculate the quadrature grid points and weights for a given set of parameters. The subroutine has 3 input parameters of type real(kind=8), dimension(:), and 2 output parameters of type real(kind=8), dimension(:,:).\n\nThe subroutine takes 3 input parameters of type real(kind=8), dimension(:) named u, w, and grid, and calculates the points and weights for the quadrature grid. The calculated points and weights are stored in the output parameters points and weights, both of type real(kind=8), dimension(:,:).\n\nThe subroutine uses imperative tone and reflects the features of Fortran subroutine.", "input": "", "output": "  subroutine spl_construct_quadrature_grid(u, w, grid, points, weights)\n    implicit none\n    real(kind=8), dimension(:), intent(in) :: u\n    real(kind=8), dimension(:), intent(in) :: w\n    real(kind=8), dimension(:), intent(in) :: grid \n    real(kind=8), dimension(:,:), intent(out) :: points\n    real(kind=8), dimension(:,:), intent(out) :: weights\n    ! local\n    integer :: i_b\n    integer :: i_e\n    integer :: k_b\n    integer :: k_e\n    integer :: i_element\n    integer :: i_point\n    real(kind=8) :: a\n    real(kind=8) :: b\n    real(kind=8) :: half\n\n    ! ...\n    i_b = lbound(grid, 1)\n    i_e = ubound(grid, 1)\n\n    k_b = lbound(u, 1)\n    k_e = ubound(u, 1)\n    ! ...\n\n    points  = 0.0\n    weights = 0.0\n\n    do i_element = i_b, -1 + i_e, 1\n      a = grid(i_element)\n      b = grid(i_element + 1)\n      half = 0.5d0*(-a + b)\n\n      do i_point = k_b, k_e, 1\n        points(i_point, i_element) = (u(i_point) + 1.0d0)*half + a\n        weights(i_point, i_element) = w(i_point)*half\n      end do\n    end do\n\n  end subroutine spl_construct_quadrature_grid\n"}, {"instruction": "Create a Fortran subroutine named \"getjminmax\" to determine the values of \"j_min\" and \"j_max\" based on the input parameters \"l\" and \"n\". The subroutine should have 2 input parameters of type integer, [\"l\", \"n\"], and 2 output parameters of type integer, [\"j_min\", \"j_max\"]. The purpose of the subroutine is to calculate the values of \"j_min\" and \"j_max\" according to specific conditions based on the values of \"l\" and \"n\".", "input": "", "output": "      subroutine getjminmax(l,n,j_min,j_max)\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      integer, intent(in) :: l, n\n      integer, intent(out):: j_min,j_max\n!-----------------------------------------------\n!\n      if(n==0 .or. 4*l+2-n==0) then\n         j_min = 0\n         j_max = 0\n      else if(n==1 .or. 4*l+2-n==1) then\n         j_min = iabs(2*l-1)\n         j_max = 2*l+1\n      else if(n==2 .or. 4*l+2-n==2) then\n         j_min = 0\n         j_max = 4*l\n      else if(l == 1) then\n         if(n==3) then\n            j_min = 1\n            j_max = 5\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else if(l==2) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==7) then\n            j_min = 1\n            j_max = 11\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==6) then\n            j_min = 0\n            j_max = 12\n         else if(n==5) then\n            j_min = 1\n            j_max = 13\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else if(l==3) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==11) then\n            j_min = 1\n            j_max = 17\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==10) then\n            j_min = 0\n            j_max = 20\n!gg!         else if(n==5) then\n         else if(n==5 .or. n==9) then\n            j_min = 1\n            j_max = 23\n!gg!         else if(n==6) then\n         else if(n==6 .or. n==8) then\n            j_min = 0\n            j_max = 24\n         else if(n==7) then\n            j_min = 1\n            j_max = 25\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else\n         write(6,'(a)') 'error in getjminmax'\n         write(6,'(a6,2i5)') 'l,n = ',l,n\n         stop\n      end if\n      return\n      end subroutine getjminmax\n"}, {"instruction": "Create a Fortran subroutine named getjjjminmax that takes 2 input parameters of type integer and returns 2 output parameters of type integer. The subroutine evaluates the values of j_min and j_max based on the input parameters j and n, according to a set of conditional statements. If the conditions are met, the subroutine assigns specific values to j_min and j_max; otherwise, it outputs an error message and stops the program.", "input": "", "output": "      subroutine getjjjminmax(j,n,j_min,j_max)\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      integer, intent(in) :: j, n\n      integer, intent(out):: j_min,j_max\n!-----------------------------------------------\n!\n      if(n==0 .or. j+1-n==0) then\n         j_min = 0\n         j_max = 0\n      else if(n==1 .or. j+1-n==1) then\n         j_min = j\n         j_max = j\n      else if(n==2 .or. j+1-n==2) then\n         j_min = 0\n         j_max = 2*(j-1)\n      else if(j == 5) then\n         if(n==3) then\n!gg!!            j_min = 5\n            j_min = 3\n            j_max = 9\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else if(j==7) then\n         if(n==3 .or. n==5) then\n!gg!!            j_min = 7\n            j_min = 3\n            j_max = 15\n         else if(n==4) then\n            j_min = 0\n            j_max = 16\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else if(j==9) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==7) then\n            j_min = 3\n            j_max = 21\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==6) then\n            j_min = 0\n            j_max = 24\n         else if(n==5) then\n            j_min = 3\n            j_max = 25\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else\n         write(6,'(a)') 'error in getjjjminmax'\n         write(6,'(a8,2i5)') '2*j,n = ',j,n\n         stop\n      end if\n      return\n      end subroutine getjjjminmax\n"}, {"instruction": "Write a Fortran subroutine named diffq_spm to compute the differential equations for a specific physical system. The number of input arguments is 5 and the test_data type is ['real(kind=8), dimension(6)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(6)'].", "input": "", "output": "  subroutine diffq_spm(x, mass1, mass2, eps1, eps2, f)\n\n    implicit none\n    real(kind=8), dimension(6), intent(in) :: x\n    real(kind=8), intent(in) :: mass1, mass2\n    real(kind=8), intent(in) :: eps1, eps2\n    real(kind=8), dimension(6), intent(out):: f\n\n    real(kind=8) :: r21, r1, a1\n\n\n\n    r21=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)\n    r1=sqrt(r21)\n\n    a1 = -mass1 / (r21 + eps1) - mass2 / (r21 + eps2)\n\n    f(1) = x(4)\n    f(2) = x(5)\n    f(3) = x(6)\n    f(4) = a1 * x(1)/r1\n    f(5) = a1 * x(2)/r1\n    f(6) = a1 * x(3)/r1\n\n\n    return\n  end subroutine diffq_spm\n"}, {"instruction": "Create a Fortran subroutine named init to initialize an array with a specified value. The subroutine takes 2 input parameters: an integer n and a real number val, and has 1 output parameter: a real array x of size n. The input parameter types are ['integer', 'real(kind=4)'] and the output parameter type is ['real(kind=4), dimension(n)']. Use the imperative tone to define the subroutine.", "input": "", "output": "subroutine init (x, n, val)\n        integer, intent(in) :: n\n        real(kind=4), intent(out), dimension(n) :: x\n        real(kind=4), intent(in) :: val\n        do i=1,n\n                x(i)=val\n        end do\nend subroutine init\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorlogical that copies a logical vector lx to another vector ly. The subroutine takes 2 input parameters: lx of type logical, dimension(:) and an optional integer parameter n. It has 1 output parameter: ly of type logical, dimension(:).", "input": "", "output": "  subroutine lalg_copyvectorlogical (lx,ly,n)\n\n!<description>\n  ! copies a logical vector lx: ly = lx\n!</description>\n\n!<input>\n\n  ! source vector\n  logical, dimension(:), intent(in) :: lx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  logical, dimension(:), intent(out) :: ly\n\n!</output>\n\n  integer :: i\n\n    if (.not. present(n)) then\n\n#ifdef has_openmp40\n      !$omp parallel do simd if(size(lx) > lalg_perfconfig%nitemmin_omp)\n#endif\n      do i = 1, size(lx)\n        ly(i) = lx(i)\n      end do\n#ifdef has_openmp40\n      !$omp end parallel do simd\n#endif\n\n    else\n\n#ifdef has_openmp40\n      !$omp parallel do simd if(n > lalg_perfconfig%nitemmin_omp)\n#endif\n      do i = 1, n\n        ly(i) = lx(i)\n      end do\n#ifdef has_openmp40\n      !$omp end parallel do simd\n#endif\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorlogical2d to copy a 2D logical vector from source lx to destination ly. The subroutine takes 3 input parameters: lx of type logical, dimension(:,:), n of type integer (optional), and m of type integer (optional). It also has 1 output parameter ly of type logical, dimension(:,:).", "input": "", "output": "  subroutine lalg_copyvectorlogical2d (lx,ly,n,m)\n\n!<description>\n  ! copies a logical vector lx: ly = lx\n!</description>\n\n!<input>\n\n  ! source vector\n  logical, dimension(:,:), intent(in) :: lx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  logical, dimension(:,:), intent(out) :: ly\n\n!</output>\n\n\n  integer :: i,j\n\n    if (present(n) .and. present(m)) then\n\n      do j = 1, m\n        do i = 1, n\n          ly(i,j) = lx(i,j)\n        end do\n      end do\n\n    else\n\n      do j = 1, size(lx,2)\n        do i = 1, size(lx,1)\n          ly(i,j) = lx(i,j)\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorchar2d to copy a 2D character array from the source vector sx to the destination vector sy. The subroutine takes 3 input parameters: sx, an array of characters with dimensions (:,:), and two optional integers n and m. It has 1 output parameter: sy, an array of characters with dimensions (:,:). If n and m are provided, the subroutine copies the subarray of size (n,m) from sx to sy; otherwise, it copies the entire array from sx to sy.", "input": "", "output": "  subroutine lalg_copyvectorchar2d (sx,sy,n,m)\n\n!<description>\n  ! copies a character vector sx: sy = sx\n!</description>\n\n!<input>\n\n  ! source vector\n  character, dimension(:,:), intent(in) :: sx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  character, dimension(:,:), intent(out) :: sy\n\n!</output>\n\n\n  integer :: i,j\n\n    if (present(n) .and. present(m)) then\n\n      do j = 1, m\n        do i = 1, n\n          sy(i,j) = sx(i,j)\n        end do\n      end do\n\n    else\n\n      do j = 1, size(sx,2)\n        do i = 1, size(sx,1)\n          sy(i,j) = sx(i,j)\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorchar3d to copy a 3-dimensional character vector from the source vector sx to the destination vector sy. The subroutine takes 4 input parameters: sx (character, dimension(:,:,:)), n (integer, optional), m (integer, optional), o (integer, optional), and 1 output parameter: sy (character, dimension(:,:,:)).\n", "input": "", "output": "  subroutine lalg_copyvectorchar3d (sx,sy,n,m,o)\n\n!<description>\n  ! copies a character vector sx: sy = sx\n!</description>\n\n!<input>\n\n  ! source vector\n  character, dimension(:,:,:), intent(in) :: sx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m,o\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  character, dimension(:,:,:), intent(out) :: sy\n\n!</output>\n\n\n  integer :: i,j,k\n\n    if (present(n) .and. present(m)) then\n\n      do k = 1, o\n        do j = 1, m\n          do i = 1, n\n            sy(i,j,k) = sx(i,j,k)\n          end do\n        end do\n      end do\n\n    else\n\n      do k = 1, size(sx,3)\n        do j = 1, size(sx,2)\n          do i = 1, size(sx,1)\n            sy(i,j,k) = sx(i,j,k)\n          end do\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_setvectorchar2d to set the elements of a two-dimensional character array to a specified character value. The subroutine takes 1 input parameter of type character and 1 output parameter of type character, dimension(:,:).", "input": "", "output": "  subroutine lalg_setvectorchar2d (sx,svalue)\n\n!<description>\n  ! sets the vector data to a defined value: sx = svalue\n!</description>\n\n!<input>\n  ! the value, the vector should be set to.\n  character, intent(in) :: svalue\n!</input>\n\n!<output>\n  ! destination vector to be set\n  character, dimension(:,:), intent(out) :: sx\n!</output>\n\n\n  ! local variables\n  integer :: i,j\n\n    do j = 1, size(sx,2)\n      do i = 1, size(sx,1)\n        sx(i,j) = svalue\n      end do\n    end do\n\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named `lalg_setvectorlogical3d` to set the elements of a 3D logical array to a specified logical value. The number of input arguments is 1, and the test_data type is ['logical']. The number of output arguments is 1, and the test_data type is ['logical, dimension(:,:,:)'].", "input": "", "output": "  subroutine lalg_setvectorlogical3d (lx,lvalue)\n\n!<description>\n  ! sets the vector data to a defined value: lx = lvalue\n!</description>\n\n!<input>\n  ! the value, the vector should be set to.\n  logical, intent(in) :: lvalue\n!</input>\n\n!<output>\n  ! destination vector to be set\n  logical, dimension(:,:,:), intent(out) :: lx\n!</output>\n\n\n  ! local variables\n  integer :: i,j,k\n\n    do k = 1, size(lx,3)\n      do j = 1, size(lx,2)\n        do i = 1, size(lx,1)\n          lx(i,j,k) = lvalue\n        end do\n      end do\n    end do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rgbmono that converts RGB colors to a reasonable grayscale. The subroutine takes 3 input parameters of type real (rr, rg, rb) representing red, green, and blue intensities ranging from 0 to 100, and provides 2 output parameters of type real (ri) and integer (status). The status variable indicates the success or failure of the computation.", "input": "", "output": "subroutine rgbmono(rr,rg,rb,ri,status)\n\n! ident_7=\"@(#)m_color::rgbmono(3f): convert rgb colors to a reasonable grayscale\"\n\n! monochrome devices that support intensity can have intensity calculated from the specified red, green, blue\n! intensities as 0.30*r + 0.59*g + 0.11*b, as in us color television systems, ntsc encoding.\n! note that most devices do not have an infinite range of monochrome intensities available.\n\nreal,intent(in)      :: rr,rg,rb                ! red, green, blue, & intensity range from 0 to 100\nreal,intent(out)     :: ri\ninteger,intent(out)  :: status\n   status=0\n   if(rr .lt. 0.0 .or. rr .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   if(rg .lt. 0.0 .or. rg .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   if(rb .lt. 0.0 .or. rb .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   ri = 0.30*rr + 0.59*rg + 0.11*rb\nend subroutine rgbmono\n"}, {"instruction": "Create a Fortran subroutine named \"sistl\" to solve a linear system of equations using the forward substitution method. The subroutine takes two input parameters of type real, dimension(:,:) and real, dimension(:), and one output parameter of type real, dimension(:).", "input": "", "output": "subroutine sistl(a, b, w)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: w\n\ninteger :: n, i, j\n\nn = size(b)\n\nprint*, 'o termo independente b e: '\nprint*, b\nprint*,\n\nw(1) = b(1)/a(1,1)\n\ndo i = 2,n\n  w(i) = b(i)\n  do j = 1,i-1\n    w(i) = w(i) - a(i,j)*w(j)\n  enddo\n\n  w(i) = w(i)/a(i,i)\nenddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sort_positions to reorder the positions of elements in an array based on their values. The subroutine takes 2 input parameters: an integer n and a real array a of dimension n. It also has 1 output parameter, an integer array ipiv of dimension n.", "input": "", "output": "subroutine sort_positions(n,a,ipiv)\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), dimension(n), intent(in) :: a\n  integer, dimension(n), intent(out) :: ipiv\n  !local variables\n  integer :: i,j,jmax,imax\n  real(kind=8) :: locmax\n\n  !neutral permutation\n  do i=1,n\n     ipiv(i)=i\n  end do\n  !find the order for all the arrays\n  do j=1,n\n  !search the maximum\n     locmax=-1.d300\n     do i=j,n\n        if (locmax < a(ipiv(i))) then\n           locmax=a(ipiv(i))\n           jmax=ipiv(i)\n           imax=i\n        end if\n     end do\n     !swap the position with j\n     ipiv(imax)=ipiv(j) !throw in the present element\n     ipiv(j)=jmax       !take out the present maximum\n  end do\n  !do i=1,n\n  !   print *,'a',i,a(i),ipiv(i),a(ipiv(i))\n  !end do\n  !stop\nend subroutine sort_positions\n"}, {"instruction": "Write a Fortran subroutine named sub to calculate the sum of two integer numbers. The subroutine takes 2 input parameters of integer type and provides 1 output parameter of integer type. The input parameters should be declared with the \"intent(in)\" attribute and the output parameter should be declared with the \"intent(out)\" attribute.", "input": "", "output": "elemental subroutine sub(a,b,c)\n  integer :: func, a, b, c\n  intent(in) :: b,c\n  intent(out) :: a\n  a = b +c\nend subroutine sub\n"}, {"instruction": "Write a Fortran subroutine named lagder to compute the derivative of a Lagrange interpolating polynomial. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine lagder(n,x,y,der)\n  implicit none\n  real*8, intent(in) :: x(n),y(n)\n  integer, intent(in):: n\n  real*8, intent(out):: der\n  ! locals\n  integer:: i, j, k\n  real*8 :: ade, anu, de, xu\n  xu=x(1)\n  de=0.d0\n  do k=2,n\n     de=de+1.d0/(xu-x(k))\n  enddo\n  de=de*y(1)\n  \n  do i=2,n\n     anu=1.d0\n     do j=2,n\n        if(j.eq.i) cycle\n        anu=anu*(xu-x(j))\n     enddo\n     ade=1.d0\n     do j=1,n\n        if(j.eq.i) cycle\n        ade=ade*(x(i)-x(j))\n     enddo\n     de=de+y(i)*anu/ade\n  enddo\n  der=de\n  return\nend subroutine lagder\n"}, {"instruction": "Create a Fortran subroutine named decompose to distribute a range of indices across multiple processes. The subroutine takes 2 input parameters of type integer: n and nprocs. It also has 2 output parameters of type integer arrays with dimensions (0:nprocs-1): jbeg and jend.", "input": "", "output": "subroutine decompose(n, nprocs, jbeg, jend)\n        implicit none\n\n        integer, intent(in) :: n, nprocs\n        integer, dimension(0:nprocs-1), intent(out) :: jbeg, jend\n        integer :: loc_size, i\n\n        loc_size = n/nprocs \n        do i = 0, nprocs-1\n\n                jbeg(i) = i*loc_size + 1\n                jend(i) = jbeg(i) + loc_size - 1\n\n\n        end do \n\n        if (mod(n, nprocs).ne.0) then \n                jend(nprocs-1) = jend(nprocs-1) + mod(n, nprocs)\n        end if\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"foo\" that takes an integer input parameter and returns an integer output parameter. The subroutine contains a nested subroutine \"bar\" which reads input using a namelist. The main subroutine assigns the value read by \"bar\" to the output parameter.", "input": "", "output": "subroutine foo (nnml, outv)\n  integer, intent(in) :: nnml\n  integer, intent(out) :: outv\n  integer :: grid\n  call bar\n  outv = grid\ncontains\n  subroutine bar\n    namelist /n/ grid\n    read (nnml, nml=n)\n  end subroutine bar\nend subroutine foo\n"}, {"instruction": "Write a Fortran subroutine named valid that takes an array of integers as input and assigns the value of the first element of the array to an output integer variable. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine valid (lhs,rhs)\n    integer, intent(out) ::  lhs\n    integer, intent(in) :: rhs(:)\n    lhs = rhs(1) \n  end subroutine valid\n"}, {"instruction": "Write a Fortran subroutine named valid2 that takes an array of integers as input and another 2D array of integers. The first element of the input array is assigned the values from the first column of the 2D array. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine valid2 (lhs,rhs)\n    integer, intent(out) ::  lhs(:)\n    integer, intent(in) :: rhs(:,:)\n    lhs(:) = rhs(:,1) \n  end subroutine valid2\n"}, {"instruction": "Create a Fortran subroutine named \"invalid\" to assign the value of an integer input parameter to an output parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer]. Ensure that the input parameter is declared with the \"intent(in)\" attribute, and the output parameter is declared with the \"intent(out)\" attribute.", "input": "", "output": "  subroutine invalid (lhs,rhs) ! { dg-error \"must not redefine an intrinsic type assignment\" }\n    integer, intent(out) ::  lhs\n    integer, intent(in) :: rhs\n    lhs = rhs\n  end subroutine invalid\n"}, {"instruction": "Create a Fortran subroutine named \"sca_deplcrv\" with two input parameters of type real and one output parameter of type real. The input parameters are \"snarea_curve\" (an array of 11 real numbers) and \"frac_swe\" (a real number). The output parameter is \"snowcov_area\" (a real number). The subroutine calculates the snow-covered area based on the depletion curve and the fractional snow water equivalent (SWE) provided. If the fractional SWE is greater than 1.0, the snow-covered area is set to the value at the 11th index of the depletion curve. Otherwise, it linearly interpolates the snow-covered area between the two closest points on the depletion curve based on the fractional SWE. Use intrinsic functions int and float for integer and floating-point conversions.", "input": "", "output": "      subroutine sca_deplcrv(snowcov_area, snarea_curve, frac_swe)\n      implicit none\n! functions\n      intrinsic :: int, float\n! arguments\n      real, intent(out) :: snowcov_area\n      real, intent(in) :: snarea_curve(11), frac_swe\n! local variables\n      integer :: idx, jdx\n      real :: af, dify, difx\n!***********************************************************************\n      if ( frac_swe>1.0 ) then\n        snowcov_area = snarea_curve(11)\n      else\n\n        ! get the indices (as integers) of the depletion curve that\n        ! bracket the given frac_swe (next highest and next lowest)\n        idx = int( 10.0*(frac_swe+0.2) ) ! [index]\n        jdx = idx - 1 ! [index]\n        if ( idx>11 ) idx = 11\n        ! calculate the fraction of the distance (from the next lowest)\n        ! the given frac_swe is between the next highest and lowest\n        ! curve values\n        af = float( jdx-1 )\n        dify = (frac_swe*10.0) - af ! [fraction]\n        ! calculate the difference in snow covered area represented\n        ! by next highest and lowest curve values\n        difx = snarea_curve(idx) - snarea_curve(jdx)\n        ! linearly interpolate a snow covered area between those\n        ! represented by the next highest and lowest curve values\n        snowcov_area = snarea_curve(jdx) + dify*difx\n      endif\n      end subroutine sca_deplcrv\n"}, {"instruction": "Create a Fortran subroutine named restart_index_to_vector_offset that takes an integer input argument and returns an integer output. The subroutine computes the offset value using the input index and the field size. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "  subroutine restart_index_to_vector_offset(var_index, var_offset)\n    integer, intent(in)  :: var_index\n    integer, intent(out) :: var_offset\n\n    var_offset = (var_index - 1) * field_size \n  end subroutine restart_index_to_vector_offset\n"}, {"instruction": "Create a Fortran subroutine named fornbergweights which calculates the weights for Fornberg interpolation. The subroutine has 3 input parameters of type real(dpk), real(dpk), and integer, and 1 output parameter of type real(dpk).", "input": "", "output": "\tsubroutine fornbergweights( x, ksi, m, c )\n\t\tinteger, parameter :: dpk = kind(1.d0)\n\t\t\n\t\treal(dpk), intent(in) :: x(0:)\n\t\treal(dpk), intent(in) :: ksi\n\t\tinteger, intent(in) :: m\n\t\treal(dpk), intent(out) :: c(0:,0:,0:)\n\t\t\t\n\t\treal (dpk) :: a, b, temp1, temp2, d\n\t\tinteger :: i, j, k\n\t\tinteger :: minim\n\t\t\n\t\tc(0,0,0) = 1.0_dpk\n\t\t\n\t\ta = 1.0_dpk\n\t\t\n\t\tdo i=1,ubound(x,1)\n\t\t\tminim = min(i,m)\n\t\t\tb = 1.0_dpk\n\t\t\t\t\n\t\t\ttemp1 = x(i) - ksi\n\t\t\t\t\n\t\t\tdo j=0,i-1\n\t\t\t\ttemp2 = x(i) - x(j)\n\t\t\t\t\n\t\t\t\tb = b * temp2\n\t\t\t\t\n\t\t\t\tif( i <= m ) c(i-1,j,i) = 0.0_dpk\n\t\t\t\t\t\n\t\t\t\tc(i,j,0) = temp1 * c(i-1,j,0) / temp2\n\t\t\t\t\t\n\t\t\t\tdo k = 1, minim\n\t\t\t\t\tc(i,j,k) = (temp1 * c(i-1,j,k) - k * c(i-1,j,k-1)) / temp2\n\t\t\t\tenddo\n\t\t\tenddo\n\t\t\n\t\t\td = a / b\n\t\t\ttemp1 = d * (ksi - x(i-1))\n\t\t\t\n\t\t\tc(i,i,0) = temp1 * c(i-1,i-1,0)\n\t\t\t\n\t\t\tdo k = 1, minim\n\t\t\t\tc(i,i,k) = d * k * c(i-1,i-1,k-1) + temp1 * c(i-1,i-1,k)\n\t\t\tenddo\n\t\t\t\n\t\t\ta = b\n\t\tenddo\n\t\t\n\tend subroutine fornbergweights\n"}, {"instruction": "Write a Fortran subroutine named trend_zfac to calculate the compressibility factor and its derivatives with respect to temperature, pressure, and composition. The number of input arguments is 3 and the test_data type is [real, real, real]. The number of output arguments is 4, with test_data types [real, real (optional), real (optional), real (optional)].", "input": "", "output": "  subroutine trend_zfac(t, rho, x, zfac, dzdt, dzdp, dzdx)\n    implicit none\n    ! input:\n    real,   intent(in)          :: t        !< temperature (k)\n    real,   intent(in)          :: rho      !< density (mol/m^3)\n    real,   intent(in)          :: x(:) !< composition (mol/mol)\n    ! output:\n    real,   intent(out)         :: zfac !< compressibility factor (-)\n    real, optional, intent(out) :: dzdt !< zfac diff. wrt. temperature\n    real, optional, intent(out) :: dzdp !< zfac diff. wrt. pressure\n    real, optional, intent(out) :: dzdx(:) !< zfac diff. wrt. composition\n    ! trend functions:\n    zfac = 0.0\n    if (present(dzdt)) then\n      dzdt = 0.0\n    endif\n    if (present(dzdp)) then\n      dzdp = 0.0\n    endif\n    if (present(dzdx)) then\n      dzdx = 0.0\n    endif\n  end subroutine trend_zfac\n"}, {"instruction": "Write a Fortran subroutine named trend_residualentropy_tp to calculate the specific residual entropy based on temperature, pressure, density, and composition as inputs. The number of input arguments is 4 with test data types ['real', 'real', 'real', 'real, dimension(:)']. The number of output arguments is 4 with test data types ['real', 'real, optional', 'real, optional', 'real, optional']. Use an imperative tone in your instructions.", "input": "", "output": "  subroutine trend_residualentropy_tp(t,p,rho,x,sr,dsrdt,dsrdp,dsrdx)\n    implicit none\n    ! input:\n    real, intent(in)                  :: t    !< temperature (k)\n    real, intent(in)                  :: p    !< pressure (pa)\n    real, intent(in)                  :: rho  !< density (mol/m3)\n    real, dimension(:), intent(in) :: x    !< composition (mol/mol)\n    ! output:\n    real, intent(out)                 :: sr   !< specific residual entropy\n                                              ! (j/(mol*k)\n    real, optional, intent(out)       :: dsrdt!< specific residual entropy diff.\n                                              ! wrpt. temperature (j/(mol*k^2)\n    real, optional, intent(out)       :: dsrdp!< specific residual entropy diff.\n                                              ! wrpt. pressure (j/(mol*k*pa)\n    real, optional, intent(out)       :: dsrdx(:) !< specific residual\n                                              !entropy diff. wrpt. mole numbers\n                                              ! (j/(mol^2*k)\n    sr = 0.0\n    if (present(dsrdt)) then\n      dsrdt = 0.0\n    endif\n    if (present(dsrdp)) then\n      dsrdp = 0.0\n    endif\n    if (present(dsrdx)) then\n      dsrdx = 0.0\n    endif\n\n  end subroutine trend_residualentropy_tp\n"}, {"instruction": "Write a Fortran subroutine named trend_thermotv to calculate thermodynamic properties based on temperature, volume, and number of moles. The subroutine takes 3 input parameters of type real: t, v, and n. It has 4 output parameters of type real, which are optional: lnfug, lnfugt, lnfugv, and lnfugn. If present, these output parameters are set to 0.0.", "input": "", "output": "  subroutine trend_thermotv(t,v,n,lnfug,lnfugt,lnfugv,lnfugn)\n    implicit none\n    real, intent(in) :: t,v,n(:)\n    ! output.\n    real, optional, intent(out) :: lnfug(:)\n    real, optional, intent(out) :: lnfugt(:),lnfugv(:),lnfugn(:,:)\n    ! locals\n    if (present(lnfug)) then\n      lnfug = 0.0\n    endif\n    if (present(lnfugt)) then\n      lnfugt = 0.0\n    endif\n    if (present(lnfugv)) then\n      lnfugv = 0.0\n    endif\n    if (present(lnfugn)) then\n    lnfugn = 0.0\n    endif\n  end subroutine trend_thermotv\n"}, {"instruction": "Create a Fortran subroutine named `trend_calcfid` that calculates various trend-related values. The subroutine should have 3 input parameters of type real and 10 optional output parameters of type real. The input parameters are `t`, `v`, and `n`, while the optional output parameters are `f`, `f_t`, `f_v`, `f_tt`, `f_tv`, `f_vv`, `f_n`, `f_tn`, `f_vn`, and `f_nn`.", "input": "", "output": "  subroutine trend_calcfid(t,v,n,f,f_t,f_v,f_tt,f_tv,f_vv,f_n,f_tn,f_vn,f_nn)\n    implicit none\n    real, intent(in) :: t,v,n(:)\n    ! output.\n    real, optional, intent(out) :: f,f_t,f_v,f_tt,f_tv,f_vv\n    real, optional, intent(out) :: f_n(:),f_tn(:),f_vn(:),f_nn(:,:)\n    ! locals\n\n    if (present(f)) f = 0.0\n    if (present(f_t)) f_t = 0.0\n    if (present(f_tt)) f_tt = 0.0\n    if (present(f_v)) f_v = 0.0\n    if (present(f_tv)) f_tv = 0.0\n    if (present(f_vv)) f_vv = 0.0\n\n    if (present(f_n)) then\n      f_n = 0.0\n    endif\n    if (present(f_tn)) then\n      f_tn = 0.0\n    endif\n    if (present(f_vn)) then\n      f_vn = 0.0\n    endif\n    if (present(f_nn)) then\n      f_nn = 0.0\n    endif\n  end subroutine trend_calcfid\n"}, {"instruction": "Create a Fortran subroutine named vol_int_part to compute the volume integral with partial bottom cells. The subroutine takes 10 input parameters of types integer, real, and real arrays, and outputs 1 real parameter. The subroutine calculates the integral using the provided input fields, areas, and depth arrays, considering partial bottom cells.", "input": "", "output": "subroutine vol_int_part(imin,jmin,kmin,imax,jmax,kmax,field,area,dz,dz_3d,integral)\n!\n!     calculates volume integral (*[m^3]) with partial bottom cells\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(km),         intent(in)  :: dz\nreal,    dimension(imt,jmt,km), intent(in)  :: dz_3d,field\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,                           intent(out) :: integral\n\nintegral = sum( area(imin:imax,jmin:jmax)                                      &\n                * sum( dz_3d(imin:imax,jmin:jmax,kmin:kmax)                    &\n                       * field(imin:imax,jmin:jmax,kmin:kmax),                 &\n               3,dz_3d(imin:imax,jmin:jmax,kmin:kmax).ne.0.0 ) )\n\nend subroutine vol_int_part\n"}, {"instruction": "Create a Fortran subroutine named \"vol_int_full\" to calculate the volume integral with full bottom cells. The subroutine takes 10 input parameters: imin, jmin, kmin, imax, jmax, kmax of type integer, arrays dz, dz_3d, field, and area of type real. The output parameter is \"integral\" of type real.", "input": "", "output": "subroutine vol_int_full(imin,jmin,kmin,imax,jmax,kmax,field,area,dz,dz_3d,integral)\n!\n!     calculates volume integral (*[m^3]) with full bottom cells\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(km),         intent(in)  :: dz\nreal,    dimension(imt,jmt,km), intent(in)  :: dz_3d,field\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,                           intent(out) :: integral\n\nintegral = 0.0\ndo k = kmin,kmax\n  integral = integral                                                          &\n           + sum( area(imin:imax,jmin:jmax)*field(imin:imax,jmin:jmax,k),      &\n                  dz_3d(imin:imax,jmin:jmax,k).ne.0.0 ) * dz(k)\nenddo !k\n\nend subroutine vol_int_full\n"}, {"instruction": "Create a Fortran subroutine named vol_int2 that calculates the volume integral of a 3D field using Kahan summation. The subroutine takes 9 input parameters of types integer and real arrays, and outputs a single real value. The input parameters include the dimensions of the field, the field itself (3D), the area, and the depth.", "input": "", "output": "subroutine vol_int2(imin,jmin,kmin,imax,jmax,kmax,field,tarea,dzt,integral)\n!\n!     calculates volume integral (*[m^3]) for ttt-field via kahan summation\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(imt,jmt,km), intent(in)  :: dzt,field\nreal,    dimension(imt,jmt),    intent(in)  :: tarea\nreal,                           intent(out) :: integral\nreal                                        :: c, y, t\n\nintegral = 0.0\nc = 0.0\ndo k = kmin,kmax\n  do j = jmin,jmax\n    do i = imin,imax\n      if ( dzt(i,j,k).ne.0.0 ) then\n        y = tarea(i,j) * dzt(i,j,k) * field(i,j,k) - c\n        t = integral + y\n        c = ( t - integral ) - y\n        integral = t\n      endif\n    enddo !i\n  enddo !j\nenddo !k\n\nintegral = integral\n\nend subroutine vol_int2\n"}, {"instruction": "Create a Fortran subroutine named surf_int_3d to calculate the surface integrals of a 3D field. The subroutine takes 7 input parameters: imin, jmin, imax, jmax of type integer, and field, tarea, dzt_k of type real, each with dimensions imt and jmt. It produces 1 output parameter of type real. The subroutine uses the imperative tone and computes the surface integrals by weighting the contribution using the cell-depth and averaging the depth.", "input": "", "output": "subroutine surf_int_3d(imin,jmin,imax,jmax,field,tarea,dzt_k,integral)\n!  calculates surface integrals *[m^2] weighting contribution by (pbc)cell-depth\nimplicit none\n\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                     intent(in)  :: imin,jmin,imax,jmax\nreal,    dimension(imt,jmt), intent(in)  :: field,tarea,dzt_k\nreal,                        intent(out) :: integral\nreal                                     :: avg_dz\n\navg_dz   = sum( tarea(imin:imax,jmin:jmax) * dzt_k(imin:imax,jmin:jmax),       &\n                dzt_k(imin:imax,jmin:jmax).ne.0.0  ) /    &\n           sum( tarea(imin:imax,jmin:jmax),  dzt_k(imin:imax,jmin:jmax).ne.0.0 )\nintegral = sum( tarea(imin:imax,jmin:jmax) * field(imin:imax,jmin:jmax)        &\n              * dzt_k(imin:imax,jmin:jmax),  dzt_k(imin:imax,jmin:jmax).ne.0.0)\nintegral = integral/avg_dz\n\nend subroutine surf_int_3d\n"}, {"instruction": "Create a Fortran subroutine named area_avg that calculates the unweighted area average of a field over different vertical levels.\nThe subroutine takes 4 input parameters of type real, with dimensions (imt, jmt, km), (imt, jmt, km), (imt, jmt), and (km) respectively. It also has 1 output parameter of type real with dimension (km).", "input": "", "output": "subroutine area_avg(field,dzt,area,area_k,avg)\n! creates unweighted area average\n\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt,km), intent(in)  :: field, dzt\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,    dimension(km),         intent(in)  :: area_k\nreal,    dimension(km),         intent(out) :: avg\n\ndo k=1,km\n  avg(k) = sum(field(:,:,k)*area(:,:),dzt(:,:,k).ne.0.0)/area_k(k)\nenddo\n\nend subroutine area_avg\n"}, {"instruction": "Create a Fortran subroutine named masked_avg to calculate the weighted average of a field over a masked area. The subroutine takes 5 input parameters of type real, each with dimensions (imt, jmt), real, and integer with dimensions (imt, jmt), and 1 output parameter of type real.", "input": "", "output": "subroutine masked_avg(dxt,dyt,mask,mask_area,field,value)\nimplicit none\n!\n!  reads yearly data that was previoously calculated and written into a binary\n!\n\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dxt,dyt,field\nreal,                        intent(in)  :: mask_area\ninteger, dimension(imt,jmt), intent(in)  :: mask\nreal,                        intent(out) :: value\n\nvalue = sum(field*dxt*dyt*mask)/mask_area\n\nend subroutine masked_avg\n"}, {"instruction": "Create a Fortran subroutine named \"zonal_int\" to calculate the zonal integral of a given field for the southern hemisphere. The subroutine takes 2 input parameters of type real, with dimensions (imt, jmt), and returns 1 output parameter of type real with dimension (jmt).", "input": "", "output": "subroutine zonal_int(dxt,field,field_zint)\n!\n!  \"zonal\" integral, true for southern hemisphere, northern one is distorted\n!\nimplicit none\n\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dxt, field\nreal,    dimension(jmt),     intent(out) :: field_zint\n\nfield_zint(:) = sum(field(:,:)*dxt(:,:),1)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named vector_vector_multiply to perform element-wise multiplication of two input arrays and store the result in an output array. The input parameters consist of two real(kind=4) arrays of unspecified size, while the output parameter is a single real(kind=4) value. Use the imperative tone in the instructions.", "input": "", "output": "        subroutine vector_vector_multiply(v, w, result)\n            implicit none\n            real(kind=4), dimension(:), intent(in) :: v\n            real(kind=4), dimension(:), intent(in) :: w\n            real(kind=4), intent(out)              :: result\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_vector_multiply to calculate the product of a matrix and a vector. The subroutine takes 2 input arguments of type real(kind=4), dimension(:,:) and real(kind=4), dimension(:), and 1 output argument of type real(kind=4), dimension(:).", "input": "", "output": "subroutine matrix_vector_multiply(a, v, result)\n    implicit none\n    real(kind=4), dimension(:,:), intent(in)  :: a\n    real(kind=4), dimension(:)  , intent(in)  :: v\n    real(kind=4), dimension(:)  , intent(out) :: result\n    integer                                   :: i, j\n\n    result = 0.\n    do i = 1, size(a(:,1))\n        do j = 1, size(a(1,:))\n            result(i) = result(i) + a(i,j) * v(j)\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_matrix_multiply that takes two input parameters of type real(kind=4), dimension(:,:) and returns one output parameter of type real(kind=4), dimension(:,:). This subroutine computes the matrix-matrix multiplication of the input matrices 'a' and 'b', and stores the result in the 'result' matrix. Use the imperative tone in the instructions.", "input": "", "output": "subroutine matrix_matrix_multiply(a, b, result)\n    implicit none\n    real(kind=4), dimension(:,:), intent(in)  :: a\n    real(kind=4), dimension(:,:), intent(in)  :: b\n    real(kind=4), dimension(:,:), intent(out) :: result\n    integer                                   :: i, j, k\n\n    result = 0.\n    !$omp parallel\n    do k = 1, size(a,1)\n        do i = 1, size(a,2)\n            do j = 1, size(a,1)\n                result(i,k) = result(i,k) + a(i,j) * b(j,i)\n            end do\n        end do\n    end do\n    !$omp end parallel\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named get_next_char to efficiently read characters from a file using buffered input. The subroutine takes 1 input parameter of type integer and 2 output parameters of types character and integer.", "input": "", "output": "subroutine get_next_char(fd,c,ios)\n! replace \"read(fd,iostat=ios) c\" because gfortran on cygwin sixty times slower with plain read (no system buffering?)\n! quick buffering read\nimplicit none\ninteger,intent(in)          :: fd\ncharacter,intent(out)       :: c\ninteger,intent(out)         :: ios\ninteger,parameter           :: bufsize=1048576\ncharacter(len=1),save       :: buff(bufsize)\ninteger,save                :: point=0\ninteger,save                :: filepoint=1\ninteger,save                :: sz=bufsize\n\nios=0\n\ndo\nselect case(point)\ncase(0)                                            ! read a buffer\n   read(fd,iostat=ios,pos=filepoint) buff(1:sz)\n   if(is_iostat_end(ios))then                      ! this is the last buffer\n      if(sz.ne.1)then                              ! try again with a smaller buffer\n         sz=sz/2\n         sz=max(1,sz)\n         cycle\n      endif\n   elseif(ios.eq.0)then                            ! no error occurred so successfully read a buffer\n      c=buff(1)\n      filepoint=filepoint+sz\n      point=sz-1\n   endif\ncase(1:)                                           ! getting a character from a previous buffer\n   point=point-1\n   c=buff(sz-point)\ncase default\n   write(*,*)'*get_next_char* internal error '\n   read(fd,iostat=ios) c\nend select\n! assume if ios is not zero, not called again until new file is started\n   if(ios.ne.0)then\n      filepoint=1\n      point=0\n      sz=bufsize\n   endif\n   exit\nenddo\nend subroutine get_next_char\n"}, {"instruction": "Write a Fortran subroutine named cross_product to calculate the cross product of two 3D vectors and the magnitude of the resulting vector. The subroutine should have 6 input parameters of type real (kind=8) and 4 output parameters of type real (kind=8).", "input": "", "output": "   subroutine cross_product(x1,y1,z1, x2,y2,z2, xc,yc,zc, mc)\n\n     real (kind=8), intent(in) :: x1, y1, z1\n     real (kind=8), intent(in) :: x2, y2, z2\n     real (kind=8), intent(out) :: xc, yc, zc, mc\n     \n     xc =  (y1*z2 - z1*y2)\n     yc = -(x1*z2 - z1*x2)\n     zc =  (x1*y2 - y1*x2)\n     \n     mc = sqrt(xc*xc + yc*yc + zc*zc)\n     return\n   end subroutine cross_product\n"}, {"instruction": "Create a Fortran subroutine named incident_plane_wave_te to calculate the incident electric field at multiple points due to a transverse electric (TE) plane wave. The subroutine takes 4 input parameters of type real(8), real(8), real(8), and complex(8), and outputs 1 parameter of type complex(8) with allocatable arrays.", "input": "", "output": "    subroutine incident_plane_wave_te(xyz_list, k, alpha, eo, ei_list)\n        real(8), intent(in) :: xyz_list(:, :)  ! list of points = [x1, y1, z1; x2, y2, z2; ...]\n        real(8), intent(in) :: k               ! wavenumber [1/m]\n        real(8), intent(in) :: alpha           ! incidence angle in (-pi, 0)\n        complex(8), intent(in) :: eo           ! incident electric field amplitud [v/m]\n        complex(8), allocatable, intent(out) :: ei_list(:, :) ! incident electric field in v/m\n                                                              ![ex1, ey1, ez1; ex2, ey2, ez2; ...]\n        integer :: n\n        integer :: n_points\n        real(8) :: k_sin_alpha, k_cos_alpha\n        real(8) :: y, z\n\n        n_points = size(xyz_list, 2)\n        k_sin_alpha = k * sin(alpha)\n        k_cos_alpha = k * cos(alpha)\n\n        allocate(ei_list(3, n_points))\n        ei_list = 0d0\n        do n = 1, n_points\n            y = xyz_list(2, n)\n            z = xyz_list(3, n)\n\n            ! field only has x component\n            ei_list(1, n) = exp(-iu * (k_cos_alpha * y - k_sin_alpha * z))\n        end do\n\n        ! scale field\n        ei_list = eo * ei_list\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rdfile to read data from a file. The subroutine takes 2 input parameters: an integer n and a character string infile, and 2 output parameters: real arrays x and y, each with dimension n. The subroutine reads data from the specified input file and assigns it to the arrays x and y.", "input": "", "output": "subroutine rdfile(x, y, n, infile)\n   implicit none\n   ! dummy arguments\n   integer, intent(in) :: n\n   real, dimension(n), intent(out) :: x, y\n   character (len=*), intent(in) :: infile\n   ! local data\n   integer :: i\n   ! processing\n   open (7,file=infile,status='old')\n   read (7,*) (x(i),i=1,n)\n   read (7,*) (y(i),i=1,n)\n   close (7)\nend subroutine rdfile\n"}, {"instruction": "Create a Fortran subroutine named chr_to_matrix to convert a string containing mathematical expressions into a 3x4 matrix of real(8) values. The input parameter is a character string, and the output parameter is a 3x4 matrix of real(8) values.", "input": "", "output": "  subroutine chr_to_matrix( cbuf, r )\n    implicit none\n    character(*),intent(in) :: cbuf\n    real(8),intent(out) :: r(3,4)\n    character(10) :: str(3)\n    integer :: i,j\n    real(8) :: f\n    r=0.0d0\n    write(*,*) cbuf\n    j=1\n    f=1.0d0\n    do i=1,len_trim(cbuf)\n       if ( cbuf(i:i) == \"-\" ) then\n          f=-1.0d0\n       end if\n       if ( cbuf(i:i) == \"x\" ) then\n          r(j,1) = f\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \"y\" ) then\n          r(j,2) = f\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \"z\" ) then\n          r(j,3) = f\n          f=1.0d0\n       end if\n       if ( 49 <= iachar(cbuf(i:i)) .and. iachar(cbuf(i:i)) <= 57 ) then\n          if ( r(j,4) == 0.0d0 ) then\n             r(j,4) = f*(iachar(cbuf(i:i))-48)\n          else\n             r(j,4) = r(j,4)/dble( iachar(cbuf(i:i))-48 )\n          end if\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \",\" ) then\n          j=j+1\n          f=1.0d0\n       end if\n    end do\n    do i=1,3\n       write(*,'(1x,3f15.10,3x,f15.10)') (r(i,j),j=1,4)\n    end do\n  end subroutine chr_to_matrix\n"}, {"instruction": "Create a Fortran subroutine named read_minima to read and allocate an array of minimum values from a file. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type double precision and allocatable. The input parameter specifies the number of dimensions, and the output parameter holds the array of minimum values read from the file.", "input": "", "output": "    subroutine read_minima(minima_array, ndimension)\n\n        double precision, allocatable, intent(out) :: minima_array(:)\n        integer, intent(in) :: ndimension\n\n        integer :: i, minima_array_size\n        integer :: inu = 20, outu = 21\n\n        open (unit=inu,form=\"unformatted\",file='output/minima_snapshot',action=\"read\")\n        read (inu) minima_array_size\n        allocate(minima_array(minima_array_size))\n        do i=1,size(minima_array),ndimension+1\n            read (inu) minima_array(i:i+ndimension) ! write one row at a time\n        end do\n        close (inu)\n\n    end subroutine    \n"}, {"instruction": "Create a Fortran subroutine named xyz2ll to convert Cartesian coordinates to longitude and latitude. The subroutine should have 3 input parameters of type real*8 and 2 output parameters of type real*8.", "input": "", "output": "subroutine xyz2ll(x,y,z,long,lat)\n\n  !     to convert cartesian coordinates to longitude and latitude\n\n  implicit none\n\n  real*8, intent(in)                       :: x\n  real*8, intent(in)                       :: y\n  real*8, intent(in)                       :: z\n  real*8, intent(out)                      :: long\n  real*8, intent(out)                      :: lat\n\n  real*8  pi,tln,tlt,r\n\n  !     -------------------------------------------------------------------\n\n  pi=4.0d0*atan(1.0d0)\n\n  if (x == 0.0d0) then\n     if (y >= 0.0d0) then\n        long=0.5d0*pi\n     else\n        long=1.5d0*pi\n     end if\n  else\n     tln=y/x\n     long=atan(tln)\n     if (x < 0.0d0) then\n        long=long+pi\n     end if\n     if (long < 0.0d0) then\n        long=long+2.0d0*pi\n     end if\n  end if\n\n  r=sqrt(x*x+y*y)\n  if (r == 0.0d0) then\n     if (z > 0.0d0) then\n        lat=0.5d0*pi\n     else\n        lat=-0.5d0*pi\n     end if\n  else\n     tlt=z/r\n     lat=atan(tlt)\n  end if\n\n  !     --------------------------------------------------------------------\n\n  return\nend subroutine xyz2ll\n"}, {"instruction": "Write a Fortran subroutine named read_int_frame to read integer data from a binary file based on the specified frame and store it in a multidimensional array. The subroutine takes 5 input parameters of type integer: funit, frame, num_parts, dimensions, and opt_bin. It also has one output parameter, coors, which is an integer array of dimensions num_parts and dimensions.", "input": "", "output": "  subroutine read_int_frame(opt_bin,funit,frame,num_parts,dimensions,coors)\n    \n    integer,intent(in)::funit,frame,num_parts,dimensions,opt_bin\n    integer,dimension(num_parts,dimensions),intent(out)::coors\n    \n    integer(kind=8)::needle\n    \n    if (opt_bin==1) then\n       needle=frame\n       needle=needle*num_parts*dimensions*4+1\n       read(funit,pos=needle) coors(:,:)\n    end if\n\n  end subroutine read_int_frame\n"}, {"instruction": "Create a Fortran subroutine named check_int_length to determine the length of integer data in a file. The subroutine takes 4 input parameters of type integer: opt_bin, funit, num_parts, and dimensions. It also has 1 output parameter of type integer: length.", "input": "", "output": "  subroutine check_int_length(opt_bin,funit,num_parts,dimensions,length)\n\n    integer,intent(in)::funit,num_parts,dimensions,opt_bin\n    integer,intent(out)::length\n\n    integer,dimension(:,:),allocatable::coors\n\n    allocate(coors(num_parts,dimensions))\n\n    length=0\n\n    if (opt_bin==1) then\n       rewind(funit)\n       \n       do\n          \n          read(funit,end=700) coors(:,:)\n          length=length+1\n          \n       end do\n       \n700    rewind(funit)\n\n    end if\n\n    deallocate(coors)\n\n  end subroutine check_int_length\n"}, {"instruction": "Create a Fortran subroutine named check_float_length that takes 4 input parameters of type integer: opt_bin, funit, num_parts, and dimensions. It also has 1 output parameter of type integer called length. The subroutine calculates the length by reading data from a file specified by funit, and the number of data parts and dimensions is determined by num_parts and dimensions, respectively. If opt_bin is 1, the subroutine reads data from the file, increments the length, and rewinds the file until the end is reached. Finally, the subroutine deallocates the memory before completion.", "input": "", "output": "  subroutine check_float_length(opt_bin,funit,num_parts,dimensions,length)\n\n    integer,intent(in)::funit,num_parts,dimensions,opt_bin\n    integer,intent(out)::length\n\n    double precision,dimension(:,:),allocatable::coors\n\n    allocate(coors(num_parts,dimensions))\n\n    length=0\n\n\n    if (opt_bin==1) then\n       rewind(funit)\n       \n       do\n          \n          read(funit,end=701) coors(:,:)\n          length=length+1\n          \n       end do\n\n701    rewind(funit)\n\n    end if\n    deallocate(coors)\n\n  end subroutine check_float_length\n"}, {"instruction": "Create a Fortran subroutine named \"prada1\" to perform a series of calculations on multidimensional arrays and integer and double-precision variables. The subroutine takes 11 input parameters of types integer and double precision, and one output parameter of type integer array. The input parameters are used for various calculations involving trajectory data, while the output parameter holds the results of the computations.", "input": "", "output": "  subroutine prada1 (ybins,bins,min,max,delta_x,rv_min,rv_max,traj,tw,num_parts,len_traj,traj_out)\n    \n    implicit none\n    integer,intent(in)::ybins,bins,tw,len_traj,num_parts,rv_min,rv_max\n    double precision,intent(in)::delta_x,min,max\n    double precision,dimension(len_traj,num_parts,1),intent(in)::traj\n    integer,dimension(len_traj-2*tw,num_parts,bins),intent(out)::traj_out\n    \n    integer::ltw,ltw1\n    integer::nn,ii,tt,kk,gg\n    double precision::delta_y\n    logical::filt_min,filt_max\n    \n    traj_out=0\n    ltw=(2*tw+1)\n    ltw1=ltw-1\n    delta_y=(1.0d0*ybins)/(1.0d0*ltw)\n    \n    filt_min=.false.\n    filt_max=.false.\n    \n    if (rv_min==1) then\n       filt_min=.true.\n    end if\n    if (rv_max==1) then\n       filt_max=.true.\n    end if\n\n    if ((filt_min.eqv..true.).or.(filt_max.eqv..true.)) then\n       do nn=1,num_parts\n          do ii=1,len_traj\n             tt=int((traj(ii,nn,1)-min)/delta_x)+1\n             if (filt_min.eqv..true.) then\n                if (tt<1) then\n                   tt=1\n                else\n                   tt=tt+1\n                end if\n             end if\n             if (tt>bins) tt=bins\n             do kk=ii-tw,ii+tw\n                gg=kk-tw\n                if ((gg>0).and.(gg<=(len_traj-ltw1))) then\n                   traj_out(gg,nn,tt)=traj_out(gg,nn,tt)+1\n                end if\n             end do\n          end do\n       end do\n    else\n       do nn=1,num_parts\n          do ii=1,len_traj\n             tt=int((traj(ii,nn,1)-min)/delta_x)+1\n             if (tt>bins) then\n                tt=bins\n             end if\n             do kk=ii-tw,ii+tw\n                gg=kk-tw\n                if ((gg>0).and.(gg<=(len_traj-ltw1))) then\n                   traj_out(gg,nn,tt)=traj_out(gg,nn,tt)+1\n                end if\n             end do\n          end do\n       end do\n    end if\n    \n    do nn=1,num_parts\n       do ii=1,len_traj-ltw1\n          do kk=1,bins\n             tt=ceiling(delta_y*traj_out(ii,nn,kk))\n             traj_out(ii,nn,kk)=tt\n          end do\n       end do\n    end do\n    \n    \n  end subroutine prada1\n"}, {"instruction": "Write a Fortran subroutine named \"prada2\" to perform a series of calculations on trajectory data. The subroutine takes 10 input parameters: ybins, sbins, bins, tw, len_traj, num_parts (all integers), delta_x, min, max (all double precision), and traj (a double precision array of dimension len_traj,num_parts,1). The subroutine produces 1 output parameter: traj_out (an integer array of dimension len_traj-2*tw,num_parts,bins+1).", "input": "", "output": "  subroutine prada2 (ybins,sbins,bins,min,max,delta_x,traj,tw,num_parts,len_traj,traj_out)\n    \n    implicit none\n    integer,intent(in)::ybins,sbins,bins,tw,len_traj,num_parts\n    double precision,intent(in)::delta_x,min,max\n    double precision,dimension(len_traj,num_parts,1),intent(in)::traj\n    integer,dimension(len_traj-2*tw,num_parts,bins+1),intent(out)::traj_out\n    \n    integer::ltw,ltw1\n    integer::nn,ii,tt,kk,gg\n    double precision::delta_y,sigma\n    \n    traj_out=0\n    ltw=(2*tw+1)\n    ltw1=ltw-1\n    delta_y=(1.0d0*ybins)/(1.0d0*ltw)\n    \n    \n    do nn=1,num_parts\n       do ii=tw+1,len_traj-tw-1\n          do kk=ii-tw,ii+tw\n             tt=ceiling((traj(kk,nn,1)-min)/delta_x)\n             if (tt>bins) tt=bins\n             traj_out(ii,nn,tt)=traj_out(ii,nn,tt)+1\n          end do\n          sigma=0.0d0\n          do kk=ii-tw,ii+tw-1\n             sigma=sigma+(traj(kk+1,nn,1)-traj(kk,nn,1))**2\n          end do\n          traj_out(ii,nn,bins+1)=int((sigma/(1.0d0*ltw))*sbins)\n       end do\n    end do\n    \n    do nn=1,num_parts\n       do ii=1,len_traj-ltw1\n          do kk=1,bins\n             tt=ceiling(delta_y*traj_out(ii,nn,kk))\n             traj_out(ii,nn,kk)=tt\n          end do\n       end do\n    end do\n    \n  end subroutine prada2\n"}, {"instruction": "Write a Fortran subroutine named calccgr to calculate a complex grid. The subroutine takes 2 input parameters of type integer, rmax and ordgr_max, and has 1 output parameter of type double complex, c(0:rmax,0:rmax,0:rmax).", "input": "", "output": "subroutine calccgr(c,rmax,ordgr_max)\n  integer, intent(in) :: rmax,ordgr_max\n  double complex :: zadj(2,2), zadj2(2,2)\n  double complex, intent(out) :: c(0:rmax,0:rmax,0:rmax)\n  double complex, allocatable :: cexpgr(:,:,:,:)\n  double complex :: caux\n  integer :: rmaxb,rmaxexp,r,n0,n1,n2,k,l,i,j,m,n,nn\n\n  rmaxb = 2*rmax\n  rmaxexp = rmaxb\n  allocate(cexpgr(0:rmaxexp/2,0:rmaxexp,0:rmaxexp,0:ordgr_max))\n   \n  rloop: do r=0,rmaxexp/2\n    do n0=r,1,-1\n      do nn=r-n0,0,-1\n        do i=1,2\n          caux = caux - zadj(i,l)\n        end do\n        cexpgr(n0,0,0,0) = caux/(2*(nn+1))\n      end do\n    end do\n    do n1=0,r\n      n2 = r-n1\n      if (r.le.rmax) then\n        c(0,n1,n2) = cexpgr(0,n1,n2,0)\n      end if\n    end do\n  end do rloop\nend subroutine calccgr\n"}, {"instruction": "Write a Fortran subroutine named norm to calculate the sum of the squares of elements in the interior domain of a 3D array. The subroutine takes 10 input parameters of type integer and real*8, including dimensions and the array itself. It returns 1 output parameter of type real*8.", "input": "", "output": "subroutine norm(x, res, k0, k1, j0, j1, i0, i1, l, m, n)\n  !\n  ! compute the sum of x**2 in the interior domain\n  ! (excluding the halo)\n  !\n  implicit none\n\n  integer, intent(in):: l, m, n\n  integer, intent(in):: k0, k1, j0, j1, i0, i1\n  real*8, dimension(l, m, n), intent(in) :: x\n  real*8, intent(out) :: res\n\n  !!!!f2py intent(inplace):: x\n\n  integer:: i, j, k\n\n  res = 0.\n  do k = k0+1, k1\n     do j = j0+1, j1\n        do i = i0+1, i1\n           res = res+ x(k,j,i)*x(k,j,i)\n        enddo\n     enddo\n  enddo\n  \nend subroutine norm\n"}, {"instruction": "Create a Fortran subroutine named preglq to calculate the zeros and weights for Gauss-Legendre quadrature. The number of input parameters is 3, of type ['real*8', 'real*8', 'integer'], representing the lower bound, upper bound, and number of points used in the quadrature. The number of output parameters is 2, of type ['real*8', 'real*8'], representing the array of zeros and array of weights used in the quadrature.", "input": "", "output": "subroutine preglq(x1, x2, n, zero, w)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis routine will find the zeros and weights that are\n!\tused in gauss-legendre quadrature routines. (based on routines\n!\tin numerical recipes).\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tx1: lower bound of integration.\n!\t\t\tx2:\tupper bound of integration.\n!\t\t\tn:\tnumber of points used in the quadrature. n points\n!\t\t\t\twill integrate a polynomial of degree 2n-1 exactly.\n!\t\tout\n!\t\t\tzero:\tarray of n gauss points, which correspond to the zeros\n!\t\t\t\tof p(n,0).\n!\t\t\tw:\tarray of n weights used in the quadrature.\n!\n!\n!\tnote \n!\t\t1.\tif eps is less than what is defined, then the do \n!\t\t\tloop for finding the roots might never terminate for some\n!\t\t\tvalues of lmax. if the algorithm doesn't converge, consider\n!\t\t\tincreasing itermax, or decreasing eps.\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek 2003\n!\n!\tcopyright (c) 2005-2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\treal*8, intent(in)  :: \tx1, x2\n\treal*8, intent(out) ::\tzero(n), w(n)\n\tinteger, intent(in) ::\tn\n\t\n\tinteger             ::\ti, j, m, iter\n\tinteger, parameter  ::\titermax = 1000\n\treal*8, parameter   ::\teps     = 1.0d-15\n\treal*8              ::\tp1, p2, p3, pp, z, z1, xm, xu\n\t\n\t\n\tzero = 0.0d0\n\tw    = 0.0d0\n\t\n\t! the roots are symmetric in the interval, so we only have to find half of them. \n\tm    = (n+1)/2\n\t\n\txm   = (x2 + x1) / 2.0d0\t! midpoint of integration\n\txu   = (x2 - x1) / 2.0d0\t! scaling factor between interval of integration, and that of \n\t\t\t\t! the -1 to 1 interval for the gauss-legendre interval\n\t\n\tdo i = 1,m \n\t\titer = 0\n\t\tz = cos(3.141592654d0 * (i - .25d0)/(n+.5d0))\t! approximation for the ith root\n\t\t\t\t\t\t\t\n\t\t! find the true value using newtons method\n\t\tdo\n\t\t\titer = iter +1\n\t\t\t\n\t\t\tp1 = 1.0d0\n\t\t\tp2 = 0.0d0\n\t\t\t\n\t\t\t! determine the legendre polynomial evaluated at z (p1) using recurrence relationships\n\t\t\tdo j=1, n \t\n\t\t\t\tp3 = p2\n\t\t\t\tp2 = p1\n\t\t\t\tp1 = (dble(2*j-1)*z*p2-dble(j-1)*p3)/dble(j)\n\t\t\tenddo\n\t\t\t\n\t\t\t! this is the derivative of the legendre polynomial using recurrence relationships\n\t\t\tpp=dble(n)*(z*p1-p2)/(z*z-1.0d0)\n\t\t\n\t\t\tz1 = z\n\t\t\tz  = z1-p1/pp \n\t\t\n\t\t\tif (abs(z-z1) <= eps) exit\n\t\t\t\n\t\t\tif (iter > itermax) then\n\t\t\t\tprint*, \"error --- preglq\"\n\t\t\t\tprint*, \"root finding of preglq not converging.\"\n\t\t\t\tprint*, \"m , n = \", m, n\n\t\t\t\tstop\n\t\t\tendif\t\t\t\n\t\tenddo\n\t\t\n\t\tzero(i) = xm + xu*z\n\t\tzero(n+1-i) = xm - xu*z\n\t\tw(i)= 2.0d0 * xu / ((1.0d0-z*z)*pp*pp)\n\t\tw(n+1-i)=w(i) \t\t\n\tenddo\nend subroutine preglq\n"}, {"instruction": "Create a Fortran subroutine named ttp_init to initialize state and gating variables based on the value of imyo. The subroutine takes 5 input parameters of types integer, integer, integer, real(kind=8) (optional), and real(kind=8) (optional), and returns 2 output parameters of type real(kind=8).", "input": "", "output": "      subroutine ttp_init(imyo, nx, ng, x, xg, x0, xg0)\n      implicit none\n      integer, intent(in) :: imyo, nx, ng\n      real(kind=8), intent(out) :: x(nx), xg(ng)\n      real(kind=8), intent(in), optional :: x0(nx), xg0(ng)\n\n      select case (imyo)\n      case (1) ! epi !\n!        initialize state variables\n         x(1)   = -85.23d0      ! v      (units: mv)\n         x(2)   =  136.89d0     ! k_i    (units: mm)\n         x(3)   =  8.6040d0     ! na_i   (units: mm)\n         x(4)   =  1.26d-4      ! ca_i   (units: mm)\n         x(5)   =  3.6d-4       ! ca_ss  (units: mm)\n         x(6)   =  3.64d0       ! ca_sr  (units: mm)\n         x(7)   =  9.073d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  6.21d-3      ! x_r1   (dimensionless)\n         xg(2)  =  4.712d-1     ! x_r2   (dimensionless)\n         xg(3)  =  9.5d-3       ! x_s    (dimensionless)\n         xg(4)  =  1.72d-3      ! m      (dimensionless)\n         xg(5)  =  7.444d-1     ! h      (dimensionless)\n         xg(6)  =  7.045d-1     ! j      (dimensionless)\n         xg(7)  =  3.373d-5     ! d      (dimensionless)\n         xg(8)  =  7.888d-1     ! f      (dimensionless)\n         xg(9)  =  9.755d-1     ! f_2    (dimensionless)\n         xg(10) =  9.953d-1     ! f_cass (dimensionless)\n         xg(11) =  9.99998d-1   ! s      (dimensionless)\n         xg(12) =  2.42d-8      ! r      (dimensionless)\n\n      case (2) ! endo !\n!        initialize state variables\n         x(1)   = -86.709d0     ! v      (units: mv)\n         x(2)   =  138.4d0      ! k_i    (units: mm)\n         x(3)   =  10.355d0     ! na_i   (units: mm)\n         x(4)   =  1.30d-4      ! ca_i   (units: mm)\n         x(5)   =  3.6d-4       ! ca_ss  (units: mm)\n         x(6)   =  3.715d0      ! ca_sr  (units: mm)\n         x(7)   =  9.068d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  4.48d-3      ! x_r1   (dimensionless)\n         xg(2)  =  4.76d-1      ! x_r2   (dimensionless)\n         xg(3)  =  8.7d-3       ! x_s    (dimensionless)\n         xg(4)  =  1.55d-3      ! m      (dimensionless)\n         xg(5)  =  7.573d-1     ! h      (dimensionless)\n         xg(6)  =  7.225d-1     ! j      (dimensionless)\n         xg(7)  =  3.164d-5     ! d      (dimensionless)\n         xg(8)  =  8.009d-1     ! f      (dimensionless)\n         xg(9)  =  9.778d-1     ! f_2    (dimensionless)\n         xg(10) =  9.953d-1     ! f_cass (dimensionless)\n         xg(11) =  3.212d-1     ! s      (dimensionless)\n         xg(12) =  2.235d-8     ! r      (dimensionless)\n\n      case (3) ! mid-myo !\n!        initialize state variables\n         x(1)   = -85.423d0     ! v      (units: mv)\n         x(2)   =  138.52d0     ! k_i    (units: mm)\n         x(3)   =  10.132d0     ! na_i   (units: mm)\n         x(4)   =  1.53d-4      ! ca_i   (units: mm)\n         x(5)   =  4.2d-4       ! ca_ss  (units: mm)\n         x(6)   =  4.272d0      ! ca_sr  (units: mm)\n         x(7)   =  8.978d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  1.65d-2      ! x_r1   (dimensionless)\n         xg(2)  =  4.730d-1     ! x_r2   (dimensionless)\n         xg(3)  =  1.74d-2      ! x_s    (dimensionless)\n         xg(4)  =  1.65d-3      ! m      (dimensionless)\n         xg(5)  =  7.490d-1     ! h      (dimensionless)\n         xg(6)  =  6.788d-1     ! j      (dimensionless)\n         xg(7)  =  3.288d-5     ! d      (dimensionless)\n         xg(8)  =  7.026d-1     ! f      (dimensionless)\n         xg(9)  =  9.526d-1     ! f_2    (dimensionless)\n         xg(10) =  9.942d-1     ! f_cass (dimensionless)\n         xg(11) =  9.99998d-1   ! s      (dimensionless)\n         xg(12) =  2.347d-8     ! r      (dimensionless)\n\n      end select\n\n      if (present(x0)) then\n         if (size(x0,1) .ne. nx) then\n            stop \"error: inconsistent array size (ttp initialization)\"\n         end if\n         x(:)  = x0(:)\n      end if\n\n      if (present(xg0)) then\n         if (size(xg0,1) .ne. ng) then\n            stop \"error: inconsistent array size (ttp initialization)\"\n         end if\n         xg(:) = xg0(:)\n      end if\n\n      return\n      end subroutine ttp_init\n"}, {"instruction": "Create a Fortran subroutine named ell_chol_det to calculate the determinant of a lower triangular matrix. The subroutine takes 2 input parameters: an integer n and a real array g of kind k_dp. It also has 1 output parameter: a real of kind k_dp to store the determinant.", "input": "", "output": "subroutine ell_chol_det( n, g, det )\n\n!  g contains (in packed format) the lower triangular n x n matrix g.\n!  the determinant of g, det, is returned.\n!  if g represents an ellipsoid e, then det is the inverse of the \n!  content (volume) of e.\n\nimplicit none\ninteger, parameter      :: k_dp = kind(1.d0)\ninteger, intent(in)     :: n\nreal(k_dp), intent(in)  :: g((n*(n+1))/2)\nreal(k_dp), intent(out) :: det\n\ninteger    :: j, k\n\ndet = 1.d0\n\nk  = 1\ndo j = 1, n\n   det = det * g(k)\n   k = k + n + 1 - j\nend do\n\nreturn\nend subroutine ell_chol_det\n"}, {"instruction": "Write a Fortran subroutine named \"mm1\" to perform matrix multiplication. The subroutine takes 2 input parameters of type real, dimension(:,:) and intent(in), named \"a\" and \"b\". It also has 1 output parameter of type real, dimension(:,:), and intent(out), named \"c\". Set \"c\" to -42, then perform the matrix multiplication of \"a\" and the transpose of \"b\" and store the result in \"c\".", "input": "", "output": "  subroutine mm1(a,b,c)\n    real, dimension(:,:), intent(in) :: a, b\n    real, dimension(:,:), intent(out) :: c\n    c = -42.\n    c = matmul(a, transpose(b))\n  end subroutine mm1\n"}, {"instruction": "Create a Fortran subroutine named one that takes in three double precision input parameters (x, mu, sig) and returns one output parameter of type double precision (oneval). The subroutine sets the value of oneval to 1.", "input": "", "output": "    subroutine one(x, mu, sig, oneval)\n        double precision, intent(in) :: x, mu, sig\n        double precision, intent(out) :: oneval\n        oneval = 1d0\n    end subroutine one\n"}, {"instruction": "Create a Fortran subroutine named \"get_cutoff_gaussian\" to calculate the left and right cutoff values for a Gaussian distribution based on the mean (mu) and standard deviation (sig) provided as input. The input parameters should be of type double precision and have intent(in), while the output parameters should also be of type double precision with intent(out). There are 2 input parameters of type double precision and 2 output parameters of type double precision.", "input": "", "output": "    subroutine get_cutoff_gaussian(mu, sig, left_cutoff, right_cutoff)\n        double precision, intent(in) :: mu, sig\n        double precision, intent(out) :: left_cutoff, right_cutoff\n        \n        if (sig > 0d0) then\n            left_cutoff = mu - 5d0*sig\n            right_cutoff = mu + 5d0*sig\n        else\n            left_cutoff = 0d0\n            right_cutoff = 0d0\n        end if\n    end subroutine get_cutoff_gaussian\n"}, {"instruction": "Create a Fortran subroutine named get_interpolated_value to perform linear interpolation between two points based on the given x and y arrays. The subroutine should take 4 input parameters of type double precision, dimension(nx), double precision, and integer, and 1 output parameter of type double precision.", "input": "", "output": "    subroutine get_interpolated_value(x, y, xval, nx, yval)\n        double precision, dimension(nx), intent(in) :: x, y\n        double precision, intent(in) :: xval\n        integer, intent(in) :: nx\n        double precision, intent(out) :: yval\n        \n        integer :: ix\n        double precision :: x_left, x_right, y_left, y_right\n        \n        if (xval <= x(1)) then\n            yval = (y(2)-y(1))*(xval-x(1))/(x(2)-x(1)) + y(1)\n            return\n        end if\n        \n        if (xval >= x(nx)) then\n            yval = (y(nx)-y(nx-1))*(xval-x(nx))/(x(nx)-x(nx-1)) + y(nx)\n            return\n        end if\n        \n        do ix=1, nx\n            if (x(ix) > xval) then\n                x_left = x(ix-1)\n                x_right = x(ix)\n                y_left = y(ix-1)\n                y_right = y(ix)\n                exit\n            end if\n        end do\n        yval = (y_right-y_left)*(xval-x_right)/(x_right-x_left) + y_right\n    end subroutine get_interpolated_value\n"}, {"instruction": "Write a Fortran subroutine named polyexp_cut to calculate the value and derivatives of a polynomial-exponential function based on the input parameters. The subroutine takes 5 input parameters of type double precision: x, xcut, fc, dfc, d2fc, and returns 4 output parameters of type double precision: y, dy, d2y, d3y. The subroutine computes the function value y, as well as the first, second, and third derivatives dy, d2y, d3y based on the input parameters and assigns them to the corresponding output parameters.", "input": "", "output": "  subroutine polyexp_cut(x, xcut, fc, dfc, d2fc, y, dy, d2y, d3y)\n\n    implicit none\n\n    double precision,                     intent(in)  :: x, xcut\n    double precision,                     intent(in)  :: fc, dfc, d2fc\n    double precision,                     intent(out) :: y, dy, d2y, d3y\n\n    y   = fc + (x - xcut)*dfc + 0.5d0*(x - xcut)*(x - xcut)*d2fc\n    dy  = dfc + (x - xcut)*d2fc\n    d2y = d2fc\n    d3y = 0\n\n  end subroutine polyexp_cut\n"}, {"instruction": "Create a Fortran subroutine named copy that takes three input parameters: two integers ni and nj, and a 2D array of double precision values src. It also has one output parameter, a 2D array of double precision values dst. The subroutine copies the values from src to dst using the dimensions specified by ni and nj.", "input": "", "output": "  subroutine copy (dst, src, ni, nj)\n    integer, intent(in) :: ni, nj\n    double precision, intent(out) :: dst(ni, nj)\n    double precision, intent(in)  :: src(ni, nj)\n    dst = src\n  end subroutine copy\n"}, {"instruction": "Create a Fortran subroutine named \"autocorr\" to calculate the normalized auto-correlation function for an array of real(8) values. The subroutine should have 3 input parameters of type integer, integer, and real(8) for the total number of elements, correlation length, and array of values, respectively. It should also have 1 output parameter of type real(8) for the normalized auto-correlation function.", "input": "", "output": "subroutine autocorr(acf, a, ittotal, itcorr)\n   implicit none\n   integer, intent(in)  ::  ittotal       ! total number of a\n   integer, intent(in)  ::  itcorr        ! correlation length\n   real(8), intent(in)  ::  a(1:ittotal)  ! array of values of a\n   real(8), intent(out) ::  acf(0:itcorr) ! normalized auto-correlation function\n\n   real(8) ::  nacf(0:itcorr)             ! number of acf, for normalization of acf\n   integer :: it, it0, it0max, itau       ! time index of t0+tau, t0, t0max and tau\n\n   ! initialize all the auto-correlation functions to be calculated\n   acf(0:itcorr)  = 0d0\n   nacf(0:itcorr) = 0d0\n\n   ! for each t0 from 1 to total, calculate auto-correlation function\n   do it0 = 1, ittotal\n\n      ! the max index of t0 must not exceed the last index\n      it0max = min(ittotal, it0+itcorr)\n\n      ! for all possible t0+tau, calculate a(t0)*a(t0+tau) and add them\n      do it = it0, it0max\n\n         ! interval between t and t0\n         itau  = it - it0\n\n         ! calculate auto-correlation function for current interval\n         acf(itau) = acf(itau) + a(it0) * a(it)\n\n         ! count the number of auto-correlation function\n         nacf(itau) = nacf(itau) + 1d0\n      end do\n\n   end do\n\n   ! normalize auto-correlation function\n   do it = 0, itcorr\n      acf(it) = acf(it) / nacf(it)\n   end do\n\n   return\nend subroutine autocorr\n"}, {"instruction": "Write a Fortran subroutine named mk_gmtrvec_on_plane that takes two input parameters of type real(8) arrays with 3 elements each. The output consists of two real(8) arrays, also with 3 elements each. The subroutine calculates the vector vt as the difference between the input arrays vto and vfrom, and computes the vector vn as a perpendicular vector to vt lying in the xy-plane.", "input": "", "output": "  subroutine mk_gmtrvec_on_plane( vfrom, vto, vt, vn )\n    implicit none\n\n    real(8), intent(in)  :: vfrom(3), vto(3)\n    real(8), intent(out) :: vt(3),    vn(3)\n    !---------------------------------------------------------------------------\n\n    vt(:) = vto(:) - vfrom(:)\n\n    vn(1) = -vt(2)\n    vn(2) =  vt(1)\n    vn(3) =   0.d0\n\n    return\n  end subroutine mk_gmtrvec_on_plane\n"}, {"instruction": "Create a Fortran subroutine named \"get_area_face\" to calculate the surface area of a face defined by 4 vertices in 3D space. The subroutine should have 13 input parameters of types integer*4, real*8, and 1 output parameter of type real*8.", "input": "", "output": "     subroutine get_area_face(x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4,surf,ielem)\n     \n     implicit none\n\n     integer*4, intent(in) :: ielem\n\n     real*8 :: a,b,c,vx,vy,vz,wx,wy,wz,xbar,ybar,zbar\n     real*8, intent(in) :: x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4\n     real*8, intent(out) :: surf\n     \n     surf = 0.d0\n     \n     xbar = (x1 + x2 + x3 + x4)/4.d0\n     ybar = (y1 + y2 + y3 + y4)/4.d0\n     zbar = (z1 + z2 + z3 + z4)/4.d0\n     \n     vx = x4 - x1\n     vy = y4 - y1 \n     vz = z4 - z1\n     \n     wx = xbar - x1\n     wy = ybar - y1\n     wz = zbar - z1     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n\n                        \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x2 - x1\n     vy = y2 - y1 \n     vz = z2 - z1\n     \n     wx = xbar - x1\n     wy = ybar - y1\n     wz = zbar - z1     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x2 - x3\n     vy = y2 - y3 \n     vz = z2 - z3\n     \n     wx = xbar - x3\n     wy = ybar - y3\n     wz = zbar - z3     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x4 - x3\n     vy = y4 - y3 \n     vz = z4 - z3\n     \n     wx = xbar - x3\n     wy = ybar - y3\n     wz = zbar - z3     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     end subroutine get_area_face\n"}, {"instruction": "Define a Fortran subroutine named define_connect_n that constructs nodal and basis connectivity matrices to establish local-global node and basis correspondence for multiple meshes. The subroutine takes 5 input parameters of type integer: bca, bcb, ne, p, and nm. It also has 2 output parameters of type integer: in and ib. The subroutine works for an arbitrary number of meshes and handles boundary conditions at x=a and x=b for each mesh.", "input": "", "output": "subroutine define_connect_n(bca, bcb, ne, p, nm, in, ib)\n! constructs connectivity matrices in and ib defining local-global node and\n! basis correspondence, respectively. works for arbitrary number of meshes\ninteger, intent(in):: bca(:)        ! bca(m) boundary condition at x=a for mesh\n    ! m: 1=dirichlet, 2=neumann\ninteger, intent(in):: bcb(:)        ! bca(m) boundary condition at x=b for mesh\n    ! m: 1=dirichlet, 2=neumann\ninteger, intent(in):: ne         ! number of elements\ninteger, intent(in):: p          ! order of fe/se basis\ninteger, intent(in):: nm         ! number of meshes\ninteger, intent(out):: in(:,:,:)   ! nodal connectivity: in(i,j,k) = index of\n    ! basis node corresponding to local node i of element j of mesh k\ninteger, intent(out):: ib(:,:,:)  ! basis connectivity: ib(i,j,k) = index of\n    ! basis function associated with local basis function i of element j of\n    ! mesh k.  0 = no associated basis fn\ninteger :: i, e, m, dofs\n! construct nodal connectivity matrix\ndofs = 0\ndo m = 1, nm\n    do e = 1, ne\n        do i = 1, p+1\n            dofs = dofs + 1\n            in(i, e, m) = dofs\n        end do\n        dofs = dofs - 1 ! connect the shape functions across the element\n    end do\n    dofs = dofs + 1 ! don't connect the shape functions across meshes\nend do\n! construct basis connectivity matrix\ndofs = 0\ndo m = 1, nm\n    do e = 1, ne\n        do i = 1, p+1\n            if (i == 1   .and. e == 1  .and. bca(m) == 1) then\n                ib(i, e, m) = 0 ! dirichlet\n                cycle\n            end if\n            if (i == p+1 .and. e == ne .and. bcb(m) == 1) then\n                ib(i, e, m) = 0 ! dirichlet\n                cycle\n            end if\n            dofs = dofs + 1\n            ib(i, e, m) = dofs\n        end do\n        dofs = dofs - 1 ! connect the shape functions across the element\n    end do\n    dofs = dofs + 1 ! don't connect the shape functions across meshes\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named transferrate to compute the unnormalized probability of a collisional energy transfer from state j to state i using a single-exponential-down model. The subroutine should have 9 input parameters of types integer, real(8), and real(8) arrays of size ngrains, and 1 output parameter of type real(8).", "input": "", "output": "subroutine transferrate(i, j, ei, ej, alpha, e0, rho, ngrains, t, rate)\n    ! computes the unnormalized probability of a collisional energy transfer\n    ! from state j (with energy ej) to state i (with energy ei) using a\n    ! single-exponental-down model.\n    !\n    ! ============ ====== ======================================================\n    ! parameter    intent description\n    ! ============ ====== ======================================================\n    ! `i`          in     index of destination state\n    ! `j`          in     index of source state\n    ! `ei`         in     energy of destination state i in cm^-1\n    ! `ej`         in     energy of source state j in cm^-1\n    ! `alpha`      in     parameter in exponential-down model in (cm^-1)^-1\n    ! `e0`         in     electronic + zero-point energy of ground state in\n    !                     cm^-1\n    ! `rho`        in     density of states\n    ! `ngrains`    in     number of energy grains in density of states\n    ! `t`          in     temperature of interest in k\n    ! `rate`       out    collisional transfer probability in s^-1\n    ! ============ ====== ======================================================\n\n    ! type definitions of parameters\n    integer, intent(in)                 ::  ngrains\n    integer, intent(in)                 ::  i\n    integer, intent(in)                 ::  j\n    real(8), intent(in)                 ::  ei\n    real(8), intent(in)                 ::  ej\n    real(8), intent(in)                 ::  alpha\n    real(8), intent(in)                 ::  e0\n    real(8), dimension(1:ngrains), intent(in)   ::  rho\n    real(8), intent(in)                 ::  t\n    real(8), intent(out)                ::  rate\n\n    real(8) r\n\n    r = 8.314472\n\n    ! evaluate collisional transfer probability - theoretically correct way\n    if (ej < e0 .or. ei < e0 .or. rho(j) .eq. 0) then\n       rate = 0.\n    elseif (ej >= ei) then\n       rate = exp(-(ej - ei) / alpha)\n    else\n       rate = exp(-(ei - ej) / alpha) * rho(i) / rho(j) * exp( -(ei - ej) / (r * t))\n    end if\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named welford to calculate the Welford's algorithm for computing the sample mean and sample variance of a real array.The number of input arguments is 1 and the test_data type is [real].The number of output arguments is 2 and the test_data type is [real, real].", "input": "", "output": "    subroutine welford(x,xb,s)\n        implicit none\n        \n            real,intent(in)     :: x(:)\n            real,intent(out)    :: xb\n            real,intent(out)    :: s\n                        \n            real    :: lxb,delta\n            integer :: n\n            \n            \n            xb = 0\n            delta = 0\n            do n = 1,size(x)\n                lxb = xb\n                xb = lxb + (x(n)-lxb)/n\n                delta = delta + (x(n)-lxb)*(x(n)-xb)\n            end do\n            s = delta/(n-1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two integer input parameters and returns an integer result. The input parameters should be specified using the \"intent(in)\" attribute, and the output parameter should be specified using the \"intent(out)\" attribute. The subroutine should compute the sum of the two input integers and assign the result to the output parameter.", "input": "", "output": "subroutine add(a, b, res)\n\n  ! listing 3.13 in the book.\n  integer, intent(in) :: a, b\n  integer, intent(out) :: res\n  res = a + b\nend subroutine add\n"}, {"instruction": "Create a Fortran subroutine named rmax to find the maximum value in an array and the location of that value in the array. The subroutine should take 2 input parameters: an integer n and a real array of dimension n. It should have 2 output parameters: a real value representing the maximum value in the array and an integer representing the location of the maximum value.", "input": "", "output": "subroutine rmax ( a, n, real_max, imax )\r\n!\r\n!  purpose:\r\n!    to find the maximum value in an array, and the location\r\n!    of that value in the array.\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n             ! no. of vals in array a.\r\nreal, intent(in), dimension(n) :: a  ! input data.\r\nreal, intent(out) :: real_max        ! maximum value in a.\r\ninteger, intent(out) :: imax         ! location of max value.\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: i                         ! index variable\r\n\r\n! initialize the maximum value to first value in array.\r\nreal_max = a(1)\r\nimax = 1\r\n \r\n! find the maximum value.\r\ndo i = 2, n\r\n   if ( a(i) > real_max ) then\r\n      real_max = a(i)\r\n      imax = i\r\n   end if\r\nend do\r\n\r\nend subroutine rmax\r\n"}, {"instruction": "Create a Fortran subroutine named \"ave_sd\" to calculate the average and standard deviation of an array. The subroutine should have 2 input parameters: one integer and one real array of dimension n. It should have 3 output parameters: two real numbers for average and standard deviation, and one integer for error flag.", "input": "", "output": "subroutine ave_sd ( a, n, ave, std_dev, error )\r\n!\r\n!  purpose:\r\n!    to calculate the average and standard deviation of an array.\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n             ! no. of vals in array a.\r\nreal, intent(in), dimension(n) :: a  ! input data.\r\nreal, intent(out) :: ave             ! average of a.\r\nreal, intent(out) :: std_dev         ! standard deviation.\r\ninteger, intent(out) :: error        ! flag: 0 -- no error\r\n                                     !       1 -- sd invalid\r\n                                     !       2 -- ave & sd invalid\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: i                         ! loop index\r\nreal :: sum_x                        ! sum of input values\r\nreal :: sum_x2                       ! sum of input values squared\r\n\r\n! initialize the sums to zero.\r\nsum_x  = 0.\r\nsum_x2 = 0.\r\n \r\n! accumulate sums.\r\ndo i = 1, n\r\n   sum_x  = sum_x + a(i)\r\n   sum_x2 = sum_x2 + a(i)**2\r\nend do\r\n \r\n! check to see if we have enough input data.\r\nif ( n >= 2 ) then ! we have enough data\r\n \r\n   ! calculate the mean and standard deviation\r\n   ave   = sum_x / real(n)\r\n   std_dev = sqrt( (real(n) * sum_x2 - sum_x**2) &\r\n           / (real(n) * real(n-1)) )\r\n   error = 0\r\n \r\nelse if ( n == 1 ) then ! no valid std_dev\r\n \r\n   ave   = sum_x               \r\n   std_dev = 0.              ! std_dev invalid\r\n   error = 1\r\n \r\nelse\r\n \r\n   ave = 0.                  ! ave invalid\r\n   std_dev = 0.              ! std_dev invalid\r\n   error = 2\r\n\r\nend if\r\nend subroutine ave_sd\r\n"}, {"instruction": "Write a Fortran subroutine named overlapping_halo_prob to calculate the overlapping halo probability. The subroutine takes 4 input parameters: two integers n1 and n2, and two real(8) numbers r and outersum(n1,n2). It produces 1 output parameter res(:,:) of type real(8).", "input": "", "output": "    subroutine overlapping_halo_prob(r,n1,n2,outersum,res)\n        integer, intent(in) :: n1,n2\n        real(8), intent(in) :: r, outersum(n1,n2)\n        real(8), intent(out):: res(:,:)\n\n        real(8) :: y(n1,n2),x(n1,n2)\n\n        x = r/outersum\n        y = (x - 0.8) / 0.29\n\n\n        res = 3 * y ** 2 - 2 * y ** 3\n        where (y.le.0.d0) res = 0.d0\n        where (y.ge.1.d0) res = 1.d0\n\n    end subroutine overlapping_halo_prob\n"}, {"instruction": "Create a Fortran subroutine named dblsimps that implements Simpson's rule for a double integral. The subroutine takes 5 input parameters of types integer, integer, real(8), real(8), real(8) and 1 output parameter of type real(8). The subroutine computes the double integral using Simpson's rule and stores the result in the output parameter.", "input": "", "output": "subroutine dblsimps(x,nx,ny, dx, dy,out)\n        integer, intent(in) :: nx,ny\n        real(8), intent(in) :: x(nx,ny)\n        real(8), intent(in) :: dx, dy\n        real(8), intent(out) :: out\n\n        integer :: lengthx,lengthy\n        integer :: i\n        real(8),allocatable :: w(:,:)\n\n        if (mod(nx,2) .eq. 0)then\n            lengthx = nx-1\n        else\n            lengthx = nx\n        end if\n\n        if (mod(ny,2) .eq. 0)then\n            lengthy = ny-1\n        else\n            lengthy = ny\n        end if\n\n        allocate(w(lengthx,lengthy))\n        w = 1.d0\n\n        w(2:lengthx-1:2, :) = w(2:lengthx-1:2, :)*4\n        w(:, 2:lengthy-1:2) = w(:, 2:lengthy-1:2)*4\n        w(3:lengthx-2:2, :) = w(3:lengthx-2:2, :)*2\n        w(:, 3:lengthy-2:2) = w(:, 3:lengthy-2:2)*2\n\n        out =dx * dy * sum(w * x(1:lengthx,1:lengthy)) / 9.0\n\n    end subroutine dblsimps\n"}, {"instruction": "Create a Fortran subroutine named mapc2pidentity to map the input 3D Cartesian coordinates (xc, yc, zc) to the output 3D Cartesian coordinates (xp, yp, zp). The input parameters consist of three real(kind=8) arrays of dynamic size, and the output parameters consist of three real(kind=8) arrays of the same size as the input arrays. Use the imperative tone when writing the subroutine.", "input": "", "output": "  subroutine mapc2pidentity(xc,yc,zc,xp,yp,zp)\n\n    implicit none\n    \n    ! input\n    real(kind=8), dimension(:), intent(in) :: xc,yc,zc\n    \n    ! output\n    real(kind=8), dimension(size(xc)), intent(out) :: xp\n    real(kind=8), dimension(size(yc)), intent(out) :: yp\n    real(kind=8), dimension(size(zc)), intent(out) :: zp\n    \n    ! x,xi coordinate\n    xp = xc\n    \n    ! y,eta coordinate\n    yp = yc\n    \n    ! z,phi coordinate\n    zp = zc\n    \n    return\n  end subroutine mapc2pidentity\n"}, {"instruction": "Create a Fortran subroutine named determinant. This subroutine takes a single input parameter of type real(kind=8), dimension(3,3) as input. It computes the determinant of a 3x3 matrix and returns the result as an output parameter of type real(kind=8).", "input": "", "output": "  subroutine determinant(a,deta)\n\n    implicit none\n\n    ! input\n    real(kind=8), dimension(3,3), intent(in) :: a\n\n    ! output\n    real(kind=8), intent(out) :: deta\n\n    deta = a(1,1)*a(2,2)*a(3,3) &\n         + a(2,1)*a(3,2)*a(1,3) &\n         + a(3,1)*a(1,2)*a(2,3) &\n         - a(3,1)*a(2,2)*a(1,3) &\n         - a(2,1)*a(1,2)*a(3,3) &\n         - a(1,1)*a(3,2)*a(2,3)\n\n    return\n  end subroutine determinant\n"}, {"instruction": "Create a Fortran subroutine named zgrid that takes 4 input parameters: two integers (nd and np), and two real*8 arrays (radius and p). It also has 1 output parameter, an allocatable one-dimensional real*8 array (z). The subroutine calculates values for the z array based on the input parameters and the allocated memory for z.", "input": "", "output": "      subroutine zgrid(radius, p, z, nd, np)\r\n\r\n      implicit none\r\n\n\r\n      integer, intent(in)  :: nd, np\r\n      real*8,  intent(in)  :: radius(nd), p(np)\r\n\r\n      real*8,  allocatable, dimension(:), intent(out) :: z\r\n\r\n      integer :: i, j, l, jmax\r\n\r\n      allocate(z(nd * np))\r\n\r\n      z(1 : nd * np) = 0.0d0\r\n\r\n      do l = 1, nd\r\n\r\n         jmax = np + 1 - l\r\n\r\n         do j = 1, jmax\r\n\r\n            i = (j - 1) * nd + l\r\n\r\n            z(i) = sqrt((radius(l) - p(j)) * (radius(l) + p(j)))\r\n\r\n        enddo\r\n\r\n      enddo\r\n\r\n      return\r\n\r\n      end subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named calc_pbl_index to calculate the planetary boundary layer index based on the given 3D array of atmospheric data and the corresponding boundary layer height profiles. The subroutine takes 2 input parameters of type real, dimension(:,:,:) and real, dimension(:,:), and 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "    subroutine calc_pbl_index(z,pblh,pblh_i)\n        implicit none\n        real, dimension(:,:,:),intent(in)::z\n        real, dimension(:,:),intent(in)::pblh\n        integer,dimension(:,:),intent(out)::pblh_i\n        integer::nx,ny,nz,i,j,k\n\n        nx=size(z,1)\n        nz=size(z,2)\n        ny=size(z,3)\n        pblh_i=1\n        !$omp parallel firstprivate(nx,ny,nz) &\n        !$omp private(i,j,k) &\n        !$omp shared(pblh_i,pblh)\n        !$omp do schedule(static)\n        do j=1,ny\n            do k=1,nz-1\n                do i=1,nx\n                    if (z(i,k,j)<=pblh(i,j)) then\n                        pblh_i(i,j)=k\n                    endif\n                enddo\n            enddo\n        enddo\n        !$omp end do\n        !$omp end parallel\n\n    end subroutine calc_pbl_index\n"}, {"instruction": "Write a Fortran subroutine named get_smallest to find the smallest value and its index from an array of double precision numbers, and determine if all the elements are equal. The subroutine should have 2 input parameters of type integer and double precision, and 3 output parameters of type integer, double precision, and logical.", "input": "", "output": "  subroutine get_smallest(idm, arr, ismall, smallest, allequal)\n    ! dummy\n    integer,                          intent(in)  :: idm\n    double precision, dimension(idm), intent(in)  :: arr\n    integer,                          intent(out) :: ismall\n    double precision,                 intent(out) :: smallest\n    logical,                          intent(out) :: allequal\n    ! local\n    integer :: i\n    double precision ::val1\n    !\n    ismall = 0\n    smallest = huge(smallest)\n    allequal = .true.\n    do i=1,idm\n      if (arr(i) < smallest) then\n        smallest = arr(i)\n        ismall = i\n      endif\n      if (i==1) then\n        val1 = arr(i)\n      else\n        if (arr(i) /= val1) allequal = .false.\n      endif\n    enddo\n    !\n    return\n  end subroutine get_smallest\n"}, {"instruction": "Write a Fortran subroutine named \"dec\" that subtracts the value of an input parameter \"offset\" from the output parameter \"base\". The input parameter \"offset\" is of type integer and is provided as an input, and the output parameter \"base\" is also of type integer.", "input": "", "output": "        pure subroutine dec(base, offset)\n\n                integer, intent(out) :: base\n                integer, intent(in) :: offset\n\n                base = base - offset\n\n                return\n\n        end subroutine dec\n"}, {"instruction": "Create a Fortran subroutine named checktimeregularity to analyze a set of timestamps and determine their regularity. The subroutine takes 2 input parameters of type ['integer, dimension(:)', 'logical, dimension(:)'] and 3 output parameters of type ['integer', 'integer', 'integer']. The subroutine analyzes the timestamps to calculate the frequency of occurrence, identify regularity, and check for gaps in the data.", "input": "", "output": "\tsubroutine checktimeregularity(ivtimestamp, lvdesiredsubset, ifrequency, iregularitycode, iretcode)\n\t\n\t\t! routine arguments\n\t\tinteger, dimension(:), intent(in)\t\t:: ivtimestamp\n\t\tlogical, dimension(:), intent(in)\t\t:: lvdesiredsubset\n\t\tinteger, intent(out)\t\t\t\t\t:: ifrequency\n\t\tinteger, intent(out)\t\t\t\t\t:: iregularitycode\n\t\tinteger, intent(out)\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\tinteger, dimension(0:3599)\t\t\t:: ivnumtimestamps\n\t\tinteger\t\t\t\t\t\t\t\t:: imaxnumstamps\n\t\tinteger\t\t\t\t\t\t\t\t:: i\n\t\tinteger, dimension(:), allocatable\t:: ivfrequency\n\t\tinteger, dimension(1)\t\t\t\t:: ivpos\n\t\tinteger\t\t\t\t\t\t\t\t:: iactualdata\n\t\tinteger\t\t\t\t\t\t\t\t:: iexpecteddata\n\t\t\n\t\t! internal constants\n\t\tinteger, parameter\t:: cond_sorted_data = 1\n\t\tinteger, parameter\t:: cond_no_gaps     = 2\n\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! set initial state of 'iregularitycode'\n\t\tiregularitycode = 0\n\t\t\n\t\t! get the number of time stamps (repeated, because only integer part is retained)\n\t\tivnumtimestamps = 0\n\t\tdo i = 1, size(ivtimestamp)\n\t\t\tif(lvdesiredsubset(i) .and. ivtimestamp(i) >= 0 .and. ivtimestamp(i) <= 3599) then\n\t\t\t\tivnumtimestamps(ivtimestamp(i)) = ivnumtimestamps(ivtimestamp(i)) + 1\n\t\t\tend if\n\t\tend do\n\t\t\n\t\t! which is the most frequent number of time stamps? if it exists, it estimates\n\t\t! sampling frequency.\n\t\timaxnumstamps = maxval(ivnumtimestamps)\n\t\tif(imaxnumstamps <= 0) then\n\t\t\tiregularitycode = 0\n\t\t\tiretcode = 1\n\t\t\treturn\n\t\tend if\n\t\tallocate(ivfrequency(imaxnumstamps))\n\t\tivfrequency = 0\n\t\tdo i = 0, 3599\n\t\t\tif(ivnumtimestamps(i) > 0) then\n\t\t\t\tivfrequency(ivnumtimestamps(i)) = ivfrequency(ivnumtimestamps(i)) + 1\n\t\t\tend if\n\t\tend do\n\t\tivpos = maxloc(ivfrequency)\n\t\tifrequency = ivpos(1)\n\t\tiregularitycode = iregularitycode + cond_sorted_data\n\t\t\n\t\t! check no gaps are present in data record, with gaps defined as\n\t\t! expected lines not received; invalid data are not considered\n\t\t! \"gaps\"\n\t\tiactualdata = sum(ivnumtimestamps)\n\t\tiexpecteddata = ifrequency * &\n\t\t\t\t\t\t(maxval(ivtimestamp, mask=ivtimestamp >= 0 .and. ivtimestamp < 3600 .and. lvdesiredsubset) - &\n\t\t\t\t\t\t minval(ivtimestamp, mask=ivtimestamp >= 0 .and. ivtimestamp < 3600 .and. lvdesiredsubset) + 1)\n\t\tif(float(abs(iactualdata-iexpecteddata)) / float(iexpecteddata) <= 0.01) then\n\t\t\tiregularitycode = iregularitycode + cond_no_gaps\n\t\tend if\n\t\t\n\t\t! leave\n\t\tdeallocate(ivfrequency)\n\t\n\tend subroutine checktimeregularity\n"}, {"instruction": "Create a Fortran subroutine named average that takes two input parameters: an array of real numbers and an array of logical values. The input parameter types are ['real, dimension(:)', 'logical, dimension(:)']. The subroutine has one output parameter of type real. The subroutine computes the average of the real numbers, considering only the elements in the array for which the corresponding logical value is true. If there are no desired elements, the output average is set to -9999.9.", "input": "", "output": "\tsubroutine average(rvx, lvdesiredsubset, ravg)\n\t\n\t\t! routine arguments\n\t\treal, dimension(:), intent(in)\t\t:: rvx\n\t\tlogical, dimension(:), intent(in)\t:: lvdesiredsubset\n\t\treal, intent(out)\t\t\t\t\t:: ravg\n\t\t\n\t\t! locals\n\t\tinteger\t:: inumdata\n\t\t\n\t\t! compute average, limiting attention to desired data\n\t\tinumdata = count(lvdesiredsubset)\n\t\tif(inumdata > 0) then\n\t\t\travg = sum(rvx, mask=lvdesiredsubset) / inumdata\n\t\telse\n\t\t\travg = -9999.9\n\t\tend if\n\t\t\n\tend subroutine average\n"}, {"instruction": "Create a Fortran subroutine named covariance to calculate the covariance between two sets of data. The subroutine takes 5 input parameters of type real, dimension(:), real, logical, dimension(:), real, and real. It also has 1 output parameter of type real.", "input": "", "output": "\tsubroutine covariance(rvx, rvy, lvdesiredsubset, ravgx, ravgy, rcov)\n\t\n\t\t! routine arguments\n\t\treal, dimension(:), intent(in)\t\t:: rvx\n\t\treal, dimension(:), intent(in)\t\t:: rvy\n\t\tlogical, dimension(:), intent(in)\t:: lvdesiredsubset\n\t\treal, intent(in)\t\t\t\t\t:: ravgx\n\t\treal, intent(in)\t\t\t\t\t:: ravgy\n\t\treal, intent(out)\t\t\t\t\t:: rcov\n\t\t\n\t\t! locals\n\t\tinteger\t:: inumdata\n\t\t\n\t\t! compute average, limiting attention to desired data\n\t\tinumdata = count(lvdesiredsubset)\n\t\tif(inumdata > 0) then\n\t\t\trcov = sum((rvx-ravgx)*(rvy-ravgy), mask=lvdesiredsubset) / inumdata\n\t\telse\n\t\t\trcov = -9999.9\n\t\tend if\n\t\t\n\tend subroutine covariance\n"}, {"instruction": "Create a Fortran subroutine named check_base64 to validate a given string as a Base64 encoded string. The subroutine takes 1 input parameter of type character with variable length. It also takes 1 output parameter of type logical.", "input": "", "output": "subroutine check_base64( string, error )\r\n    character(len=*), intent(in) :: string\r\n    logical, intent(out)         :: error\r\n\r\n    integer                      :: i\r\n\r\n    error = .false.\r\n    do i = 1,len(string)\r\n        if ( index( '0123456789 +/=', string(i:i) ) > 0 ) then\r\n            cycle\r\n        endif\r\n        if ( iachar(string(i:i)) >= iachar('a') .and. iachar(string(i:i)) <= iachar('z') ) then\r\n            cycle\r\n        endif\r\n\r\n        error = .true.\r\n        exit\r\n    enddo\r\nend subroutine check_base64\r\n"}, {"instruction": "Create a Fortran subroutine named invertmatrix that takes two input parameters: an integer n and a real(8) matrix, and two output parameters: an integer errorflag and a real(8) inverted matrix. The subroutine is designed to calculate the inverse of the input matrix using Gaussian elimination. The errorflag indicates the success or failure of the inversion process. If the inversion is successful, errorflag will be 0; otherwise, it will be -1.", "input": "", "output": "subroutine invertmatrix(matrix, inverse, n, errorflag)\n\timplicit none\n\t!declarations\n\tinteger, intent(in)  :: n\n\tinteger, intent(out) :: errorflag  !return error status. -1 for error, 0 for normal\n\treal(8), intent(in)\t:: matrix(n,n)  !input matrix\n\treal(8), intent(out)\t:: inverse(n,n) !inverted matrix\n\t\n\tlogical :: flag = .true.\n\tinteger :: i, j, k\n\treal(8) :: m\n\treal(8), dimension(n,2*n) :: augmatrix !augmented matrix\n\t\n\t!augment input matrix with an identity matrix\n\tdo i = 1, n\n\t\tdo j = 1, 2*n\n\t\t\tif (j <= n ) then\n\t\t\t\taugmatrix(i,j) = matrix(i,j)\n\t\t\telse if ((i+n) == j) then\n\t\t\t\taugmatrix(i,j) = 1\n\t\t\telse\n\t\t\t\taugmatrix(i,j) = 0\n\t\t\tendif\n\t\tend do\n\tend do\n\t\n\t!reduce augmented matrix to upper traingular form\n\tdo k =1, n-1\n\t\tif (augmatrix(k,k) == 0) then\n\t\t\tflag = .false.\n\t\t\tdo i = k+1, n\n\t\t\t\tif (augmatrix(i,k) /= 0) then\n\t\t\t\t\tdo j = 1,2*n\n\t\t\t\t\t\taugmatrix(k,j) = augmatrix(k,j)+augmatrix(i,j)\n\t\t\t\t\tend do\n\t\t\t\t\tflag = .true.\n\t\t\t\t\texit\n\t\t\t\tendif\n\t\t\t\tif (flag .eqv. .false.) then\n\t\t\t\t\tprint*, \"matrix is non - invertible\"\n\t\t\t\t\tinverse = 0\n\t\t\t\t\terrorflag = -1\n\t\t\t\t\treturn\n\t\t\t\tendif\n\t\t\tend do\n\t\tendif\n\t\tdo j = k+1, n\t\t\t\n\t\t\tm = augmatrix(j,k)/augmatrix(k,k)\n\t\t\tdo i = k, 2*n\n\t\t\t\taugmatrix(j,i) = augmatrix(j,i) - m*augmatrix(k,i)\n\t\t\tend do\n\t\tend do\n\tend do\n\t\n\t!test for invertibility\n\tdo i = 1, n\n\t\tif (augmatrix(i,i) == 0) then\n\t\t\tprint*, \"matrix is non - invertible\"\n\t\t\tinverse = 0\n\t\t\terrorflag = -1\n\t\t\treturn\n\t\tendif\n\tend do\n\t\n\t!make diagonal elements as 1\n\tdo i = 1 , n\n\t\tm = augmatrix(i,i)\n\t\tdo j = i , (2 * n)\t\t\t\t\n\t\t\t   augmatrix(i,j) = (augmatrix(i,j) / m)\n\t\tend do\n\tend do\n\t\n\t!reduced right side half of augmented matrix to identity matrix\n\tdo k = n-1, 1, -1\n\t\tdo i =1, k\n\t\tm = augmatrix(i,k+1)\n\t\t\tdo j = k, (2*n)\n\t\t\t\taugmatrix(i,j) = augmatrix(i,j) -augmatrix(k+1,j) * m\n\t\t\tend do\n\t\tend do\n\tend do\t\t\t\t\n\t\n\t!store answer\n\tdo i =1, n\n\t\tdo j = 1, n\n\t\t\tinverse(i,j) = augmatrix(i,j+n)\n\t\tend do\n\tend do\n\terrorflag = 0\nend subroutine invertmatrix\n"}, {"instruction": "Create a Fortran subroutine named interp_sgl to perform linear interpolation. This subroutine takes 4 input parameters: an integer npts, an array of real(kind=kind) x, an array of real(kind=kind) y, and a single real(kind=kind) x0. It returns 2 output parameters: a real(kind=kind) y0 and an integer error.", "input": "", "output": "subroutine interp_sgl ( x, y, npts, x0, y0, error )\n!\n!  purpose:\n!    to linearly interpolate the value y0 at position x0, given a\n!    set of (x,y) measurements organized in increasing order of x.\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    03/17/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare local parameters\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: npts           ! dimension of arrays x and y\nreal(kind=kind),dimension(npts), intent(in) :: x\n                                      ! independent variable x.\nreal(kind=kind),dimension(npts), intent(in) :: y\n                                      ! dependent variable y.\nreal(kind=kind),intent(in) :: x0      ! point to interpolate.\nreal(kind=kind),intent(out) :: y0     ! interpolated value.\ninteger, intent(out) :: error         ! error flag: 0 -- no error\n                                      !            -1 -- x0 < x(1)\n                                      !             1 -- x0 > x(npts)\n\n! declare local variables:\ninteger :: i                     ! index variable\ninteger :: ibase                 ! index for interpolation.\nreal :: slope                    ! slope for interpolation.\n\n\n! assume that the input data set is in ascending order of x.\n! see if the measurement position x0 is smaller or larger\n! than any value in the data set.\nif ( x0 < x(1) ) then\n   error = -1\nelse if ( x0 > x(npts) ) then\n   error = 1\nelse\n\n   ! point is between x(1) and x(npts).  find the two points\n   ! that it is between.\n    do i = 1, npts-1\n       if ( (x0 >= x(i)) .and. (x0 <= x(i+1)) ) then\n            ibase = i        ! found the point\n            exit\n       end if\n    end do\n\n    ! now linearly interpolate point.\n    slope = ( y(ibase+1)-y(ibase) ) / ( x(ibase+1)-x(ibase) )\n    y0 = slope * ( x0 - x(ibase) ) + y(ibase)\n\n    ! set error flag to 0.\n    error = 0\nend if\n\nend subroutine interp_sgl\n"}, {"instruction": "Create a Fortran subroutine named \"lstmul\" to calculate the next power of 2 greater than or equal to a given value. The subroutine should have 2 input parameters of type integer and 2 output parameters of type integer. The input parameters should be \"value\" and \"base\", while the output parameters should be \"exp\" and \"mul\". Use the subroutine to calculate \"mul\" and the power \"exp\" required to obtain the next power of 2 from \"base\" that exceeds or equals \"value\".", "input": "", "output": "subroutine lstmul ( value, base, exp, mul )\n!\n!  purpose:\n\n!    value => mul ( = base**exp ).  this calculation is useful\n!    for sizing fft's, etc.\n!\nimplicit none\n\n! list of dummy arguments:\ninteger,intent(in) :: value ! value to compare.\ninteger,intent(in) :: base  ! base to which power exp is raised.\ninteger,intent(out) :: exp  ! the exponent.\ninteger,intent(out) :: mul  ! the next power of 2: mul = base**exp.\n\n! calculate \"mul\" and power of \"base\" required.\nexp = 0\nmul = base ** exp\n\n! find the power of base which exceeds or equals value.\ndo\n   exp = exp + 1\n   mul = base ** exp\n   if ( mul >= value ) exit\nend do\n\n! if the pwer exceeds value, back off by one power of base.\nif ( mul > value ) then\n   exp = exp - 1\n   mul = base ** exp\nend if\n\nend subroutine lstmul\n"}, {"instruction": "Create a Fortran subroutine named \"spline_fit_sgl\" to calculate the second derivatives for a set of cubic spline interpolation using the given input parameters. The number and type of input parameters are 5, with test_data type ['integer', 'real(kind=kind),dimension(n)', 'real(kind=kind),dimension(n)', 'real,optional', 'real,optional']. The number and type of output parameters are 2, with test_data type ['real(kind=kind),dimension(n)', 'integer'].", "input": "", "output": "subroutine spline_fit_sgl ( x, y, n, ypp, error, yp1, ypn )\n!\n!  purpose:\n\n!    ypp which define a set of cubic spline interpolation\n\n!    are supplied in monotonically increasing order of x.\n!    optional values yp1 and ypn are the first derivative of\n!    the function at positions 1 and n, respectively.  if a\n!    value is supplied at position 1 or n, then the\n!    second derivatives ypp are computed to satisfy that\n!    boundary.  if no value is supplied, then the \"natural\n!    cubic spline\", which has a value of ypp = 0 at the\n!    corresponding boundary, is computed.  this algorithm\n!    is adapted from the discussion in chapter 3 of\n!    \"numerical recipes in fortran\".\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    06/02/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare parameters:\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: n                        ! number of pts\nreal(kind=kind),dimension(n),intent(in) :: x    ! input x values\nreal(kind=kind),dimension(n),intent(in) :: y    ! input y values\nreal(kind=kind),dimension(n),intent(out) :: ypp ! 2nd derivatives\ninteger,intent(out) :: error                    ! error: 0 = none\n                                                ! 1=insuf. data\nreal,intent(in),optional :: yp1                 ! 1st der @ pt 1\nreal,intent(in),optional :: ypn                 ! 1st der @ pt n\n\n! declare local variables:\nreal(kind=kind) :: delta              !\ninteger :: i, k                       ! index variables\nreal(kind=kind),dimension(n) :: u     ! temp storage\nreal(kind=kind) :: p                  !\nreal(kind=kind) :: qn                 !\nreal(kind=kind) :: un                 ! temp storage\n\n! check for sufficient data\nenough_data: if ( n >= 2 ) then\n\n   ! set initial boundary condition\n   if ( present(yp1) ) then\n      ! set specified first derivative\n      ypp(1) = -0.5\n      u(1) = (3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)\n   else\n      ! set natural lower bound\n      ypp(1) = 0.\n      u(1) = 0.\n   end if\n\n   ! decomposition loop\n   do i = 2, n-1\n      delta = (x(i)-x(i-1)) / (x(i+1)-x(i-1))\n      p = delta * ypp(i-1) + 2.\n      ypp(i) = (delta - 1.) / p\n      u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1)) &\n           /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-delta*u(i-1))/p\n   end do\n\n   ! set final boundary condition\n   if ( present(ypn) ) then\n      ! set specified first derivative\n      qn = 0.5\n      un = (3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))\n   else\n      ! set natural lower bound\n      qn = 0.\n      un = 0.\n   end if\n\n   ! back substitution loop\n   ypp(n) = (un-qn*u(n-1)) / (qn*ypp(n-1)+1.)\n   do k = n-1,1,-1\n      ypp(k) = ypp(k)*ypp(k+1) + u(k)\n   end do\nelse\n   error = 1\nend if enough_data\n\nend subroutine spline_fit_sgl\n"}, {"instruction": "Create a Fortran subroutine named spline_int_sgl to perform cubic spline interpolation. The subroutine takes 5 input parameters: n (integer), x (real(kind=kind) array of dimension n), y (real(kind=kind) array of dimension n), ypp (real(kind=kind) array of dimension n), x0 (optional, real(kind=kind)). It also returns 2 output parameters: y0 (optional, real(kind=kind)) and error (integer). The purpose of this subroutine is to interpolate the value y0 at a given x0 using cubic spline interpolation based on the input knots and spline coefficients.", "input": "", "output": "subroutine spline_int_sgl(x, y, n, ypp, x0, y0, error)\n!\n!  purpose:\n\n!    given the set of knots and spline coefficients x,\n\n!    spline_fit.  this algorithm is adapted from the\n!    discussion in chapter 3 of \"numerical recipes in\n!    fortran\".\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    06/02/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare parameters:\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: n                        ! number of pts\nreal(kind=kind),dimension(n),intent(in) :: x    ! input x values\nreal(kind=kind),dimension(n),intent(in) :: y    ! input y values\nreal(kind=kind),dimension(n),intent(in) :: ypp  ! 2nd derivatives\nreal(kind=kind),intent(in),optional :: x0       ! point to inter.\nreal(kind=kind),intent(out),optional :: y0      ! interpolated value\ninteger,intent(out) :: error                    ! error\n                                                !  0 - no error\n                                                !  1 - dx == 0\n\n! declare local variables:\nreal(kind=kind) :: a, b     ! temp storage\nreal(kind=kind) :: dx       ! delta x between points\ninteger :: k                ! index variables\ninteger :: klo              ! index of x just below x0\ninteger :: khi              ! index of x just above x0\n\n! find the interval containing x0 by bisection.  note that the\n! x values must be monotonically increasing, for this search may\n! fail.\nklo = 1\nkhi = n\ndo\n   if ( (khi-klo) == 1 ) exit     ! x(klo) < x <= x(khi)\n   k = ( khi + klo ) / 2\n   if ( x(k) < x0 ) then\n      klo = k\n   else\n      khi = k\n   end if\nend do\n\n! get dx\ndx = x(khi) - x(klo)\n\n! check for error\nif ( dx == 0. ) then\n   error = 1\nelse\n   ! interpolate cubic equation to get point\n   error = 0\n   a = ( x(khi) - x0 ) / dx\n   b = ( x0 - x(klo) ) / dx\n   y0 = a * y(klo) + b * y(khi) + &\n      ((a**3-a) * ypp(klo) + (b**3-b) * ypp(khi)) * (dx**2) / 6.\nend if\n\nend subroutine spline_int_sgl\n"}, {"instruction": "Create a Fortran subroutine named continuous_integrals_b2equal0 to calculate continuous integrals using the given input parameters. There are 5 input parameters of types integer, real(8) arrays of dimension (npt-1), and 1 output parameter of type real(8) array of dimension (npt-1). The subroutine uses the imperative tone and computes the integrals based on the given formula.", "input": "", "output": "subroutine continuous_integrals_b2equal0(npt, beta0, beta1, xlow, xhigh, integrals)\n    implicit none\n    integer,intent(in)                      :: npt\n    real(8),dimension(npt-1),intent(in)     :: beta0, beta1, xlow, xhigh\n    real(8),dimension(npt-1),intent(out)    :: integrals\n\n    integrals = exp(beta0) * (exp(beta1 * xhigh) - exp(beta1 * xlow) ) / beta1\nend subroutine continuous_integrals_b2equal0\n"}, {"instruction": "Write a Fortran subroutine named \"erfv\" to compute the error function values for a given array of real numbers. The subroutine takes 2 input parameters: an integer \"n\" and an array of real numbers \"x\" with dimension \"n\". It also has 1 output parameter, an array of real numbers \"res\" with dimension \"n\". Use the provided formula to calculate the error function values and assign the results to the \"res\" array.", "input": "", "output": "subroutine erfv(n,x,res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    real(8),dimension(n)                :: t\n\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * abs(x))\n    res = sign(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                        1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-x**2), x)\nend subroutine erfv\n"}, {"instruction": "Create a Fortran subroutine named erfs to compute the error function of a real(8) input. The subroutine takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "subroutine erfs(x,res)\n    implicit none\n    real(8),intent(in)     :: x\n    real(8),intent(out)    :: res\n    real(8)                :: t\n\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * abs(x))\n    res = sign(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                        1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-x**2), x)\nend subroutine erfs\n"}, {"instruction": "Create a Fortran subroutine named \"erfis\" to calculate the error function of a real(8) input parameter. The subroutine should have 1 input parameter of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine erfis(x, res)\n    implicit none\n    real(8),intent(in)     :: x\n    real(8),intent(out)    :: res\n    complex(8)             :: t, u\n\n    u   = cmplx(0.0d0,abs(x),kind=8)\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * u )\n    res = sign(aimag(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                   1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-u**2) ), x)\nend subroutine erfis\n"}, {"instruction": "Create a Fortran subroutine named inv_erfv to calculate the inverse error function values. The subroutine takes 2 input parameters: an integer n and an array of real(8) numbers of size n. The output is a real(8) array of size n.", "input": "", "output": "subroutine inv_erfv(n, x, res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    real(8),dimension(n)                :: t, q\n    real(8),parameter                   :: a = 0.145d0\n    real(8),parameter                   :: twopia = 2.0d0/(3.141592653589793d0*0.145d0)\n\n    t   = log(1.0d0 - x**2)\n    q   = twopia + 0.5d0 * t\n    res = sign( sqrt( sqrt(q**2 - t / a) - q ), x)\nend subroutine inv_erfv\n"}, {"instruction": "Create a Fortran subroutine named inv_erfiv to calculate the inverse error function value for each element of an input real array. The number of input arguments is 2 and the test_data type is ['integer', 'real(8),dimension(n)']. The number of output arguments is 1 and the test_data type is ['real(8),dimension(n)'].", "input": "", "output": "subroutine inv_erfiv(n, x, res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    complex(8),dimension(n)             :: t, q, u\n    real(8), parameter                  :: a = 0.1382d0\n    real(8),parameter                   :: itwopia = 2.0d0/(3.141592653589793d0 * a)\n\n    u   = cmplx(0.0d0, abs(x),kind=8)\n    t   = log(1.0d0 - u**2)\n    q   = itwopia + 0.5d0 * t\n    res = sign(aimag(sqrt( sqrt(q**2 - t / a) - q )), x)\nend subroutine inv_erfiv\n"}, {"instruction": "Create a Fortran subroutine named histogram to generate a histogram of values, counting the occurrences within each specified bin range. The subroutine takes 4 input parameters of types ['integer', 'integer', 'real(dp)', 'real(dp)'] and 1 output parameter of type ['real(dp)']. The subroutine utilizes the imperative tone to declare the intent of the input and output parameters, and it updates the histogram counts based on the input data and bin edges.", "input": "", "output": "subroutine histogram(x, range, c, m, n)\n    ! generates a histogram of values, counting the number within each of a given set of bin ranges.\n    integer, parameter :: dp = kind(0.0d0)  ! double precision\n    ! sizes of the data to be binned, and the number of bins, respectively.\n    integer, intent(in) :: n, m\n    ! the input data to be binned, and values of bin edges, respectively.\n    real(dp), intent(in) :: x(n), range(m)\n    ! the histogram counts. note that range is left hand bins plus one right hand bin, and hence\n    ! c has length m-1.\n    real(dp), intent(out) :: c(m-1)\n    integer :: i, j  \n\n    c(:) = 0\n\n    do i = 1, n                       ! for each input score\n        do j = 1, m-1                    ! determine the bucket\n            if (x(i) < range(1) .or. x(i) > range(m)) then\n                exit\n            end if\n            if (x(i) < range(j+1) .and. x(i) >= range(j)) then\n                c(j) = c(j) + 1\n                exit\n            end if               \n        end do    \n        if (x(i) >= range(m)) then\n            c(m-1) = c(m-1) + 1\n        end if                    \n    end do\n\nend subroutine histogram\n"}, {"instruction": "Create a Fortran subroutine named plik_dust_template to generate a dust template array based on the specified range of wavelengths. It takes 2 input parameters of type integer, lmin and lmax, and has 1 output parameter of type real(8) array with dimensions ranging from lmin to an unspecified upper bound. Use an imperative tone in the instructions.", "input": "", "output": "   subroutine plik_dust_template(dust_template__l, lmin, lmax)\n\n    integer,                                intent(in)    :: lmin\n    integer,                                intent(in)    :: lmax\n    real(8),      dimension(lmin:),         intent(out)   :: dust_template__l\n\n    integer                                               :: i\n    real(8)                                               :: l_pivot\n    real(8)                                               :: gal_index\n    real(8),                                parameter     :: twopi = 6.283185307179586476925286766559005768394\n\n    l_pivot   = 500.0\n    gal_index = -2.6\n\n    do i = lmin,lmax\n       dust_template__l(i) = (dble(i)/l_pivot)**gal_index / twopi\n    enddo\n\n\n  end subroutine plik_dust_template\n"}, {"instruction": "Write a Fortran subroutine named sub2 that takes an integer as input and returns a character array of length specified by the input integer.", "input": "", "output": "  subroutine sub2(string,str_size)\n    integer,intent(in)    :: str_size\n    character,intent(out) :: string(str_size)\n    string(:) = 'a'\n  end subroutine sub2\n"}, {"instruction": "Create a Fortran subroutine named sfntri to calculate the shape functions, their derivatives, and Jacobian for a triangle element at specified global positions. The subroutine takes 4 input parameters of type real,dimension(3,2), real, real, and real, and returns 3 output parameters of type real, real,dimension(3), and real,dimension(2,3) respectively.", "input": "", "output": "subroutine sfntri(det,sf,gdsf,l1,l2,l3,elxy)\n  implicit none\n\n! and their derivatives at specified global positions\n  integer,parameter :: npe=3\n  integer :: i,j,k\n  real,dimension(3,2),intent(in) :: elxy\n  real,intent(in) :: l1,l2,l3\n  real,intent(out) :: det\n  real,dimension(3),intent(out) :: sf\n  real,dimension(2,3),intent(out) :: gdsf\n  real,dimension(3,3) :: dsf\n  real,dimension(2,2) :: gj,gjinv\n  real :: sum\n\n! initialize arrays\n  do i=1,npe  \n     dsf(1,i) = 0.0\n     dsf(2,i) = 0.0\n     dsf(3,i) = 0.0\n     sf(i)    = 0.0\n  end do\n  \n! set the shape functions for a triangle\n  sf(1) = l1\n  sf(2) = l2\n  sf(3) = l3\n  dsf(1,1) = 1.0\n  dsf(2,2) = 1.0\n  dsf(3,3) = 1.0\n\n! find the jacobian\n  do i=1,2\n     do j=1,2\n        sum = 0.0\n        do k=1,npe\n           sum = sum + (dsf(i,k) - dsf(3,k))*elxy(k,j)\n        end do\n        gj(i,j) = sum\n     end do\n  end do\n\n! find gj's inverse\n  det        =  gj(1,1)*gj(2,2) - gj(1,2)*gj(2,1)\n  gjinv(1,1) =  gj(2,2)/det\n  gjinv(2,2) =  gj(1,1)/det\n  gjinv(1,2) = -1.0*gj(1,2)/det\n  gjinv(2,1) = -1.0*gj(2,1)/det\n\n! obtain the derivative of the shape function with proper\n! transformation\n  do i=1,2\n     do j=1,npe\n        sum = 0.0\n        do k=1,2\n           sum = sum + gjinv(i,k)*(dsf(k,j) - dsf(3,j))\n        end do\n        gdsf(i,j) = sum\n     end do\n  end do\n\nend subroutine sfntri\n"}, {"instruction": "Create a Fortran subroutine named getthetasize to determine the size of the quadpoint array and check for custom points. The subroutine takes 1 input parameter of type real(kind=8) and returns 2 output parameters: one of type integer and one of type logical.", "input": "", "output": "subroutine getthetasize(quadpoint,irfcount,custompoints)\r\nimplicit none\r\ninteger,intent(out)::irfcount\r\nlogical,intent(out)::custompoints\r\nreal(kind=8),intent(in)::quadpoint(:,:)\r\n!\terror flag for input.\r\ninteger::io\r\n\r\nnamelist/irfspecs/irfcount,custompoints\r\nirfcount=size(quadpoint,2)\r\ncustompoints=.false.\r\nread(*,nml=irfspecs,iostat=io)\r\nif(io/=0) stop 'failure to read specifications for points for item response functions.'\r\nif(irfcount/=size(quadpoint,2)) custompoints=.true.\r\nend subroutine getthetasize\n"}, {"instruction": "Create a Fortran subroutine named smallest_prime to find the smallest prime factor of a given positive integer. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter represents the integer for which the smallest prime factor needs to be determined, and the output parameter stores the value of the smallest prime factor. If the input number is less than or equal to 2, the output will be the input number itself. If the input number is greater than 2, the subroutine will iterate to find the smallest prime factor and store it in the output parameter. If the input number is negative, the subroutine will stop and display a message indicating that it is only designed for positive integers.", "input": "", "output": "  subroutine smallest_prime(a,sp)\n    integer, intent(in) :: a\n    integer, intent(out) :: sp\n\n    integer ::i\n\n    if (a<0) stop \"smallest_prime is only designed for positive integers.\"\n    if (a <= 2) then\n       sp = a\n    else\n       do i = 2, a\n          if (mod(a,i)==0) then\n             sp = i\n             exit\n          end if\n       end do\n    end if\n\n  end subroutine smallest_prime\n"}, {"instruction": "Create a Fortran subroutine named \"glob_to_axial\" that calculates the axial force for rod elements in 2D or 3D. The subroutine should have 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp).", "input": "", "output": "subroutine glob_to_axial(axial,global,coord)\r\n!\r\n\n! into an axial force for rod elements (2- or 3-d).\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::global(:),coord(:,:)\r\n real(iwp),intent(out)::axial\r\n real(iwp)::add,ell,zero=0.0_iwp\r\n integer::ndim,i\r\n ndim=ubound(coord,2)\r\n add=zero\r\n do i=1,ndim\r\n   add=add+(coord(2,i)-coord(1,i))**2\r\n end do\r\n ell=sqrt(add)\r\n axial=zero\r\n do i=1,ndim\r\n   axial=axial+(coord(2,i)-coord(1,i))/ell*global(ndim+i)\r\n end do\r\nreturn\r\nend subroutine glob_to_axial                       \r\n"}, {"instruction": "Create a Fortran subroutine named ppnd that implements an algorithm to produce a normal deviate corresponding to the lower tail area of a given probability, p. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type integer and real.", "input": "", "output": "subroutine ppnd(p, ifault, fn_val)\r\n\r\n!  algorithm as 111  appl. statist. (1977), vol.26, no.1\r\n\r\n!  produces normal deviate corresponding to lower tail area of p\r\n!  real version for eps = 2 **(-31)\r\n!  the hash sums are the sums of the moduli of the coefficients\r\n!  they have no inherent meanings but are included for use in\r\n!  checking transcriptions\r\n!  standard functions abs, alog and sqrt are used\r\n\r\nimplicit none\r\nreal, intent(in)      :: p\r\ninteger, intent(out)  :: ifault\r\nreal, intent(out)     :: fn_val\r\n\r\nreal :: q, r\r\n\r\nreal, parameter  :: zero = 0.0e0, half = 0.5e0, one = 1.0e0\r\nreal, parameter  :: split = 0.42e0\r\nreal, parameter  :: a0 = 2.50662823884e0\r\nreal, parameter  :: a1 = -18.61500062529e0\r\nreal, parameter  :: a2 = 41.39119773534e0\r\nreal, parameter  :: a3 = -25.44106049637e0\r\nreal, parameter  :: b1 = -8.47351093090e0\r\nreal, parameter  :: b2 = 23.08336743743e0\r\nreal, parameter  :: b3 = -21.06224101826e0\r\nreal, parameter  :: b4 = 3.13082909833e0\r\nreal, parameter  :: c0 = -2.78718931138e0\r\nreal, parameter  :: c1 = -2.29796479134e0\r\nreal, parameter  :: c2 = 4.85014127135e0\r\nreal, parameter  :: c3 = 2.32121276858e0\r\nreal, parameter  :: d1 = 3.54388924762e0\r\nreal, parameter  :: d2 = 1.63706781897e0\r\n\r\nifault = 0\r\nq = p - half\r\nif (abs(q) > split) go to 1\r\nr = q*q\r\nfn_val = q * (((a3*r + a2)*r + a1) * r + a0) /  &\r\n    ((((b4*r + b3)*r + b2) * r + b1) * r + one)\r\nreturn\r\n\r\n1 r = p\r\nif (q > zero)r = one - p\r\nif (r <= zero) go to 2\r\nr = sqrt(-log(r))\r\nfn_val = (((c3 * r + c2) * r + c1) * r + c0)/ ((d2*r + d1) * r + one)\r\nif (q < zero) fn_val = -fn_val\r\nreturn\r\n\r\n2 ifault = 1\r\nfn_val = zero\r\nreturn\r\nend subroutine ppnd\r\n"}, {"instruction": "Write a Fortran subroutine named swa to calculate specific values and assign them to a 2x2 array based on input parameters. The subroutine takes 2 input arguments of type double precision and outputs a 2x2 array of type double precision. The input parameters are q1 and q2, both of type double precision. The output is a 2x2 array named 'a' of type double precision. The subroutine uses the values of q1 and q2 to perform calculations and assign specific values to the elements of the 2x2 array 'a'. The subroutine should be named swa.", "input": "", "output": "\tsubroutine swa(a,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: a\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c\n\t\n\tc = sqrt(g*q1)\n\t\n\ta(1,1) = q2/q1-c\n\ta(1,2) = 0d0\n\ta(2,1) = 0d0\n\ta(2,2) = q2/q1+c\n\t\n\t\n\tend subroutine swa\n"}, {"instruction": "Create a Fortran subroutine named swr to calculate the values of a 2x2 matrix based on the input parameters q1 and q2, both of type double precision. The output parameter r is also of type double precision and has a dimension of 2x2. Ensure that the subroutine includes the calculation of c as the square root of the product of g and q1.", "input": "", "output": "\tsubroutine swr(r,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: r\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c\n\t\n\tc = sqrt(g*q1)\n\t\n\tr(1,1) = 1d0\n\tr(1,2) = 1d0\n\tr(2,1) = q2/q1-c\n\tr(2,2) = q2/q1+c\n\t\n\tend subroutine swr\n"}, {"instruction": "Create a Fortran subroutine named \"swri\" to calculate the values of a 2x2 matrix based on given input parameters. The subroutine takes 2 input parameters of type 'double precision' and returns a 2x2 matrix of type 'double precision'. The input parameters are q1 and q2, while the output parameter is ri. The subroutine uses the given input parameters and a predefined constant 'g' to compute values for the 2x2 matrix 'ri'.", "input": "", "output": "\tsubroutine swri(ri,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: ri\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c, twoc\n\t\n\tc = sqrt(g*q1)\n\ttwoc = 2d0*c\n\t\n\tri(1,1) = (q2/q1+c)/twoc\n\tri(1,2) = -1d0/twoc\n\tri(2,1) = (c-q2/q1)/twoc\n\tri(2,2) = 1d0/twoc\n\t\n\tend subroutine swri\n"}, {"instruction": "Create a Fortran subroutine named betalimits to calculate the minimum and maximum values based on the composition and k factors of a chemical system. The subroutine should have 3 input parameters of type integer, real*8 array of size n, and real*8 array of size n. It should also have 2 output parameters of type real*8.", "input": "", "output": "\tsubroutine betalimits (n,z,kfact,bmin,bmax)\r\n\r\n      implicit none\r\n\r\n        integer, intent(in) :: n  ! number of compounds in the system\r\n        real*8, dimension(n), intent(in) :: z, kfact  ! composition of the system and k factors\r\n        real*8, intent(out) :: bmin, bmax\r\n        real*8, dimension(n) :: vmin, vmax\r\n        integer :: i, in=0, ix=0\r\n\r\n        vmin=0.d0\r\n        vmax=1.d0\r\n        do i=1,n\r\n            if (kfact(i)*z(i)>1)then\r\n                in = in+1\r\n                vmin(in) = (kfact(i)*z(i)-1.d0)/(kfact(i)-1.d0)\r\n            else if (kfact(i)<z(i))then\r\n                ix = ix+1\r\n                vmax(ix) = (1.d0-z(i))/(1.d0-kfact(i))\r\n            end if\r\n        end do\r\n        bmin = maxval(vmin)\r\n        bmax = minval(vmax)\r\n\r\n    end subroutine betalimits\r\n"}, {"instruction": "Create a Fortran subroutine named sb_resample to resample an input array to a specified length. The subroutine takes 3 input parameters: two integers (in_n and out_n) passed by value, and an array of real numbers (in) with a dimension of in_n. It also has 1 output parameter, an array of real numbers (out) with a dimension of out_n. The subroutine resamples the input array to the specified length using linear interpolation and stores the result in the output array.", "input": "", "output": "subroutine sb_resample(in, in_n, out, out_n)\n  integer, intent(in), value :: in_n, out_n\n  real, dimension(in_n), intent(in) :: in\n  real, dimension(out_n), intent(out) :: out\n  out = (/ (in(1 + (i - 1) * in_n / out_n), i = 1, out_n) /)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named s_count_pdb_atoms to read a pdb_file and determine the number of atom or hetatm records declared in the file. The number of input parameters is 1 with the test_data type of ['character(len=*)'], and the number of output parameters is 1 with the test_data type of ['integer(c_int)'].", "input": "", "output": "subroutine s_count_pdb_atoms(pdb_file,num_atoms)\n!\n! reads the number of atom or hetatm records declared in pdb file.\n! single model hosted inside the pdb file is assumed.\n!\n! author : veselin kolev <vesso.kolev@gmail.com>\n! version: 2018121000\n! license: gplv2\n!\nuse iso_c_binding,only:c_int\n!\nimplicit none\n!\n! interface variables:\n!\ncharacter(len=*),intent(in) :: pdb_file\ninteger(c_int),intent(out)  :: num_atoms\n!\n! local variables:\n!\ninteger(c_int)              :: stat\ninteger(c_int),parameter    :: str_len=54\ncharacter(len=str_len)      :: buffer\n\nopen(666,file=pdb_file,iostat=stat)\n!\nnum_atoms=0\n!\ndo while(stat.eq.0)\n   !\n   read(666,'(a54)',iostat=stat) buffer\n   !\n   if (stat==0) then\n      !\n      if (buffer(1:6).eq.'atom  ') then\n         !\n         num_atoms=num_atoms+1\n         !\n      end if\n      !\n   end if\n   !\nend do\n!\nclose(666)\n\nend subroutine s_count_pdb_atoms\n"}, {"instruction": "Create a Fortran subroutine named get_opacities to calculate the opacities kp and kr based on the given input parameters. The subroutine takes 6 input parameters of types ['logical', 'logical', 'double precision', 'double precision', 'double precision', 'double precision'] and returns 2 output parameters of type ['double precision', 'double precision']. The subroutine uses the \"implicit none\" statement to enforce explicit declaration of all variables.", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    kp = 0.d0\n    kr = 0.d0\n\n  end subroutine get_opacities\n"}, {"instruction": "Write a Fortran subroutine named radiat to calculate the isothermal net radiation based on the van Ulden and Holtslag (1985) radiation scheme. The number of input arguments is 6, and the test_data type is [real, real, real, real, real, real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "      subroutine radiat(sigma,sinphi,tm,rnn,rkin,ralb,qsti)  \n! ---------------------------------------------------------------------\n!         radiation scheme according to van ulden and holtslag \n!         (1985,jcam, 24, 1196-1207).\n!         \n!\n!         input:\n!             sigma  : stefan boltzmanns constant\n!             sinphi : sine of the solar elevation\n!             rnn    : cloud cover fraction (0-1)   \n!             rkin   : incoming short wave radiation (w/m2)\n!                      (missing : -9900. or 0.0)\n!             ralb   : surface albedo [0.0 - 1.0(total reflection)]   \n!\n!                      surface      albedo(%)   ralb\n!               1  :   dark soil       10       0.10\n!               2  :   forest          15       0.15\n!               3  :   grass,lush      20       0.20\n!               4  :   sand            25       0.25\n!               5  :   ice,old         30       0.30\n!               6  :   ice,new         35       0.35\n!               7  :   snow,old        40       0.40\n!               8  :   snow,normal     60       0.60\n!               9  :   snow,fresh      80       0.80\n!        \n!         output:\n!             qsti   : isothermal net radiation, q*_i. (w/m2)\n\n!    ------------------------------------------------------------------\n! ----------------------------------------------------------------------------------\n! based on:\n! version episode 5.5 (may29, 2012) prepared for bb-stand-alone\n! original source code of episode by sam-erik walker (nilu)\n!\n! sam-erik walker\n! norwegian institute for air research (nilu)\n! instituttveien 18 p.o. box 100\n! n-2027 kjeller, norway\n! tel: +47 63898000 fax: +47 63898050\n! e-mail: sam-erik.walker@nilu.no\n!\n! ----------------------------------------------------------------------------------\n! ----------------------------------------------------------------------------------\n! revision history\n!\n!    xx dat 201x  name: line  description of change\n!\n! ----------------------------------------------------------------------------------\n\n        implicit none\n\n! *** input variables:\n      real,intent(in)  :: sigma,sinphi,tm,rnn,rkin,ralb\n\n! *** output variables\n      real,intent(out) :: qsti\n\n! *** local variables:\n      real :: rkst,rlsti\n\t\n! *** the values of the constants below are identical with the ones\n! *** given in vu&h, 1985. \n      real,parameter :: a1    = 990.0 \n      real,parameter :: a2    = -30.0\n      real,parameter :: b1    =   0.75\n      real,parameter :: b2    =   3.4\n      real,parameter :: c1    =   9.35e-6\n      real,parameter :: c2    =  60.0\n      real,parameter :: sphi0 =   0.03\n\n!     selection of albedo (input parameter)\n\n      if(rkin >= 0.0) then\n! ***   if measured values of the incoming short wave rad. exists:\n          rkst = rkin*(1.0 - ralb)\n      else\n!       for phi < 1.7 degrees : no short wave radiation (vu&h, 1985). \n        if (sinphi .lt. sphi0) then\n           rkst = 0.0\n        else                                      \n! ***     the net shortwave radiation, see eq. (17) in vu&h, 1985:\n           rkst = (a1*sinphi + a2)*(1.0 - b1*rnn**b2)*(1.0 - ralb)    \n        endif\n      endif\n\n! *** isothermal longwave radiation, l*_i, see eq.(21) in vu&h,1985:\n      rlsti = -sigma*tm**4*(1.0 - c1*tm**2) + c2*rnn\n\n! *** isothermal net radiation, q*_i, see eq.(28) in vu&h,1985:\n      qsti = rkst + rlsti\n\n      return\n\n      end subroutine radiat\n"}, {"instruction": "Create a Fortran subroutine named get_index_of_csr_data to find the index of a specific element in a Compressed Sparse Row (CSR) matrix based on its row and column indices. The subroutine takes 6 input parameters of type integer: i, j, indptr, indices, n, and m. It also has 1 output parameter of type integer: k. The subroutine identifies the position (k) of the element in the data array of the CSR matrix based on the provided row and column indices and the CSR matrix arrays. Ensure that the subroutine considers the 0-based indexing used in numpy arrays.", "input": "", "output": "subroutine get_index_of_csr_data(i, j, indptr, indices, k, n, m)\n    ! i, j are the indices of the global array\n    ! indptr and indices are the arrays from the csr matrix\n    ! k is the python-index of the data array in the csr matrix\n    ! n is the dimension of the indptr-array\n    ! m is the dimension of the indices array\n\n    ! be careful, but the indexing is given in numpy arrays.\n    ! so the entries containing indices start at zero!\n\n    implicit none\n\n    integer, intent(in) :: n, m\n    integer, intent(in) :: i, j, indptr(n), indices(m)\n    integer, intent(out) :: k\n\n    k = indptr(i+1)\n    do while( j /= indices(k+1) )\n        k = k + 1\n\n        if (k > indptr(i+2)) then\n            k = 0\n            exit\n        end if\n\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named project_pt to perform a coordinate transformation. The subroutine takes 6 input parameters of types character(len=3), real(8), and real(8), and provides 3 output parameters of type real(8). The function converts coordinates between global and local frames based on the direction specified by the 'dir' parameter. Use the 'intent' attribute to specify the input and output parameters. Use the 'stop' statement to handle unknown direction flags. Use the 'implicit' statement to define the data types implicitly.", "input": "", "output": "      subroutine project_pt(dir,xi,yi,zi,origin0,frame0,xo,yo,zo)\n      implicit real*8(a-h,o-z)\n\n      character(len=3), intent(in) :: dir\n      real(8), intent(in) :: xi,yi,zi,origin0(3),frame0(3,3)\n      real(8), intent(out) :: xo,yo,zo\n\n      !local\n      real(8) :: wild(3)\n\n      if(dir.eq.'g2l') then\n        wild(1:3)=(xi-origin0(1))*frame0(1,1:3)+(yi-origin0(2))*frame0(2,1:3)+ &\n                 &(zi-origin0(3))*frame0(3,1:3)\n      else if(dir.eq.'l2g') then\n        wild(1:3)=origin0(1:3)+xi*frame0(1:3,1)+yi*frame0(1:3,2)+ &\n     &zi*frame0(1:3,3)\n      else\n        stop 'project_pt: unknown flag'\n      endif\n      xo=wild(1)\n      yo=wild(2)\n      zo=wild(3)\n\n      end subroutine project_pt\n"}, {"instruction": "Write a Fortran subroutine named loadc1nz_ that returns the non-zero values of 1e coupling constants. The subroutine takes 3 input parameters of types integer, integer, and real(8), and 5 output parameters of types integer, integer, integer, integer, and real(8).", "input": "", "output": "        subroutine loadc1nz_(inz,lnz,vnz,ic,jc,im,jm,a1)\n          ! return non-zero values of 1e coupling const.\n          implicit none\n          integer,intent(in)::inz,lnz(:,:)\n          real(8),intent(in)::vnz(:)\n          integer,intent(out)::ic,jc,im,jm\n          real(8),intent(out)::a1\n          ic=lnz(1,inz)\n          jc=lnz(2,inz)\n          im=lnz(3,inz)\n          jm=lnz(4,inz)\n          a1=vnz(inz)\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named loadc2nz_ to load the non-zero values of 2e coupling constants. The subroutine has 3 input parameters of type integer, integer, and real(8), and 7 output parameters of type integer, integer, integer, integer, integer, integer, and real(8).", "input": "", "output": "        subroutine loadc2nz_(inz,lc2,vc2,icr,jcr,im,jm,km,lm,val)\n          ! load the non-zero value of 2e coupling const.\n          implicit none\n          integer,intent(in)::inz,lc2(:,:)\n          real(8),intent(in)::vc2(:)\n          integer,intent(out)::icr,jcr,im,jm,km,lm\n          real(8),intent(out)::val\n          icr=lc2(1,inz)\n          jcr=lc2(2,inz)\n          im=lc2(3,inz)\n          jm=lc2(4,inz)\n          km=lc2(5,inz)\n          lm=lc2(6,inz)\n          val=vc2(inz)\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"getpasttimes\" to retrieve the indices of the previous time steps. It takes 2 input parameters of type integer and returns 3 output parameters of type integer.", "input": "", "output": "  subroutine getpasttimes (ntpc,n , n_1,n_2,n_3)\n    ! description :\n    ! recupere les indices des pas de temps precedents.\n    implicit none\n    ! inputs :\n    ! nombre de pas de temps par periode\n    integer, intent(in)                                     :: ntpc\n    ! indice du pas de temps courant\n    integer, intent(in)                                     :: n\n    ! outputs :\n    ! indices des pas de temps precedents\n    integer, intent(out)                                    :: n_1, n_2, n_3\n    \n    ! modulo ntpc\n    if ( n == 1 ) then\n      n_1 = ntpc\n      n_2 = ntpc-1\n      n_3 = ntpc-2\n      \n    else if ( n == 2 ) then\n      n_1 = 1\n      n_2 = ntpc\n      n_3 = ntpc-1\n      \n    else if ( n == 3 ) then\n      n_1 = 2\n      n_2 = 1\n      n_3 = ntpc\n      \n    else\n      n_1 = n-1\n      n_2 = n-2\n      n_3 = n-3\n      \n    end if\n    \n    return\n  end subroutine getpasttimes\n"}, {"instruction": "Create a Fortran subroutine named predictinitialsolution that implements second-order extrapolation to initialize a solution. This subroutine takes 4 input parameters of types integer, double precision arrays of size ndof, and one output parameter of type double precision array of size ndof.", "input": "", "output": "  subroutine predictinitialsolution (ndof,h_1,h_2,h_3 , h_n)\n    ! description :\n    ! extrapolation d'ordre 2 pour initialiser la solution.\n    implicit none\n    ! inputs :\n    ! discretisation\n    integer, intent(in)                                     :: ndof\n    ! champ aux pas precedents                              \n    double precision, dimension(ndof), intent(in)           :: h_1, h_2, h_3\n    ! outputs :                                           \n    ! prediction                                            \n    double precision, dimension(ndof), intent(out)          :: h_n\n    \n    ! prediction de la solution au pas n\n    h_n = 0.5d0*( 5.0d0*h_1 - 4.0d0*h_2 + h_3 )\n    \n    return\n  end subroutine predictinitialsolution\n"}, {"instruction": "Create a Fortran subroutine named calcullosses to calculate losses in a system. The subroutine takes 8 input parameters: ndof and ntpc of type integer, dx and dt of type double precision, rho of type double precision, and h_x_t, b_x_t, j_x_t of type double precision arrays of dimension (ndof+1,ntpc). It also has 2 output parameters: pj_x_t and ph_x_t, both of type double precision arrays of dimension (ndof+1,ntpc).", "input": "", "output": "  subroutine calcullosses (ndof,ntpc,dx,dt,rho,h_x_t,b_x_t,j_x_t , pj_x_t,ph_x_t)\n    implicit none\n    ! inputs :\n    ! discretisation\n    integer, intent(in)                                     :: ndof, ntpc\n    double precision, intent(in)                            :: dx, dt\n    ! resistivite\n    double precision, intent(in)                            :: rho\n    ! solution\n    double precision, dimension(ndof+1,ntpc), intent(in)    :: h_x_t, b_x_t, j_x_t\n    ! outputs :\n    ! pertes\n    double precision, dimension(ndof+1,ntpc), intent(out)   :: pj_x_t, ph_x_t\n    \n    ! variables :\n    integer                                                 :: n, nm1, np1\n    \n    ! initialisation\n    pj_x_t = 0.0d0\n    ph_x_t = 0.0d0\n    \n    ! calcul des pertes\n    do n = 1, ntpc\n      \n      ! index pas avant et apres\n      if ( n == 1 ) then\n        nm1 = ntpc\n        np1 = 2\n      else if ( n == ntpc ) then\n        nm1 = ntpc - 1\n        np1 = 1\n      else\n        nm1 = n - 1\n        np1 = n + 1\n      end if\n      \n      ! calcul des pertes joules en fonction du temps\n      pj_x_t(1:ndof+1,n) = rho*j_x_t(1:ndof+1,n)*j_x_t(1:ndof+1,n)\n      \n      ! calcul des pertes par hysteresis en fonction du temps\n      ph_x_t(1:ndof+1,n) = h_x_t(1:ndof+1,n)*0.5d0/dt*(b_x_t(1:ndof+1,np1)-b_x_t(1:ndof+1,nm1))\n      \n    end do\n    \n    return\n  end subroutine calcullosses\n"}, {"instruction": "Create a Fortran subroutine named apply_ptilde to calculate the weighted sum of pixel values and gains based on the given parameters. The subroutine takes 4 input parameters of type real(kind=8), dimension(:), real(kind=8), dimension(:), integer(kind=8), dimension(size(gains)), and integer(kind=8), dimension(:). It has 1 output parameter of type real(kind=8), dimension(size(pix_idx)).", "input": "", "output": "subroutine apply_ptilde(map_pixels, gains, samples_per_gainp, pix_idx, output)\n  real(kind=8), dimension(:), intent(in) :: map_pixels\n  real(kind=8), dimension(:), intent(in) :: gains\n  integer(kind=8), dimension(size(gains)), intent(in) :: samples_per_gainp\n  integer(kind=8), dimension(:), intent(in) :: pix_idx\n  real(kind=8), dimension(size(pix_idx)), intent(out) :: output\n\n  integer(kind=8) :: cur_gainp_idx, samples_in_gainp\n  integer(kind=8) :: i\n\n  output = 0\n  cur_gainp_idx = 1\n  samples_in_gainp = 0\n\n  do i = 1, size(pix_idx)\n     output(i) = output(i) + map_pixels(pix_idx(i) + 1) * gains(cur_gainp_idx)\n     samples_in_gainp = samples_in_gainp + 1\n\n     if (samples_in_gainp .ge. samples_per_gainp(cur_gainp_idx)) then\n        cur_gainp_idx = cur_gainp_idx + 1\n        samples_in_gainp = 0\n     endif\n  enddo\n\nend subroutine apply_ptilde\n"}, {"instruction": "Create a Fortran subroutine named padecof to calculate the Pad\u00e9 approximant coefficients. The subroutine takes 3 input parameters of type complex*16, complex*16, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine padecof(pt,gn,zn,nn)\n!****************************\n  implicit none\n  complex*16, intent(out) :: pt(nn)\n  complex*16, intent(in)  :: gn(nn),zn(nn)\n  integer, intent(in)     :: nn\n  ! local\n  complex*16  :: p(nn,nn)\n  integer :: i, j\n  p=0.0\n  do j=1,nn\n     p(1,j) = gn(j)\n  enddo\n  do j=2,nn\n     do i=2,j\n        p(i,j)=(p(i-1,i-1)-p(i-1,j))/(zn(j)-zn(i-1))/p(i-1,j)\n     enddo\n  enddo\n  do j=1,nn\n     pt(j)=p(j,j)\n  enddo\n  return\nend subroutine padecof\n"}, {"instruction": "Create a Fortran subroutine named setup_num_levels to calculate the number of levels based on the given fine cell dimensions. The subroutine takes 2 input parameters of type integer (icv_fine, jcv_fine) and returns 1 output parameter of type integer (num_level).", "input": "", "output": "subroutine setup_num_levels(icv_fine, jcv_fine, num_level)\n\n! argument variables\ninteger, intent(in):: icv_fine, jcv_fine\ninteger, intent(out):: num_level\n\n! local variables\n\ninteger:: i, ncv\n\nncv = jcv_fine\ni = 1\n\ndo\n\n    if( mod(ncv,2) /= 0) exit\n    if( ncv/2 < 16 ) exit\n\n    ncv = ncv/2\n    i = i+1\n\nend do\n\nnum_level = i\n\nend subroutine setup_num_levels\n"}, {"instruction": "Create a Fortran subroutine named basis_orthg to calculate high-order orthogonal coefficients. The subroutine must take 5 input parameters: ndegr (integer), npoly (integer), nbsis (integer), b_taylor (real*8, array with dimension ndegr), cfbs (real*8, array with dimension 14). It should have 1 output parameter: b_out (real*8, array with dimension ndegr).", "input": "", "output": "subroutine basis_orthg(npoly,ndegr, nbsis, b_taylor, cfbs, b_out)\nimplicit none\ninteger, intent(in):: ndegr, npoly, nbsis\nreal*8, dimension(ndegr), intent(in)::b_taylor\nreal*8, dimension(14), intent(in)::cfbs\nreal*8, dimension(ndegr),intent(out)::b_out\n\n!...local\nreal*8::cfthg(6,6)\nreal*8, dimension(ndegr)::bph\n\n!...high-order orthogonal coefficients\nif(nbsis.eq.1)then\n!\nbph(1:3) = b_taylor(1:3)\n\nb_out(1:3) = bph(1:3)\n\nif(npoly.eq.2)then\nb_out(4) = 0.5d0*bph(2)*bph(2) - cfbs(1)\nb_out(5) = 0.5d0*bph(3)*bph(3) - cfbs(2)\nb_out(6) =       bph(2)*bph(3) - cfbs(3)\nendif\n\nelseif(nbsis.eq.2)then\ncfthg(3,1) = cfbs(1)\ncfthg(3,2) = cfbs(2)\n\nbph(1:3) = b_taylor(1:3)\n\nb_out(1) = 1.d0\nb_out(2) = bph(2)\nb_out(3) = cfthg(3, 1)*bph(2) + bph(3) + cfthg(3, 2)\n\nif(npoly.eq.2)then\ncfthg(4,1) = cfbs(3)\ncfthg(4,2) = cfbs(4)\ncfthg(4,3) = cfbs(5)\n\ncfthg(5,1) = cfbs(6)\ncfthg(5,2) = cfbs(7)\ncfthg(5,3) = cfbs(8)\ncfthg(5,4) = cfbs(9)\n\ncfthg(6,1) = cfbs(10)\ncfthg(6,2) = cfbs(11)\ncfthg(6,3) = cfbs(12)\ncfthg(6,4) = cfbs(13)\ncfthg(6,5) = cfbs(14)\n!\nbph(4) = bph(2)*bph(2)\nbph(5) = bph(3)*bph(3)\nbph(6) = bph(2)*bph(3)\n!\nb_out(4) =             bph(4) + cfthg(4, 1)*bph(2) + cfthg(4, 2)*bph(3) + cfthg(4, 3)\nb_out(5) = cfthg(5, 1)*bph(4) +             bph(6) + cfthg(5, 2)*bph(2) +&\ncfthg(5, 3)*bph(3) + cfthg(5, 4)\nb_out(6) = cfthg(6, 1)*bph(4) + cfthg(6, 2)*bph(6) +             bph(5) +&\ncfthg(6, 3)*bph(2) + cfthg(6, 4)*bph(3) + cfthg(6, 5)\n\nendif\n\nendif\nend subroutine basis_orthg\n"}, {"instruction": "Create a Fortran subroutine named p2r to convert polar coordinates to rectangular coordinates. The subroutine takes 2 input parameters of type real, representing velocity and angle in radians, and produces 2 output parameters of type real, representing x and y velocities.", "input": "", "output": "    subroutine p2r(v, theta, v_x, v_y)\n        !! convert polar to rectangular\n        implicit none\n        real, intent(in)    :: v, theta ! velocity, angle [rad]\n        real, intent(out)   :: v_x, v_y ! x, y velocity\n        v_x = v * cos(theta)\n        v_y = v * sin(theta)\n    end subroutine p2r\n"}, {"instruction": "Create a Fortran subroutine named r2p to convert rectangular coordinates to polar coordinates. The subroutine takes 2 input parameters of real type, v_x and v_y, and returns 2 output parameters of real type, v and theta, representing velocity and angle in radians, respectively.", "input": "", "output": "    subroutine r2p(v_x, v_y, v, theta)\n        !! convert rectangular to polar\n        implicit none\n        real, intent(in)    :: v_x, v_y ! x, y velocity\n        real, intent(out)   :: v, theta ! velocity, angle [rad]\n        v = sqrt(v_x ** 2 + v_y ** 2)\n        theta = atan2(v_y, v_x)\n    end subroutine r2p\n"}, {"instruction": "Create a Fortran subroutine named sqrt_array to compute the square root of each element in an input array. The subroutine should have 2 input parameters: an integer representing the length of the array and a real array of kind=8. It should also have 1 output parameter, a real array of kind=8.", "input": "", "output": "      subroutine sqrt_array(vect, vect_len, res)\n      \n        implicit none\n        \n        integer, intent(in)     :: vect_len\n        real(kind=8), intent(in)        :: vect(vect_len)\n        real(kind=8), intent(out)       :: res(vect_len)\n        \n        integer ::  i\n\n        do i=1,vect_len\n            res(i) = sqrt(vect(i))\n        enddo \n\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named set_flam_vert. This subroutine takes 4 input parameters of type real, integer, real, and real, respectively, and 3 output parameters of type integer, integer, and real. The subroutine calculates and sets values for k1, k2, and vmd based on the input parameters ztopmax, nkp, zzcon, and w_vmd.", "input": "", "output": "  subroutine set_flam_vert(ztopmax,k1,k2,nkp,zzcon,w_vmd,vmd)\n    real , intent(in) :: ztopmax(2)\n    integer , intent(out) :: k1\n    integer , intent(out) :: k2\n    integer , intent(in) :: nkp\n    real , intent(in) :: zzcon(nkp)\n    integer imm,k\n    integer, dimension(2) :: k_lim\n    real , intent(in) :: w_vmd(nkp,2)\n    real , intent(out) :: vmd(nkp,2)\n    real w_thresold,xxx\n    integer k_initial,k_final,ko,kk4,kl\n    do imm=1,2\n       do k=1,nkp-1\n          if(zzcon(k) > ztopmax(imm) ) exit\n       enddo\n       k_lim(imm) = k\n    enddo\n    k1=max(3,k_lim(1))\n    k2=max(3,k_lim(2))\n    if(k2 < k1) then\n       k2=k1\n    endif\n    w_thresold = 1.\n    do imm=1,2\n       vmd(1:nkp,imm)= 0.\n       xxx=0.\n       k_initial= 0\n       k_final = 0\n       do ko=nkp-10,2,-1\n        if(w_vmd(ko,imm) < w_thresold) cycle\n        if(k_final==0) k_final=ko\n        if(w_vmd(ko,imm)-1. > w_vmd(ko-1,imm)) then\n          k_initial=ko\n          exit\n        endif\n       enddo\n       if(k_final > 0 .and. k_initial > 0) then\n           k_initial=int((k_final+k_initial)*0.5)\n           kk4 = k_final-k_initial+2\n           do ko=1,kk4-1\n               kl=ko+k_initial-1\n               vmd(kl,imm) = 6.* float(ko)/float(kk4)**2 * (1. - float(ko)/float(kk4))\n           enddo\n    if(sum(vmd(1:nkp,imm)) .ne. 1.) then\n         xxx= ( 1.- sum(vmd(1:nkp,imm)) )/float(k_final-k_initial+1)\n         do ko=k_initial,k_final\n           vmd(ko,imm) = vmd(ko,imm)+ xxx\n         enddo\n           endif\n        endif\n    enddo\n  end subroutine set_flam_vert\n"}, {"instruction": "Write a Fortran subroutine named \"sub7\" with one input parameter and one output parameter. The input parameter should be an allocatable integer array, specified with the \"intent(in)\" attribute. The output parameter should also be an allocatable integer array, specified with the \"intent(out)\" attribute. The subroutine should copy the contents of the input array \"y\" to the output array \"x\".", "input": "", "output": "  subroutine sub7 (x, y)\n    integer, allocatable, intent(in) :: y(:)\n    integer, allocatable, intent(out) :: x(:)\n    x = y\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named linear_polynom_fit to perform a linear polynomial fit. The subroutine takes 3 input parameters of type integer and double precision, and 2 output parameters of type double precision. The input parameters are n, x(n), and y(n), while the output parameters are p1 and p2. The subroutine calculates the coefficients p1 and p2 of the linear polynomial that best fits the given data points.", "input": "", "output": "subroutine linear_polynom_fit(n,x,y,p1,p2)\n\nimplicit none\ninteger, intent(in)             :: n\ndouble precision, intent(in)    :: x(n), y(n)\ndouble precision, intent(out)   :: p1, p2\n!----------------------------------------------------\ndouble precision                :: sumx, sumy, sumx2, sumxy\n\nsumx = 0.0d0\nsumy = 0.0d0\nsumx2 = 0.0d0\nsumxy = 0.0d0\n\nsumx = sum(x)\nsumy = sum(y)\nsumx2 = sum(x**2)\nsumxy = sum(x*y)\n\np1 = (n*sumxy - sumx*sumy)/(n*sumx2 - sumx**2)\np2 = (sumy - p1*sumx)/n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rotation_matrix to calculate the 3x3 rotation matrix from the input quaternion. The number of input parameters is 1 of type double precision array with dimension (4). The number of output parameters is 1 of type double precision array with dimension (3,3).", "input": "", "output": "  subroutine rotation_matrix(q, u)\n  \n    double precision,dimension(4),intent(in)::q\n    double precision,dimension(3,3),intent(out)::u\n    double precision::q0,q1,q2,q3,b0,b1,b2,b3,q00,q01,q02,q03,q11,q12,q13,q22,q23,q33\n    \n    q0=q(1)\n    q1=q(2)\n    q2=q(3)\n    q3=q(4)\n    \n    b0=2.0d0*q0\n    b1=2.0d0*q1\n    b2=2.0d0*q2\n    b3=2.0d0*q3\n    \n    q00=b0*q0-1.0d0\n    q01=b0*q1\n    q02=b0*q2\n    q03=b0*q3\n    \n    q11=b1*q1\n    q12=b1*q2\n    q13=b1*q3  \n    \n    q22=b2*q2\n    q23=b2*q3\n    \n    q33=b3*q3 \n    \n    u(1,1)=q00+q11\n    u(1,2)=q12-q03\n    u(1,3)=q13+q02\n    \n    u(2,1)=q12+q03\n    u(2,2)=q00+q22\n    u(2,3)=q23-q01\n    \n    u(3,1)=q13-q02\n    u(3,2)=q23+q01\n    u(3,3)=q00+q33\n    \n  end subroutine rotation_matrix\n"}, {"instruction": "Create a Fortran subroutine named initial to initialize arrays representing the height and velocity of a fluid at different positions along a domain. The subroutine takes 4 input parameters of type integer, real(8), and real(8) and 2 output parameters of type real(8).", "input": "", "output": "subroutine initial(pi, nx, x, h, uh, x_length)\nimplicit none\n\n    integer, intent(in):: nx\n\treal(8), intent(in):: x(nx), pi, x_length\n\treal(8), intent(out):: h(nx), uh(nx)\n\treal(8)::a, b, c\n\n    ! sine wave initial condition\n\t!h(1:nx) = 2.0d0 + sin(2*pi* x(1:nx))\n\n\t! dam break initial condition\n\t!h = 1.0d0\n\t!h(1:nx/2) = 3.0d0\n\n    ! gaussian function\n    a=3.0d0\n    b=x_length/2.0d0\n    c=0.2d0\n    h(1:nx) = a*exp(-(x(1:nx)-b)**2 /(2*c**2))\n\n\tuh(1:nx) = 0.0d0\n\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named detect_start to determine the start and finish indices based on the given seedling and harvesting days in an agricultural context. The subroutine takes 3 input parameters of type integer (seedling_day, harvesting_day, day) and 2 output parameters of type integer (start, finish).", "input": "", "output": " subroutine detect_start(start,finish,seedling_day,harvesting_day,day)\r\n\tinteger,intent(out)::start,finish\r\n\tinteger,intent(in)::seedling_day(:),harvesting_day(:),day(:,:)\r\n\tinteger i,j,n,yy,mm,dd,diff\r\n\t\r\n\tdo i=1,size(day,1)\r\n\t\tyy=day(i,1)\r\n\t\tmm=day(i,2)\r\n\t\tdd=day(i,3)\r\n\t\t\r\n\t\tdiff=abs( seedling_day(1)-yy )&\r\n\t\t\t+abs( seedling_day(2)-mm )&\r\n\t\t\t+abs( seedling_day(3)-dd )\r\n\t\t\r\n\t\tif(diff==0 )then\r\n\t\t\tstart=i\r\n\t\t\texit\r\n\t\tendif\r\n\t\t\r\n\tenddo\r\n\t\r\n\tdo i=1,size(day,1)\r\n\t\tyy=day(i,1)\r\n\t\tmm=day(i,2)\r\n\t\tdd=day(i,3)\r\n\t\t\r\n\t\tdiff=abs( harvesting_day(1)-yy )&\r\n\t\t\t+abs( harvesting_day(2)-mm )&\r\n\t\t\t+abs( harvesting_day(3)-dd )\r\n\t\t\r\n\t\tif(diff==0 )then\r\n\t\t\tfinish=i\r\n\t\t\texit\r\n\t\tendif\r\n\t\t\r\n\tenddo\r\n\t\r\n\t\r\n end subroutine detect_start\r\n"}, {"instruction": "Create a Fortran subroutine named count_br_per_node to calculate the number of branch connections per node. The subroutine takes 2 input parameters of type integer and an array, and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine count_br_per_node(node_number,br_per_node,d_connect)\r\n\tinteger,intent(in)::node_number,d_connect(:,:)\r\n\tinteger,intent(out)::br_per_node\r\n\tinteger i\r\n\t\r\n\tbr_per_node=0\r\n\tdo i=1,size(d_connect,1)\r\n\t\tif(node_number==d_connect(i,1) )then\r\n\t\t\tbr_per_node=br_per_node+1\r\n\t\telse\r\n\t\t\tcycle\r\n\t\tendif\r\n\tenddo\r\n\tif(br_per_node>=3)stop\"debug\"\r\n\t\r\n end subroutine count_br_per_node\r\n"}, {"instruction": "Create a Fortran subroutine named detect_light_area to calculate the light area and total area based on leaf coordinates and node information. The subroutine takes 3 input parameters of type real(8), integer, and integer. It returns 2 output parameters of type real(8).", "input": "", "output": " subroutine detect_light_area(leaf_coord,light_area,total_area,node_id,leaf_id)\r\n\treal(8),intent(in)::leaf_coord(:,:,:,:)\r\n\treal(8),intent(out)::light_area,total_area\r\n\treal(8),allocatable::mid_x(:),shape_function(:),evaluate_point(:,:),eva_x(:),rvec(:)&\r\n\t\t,x1(:),x2(:),y1(:),y2(:)\r\n\treal(8) gzi_1,gzi_2,eva_r,mid_r,both_r,l1,l2,l3\r\n\tinteger,intent(in)::node_id,leaf_id\r\n\tinteger i,j,k,l,m,shade_or_not,count_shade\r\n\t\r\n\tallocate(mid_x(3),shape_function(4),evaluate_point(4,2),eva_x(3),rvec(2),x1(2),x2(2))\r\n\tallocate(y1(3),y2(3))\r\n\t\r\n\t!2d linear interpolation,4 points\r\n\tevaluate_point(1,1)=-0.50d0\r\n\tevaluate_point(1,2)=-0.50d0\r\n\tevaluate_point(2,1)=-0.50d0\r\n\tevaluate_point(2,2)=0.50d0\r\n\tevaluate_point(3,1)=0.50d0\r\n\tevaluate_point(3,2)=0.50d0\r\n\tevaluate_point(4,1)=0.50d0\r\n\tevaluate_point(4,2)=-0.50d0\r\n\t\r\n\ty1(1:3)=leaf_coord(node_id,leaf_id,1,1:3)-leaf_coord(node_id,leaf_id,3,1:3)\r\n\ty2(1:3)=leaf_coord(node_id,leaf_id,2,1:3)-leaf_coord(node_id,leaf_id,4,1:3)\r\n\tl1=dsqrt( dot_product(y1,y1) )\r\n\tl2=dsqrt( dot_product(y2,y2) )\r\n\ttotal_area=0.50d0*l1*l2/100.0d0/100.0d0\r\n\t\r\n\tcount_shade=0\r\n\tdo k=1,4 !evaluate points\r\n\t\tgzi_1=evaluate_point(k,1)\r\n\t\tgzi_2=evaluate_point(k,2)\r\n\t\tshape_function(1)=0.250d0*(1.0d0-gzi_1)*(1.0d0-gzi_1)\r\n\t\tshape_function(2)=0.250d0*(1.0d0-gzi_1)*(1.0d0+gzi_1)\r\n\t\tshape_function(3)=0.250d0*(1.0d0+gzi_1)*(1.0d0+gzi_1)\r\n\t\tshape_function(4)=0.250d0*(1.0d0+gzi_1)*(1.0d0-gzi_1)\r\n\t\t\r\n\t\teva_x(:)=0.0d0\r\n\t\tdo l=1,4 \r\n\t\t\teva_x(:)=eva_x(:)+leaf_coord(node_id,leaf_id,l,:)&\r\n\t\t\t\t*shape_function(l)\r\n\t\tenddo\r\n\t\trvec(:)=leaf_coord(node_id,leaf_id,k,1:2)\r\n\t\teva_r=dsqrt( dot_product(rvec-eva_x(1:2) ,rvec-eva_x(1:2)  ) )\r\n\t\t\r\n\t\tshade_or_not=0\r\n\t\t\r\n\t\tdo i=1,size(leaf_coord,1)\r\n\t\t\tdo j=1,size(leaf_coord,2)\r\n\t\t\t\tmid_x(:)=0.0d0\r\n\t\t\t\tdo l=1,4\r\n\t\t\t\t\tmid_x(:)=mid_x(:)+0.250d0*leaf_coord(i,j,l,:)\r\n\t\t\t\tenddo\r\n\t\t\t\t\r\n\t\t\t\t!if z coordinate of the midpoint of the leaf > evaluate point\r\n\t\t\t\t! => possible node\r\n\t\t\t\tif(mid_x(3) < eva_x(3) )then\r\n\t\t\t\t\tcycle\r\n\t\t\t\tendif\r\n\t\t\t\t\r\n\t\t\t\tx1(1:2)=leaf_coord(i,j,1,1:2)-leaf_coord(i,j,3,1:2)\r\n\t\t\t\tx2(1:2)=leaf_coord(i,j,2,1:2)-leaf_coord(i,j,4,1:2)\r\n\t\t\t\t\r\n\t\t\t\tmid_r=dsqrt( dot_product(x1,x1) )+dsqrt( dot_product(x2,x2) )\r\n\t\t\t\tmid_r=0.50d0*mid_r\r\n\t\t\t\t\r\n\t\t\t\tboth_r=dsqrt( dot_product(mid_x(1:2)-eva_x(1:2),mid_x(1:2)-eva_x(1:2)))\r\n\t\t\t\t\r\n\t\t\t\tif(both_r > eva_r+mid_r)then\r\n\t\t\t\t\tcycle\r\n\t\t\t\telse\r\n\t\t\t\t\tshade_or_not=1\r\n\t\t\t\t\texit\r\n\t\t\t\tendif\t\t\r\n\t\t\tenddo\r\n\t\t\t\r\n\t\t\tif(shade_or_not==1)then\r\n\t\t\t\texit\r\n\t\t\tendif\r\n\t\tenddo\r\n\t\t\r\n\t\tif(shade_or_not==1)then\r\n\t\t\tcycle\r\n\t\telse\r\n\t\t\tcount_shade=count_shade+1\r\n\t\tendif\t\r\n\tenddo\r\n\t\r\n\tlight_area=total_area/4.0d0*dble(count_shade)\r\n\t\r\n end subroutine detect_light_area\r\n"}, {"instruction": "Create a Fortran subroutine named get_descra that takes two input parameters of type character*11 and character, and two output parameters of type character and integer. The subroutine assigns a message based on the value of the descriptor and sets ierr to 0 if successful or -1 if there is an error.", "input": "", "output": "      subroutine get_descra(descra,descriptor,message,ierr)\n      implicit none\n      character*11, intent(in) :: descra\n      character, intent(in) :: descriptor\n      character, intent(out) :: message\n      integer, intent(out) :: ierr\n      ierr = -1\n      message = ''\n      select case(descriptor)\n      case('a') !lower,upper or both parts\n         message = descra(3:3)\n      case('b') !base\n         message = descra(5:5)\n      case('d') !unity diagonal stored or not\n         message = descra(1:1)\n      case('f') !internal block storage is row- or column-wise\n         message = descra(7:7)\n      case('r') !repeated indices\n         message = descra(2:2)\n      case('s') !structure of matrix\n         message = descra(4:4)\n      case('t') !matrix type\n         message = descra(6:6)\n      case default\n         return\n      end select      \n      ierr = 0\n      end subroutine get_descra\n"}, {"instruction": "Create a Fortran subroutine named estimate_coef. The subroutine takes 2 input parameters of type real, represented by arrays x and y, and 1 output parameter of type real represented by array b. This subroutine calculates the regression coefficients based on the input data and stores the result in the b array.", "input": "", "output": "subroutine estimate_coef(x, y, b)\n\n  real, intent(in) :: x(:), y(:)\n  real, intent(out) :: b(2)\n  real :: m_x, m_y\n  integer :: n\n\n  ! number of observations/points\n  n = size(x)\n\n  ! mean of x and y vector\n  m_x = sum(x)/n \n  m_y = sum(y)/n\n\n  ! calculating cross-deviation and deviation about x\n  ss_xy = sum(y*x) - n*m_y*m_x\n  ss_xx = sum(x*x) - n*m_x*m_x \n  \n  ! calculating regression coefficients \n  b(2) = ss_xy / ss_xx \n  b(1) = m_y - b(2)*m_x \n\n  return\n  \nend subroutine estimate_coef\n"}, {"instruction": "Write a Fortran subroutine named multiindices to generate multi-indices for a given set of degrees and stratify them.The number of input arguments is 6 and the test_data type is ['integer', 'integer', 'integer', 'integer', 'integer', 'integer']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "input": "", "output": "  subroutine multiindices(n, m, degs, n_deg, n_idx, n_idx_by_deg, idx_ptr, idx, stratifier)\n    implicit none\n\n    integer, intent(in) :: n, n_deg, n_idx, m(n), degs(n_deg), n_idx_by_deg(n_deg)\n    integer, intent(out) :: idx_ptr(:), idx(:), stratifier(:)\n    integer, allocatable :: var(:)\n    integer i, i1, i2, j, k\n\n    idx_ptr(1) = 0\n    i = 2\n    do j = 1, n_deg\n       do k = 1, n_idx_by_deg(j)\n          idx_ptr(i) = idx_ptr(i-1) + degs(j)\n          i = i + 1\n       end do\n    end do\n    ! print*, 'idx_ptr', idx_ptr\n\n    i = 1\n    do j = 1, n_deg\n       allocate(var(degs(j)))\n       ! var = (/ (i2, i=12, degs(j)) /)\n       do i2 = 1, degs(j)\n          var(i2) = i2\n       end do\n       idx(idx_ptr(i)+1:idx_ptr(i+1)) = var\n       i = i + 1\n       ! do k = 1, n_idx_by_deg(degs(j))-1\n       do k = 1, n_idx_by_deg(j)-1\n          i1 = degs(j)\n          var(i1) = var(i1) + 1\n          do while (var(i1) + degs(j) > i1 + n)\n             i1 = i1 - 1\n             var(i1) = var(i1) + 1\n          end do\n          ! var(i1+1:) = (/ (var(i2-1)+1, i2=i1+1, degs(j)) /)\n          do i2 = i1+1, degs(j)\n             var(i2) = var(i2-1)+1\n          end do\n          idx(idx_ptr(i)+1:idx_ptr(i+1)) = var\n          i = i + 1\n       end do\n       deallocate(var)\n    end do\n    ! print*, 'idx', idx\n\n    stratifier = 1\n    do i = 2, n_idx\n       do j = idx_ptr(i-1)+1, idx_ptr(i)\n          stratifier(i) = stratifier(i) * m(idx(j))\n       end do\n       stratifier(i) = stratifier(i) + stratifier(i-1)\n    end do\n    ! print*, 'stratifier', stratifier\n\n  end subroutine multiindices\n"}, {"instruction": "Create a Fortran subroutine named make_state_name to generate a state name based on the input integer value. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type character with varying length.", "input": "", "output": "      subroutine make_state_name(state_name, nstate)\n      implicit none\n      integer,          intent(in)  :: nstate\n      character(len=*), intent(out) :: state_name\n\n      state_name='/state_0000/'\n      write (state_name(8:11),'(i4.4)') nstate\n\n      return\n      end subroutine make_state_name\n"}, {"instruction": "Write a Fortran subroutine named copy_data_3d_real8 to copy 3D real(8) array data from the source array to the destination array. The subroutine takes one input parameter of type real(8) array and one output parameter of type real(8) array.", "input": "", "output": "  subroutine copy_data_3d_real8(src,dst)\n    implicit none\n    real(8), intent(in)  :: src(:,:,:)\n    real(8), intent(out) :: dst(:,:,:)\n    integer :: ix,iy,iz\n    integer :: nx,ny,nz\n\n    nz = size(src,3)\n    ny = size(src,2)\n    nx = size(src,1)\n\n!$omp parallel do collapse(2) default(none) &\n!$omp          private(ix,iy,iz) &\n!$omp          firstprivate(nx,ny,nz) &\n!$omp          shared(src,dst)\n    do iz=1,nz\n    do iy=1,ny\n    do ix=1,nx\n      dst(ix,iy,iz) = src(ix,iy,iz)\n    end do\n    end do\n    end do\n!$omp end parallel do\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named return_gauge to extract values from arrays q and aux at a specific location xgauge. The subroutine takes 9 input parameters of types integer, integer, integer, integer, double precision, double precision, double precision, double precision, and double precision. The output is a single parameter of type double precision.", "input": "", "output": "      subroutine return_gauge(meqn,maux,mvars,mx,dx,xlower,xgauge,sol,q,aux)\n      !\n      ! return values sol(vars) at xlower\n      !=================================================================\n\n      !i/o\n      integer, intent(in) :: meqn,maux,mvars,mx\n      double precision, intent(in) :: dx,xlower,xgauge\n      double precision, intent(in) :: q(mx,meqn), aux(mx,maux)\n      double precision, intent(out) :: sol(mvars)\n\n      !locals\n      integer :: i,m\n\n      i = floor((xgauge - xlower)/dx) + 1\n\n      do m = 1, meqn\n         sol(m) = q(i,m)\n      enddo\n      do m = 1, maux\n         sol(m+meqn) = aux(i,m)\n      enddo\n\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lj_functions to calculate the magnitude of the Lennard-Jones force and potential between a pair of atoms at a given distance from each other. The subroutine takes 3 input parameters of type double precision: sigma, eps, and r, and provides 2 output parameters of type double precision: pot and force.", "input": "", "output": "         subroutine lj_functions(sigma, eps, r, pot, force)\n            ! calculates the magnitude of the lj force and potential between\n            ! a pair of atoms at a given distance from each other.\n            !\n            ! args:\n            !    sigma: the lj distance parameter.\n            !    eps: the lj energy parameter.\n            !    r: the separation of the atoms.\n            !    pot: the lj interaction potential.\n            !    force: the magnitude of the lj force.\n\n            double precision, intent(in) :: sigma\n            double precision, intent(in) :: eps\n            double precision, intent(in) :: r\n            double precision, intent(out) :: pot\n            double precision, intent(out) :: force\n\n            double precision sigma_by_r6\n\n            sigma_by_r6 = sigma/r\n            sigma_by_r6 = sigma_by_r6*sigma_by_r6*sigma_by_r6\n            sigma_by_r6 = sigma_by_r6*sigma_by_r6\n\n            pot = 4*eps*(sigma_by_r6*(sigma_by_r6 - 1))\n            force = 24*eps*(sigma_by_r6*(2*sigma_by_r6 - 1)/r)\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lj_longrange to calculate the long-range correction to the total potential and virial pressure. The subroutine should have 5 input parameters of type double precision and 2 output parameters of type double precision. The input parameters are rc, sigma, eps, natoms, and volume, while the output parameters are pot_lr and vir_lr.", "input": "", "output": "         subroutine lj_longrange(rc, sigma, eps, natoms, volume, pot_lr, vir_lr)\n            ! calculates the long range correction to the total potential and\n            ! virial pressure.\n            !\n            ! uses the tail correction for a sharp cut-off, with no smoothing\n            ! function, as derived in martyna and hughes, journal of chemical\n            ! physics, 110, 3275, (1999).\n            !\n            ! args:\n            !    rc: the cut-off radius.\n            !    sigma: the lj distance parameter.\n            !    eps: the lj energy parameter.\n            !    natoms: the number of atoms in the system.\n            !    volume: the volume of the system box.\n            !    pot_lr: the tail correction to the lj interaction potential.\n            !    vir_lr: the tail correction to the lj virial pressure.\n\n            double precision, intent(in) :: rc\n            double precision, intent(in) :: sigma\n            double precision, intent(in) :: eps\n            integer, intent(in) :: natoms\n            double precision, intent(in) :: volume\n            double precision, intent(out) :: pot_lr\n            double precision, intent(out) :: vir_lr\n\n            double precision sbyr, s3byr3, s6byr3, s6byr6, prefactor\n\n            sbyr = sigma/rc\n            s3byr3 = sbyr*sbyr*sbyr\n            s6byr6 = s3byr3*s3byr3\n            prefactor = four_tau_by_3*natoms*natoms*eps/volume\n            prefactor = prefactor*s3byr3*sigma*sigma*sigma\n\n            pot_lr = prefactor*(s6byr6/3-1)\n            vir_lr = prefactor*(s6byr6-1) + pot_lr\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_input_file_time_series to read a time series data from a file or use a default array if no file name is provided. The subroutine takes 3 input parameters of types character(60), double precision, and integer, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine read_input_file_time_series(name, array, default, ntimesteps)\n    implicit none\n\n    character(60), intent(in) :: name\n    double precision, intent(out) :: array(ntimesteps)\n    double precision, intent(in) :: default\n    integer, intent(in) :: ntimesteps\n\n    if (name.ne.'') then\n      open(unit=10, form='unformatted', file=name)\n      read(10) array\n      close(10)\n    else\n      array = default\n    end if\n\n    return\n  end subroutine read_input_file_time_series\n"}, {"instruction": "Create a Fortran subroutine named set_acc_fact to calculate the accuracy factor based on certain conditions. The subroutine takes 3 input parameters of types logical, real*8, and real*8, and returns 1 output parameter of type real*8.", "input": "", "output": "      subroutine set_acc_fact(acccond, accfactcutoff, loe, accfact)\n\n      implicit none\n\n      logical, intent(in) :: acccond\n\n      real*8, intent(in) ::  accfactcutoff, loe\n\n      real*8, intent(out) :: accfact\n\n      accfact = 0.0d0\n\n      if (acccond) accfact = loe\n\n      if (accfact .gt. accfactcutoff) accfact = accfactcutoff\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gaussmat to perform Gaussian elimination on a matrix. This subroutine takes 3 input parameters of type integer, real array, and real array, and 1 output parameter of type real array with allocatable memory.", "input": "", "output": "    subroutine gaussmat(jaa, bb, xx, nn)\n\n        integer, intent(in) :: nn\n        real, intent(in) :: jaa(:,:), bb(:)\n        real, allocatable, intent(out) :: xx(:)\n\n        real, allocatable, dimension(:,:) :: aa\n        integer :: ii, ij, ik\n        real :: xsum, xmult\n        !character(len=40) :: a3fmt\n\n        ! formation de la matrice a = [jaa | i]\n        allocate(aa(nn,nn+1), xx(nn))\n\n        xx=0.\n        aa=0.\n        do ii=1, nn\n            do ij=1, nn+1\n               aa(ii,ij) = jaa(ii,ij)\n            end do\n            aa(ii, nn+1) = bb(ii)\n        end do\n\n        ! elimination de gauss\n        do ik = 1, nn-1\n           do ii = ik+1, nn\n              xmult = aa(ii, ik) / aa(ik, ik)\n              aa(ii, ik) = 0.\n              do ij = ik+1, nn+1\n                 aa(ii, ij) = aa(ii, ij) - xmult * aa(ik, ij)\n              end do\n           end do\n        end do\n\n        xx(nn) = aa(nn, nn+1) / aa(nn, nn)\n        do ii = nn-1, 1, -1\n           xsum = 0.\n           do ij= ii+1, nn\n              xsum = xsum + aa(ii, ij) * xx(ij)\n           end do\n           xx(ii) = (aa(ii, nn+1) - xsum) / aa(ii, ii)\n        end do\n\n        deallocate(aa)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_v to convert 3D Cartesian coordinates to 3D spherical coordinates. The subroutine takes 1 input parameter of type real(8) and 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_v(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n)\n      complex(8), intent(out) :: v(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      v(1)=(sqrt(2.0d0)/2.0d0)*cmplx(u(1),u(2),kind=8)\n      v(3)=-(sqrt(2.0d0)/2.0d0)*cmplx(u(1),-u(2),kind=8)\n      v(2)=-u(3)\n      \n   end subroutine cart2sph_v\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_v_modified that converts Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_v_modified(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      v(1)=(1.0d0/sqrt(2.0d0))*cmplx(-u(1,3),u(2,3),kind=8)\n      v(3)=(1.0d0/sqrt(2.0d0))*cmplx(-u(1,3),-u(2,3),kind=8)\n      v(2)=(1.0d0/sqrt(8.0d0))*cmplx(0.0d0,2.0d0*u(1,2)-2.0d0*u(2,1),kind=8)\n   end subroutine cart2sph_t_v_modified\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_v to convert Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_v(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m)\n      complex(8) a(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      ! call cart2sph_v(u,a)\n      ! v(3)=1.0d0/sqrt(2.0d0)*(a(3)*a(2)-a(2)*a(3))\n      ! v(1)=1.0d0/sqrt(2.0d0)*(a(2)*a(1)-a(1)*a(2))\n      ! v(2)=1.0d0/sqrt(2.0d0)*(a(3)*a(1)-a(1)*a(3))\n      \n      v(1)=(1.0d0/sqrt(4.0d0))*cmplx(u(3,1)-u(1,3),-u(3,2)+u(2,3),kind=8)\n      v(3)=(1.0d0/sqrt(4.0d0))*cmplx(u(3,1)-u(1,3),-u(2,3)+u(3,2),kind=8)\n      v(2)=(1.0d0/sqrt(8.0d0))*cmplx(0.0d0,2.0d0*u(1,2)-2.0d0*u(2,1),kind=8)\n   end subroutine cart2sph_t_v\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_mix to convert Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_mix(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m,m)\n      complex(8) iu\n      \n      iu=(0d0,1d0)\n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      goto 51\n51       continue\n      !-1,-1\n      v(1,1)=0.5d0*(u(1,1)-iu*u(2,1)+iu*u(1,2)+u(2,2))\n      v(1,2)=1d0/sqrt(2d0)*(u(1,3)-iu*u(2,3))\n      v(1,3)=0.5d0*(-u(1,1)+u(2,2)+iu*u(2,1)+iu*u(1,2))\n      \n      v(2,1)=1d0/sqrt(2d0)*(u(3,1)+iu*u(3,2))\n      v(2,2)=u(3,3)\n      v(2,3)=1d0/sqrt(2d0)*(-u(3,1)+iu*u(3,2))\n      \n      \n      v(3,3)=0.5d0*(u(1,1)+iu*u(2,1)-iu*u(1,2)+u(2,2))\n      v(3,2)=-1d0/sqrt(2d0)*(u(1,3)+iu*u(2,3))\n      v(3,1)=0.5d0*(u(2,2)-iu*u(2,1)-u(1,1)-iu*u(1,2))\n      \n      !v(1,2)=1d0/sqrt(2d0)*(u(1,3)-iu*u(2,3))\n      \n      \n      return\n      !-1,-1\n      v(1,1)=0.5d0*cmplx(u(1,1)-u(2,2),-(u(1,2)+u(2,1)),kind=8)\n      !-1,0\n      v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      v(1,3)=0.5d0*cmplx(-u(1,1)-u(2,2),-(u(1,2)-u(2,1)),kind=8)\n      !0,-1\n      v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !1,-1\n      v(3,1)=0.5d0*cmplx(-u(1,1)-u(2,2),u(1,2)-u(2,1),kind=8)\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      !1,1\n      v(3,3)=0.5d0*cmplx(u(1,1)-u(2,2),u(1,2)+u(2,1),kind=8)\n      \n      return\n      !-1,-1\n      v(1,1)=0.5d0*((u(1,1)-iu*u(2,1))+iu*(u(1,2)-iu*u(2,2)))\n      !-1,0\n      v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      v(1,3)=-0.5d0*((u(1,1)-iu*u(2,1))-iu*(u(1,2)-iu*u(2,2)))\n      !0,-1\n      v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      !1,-1\n      v(3,1)=-0.5d0*((u(1,1)+iu*u(2,1))+iu*(u(1,2)+iu*u(2,2)))\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      !1,1\n      v(3,3)=0.5d0*((u(1,1)+iu*u(2,1))-iu*(u(1,2)+iu*u(2,2)))\n      \n      return\n      \n      !-1,-1\n      !v(1,1)=0.5d0*((u(1,1)-iu*u(2,1))+iu*(u(1,2)-iu*u(2,2)))\n      !-1,0\n      !v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      !v(1,3)=-0.5d0*((u(1,1)-iu*u(2,1))-iu*(u(1,2)-iu*u(2,2)))\n      !0,-1\n      !v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      v(2,1)=-conjg(v(2,3))\n      !1,-1\n      v(3,1)=-0.5d0*((u(1,1)+iu*u(1,2))+iu*(u(2,1)+iu*u(2,2)))\n      v(1,3)=conjg(v(3,1))\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      v(1,2)=-conjg(v(3,2))\n      !1,1\n      v(3,3)=0.5d0*((u(1,1)-iu*u(1,2))+iu*(u(2,1)-iu*u(2,2)))\n      v(1,1)=conjg(v(3,3))\n   \n   end subroutine cart2sph_t_mix\n"}, {"instruction": "Write a Fortran subroutine named readflags_binary that takes 2 input parameters of type integer(4) and character(n), and 1 output parameter of type logical. The subroutine sets the elements of the logical array arr based on the characters in the input string str. If the character is '1', the corresponding array element is set to .true.; otherwise, it is set to .false. The subroutine stops processing if a space character is encountered in the input string.\n\nNote: The length of the character array str is specified by the integer parameter n.", "input": "", "output": "   subroutine readflags_binary(str,arr,n)\n      integer(4),intent(in) :: n\n      character(n),intent(in) :: str\n      logical,intent(out) :: arr(n)\n      integer(4) i\n\n      arr=.false.\n      do i = 1,n\n         if(str(i:i)=='1')then\n            arr(i)=.true.\n         else if(str(i:i)==' ')then\n            return\n         end if\n      end do\n   \n   end subroutine readflags_binary\n"}, {"instruction": "Write a Fortran subroutine named \"s\" that initializes a 2D array \"x\" with zeros and assigns the value of the first element of input array \"c\" to the first element of \"x\". The subroutine takes 3 input arguments of type integer, integer, and real(kind=8) and outputs a 2D array of real(kind=8) with dimensions specified by the input integers.", "input": "", "output": "subroutine s(n, m, c, x)\n\timplicit none\n  \tinteger, intent(in) :: n, m\n  \treal(kind=8), intent(out), dimension(n,m) :: x\n  \treal(kind=8), intent(in) :: c(:)\n\n\tx = 0.0d0\n\tx(1, 1) = c(1)\n\nend subroutine s\n"}, {"instruction": "Create a Fortran subroutine named create_rotmat to generate a 3x3 rotation matrix based on three random angles. The input parameter is a real(8) value for the step size, and the output parameter is a 3x3 real(8) matrix for the full rotation matrix.", "input": "", "output": "subroutine create_rotmat(fullrotmat, stepsize)\nreal(8), intent(in)  :: stepsize\nreal(8), intent(out) :: fullrotmat(3,3)\nreal(8)              :: rotmat_x(3,3), rotmat_y(3,3), rotmat_z(3,3)\nreal(8)              :: rand1, rand2, rand3\nreal(8), parameter   :: pi = 3.14159265358979323846 ! define pi\n\ncall random_number(rand1)                               ! random number for angle 1.    use the same angles for all coordinates -> rotation\ncall random_number(rand2)                               ! same for angle 2\ncall random_number(rand3)                               ! same for angle 3\n!\n! rotation based on the rotation around the cartesian axes. three random numbers for three random angles\n!\nrand1 = (2*rand1 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\nrand2 = (2*rand2 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\nrand3 = (2*rand3 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\n\nrotmat_x(1,1:3) = (/ real(1.0,8), real(0.0,8), real(0.0,8) /)\nrotmat_x(2,1:3) = (/ real(0.0,8), cos(rand1), -sin(rand1) /)\nrotmat_x(3,1:3) = (/ real(0.0,8), sin(rand1),  cos(rand1) /)\n\nrotmat_y(1,1:3) = (/ cos(rand2),  real(0.0,8), sin(rand2) /)\nrotmat_y(2,1:3) = (/ real(0.0,8), real(1.0,8), real(0.0,8) /)\nrotmat_y(3,1:3) = (/ -sin(rand2), real(0.0,8), cos(rand2) /)\n\nrotmat_z(1,1:3) = (/ cos(rand3), -sin(rand3),  real(0.0,8) /)\nrotmat_z(2,1:3) = (/ sin(rand3),  cos(rand3),  real(0.0,8) /)\nrotmat_z(3,1:3) = (/ real(0.0,8), real(0.0,8), real(1.0,8) /)\n\nfullrotmat = matmul(rotmat_z,matmul(rotmat_y,rotmat_x))\nreturn\nend subroutine create_rotmat\n"}, {"instruction": "Write a Fortran subroutine called create_rotmat_bond to generate a rotation matrix based on the input axis_vector and stepsize. The input parameters are two real(8) values for axis_vector and stepsize, and the output parameter is a real(8) array fullrotmat(3,3).", "input": "", "output": "subroutine create_rotmat_bond(fullrotmat,axis_vector,stepsize)\nreal(8), intent(in)  :: stepsize\nreal(8), intent(in)  :: axis_vector(3)\nreal(8), intent(out) :: fullrotmat(3,3)\nreal(8)              :: len_vector\nreal(8)              :: norm_vector(3)\nreal(8)              :: rand1\nreal(8), parameter   :: pi = 3.14159265358979323846 ! define pi\n\ncall random_number(rand1)          ! random number for angle\nrand1 = (2*rand1 - 1)*stepsize*10.0*pi  ! angle in radians. should be sufficiently small\n! normalize vector\nlen_vector = sqrt(sum(axis_vector(:)**2))\nnorm_vector(:) = axis_vector(:)/len_vector\n! generate rotation matrix\nfullrotmat(1,1) = cos(rand1) + norm_vector(1)**2*(1 - cos(rand1))\nfullrotmat(1,2) = norm_vector(1)*norm_vector(2)*(1 - cos(rand1)) - norm_vector(3)*sin(rand1)\nfullrotmat(1,3) = norm_vector(1)*norm_vector(3)*(1 - cos(rand1)) + norm_vector(2)*sin(rand1)\nfullrotmat(2,1) = norm_vector(2)*norm_vector(1)*(1 - cos(rand1)) + norm_vector(3)*sin(rand1)\nfullrotmat(2,2) = cos(rand1) + norm_vector(2)**2*(1 - cos(rand1))\nfullrotmat(2,3) = norm_vector(2)*norm_vector(3)*(1 - cos(rand1)) - norm_vector(1)*sin(rand1)\nfullrotmat(3,1) = norm_vector(3)*norm_vector(1)*(1 - cos(rand1)) - norm_vector(2)*sin(rand1)\nfullrotmat(3,2) = norm_vector(3)*norm_vector(2)*(1 - cos(rand1)) + norm_vector(1)*sin(rand1)\nfullrotmat(3,3) = cos(rand1) + norm_vector(3)**2*(1 - cos(rand1))\n\nreturn\nend subroutine create_rotmat_bond\n"}, {"instruction": "Create a Fortran subroutine named rotate_pos that takes 3 input parameters of type real(8) (fullrotmat, xyz1, center_xyz) and 1 output parameter of type real(8) (xyz2). The subroutine executes a rotation transformation on the coordinates xyz1 around the center_xyz using the rotation matrix fullrotmat. Use the do loop to perform the transformation on each coordinate and store the result in xyz2.", "input": "", "output": "subroutine rotate_pos(fullrotmat, xyz1, center_xyz, xyz2)\nreal(8), intent(in)  :: fullrotmat(3,3), xyz1(3), center_xyz(3)\nreal(8), intent(out) :: xyz2(3)\ninteger              :: a\n! rotation at origin. move to origin, rotate and move back to center\ndo a = 1,3\n  xyz2(a) = fullrotmat(a,1)*(xyz1(1) - center_xyz(1)) + &\n            fullrotmat(a,2)*(xyz1(2) - center_xyz(2)) + &\n            fullrotmat(a,3)*(xyz1(3) - center_xyz(3)) + &\n            center_xyz(a)\nend do\nreturn\nend subroutine rotate_pos\n"}, {"instruction": "Create a Fortran subroutine named temp_convert that takes a single input parameter of type real and returns three output parameters of type real. The input parameter represents the temperature in Kelvin, while the output parameters represent the temperature converted to Celsius, Fahrenheit, and Rankine, respectively.", "input": "", "output": "subroutine temp_convert(kelvin, celsius, fahrenheit, rankine)\n  real, intent(in)  :: kelvin\n  real, intent(out) :: celsius, fahrenheit, rankine\n\n  celsius = kelvin - 273.15\n  fahrenheit = kelvin * 1.8 - 459.67\n  rankine = kelvin * 1.8\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mymodsub, which takes an integer input argument and returns an integer output argument. The subroutine doubles the value of the input argument and assigns it to the output argument.", "input": "", "output": "  subroutine mymodsub(arg1,arg2)\n    integer,intent(in) :: arg1\n    integer,intent(out) :: arg2\n\n    arg2=2*arg1\n  end subroutine mymodsub\n"}, {"instruction": "Create a Fortran subroutine named cal_sd to calculate the standard deviation of a given array of double precision numbers. The subroutine takes 2 input parameters of type integer and double precision in the form of an array, and provides 1 output parameter of type double precision.", "input": "", "output": "subroutine cal_sd(n,x,sd)\n  implicit none\n  integer,intent(in) :: n\n  double precision, intent(in) :: x(n)\n  double precision, intent(out) :: sd\n  integer :: i\n  double precision :: mean, mean2\n  mean = 0.d0\n  mean2 = 0.d0\n  do i = 1, n\n    mean = mean + x(i)\n    mean2 = mean2 + x(i)**2\n  end do\n  mean = mean/n\n  mean2 = mean2/n\n  sd = sqrt(mean2 - mean**2)\nend subroutine cal_sd\n"}, {"instruction": "Create a Fortran subroutine named set_initial to initialize a complex array with values computed based on the input parameters. The number of input parameters is 4, the test_data type is ['integer', 'integer', 'real(8)', 'real(8)'], and the number of output parameters is 1 of type complex(8). Use a combination of nested loops and mathematical operations to set the values of the complex array based on the input parameters.", "input": "", "output": " subroutine set_initial(nx, ny, dx, dy, u)\n    ! matlab: u = ones(m1,m2) + 2*repmat(cos(x'),[1,m2])+2*repmat(cos(y'),[1,m1])';\n    integer, intent(in) :: nx, ny\n    real(8), intent(in) :: dx, dy\n    complex(8), intent(out) :: u(nx, ny)\n\n    real(8) :: x, y\n    integer :: i, j\n\n    do i = 1, nx\n      do j = 1, ny\n        x = dx * (i - 1)\n        y = dy * (j - 1)\n        u(i, j) = 1d0 + 2d0 * cos(x) + 2d0 * cos(y)\n      end do\n    end do\n  end subroutine set_initial\n"}, {"instruction": "Create a Fortran subroutine named \"reshape_to_vector\" to convert a 2D complex array \"u\" into two real arrays \"p\" and \"q\" by separating the real and imaginary parts. The subroutine should take 3 input parameters of type integer, integer, and complex(8), and 2 output parameters of type real(8) and real(8).", "input": "", "output": "  subroutine reshape_to_vector(nx, ny, u, p, q)\n   integer, intent(in) :: nx, ny\n    complex(8), intent(in) :: u(nx, ny)\n    real(8), intent(out) :: p(nx, ny), q(nx, ny)\n\n    p = real(u)\n    q = aimag(u)\n  end subroutine reshape_to_vector\n"}, {"instruction": "Write a Fortran subroutine named set_jacobian that calculates the Jacobian matrix for a given set of input parameters. The subroutine takes 5 input parameters of type integer, real(8), real(8), real(8) and real(8), and returns 1 output parameter of type real(8).", "input": "", "output": "  subroutine set_jacobian(n, eps, p0, q0, a, jf)\n    ! matlab: jf = [2*eps*diag(p0.*q0), a + eps * diag(p0.^2+3*q0.^2);\n    !               -a - eps * diag(p0.^2+3*q0.^2), 2*eps*diag(p0.*q0)];\n    integer, intent(in) :: n\n    real(8), intent(in) :: eps, p0(n), q0(n), a(n, n)\n    real(8), intent(out) :: jf(n * 2, n * 2)\n\n    integer :: i\n    real(8) :: jfd1(n), jfd2(n)\n\n\n    jf(:, :) = 0d0\n    jf(1 : n, n + 1 : n * 2) = a(1 : n, 1 : n)\n    jf(n + 1 : n * 2, 1 : n) = -a(1 : n, 1 : n)\n\n    jfd1 = 2d0 * eps * (p0 * q0)\n    jfd2 = eps * ((p0**2) + 3d0 * (q0**2))\n    do i = 1, n\n      jf(i, i) = jfd1(i)\n      jf(n + i, n + i) = jfd1(i)\n      jf(i, n + i) = jf(i, n + i) + jfd2(i)\n      jf(n + i, i) = jf(n + i, i) - jfd2(i)\n    end do\n  end subroutine set_jacobian\n"}, {"instruction": "Create a Fortran subroutine named set_eye to initialize a square matrix with the identity matrix of a specified size. The number of input parameters is 1 of type integer, and the number of output parameters is 1 of type real(8).", "input": "", "output": "  subroutine set_eye(n, x)\n    ! set identity matrix with size n.\n    integer, intent(in) :: n\n    real(8), intent(out) :: x(n, n)\n\n    integer :: i\n\n    x(:, :) = 0d0\n    do i = 1, n\n      x(i, i) = 1d0\n    end do\n  end subroutine set_eye\n"}, {"instruction": "Write a Fortran subroutine named reshape_to_matrix that takes in four input parameters of type integer, integer, real(8), and real(8), and one output parameter of type complex(8). The subroutine reshapes the input real arrays p and q into a complex array u with dimensions nx and ny, where nx and ny are the input integers.", "input": "", "output": "  subroutine reshape_to_matrix(nx, ny, p, q, u)\n    ! matlab: u = reshape(p + sqrt(-1)*q,[nx,ny]);\n    integer, intent(in) :: nx, ny\n    real(8), intent(in) :: p(nx, ny), q(nx, ny)\n    complex(8), intent(out) :: u(nx, ny)\n\n    u = cmplx(p, q, 8)\n  end subroutine reshape_to_matrix\n"}, {"instruction": "Create a Fortran subroutine named krontmv to perform a Kronecker product transpose operation. The subroutine takes 3 input parameters of type integer, real(8) and real(8), and 1 output parameter of type real(8). The input parameters represent the size of the matrix, the 3x3 matrix T, and the vector X, while the output parameter represents the resulting vector Y. The subroutine uses the imperative do concurrent loop to calculate the elements of the resulting vector Y based on the Kronecker product transpose operation.", "input": "", "output": "  subroutine krontmv(n, t, x, y)\n    integer, intent(in) :: n\n    real(8), intent(in) :: t(3, 3), x(3*n)\n    real(8), intent(out) :: y(3*n)\n    integer :: i\n    do concurrent (i=1:n)\n      y(i    ) = t(1,1) * x(i) + t(1,2) * x(i+n) + t(1,3) * x(i+2*n)\n      y(i+n  ) = t(2,1) * x(i) + t(2,2) * x(i+n) + t(2,3) * x(i+2*n)\n      y(i+2*n) = t(3,1) * x(i) + t(3,2) * x(i+n) + t(3,3) * x(i+2*n)\n    end do\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named number_of_lines to count the number of lines in a text file. The subroutine takes 1 input parameter of type character (len=30) and outputs 1 parameter of type integer.", "input": "", "output": "subroutine number_of_lines(input_file, n)\n    implicit none\n\t! dummy vars\n\tcharacter (len=30), intent(in) :: input_file\n\tinteger, intent(out) :: n\n\t\n\t! local vars\n    integer :: temp=0, iostatus=0, i=0\n\n    open(unit=10, file=input_file, status=\"old\", action=\"read\")\n    do\n        read(10,*,iostat=iostatus) temp\n        if (iostatus < 0) then\n            exit\n        else\n            i=i+1\n        endif\n    enddo\n\t    \n    close(10)\n    n = i\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linspace that generates a linearly spaced array of real numbers between the given minimum and maximum values. The subroutine should take 3 input parameters of type real, real, and integer and 1 output parameter of type real array with dimension n.", "input": "", "output": "subroutine linspace(xmin, xmax, n, x)\n\timplicit none\n\t! dummy vars\n\treal, intent(in) :: xmin\n\treal, intent(in) :: xmax\n\tinteger, intent(in) :: n\n\treal, dimension(n), intent(out) :: x\n\t\n\t! local vars\n\tinteger :: i\n\treal :: dx\n\t\n\tdx = (xmax - xmin) / (n-1)\n\n\tdo i=1,n\n\t\tx(i) = xmin + dx * (i-1)\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named spherical_to_cart to convert spherical coordinates to Cartesian coordinates. The subroutine takes 3 input parameters of type real (rad, phi, theta) and 3 output parameters of type real (x, y, z).", "input": "", "output": "subroutine spherical_to_cart( rad, phi, theta, x, y, z )\n    real, intent(in)  :: rad, phi, theta\n    real, intent(out) :: x, y, z\n\n    x = rad * cos(phi) * cos(theta)\n    y = rad * sin(phi) * cos(theta)\n    z = rad * sin(theta)\n\nend subroutine spherical_to_cart\n"}, {"instruction": "Write a Fortran subroutine named cart_to_spherical to convert Cartesian coordinates to spherical coordinates. The subroutine takes 3 input arguments of type real (x, y, z) and returns 3 output arguments of type real (rad, phi, theta).", "input": "", "output": "subroutine cart_to_spherical( x, y, z, rad, phi, theta )\n    real, intent(in)  :: x, y, z\n    real, intent(out) :: rad, phi, theta\n\n    rad    = sqrt( x ** 2 + y ** 2 + z ** 2 )\n    theta  = asin(z/rad)\n    if ( x /= 0.0 .or. y /= 0.0 ) then\n        phi = atan2(y,x)\n    else\n        phi = 0.0\n    endif\n\nend subroutine cart_to_spherical\n"}, {"instruction": "Write a Fortran subroutine named polar_to_cart to convert polar coordinates to Cartesian coordinates. The subroutine takes 2 input parameters of type real, representing the radius (rad) and angle (phi), and 2 output parameters of type real, representing the x and y coordinates.", "input": "", "output": "subroutine polar_to_cart( rad, phi, x, y )\n    real, intent(in)  :: rad, phi\n    real, intent(out) :: x, y\n\n\n    x = rad * cos(phi)\n    y = rad * sin(phi)\n\nend subroutine polar_to_cart\n"}, {"instruction": "Create a Fortran subroutine named model to calculate the model output based on the provided input parameters. The number of input parameters is 5, with test_data types ['double precision', 'double precision', 'double precision', 'double precision', 'double precision'], and there is 1 output parameter of test_data type 'double precision'.", "input": "", "output": "subroutine model(t, y, freqs, fitting_coeffs, params, y_model_array)\n    !computes model according to fitting coefficients, frequencies and params\n    double precision, intent(in) :: t(:), y(:), freqs(:), fitting_coeffs(:), params(:) \n    double precision, intent(out) :: y_model_array(size(t))\n    double precision :: y_model, t_p, t_ref\n    double precision :: pi=dacos(-1.0d0)\n    integer :: k, n_dim, delay\n    \n    t_ref = t(1)\n    n_dim = size(freqs)\n    n_data = size(t)\n    do j = 1, n_data\n        y_model = 0.0\n        t_p = t(j)\n        do k = 1,size(fitting_coeffs)\n            if (k.eq.1) then\n                y_model = y_model + fitting_coeffs(k)\n            else if ((k.gt.1).and.(k.le.(n_dim+1))) then\n                y_model = y_model + &\n                        fitting_coeffs(k)*cos(2.0*pi*(t_p-t_ref)*freqs(k-1))\n            else if ((k.gt.(n_dim+1)).and.(k.lt.(2*n_dim+2))) then\n                y_model = y_model + &\n                    fitting_coeffs(k)*sin(2.0*pi*(t_p-t_ref)*freqs((k-(n_dim+1))))\n            else if (k.ge.(2*n_dim+2)) then\n                    delay = k - (2*n_dim+1)\n                    if (j.gt.delay) then   \n                        y_model = y_model + fitting_coeffs(k)*exp((t(j-delay)-t(j))/params(1))*y(j-delay)\n                    endif\n            endif\n        enddo\n        y_model_array(j) = y_model\n    enddo\n\nend subroutine model\n"}, {"instruction": "Create a Fortran subroutine named computeintegrationnodesx2 that calculates the integration nodes for a given input value.The subroutine should take 1 input argument of type integer and provide 1 output argument of type array of integers.", "input": "", "output": "  subroutine computeintegrationnodesx2( inx1, nodesx2 )\n\n    integer, intent(in)  :: inx1\n    integer, intent(out) :: nodesx2(:)\n\n    if     ( nnodes .eq. 1 )then\n\n      nodesx2 = [ 1 ]\n\n    else if( nnodes .eq. 2 )then\n\n      if( inx1 .eq. 1 )then\n\n        nodesx2 = [ 1, 3 ]\n\n      else\n\n        nodesx2 = [ 2, 4 ]\n\n      end if\n\n    else if( nnodes .eq. 3 )then\n\n      if( inx1 .eq. 1 )then\n\n        nodesx2 = [ 1, 4, 7  ]\n\n      else if( inx1 .eq. 2 )then\n\n        nodesx2 = [ 2, 5, 9 ]\n\n      else\n\n        nodesx2 = [ 3, 6, 9 ]\n\n      end if\n\n    else\n\n      print*, 'not implemented for nnodes > 3. stopping...'\n      stop\n\n    end if\n\n  end subroutine computeintegrationnodesx2\n"}, {"instruction": "Create a Fortran subroutine named calc_factorials to calculate the factorial of numbers up to a specified maximum value. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter represents the maximum value for which to calculate the factorials, and the output parameter stores the computed factorials. Use the imperative tone to create the subroutine.", "input": "", "output": "  subroutine calc_factorials(nmax, fact)\n    implicit none\n    integer, intent(in) :: nmax\n    integer, intent(out) :: fact(nmax)\n    integer :: i\n\n    fact(0) = 1\n    do i=1,nmax\n       fact(i) = fact(i-1)*i\n    end do\n\n  end subroutine calc_factorials\n"}, {"instruction": "Write a Fortran subroutine named randominit that initializes the weight with a random real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone in the instructions.", "input": "", "output": "        subroutine randominit(weight, args)\n            real, intent(out) :: weight\n            real, intent(in) :: args(0:)\n            call random_number(weight)\n        end subroutine randominit\n"}, {"instruction": "Create a Fortran subroutine called test_g2cart to perform a specific calculation. The subroutine takes 4 input parameters: 3 integers (n1, n2, n3) and a 3x3 real array (gprimd). It also has 1 output parameter: a real array of size n1*n2*n3 (g2cart). The purpose of the subroutine is to compute certain values based on the input parameters and store the results in the g2cart array.", "input": "", "output": "subroutine test_g2cart(n1,n2,n3,gprimd,g2cart)\n   implicit none\n   integer, intent(in) :: n1,n2,n3\n   real(kind=8), dimension(3,3), intent(in) :: gprimd\n   real(kind=8), dimension(n1*n2*n3), intent(out) :: g2cart\n   !local variables\n   integer :: count, i1,i2,i3,id1,id2,id3,ifft,ig1,ig2,ig3,ii1\n   real(kind=8) :: b11,b12,b13,b21,b22,b23,b31,b32,b33\n   \n\n   id1=int(n1/2)+2\n   id2=int(n2/2)+2\n   id3=int(n3/2)+2\n   ifft=0\n   count=0\n   do i3=1,n3\n      ifft=(i3-1)*n1*n2\n      ig3=i3-int(i3/id3)*n3-1\n      do i2=1,n2\n         ig2=i2-int(i2/id2)*n2-1\n         ii1=1\n         do i1=ii1,n1\n            ig1=i1-int(i1/id1)*n1-1\n            ifft=ifft+1\n\n            b11=gprimd(1,1)*real(ig1,kind=8)\n            b21=gprimd(2,1)*real(ig1,kind=8)\n            b31=gprimd(3,1)*real(ig1,kind=8)\n            b12=gprimd(1,2)*real(ig2,kind=8)\n            b22=gprimd(2,2)*real(ig2,kind=8)\n            b32=gprimd(3,2)*real(ig2,kind=8)\n            b13=gprimd(1,3)*real(ig3,kind=8)\n            b23=gprimd(2,3)*real(ig3,kind=8)\n            b33=gprimd(3,3)*real(ig3,kind=8)\n\n            g2cart(ifft)=( &\n                 &     (b11+b12+b13)**2&\n                 &     +(b21+b22+b23)**2&\n                 &     +(b31+b32+b33)**2&\n                 &     )\n!!$     do ifunc=1,nfunc\n!!$!     compute the laplacien in fourrier space\n!!$!     that is * (i x 2pi x g)**2\n!!$      laplacerdfuncg(1,ifft,ifunc) = -rdfuncg(1,ifft,ifunc)*g2cart(ifft)*two_pi*two_pi\n!!$      laplacerdfuncg(2,ifft,ifunc) = -rdfuncg(2,ifft,ifunc)*g2cart(ifft)*two_pi*two_pi\n!!$     end do\n         end do\n      end do\n   end do\nend subroutine test_g2cart\n"}, {"instruction": "Create a Fortran subroutine named check_gap to find the largest gap in a given direction and transverse directions. The subroutine takes 3 input parameters of type integer, integer array, and integer array, and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine check_gap(dir, n_blocks, n_atoms_block, gap_start, gap_end)\n    ! check gap in direction dir, transverse directions are b and c\n    ! find the largest gap\n\n    implicit none\n\n    ! passed parameters\n    integer,               intent(in)  :: dir\n    integer, dimension(:), intent(in)  :: n_blocks, n_atoms_block\n    integer,               intent(out) :: gap_start, gap_end\n\n    ! local variables\n    integer, dimension(2) :: tran_dir ! transverse directions\n    integer, dimension(3) :: cc_multiplier\n    integer :: ii, ia, ib, ic, icc\n    integer :: tmp_start, tmp_gap, gap\n    logical :: start_count, found_atom\n\n    ! work out transverse directions\n    do ii = 1, 2\n       tran_dir(ii) = mod(dir+ii-1, 3) + 1\n    end do\n    ! define cc index multipliers\n    cc_multiplier(1) = n_blocks(2) * n_blocks(3)\n    cc_multiplier(2) = n_blocks(3)\n    cc_multiplier(3) = 1\n    ! initialise values\n    gap = 0\n    start_count = .false.\n    gap_start = 0\n    gap_end = 0\n    ! find the maximum gap\n    loop_a: do ia = 1, n_blocks(dir)\n       found_atom = .false.\n       loop_b: do ib = 1, n_blocks(tran_dir(1))\n          loop_c: do ic = 1, n_blocks(tran_dir(2))\n             icc = (ia-1) * cc_multiplier(dir) + &\n                   (ib-1) * cc_multiplier(tran_dir(1)) + &\n                   (ic-1) * cc_multiplier(tran_dir(2)) + 1\n             if (n_atoms_block(icc) > 0)  then\n                found_atom = .true.\n                ! we have reached the end of the gap\n                if (start_count) then\n                   start_count = .false.\n                   tmp_gap = ia - tmp_start\n                   if (tmp_gap > gap) then\n                      gap = tmp_gap\n                      gap_start = tmp_start\n                      gap_end = ia - 1\n                   end if\n                end if\n                exit loop_b\n             end if\n          end do loop_c\n       end do loop_b\n       ! only start counting after found an empty slab\n       if ((.not. start_count) .and. (.not. found_atom)) then\n          tmp_start = ia\n          start_count = .true.\n       end if\n       ! if no atoms were found, but have reached the end of cell\n       if ((start_count) .and. (.not. found_atom) .and. &\n           (ia == n_blocks(dir))) then\n          ! remember the slab is still empty, so must be counted in\n          ! the gap, so need to add 1\n          tmp_gap = ia - tmp_start + 1\n          if (tmp_gap > gap) then\n             gap = tmp_gap\n             gap_start = tmp_start\n             gap_end = ia\n          end if\n       end if\n    end do loop_a\n\n    return\n  end subroutine check_gap\n"}, {"instruction": "Create a Fortran subroutine named rdsamo to read and store Hartree-Fock molecular orbital coefficients in atomic orbital (AO) basis from a dumpfile. The subroutine takes 4 input parameters of types integer, integer, integer, and double precision, and has 1 output parameter of type double precision.", "input": "", "output": "subroutine rdsamo( idmp, vmoao, norb, nbsf, rnel)\n  !************************************************************************\n  !\n  ! read hf-mos in ao basis from the dumpfile and store in vmoao\n  !\n  !************************************************************************\n  implicit none\n\n  integer, intent(in)           :: idmp, norb, nbsf\n  double precision, intent(in)  :: rnel\n  double precision, intent(out) :: vmoao(nbsf,nbsf)\n\n  integer          :: i, j, ncoeffs\n\n  write(6,'(/'' reading mo coefficients in ao basis'')')\n  read(idmp,*)\n  ncoeffs = 0\n\n  do i = 1, nbsf\n     do j = 1, nbsf\n\n        read(idmp,'(es24.16)',err=10) vmoao(j,i)\n        ncoeffs = ncoeffs + 1\n\n     enddo\n  enddo\n\n  write(6,'(''  ====> complete'')')\n  write(6,'(''  number of coefficients restored from file : '', &\n         & i12)') ncoeffs\n\n  return\n\n10 continue\n  write(6,'(/,'' error::: something went wrong reading mo coeffs'')')\n  write(6,'(''mo coeffs expected : '',i8,/,''mo coeff attempted to read : '',i8)') nbsf * nbsf, ncoeffs\n  stop\n  \nend subroutine rdsamo\n"}, {"instruction": "Write a Fortran subroutine named station2 that calculates the starting point for a journey based on the input arrays gas and distance. The input arguments are 2 arrays of type integer, and the output argument is a single integer.", "input": "", "output": "   subroutine station2(gas, distance, start)\n      integer, intent(in) :: gas(:), distance(size(gas))\n      integer, intent(out) :: start\n      integer i, tank\n\n      start = size(gas) + 1\n      i = 1\n      tank = 0\n      do while (i < start)\n         if (tank + gas(i) >= distance(i)) then\n            tank = tank + gas(i) - distance(i)\n            i = i + 1\n         else\n            start = start - 1\n            tank = tank + gas(start) - distance(start)\n         end if\n      end do\n      if (tank >= 0) then\n         start = modulo(start, size(gas))\n      else\n         start = 0\n      end if\n   end subroutine station2\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_integer2_1d to allocate memory for a one-dimensional array of 2-byte integers. The subroutine should have 1 input parameter of type integer(kind=8), dimension(1) and 2 output parameters of type integer(kind=2), dimension(:), allocatable and integer.", "input": "", "output": "    subroutine adios2_allocate_integer2_1d(array, shp, ierr)\n        integer(kind=2), dimension(:), allocatable, intent(out):: array\n        integer(kind=8), dimension(1), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_dp_3d to allocate a 3-dimensional array of double-precision real numbers. The subroutine takes 1 input parameter of type integer(kind=8), dimension(3), and returns 2 output parameters: a real(kind=8), 3-dimensional, allocatable array and an integer representing the error status. If the array is already allocated, deallocate it and then allocate a new array with dimensions specified by the input parameter.", "input": "", "output": "    subroutine adios2_allocate_dp_3d(array, shp, ierr)\n        real(kind=8), dimension(:, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(3), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_complex_5d to allocate a 5-dimensional array of complex numbers. The subroutine takes 1 input parameter of type integer(kind=8), dimension(5), and provides 2 output parameters of type complex, dimension(:, :, :, :, :), allocatable, and integer.", "input": "", "output": "    subroutine adios2_allocate_complex_5d(array, shp, ierr)\n        complex, dimension(:, :, :, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(5), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3), shp(4), shp(5)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios2_allocate_integer2_6d\" to dynamically allocate a 6-dimensional array of 2-byte integers based on the shape provided as input. The subroutine takes 1 input parameter of type integer(kind=8), dimension(6) and 2 output parameters of types integer(kind=2), dimension(:, :, :, :, :, :), allocatable and integer. Remember to deallocate the array if it is already allocated, then allocate it based on the provided shape.", "input": "", "output": "    subroutine adios2_allocate_integer2_6d(array, shp, ierr)\n        integer(kind=2), dimension(:, :, :, :, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(6), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3), shp(4), shp(5), shp(6)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cerf to calculate the complex error function erf(z) and its derivative erf'(z) for a given complex argument z. The subroutine takes 1 input parameter of type complex *16, and returns 2 output parameters, both of type complex *16.", "input": "", "output": "subroutine cerf(z,cer,cder)\n\n!     ==========================================================\n!     purpose: compute complex error function erf(z) & erf'(z)\n!     input:   z   --- complex argument of erf(z)\n!     x   --- real part of z\n!     y   --- imaginary part of z\n!     output:  cer --- erf(z)\n!     cder --- erf'(z)\n!     ==========================================================\n\nimplicit double precision (a-h,o-z)\ncomplex *16, intent(in)                  :: z\ncomplex *16, intent(out)                 :: cer\ncomplex *16, intent(out)                 :: cder\n\n\nw=0.0\nw1=0.0\nw2=0.0\neps=1.0d-12\npi=3.141592653589793d0\nx=real(z)\ny=dimag(z)\nx2=x*x\nif (x <= 3.5d0) then\n  er=1.0d0\n  r=1.0d0\n  do  k=1,100\n    r=r*x2/(k+0.5d0)\n    er=er+r\n    if (dabs(er-w) <= eps*dabs(er)) exit\n    w=er\n  end do\n  15    c0=2.0d0/dsqrt(pi)*x*dexp(-x2)\n  er0=c0*er\nelse\n  er=1.0d0\n  r=1.0d0\n  do  k=1,12\n    r=-r*(k-0.5d0)/x2\n    er=er+r\n  end do\n  c0=dexp(-x2)/(x*dsqrt(pi))\n  er0=1.0d0-c0*er\nend if\nif (y == 0.0d0) then\n  err=er0\n  eri=0.0d0\nelse\n  cs=dcos(2.0d0*x*y)\n  ss=dsin(2.0d0*x*y)\n  er1=dexp(-x2)*(1.0d0-cs)/(2.0d0*pi*x)\n  ei1=dexp(-x2)*ss/(2.0d0*pi*x)\n  er2=0.0d0\n  do  n=1,100\n    er2=er2+dexp(-.25d0*n*n)/(n*n+4.0d0*x2)*(2.0d0*x  &\n        -2.0d0*x*dcosh(n*y)*cs+n*dsinh(n*y)*ss)\n    if (dabs((er2-w1)/er2) < eps) exit\n    w1=er2\n  end do\n  30    c0=2.0d0*dexp(-x2)/pi\n  err=er0+er1+c0*er2\n  ei2=0.0d0\n  do  n=1,100\n    ei2=ei2+dexp(-.25d0*n*n)/(n*n+4.0d0*x2)*(2.0d0*x  &\n        *dcosh(n*y)*ss+n*dsinh(n*y)*cs)\n    if (dabs((ei2-w2)/ei2) < eps) exit\n    w2=ei2\n  end do\n  40    eri=ei1+c0*ei2\nend if\ncer=cmplx(err,eri)\ncder=2.0d0/dsqrt(pi)*cdexp(-z*z)\nreturn\nend subroutine cerf\n"}, {"instruction": "Write a Fortran subroutine named factorial to calculate the factorial of a given integer. The subroutine has 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "recursive subroutine factorial ( n, result )\r\n!\r\n!  purpose:\r\n!    to calculate the factorial function\r\n!             | n(n-1)!    n >= 1 \r\n!       n ! = |\r\n!             | 1          n = 0\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    12/07/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n         ! value to calculate\r\ninteger, intent(out) :: result   ! result\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: temp                  ! temporary variable\r\n\r\nif ( n >= 1 ) then\r\n   call factorial ( n-1, temp )\r\n   result = n * temp\r\nelse\r\n   result = 1\r\nend if\r\n\r\nend subroutine factorial\r\n"}, {"instruction": "Write a Fortran subroutine named random_order to generate a random ordering of the integers 1 to n, where n is the input parameter of type integer and intent(in). The output is an array order of integers with length n, specified by the intent(out) attribute.", "input": "", "output": "subroutine random_order(order, n)\n\n!     generate a random ordering of the integers 1 ... n.\n\ninteger, intent(in)  :: n\ninteger, intent(out) :: order(n)\n\n!     local variables\n\ninteger :: i, j, k\nreal    :: wk\n\ndo i = 1, n\n  order(i) = i\nend do\n\n!     starting at the end, swap the current last indicator with one\n!     randomly chosen from those preceeding it.\n\ndo i = n, 2, -1\n  call random_number(wk)\n  j = 1 + i * wk\n  if (j < i) then\n    k = order(i)\n    order(i) = order(j)\n    order(j) = k\n  end if\nend do\n\nreturn\nend subroutine random_order\n"}, {"instruction": "Create a Fortran subroutine named aggiorno_ottimo to update the optimal solution with the given input values. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and 2 output parameters of type double precision. Upon execution, the subroutine updates the optimal solution and writes the updated values to a file named 'ottimocorrente.txt'.", "input": "", "output": "subroutine aggiorno_ottimo(n,xprop,fprop,xott,fott)\n\timplicit none\n\n\tinteger,\t  intent(in)\t\t:: n\n\tdouble precision, intent(in)\t\t:: xprop(n), fprop\n\tdouble precision, intent(out)\t\t:: xott(n),  fott\n\tinteger\t\t\t\t\t:: i\n\n\txott = xprop\n\tfott = fprop\n\n\treturn\n\n\topen(99,file='ottimocorrente.txt',status='replace')\n\tdo i = 1,n\n\t\twrite(99,1000) i, xott(i)\n\tenddo\n\twrite(99,1010) fott\n\tclose(99)\n\n1000 format(1x,'xott(',i3,') = ',es11.4)\n1010 format(1x,'fott      = ',es11.4)\n\n\treturn\n\nend subroutine aggiorno_ottimo\n"}, {"instruction": "Create a Fortran subroutine named coarsen3d to average the values of a 3D field over larger grid boxes. The subroutine takes 7 input parameters of type integer and real arrays, and 1 output parameter of type real array.", "input": "", "output": "subroutine coarsen3d(f,g,nlon1,nlat1,nlev1,nlon2,nlat2,nlev2)\n  !   averages the values of field f (grid size nlon1 x nlat1 x nlev1) over larger\n  !   grid boxes (grid size nlon2 x nlat2 x nlev2), to field g\n\n  !   to keep the algorithm\n  !   simple, only 0/1 weights are used -> works only well if\n  !   div(nlon1/nlon2)=div(nlat1/nlat2)=div(nlev1/nlev2)\n  !\n  integer,intent(in) :: nlon1,nlat1,nlon2,nlat2,nlev1,nlev2\n  real,dimension(nlon1,nlat1,nlev1),intent(in) :: f\n  real,dimension(nlon2,nlat2,nlev2),intent(out) :: g\n  integer :: i,i2,j,j2,k,k2,imin,imax,jmin,jmax,kmin,kmax\n  real :: fsum\n\n  do i2=1,nlon2\n     imin=nint((i2-1)*real(nlon1)/real(nlon2)+1)\n     imax=nint(i2*real(nlon1)/real(nlon2))\n     do j2=1,nlat2\n        jmin=nint((j2-1)*real(nlat1)/real(nlat2)+1)\n        jmax=nint(j2*real(nlat1)/real(nlat2))\n        do k2=1,nlev2\n           kmin=nint((k2-1)*real(nlev1)/real(nlev2)+1)\n           kmax=nint(k2*real(nlev1)/real(nlev2))\n           fsum=0.\n           do i=imin,imax\n              do j=jmin,jmax\n                 do k=kmin,kmax\n                    fsum=fsum+f(i,j,k)\n                 enddo\n              enddo\n           enddo\n           g(i2,j2,k2)=fsum/((imax-imin+1)*(jmax-jmin+1)*(kmax-kmin+1))\n        enddo\n     enddo\n  enddo\n\nend subroutine coarsen3d\n"}, {"instruction": "Create a Fortran subroutine named laplace2_cart that computes the laplacian and coefficient for a given field using a Cartesian grid. The subroutine takes 3 input parameters: a 3D array of real numbers representing the field (f), and two real numbers (dx and dy). It produces 2 output parameters: a 3D array of real numbers representing the laplacian (lapl2), and a 3D array of real numbers representing the coefficient (coeff).", "input": "", "output": "subroutine laplace2_cart(f,dx,dy,lapl2,coeff)\n  !\n  !      as laplace_cart but\n  !        - the contribution of the local value to the laplacian is left out\n  !        - coeff is the coefficient for the local value\n  !\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),intent(out) :: lapl2,coeff\n  real,intent(in) :: dx,dy\n  integer :: nlon,nlat,nlev,i,j,k,c\n  real :: inv_dx,inv_dy\n  nlon=size(f,1)\n  nlat=size(f,2)\n  nlev=size(f,3)\n  inv_dx = 1.0 / (dx * dx)\n  inv_dy = 1.0 / (dy * dy)\n  c=1\n  select case (c)\n  case(1)\n\n     ! x-direction\n     lapl2 ( 2 : nlon - 1, :, : ) = f( 1: nlon - 2, :, : ) &\n          + f ( 3: nlon, :, : )\n     lapl2 ( 1, :, : )    = f( nlon, :, : ) + f ( 2, :, : )\n     lapl2 ( nlon, :, : ) = f( nlon - 1, :, : ) + f ( 1, :, : )\n     lapl2 = lapl2 * inv_dx\n\n     ! y-direction\n     lapl2 ( :, 2 : nlat -1, : ) = lapl2 ( :, 2 : nlat -1, : ) &\n          + ( f ( :, 1 : nlat -2, : ) + f ( :, 3 : nlat, :) ) * inv_dy\n\n     coeff ( :, 2 : nlat -1, : ) = -2 * (inv_dx + inv_dy)\n     coeff ( :, 1, : ) = -2 * ( inv_dx )\n     coeff ( :, nlat, : ) = -2 * ( inv_dx )\n  case(2)\n     do j=1,nlat\n        do k=1,nlev\n           do i=1,nlon\n              ! x-direction\n              if(i==1)then\n                 lapl2(i,j,k)=(-(1./12.)*f(nlon-1,j,k)+(4./3.)*f(nlon,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k))/(dx*dx)\n              else if(i==2)then\n                 lapl2(i,j,k)=(-(1./12.)*f(nlon,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k))/(dx*dx)\n              else if(i==nlon-1)then\n                 lapl2(i,j,k)=(-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(1,j,k))/(dx*dx)\n              else if(i==nlon)then\n                 lapl2(i,j,k)=(-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(1,j,k)-(1./12.)*f(2,j,k))/(dx*dx)\n              else\n                 lapl2(i,j,k)=-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k)\n                 lapl2(i,j,k)=lapl2(i,j,k)/(dx*dx)\n              end if\n           enddo\n        enddo\n     enddo\n\n     do i=1,nlon\n        do k=1,nlev\n           do j=2,nlat-1\n              ! y-direction\n              if(j==2)then\n                 lapl2(i,j,k)=lapl2(i,j,k)+(f(i,j-1,k)+f(i,j+1,k))/(dy*dy)\n              else if(j==nlat-1)then\n                 lapl2(i,j,k)=lapl2(i,j,k)+(f(i,j-1,k)+f(i,j+1,k))/(dy*dy)\n              else\n                 lapl2(i,j,k)=lapl2(i,j,k)+(-(1./12.)*f(i,j-2,k)+(4./3.) &\n                      *f(i,j-1,k) + (4./3.)*f(i,j+1,k)-(1./12.)*f(i,j+2,k)) &\n                      /(dy*dy)\n              end if\n           enddo\n        enddo\n     enddo\n     coeff(:,3:nlat-2,:)=-(5./2.)/(dx*dx)-(5./2.)/(dy*dy)\n     coeff(:,2,:)=-(5./2.)/(dx*dx)-2./(dy*dy)\n     coeff(:,nlat-1,:)=-(5./2.)/(dx*dx)-2./(dy*dy)\n     coeff(:,1,:)=-(5./2.)/(dx*dx)\n     coeff(:,nlat,:)=-(5./2.)/(dx*dx)\n  end select\n\nend subroutine laplace2_cart\n"}, {"instruction": "Write a Fortran subroutine named p2der2 that calculates the second derivative of a three-dimensional array f with respect to a parameter dp. The subroutine has 2 input parameters of type real,dimension(:,:,:) and real, and 2 output parameters of type real,dimension(:,:,:) and real,dimension(:,:,:), respectively.", "input": "", "output": "subroutine p2der2(f,dp,df2dp22,coeff)\n  !  as p2der, but\n  !     - the contribution of the local value is left out\n  !     - the coefficient 'coeff' of the local value is also calculated\n\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),intent(out) :: df2dp22,coeff\n  real,intent(in) :: dp\n  integer :: nlev,c,k\n\n  c=1\n  nlev=size(f,3)\n\n  select case (c)\n  case(1)\n     df2dp22(:,:,2:nlev-1)=(f(:,:,3:nlev)+f(:,:,1:nlev-2)) &\n          /(dp*dp)\n     coeff(:,:,2:nlev-1)=-2./(dp*dp)\n     df2dp22(:,:,1)=0.\n     df2dp22(:,:,nlev)=0.\n     coeff(:,:,1)=0.\n     coeff(:,:,nlev)=0.\n  case(2)\n     do k=3,nlev-2\n        df2dp22(:,:,k)=(-1./12.)*f(:,:,k-2)+(4./3.)*f(:,:,k-1) &\n             +(4./3.)*f(:,:,k+1)-(1./12.)*f(:,:,k+2)\n        df2dp22(:,:,k)=df2dp22(:,:,k)/(dp*dp)\n     enddo\n     coeff(:,:,3:nlev-2)=(-5./2.)/(dp*dp)\n     df2dp22(:,:,2)=(f(:,:,3)+f(:,:,1))/(dp*dp)\n     df2dp22(:,:,nlev-1)=(f(:,:,nlev)+f(:,:,nlev-2))/(dp*dp)\n     coeff(:,:,2)=-2./(dp*dp)\n     coeff(:,:,nlev-1)=-2./(dp*dp)\n     coeff(:,:,1)=0\n     coeff(:,:,nlev)=0\n     df2dp22(:,:,1)=0.\n     df2dp22(:,:,nlev)=0.\n  end select\n\nend subroutine p2der2\n"}, {"instruction": "Create a Fortran subroutine named boxnum to categorize two energy values into bins based on predefined energy and interval arrays. The subroutine takes 5 input parameters of type real, real, real, real, and integer, representing energies e1, e2, del, ener, and nbins respectively. It also has 4 output parameters of type real, real, integer, and integer, representing r1, r2, m1, and m2 respectively. The subroutine categorizes the input energies e1 and e2 into the appropriate bins based on the energy intervals and assigns the corresponding bin numbers and edges to the output parameters.", "input": "", "output": "subroutine boxnum (e1, e2, m1, m2, r1, r2, nbins, del, ener)\n\n! energies e1 and e2, and calls them m1 and m2.\n! r1 is the upper edge of the lower box, r2 is the lower edge of the\n! upper box.\n\n  implicit none\n\n  real,intent(in) :: e1,e2\n  real,intent(in) :: del(nbins), ener(nbins)\n  integer,intent(in) :: nbins\n  real,intent(out) :: r1,r2\n  integer,intent(out) :: m1,m2\n  integer :: i,j\n\n  do i=1,nbins\n    if (e1 < ener(i)+del(i)/2.) then\n      m1 = i\n      r1 = ener(i) + del(i)/2.\n      do j=1,nbins\n        if (e2 < ener(j)+del(j)/2.) then\n          m2 = j\n          r2 = ener(j) - del(j)/2.\n          return \n        endif\n      enddo\n      m2 = nbins\n      r2 = e2 - del(nbins)\n      return\n    endif\n  enddo\n  m1 = nbins+1\n  return\n\nend subroutine boxnum\n"}, {"instruction": "Write a Fortran subroutine named comp_coef to compute coefficients a1, b1, c1, d1, a2, b2, c2, and d2 using the input parameter phi of type real. The subroutine should have 1 input parameter of type real and 8 output parameters of type real.", "input": "", "output": "  subroutine comp_coef(phi, a1,b1,c1,d1,a2,b2,c2,d2)\n\n    ! compute coefficients a,b,c,d\n\n    real, intent(in) :: phi\n    real, intent(out):: a1,b1,c1,d1, a2,b2,c2,d2\n    \n    real :: phi2, s,c,sc,s2, delta,q, d, e1,e2\n    \n\n    phi2 = phi**2\n    \n    s = sin(phi)\n    c = cos(phi)\n    sc = s*c\n    s2 = s**2\n        \n    delta = phi - pi\n    !##q = miu2  ! ambiguous (not sure if should be the inverse)\n    q = miu1/miu2  ! mu_a/mu_b, a is where the contact measured from\n    \n    d = (sc-phi)*(delta**2-s2) + q*(delta-sc)*(phi2-s2)\n\n    e1 = s2-delta*phi+q*(phi2-s2)\n    c1 = s2*e1/d\n    d1 = sc*(e1-pi*tan(phi))/d\n    a1 = -1.-pi*c1-d1\n    b1 = -pi*d1\n\n    e2 = s2-delta**2+q*(delta*phi-s2)\n    c2 = s2*e2/d\n    d2 = sc*(e2-q*pi*tan(phi))/d\n    a2 = -1.-d2\n    b2 = 0.\n   \n\n    return\n  end subroutine comp_coef\n"}, {"instruction": "Create a Fortran subroutine named get_vgrid, which reads and processes input data from the file vgrid.in or its parent directory. The subroutine takes 3 input parameters of type character(len=*), integer, and integer, and produces 10 output parameters of type integer, integer, integer, real, real, real, real, real, real, and real.", "input": "", "output": "      subroutine get_vgrid(vgrid,np,nvrt1,ivcor,kz,h_s,h_c,theta_b,theta_f,ztot,sigma,sigma_lcl,kbp)\n!     (single-precision) routine to read in vgrid.in (either in the current dir or ../) \n!     not all outputs have meaningful values, depending on ivcor.\n!      implicit real*8(a-h,o-z)\n      character(len=*), intent(in) :: vgrid\n      integer, intent(in) :: np,nvrt1\n      integer, intent(out) :: ivcor,kz,kbp(np)\n      real, intent(out) :: h_s,h_c,theta_b,theta_f,ztot(nvrt1),sigma(nvrt1),sigma_lcl(nvrt1,np)\n\n      !local\n      logical :: lexist\n      \n      inquire(file=vgrid,exist=lexist)\n      if(lexist) then\n        open(19,file=vgrid,status='old')\n      else\n        inquire(file='../'//vgrid,exist=lexist)\n        if(lexist) then\n          open(19,file='../'//vgrid,status='old')\n        else\n          write(*,*)'unable to find vgrid.in'\n          stop\n        endif\n      endif\n\n      read(19,*)ivcor\n      select case(ivcor)\n        case(2) !sz\n          read(19,*) nvrt,kz,h_s !kz>=1\n          if(nvrt<2) stop 'nvrt<2'\n          if(kz<1) then !.or.kz>nvrt-2) then\n            write(*,*)'wrong kz:',kz\n            stop\n          endif\n          if(h_s<6) then\n            write(*,*)'h_s needs to be larger:',h_s\n            stop\n          endif\n\n          ! # of z-levels excluding \"bottom\" at h_s\n          read(19,*) !for adding comment \"z levels\"\n          do k=1,kz-1\n            read(19,*)j,ztot(k)\n            if(ztot(k)>=-h_s) then\n              print*, 'illegal z level:',k\n              stop\n            endif\n            if(k>1) then; if(ztot(k)<=ztot(k-1)) then\n              print*, 'z-level inverted:',k\n              stop\n            endif; endif\n          enddo !k\n          read(19,*) !level kz       \n          ! in case kz=1, there is only 1 ztot(1)=-h_s\n          ztot(kz)=-h_s\n\n          nsig=nvrt-kz+1 !# of s levels (including \"bottom\" & f.s.)\n          read(19,*) !for adding comment \"s levels\"\n          read(19,*)h_c,theta_b,theta_f\n          if(h_c<5.or.h_c>=h_s) then !large h_c to avoid 2nd type abnormality\n            print*, 'h_c needs to be larger avoid 2nd type abnormality; &\n     &do u want to continue? enter 1 to continue, or ctrl-c to abort:'\n            read*, itmp\n          endif\n          if(theta_b<0.or.theta_b>1) then\n            write(*,*)'wrong theta_b:',theta_b\n            stop\n          endif\n          if(theta_f<=0) then\n            write(*,*)'wrong theta_f:',theta_f\n            stop\n          endif\n\n          sigma(1)=-1 !bottom\n          sigma(nsig)=0 !surface\n          read(19,*) !level kz\n          do k=kz+1,nvrt-1\n            kin=k-kz+1\n            read(19,*) j,sigma(kin)\n            if(sigma(kin)<=sigma(kin-1).or.sigma(kin)>=0) then\n              write(*,*)'check sigma levels at:',k,sigma(kin),sigma(kin-1)\n              stop\n            endif\n          enddo !k\n          read(19,*) !level nvrt\n\n        case(1) !localized sigma\n          read(19,*)nvrt\n          do i=1,np\n            read(19,*)j,kbp(i),sigma_lcl(kbp(i):nvrt,i)\n          enddo !i\n        case default\n          write(*,*)'unknown ivcor:',ivcor\n          stop\n      end select\n      close(19)      \n\n      end subroutine get_vgrid\n"}, {"instruction": "Create a Fortran subroutine named cmp_pw_olap to calculate the overlap between plane waves. It should take 10 input parameters of types integer and complex*16 and 1 output parameter of type complex*16. The subroutine should use the imperative tone and reflect Fortran features.", "input": "", "output": "subroutine cmp_pw_olap(olap, indgq, ipwint, gindex, i_g0, ngq, ng, maxngq_barc, n1, n2, n3)\n  ! calculates overlap between plane waves from indgq\n  implicit none\n  complex*16, intent(out):: olap(ngq,ngq)\n  integer,   intent(in)  :: indgq(maxngq_barc)  !\n  integer,   intent(in)  :: gindex(ng,3)       ! all g-points\n  complex*16, intent(in) :: ipwint(ng)\n  integer, intent(in)    :: i_g0(2*n1+1,2*n2+1,2*n3+1)\n  integer,    intent(in) :: ngq, ng, maxngq_barc, n1, n2, n3\n  !\n  integer :: ipw, jpw, ig(3), idg\n  do ipw=1,ngq\n     olap(ipw,ipw) = ipwint(1)\n     do jpw=ipw+1,ngq\n        ig  = gindex(indgq(ipw)+1,:) - gindex(indgq(jpw)+1,:)\n        idg = i_g0(ig(1)+n1+1,ig(2)+n2+1,ig(3)+n3+1)\n        olap(ipw,jpw) = ipwint(idg+1)\n        olap(jpw,ipw) = conjg(ipwint(idg+1))\n     enddo\n  enddo\nend subroutine cmp_pw_olap\n"}, {"instruction": "Write a Fortran subroutine named cmp_pw_olap2 to calculate the overlap between plane waves from the given input parameters. The subroutine takes 11 input parameters of type integer and complex*16 and outputs a single complex*16 value. The subroutine should be designed to calculate the overlap matrix between plane waves based on the provided input parameters.", "input": "", "output": "subroutine cmp_pw_olap2(olap, indgq, ipwint, gindex, i_g0, ngq, ngq_barc, ng, maxngq_barc, n1, n2, n3)\n  ! calculates overlap between plane waves from indgq\n  implicit none\n  complex*16,intent(out) :: olap(ngq,ngq_barc)\n  integer,   intent(in)  :: indgq(maxngq_barc)  !\n  integer,   intent(in)  :: gindex(ng,3)       ! all g-points\n  complex*16, intent(in) :: ipwint(ng)\n  integer, intent(in)    :: i_g0(2*n1+1,2*n2+1,2*n3+1)\n  integer,    intent(in) :: ngq, ngq_barc, ng, maxngq_barc, n1, n2, n3\n  !\n  integer :: ipw, jpw, igv(3), idg\n  olap = 0.d0\n  do ipw=1,ngq_barc\n     do jpw=1,ngq\n        igv  = gindex(indgq(ipw)+1,:) - gindex(indgq(jpw)+1,:)   ! g_{ipw}-g_{jpw}\n        if ( abs(igv(1))<=n1 .and. abs(igv(2))<=n2 .and. abs(igv(3))<=n3 ) idg = i_g0(igv(1)+n1+1,igv(2)+n2+1,igv(3)+n3+1)+1\n        if (idg>0) olap(jpw,ipw) = ipwint(idg)  ! olap[jpw,ipw]=integrate[ (e^{i(g[ipw]-g[jpw])r},{r in interstitials}]/v_cell = <g_{jpw}|g_{ipw}>_{interstitials}\n     enddo\n  enddo\nend subroutine cmp_pw_olap2\n"}, {"instruction": "Write a Fortran subroutine named pw_get_short_length to find the number of unique lengths present. The subroutine takes 2 input parameters of type real(8) and integer, and 2 output parameters of type integer. The number of input arguments is 2 and the test_data type is ['real(8)', 'integer'], and the number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "subroutine pw_get_short_length(ngs, gind4, glen, nk)\n  ! this function find how many unique lengths are present\n  implicit none\n  integer, intent(out)    :: ngs, gind4(nk)\n  real(8), intent(in)     :: glen(nk)\n  integer, intent(in)     :: nk\n  !\n  integer    :: ipw, igl\n  real(8)    :: glprev\n  !\n  glprev=0.d0 ! notice that we remove g=0 by setting glprev to zero. make it negative if we want to inlcude g=0\n  igl=0\n  do ipw=1,nk\n     if ( abs(glen(ipw)-glprev) > 1e-10 ) then\n        igl=igl+1          ! how many different lengths\n        glprev = glen(ipw)\n     endif\n     gind4(ipw) = igl      ! gind4(ipw_long) = index_to_unique\n  enddo\n  ngs=igl\nend subroutine pw_get_short_length\n"}, {"instruction": "Create a Fortran subroutine named pw_get_short_and_phase to calculate the integral of the plane wave in the interstitials. The subroutine takes 9 input parameters of types integer, integer, real(8), integer, real(8), integer, integer, integer, integer and returns 2 output parameters of types real(8) and complex*16.", "input": "", "output": "subroutine pw_get_short_and_phase(glen0, phase, ngs, gind4, gind, glen, pos, mult, nk, nat, ndf)\n  ! this function calculated integral of the plane wave in the interstitials\n  ! for all vectors in gind array with length glen:\n  !  integrate[ exp(i g\\vr), {\\vr in interstitials}]\n  ! \n  ! we could use  function int1ipw from for_vxcnn.f90, which does the same thing, but for\n  ! a single vector\n  implicit none\n  real(8), intent(out)    :: glen0(ngs)\n  complex*16, intent(out) :: phase(ndf,ndf,ngs)\n  integer, intent(in)     :: gind(nk,3), gind4(nk)\n  real(8), intent(in)     :: glen(nk)\n  integer, intent(in)     :: mult(nat)\n  real(8), intent(in)     :: pos(3,ndf)\n  integer, intent(in)     :: ngs        ! length of the short arrays\n  integer, intent(in)     :: nk, nat, ndf\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  !\n  integer    :: ipw, igl, jgl, iat, ieq, jat, jeq, idf, jdf\n  real(8)    :: dpos(3)\n  complex*16 :: expg, two_pi_i\n  !\n  glen0=0.d0    ! glen0 stores only different lengths  (much smaller than number of all g-points)\n  jgl=0\n  do ipw=1,nk\n     !print *, 'ipw=', ipw, 'jgl=', jgl\n     if (gind4(ipw) .ne. jgl) then\n        jgl = gind4(ipw)\n        glen0(jgl) = glen(ipw) ! fancy way of setting smaller mesh of glen0 with inequivalent lengths only\n        !write(6,'(a,i3,a,f10.6)') 'glen0[',jgl,']=',glen0(jgl)\n     endif\n  enddo\n  if (jgl.ne.ngs) then\n     write(6,'(a,i4,a,i4)') 'error in pw_get_short_and_phase for_coulomb.f90 ngs=', ngs, 'while jgl=', jgl\n  endif\n  !\n  two_pi_i = 2.0d0*pi*cmplx(0.d0,1.d0,8)\n  phase(:,:,:) = cmplx(0.d0,0.d0,8)\n  idf=0\n  do iat = 1, nat\n     do ieq = 1, mult(iat)\n        idf=idf+1\n        jdf=0    \n        do jat=1,nat\n           do jeq=1,mult(jat)\n              jdf=jdf+1\n              if (idf .eq. jdf) then\n                 do ipw = 2, nk                 ! over all g's, excepy g=0\n                    igl = gind4(ipw)            ! igl is index in the shorter array\n                    phase(idf,jdf,igl) = phase(idf,jdf,igl) + 1.d0 ! phase for the entire set of g vectors which have equal length!\n                 enddo ! ipw\n              else\n                 dpos(1:3) = pos(1:3,idf)-pos(1:3,jdf)\n                 do ipw = 2, nk                 ! over all g's, excepy g=0\n                    expg = exp( -dot_product( gind(ipw,:), dpos) * two_pi_i )  ! exp(-(g*(r_i-r_j)*2*pi*1j)\n                    igl = gind4(ipw)            ! igl is index in the shorter array\n                    phase(idf,jdf,igl) = phase(idf,jdf,igl) + expg      ! phase for the entire set of g vectors which have equal length!\n                 enddo ! ipw\n              endif\n              !do igl=1,ngs\n              !   write(6,'(3i5,2x,2f12.4)') idf, jdf, igl, phase(idf,jdf,igl)\n              !end do\n           enddo ! jeq\n        enddo ! jat\n     enddo ! ieq\n  enddo ! iat\nend subroutine pw_get_short_and_phase\n"}, {"instruction": "Create a Fortran subroutine named make_date that takes two input parameters of type integer, representing an 8-digit date (yyyymmdd) and a 6-digit time (hhmmss). The subroutine should produce one output parameter of type character with a length of 24, representing the date and time in the format \"yyyy-mm-dd_hh:mm:ss.ffff\".", "input": "", "output": "subroutine make_date ( date , time , date_time_char )\n\n!  this routine takes an 8-digit date (yyyymmdd) and a\n!  6-digit time (hhmmss) and converts it to a 24-digit\n!  string (yyyy-mm-dd_hh:mm:ss.ffff).\n\n   integer , intent(in) :: date , &\n                           time\n\n   character (len=24) , intent(out) :: date_time_char\n\n\n   !  local data.\n\n   integer :: year , month , day , hour , minute , second , fraction\n\n   year = date / 10000\n   month = ( date - year*10000 ) / 100\n   day   =  date - year*10000 - month*100\n\n\n   hour = time / 10000\n   minute = ( time - hour*10000 ) / 100\n   second = time - hour*10000 - minute*100\n\n   fraction = 0\n\n   write ( date_time_char , &\n   fmt = '(i4.4,\"-\",i2.2,\"-\",i2.2,\"_\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i4.4) ') &\n           year , month ,    day ,    hour  , minute , second , fraction\n\nend subroutine make_date\n"}, {"instruction": "Write a Fortran subroutine named strtoarr, which takes an integer and a character array as input and returns an integer array as output. The subroutine converts the characters in the input array to their ASCII values and stores them in the output integer array. The input parameters consist of an integer and an array of characters with a specified length, and the output is an array of integers. ", "input": "", "output": "subroutine strtoarr(strin, chararr, n_str)\n  integer, intent(in) :: n_str\n  character(len=n_str), intent(in) :: strin\n  integer, intent(out) ::  chararr(n_str+1)\n  chararr = 32 ! space\n  do j=1,n_str\n     chararr(j) = ichar(strin(j:j))\n  enddo\n  chararr(n_str+1) = 124 ! '|'\nend subroutine strtoarr\n"}, {"instruction": "Create a Fortran subroutine named \"get_chmcycles\" to calculate the number of cycles per nops based on the input parameters nrchem and nropsm. The number of input parameters is 2, with test_data type ['integer', 'integer'], and the number of output parameters is 1, with test_data type ['integer'].", "input": "", "output": "  subroutine get_chmcycles(chmcycles, nrchem, nropsm)\n    !// --------------------------------------------------------------------\n    !// internal uio loop for chemistry/boundary layer mixing\n    !// number of cycles per nops when nropsm==3.\n    !//\n    !// ole amund sovde, november 2009\n    !// --------------------------------------------------------------------\n    implicit none\n    !// --------------------------------------------------------------------\n    !// input\n    integer, intent(in) :: nrchem, nropsm\n    !// output\n    integer, intent(out) :: chmcycles\n    !// --------------------------------------------------------------------\n    character(len=*), parameter :: subr = 'get_chmcycles'\n    !// --------------------------------------------------------------------\n\n    if (nrchem .eq. 1) then\n       chmcycles = 4\n       !// simple test to take nropsm into account,\n       if (nropsm .ge. 6 .and. nropsm .lt. 12) chmcycles = 2\n       if (nropsm .ge. 12) chmcycles = 1\n    else if (nrchem .eq. 2) then\n       chmcycles = 2\n       !// simple test to take nropsm into account\n       if (nropsm .ge. 6) chmcycles = 1\n    else\n       chmcycles = 1\n    end if\n\n    !// --------------------------------------------------------------------\n  end subroutine get_chmcycles\n"}, {"instruction": "Create a Fortran subroutine named stringupcase to convert a given input string to uppercase letters (English alphabet). The subroutine takes 1 input parameter of type character(len=*) and outputs 1 parameter of type character(len=*).", "input": "", "output": "  subroutine stringupcase(ucstr,instr)\n    !// --------------------------------------------------------------------\n    !// put a string into upper case letters (english alphabet).\n    !//\n    !// ole amund sovde, august 2009\n    !// --------------------------------------------------------------------\n    implicit none\n    !// --------------------------------------------------------------------\n    !// input\n    character(len=*),intent(in) :: instr\n    !// output\n    character(len=*),intent(out) :: ucstr\n\n    !// locals\n    character(len=*),parameter :: lc='abcdefghijklmnopqrstuvwxyz'\n    character(len=*),parameter :: uc='abcdefghijklmnopqrstuvwxyz'\n    integer :: i, n,strlen\n    !// --------------------------------------------------------------------\n\n    ucstr = instr\n    strlen = min(len(instr),len(ucstr))\n\n    do i = 1, strlen\n       !// find location of letter in lower case constant string\n       n = index( lc, instr(i:i))\n       !// if current substring is a lower case letter, make it upper case,\n       !// otherwise keep the input letter.\n       if ( n .ne. 0 ) then\n          ucstr(i:i) = uc(n:n)\n       else\n          ucstr(i:i) = instr(i:i)\n       end if\n    end do\n\n    !// --------------------------------------------------------------------\n  end subroutine stringupcase\n"}, {"instruction": "Create a Fortran subroutine named skewsymmetric to generate a skew-symmetric matrix from a given 3D vector. The input parameter is a real*8 array of size 3, and the output parameter is a real*8 array of size (3,3).", "input": "", "output": "    pure subroutine skewsymmetric(vector, s)\n      real*8, intent(in) :: vector(3)\n      real*8, intent(out) :: s(3,3)\n\n      s(1,:) = (/        0d0, -vector(3),  vector(2) /)\n      s(2,:) = (/  vector(3),        0d0, -vector(1) /)\n      s(3,:) = (/ -vector(2),  vector(1),        0d0 /)\n\n    end subroutine skewsymmetric\n"}, {"instruction": "Create a Fortran subroutine named \"photgrid\" to calculate the grid spacing and altitude grid for a photochemical model. The subroutine takes 3 input parameters of type integer, real(8), and real(8), and 2 output parameters of type real(8).", "input": "", "output": "subroutine photgrid(top_atmos, bottom_atmos, nz, z, dz)\n  implicit none\n\n  ! local variables\n  integer, intent(in) :: nz\n  real(8), intent(in) :: top_atmos, bottom_atmos \n  real(8), intent(out) :: z(nz), dz(nz)\n  \n  \n  real*8 :: dzgrid\n  integer :: i\n\n  dzgrid = (top_atmos - bottom_atmos)/nz\n  dz = dzgrid\n\n  z(1) = bottom_atmos + 0.5d0*dzgrid\n  do i=2,nz\n   z(i) = z(i-1) + dzgrid\n  enddo\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"vecadd\" to perform element-wise addition of two integer arrays and store the result in a third integer array. The subroutine takes 3 input parameters of type integer arrays and 1 output parameter of type integer array. The input arrays \"a\" and \"b\" are of length \"n\", and the output array \"c\" is also of length \"n\".", "input": "", "output": "   subroutine vecadd(a, b, c, n)\n      integer, intent(in) :: n\n      integer, intent(in) :: a(n), b(n)\n      integer, intent(out) :: c(n)\n      integer :: i\n      !dir$ omp offload target(mic)\n      !$omp parallel do\n      do i=1,n\n         c(i) = a(i) + b(i)\n      end do\n   end subroutine\n"}, {"instruction": "Write a Fortran subroutine named evolution_step to perform an evolution step for a given system. The subroutine takes 6 input parameters: n_nodes (integer), ktot (integer), t_ind (array of integers), t_tau (array of double precision), t_start (array of integers), and vect_in (array of double precision). It produces 1 output parameter named vect_out (array of double precision).", "input": "", "output": "subroutine evolution_step(t_start,t_ind,t_tau,vect_in,n_nodes,ktot,vect_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  \n  double precision,dimension(n_nodes),intent(in)::vect_in\n  double precision,dimension(n_nodes),intent(out)::vect_out\n  double precision,dimension(n_nodes)::pe\n\n  integer::i,j,jj\n  \n  pe=0\n  vect_out=0.0d0\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        pe(i)=pe(i)+t_tau(j)\n     end do\n  end do\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        jj=t_ind(j)\n        vect_out(jj)=vect_out(jj)+(t_tau(j)/pe(i))*vect_in(i)\n     end do\n  end do\n\nend subroutine evolution_step\n"}, {"instruction": "Write a Fortran subroutine named criterio_distancia to calculate the shortest path distances between nodes in a graph based on the input adjacency matrix. The subroutine takes 2 input parameters: an integer representing the number of nodes and a 2D array of double precision numbers representing the adjacency matrix. It returns 1 output parameter: a 2D array of double precision numbers representing the shortest path distances between nodes.", "input": "", "output": "subroutine criterio_distancia(mat_in,n_nodes,mat_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes\n  double precision,dimension(n_nodes,n_nodes),intent(in)::mat_in\n  double precision,dimension(n_nodes,n_nodes),intent(out)::mat_out\n\n  double precision::aa,azero\n  integer::ii,jj,kk,ll\n  logical,dimension(:),allocatable::filtro\n  double precision,dimension(:),allocatable::vect_aux\n\n  allocate(filtro(n_nodes))\n  allocate(vect_aux(n_nodes))\n  azero=0.0d0\n\n  do ii=1,n_nodes\n     vect_aux(:)=1.0d0/azero\n     filtro=.true.\n     vect_aux(ii)=0.0d0\n  \n     do while (count(filtro)>0)\n        ll=minloc(vect_aux(:),dim=1,mask=filtro)\n        do jj=1,n_nodes\n           if (filtro(jj).eqv..true.) then\n              if (vect_aux(jj)>(vect_aux(ll)+mat_in(jj,ll))) then\n                 vect_aux(jj)=vect_aux(ll)+mat_in(jj,ll)\n              end if\n           end if\n        end do\n        filtro(ll)=.false.\n     end do\n     mat_out(:,ii)=vect_aux(:)\n  end do\n\n\nend subroutine criterio_distancia\n"}, {"instruction": "Write a Fortran subroutine named matrix_fpt to perform a matrix computation. The subroutine takes 5 input parameters of types: integer, integer, integer array of size ktot, double precision array of size ktot, and integer array of size n_nodes+1. It also has 1 output parameter of type double precision array of size n_nodes x n_nodes.", "input": "", "output": "subroutine matrix_fpt (t_start,t_ind,t_tau,n_nodes,ktot,mat_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,dimension(n_nodes,n_nodes),intent(out)::mat_out\n\n  double precision,dimension(n_nodes)::pe\n  integer::ii,jj,gg,times,a\n\n  double precision,dimension(:),allocatable::pf,pf2,antes\n  logical::interr\n\n  mat_out  = 0.0d0\n\n  pe=0\n  do ii=1,n_nodes\n     do jj=t_start(ii)+1,t_start(ii+1)\n        pe(ii)=pe(ii)+t_tau(jj)\n     end do\n  end do\n\n  allocate(pf(n_nodes),pf2(n_nodes),antes(n_nodes))\n\n  do a=1,n_nodes\n\n     print*,a\n\n     pf=0.0d0\n\n     pf2=100000.0d0\n     pf2(a)=0.0d0\n\n     do times=1,1000000\n        \n        pf2(a)=0.0d0\n        pf=pf2\n        antes=pf2\n        pf2=0.0d0\n        \n        do ii=1,n_nodes\n           do jj=t_start(ii)+1,t_start(ii+1)\n              gg=t_ind(jj)\n              pf2(ii)=pf2(ii)+(t_tau(jj)*pf(gg))/pe(ii)\n           end do\n        end do\n        \n        antes=antes-pf2\n        interr=.false.\n        do ii=1,n_nodes\n           if (abs(antes(ii))>0.0010d0) then\n              interr=.true.\n              exit\n           end if\n        end do\n        \n        if (interr.eqv..false.) exit\n        \n        pf2=pf2+1.0d0\n     end do\n\n     pf2(a)=0.0d0\n\n     pf=pf2\n     \n     mat_out(:,a)=pf(:)\n\n     do ii=1,n_nodes\n        write(789,*) a, ii, pf(ii)\n     end do\n\n  end do\n\nend subroutine matrix_fpt\n"}, {"instruction": "Write a Fortran subroutine named detailed_balance_distance to calculate the detailed balance distance based on the provided inputs. The subroutine takes 6 input parameters of types integer, integer, integer array of size ktot, double precision array of size ktot, integer array of size n_nodes+1, and double precision. It also has 1 output parameter of type double precision.", "input": "", "output": "subroutine detailed_balance_distance(db_dist,p,t_start,t_ind,t_tau,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,intent(in)::p\n  double precision,intent(out)::db_dist\n\n\n  integer::i,j,ii,jj\n  double precision::overp\n  double precision::we_total,i_trans,j_trans\n\n  overp=1.0d0/p\n  db_dist=0.0d0\n\n  we_total=0\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        we_total=we_total+t_tau(j)\n     end do\n  end do\n\n  do i=1,n_nodes\n     do ii=t_start(i)+1,t_start(i+1)\n        j=t_ind(ii)\n        i_trans=t_tau(ii)\n        j_trans=0\n        do jj=t_start(j)+1,t_start(j+1)\n           if (i==t_ind(jj)) then\n              j_trans=t_tau(jj)\n              exit\n           end if\n        end do\n        db_dist=db_dist+(abs((i_trans-j_trans))/(we_total))**p\n     end do\n  end do\n\n  db_dist=(0.50d0*db_dist)**overp\n\n\nend subroutine detailed_balance_distance\n"}, {"instruction": "Create a Fortran subroutine named \"weight_core_new_k_total\" to calculate the new values of \"newktot\" and \"newnnodes\" based on the input parameters \"newktot\", \"newnnodes\", \"threshold\", \"t_ind\", \"t_tau\", \"t_start\", \"n_nodes\", and \"ktot\". The input parameter types are ['integer', 'integer', 'double precision', 'integer,dimension(ktot)', 'double precision,dimension(ktot)', 'integer,dimension(n_nodes+1)'], and the output parameter types are ['integer', 'integer'].", "input": "", "output": "subroutine weight_core_new_k_total(newktot,newnnodes,threshold,t_ind,t_tau,t_start,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  double precision,intent(in)::threshold\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n\n  integer,intent(out)::newktot,newnnodes\n\n  integer::i,j\n  logical,dimension(:),allocatable::filtro\n  double precision::pe\n\n  allocate(filtro(n_nodes))\n\n  filtro=.true.\n\n  do i=1,n_nodes\n     pe=0.0d0\n     do j=t_start(i)+1,t_start(i+1)\n        pe=pe+t_tau(j)\n     end do\n     if (pe<=threshold) filtro(i)=.false.\n  end do\n\n  newktot=0\n  do i=1,n_nodes\n     if (filtro(i).eqv..true.) then\n        do j=t_start(i)+1,t_start(i+1)\n           if (filtro(t_ind(j)).eqv..true.) then\n              newktot=newktot+1\n           end if\n        end do\n     end if\n  end do\n\n  newnnodes=count(filtro,dim=1)\n\n  deallocate(filtro)\n\nend subroutine weight_core_new_k_total\n"}, {"instruction": "Create a Fortran subroutine named extract_net_new_k_total to calculate the total number of new connections based on the input parameters. The subroutine takes 6 input parameters of type integer and array, and 1 output parameter of type integer. The input parameter types are ['integer', 'integer', 'integer', 'integer,dimension(ktot)', 'integer,dimension(n_nodes+1)', 'integer,dimension(newnnodes)'].", "input": "", "output": "subroutine extract_net_new_k_total(newktot,list_nodes,t_ind,t_start,newnnodes,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot,newnnodes\n  integer,dimension(ktot),intent(in)::t_ind\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  integer,dimension(newnnodes),intent(in)::list_nodes\n\n  integer,intent(out)::newktot\n\n  integer::i,j,tt\n  logical,dimension(:),allocatable::filtro\n\n  allocate(filtro(n_nodes))\n\n  filtro=.false.\n\n  do i=1,newnnodes\n     filtro(list_nodes(i)+1)=.true.\n  end do\n\n  newktot=0\n  do i=1,newnnodes\n     tt=list_nodes(i)+1\n     do j=t_start(tt)+1,t_start(tt+1)\n        if (filtro(t_ind(j)).eqv..true.) then\n           newktot=newktot+1\n        end if\n     end do\n  end do\n\n  deallocate(filtro)\n\nend subroutine extract_net_new_k_total\n"}, {"instruction": "Create a Fortran subroutine named dijkstra to implement Dijkstra's algorithm for finding the shortest path in a graph. The subroutine takes 8 input parameters of types integer, integer, integer, integer, integer, integer dimension(ktot), double precision dimension(ktot), and integer dimension(n_nodes+1). It also has 1 output parameter of type double precision dimension(n_nodes,dim_out).", "input": "", "output": "subroutine dijkstra (distancia,node,dim_out,directed,t_start,t_ind,t_tau,n_nodes,ktot)\n \n  implicit none\n  \n  integer,intent(in)::n_nodes,ktot,node,directed,dim_out\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,dimension(n_nodes,dim_out),intent(out)::distancia\n  \n  double precision,dimension(:),allocatable::vect_aux\n  logical,dimension(:),allocatable::filtro,filtro2\n  \n  double precision::azero\n  integer::i,j,g,h\n  \n  allocate(filtro(n_nodes),vect_aux(n_nodes))\n  \n  distancia=0.0d0\n  azero=0.0d0\n\n  if (node>0) then\n     \n     vect_aux=1.0d0/azero\n     filtro=.true.\n     vect_aux(node)=0.0d0\n     \n     do while (count(filtro)>0)\n        i=minloc(vect_aux(:),dim=1,mask=filtro)\n        do j=t_start(i)+1,t_start(i+1)\n           g=t_ind(j)\n           if (filtro(g).eqv..true.) then\n              if (vect_aux(g)>(vect_aux(i)+t_tau(j))) then\n                 vect_aux(g)=vect_aux(i)+t_tau(j)\n              end if\n           end if\n        end do\n        filtro(i)=.false.\n     end do\n     distancia(:,1)=vect_aux(:)\n\n  else\n\n     allocate(filtro2(n_nodes))\n     do h=1,n_nodes\n        vect_aux=1.0d0/azero\n        filtro=.true.\n        filtro2=.true.\n        vect_aux(h)=0.0d0\n        if (directed==0) then\n           do i=1,h-1\n              vect_aux(i)=distancia(h,i)\n              filtro2(i)=.false.\n           end do\n        end if\n        do while (count(filtro)>0)\n           i=minloc(vect_aux(:),dim=1,mask=filtro)\n           do j=t_start(i)+1,t_start(i+1)\n              g=t_ind(j)\n              if (filtro2(g).eqv..true.) then\n                 if (vect_aux(g)>(vect_aux(i)+t_tau(j))) then\n                    vect_aux(g)=vect_aux(i)+t_tau(j)\n                 end if\n              end if\n           end do\n\n           filtro(i)=.false.\n           filtro2(i)=.false.\n        end do\n        distancia(:,h)=vect_aux(:)\n     end do\n     deallocate(filtro2)\n\n  end if\n\n  deallocate(filtro,vect_aux)\n\nend subroutine dijkstra\n"}, {"instruction": "Create a Fortran subroutine named reshape_to_2_by_99_x_99 to reshape a 3D integer array into a 2D array. The input parameter is a 3D integer array, and the output parameter is a 2D integer array.", "input": "", "output": "    subroutine reshape_to_2_by_99_x_99(arr_in, arr_out)\n        integer, intent(in) :: arr_in(:, :, :)\n        integer, intent(out) :: arr_out(:, :)\n\n        arr_out = reshape(arr_in, [2, 99*99])\n    end subroutine reshape_to_2_by_99_x_99\n"}, {"instruction": "Write a Fortran subroutine named mpi_read_control_p to read integer and real values from a file specified by the input file path. The subroutine takes 2 input parameters of type integer and character*17, and 2 output parameters of type integer and real(8).", "input": "", "output": "subroutine mpi_read_control_p(infile_control,my_rank,itr_max,tol)\n\t\n\tinteger,intent(in)::my_rank\n\tinteger,intent(out)::itr_max\n\treal(8),intent(out)::tol\n\tcharacter*17,intent(in):: infile_control\n\t\n\topen(10,file=infile_control)\n\tread(10,*)itr_max,tol\n\tclose(10)\n\nend subroutine mpi_read_control_p\n"}, {"instruction": "Write a Fortran subroutine named interpltn to calculate the interpolating coefficients for a general interpolation. The subroutine takes 4 input parameters of type integer, integer, real array, and real array, and 1 output parameter of type real array. The subroutine performs calculations based on the input parameters to determine the interpolating coefficients.", "input": "", "output": "subroutine interpltn(nd,ng,co,ac,oc)\n!*************************************************\n! calculate the interpolating coefficent (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n! 2     , 3     , 5     , 9\n! 2**0+1, 2**1+1, 2**2+1, 2**3+1\n  implicit none\n! --------------------\n  integer  :: i,j\n  integer , intent(in)  :: nd,ng\n  real    , intent(in)  :: ac(nd,ng),oc(nd)\n  real    , intent(out) :: co(ng)\n  real                  :: dd(nd,ng),dc(nd)\n! --------------------\n! declare:\n!        'nd' is the number of dimensions of the field\n!        'ng' is the number of gridpoints neighbor to the position, which is to be interpolated, ng is equal to 2**nd\n!        'co' is the interpolating coefficients.\n!        'oc' is the position where to be interpolated \n!        'ac' is the index of the gridpoints, which is neighbor to the positioin\n! --------------------\n  do i=1,nd\n    if((oc(i)-ac(i,1))*(oc(i)-ac(i,2**(i-1)+1)).gt.0.0) then\n      print*,'interpltn: oc is not in the domain ',i,oc(i),ac(i,1),ac(i,2**(i-1)+1)\n      stop\n    endif\n  enddo\n  do i=1,nd\n    do j=1,ng\n      dd(i,j)=ac(i,j)-oc(i)\n    enddo\n    dc(i)=abs(ac(i,2**(i-1)+1)-ac(i,1))\n!    if(dc(i).le.0.0)stop 'grid arrange wrong!!!'            ! omitted by zhongjie he\n  enddo\n  do i=1,nd\n    if(dc(i).ne.0) then \n      do j=1,ng\n        dd(i,j)=dd(i,j)/dc(i)\n        if(dd(i,j).gt.0.0)then\n          dd(i,j)=dd(i,j)-1.0\n        else\n          dd(i,j)=dd(i,j)+1.0\n        endif\n        dd(i,j)=abs(dd(i,j))\n      enddo\n    else                                     !     added by zhongjie he \n      do j=1,ng\n        dd(i,j)=1.\n      enddo\n    endif\n  enddo\n  do j=1,ng\n    co(j)=1.0\n    do i=1,nd\n      co(j)=co(j)*dd(i,j)\n    enddo\n  enddo\n  return\nend subroutine interpltn\n"}, {"instruction": "Create a Fortran subroutine named \"interpltn_xie\" to calculate the interpolating coefficients for a general interpolation. The subroutine takes 7 input parameters of type [integer, integer, integer, integer, real, real, real] and 1 output parameter of type [real].", "input": "", "output": "subroutine interpltn_xie(nd,ng,co,ac,oc,ip,np,pv)\n!*************************************************\n! calculate the interpolating coefficent (general)\n! history: august 2007, coded by wei li.\n!\n!          march 31, 2009 by yuanfu xie for log(p)\n!          interpolation.\n!*************************************************\n! 2     , 3     , 5     , 9\n! 2**0+1, 2**1+1, 2**2+1, 2**3+1\n  implicit none\n! --------------------\n  integer  :: i,j,k,k1\n  integer , intent(in)  :: nd,ng,ip,np\n  real    , intent(in)  :: ac(nd,ng),oc(nd),pv(np)\n  real    , intent(out) :: co(ng)\n  real                  :: dd(nd,ng),dc(nd),p\n! --------------------\n! declare:\n!        'nd' is the number of dimensions of the field\n!        'ng' is the number of gridpoints neighbor to the position, which is to be interpolated, ng is equal to 2**nd\n!        'co' is the interpolating coefficients.\n!        'oc' is the position where to be interpolated \n!        'ac' is the index of the gridpoints, which is neighbor to the positioin\n! --------------------\n  do i=1,nd\n    if((oc(i)-ac(i,1))*(oc(i)-ac(i,2**(i-1)+1)).gt.0.0) then\n      print*,'interpltn: oc is not in the domain ',i,oc(i),ac(i,1),ac(i,2**(i-1)+1)\n      stop\n    endif\n  enddo\n  do i=1,nd\n    do j=1,ng\n      dd(i,j)=ac(i,j)-oc(i)\n    enddo\n    dc(i)=abs(ac(i,2**(i-1)+1)-ac(i,1))\n  enddo\n  do i=1,nd\n    if(dc(i).ne.0) then \n      do j=1,ng\n        dd(i,j)=dd(i,j)/dc(i)\n        if(dd(i,j).gt.0.0)then\n          ! log(p):\n          if (i .eq. ip) then\n            k1 = ac(i,j)\n            if (k1 .le. 1) then\n              dd(i,j) = 0.0\n            else\n              k = k1-1\n              p = pv(k)*dd(i,j)+(1.0-dd(i,j))*pv(k+1)\n              dd(i,j) = (log(p)-log(pv(k)))/(log(pv(k1))-log(pv(k)))\n            endif\n          else\n            dd(i,j)=dd(i,j)-1.0\n          endif\n        else\n          if (i .eq. ip) then\n            k = ac(i,j)\n            if (k .ge. np) then\n              dd(i,j) = 1.0\n            else\n              k1 = k+1\n              p = (1.0+dd(i,j))*pv(k)-dd(i,j)*pv(k1)\n              dd(i,j) = (log(pv(k1))-log(p))/(log(pv(k1))-log(pv(k)))\n            endif\n          else\n            dd(i,j)=dd(i,j)+1.0\n          endif\n        endif\n        dd(i,j)=abs(dd(i,j))\n      enddo\n    else                                     !     added by zhongjie he \n      do j=1,ng\n        dd(i,j)=1.\n      enddo\n    endif\n  enddo\n\n  do j=1,ng\n    co(j)=1.0\n    do i=1,nd\n      co(j)=co(j)*dd(i,j)\n    enddo\n  enddo\n  return\nend subroutine interpltn_xie\n"}, {"instruction": "Write a Fortran subroutine named gderiveit to calculate the general derivative of interior (general). The subroutine takes 3 input parameters of type real and returns 3 output parameters of type real. The input parameters are z1, z2, and z3, and the output parameters are a, b, and c.", "input": "", "output": "subroutine gderiveit(z1,z2,z3,a,b,c)\n!*************************************************\n! general derivative of interior (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  real  :: x,y\n  real , intent(in)  :: z1,z2,z3\n  real , intent(out) :: a,b,c\n! --------------------\n  x=z2-z1\n  y=z3-z2\n  a=-y/(x*x+x*y)\n  b=(-x+y)/(x*y)\n  c=x/(x*y+y*y)\n  return\nend subroutine gderiveit\n"}, {"instruction": "Write a Fortran subroutine named gderivelb to calculate the general derivative of the left boundary. The subroutine takes 3 input parameters of type real: z1, z2, and z3. It returns 3 output parameters of type real: a, b, and c.", "input": "", "output": "subroutine gderivelb(z1,z2,z3,a,b,c)\n!*************************************************\n! general derivative of left boundary (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  real  :: x,y\n  real , intent(in)  :: z1,z2,z3\n  real , intent(out) :: a,b,c\n! --------------------\n  x=z2-z1\n  y=z3-z2\n  a=(-2.0*x-y)/(x*x+x*y)\n  b=(x+y)/(x*y)\n  c=-x/(x*y+y*y)\n  return\nend subroutine gderivelb\n"}, {"instruction": "Write a Fortran subroutine named \"pstn2numb\" that transforms the position to a number (general), coded by Wei Li in August 2007. The subroutine takes 3 input parameters of type integer: nn, np(nn), nm(nn), and outputs one integer parameter nc. The subroutine computes the index of the gridpoint in a 1-dimensional field given the dimensions and gridpoint indices.", "input": "", "output": "subroutine pstn2numb(nn,np,nm,nc)\n!*************************************************\n! transform position to number (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer               :: pt,m,n\n  integer , intent(in)  :: nn\n  integer , intent(in)  :: np(nn),nm(nn)\n  integer , intent(out) :: nc\n! --------------------\n! declare:\n!        'nn' is the number of dimensions of the field\n!        'np' is the index of the gridpoint at each dimension\n!        'nm' is the total grid number of each dimensioin \n!        'nc' is the index of the gridpoint, when the field is translated to a 1 dimensional filed\n! --------------------\n  nc=np(1)\n  if(nn.eq.1)return\n  do n=2,nn\n    pt=np(n)-1\n    do m=1,n-1\n      pt=pt*nm(m)\n    enddo\n    nc=nc+pt\n  enddo\n  return\nend subroutine pstn2numb\n"}, {"instruction": "Create a Fortran subroutine named \"vrtclpstn8\" to determine the vertical position based on the provided parameters. The subroutine takes 4 input parameters of type integer, real, real, and real, and returns 2 output parameters of type real and integer. The subroutine is used to calculate the index of a given position in the vertical coordinate based on the pressure levels and limitations.", "input": "", "output": "subroutine vrtclpstn8(km,lm,pp,p,ps,is)\n!*************************************************\n! get vertical position (general)\n! history: september 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer  :: k\n  integer ,intent(in)  :: km\n  real ,   intent(in)  :: pp(km)\n  real ,   intent(in)  :: p,lm\n  real ,   intent(out) :: ps\n  integer ,intent(out) :: is\n! --------------------\n! declare:\n!        'km' is the number of levels of the field\n!        'pp' is the presure of each level\n!        'p'  is the presure of the position, which we want to get its index in the vertical coordinate\n!        'ps' is the index of the point in the vertical coordinate\n\n!        'lm' is a limitation to decide whether the observation is available (just used for the case: km=1)\n! --------------------\n  is=0\n  if(km.ge.2) then\n    do k=1,km-1\n      if((p-pp(k))*(p-pp(k+1)).gt.0.0)cycle\n      ps=k+abs(p-pp(k))/abs(pp(k+1)-pp(k))\n      is=1\n    enddo\n  elseif(km.eq.1) then\n    if(abs(p-pp(1)).le.lm) then\n      ps=1\n      is=1\n    endif\n  endif\n  return\nend subroutine vrtclpstn8\n"}, {"instruction": "Create a Fortran subroutine named zpconvert to calculate the pressure from a given height. The subroutine takes 4 input parameters of types integer, real, real, and real, and 2 output parameters of types real and integer. The input parameters are km, zz, pp, and z, while the output parameters are p and is. Ensure that the subroutine is coded properly to perform the required pressure calculation based on the given height and level data.", "input": "", "output": "subroutine zpconvert(km,zz,pp,z,p,is)\n!*************************************************\n! find pressure from height (general)\n! history: september 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer              :: k\n  integer ,intent(in)  :: km\n  real ,   intent(in)  :: zz(km),z\n  real ,   intent(in)  :: pp(km)\n  real ,   intent(out) :: p\n  integer ,intent(out) :: is\n! --------------------\n! declare:\n!        'km' is the number of levels of the field\n!        'zz' is the height of each level\n!        'pp' is the presure of each level\n!        'z'  is the height of point, which we want to get its presure\n!        'p'  is the presure calculated from the zz, pp, and z\n\n! --------------------\n  is=0\n  do k=1,km-1\n    if((z-zz(k))*(z-zz(k+1)).gt.0.0)cycle\n    p=pp(k)*abs(zz(k+1)-z)/abs(zz(k+1)-zz(k))+pp(k+1)*abs(z-zz(k))/abs(zz(k+1)-zz(k))\n    is=1\n  enddo\n  return\nend subroutine zpconvert\n"}, {"instruction": "Create a Fortran subroutine named checkpstn, which calculates the position of a given value within an array. The subroutine takes 3 input parameters of type integer, real, and real, and 1 output parameter of type integer.", "input": "", "output": "subroutine checkpstn(km,zz,z,kz)\n!*************************************************\n! find the position (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer  :: k\n  integer , intent(in)  :: km\n  real    , intent(in)  :: zz(km),z\n  integer , intent(out) :: kz\n! --------------------\n  kz=0\n  if(km.eq.1.and.zz(1).eq.z)then\n    kz=1\n    return\n  endif\n  do k=1,km-1\n    if((z-zz(k))*(z-zz(k+1)).gt.0.0)cycle\n    kz=k\n    exit\n  enddo\n  return\nend subroutine checkpstn\n"}, {"instruction": "Create a Fortran subroutine named obstogrid to calculate the position of an observation at the model grid. The subroutine takes 6 input parameters of type integer and real, and 3 output parameters of type real and integer.", "input": "", "output": "subroutine obstogrid(y0,x0,y00,x00,im,jm,x,y,is)\n!*************************************************\n! calculate the position of observation at the model grid.\n! history: feburary 2008, coded by zhongjie he.\n!*************************************************\n  implicit none\n  integer  :: i,j\n  integer , intent(in)  :: im,jm\n  real    , intent(in)  :: x0,y0\n  real    , intent(in)  :: x00(im,jm),y00(im,jm)\n  real    , intent(out) :: x,y\n  integer , intent(out) :: is\n!--------------------\n  is=0\n  x=0\n  y=0\n\n  if(x0.le.x00(1,1)) then\n    if(abs(x00(1,1)-x00(2,1)).le.1e-10) return \n    x=1-(x0-x00(1,1))/(x00(1,1)-x00(2,1))\n  endif\n  if(x0.ge.x00(im,jm)) then\n    if(abs(x00(im,jm)-x00(im-1,jm)).le.1e-10) return\n    x=im+(x0-x00(im,jm))/(x00(im,jm)-x00(im-1,jm))\n  endif\n  do i=2,im\n    if(x0.ge.x00(i-1,1) .and. x0.lt.x00(i,1)) then\n      if(abs(x00(i-1,1)-x00(i,1)).le.1e-10) return\n      x=i-1+(x0-x00(i-1,1))/(x00(i,1)-x00(i-1,1))\n    endif\n  enddo  \n\n  if(y0.le.y00(1,1)) then\n    if(abs(y00(1,1)-y00(1,2)).le.1e-10) return\n    y=1-(y0-y00(1,1))/(y00(1,1)-y00(1,2))\n  endif\n  if(y0.ge.y00(im,jm)) then\n    if(abs(y00(im,jm)-y00(im,jm-1)).le.1e-10) return\n    y=jm+(y0-y00(im,jm))/(y00(im,jm)-y00(im,jm-1))\n  endif\n  do j=2,jm\n    if(y0.ge.y00(1,j-1) .and. y0.lt.y00(1,j)) then\n      if(abs(y00(1,j-1)-y00(1,j)).le.1e-10) return\n      y=j-1+(y0-y00(1,j-1))/(y00(1,j)-y00(1,j-1))\n    endif\n  enddo\n  \n  if(x.ge.1 .and. x.le.im .and. y.ge.1 .and. y.le.jm) is=1\n\n  return\nend subroutine obstogrid\n"}, {"instruction": "Create a Fortran subroutine named \"scsmethod_help\" that takes 5 input parameters of type real(8) and 2 output parameters of type real(8). The inputs are rain, smi, smax, fc, and tn, while the outputs are roff and filtrn. This subroutine computes runoff and infiltration based on the modified scs method. Ensure that the imperative tone is used while providing the instructions.", "input": "", "output": "  subroutine scsmethod_help(rain,smi,smax,fc,tn,roff,filtrn)\n    real(8),intent(in) ::rain ,smi ,smax ,fc ,tn\n    real(8),intent(out)::roff ,filtrn\n\n    !local variables\n    real(8)::s ,si ,sp, smi_work \n\n    !initialize variables\n    roff   = 0.0\n    filtrn = rain\n\n    !compute runoff and infiltration based on modified scs method\n    if (rain.gt.0.0) then\n      if (smi.gt.fc/2.0) then\n        smi_work = min(smi,tn)\n        s        = smax*(1.0-(smi_work-fc/2.0)/(tn-fc/2.0))\n      else\n        s = smax\n      end if\n      si = 0.2*s\n      sp = 0.8*s\n      if (rain.gt.si) then\n        roff   = rain-si\n        roff   = min(roff*roff/(rain+sp) , rain)\n        filtrn = rain-roff\n      end if\n    end if\n\n  end subroutine scsmethod_help\n"}, {"instruction": "Write a Fortran subroutine named sumation to compute the element-wise sum of two arrays of integers. The subroutine takes 2 input arrays of integers and produces 1 output array of integers. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine sumation(a,b,d)\nimplicit none\ninteger,intent(in) :: a(:)\ninteger,intent(in) :: b(:)\ninteger,intent(out):: d(:)\ninteger :: i,n\n\nn = size(a)\ndo i = 1, n\nd(i) = a(i)+b(i)\nend do\nend subroutine sumation      \n"}, {"instruction": "Create a Fortran subroutine named quad_eq to solve a quadratic equation of the form ax^2 + bx + c = 0. The subroutine takes 3 input arguments of type real(16) (a, b, c) and returns 2 output arguments of type real(16) (result1, result2) representing the solutions to the quadratic equation. If the discriminant (b^2 - 4ac) is negative, the subroutine will print a message indicating that the result will be imaginary and return without computing the solutions.", "input": "", "output": "subroutine quad_eq(a, b, c, result1, result2) \n    !-b(+-)sqrt(b^2-4ac)\n    !------------------\n    !      2a\n    implicit none\n    real(16), intent(in) :: a, b, c\n    real(16), intent(out) :: result1, result2\n    real(16) :: inside_sqrt\n    \n    if ((b**2 - (4 * a * c)) < 0) then\n        print *, \"the result will be imaginary\"\n        return\n    end if\n    \n    inside_sqrt = b**2 - 4 * a * c\n    \n    result1 = (-b + sqrt(inside_sqrt))/2 * a\n    result2 = (-b - sqrt(inside_sqrt))/2 * a\n    \nend subroutine quad_eq\n"}, {"instruction": "Write a Fortran subroutine named chebyshev to compute the value of a Chebyshev polynomial of the first kind. The subroutine takes 2 input parameters of type integer and real(8), and 1 output parameter of type real(8). The input parameters are n and x, and the output parameter is phi.", "input": "", "output": "    subroutine chebyshev(n, x, phi)\n\n        integer, intent(in) :: n\n        real(8), intent(in) :: x\n        real(8), intent(out) :: phi\n\n        phi = cos(n * acos(x));\n\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named byte2bin to convert an input byte into an array of 8 binary digits. The number of input parameters is 1, with the test data type being 'integer'. The number of output parameters is 1, with the test data type being 'integer, dimension(8)'.", "input": "", "output": "subroutine byte2bin(inbyte,bin)\r\ninteger, intent(in) :: inbyte\r\ninteger, intent(out), dimension(8) :: bin\r\n\r\ninteger :: byte\r\n!----------------------------------------------------------------------!\r\n\r\nbyte = inbyte\r\n\r\nbin(1)=byte/128\r\nbyte=byte-bin(1)*128\r\nbin(2)=byte/64\r\nbyte=byte-bin(2)*64\r\nbin(3)=byte/32\r\nbyte=byte-bin(3)*32\r\nbin(4)=byte/16\r\nbyte=byte-bin(4)*16\r\nbin(5)=byte/8\r\nbyte=byte-bin(5)*8\r\nbin(6)=byte/4\r\nbyte=byte-bin(6)*4\r\nbin(7)=byte/2\r\nbyte=byte-bin(7)*2\r\nbin(8)=byte\r\n\r\nend subroutine byte2bin\r\n"}, {"instruction": "Create a Fortran subroutine named safe_open_old that takes two input arguments of type character(len=*) and returns two output arguments of type integer. This subroutine opens a file located in a specified directory with a given filename and assigns a logical unit number to it. If the file cannot be opened, the subroutine sets the error code and prints an error message.", "input": "", "output": "  subroutine safe_open_old( lun, dir, fname, ierr )\n    implicit none\n\n    ! input variables\n    character(len=*), intent(in) :: dir, fname\n\n    ! output variables\n    integer, intent(out) :: lun, ierr\n\n    ! local variables\n    character(len=130) :: tmp_fname\n\n    tmp_fname = trim(adjustl(dir))//'/'//trim(adjustl(fname))\n    open( newunit=lun, file=trim(tmp_fname), status='old', iostat=ierr )\n    if ( ierr /= 0 ) write(*,'(a,i3,2a)') 'error(',ierr,'): cannot open ',tmp_fname\n\n    return\n  end subroutine safe_open_old\n"}, {"instruction": "Write a Fortran subroutine named \"sub\" that extracts the first 5 characters from a given input string and assigns it to an output string. The input parameter is a string of type character(len=*), and the output parameter is also a string of type character(len=*).", "input": "", "output": "  subroutine sub(a,b)\n    character(len=*), intent(in) :: a\n    character(len=*), intent(out) :: b\n    b = ''\n    b = a(1:5)\n  end subroutine sub\n"}, {"instruction": "Create a Fortran subroutine named get_inti to calculate interstitial integrals for the difference between two wave vectors. The subroutine takes 4 input parameters: jipw (integer array), istpw (complex*16 array), nvk (integer), npw2apw (integer). It returns 1 output parameter inti (complex*16 array).", "input": "", "output": "subroutine get_inti(inti, jipw, istpw, nvk, npw2apw)\n  ! now we calculate interstitail integral for the difference g1-g2 (with g1 and g2 from hamiltonian basis)\n  !       inti[1,2] = integrate[ (ik - i(g1-g2))\\vr, {\\vr in interstitial}]  = <g1|e^{ik\\vr}|g2>\n  implicit none\n  complex*16, intent(out) :: inti(nvk,nvk)        ! output\n  integer,    intent(in)  :: jipw(nvk,nvk)        ! jipw is index for difference between two g points from vector file\n  complex*16, intent(in)  :: istpw(npw2apw)       ! interstitial integral integrate[ (ik - ig)\\vr, {\\vr in interstitial}] where k is averaged over all members of the star\n  integer,    intent(in)  :: nvk, npw2apw\n  !\n  integer :: iv1, iv2\n  !\n  inti = 0.d0\n  do iv1=1,nvk\n     do iv2=1,nvk\n        if ( jipw(iv1,iv2) >= 0 ) then\n           inti(iv1,iv2) = istpw(jipw(iv1,iv2)+1)\n        end if\n     end do\n  end do\nend subroutine get_inti\n"}, {"instruction": "Create a Fortran subroutine named loginterp that performs logarithmic interpolation in log-pressure space. It takes 2 input parameters of type real, dimension(:) and 2 output parameters of type real, dimension(:).", "input": "", "output": "  subroutine loginterp(presi, zi, z, pres)\n    ! interpolation function taken from pressz.f90\n    ! interpolates in log-pressure space\n    real, intent(in), dimension(:) :: presi, zi\n    real, intent(out), dimension(:) :: pres, z\n    integer k\n\n    do k=1, size(pres)\n       pres(k) = exp(log(presi(k))+log(presi(k+1)/presi(k))* &\n            (z(k)-zi(k))/(zi(k+1)-zi(k)))\n    end do\n  end subroutine loginterp\n"}, {"instruction": "Create a Fortran subroutine named convective_radius to calculate the convective radius based on the given mean background reflectivity value and area relation. The subroutine takes 2 input parameters of types real(kind=8) and character(len=16), and returns 1 output parameter of type real(kind=8).", "input": "", "output": "subroutine convective_radius(ze_bkg, area_relation, conv_rad)\n\n   implicit none\n\n   real(kind=8), intent(in)      :: ze_bkg\n   character(len=16), intent(in) :: area_relation\n   real(kind=8), intent(out)     :: conv_rad\n\n\n!  f2py directives ===========================================================\n\n   !f2py character(len=16), intent(in) :: area_relation\n   !f2py real(kind=8), intent(in)      :: ze_bkg\n   !f2py real(kind=8), intent(out)     :: conv_rad\n\n!  ===========================================================================\n\n\n!  given a mean background reflectivity value, we determine via a step\n!  function what the corresponding convective radius would be\n!\n!  higher background reflectivitives are expected to have larger convective\n!  influence on surrounding areas, so a larger convective radius would be\n!  prescribed\n\n   if (area_relation == 'small') then\n\n      if (ze_bkg < 30.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 35.d0 .and. ze_bkg < 40.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 40.d0 .and. ze_bkg < 45.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n\n   elseif (area_relation == 'medium') then\n\n      if (ze_bkg < 25.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 25.d0 .and. ze_bkg < 30.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 35.d0 .and. ze_bkg < 40.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n   elseif (area_relation == 'large') then\n\n      if (ze_bkg < 20.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 20.d0 .and. ze_bkg < 25.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 25.d0 .and. ze_bkg < 30.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n   elseif (area_relation == 'sgp') then\n\n      if (ze_bkg < 40.d0) then\n         conv_rad = 0.d0\n      elseif (ze_bkg >= 40.d0 .and. ze_bkg < 45.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 45.d0 .and. ze_bkg < 50.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 50.d0 .and. ze_bkg < 55.d0) then\n         conv_rad = 6000.d0\n      else\n         conv_rad = 8000.d0\n      endif\n      \n   else\n\n      stop\n\n   endif\n\n   return\n\n end subroutine convective_radius\n"}, {"instruction": "Create a Fortran subroutine named peakedness that takes 2 input parameters of type real(kind=8) and character(len=16), and 1 output parameter of type real(kind=8). The subroutine calculates the necessary peakedness value based on the background reflectivity and a specified peak relation. Use the imperative tone to define the subroutine.", "input": "", "output": " subroutine peakedness(ze_bkg, peak_relation, peak)\n\n   implicit none\n\n   real(kind=8), intent(in)      :: ze_bkg\n   character(len=16), intent(in) :: peak_relation\n   real(kind=8), intent(out)     :: peak\n\n\n!  f2py directives ===========================================================\n\n   !f2py character(len=16), intent(in) :: peak_relation\n   !f2py real(kind=8), intent(in)     :: ze_bkg\n   !f2py real(kind=8), intent(out)    :: peak\n\n!  ===========================================================================\n\n\n!  given a background reflectivity value, we determine what the necessary\n!  peakedness (or difference) has to be between a grid point's reflectivity\n!  and the background reflectivity in order for that grid point to be labeled\n!  convective\n\n   if (peak_relation == 'default') then\n\n      if (ze_bkg < 0.d0) then\n         peak = 10.d0\n      elseif (ze_bkg >= 0.d0 .and. ze_bkg < 42.43d0) then\n         peak = 10.d0 - ze_bkg**2 / 180.d0\n      else\n         peak = 0.d0\n      endif\n      \n   elseif (peak_relation == 'sgp') then\n\n      if (ze_bkg < 0.d0) then\n         peak = 14.d0\n      elseif (ze_bkg >= 0.d0 .and. ze_bkg < 42.43d0) then\n         peak = 14.d0 - ze_bkg**2 / 180.d0\n      else\n         peak = 4.d0\n      endif\n      \n   else\n\n      stop\n\n   endif\n\n   return\n\nend subroutine peakedness\n"}, {"instruction": "Write a Fortran subroutine named c_get_global_int to retrieve a global integer value using the C binding. The subroutine should take 1 input parameter of type character(kind=c_char) and 1 output parameter of type integer(kind=c_int64_t).", "input": "", "output": "        subroutine c_get_global_int(name, val) bind(c)\n            use iso_c_binding\n            implicit none\n            character(kind=c_char), intent(in)::name(*)\n            integer(kind=c_int64_t), intent(out)::val\n        end subroutine c_get_global_int\n"}, {"instruction": "Write a Fortran subroutine named dist to calculate the Euclidean distance between two n-dimensional points. The subroutine takes 2 input parameters of type real*8, dimension(:) and 1 output parameter of type real*8.", "input": "", "output": "subroutine dist(x, y, d)\n\n   implicit none\n\n   real*8, dimension(:), intent(in) :: x\n   real*8, dimension(:), intent(in) :: y\n   real*8, intent(out) :: d\n   \n   d = sqrt(sum((x - y)**2))\n\nend subroutine dist\n"}, {"instruction": "Write a Fortran subroutine named readval_l that checks whether a specific substring, specified by the 'name' parameter, exists within the input string 'string'. The subroutine takes 2 input parameters of type character(len=*) and 1 output parameter of type logical. The number and type of input parameters is ['character(len=*)', 'character(len=*)'], and the number and type of output parameters is ['logical'].", "input": "", "output": "  subroutine readval_l(string, name, value)\n\n    implicit none\n\n    character(len=*), intent(in)  :: string, name\n    logical,          intent(out) :: value\n\n    integer :: i\n\n    i = index(string, trim(name))\n    if (i == 0) then\n       value = .false.\n    else\n       value = .true.\n    end if\n\n  end subroutine readval_l\n"}, {"instruction": "Create a Fortran subroutine named foobar. The subroutine takes 2 optional integer input parameters and 1 integer output parameter. The purpose of the subroutine is to assign the value of 1 to the output parameter.", "input": "", "output": "  elemental subroutine foobar (b1,b2,b3)\n    integer, intent(out)           :: b1\n    integer, optional, intent(in)  :: b2, b3\n    b1 = 1\n  end subroutine foobar\n"}, {"instruction": "Create a Fortran subroutine named fitparabola to calculate the coefficients (a, b, c) and the chi-squared value of a parabola that best fits the given data points. The subroutine takes 3 input parameters of type real*8, real*8, and integer, representing the x-coordinates, y-coordinates, and the number of data points respectively. It also has 4 output parameters of type real*8, real*8, real*8, and real*8, representing the coefficients a, b, c, and the chi-squared value respectively.", "input": "", "output": "subroutine fitparabola(a, b, c, chi2, xw, fw, n)\n  implicit none\n  real*8, intent(out) :: a, b, c, chi2\n  real*8, intent(in)  :: xw(n), fw(n)\n  integer, intent(in) :: n\n  ! locals\n  real*8 :: s, sx, sxx, sxxx, sxxxx, sy, sxy, sxxy, x, y, den\n  integer :: i\n  do i=1,n\n     x = xw(i)\n     y = fw(i)\n     s     = s    + 1\n     sx    = sx   + x\n     sxx   = sxx  + x*x\n     sxxx  = sxxx + x*x*x\n     sxxxx = sxxxx+ x*x*x*x\n     sy    = sy   + y\n     sxy   = sxy  + x*y\n     sxxy  = sxxy + x*x*y\n  enddo\n  den = sxx**3 + s*sxxx**2 + sx**2*sxxxx - sxx*(2*sx*sxxx + s*sxxxx)\n  a = (sxx**2*sxxy - sx*sxxx*sxxy + sx*sxxxx*sxy + sxxx**2*sy -  sxx*(sxxx*sxy + sxxxx*sy))/den\n  b = (-sx*sxx*sxxy + s*sxxx*sxxy + sxx**2*sxy - s*sxxxx*sxy - sxx*sxxx*sy +  sx*sxxxx*sy)/den\n  c = (sx**2*sxxy - s*sxx*sxxy + s*sxxx*sxy + sxx**2*sy -  sx*(sxx*sxy + sxxx*sy))/den\n  \n  chi2=0\n  do i=1,n\n     chi2 = chi2 + (a+b*xw(i)+c*xw(i)*xw(i) - fw(i))**2\n  enddo\n  chi2 = chi2/n\nend subroutine fitparabola\n"}, {"instruction": "Write a Fortran subroutine named cardano to solve a cubic equation using Cardano's formula. The number of input parameters is 3, the test_data type is ['complex(8)', 'complex(8)', 'complex(8)']. The number of output parameters is 1, the test_data type is ['complex(8)'].", "input": "", "output": "  subroutine cardano(a,b,c,x)\n    !3\u6b21\u65b9\u7a0b\u5f0f\u3092\u30ab\u30eb\u30c0\u30ce\u306e\u516c\u5f0f\u306b\u3088\u308a\u89e3\u304f\n    !x**3 + a*x**2 + b*x + c = 0\n    implicit none\n    integer :: i\n    complex(8),intent(in) :: a,b,c\n    complex(8),parameter :: omega = (-1d0 + sqrt(cmplx(-3d0)))/2d0\n    complex(8) :: u,v,p,q,d\n    complex(8),intent(out) :: x(:)\n\n    p = b/3d0 - a**2/9d0\n    q = c/2d0 + a**3/27d0 -a*b/6d0\n    d = q**2+p**3\n    u = (-cmplx(q) + sqrt(cmplx(d)))**(1d0/3d0)\n\n    if(abs(u) /= 0.0d0) then\n      !uv = -p\n      v = -cmplx(p)/u\n\n      x(1) = u + v -cmplx(a)/3.0d0\n      x(2) = u*omega + v*omega**2 -cmplx(a)/3.0d0\n      x(3) = u*omega**2 + v*omega -cmplx(a)/3.0d0\n    else\n      v = (-cmplx(2*q))**(1.0d0/3.0d0)\n\n      x(1) = v -cmplx(a)/3.0d0\n      x(2) = v*omega -cmplx(a)/3.0d0\n      x(3) = v*omega**2 -cmplx(a)/3.0d0\n    endif\n  end subroutine cardano\n"}, {"instruction": "Create a Fortran subroutine named prep_netcdf_ocn_w to prepare ocean data for netCDF format. The subroutine takes 6 input parameters of types (integer, integer, integer, real, integer, real) and 1 output parameter of type real. The subroutine processes the input data to generate ocean data suitable for netCDF format and assigns the result to the output parameter.", "input": "", "output": "  subroutine prep_netcdf_ocn_w(maxi, maxj, maxk, data_i, data_o, iland, scale)\n    implicit none\n    integer, intent(in) ::maxi, maxj, maxk\n    real, intent(in) :: data_i(3,0:maxi,0:maxj,1:maxk)\n    real, intent(out) :: data_o(maxi, maxj, maxk+1)\n    integer, intent(in) :: iland(0:maxi+1,0:maxj+1)\n    real, intent(in) :: scale\n\n    integer :: i, j, k\n\n    do k = 1, maxk\n       do j = 1, maxj\n          do i = 1, maxi\n             if (iland(i,j) >= 90 .or. iland(i,j) > (maxk+1-k)) then\n                data_o(i,j,k) = -99999.0\n             else\n                data_o(i,j,k) = real(scale * data_i(3,i,j,maxk+1-k))\n             end if\n          end do\n       end do\n    end do\n    data_o(1:maxi,1:maxj,maxk+1) = -99999.0\n  end subroutine prep_netcdf_ocn_w\n"}, {"instruction": "Create a Fortran subroutine named twodee_tracer2 to process two-dimensional temperature data and land mask values. The subroutine takes 5 input parameters of types real, integer, integer, integer, and real, and has 1 output parameter of type real. This subroutine uses a where construct to assign values to the output parameter based on the land mask values.", "input": "", "output": "  subroutine twodee_tracer2(temper, temp1, maxi, maxj, iland, scale)\n    implicit none\n    real, intent(in) :: temper(maxi, maxj)\n    real, intent(out) :: temp1(maxi,maxj)\n    integer, intent(in) :: maxi, maxj\n    integer, intent(in) :: iland(0:maxi+1,0:maxj+1)\n    real, intent(in) :: scale\n\n    where (iland(1:maxi,1:maxj) >= 90)\n       temp1 = -99999.0\n    elsewhere\n       temp1 = real(scale * temper)\n    end where\n  end subroutine twodee_tracer2\n"}, {"instruction": "Create a Fortran subroutine named is_equal_arr to compare two real arrays for equality. The subroutine takes 3 input parameters of types integer, real(8) array, and real(8) array, and 1 output parameter of type logical. The subroutine checks if the elements of the two arrays are equal within a tolerance of 1e-4 and sets the output parameter accordingly.", "input": "", "output": "subroutine is_equal_arr(a, b, n, ans)\n    integer, intent(in) :: n\n    real(8), intent(in) ::a(n), b(n)\n    logical, intent(out) :: ans\n    integer :: i\n    real(8) :: tol = 1e-4\n    ans = .true.\n    \n    do i=1, n\n        if (abs(a(i)- b(i)) .ge. tol ) then\n            ans = .false.\n            return\n        end if\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"randos\" to generate an array of random numbers using the Marsaglia shift sequence algorithm. The subroutine takes 2 input parameters of type integer and produces 1 output parameter of type integer array. The input parameters are the seed and the number of random numbers to generate, and the output parameter is the array of generated random numbers.", "input": "", "output": "subroutine randos(seed,n,ys)\n    !grows a single seed into an array of seeds\n    implicit none\n    integer, intent(in) :: seed\n    integer, intent(in) :: n\n    integer, intent(out) :: ys(1:n)\n    integer :: i,y\n\n    !initialize\n    y = ieor(777755555,abs(seed))\n    !fill the array ys using marsaglia shift sequence with period 2**32 \u2212 1.\n    do i = 1,n\n        y = ieor( y , ishft(y,13) ) \n        y = ieor( y , ishft(y,-17) )\n        y = ieor( y , ishft(y,5) )\n        ys(i) = y\n    end do\nend subroutine randos\n"}, {"instruction": "Write a Fortran subroutine named get_xgwg that computes the Gauss-Legendre ordinates and weights on an interval. The number of input parameters is 3: an integer n, and two double precision numbers x1 and x2. The output parameters are two double precision arrays x and w, both of dimension n.", "input": "", "output": "subroutine get_xgwg(x1, x2, x, w, n)\n    ! gauleg.f90     p145 numerical recipes in fortran\n    ! compute x(i) and w(i)  i=1,n  gauss-legendre ordinates and weights\n    ! on interval -1.0 to 1.0 (length is 2.0)\n    ! use ordinates and weights for gauss legendre integration\n    ! after f2py implicit argument wrapping: x, w = get_xgwg(x1, x2, n)\n  implicit none\n  integer, intent(in) :: n\n  double precision, intent(in) :: x1, x2\n  double precision, dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  double precision :: p1, p2, p3, pp, xl, xm, z, z1\n  double precision, parameter :: eps=1.d-15\n\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.d0\n    do while(abs(z-z1) > eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\nend subroutine get_xgwg\n"}, {"instruction": "Create a Fortran subroutine named \"dhdt_vert_diff\" to calculate the vertical diffusive mass fluxes. The subroutine takes 9 input parameters of type ['double precision', 'double precision', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'logical'] and returns 1 output parameter of type ['double precision']. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes to specify the direction of data flow for each parameter.", "input": "", "output": "  subroutine dhdt_vert_diff(dhdt_kv, h, kv, xlow, xhigh, ylow, yhigh, layers, ol, redgrav)\n    implicit none\n\n    ! dhdt is evaluated at the centre of the grid box\n    double precision, intent(out) :: dhdt_kv(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: h(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: kv\n    integer, intent(in) :: xlow, xhigh, ylow, yhigh, layers, ol\n    logical, intent(in) :: redgrav\n\n    integer i, j, k\n\n    dhdt_kv = 0d0\n\n    ! calculate vertical diffusive mass fluxes\n    ! only evaluate vertical mass diff flux if more than 1 layer, or reduced gravity\n    if (layers .eq. 1) then\n      if (redgrav) then\n        do j = ylow, yhigh\n          do i = xlow, xhigh\n            dhdt_kv(i,j,1) = kv/h(i,j,1)\n          end do\n        end do\n      end if\n    else if (layers .gt. 1) then\n      ! if more than one layer, need to have multiple fluxes\n      do k = 1, layers\n        do j = ylow, yhigh\n          do i = xlow, xhigh\n            if (k .eq. 1) then ! in top layer\n              dhdt_kv(i,j,k) = kv/h(i,j,k) - kv/h(i,j,k+1)\n            else if (k .eq. layers) then ! bottom layer\n              dhdt_kv(i,j,k) = kv/h(i,j,k) - kv/h(i,j,k-1)\n            else ! mid layer/s\n              dhdt_kv(i,j,k) = 2d0*kv/h(i,j,k) -  &\n                  kv/h(i,j,k-1) - kv/h(i,j,k+1)\n            end if\n          end do\n        end do\n      end do\n    end if\n\n    return\n  end subroutine dhdt_vert_diff\n"}, {"instruction": "Write a Fortran subroutine named \"epade\" to calculate the value of the Pad\u00e9 approximant at given complex points. The subroutine takes 2 input parameters of type complex(kind=16) for points in the complex plane and Pad\u00e9 coefficients, and 1 output parameter of type complex(kind=16) for the values of the Pad\u00e9 approximant at the given points.", "input": "", "output": "subroutine epade(z,x,f)\n    ! returns the value of the pad\u00e9 approximant at the points z.\n    implicit none\n    complex(kind=16),intent(in) :: z(:)  ! points in the complex plane\n    complex(kind=16),intent(in) :: x(:)  ! pade coefficients\n    complex(kind=16),intent(out) :: f(:) ! values of the pade approximant at the points z.\n    integer :: i,r\n    complex(kind=16),allocatable :: num(:),denum(:)\n    r = size(x)/2\n    allocate(num(size(z)),denum(size(z)))\n    num = 0q0\n    denum = 0q0\n    do i=1,r\n        num = num + x(i)*z**(i-1)\n        denum = denum + x(r+i)*z**(i-1)\n    enddo  \n    denum = denum + z**r\n    f = num/denum\n    deallocate(num,denum)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named exist_netcdf_file to check the existence of a specified file. The subroutine should take 1 input parameter with test_data type ['character(*)'] to represent the file name, and 1 output parameter with test_data type ['logical'] to indicate the existence of the file. Use the imperative tone in your instructions.", "input": "", "output": "        subroutine exist_netcdf_file(ncfname, l_exist)\n            character(*), intent(in)  :: ncfname\n            logical,      intent(out) :: l_exist\n\n            ! check whether file exists\n            inquire(file=ncfname, exist=l_exist)\n        end subroutine exist_netcdf_file\n"}, {"instruction": "Write a Fortran subroutine named readvelocityk to read and process optics matrix elements. The subroutine takes 2 input arguments of type integer and 3 output arguments of type complex*16, integer, and integer.", "input": "", "output": "subroutine readvelocityk(vel, ne, fh_m, nb_min, nb_max)!, nemin, nbands)\n  implicit none\n  complex*16, intent(out) :: vel(ne,ne,3)\n  integer, intent(out) :: nb_min, nb_max\n  integer, intent(in) :: fh_m, ne!, nemin, nbands\n  ! locals\n  integer      :: iikp, i1, i2, ib1, ib2, ixyz\n  real*8       :: wemin, wemax, de\n  character*10 :: kname\n  complex*16   :: o(3)\n  \n  vel = 0\n!!! reading optics matrix elements\n  read(fh_m,9010) iikp,nb_min,nb_max,wemin,wemax,kname\n  do i1=nb_min,nb_max\n     do i2=i1,nb_max\n        read(fh_m, 9040) ib1,ib2, o(1), o(2), o(3), de\n        if (i1.ne.ib1 .or. i2.ne.ib2) then\n           print *, 'error', i1, ib1, i2, ib2\n        endif\n        !if (i1.ge.nemin .and. i1.lt.nemin+nbands .and. i2.ge.nemin .and. i2.lt.nemin+nbands) then\n        if (i1.le.ne .and. i2.le.ne) then\n           do ixyz=1,3\n              vel(i1,i2,ixyz) = o(ixyz)\n              if (i2.ne.i1) then\n                 vel(i2,i1,ixyz) = conjg(o(ixyz))\n              endif\n           enddo\n        endif\n     enddo\n  enddo\n  if (nb_max.gt.ne) nb_max = ne\n!9010 format(/,2x,' kp:',i6,' nemin nemax : ',2i5, ' de:',2f5.2,' k:',a10 /)\n9010 format(/,2x,4x,i6,15x,2i5,4x,2f5.2,3x,a10 /)\n9040 format(3x,2i4,6e13.6,f13.8)\nend subroutine readvelocityk\n"}, {"instruction": "Write a Fortran subroutine named functionphieval to calculate the value of a function based on the input parameters. The number of input arguments is 4 and the test_data type is [real, real, real, real]. The number of output arguments is 1 and the test_data type is [real]. The subroutine computes the value of the functionphi using the formula functionphi = ( x + v2*sin(2*(x-psi)) - phi0 ). Use the \"intent(in)\" and \"intent(out)\" attributes to specify the input and output parameters.", "input": "", "output": "      subroutine functionphieval(x, v2, psi, phi0, functionphi)\n        implicit none\n        real, intent(in)  :: x, v2, psi, phi0\n        real, intent(out) :: functionphi\n\n        functionphi = ( x + v2*sin(2*(x-psi)) - phi0 ) \n\n      end subroutine functionphieval\n"}, {"instruction": "Create a Fortran subroutine named tensor_inner_product_3x3 to compute the inner product of two 3x3 tensors. The subroutine should take 2 input parameters of type real(8), dimension(3,3) and an output parameter of type real(8).", "input": "", "output": "        subroutine tensor_inner_product_3x3(a,b,t)\n            \n            implicit none\n            real(8), dimension(3,3), intent(in) :: a, b\n            real(8), intent(out) :: t!, tx\n\n            !tx = sum(sum(a*b,2))\n            \n            t = a(1,1)*b(1,1) + a(1,2)*b(1,2) + a(1,3)*b(1,3) \n            t = t + a(2,1)*b(2,1) + a(2,2)*b(2,2) + a(2,3)*b(2,3)\n            t = t + a(3,1)*b(3,1) + a(3,2)*b(3,2) + a(3,3)*b(3,3)                \n\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"hencky_1d\" to calculate the first Piola-Kirchhoff stress, the second Piola-Kirchhoff stress, and the strain energy. The subroutine has 3 input parameters of type real(8), and 3 output parameters of type real(8). Ensure the input and output parameters are appropriately labeled and assigned within the subroutine.", "input": "", "output": "        subroutine hencky_1d(mu, etr, ei, dwtr, d2wtr, energye)\n\n            implicit none\n            real(8), intent(in) :: mu, etr(3,1), ei(3,3,3)\n            real(8) :: g, eps(3), vdwtr(3)\n            real(8), intent(out) :: dwtr(3,3), d2wtr(3,3), energye\n\n            eps(:) = 0.d0\n\n            g = mu\n\n            eps=[etr(1,1), etr(2,1), etr(3,1)]\n\n            vdwtr(:) = 2*g*eps(:)\n\n            dwtr(1, 1:3) = [vdwtr(1),    0.0d0,    0.0d0]\n            dwtr(2, 1:3) = [   0.0d0, vdwtr(2),    0.0d0]\n            dwtr(3, 1:3) = [   0.0d0,    0.0d0, vdwtr(3)]\n\n            d2wtr(1, 1:3) = [2*g,    0.0d0,    0.0d0]\n            d2wtr(2, 1:3) = [   0.0d0, 2*g,    0.0d0]\n            d2wtr(3, 1:3) = [   0.0d0,    0.0d0, 2*g]\n\n            energye = g*(eps(1)**2 + eps(2)**2 + eps(3)**2)\n\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named entropy_fd to calculate the entropy based on given occupancy data and temperature factor. The subroutine takes 2 input parameters of type real(8) and 1 output parameter of type real(8). The number of input arguments is 2, and the test_data type is [real(8), real(8)]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "  subroutine entropy_fd( eentropy, ekbt, occ )\n    implicit none\n    real(8), intent(out) :: eentropy\n    real(8), intent(in)  :: ekbt\n    real(8), intent(in)  :: occ(:,:,:)\n    real(8) :: factor1,factor2,sf,f,g\n    integer :: n,k,s,nb,nk,ns\n    nb=size(occ,1)\n    nk=size(occ,2)\n    ns=size(occ,3)\n    factor1=ns/2.0d0  ! ns=1: factor1=0.5,  ns=2: factor1=1.0\n    factor2=2.0d0/ns  ! ns=1: factor2=2.0,  ns=2: factor2=1.0\n    eentropy=0.0d0\n    do s=1,ns\n    do k=1,nk\n    do n=1,nb\n       sf=0.0d0\n       f=occ(n,k,s)*factor1\n       if ( f > 0.0d0 ) sf=sf-f*log(f)\n       g=1.0d0-f\n       if ( g > 0.0d0 ) sf=sf-g*log(g)\n       eentropy=eentropy+factor2*ekbt*sf\n    end do\n    end do\n    end do\n  end subroutine entropy_fd\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_n2t\" to stagger a 3D array of non-staggered data to the mass grid of an Arakawa C stagger. The subroutine should have 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real.", "input": "", "output": "  subroutine arakawa_c_n2t(datain, nx, ny, nz, dataout)\n    \n    ! staggers a 3d array of data from the non-staggered points\n    ! to the mass grid of an arakawa c stagger.\n\n    implicit none\n    integer, intent(in)                :: nx\n    integer, intent(in)                :: ny\n    integer, intent(in)                :: nz\n    real, intent(in)                   :: datain(nx,ny,nz)\n    real, intent(out)                  :: dataout(nx,ny,nz)\n   \n    integer                            :: i,j,k\n    print *, 'staggering to t grid (arakawa c)'\n    do k = 1, nz\n      do j = 1, ny-1\n        do i = 1, nx-1\n          dataout(i,j,k) = 0.25 * ( datain(i,j,k)    + &\n                                    datain(i+1,j,k)  + &\n                                    datain(i+1,j+1,k)+ &\n                                    datain(i,j+1,k) )\n        enddo\n        ! fill unused rightmost column\n        dataout(nx,j,k) = dataout(nx-1,j,k)\n      enddo\n      ! fill unused uppermost row\n      dataout(:,ny,k) = dataout(:,ny-1,k)\n    enddo\n    return\n  end subroutine arakawa_c_n2t\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_t2n\" that destaggers a WRF Arakawa C grid from staggered thermodynamic points to non-staggered points. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The input parameters represent the dimensions of the staggered thermodynamic points and the input array, while the output parameter represents the destaggered array. The subroutine returns an array that is one element larger in each direction than the input array.", "input": "", "output": "  subroutine arakawa_c_t2n(datain,nx_t,ny_t,nz,dataout)\n\n    ! destaggers a wrf arakawa c from the staggered thermodynamic\n    ! points to the non-staggered points.   note that this routine\n    ! returns an array that is one element larger in each direction\n    ! than the input array.\n    !\n    !  example:  input 3x3 \"t\" points, return 4x4 \"n\" points\n    !\n    !           n   n   n   n\n    !             t   t   t\n    !           n   n   n   n \n    !             t   t   t\n    !           n   n   n   n\n    !             t   t   t \n    !           n   n   n   n\n\n    implicit none\n\n    integer, intent(in)       :: nx_t\n    integer, intent(in)       :: ny_t    \n    integer, intent(in)       :: nz\n    real, intent(in)          :: datain(nx_t,ny_t,nz)       \n    real, intent(out)         :: dataout(nx_t+1,ny_t+1,nz)   \n\n    integer                   :: i,j,k\n\n    vertical_loop:  do k=1,nz\n\n      ! first, compute all of the interior points\n\n      do j = 2, ny_t\n        do i = 1, nx_t\n\n           dataout(i,j,k) = 0.25*( datain(i-1,j-1,k) + datain(i-1,j,k) + &\n                                  datain(i,j,k) + datain(i,j-1,k) )\n\n        enddo\n      enddo\n\n      ! now, extrapolate upper and lower rows, except corner points\n\n      do i = 2, nx_t\n \n        dataout(i,1,k) = 2.0* dataout(i,2,k)-dataout(i,3,k)\n        dataout(i,ny_t+1,k) = 2.0*dataout(i,ny_t,k)-dataout(i,ny_t-1,k)\n\n      enddo\n\n      ! extrapolate left and right columns, except corner points\n\n      do j = 2, ny_t\n    \n        dataout(1,j,k) = 2.0*dataout(2,j,k)-dataout(3,j,k)\n        dataout(nx_t+1,j,k) = 2.0*dataout(nx_t,j,k)-dataout(nx_t-1,j,k)\n\n      enddo\n\n      ! compute corner point values by solving for 4 point average\n\n      dataout(1,1,k) = 4.0 * datain(1,1,k) - &\n                             dataout(1,2,k) - &\n                             dataout(2,2,k) - &\n                             dataout(2,1,k)\n      dataout(1,ny_t+1,k) = 4.0 * datain(1,ny_t,k) - &\n                                  dataout(1,ny_t,k) - &\n                                  dataout(2,ny_t+1,k) - &\n                                  dataout(2,ny_t,k)\n      dataout(nx_t+1,ny_t+1,k) = 4.0 * datain(nx_t,ny_t,k) - &\n                                       dataout(nx_t,ny_t,k) - &\n                                       dataout(nx_t,ny_t+1,k) - &\n                                       dataout(nx_t+1,ny_t,k)\n      dataout(nx_t+1,1,k) = 4.0 * datain(nx_t,1,k) - &\n                                dataout(nx_t,1,k) - &\n                                dataout(nx_t,2,k) - &\n                                dataout(nx_t+1,2,k)\n\n    enddo vertical_loop       \n    return\n  end subroutine arakawa_c_t2n\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_u2n\" to destagger data from the \"u\" grid to the non-staggered grid. The subroutine takes 4 input parameters of types integer, integer, integer, and real, and returns 1 output parameter of type real. The input parameters represent the dimensions and data of the \"u\" grid, and the output parameter represents the destaggered data on the non-staggered grid.", "input": "", "output": "  subroutine arakawa_c_u2n(datain,nx_u,ny_u,nz,dataout)\n\n    ! destaggers from the wrf \"u\" grid to the non-staggered grid.  the\n    ! return array will be 1 element larger in the y direction than\n    ! the input array.  example:\n    !\n    !   input 4x3 \"u\" grid, return 4x4 \"n\" grid:\n    !\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n\n    implicit none\n\n    integer,  intent(in)   :: nx_u\n    integer,  intent(in)   :: ny_u\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_u,ny_u,nz)\n    real,     intent(out)  :: dataout(nx_u,ny_u+1,nz)\n\n    integer                :: i,k\n    integer                :: nx,ny\n\n    nx = nx_u\n    ny = ny_u+1\n\n    do k = 1, nz\n   \n      ! linear interpolation along each column, except top/bottom rows\n      do i = 1, nx\n   \n        ! average of points above and below to fill interior rows \n        dataout(i,2:ny_u,k) = 0.5*(datain(i,1:ny_u-1,k)+datain(i,2:ny_u,k))\n \n        ! fill bottom row\n        dataout(i,1,k) = 2.0 * dataout(i,2,k) - dataout(i,3,k)\n\n        ! fill top row\n        dataout(i,ny,k) = 2.0 * dataout(i,ny-1,k) - dataout(i,ny-2,k)\n\n      enddo\n    enddo \n    return\n  end subroutine arakawa_c_u2n\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_v2n\" that destaggers the input \"v\" grid data to a non-staggered grid. The subroutine takes 4 input parameters of type ['integer', 'integer', 'integer', 'real'] representing nx_v, ny_v, nz, and datain, and returns 1 output parameter of type ['real'] representing dataout. The subroutine performs linear interpolation and boundary filling to generate the non-staggered grid data.", "input": "", "output": " subroutine arakawa_c_v2n(datain,nx_v,ny_v,nz,dataout)\n\n    ! destaggers from the wrf \"v\" grid to the non-staggered grid.  the\n    ! return array will be 1 element larger in the x direction than\n    ! the input array.  example:\n    !\n    !   input 3x4 \"v\" grid, return 4x4 \"n\" grid:\n    !\n    !            n v n v n v n\n    !           \n    !            n v n v n v n\n    !       \n    !            n v n v n v n\n    !        \n    !            n v n v n v n\n\n    implicit none\n    integer,  intent(in)   :: nx_v\n    integer,  intent(in)   :: ny_v\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_v,ny_v,nz)\n    real,     intent(out)  :: dataout(nx_v+1,ny_v,nz)\n\n    integer                :: j,k\n    integer                :: nx,ny\n\n    nx = nx_v + 1\n    ny = ny_v\n\n    do k = 1, nz\n\n      ! linear interpolation along each row, except left/right columns\n      do j = 1, ny\n\n        ! average of points above and below to fill interior rows \n        dataout(2:nx_v,j,k) = 0.5*(datain(1:nx_v-1,j,k)+datain(2:nx_v,j,k))\n\n        ! fill left column\n        dataout(1,j,k) = 2.0 * dataout(2,j,k) - dataout(3,j,k)\n\n        ! fill top row\n        dataout(nx,j,k) = 2.0 * dataout(nx-1,j,k) - dataout(nx-2,j,k)\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_v2n\n"}, {"instruction": "Create a Fortran subroutine named arakawa_c_v2t to destagger data from the \"v\" grid to the mass grid. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real.", "input": "", "output": " subroutine arakawa_c_v2t(datain,nx_v,ny_v,nz,dataout)\n\n    ! destaggers from the wrf \"v\" grid to the mass grid.  the\n    ! return array will be 1 element smaller in the y direction than\n    ! the input array.  example:\n    !\n    !   input 3x4 \"v\" grid, return 3x3 \"t\" grid:\n    !\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n\n    implicit none\n    integer,  intent(in)   :: nx_v\n    integer,  intent(in)   :: ny_v\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_v,ny_v,nz)\n    real,     intent(out)  :: dataout(nx_v,ny_v-1,nz)\n\n    integer                :: j,k\n    integer                :: nx,ny\n\n    nx = nx_v \n    ny = ny_v - 1\n\n    do k = 1, nz\n\n      ! linear interpolation along each column\n      do j = 1, ny\n\n        dataout(:,j,k) = 0.5*(datain(:,j,k) + datain(:,j+1,k))\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_v2t\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_u2t\" that performs destaggering from the \"u\" grid to the mass grid. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The purpose of the subroutine is to interpolate the input data and store the results in the output array, where the x-dimension of the output array is one element smaller than the input array. The subroutine uses linear interpolation along each row to achieve this.", "input": "", "output": " subroutine arakawa_c_u2t(datain,nx_u,ny_u,nz,dataout)\n\n    ! destaggers from the wrf \"u\" grid to the mass grid.  the\n    ! return array will be 1 element smaller in the x direction than\n    ! the input array.  example:\n    !\n    !   input 4x3 \"u\" grid, return 3x3 \"t\" grid:\n    !\n    !                           \n    !            u t u t u t u\n    !                             \n    !            u t u t u t u\n    !                             \n    !            u t u t u t u\n    !                           \n    implicit none\n    integer,  intent(in)   :: nx_u\n    integer,  intent(in)   :: ny_u\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_u,ny_u,nz)\n    real,     intent(out)  :: dataout(nx_u-1,ny_u,nz)\n\n    integer                :: i,k\n    integer                :: nx,ny\n\n    nx = nx_u - 1\n    ny = ny_u\n\n    do k = 1, nz\n\n      ! linear interpolation along each row     \n      do i = 1, nx\n\n        dataout(i,:,k) = 0.5*(datain(i,:,k) + datain(i+1,:,k))\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_u2t\n"}, {"instruction": "Write a Fortran subroutine named wlevs2hlevs that vertically destaggers an array from the full w levels to the half levels. The subroutine takes 4 input parameters of types integer, integer, integer, and real. The output parameter is of type real.", "input": "", "output": "  subroutine wlevs2hlevs(datain,nx,ny,nz_in,dataout)\n\n    ! vertically destaggers an array from the full w levels to\n    ! the half levels.  output array is one less in the z dimension\n    ! than the input array\n\n    implicit none\n    integer, intent(in)   :: nx,ny,nz_in\n    real, intent(in)      :: datain(nx,ny,nz_in)\n    real, intent(out)     :: dataout(nx,ny,nz_in-1)\n\n    integer :: k\n\n    do k = 1,nz_in-1\n\n      dataout(:,:,k) = 0.5*(datain(:,:,k)+datain(:,:,k+1))\n  \n    enddo\n    return\n  end subroutine wlevs2hlevs\n"}, {"instruction": "Write a Fortran subroutine named reverse_point_order that takes in four sets of three real numbers representing points p1, p2, p3, p4, and outputs the points p1r, p2r, p3r, p4r in reverse order. The input parameters should be of type real and intent(in), while the output parameters should also be of type real and intent(out).", "input": "", "output": "    subroutine reverse_point_order(p1,p2,p3,p4,p1r,p2r,p3r,p4r)\n\n        ! reverse_points() : reverses the ordering of four points given by p1,p2,p3,p4\n\n        real, intent(in) :: p1(3), p2(3), p3(3), p4(3)\n        real, intent(out) :: p1r(3), p2r(3), p3r(3), p4r(3)\n        real :: temp1(3), temp2(3)\n\n        temp1 = p1\n        temp2 = p2\n\n        p1r = p4\n        p2r = p3\n        p3r = temp2\n        p4r = temp1\n\n    end subroutine reverse_point_order\n"}, {"instruction": "Create a Fortran subroutine named stern to generate the start of a reciprocal vector. The subroutine takes 5 input parameters: g (array of 3 integers), iz (3D array of integers), tau (2D array of real*8), iord (integer), qcomplex (logical). It provides 3 output parameters: nst (integer), stg (2D array of integers), taup (1D array of complex*16).", "input": "", "output": "subroutine stern(g,nst,stg,taup, iz, tau, iord, qcomplex)\n  ! generates the start of reciprocal vector g\n  ! input:\n  !     g(3)           -- reciprocal vector\n  !     iz(3,3,iord)   -- 3x3 matrices for group operations (rotations, reflections...)\n  !     tau(3,iord)    -- vector shifts for non-simmorphic symmetries\n  !     qcomplex       -- calculation is real when inversion is present and there is no spin-orbit. otherwise we work with complex phase factors.\n  ! output:\n  !     nst            -- number of star members\n  !     stg            -- the first star member, i.e., iz*g\n  !     taup           -- sum of phase factors for non-simmorphic symmetries : sum_{star_members=j} e^{2*pi*i*g*tau_j}, otherwise just degeneracy of star member\n  !\n  implicit none\n  !\n  integer, intent(out)      :: nst,stg(3,iord)  \n  complex*16, intent(out)   :: taup(iord)\n  integer, intent(in)       :: g(3)             \n  integer, intent(in)       :: iord\n  integer, intent(in)       :: iz(3,3,iord)\n  real*8, intent(in)        :: tau(3,iord)\n  logical, intent(in)       :: qcomplex\n  ! locals\n  integer :: i, m\n  real*8  :: tk, pi, greal(3)\n  integer :: ind(iord)\n  logical :: foundstarmember\n  !---------------------------------------------------------------------  \n  !\n  pi=acos(-1.d0)\n  nst=0\n  greal(:) = g(:)\n  do i=1,iord\n     tk = dot_product(greal(:),tau(:,i))*2.0d0*pi\n     stg(:,i) = matmul(iz(:,:,i),g(:))\n     foundstarmember=.false.\n     do m=1,nst\n        if( stg(1,m).ne.stg(1,i) .or. stg(2,m).ne.stg(2,i) .or. stg(3,m).ne.stg(3,i) ) cycle\n        ! if we come here, previous stg(:,m) is exactly equal to current stg(:,i). hence stg(:,i) is part of the same star.\n        ind(m)=ind(m)+1\n        if (qcomplex) then\n           taup(m) = taup(m) + dcmplx(cos(tk),sin(tk))\n        else\n           taup(m) = taup(m) + cos(tk)\n        endif\n        foundstarmember=.true.\n     enddo\n\n     if (.not.foundstarmember) then\n        ! we come here only when we start a new star member\n        nst=nst+1            ! next start member started\n        stg(:,nst)=stg(:,i)  ! symmetry related g\n        ind(nst)=1           ! how many members of the star we have\n        if (qcomplex) then\n           taup(nst) = dcmplx(cos(tk),sin(tk))\n        else\n           taup(nst) = cos(tk)\n        endif\n     endif\n  enddo\n\n  taup(1:nst)=taup(1:nst)/ind(1:nst)                                            \n  return                                                            \nend subroutine stern\n"}, {"instruction": "Write a Fortran subroutine named sinedvr to perform calculations related to the discrete variable representation of the sine function. The subroutine takes 2 input parameters of type integer and real*8 and 3 output parameters of type real*8. The subroutine calculates the ketot, fdtot, and points based on the gridpoints and spacing provided. Use the imperative tone in your instructions.", "input": "", "output": "subroutine sinedvr(ketot,fdtot, points,gridpoints,spacing)\n  implicit none\n  integer,intent(in) :: gridpoints\n  real*8,intent(in) :: spacing\n  real*8,intent(out) :: ketot(1-gridpoints:gridpoints-1),points(gridpoints),&\n       fdtot(1-gridpoints:gridpoints-1)\n  integer :: i\n  real*8 ::  mypi\n\n  mypi   = 4d0*atan(1d0)\n\n  do i=1,gridpoints\n     points(i) = i*spacing\n  enddo\n\n  points(:)=points(:)-(points(1)+points(gridpoints))/2d0\n\n  do i=1-gridpoints,gridpoints-1\n     if (i==0) then\n        ketot(i) = mypi**2/3.d0\n        fdtot(i) = 0d0\n     else\n        ketot(i) = 2.d0/real(i,8)**2 * (-1)**(i)\n        fdtot(i) = 1d0/real(i,8) * (-1)**(i)\n     endif\n  enddo\n\n  ketot=ketot/2.d0/spacing**2 \n  fdtot=fdtot/spacing\n\nend subroutine sinedvr\n"}, {"instruction": "Create a Fortran subroutine named quintic_extrap to perform quintic extrapolation on an input array of double precision with dimension (6), and output the result as an array of double precision with dimension (2).", "input": "", "output": "subroutine quintic_extrap(source, dest)\n    implicit none\n    double precision, dimension(6), intent(in) :: source\n    double precision, dimension(2), intent(out) :: dest\n    dest(1) = 21.d0 * source(1) - 70.d0 * source(2) + 105.d0 * source(3)  &\n        - 84.d0 * source(4) + 35.d0 * source(5) - 6.d0 * source(6)\n    dest(2) = 6.d0 * source(1) - 15.d0 * source(2) + 20.d0 * source(3)  &\n        - 15.d0 * source(4) + 6.d0 * source(5) - source(6)\nend subroutine quintic_extrap\n"}, {"instruction": "Create a Fortran subroutine named cosine to calculate the value of c using the input parameters a, b, thetai, and thetaf, which are all real numbers. The output parameter c is also a real number.", "input": "", "output": "subroutine cosine(a,b,thetai,thetaf,c)\n    implicit none\n\n    real, intent(in) :: a,b,thetai,thetaf\n    real, intent(out):: c\n    real:: pi,d2r,dtheta\n\n    !convert to radians\n    pi=4.*atan(1.)\n    dtheta=abs(thetai-thetaf)\n    d2r=(2.*pi)/360.\n    c=sqrt(a*a + b*b - 2.*a*b*cos(dtheta*d2r))\n\nend subroutine cosine\n"}, {"instruction": "Create a Fortran subroutine named fac2mit to calculate the flimit based on the given smcmax value. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter is specified with the intent(in) attribute, and the output parameter is specified with the intent(out) attribute. The flimit value is calculated based on the conditions specified in the subroutine.", "input": "", "output": "  subroutine fac2mit(smcmax,flimit)\n    implicit none\n    real, intent(in) :: smcmax\n    real, intent(out) :: flimit\n    flimit = 0.90\n    if ( smcmax == 0.395 ) then\n       flimit = 0.59\n    else if ( ( smcmax == 0.434 ) .or. ( smcmax == 0.404 ) ) then\n       flimit = 0.85\n    else if ( ( smcmax == 0.465 ) .or. ( smcmax == 0.406 ) ) then\n       flimit = 0.86\n    else if ( ( smcmax == 0.476 ) .or. ( smcmax == 0.439 ) ) then\n       flimit = 0.74\n    else if ( ( smcmax == 0.200 ) .or. ( smcmax == 0.464 ) ) then\n       flimit = 0.80\n    endif\n  end subroutine fac2mit\n"}, {"instruction": "Create a Fortran subroutine named frh2o to calculate the free water content based on input parameters. The subroutine takes 6 input parameters of type real: bexp, psis, sh2o, smc, smcmax, and tkelv. It returns 1 output parameter of type real: free.", "input": "", "output": "      subroutine frh2o (free,tkelv,smc,sh2o,smcmax,bexp,psis)\n      implicit none\n      real, intent(in) :: bexp,psis,sh2o,smc,smcmax,tkelv\n      real, intent(out) :: free\n      real :: bx,denom,df,dswl,fk,swl,swlk\n      integer :: nlog,kcount\n      real, parameter :: ck = 8.0, blim = 5.5, error = 0.005, &\n                              hlice = 3.335e5, gs = 9.81,dice = 920.0, &\n                              dh2o = 1000.0, t0 = 273.15\n      bx = bexp\n      if (bexp > blim) bx = blim\n      nlog = 0\n      kcount = 0\n      if (tkelv > (t0- 1.e-3)) then\n          free = smc\n      else\n         if (ck /= 0.0) then\n            swl = smc - sh2o\n            if (swl > (smc -0.02)) swl = smc -0.02\n            if (swl < 0.) swl = 0.\n 1001 continue\n              if (.not.( (nlog < 10) .and. (kcount == 0))) goto 1002\n              nlog = nlog +1\n              df = alog ( ( psis * gs / hlice ) * ( ( 1. + ck * swl )**2.) * &\n                   ( smcmax / (smc - swl) )** bx) - alog ( - ( &\n                   tkelv - t0)/ tkelv)\n              denom = 2. * ck / ( 1. + ck * swl ) + bx / ( smc - swl )\n              swlk = swl - df / denom\n              if (swlk > (smc -0.02)) swlk = smc - 0.02\n              if (swlk < 0.) swlk = 0.\n              dswl = abs (swlk - swl)\n              swl = swlk\n              if ( dswl <= error ) then\n                    kcount = kcount +1\n              end if\n           goto 1001\n 1002 continue\n           free = smc - swl\n         end if\n         if (kcount == 0) then\n             print *,'flerchinger used in new version. iterations=',nlog\n                  fk = ( ( (hlice / (gs * ( - psis)))* &\n                       ( (tkelv - t0)/ tkelv))** ( -1/ bx))* smcmax\n             if (fk < 0.02) fk = 0.02\n             free = min (fk, smc)\n         end if\n      end if\n  end subroutine frh2o\n"}, {"instruction": "Create a Fortran subroutine named snowz0 to calculate the roughness length for momentum and scalar transfer over snow-covered and non-snow-covered surfaces.\nThe subroutine takes 7 input parameters of type real, real, real, logical, real, real, real and returns 1 output parameter of type real.", "input": "", "output": "      subroutine snowz0 (sncovr,z0, z0brd, snowh,fbur,fgsn,shdmax,ua_phys)\n      implicit none\n      real, intent(in) :: sncovr, z0brd\n      real, intent(out) :: z0\n      real, parameter :: z0s=0.001\n      real, intent(in) :: snowh\n      real :: burial\n      real :: z0eff\n      logical, intent(in) :: ua_phys\n      real, intent(in) :: fbur\n      real, intent(in) :: fgsn\n      real, intent(in) :: shdmax\n      real, parameter :: z0g=0.01\n      real :: fv,a1,a2\n      if(ua_phys) then\n          fv = shdmax * (1.-fbur)\n          a1 = (1.-fv)**2*((1.-fgsn**2)*log(z0g) + (fgsn**2)*log(z0s))\n          a2 = (1.-(1.-fv)**2)*log(z0brd)\n          z0 = exp(a1+a2)\n      else\n          burial = 7.0*z0brd - snowh\n          if(burial.le.0.0007) then\n              z0eff = z0s\n          else\n              z0eff = burial/7.0\n          endif\n          z0 = (1.- sncovr)* z0brd + sncovr * z0eff\n      endif\n  end subroutine snowz0\n"}, {"instruction": "Create a Fortran subroutine named tdfcnd to calculate the value of df based on the input parameters qz, smc, smcmax, and sh2o, which are all real numbers. The subroutine takes 4 input parameters (real, real, real, real) and returns 1 output parameter (real).", "input": "", "output": "      subroutine tdfcnd ( df, smc, qz, smcmax, sh2o)\n      implicit none\n      real, intent(in) :: qz, smc, smcmax, sh2o\n      real, intent(out) :: df\n      real :: ake, gammd, thkdry, thkice, thko, &\n                                   thkqtz,thksat,thks,thkw,satratio,xu, &\n                                   xunfroz\n      satratio = smc / smcmax\n      thkice = 2.2\n      thkw = 0.57\n      thko = 2.0\n      thkqtz = 7.7\n      thks = (thkqtz ** qz)* (thko ** (1. - qz))\n      xunfroz = sh2o / smc\n      xu = xunfroz * smcmax\n      thksat = thks ** (1. - smcmax)* thkice ** (smcmax - xu)* thkw ** &\n         (xu)\n      gammd = (1. - smcmax)*2700.\n      thkdry = (0.135* gammd+ 64.7)/ (2700. - 0.947* gammd)\n      if ( (sh2o + 0.0005) < smc ) then\n         ake = satratio\n      else\n         if ( satratio > 0.1 ) then\n            ake = log10 (satratio) + 1.0\n         else\n            ake = 0.0\n         end if\n      end if\n      df = ake * (thksat - thkdry) + thkdry\n  end subroutine tdfcnd\n"}, {"instruction": "Write a Fortran subroutine named bmat_nonaxi to handle axisymmetric solids under non-axisymmetric loading. The subroutine takes 5 input parameters of type real(iwp), real(iwp), real(iwp), integer, and integer, and 2 output parameters of type real(iwp).", "input": "", "output": "subroutine bmat_nonaxi(bee,radius,coord,deriv,fun,iflag,lth)\n!\n\n! axisymmetric solids subjected to non-axisymmetric loading.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::deriv(:,:),fun(:),coord(:,:)\n real(iwp),intent(out)::bee(:,:),radius\n integer,intent(in)::iflag,lth\n integer::nod,k,l,m,n\n nod=ubound(deriv,2) \n bee=0.0_iwp\n radius=sum(fun*coord(:,1))\n do m=1,nod\n   n=3*m      \n   k=n-1      \n   l=k-1\n   bee(1,l)=deriv(1,m)\n   bee(2,k)=deriv(2,m)\n   bee(3,l)=fun(m)/radius\n   bee(3,n)=iflag*lth*bee(3,l) \n   bee(4,l)=deriv(2,m)\n   bee(4,k)=deriv(1,m)\n   bee(5,k)=-iflag*lth*fun(m)/radius \n   bee(5,n)=deriv(2,m)\n   bee(6,l)=bee(5,k) \n   bee(6,n)=deriv(1,m)-fun(m)/radius\n end do\nreturn\nend subroutine bmat_nonaxi\n"}, {"instruction": "Create a Fortran subroutine named qadd that takes two input arrays of real(kind=8) type, with dimensions of [:, :] and [size(a, 1), size(a, 2)], and one output array of real(kind=8) type with dimensions [size(a, 1), size(a, 2)]. The subroutine computes the sum of the two input arrays element-wise and stores the result in the output array.", "input": "", "output": "subroutine qadd(a, b, output)\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(out) :: output\n\n  output = a + b\nend subroutine qadd\n"}, {"instruction": "Write a Fortran subroutine named qnorm to calculate the normalized vectors from an input array of vectors. The number of input arguments is 1 and the test_data type is ['real(kind=8), dimension(:, :)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(size(q, 1), size(q, 2))'].", "input": "", "output": "subroutine qnorm(q, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), size(q, 2)), intent(out) :: output\n  real(kind=8) :: curnorm\n  integer :: i\n\n  do i = 1, size(q, 1)\n     curnorm = sqrt(dot_product(q(i, 1:4), q(i, 1:4)))\n     if (curnorm .gt. 0.0) then\n        output(i, :) = q(i, :) / curnorm\n     else\n        output(i, :) = 0.0\n     endif\n  enddo\nend subroutine qnorm\n"}, {"instruction": "Create a Fortran subroutine named qmul that takes two input parameters and one output parameter. The input parameters are of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(a, 1), size(a, 2)), while the output parameter is of type real(kind=8), dimension(size(a, 1), size(a, 2)). The subroutine performs quaternion multiplication for each row of the input matrices a and b and stores the results in the output matrix.", "input": "", "output": "subroutine qmul(a, b, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(out) :: output\n  integer :: i\n\n  do i = 1, size(a, 1)\n     output(i, 1) = a(i, 1) * b(i, 4) + a(i, 4) * b(i, 1) + a(i, 2) * b(i, 3) - a(i, 3) * b(i, 2)\n     output(i, 2) = a(i, 2) * b(i, 4) + a(i, 4) * b(i, 2) + a(i, 3) * b(i, 1) - a(i, 1) * b(i, 3)\n     output(i, 3) = a(i, 3) * b(i, 4) + a(i, 4) * b(i, 3) + a(i, 1) * b(i, 2) - a(i, 2) * b(i, 1)\n     output(i, 4) = a(i, 4) * b(i, 4) - a(i, 1) * b(i, 1) - a(i, 2) * b(i, 2) - a(i, 3) * b(i, 3)\n  enddo\n\nend subroutine qmul\n"}, {"instruction": "Create a Fortran subroutine named qfromaxisangle to calculate the quaternion from the axis-angle representation. The subroutine takes 2 input parameters of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(axes, 1)), and 1 output parameter of type real(kind=8), dimension(size(axes, 1), 4).", "input": "", "output": "subroutine qfromaxisangle(axes, angles, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: axes\n  real(kind=8), dimension(size(axes, 1)), intent(in) :: angles\n  real(kind=8), dimension(size(axes, 1), 4), intent(out) :: output\n\n  integer :: i\n  real(kind=8) :: sinangle\n  real(kind=8) :: cosangle\n\n  do i = 1, size(axes, 1)\n     sinangle = sin(angles(i) / 2)\n     cosangle = cos(angles(i) / 2)\n     output(i, 1:3) = sinangle * axes(i, :)\n     output(i, 4) = cosangle\n  enddo\nend subroutine qfromaxisangle\n"}, {"instruction": "Create a Fortran subroutine called \"qtoaxisangle\" that takes an input array of real numbers with kind=8 and dimensions(:, :) and returns two output arrays of real numbers with kind=8 and dimensions(size(q, 1), 3) and dimensions(size(q, 1)). The subroutine computes the axes and angles from the input quaternion array and assigns the results to the output arrays. Use an imperative tone to create the subroutine.", "input": "", "output": "subroutine qtoaxisangle(q, axes, angles)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), 3), intent(out) :: axes\n  real(kind=8), dimension(size(q, 1)), intent(out) :: angles\n\n  integer :: idx\n\n  do idx = 1, size(q, 1)\n     angles(idx) = 2 * acos(q(idx, 4))\n     if (angles(idx) == 0.0) then\n        axes(idx, :) = 0.0\n     else\n        axes(idx, :) = q(idx, 1:3) / sin(angles(idx) / 2.0)\n     endif\n  end do\n\nend subroutine qtoaxisangle\n"}, {"instruction": "Create a Fortran subroutine named qinvrot to calculate the inverse rotation of a quaternion matrix. The subroutine takes 1 input parameter of type real(kind=8), dimension(:, :). The output is 1 parameter of type real(kind=8), dimension(size(q, 1), size(q, 2)). Use the imperative tone.", "input": "", "output": "subroutine qinvrot(q, output)\n  implicit none\n  \n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), size(q, 2)), intent(out) :: output\n\n  integer :: idx\n\n  do idx = 1, size(q, 1)\n    output(idx, 1:3) = -q(idx, 1:3)\n    output(idx, 4) = q(idx, 4)\n  enddo\nend subroutine qinvrot\n"}, {"instruction": "Write a Fortran subroutine named qrotate to perform quaternion rotation on a vector. The subroutine takes 2 input parameters of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(vec, 1), 4), and 1 output parameter of type real(kind=8), dimension(size(vec, 1), size(vec, 2)). The subroutine compute the expression output = inv(quat) * (vec * quat) and uses the imperative tone.", "input": "", "output": "subroutine qrotate(vec, quat, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: vec\n  real(kind=8), dimension(size(vec, 1), 4), intent(in) :: quat\n  real(kind=8), dimension(size(vec, 1), size(vec, 2)), intent(out) :: output\n\n  ! the computation is the following (in symbols):\n  !     output = inv(quat) * (vec * quat)\n  ! we use \"tmpq\" to store the value of \"vec * quat\"\n  real(kind=8), dimension(4) :: tmpq\n  real(kind=8), dimension(4) :: invq\n  integer :: i\n\n  do i = 1, size(vec, 1)\n     invq(1:3) = -quat(i, 1:3)\n     invq(4) = quat(i, 4)\n\n     ! this code is like \"qmul\", but it assumes that \"vec\" is an array of\n     ! 3-element vector instead of an array of 4-element quaternions: so a few\n     ! terms can be safely dropped (vec(i, 4) is always zero!)\n     tmpq(1) =  vec(i, 1) * invq(4) + vec(i, 2) * invq(3) - vec(i, 3) * invq(2)\n     tmpq(2) =  vec(i, 2) * invq(4) + vec(i, 3) * invq(1) - vec(i, 1) * invq(3)\n     tmpq(3) =  vec(i, 3) * invq(4) + vec(i, 1) * invq(2) - vec(i, 2) * invq(1)\n     tmpq(4) = -vec(i, 1) * invq(1) - vec(i, 2) * invq(2) - vec(i, 3) * invq(3)\n\n     ! this code is again like \"qmul\", but we drop the last term, as we are\n     ! only interested in the \"vector\" part of the computation (i.e., the first\n     ! three elements of the \"output(i, :)\" quaternion)\n     output(i, 1) = quat(i, 1) * tmpq(4) + quat(i, 4) * tmpq(1) &\n         + quat(i, 2) * tmpq(3) - quat(i, 3) * tmpq(2)\n     output(i, 2) = quat(i, 2) * tmpq(4) + quat(i, 4) * tmpq(2) &\n         + quat(i, 3) * tmpq(1) - quat(i, 1) * tmpq(3)\n     output(i, 3) = quat(i, 3) * tmpq(4) + quat(i, 4) * tmpq(3) &\n         + quat(i, 1) * tmpq(2) - quat(i, 2) * tmpq(1)\n  enddo\nend subroutine qrotate\n"}, {"instruction": "Create a Fortran subroutine named lint1u that performs linear interpolation. The subroutine takes 7 input parameters of types ['integer', 'real (kind=8)', 'integer', 'integer', 'real (kind=8)', 'integer', 'integer'], and 1 output parameter of type ['real (kind=8)']. The subroutine uses the imperative tone to linearly interpolate and assign values to the output parameter q based on the input parameters p, ix, dx, inmx, and isubx.", "input": "", "output": "    subroutine lint1u(nx,p,mx,q,ix,dx,inmx,isubx)\n\n    implicit none\n    integer, intent(in)                      :: nx\n    real (kind=8), intent(in)                :: p(nx)\n    integer, intent(in)                      :: mx\n    real (kind=8), intent(out)               :: q(mx)\n    integer, intent(in)                      :: ix(mx)\n    real (kind=8), intent(in)                :: dx(mx)\n    integer, intent(in)                      :: inmx\n    integer, intent(in)                      :: isubx\n    integer :: i,ii\n\n\n    if (isubx == 1) then\n      \n    !     mx grid is subset of nx grid so q can be set directly\n      \n      do ii=1,mx\n        i = inmx*(ii-1)+1\n        q(ii) = p(i)\n      end do\n      return\n    else\n      \n    !     linearly interpolate\n      \n      do ii=1,mx\n        i = ix(ii)\n        q(ii) = p(i)+dx(ii)*(p(i+1)-p(i))\n      end do\n      return\n    end if\n    end subroutine lint1u\n"}, {"instruction": "Create a Fortran subroutine named linmxu to set linear interpolation terms. It takes 2 input parameters of type integer and returns 2 output parameters, one of type integer and the other of type real (kind=8).", "input": "", "output": "    subroutine linmxu(nx,mx,ix,dx)\n\n    !     set linear interpolation terms\n\n\n    implicit none\n    integer, intent(in)                      :: nx\n    integer, intent(in)                      :: mx\n    integer, intent(out)                     :: ix(mx)\n    real (kind=8), intent(out)               :: dx(mx)\n    integer :: i,ii\n    real (kind=8) :: dnx,dmx,x,xx\n\n    !     set \"virtual\" uniform increments\n\n    dnx = 1.0/(nx-1)\n    dmx = 1.0/(mx-1)\n\n    !     set ix(ii) = i  s.t. i,i+1 can interpolate for ii\n\n    do ii=1,mx\n      xx = (ii-1)*dmx\n      ix(ii) = min0(int(xx/dnx)+1,nx-1)\n      \n    !     set scale term for linear\n      \n      i = ix(ii)\n      x = (i-1)*dnx\n      dx(ii) = (xx-x)/dnx\n    end do\n    return\n    end subroutine linmxu\n"}, {"instruction": "Write a Fortran subroutine named cubnmxu to calculate cubic interpolation terms. The subroutine takes 2 input parameters of type integer, nx and mx. It returns 5 output parameters of type integer (ix) and real (kind=8) (dxm, dx, dxp, dxpp).", "input": "", "output": "    subroutine cubnmxu(nx,mx,ix,dxm,dx,dxp,dxpp)\n\n    !     set cubic interpolation terms\n\n\n    implicit none\n    integer, intent(in)                      :: nx\n    integer, intent(in)                      :: mx\n    integer, intent(out)                     :: ix(mx)\n    real (kind=8), intent(out)               :: dxm(mx)\n    real (kind=8), intent(out)               :: dx(mx)\n    real (kind=8), intent(out)               :: dxp(mx)\n    real (kind=8), intent(out)               :: dxpp(mx)\n    integer :: i,ii\n    real (kind=8) :: dnx,dmx,odnx3\n    real (kind=8) :: xx,xim,xi,xip,xipp\n\n    !     set \"virtual\" uniform increments\n\n    dnx = 1.0/(nx-1)\n    dmx = 1.0/(mx-1)\n    odnx3 = 1.0/(6.*dnx*dnx*dnx)\n\n    !     set i=ix(ii) in [2,nx-2] such that\n    !     i-1,i,i+1,i+2 can be used to interpolate at ii\n\n    do ii=1,mx\n      xx = (ii-1)*dmx\n      ix(ii) = min0(max0(int(xx/dnx)+1,2),nx-2)\n      i = ix(ii)\n      \n    !     set scale terms for cubic\n      \n      xi = (i-1)*dnx\n      xim = xi-dnx\n      xip = xi+dnx\n      xipp = xip+dnx\n      dxm(ii) = -(xx-xi)*(xx-xip)*(xx-xipp)*odnx3\n      dx(ii) = 3.*(xx-xim)*(xx-xip)*(xx-xipp)*odnx3\n      dxp(ii) = -3.*(xx-xim)*(xx-xi)*(xx-xipp)*odnx3\n      dxpp(ii) = (xx-xim)*(xx-xi)*(xx-xip)*odnx3\n    end do\n    return\n    end subroutine cubnmxu\n"}, {"instruction": "Write a Fortran subroutine named polint to perform polynomial interpolation. The subroutine takes 4 input parameters of types integer, real(8) array, real(8) array, and real(8), and 2 output parameters of types real(8) and real(8).", "input": "", "output": "  subroutine polint( xa,ya,n,x,y,dy )\n\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: xa(n),ya(n),x\n    real(8),intent(out) :: y,dy\n    integer :: i,m\n    real(8) :: a,b,f0nm,f0nm_0\n    real(8),allocatable :: f0(:)\n\n    allocate( f0(n) )\n    f0(:) = ya(:)\n\n    f0nm = ya(1)\n\n    do m=1,n-1\n       do i=1,n-m\n          a = x-xa(i)\n          b = x-xa(i+m)\n          f0(i) = ( b*f0(i) - a*f0(i+1) )/( b - a )\n       end do\n       f0nm_0 = f0nm\n       f0nm   = sum( f0(1:n-m) )/(n-m)\n    end do\n    y  = f0(1)\n    dy = f0nm - f0nm_0\n\n    deallocate( f0 )\n\n    return\n  end subroutine polint\n"}, {"instruction": "Create a Fortran subroutine named dpolint to perform polynomial interpolation. The number of input arguments is 4 with test_data type ['integer', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 2 with test_data type ['real(8)', 'real(8)'].", "input": "", "output": "  subroutine dpolint( xa,ya,n,x,y,dy )\n\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: xa(n),ya(n),x\n    real(8),intent(out) :: y,dy\n    integer :: i,m\n    real(8) :: a,b,f1nm,f1nm_0\n    real(8),allocatable :: f0(:),f1(:)\n\n    allocate( f0(n),f1(n) )\n    f0(:) = ya(:)\n    f1(:) = 0.0d0\n\n    f1nm = ( ya(2)-ya(1) )/( xa(2)-xa(1) )\n\n    do m=1,n-1\n       do i=1,n-m\n          a = x-xa(i)\n          b = x-xa(i+m)\n          f1(i) = ( f0(i) - f0(i+1) + b*f1(i) -a*f1(i+1) )/( b - a )\n          f0(i) = ( b*f0(i) - a*f0(i+1) )/( b - a )\n       end do\n       f1nm_0 = f1nm\n       f1nm   = sum( f1(1:n-m) )/(n-m)\n    end do\n\n    y  = f1(1)\n    dy = f1nm - f1nm_0\n\n    deallocate( f0,f1 )\n\n    return\n  end subroutine dpolint\n"}, {"instruction": "Write a Fortran subroutine named get_nloat that reads linearization energy data for lapw and computes the total number of entries based on the maximum angular momentum (lomax) and the number of atoms (nat) provided as input. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine get_nloat(lomax,nat,nloat)\n  implicit none\n  integer, intent(in) :: lomax, nat\n  integer, intent(out):: nloat\n  ! locals\n  integer ::   i,ios, ii\n  real*8, allocatable :: elo(:,:)\n  nloat=1000\n  allocate (elo(0:lomax,1:nloat))\n  ii=1\n  nloat=0\n  do i=1,nat\n     read(9)  ! linearization energy for lapw\n     do\n        read(9,iostat=ios) elo(0:lomax,1:ii)\n        if (ios.ne.0) exit ! no more entries\n        ii=ii+1\n        backspace(9)\n     enddo\n     nloat=ii\n  enddo\n  deallocate(elo)\n  rewind(9)\nend subroutine get_nloat\n"}, {"instruction": "Create a Fortran subroutine named evaluatecubicandderivs to evaluate a cubic polynomial and its 1st, 2nd, and 3rd derivatives at a specified point. The subroutine takes 7 input parameters of type real: a, fa, fpa, b, fb, fpb, and u. It also has 4 optional output parameters of type real: f, fp, fpp, and fppp.", "input": "", "output": "pure subroutine evaluatecubicandderivs(a,fa,fpa, b,fb,fpb, u, f,fp,fpp,fppp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - evaluate a cubic polynomial and its 1st, 2nd, and 3rd\r\n!   derivatives at a specified point. the cubic is defined by the function\r\n!   and the 1st derivative at two points. the cubic is mapped onto [0,1]\r\n!   for some savings in computation. if no derivatives are wanted, it is\r\n!   probably preferable to use functions evaluatecubic above.\r\n\r\n  real,intent(in):: a,fa,fpa   ! a, f(a), f'(a)  at first point\r\n  real,intent(in):: b,fb,fpb   ! b, f(b), f'(b)  at second point\r\n  real,intent(in):: u   ! point where function is to be evaluated\r\n\r\n  real,intent(out),optional:: f,fp,fpp,fppp   ! f(u),f'(u),f''(u),f'''(u)\r\n  \r\n  real,parameter:: one=1.0, two=2.0, three=3.0, six=6.0\r\n! the \"magic\" matrix. this is how you declare a constant 4x4 matrix\r\n  real,parameter,dimension(4,4):: magic = reshape(                      &\r\n     & (/2.0, -3.0,  0.0,  1.0, -2.0,  3.0,  0.0,  0.0,                 &\r\n     &   1.0, -2.0,  1.0,  0.0,  1.0, -1.0,  0.0,  0.0/), (/4,4/) )\r\n  real,dimension(4)::coef,rhs\r\n  real:: h,t\r\n! ------------------------------------------------------------------------------\r\n  rhs(1)=fa\r\n  rhs(2)=fb\r\n  rhs(3)=fpa*(b-a)\r\n  rhs(4)=fpb*(b-a)\r\n  coef=matmul(magic,rhs)\r\n\r\n! caution - these are not the coefficients of the cubic in the original \r\n! coordinates. this is the cubic on [0,1] from the mapping t=(x-a)/(b-a). \r\n! that is why the h terms appear in the derivatives.       \r\n\r\n  h=one/(b-a)\r\n  t=(u-a)*h\r\n  if (present(f)) then\r\n    f=             coef(4) +     t*(coef(3) + t*(coef(2)   + t*coef(1)))\r\n  end if\r\n  if (present(fp)) then\r\n    fp=         h*(coef(3) + t*(two*coef(2) + t*three*coef(1)))\r\n  end if\r\n  if (present(fpp)) then\r\n    fpp=  h*h*(two*coef(2) +  t*six*coef(1))\r\n  end if\r\n  if (present(fppp)) then\r\n    fppp=h*h*h*six*coef(1)\r\n  end if\r\n  return\r\nend subroutine evaluatecubicandderivs   ! -------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named f1max that calculates approximations to the 1%, 5%, and 10% points of the distribution of the maximum of nf values of an f-ratio. The subroutine takes 2 input parameters of type integer and 4 output parameters of type real and integer.", "input": "", "output": "subroutine f1max(ndf, nf, f1, f5, f10, ier)\r\n! calculates approximations to the 1%, 5% & 10% points of the distribution\r\n! of the maximum of nf values of an f-ratio with 1 d.f. for the numerator\r\n! and ndf d.f. for the denominator.\r\n! an approximation is used to the values given in table 2 of:\r\n!     gilmour, s.g. (1996) `the interpretation of mallows's cp-statistic',\r\n!     the statistician, vol.45, pp.49-56\r\n\r\nimplicit none\r\ninteger, intent(in)  :: ndf, nf\r\nreal, intent(out)    :: f1, f5, f10\r\ninteger, intent(out) :: ier\r\n\r\n! local variables\r\nreal :: a1(6) = (/ 1.67649, 6.94330,  1.22627, 0.25319,  0.06136, -2.41097 /)\r\nreal :: a5(6) = (/ 1.28152, 4.93268, -0.29583, 0.28518, -0.23566, -1.60581 /)\r\nreal :: a10(6) = (/1.06642, 3.96276, -0.62483, 0.30228, -0.52843, -1.04499 /)\r\n\r\nreal :: log_nf, one = 1.0\r\n\r\nif (ndf < 4 .or. nf < 1) then\r\n  ier = 1\r\n  return\r\nend if\r\nier = 0\r\n\r\nlog_nf = log(dble(nf))\r\n\r\nf1 = one + exp(a1(1) + (a1(3)/ndf + a1(2))/ndf + a1(4)*log_nf          &\r\n               + (a1(6)/ndf + a1(5))/nf)\r\n\r\nf5 = one + exp(a5(1) + (a5(3)/ndf + a5(2))/ndf + a5(4)*log_nf          &\r\n               + (a5(6)/ndf + a5(5))/nf)\r\n\r\nf10 = one + exp(a10(1) + (a10(3)/ndf + a10(2))/ndf + a10(4)*log_nf     &\r\n                + (a10(6)/ndf + a10(5))/nf)\r\n\r\nreturn\r\nend subroutine f1max\r\n"}, {"instruction": "Create a Fortran subroutine named polar_to_cartesian to convert polar coordinates to cartesian coordinates. The subroutine takes 2 input parameters of type real: radius and inclination. It also outputs 2 parameters of type real: x and y. If the radius is zero, the x and y coordinates are set to 0.0; otherwise, x is calculated as radius times cosine of inclination, and y is calculated as radius times sine of inclination.", "input": "", "output": "   subroutine polar_to_cartesian(radius,inclination,x,y)\n      implicit none\n      character(len=*),parameter::ident_21=\"@(#)m_units::polar_to_cartesian(3f): convert polar coordinates to cartesian coordinates\"\n      real,intent(in) :: radius,inclination\n      real,intent(out)  :: x,y\n      if(radius.eq.0)then\n         x=0.0\n         y=0.0\n      else\n         x=radius*cos(inclination)\n         y=radius*sin(inclination)\n      endif\n   end subroutine polar_to_cartesian\n"}, {"instruction": "Write a Fortran subroutine named readscalar_i to read a single integer value from a file specified by the input file_name. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    subroutine readscalar_i(x,file_name)\r\n    \r\n    implicit none\r\n    \r\n    character(len=*), intent(in) :: file_name\r\n    integer, intent(out) :: x\r\n    integer :: unitno,i, ierr\r\n    \r\n    open(newunit=unitno, file=file_name, status='old', iostat=ierr)\r\n    if (ierr/=0) then\r\n        write(*,*) \"error in readscalar: cannot open file\"\r\n\t\tpause\r\n\t\tstop \r\n    endif\r\n    \r\n    read(unitno,*) x\r\n    \r\n    close(unitno)\r\n    \r\n    end subroutine readscalar_i\r\n"}, {"instruction": "Create a Fortran subroutine named read1dim_i to read integer data from a file and store it in an array. The subroutine has 1 input parameter of type character(len=*) to specify the file name, and 1 output parameter of type integer array to store the read data.", "input": "", "output": "    subroutine read1dim_i(x,file_name)\r\n    \r\n    implicit none\r\n    \r\n    character(len=*), intent(in) :: file_name\r\n    integer, intent(out) :: x(:)\r\n    integer :: unitno,i, ierr\r\n    \r\n    open(newunit=unitno, file=file_name, status='old', iostat=ierr)\r\n    if (ierr/=0) then\r\n        write(*,*) \"error in read1dim: cannot open file\"\r\n\t\tpause\r\n\t\tstop \r\n    endif\r\n    \r\n    do i = 1,size(x)\r\n        read(unitno,*) x(i)\r\n    enddo\r\n    close(unitno)\r\n    \r\n    end subroutine read1dim_i\r\n"}, {"instruction": "Create a Fortran subroutine named \"flncoshd\" that takes a single input parameter of type real*8 and returns a single output parameter of type real*8. The subroutine should calculate the natural logarithm of the hyperbolic cosine of the input parameter and store the result in the output parameter. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes to specify the purpose of each parameter.", "input": "", "output": "subroutine flncoshd(x,y)\n    implicit none\n    real*8,parameter :: log2_=log(2d0)\n    real*8,intent(in) :: x\n    real*8,intent(out) :: y\n    real*8 :: absx\n    !f2py intent(in) :: x\n    !f2py intent(out) :: y\n    absx=abs(x)\n    if(x>12) then\n        y=x-log2_\n    else\n        y=log(cosh(x))\n    endif\nend subroutine flncoshd\n"}, {"instruction": "Create a Fortran subroutine named \"c_uparser_get_bool\" that takes 1 input parameter of type character(kind=c_char) and 1 output parameter of type logical(kind=c_bool). The subroutine is intended to retrieve a boolean value associated with the specified key. Use the imperative tone to define this subroutine.", "input": "", "output": "        subroutine c_uparser_get_bool(key, val) &\n            bind(c, name = \"uparser_get_bool\")\n            use, intrinsic :: iso_c_binding, only: c_char, c_bool\n            implicit none\n            character(kind=c_char), intent(in) :: key\n            logical(kind=c_bool),  intent(out) :: val\n        end subroutine c_uparser_get_bool\n"}, {"instruction": "Create a Fortran subroutine named c_uparser_get_char to retrieve a character value associated with a given key. The subroutine takes 1 input parameter of type character(kind=c_char) and provides 1 output parameter of type character(kind=c_char).", "input": "", "output": "        subroutine c_uparser_get_char(key, val) &\n            bind(c, name='uparser_get_char')\n            use, intrinsic :: iso_c_binding, only: c_char\n            character(kind=c_char),  intent(in) :: key\n            character(kind=c_char), intent(out) :: val\n        end subroutine c_uparser_get_char\n"}, {"instruction": "Create a Fortran subroutine named splint to perform spline interpolation. The subroutine takes 7 input parameters of types integer and real, and 1 output parameter of type real. The input parameters are n, nrow, ncol (integers), x (2D real array), xa, ya, y2a (1D real arrays). The output parameter is y (2D real array). Ensure to use the provided code for the subroutine.", "input": "", "output": "subroutine splint(xa,ya,y2a,n,x,nrow,ncol,y)\ninteger, intent(in) :: n, nrow, ncol\nreal, intent(in) :: x(nrow,ncol)\nreal, intent(in) :: xa(n,1), ya(n,1), y2a(n,1)\nreal, intent(out) :: y(nrow,ncol)\ninteger :: k, khi, klo, indr, indc\nreal :: a, b, h\nklo = 1\nkhi = n\n!print *, 'the fifth argument in splint.f90 is', x\ndo indr=1,nrow\n  do indc=1,ncol\n       klo = 1\n       khi = n\n       do while (khi-klo>1)\n          k=(khi+klo)/2\n          if (xa(k,1)>x(indr,indc)) then\n            khi=k\n          else\n            klo=k\n          end if\n       end do\n    h = xa(khi,1)-xa(klo,1)\n    a = (xa(khi,1)-x(indr,indc))/h\n    b = (x(indr,indc)-xa(klo,1))/h\n    y(indr,indc) = a*ya(klo,1)+b*ya(khi,1)+((a**3-a)*y2a(klo,1)+(b**3-b)*y2a(khi,1))*(h**2)/6.0\n  end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named f2ksubstr to locate the start and end positions of the first sub-string in the supplied character string. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters of type integer. The start position of the delimited string is returned as zero if the string is blank, and the end position of the delimited string is also returned as zero if the string is blank. Use this subroutine to efficiently find and extract sub-strings within a larger string.", "input": "", "output": "      subroutine f2ksubstr(string,istart,iend)\r\n!\r\n! locate start and end of first sub-string in supplied string\r\n!\r\n! string = character string to search\r\n! istart = start position of delimited string\r\n!          returned as zero if string is blank\r\n! iend   = end position of delimited string\r\n!          returned as zero if string is blank\r\n!\r\n      implicit none\r\n!\r\n      character(len=*), intent(in)  :: string\r\n      integer         , intent(out) :: istart,iend\r\n!\r\n      integer :: ipos,ipos2\r\n!\r\n! find start of sub-string\r\n!\r\n      do ipos = 1,len(string)\r\n        if (string(ipos:ipos) /= ' ') then\r\n            istart = ipos\r\n!\r\n! find the end of the sub-string\r\n!\r\n            ipos2 = index(string(ipos:),' ')\r\n            if (ipos2 == 0) then\r\n                iend = len(string)\r\n            else\r\n                iend = ipos2 + ipos - 2\r\n            end if\r\n            return\r\n        end if\r\n      end do\r\n!\r\n! string was blank\r\n!\r\n      istart = 0\r\n      iend   = 0\r\n      return\r\n      end subroutine f2ksubstr\r\n"}, {"instruction": "Create a Fortran subroutine named get_ref_date. It takes 1 input parameter of type character(len=*) and 1 output parameter of type integer. The subroutine reads the time units label and extracts the reference date if the label contains the word \"since\". If \"since\" is found, the subroutine extracts the date and assigns it to the output parameter.", "input": "", "output": " subroutine get_ref_date (units, date)\n\n  character(len=*), intent(in)  :: units\n  integer         , intent(out) :: date(6)\n\n  integer :: is, ie\n\n!---- returns the reference date from time units label ----\n!---- note: this version requires a specific format ----\n\n  date = 0\n\n  is = index(units, 'since')\n\n  if ( is > 0 ) then\n       ie = is + 24\n       read (units(is:ie),10) date(1:6)\n 10    format (6x,i4,5(1x,i2))      \n  endif\n\n end subroutine get_ref_date\n"}, {"instruction": "Create a Fortran subroutine named looktmdf to analyze a given character string and determine the presence of certain terms. The subroutine takes 1 input parameter of type character(len=2) and provides 2 output parameters of type integer.", "input": "", "output": "        subroutine looktmdf(sl, ip, nsl)\n!======================================================================\n!\n!     terms for the configuration d(1) f(1)\n!\n!----------------------------------------------------------------------\n           implicit none\n           integer, intent(out) :: ip\n           integer, intent(out) :: nsl\n           character(len=2), intent(in) :: sl\n           integer :: i1, j2, i\n           character(len=2), dimension(10) :: terms\n\n!             .. d1 f1 terms\n           data terms/'1p', '1d', '1f', '1g', '1h', '3p', '3d', '3f', '3g', '3h'/\n!\n           ip = 0\n           nsl = 0\n           i = 1\n           i1 = i\n           j2 = max(10, i1)\n           do i = i1, j2\n              if (sl /= terms(i)) cycle\n              nsl = nsl + 1\n              ip = i\n           end do\n           return\n        end subroutine looktmdf\n"}, {"instruction": "Create a Fortran subroutine named reorderpdg that takes an array of integers as input and rearranges the elements in ascending order. The number of input parameters is 1, with the test_data type being ['integer']. The number of output parameters is 1, with the test_data type also being ['integer'].", "input": "", "output": " subroutine reorderpdg(array_in,array_out)\n !********************************************************\n  implicit none\n  integer,intent(in) :: array_in(:)\n  integer,allocatable :: array_in_temp(:)\n  integer,intent(out) :: array_out(:)\n  integer,parameter :: veryhighnumber=1000000000 !should be higher than all the pdg numbers\n  integer :: i, minl\n\n  allocate(array_in_temp(lbound(array_in,dim=1):ubound(array_in,dim=1)))\n\n  array_in_temp=array_in\n  array_out=0\n\n  do i=lbound(array_in_temp,dim=1),ubound(array_in_temp,dim=1)\n    minl=minloc(array_in_temp,dim=1)\n    array_out(i)=array_in_temp(minl)\n    array_in_temp(minl)=veryhighnumber\n  enddo\n   \n  deallocate(array_in_temp)\n\n end subroutine reorderpdg\n"}, {"instruction": "Create a Fortran subroutine named bcucof that takes 6 input parameters of type double precision and dimension 4, and 2 input parameters of type double precision. The input parameters are y, y1, y2, y12, d1, and d2. The output parameter is c of type double precision and dimension 4x4. This subroutine computes a 4x4 table used for bicubic interpolation based on the given function, gradients, and cross derivative at four grid points of a rectangular grid cell, along with the lengths of the grid cell in the 1- and 2-directions.", "input": "", "output": "  subroutine bcucof(y,y1,y2,y12,d1,d2,c)\n    !\n    implicit none\n    !\n    double precision, intent(in) :: d1,d2\n    double precision, dimension(4), intent(in) :: y,y1,y2,y12\n    double precision, dimension(4,4), intent(out) :: c\n      !given arrays y, y1, y2, and y12, each of length 4, containing the function, gradients, and\n      !cross derivative at the four grid points of a rectangular grid cell (numbered counterclockwise\n      !from the lower left), and given d1 and d2, the length of the grid cell in the 1- and 2-\n      !directions, this routine returns the 4\u00d74 table c that is used by routine bcuint for bicubic\n      !interpolation.\n    double precision, dimension(16) :: x,c1\n    double precision :: xx\n!     double precision, dimension(4,4) :: c1\n    double precision, dimension(16,16) :: wt\n    integer :: i,j,k,l\n    data wt /1., 0.,-3., 2., 0., 0., 0., 0.,-3., 0., 9.,-6., 2., 0.,-6., 4., &\n\t     0., 0., 0., 0., 0., 0., 0., 0., 3., 0.,-9., 6.,-2., 0., 6.,-4., &\n\t     0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 9.,-6., 0., 0.,-6., 4., &\n             0., 0., 3.,-2., 0., 0., 0., 0., 0., 0.,-9., 6., 0., 0., 6.,-4., &\n             0., 0., 0., 0., 1., 0.,-3., 2.,-2., 0., 6.,-4., 1., 0.,-3., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0.,-1., 0., 3.,-2., 1., 0.,-3., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,-3., 2., 0., 0., 3.,-2., &\n             0., 0., 0., 0., 0., 0., 3.,-2., 0., 0.,-6., 4., 0., 0., 3.,-2., &\n             0., 1.,-2., 1., 0., 0., 0., 0., 0.,-3., 6.,-3., 0., 2.,-4., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 3.,-6., 3., 0.,-2., 4.,-2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,-3., 3., 0., 0., 2.,-2., &\n             0., 0.,-1., 1., 0., 0., 0., 0., 0., 0., 3.,-3., 0., 0.,-2., 2., &\n             0., 0., 0., 0., 0., 1.,-2., 1., 0.,-2., 4.,-2., 0., 1.,-2., 1., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0.,-1., 2.,-1., 0., 1.,-2., 1., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,-1., 0., 0.,-1., 1., &\n             0., 0., 0., 0., 0., 0.,-1., 1., 0., 0., 2.,-2., 0., 0.,-1., 1./\n\n    x(1:4)=y !pack a temporary vector x.\n    x(5:8)=y1*d1\n    x(9:12)=y2*d2\n    x(13:16)=y12*d1*d2\n    x=matmul(wt,x) !matrix multiply by the stored table.\n    c=reshape(x,(/4,4/),order=(/2,1/)) !unpack the result into the output table.\n\n  end subroutine bcucof\n"}, {"instruction": "Create a Fortran subroutine named c1 that takes an array of double precision values as input and outputs another array of double precision values. The input array is marked as intent(in) and the output array is marked as intent(out). The subroutine calculates the first element of the output array based on the values of the input array.", "input": "", "output": "    subroutine c1(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = x(1) + x(2) - 1\n    end subroutine c1\n"}, {"instruction": "Create a Fortran subroutine named dc1 that takes an array of double precision values as input and returns a 2x2 array of double precision values as output. The subroutine sets the elements of the output array dcx to specific values.", "input": "", "output": "    subroutine dc1(dcx, x)\n        double precision, intent(out) :: dcx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        dcx(1, 1) = 1\n        dcx(1, 2) = 1\n    end subroutine dc1\n"}, {"instruction": "Create a Fortran subroutine named testh2 that takes an input array of double precision values and outputs a 2D array of double precision values. The input parameter consists of a single array of double precision values, while the output parameter is a 2D array of double precision values. The subroutine initializes the output array to zeros and then sets the diagonal elements to 2.", "input": "", "output": "    subroutine testh2(hx, x)\n        double precision, intent(out) :: hx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        integer :: i, n\n        n = size(x)\n\n        hx(:, :) = 0.d0\n        do i = 1, n\n            hx(i, i) = 2\n        end do\n    end subroutine testh2\n"}, {"instruction": "Create a Fortran subroutine named dc2 that takes an array of double precision as input and computes the derivative of a specific mathematical function. The input parameter is of type double precision, intent(in) and the output parameter is of type double precision, intent(out).", "input": "", "output": "    subroutine dc2(dcx, x)\n        double precision, intent(out) :: dcx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        dcx(1, 1) = 3*(x(1) + x(2) - 1)**2\n        dcx(1, 2) = 3*(x(1) + x(2) - 1)**2\n    end subroutine dc2\n"}, {"instruction": "Create a Fortran subroutine named d2c2 to compute the elements of a three-dimensional array d2cx based on the computation involving a one-dimensional array x. The input parameter is a three-dimensional array d2cx of type double precision, and the output parameter is a one-dimensional array x of type double precision.", "input": "", "output": "    subroutine d2c2(d2cx, x)\n        double precision, intent(out) :: d2cx(:, :, :)\n        double precision, intent(in)  :: x(:)\n\n        d2cx(1, 1, 1) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 1, 2) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 2, 1) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 2, 2) = 6*(x(1) + x(2) - 1)\n    end subroutine d2c2\n"}, {"instruction": "Create a Fortran subroutine named c3 that takes an array of double precision numbers as input and returns another array of double precision numbers as output. The input is specified using the \"intent(in)\" attribute, and the output is specified using the \"intent(out)\" attribute. The subroutine computes the output array by modifying the input array based on specific operations.", "input": "", "output": "    subroutine c3(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = x(1) - 1\n        cx(2) = x(2)\n    end subroutine c3\n"}, {"instruction": "Create a Fortran subroutine named testg4 to perform an element-wise multiplication of an input array x of type double precision. The output array gx, also of type double precision, will store the result of multiplying each element of x by 2. The subroutine has 1 input parameter of type double precision and 1 output parameter of type double precision.", "input": "", "output": "    subroutine testg4(gx, x)\n        double precision, intent(out) :: gx(:)\n        double precision, intent(in)  :: x(:)\n\n        gx(:) = 2*x(:)\n    end subroutine testg4\n"}, {"instruction": "Write a Fortran subroutine named c4 that takes an array of double precision values as input and outputs an array of double precision values. The input array is marked as intent(in) and the output array is marked as intent(out). The subroutine calculates two equations and assigns the results to the elements of the output array. The number of input arguments is 1 and the test_data type is ['double precision'].The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "    subroutine c4(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = (x(1) - 1)**2 + (x(2) - 1)**2 - 1\n        cx(2) = (x(1) - 1)**2 + (x(2) + 1)**2 - 1\n    end subroutine c4\n"}, {"instruction": "Write a Fortran subroutine named tdma to solve a tridiagonal matrix equation. The subroutine takes 5 input parameters of type integer*4, real*8, real*8, real*8, and real*8, and 1 output parameter of type real*8. The subroutine uses the Thomas algorithm to solve the tridiagonal matrix equation.", "input": "", "output": "subroutine tdma(n, a, b, c, d, x)\n\n    implicit none\n\n    integer*4, intent(in)  :: n\n    real*8,    intent(in)  :: a(n)\n    real*8,    intent(in)  :: b(n)\n    real*8,    intent(in)  :: c(n)\n    real*8,    intent(in)  :: d(n)\n    real*8,    intent(out) :: x(n)\n\n    real*8    :: p(n) \n    real*8    :: q(n) \n    real*8    :: r(n) \n    integer*4 :: i\n\n    p(1) = -c(1)/b(1)\n    q(1) =  d(1)/b(1)\n    do i = 2, n\n        r(i) =  a(i)*p(i-1) + b(i)\n        p(i) = -c(i)/r(i)\n        q(i) = (d(i) - a(i)*q(i-1))/r(i)\n    end do\n\n    x(n) = q(n)\n    do i = n - 1, 1, -1\n        x(i) = p(i)*x(i+1) + q(i)\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named eapskill to perform a transformation on the input arrays covtheta, lintran, and meantheta. The subroutine takes 3 input parameters of type real(kind=8) and returns 2 output parameters of the same type. The covnewtheta and meannewtheta arrays are populated by performing matrix operations involving covtheta, lintran, and meantheta. Use this subroutine to transform covariance and mean arrays according to the specified calculations.", "input": "", "output": "subroutine eapskill(covtheta,lintran,meantheta,covnewtheta,meannewtheta)\r\nimplicit none\r\nreal(kind=8),intent(in)::covtheta(:,:,:),lintran(:,:),meantheta(:,:)\r\nreal(kind=8),intent(out)::covnewtheta(:,:,:),meannewtheta(:,:)\r\n!\tobs is observation number.\r\ninteger::obs\r\n!\tset up parameter arrays for simplified processing.\r\ndo obs=1,size(meantheta,2)\r\n\tcovnewtheta(:,:,obs)=matmul(lintran,matmul(covtheta(:,:,obs),transpose(lintran)))\r\n\tmeannewtheta(:,obs)=matmul(lintran,meantheta(:,obs))\r\n\t\r\nend do\r\n\r\nreturn\r\nend subroutine eapskill\r\n"}, {"instruction": "Create a Fortran subroutine named dp_format to format double precision numbers. The subroutine takes three input parameters: an integer n, an array of double precision numbers x, and an optional integer decimals. The subroutine also has two output parameters: an integer w and an integer d. \n\nThe dp_format subroutine first determines the number of decimal places required based on the optional decimals argument, or uses a default value if the argument is not present. It then calculates the minimum width required to accommodate the formatted numbers by finding the maximum absolute value of the elements in the x array and adding the number of decimal places and additional space.\n\nTo calculate the minimum width required, the subroutine finds the ceiling of the logarithm base 10 of the maximum absolute value of the elements in the x array. It then adds the number of decimal places and three additional spaces.\n\nThe subroutine assigns the calculated minimum width to the output parameter w and the number of decimal places to the output parameter d.", "input": "", "output": "  subroutine dp_format (n, x, w, d, decimals)\n    integer , intent(in) :: n\n    double precision , intent(in) :: x(n)\n    integer , intent(out) :: w, d\n    integer , optional , intent(in) :: decimals\n    ! ! alternative method variables\n    ! character(len=100) :: temp, fmt_temp, str_d\n    ! integer :: l\n    ! integer :: ii\n\n    ! determine decimal places, either from optional argument or predefined\n    ! global parameter\n    if (present(decimals)) then\n      d = decimals\n    else\n      d = dp_max\n    end if\n\n    ! determine minimum width required\n    w = max(ceiling(log10(maxval(abs(x(:))))), 1) + d + 3\n\n    ! ! alternative method\n    ! write (str_d, \"(i)\") d\n    ! write (fmt_temp, \"(i)\") \"(f0.\", trim(adjustl(str_d)), \")\"\n    ! l = 0\n    ! do ii = 1, n\n    !   write (temp, fmt_temp) x(ii)\n    !   l = max(l, len(trim(adjustl(temp))))\n    ! end do\n    ! w = l\n\n  end subroutine dp_format\n"}, {"instruction": "Write a Fortran subroutine named dp_format_string that takes two integer input arguments, w and d, and one output argument, str. The purpose of this subroutine is to generate a formatted string that represents a floating-point number with a specified width and decimal precision. The input parameters w and d specify the desired width and decimal precision, respectively. The output parameter str is an allocatable character array that will store the generated format string.\n\nThe subroutine begins by declaring some local variables and character arrays to store intermediate results. It then converts the integer values w and d into strings using the write function. Next, it constructs the format string by concatenating the necessary components using the write function and storing it in the str_temp character array.\n\nThe length of the non-empty part of the format string is determined by calculating the length of the trimmed and adjusted str_temp. Finally, the subroutine allocates the required memory for the output parameter str and writes the trimmed and adjusted str_temp into it using the write function.\n\nTo use this subroutine, you need to pass two input integers for w and d, and provide an allocatable character array for the output parameter str. The subroutine will generate a formatted string based on the input values of w and d and store it in the str array.", "input": "", "output": "  subroutine dp_format_string (w, d, str)\n    integer , intent(in) :: w, d\n    character(len=:) , allocatable , intent(out) :: str\n    character(len=100) :: str_w, str_d, str_temp\n    integer :: l\n\n    ! write width, decimal precision to string\n    write (str_w, *) w\n    write (str_d, *) d\n\n    ! write format string\n    write (str_temp, \"(a,a,a,a,a)\") &\n        \"(f\", trim(adjustl(str_w)), \".\", trim(adjustl(str_d)), \")\"\n\n    ! determine length of (non-empty part of) string\n    l = len(trim(adjustl(str_temp)))\n\n    ! write compacted format string (uses minimal space)\n    allocate(character(len=l) :: str)\n\n    write (str, \"(a)\") trim(adjustl(str_temp))\n\n  end subroutine dp_format_string\n"}, {"instruction": "Write a Fortran subroutine named dp_zero_string that creates a string of whitespaces with a specified width and inserts a dot at a specific position. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [character(len=:) , allocatable].", "input": "", "output": "  subroutine dp_zero_string (w, d, str)\n    integer , intent(in) :: w, d\n    character(len=:) , allocatable , intent(out) :: str\n\n    ! allocate\n    allocate(character(len=w) :: str)\n\n    ! write zero string\n    str = repeat(' ', w)\n    str(w-d:w-d) = '.'\n\n  end subroutine dp_zero_string\n"}, {"instruction": "Write a Fortran subroutine named \"cncalcelemaveragefromnodes\" that calculates the average value of elements based on the values of connected nodes. The subroutine takes four input parameters: \"elemcount\" and \"nodecount\" of type integer, \"elemconnect\" of type integer array with dimensions (elemcount,4), and \"rnodesin\" of type real*8 array with dimension (nodecount). The subroutine also has one output parameter: \"relemout\" of type real*8 array with dimension (elemcount).", "input": "", "output": "        subroutine cncalcelemaveragefromnodes (elemcount, nodecount,elemconnect,rnodesin,relemout) \n            implicit none\n            integer,   intent(in) :: elemcount, nodecount\n            integer,    intent(in) :: elemconnect(elemcount,4)\n            real*8,    intent(in) :: rnodesin(nodecount)\n            real*8,    intent(out):: relemout(elemcount)\n            real*8 ::valn1,valn2,valn3,valn4\n            integer i\n            \n            \n            do i=1,elemcount\n                valn1=rnodesin(elemconnect(i,1))\n                valn2=rnodesin(elemconnect(i,2))\n                valn3=rnodesin(elemconnect(i,3))\n                valn4=rnodesin(elemconnect(i,4))\n                relemout(i)=0.25*(valn1+valn2+valn3+valn4)\n            enddo\n            \n        end subroutine cncalcelemaveragefromnodes\n"}, {"instruction": "Provide a Fortran subroutine named paircount to perform a specific calculation. The purpose of this subroutine is to compute pairwise counts based on given input parameters. \n\nThe subroutine takes 13 input parameters:\n- Four integers: n1, n2, m, auto\n- Four real arrays of size n1: theta1, phi1, delta1, fpix1\n- Four real arrays of size n2: theta2, phi2, delta2, fpix2\n- One real array of size m+1: bins\n\nIt has one output parameter:\n- A real array of size 2 by m: c\n\nThe computation in the subroutine involves multiple loops and conditions. It first calculates the trigonometric functions for the input angles. Then, depending on the value of the auto parameter, it performs different calculations. \n\nIf auto is 0, it iterates over the elements of theta1 and theta2 arrays and calculates a value 's'. It then determines the bin id based on the 's' value and updates the elements of the c array accordingly.\n\nIf auto is 1 and n1 is equal to n2, it performs a similar calculation as above but with an additional condition that ensures the loop only runs for unique pairs of indices.\n\nThe subroutine returns after completing the calculations.\n\nPlease note that the subroutine uses Fortran-specific features such as array dimensions and array element access.", "input": "", "output": "subroutine paircount(theta1, phi1, theta2, phi2, delta1, delta2, fpix1, fpix2, bins, auto, c, n1,n2, m)\ninteger,intent(in) :: n1, n2, m, auto\nreal(8),dimension(n1),intent(in)   :: theta1, phi1, delta1, fpix1\nreal(8),dimension(n2),intent(in)   :: theta2, phi2, delta2, fpix2\nreal(8),dimension(m+1),intent(in)  :: bins\nreal(8),dimension(2,m),intent(out) :: c\n\n\nreal(8) :: s, be\ninteger :: i,j,binid\nreal(8), dimension(n1) :: cost1,sint1,cosp1,sinp1\nreal(8), dimension(n2) :: cost2,sint2,cosp2,sinp2\n\n\n!\ncost1 = dcos(theta1)\nsint1 = dsin(theta1)\ncosp1 = dcos(phi1)\nsinp1 = dsin(phi1)\n!\ncost2 = dcos(theta2)\nsint2 = dsin(theta2)\ncosp2 = dcos(phi2)\nsinp2 = dsin(phi2)\n\nc    = 0.0\ns    = 0.0\n\nif (auto .eq. 0) then\n    do i = 1, n1\n        do j = 1, n2\n           s = sint1(i)*sint2(j)*(cosp1(i)*cosp2(j) + sinp1(i)*sinp2(j))+cost1(i)*cost2(j)\n           be = bins(1) ! starts from the max sep angle\n           binid = 0\n           do while (s > be)\n                binid = binid + 1\n                be    = bins(binid+1)\n           end do\n           if ((binid .ge. 1) .and. (binid .le. m)) then\n               c(1,binid) = c(1,binid) + delta1(i)*delta2(j)*fpix1(i)*fpix2(j)\n               c(2,binid) = c(2,binid) + fpix1(i)*fpix2(j)\n           end if\n           s = 0\n        end do\n    end do\nelse if ((auto .eq. 1) .and. (n1 .eq. n2)) then\n    do i = 1, n1\n        do j = i+1, n1\n           !print*, i, j\n           s = sint1(i)*sint2(j)*(cosp1(i)*cosp2(j) + sinp1(i)*sinp2(j))+cost1(i)*cost2(j)\n           be = bins(1) ! starts from the max sep angle\n           binid = 0\n           do while (s > be)\n                binid = binid + 1\n                be    = bins(binid+1)\n           end do\n           if ((binid .ge. 1) .and. (binid .le. m)) then\n               c(1,binid) = c(1,binid) + delta1(i)*delta2(j)*fpix1(i)*fpix2(j)\n               c(2,binid) = c(2,binid) + fpix1(i)*fpix2(j)\n           end if\n           s = 0\n        end do\n    end do\nend if\nreturn\nend subroutine paircount\n"}, {"instruction": "Provide a Fortran subroutine named abc0 to calculate the coefficients a, b, and c for local orbitals (lo). The subroutine takes 14 input parameters of various types: logical, real*8, and integer. The output parameters consist of three real*8 variables. The purpose of this subroutine is to construct the lo orbitals based on different conditions. If the logical parameter \"lapw\" is true, the subroutine calculates the coefficients using specific formulas. Otherwise, different formulas are used based on the value of the integer parameter \"jlo\". The subroutine returns the coefficients a, b, and c as output parameters.", "input": "", "output": "subroutine abc0(alo,blo,clo,lapw,p,dp,pe,dpe,pei,plo,dplo,pi12lo,pe12lo,rmt_,l,jlo,qprint_)\n  implicit none\n  real*8, intent(out) :: alo, blo, clo\n  logical, intent(in) :: lapw\n  real*8,  intent(in) :: p, dp, pe, dpe, pei, plo, dplo, pi12lo, pe12lo, rmt_\n  integer, intent(in) :: l, jlo\n  logical, intent(in) :: qprint_\n  !..................................................................\n  !   abc calculates the cofficients a,b,c of the local orbitals (lo)\n  !..................................................................\n  !        local parameters\n  double precision   cutoff\n  parameter          (cutoff = 200.0d+0)\n  !        local scalars\n  double precision   xac, xbc, alonorm\n  !        intrinsic functions\n  \n  if(lapw) then\n     ! dpe are indexed from 0 to lmax2 in lapw2 usw\n     ! dpe are indexed from 1 to lmax2+1 in lapw1 usw\n     !   p(l)   = ul_rmt(1,l,jatom)\n     !   pe(l)  = ul_rmt(2,l,jatom)\n     !   dp(l)  = dul_rmt(1,l,jatom)\n     !   dpe(l) = dul_rmt(2,l,jatom)\n     !   plo(l) = ul_rmt(2+jlo,l,jatom)\n     !   dplo(l)= dul_rmt(2+jlo,l,jatom)\n     !   ri_mat(2,2,l,jatom)=pei(l) ! <udot|udot>\n     !   ri_mat(1,2+jlo,l,jatom) = pi12lo(jlo,l)  ! <u | u_lo>\n     !   ri_mat(2+jlo,1,l,jatom) = pi12lo(jlo,l)  ! <u_lo | u>\n     !   ri_mat(2,2+jlo,l,jatom) = pe12lo(jlo,l)  ! <udot | u_lo>\n     !   ri_mat(2+jlo,2,l,jatom) = pe12lo(jlo,l)  ! <u_lo | udot>\n     !   ri_mat(2+jlo,2+jlop,l,jatom) = pr12lo(jlo,jlop,l)  ! <u_lo | u_lo >\n     !\n     !  we construct the lo orbtial as   u_new = alo*u + blo*dotu + clo*u_lo\n     !    and require       u_new(r) = 0\n     !                  du_new/dr(r) = 0\n     !         and     <u_new|u_new> = 1\n     !  which leads to:\n     ! xac =  (u_lo*ddotu-du_lo*dotu)*r^2\n     ! xbc = -(u_lo*du - du_lo*u)*r^2\n     ! clo =   1/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     ! alo = xac/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     ! blo = xbc/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     xac = (plo*dpe - dplo*pe)*rmt_**2\n     xbc = -(plo*dp - dplo*p)*rmt_**2\n     clo = 1.0d0/sqrt(1.d0 + xac*(xac + 2.0d0*pi12lo) + xbc*(xbc*pei + 2.0d0*pe12lo))\n     clo = min(clo,cutoff)\n     alo = clo*xac\n     blo = clo*xbc\n  else\n     !.....apw definitions\n     if(jlo.eq.1) then  ! apw+lo, hence ony u and dotu are used\n        ! we construct the lo orbtial as   u_new = alo*u + blo*dotu\n        !   and require       u_new(r) = 0\n        !        and     <u_new|u_new> = 1\n        ! which leads to:\n        ! alo = 1/sqrt(1 + (u/dotu)**2 * <dotu|dotu>)\n        ! blo = -u/dotu/sqrt(1 + (u/dotu)**2 * <dotu|dotu>)\n        ! clo = 0.d0\n        alonorm=sqrt(1.d0+(p/pe)**2*pei)\n        alo = 1.d0 /alonorm \n        blo = -p/pe/alonorm\n        clo = 0.d0\n     else ! apw+lo\n        ! we construct the lo orbital as u_new = alo*u + clo*u_lo\n        !   and require       u_new(r) = 0\n        !       and      <u_new|u_new> = 1\n        ! which leads to:\n        ! xac = sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        ! alo = 1/sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        ! clo = -u/u_lo /sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        xbc=-p/plo\n        xac=sqrt(1+xbc**2+2*xbc*pi12lo)\n        alo = 1.d0/xac\n        blo = 0.d0\n        clo = xbc/xac\n     endif\n  endif\n  if (qprint_) write(6,6000) l,alo,blo,clo\n  !\n  return\n  !\n6000 format ('lo coefficient: l,a,b,c  ',i2,5x,3f12.5)\nend subroutine abc0\n"}, {"instruction": "Write a Fortran subroutine named compute_stream_function to compute the stream function values for a given grid size and domain. The subroutine takes 9 input parameters: nx (integer), ny (integer), hx (real), hy (real), xmin (real), xmax (real), ymin (real), ymax (real), and b (real). It also has one output parameter s (real 2D array). \n\nThe subroutine uses a nested loop to iterate over the grid points and calculates the stream function value at each point based on the given formula. The calculated values are stored in the s array.\n\nPlease note that the subroutine uses the concurrent loop construct to parallelize the computation.\n\nNow, write the Fortran subroutine code.", "input": "", "output": "  subroutine compute_stream_function(nx, ny, hx, hy, xmin, xmax, ymin, ymax, b, s)\n    implicit none\n    ! arguments\n    integer, intent(in) :: nx, ny\n    real, intent(in) :: hx, hy\n    real, intent(in) :: xmin, xmax, ymin, ymax\n    real, intent(in) :: b\n    real, intent(out) :: s(:, :)\n    ! local variables\n    real, parameter :: pi = 3.141592653589793238462643383279502884\n    real :: x = 0.0, y = 0.0\n    integer :: i = 0, j = 0\n\n    do concurrent (i=1:nx, j=1:ny)\n      x = xmin + (i-1) * hx\n      y = ymin + (j-1) * hy\n      s(i, j) = b * sin((pi * x) / xmax) * sin((pi * y) / ymax)\n    end do\n\n  end subroutine compute_stream_function\n"}, {"instruction": "Create a Fortran subroutine named compute_velocity to calculate the velocity components at interior points of a grid using centered finite differences. The subroutine takes 3 input arguments of type real (hx, hy, s) and provides 2 output arguments of type real (vx, vy).", "input": "", "output": "  subroutine compute_velocity(s, hx, hy, vx, vy)\n    implicit none\n    ! arguments\n    real, intent(in) :: hx, hy\n    real, intent(in) :: s(:, :)\n    real, intent(out) :: vx(:, :)\n    real, intent(out) :: vy(:, :)\n    ! local variables\n    integer :: nx, ny\n    nx = size(s, 1)\n    ny = size(s, 2)\n\n    ! initialize vx and vy\n    vx = 0.0\n    vy = 0.0\n\n    ! compute velocity at each interior point using centered finite differences\n    vx(2:nx-1, 2:ny-1) =  (s(2:nx-1, 3:ny) - s(2:nx-1, 1:ny-2)) / (2 * hy)\n    vy(2:nx-1, 2:ny-1) = -(s(3:nx, 2:ny-1) - s(1:nx-2, 2:ny-1)) / (2 * hx)\n\n  end subroutine compute_velocity\n"}, {"instruction": "Create a Fortran subroutine named lay2vel1 that takes 4 input parameters of type integer, integer, real, and real and 1 output parameter of type real. The subroutine should use the input parameters to calculate and output the velocity values based on the layer thicknesses and velocities provided.", "input": "", "output": "  subroutine lay2vel1(vel, lay, nlay, dz, nz)\n    integer, intent(in) :: nlay, nz\n    real, intent(in) :: lay(nlay,2), dz\n    real, intent(out) :: vel(nz)\n    integer :: i, ztop, zbot\n\n    ztop = 1\n    do i = 1, nlay\n      zbot = min( nint( lay(i,2) / dz ), nz )\n      vel(ztop:zbot) = lay(i,1)\n      if ( zbot .ge. nz ) then\n        exit\n      else\n        ztop = zbot + 1\n      end if\n    end do\n    vel(zbot+1:nz) = lay(nlay,1)\n    return\n  end subroutine lay2vel1\n"}, {"instruction": "Write a Fortran subroutine named sphericaltocart to convert spherical coordinates (r, theta, phi) to Cartesian coordinates (x, y, z). The subroutine takes 3 input arguments of type real (r, theta, phi) and provides 3 output arguments of type real (x, y, z).", "input": "", "output": "    subroutine sphericaltocart(r, theta, phi, x, y, z)\n       implicit none\n\n       real, intent(in)  :: r, theta, phi\n       real, intent(out) :: x, y, z\n\n       x=r*sin(theta)*cos(phi)\n       y=r*sin(theta)*sin(phi)\n       z=r*cos(theta)\n    end subroutine sphericaltocart\n"}, {"instruction": "Write a Fortran subroutine named stpnt that initializes the elements of the array par and the array u according to specific values. The subroutine takes 2 input parameters of type integer and double precision and returns 2 output parameters of type double precision and double precision.", "input": "", "output": " subroutine stpnt(ndim,u,par,t)\n!---------- -----\n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   par(1)=5.0         ! a_1\n   par(2)=3.0         ! b_1\n   par(3)=1.10830e+00 ! d_1\n   par(4)=0.1         ! a_2\n   par(5)=2.0         ! b_2\n   par(6)=0.01        ! d_2\n\n   u(1:3)=(/log(0.66163d0),log(0.20199d0),0.0d0/)\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named random_number_int to generate an array of random integers within a specified range. The subroutine takes 2 input parameters of type integer and optional integer, and 1 output parameter of type integer. The first input parameter specifies the maximum value for the random numbers, and the optional second input parameter specifies the minimum value (defaulted to 0 if not provided).", "input": "", "output": "    subroutine random_number_int(array, max, min)\n        !arguments\n        integer, intent(out) :: array(:)\n        integer, intent(in) :: max\n        integer, optional, intent(in) :: min\n        !variables\n        integer :: i, min_number\n        real :: rand\n\n        if(present(min)) then\n            min_number = min\n        else\n            min_number = 0\n        endif\n\n        do i=1,size(array)\n            call random_number(rand)\n            array(i) = int((max-min_number+1)*rand) + min_number\n        end do\n    end subroutine random_number_int\n"}, {"instruction": "Write a Fortran subroutine named covariance_matrix that computes the covariance matrix of input data. The number of input arguments is 1, and the test_data type is ['real'] representing the input data matrix. The number of output arguments is 1, and the test_data type is ['real'] representing the covariance matrix.", "input": "", "output": "    subroutine covariance_matrix(x, cov)\n        !arguments\n        real, intent(in) :: x(:,:)\n        real, intent(out) :: cov(:,:)\n        !variables\n        integer :: i, j, n_samples, n_data\n        real :: mean_i, mean_j\n\n        n_samples = size(x, dim=1)\n        n_data = size(x, dim=2)\n\n        do i=1,n_data\n            mean_i = sum(x(:,i))/n_samples\n            do j=1,i\n                mean_j = sum(x(:,j))/n_samples\n                cov(i,j) = sum((x(:,i)-mean_i)*(x(:,j)-mean_j))/(n_samples-1)\n                cov(j,i) = cov(i,j)\n            end do\n        end do\n    end subroutine covariance_matrix\n"}, {"instruction": "Create a Fortran subroutine named get_ggg_kinetic to calculate the kinetic energy geometric tensor. The subroutine takes 2 input parameters of type real(8) and 3x3 arrays, and 1 output parameter of type real(8) array. The input parameters are aa and bb, and the output parameter is ggg.", "input": "", "output": "  subroutine get_ggg_kinetic(aa,bb,ggg)\n    implicit none\n    real(8),intent(in)  :: aa(3,3),bb(3,3)\n    real(8),intent(out) :: ggg(6)\n    real(8) :: const,a1,a2,a3\n    const=1.d0/(4.d0*acos(-1.d0)**2)\n    a1 = sqrt( sum( aa(:,1)**2 ) )\n    a2 = sqrt( sum( aa(:,2)**2 ) )\n    a3 = sqrt( sum( aa(:,3)**2 ) )\n    ggg(1) = a1*a1*sum(bb(:,1)*bb(:,1))*const\n    ggg(2) = a2*a2*sum(bb(:,2)*bb(:,2))*const\n    ggg(3) = a3*a3*sum(bb(:,3)*bb(:,3))*const\n    ggg(4) = a1*a2*sum(bb(:,1)*bb(:,2))*const\n    ggg(5) = a2*a3*sum(bb(:,2)*bb(:,3))*const\n    ggg(6) = a3*a1*sum(bb(:,3)*bb(:,1))*const\n  end subroutine get_ggg_kinetic\n"}, {"instruction": "Create a Fortran subroutine named fun with two input parameters, one of real type (x) and the other of real, dimension(:) type (param). The subroutine also has two output parameters, one of real type (f) and an optional one of real type (df).", "input": "", "output": "       subroutine fun(x, param, f, df)\n         implicit none\n         real, intent(in)  :: x                     !< function argument x\n         real, dimension(:), intent(in) :: param    !< additional parameters\n         real, intent(out) :: f                     !< function value f(x)\n         real, intent(out), optional :: df          !< derivative value df(x)/dx\n       end subroutine fun\n"}, {"instruction": "Create a Fortran subroutine named getnuniquerandomnumbers. This subroutine generates a specified number of unique random integers within a specified range and stores them in an array. The number of input parameters is 2, with test_data type ['integer', 'integer'], representing the number of random numbers and the range of values. The number of output parameters is 1, with test_data type ['integer'], representing the array of unique random numbers.", "input": "", "output": "subroutine getnuniquerandomnumbers(rvals, rvn, nw)\n  ! stores rvn integer random numbers into array rvals(1:rvn), which can take values -nw,-nw+1,...,nw,nw+1\n  implicit none\n  integer, intent(in)  :: rvn, nw\n  integer, intent(out) :: rvals(rvn)\n  ! locals\n  integer :: i, j, ix\n  real*8  :: x\n  logical :: duplicate\n  do i=1,rvn\n     do\n        call random_number(x)\n        ix = int(x*(2*nw+1))-nw\n        duplicate=.false.\n        do j=1,i-1\n           if (ix.eq.rvals(j)) then\n              duplicate=.true.\n              !print *, 'found duplicate', i, j, ix\n              exit\n           endif\n        enddo\n        if (.not.duplicate) exit\n     enddo\n     rvals(i) = ix\n     !print *, i, ix\n  enddo\nend subroutine getnuniquerandomnumbers\n"}, {"instruction": "Create a Fortran subroutine named identity that takes a single input argument of type character and returns a single output argument of type character. The subroutine copies the input character to the output character.", "input": "", "output": "    subroutine identity(x, y)\n        character, intent(in) :: x\n        character, intent(out) :: y\n        y = x\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_aainv to calculate the inverse of a 3x3 matrix. The subroutine takes one input parameter of type real(8) and intent(in), and one output parameter of type real(8) and intent(out).", "input": "", "output": "  subroutine calc_aainv( aa, bb )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: bb(3,3)\n    real(8) :: va\n    va = aa(1,1)*aa(2,2)*aa(3,3)+aa(1,2)*aa(2,3)*aa(3,1) &\n        +aa(1,3)*aa(2,1)*aa(3,2)-aa(1,3)*aa(2,2)*aa(3,1) &\n        -aa(1,2)*aa(2,1)*aa(3,3)-aa(1,1)*aa(2,3)*aa(3,2)\n    bb(1,1) = aa(2,2)*aa(3,3) - aa(3,2)*aa(2,3)\n    bb(2,1) = aa(3,2)*aa(1,3) - aa(1,2)*aa(3,3)\n    bb(3,1) = aa(1,2)*aa(2,3) - aa(2,2)*aa(1,3)\n    bb(1,2) = aa(2,3)*aa(3,1) - aa(3,3)*aa(2,1)\n    bb(2,2) = aa(3,3)*aa(1,1) - aa(1,3)*aa(3,1)\n    bb(3,2) = aa(1,3)*aa(2,1) - aa(2,3)*aa(1,1)\n    bb(1,3) = aa(2,1)*aa(3,2) - aa(3,1)*aa(2,2)\n    bb(2,3) = aa(3,1)*aa(1,2) - aa(1,1)*aa(3,2)\n    bb(3,3) = aa(1,1)*aa(2,2) - aa(2,1)*aa(1,2)\n    bb(:,:) = bb(:,:)/va\n    bb(:,:) = transpose( bb )\n  end subroutine calc_aainv\n"}, {"instruction": "Create a Fortran subroutine named check_open to handle file opening and management. The subroutine takes 1 input parameter of type character(*) for the file name. It returns 2 output parameters of type integer.", "input": "", "output": "      subroutine check_open( file_name, file_num, err )\n\n         ! unit number or to open a file named file_name (create the file if it doesn't exist)\n         implicit none\n         character(*), intent(in) :: file_name\n         integer, intent(out)     :: file_num, err\n         logical                  :: isopen, isthere\n\n         err=0\n         inquire( file=file_name, opened=isopen, exist=isthere, number=file_num )\n         if ( isopen ) goto 10\n\n         file_num = 1\n         do\n            inquire( unit=file_num, opened=isopen )\n            if ( .not. isopen ) exit\n            file_num = file_num + 1\n         enddo\n\n         if ( isthere ) then\n            open( unit=file_num, file=file_name, action='write', status='old', iostat=err )\n         else\n            open( unit=file_num, file=file_name, action='write', status='new', iostat=err )\n         endif\n\n         10 return\n\n      end subroutine check_open\n"}, {"instruction": "Write a Fortran subroutine named \"s\" that takes 4 input integer arguments and returns 1 output integer argument. The input argument types are ['integer', 'integer', 'integer', 'integer'], and the output argument type is ['integer']. The subroutine should compute the output by concatenating the input integers as per the given formula.", "input": "", "output": "    subroutine s(a, b, c, d, f)\n    integer, intent(in) :: a, b, c, d\n    integer, intent(out) :: f\n    f = a*1000 + b*100 + c*10 + d\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rotylm to compute the rotation matrix given the gradient matrices in complex numbers. The subroutine takes 3 input parameters of type complex and intent(in), and 1 output parameter of type complex and intent(out). The input parameters are gradmtx, gradmty, and gradmtz, while the output parameter is rotmt.", "input": "", "output": "   subroutine rotylm(gradmtx, gradmty, gradmtz, rotmt)\n      complex, intent(in) :: gradmtx(:,:,:,:), gradmty(:,:,:,:), gradmtz(:,:,:,:) !r,lm,n,x\n      complex, intent(out) :: rotmt(:,:,:,:)\n\n      rotmt(:,:,:,1)=gradmtz(:,:,:,2)-gradmty(:,:,:,3)\n      rotmt(:,:,:,2)=gradmtx(:,:,:,3)-gradmtz(:,:,:,1)\n      rotmt(:,:,:,3)=gradmty(:,:,:,1)-gradmtx(:,:,:,2)\n\n   end subroutine rotylm\n"}, {"instruction": "Create a Fortran subroutine named getbasename to extract the indices of the base name from a given filename. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type integer array with size 2.", "input": "", "output": "      subroutine getbasename(filename, indices)\n            implicit none\n            character(*), intent(in) :: filename\n            integer, intent(out) :: indices(2)\n            integer :: n, temp, slashtemp, extindex, slashindex\n\n            n = len(filename)\n            temp = index(filename, '/')\n            slashtemp = 0\n            slashindex = 0\n            do while (temp.ne.0 .and. slashtemp.ne.n)\n                slashtemp = slashtemp + temp\n                slashindex = slashtemp\n                temp = index(filename(slashtemp+1:), '/')\n            end do\n\n            extindex = index(filename(slashindex+1:), '.')\n            if (extindex.eq.0) then\n                extindex = n + 1\n            else\n                extindex = slashindex + extindex\n            end if\n\n            indices(1) = slashindex + 1\n            indices(2) = extindex - 1\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named int2bool that takes an input parameter of type integer and an output parameter of type logical. The subroutine converts the input integer to a boolean value by assigning true if the integer is non-zero, and false if the integer is zero.", "input": "", "output": "subroutine int2bool (lhs, rhs)\n   implicit none\n   logical, intent(out) :: lhs\n   integer, intent(in) :: rhs\n\n   lhs = rhs .ne. 0\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_baro_u to calculate the barotropic velocity field based on the provided input parameters. The subroutine takes 10 input parameters of type double precision, integer and calculates 1 output parameter of type double precision.", "input": "", "output": "  subroutine calc_baro_u(ub, u, h, eta, freesurffac, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    double precision, intent(out) :: ub(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    double precision, intent(in)  :: u(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: h(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: eta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    double precision, intent(in)  :: freesurffac\n    integer, intent(in) :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer i, j, k\n    double precision h_temp(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n\n    ub = 0d0\n\n    h_temp = h\n    ! add free surface elevation to the upper layer\n    h_temp(:, :, 1) = h(:, :, 1) + eta*freesurffac\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol\n          ub(i,j) = ub(i,j) + u(i,j,k)*(h_temp(i,j,k)+h_temp(i-1,j,k))/2d0\n        end do\n      end do\n    end do\n\n    return\n  end subroutine calc_baro_u\n"}, {"instruction": "Create a Fortran subroutine named calc_metric to compute the metric of a 3x3 tensor 'a' and store the result in 'm'. The input parameter is a 3x3 real(8) array, and the output parameter is a 3x3 real(8) array.", "input": "", "output": "  subroutine calc_metric(a, m)\n    !! compute the metric of a box of tensor `a` to `m`.\n    real(8), intent(in) :: a(3,3)\n    real(8), intent(out) :: m(3,3)\n\n    integer :: i,j,k\n    do i=1,3\n      do j=1,3\n        m(i,j) = 0.d0\n        do k=1,3\n          m(i,j) = m(i,j) + a(k,i)*a(k,j)\n        end do\n      end do\n    end do\n\n  end subroutine calc_metric\n"}, {"instruction": "Create a Fortran subroutine named create_box_from_3l3a to compute a box tensor from box lengths and box angles. The subroutine takes 6 input parameters of type real(8) representing the box lengths (la, lb, lc) and box angles (alpha, beta, gamma), and outputs a 3x3 array of real(8) representing the box tensor. The subroutine should be written in the imperative tone.", "input": "", "output": "  subroutine create_box_from_3l3a(boxtens,la,lb,lc,alpha,beta,gamma)\n    !! computes a box tensor from box lengths and box angles.\n    implicit none\n    real(8),intent(in) :: la,lb,lc,alpha,beta,gamma\n    real(8),intent(out) :: boxtens(3,3)\n\n    real(8) :: a(3),b(3),c(3)\n\n    a(1)=la ; a(2)=0.d0 ; a(3)=0.d0\n    b(1)=lb*cos(gamma) ; b(2) = lb*sin(gamma) ; b(3)=0.d0\n    c(1)=lc*cos(beta) \n    c(2)=lc/(lb*sin(gamma))*(lb*cos(alpha)-la*cos(beta)*cos(gamma))\n    c(3) = sqrt(lc**2-c(2)**2-c(1)**2)\n\n    boxtens(1,:) = a\n    boxtens(2,:) = b\n    boxtens(3,:) = c\n\n  end subroutine create_box_from_3l3a\n"}, {"instruction": "Create a Fortran subroutine named calc_eij_morse to calculate the interaction energy eij based on the Morse potential function. The subroutine takes 2 input parameters of type real*8, dimension(3) and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine calc_eij_morse(rij, param, eij)\n\n    implicit none\n    real*8, dimension(3), intent(in) :: param\n    real*8, intent(in) :: rij\n    real*8, intent(out) :: eij\n    real*8 :: t\n    t = exp(-param(2)*(rij-param(3)))\n    eij = param(1) * (t*t - 2*t)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named stpnt to initialize the array parameters par and the array solution u. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 2, and their test_data types are [double precision, double precision].", "input": "", "output": "subroutine stpnt(ndim,u,par)\n!--------- -----\n  \n  implicit none\n  integer, intent(in) :: ndim\n  double precision, intent(out) :: u(ndim), par(*)\n\n  par(1:3) = (/ 1.0d0, 2.0d0, 0.0d0 /)\n\n  u(1) = 1.0 \n   \nend subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named build_square to generate a square mesh of triangles. The subroutine takes 4 input parameters of type integer and real(8), and returns 4 output parameters of type real(8), integer, integer, and integer. The inputs are the number of points per side, the number of elements, the number of nodes, and the width of one side of the square. The outputs are the xyz points, the element map, the boundary conditions, and the hex number.", "input": "", "output": "      subroutine build_square(jjmax, nelem, nnode, width, xi, gg, ibc, ihex)\n      implicit none\n      integer, intent(in)  :: jjmax    ! number of points per side\n      integer, intent(in)  :: nelem    ! number of elements\n      integer, intent(in)  :: nnode    ! number of nodes\n      real(8), intent(in)  :: width    ! width of one side of square\n      real(8), intent(out) :: xi(3,nnode)   ! xyz points\n      integer, intent(out) :: gg(3,nelem)   ! element map\n      integer, intent(out) :: ibc(nnode)    ! boundary conditions\n      integer, intent(out) :: ihex(nelem)   ! hex number\n\n      integer :: i, j\n      integer :: ne      ! element counter\n      integer :: nn      ! node counter\n      real(8) :: delx\n      real(8) :: x, y\n\n      write (*,*)\n      write (*,*) 'building square mesh of triangles'\n      write (*,*) 'number of points along edge ', jjmax\n\n      ibc(:)=0\n\n      delx=width/dble(jjmax)  ! mesh width\n\n      nn=0\n      ne=0\n\n      y=0.0d0\n      do j=0, jjmax\n        x=0.0d0\n        do i=0,jjmax\n\n           nn=nn+1\n           xi(1,nn)=x\n           xi(2,nn)=y\n           xi(3,nn)=0.0d0\n           x=x+delx\n\n           if (i.eq.0) ibc(nn)=3\n           if (j.eq.0) ibc(nn)=3\n           if (i.eq.jjmax) ibc(nn)=3\n           if (j.eq.jjmax) ibc(nn)=3\n\n           if (i.ne.0 .and. y.ne.0) then    ! first nn is 11\n             ne=ne+1\n             gg(1,ne)=nn-jjmax-2\n             gg(2,ne)=nn-jjmax-1\n             gg(3,ne)=nn-1\n\n             ihex(ne)=(i-1)*jjmax+j\n\n             ne=ne+1\n             gg(1,ne)=nn-1\n             gg(2,ne)=nn-jjmax-1\n             gg(3,ne)=nn\n\n             ihex(ne)=ihex(ne-1)\n           endif\n        enddo\n\n        y=y+delx\n      enddo\n\n      if (nn.ne.nnode) stop 'nnode error in square_build'\n      if (ne.ne.nelem) stop 'nelem error in square_build'\n\n      return\n      end subroutine build_square\n"}, {"instruction": "Write a Fortran subroutine named l2g to calculate the global array index based on the local array index, processor array index, global array dimension, processor array dimension, and block size. The subroutine takes 5 input parameters of type integer: il, p, n, np, and nb. It returns 1 output parameter of type integer, i, which represents the global array index.", "input": "", "output": "   pure subroutine l2g(il, p, n, np, nb, i)\n      implicit none\n      integer,intent(in) :: il   ! local array index, input\n      integer,intent(in) :: p    ! processor array index, input\n      integer,intent(in) :: n    ! global array dimension, input\n      integer,intent(in) :: np   ! processor array dimension, input\n      integer,intent(in) :: nb   ! block size, input\n      integer,intent(out) :: i    ! global array index, output\n      integer :: ilm1\n      ilm1 = il - 1\n      i = (((ilm1/nb)*np) + p)*nb + mod(ilm1, nb) + 1\n      return\n   end subroutine l2g\n"}, {"instruction": "Create a Fortran subroutine named open_for_write to open a new stream input/output file and return the I/O unit used. The number of input parameters is 1 with the test_data type of ['character(len=*)'], and the number of output parameters is 1 with the test_data type of ['integer'].", "input": "", "output": "subroutine open_for_write(fname, funit)\n! creates a new stream i/o file returning i/o unit used   \n! cgp 2009 jan 28\ncharacter(len=*), intent(in)  :: fname\ninteger, intent(out)          :: funit\n!\nlogical :: exists, open\n! get free i/o unit number\ndo funit = 90, 7, -1\n    inquire(unit=funit, exist=exists, opened=open)\n    if(exists .and. .not. open) exit\nend do\nif(funit < 7) stop 'open_for_write failed - no free i/o units'\nopen (unit=funit, file=fname, access=\"stream\", status=\"replace\")\nend subroutine open_for_write\n"}, {"instruction": "Write a Fortran subroutine named trans that takes a matrix x of real numbers as input and produces the transpose of x as output. The input parameter is of type real, dimension(:,:), and is specified with intent(in). The output parameter is also of type real, dimension(size(x,2), size(x,1)), and is specified with intent(out).", "input": "", "output": "subroutine trans(x,y)\r\n  implicit none\r\n  real, intent(in), dimension(:,:) :: x\r\n  real, intent(out), dimension( size(x,2), size(x,1) ) :: y\r\n  integer :: n, m, i, j\r\n  n = size(x,1)\r\n  m = size(x,2)\r\n  do i=1,n\r\n     do j=1,m\r\n        y(j,i) = x(i,j)\r\n     end do\r\n  end do\r\nend subroutine trans\r\n"}, {"instruction": "Write a Fortran subroutine named \"flatten\" that takes a 2D array as input and outputs a 1D array containing the elements of the input array in row-major order. The input parameter is of type real, dimension(:,:), and the output parameter is of type real, dimension(size(x)).", "input": "", "output": "subroutine flatten(x,y)\r\n  implicit none\r\n  real, intent(in), dimension(:,:) :: x\r\n  real, intent(out), dimension( size(x) ) :: y\r\n  integer :: n, m, i, j, k\r\n  n = size(x,1)\r\n  m = size(x,2)\r\n  k = 1\r\n  do i=1,n\r\n     do j=1,m\r\n        y(k) = x(i,j)\r\n        k = k + 1\r\n     end do\r\n  end do\r\nend subroutine flatten\r\n"}, {"instruction": "Write a Fortran subroutine named locate to locate the index of a value x in a given monotonic array xx. The subroutine takes 2 input parameters of type real: xx (array of monotonic values) and x (value to be located), and 1 output parameter of type integer: j (index where x is located in xx). The subroutine is adapted from the numerical recipe and uses a do loop to step through the array and find the index.", "input": "", "output": "subroutine locate (xx, x, j)\n\n!-------------------------------------------------------------------------------\n! name:     locate\n! purpose:  locates index of value x for given monotonic array xx.\n! input:    xx:  array of monotonic values\n!                for our application, it represents vertical coordinate values\n!           x:   value to bracket in xx\n! output:   j:   index where x is located in xx\n!                            xx(j) <= x < xx(j+1)  \n!                 ***  i hope this is correct - test it dwb    \n! notes:    this routine is adapted from the numerical recipe.\n! revised:  ?? ??? 19??  original version.  (d. byun)\n!           10 sep 2001  converted to free-form f90.  removed n from\n!                        argument list.  (t. otte)\n!           19 mar 2002  corrected upper limit on do loop.  (t. otte)\n!           07 sep 2011  updated disclaimer.  (t. otte)\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  integer,       intent(out)   :: j\n  integer                      :: lbnd\n  real,          parameter     :: small      = 1.0e-6\n  integer                      :: ubnd\n  real,          intent(in)    :: x\n  real,          intent(in)    :: xx         ( : )\n\n  ! step thru array 1 element at a time.\n\n  lbnd = lbound(xx,1)\n  ubnd = ubound(xx,1)\n\n  do j = lbnd, ubnd-1\n    if ( ( x+small >= xx(j) ) .and. ( x < xx(j+1) ) ) exit\n  enddo\n\nend subroutine locate\n"}, {"instruction": "Write a Fortran subroutine named compress. The subroutine takes 4 input parameters of types integer, real*8, real*8, and real*8, and 4 output parameters of types real*8, real*8, real*8, and integer. The subroutine compresses the input Gaussian functions based on their heights, widths, and hill positions, and then outputs the compressed Gaussian functions.", "input": "", "output": "subroutine compress(ng,hill,height,width,cng,c_hill,c_width,c_height)\nimplicit none\n integer, intent(in)::ng\n real*8,  intent(in)::hill(ng),width(ng),height(ng)\n real*8, intent(out)::c_hill(ng),c_width(ng),c_height(ng)\n integer,intent(out)::cng\n!\n integer :: i,j,n,min_j\n real*8  :: distance,cutoff=1.0,dum,new_height,new_width,new_hill,min_d\n!\n! initialization of compressed gaussians\n c_hill(1) =hill(1)\n c_width(1)=width(1)\n c_height(1)=height(1)\n n=1\n \n do i=2,ng\n    min_d=sqrt(abs(((hill(i))-c_hill(1))/c_width(1))**2)\n    min_j=1\n      do j=1,n\n         distance=sqrt(abs(((hill(i))-c_hill(j))/c_width(j))**2)\n         if(distance.lt.min_d) then\n            min_d=distance\n            min_j=j\n         endif\n        ! print*,\"distance: \",distance\n     enddo\n     !print*,\"minimum distance: \",min_d,\"location: \",min_j\n     !if minimun distance is less than given cutoff, it merges the both gaussinas\n     ! add as new compressed kernal otherwise.   \n     if(min_d.lt.cutoff)then\n           new_height=height(i)+c_height(min_j)\n           new_hill  =(1.0/new_height)*((height(i)*hill(i))+(c_height(min_j)*c_hill(min_j)))\n           dum=(height(i)*(width(i)**2+hill(i)**2)+c_height(min_j)*(c_width(min_j)**2+c_hill(min_j)**2))\n           new_width=(1.0/new_height)*dum-new_hill**2\n           ! store new variables to min_jth kernel\n           c_height(min_j)=new_height           \n           c_width(min_j)=new_width\n           c_hill(min_j)=new_hill\n        else\n           n=n+1\n           c_height(n)=height(i)  \n           c_width(n)=width(i)\n           c_hill(n)=hill(i)\n        endif   \n\n enddo\n! store n as no. of compressed gaussians\n cng=n\n\nend subroutine compress\n"}, {"instruction": "Create a Fortran subroutine named get_value_definitions to fetch the definition for a given long variable name and requested value. The subroutine takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=*). The input parameters are long_var_name and req_val, and the output parameter is ret_val.", "input": "", "output": "subroutine get_value_definitions(long_var_name, req_val, ret_val)\n    implicit none\n    character(len=*), intent(in) :: long_var_name\n    character(len=*), intent(in) :: req_val\n    character(len=*), intent(out) :: ret_val\n    print *, 'ltrans_bmi> fetching definition for the long variable name: ', trim(long_var_name)\n    select case( trim(long_var_name) )\n        case('s_coordinate_stretching_curves_at_rho_points')\n            if(trim(req_val) == \"type\")then\n                ret_val = 'double'\n            else if(trim(req_val) == \"rank\")then\n                ret_val = \"1\"\n            else if(trim(req_val) == \"units\")then\n                ret_val = 'nondimensional'\n            else if(trim(req_val) == \"name\")then\n                ret_val = 'cs_r'\n            endif\n        case default\n            print *, 'ltrans_bmi> error in fetching the value for the requested long name'\n            ret_val = \"-1\"\n    end select\nend subroutine get_value_definitions\n"}, {"instruction": "Create a Fortran subroutine named read_int_param to convert a string input into an integer value. The subroutine should have 1 input parameter of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine read_int_param(valstr,par)\n    character(len=*), intent(in) :: valstr\n    integer, intent(out) :: par\n    read(valstr,*) par\n  end subroutine read_int_param\n"}, {"instruction": "Create a Fortran subroutine named read_logical_param to convert a string input to a logical value. The subroutine takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical.", "input": "", "output": "  subroutine read_logical_param(valstr,par)\n    character(len=*), intent(in) :: valstr\n    logical, intent(out) :: par\n    read(valstr,*) par\n  end subroutine read_logical_param\n"}, {"instruction": "Create a Fortran subroutine named getshapfct_edge to calculate shape functions and their derivatives for a specific edge. The subroutine takes 3 input parameters of type integer, integer, and real*8 and returns 2 output parameters of type real*8, each with a dimension of nvfac.", "input": "", "output": "subroutine getshapfct_edge(ncurv,nvfac,shpf, dshprf, r)\nimplicit none\ninteger,                   intent(in)::ncurv,nvfac\nreal*8, dimension(nvfac), intent(out):: shpf\nreal*8, dimension(nvfac), intent(out):: dshprf\nreal*8,                    intent(in):: r\n!\nif(ncurv.eq.0)then\n!...shape functions\nshpf(1) =  (1.d0-r)/2.d0\nshpf(2) =  (1.d0+r)/2.d0\n\ndshprf(1) =-.5d0\ndshprf(2) = .5d0\n\n!...quadratic cell\nelseif(ncurv.eq.1)then\nshpf(1) =  -0.5d0*(1.d0-r)*r\nshpf(2) =   0.5d0*(1.d0+r)*r\nshpf(3) =         (1.d0+r)*(1.d0-r)\n!\ndshprf(1) = -0.5d0 + r\ndshprf(2) =  0.5d0 + r\ndshprf(3) = -2.d0*r\n\n!...cubic cell\nelseif(ncurv.eq.2)then\n!...shape functions\nshpf(1) =  9.d0/16.d0*(1.d0-r)*(r+1.d0/3.d0)*(r-1.d0/3.d0)\nshpf(2) = -9.d0/16.d0*(1.d0+r)*(1.d0/3.d0-r)*(r+1.d0/3.d0)\nshpf(3) =  27.d0/16.d0*(r-1.d0)*(r+1.d0)*(r-1.d0/3.d0)\nshpf(4) = -27.d0/16.d0*(r-1.d0)*(r+1.d0)*(r+1.d0/3.d0)\n!\ndshprf(1) = 9.d0/16.d0*(1.d0/9.d0-3.d0*r**2+2.d0*r)\ndshprf(2) =-9.d0/16.d0*(1.d0/9.d0-3.d0*r**2-2.d0*r)\ndshprf(3) = 27.d0/16.d0*(-1.d0+3.d0*r**2-2.d0/3.d0*r)\ndshprf(4) =-27.d0/16.d0*(-1.d0+3.d0*r**2+2.d0/3.d0*r)\n!\nendif\n\nend subroutine getshapfct_edge\n"}, {"instruction": "Create a Fortran subroutine named atomic_write to atomically store an integer value into another integer variable. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. Ensure that the value is stored atomically into the output parameter, and no part of the output parameter can change until after the entire write operation is completed.", "input": "", "output": "       subroutine atomic_write(p, value)\n       integer, intent(out) :: p\n       integer, intent(in) :: value\n! guarantee that value is stored atomically into p. no part of p can change\n! until after the entire write operation is completed.\n!$omp atomic write\n       p = value\n       end subroutine atomic_write\n"}, {"instruction": "Create a Fortran subroutine named sum, which takes two input arrays: one of integer type and allocatable, and the other of real type and allocatable. It produces one output array of complex type and allocatable. The function computes the sum of the elements from the input arrays and stores the results in the output array. Ensure to deallocate any temporary arrays created during the computation.", "input": "", "output": "subroutine sum(a, b, c)\nimplicit none\n\ninteger, allocatable, intent(in) :: a(:)\nreal, allocatable, intent(in) :: b(:, :)\ncomplex, allocatable, intent(out) :: c(:, :, :)\ninteger :: i, j, k\n\ncomplex, allocatable :: c_copy(:, :, :)\n\nallocate(c_copy(lbound(a, 1):ubound(a, 1), lbound(b, 1):ubound(b, 1), lbound(b, 2):ubound(b, 2)))\nallocate(c(lbound(a, 1):ubound(a, 1), lbound(b, 1):ubound(b, 1), lbound(b, 2):ubound(b, 2)))\n\ndo i = lbound(a, 1), ubound(a, 1)\n    do j = lbound(b, 1), ubound(b, 1)\n        do k = lbound(b, 2), ubound(b, 2)\n            c_copy(i, j, k) = a(i) + b(j, k)\n            c(i, j, k) = a(i) + b(j, k)\n        end do\n    end do\nend do\n\ndeallocate(c_copy)\n\nend subroutine sum\n"}, {"instruction": "Create a Fortran subroutine named mult that takes two real input parameters and computes their product. The number of input parameters is 2 and the test_data type is ['real', 'real']. The number of output parameters is 1 and the test_data type is ['real'].", "input": "", "output": "subroutine mult(x,y,z)\nreal, intent(in) :: x,y\nreal, intent(out) :: z\nz=x*y\nend subroutine mult\n"}, {"instruction": "Create a Fortran subroutine named solve_heat_explicit to solve the heat equation using an explicit method. The subroutine takes 5 input parameters of type real(kind=8), real(kind=8), real(kind=8), real(kind=8), and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "subroutine solve_heat_explicit(x, u0, t0, tfinal, nsteps, u)\n    implicit none\n    real(kind=8), intent(in) :: x(0:), u0(0:), t0, tfinal\n    integer, intent(in) :: nsteps\n    real(kind=8), intent(out) :: u(0:)\n    integer :: n, i, nstep\n    real(kind=8) :: dx, dt, dtdx2, um1, up1\n    real(kind=8), allocatable :: uxx(:)\n\n    n = size(x) - 2\n    dx = x(2) - x(1)\n    dt = (tfinal - t0) / float(nsteps)\n\n    print 21, n, dx, dt\n21  format(\"solving heat equation with n = \",i6, \" dx = \",e10.3,\" dt = \",e10.3)\n\n    dtdx2 = dt / dx**2\n    print 22, dtdx2\n22  format(\"  dt/dx**2 = \",f7.3)\n\tif (dtdx2 > 0.5d0) then\n\t\tprint *, \"*** warning: the explicit method is unstable\"\n\t\tendif\n\n    allocate(uxx(1:n))\n\n    u = u0\n\n    do nstep=1,nsteps\n\n        do i=1,n\n            uxx(i) = (u(i-1) - 2.d0*u(i) + u(i+1)) / dx**2\n            enddo\n\n        do i=1,n\n            u(i) = u(i) + dt * uxx(i)\n            enddo\n\n        enddo\n\nend subroutine solve_heat_explicit\n"}, {"instruction": "Write a Fortran subroutine named tstar to calculate the saturation point temperature ts [k] given the temperature t [k], pressure p [mb], and specific humidity q [g/kg]. The subroutine should have 6 input parameters of types integer, integer, integer, real(8) arrays of dimensions (km,jm,im), real(8) arrays of dimensions (km,jm,im), and real(8) arrays of dimensions (km,jm,im). It should also have 1 output parameter of type real(8) array of dimensions (km,jm,im).", "input": "", "output": "subroutine tstar(km,jm,im,t,p,q,ts)\n\n! compute saturation point temperature ts [k] \n! (i.e. temperature at lifting condensation level) \n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n! use bolton eqn (12)\n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: ts\n\n! local\n  real(8) :: rv, rd, eps, oneoverk\n  real(8), dimension(km,jm,im) :: r,th,c,e\n\n  rv  = 461.5\n  rd  = 287.04\n  eps = rd/rv\n  oneoverk = 3.504 ! cp/rd\n  r = q/(1.e3 - q)  ! water vap. mixing ratio [kg/kg]\n\n!  call theta(km,jm,im,t,p,q,th)\n!  c=log( r/(r+eps*1.e3)/t**oneoverk / 1.7743e-8 )\n!  ts=217.8*c/(12.992-c) + 273.15\n  e = p*r/(r+eps)\n  ts = 2840./( 3.5*log(t) - log(e) - 4.805) + 55. \n\nend subroutine tstar\n"}, {"instruction": "Create a Fortran subroutine named \"theta\" to compute the potential temperature theta [k] based on the given parameters. The subroutine should have 11 input parameters of types integer, real(8), and real(8) arrays with dimensions km, jm, and im. It should also have 1 output parameter of type real(8) array with dimensions km, jm, and im.", "input": "", "output": "subroutine theta(km,jm,im, rd, rv, cpd, cpv, p0, p, t, q, th)\n\n! compute potential temperature  theta [k]\n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), intent(in)                       :: p0,rd,rv,cpd,cpv\n  real(8), dimension(km,jm,im), intent(in)  :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: th\n\n! local\n  real(8) :: eps\n  real(8), dimension(km,jm,im) :: cp,r,kappa\n\n  eps   = rd/rv\n  r     = rd * (1.+ (1.-eps)/eps*q*1.e-3)\n  cp    = cpd * (1. + (cpv/cpd-1.)*q*1.e-3)\n  kappa = r/cp \n\n  th = t*(p0/p)**kappa\n      \nend subroutine theta\n"}, {"instruction": "Write a Fortran subroutine named theta_old to calculate the potential temperature theta in Kelvin. The subroutine takes 6 input parameters: km, jm, im (all integers), and arrays t, p, q of type real(8) and dimensions km, jm, im. It provides 1 output parameter th of type real(8) and dimensions km, jm, im.", "input": "", "output": "subroutine theta_old(km,jm,im,t,p,q,th)\n\n! compute potential temperature  theta [k]\n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n! use bolton eqn (7) \n \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: th\n\n! local\n  real(8) :: ak\n  real(8), dimension(km,jm,im) :: r\n\n  ak=0.2854 ! r_(dry air)/cp\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  th = t*(1000./p)**( ak*(1.-0.28e-3*r) )\n      \nend subroutine theta_old\n"}, {"instruction": "Create a Fortran subroutine named \"es\" to compute the saturation partial pressure of water vapor. The subroutine should have 4 input parameters: 3 integers (km, jm, im) and a 3D array of real(8) type (t), and 1 output parameter of a 3D array of real(8) type (e). The subroutine calculates the saturation partial pressure using the formula provided and stores the result in the array e.", "input": "", "output": "subroutine es(km,jm,im,t,e)\n\n! compute saturation partial pressure of water vapor es [mb]\n! at temperature t [k].\n! use bohren+albrecht p. 198\n     \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t\n  real(8), dimension(km,jm,im), intent(out) :: e\n\n! local\n  real(8) :: t0\n\n  t0 = 273.15\n  e  = 6.11 * exp( 6808.*(1./t0 - 1./t) - 5.09*log(t/t0) )\n\nend subroutine es\n"}, {"instruction": "Write a Fortran subroutine named \"esflatau\" to compute the saturation partial pressure of water vapor at a given temperature using an 8th order polynomial fit by Flatau et al. The subroutine takes 5 input parameters: km, jm, im, t, and i with types [integer, integer, integer, integer, real(8), dimension(km,jm,im)]. It produces 1 output parameter: e with type [real(8), dimension(km,jm,im)].", "input": "", "output": "subroutine esflatau(km,jm,im,t,i,e)\n\n! compute saturation partial pressure of water vapor es [mb]\n! at temperature t [k].\n! use 8th order polynomial fit of flatau et al (1992), table 4\n\n! i=1 => vapour pressure over water (valid -85c < t < 70c)\n! i=2 => vapour pressure over ice (valid -90c < t < 0c)\n    \n  implicit none\n  integer,intent(in)                       :: km,jm,im,i\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t\n  real(8), dimension(km,jm,im), intent(out) :: e\n\n! local\n  integer :: n\n  real(8) :: t0\n  real(8), dimension(9,2) :: a\n\n  data a / 6.11239921,    0.443987641,  0.142986287e-1,  0.264847430e-3, &\n       0.302950461e-5, 0.206739458e-7, 0.640689451e-10,-0.952447341e-13, &\n       -0.976195544e-15,                                                 &\n       6.11147274,    0.503160820, 0.188439774e-1,  0.420895665e-3,  &\n   0.615021634e-5, 0.602588177e-7, 0.385852041e-9, 0.146898966e-11,  &\n   0.252751365e-14 /\n\n  t0=273.15\n\n  e = a(9,i)\n  do n=8,1,-1\n     e = e*(t-t0) + a(n,i)\n  enddo\n\nend subroutine esflatau\n"}, {"instruction": "Write a Fortran subroutine named pdryadiab that calculates the pressure level at which a given temperature occurs on a dry adiabat, identified by potential temperature and mixing ratio. The number of input arguments is 6 and the test_data type is [integer, integer, integer, real(8), dimension(km,jm,im), real(8), dimension(km,jm,im)]. The number of output arguments is 1 and the test_data type is [real(8), dimension(km,jm,im)].", "input": "", "output": "subroutine pdryadiab(km,jm,im,t,theta,q,p)\n\n! compute pressure level pdryadiab [mb] at which temperature is t [k]\n! on the dry (i.e. unsaturated) adiabat identified by \n! potential temperature theta [k] and mixing ratio q [g/kg].\n! use bolton eqn (7) \n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,theta,q\n  real(8), dimension(km,jm,im), intent(out) :: p\n\n! local\n  real(8) :: oneoverk\n  real(8), dimension(km,jm,im) :: r\n\n  oneoverk=3.504 ! cp/r_(dry air)\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  p = 1000.*(t/theta)**( oneoverk/(1.-0.28e-3*r) )\n\nend subroutine pdryadiab\n"}, {"instruction": "Write a Fortran subroutine named tdryadiab to calculate the temperature t [K] at a given pressure level p [mb] on the dry adiabat using the potential temperature theta [K] and mixing ratio q [g/kg]. The subroutine has 6 input parameters of types integer, integer, integer, real(8) arrays, and outputs a real(8) array.", "input": "", "output": "subroutine tdryadiab(km,jm,im,theta,p,q,t)\n\n! compute temperature t [k] at level p [mb] \n! on the dry (i.e. unsaturated) adiabat identified by \n! potential temperature theta [k] and mixing ratio q [g/kg].\n! use bolton eqn (7) \n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: theta,p,q\n  real(8), dimension(km,jm,im), intent(out) :: t\n\n! local\n  real(8) :: ak\n  real(8), dimension(km,jm,im) :: r\n\n  ak=0.2854 ! r_(dry air)/cp\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  t = theta*(1000./p)**( -ak*(1.-0.28e-3*r) )\n      \nend subroutine tdryadiab\n"}, {"instruction": "Write a Fortran subroutine named z that performs a specific computation for atmospheric or oceanic modeling. The subroutine takes 8 input parameters: integer km, integer jm, integer im, real(8) r, real(8) g, real(8) arrays p0(jm,im), p(km,jm,im), and t(km,jm,im). It produces 1 output parameter: a real(8) array zz(km,jm,im).", "input": "", "output": "subroutine z(km,jm,im,r,g,p0,p,t,zz)\n\n!\n  implicit none\n  integer, intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), intent(in)                       :: r,g\n  real(8), dimension(jm,im), intent(in)     :: p0\n  real(8), dimension(km,jm,im), intent(in)  :: p,t\n  real(8), dimension(km,jm,im), intent(out) :: zz\n\n! local\n  integer :: k\n  real(8), dimension(jm,im) :: dp,pm,tm\n\n! bottom level\n  dp = (p0 - p(km,:,:))\n  pm = (p0 + p(km,:,:))/2.\n  zz(km,:,:) = r/g * t(km,:,:)/pm * dp\n\n! build up from bottom\n  do k=km-1,1,-1\n     dp = p(k+1,:,:) - p(k,:,:)\n     pm = (p(k+1,:,:) + p(k,:,:))/2.\n     tm = (t(k+1,:,:) + t(k,:,:))/2.\n     zz(k,:,:) = zz(k+1,:,:) + r/g * tm/pm * dp\n  enddo\n\nend subroutine z\n"}, {"instruction": "Create a Fortran subroutine named perm_rsp to calculate the species-level effect of permafrost on growth based on the provided code. The subroutine takes 4 input arguments of type integer, real, real, and real, and returns 1 output argument of type real.", "input": "", "output": "    subroutine perm_rsp(p_tol, l1_p_tol, l2_p_tol, amlt, fc_perm)\n        !\n        !  calculates species-level effect of permafrost on growth\n        !  adapted from bonan 1989 ecological modelling 45:275-306\n        !\n        !  record of revisions:\n        !      date       programmer          description of change\n        !      ====       ==========          =====================\n        !    09/08/19     a. c. foster        original code\n        !\n\n        ! data dictionary: calling arguments\n        integer, intent(in)  :: p_tol    ! relative permafrost tolerane (1-2; 2 = least tolerant)\n        real,    intent(in)  :: amlt     ! active layer depth (m)\n\treal,    intent(in)  :: l1_p_tol ! tolerant species growth response at low active layer depths\n\treal,    intent(in)  :: l2_p_tol ! intolerant species growth response at low active layer depths\n        real,    intent(out) :: fc_perm  ! growth response to permafrost (0-1)\n\n        ! data dictionary: local variables\n        real :: y ! growth response to permafrost (0-1)\n\n       if (amlt .le. 1.0) then\n\t\t\tif (p_tol .eq. 1) then\n\t\t\t\ty = (1*.001)/(.001 + (1-.001)*exp(-l1_p_tol*amlt))\n\t\t\telse\n\t\t\t\ty = (1*.001)/(.001 + (1-.001)*exp(-l2_p_tol*amlt))\n\t\t\tend if\n\t\t\n\t\telse if (amlt .gt. 1.0) then\n\t\t\ty = 1.0\n\t\tend if\n        ! must be between 0.0 and 1.0\n        if (y .ge. 1.0) y = 1.0\n        if (y .le. 0.0) y = 0.0\n\n        fc_perm = y\n\n    end subroutine perm_rsp\n"}, {"instruction": "Create a Fortran subroutine named pbc_mp_kpoint_set to generate k-points in reciprocal space for periodic boundary conditions. The subroutine takes 3 input parameters of type integer, dimension(3), double precision, dimension(3), and integer. It has 2 output parameters of type double precision, dimension(1:3,nkpts) and double precision, dimension(nkpts).", "input": "", "output": "  subroutine pbc_mp_kpoint_set(n, s, nkpts, kpt, w)\n\n    implicit none\n\n    integer,          dimension(3),         intent(in)  :: n\n    double precision, dimension(3),         intent(in)  :: s\n    integer,                                intent(in)  :: nkpts\n    double precision, dimension(1:3,nkpts), intent(out) :: kpt\n    double precision, dimension(nkpts),     intent(out) :: w\n    \n    integer          :: i1, i2, i3, ikpt\n    double precision :: n1_inv, n2_inv, n3_inv\n\n    if (nkpts /= n(1)*n(2)*n(3)) then\n       write(0,*) \"error: ill-sized k-point array in `pbc_mp_kpoint_set()'.\"\n       stop\n    end if\n\n    n1_inv = 1.0d0/dble(n(1))\n    n2_inv = 1.0d0/dble(n(2))\n    n3_inv = 1.0d0/dble(n(3))\n\n    ikpt = 0\n    do i1 = 0, (n(1) - 1)\n    do i2 = 0, (n(2) - 1)\n    do i3 = 0, (n(3) - 1)\n       ikpt = ikpt + 1\n       kpt(1,ikpt) = n1_inv*(dble(i1) + s(1))\n       kpt(2,ikpt) = n2_inv*(dble(i2) + s(2))\n       kpt(3,ikpt) = n3_inv*(dble(i3) + s(3))\n    end do\n    end do\n    end do\n\n    ! for now, all k-points are equally weighted:\n    w(1:nkpts) = 1.0d0/dble(nkpts)\n\n  end subroutine pbc_mp_kpoint_set\n"}, {"instruction": "Create a Fortran subroutine named build_equilateral to generate an equilateral triangle mesh. The subroutine takes 1 input parameter of type integer and returns 5 output parameters: 3 of type integer, 1 of type real(8), and 1 of type integer. The function builds the mesh using the input parameter and calculates the number of elements, number of nodes, xyz points, element map, and boundary condition map.", "input": "", "output": "      subroutine build_equilateral(jjmax, xi, gg, ibc, nelem, nnode)\n      implicit none\n      integer, intent(in)  :: jjmax    ! number of points per side\n      integer, intent(out) :: nelem    ! number of elements\n      integer, intent(out) :: nnode    ! number of nodes\n      real(8), intent(out) :: xi(3,jjmax*jjmax)  ! xyz points\n      integer, intent(out) :: gg(3,jjmax*jjmax)  ! element map\n      integer, intent(out) :: ibc(jjmax*jjmax)   ! boundary condition map\n\n      integer :: i, j, ii\n      real(8) :: delx\n      real(8) :: dely\n      real(8) :: x, y, x1\n\n      write (*,*)\n      write (*,*) 'building equilateral triangle mesh'\n      write (*,*) 'number of points along edge ', jjmax\n\n      delx=1.0d0/dble(jjmax-1)\n      dely=delx*sqrt(3.0d0)/2.0d0\n\n      y=0.0d0\n\n      x1=0.0d0\n      x=0.0d0\n      y=0.0d0\n      do j=1, jjmax\n        x=x1\n        ii=jjmax+1-j\n        do i=1,ii\n\n           nnode=nnode+1\n           xi(1,nnode)=x\n           xi(2,nnode)=y\n           xi(3,nnode)=0.0d0\n           x=x+delx\n           if (i.eq.1 .or. i.eq.ii .or. j.eq.1) then\n             ibc(nnode)=3\n           else\n             ibc(nnode)=0\n           endif\n\n           if (i.lt.ii) then\n             nelem=nelem+1\n             gg(1,nelem)=nnode\n             gg(2,nelem)=nnode+1\n             gg(3,nelem)=nnode+ii\n           endif\n           if (i.lt.ii-1) then\n             nelem=nelem+1\n             gg(1,nelem)=nnode+1\n             gg(2,nelem)=nnode+ii+1\n             gg(3,nelem)=nnode+ii\n           endif\n\n        enddo\n        y=y+dely\n        x1=x1+delx*0.5d0    ! increment half width for start of next time\n      enddo\n\n      write (*,*) 'final nnode ', nnode\n      write (*,*) 'final nelem ', nelem\n\n!!    write (*,*) 'sqrt3/2 = ', sqrt(3.0d0)/2.0d0\n!!    write (*,*) 'final x = ', xi(1,nnode)\n!!    write (*,*) 'final y = ', xi(2,nnode)\n\n      x=xi(1,nnode)\n      y=xi(2,nnode)\n      if (abs(x-0.5d0)            .gt.1.0d-8) stop 'error in final mesh x value'\n      if (abs(y-sqrt(3.0d0)/2.0d0).gt.1.0d-8) stop 'error in final mesh y value'\n\n      return\n      end subroutine build_equilateral\n"}, {"instruction": "Create a Fortran subroutine named powers to calculate the square and cube of an input integer. The subroutine should take 1 input parameter of type integer and provide 2 output parameters of type integer representing the square and cube of the input integer.", "input": "", "output": "subroutine powers(i,isquare,icube)\r\ninteger, intent(in)  :: i\r\ninteger, intent(out) :: isquare,icube\r\nisquare = i**2\r\nicube   = i*isquare\r\nend subroutine powers\r\n"}, {"instruction": "Create a Fortran subroutine named \"wrf_time_to_hms\" that takes a real number as input to represent time in seconds and returns three integers representing hours, minutes, and seconds. The input parameter is 1 of type real, and the output parameters are 3 of type integer.", "input": "", "output": "  subroutine wrf_time_to_hms(wrf_time, hour,minute,second)\n    implicit none\n    real, intent(in)                    :: wrf_time\n    integer, intent(out)                :: hour, minute, second\n    integer                             :: leftover_seconds\n    hour = floor(wrf_time)/3600\n    leftover_seconds = mod(floor(wrf_time),3600)\n    minute = leftover_seconds/60           \n    second = mod(leftover_seconds,60)\n  end subroutine wrf_time_to_hms\n"}, {"instruction": "Write a Fortran subroutine named determinant to calculate the determinant of a 3x3 matrix. The subroutine takes one input parameter, a real array of size 3x3. The input matrix is specified using the \"intent(in)\" keyword. The subroutine also has one output parameter, a real value that represents the determinant of the matrix. The output value is specified using the \"intent(out)\" keyword. The type of the input matrix is \"real(8), dimension(3, 3)\" and the type of the output determinant is \"real(8)\".", "input": "", "output": "        subroutine determinant(matrix, deter_value)\n            real(8), dimension(3, 3), intent(in) :: matrix\n            real(8), intent(out) :: deter_value\n            deter_value=(matrix(1,1)*matrix(2,2)*matrix(3,3)+matrix(1,2)*matrix(2,3)*matrix(3,1)&\n                    +matrix(1,3)*matrix(2,1)*matrix(3,2)&\n                    -matrix(3,1)*matrix(2,2)*matrix(1,3)-matrix(2,1)*matrix(1,2)*matrix(3,3)&\n                    -matrix(1,1)*matrix(3,2)*matrix(2,3))\n        end subroutine determinant\n"}, {"instruction": "Write a Fortran subroutine named \"comp_vel\" that converts wind velocity from speed and direction to u and v components. The subroutine requires two input parameters of type real, representing the wind speed (ff) and wind direction (dd). It also has two output parameters of type real, representing the u and v components of the wind velocity.", "input": "", "output": "      subroutine comp_vel(ff,dd,u,v)\n\n! *** this function converts the wind velocity from:   \n! ***         speed (ff) and direction (dd) \n! *** to:       u   and           v.\n\n\n! *** we require the use of implicit none:\n\n      implicit none\n\n! *** global declarations:\n      real,intent(in)  :: ff,dd\n      real,intent(out) :: u,v\n\n! *** local declarations:\n      real,parameter :: pi  = 3.141592654\n      real,parameter :: rad = pi/180.0\n\n      real :: theta\n\n! *** \"pi\"    - the constant pi.\n! *** \"rad\"   - the conversion from degrees to radians.\n!\n! *** \"dd\" =  0 degrees means wind from the north blowing southards.\n! *** \"dd\" = 90 degrees means wind from the east  blowing westwards.  \n!\n! *** converts the wind direction to radians:\n\n      theta = dd * rad\n\n      u = -ff*sin(theta)\n      v = -ff*cos(theta)\n\n      return\n      \n      end subroutine comp_vel\n"}, {"instruction": "Write a Fortran subroutine named sdf_safe_copy_string that safely copies a string from one variable to another. The subroutine has 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine sdf_safe_copy_string(s1, s2)\n\n    character(len=*), intent(in) :: s1\n    character(len=*), intent(out) :: s2\n    integer :: len1, len2, olen, i\n\n    len1 = len_trim(s1)\n    len2 = len(s2)\n    olen = min(len1,len2)\n    if (olen > 0) then\n      s2(1:olen) = s1(1:olen)\n      do i = olen+1,len2\n        s2(i:i) = ' '\n      end do\n    else\n      do i = 1,len2\n        s2(i:i) = ' '\n      end do\n    end if\n\n  end subroutine sdf_safe_copy_string\n"}, {"instruction": "Write a Fortran subroutine named \"word2hex\" to convert a string of characters into its hexadecimal representation. The subroutine takes 1 input parameter of type \"character (len = 10)\" and 2 output parameters. The first output parameter is an array of integers with dimensions 0 to 31, representing the hexadecimal values of each character in the input string. The second output parameter is a single integer indicating the length of the resulting hexadecimal representation. The subroutine iterates over each character in the input string, converts it to its corresponding hexadecimal value, and stores it in the output array. Finally, it updates the length parameter to reflect the final length of the hexadecimal representation.", "input": "", "output": "      subroutine word2hex(w, h, l)\n\n!   w is usually the word we get from readword(w).\n!   h is the output array, which is w, but in hex.\n!   l is the resultant length. because we are going from native string\n!   to array of integers, we no longer have the luxury of strlen.\n      character (len = 10), intent(in) :: w\n      integer, dimension(0:31), intent(out) :: h\n      integer, intent(out) :: l\n\n!   i is used to iterate through the input, from 1 to len_trim(w),\n!      where len_trim(w) is the usable length of the string.\n!   j is used to keep track of how many characters are being written\n!      to the final output array, h. that way we can assign it to l,\n!      the length of the string\n!   temph is a temporary 2-member array that holds the intermediate\n!      representation of the conversion to hex (e.g. 7f). we then\n!      convert the individual two members to integers in the output\n      integer :: i, j = 0\n      integer, dimension(1:2) :: hex\n      character (len = 2) :: temph\n\n!   here we iterate over every usable character of the input string\n      do i = 1, len_trim(w)\n\n!      i will be our iterator variable, so we take the character at\n!      i of w ( w(i:i) ) and write two characters to the temph array;\n!      these two characters represent the left and right parts of the\n!      hex representation of each character.\n         write(temph, '(z2)') w(i:i)\n\n!      then, we take each of the two characters in temph and write them\n!      to another temporary array of two members, this time it's hex,\n!      which is an array of two integers. they represent the cardinal\n!      value of the hex. from 0-9 it's 0-9, but characters a,b,c,d,e,f\n!      are actually represented as 10,11,12,13,14,15 in decimal, hence\n!      why we are converting it as such\n         read(temph(1:1), '(z1)') hex(1)\n         read(temph(2:2), '(z1)') hex(2)\n\n!      every time this step completes, we increment the j variable to\n!      keep track of the final length of the hex array when writing.\n         h(j) = hex(1)\n         j = j + 1\n         h(j) = hex(2)\n         j = j + 1\n\n      end do\n\n!   finally, we write the final value of j to the length variable.\n      l = j\n\n      end subroutine word2hex\n"}, {"instruction": "Provide a Fortran subroutine named elem that converts a given input key1, which is a string of characters, into a corresponding integer value nat. The subroutine takes one input parameter of type character(*) and one output parameter of type integer. \n\nIn the subroutine, an array of character elements named \"elemnt\" is defined and initialized with two-character representations of chemical elements. The subroutine iterates over each character in the input key1 and checks if it matches any element in the elemnt array. If a match is found, the corresponding integer value is assigned to the output parameter nat. \n\nYour task is to provide the Fortran instruction for this subroutine.", "input": "", "output": "  elemental subroutine elem(key1, nat)\n    character(*), intent(in) :: key1\n    integer, intent(out) :: nat\n\n    character(2), parameter :: elemnt(94) = [&\n        & 'h ','he', &\n        & 'li','be','b ','c ','n ','o ','f ','ne', &\n        & 'na','mg','al','si','p ','s ','cl','ar', &\n        & 'k ','ca','sc','ti','v ','cr','mn','fe','co','ni','cu', &\n        & 'zn','ga','ge','as','se','br','kr', &\n        & 'rb','sr','y ','zr','nb','mo','tc','ru','rh','pd','ag', &\n        & 'cd','in','sn','sb','te','i ','xe', &\n        & 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy', &\n        & 'ho','er','tm','yb','lu','hf','ta','w ','re','os','ir','pt', &\n        & 'au','hg','tl','pb','bi','po','at','rn', &\n        & 'fr','ra','ac','th','pa','u ','np','pu' ]\n\n    character(2) :: e\n    integer :: k, j, n, i\n\n    nat=0\n    e=' '\n    k=1\n    do j=1,len(key1)\n      if (k.gt.2)exit\n      n=ichar(key1(j:j))\n      if (n.ge.ichar('a') .and. n.le.ichar('z') )then\n        e(k:k)=char(n+ichar('a')-ichar('a'))\n        k=k+1\n      end if\n      if (n.ge.ichar('a') .and. n.le.ichar('z') )then\n        e(k:k)=key1(j:j)\n        k=k+1\n      end if\n    end do\n\n    do i=1,94\n      if (e.eq.elemnt(i))then\n        nat=i\n        return\n      end if\n    end do\n\n\n  end subroutine elem\n"}, {"instruction": "Write a Fortran subroutine named \"errp\" to calculate the error between a set of predicted values and actual values. The subroutine takes 4 input parameters: an integer*4 variable \"nt\", real*8 arrays \"p\", \"x\", and a 2D real*8 array \"c\" with dimensions (4,1). It also has 1 output parameter: a real*8 variable \"err\".\n\nInside the subroutine, initialize the \"err\" variable to 0. Then, using a do loop, iterate over the \"nt\" number of values. For each iteration, calculate a polynomial fit using the coefficients from array \"c\" and the corresponding \"x\" value. Compute the squared difference between the predicted value \"pfit\" and the actual value \"p(i)\", and add it to the \"err\" variable. Finally, return from the subroutine.\n\nMake sure to properly declare the variables and use the \"implicit\" statement to specify the variable types.", "input": "", "output": "      subroutine errp(nt,p,x,c,err)\n      implicit real*8(a-h,o-z)\n\n      integer*4, intent(in)  :: nt\n      real*8,    intent(in)  :: p(nt),x(nt),c(4,1)\n      real*8,    intent(out) :: err\n      \n      common/smaple/xmin,xmax,dx\n     \n      err = 0d0\n      do i=1,nt\n        pfit = c(1,1)*x(i)+c(2,1)*x(i)**2+c(3,1)*x(i)**3+c(4,1)\n        err = err+(p(i)-pfit)**2*dx\n      enddo\n\n      return\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named derivs to calculate the derivative of a function for multiple trajectories. The number of input arguments is 2 and the test_data type is ['integer*4', 'real*8']. The number of output arguments is 3 and the test_data type is ['real*8', 'real*8', 'real*8']. The subroutine takes an array of trajectories, computes the derivative for each trajectory, and stores the results in separate arrays.", "input": "", "output": "        subroutine derivs(x,ntraj,fx,v,ddv)\n        implicit real*8(a-h,o-z)\n        parameter(ak=1.2d0)\n        integer*4,intent(in) :: ntraj\n        real*8,intent(in) :: x(ntraj)\n        real*8,intent(out) :: fx(ntraj),v(ntraj),ddv(ntraj)\n        \n        do i=1,ntraj\n          fx(i) = -ak*x(i)\n          v(i)  = ak*x(i)**2/2d0\n          ddv(i) = ak\n        enddo\n\n        return\n        end subroutine\n"}]