{"instruction": "Create a Fortran function named uppercase that takes a string as input and returns the uppercase version of the input string. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1 and the test_data type is ['character(len(str))'].", "input": "", "output": "  function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n"}
{"instruction": "Create a Fortran function named sbend to calculate the bending of a beam. It takes 3 input parameters of type real(8) - y, amp, and wid. The output is a single real(8) value. The function computes the bending using the formula sbend = amp * wid * sqrt(1.0 + ((y - 0d0) / wid)**2).", "input": "", "output": "  function sbend(y,amp,wid)\n    implicit none\n    real(8)::y,amp,wid,sbend\n    !sbend=amp*tanh((y-0d0)/wid)\n    sbend=amp*wid*sqrt(1.0+((y-0d0)/wid)**2)\n  end function\n"}
{"instruction": "Create a Fortran function called istep to calculate the step function for a given real(8) input. The function takes 1 input argument of type real(8) and returns 1 output argument of type real(8). If the input is less than 0, the output is 1.0d0; if the input is equal to 0, the output is 0.50d0; otherwise, the output is 0.0d0.", "input": "", "output": "  elemental function istep(x) result(out)!,beta) result(out)\n    real(8),intent(in) :: x!, beta \n    real(8)            :: out\n    ! if(x*beta > 100.d0)then\n    !    fermi=0.d0\n    !    return\n    ! endif\n    ! fermi = 1.d0/(1.d0+exp(beta*x))\n    if(x < 0.d0) then\n       out = 1.0d0\n    elseif(x==0.d0)then\n       out = 0.50d0\n    else\n       out = 0.0d0\n    endif\n  end function istep\n"}
{"instruction": "Create a Fortran pure function named escape_token to process a string and return the processed string. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(len=len(string)+2).", "input": "", "output": "  pure function escape_token(string)\n    character(*), intent(in) :: string\n    character(len=len(string)+2) :: escape_token\n\n    ! do we need single quotes?\n    if (index(trim(string), '\"').ne.0) then\n      escape_token = \"'\" // trim(string) // \"'\"\n\n    ! do we need quotes at all?\n    else if (scan(trim(string), \" '\").ne.0) then\n      escape_token = '\"' // trim(string) // '\"'\n\n    ! a simple token\n    else\n      escape_token = trim(string)\n    end if\n  end function escape_token\n"}
{"instruction": "Write a Fortran function named lr2gr that takes two integer inputs, locrow and level. The function returns an integer, globrow, which is the row number in the original input at level 1.", "input": "", "output": "function lr2gr( locrow, level ) result ( globrow )\n  !-----------------------------------------------------------------------------\n  ! formal arguments\n  !-----------------------------------------------------------------------------\n  integer, intent(in) :: locrow !<local row number of global row, at given level\n  integer, intent(in) :: level !<level at which locrow's position is given\n  integer :: globrow !<returned: row number in original input (level 1)\n\n  !-----------------------------------------------------------------------------\n  ! local variables\n  !-----------------------------------------------------------------------------\n  integer :: i !<loop variable\n\n  !-----------------------------------------------------------------------------\n  ! invert the rule r=(r+1)/2 backward for all levels\n  !-----------------------------------------------------------------------------\n  if (locrow .lt. 1) then\n     globrow = -1\n  else\n     globrow = locrow\n     levelloop: do i = level-1, 1, -1\n        globrow = 2*globrow - 1\n     end do levelloop\n  end if\n\n  return\nend function lr2gr\n"}
{"instruction": "Write a Fortran function named get_box_num that takes 6 input arguments of type integer - xval, yval, zval, xgridnum, ygridnum, zgridnum. It returns a single output parameter of type integer. This function calculates the box number based on the input values and grid numbers, using the formula boxnum = yval * xgridnum + xval * ygridnum + zval. If the computed box number exceeds the limit, a warning message is displayed and the program pauses.", "input": "", "output": "    function get_box_num(xval,yval,zval,xgridnum,ygridnum,zgridnum) result(boxnum)\n        implicit none\n        integer,intent(in)::xval,yval,zval\n        integer,intent(in)::xgridnum,ygridnum,zgridnum\n        integer::boxnum\n    \n        !boxnum = (yval-1)*xgridnum + xval + 1\n        boxnum = yval*xgridnum + xval*ygridnum + zval\n\n        if (boxnum.gt.xgridnum*ygridnum*zgridnum) then\n            write(*,*) \"warnning:\"\n            write(*,*) \"the computation of the box beyond limit\"\n            write(*,*)  \" computed box value = \", boxnum\n            write(*,*) \"xval = \",xval,\"yval = \",yval,\"zval =\",zval\n            write(*,*) \"xgridnum = \",xgridnum, \"ygridnum = \",ygridnum,&\n                        \"zgridnum = \",zgridnum\n            pause\n        end if\n    end function\n"}
{"instruction": "Create a Fortran function called fib to calculate the Fibonacci sequence up to the given number. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "recursive function fib(n) result(res)\n  implicit none\n\n  integer, intent(in) :: n\n  integer :: res\n\n  integer :: x,y\n  \n  if (n<2) then\n     res=n\n  else if (n<20) then\n     x = fib(n-1)\n     y = fib(n-2)\n     res=x+y\n  else\n     !$omp task default(none) shared(x,n)\n     x = fib(n-1)\n     !$omp end task\n     !$omp task default(none) shared(y,n)\n     y = fib(n-2)\n     !$omp end task\n     !$omp taskwait     \n     res=x+y\n  end if\nend function fib\n"}
{"instruction": "Create a Fortran function named \"es_wexler\" to calculate the saturation water vapor pressure using the Wexler formulation with new coefficients. The function takes 2 input parameters of real type (temperature in kelvins and atmospheric pressure in hPa) and returns 1 output parameter of real type (saturation water vapor pressure in hPa).", "input": "", "output": "function es_wexler(t, p)\n        !saturation water vapor pressure (es) using wexler formulation with new coefficients (adjusted for its-90)\n        !input : t = temperature (in kelvins)\n        !        p = atmospheric pressure (in hpa)\n        !output: es= saturation water vapor pressure (in hpa)\n        !references:\n        !1)\n        !wexler, a. vapor pressure formulation for water in range 0 to 100 degrees c. a revision.\n        !j. res. natl. bur. stand. 1976, 80a, 775\u2013785.\n        !2)\n        !wexler, a. vapor pressure formulation for ice. j. res. natl. bur. stand. 1977, 81a, 5\u201320.\n        !3)\n        !hardy, b. its-90 formulations for water vapor pressure, frostpoint temperature, dewpoint temperature, and enhancement factors in range -100 to +100 c.\n        !in proceedings of the third international symposium on humidity and moisture;\n        !uk national physical laboratory (npl): teddington, uk, april 6 1998; pp. 1\u20138.\n\treal, intent(in) :: t, p\n  \treal             :: es_wexler   \n        real :: g0, g1, g2, g3, g4, g5, g6, g7, a0, a1, a2, a3, b0, b1, b2, b3, &\n                k0, k1, k2, k3, k4, k5, es, alpha, beta, f                \n\n        if ( t >= 273.15 ) then\n\t\t! saturation vapor pressure over water\n                g0 =-2.8365744d3\n                g1 =-6.028076559d3\n                g2 = 1.954263612d1\n                g3 =-2.737830188d-2\n                g4 = 1.6261698d-5\n                g5 = 7.0229056d-10\n                g6 =-1.8680009d-13\n                g7 = 2.7150305\n                es = 0.01 * exp(g0*t**(-2) + g1*t**(-1) + g2 + g3*t + g4*t**2 + g5*t**3 + g6*t**4 + g7*log(t))\n\n                ! enhancement factor coefficients for water 0 to 100\u00b0c\n                a0 =-1.6302041d-1\n                a1 = 1.8071570d-3\n                a2 =-6.7703064d-6\n                a3 = 8.5813609d-9\n                b0 =-5.9890467d1\n                b1 = 3.4378043d-1\n                b2 =-7.7326396d-4\n                b3 = 6.3405286d-7\n\telse\n                ! saturation vapor pressure over ice\n                k0 =-5.8666426d3\n                k1 = 2.232870244d1\n                k2 = 1.39387003d-2\n                k3 =-3.4262402d-5\n                k4 = 2.7040955d-8\n                k5 = 6.7063522d-1\n                es = 0.01 * exp(k0*t**(-1) + k1 + k2*t + k3*t**2 + k4*t**3 + k5*log(t))\n\n                ! enhancement factor coefficients for ice \u2013100 to 0\u00b0c\n                a0 =-6.0190570d-2\n                a1 = 7.3984060d-4\n                a2 =-3.0897838d-6\n                a3 = 4.3669918d-9\n                b0 =-9.4868712d1\n                b1 = 7.2392075d-1\n                b2 =-2.1963437d-3\n                b3 = 2.4668279d-6\n\tend if \n        ! enhancement factor\n        alpha = a0 + a1*t + a2*t**2 + a3*t**3\n        beta = exp(b0 + b1*t + b2*t**2 + b3*t**3)\n        f = exp( alpha*(1-es/p) + beta*(p/es-1) )\n        es = es * f\n\treturn\nend function\n"}
{"instruction": "Create a Fortran function named getinterval which implements a binary search algorithm to find the upper and lower indices of a 1-dimensional sorted array for a given search value. The function takes 2 input parameters of type real, dimension(:) and real. It returns 1 output parameter of type integer, dimension(2).", "input": "", "output": "  function getinterval(a,x) result(indx)\n    !! returns upper and lower indices of a 1-d sorted array \n    !! using binary search in which a search value lies \n    real, intent(in), dimension(:) :: a \n    real, intent(in) :: x\n    integer, dimension(2) :: indx  ! left and right indices \n    integer :: n, i\n\n    n = size(a,1)\n    indx(1) = 1\n    indx(2) = n\n\n    ! binary search algorithm\n    do while ((indx(1) .ne. indx(2)) .and. (indx(2) .ne. (indx(1)+1)))\n      i = floor((indx(1)+indx(2))*0.5)\n      if (x < a(i)) then\n        indx(2) = i\n      elseif (x > a(i)) then\n        indx(1) = i\n      else\n        indx(1) = i\n        indx(2) = i\n      endif\n    enddo\n\n    ! check end cases\n    if (abs(a(indx(1))-x) .le. epsilon(1.)) then\n      indx(2) = indx(1)\n    elseif (abs(a(indx(2))-x) .le. epsilon(1.)) then\n      indx(1) = indx(2)\n    endif\n  end function getinterval\n"}
{"instruction": "Create a Fortran function named uppercase to convert a given string to uppercase. The function takes 1 input parameter of type character (len=*) and returns 1 output parameter of type character (len=len_trim(str)).", "input": "", "output": "function uppercase(str) result(ucstr)\n\n! convert string to upper case\n\ncharacter (len=*):: str\ncharacter (len=len_trim(str)):: ucstr\n\nilen=len_trim(str)\nioffset=iachar('a')-iachar('a')     \niquote=0\nucstr=str\ndo i=1,ilen\n  iav=iachar(str(i:i))\n  if(iquote==0 .and. (iav==34 .or.iav==39)) then\n    iquote=1\n    iqc=iav\n    cycle\n  end if\n  if(iquote==1 .and. iav==iqc) then\n    iquote=0\n    cycle\n  end if\n  if (iquote==1) cycle\n  if(iav >= iachar('a') .and. iav <= iachar('z')) then\n    ucstr(i:i)=achar(iav+ioffset)\n  else\n    ucstr(i:i)=str(i:i)\n  end if\nend do\nreturn\n\nend function uppercase\n"}
{"instruction": "Create a Fortran function named notinmset that takes two input parameters of type complex and integer respectively. The function returns a single output parameter of type logical. The function calculates whether a given complex number is not in the Mandelbrot set based on the maximum number of iterations specified.", "input": "", "output": "    pure function notinmset(c, n_max)\n        complex, intent(in) :: c\n        integer, intent(in) :: n_max\n        integer :: n\n        complex :: z\n        logical :: notinmset\n        z = cmplx(0,0) \n        n = 0\n        \n        ! early escape attempts. if it's in the main cardioid or largest bulbs\n        ! then it's proven it's in the mandelbrot set\n        if(((abs(c - cmplx(-1,0) )) < 0.25) .or. ((abs( 1.0 - sqrt(1-(4*c)) ))  < 1.0 ) ) then\n            notinmset = .false.\n\n        ! else do the regular iteration\n        else\n            ! iterate until we escape or reach mac iteration\n            do while (abs(z) < 2 .and. (n < n_max))\n                z = z**2 + c\n                n = n + 1\n            end do\n            \n            if (n >= n_max) then\n                ! we reached max iteration without escaping, it may be in mandelbrot set so we return false\n                notinmset = .false.\n            else\n                ! it escaped before reaching max iteration, it's not in mandelbrot set for sure\n                notinmset = .true.\n            end if\n        end if\n    end function notinmset\n"}
{"instruction": "Create a Fortran function named nextp that takes two input parameters. The first parameter is an integer, and the second parameter is an array of integers with a dimension of n. It returns a logical value as the output parameter. The function reorders the elements of the array a in place and returns true if the reordered sequence is the next lexicographically greater permutation, otherwise it returns false.", "input": "", "output": "      function nextp ( n, a )\n      logical :: nextp\n      integer,intent(in) :: n\n      integer,dimension(n),intent(inout) :: a\n!\n!     local variables:\n!\n      integer i,j,k,t\n!\n      i = n-1\n   10 if ( a(i) .lt. a(i+1) ) goto 20\n      i = i-1\n      if ( i .eq. 0 ) goto 20\n      goto 10\n   20 j = i+1\n      k = n\n   30 t = a(j)\n      a(j) = a(k)\n      a(k) = t\n      j = j+1\n      k = k-1\n      if ( j .lt. k ) goto 30\n      j = i\n      if (j .ne. 0 ) goto 40\n!\n      nextp = .false.\n!\n      return\n!\n   40 j = j+1\n      if ( a(j) .lt. a(i) ) goto 40\n      t = a(i)\n      a(i) = a(j)\n      a(j) = t\n!\n      nextp = .true.\n!\n      return\n      end function\n"}
{"instruction": "Create a Fortran function named sinc to calculate the value of the sinc function for a given input argument. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function sinc ( x )\r\n!\r\n!  purpose:\r\n\n!       sinc(x) = sin(x) / x\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    11/23/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\nreal, intent(in) :: x        ! value for which to evaluate sinc\r\nreal :: sinc                 ! output value sinc(x)\r\n\r\n! data dictionary: declare local constants\r\nreal, parameter :: epsilon = 1.0e-30  ! the smallest value for which \r\n                                      ! to calculate sin(x)/x\r\n\r\n! check to see of abs(x) > epsilon.\r\nif ( abs(x) > epsilon ) then\r\n   sinc = sin(x) / x\r\nelse\r\n   sinc = 1.\r\nend if\r\n\r\nend function sinc\r\n"}
{"instruction": "Write a Fortran function named in_circle to determine whether a given point (pos_x, pos_y) lies within a circle of radius r. The function takes 3 input arguments of type real(16) - pos_x, pos_y, and r. It returns 1 output argument of type logical.", "input": "", "output": "function in_circle(pos_x, pos_y, r)\n    implicit none\n    real(16), intent(in) :: pos_x, pos_y, r\n    logical              :: in_circle\n\n    in_circle = (pos_x ** 2 + pos_y ** 2) < r ** 2\n\nend function in_circle \n"}
{"instruction": "Create a Fortran function named st_idx_in_array to check if a given integer index exists in an array of integers. The function takes 2 input parameters: idx of type integer, and array of type integer, dimension(:). It returns 1 output parameter exists of type logical.", "input": "", "output": "function st_idx_in_array(idx, array) result(exists)\n!===============================================================================\n!  return .true. if idx is in array\n   integer, intent(in) :: idx\n   integer, intent(in), dimension(:) :: array\n   logical :: exists\n   integer :: ii\n\n   exists = .false.\n   do ii = 1, size(array)\n      if (idx == array(ii)) then\n         exists = .true.\n         return\n      endif\n   enddo\nend function st_idx_in_array\n"}
{"instruction": "Create a Fortran function named intersect that takes 5 input parameters of type real: x1, y1, x2, y2, and x. The function returns a real value. The function computes the y-coordinate of the point of intersection between the line passing through (x1, y1) and (x2, y2) and the vertical line at x.", "input": "", "output": "  function intersect(x1, y1, x2, y2, x)\n     real, intent(in) :: x1, y1, x2, y2, x\n     real             :: intersect\n\n     intersect = (y2-y1)*(x-x1)/(x2-x1) + y1\n\n  return\n\n  end function intersect\n"}
{"instruction": "Create a Fortran function named lgcl that takes an integer input argument and returns a logical value. The input parameter should be of type integer, and the output parameter should be of type logical. This function checks if the input integer is less than or equal to zero and returns .false. if true, and .true. if false.", "input": "", "output": "        pure elemental function lgcl(i)\n            integer, intent(in) :: i\n            logical :: lgcl\n            if (i .le. 0) then\n                lgcl = .false.\n            else\n                lgcl = .true.\n            end if\n        end function\n"}
{"instruction": "Write a Fortran function named padfft that calculates the padded length for a Fast Fourier Transform (FFT). The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter represents the original length of the FFT, and the output parameter represents the padded length.", "input": "", "output": "        recursive function padfft(n) result(m)\r\n        integer, intent(in) :: n\r\n        integer :: m\r\n\r\n        integer, parameter :: ntry = 4\r\n        integer, dimension(ntry) :: htry \r\n\r\n        integer, parameter :: idebug = 0\r\n        integer :: itry, i\r\n\r\n\r\n        if (n.le.1) then\r\n                m = 1\r\n                return\r\n        endif\r\n\r\n        if (idebug.ge.1) then\r\n                write(*,*) 'padfft(',n,') '\r\n        endif\r\n\r\n         htry(1) = 4\r\n         htry(2) = 2\r\n         htry(3) = 3\r\n         htry(4) = 5\r\n\r\n        do i=1,ntry\r\n          itry = htry(i)\r\n          if (mod(n,itry).eq.0) then\r\n                  m = itry * padfft( int(n/itry) )\r\n                  return\r\n          endif\r\n        enddo\r\n\r\n!       --------------------\r\n!       no match, odd number\r\n!       --------------------\r\n        m = 2* padfft( int( (n+1)/2 ) )\r\n        return\r\n        end function padfft\r\n"}
{"instruction": "Create a Fortran function named fetch_and_add that takes an integer input argument and returns an integer output. The function atomically reads the value of the input parameter and then increments it. The previous value is returned. This function can be used to implement a simple lock.", "input": "", "output": "       function fetch_and_add(p)\n       integer:: fetch_and_add\n       integer, intent(inout) :: p\n\n! atomically read the value of p and then increment it. the previous value is\n! returned. this can be used to implement a simple lock as shown below.\n!$omp atomic capture\n       fetch_and_add = p\n       p = p + 1\n!$omp end atomic\n       end function fetch_and_add\n"}
{"instruction": "Create a Fortran function called find_intersection_between_segments to determine if two line segments intersect. The function takes 4 input arguments of type real(kind=8), each of dimension 2. The output is a single logical value.", "input": "", "output": "  function find_intersection_between_segments(pt1,pt2,pt3,pt4) result(solution)\n\n      logical :: solution\n      real(kind=8),dimension(2)::pt1,pt2,pt3,pt4\n      real(kind=8),dimension(2)::p13,p43,p21\n      real(kind=8)::num_a,num_b,denom,mua,mub\n\n      solution=.false.\n      p21(1)=pt2(1)-pt1(1)\n      p21(2)=pt2(2)-pt1(2)\n      p43(1)=pt4(1)-pt3(1)\n      p43(2)=pt4(2)-pt3(2)\n      p13(1)=pt1(1)-pt3(1)\n      p13(2)=pt1(2)-pt3(2)\n      denom=p43(2)*p21(1)-p43(1)*p21(2)\n      num_a=p43(1)*p13(2)-p43(2)*p13(1)\n      num_b=p21(1)*p13(2)-p21(2)*p13(1)\n      if(denom==0.0_8)then\n         return\n      else\n         mua=num_a/denom\n         mub=num_b/denom\n         if(mua>=0.0_8 .and. mua<=1.0_8)then\n            solution = .true.\n            return\n         else\n            return\n         endif\n      endif\n\n   end function find_intersection_between_segments\n"}
{"instruction": "Create a Fortran function named sku_quench to calculate the quenched structure factor using the input arrays sk0_v, skf_v, and alpha_v, as well as the scalar value u_val. The input parameters consist of 4 arrays of real*8 type and different dimensions. The output parameter is an array of real*8 type with the same dimension as sk0_v. Use an if-else statement to determine the value of sku based on the condition of u_val.", "input": "", "output": "function sku_quench(sk0_v,skf_v,alpha_v,u_val) result(sku)\n\timplicit none\n\treal * 8, dimension(:), intent(in) :: sk0_v, skf_v, alpha_v\n\treal * 8, intent(in) :: u_val\n\treal * 8, dimension(size(sk0_v)) :: sku\n\tinteger :: i1\n\tif (u_val > 0.d0) then\n\t\tsku = skf_v + ( sk0_v - skf_v ) * exp( - alpha_v * u_val )\n\telse\n\t\tsku= sk0_v\n\tend if\n\treturn\nend function\n"}
{"instruction": "Create a Fortran function named util_datetime_get_next_day that takes a single real(8) input parameter, epochtime, and returns a single real(8) output parameter. This function computes the next day's date from the given epochtime and returns it as real(8) type.", "input": "", "output": "    function util_datetime_get_next_day(epochtime)\n        real(8), intent(in) :: epochtime\n        real(8) :: util_datetime_get_next_day\n        if (epochtime - int(epochtime) > 0) then\n            util_datetime_get_next_day = real(ceiling(epochtime))\n        else\n            util_datetime_get_next_day = epochtime + real(1.0)\n        end if\n    end function util_datetime_get_next_day\n"}
{"instruction": "Create a Fortran function named lowercase that takes a single input argument of type character(*) and returns the result as an allocatable character array. The function converts all uppercase letters in the input string to lowercase and leaves other characters unchanged.", "input": "", "output": "pure function lowercase(strinp) result(strout)\n  character(*)                  ,intent(in)     ::      strinp                                                  !<\n  character(:)  ,allocatable                    ::      strout\n  integer                                       ::      i, ilen, ioffset, iquote, iav, iqc\n  ilen          =       len_trim(strinp)\n  ioffset       =       iachar('a')-iachar('a')\n  iquote        =       0\n  strout        =       strinp\n  do i = 1,ilen\n    iav =       iachar(strinp(i:i))\n    if(iquote==0 .and. (iav==34 .or.iav==39)) then\n      iquote    =       1\n      iqc       =       iav\n      cycle\n    end if\n    if(iquote==1 .and. iav==iqc) then\n      iquote    =       0\n      cycle\n    end if\n    if (iquote==1) cycle\n    if(iav >= iachar('a') .and. iav <= iachar('z')) then\n      strout(i:i)       =       achar(iav-ioffset)\n    else\n      strout(i:i)       =       strinp(i:i)\n    end if\n  end do\n  strout    =   trim(adjustl(strout))\nend function\n"}
{"instruction": "Create a Fortran function named \"length\" that takes a string as input and returns the length of the string. The input parameter type is ['character(*)'] and the output parameter type is ['integer'].", "input": "", "output": "  function length(str)\n    !returns the lengths of a string\n    integer :: length,i\n    character(*) :: str\n    do i=1,len(str)\n       if (str(i:i).eq.' ') then\n          length=i-1\n          return\n       end if\n    end do\n    length=len(str)\n  end function length\n"}
{"instruction": "Create a Fortran function named \"lowercase\" that takes a single input parameter of type character(len=*) and returns a single output parameter of type character(len=len(string)). The function should convert the input string to lowercase and return the result. Use the imperative tone in the instruction.", "input": "", "output": "function lowercase(string)\ncharacter(len=*), intent(in) :: string\ncharacter(len=len(string)) :: lowercase\n\n! returns the string converted to lower case\n\ninteger, parameter :: int_a = iachar(\"a\"), &\n                      int_z = iachar(\"z\"), &\n                      a_a_diff = iachar(\"a\") - iachar(\"a\")\ninteger :: i, int_char\n\ndo i=1,len(string)\n   int_char = iachar(string(i:i))\n   if (int_char >= int_a .and. int_char <= int_z) then\n      lowercase(i:i) = achar(int_char + a_a_diff)\n   else\n      lowercase(i:i) = string(i:i)\n   endif\nend do\n\nend function lowercase\n"}
{"instruction": "Create a Fortran function named correc to compute the correction for the tail area of the i-th largest of n order statistics. The function takes 2 input parameters of type integer and returns 1 output parameter of type real.", "input": "", "output": "function correc(i, n) result(fn_val)\r\n\r\n! calculates correction for tail area of the i-th largest of n order statistics.\r\n\r\nimplicit none\r\n\r\ninteger, intent(in)  :: i\r\ninteger, intent(in)  :: n\r\nreal                 :: fn_val\r\n\r\nreal  :: an\r\nreal, parameter  :: c1(7) = (/ 9.5, 28.7, 1.9, 0., -7.0, -6.2, -1.6 /),  &\r\n    c2(7) = (/ -6195., -9569., -6728., -17614., -8278., -3570., 1075. /),  &\r\n    c3(7) = (/ 9.338e4, 1.7516e5, 4.1040e5, 2.1576e6, 2.376e6, 2.065e6,  &\r\n    2.065e6 /), mic = 1.e-6, c14 = 1.9e-5\r\n\r\nfn_val = c14\r\nif(i*n == 4) return\r\nfn_val = 0.0\r\nif(i < 1 .or. i > 7) return\r\nif(i /= 4 .and. n > 20) return\r\nif(i == 4 .and. n > 40) return\r\nan = n\r\nan = 1.0/(an*an)\r\nfn_val = (c1(i) + an*(c2(i) + an*c3(i)))*mic\r\nreturn\r\nend function correc\r\n"}
{"instruction": "Create a Fortran function named sqr_it that takes two input parameters, one of type real*8 and the other of type integer*4. The function returns a real*8 value. The function checks the value of the switch parameter and either returns the square of the input parameter x if switch is 0, or returns 1 if x is positive and -1 if x is negative when switch is 1.", "input": "", "output": "  function sqr_it(x, switch)\n\n    real*8 :: sqr_it, x\n    integer*4 :: switch\n\n    if (switch == 1) then\n      if (x < 0) then\n        sqr_it = -1\n      else\n        sqr_it = 1\n      end if\n    else\n      sqr_it = x\n    end if\n\n  end function sqr_it\n"}
{"instruction": "Create a Fortran function named strain_index that takes two integer input parameters and returns an integer output. The input parameters should be of type integer, and the output parameter should also be of type integer. The function calculates the strain index based on the values of the input parameters and assigns the result to the variable strain_index.", "input": "", "output": "  function strain_index(i, j)\n    integer, intent(in) :: i, j\n    integer :: strain_index\n\n    if (i == j) strain_index = i\n    if ((i == 2 .and. j == 3) .or. (i == 3 .and. j == 2)) strain_index = 4\n    if ((i == 3 .and. j == 1) .or. (i == 1 .and. j == 3)) strain_index = 5\n    if ((i == 1 .and. j == 2) .or. (i == 2 .and. j == 1)) strain_index = 6\n  end function strain_index\n"}
{"instruction": "Create a Fortran function named producto_cruz to compute the cross product of two 3D vectors. The function should have 2 input parameters of type real(kind=8), dimension(3) and an intent(in), and the output parameter should be a 3D vector of type real(kind=8), dimension(3).", "input": "", "output": "function producto_cruz(a,b) result(vector)\r\n\r\n! definici\ufffdn de la funci\ufffdn prodcuto cruz con\r\n! salida como resultado de un vector 3d\r\n!\r\n! *****************************************!\r\n\r\nimplicit none\r\n\r\nreal(kind=8),dimension(3),intent(in)::a,b\r\nreal(kind=8),dimension(3) :: vector\r\n\r\n\r\nvector(1) = a(2) * b(3) - a(3) * b(2)\r\nvector(2) = a(3) * b(1) - a(1) * b(3)\r\nvector(3) = a(1) * b(2) - a(2) * b(1)\r\n\r\n\r\nend function producto_cruz\r\n"}
{"instruction": "Create a Fortran function named reduce_blanks that processes a string input to remove consecutive blank characters and pad trailing blanks. The number of input arguments is 1 with a test_data type of ['character(*)'], and the number of output arguments is 1 with a test_data type of ['character(len_trim(s))'].", "input": "", "output": "\tfunction reduce_blanks(s)  result (outs)\n\t\tcharacter(*)      :: s\n\t\tcharacter(len_trim(s)) :: outs\n\t\tinteger           :: i, k, n\n\n\t\tn = 0  ; k = len_trim(s)          ! k=index last non-blank (may be null)\n\t\tdo i = 1,k-1                      ! dont process last char yet\n\t\t   n = n+1 ; outs(n:n) = s(i:i)\n\t\t   if (s(i:i+1) == '  ') n = n-1  ! backup/discard consecutive output blank\n\t\tend do\n\t\tn = n+1  ; outs(n:n)  = s(k:k)    ! last non-blank char output (may be null)\n\t\tif (n < k) outs(n+1:) = ' '       ! pad trailing blanks\n\tend function reduce_blanks\n"}
{"instruction": "Create a Fortran function named tolower, which takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len(line)). The function converts all uppercase letters in the input string to lowercase. Use imperative tone to define the function.", "input": "", "output": "function tolower( line )\n    character(len=*)                          :: line\n    character(len=len(line))                  :: tolower\n\n    integer                                   :: i\n    integer, parameter                        :: offset = iachar('a') - iachar('a')\n\n    tolower = line\n    do i = 1,len_trim(line)\n        if ( iachar(line(i:i)) >= iachar('a') .and. iachar(line(i:i)) <= iachar('z') ) then\n            tolower(i:i) = achar(iachar(line(i:i))-offset)\n        endif\n    enddo\nend function tolower\n"}
{"instruction": "Create a Fortran function named julday that takes three integer input parameters (dd, mm, yyyy) and returns a single integer output. This function computes the Julian day number corresponding to the given calendar date, where dd represents the day, mm represents the month, and yyyy represents the year. Ensure to handle edge cases such as zero year and the transition to the Gregorian calendar in 1582.", "input": "", "output": "function julday(dd,mm,yyyy)\n!\nimplicit none\n!\n! parameter definitions\n!\ninteger,parameter :: igreg = 15 + 31*(10+12*1582)\n!\n\n!\ninteger :: dd,mm,yyyy\ninteger :: julday\n!\n! local variables\n!\nreal*8 :: dble\ninteger :: int\ninteger :: ja,jm,jy,y_nw\n!\n!     + + + purpose + + +\n!     in this routine julday returns the julian day number which begins at\n!     noon of the calendar date specified by day \"dd\", month \"mm\", & year \"yyyy\"\n!     all are integer variables. positive year signifies a.d.; negative, b.c.\n!     remember that the year after 1 b.c. was 1 a.d.\n \n!     the following invalid calendar dates are checked for and reported:\n!     1. zero year\n!     2. dates between 4/10/1582 and 15/10/1582 are specified.\n!\n!     additional checking for other invalid dates could be added\n!     in the future if necessary.\n!\n!     + + + keywords + + +\n!     date, utility\n!\n!     + + + argument declarations + + +\n!\n!     + + + argument definitions + + +\n!     dd - integer value of day in the range 1-31\n\n!     mm - integer value of month in the range 1-12\n!     yyyy - integer value of year (negative a.d., positive b.c.)\n!\n!     + + + parameters + + +\n!     gregorian calendar was adopted on oct. 15, 1582.\n!\n!     + + + local variable definitions + + +\n!     dble - \n!     int - \n!     ja - \n!     jm - \n!     jy - \n!     y_nw - \n\n!     + + + end specifications + + +\n!\nif (yyyy.eq.0) write (*,*) 'there is no year zero'\nif ((yyyy.eq.1582).and.(mm.eq.10).and.(dd.lt.15).and.(dd.gt.4)) write (*,*)     &\n   & 'this is an invalid date'\nif (yyyy.lt.0) then\n  y_nw = yyyy + 1\nelse\n  y_nw = yyyy\nend if\nif (mm.gt.2) then\n  jy = y_nw\n  jm = mm + 1\nelse\n  jy = y_nw - 1\n  jm = mm + 13\nend if\njulday = int(365.25*jy) + int(30.6001*jm) + dd + 1720995\nif (dd+31*(mm+12*y_nw).ge.igreg) then\n  ja = jy/100\n!         ja=int(dble(0.01)*dble(jy))\n  julday = julday + 2 - ja + int(dble(0.25)*dble(ja))\nend if\n!\nend function julday\n"}
{"instruction": "Create a Fortran function named erf_salmon_short to calculate the approximate value of the error function for a given real(8) input. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "  function erf_salmon_short(x) result(y) ! 0d0 <=x<0.5d0\n    implicit none\n    real(8),intent(in) :: x\n    real(8) :: y\n    real(8) :: x2\n    real(8),parameter :: &\n       a(0:4) = (/  &\n       & 3.209377589138469472562d3, &\n       & 3.774852376853020208137d2, &\n       & 1.138641541510501556495d2, &\n       & 3.161123743870565596947d0, &\n       & 1.857777061846031526730d-1 &\n       &/), &\n       b(0:4) = (/  &\n       & 2.844236833439170622273d3, &\n       & 1.282616526077372275645d3, &\n       & 2.440246379344441733056d2, &\n       & 2.360129095234412093499d1, &\n       & 1d0 &\n       &/)\n\n    x2 = x**2\n    y = x*(a(0) + a(1)*x2 + a(2)*x2**2 + a(3)*x2**3 + a(4)*x2**4 ) &\n         /(b(0) + b(1)*x2 + b(2)*x2**2 + b(3)*x2**3 + b(4)*x2**4 )\n\n\n  end function erf_salmon_short\n"}
{"instruction": "Create a Fortran function named krondelta to calculate the Kronecker delta. The function takes 2 integer input parameters and returns 1 integer output parameter. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "pure function krondelta(i,j) result(k)\n\n    integer, intent(in) :: i,j\n    integer :: k\n\n    if (i == j) then\n        k = 1\n    else\n        k = 0\n    end if\n\nend function\n"}
{"instruction": "Write a Fortran function named deriv to calculate the derivative of a point using three neighboring points and corresponding function values. The function takes 7 input arguments of type real(kind=8) and integer. The input arguments are x0, x1, x2, f0, f1, f2, and which, and the output argument is deriv of type real(kind=8).", "input": "", "output": "\tfunction deriv(x0, x1, x2, f0, f1, f2, which)\n\treal(kind=8) :: deriv\n\treal(kind=8), intent(in) :: x0, x1, x2, f0, f1, f2\n\tinteger, intent(in) :: which\n\treal(kind=8) :: h1, h2, c0, c1, c2, x\n\t\n\t\tx = 0.d0\n\t\tif (which == 0) x = x0\n\t\tif (which == 1) x = x1\n\t\tif (which == 2) x = x2\n\t\th1 = x1 - x0\n\t\th2 = x2 - x1\n\t\tc0 = 1.d0 / (h1*(h1+h2))\n\t\tc1 = 1.d0 / (h1*h2)\n\t\tc2 = 1.d0 / (h2*(h1+h2))\n\t\t\n\t\tderiv = f0 * c0 * ( (x-x2) + (x-x1) ) - f1 * c1 * ( (x-x0) + (x-x2) ) + &\n\t\t\tf2 * c2 * ( (x-x0) + (x-x1) ) \n\t\t\t\n\tend function deriv\n"}
{"instruction": "Create a Fortran function named lag_deriv, which takes 7 input arguments of type real(kind=8) and integer. The input arguments are x0, x1, x2, f0, f1, f2, and which. The output is a single real(kind=8) value. The function computes the derivative using Lagrange interpolation based on the input values and the specified derivative order. Use the imperative tone to define the function.", "input": "", "output": "\tfunction lag_deriv(x0, x1, x2, f0, f1, f2, which)\n\treal(kind=8) :: lag_deriv\n\treal(kind=8), intent(in) :: x0, x1, x2, f0, f1, f2\n\tinteger, intent(in) :: which\n\treal(kind=8) :: h1, h2, c0, c1, c2\n\t\th1 = x1 - x0\n\t\th2 = x2 - x1\n\t\tc0 = 1.d0 / (h1*(h1+h2))\n\t\tc1 = 1.d0 / (h1*h2)\n\t\tc2 = 1.d0 / (h2*(h1+h2))\n\n\t\tlag_deriv = 0.d0\n\t\t\n\t\tif (which == 0) then\n\t\t\tlag_deriv = -c0 * f0 * (2d0 * h1 + h2) - c1 * f1 * (h1 + h2) - c2 * f2 * h1\n\t\tendif\n\t\t\n\t\tif (which == 1) then\n\t\t\tlag_deriv = -c0 * f0 * h2 + c1 * f1 * (h1 - h2) + c2 * f2 * h1\n\t\tendif\n\t\t\n\t\tif (which == 2) then\t\t\t\n\t\t\tlag_deriv = c0 * f0 * h2 + c1 * f1 * (h1 + h2) + c2 * f2 * (2.d0 * h2 + h1)\n\t\tendif\n\t\t\n\tend function lag_deriv\n"}
{"instruction": "Create a Fortran function named voigt, which takes 3 input parameters of type real(kind=8), real(kind=8), and integer respectively. The function should return 1 output parameter of type real(kind=8). The function calculates the Voigt profile function, which is a convolution of a Gaussian and a Lorentzian distribution, and returns the resulting value. Use the imperative tone to define the function.", "input": "", "output": "      function voigt(a,vv,j)\n\t  real(kind=8) :: voigt, a, vv\n\t  integer :: j, k, i, kk, kkk\n\t  real(kind=8) :: d1, d2, d3, d12, d13, d23, d, y\n      real(kind=8) :: a0, a1, a2, a3, a4, a5, a6, b0, b1, b2, b3, b4, b5, b6\n\t  real(kind=8) :: v\n      complex :: z\n      real(kind=8) :: xdws(28),ydws(28)\n\n      data a0,a1,a2,a3,a4,a5,a6,b0,b1,b2,b3,b4,b5,b6/&\n      122.607931777104326d0,214.382388694706425d0,181.928533092181549d0,&\n      93.155580458138441d0,30.180142196210589d0,5.912626209773153d0,&\n      .564189583562615d0,122.60793177387535d0,352.730625110963558d0,&\n      457.334478783897737d0,348.703917719495792d0,170.354001821091472d0,&\n      53.992906912940207d0,10.479857114260399d0/\n\n      data xdws/.1d0,.2d0,.3d0,.4d0,.5d0,.6d0,.7d0,.8d0,.9d0,1.d0,1.2d0,1.4d0,1.6d0,1.8d0,2.d0,&\n      3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,12.d0,14.d0,16.d0,18.d0,20.d0/,ydws/&\n      9.9335991d-02,1.9475104d-01,2.8263167d-01,3.5994348d-01,&\n      4.2443639d-01,4.7476321d-01,5.1050407d-01,5.3210169d-01,&\n      5.4072434d-01,5.3807950d-01,5.0727350d-01,4.5650724d-01,&\n      3.9993989d-01,3.4677279d-01,3.0134040d-01,1.7827103d-01,&\n      1.2934799d-01,1.0213407d-01,8.4542692d-02,7.2180972d-02,&\n      6.3000202d-02,5.5905048d-02,5.0253846d-02,4.1812878d-02,&\n      3.5806101d-02,3.1311397d-02,2.7820844d-02,2.5031367d-02/\n\n      v=dabs(vv)\n      if(a.ne.0) goto 1 \n      if(j.ne.0) goto 3 \n      voigt=dexp(-v*v)   \n      return\n   3  if(v.gt.xdws(1)) goto 4   \n      d=v*(1.-.66666667d0*v*v)\n      goto 8\n   4  if(v.gt.xdws(28)) goto 5  \n      k=27  \n      do 7 i=2,27   \n      if(xdws(i).lt.v) goto 7   \n      k=i   \n      goto 6\n   7  continue  \n   6  kk=k-1\n      kkk=k+1   \n      d1=v-xdws(kk) \n      d2=v-xdws(k)  \n      d3=v-xdws(kkk)\n      d12=xdws(kk)-xdws(k)  \n      d13=xdws(kk)-xdws(kkk)\n      d23=xdws(k)-xdws(kkk) \n      d=ydws(kk)*d2*d3/(d12*d13)-ydws(k)*d1*d3/(d12*d23)+ydws(kkk)*&\n        d1*d2/(d13*d23)\n      goto 8\n   5  y=.5/v\n      d=y*(1.+y/v)  \n   8  voigt=5.641895836d-1*d\n   9  if(vv.lt.0.) voigt=-voigt \n      return\n   1  z=cmplx(a,-v) \n      z=((((((a6*z+a5)*z+a4)*z+a3)*z+a2)*z+a1)*z+a0)/&\n      (((((((z+b6)*z+b5)*z+b4)*z+b3)*z+b2)*z+b1)*z+b0)\n      if(j.ne.0) goto 2 \n      voigt=real(z) \n      return\n   2  voigt=.5d0*aimag(z) \n      goto 9\n      end function voigt\n"}
{"instruction": "Write a Fortran function named scatter_realvector that takes three input parameters: a real array 'sparsevec', an integer array 'sparseindex', and a single integer 'ndimdense'. It returns one output parameter, a real allocatable array 'densevec'. The function populates the 'densevec' array with the values from 'sparsevec' at the corresponding indices specified by 'sparseindex', and allocates memory for 'densevec' with dimension 'ndimdense'.", "input": "", "output": "      function scatter_realvector(sparsevec,sparseindex,ndimdense) result(densevec)\n!\n\n!     into the output vector that is dense with dimension ndimdense.\n!\n      implicit none\n      real,dimension(:),allocatable::densevec\n      real,dimension(:),intent(in)::sparsevec\n      integer,dimension(:),intent(in)::sparseindex\n      integer,intent(in)::ndimdense\n      integer::i\n!\n      allocate(densevec(ndimdense))\n      densevec = float(0)\n      do i = 1,size(sparseindex)\n        densevec(sparseindex(i)) = sparsevec(i)\n      enddo\n!\n      return\n      end function scatter_realvector\n"}
{"instruction": "Write a Fortran function named compar to compare two integers and return the result as an integer. The function takes 2 input arguments of type integer(4) and returns 1 output argument of type integer(2). The comparison result is -1 if the first argument is less than the second, 1 if the first argument is greater than the second, and 0 if they are equal.", "input": "", "output": "    function compar (arg1, arg2)\n    integer(2) :: compar\n    integer(4) :: arg1,arg2\n    if (arg1 < arg2) then\n        compar = -1\n    else if (arg1 > arg2) then\n        compar = 1\n    else\n        compar = 0\n    end if\n    end function compar\n"}
{"instruction": "Write a Fortran function named heus2010 to calculate the humidity parameter based on the input temperature, qsat, and total liquid water content. The number of input arguments is 3 and the test_data type is [real, real, real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function heus2010(t, qs, qt)\n  implicit none\n  real :: heus2010\n  real, intent(in) :: t   ! [k] temperature to evalute at (tl)\n  real, intent(in) :: qs  ! []  qsat at this temperature t\n  real, intent(in) :: qt  ! []  total liquid water\n\n  real, parameter :: l = 2.5e6      ! [j/kg] the latent heat of vaporization\n  real, parameter :: rv = 461.5     ! [j/kgk] the gas constant for water vapor\n  real, parameter :: c_pd = 1004.0  ! [j/kgk] the heat capacity of dry air\n  real, parameter :: c = rv * c_pd / l**2\n\n  ! heus2010 = qs * &\n  !   (1. + l**2 * qt / (rv * c_pd * t**2)) / & \n  !   (1. + l**2 * qs / (rv * c_pd * t**2))\n\n  ! heus2010 = qs * (c * t*t + qt) / (c * t*t + qs)\n  heus2010 = qs * (1 + qt/(c*t*t)) / (1 + qs/(c*t*t))\nend function heus2010\n"}
{"instruction": "Create a Fortran function named wagnerpruss_ice that takes a single real number as input and computes the vapor pressure of ice at that temperature. The input parameter is of type real, and the output parameter is also of type real.", "input": "", "output": "function wagnerpruss_ice(t)\n\nimplicit none\nreal, intent(in) :: t\nreal :: wagnerpruss_ice\n\nreal, parameter :: tt = 273.16 ! triple point temperature of water [k]\n\nwagnerpruss_ice = 611.657 * exp( &\n  (tt/t) * ( &\n    + 21.2144006 * (t/tt)**0.00333333333 &\n    + 27.3203819 * (t/tt)**1.20666667 &\n    +  6.1059813 * (t/tt)**1.70333333 &\n  ))\n\nend function wagnerpruss_ice\n"}
{"instruction": "Write a Fortran function called prefix that checks if the first input string is a prefix of the second input string. The number of input arguments is 2 with test_data type ['character(len=*)', 'character(len=*)'], and the number of output arguments is 1 with test_data type ['logical'].", "input": "", "output": "function prefix(pre, str) result(out)\n\tcharacter(len=*), intent(in) :: pre\n\tcharacter(len=*), intent(in) :: str\n\tlogical :: out\n\n\tinteger :: length\n\tinteger :: i\n\n\tlength = len(pre)\n\tout = .true.\n\n\tif (length > len(str)) then\n\t\tout = .false.\n\t\treturn\n\tend if\n\n\tdo i = 1, length\n\t\tif (pre(i:i) /= str(i:i)) then\n\t\t\tout = .false.\n\t\t\texit\n\t\tend if\n\tend do\nend function prefix\n"}
{"instruction": "Create a Fortran function named isspace to determine if a character is a white space character. The function takes 1 input parameter of type character(len=1) and returns 1 output parameter of type logical. The test_data type for input is ['character(len=1)'] and for output is ['logical'].", "input": "", "output": "function isspace(c) result(out)\n\tcharacter(len=1), intent(in) :: c\n\tlogical :: out\n\n\tselect case (ichar(c))\n\t\tcase (9:13) ! horizontal tab, newline, vertical tab, form-feed, carriage return\n\t\t\tout = .true.\n\t\tcase (32) ! space\n\t\t\tout = .true.\n\t\tcase default\n\t\t\tout = .false.\n\tend select\nend function isspace\n"}
{"instruction": "Write a Fortran function named isalnum to determine if a single character is alphanumeric. The function should have 1 input parameter with a test_data type of ['character(len=1)'] and 1 output parameter with a test_data type of ['logical'].", "input": "", "output": "function isalnum(c) result(out)\n\tcharacter(len=1), intent(in) :: c\n\tlogical :: out\n\n\tselect case (ichar(c))\n\t\tcase (48:57) ! numeric\n\t\t\tout = .true.\n\t\tcase (65:90) ! capital letters\n\t\t\tout = .true.\n\t\tcase (97:122) ! lowercase letters\n\t\t\tout = .true.\n\t\tcase default\n\t\t\tout = .false.\n\tend select\nend function isalnum\n"}
{"instruction": "Write a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer (kind=8) and has 1 output parameter of type logical.", "input": "", "output": "        function isprime (s)\n                logical :: isprime\n                integer (kind=8) :: s, i, top\n\n                isprime = .false.  \n\n                if(s <= 1) then\n                        return\n                end if\n\n                top = int(sqrt(real(s))) + 1\n\n                do i = 2, top + 1, 1\n\n                        if (i == top) then\n                                isprime = .true.\n                                exit\n                        end if\n\n                        if(mod(s, i) == 0) then\n                                exit\n                        end if\n\n                end do\n\n                return\n\n        end function isprime\n"}
{"instruction": "Create a Fortran function named fstring_toupper that takes a single input argument of type character(*) and returns a single output argument of type character(len(str)). The function converts each character in the input string to uppercase and then returns the modified string.", "input": "", "output": "\tfunction fstring_toupper( str ) result( output )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(len(str)) :: output\n\t\t\n\t\t! translation from awk implementation\n\t\t! echo a\u00e1bcde\u00e9fghi\u00e9jklmno\u00f3pqrstu\u00favwxyz | awk '{ print toupper($0) }'\n\t\tcharacter(*), parameter :: lc = \"\u00a1!\u00bf? a\u00e1bcde\u00e9fghi\u00edjklmno\u00f3pqrstu\u00favwxyz\"\n\t\tcharacter(*), parameter :: uc = \"\u00a1!\u00bf? a\u00e1bcde\u00e9fghi\u00edjklmno\u00f3pqrstu\u00favwxyz\"\n\t\t\n\t\tinteger :: j, k\n\t\t\n\t\toutput = str\n\t\tdo j=1,len_trim(str)\n\t\t\tk = index( lc, str(j:j) )\n\t\t\tif (k > 0) output(j:j) = uc(k:k)\n\t\tend do\n\tend function fstring_toupper\n"}
{"instruction": "Create a Fortran function named fstring_tolower, which takes a string as input and converts it to lowercase. The number of input parameters is 1, and the test_data type is ['character(*)']. The number of output parameters is 1, and the test_data type is ['character(len(str))'].", "input": "", "output": "\tfunction fstring_tolower( str ) result( output )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(len(str)) :: output\n\t\t\n\t\tcharacter(*), parameter :: lc = \"\u00a1!\u00bf? a\u00e1bcde\u00e9fghi\u00edjklmno\u00f3pqrstu\u00favwxyz\"\n\t\tcharacter(*), parameter :: uc = \"\u00a1!\u00bf? a\u00e1bcde\u00e9fghi\u00edjklmno\u00f3pqrstu\u00favwxyz\"\n\t\t\n\t\tinteger :: j, k\n\t\t\n\t\toutput = str\n\t\tdo j=1,len_trim(str)\n\t\t\tk = index( uc, str(j:j) )\n\t\t\tif (k > 0) output(j:j) = lc(k:k)\n\t\tend do\n\tend function fstring_tolower\n"}
{"instruction": "Create a Fortran function named bump_function that takes a single input argument of type real. This function computes and returns a single real value based on the input. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function bump_function(x) result(y)\n    real :: x, y\n    if (abs(x) < 1) then\n        y = exp(-1/(1-(x**2)))\n    else\n        y = 0\n    end if\nend function bump_function\n"}
{"instruction": "Create a Fortran function named convertgalactictoxyz to convert galactic coordinates (r, l, b) to Cartesian (x, y, z) coordinates. The number of input arguments is 3 and the test_data type is ['real*8', 'real*8', 'real*8']. The number of output arguments is 1 and the test_data type is ['real*8, dimension(3)'].", "input": "", "output": "    function convertgalactictoxyz(r, l, b) result(coordinate)\n        real*8, intent(in) :: r, l, b\n        real*8, dimension(3) :: coordinate\n\n        coordinate(1) = r * dcos(b) * dcos(l)\n        coordinate(2) = r * dcos(b) * dsin(l)\n        coordinate(3) = r * dsin(b)\n    end function\n"}
{"instruction": "Create a Fortran function named formattime to format the date and time. The function takes 7 input arguments of type integer and optional integer, and 1 optional logical argument. The output is a character string of length 19. Use the imperative tone.", "input": "", "output": "    function formattime(iyear, imonth, iday, ihourin, iminutein, isecondin, lshortformin) result(sdate)\n    \n        ! routine arguments\n        integer, intent(in)             :: iyear\n        integer, intent(in)             :: imonth\n        integer, intent(in)             :: iday\n        integer, intent(in), optional   :: ihourin\n        integer, intent(in), optional   :: iminutein\n        integer, intent(in), optional   :: isecondin\n        logical, intent(in), optional   :: lshortformin\n        character(len=19)               :: sdate\n        \n        ! locals\n        integer :: ihour\n        integer :: iminute\n        integer :: isecond\n        logical :: lshortform\n        \n        ! format date\n        if(present(ihourin)) then\n            ihour = ihourin\n        else\n            ihour = 0\n        end if\n        if(present(iminutein)) then\n            iminute = iminutein\n        else\n            iminute = 0\n        end if\n        if(present(isecondin)) then\n            isecond = isecondin\n        else\n            isecond = 0\n        end if\n        if(present(lshortformin)) then\n            lshortform = lshortformin\n        else\n            lshortform = .false.\n        end if\n        if(lshortform) then\n            write(sdate,\"(2(i2.2,'/'),i2.2,1x,2(i2.2,':'),i2.2)\") iday, imonth, mod(iyear,100), ihour, iminute, isecond\n        else\n            write(sdate,\"(2(i2.2,'/'),i4.4,1x,2(i2.2,':'),i2.2)\") iday, imonth, iyear, ihour, iminute, isecond\n        end if\n        \n    end function formattime\n"}
{"instruction": "Create a Fortran function named numdays that calculates the number of days in a given month of a specified year. The function takes 2 input arguments of type integer (iyear, imonthin) and returns 1 output argument of type integer (idays). The function uses parameters and conditional statements to handle leap years and computes the number of days accordingly.", "input": "", "output": "    function numdays(iyear, imonthin) result(idays)\n    \n    \t! routine arguments\n    \tinteger, intent(in)\t:: iyear\n    \tinteger, intent(in)\t:: imonthin\n    \tinteger\t\t\t\t:: idays\n    \t\n    \t! locals\n    \tinteger\t\t\t\t\t\t\t\t:: imonth\n    \tinteger, dimension(12), parameter\t:: ivdaysn = (/ &\n    \t\t31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &\n    \t/)\n    \tinteger, dimension(12), parameter\t:: ivdayse = (/ &\n    \t\t31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &\n    \t/)\n    \t\n    \t! compute the number of days in current month\n    \timonth = max(min(imonthin,12),1)\n    \tif(mod(iyear,4)/=0) then\n    \t\tidays = ivdaysn(imonth)\n    \telse\n    \t\tidays = ivdayse(imonth)\n    \tend if\n    \t\n    end function numdays\n"}
{"instruction": "Create a Fortran function named construct_record to process given data and generate a formatted record. The function takes 4 input parameters of types ['character (len=*)', 'character (len=*)', 'integer, dimension(8)', 'real, dimension(3)'] and returns 1 output parameter of type ['character (len=256)'].", "input": "", "output": "function construct_record(label, votes, pcts, flag) result(record)\n   implicit none\n   ! dummy arguments\n   character (len=*), intent(in) :: label, flag\n   integer, dimension(8), intent(in) :: votes\n   real, dimension(3), intent(in) :: pcts\n\n   character (len=256) :: record\n   ! local data\n   integer i, n\n   character (len=25) :: field\n   ! processing\n   record = '' ! clear any junk\n   if (flag == 'flat') then\n      record(1:14) = label\n      n = 15\n      do i = 1, 4\n         write (record(n:n+3),'(i4)') votes(i)\n         n = n + 4\n      end do\n      do i = 5, 8\n         write (record(n:n+9),'(i10)') votes(i)\n         n = n + 10\n      end do\n      do i = 1, 3\n         write (record(n:n+7),'(f8.2)') pcts(i)\n         n = n + 8\n      end do\n      return\n   else if (flag == 'html') then \n      record='<tr><td>'//trim(label)//'</td>'\n   else\n      record=trim(label)\n   end if\n   do i = 1, 8\n      if (flag == 'csv') record = trim(record)//','\n      if (flag == 'tab') record = trim(record)//char(9)\n      if (flag == 'html') record = trim(record)//'<td>'\n      write (field,*) votes(i)\n      record = trim(record)//adjustl(field)\n      if (flag == 'html') record = trim(record)//'</td>'\n   end do\n   do i = 1, 3\n      if (flag == 'csv') record = trim(record)//','\n      if (flag == 'tab') record = trim(record)//char(9)\n      if (flag == 'html') record = trim(record)//'<td>'\n      write (field,'(f8.2)') pcts(i)\n      record = trim(record)//adjustl(field)\n      if (flag == 'html') record = trim(record)//'</td>'\n   end do   \n   if (flag == 'html') record = trim(record)//'</tr>'\nend function construct_record\n"}
{"instruction": "Provide a Fortran function named tolower to convert all uppercase characters in a given string to lowercase. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(len(str)).", "input": "", "output": "elemental function tolower(str)\n!! convert uppercase characters to lowercase\n!!\n!! can be trivially extended to non-ascii\ncharacter(*), intent(in) :: str\ncharacter(len(str)) :: tolower\ncharacter(*), parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\", &\n                           upper=\"abcdefghijklmnopqrstuvwxyz\"\ninteger :: i,j\n\ntolower = str\n\ndo concurrent (i = 1:len(str))\n  j = index(upper,str(i:i))\n  if (j > 0) tolower(i:i) = lower(j:j)\nend do\n\nend function tolower\n"}
{"instruction": "Provide a Fortran function named lowercase, which converts a given string to lower case. The function takes 1 input argument of type character (len=*) and returns the modified string as an output argument of type character (len=len_trim(str)).", "input": "", "output": "    function lowercase(str) result(lcstr)\r\n\r\n    ! convert string to lower case\r\n\r\n    character (len=*):: str\r\n    character (len=len_trim(str)):: lcstr\r\n\r\n    ilen=len_trim(str)\r\n    ioffset=iachar('a')-iachar('a')\r\n    iquote=0\r\n    lcstr=str\r\n    do i=1,ilen\r\n    iav=iachar(str(i:i))\r\n    if(iquote==0 .and. (iav==34 .or.iav==39)) then !checks if character is ' or \"\r\n    iquote=1\r\n    iqc=iav\r\n    cycle\r\n    end if\r\n    if(iquote==1 .and. iav==iqc) then !checks if previous character was ' or \"\r\n    iquote=0\r\n    cycle\r\n    end if\r\n    if (iquote==1) cycle\r\n    if(iav >= iachar('a') .and. iav <= iachar('z')) then !checks if character is capital\r\n    lcstr(i:i)=achar(iav-ioffset) !makes it lowercase\r\n    else\r\n    lcstr(i:i)=str(i:i) !if already lowercase\r\n    end if\r\n    end do\r\n    return\r\n\r\n    end function lowercase\r\n"}
{"instruction": "Create a Fortran function named lengths_and_angles_to_box to convert lengths and angles to a box matrix for multiple frames. The function takes 3 input parameters of type integer, double precision array of dimension (nframes,3), and double precision array of dimension (nframes,3). It returns 1 output parameter of type double precision array of dimension (nframes,3,3).", "input": "", "output": "  function lengths_and_angles_to_box (lengths, angles, nframes) result(box)\n\n    implicit none\n    integer,intent(in)::nframes\n    double precision,dimension(nframes,3),intent(in):: lengths, angles\n    integer::ii\n    double precision,dimension(nframes,3,3)::box\n    double precision::alpha,beta,gamm,x,y,z\n    double precision,parameter::fact_pi_div_180=1.745329251994329547437168059786927e-0002\n \n    box=0.0d0\n\n    do ii=1,nframes\n  \n      alpha=angles(ii,1)*fact_pi_div_180\n      beta=angles(ii,2)*fact_pi_div_180\n      gamm=angles(ii,3)*fact_pi_div_180\n      x=lengths(ii,1)\n      y=lengths(ii,2)\n      z=lengths(ii,3)\n      box(ii,1,1)=x\n      box(ii,2,1)=y*cos(gamm)\n      box(ii,2,2)=y*sin(gamm)\n      box(ii,3,1)=z*cos(beta)\n      box(ii,3,2)=z*(cos(alpha)-cos(beta)*cos(gamm))/sin(gamm) \n      box(ii,3,3)=sqrt(z*z-box(ii,3,1)**2-box(ii,3,2)**2)\n  \n    end do\n\n  end function lengths_and_angles_to_box\n"}
{"instruction": "Write a Fortran function named det to compute the determinant of a 2x2 matrix. The function should take 4 input arguments of type real(8) and return 1 output argument of type real(8).", "input": "", "output": "   function det(p1, p2, p3, p4)\n      !!----------------------------------------------------------\n\n      !!\n      !!    ** purpose : compute determinant\n      !!\n      !! * history:\n      !!     j.m. molines may 2007\n      !!----------------------------------------------------------\n      implicit none\n      real(8),intent(in) :: p1, p2, p3, p4\n      real(8) :: det\n      det = p1*p4 - p2*p3\n   end function det\n"}
{"instruction": "Create a Fortran function named verifyprob to check if the input integer argument corresponds to specific predefined values. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "  function verifyprob(prob)\n\n    ! scalar arguments\n\n    integer :: prob\n\n    ! return value\n\n    logical :: verifyprob\n\n    verifyprob = .false.\n\n    if ( prob .eq. 10 .or. & \n         prob .eq. 11 .or. & \n         prob .eq. 12 .or. & \n         prob .eq. 13 .or. & \n         prob .eq. 15 .or. & \n         prob .eq. 16 .or. & \n         prob .eq. 17 .or. & \n         prob .eq. 18 .or. & \n         prob .eq. 19 .or. & \n         prob .eq. 20 .or. & \n         prob .eq. 21 .or. & \n         prob .eq. 22 .or. & \n         prob .eq. 23 .or. & \n         prob .eq. 24 .or. & \n         prob .eq. 29 .or. & \n         prob .eq. 30 .or. & \n         prob .eq. 31 .or. & \n         prob .eq. 33 .or. & \n         prob .eq. 34 .or. & \n         prob .eq. 35 .or. & \n         prob .eq. 36 .or. & \n         prob .eq. 37 .or. & \n         prob .eq. 43 .or. & \n         prob .eq. 44 .or. & \n         prob .eq. 57 .or. & \n         prob .eq. 58 .or. & \n         prob .eq. 59 .or. & \n         prob .eq. 64 .or. & \n         prob .eq. 65 .or. & \n         prob .eq. 66 .or. & \n         prob .eq. 67 .or. & \n         prob .eq. 70 .or. & \n         prob .eq. 72 .or. & \n         prob .eq. 76 .or. & \n         prob .eq. 83 .or. & \n         prob .eq. 84 .or. & \n         prob .eq. 85 .or. & \n         prob .eq. 86 .or. & \n         prob .eq. 88 .or. & \n         prob .eq. 89 .or. & \n         prob .eq. 90 .or. & \n         prob .eq. 91 .or. & \n         prob .eq. 92 .or. & \n         prob .eq. 93 .or. & \n         prob .eq. 95 .or. & \n         prob .eq. 96 .or. & \n         prob .eq. 97 .or. & \n         prob .eq. 98 .or. & \n         prob .eq. 100 .or. & \n         prob .eq. 101 .or. & \n         prob .eq. 102 .or. & \n         prob .eq. 103 .or. & \n         prob .eq. 104 .or. & \n         prob .eq. 105 .or. & \n         prob .eq. 106 .or. & \n         prob .eq. 108 .or. & \n         prob .eq. 113 .or. & \n         prob .eq. 116 .or. & \n         prob .eq. 117 .or. & \n         prob .eq. 118 .or. & \n         prob .eq. 215 .or. & \n         prob .eq. 218 .or. & \n         prob .eq. 220 .or. & \n         prob .eq. 221 .or. & \n         prob .eq. 222 .or. & \n         prob .eq. 223 .or. & \n         prob .eq. 224 .or. & \n         prob .eq. 225 .or. & \n         prob .eq. 226 .or. & \n         prob .eq. 227 .or. & \n         prob .eq. 228 .or. & \n         prob .eq. 230 .or. & \n         prob .eq. 231 .or. & \n         prob .eq. 232 .or. & \n         prob .eq. 233 .or. & \n         prob .eq. 234 .or. & \n         prob .eq. 236 .or. & \n         prob .eq. 237 .or. & \n         prob .eq. 238 .or. & \n         prob .eq. 239 .or. & \n         prob .eq. 249 .or. & \n         prob .eq. 250 .or. & \n         prob .eq. 251 .or. & \n         prob .eq. 253 .or. & \n         prob .eq. 264 .or. & \n         prob .eq. 268 .or. & \n         prob .eq. 270 .or. & \n         prob .eq. 277 .or. & \n         prob .eq. 278 .or. & \n         prob .eq. 279 .or. & \n         prob .eq. 280 .or. & \n         prob .eq. 284 .or. & \n         prob .eq. 285 .or. & \n         prob .eq. 315 .or. & \n         prob .eq. 323 .or. & \n         prob .eq. 324 .or. & \n         prob .eq. 326 .or. & \n         prob .eq. 327 .or. & \n         prob .eq. 329 .or. & \n         prob .eq. 330 .or. & \n         prob .eq. 331 .or. & \n         prob .eq. 332 .or. & \n         prob .eq. 337 .or. & \n         prob .eq. 339 .or. & \n         prob .eq. 340 .or. & \n         prob .eq. 341 .or. & \n         prob .eq. 342 .or. & \n         prob .eq. 343 .or. & \n         prob .eq. 346 .or. & \n         prob .eq. 347 .or. & \n         prob .eq. 349 .or. & \n         prob .eq. 354 .or. & \n         prob .eq. 356 .or. & \n         prob .eq. 359 .or. & \n         prob .eq. 360 .or. & \n         prob .eq. 361 .or. & \n         prob .eq. 362 .or. & \n         prob .eq. 363 .or. & \n         prob .eq. 364 .or. & \n         prob .eq. 365 .or. & \n         prob .eq. 366 .or. & \n         prob .eq. 369 .or. & \n         prob .eq. 372 .or. & \n         prob .eq. 374 .or. & \n         prob .eq. 380 .or. & \n         prob .eq. 384 .or. & \n         prob .eq. 385 .or. & \n         prob .eq. 386 .or. & \n         prob .eq. 387 .or. & \n         prob .eq. 388 .or. & \n         prob .eq. 389 .or. & \n         prob .eq. 392 ) then\n\n       verifyprob = .true.\n\n    end if\n\n    return\n\n  end function verifyprob\n"}
{"instruction": "Write a Fortran function named isleapyear to determine if a given year is a leap year or not. The function takes 1 input argument of type integer and returns 1 output argument of type logical. The test_data type for the input is ['integer'] and for the output is ['logical'].", "input": "", "output": "function isleapyear(year)\n! check if year is leapyear\nimplicit none\ninteger,intent(in) :: year\nlogical :: isleapyear\n\nif( mod(year,4) .ne. 0 ) then\n  isleapyear=.false.\nelse \n  isleapyear=.true.\n  if ( mod(year,100) == 0 .and. mod(year,400) .ne. 0 ) isleapyear=.false.\nendif\nend function isleapyear\n"}
{"instruction": "Write a Fortran function named i4_reflect to calculate the reflected value of an integer within a specified range. The function takes 3 input parameters of type integer(kind=4) - ival, ilo, and ihi. It returns 1 output parameter of type integer(kind=4).", "input": "", "output": "    elemental function i4_reflect(ival, ilo, ihi)\n        integer(kind=4) :: i4_reflect\n        integer(kind=4), intent(in) :: ival, ilo, ihi\n        integer(kind=4) :: value\n        integer(kind=4) :: dist\n\n        ! the default return value\n        value = ival\n\n        ! the upper boundary\n        if (ival .gt. ihi) then\n            dist = ival - ihi\n            value = ihi - (dist - 1)\n        end if\n\n        ! the lower boundary\n        if (ival .lt. ilo) then\n            dist = ilo - ival\n            value = ilo + (dist - 1)\n        end if\n\n        i4_reflect = value\n\n        return\n    end function i4_reflect\n"}
{"instruction": "Create a Fortran function named quantize that takes 4 input parameters of type real, integer, integer, and integer, and returns 1 output parameter of type integer(kind=1). The function quantize computes the quantization of a real number based on the specified exponent, maximum exponent, and number of bits. Use the imperative tone in your instructions.", "input": "", "output": "    elemental function quantize(x, e, max_exp, bits)\n        real, intent(in) :: x\n        integer, intent(in) :: e, max_exp, bits\n        integer(kind=1) :: quantize\n        integer i\n\n        ! what it does\n        ! quantize = nint(x*(2**bits)/(2**max_exp), kind=1)\n\n        i = e - max_exp + bits\n        quantize = nint(set_exponent(x, i), kind=1)\n\n    end function quantize\n"}
{"instruction": "Create a Fortran function named fun_calc_isotope_fraction that takes 2 real input parameters and returns a real output parameter. The input parameters are dum_delta and dum_standard, and the output parameter is fun_calc_isotope_fraction. The function calculates the isotope fraction using the formula loc_r/(1.0 + loc_r), where loc_r is calculated as dum_standard*(1.0 + dum_delta/1000.0).", "input": "", "output": "  function fun_calc_isotope_fraction(dum_delta,dum_standard)\n    implicit none\n    ! result variable\n    real::fun_calc_isotope_fraction\n    ! dummy arguments\n    real,intent(in)::dum_delta,dum_standard\n    ! local variables\n    real::loc_r\n    ! calculate local variables\n    loc_r = dum_standard*(1.0 + dum_delta/1000.0)\n\n    ! (and convert from r to r)\n    fun_calc_isotope_fraction = loc_r/(1.0 + loc_r)\n  end function fun_calc_isotope_fraction\n"}
{"instruction": "Write a Fortran function named invm to calculate the inverse of a matrix. The function takes one input parameter of type double precision and dimension (:,:), and returns one output parameter of type double precision and dimension(size(ms,1),size(ms,2)).", "input": "", "output": "  function  invm(ms) result(minv)\n    implicit none\n    ! double == double precision (arreglar esto, aumentar precision!)\n    !real, intent(in), dimension(:,:) :: m ! input\n    double precision, dimension(:,:) :: ms ! input\n    integer :: d1,d2,i,i1,j\n    double precision, dimension(size(ms,1),size(ms,2)) :: minv,m ! output\n    double precision :: aux,auxp\n\n\n    d1 = size(ms,1);d2 = size(ms,2)\n    m = ms\n\n    ! creation of the identity matrix:\n    minv = 0\n    do i=1,d1\n      minv(i,i) = 1\n    end do\n\n\n    ! calculation of the inverse matrix:\n\n    do i=1,d1\n      aux = m(i,i)\n      do j=1,d2\n        m(i,j) = m(i,j)/aux\n        minv(i,j) = minv(i,j)/aux\n      end do ! j\n\n      do i1 = 1,d1\n        if (i1 /= i) then ! i1 not equal to i\n          auxp = -m(i1,i);\n\n          do j=1,d2\n            m(i1,j) = m(i1,j) + m(i,j)*auxp;\n            minv(i1,j) = minv(i1,j) + minv(i,j)*auxp;\n          end do\n\n        end if\n      end do ! i1\n\n    end do ! i\n\n\n  end function invm\n"}
{"instruction": "Write a Fortran function named incr2 that generates an array of consecutive integers from a to b. The number of input arguments is 2, and the test_data type is ['integer', 'integer']. The number of output arguments is 1, and the test_data type is ['integer, allocatable, dimension(:,:)']. Make sure to use \"allocate\" to dynamically allocate memory for the output array. Remember to deallocate the memory once the array is no longer needed.", "input": "", "output": "  function  incr2(a,b) result(m)\n    implicit none\n    integer :: a,b,i,n\n    integer, allocatable, dimension(:,:) :: m ! output\n\n    n = b-a+1\n    allocate( m(1,n) )  != (/(i, i=a, b, 1)/)\n    m(1,:) = (/(i, i=a, b, 1)/)\n    !deallocate(m)\n  end function incr2\n"}
{"instruction": "Create a Fortran function named h_2 that concatenates two input matrices m1 and m2 into a single output matrix m. The input parameters are of type double precision and have dimensions specified by the size of the matrices. The output parameter is also of type double precision with dimensions determined by the size of m1 and m2.", "input": "", "output": "function h_2(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:,:) :: m1,m2 ! input\n  double precision, dimension(size(m1,1),size(m1,2)+size(m2,2)) :: m ! output\n\n\n  m(:,1:size(m1,2)) = m1\n  m(:,size(m1,2)+1:size(m1,2)+size(m2,2)) = m2\n\nend function h_2\n"}
{"instruction": "Write a Fortran function named formatdate to convert a date string from one format to another. The function takes 2 input arguments of type character(len=*) and returns 1 output argument of type character(len=80).", "input": "", "output": "function formatdate(datein,dateform)\ncharacter(len=*), intent(in) :: datein\ncharacter(len=*), intent(in) :: dateform\n\ncharacter(len=80) :: formatdate\ninteger :: ic,iy,im,id,ih,in,is\n\nic=index(dateform,'cc')\niy=index(dateform,'yy')\nim=index(dateform,'mm')\nid=index(dateform,'dd')\nih=index(dateform,'hh')\nin=index(dateform,'nn')\nis=index(dateform,'ss')\n\nformatdate=trim(dateform)\n\nif (ic /= 0) formatdate(ic:ic+1) = datein(1:2)\nif (iy /= 0) formatdate(iy:iy+1) = datein(3:4)\nif (im /= 0) formatdate(im:im+1) = datein(5:6)\nif (id /= 0) formatdate(id:id+1) = datein(7:8)\nif (ih /= 0) formatdate(ih:ih+1) = datein(9:10)\nif (in /= 0) formatdate(in:in+1) = datein(11:12)\nif (is /= 0) formatdate(is:is+1) = datein(13:14)\n\nend function formatdate\n"}
{"instruction": "Create a Fortran function called add_allopt that calculates the sum of up to three optional integer input arguments. The number of input arguments is 3 and the test_data type is ['integer, optional', 'integer, optional', 'integer, optional']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function add_allopt(a,b,c) result(y)\n      integer, intent(in), optional :: a,b,c\n      integer :: y\n      y = 0\n      if (present(a)) y = y + a\n      if (present(b)) y = y + b\n      if (present(c)) y = y + c\n    end function add_allopt\n"}
{"instruction": "Write a Fortran function named ei_ex to calculate the exponential integral Ei(x). The function takes 1 input parameter of type real and returns 1 output parameter of type real. If the input parameter x is less than or equal to 1, the function computes the Ei(x) using a series expansion formula, otherwise, it uses a different formula.", "input": "", "output": "  function ei_ex(x) result (y)\n    real  :: x,y\n\n    real, parameter :: a0 = -0.57721566\n    real, parameter :: a1 =  0.99999193\n    real, parameter :: a2 = -0.24991055\n    real, parameter :: a3 =  0.05519968\n    real, parameter :: a4 = -0.00976004\n    real, parameter :: a5 =  0.00107857\n\n    real, parameter :: aa1 = 2.334733  \n    real, parameter :: aa2 = 0.250621\n    real, parameter :: bb1 = 3.330657  \n    real, parameter :: bb2 = 1.681534  \n\n    if (x.le.1) then\n       y = a0+x*(a1+x*(a2+x*(a3+x*(a4+x*a5)))) - log(x)\n    else\n       y = (aa2+x*(aa1+x))/(bb2+x*(bb1+x))/(x*exp(x))\n    end if\n\n  end function ei_ex\n"}
{"instruction": "Create a Fortran function named bcut_getminmod that takes two real numbers as input and returns a real number as output. The function computes the minimum of the absolute values of the two input numbers and returns the result.", "input": "", "output": "function bcut_getminmod(a, b)\n  implicit none\n  real          :: bcut_getminmod\n  real          :: a, b\n!  bcut_getminmod = 0.5*(sign(a, a) + sign(b, b))*min(abs(a), abs(b))\n  bcut_getminmod = 0.0d0\n  if( abs(a) .lt. abs(b) ) then\n    bcut_getminmod = a\n  else if( abs(a) .gt. abs(b) ) then\n    bcut_getminmod = b\n  endif\n  return\nend function bcut_getminmod\n"}
{"instruction": "Create a Fortran function named get_env to retrieve the value of an environment variable. The function takes 2 input arguments of type character(len=*) and character(len=*),optional. It returns 1 output argument of type character(len=:),allocatable.", "input": "", "output": "    function get_env(name,default) result(value)\n\n    implicit none\n    character(len=*),intent(in)          :: name\n    character(len=*),intent(in),optional :: default\n    character(len=:),allocatable         :: value\n    integer                              :: howbig\n    integer                              :: stat\n    integer                              :: length\n       ! get length required to hold value\n       length=0\n       value=''\n       if(name.ne.'')then\n          call get_environment_variable( &\n          & name, length=howbig,status=stat,trim_name=.true.)\n          select case (stat)\n          case (1)\n           !*!print *, name, \" is not defined in the environment. strange...\"\n           value=''\n          case (2)\n           !*!print *, &\n           !*!\"this processor does not support environment variables. boooh!\"\n           value=''\n          case default\n           ! make string to hold value of sufficient size\n           if(allocated(value))deallocate(value)\n           allocate(character(len=max(howbig,1)) :: value)\n           ! get value\n           call get_environment_variable( &\n           & name,value,status=stat,trim_name=.true.)\n           if(stat.ne.0)value=''\n          end select\n       endif\n       if(value.eq.''.and.present(default))value=default\n    end function get_env\n"}
{"instruction": "Write a Fortran function named strtok to tokenize a source string using specified delimiters. The function takes 5 input parameters of type character(len=*), character(len=*), integer, integer, and integer, and returns 1 output parameter of type logical. The function should be used with the imperative tone.", "input": "", "output": "function strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)\n\ncharacter(len=*),intent(in)  :: source_string\ncharacter(len=*),intent(in)  :: delimiters\ninteger,intent(inout)        :: itoken\nlogical                      :: strtok_status\ninteger,intent(out)          :: token_start\ninteger,intent(inout)        :: token_end\ninteger,save                 :: isource_len\n   if(itoken.le.0)then\n      token_start=1\n   else\n      token_start=token_end+1\n   endif\n   isource_len=len(source_string)\n   if(token_start.gt.isource_len)then\n      token_end=isource_len\n      strtok_status=.false.\n      return\n   endif\n   do while (token_start .le. isource_len)\n      if(index(delimiters,source_string(token_start:token_start)) .ne. 0) then\n         token_start = token_start + 1\n      else\n         exit\n      endif\n   enddo\n   token_end=token_start\n   do while (token_end .le. isource_len-1)\n      if(index(delimiters,source_string(token_end+1:token_end+1)) .ne. 0) then\n         exit\n      endif\n      token_end = token_end + 1\n   enddo\n   if (token_start .gt. isource_len) then\n      strtok_status=.false.\n   else\n      itoken=itoken+1\n      strtok_status=.true.\n   endif\nend function strtok\n"}
{"instruction": "Write a Fortran pure function named upper that converts the characters in a given string to uppercase. The function takes 3 input parameters: a character array, and two optional integers denoting the starting and ending positions for the conversion. The output parameter is a character array of the same length as the input. If the starting and ending positions are not provided, the entire string will be converted to uppercase.", "input": "", "output": "elemental pure function upper(str,begin,end) result (string)\n\ncharacter(*), intent(in)      :: str\ninteger, intent(in), optional :: begin,end\ncharacter(len(str))           :: string\ninteger                       :: i\ninteger                       :: ibegin,iend\ninteger,parameter             :: diff = iachar('a')-iachar('a')\n   string = str\n   ibegin=1\n   iend=len_trim(str)\n\n   if (present(begin))then\n      ibegin = min(max(ibegin,begin),iend)\n   endif\n\n   if (present(end))then\n      iend= max(1,min(iend,end))\n   endif\n\n   do concurrent (i = ibegin:iend)\n       select case (str(i:i))\n       case ('a':'z')\n          string(i:i) = char(iachar(str(i:i))+diff)\n       end select\n   enddo\n\nend function upper\n"}
{"instruction": "Create a Fortran function named tobase to convert a given integer number to a string representation in a specified base. The function takes 2 input parameters of type integer. The first parameter is the base to which the number will be converted, and the second parameter is the number to be converted. The output is a character string of variable length. Use imperative tone when creating the instruction.", "input": "", "output": "function tobase(base, number)\n\ncharacter(len=36),parameter  :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\"\ninteger,intent(in)           :: base\ninteger,intent(in)           :: number\ncharacter(len=:),allocatable :: tobase\ncharacter(len=31)            :: holdit\ninteger                      :: number_local, i, rem\n   number_local=number\n\n   holdit = \"                               \"\n   do i = 31, 1, -1\n      if(number_local < base) then\n         holdit(i:i) = alphanum(number_local+1:number_local+1)\n         exit\n      endif\n      rem = mod(number_local, base)\n      holdit(i:i) = alphanum(rem+1:rem+1)\n      number_local = number_local / base\n   enddo\n   tobase = adjustl(holdit)\nend function tobase\n"}
{"instruction": "Create a Fortran function named isupper that takes a single input parameter of type character and returns a logical value. The function checks whether the input character is an uppercase letter and returns true if it is, otherwise it returns false.", "input": "", "output": "pure elemental function isupper(ch) result(res)\n\n! ident_26=\"@(#)m_strings::isupper(3f): returns true if character is an uppercase letter (a-z)\"\n\ncharacter,intent(in) :: ch\nlogical              :: res\n   select case(ch)\n   case('a':'z')\n     res=.true.\n   case default\n     res=.false.\n   end select\nend function isupper\n"}
{"instruction": "Create a Fortran function named upper that converts a specified range of characters in a given string to uppercase. The function takes 3 input parameters: a character string, an optional integer representing the beginning index, and an optional integer representing the ending index. It returns a single output parameter of type character(len(str)), which contains the modified string. Remember to include the necessary error handling for the optional parameters.", "input": "", "output": "elemental pure function upper(str,begin,end) result (string)\n\n! ident_27=\"@(#)m_strings::upper(3f): changes a string to uppercase\"\n\ncharacter(*), intent(in)      :: str                 ! inpout string to convert to all uppercase\ninteger, intent(in), optional :: begin,end\ncharacter(len(str))           :: string              ! output string that contains no miniscule letters\ninteger                       :: i                   ! loop counter\ninteger                       :: ibegin,iend\n   string = str                                      ! initialize output string to input string\n\n   ibegin = 1\n   if (present(begin))then\n      ibegin = max(ibegin,begin)\n   endif\n\n   iend = len_trim(str)\n   if (present(end))then\n      iend= min(iend,end)\n   endif\n\n   do i = ibegin, iend                               ! step thru each letter in the string in specified range\n       select case (str(i:i))\n       case ('a':'z')                                ! located miniscule letter\n          string(i:i) = char(iachar(str(i:i))-32)    ! change miniscule letter to uppercase\n       end select\n   end do\n\nend function upper\n"}
{"instruction": "Create a Fortran function named wkjday that takes an integer representing a date in Julian day format and returns an integer representing the day of the week. The number of input parameters is 1 with the test_data type ['integer'], and the number of output parameters is 1 with the test_data type ['integer'].", "input": "", "output": "function wkjday(jday)\n!\nimplicit none\n!\n\n!\ninteger :: jday\ninteger :: wkjday\n!\n!     + + + purpose + + +\n!     given a date in julian day format\n!     wkjday will give the day of the week.\n!     0 = monday\n!     1 = tuesday\n!     2 = wednesday\n!     3 = thursday\n!     4 = friday\n!     5 = saturday\n!     6 = sunday\n!\n!     + + + keywords + + +\n!     date, utility\n!\n!     + + + argument declarations + + +\n!\n!     + + + argument definitions + + +\n!     jday   - julian day\n!\n!     + + + end specifications + + +\n!\n!     we simply take the julian day and do a modulo of the value\n!\nwkjday = mod(jday,7)\n!\nend function wkjday\n"}
{"instruction": "Create a Fortran function named fahren to convert the temperature from Celsius to Fahrenheit. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  function fahren (t)\n\n    ! converts from celsius to fahrenheit\n\n    implicit none\n\n    real, intent(in)          :: t\n    real                      :: fahren\n\n    fahren = (1.8 * t) + 32.\n  end function fahren\n"}
{"instruction": "Create a Fortran function named kronckerdelta that computes the Kronecker delta. This function takes 2 integer input parameters and returns 1 real(8) output parameter. The input parameters have a test_data type of ['integer', 'integer'], and the output parameter has a test_data type of ['real(8)'].", "input": "", "output": "      function kronckerdelta (idm1,idm2) result(res)\n      ! returns the kronecker delta\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in) :: idm1, idm2\n         real(8)             :: res\n      \n         !### var ###!\n         \n         !### code ###!\n         if (idm1 == idm2) then\n            res = 1.0d0\n         else\n            res = 0.0d0\n         endif\n      \n      end function\n"}
{"instruction": "Create a Fortran function named equalepsilon that compares two real numbers with a given epsilon value to determine if they are approximately equal. The function takes 3 input parameters of type real: number1, number2, and epsilon. It returns a single logical output parameter indicating whether the two numbers are approximately equal.", "input": "", "output": "  function equalepsilon (number1, number2, epsilon ) result (resultvalue)\n    real , intent (in) :: number1, number2, epsilon \n    logical :: resultvalue \n\n    resultvalue = .false.\n\n    ! test very small number1\n    if ( abs(number1) < epsilon .and.  abs(number1 - number2) < epsilon ) then\n       resultvalue = .true.\n    else \n       if ((abs(( number1 - number2)) / number1) < epsilon ) then\n          resultvalue = .true.\n       else\n          resultvalue = .false.\n       end if\n    end if\n\n  end function equalepsilon\n"}
{"instruction": "Create a Fortran pure function named is_alpha_int that takes a single input argument of type character(len=1) and returns a single output argument of type logical. This function checks whether the input character is an alphabet (either uppercase or lowercase) and returns true if it is, otherwise false.", "input": "", "output": "  pure function is_alpha_int(c) result(res)\n    character(len=1), intent(in) :: c\n    logical :: res\n    associate(ic => iachar(c))\n      res = (ic >= 65 .and. ic <= 90) .or. &\n            (ic >= 97 .and. ic <=122)\n    end associate\n  end function\n"}
{"instruction": "Write a Fortran function named int2str that converts an integer to a string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['(1-sign(1,int_val))/2 )'].", "input": "", "output": "    function int2str( int_val )\n      implicit none\n      integer :: int_val\n      character( int(log10(real(max(abs(int_val),1)))) + 1 + &\n          (1-sign(1,int_val))/2 ) :: int2str\n      character(64) :: all_chars      \n      write(all_chars,*) int_val\n      int2str = trim( adjustl( all_chars ) )\n    end function\n"}
{"instruction": "Create a Fortran function named swap_i4 to swap the bytes of a 4-byte integer. The function takes 1 input argument of type integer(b_sz) and produces 1 output argument of type integer(b_sz).", "input": "", "output": "        function swap_i4(input) result(output)\n            implicit none\n            integer(4), parameter  :: b_sz = 4\n            integer(b_sz), intent(in) :: input \n            integer(b_sz)             :: output \n\n            integer(1) :: byte_arr(b_sz), byte_arr_tmp(b_sz)\n            integer(1) :: i\n\n            byte_arr_tmp =  transfer(input, byte_arr_tmp)\n\n            do i = 1,b_sz\n                byte_arr(i) =  byte_arr_tmp(1 + b_sz - i)\n            enddo\n\n            output =  transfer(byte_arr, output)\n        end function swap_i4 \n"}
{"instruction": "Create a Fortran function named chr_tolower that takes a string as input and converts all the characters to lowercase. The input parameter should be of type character(len=*), and the output parameter should be of type character(len=:), allocatable.", "input": "", "output": "function chr_tolower(thestring) result(retstring)\n  character(len=*), intent(in)  :: thestring\n  character(len=:), allocatable :: retstring\n  character          :: ch\n  integer, parameter :: uloffset = ichar(\"a\") - ichar(\"a\")\n  integer            :: i\n  allocate(character(len(thestring)) :: retstring)\n  do i = 1,len(thestring)\n    ch = thestring(i:i)\n    if(ch >= \"a\" .and. ch <= \"z\") ch = char(ichar(ch)-uloffset)\n    retstring(i:i) = ch\n  end do\nend function chr_tolower\n"}
{"instruction": "Create a Fortran function named r_hyperg that implements algorithm 3.1 from page 52 of the book \"Principles of Random Variate Generation\" by J. Dagpunar. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The input arguments are n, r, and g, and the output argument is x.", "input": "", "output": "function r_hyperg(n, r, g) result(x)\r\n\r\n! this is algorithm 3.1 from page 52 of:\r\n!   dagpunar, john (1988) `principles of random variate generation'\r\n!   published by clarendon press, oxford.   isbn 0-19-852202-9\r\n\r\ninteger, intent(in)  :: n, r, g\r\ninteger              :: x\r\n\r\n! local variables\r\n\r\ninteger  :: gg, i, nn\r\nreal     :: p, u\r\n\r\ngg = g\r\nnn = n\r\ni = 1\r\nx = 0\r\ndo\r\n  if (gg <= 0 .or. i > r) exit\r\n  p = real(gg) / nn\r\n  call random_number(u)\r\n  if (u < p) then\r\n    x = x + 1\r\n    gg = gg - 1\r\n  end if\r\n  i = i + 1\r\n  nn = nn - 1\r\nend do\r\n\r\nreturn\r\nend function r_hyperg\r\n"}
{"instruction": "Create a Fortran function named accumulate that takes two real input parameters and updates the value of the second parameter by adding the first parameter to it. The function returns the updated value of the second parameter. The number of input parameters is 2, and the test_data type is [real, real]. The number of output parameters is 1, and the test_data type is [real].", "input": "", "output": "impure elemental function accumulate( a, partial )\r\n    real, intent(in)    :: a\r\n    real, intent(inout) :: partial\r\n    real                :: accumulate\r\n\r\n    partial    = partial + a\r\n    accumulate = partial\r\nend function accumulate\r\n"}
{"instruction": "Create a Fortran function named rtndt that calculates the total normal stress increment based on the given input parameters. The function takes 5 input parameters of type real: a, cf, fsurf, rtndt0, and phi. It returns 1 output parameter of type real.", "input": "", "output": "  elemental function rtndt(a, cf, fsurf, rtndt0, phi)\n\n    real :: rtndt\n    real, intent(in) :: a, cf, fsurf, rtndt0, phi\n\n    associate( &\n      d_rtepi => -29.5+78.0*(-log(1-phi))**(1/1.73), &\n      f => fsurf*exp(-0.24*a) &\n    )\n      associate(d_rtndt => cf*f**(0.28-0.10*log10(f)))\n        rtndt = rtndt0 + d_rtepi + d_rtndt\n      end associate\n    end associate\n\n  end function rtndt\n"}
{"instruction": "Create a Fortran function named lcase that takes a string input and returns the string in lowercase. The input parameter should be of type character with variable length, and the output parameter should also be of type character with the same length as the input string.", "input": "", "output": "    function lcase(strinput)\r\n!..............................................................................\r\n        ! return the string (strinput) in lowercase\r\n        character(len=*), intent(in) :: strinput\r\n        character(len=len(strinput)):: lcase\r\n        integer:: i\r\n        integer:: n\r\n        character(1):: chr\r\n\r\n        do i=1, len(strinput)\r\n            chr=strinput(i:i)\r\n            n=ichar(chr)\r\n            if (n >=65 .and. n <= 90) then\r\n                lcase(i:i)=char(n+32)\r\n            else\r\n                lcase(i:i)=chr\r\n            end if\r\n        end do\r\n    end function lcase\r\n"}
{"instruction": "Create a Fortran function named day_of_year that takes three integer input parameters (iyear, imonth, iday) and returns a real result of kind=4. The function calculates the day of the year based on the input date and accounts for leap years.", "input": "", "output": "      function day_of_year(iyear,imonth,iday)\n\n      implicit none\n\n      real(kind=4) :: day_of_year\n      integer :: iyear,imonth,iday\n      logical :: isleapyear\n      integer, dimension(12) :: monthdays \n\n      if  ((mod(iyear,4).eq.0)     .and.                          &\n           (mod(iyear,100).ne.0).or.(mod(iyear,400).eq.0))then\n        isleapyear = .true.\n        monthdays = (/31,29,31,30,31,30,31,31,30,31,30,31/)\n      else\n        isleapyear = .false.\n        monthdays = (/31,28,31,30,31,30,31,31,30,31,30,31/)\n      endif\n\n      if(imonth.eq.1)then\n        day_of_year = iday\n      else\n        day_of_year = sum(monthdays(1:imonth-1)) + iday\n      endif\n\n      end function day_of_year\n"}
{"instruction": "Create a Fortran function named quoted that takes a string as input and returns a modified string with double quotation marks escaped. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=len(text))'].", "input": "", "output": "function quoted( text ) result(qtext)\n    character(len=*)         :: text\n    character(len=len(text)) :: qtext\n\n    integer :: pos, first, last, offset, qfirst, qlast\n\n    qtext = text\n    last  = len_trim(text)\n\n    offset = -1\n    first  =  1\n    qfirst =  1\n    qlast  =  last\n    do\n        pos = index( text(first:last), '\"' )\n\n        if ( pos <= 0 ) then\n            exit\n        else\n            pos    = pos    + first - 1\n            offset = offset + 1\n            qfirst = pos    + offset\n            first  = pos    + 1\n            qlast  = qlast  + 1\n            qtext(qfirst:qfirst)  = '\"'\n            qtext(qfirst+1:qlast) = text(pos:)\n        endif\n    enddo\nend function quoted\n"}
{"instruction": "Write a Fortran function named jd to calculate the Julian date from a given calendar date. The function takes 3 input parameters of type integer representing the year, month, and day. The output is a single integer representing the Julian date.", "input": "", "output": "  function jd(yyyy, mm, dd) result(ival)\r\n\r\n    integer, intent(in)  :: yyyy\r\n    integer, intent(in)  :: mm\r\n    integer, intent(in)  :: dd\r\n    integer              :: ival\r\n\r\n    ! date routine jd(yyyy, mm, dd) converts calender date to\r\n    ! julian date.  see cacm 1968 11(10):657, letter to the\r\n    ! editor by henry f. fliegel and thomas c. van flandern.\r\n    ! example jd(1970, 1, 1) = 2440588\r\n\r\n    ival = dd - 32075 + 1461*(yyyy+4800+(mm-14)/12)/4 +  &\r\n       367*(mm-2-((mm-14)/12)*12)/12 - 3*((yyyy+4900+(mm-14)/12)/100)/4\r\n\r\n    return\r\n  end function jd\r\n"}
{"instruction": "Create a Fortran function named p0 that takes two real*8 input parameters and returns a real*8 output. The input parameters should be k and a, and the output parameter should be p. The function computes the value of p based on specific mathematical conditions involving the input parameters.", "input": "", "output": "  function p0(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka, k2, ka2, ka4\n    ka = k*a\n    k2 = k**2\n    ka2 = ka * ka\n    ka4 = ka2 * ka2\n    if (ka < 0.075 ) then\n      if (k > 0.d0) then\n        p = ( -1.d0 / k2) + a*a* (0.5d0 - (ka2/24.d0))\n      else\n        p = - 1.d20\n      end if\n    else\n      p = - cos(ka) / k2\n    end if\n    return\n  end function\n"}
{"instruction": "Create a Fortran function named int2str to convert an integer to a string. The function takes 1 input argument of type integer and returns 1 output argument of type character(:),allocatable.", "input": "", "output": "   function int2str(i) result(res)\n      !-------------------------------------\n      !\n      !  convert an integer(ip) to a string\n      !\n      !-------------------------------------\n       character(:),allocatable :: res\n       integer,intent(in) :: i\n       character(range(i)+2) :: tmp\n       write(tmp,'(i0)') i\n       res = trim(tmp)\n   end function\n"}
{"instruction": "Write a Fortran pure function named spice_id_to_standish_id that takes an integer spice_id as input and returns the corresponding standish_id. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. This function performs a simple search on a predefined array to find the matching standish_id based on the given spice_id. If a match is found, the corresponding standish_id is returned; otherwise, 0 is returned.", "input": "", "output": "    pure function spice_id_to_standish_id(spice_id) result(old_id)\r\n\r\n    implicit none\r\n\r\n    integer,intent(in) :: spice_id !! the id code used by spice\r\n    integer            :: old_id   !! the id code used by this module\r\n\r\n    integer :: i !! counter\r\n\r\n    !>\r\n    !  the index of this array is the id code. the value is the naif code.\r\n    !  see: [naif integer id codes](http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/fortran/req/naif_ids.html)\r\n    integer,parameter,dimension(9) :: new_ids = &\r\n        [   199,&  ! mercury\r\n            299,&  ! venus\r\n            3,  &  ! earth-moon barycenter\r\n            499,&  ! mars\r\n            599,&  ! jupiter\r\n            699,&  ! saturn\r\n            799,&  ! uranus\r\n            899,&  ! neptune\r\n            999]   ! pluto\r\n\r\n    !just a simple search of the list:\r\n    ! [small enough that bisection search probably not worth it]\r\n    do i=1,size(new_ids)\r\n        if (new_ids(i)==spice_id) then\r\n            old_id = i\r\n            return\r\n        end if\r\n    end do\r\n\r\n    !not found:\r\n    old_id = 0\r\n\r\n    end function spice_id_to_standish_id\r\n"}
{"instruction": "Create a Fortran function named calc_weight to calculate the weight based on the input data and positions. The function takes 4 input parameters of type real, array, two integers, and a real number. The output is a real number.", "input": "", "output": "    function calc_weight(indata, bestpos, nextpos, match) result(weight)\n        implicit none\n        real :: weight\n        real, dimension(:), intent(in) :: indata\n        integer, intent(in) :: bestpos\n        integer, intent(inout) :: nextpos\n        real, intent(in) :: match\n\n        integer :: n\n\n        n=size(indata)\n\n        if (match<indata(1)) then\n            nextpos=1\n            weight=1\n        else\n            if (bestpos==n) then\n                nextpos=n\n                weight=1\n            else\n                nextpos=bestpos+1\n                weight=(indata(nextpos)-match) / (indata(nextpos) - indata(bestpos))\n            endif\n        endif\n\n    end function\n"}
{"instruction": "Create a Fortran function named file_exists that checks whether a file exists. The function takes 1 input argument with a test_data type of ['character(len=*)'] and returns 1 output argument with a test_data type of ['logical'].", "input": "", "output": "        function file_exists(file) result(exists)\n\n        !! returns true if the file exists\n\n        implicit none\n        character(len=*),intent(in) :: file\n        logical :: exists\n\n        integer :: istat\n\n        inquire(file=file,exist=exists,iostat=istat)\n\n        exists = exists .and. istat==0 ! just in case?\n\n        end function file_exists\n"}
{"instruction": "Write a Fortran function named cumprod_int that calculates the cumulative product of an integer array. The function takes 2 input parameters: an array of integers and an optional seed value that defaults to 1. The output is an array of integers with the same size as the input array.", "input": "", "output": "  recursive function cumprod_int(arr,seed) result(ans)\n  \n    implicit none\n    integer, dimension(:), intent(in) :: arr\n    integer, optional, intent(in) :: seed\n    integer, dimension(size(arr)) :: ans\n\n    integer, parameter :: npar_cumprod = 8\n    integer :: n, j\n    integer :: sd\n\n    !----------------------------------------------------------------------\n\n    n = size(arr)\n    if (n == 0) return\n      sd = 1\n    if (present(seed)) sd = seed\n    ans(1) = arr(1) * sd\n    if (n < npar_cumprod) then\n      do j=2,n ; ans(j) = ans(j-1) * arr(j) ; end do\n    else\n      ans(2:n:2) = cumprod_int(arr(2:n:2)*arr(1:n-1:2),sd)\n      ans(3:n:2) = ans(2:n-1:2) * arr(3:n:2)\n    end if\n\n    !----------------------------------------------------------------------\n\n  end function cumprod_int\n"}
{"instruction": "Create a Fortran function named strreplace_0_0 that takes three input parameters of type character(*). This function returns one output parameter of type character(len(s)+100). The function aims to replace all occurrences of a specified text within a given string with a replacement string and returns the modified string. Use an imperative tone to define the function.", "input": "", "output": "  function strreplace_0_0 (s,text,repl)\n\n    implicit none\n\n    character(*) :: s, text, repl\n    character(len(s)+100) :: strreplace_0_0 ! make sure it is long enough\n    integer :: i, nt, nr\n\n    !----------------------------------------------------------------------\n\n    strreplace_0_0 = s\n    nt = len_trim(text)\n    nr = len_trim(repl)\n    do\n      i = index(strreplace_0_0,text(:nt))\n      if (i == 0) exit\n      strreplace_0_0 = strreplace_0_0(:i-1) // repl(:nr) // strreplace_0_0(i+nt:)\n    end do\n\n    !----------------------------------------------------------------------\n\n  end function strreplace_0_0\n"}
{"instruction": "Create a Fortran function named ceiling_pow2 to find the smallest power of 2 that is greater than or equal to the input integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function ceiling_pow2(n)\n    implicit none\n    integer            :: ceiling_pow2\n    integer,intent(in) :: n\n    integer :: k\n\n    k = 1\n    do while(k < n)\n      k = k * 2\n    end do\n    ceiling_pow2 = k\n  end function ceiling_pow2\n"}
{"instruction": "Write a Fortran function named strh2l that takes a single input argument of type character(*) and returns a single output argument of type character(len(input_string)). This function converts the input string to lowercase and assigns the result to the output string. Use the imperative tone in your instructions.", "input": "", "output": "    function strh2l(input_string) result(output_string)\n        ! input / output\n        character(*), intent(in)     :: input_string                            !< input string\n        character(len(input_string)) :: output_string                           !< lowercase version\n        \n        ! local variables\n        integer :: i, n\n        character(*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n        character(*), parameter :: upper_case = 'abcdefghijklmnopqrstuvwxyz'\n        \n        ! copy input string\n        output_string = input_string\n        \n        ! convert case character by character\n        do i = 1, len(output_string)\n          n = index(upper_case, output_string(i:i))\n          if ( n /= 0 ) output_string(i:i) = lower_case(n:n)\n        end do\n    end function strh2l\n"}
{"instruction": "Create a Fortran function named friccion1pto that calculates the friction factor for flow in a pipe using the given inputs. The function takes 3 input parameters of type real, real, and integer. The output is a real value. If the Reynolds number is greater than 2200, it iteratively computes the friction factor using the given equation until a convergence criterion is met. Otherwise, it computes the friction factor using a different formula.", "input": "", "output": "    function friccion1pto(ksd, re,semilla_f)\n        implicit none\n        !variables externas\n        real :: friccion1pto, ksd, semilla_f\n        integer::re\n\n        !variables internas\n        real :: fi, fi_1\n        integer :: i\n\n        !parameters\n        real, parameter :: e = 1e-8\n\n        if (re > 2200) then\n            fi= semilla_f\n            print\"(a10,a15,a18,a18)\", \"fi\",\"x\",\"g(x)\",\"fi_1\"\n\n            do i = 1,15\n\n                fi_1 = (-2 * log10((ksd / (3.7)) + (2.51 / (re * sqrt(fi))))) ** (-2) !ksd es ks/d, por esta razon no esta d en la formula\n\n                print *, fi, 1/sqrt(fi),1/sqrt(fi_1),fi_1\n                if (abs(fi - fi_1)<e) then\n                    exit\n                else\n                    fi = fi_1\n                end if\n            end do\n\n            friccion1pto = fi    \n        else \n            friccion1pto = 64/re\n\n        end if\n    \n    end function friccion1pto\n"}
{"instruction": "Create a Fortran function named counter that returns the current count. The function takes one input argument of type logical, which is optional. The output is an integer. If the input argument is provided and is true, the count is reset to 0. If no input argument is provided or if it's false, the count is incremented by 1, and then returned.", "input": "", "output": "function counter( init )\nlogical,intent(in),optional :: init\ninteger :: counter\n!!--begin--\nif( present(init) )then\n if( init )then\n  counts = 0\n end if\nelse\n counts = counts + 1\nend if\ncounter = counts\n!!--end--\nend function\n"}
{"instruction": "Create a Fortran function named string_eq to compare two strings and return a logical value indicating whether the strings are equal. The function takes 2 input arguments of type character(*) and returns 1 output argument of type logical.", "input": "", "output": "  function string_eq(string1,string2)\n    ! {{{ string comparison\n    logical :: string_eq\n    character(*), intent(in) :: string1, string2\n    integer :: i, j\n    i=index(string1,trim(string2))\n    j=index(string2,trim(string1))\n    if ( ( i > 0 ) .and. ( j > 0 ) ) then\n       string_eq=.true.\n    else\n       string_eq=.false.\n    end if\n    ! }}}\n  end function string_eq\n"}
{"instruction": "Write a Fortran function named formatstr that takes a character string and an integer length as input and returns a new character string of the specified length. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=length)'].", "input": "", "output": "  function formatstr(char, length) result(ret)\n    implicit none\n    character(len=*), intent(in) :: char\n    integer, intent(in)          :: length\n    character(len=length)        :: ret\n\n    ret = char\n\n  end function formatstr\n"}
{"instruction": "Write a Fortran function called \"inter\" to replace a substring within a given string with another substring. The function has 3 input parameters of type character(len=*): string, place, and ins. It also has 1 output parameter of type character(len=len(string)+max(0,len(ins)-len(place))).", "input": "", "output": "  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n"}
{"instruction": "Create a Fortran pure function named sys_upcase to convert a given string to its uppercase version. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(sinput)).", "input": "", "output": "  pure function sys_upcase(sinput) result(soutput)\n\n!<description>\n    ! this routine converts a given string to its uppercase version.\n!</description>\n\n!<input>\n\n    ! input string\n    character(len=*), intent(in) :: sinput\n\n!</input>\n\n!<output>\n\n    ! output string\n    character(len=len(sinput)) :: soutput\n\n!</output>\n\n\n    ! index variable\n    integer :: i\n\n    soutput = \" \"   ! initialise string\n    do i = 1,len(sinput)\n      if(sinput(i:i) .ge. \"a\" .and. sinput(i:i) .le. \"z\") then\n        soutput(i:i) = achar(iachar(sinput(i:i)) - 32)\n      else\n        soutput(i:i) = sinput(i:i)\n      end if\n    end do\n\n  end function sys_upcase\n"}
{"instruction": "Create a Fortran function named sys_charreplace. This function takes three input parameters of type character(len=*), character, and character, and one output parameter of type character(len=len(sinput)). The function replaces all occurrences of a specified character in the input string with another specified character, and the result is returned as the output string.", "input": "", "output": "  pure function sys_charreplace(sinput,scharsource,schardest) result(soutput)\n\n!<description>\n    ! replaces all characers scharsource in sinput by schardest.\n    ! case sensitive.\n!</description>\n\n!<input>\n    ! input string\n    character(len=*), intent(in) :: sinput\n\n    ! character to be searched for.\n    character, intent(in) :: scharsource\n\n    ! detinatiion character, all scarsource characters in sinput should be\n    ! replaced by.\n    character, intent(in) :: schardest\n!</input>\n\n!<output>\n    ! output string\n    character(len=len(sinput)) :: soutput\n!</output>\n\n\n    !index variable\n    integer :: i\n\n    soutput = \" \"   !initialise string\n    do i = 1,len(sinput)\n      if(sinput(i:i) .eq. scharsource) then\n        soutput(i:i) = schardest\n      else\n        soutput(i:i) = sinput(i:i)\n      end if\n    end do\n\n  end function sys_charreplace\n"}
{"instruction": "Please write a Fortran function named \"g\" to compute the right-hand side of the Poisson equation for given input coordinates x and y. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision']. The function should compute the value of -2 * (2 * pi)^2 * sin(2 * pi * x) * sin(2 * pi * y) and assign it to the variable g.", "input": "", "output": "function g(x,y)\n\n  ! the rhs of the poisson equation we are solving\n\n  implicit none\n\n  double precision :: g, x, y\n  double precision, parameter :: pi = 3.14159265358979323846d0\n\n  g = -2.d0*(2.0*pi)**2 * sin(2.0*pi*x) * sin(2.0*pi*y)\n\n  return\nend function g\n"}
{"instruction": "Create a Fortran function named swap_string that takes a single character string as input and returns a new string with the characters reversed. The input parameter has a data type of 'character(len=*)', and the output parameter has a data type of 'character(len=len(string))'.", "input": "", "output": "function swap_string(string)\r\nimplicit none\r\ncharacter(len=*), intent(in) :: string\r\ncharacter(len=len(string)) :: swap_string\r\ninteger :: length, i\r\nlength = len(string)\r\ndo i = 1, length\r\n    swap_string(length-i+1:length-i+1) = string(i:i)\r\nend do\r\nend function\r\n"}
{"instruction": "Create a Fortran recursive function named film_find to find the root of a given integer with path compression. The function takes 2 input arguments of type integer, dimension(:) and integer. The output is a single integer. When calling the film_find function, it will return the root of the input integer with path compression.", "input": "", "output": "      recursive function film_find(a_parent,a_x) result(a_y)\n         implicit none\n         integer, dimension(:) :: a_parent\n         integer :: a_x\n         integer :: a_y\n         \n         a_y = a_x\n         ! find root of x with path compression\n         if ( a_y.ne.a_parent(a_y) ) then\n            a_parent(a_y) = film_find(a_parent,a_parent(a_y))\n            a_y = a_parent(a_y)\n         end if\n         return\n      end function film_find\n"}
{"instruction": "Create a Fortran function named datetime2string that takes 7 input arguments of type integer and optional integer, and 1 output argument of type character(len=20). The function generates a date-time string in the format \"yyyy-mm-ddThh:mm:ssz\" based on the input year, month, day, and optional hour, minute, and second values. If an error occurs during the formatting, the ierr output argument will be set to a non-zero value.", "input": "", "output": "      function datetime2string(iyear, imonth, iday, ihour, imin, isec, ierr) result(datetimestr)\n         integer,           intent(in)  :: iyear, imonth, iday\n         integer, optional, intent(in)  :: ihour, imin, isec !< time is optional, will be printed as 00:00:00 if omitted.\n         integer, optional, intent(out) :: ierr !< error status, 0 if success, nonzero in case of format error.\n\n         character(len=20) :: datetimestr !< the resulting date time string. considering using trim() on it.\n\n         integer :: ihour_, imin_, isec_, ierr_\n         if (.not. present(ihour)) then\n            ihour_ = 0\n         else\n            ihour_ = ihour\n         end if\n         if (.not. present(imin)) then\n            imin_ = 0\n         else\n            imin_ = imin\n         end if\n         if (.not. present(isec)) then\n            isec_ = 0\n         else\n            isec_ = isec\n         end if\n\n         write (datetimestr, '(i4,\"-\",i2.2,\"-\",i2.2,\"t\",i2.2,\":\",i2.2,\":\",i2.2,\"z\")', iostat=ierr_) &\n                               iyear, imonth, iday, ihour_, imin_, isec_\n\n         if (present(ierr)) then\n            ierr = ierr_\n         end if\n      end function datetime2string\n"}
{"instruction": "Create a Fortran function named line_replace to replace occurrences of a specified pattern within a given string. The function takes 4 input parameters of types character(len=*), character(len=*), character(len=*), and integer (optional). The output is a character string of length equal to the input string. If the optional integer parameter is provided, the replacement is performed a specific number of times, otherwise, it replaces all occurrences. Use an imperative tone to convey these instructions to the user.", "input": "", "output": "pure function line_replace(a,pattern1,pattern2,ntimes) result(t)\n! ... takes pattern1 in a and replaces it by pattern2. does it ntimes\n! ... if ntimes < 0 it does it for all appearences\n\ncharacter(len=*), intent(in)   :: a\ncharacter(len=*), intent(in)   :: pattern1\ncharacter(len=*), intent(in)   :: pattern2\ninteger, intent(in), optional  :: ntimes\ncharacter(len=len(a))          :: t\n\n! ... local variables\n! ...\ninteger j,n,n1,n2,nc,ncm\n\nn = len_trim(a)\nn1 = len(pattern1)\nn2 = len(pattern2)\nif (.not.present(ntimes)) then\n  ncm = -1\nelse\n  ncm = ntimes\nendif\n\nif (n.eq.0) return\nif (n1.eq.0) return\n\nt = a\nnc = 0\n10  j = index (t(:n),pattern1)\n    nc = nc + 1\n    if (j.gt.0) then\n      t(j+n2:) = t(j+n1:n)\n      t(j:j+n2-1) = pattern2(:n2)\n      n = len_trim(t)\n      if ((ncm.lt.0).or.(nc.lt.ncm)) goto 10\n    endif\n\nend function line_replace\n"}
{"instruction": "Create a Fortran pure function named lowercase to convert a given string to lowercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(a)).", "input": "", "output": "pure function lowercase(a) result(t)\n! ... returns string in lowercase\n\ncharacter(len=*), intent(in)   :: a\ncharacter(len=len(a))          :: t\n\n! ... local variables\n! ...\ninteger i,nal,nau,nzl,ii,l\n\nt   = a\nnal = ichar('a')\nnau = ichar('a')\nnzl = ichar('z')\nl   = nau - nal\n\ndo i=1,len(a)\n  ii = ichar(a(i:i))\n  if ((ii.ge.nal).and.(ii.le.nzl)) then\n    ii = ii + l\n    t(i:i) = char(ii)\n  endif\nenddo            \n\nreturn\nend function lowercase\n"}
{"instruction": "Write a Fortran function named stalinsort that takes an allocatable array of real numbers as input and returns a sorted array with the same type and dimensions as output.", "input": "", "output": "    function stalinsort(a)\n        real, allocatable, dimension(:), intent(in) :: a\n        real, allocatable, dimension(:) :: tmp, stalinsort\n        integer :: j, n\n        n = size(a)\n        allocate(tmp(n))\n\n        j = 1\n        do i = 1, n\n            if ((i .eq. 1) .or. (a(i) .gt. a(i - 1))) then\n                tmp(j) = a(i)\n                j = j + 1\n            end if\n        end do\n\n        allocate(stalinsort(j - 1))\n        stalinsort = tmp(:j - 1)\n    end function stalinsort\n"}
{"instruction": "Write a Fortran function named replace_text to replace all occurrences of a specified substring with another substring within a given input string. The function takes 3 input parameters of type character(len=*), namely inputstr, search, and replace. It returns 1 output parameter of type character(len(inputstr)+100).", "input": "", "output": "function replace_text (inputstr,search,replace) result(outputstr)\n\nimplicit none\ncharacter(len=*), intent(in) :: inputstr\ncharacter(len=*), intent(in) :: search\ncharacter(len=*), intent(in) :: replace\ncharacter(len(inputstr)+100) :: outputstr\n\n! locals\ninteger :: i, nt, nr\n\noutputstr = inputstr\nnt = len_trim(search)\nnr = len_trim(replace)\n\ndo\n  i = index(outputstr,search(:nt)) ; if (i == 0) exit\n  outputstr = outputstr(:i-1) // replace(:nr) // outputstr(i+nt:)\nend do\n\nend function replace_text\n"}
{"instruction": "Write a Fortran function named s3m_tools_time_jd to convert a calendar date to a Julian date. The function takes 3 input arguments of type integer representing the year, month, and day. The output is an integer representing the Julian date.", "input": "", "output": "    function s3m_tools_time_jd(yyyy, mm, dd) result (julian)\n\n        ! converts calendar date to julian date\n        ! cf fliegel & van flandern, cacm 11(10):657, 1968\n        ! example: julian_date(1970,1,1) = 2440588\n        integer, intent(in) :: yyyy,mm,dd\n        integer :: julian\n        \n        julian = dd-32075+1461*(yyyy+4800+(mm-14)/12)/4 + &\n        367*(mm-2-((mm-14)/12)*12)/12- &\n        3*((yyyy + 4900 + (mm - 14)/12)/100)/4\n        \n    end function s3m_tools_time_jd\n"}
{"instruction": "Create a Fortran function named \"ipmpar\" to provide the integer machine constants for the computer used. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "function ipmpar (i) result(fn_val)\n!-----------------------------------------------------------------------\n\n!     ipmpar provides the integer machine constants for the computer\n!     that is used. it is assumed that the argument i is an integer\n!     having one of the values 1-10. ipmpar(i) has the value ...\n\n!  integers.\n\n!     assume integers are represented in the n-digit, base-a form\n\n!               sign ( x(n-1)*a**(n-1) + ... + x(1)*a + x(0) )\n\n!               where 0 .le. x(i) .lt. a for i=0,...,n-1.\n\n!     ipmpar(1) = a, the base (radix).\n\n!     ipmpar(2) = n, the number of base-a digits (digits).\n\n!     ipmpar(3) = a**n - 1, the largest magnitude (huge).\n\n!  floating-point numbers.\n\n!     it is assumed that the single and double precision floating\n!     point arithmetics have the same base, say b, and that the\n!     nonzero numbers are represented in the form\n\n!               sign (b**e) * (x(1)/b + ... + x(m)/b**m)\n\n!               where x(i) = 0,1,...,b-1 for i=1,...,m,\n!               x(1) .ge. 1, and emin .le. e .le. emax.\n\n!     ipmpar(4) = b, the base.\n\n!  single-precision\n\n!     ipmpar(5) = m, the number of base-b digits.\n\n!     ipmpar(6) = emin, the smallest exponent e.\n\n!     ipmpar(7) = emax, the largest exponent e.\n\n!  double-precision\n\n!     ipmpar(8) = m, the number of base-b digits.\n\n!     ipmpar(9) = emin, the smallest exponent e.\n\n!     ipmpar(10) = emax, the largest exponent e.\n\n!-----------------------------------------------------------------------\n\nimplicit none\ninteger, intent(in) :: i\ninteger             :: fn_val\n\nselect case(i)\n  case( 1)\n    fn_val = radix(i)\n  case( 2)\n    fn_val = digits(i)\n  case( 3)\n    fn_val = huge(i)\n  case( 4)\n    fn_val = radix(1.0)\n  case( 5)\n    fn_val = digits(1.0)\n  case( 6)\n    fn_val = minexponent(1.0)\n  case( 7)\n    fn_val = maxexponent(1.0)\n  case( 8)\n    fn_val = digits(1.0d0)\n  case( 9)\n    fn_val = minexponent(1.0d0)\n  case(10)\n    fn_val = maxexponent(1.0d0)\n  case default\n    return\nend select\n\nreturn\nend function ipmpar\n"}
{"instruction": "Write a Fortran function named slice_char that takes in a string and optional integer parameters for first index, last index, and stride. The function returns a sliced string based on the provided indices and stride. The input parameters are of type character(len=*), integer (optional), integer (optional), and integer (optional), and the output parameter is of type character(len=:), allocatable.", "input": "", "output": "    pure function slice_char(string, first, last, stride) result(sliced_string)\n        character(len=*), intent(in) :: string\n        integer, intent(in), optional :: first, last, stride\n        integer :: first_index, last_index, stride_vector, strides_taken, length_string, i, j\n        character(len=:), allocatable :: sliced_string\n        length_string = len(string)\n\n        first_index = 0                 ! first_index = -infinity\n        last_index = length_string + 1  ! last_index = +infinity\n        stride_vector = 1\n\n        if (present(stride)) then\n            if (stride /= 0) then\n                if (stride < 0) then\n                    first_index = length_string + 1     ! first_index = +infinity\n                    last_index = 0                      ! last_index = -infinity\n                end if\n                stride_vector = stride\n            end if\n        else\n            if (present(first) .and. present(last)) then\n                if (last < first) then\n                    stride_vector = -1\n                end if\n            end if\n        end if\n\n        if (present(first)) then\n            first_index = first\n        end if\n        if (present(last)) then\n            last_index = last\n        end if\n        \n        if (stride_vector > 0) then\n            first_index = max(first_index, 1)\n            last_index = min(last_index, length_string)\n        else\n            first_index = min(first_index, length_string)\n            last_index = max(last_index, 1)\n        end if\n        \n        strides_taken = floor( real(last_index - first_index)/real(stride_vector) )\n        allocate(character(len=max(0, strides_taken + 1)) :: sliced_string)\n        \n        j = 1\n        do i = first_index, last_index, stride_vector\n            sliced_string(j:j) = string(i:i)\n            j = j + 1\n        end do\n    end function slice_char\n"}
{"instruction": "Provide a Fortran function named lower_case that takes a string as input and converts all the characters to lowercase. The function has 1 input parameter of type character(len=*) and 1 output parameter of type character(len=len(string)).", "input": "", "output": "function lower_case(string) result(new)\r\n! adapted from code by arjen markus at\r\n! https://groups.google.com/g/comp.lang.fortran/c/ckx1l2ahkxg\r\ncharacter(len=*), intent(in) :: string\r\ncharacter(len=len(string))   :: new\r\ninteger                      :: i,k\r\ninteger, parameter           :: diff = iachar(\"a\") - iachar(\"a\")\r\nnew = string\r\ndo i=1,len(string)\r\n   k = iachar(string(i:i))\r\n   if (k >= iachar(\"a\") .and. k <= iachar(\"z\")) then\r\n      k = k + diff\r\n      new(i:i) = achar(k) ! set the i'th character of new\r\n   end if\r\nend do\r\nend function lower_case\r\n"}
{"instruction": "Write a Fortran function named f that calculates the value of the mathematical function sin(x) - cos(x). The function takes 1 input parameter of type real, and returns 1 output parameter of type real.", "input": "", "output": "function f(x) !funci\u00f3n que genera los puntos\n  implicit none\n  real::f, x\n  f=sin(x)-cos(x)\nend function f\n"}
{"instruction": "Create a Fortran function named norm_rand to generate a random number following a normal distribution with a given mean and standard deviation. The function takes 2 input arguments of type real: mean and std_dev. It returns 1 output argument of type real.", "input": "", "output": "\tfunction norm_rand(mean, std_dev)\n\t\treal :: norm_rand\n\t\treal, intent(in) :: mean, std_dev\n\t\treal :: x, y, r\n\t\treal, save :: spare\n\t\tlogical, save :: has_spare\n\t\t! use a spare saved from a previous run if one exists\n\t\tif (has_spare) then\n\t\t\thas_spare = .false.\n\t\t\tnorm_rand = mean + (std_dev * spare)\n\t\t\treturn\n\t\telse\n\t\t\tr = 1.0\n\t\t\tdo while ( r >= 1.0 )\n\t\t\t\t! generate random number pair between 0 and 1\n\t\t\t\tcall random_number(x)\n\t\t\t\tcall random_number(y)\n\t\t\t\t! normalise random numbers to be in square of side-length = r\n\t\t\t\tx = (x * 2.0) - 1.0\n\t\t\t\ty = (y * 2.0) - 1.0\n\t\t\t\tr = x*x + y*y\n\t\t\tend do\n\n\t\t\t! calculate the co-efficient to multiply random numbers x and y\n\t\t\t! by to achieve normal distribution\n\t\t\tr = sqrt((-2.0 * log(r)) / r)\n\n\t\t\tnorm_rand = mean + (std_dev * x * r)\n\t\t\tspare = y * r\n\t\t\thas_spare = .true.\n\t\t\treturn\n\t\tend if\n\tend function norm_rand\t\n"}
{"instruction": "Create a Fortran function named f_clean to clean and modify a given string. The function should take 1 input argument with the test_data type of ['character(len=*)'] and return 1 output argument with the test_data type of ['character(len=len(func))'].", "input": "", "output": "  function f_clean(func) result(tmpfunc)\n    character(len=*), intent(in) :: func\n    character(len=len(func)) :: tmpfunc\n    integer :: i, c, l\n    \n    tmpfunc = adjustl(func)\n    l = len_trim(tmpfunc)\n    i = 1\n\n    do while (i <= l)\n       if (tmpfunc(i:i)== ' ') then\n          tmpfunc(i:) = tmpfunc(i+1:)\n          l = l - 1\n       else\n          c = ichar(tmpfunc(i:i))\n          if ((c <= ichar('z')) .and. (c >= ichar('a'))) tmpfunc(i:i) = achar(c-ichar('a')+ichar('a'))\n          i = i + 1\n       end if\n    end do\n  end function f_clean\n"}
{"instruction": "Create a Fortran function named alog1 that takes 2 input parameters of type real and logical, and returns 1 output parameter of type real. The function computes the logarithm of (1 + x) if the second input parameter is true, else it computes the logarithm of (1 + x) - x. Use an iterative process to calculate the result, and the final value is stored in the variable fn_val.", "input": "", "output": "function alog1(x, first) result(fn_val)\r\n\r\n!     if first then return ln(1 + x) else ln(1 + x) - x.\r\n\r\nimplicit none\r\nreal, intent(in)     :: x\r\nlogical, intent(in)  :: first\r\nreal                 :: fn_val\r\n\r\nreal    :: s, s1, term, y, ak\r\nreal, parameter  :: pt1 = 0.1, one = 1.0, two = 2.0, three = 3.0\r\n\r\nif (.not.(abs(x) > pt1)) go to 20\r\nif (.not.(first)) go to 10\r\nfn_val = log(one + x)\r\ngo to 70\r\n\r\n10 fn_val = log(one + x) - x\r\ngo to 70\r\n\r\n20 y = x/(two + x)\r\nterm = two*y**3\r\nak = three\r\nif (.not.(first)) go to 30\r\ns = two\r\ngo to 40\r\n\r\n30 s = -x\r\n40 s = s*y\r\ny = y**2\r\ns1 = s + term/ak\r\n\r\n50 if (.not.(s1 /= s)) go to 60\r\nak = ak + two\r\nterm = term*y\r\ns = s1\r\ns1 = s + term/ak\r\ngo to 50\r\n\r\n60 fn_val = s\r\n70 return\r\nend function alog1\r\n"}
{"instruction": "Provide a Fortran function named fullname to construct a full file name, including path, from a partial file name. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=:),allocatable.", "input": "", "output": "function fullname( name )\n!\n!     constructs a full name, including path, from the partial\n!     file name.\n!\n!     uses getenv, getcwd\n!\n!     does not remove (probably) redundant slashes\n!\nimplicit none\ncharacter(len=*),intent(in)  :: name\ncharacter(len=4096)          :: fname, prefix\ncharacter(len=:),allocatable :: fullname\ninteger                      :: i\ninteger                      :: len\n!\n      fname = ' '\n      fullname=''\n      prefix   = ' '\n      if (name(1:1) .eq. '/') then\n        fname = name\n      elseif (name(1:2) .eq. '~/') then\n        call getenv( 'home', prefix )\n        fname = prefix( :len_trim(prefix) ) // name( 2:len_trim(name) )\n      elseif (name(1:1) .eq. '$') then\n        len = len_trim(name)\n        do i = 2, len\n          if (name(i:i) .eq. '/') then\n            call getenv( name(2:i-1), prefix )\n            fname = prefix( :len_trim(prefix) ) // name( i:len_trim(name) )\n            fullname=trim(fname)\n            return\n          endif\n        enddo\n        call getenv( name(2:len), fname )\n      elseif (name(1:2) .eq. './') then\n        call getcwd( prefix )\n        fname = prefix( :len_trim(prefix) ) // '/' //  name(3:len_trim(name) )\n      elseif (name(1:3) .eq. '../') then\n        call getcwd( prefix )\n        len = len_trim(prefix)\n        do i = 1, len_trim(prefix)\n          if (prefix(i:i) .eq. '/') len = i - 1\n        enddo\n        fname = prefix( :len ) // '/' //  name(4:len_trim(name) )\n      else\n        call getcwd( prefix )\n        fname = prefix(:len_trim(prefix) ) // '/' //  name(:len_trim(name) )\n      endif\n      fullname=trim(fname)\nend function fullname\n"}
{"instruction": "Create a Fortran function named fun_calc_ion that calculates the ionic strength based on the input chloride concentration. The function should take 1 input argument of type real and return 1 output argument of type real. If the input chloride concentration is greater than a small constant, the function should calculate the ionic strength using a specified formula. Otherwise, it should return the small constant.", "input": "", "output": "  function fun_calc_ion(dum_cl)\n    ! result variable\n    real::fun_calc_ion\n    ! dummy arguments\n    real,intent(in)::dum_cl\n    ! the ionic strength calculated after zeebe and wolf-gladrow [2001]\n    if (dum_cl > const_real_nullsmall) then\n       fun_calc_ion = 0.00147 + 0.03592*dum_cl + 0.000068*dum_cl*dum_cl\n    else\n       fun_calc_ion = const_real_nullsmall\n    end if\n  end function fun_calc_ion\n"}
{"instruction": "Write a Fortran function named popfirststringtoken that extracts the first string token from a given character string and returns it. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len = len(line)).", "input": "", "output": " function popfirststringtoken(line) result(firsttoken)\n\n      implicit none\n\n      character(*), intent(inout) :: line\n      character(len = len(line)) :: firsttoken\n\n      integer separatorindex\n\n      separatorindex = 0\n      line = trim(adjustl(line))\n\n      separatorindex = index(line,' ')\n      if (separatorindex.le.1) then\n         firsttoken = ' '\n      else\n         firsttoken = line(1:separatorindex-1)\n         line = line(separatorindex+1:)\n      end if\n\n   end function popfirststringtoken\n"}
{"instruction": "Create a Fortran function named sim_geth_2 to calculate a value based on the given formula. The function takes 2 real input parameters (phi, d) and returns a real output value. Use the formula sim_geth_2 = 0.5 + 0.5*max(-1.0, min(1.0, phi/d + 1.0/pi*sin(pi*phi/d))).", "input": "", "output": "function sim_geth_2(phi, d)\n  implicit none\n  real          :: sim_geth_2\n  real          :: phi\n\treal\t\t\t\t\t:: d\n\treal\t\t\t\t\t:: pi\n\tpi = atan(1.0)*4.0\n\tsim_geth_2 = 0.5 + 0.5*max(-1.0, min(1.0, phi/d + 1.0/pi*sin(pi*phi/d)))\n  return\nend function sim_geth_2\n"}
{"instruction": "Create a Fortran function named sim_getd to calculate the similarity measure \"sim_getd\" based on the input parameters phi0 and phi1, both of type real. The function returns a real value as the similarity measure. If both phi0 and phi1 are non-negative, the similarity measure is set to 1.0. If both phi0 and phi1 are negative, the similarity measure is also set to 1.0.", "input": "", "output": "function sim_getd(phi0, phi1)\n  implicit none\n  real          :: sim_getd\n  real          :: phi0, phi1\n  sim_getd = abs(phi0)/(abs(phi0) + abs(phi1))\n  if( phi0 >= 0 .and. phi1 >= 0 ) then\n    sim_getd = 1.0\n  endif\n  if( phi0 < 0 .and. phi1 < 0 ) then\n    sim_getd = 1.0\n  endif\n  return\nend function sim_getd\n"}
{"instruction": "Create a Fortran function named sim_getupwind to calculate the upwind value based on the input parameters. The function takes 3 input arguments of type real: u, n, and p. It returns a single output argument of type real. If u is greater than 0, the function returns n. If u is less than 0, the function returns p. If none of these conditions are met, the function returns 0.0.", "input": "", "output": "function sim_getupwind(u, n, p)\n  implicit none\n  real          :: sim_getupwind\n  real          :: u\n  real          :: n, p\n  sim_getupwind = 0.0\n  if( u .gt. 0 ) then\n    sim_getupwind = n\n  else if( u .lt. 0 ) then\n    sim_getupwind = p\n  endif\n  return\nend function sim_getupwind\n"}
{"instruction": "Provide a Fortran function named trims that trims any leading or trailing white spaces from a given character string. The number of input arguments is 1, and the test_data type is ['character(*)']. The number of output arguments is 1, and the test_data type is ['character(len_trim(s))'].", "input": "", "output": "    function trims(s) result(t)\n      character(*), intent(in) :: s\n      character(len_trim(s)) :: t\n      intrinsic trim\n      t = trim(s)\n    end function trims\n"}
{"instruction": "Create a Fortran function named is_p1 to determine if a given integer is a multiple of 3 or 5.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "pure function is_p1(n)\n  implicit none\n  integer, intent(in) :: n\n  logical :: is_p1\n  is_p1 = n /= 0 .and. (modulo(n, 3) == 0 .or. modulo(n, 5) == 0)\nend function is_p1\n"}
{"instruction": "Create a Fortran function named getnopt that calculates the unique identifier for a node or calculation point based on the input element number (integer), point number (integer), and point type (integer). Ensure that the function returns the calculated unique identifier as an integer. The input parameters are of type ['integer', 'integer', 'integer'], and the output parameter is of type ['integer'].", "input": "", "output": "  function getnopt (e,k,type )\n    ! description :\n    ! recupere le numero unique identifiant un noeud ou un point de calcul.\n    implicit none\n    ! inputs :\n    ! numero de l'element\n    integer, intent(in)                                     :: e\n    ! numero du point (calcul ou neud)                      \n    integer, intent(in)                                     :: k\n    ! type de point (1 pour noeud, 2 pour gauss)            \n    integer, intent(in)                                     :: type\n    ! output :                                              \n    integer                                                 :: getnopt\n\n    ! calcul du numero du point\n    ! degres de liberte\n    if ( type == 1 ) then\n      getnopt = 6*(e-1) + 3*(k-1) + 1\n      \n    ! pts d'integration\n    else\n      getnopt = 6*(e-1) + k + 1\n      if ( k >= 3 ) getnopt = getnopt + 1\n      \n    end if\n    \n    return\n  end function getnopt\n"}
{"instruction": "Write a Fortran function named multiply_modulo to compute the value of (a*s) mod m. The number of input arguments is 3, and the test_data type is ['integer', 'integer', 'integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "      function multiply_modulo(a,s,m)\n!----------------------------------------------------------------------\n\n!                    returns (a*s) mod m\n!     this is a transcription from pascal to fortran of routine\n!     multmod_decompos from the paper\n!     l'ecuyer, p. and cote, s. \"implementing a random number package\n!     with splitting facilities.\" acm transactions on mathematical\n!     software, 17:98-111 (1991)\n!                              arguments\n!     a, s, m  -->\n!                         integer a,s,m\n!----------------------------------------------------------------------\n! .. implicit none statement ..\n        implicit none\n! ..\n\n        integer :: multiply_modulo\n! ..\n! .. parameters ..\n        integer, parameter :: h = 32768\n! ..\n! .. scalar arguments ..\n        integer, intent (in) :: a, m, s\n! ..\n! .. local scalars ..\n        integer :: a0, a1, k, p, q, qh, rh\n! ..\n! .. executable statements ..\n\n!     h = 2**((b-2)/2) where b = 32 because we are using a 32 bit\n!      machine. on a different machine recompute h\n        if (a<=0 .or. a>=m .or. s<=0 .or. s>=m) then\n          write (*,*) ' a, m, s out of order in mltmod - abort!'\n          write (*,*) ' a = ', a, ' s = ', s, ' m = ', m\n          write (*,*) ' mltmod requires: 0 < a < m; 0 < s < m'\n          stop ' a, m, s out of order in mltmod - abort!'\n        end if\n\n        if (a<h) then\n          a0 = a\n          p = 0\n        else\n\n          a1 = a/h\n          a0 = a - h*a1\n          qh = m/h\n          rh = m - h*qh\n          if (a1>=h) then\n            a1 = a1 - h\n            k = s/qh\n            p = h*(s-k*qh) - k*rh\n            do while (p<0)\n              p = p + m\n            end do\n\n          else\n\n            p = 0\n          end if\n\n!     p = (a2*s*h)mod m\n\n          if (a1/=0) then\n            q = m/a1\n            k = s/q\n            p = p - k*(m-a1*q)\n            if (p>0) p = p - m\n            p = p + a1*(s-k*q)\n            do while (p<0)\n              p = p + m\n            end do\n\n          end if\n          k = p/qh\n\n!     p = ((a2*h + a1)*s)mod m\n\n          p = h*(p-k*qh) - k*rh\n          do while (p<0)\n            p = p + m\n          end do\n\n        end if\n        if (a0/=0) then\n\n!     p = ((a2*h + a1)*h*s)mod m\n\n          q = m/a0\n          k = s/q\n          p = p - k*(m-a0*q)\n          if (p>0) p = p - m\n          p = p + a0*(s-k*q)\n          do while (p<0)\n            p = p + m\n          end do\n\n        end if\n        multiply_modulo = p\n\n        return\n\n      end function multiply_modulo\n"}
{"instruction": "Create a Fortran function named thetaofx2 to compute the value of a function theta based on the input arrays x2 and ror0nu. The input parameters are of type real(kind=8), dimension(:) and real(kind=8), dimension(:), and the output parameter is of type real(kind=8), dimension(size(x2)).", "input": "", "output": "        function thetaofx2(x2, ror0nu) result(res)\n          real(kind=8), intent(in), dimension(:) ::  x2,ror0nu\n!          real(kind=8), dimension(size(x2)) :: res\n          real(kind=8), dimension(size(x2)) :: theta,theta2,theta3,res\n          theta = atan( tan((x2+1)*pi/2.)/ror0nu )\n          theta2 = (pi    + atan( tan((x2-1)*pi/2.)/ror0nu ))\n          theta3 = (pi/2. + atan( tan(x2*pi/2.)*ror0nu ))\n          res = merge(merge(theta,theta2,x2.lt.-0.5),theta3,x2.gt.0.5)\n!          res = theta+theta2+theta3\n        end function thetaofx2\n"}
{"instruction": "Create a Fortran function named fluxp that takes 10 input parameters of type real(8) to calculate flux values. The input parameters are rho, ux, uy, e, p, t, a, b, nx, and ny. The output consists of an array of 4 real(8) values stored in the variable fluxp.", "input": "", "output": "  function fluxp(rho,ux,uy,e,p,t,a,b,nx,ny) \n    \n    implicit none\n\n    real(8), intent(in) :: rho,ux,uy,e,p,t,a,b,nx,ny\n    real(8), dimension(1:4) :: fluxp\n\n    real(8) :: un,ut,f1,f2,f3,f4\n\n    un=nx*ux+ny*uy\n    ut=-ny*ux+nx*uy\n\n    if (un>=b) then\n       \n       f1=rho*un\n       f2=rho*un**2+p\n       f3=ut*f1\n       f4=(e+p)*un\n\n    elseif (un<=-b) then\n\n       f1=0.0d0\n       f2=0.0d0\n       f3=0.0d0\n       f4=0.0d0\n\n    else\n\n       f1=2.0d0*a*b**2*(un+b)**2\n       f2=4.0d0/3.0d0*a*b**2*(un+b)**3\n       f3=ut*f1\n       f4=a*b**2/2.0d0*(un+b)**2*(un**2+2.0d0*un*b+2*ut**2+7.0d0/3.0d0*b**2)\n\n    end if\n\n    fluxp(1)=f1\n    fluxp(2)=nx*f2-ny*f3\n    fluxp(3)=ny*f2+nx*f3\n    fluxp(4)=f4\n\n  end function fluxp\n"}
{"instruction": "Create a Fortran function named func that takes an integer input parameter and returns an integer array of size n. The function should parallelize the computation of the array elements using OpenMP, with each element incremented by 1.", "input": "", "output": "    function func(n)\n      integer, intent(in) :: n\n      integer, dimension(n) :: func\n      integer :: k\n      func = 0\n!$omp parallel do private(k), reduction(+:func), num_threads(4)\n      do k = 1, n\n        func = func + 1\n      end do\n!$omp end parallel do\n    end function\n"}
{"instruction": "Create a Fortran function named my_start that takes 3 input parameters of type integer: n_global, me, and nimg. This function returns a single output parameter of type integer. The purpose of the function is to calculate the starting memory location based on the global size, process rank, and number of processes.", "input": "", "output": "    function my_start(n_global, me, nimg) result(memory_start)\n        implicit none\n        integer, intent(in) :: n_global, me, nimg\n        integer :: memory_start\n        integer :: base_n\n\n        base_n = n_global / nimg\n\n        memory_start = (me-1)*(base_n) + min(me-1,mod(n_global,nimg)) + 1\n\n    end function my_start\n"}
{"instruction": "Create a Fortran function named trim_fits_strings that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len_trim(str(2:len_trim(str)-1))). This function trims the first and last characters from the input string and returns the trimmed string.", "input": "", "output": "    function trim_fits_strings(str) result(trimmed)\n        !arguments\n        character(len=*), intent(in) :: str\n        !return value\n        character(len=len_trim(str(2:len_trim(str)-1))) :: trimmed\n\n        trimmed = trim(str(2:len_trim(str)-1))\n        return\n    end function trim_fits_strings\n"}
{"instruction": "Write a Fortran function named bin_prob to calculate a binomial probability. The function takes 3 input parameters of type integer, integer, and real, and returns 1 output parameter of type real. The input parameters are n, p, and r, and the output parameter is prob. The function uses the lanczos-type approximation to ln(gamma) for z > 0.", "input": "", "output": "function bin_prob(n, p, r) result(prob)\r\n!     calculate a binomial probability\r\n\r\nimplicit none\r\n\r\ninteger, intent(in) :: n, r\r\nreal, intent(in)    :: p\r\nreal                :: prob\r\n\r\n!     local variable\r\nreal                :: one = 1.0\r\n\r\nprob = exp( lngamma(dble(n+1)) - lngamma(dble(r+1)) - lngamma(dble(n-r+1)) &\r\n                + r*log(p) + (n-r)*log(one - p) )\r\nreturn\r\n\r\n\r\ncontains\r\n\r\n\r\nfunction lngamma(z) result(lanczos)\r\n\r\n!  uses lanczos-type approximation to ln(gamma) for z > 0.\r\n!  reference:\r\n!       lanczos, c. 'a precision approximation of the gamma\r\n\n!  accuracy: about 14 significant digits except for small regions\r\n!            in the vicinity of 1 and 2.\r\n\r\n!  programmer: alan miller\r\n!              1 creswick street, brighton, vic. 3187, australia\r\n!  latest revision - 14 october 1996\r\n\r\nimplicit none\r\ninteger, parameter          :: doub_prec = selected_real_kind(15, 60)\r\nreal(doub_prec), intent(in) :: z\r\nreal(doub_prec)             :: lanczos\r\n\r\n! local variables\r\n\r\nreal(doub_prec)  :: a(9) = (/ 0.9999999999995183d0, 676.5203681218835d0, &\r\n                              -1259.139216722289d0, 771.3234287757674d0, &\r\n                              -176.6150291498386d0, 12.50734324009056d0, &\r\n                              -0.1385710331296526d0, 0.9934937113930748d-05, &\r\n                               0.1659470187408462d-06 /), zero = 0.d0,   &\r\n                               one = 1.d0, lnsqrt2pi = 0.9189385332046727d0, &\r\n                               half = 0.5d0, sixpt5 = 6.5d0, seven = 7.d0, tmp\r\ninteger          :: j\r\n\r\nif (z <= zero) then\r\n  write(*, *)'error: zero or -ve argument for lngamma'\r\n  return\r\nend if\r\n\r\nlanczos = zero\r\ntmp = z + seven\r\ndo j = 9, 2, -1\r\n  lanczos = lanczos + a(j)/tmp\r\n  tmp = tmp - one\r\nend do\r\nlanczos = lanczos + a(1)\r\nlanczos = log(lanczos) + lnsqrt2pi - (z + sixpt5) + (z - half)*log(z + sixpt5)\r\nreturn\r\n\r\nend function lngamma\r\n\r\nend function bin_prob\r\n"}
{"instruction": "Write a Fortran function named heatunit that calculates the amount of heat units in degree-days above a threshold temperature based on the maximum and minimum daily air temperature. The number of input arguments is 3 and the test_data type is [real, real, real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function heatunit(tmax,tmin,thres)\n!\nimplicit none\n!\n! parameter definitions\n!\nreal,parameter :: pi = 3.1415927\n!\n\n!\nreal :: thres,tmax,tmin\nreal :: heatunit\n!\n! local variables\n!\nreal :: range,theta,tmean\n!\n!     calculates the amount of heat units in degree-days above a\n!     threshold temperature assuming a fully sinusoidal daily\n!     temperature cycle with maximum and minimum 12 hours apart.\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     tmax   - maximum daily air temperature\n!     tmin   - minimum daily air temperature\n!     thres  - threshold temperature (such as minimum temperature for growth)\n \n!     + + + local variables + +\n \n!     + + + local variable definitions + + +\n!     tmean  - arithmetic average of tmax and tmin\n!     range  - daily range of maximum and minimum temperature\n!     theta  - point where threshold and air temperature are equal\n!              defines integration limits\n \n!     + + + parameters + + +\n \n!     + + + end initializations + + +\n \nif (thres.ge.tmax) then\n  heatunit = 0.0\nelse if ((thres.le.tmin).or.(tmax.le.tmin)) then\n  tmean = (tmax+tmin)/2.0\n  heatunit = tmean - thres\nelse\n  tmean = (tmax+tmin)/2.0\n  range = (tmax-tmin)/2.0\n  theta = asin((thres-tmean)/range)\n  heatunit = ((tmean-thres)*(pi/2.0-theta)+range*cos(theta))/pi\nend if\n! \nend function heatunit\n"}
{"instruction": "Create a Fortran function named monotonic_sngl to determine if the input array of real numbers is monotonically increasing. The function takes 2 input parameters: an integer n and a real array of dimension n. It returns 1 output parameter of type logical.", "input": "", "output": "  function monotonic_sngl( x, n )\r\n    logical :: monotonic_sngl\r\n    integer,                       intent( in ) :: n\r\n    real (kind=4), dimension( n ), intent( in ) :: x\r\n\r\n    monotonic_sngl = .true.\r\n    if ( n == 1 ) return\r\n    if ( any( x( 2 : n ) <= x( 1 : n - 1 ) ) ) monotonic_sngl = .false.   \r\n\r\n  end function monotonic_sngl\r\n"}
{"instruction": "Create a Fortran function named gcd_2ints to calculate the greatest common divisor of two integers. The function should have 2 input parameters with test_data type ['integer', 'integer'] and 1 output parameter with test_data type ['integer']. Include a subroutine within the function to swap two values.", "input": "", "output": "  function gcd_2ints(x1, x2) result(divisor)\n    integer, intent(in) :: x1, x2\n    integer :: divisor\n\n    integer :: a, b\n    a = abs(x1); b = abs(x2) ! make sure inputs are positive\n    if (b>a) call swap(a,b)\n\n    do ! keep dividing a by b, until one of them is zero\n       if (b>a) call swap(a,b) ! keep the bigger number in a's place\n       if (b == 0) exit ! we're done when b == 0\n       a = mod(a,b) ! divide a by b and keep only the remainder\n    enddo\n    divisor = a\n\n  contains\n    !!<summary>swaps x and y.</summary>\n    !!<parameter name=\"x\" regular=\"true\"></parameter>\n    !!<parameter name=\"y\" regular=\"true\"></parameter>\n    subroutine swap(x,y) ! swap two values\n      integer :: x,y,tmp\n      tmp = x; x = y; y = tmp\n    endsubroutine swap\n  end function gcd_2ints\n"}
{"instruction": "Create a Fortran function called windows_path that takes a single input argument of type character(*) and returns a single output argument of type character(:), allocatable. This function replaces file system separators for Windows in the input path and assigns the modified path to the output variable winpath.", "input": "", "output": "function windows_path(path) result(winpath)\n    ! replace file system separators for windows\n    !\n    character(*), intent(in) :: path\n    character(:), allocatable :: winpath\n\n    integer :: idx\n\n    winpath = path\n\n    idx = index(winpath,'/')\n    do while(idx > 0)\n        winpath(idx:idx) = '\\'\n        idx = index(winpath,'/')\n    end do\n    \nend function windows_path\n"}
{"instruction": "Write a Fortran function named unix_path to replace file system separators in a given path with Unix-style separators. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "function unix_path(path) result(nixpath)\n    ! replace file system separators for unix\n    !\n    character(*), intent(in) :: path\n    character(:), allocatable :: nixpath\n\n    integer :: idx\n\n    nixpath = path\n\n    idx = index(nixpath,'\\')\n    do while(idx > 0)\n        nixpath(idx:idx) = '/'\n        idx = index(nixpath,'\\')\n    end do\n    \nend function unix_path\n"}
{"instruction": "Create a Fortran function named intexp. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function computes the result of raising the base to the power of the exponent using a loop and returns the computed value.", "input": "", "output": "  function intexp (base, exponent)\n    integer :: intexp\n    integer, intent(in) :: base, exponent\n    integer :: i\n\n    if (exponent < 0) then\n       if (base == 1) then\n          intexp = 1\n       else\n          intexp = 0\n       end if\n       return\n    end if\n    intexp = 1\n    do i = 1, exponent\n      intexp = intexp * base\n    end do\n  end function intexp\n"}
{"instruction": "Create a Fortran function named heavyside to determine the Heaviside step function value for a given real*8 input. The function should take 1 input argument of type real*8 and return 1 output argument of type real*8.", "input": "", "output": "  function heavyside(x) result (hside)\n    \n    real*8, intent(in)  :: x\n    real*8              :: hside\n\n    if (x < 0) then\n       hside = 0.0\n    else if (x >= 1) then\n       hside = 1.0\n    end if\n \n  end function heavyside\n"}
{"instruction": "Create a Fortran function named tab2space to replace any vertical tab characters with space characters in a given input string. The function should take 1 input parameter with the type 'character(*)' and return 1 output parameter with the type 'character(len(strinp))'.", "input": "", "output": "pure function tab2space ( strinp )      result(strout)\n  character(*)                                          ,intent(in)     ::      strinp                          !< input character string\n  character(len(strinp))                                                ::      strout                          ! output character string\n  integer                                                               ::      i                               ! character index\n  strout        =       strinp                                                                                  ! initialization of the output string\n  forall (i=1:len_trim(strinp),iachar(strout(i:i))==i_ascii_verttab)    strout(i:i) = ' '                       ! if the current character is a vertical tabulation, then convert tabulation into space character\nend function\n"}
{"instruction": "Create a Fortran pure function called removespace that takes in a single input parameter of type character(*) and returns a single output parameter of type character(len(strinp)). The function removes spaces from the input string and returns the modified string without spaces.", "input": "", "output": "pure function removespace ( strinp )    result(strout)\n  character(*)                                          ,intent(in)     ::      strinp                          !< input character string\n  character(len(strinp))                                                ::      strout                          ! output character string\n  integer                                                               ::      i, k                            ! character index\n  integer                                                               ::      i_ascii                         ! interger ascii code for a given characters\n  strout        =       ''                                                                                      ! initialization of the output string\n  k             =       0                                                                                       ! initialization of the character index\n  do i = 1,len_trim(strinp)                                                                                     ! loop on all string characters\n    i_ascii     =       iachar(strinp(i:i))                                                                     ! getting the code for the ascii character of the current character\n    if  (i_ascii == i_ascii_space)      cycle                                                                   ! if the character is a space, then going to the next character\n    k           =       k + 1                                                                                   ! incrementing the output character string index\n    strout(k:k) =       strinp(i:i)                                                                             ! setting the current charatcer to the input character\n  end do                                                                                                        ! end loop on string characters\nend function\n"}
{"instruction": "Create a Fortran pure function named set_length that takes a character string and an integer as input arguments. The input parameter types are ['character(*)', 'integer']. The function allocates a new string of the specified length and returns it as output. The output parameter type is ['character(:), allocatable'].", "input": "", "output": "pure function set_length( strinp, length ) result(strout)\n  character(*)                                          ,intent(in)     ::      strinp\n  integer                                               ,intent(in)     ::      length\n  character(length)                                                     ::      strtmp\n  character(:)  ,allocatable                                            ::      strout\n!   allocate( character(length) :: strout )\n!   strout(:)     =       strinp\n  strtmp        =       strinp\n  allocate( strout , source = strtmp)\nend function\n"}
{"instruction": "Create a Fortran function named replace_character that takes three input parameters of type character(*). This function replaces a specific character in a given string with a new character. The function returns the modified string as an allocatable character array.", "input": "", "output": "pure function replace_character( string_inp, charold, charnew ) result(string_out)\n  character(*)                                          ,intent(in)     ::      string_inp                         !< string variable to be modified\n  character(*)                                          ,intent(in)     ::      charold                        !<\n  character(*)                                          ,intent(in)     ::      charnew                        !<\n  character(:)  ,allocatable                                            ::      string_out                         !<\n  integer                                                               ::      ioldini                               ! character index\n  integer                                                               ::      ioldfin\n  integer                                                               ::      inewini\n  integer                                                               ::      inewfin\n  character(:)  ,allocatable                                            ::      string_tmp\n  string_out    =       \"\"\n  string_tmp    =       string_inp                                                                              ! loading the input string in the temporary variable\n  do                                                                                                            ! loop on all character for character replacement\n    ioldini     =       index(string_tmp,charold)                                                               ! setting index of first (initial) character to be replaced in the old string\n    ioldfin     =       ioldini - 1 + len(charold)                                                              ! setting index of last (final) character to be replaced in the old string\n    inewini     =       ioldini                                                                                 ! setting index of first (initial) character to be replaced in the new string\n    inewfin     =       ioldini - 1 + len(charnew)                                                              ! setting index of last (final) character to be replaced in the new string\n    if ( ioldini /= 0 ) then\n      string_out        =       string_out // string_tmp(1:ioldini-1) // charnew\n      string_tmp        =       string_tmp(ioldfin+1:)\n    else\n      string_out        =       string_out // string_tmp\n      exit                                                                                    ! if character index is zero, then no character to be replace and so exiting the loop\n    end if\n  end do                                                                                                        ! end of loop on string characters\nend function\n"}
{"instruction": "Create a Fortran function named remove_last_directory_from_path to extract the parent directory path from a given directory path. The input parameter is a character string, and the output parameter is an allocatable character string.", "input": "", "output": "pure function remove_last_directory_from_path( dirinp ) result(dirout)\n  character(*)                                          ,intent(in)     ::      dirinp\n  character(:)  ,allocatable                                            ::      dirout\n  integer                                                               ::      length\n  integer                                                               ::      islash\n  character(*)  ,parameter                                              ::      slash_char = '/'\n  character(1)                                                          ::      last_char\n  logical                                                               ::      trailing_slash\n  dirout        =       trim(dirinp)\n  length        =       len_trim(dirout)\n  last_char     =       dirout(length:length)\n  trailing_slash        =       ( last_char == slash_char )\n  if (trailing_slash) dirout = dirout(1:length-1)       ! remove the trailing slash\n  islash        =       index(dirout,slash_char,back=.true.)\n  if (trailing_slash) then\n    dirout      =       dirout(1:islash)\n  else\n    dirout      =       dirout(1:islash-1)\n  end if\nend function\n"}
{"instruction": "Create a Fortran function named csedvis to calculate the kinematic viscosity of a high concentration cohesive sediment-water mixture. The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function csedvis(sed)\n\n  ! change record\n  !\n  !\n  ! **  calculates kinematic viscosity of high concentration cohesive\n  ! **  sediment-water mixture based on\n  ! **\n  ! **  mehta, a. j., and f.jiang, 1990: some observations on bottom\n  ! **  mud motion due to waves. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n\n  implicit none\n  real :: csedvis,sed,wtl,wth,visl,vish,visr\n\n  if( sed <= 25667.) visr=0.116883d-3*sed\n  if( sed >= 36667.) visr=1.52646d-6*sed+3.125\n  if( sed > 25667.0 .and. sed < 36667.0 )then\n    wtl=(36667.-sed)/11000.\n    wth=(sed-25667.)/11000.\n    visl=0.116883d-3*25667\n    vish=1.52646d-6*36667.+3.125\n    visr=wtl*visl+wth*vish\n  endif\n  csedvis=1.d-6*(10.**visr)\n\nend function\n"}
{"instruction": "Create a Fortran function named binomial to compute the binomial coefficient. It takes 2 input arguments of type integer, denoted as n and k, and returns 1 output argument of type double precision, denoted as bc. The function calculates the binomial coefficient based on the input values of n and k.", "input": "", "output": "function binomial(n, k) result(bc)\n    !> compute binomial coefficients.\n    !> n - non-negative integer (n > 0).\n    !> k - non-negative integer (k < n).\n    !> bc - binomial coefficient.\n    \n    ! input\n    integer, intent(in) :: n, k\n    \n    ! output\n    double precision :: bc\n    \n    ! working\n    integer :: i, kk\n    \n    if ((k .lt. 0) .or. ( k .gt. n)) then\n        bc = 0.0d0\n        return\n    end if\n    if ((k .eq. 0) .or. ( k .eq. n)) then\n        bc = 1.0d0\n        return\n    end if\n    kk = min(k, n - k)\n    bc = 1.0d0\n    do i = 0, kk - 1\n        bc = bc * dble(n - i) / dble(i + 1)\n    end do\n    \nend function binomial\n"}
{"instruction": "Create a Fortran function named one_arg that takes an array of real numbers as input and assigns the value 1.61803399_8 to the elements of the array. The function returns the integer value 42 as the output. The number of input arguments is 1 and the test_data type is ['real(kind=8), dimension(:, :)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function one_arg(a)\n  implicit none\n  !automatic type discovery: the c type correspondacnes\n  !will be automatically determined at compile time\n  integer :: one_arg\n  real(kind=8), dimension(:, : ), intent(inout) :: a\n\n  a = 1.61803399_8\n  one_arg = 42\n\nend function\n"}
{"instruction": "Provide a Fortran function called nrg_occupancy that calculates the occupancy of an energy level. The function takes 4 input parameters of type double precision, double precision, logical, and double precision, respectively. The output parameter is of type double precision.", "input": "", "output": "  function nrg_occupancy(e, flevel, metallic, smearwidth) result(f)\n\n    implicit none\n\n    double precision, intent(in) :: e\n    double precision, intent(in) :: flevel\n    logical,          intent(in) :: metallic\n    double precision, intent(in) :: smearwidth\n    double precision             :: f\n\n    double precision, parameter  :: eps_here = 1.0d-6\n\n    if (metallic) then\n       f = 0.5d0*(erfc((e - flevel)/smearwidth))\n    else if ((e - flevel) < eps_here) then\n       f = 1.0d0\n    else\n       f = 0.0d0\n    end if\n\n  end function nrg_occupancy\n"}
{"instruction": "Write a Fortran function named stripper that removes all occurrences of a specified character from a given string. The function takes 2 input parameters of type character(len=*) and character. The output is a single parameter of type character(:), allocatable. If the specified character is found in the input string, it is removed, and the resulting string is returned.", "input": "", "output": "    recursive function stripper(string,ch) result(stripped)\n        implicit none\n        character(len=*), intent(in) :: string\n        character, intent(in) :: ch\n        character(:), allocatable :: stripped\n\n        if (len(string)==1) then\n           if (string==ch) then\n              stripped = ''\n           else\n              stripped = string\n           end if\n        else\n           if (string(1:1)==ch) then\n              stripped = stripper(string(2:),ch)\n           else\n              stripped = string(1:1)//stripper(string(2:),ch)\n           end if\n        end if\n    end function stripper\n"}
{"instruction": "Create a Fortran function named uppercase that takes a string as input and returns a new string with all letters converted to uppercase. The input parameter is of type character(len=*) and the output parameter is of type character(len=len(astring)).", "input": "", "output": "  function uppercase(astring) result(uppercasestring)\n    character(len=*)::astring\n    character(len=len(astring))::uppercasestring\n\n    character(len=26), parameter ::upper = 'abcdefghijklmnopqrstuvwxyz' ,&              \n                                   lower = 'abcdefghijklmnopqrstuvwxyz'\n    integer :: k    ! loop counter\n    integer :: loc  ! position in alphabet\n\n    uppercasestring = astring       ! copy everything\n    do k = 1, len_trim(astring)     !  to change letters\n      loc = index(lower,astring (k:k))                     ! locate\n      if (loc.ne.0) uppercasestring (k:k) = upper(loc:loc) ! convert\n    end do \n\n  end function uppercase\n"}
{"instruction": "Create a Fortran function named fun_convert_d14ctodelta14c to calculate the conversion of a radiocarbon date (\u039414C) to the corresponding \u03b414C value. This function takes 2 real input parameters (dum_delta13c and dum_d14c) and returns 1 real output parameter.", "input": "", "output": "  function fun_convert_d14ctodelta14c(dum_delta13c,dum_d14c)\n    implicit none\n    ! result variable\n    real::fun_convert_d14ctodelta14c\n    ! dummy arguments\n    real,intent(in)::dum_delta13c,dum_d14c\n\n    ! note: see stuiver and polach [1977] (stuiver and robinson [1974])\n    fun_convert_d14ctodelta14c = 1000.0* &\n         &( &\n         &   (1.0 + dum_d14c/1000.0) * &\n         &   ((1.0 + dum_delta13c/1000.0)**2)/(0.975**2) - &\n         &   1.0 &\n         & )\n  end function fun_convert_d14ctodelta14c\n"}
{"instruction": "Create a Fortran pure function named to_string that converts an integer value to a string. The function takes 2 input parameters of type integer, one of which is optional. The output is a character string of allocatable length.", "input": "", "output": "pure function to_string(val, width) result(string)\n   integer, intent(in) :: val\n   integer, intent(in), optional :: width\n   character(len=:), allocatable :: string\n   integer, parameter :: buffer_len = range(val)+2\n   character(len=buffer_len) :: buffer\n   integer :: pos\n   integer :: n\n   character(len=1), parameter :: numbers(0:9) = &\n      [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n   if (val == 0) then\n      string = numbers(0)\n      return\n   end if\n\n   n = abs(val)\n   buffer = \"\"\n\n   pos = buffer_len + 1\n   do while (n > 0)\n      pos = pos - 1\n      buffer(pos:pos) = numbers(mod(n, 10))\n      n = n/10\n   end do\n   if (val < 0) then\n      pos = pos - 1\n      buffer(pos:pos) = '-'\n   end if\n\n   if (present(width)) then\n      string = repeat(\" \", max(width-(buffer_len+1-pos), 0)) // buffer(pos:)\n   else\n      string = buffer(pos:)\n   end if\nend function to_string\n"}
{"instruction": "Write a Fortran function named reverse that takes a string as input and returns the reversed string. The number of input arguments is 1 and the test_data type is ['character (len=*)']. The number of output arguments is 1 and the test_data type is ['character (len=len(s))'].", "input": "", "output": "elemental function reverse(s) result(t)\r\n! return reversed string\r\ncharacter (len=*), intent(in) :: s\r\ncharacter (len=len(s))        :: t\r\ninteger                       :: i,j,nlen\r\nnlen = len(s)\r\ndo i=1,nlen\r\n   j = nlen-i+1\r\n   t(i:i) = s(j:j)\r\nend do\r\nend function reverse\r\n"}
{"instruction": "Provide a Fortran function named chr_trimzero that removes trailing zeros from a character string. The number of input arguments is 1 with the test_data type of ['character(len=*)'], and the number of output arguments is 1 with the test_data type of ['character(len=:), allocatable'].", "input": "", "output": "function chr_trimzero(thestring) result(retstring)\n\n  character(len=*), intent(in)  :: thestring\n  character(len=:), allocatable :: retstring\n\n  integer ch\n\n  allocate(character(len=len(thestring)) :: retstring)\n  do ch=1, len(thestring)\n    if(thestring(ch:ch) == char(0)) then\n      retstring(ch:ch) = \" \"\n    else\n      retstring(ch:ch) = thestring(ch:ch)\n    end if\n  end do\n  retstring = trim(retstring)\n\nend function chr_trimzero\n"}
{"instruction": "Create a Fortran function named \"atanc\" to calculate the position angle of a point given its position coordinates and the position angle of a nearby point. The function should take 3 input arguments of type real: \"x\", \"y\", and \"thold\". It should return a single output argument of type real. The function should ensure that the position change does not cross the atan2 branch cut.", "input": "", "output": "    function atanc(y, x, thold)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        real :: thold, x, y\n        real :: atanc\n        intent (in) thold, x, y\n        !\n        ! local variables\n        !\n        real :: dtcorr, dthet, thnew\n        real, save :: pi, tpi\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !---------------------------------------------------------------\n\n        !\n        !     increments position angle of point x,y from some previous\n        !     value thold due to a change in position, ensuring that the\n        !     position change does not cross the atan2 branch cut\n        !     (which is in the -x direction).  for example:\n        !\n        !       atanc( -1.0 , -1.0 , 0.75*pi )  returns  1.25*pi , whereas\n        !       atan2( -1.0 , -1.0 )            returns  -.75*pi .\n        !\n        !     typically, atanc is used to fill an array of angles:\n        !\n        !        theta(1) = atan2( y(1) , x(1) )\n        !        do i=2, n\n        !          theta(i) = atanc( y(i) , x(i) , theta(i-1) )\n        !        end do\n        !\n        !     this will prevent the angle array theta(i) from jumping by\n        !     +/- 2 pi when the path x(i),y(i) crosses the negative x axis.\n        !\n        !     input:\n        !       x,y     point position coordinates\n        !       thold   position angle of nearby point\n        !\n        !     output:\n        !       atanc   position angle of x,y\n        !---------------------------------------------------------------\n        data pi/3.1415926535897932384/\n        data tpi/6.2831853071795864769/\n        !\n\n        thnew = atan2(y, x)\n        dthet = thnew - thold\n        !\n        !---- angle change cannot exceed +/- pi, so get rid of any multiples of 2 pi\n        dtcorr = dthet - tpi * int((dthet + sign(pi, dthet)) / tpi)\n        !\n        !---- set correct new angle\n        atanc = thold + dtcorr\n        !\n    end function atanc\n"}
{"instruction": "Create a Fortran function named csqrti that takes an integer input argument and returns a complex value. The input parameter is of type integer, and the output parameter is of type complex(kind(1d0)). The function calculates the square root of the input integer and returns the result as a complex number.", "input": "", "output": "function csqrti(x)\r\n  implicit none\r\n  complex(kind(1d0))::csqrti\r\n  integer,intent(in)::x\r\n  real(kind(1d0))::xx\r\n  complex(kind(1d0))::xxx\r\n  if(x.ge.0)then\r\n     xx=x\r\n     csqrti=dcmplx(dsqrt(xx))\r\n  else\r\n     xxx=x\r\n     csqrti=cdsqrt(xxx)\r\n  endif\r\n  return\r\nend function csqrti\r\n"}
{"instruction": "Create a Fortran function named is_binary_palindrome to determine if an integer is a binary palindrome. The function takes 1 input parameter with test_data type ['integer'] and returns 1 output parameter with test_data type ['logical'].", "input": "", "output": "  function is_binary_palindrome(n)\n    implicit none\n    integer, intent(in)      :: n\n    integer                  :: temp,digits,i\n    integer*1, dimension(32) :: bits\n    logical                  :: is_binary_palindrome\n    real*8                   :: temp2\n\n    temp2=log(dble(n))/log(dble(2))\n    if (mod(temp2,1.0_8) == 0.0_8) temp2=temp2+0.1\n    digits = ceiling(temp2)\n    is_binary_palindrome=.true.\n    temp=n\n\n    do i=1,digits\n       bits(i)=mod(temp,2)\n       temp=temp/2\n    end do\n\n    do i=1,digits\n       if (bits(i) /= bits(digits+1-i)) then\n          is_binary_palindrome=.false.\n          exit\n       end if\n    end do\n  end function is_binary_palindrome\n"}
{"instruction": "Create a Fortran function named vfn to calculate the value of vfn based on the input parameters. The function takes 4 input parameters of types integer, real(8), real(8), and real(8). The output parameter is of type real(8). The function calculates vfn using the provided formula and returns the result.", "input": "", "output": " function vfn(zeta,d1,d2,m)\n\n\t \n implicit none\n\n integer, intent(in) :: m ! m = +/- 1\n real(8), intent(in) :: zeta, d1, d2\n real(8) :: vfn\n \n vfn = ((m*(1.0 - zeta**2) + 6.0*zeta)*d1 + & \n       (2.0 + zeta**2)*d2) / (zeta*(1.0-zeta**2)* &\n\t     (zeta+m)*(zeta+2.0*m))\n  \n return\n\n end function\n"}
{"instruction": "Create a Fortran function named pentagonal to calculate the pentagonal number for a given integer input. The function should take 1 input argument of type integer and return 1 output argument of type integer.", "input": "", "output": "  function pentagonal(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: m,pentagonal\n\n    if (mod(n,2)==1) then\n       m=1\n    else\n       m=-1\n    end if\n    m=m*(n+1)/2\n    pentagonal=m*(3*m-1)/2\n\n  end function pentagonal\n"}
{"instruction": "Write a Fortran function named \"weights\" to calculate the interpolation weights for a given input value between two reference values. The function should take 3 input arguments of type real: zin, ztop, and zbot. It should return 1 output argument of type real, dimension(2) representing the interpolation weights. If ztop is equal to zbot, the function should set both weights to 0.5; otherwise, it should calculate the weights based on the input values.", "input": "", "output": "    function weights(zin,ztop,zbot)\n        ! compute weights to interpolate between ztop and zbottom to get to zin\n        implicit none\n        real, intent(in) :: zin,ztop,zbot\n        real, dimension(2) :: weights\n        real :: zrange\n\n        if (ztop==zbot) then\n            weights(1)=0.5\n            weights(2)=0.5\n        else\n            weights(1)=(zin-zbot)/(ztop-zbot)\n            weights(2)=1-weights(1)\n        endif\n    end function weights\n"}
{"instruction": "Write a Fortran function named isleapyear to determine if a given year is a leap year. The function takes 1 input argument of type integer. The output is 1 logical value.", "input": "", "output": "  function isleapyear(iyear) result(lleapyear)\n    integer,intent(in) :: iyear\n    logical            :: lleapyear\n\n    if (modulo(iyear,400) .eq. 0) then\n      lleapyear = .true.\n    else if (modulo(iyear,100) .eq. 0) then\n      lleapyear = .false.\n    else if (modulo(iyear,4) .eq. 0) then\n      lleapyear = .true.\n    else\n      lleapyear = .false.\n    end if\n\n  end function isleapyear\n"}
{"instruction": "Write a Fortran function named binomial to calculate the binomial coefficient. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function should be called binomial.", "input": "", "output": "  function binomial(n1,n2) result(nchoos)\n    real(8) :: xh\n    integer :: n1,n2,i\n    integer :: nchoos\n    xh = 1.d0\n    if(n2<0) then\n       nchoos = 0\n       return\n    endif\n    if(n2==0) then\n       nchoos = 1\n       return\n    endif\n    do i = 1,n2\n       xh = xh*dble(n1+1-i)/dble(i)\n    enddo\n    nchoos = int(xh + 0.5d0)\n  end function binomial\n"}
{"instruction": "Create a Fortran function named work1 that takes 3 input parameters of type integer, integer, and logical, and returns 1 output parameter of type logical. The function should check if the digits in the input integer are in decreasing order and also if a pair of the same digit is present, based on the conditions specified within the code.", "input": "", "output": "recursive function work1(num, previous, seenpair) result (result)\n\n  integer, intent(in) :: num, previous\n  logical , intent(in) :: seenpair\n  logical ::result, digitsdescreasing,seenpairstillvalid\n  integer::digit\n\n  digit = mod(num,10)\n\n  digitsdescreasing = (digit <= previous)\n  seenpairstillvalid = seenpair .or. digit == previous\n\n  if (num >= 10) then\n    result = digitsdescreasing .and. work1(int(num / 10), digit, seenpairstillvalid )\n  else\n    result = digitsdescreasing .and. seenpairstillvalid\n  end if\nend function work1\n"}
{"instruction": "Write a Fortran function named extension to extract the file extension from a given path. The input parameter is a character string (test_data type is ['character(*)']), and the output parameter is an allocatable character string (test_data type is ['character(:), allocatable']).", "input": "", "output": "   function extension(path)\n      character(:), allocatable :: extension\n\n      character(*), intent(in) :: path\n\n      integer :: dot, slash\n\n      dot = index(path, '.', back=.true.)\n      slash = scan(path, '/\\:', back=.true.)\n\n      if (dot .gt. slash) then\n         extension = path(dot + 1:)\n      else\n         extension = ''\n      end if\n   end function extension\n"}
{"instruction": "Create a Fortran function named fastradpoly that takes 3 real*8 input parameters (rho, n, m) and returns 1 real*8 output parameter. The function computes a fast algorithm for a specific mathematical polynomial expression.", "input": "", "output": "recursive function fastradpoly(rho,n,m) result(output)\n  !declarations\n  implicit none\n  real*8, intent(in) :: rho,n,m\n  !integer, intent(in) :: n,m\n  real*8 :: output,r2,r4,h1,h2,h3,tempm\n\n  !handle rho=0\n  if (rho==0) then\n    if (m==0) then\n      output = (-1.)**(n/2)\n      return\n    else\n      output = 0.\n      return\n    end if\n  end if\n\n  !three possibilities, m=n, m=n-2, m<n-2\n  if (m==n) then\n    output = rho**n\n    return\n  else if (m==n-2) then\n    output = n*rho**n - (n-1)*rho**(n-2)\n    return\n  else\n    tempm = n-4\n    r4 = rho**n\n    r2 = n*rho**n - (n-1)*rho**(n-2)\n    do while(tempm >= m)\n      h3 = -4*(tempm+2)*(tempm+1)/(n+tempm+2)/(n-tempm)\n      h2 = h3*(n+tempm+4)*(n-tempm-2)/4./(tempm+3) + (tempm+2)\n      h1 = .5*(tempm+4)*(tempm+3) - (tempm+4)*h2 + h3*(n+tempm+6)*(n-tempm-4)/8.\n      output = h1*r4 + (h2 + h3/rho**2)*r2\n      if (tempm == m) then\n        return\n      end if\n      r4 = r2\n      r2 = output\n      tempm = tempm - 2\n    end do\n  end if\n\nend function fastradpoly\n"}
{"instruction": "Write a Fortran function called drop_sep, which removes any double forward slashes ('//') from the input path string. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "pure function drop_sep(path)\ncharacter(*), intent(in) :: path\ncharacter(:), allocatable :: drop_sep\n\ninteger :: i\n\ndrop_sep = trim(path)\ni = index(drop_sep, \"//\")\ndo while (i > 0)\n  drop_sep(i:) = drop_sep(i+1:)\n  i = index(drop_sep, \"//\")\nend do\nend function\n"}
{"instruction": "Create a Fortran function named to_lowercase that takes a string as input and returns a new string with all characters converted to lowercase. The number of input arguments is 1 and the test_data type is ['character(*)'], and the number of output arguments is 1 with the test_data type ['character(len(str))'].", "input": "", "output": " function to_lowercase (str)\n !==============================\n !changes a string to lower case\n !==============================\n  implicit none\n  character(*), intent(in) :: str\n  character(len(str))      :: to_lowercase\n  character(len(str))      :: string\n\n  integer :: ic, i\n\n  character(26), parameter :: cap = 'abcdefghijklmnopqrstuvwxyz'\n  character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n\n !capitalize each letter if it is lowecase\n  string = str\n  do i = 1, len_trim(str)\n   ic = index(cap, str(i:i))\n   if (ic > 0) string(i:i) = low(ic:ic)\n  end do\n\n  to_lowercase=trim(string)\n\n  return\n end function to_lowercase\n"}
{"instruction": "Create a Fortran function called inside_obj that determines whether a point is inside an object. This function takes 2 input parameters of type real(8) and returns 1 output parameter of type logical.", "input": "", "output": "  function inside_obj(x1pos,x2pos)\n\n    !------------------------------------------------------------\n    !-------determines whether or not a point is inside the object\n    !------------------------------------------------------------\n\n\n    real(8), intent(in) :: x1pos,x2pos\n\n    real(8) :: r\n\n    logical :: inside_obj\n\n\n    r=sqrt((x1pos-x1ctr)**2+(x2pos-x2ctr)**2)\n    if (r<robj) then\n      inside_obj=.true.\n    else\n      inside_obj=.false.\n    end if\n\n  end function inside_obj\n"}
{"instruction": "Create a Fortran function named itabrow6 that takes one input argument of type integer and returns an output of type integer. The function's purpose is to determine which category a given integer falls into based on predefined ranges. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "   pure function itabrow6(i)\n      integer, intent(in) :: i\n      integer :: itabrow6\n\n      itabrow6=0\n      if (i.gt. 0 .and. i.le. 2) then\n         itabrow6=1\n      else if (i.gt. 2 .and. i.le.10) then\n         itabrow6=2\n      else if (i.gt.10 .and. i.le.18) then\n         itabrow6=3\n      else if (i.gt.18 .and. i.le.36) then\n         itabrow6=4\n      else if (i.gt.36 .and. i.le.54) then\n         itabrow6=5\n      else if (i.gt.54) then\n         itabrow6=6\n      end if\n   end function itabrow6\n"}
{"instruction": "Write a Fortran function named sort_down to sort an input array of real numbers in decreasing order. The function takes 1 input parameter with the test_data type ['real, dimension(:)'] and 1 output parameter with the test_data type ['real, dimension(size(x))'].", "input": "", "output": "  function sort_down(x) result(y)\n  ! sort table by decreasing order\n    implicit none\n    real, dimension(:)       :: x\n    real, dimension(size(x)) :: y\n    real :: swap\n    integer :: change, i, n\n\n    n=size(x)\n\n    change=1\n    do while (change.eq.1)\n      change=0\n      do i= 1, n-1\n        if(x(i) .lt. x(i+1)) then\n          change=1\n          swap=x(i+1)\n          x(i+1)=x(i)\n          x(i)=swap\n        endif\n      enddo\n    enddo\n    y=x\n\n  end function sort_down\n"}
{"instruction": "Create a Fortran function named xdn that takes a 3D array of real numbers as input and returns a modified 3D array of real numbers. The input parameter should be of type real and have a dimension of (:,:,:), while the output parameter should also be of type real and have a dimension of (size(a,1),size(a,2),size(a,3)). The function calculates the average of adjacent elements along the first dimension and assigns the result to the corresponding element in the output array.", "input": "", "output": "  function xdn(a) result (b)\n    real, dimension(:,:,:):: a\n    real, dimension(size(a,1),size(a,2),size(a,3)):: b\n    do k=1,size(a,3)\n    do j=1,size(a,2)\n    do i=2,size(a,1)\n      b(i,j,k)=half*(a(i-1,j,k)+a(i,j,k))\n    end do\n    end do\n    end do\n    b(1,:,:) = a(1,:,:)\n  end function\n"}
{"instruction": "Create a Fortran function named countselfenergy that takes 2 input parameters of type integer. The function reads a file containing complex numbers and counts the number of successful read operations. The output is a single integer representing the count of successful read operations. The name of the function is countselfenergy.", "input": "", "output": "function countselfenergy(fh_sig, ncorr)\n  implicit none\n  integer, intent(in) :: fh_sig, ncorr\n  integer :: countselfenergy\n  ! locals\n  real*8 :: sigma_vec(2*ncorr), ome\n  integer:: nom, ios, i\n  nom=0\n  ios=0\n  do\n     ! read single complex number for each correlation index\n     read(fh_sig,*,iostat=ios) ome,(sigma_vec(i),i=1,2*ncorr) \n     if (ios.ne.0) exit ! if the read statement was not successful, exit\n     nom=nom+1\n  enddo\n  if (ios.gt.0) print *, 'error readings self energy file', fh_sig, ios, nom\n  countselfenergy = nom\n  rewind(fh_sig)\n  return\nend function countselfenergy\n"}
{"instruction": "Write a Fortran function named selectothers that takes an array of integers and a maximum value as input. The input arguments are 2, and their test_data types are ['integer, dimension(:)', 'integer']. The function returns an array of integers that are not present in the input array, up to the maximum value. The output argument is 1, and its test_data type is ['integer, dimension(:), allocatable'].", "input": "", "output": "        function selectothers(notarray, max) result(res)\n            implicit none\n            integer, dimension(:), intent(in) :: notarray\n            integer, intent(in) :: max\n            integer, dimension(:), allocatable :: res \n\n            integer :: i, numout, index\n            numout = max - size(notarray)\n            allocate(res(numout))\n\n            index = 1\n            do i = 1, max \n                if(.not. any(notarray == i)) then\n                    res(index) = i\n                    index = index + 1\n                endif\n            enddo\n        end function\n"}
{"instruction": "Create a Fortran function named convolve that performs the convolution operation on two input arrays. The number of input arguments is 2, both of type real and dimension(:). The number of output arguments is 1, of type real and dimension(:) with the allocatable attribute.", "input": "", "output": "function convolve(x, h)\n        implicit none\n\n        !x is the signal array\n        !h is the noise/impulse array\n        real, dimension(:), allocatable :: convolve, y\n        real, dimension(:) :: x, h\n        integer :: kernelsize, datasize\n        integer :: i,j,k\n\n        datasize = size(x)\n        kernelsize = size(h)\n\n        allocate(y(datasize))\n        allocate(convolve(datasize))\n\n        do i=kernelsize,datasize\n            y(i) = 0.0\n            j=i\n            do k=1,kernelsize\n                y(i) = y(i) + x(j)*h(k)\n                j = j-1\n            end do\n        end do\n\n        do i=1,kernelsize\n            y(i) = 0.0\n            j=i\n            k=1\n            do while (j > 0)\n                y(i) = y(i) + x(j)*h(k)\n                j = j-1\n                k = k+1\n            end do\n        end do\n\n        convolve = y\n\n    end function convolve\n"}
{"instruction": "Create a Fortran function named get_principal_number to determine the principal quantum number based on the input orbital type. The number of input arguments is 1 with the test_data type ['character(len=*)'], and the number of output arguments is 1 with the test_data type ['integer(kind=4)'].", "input": "", "output": "    function get_principal_number(orb)\n    implicit none\n\n    character(len=*),intent(in) :: orb\n    integer(kind=4) :: get_principal_number\n    character(len=8)   :: temp\n\n    temp = trim(adjustl(orb))\n\n    if (temp(1:1) .eq. 's') then\n        get_principal_number = 1\n    else if (temp(1:1) .eq. 'p') then\n        get_principal_number = 2\n    else if (temp(1:1) .eq. 'd') then\n        get_principal_number = 3\n    end if\n        \n    if (temp(1:2) .eq. 's*') then\n        get_principal_number = 4\n    end if\n    end function get_principal_number\n"}
{"instruction": "Write a Fortran function named rdot that calculates the dot product of two arrays, a and b, where a is a 2D array of real numbers with dimensions n1 and n2, and b is a 1D array of real numbers with dimension n2. The function takes 4 input parameters: n1 and n2 of type integer, a of type real(kind(1d0)) with dimensions n1 and n2, and b of type real(kind(1d0)) with dimension n2. The function returns a single output parameter, rdot, of type real(kind(1d0)) with dimension n1.", "input": "", "output": "    function rdot(n1,n2,a,b)\n      ! a.b\n      implicit none\n      integer,intent(in)::n1,n2\n      real(kind(1d0)),dimension(n1,n2),intent(in)::a\n      real(kind(1d0)),dimension(n2),intent(in)::b\n      real(kind(1d0)),dimension(n1)::rdot\n      integer::i,j\n      do i=1,n1\n         rdot(i)=0d0\n         do j=1,n2\n            rdot(i)=rdot(i)+a(i,j)*b(j)\n         enddo\n      enddo\n      return\n    end function rdot\n"}
{"instruction": "Create a Fortran function named search_sorted_first_integer that takes two input arguments: an array of integers (monotonically increasing) and a single integer value to search. It returns the index of the first value in the array greater than or equal to the given value. If the given value is greater than all values in the array, the function returns the length of the array plus one.", "input": "", "output": "function search_sorted_first_integer(x, v) result(hi)\n    !+ returns the index of the first value in `x` greater or equal to `v`.\n    !+ returns `length(x)+1` if `v` is greater then all values in `x`.\n    integer, dimension(:), intent(in) :: x\n        !+ monotonically increasing array\n    integer, intent(in)               :: v\n        !+ value to search\n\n    integer :: hi, lo, m\n\n    lo = 0\n    hi = size(x)+1\n\n    do while (lo.lt.(hi-1))\n        m = rshift(lo+hi,1)\n        if(x(m).lt.v) then\n            lo = m\n        else\n            hi = m\n        endif\n    enddo\n\nend function search_sorted_first_integer\n"}
{"instruction": "Create a Fortran function named lagger_polynomial to compute the value of the generalized Laguerre polynomial for a given real number x, integer n, and real alpha. The function should have 3 input parameters of type real, integer, and real and 1 output parameter of type real.", "input": "", "output": "recursive function lagger_polynomial(x, n, alpha) result(y)\r\n    implicit none\r\n    real :: x\r\n    integer :: n\r\n    real :: alpha\r\n    real :: y\r\n    if (n==0) then\r\n        y = 1\r\n    else if (n==1) then\r\n        y = 1 + alpha - x\r\n    else\r\n        y = ((2 * n + alpha - 1 - x) * lagger_polynomial(x, n - 1, alpha) - (n + alpha - 1) * &\r\n                lagger_polynomial(x, n - 2, alpha)) / n\r\n    end if\r\nend function lagger_polynomial\r\n"}
{"instruction": "Create a Fortran function named csize that takes an integer as input and returns the number of digits in the integer. The number of input parameters is 1 and the test_data type is ['integer']. The number of output parameters is 1 and the test_data type is ['integer'].", "input": "", "output": "   pure function csize(i) result (sz)\n      implicit none\n      integer, intent (in) :: i\n      integer :: sz\n\n      if(i==0) then\n         sz=1\n      else if(i<0) then\n         sz = floor(log10(real(abs(i),kind(1.0d0)))) + 1 + 1 ! additional  1 for minus sign\n      else\n         sz = floor(log10(real(i,kind(1.0d0)))) + 1\n      endif\n\n   end function csize\n"}
{"instruction": "Create a Fortran function named j to calculate the Jacobian matrix for a given set of input parameters. The number of input arguments is 3, with test_data type ['real, dimension(12)', 'real', 'real']. The number of output arguments is 1, with test_data type ['real, dimension(2, 2)'].", "input": "", "output": "    pure function j(a, x, y)\n        implicit none\n        real, dimension(2, 2) :: j\n        real, dimension(12), intent(in) :: a\n        real, intent(in) :: x, y\n\n        real :: dxx, dxy, dyx, dyy\n\n        dxx = a(2) + a(4) * y + 2 * a(5) * x\n        dxy = a(3) + a(4) * x + 2 * a(6) * y\n        dyx = a(8) + a(10) * y + 2 * a(11) * x\n        dyy = a(9) + a(10) * x + 2 * a(12) * y\n\n        j(1,1) = dxx\n        j(1,2) = dxy\n        j(2,1) = dyx\n        j(2,2) = dyy\n    end function j\n"}
{"instruction": "Create a Fortran function named set_qt_forcing to set the type of forcing for qt (specific humidity) calculations. The function takes 1 input argument of type integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use the imperative tone in the instructions.", "input": "", "output": "    function set_qt_forcing(forcing_type) result(ret)\n        integer :: ret\n        integer, intent(in) :: forcing_type\n        if (forcing_type >= 0 .and. forcing_type <= 3) then\n           write(*,*) 'setting qt forcing type', forcing_type\n           qt_forcing_type = forcing_type\n           ret = 0\n         else\n            write(*,*) 'qt forcing type out of range', forcing_type\n            ret = 1\n         endif\n    end function set_qt_forcing\n"}
{"instruction": "Create a Fortran function named findfirstinset to check if a specific character in a given string belongs to a set of characters. The function takes 3 input parameters of type character(len=*), character(len=*), and integer, and 1 output parameter of type logical.", "input": "", "output": "  function findfirstinset(str, set, idx) result (status)\n    character(len=*), intent(in) :: str\n    character(len=*), intent(in) :: set\n    integer, intent(out) :: idx\n    logical :: status\n\n    idx = scan(str, set)\n\n    if (0 < idx) then\n      status = .true.\n    else\n      status = .false.\n    end if\n\n  end function\n"}
{"instruction": "Create a Fortran function named findfirstnotinset, which takes 3 input parameters of type character(len=*), character(len=*), and integer, and 1 output parameter of type logical. The function finds the index of the first character in the input string that does not belong to the specified set. Use the imperative tone and reflect the features of Fortran function in the instruction.", "input": "", "output": "  function findfirstnotinset(str, set, idx) result (status)\n    character(len=*), intent(in) :: str\n    character(len=*), intent(in) :: set\n    integer, intent(out) :: idx\n    logical :: status\n    integer :: i\n\n    idx = 0\n    do i = 1, len(str), 1\n      if (scan(str(i:i), set) == 0) then\n        idx = i\n        exit\n      end if\n    end do\n\n    if (0 < idx) then\n      status = .true.\n    else\n      status = .false.\n    end if\n\n  end function\n"}
{"instruction": "Write a Fortran function named presentdefault_l to determine the final logical value based on the input arguments. The function takes 2 input arguments of types logical and logical (optional) and returns 1 output argument of type logical.", "input": "", "output": "    function presentdefault_l(default, s) result(sout)\n    logical, intent(in) :: default\n    logical, intent(in), optional :: s\n    logical :: sout\n\n    if (present(s)) then\n        sout = s\n    else\n        sout = default\n    end if\n    end function presentdefault_l\n"}
{"instruction": "Create a Fortran function named presentdefault_i that accepts two input arguments, where the first argument is of type integer and the second argument is an optional integer. The function returns a single integer as the output. If the optional second argument is provided, the output is set to the value of the second argument; otherwise, the output is set to the value of the first argument.", "input": "", "output": "    function presentdefault_i(default, s) result(sout)\n    integer, intent(in) :: default\n    integer, intent(in), optional :: s\n    integer :: sout\n\n    if (present(s)) then\n        sout = s\n    else\n        sout = default\n    end if\n    end function presentdefault_i\n"}
{"instruction": "Create a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer*2. The output is 1 parameter of type logical, indicating whether the input integer is a prime number or not.", "input": "", "output": "    function isprime(i) result(r)\n        integer*2, intent(in) :: i\n        integer*2 :: limit\n        integer*2 :: j\n        logical :: r\n        \n        if (i .eq. 1 .or. i .eq. 2) then\n            r = .true.\n            return\n        end if\n        \n        limit = i/2\n        \n        do j=2,limit\n            if (mod(i, j) == 0) then\n                r = .false.\n                return\n            end if\n        end do\n        \n        r = .true.\n        return\n    end function\n"}
{"instruction": "Write a Fortran function named tolower to convert the input string to lowercase characters. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(s)).", "input": "", "output": "  function tolower( s )\n    implicit none\n    character(*), intent(in) :: s\n    character(len(s)) :: tolower\n    integer :: i, idx\n    character(26) :: upper = 'abcdefghijklmnopqrstuvwxyz'\n    character(26) :: lower = 'abcdefghijklmnopqrstuvwxyz'\n    tolower=s\n    do i=1,len_trim(s)\n      idx=index(upper,s(i:i))\n      if (idx > 0) tolower(i:i) = lower(idx:idx)\n    end do\n  end function tolower\n"}
{"instruction": "Create a Fortran function named my_cumsum to calculate the cumulative sum of an input array. The function takes 2 input arguments of types integer and real, dimension(ngrid), and returns 1 output argument of type real, dimension(ngrid).", "input": "", "output": "  function my_cumsum(pdf, ngrid) result(cdf)\n    implicit none\n    ! input\n    integer, intent(in) :: ngrid\n    real, dimension(ngrid), intent(in) :: pdf\n    ! output\n    real, dimension(ngrid) :: cdf\n\n    ! local data\n    integer :: j\n\n    cdf(1) = 0.0\n    do j = 2, ngrid\n      cdf(j) = cdf(j-1) + (pdf(j-1) + pdf(j)) / 2.0\n    enddo\n  end function\n"}
{"instruction": "Create a Fortran function named hk_bhz2x2 that takes two real(8) input parameters, kx and ky, and returns a complex(8) 2x2 matrix as output. The function computes the elements of the 2x2 matrix based on the input parameters kx and ky, and predefined constants mh, lambda, and xi.", "input": "", "output": "  function hk_bhz2x2(kx,ky) result(hk)\n    real(8)                   :: kx,ky,epsik\n    complex(8),dimension(2,2) :: hk\n    epsik   = cos(kx)+cos(ky)\n    hk(1,1) = mh - epsik\n    hk(2,2) =-mh + epsik\n    hk(1,2) = lambda*(sin(kx)-xi*sin(ky))\n    hk(2,1) = lambda*(sin(kx)+xi*sin(ky))\n  end function hk_bhz2x2\n"}
{"instruction": "Write a Fortran function named sedlo to calculate the difference of squares of two input real numbers. The function takes 2 real numbers as input and returns 1 real number as output. The input parameter types are ['real', 'real'], and the output parameter type is ['real'].", "input": "", "output": "function sedlo(a,b) result(c)\n\timplicit none\n\treal,intent(in) :: a,b\n\treal :: c\n\tc = (a*a-b*b)/4\nend function sedlo\n"}
{"instruction": "Create a Fortran function named compact that takes two input parameters of type 'character(len=*)' and 'character(len=*), optional', and returns one output parameter of type 'character(len=len(str))'. The function removes extra white spaces from the input string and replaces multiple consecutive white spaces with a single space. Ensure that the instruction reflects the features of Fortran function and imperative tone.", "input": "", "output": "function compact(str,char) result (outstr)\n\n!character(len=*),parameter::ident_38=\"@(#)m_strings::compact(3f): converts white-space to single spaces\"\n\ncharacter(len=*),intent(in)          :: str\ncharacter(len=*),intent(in),optional :: char\ncharacter(len=len(str))              :: outstr\ncharacter(len=1)                     :: ch\ninteger                              :: i\ninteger                              :: position_in_output\nlogical                              :: last_was_space\ncharacter(len=1)                     :: char_p\nlogical                              :: nospace\nif(present(char))then\n   char_p=char\n   if(len(char).eq.0)then\n      nospace=.true.\n   else\n      nospace=.false.\n   endif\nelse\n   char_p=' '\n   nospace=.false.\nendif\n   outstr=' '\n   last_was_space=.false.\n   position_in_output=0\n\n   ifspace: do i=1,len_trim(str)\n     ch=str(i:i)\n     select case(ichar(ch))\n       case(0:32,127)                                         ! space or tab character or control character\n         if(position_in_output.eq.0)then                      ! still at beginning so ignore leading whitespace\n            cycle ifspace\n         elseif(.not.last_was_space) then                     ! if have not already put out a space output one\n           if(.not.nospace)then\n              position_in_output=position_in_output+1\n              outstr(position_in_output:position_in_output)=char_p\n           endif\n         endif\n         last_was_space=.true.\n       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it\n         position_in_output=position_in_output+1\n         outstr(position_in_output:position_in_output)=ch\n         last_was_space=.false.\n     end select\n   end do ifspace\n\nend function compact\n"}
{"instruction": "Write a Fortran function named matmul_ to perform matrix multiplication. It takes 2 input parameters of type double precision and dimension(:, :) and produces 1 output parameter of type double precision, dimension(:, :), allocatable.", "input": "", "output": "    function matmul_(matrix_a, matrix_b) result(matrix_r)\n        implicit none\n        double precision, intent(in), dimension(:, :) :: matrix_a, matrix_b\n        double precision, dimension(:, :), allocatable :: matrix_r\n        integer :: n, i, j, k\n        double precision :: s\n\n        n = size(matrix_a, 1)\n        allocate(matrix_r(n, n))\n\n        !$omp parallel shared(matrix_a, matrix_b, matrix_r, n) private(i, j, s, k)\n\n        !$omp parallel do\n        do i = 1, n\n            do j = 1, n\n                s = 0.0\n                do k = 1, n\n                    s = s + matrix_a(i, k) * matrix_b(k, j)\n                end do\n                matrix_r(i, j) = s\n            end do\n        end do\n        !$omp end parallel do\n\n        !$omp end parallel\n    end function matmul_\n"}
{"instruction": "Create a Fortran function named expint_2 to calculate the value of the exponential integral Ei(x) for a given real input parameter x. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "  function expint_2( x )\n\n    implicit none\n    real(8) :: expint_2\n    real(8),intent(in) :: x\n    real(8),parameter :: euler=0.577215664901532860606512d0\n    real(8) :: y,tny,eps,delta\n    real(8) :: ai,bi,f0,f1,c0,c1,d0,d1,a0\n    integer :: nmax,i,j\n\n    nmax = 100000\n    eps  = epsilon(1.0d0)\n    tny  = tiny(1.0d0)\n\n    if ( x <= 0.0d0 ) then\n\n       stop \"bad argument (stop@expint)\"\n\n    else if ( x >= 0.5d0 ) then\n\n       f0 = tny\n       c0 = f0\n       d0 = 0.0d0\n       a0 = 1.0d0\n\n       do i=1,nmax\n          bi = x + 2.0d0*i - 1.0d0\n          ai = -(i-1)*(i-1) + a0\n          d1 = bi + ai*d0\n          if ( d1 == 0.0d0 ) d1=tny\n          c1 = bi + ai/c0\n          if ( c1 == 0.0d0 ) c1=tny\n          d1 = 1.0d0/d1\n          delta = c1*d1\n          f1 = f0*delta\n          if ( abs(delta-1.0d0) < eps ) exit\n          f0 = f1\n          c0 = c1\n          d0 = d1\n          a0 = 0.0d0\n       end do\n\n       if ( i > nmax ) stop \"continued fraction is not converged(stop@expint)\"\n\n       expint_2 = f1*exp(-x)\n\n    else if ( x < 0.5d0 ) then\n\n       f0 = 0.0d0\n\n       do i=1,nmax\n\n          f1 = f0\n\n          ai = 1.0d0\n          do j=1,i\n             ai = ai*( -x/dble(j) )\n          end do\n\n          f0 = f0 + ai/dble(i)\n\n          if ( abs(f0-f1) < eps ) exit\n\n       end do\n\n       if ( i > nmax ) stop \"power series is not converged(stop@expint)\"\n\n       expint_2 = - euler - log(x) - f0\n\n    end if\n\n  end function expint_2\n"}
{"instruction": "Create a Fortran function named than that takes a single input argument of type character with varying length. The output is a character with allocatable length. This function replaces the characters \"<\" and \">\" in the input with \"<lt>\" and \"<gt>\", respectively.", "input": "", "output": "function than(in) result(out)\ncharacter(len=*),intent(in)  :: in\ncharacter(len=:),allocatable :: out\ninteger                      :: i\n   out=''\n   do i=1,len_trim(in)\n      select case(in(i:i))\n      case('<')\n         out=out//'<lt>'\n      case('>')\n         out=out//'<gt>'\n      case default\n         out=out//in(i:i)\n      endselect\n   enddo\nend function than\n"}
{"instruction": "Create a Fortran function named yder_cart to calculate the y derivatives of a 3D array of real numbers. The function takes 2 input parameters of type real,dimension(:,:,:) and real, and returns 1 output parameter of type real,dimension(:,:,:),allocatable.", "input": "", "output": "  function yder_cart(f,dy) result(dfdy)\n    !   calculation of y derivatives\n    !   one-sided estimates are used at the southern and northern boundaries\n    implicit none\n\n    real,dimension(:,:,:),intent(in) :: f\n    real,                 intent(in) :: dy\n    real,dimension(:,:,:),allocatable  :: dfdy\n    real :: inv_dy\n    integer :: i,j,k,nlon,nlat,nlev,acc\n    nlon=size(f,1); nlat=size(f,2); nlev=size(f,3)\n    allocate(dfdy(nlon,nlat,nlev))\n    inv_dy = 1.0 / (2.*dy)\n    acc=1\n    select case(acc)\n\n    case(1)\n       do k=1,nlev\n          do j=2,nlat-1\n             do i=1,nlon\n                dfdy(i,j,k)=(f(i,j+1,k)-f(i,j-1,k))*inv_dy\n             enddo\n          enddo\n       enddo\n       dfdy(:,1,:)=(f(:,2,:)-f(:,1,:))/dy\n       dfdy(:,nlat,:)=(f(:,nlat,:)-f(:,nlat-1,:))/dy\n\n    case (2)\n       do k=1,nlev\n          do j=1,nlat\n             do i=1,nlon\n                if(j==2)then\n                   dfdy(i,2,k)=(f(i,3,k)-f(i,1,k))/(2*dy)\n                else if(j==1)then\n                   dfdy(i,1,k)=(-f(i,3,k)+4*f(i,2,k)-3*f(i,1,k))/(2*dy)\n                else if(j==nlat-1)then\n                   dfdy(i,nlat-1,k)=(f(i,nlat,k)-f(i,nlat-2,k))/(2*dy)\n                else if(j==nlat)then\n                   dfdy(i,nlat,k)=(f(i,nlat-2,k)-4*f(i,nlat-1,k) &\n                        +3*f(i,nlat,k))/(2*dy)\n                else\n                   dfdy(i,j,k)=(f(i,j-2,k)-8*f(i,j-1,k)+8*f(i,j+1,k)&\n                        -f(i,j+2,k))/(12*dy)\n                end if\n             enddo\n          enddo\n       enddo\n    end select\n\n\n  end function yder_cart\n"}
{"instruction": "Create a Fortran function named \"laplace_cart\" to calculate the Laplace operator in Cartesian coordinates based on the given periodic domain and boundary conditions. The function takes 3 input parameters: a 3D real array \"f\" representing the field, and two real numbers \"dx\" and \"dy\" representing the grid spacing in the x and y directions respectively. It returns 1 output parameter, a 3D real array \"lapl\" allocated within the function to store the Laplacian of the input field.", "input": "", "output": "  function laplace_cart(f,dx,dy) result(lapl)\n    !     laplace operator in cartesian coordinates.\n    !     the domain is assumed to be periodic in east-west-direction\n    !     ** at the northern and southern boundaries, second y derivative\n    !     is assumed to be zero\n    implicit none\n\n    real,dimension(:,:,:),intent(in) :: f\n    real,                 intent(in) :: dx,dy\n    real,dimension(:,:,:),allocatable :: lapl\n    integer :: nlon,nlat,nlev,acc,i,j,k\n    real :: inv_dx,inv_dy\n    nlon=size(f,1)\n    nlat=size(f,2)\n    nlev=size(f,3)\n    allocate(lapl(nlon,nlat,nlev))\n    inv_dx = 1.0 / (dx * dx)\n    inv_dy = 1.0 / (dy * dy)\n    acc=1\n\n    select case(acc)\n    case(1)\n       ! x-direction\n       lapl ( 2 : nlon - 1, :, : ) = f( 1: nlon - 2, :, : ) + f ( 3: nlon, :, : ) &\n            - 2 * f( 2 : nlon - 1, :, : )\n       lapl ( 1, :, : )    = f( nlon, :, : ) + f ( 2, :, : ) &\n            - 2 * f( 1, :, : )\n       lapl ( nlon, :, : ) = f( nlon - 1, :, : ) + f ( 1, :, : ) &\n            - 2 * f( nlon, :, : )\n       lapl = lapl * inv_dx\n\n       ! y-directon\n       lapl ( :, 2 : nlat -1, : ) = lapl ( :, 2 : nlat -1, : ) &\n            + ( f ( :, 1 : nlat -2, : ) + f ( :, 3 : nlat, :) &\n            - 2 * f( :, 2 : nlat -1, : ) ) * inv_dy\n\n    case(2)\n\n       do j=1,nlat\n          do k=1,nlev\n             do i=1,nlon\n                ! x-direction\n                if(i==1)then\n                   lapl(i,j,k)=(-(1/12)*f(nlon-1,j,k)+(4/3)*f(nlon,j,k)-(5/2)*f(i,j,k) &\n                        +(4/3)*f(i+1,j,k)-(1/12)*f(i+2,j,k))/(dx*dx)\n                else if(i==2)then\n                   lapl(i,j,k)=(-(1/12)*f(nlon,j,k)+(4/3)*f(i-1,j,k)-(5/2)*f(i,j,k) &\n                        +(4/3)*f(i+1,j,k)-(1/12)*f(i+2,j,k))/(dx*dx)\n                else if(i==nlon-1)then\n                   lapl(i,j,k)=(-(1/12)*f(i-2,j,k)+(4/3)*f(i-1,j,k)-(5/2)*f(i,j,k) &\n                        +(4/3)*f(i+1,j,k)-(1/12)*f(1,j,k))/(dx*dx)\n                else if(i==nlon)then\n                   lapl(i,j,k)=(-(1/12)*f(i-2,j,k)+(4/3)*f(i-1,j,k)-(5/2)*f(i,j,k) &\n                        +(4/3)*f(1,j,k)-(1/12)*f(2,j,k))/(dx*dx)\n                else\n                   lapl(i,j,k)=-(1/12)*f(i-2,j,k)+(4/3)*f(i-1,j,k)-(5/2)*f(i,j,k) &\n                        +(4/3)*f(i+1,j,k)-(1/12)*f(i+2,j,k)\n                   lapl(i,j,k)=lapl(i,j,k)/(dx*dx)\n                end if\n             enddo\n          enddo\n       enddo\n\n       do i=1,nlon\n          do k=1,nlev\n             do j=2,nlat-1\n                ! y-direction\n                if(j==2)then\n                   lapl(i,j,k)=lapl(i,j,k)+(f(i,j-1,k)+f(i,j+1,k)-2*f(i,j,k))&\n                        /(dy*dy)\n                else if(j==nlat-1)then\n                   lapl(i,j,k)=lapl(i,j,k)+(f(i,j-1,k)+f(i,j+1,k)-2*f(i,j,k))&\n                        /(dy*dy)\n                else\n                   lapl(i,j,k)=lapl(i,j,k)+(-(1/12)*f(i,j-2,k)+(4/3)*f(i,j-1,k) &\n                        -(5/2)*f(i,j,k)+(4/3)*f(i,j+1,k)-(1/12)*f(i,j+2,k))/(dy*dy)\n                end if\n             enddo\n          enddo\n       enddo\n\n    end select\n\n  end function laplace_cart\n"}
{"instruction": "Create a Fortran function named primality_tester to determine if a given integer is a prime number or not. The function should take 1 input argument of type integer and return 1 output argument of type logical. ", "input": "", "output": "  function primality_tester(n) result(prime)\n    integer, intent(in) :: n\n    logical :: prime\n\n    integer :: i\n\n    if (n <= 1) then\n      prime = .false.\n      return\n    else if (n <= 3) then\n      prime = .true.\n      return\n    else if (mod(n, 2) == 0 .or. mod(n, 3) == 0) then\n      prime = .false.\n      return\n    end if\n\n    i = 5\n    do while (i * i <= n)\n      if (mod(n, i) == 0 .or. mod(n, i + 2) == 0) then\n        prime = .false.\n        return\n      end if\n      i = i + 6\n    end do\n\n    prime = .true.\n  end function\n"}
{"instruction": "Write a Fortran function called get_costs_for_illegal to determine the cost associated with a particular closing token. The function takes 1 input parameter of type character and returns 1 output parameter of type integer. The input parameter, closingtoken, represents the closing token, and the output parameter, get_costs_for_illegal, represents the associated cost.", "input": "", "output": "  pure function get_costs_for_illegal(closingtoken)\n    implicit none\n\n    character, intent(in) :: closingtoken\n    integer :: get_costs_for_illegal\n\n    select case (closingtoken)\n      case(\")\")\n        get_costs_for_illegal = 3\n      case (\"]\")\n        get_costs_for_illegal = 57\n      case (\"}\")\n        get_costs_for_illegal = 1197\n      case (\">\")\n        get_costs_for_illegal = 25137\n    end select\n  end function get_costs_for_illegal\n"}
{"instruction": "Create a Fortran function named get_expected_closing_char_from to determine the expected closing character based on the provided opening character. The function should take 1 input argument of type character and return 1 output argument of type character. The input argument represents the opening character, and the output argument represents the expected closing character. Use the select case construct to determine the expected closing character based on the input opening character.", "input": "", "output": "  pure function get_expected_closing_char_from(openingtoken) \n    implicit none\n\n    character, intent(in) :: openingtoken\n    character :: get_expected_closing_char_from\n\n    select case (openingtoken)\n      case(\"(\")\n        get_expected_closing_char_from = \")\"\n      case (\"[\")\n        get_expected_closing_char_from = \"]\"\n      case (\"{\")\n        get_expected_closing_char_from = \"}\"\n      case (\"<\")\n        get_expected_closing_char_from = \">\"\n    end select\n  end function get_expected_closing_char_from\n"}
{"instruction": "Create a Fortran function named atan2_cc that computes the complex arctangent of val1 divided by val2. The function should have 2 input parameters of type complex(8) and 1 output parameter of type complex(8). The number of input arguments is 2 and the test_data type is ['complex(8)', 'complex(8)']. The number of output arguments is 1 and the test_data type is ['complex(8)'].", "input": "", "output": "function atan2_cc(val1,val2)\n  character(len=*),parameter :: this_sub_name = 'atan2_cc'\n\n  complex(8),intent(in) :: val1\n  complex(8),intent(in) :: val2\n\n  complex(8) :: atan2_cc\n\n  real(8) :: r1\n  real(8) :: c1\n  real(8) :: r2\n  real(8) :: c2\n\n  r1 = real(val1)\n  c1 = aimag(val1)\n  r2 = real(val2)\n  c2 = aimag(val2)\n\n  if ((r1 .ne. 0) .or. (r2 .ne. 0)) then\n    atan2_cc = cmplx(atan2(r1,r2),(r2*c1-r1*c2)/(r1**2+r2**2),8)\n  else\n    atan2_cc = cmplx(atan2(r1,r2),0.0,8)\n  endif\nend function atan2_cc\n"}
{"instruction": "Create a Fortran function called \"sub\" to subtract two arrays of real numbers. The function should accept 2 input parameters of type real (kind=8), dimension(:), and intent(in). It should also have 1 output parameter of type real (kind=8), allocatable, dimension(:).", "input": "", "output": "    function sub(v1,v2)\n      real (kind=8), intent(in), dimension(:) :: v1, v2\n      integer(kind=4) :: i, length\n      real (kind=8), allocatable, dimension(:) :: sub\n      length = size(v1)\n      allocate(sub(length))\n      sub = v1 - v2\n    end function sub\n"}
{"instruction": "Write a Fortran function named qaverage that calculates the average of two quantities based on different cases. The function accepts 5 input arguments: an integer q, and four real*8 values rhoa, rhob, mya, and myb. The output of the function is a single real*8 value.\n\nThe function first calculates the sum of rhoa and rhob. Then, based on the value of q, it performs different calculations to determine the average. If q is 1, the average is computed as rhoa/rhosum multiplied by mya plus rhob/rhosum multiplied by myb. If q is -1, the average is computed as the reciprocal of the sum of (rhoa/rhosum) multiplied by the reciprocal of mya, and (rhob/rhosum) multiplied by the reciprocal of myb. If q is 0, the average is computed as the square root of (mya raised to the power of rhoa) plus (myb raised to the power of rhob), all raised to the power of (1/rhosum). For any other value of q, the average is set to zero.\n\nMake sure to define the function using the Fortran keyword \"function\" and specify the input and output arguments along with their types.", "input": "", "output": " pure function qaverage(q,rhoa,rhob,mya,myb)\n  \n  implicit none\n  \n  integer, intent(in) :: q \n  \n  real*8, intent(in) :: rhoa,rhob,mya,myb\n  \n  real*8 :: qaverage,rhosum\n  \n  rhosum=rhoa+rhob\n  \n  select case(q)\n  case(1)\n    qaverage=rhoa/rhosum*mya+rhob/rhosum*myb\n  case(-1)\n    qaverage=1.d0/(rhoa/rhosum*(1.d0/mya)+rhob/rhosum*(1.d0/myb))\n  case(0)\n    qaverage=(mya**(rhoa)+myb**(rhob))**(1.d0/rhosum)\n  case default\n    qaverage=0.d0\n  end select\n  \n  return\n  \n end function\n"}
{"instruction": "Create a Fortran function called \"studnt\" to calculate the upper tail area under Student's t-distribution. The function takes two input arguments of type real, namely \"t\" and \"doff\". The output of the function is a real value. The function performs a series evaluation and uses several local variables to compute the result. Remember to ensure that the number of degrees of freedom, \"doff\", is greater than 4.", "input": "", "output": "function studnt (t, doff) result(fn_val)\r\n\r\n! n.b. argument ifault has been removed.\r\n \r\n! code converted using to_f90 by alan miller\r\n! date: 2002-01-02  time: 21:19:45\r\n\r\n!     algorithm as 27  appl. statist. vol.19, no.1\r\n\r\n!     calculate the upper tail area under student's t-distribution\r\n\r\n!     translated from algol by alan miller\r\n\r\nimplicit none\r\nreal, intent(in)      :: t\r\nreal, intent(in)      :: doff\r\nreal                  :: fn_val\r\n\r\n!     local variables\r\n\r\nreal     :: v, x, tt\r\nlogical  :: pos\r\nreal, parameter  :: four = 4.0, one = 1.0, zero = 0.0, half = 0.5\r\nreal, parameter  :: a1 = 0.09979441, a2 = -0.581821, a3 = 1.390993,  &\r\n                    a4 = -1.222452, a5 = 2.151185\r\nreal, parameter  :: b1 = 5.537409, b2 = 11.42343\r\nreal, parameter  :: c1 = 0.04431742, c2 = -0.2206018, c3 = -0.03317253,  &\r\n                    c4 = 5.679969, c5 = -12.96519\r\nreal, parameter  :: d1 = 5.166733, d2 = 13.49862\r\nreal, parameter  :: e1 = 0.009694901, e2 = -0.1408854, e3 = 1.88993,  &\r\n                    e4 = -12.75532, e5 = 25.77532\r\nreal, parameter  :: f1 = 4.233736, f2 = 14.3963\r\nreal, parameter  :: g1 = -9.187228e-5, g2 = 0.03789901, g3 = -1.280346,  &\r\n                    g4 = 9.249528, g5 = -19.08115\r\nreal, parameter  :: h1 = 2.777816, h2 = 16.46132\r\nreal, parameter  :: i1 = 5.79602e-4, i2 = -0.02763334, i3 = 0.4517029,  &\r\n                    i4 = -2.657697, i5 = 5.127212\r\nreal, parameter  :: j1 = 0.5657187, j2 = 21.83269\r\n\r\n!     check that number of degrees of freedom > 4.\r\n\r\nif (doff <= four) then\r\n  write(*, *) '** error in as27 - degrees of freedom <= 4  **'\r\n  return\r\nend if\r\n\r\n!     evaluate series.\r\n\r\nv = one / doff\r\npos = (t >= zero)\r\ntt = abs(t)\r\nx = half*(one +   &\r\n    tt*(((a1 + v*(a2 + v*(a3 + v*(a4 + v*a5)))) / (one - v*(b1 - v*b2))) +  &\r\n    tt*(((c1 + v*(c2 + v*(c3 + v*(c4 + v*c5)))) / (one - v*(d1 - v*d2))) +  &\r\n    tt*(((e1 + v*(e2 + v*(e3 + v*(e4 + v*e5)))) / (one - v*(f1 - v*f2))) +  &\r\n    tt*(((g1 + v*(g2 + v*(g3 + v*(g4 + v*g5)))) / (one - v*(h1 - v*h2))) +  &\r\n    tt*((i1 + v*(i2 + v*(i3 + v*(i4 + v*i5)))) / (one - v*(j1 - v*j2))) ))))) ** (-8)\r\nif (pos) then\r\n  fn_val = x\r\nelse\r\n  fn_val = one - x\r\nend if\r\n\r\nreturn\r\nend function studnt\r\n"}
{"instruction": "Write a Fortran function named compress that takes a string as input and removes all spaces and tabs from it. The input parameter is of type character with variable length. The function returns an output string with the same length as the input string, but without any spaces or tabs.", "input": "", "output": "   function compress(str_in) result(str_out)\n      ! inputs/outputs\n      character(len=*), intent(in) :: str_in  !< input string\n      character(len=len(str_in)) :: str_out   !< output string, no more spaces and tabs\n      ! local variables\n      integer, parameter :: iachar_space = 32\n      integer, parameter :: iachar_tab = 9\n      integer :: i,j,my_iachar\n      j=0; str_out=' '\n      do i=1,len(str_in)\n         my_iachar=iachar(str_in(i:i))\n         if (my_iachar.ne.iachar_space .and. my_iachar.ne.iachar_tab) then\n            j=j+1; str_out(j:j)=str_in(i:i)\n         end if\n      end do\n   end function compress\n"}
{"instruction": "Write a Fortran function code named getoddpositionelements that takes an array of integers as input and returns an array containing elements from odd positions of the input array. The number of input arguments is 1 and the test_data type is ['integer, dimension(1:)']. The number of output arguments is 1 and the test_data type is ['integer, dimension(1:(size(list)+1)/2)'].\n\nTo achieve this, iterate through the input array and check if the position is odd using the modulo operator. If the position is odd, store the element in a new array. Finally, return the new array containing elements from odd positions.\n\nUse the following Fortran code as a reference:\n\n```fortran\nfunction getoddpositionelements(list) result(r)\n    integer, dimension(1:), intent(in) :: list\n    integer, dimension(1:(size(list)+1)/2) :: r\n    integer :: i\n    integer :: j\n\n    j=1            \n    do i=1,size(list)\n        if (modulo(i, 2) == 1) then ! odd position\n            r(j) = list(i)\n            j = j + 1\n        end if\n    end do\nend function getoddpositionelements\n```", "input": "", "output": "        function getoddpositionelements(list) result(r)\n            integer, dimension(1:), intent(in) :: list\n            integer, dimension(1:(size(list)+1)/2) :: r\n            integer :: i\n            integer :: j\n            \n            j=1            \n            do i=1,size(list)\n                if (modulo(i, 2) == 1) then ! odd position\n                    r(j) = list(i)\n                    j = j + 1\n                end if\n            end do\n            \n        end function getoddpositionelements\n"}
{"instruction": "Create a Fortran function named adjustr_atleast that pads the input string on the left with spaces to ensure it is at least the specified length. The number of input arguments is 2, with test_data types ['character(len=*)', 'integer']. The number of output arguments is 1, with a test_data type of ['character(len=max(length,len(trim(line))))'].", "input": "", "output": "function adjustr_atleast(line,length) result(strout)\n\n! ident_4=\"@(#)m_overload::adjustr_atleast(3f): return string padded on left to at least specified length\"\n\ncharacter(len=*),intent(in)                :: line\ninteger,intent(in)                         :: length\ncharacter(len=max(length,len(trim(line)))) :: strout\n   strout=line\n   strout=adjustr(strout)\nend function adjustr_atleast\n"}
{"instruction": "Create a Fortran function named fjson_convert_bool_to_value that takes a logical input argument and returns a character string. The input argument's test_data type is ['logical'], and the output argument's test_data type is ['character(len=:), allocatable']. This function converts the logical input to a corresponding JSON string representation, where true is represented as \"true\" and false is represented as \"false\".", "input": "", "output": "   function fjson_convert_bool_to_value(var) result(val_string)\n\n      implicit none\n\n      !> variable to be converted\n      logical, intent(in) :: var\n\n      !> json string\n      character(len=:), allocatable :: val_string\n\n      character(len=:), allocatable :: bool_string\n\n      character(len=*), parameter :: caller = \"fjson_convert_bool_to_value\"\n\n      if (var) then\n         bool_string = \"true\"\n      else\n         bool_string = \"false\"\n      end if\n      val_string = trim(adjustl(bool_string))\n\n   end function\n"}
{"instruction": "Create a Fortran function named elementformat that takes a single input parameter of type character(*) and returns a single output parameter of type character(len=len_trim(lower_upper)). The function should convert the case of the input string, i.e., convert lowercase letters to uppercase and vice versa, and return the modified string.", "input": "", "output": "  function elementformat(lower_upper) result(upper_lower)\n    character(*), intent(in)             :: lower_upper\n    character(len=len_trim(lower_upper)) :: upper_lower\n    character(len=*), parameter          :: lc = 'abcdefghijklmnopqrstuvwxyz', &\n                                            uc = 'abcdefghijklmnopqrstuvwxyz'\n    integer                              :: i,j\n\n    upper_lower = lower_upper\n    j = index(lc,lower_upper(1:1))\n    if (j>0) upper_lower(1:1) = uc(j:j)\n    do i = 2, len_trim(lower_upper)\n       j = index(uc,lower_upper(i:i))\n       if (j>0) upper_lower(i:i) = lc(j:j)\n    enddo\n\n  end function elementformat\n"}
{"instruction": "Create a Fortran function named optval_char that takes two input parameters, one optional character and one non-optional character. The output is a character with allocatable length. If the optional parameter is present, the output is assigned the value of the optional parameter; otherwise, the output is assigned the value of the non-optional parameter.", "input": "", "output": "    function optval_char(opt, default) result(val)\n        character(len=*), intent(in), optional :: opt\n        character(len=*), intent(in) :: default\n        character(len=:), allocatable :: val\n\n        if (present(opt)) then\n            val = opt\n        else\n            val = default\n        end if\n\n    end function optval_char\n"}
{"instruction": "Create a Fortran function named mhd_grid_gauss_weight that calculates the weights of the Gauss quadrature. The function takes 2 input parameters of type integer and returns 1 output parameter of type real(8).", "input": "", "output": "function mhd_grid_gauss_weight(npoints, k) result(w)\n    !> weights of the gauss quadrature.\n    !> {{{\n    integer, intent(in) :: npoints\n    integer, intent(in) :: k\n    real(8) :: w\n    !> }}}\n    real(8), dimension(1:1), parameter :: w1 = [ +1.000000000d0 ]\n    real(8), dimension(1:2), parameter :: w2 = [ +0.500000000d0, +0.50000000d0 ]\n    real(8), dimension(1:3), parameter :: w3 = [ +0.277777778d0, +0.444444444d0, +0.277777778d0 ]\n    real(8), dimension(1:4), parameter :: w4 = [ +0.173927423d0, +0.326072577d0, +0.326072577d0, &\n                                                 +0.173927423d0 ]\n    real(8), dimension(1:5), parameter :: w5 = [ +0.118463443d0, +0.239314335d0, +0.284444444d0, &\n                                                 +0.239314335d0, +0.118463443d0 ]\n    select case ( npoints )\n        case ( 1 )\n            w = w1(k)\n        case ( 2 )\n            w = w2(k)\n        case ( 3 )\n            w = w3(k)\n        case ( 4 )\n            w = w4(k)\n        case ( 5 )\n            w = w5(k)\n        case default\n            write (0,*) 'too many points for gauss quadratures.'\n            error stop -1\n    end select\nend function mhd_grid_gauss_weight\n"}
{"instruction": "Create a Fortran function named mhd_legendre_poly that calculates the value of the Legendre polynomial for a given order and input value. The function takes 2 input parameters with test_data types ['integer', 'real(8)'] and returns 1 output parameter with a test_data type of ['real(8)'].", "input": "", "output": "function mhd_legendre_poly(m, x) result(y)\n    !> legendre polynomial value.\n    !> {{{\n    integer, intent(in) :: m\n    real(8), intent(in) :: x\n    real(8) :: y\n    !> }}}\n    select case ( m )\n        case ( 0 )\n            y = 1.0d0\n        case ( 1 )\n            y = x\n        case ( 2 )\n            y = 1.5d0*x**2 - 0.5d0\n        case ( 3 )\n            y = x*( 2.5d0*x**2 - 1.5d0 )\n        case ( 4 )\n            y = x**2\n            y = 4.375d0*y**2 - 3.75d0*y + 0.375d0\n        case ( 5 )\n            y = x**2\n            y = x*( 7.875d0*y**2 - 8.75*y + 1.875d0 )\n        case default\n            write (0,*) 'too large legendre polynomial number.'\n            error stop -1\n    end select\nend function mhd_legendre_poly\n"}
{"instruction": "Create a Fortran function named basicanemology that takes 4 input parameters of type real, dimension(3), real, real, and real, and 1 output parameter of type integer. This function computes wind speed, wind direction, and 3D wind speed based on the input wind vector. Use the imperative tone to instruct the code.", "input": "", "output": "\tfunction basicanemology(rvwindavg, rvel, rdir, r3dvel) result(iretcode)\n\t\n\t\t! routine arguments\n\t\treal, dimension(3), intent(in)\t:: rvwindavg\n\t\treal, intent(out)\t\t\t\t:: rvel\n\t\treal, intent(out)\t\t\t\t:: rdir\n\t\treal, intent(out)\t\t\t\t:: r3dvel\n\t\tinteger\t\t\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\treal, parameter\t:: pi = 3.1415927\n\t\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! compute horizontal and full-vector wind speeds\n\t\trvel = sqrt(sum(rvwindavg(1:2)**2))\n\t\tr3dvel = sqrt(sum(rvwindavg**2))\n\t\t\n\t\t! compute horizontal wind direction (provenance convention: see sign of wind components!)\n\t\trdir = 180./pi * atan2(-rvwindavg(1), -rvwindavg(2))\n\t\tif(rdir <    0.) rdir = rdir + 360.\n\t\tif(rdir >= 360.) rdir = rdir - 360.\n\t\t\n\tend function basicanemology\n"}
{"instruction": "Create a Fortran function named has_duplicates to determine if an array of integers contains any duplicate values. The function should take 1 input parameter of type integer array and return 1 output parameter of type logical. The input parameter must have the attribute \"intent(in)\" and be of dimension(:).", "input": "", "output": "    function has_duplicates(data) result(result)\n        integer, dimension(:), intent(in) :: data\n        logical :: result\n        integer :: i, j\n\n        result = .false.\n        outer: do i = 1, size(data) - 1\n            do j = i + 1, size(data)\n                if (data(i) == data(j)) then\n                    result = .true.\n                    exit outer\n                end if\n            end do\n        end do outer\n    end function has_duplicates\n"}
{"instruction": "Create a Fortran function named factorial2 to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer. Ensure the function computes the factorial of the input integer based on whether it is odd or even.", "input": "", "output": "        function factorial2(n) result(fact2)\n            implicit none\n\n            ! input\n            integer, intent(in) :: n\n\n            ! intermediate variable\n            integer :: i\n\n            ! output\n            integer :: fact2\n\n            if (n == -1) then\n                fact2 = 1\n            else if (mod(n,2) == 0) then ! even number\n                fact2 = 1\n\n                do i = 2, n, 2\n                    fact2 = fact2 * i\n                end do\n            else ! odd number\n                fact2 = 1\n\n                do i = 1, n, 2\n                    fact2 = fact2 * i\n                end do\n            end if\n\n        end function factorial2\n"}
{"instruction": "Create a Fortran function named toupper that takes a string as input and returns a new string with all characters converted to uppercase. The input parameter is of type character(len=*) and the output parameter is of type character(len=:), allocatable.", "input": "", "output": "    function toupper(strin) result(strout)\n        character(len=*), intent(in) :: strin\n        character(len=:), allocatable :: strout\n        integer :: i\n        integer :: j\n        integer :: offset\n  \n        offset=iachar('a')-iachar('a')\n        strout = strin\n        do i = 1, len(strin)\n            j = iachar(strin(i:i))\n            if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n                strout(i:i) = achar(iachar(strin(i:i)) + offset)\n            else\n                strout(i:i) = strin(i:i)\n            end if\n        end do\n    end function toupper\n"}
{"instruction": "Create a Fortran function named tolower that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=:), allocatable. This function converts all uppercase letters in the input string to their corresponding lowercase letters and leaves all other characters unchanged.", "input": "", "output": "    pure function tolower(strin) result(strout)\n        character(len=*), intent(in) :: strin\n        character(len=:), allocatable :: strout\n        integer :: i\n        integer :: j\n        integer :: offset\n \n        offset=iachar('a')-iachar('a')\n        strout = strin\n        do i = 1, len(strin)\n            j = iachar(strin(i:i))\n            if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n                strout(i:i) = achar(iachar(strin(i:i)) - offset)\n            else\n                strout(i:i) = strin(i:i)\n            end if\n        end do\n    end function tolower\n"}
{"instruction": "Write a Fortran function named a_int that operates on quantum states. It takes 2 input parameters: an integer 'k' and an array of integers 'state'. It returns 1 output parameter of type 'double precision' and dimension 'size(state,1)'. This function modifies the input 'state' based on the value of 'k' and returns the modified state.", "input": "", "output": "    function a_int(k,state) result(new_state)\n    !a_dagger |n> = sqrt(n+1) |n+1>\n        implicit none\n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n\n        new_state    = state \n!        write(*,*) k,new_state\n        if(state(k).gt.0) then\n            new_state(k) = new_state(k) - 1\n            new_state    = sqrt(1.0*new_state(k))*new_state\n        else\n            new_state =0\n        end if\n !       write(*,*) k,new_state\n    end function a_int\n"}
{"instruction": "Create a Fortran function named getstoragesize that takes 3 integer input parameters and returns 1 integer output parameter. The input parameters have the test_data type of ['integer', 'integer', 'integer'], and the output parameter has the test_data type of ['integer']. This function calculates the size of an array based on the minimum required size, the current size, and the new size, considering some additional allocation based on the new size.", "input": "", "output": "  function getstoragesize(minsize, oldsize, newsize) result(arraysize)\n    integer, intent(in) :: minsize, oldsize, newsize\n    integer :: arraysize\n\n    integer :: overalloc\n    \n    if (oldsize >= newsize .and. oldsize <= 2 * newsize) then\n      arraysize = oldsize\n    else\n      overalloc = newsize / 8\n      if (newsize < 9) then\n        overalloc = overalloc + 3\n      else\n        overalloc = overalloc + 6\n      end if\n      arraysize = newsize + overalloc\n      if (arraysize < minsize) then\n        arraysize = max(oldsize, minsize)\n      end if\n    end if\n\n  end function getstoragesize\n"}
{"instruction": "Write a Fortran function named wrap that takes 3 integer input arguments (x, ub, isper) and returns 1 integer output. The test_data type for input is ['integer', 'integer', 'integer'] and for output is ['integer']. The function computes the wrapped value of x based on the upper bound ub. If isper is not equal to 1, the function returns without computation.", "input": "", "output": " pure function wrap(x, ub, isper)\n  implicit none\n  integer, intent(in) :: x, ub, isper\n  integer :: wrap\n\n  if(isper /= 1) return\n\n  wrap = modulo(x-1, ub) + 1\n end function wrap\n"}
{"instruction": "Create a Fortran function named check_bounds to check if a given floating-point number is within specified bounds and return an updated value if it is not. The function takes 3 input parameters of type double precision: x, a (lower bound), and b (upper bound), and returns 1 output parameter of type double precision. If the input value x is less than the lower bound a, the function updates x to the lower bound. If x is greater than the upper bound b, the function updates x to the upper bound.", "input": "", "output": "function check_bounds(x, a, b) result(xout)\n    !> check that a float is between the bounds and return an updated value\n    !> if not.\n    !> x - float to check.\n    !> a - lower bound.\n    !> b - upper bound.\n    \n    ! input\n    double precision, intent(in) :: x, a, b\n    \n    ! output\n    double precision :: xout\n    \n    xout = x\n    \n    if ( x .lt. a) then\n        xout = a\n        return\n    end if\n    \n    if ( x .gt. b) then\n        xout = b\n        return\n    end if\n\nend function check_bounds\n"}
{"instruction": "Write a Fortran function called kim_l that takes one input parameter of type logical. The function returns an integer based on the input logical value, where 1 is returned if the input is true and 0 is returned if the input is false. The number of input arguments is 1 and the test_data type is [logical].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function kim_l(l)\n   logical, intent(in) :: l\n   integer :: kim_l\n\n   if (l) then\n      kim_l = 1\n   else\n      kim_l = 0\n   endif\nend function kim_l\n"}
{"instruction": "Create a Fortran function named vca_get_cluster_dimension to determine the cluster dimension based on the input logical value with_bath. The function takes 1 input parameter of type logical, which is optional. The output parameter is of type integer.", "input": "", "output": "  function vca_get_cluster_dimension(with_bath) result(ncluster)\n    logical,optional :: with_bath\n    logical          :: bool\n    integer          :: ns\n    integer          :: ncluster\n    !\n    bool = .false. ; if(present(with_bath))bool = with_bath\n    !\n    !count how many levels are there in the cluster:\n    ns = nlat*norb\n    if(bool)then\n       ! select case(bath_type)\n       ! case default\n       ns = (nbath+1)*nlat*norb !norb per site plus nbath per orb per site\n       ! case ('hybrid')\n       !    ns = nbath+nlat*norb     !norb per site plus shared nbath sites fixme: maybe add hybrid\n       ! end select\n    endif\n    !\n    !count the spin:\n    ncluster  = nspin*ns\n    !\n  end function vca_get_cluster_dimension\n"}
{"instruction": "Create a Fortran function named lcase that converts the input character string to lowercase. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type character(len=len(cs)).", "input": "", "output": " function lcase (cs) \n!\n    integer, parameter :: co=iachar('a')-iachar('a') ! case offset\n    \n    character(len=*), intent(in) :: cs ! character string \n    character(len=len(cs)) :: lcase \n    character :: ca(len(cs)) ! character array\n    \n    ca=transfer(cs,\"x\",len(cs)) \n    where (ca >= \"a\" .and. ca <= \"z\") ca=achar(iachar(ca)+co) \n    lcase=transfer(ca,cs) \n    return\n    \n end function lcase \n"}
{"instruction": "Write a Fortran function named to_lower that takes a string as input and returns a lowercase version of the input string. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=len(str))'].", "input": "", "output": "elemental function to_lower(str) result(lcstr)\n\n   !> input string\n   character(len=*), intent(in) :: str\n\n   !> lowercase version of string\n   character(len=len(str)):: lcstr\n\n   integer :: ilen, iquote, i, iav, iqc\n   integer, parameter :: offset = iachar('a') - iachar('a')\n\n   ilen = len(str)\n   iquote = 0\n   lcstr = str\n\n   do i = 1, ilen\n      iav = iachar(str(i:i))\n      if (iquote == 0 .and. (iav == 34 .or.iav == 39)) then\n         iquote = 1\n         iqc = iav\n         cycle\n      end if\n      if (iquote == 1 .and. iav==iqc) then\n         iquote=0\n         cycle\n      end if\n      if (iquote == 1) cycle\n      if (iav >= iachar('a') .and. iav <= iachar('z')) then\n         lcstr(i:i) = achar(iav - offset)\n      else\n         lcstr(i:i) = str(i:i)\n      end if\n   end do\n\nend function to_lower\n"}
{"instruction": "Write a Fortran function named lsm_getsign to determine the sign of a real number. The function takes 1 input argument of type real and returns 1 output argument of type real. If the input is less than 0, the function returns -1.0; otherwise, it returns 1.0.", "input": "", "output": "function lsm_getsign(a)\n\timplicit none\n\treal\t\t\t\t\t:: lsm_getsign\n\treal\t\t\t\t\t:: a\n\tlsm_getsign = 1.0\n\tif( a < 0 ) then\n\t\tlsm_getsign = -1.0\n\tend if\n\treturn\nend function lsm_getsign\n"}
{"instruction": "Create a Fortran function named character_is_integer to determine if a single character input represents an integer. The function takes 1 input parameter of type character(len=1) and returns 1 output parameter of type logical. The input character is checked, and the function returns true if it represents an integer, otherwise returns false.", "input": "", "output": "    pure elemental function character_is_integer(c) result(is_integer)\n\n    implicit none\n\n    character(len=1),intent(in) :: c\n    logical                     :: is_integer\n\n    is_integer = c>='0' .and. c<='9'\n\n    end function character_is_integer\n"}
{"instruction": "Provide a Fortran function named \"julian\" to calculate the Julian day corresponding to a given date. The function takes 3 input parameters of type integer representing the day, month, and year. It returns one output parameter of type integer representing the Julian day.", "input": "", "output": "function julian (year, mnth, mday)\n\n!-------------------------------------------------------------------------------\n! name:     julian day\n! purpose:  returns the julian day (1...365,366) corresponding to the date\n!           mnth-mday-year.  note:  this is not the julian date -- only the\n!           day-number.  to get the julian date:\n!              jdate = 1000 * year  +  julian ( year , mnth , mday )\n! revised:  ?? may 1988  modified for romnet.  (???)\n!           ?? aug 1990  modified for rom 2.2:  improved comments; improved\n!                        algorithm using if-then-else if construction. (???)\n!           10 sep 2001  converted to free-form f90.  (t. otte)\n!           07 sep 2011  updated disclaimer.  (t. otte)\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  integer                      :: julian   ! julian day from arguments\n  integer                      :: l\n  integer                      :: m\n  integer,       intent(in)    :: mday     ! day of month [1-31]\n  integer,       intent(in)    :: mnth     ! month of year [1-12]\n  integer                      :: n\n  integer,       intent(in)    :: year     ! four-digit calendar year\n\n  m = mod((mnth + 9), 12)\n  n = (m * 153 + 2) / 5 + mday + 58\n\n  if ( mod(year, 4) /= 0 ) then\n    l = 365\n  else if ( mod(year, 100) /= 0 ) then\n    l = 366\n    n = 1 + n\n  else if ( mod(year, 400) /= 0 )  then\n    l = 365\n  else \n    l = 366\n    n = 1 + n\n  end if\n\n  julian = 1 + mod(n, l)\n\nend function julian\n"}
{"instruction": "Provide a Fortran function named removespaces that replaces multiple spaces in a given string with a single space. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(len(string)).", "input": "", "output": "  function removespaces(string) result(stringout)\n    ! replaces multiple spaces in string by one space\n    character(*), intent(in) :: string\n    character(len(string))   :: stringout\n\n    integer :: i\n\n    stringout = trim(string)\n\n    do\n      i = index(trim(stringout),'  ')\n      if ( i == 0 ) exit\n      stringout = trim(adjustl(stringout(:i-1))) &\n      &           //' '//                        &\n      &           trim(adjustl(stringout(i+1:)))\n    end do\n\n  end function removespaces\n"}
{"instruction": "Provide a Fortran function named element_name that takes an integer as input and returns a character string representing the element symbol for the given atomic number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(2)'].", "input": "", "output": "function element_name( z )\n\n  implicit none\n  integer,intent(in) :: z\n  character(2) :: element_name\n  character(2),save :: name(112)\n!  character(2) :: a\n!  integer :: i\n\n  data name/ \"h\" ,\"he\", &\n             \"li\",\"be\",\"b\" ,\"c\" ,\"n\" ,\"o\" ,\"f\" ,\"ne\", &\n             \"na\",\"mg\",\"al\",\"si\",\"p\" ,\"s\" ,\"cl\",\"ar\", &\n             \"k\" ,\"ca\",\"sc\",\"ti\",\"v\" ,\"cr\",\"mn\",\"fe\",\"co\", &\n             \"ni\",\"cu\",\"zn\",\"ga\",\"ge\",\"as\",\"se\",\"br\",\"kr\", &\n             \"rb\",\"sr\",\"y\" ,\"zr\",\"nb\",\"mo\",\"tc\",\"ru\",\"rh\", &\n             \"pd\",\"ag\",\"cd\",\"in\",\"sn\",\"sb\",\"te\",\"i\" ,\"xe\", &\n             \"cs\",\"ba\",\"la\",\"ce\",\"pr\",\"nd\",\"pm\",\"sm\",\"eu\", &\n             \"gd\",\"tb\",\"dy\",\"ho\",\"er\",\"tm\",\"yb\",\"lu\", &\n             \"hf\",\"ta\",\"w\" ,\"re\",\"os\",\"ir\", &\n             \"pt\",\"au\",\"hg\",\"tl\",\"pb\",\"bi\",\"po\",\"at\",\"rn\", &\n             \"fr\",\"ra\",\"ac\",\"th\",\"pa\",\"u\" ,\"np\",\"pu\",\"am\", &\n             \"cm\",\"bk\",\"cf\",\"es\",\"fm\",\"md\",\"no\",\"lr\",\"rf\", &\n             \"db\",\"sg\",\"bh\",\"hs\",\"mt\",\"ds\",\"rg\",\"cn\" /\n\n  element_name = name(z)\n\n!  z=0\n!  do i=1,size(name)\n!     if ( element_name(1:2) == name(i) ) then\n!        z=i\n!        exit\n!     else\n!        a=name(i)\n!        if ( element_name(1:1) == a(1:len_trim(a)) ) z=i\n!     end if\n!  end do\n\nend function element_name\n"}
{"instruction": "Create a Fortran function named findorder that takes in an array of integers (of length n) and an integer n as input. The function returns an array of integers (also of length n) as output. The purpose of this function is to find the order of elements in the input array. The input parameters are of types ['integer, dimension(n)', 'integer'], and the output parameter is of type ['integer, dimension(n)'].", "input": "", "output": "function findorder(a, n) result (r)\r\ninteger, dimension(n), intent(in) :: a\r\ninteger, intent(in) :: n\r\ninteger, dimension(n) :: b, r\r\ninteger :: i, j, maxvalue, minvalue\r\n\r\n!- we'll be working with the array a but don't want to change it\r\n!- so lets define that the array b is a but we can change b\r\nb = a\r\nr = a\r\n!- find the largest element of the array, \r\n!- then introduce a new element that is greater than the rest\r\nmaxvalue = b(1)\r\ndo i = 1,n\r\n  \tif (maxvalue .lt. b(i)) maxvalue = b(i)\r\nend do\r\nmaxvalue = maxvalue + 1\r\n!- sort through the array b and find the lowest value, and it's index.\r\n!- once the min is found then replace it with our largest value found above.\r\nminvalue = 1\r\ndo i = 1,n\r\n    do j = 1,n\r\n      \tif (b(minvalue) .gt. b(j)) minvalue = j\r\n\tend do\r\n    b(minvalue) = maxvalue\r\n    r(i) = minvalue \r\nend do\r\n\r\nend function findorder\r\n"}
{"instruction": "Create a Fortran function named nwords that takes a string as input and returns the number of words in the string. The input parameter is of type character(len=*), and the output parameter is of type integer.", "input": "", "output": "  function nwords(string)\n    character(len=*), intent(in)  :: string\n    integer :: pos1, pos2, pe\n    integer :: i1,i2,i3,i4 \n    integer :: nwords\n  ! initialize the null and tab characters.\n    pe = len_trim(string) \n    pos1 = 1\n    nwords = 0\n    if (pe == 0) return\n    do \n      i1=index(string(pos1:pe), \",\")\n      i2=index(string(pos1:pe), \" \")\n      i3=index(string(pos1:pe), achar(0))\n      i4=index(string(pos1:pe), achar(9))\n      if (i1 == 0 ) i1 = pe+1\n      if (i2 == 0 ) i2 = pe+1\n      if (i3 == 0 ) i3 = pe+1\n      if (i4 == 0 ) i4 = pe+1\n      if (min(i1,i2,i3,i4) > pe) then\n         nwords = nwords + 1\n         exit\n      end if\n      pos2=min(i1,i2,i3,i4) \n      if (pos2 > 1 ) then\n        nwords = nwords + 1\n      end if\n      pos1 = pos2+pos1\n    end do \n    return\n  end function nwords\n"}
{"instruction": "Create a Fortran function named int_to_char that takes an integer input and returns a left-justified character variable of length 6. The input parameter should be of type integer, and the output parameter should be of type character (len=6).", "input": "", "output": "  function int_to_char( i )\n    !-----------------------------------------------------------------------\n    !\n    ! ... converts an integer number of up to 6 figures\n    ! ... into a left-justifed character variable \n    !\n    implicit none\n    !\n    integer, intent(in) :: i\n    character (len=6)   :: int_to_char\n    character :: c\n    integer   :: n, j, nc\n    logical   :: neg\n    !   \n    nc = 6\n    !\n    if( i < 0 ) then\n       nc  = nc - 1\n       n   = -i\n       neg = .true.\n    else\n       n   = i\n       neg = .false.\n    end if\n    !\n    j = 1\n    do while( j <= nc ) \n       int_to_char(j:j) = char( mod( n, 10 ) + ichar( '0' ) )\n       n = n / 10\n       if( n == 0 ) exit\n       j = j + 1\n    end do\n    !\n    if( j <= nc ) then\n       do n = 1, j/2\n          c = int_to_char( n : n )\n          int_to_char( n : n ) = int_to_char( j-n+1 : j-n+1 )\n          int_to_char( j-n+1 : j-n+1 ) = c\n       end do\n       if( j < nc ) int_to_char(j+1:nc) = ' '\n    else\n       int_to_char(:) = '*'\n    end if\n    !\n    if( neg ) then\n       do n = nc+1, 2, -1\n          int_to_char(n:n) = int_to_char(n-1:n-1)\n       end do\n       int_to_char(1:1) = '-'\n    end if\n    !\n    return\n    !\n  end function int_to_char\n"}
{"instruction": "Create a Fortran function named strdup to duplicate a given string. The function takes 1 input parameter with test_data type ['character (len=*)'] and returns 1 output parameter with test_data type ['character (len=:), allocatable'].", "input": "", "output": "  pure function strdup(string)\n  implicit none\n   character (len=:), allocatable  :: strdup\n\n   character (len=*), intent(in)   :: string\n\n   allocate(character(len=len_trim(string)) :: strdup)\n   strdup = trim(string)\n\n  end function strdup\n"}
{"instruction": "Create a Fortran function named suspicious to determine if a system is suspicious based on the number of edges and grid points. The number of input parameters is 2, and they are of type integer. The output parameter is 1, of type logical.", "input": "", "output": "   function suspicious(nedge,ngp)\n\n     implicit none\n     logical :: suspicious\n     integer :: nedge, ngp, n\n\n     if (ngp .gt. 8) then \n        n = 16-ngp\n     else\n        n = ngp\n     end if\n\n     suspicious = ((nedge .ge. 42).or.                                   &\n                   ((nedge .ge. 36).and.((n .eq. 5).or.(n .eq. 4))).or.  &\n                   ((nedge .ge. 30).and.(n .eq. 3)).or.                  &\n                   ((nedge .ge. 24).and.(n .eq. 2)))\n\n   end function suspicious\n"}
{"instruction": "Create a Fortran function named minmod that takes three input arguments of type real(kind=8) and returns a single output argument of the same type. The function computes the minmod value of the input arguments based on their signs. If all input arguments are non-negative, the minmod value is the minimum of the three arguments. If all input arguments are non-positive, the minmod value is the negative of the minimum absolute value of the three arguments. Otherwise, the minmod value is 0.", "input": "", "output": "  function minmod(a,b,c)\n\n    implicit none\n\n    real(kind=8), intent(in) :: a, b, c \n \n    real(kind=8) :: minmod\n\n    if ( (a .ge. 0.0) .and. (b .ge. 0.0) .and. (c .ge. 0.0) ) then\n      minmod = min(a,b,c)\n    else if ( (a .le. 0.0) .and. (b .le. 0.0) .and. (c .le. 0.0) ) then\n      minmod = -min(abs(a), abs(b), abs(c))\n    else\n      minmod = 0.0\n    end if\n\n  end function\n"}
{"instruction": "Create a Fortran function named map2stran to convert a 3x3 matrix to a vector of strain components. The function takes 2 input parameters: a 3x3 real(8) matrix 'a' and an integer 'ntens'. The output is a real(8) vector 'map2stran' of length 'ntens'.", "input": "", "output": "      function map2stran(a,ntens)\n        implicit none             !===converts d(3,3)  to stran(6) with $\\gamma_{12} = 2 \\epsilon_{12}$ etc.\n        real(8), intent(in), dimension(1:3,1:3) :: a\n        integer, intent(in) :: ntens\n        real(8),  dimension(1:ntens) :: map2stran\n        real(8), dimension(1:6) :: b\n        b =[a(1,1),a(2,2),a(3,3),2*a(1,2),2*a(1,3),2*a(2,3)]\n        map2stran(1:ntens)=b(1:ntens)\n      end function map2stran\n"}
{"instruction": "Write a Fortran function named \"bmw_parallel_context_j\" to calculate the parallel context for a given index, number of rows, and number of columns. The function takes 3 input arguments of type integer: \"index\", \"num_i\", and \"num_j\". It returns 1 output argument of type integer. Remember to use the \"intent(in)\" attribute for the input arguments.", "input": "", "output": "      pure function bmw_parallel_context_j(index, num_i, num_j)\n\n      implicit none\n\n!  declare arguments\n      integer :: bmw_parallel_context_j\n      integer, intent(in) :: index\n      integer, intent(in) :: num_i\n      integer, intent(in) :: num_j\n\n!  start of executable code\n      bmw_parallel_context_j = mod((index - 1)/num_i, num_j) + 1\n\n      end function\n"}
{"instruction": "Create a Fortran function named find_next_unit to find the next available I/O unit number within a specified range. The function takes 2 optional integer input parameters, istart and istop. It returns a single integer value representing the next available unit number.", "input": "", "output": "  function find_next_unit(istart,istop)\n\n    implicit none\n\n    integer, intent(in), optional :: istart, istop\n    integer                       :: find_next_unit\n\n    logical :: opened\n    integer :: i, ifirst, ilast\n\n    ifirst = 20\n    if (present(istart)) ifirst = istart\n    ilast = 1000\n    if (present(istop)) ilast = istop\n    \n    opened         = .true.\n    find_next_unit = -1\n    do i=ifirst, ilast\n       inquire(unit=i, opened=opened)\n       if (.not. opened) then\n          find_next_unit = i\n          exit\n       end if\n    end do\n\n  end function find_next_unit\n"}
{"instruction": "Create a Fortran function named checkargs to validate soil composition parameters. The function takes 3 input arguments of type real: sand, clay, and ompc. It returns 1 output argument of type logical. If any of the input parameters fall outside the valid ranges (sand and clay between 0 and 1, ompc between 0 and 70, and the sum of sand and clay not exceeding 1), the function returns false; otherwise, it returns true.", "input": "", "output": "\tfunction checkargs ( sand, clay, ompc ) result ( ok )\n\n\t    real, intent (in) :: sand, clay, ompc\n\t    logical :: ok\n\n\t    ok = .true.\n\t    if ( sand < 0.0 .or. sand > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( clay < 0.0 .or. clay > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( ompc < 0.0 .or. ompc > 70.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( sand + clay > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\n\tend function checkargs\n"}
{"instruction": "Create a Fortran function named deriv_coeff that takes two real input parameters, d1 and d2, representing grid spacings adjacent to the derivative point. The function returns a real array of dimension 3, deriv_coeff, as output.", "input": "", "output": "  pure function deriv_coeff(d1, d2)\n    real, intent(in)   :: d1, d2      ! grid spacings adj. to derivative pt.\n    real, dimension(3) :: deriv_coeff\n    \n    deriv_coeff(1) = -d2 / (d1 * (d1+d2))\n    deriv_coeff(2) = (d2**2 - d1**2) / (d1 * d2 * (d1+d2))\n    deriv_coeff(3) = d1 / (d2 * (d1+d2))\n  end function deriv_coeff\n"}
{"instruction": "Create a Fortran function named argv to retrieve a specific command-line argument based on the argument number provided. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(len=:),allocatable'].", "input": "", "output": "    function argv(arg_num) result(arg)\n\n    integer,intent(in) :: arg_num !! argument number (>=0)\n    character(len=:),allocatable :: arg !! the command line argument\n\n    integer :: ilen  !! command-line argument string length\n\n    call get_command_argument(arg_num, length=ilen)\n    arg = repeat(' ',ilen)\n    call get_command_argument(arg_num, value=arg)\n\n    end function argv\n"}
{"instruction": "Create a Fortran function named basename that takes a string input and returns the base name of a file path. The input parameter is of type character(len=*), and the output parameter is also of type character(len=len(fname)).", "input": "", "output": "  recursive function basename(fname) result(retchar)\n    character(len=1), parameter :: delimeter = '/'\n    character(len=*), intent(in) :: fname\n    character(len=len(fname)) :: retchar\n\n    integer :: pos\n\n    retchar = fname\n    if (trim(retchar) == delimeter) return  ! basename('/') ! => '/'\n\n    pos = scan(trim(retchar), delimeter, back=.true.)\n    if (pos .le. 0) return  ! no delimiter is found.\n    if (pos < len_trim(retchar)) then\n      retchar = fname(pos+1:len_trim(retchar))\n      return\n    end if\n\n    ! now, the last character of fname is delimiter='/'.\n    ! then, for example, if fname=='abc//', this returns 'abc' (by recursive calls).\n    retchar = basename(fname(1:pos-1))\n  end function basename\n"}
{"instruction": "Create a Fortran function named test_read_text_file to read the contents of a file. It takes 1 input argument of type character(*) for the file name and returns 1 output argument of type character(:), allocatable, target for the file contents.", "input": "", "output": "    function test_read_text_file(file_name) result(file_contents)\n        character(*) :: file_name\n        character(:), allocatable, target :: file_contents\n        integer, target :: file_unit, file_contents_size\n\n        open(newunit=file_unit, file=trim(file_name), action='read', form='unformatted', access='stream')\n        inquire(unit=file_unit, size=file_contents_size)\n        allocate(character(file_contents_size) :: file_contents)\n        read(file_unit) file_contents\n        close(file_unit)\n    end function\n"}
{"instruction": "Create a Fortran function named test_replace_text to replace all occurrences of a specified substring (needle) with a new substring (replacement) within a given string (haystack). The number of input arguments is 3 with test_data types ['character(*)', 'character(*)', 'character(*)'], and the number of output arguments is 1 with the test_data type ['character(len(haystack)+100)'].", "input": "", "output": "    function test_replace_text(haystack, needle, replacement) result(output)\n        character(*) :: haystack, needle, replacement\n        character(len(haystack)+100) :: output\n        integer :: i, in, ir\n\n        output = haystack\n        in = len_trim(needle)\n        ir = len_trim(replacement)\n        do\n           i = index(output, needle(:in))\n           if (i == 0) exit\n           output = output(:i-1) // replacement(:ir) // output(i+in:)\n        end do\n\n    end function\n"}
{"instruction": "Create a Fortran function named tolower to convert all the uppercase characters in a given string to their corresponding lowercase characters. The function takes 1 input parameter of type character (len=*) and returns 1 output parameter of type character (len=len(string)).", "input": "", "output": "function tolower(string) result (tolower_result)\n\n  implicit none\n  character (len=*), intent(in) :: string\n  character (len=len(string)) :: tolower_result\n  integer         :: i,ii\n\n  do i=1,len(string)\n    ii=iachar(string(i:i))\n    select case (ii)\n      case (65:90)\n        tolower_result(i:i)=achar(ii+32)\n      case default\n        tolower_result(i:i)=string(i:i)\n    end select\n  enddo\n\nend function tolower\n"}
{"instruction": "Write a Fortran function named fibonacci to compute the Fibonacci number for a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. If the input integer is less than or equal to 0, the function returns 0; otherwise, it computes the Fibonacci number based on the input.", "input": "", "output": "  recursive function fibonacci(n) result (fib)\n    integer, intent(in) :: n   !< if n <= 0 then 0 is assumed.\n    integer             :: fib !< fibonacci number\n    if (n < 2) then\n      fib = n\n    else\n      fib = fibonacci(n - 1) + fibonacci(n - 2)\n    endif\n  end function fibonacci\n"}
{"instruction": "Create a Fortran function named model_function that takes an array of single-precision floating-point numbers as input and returns a dynamically allocated array of single-precision floating-point numbers as output. The input array is denoted as real(kind=4), dimension(:), and the output array is denoted as real(kind=4), dimension(:), allocatable. Within the function, each element of the output array is calculated by adding 2.0 to the corresponding element of the input array. Additionally, the function displays the input and output arrays in a specific format to the standard output.", "input": "", "output": "function model_function(x) result(y)\n  real(kind=4), dimension(:), intent(in) :: x\n  real(kind=4), dimension(:), allocatable :: y\n  integer :: i\n  allocate(y(size(x, 1)))\n  do i = 1, size(x, 1)\n     y(i) = x(i) + 2.0\n  end do\n  write(*, '(\"model b: [\")', advance=\"no\")\n  do i = 1, size(x, 1)\n     write(*, '(f10.5,\" \")', advance=\"no\") x(i)\n  end do\n  write(*, '(\"] -> [\")', advance=\"no\")\n  do i = 1, size(y, 1)\n     write(*, '(f10.5,\" \")', advance=\"no\") y(i)\n  end do\n  write(*, '(\"]\")')\nend function model_function\n"}
{"instruction": "Create a Fortran function named strcomp to compare two strings and return a logical result. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type logical. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "function strcomp(sa, sb) result(r)\n\n    character(len=*), intent(in) :: sa\n    character(len=*), intent(in) :: sb\n\n    logical :: r\n    integer :: i\n\n    r = .true.\n    do i = 1,merge(len(sa),len(sb),len(sa) < len(sb))     \n        if (sa(i:i) /= sb(i:i)) then\n            r = .false.\n            exit\n        end if\n    end do\n\nend function\n"}
{"instruction": "Create a Fortran function named foo that takes in two integer input parameters. The number of input arguments is 2 and the test_data type is [integer, integer]. The function returns an integer array of size n as output. The number of output arguments is 1 and the test_data type is [integer, dimension(n)].", "input": "", "output": "  function foo (n, calls)\n    integer :: i, n, calls\n    integer, dimension (n) :: foo\n\n    calls = calls + 1\n    foo = (/ (i + 3, i = 1, n) /)\n  end function foo\n"}
{"instruction": "Create a Fortran function named lower to convert the input string to lowercase. It takes 1 input argument of type character(*) and returns 1 output argument of type character(len(str)).", "input": "", "output": "pure function lower (str) result (string)\n    implicit none\n    character(*), intent(in) :: str\n    character(len(str))      :: string\n    integer :: ic, i\n\n    character(26), parameter :: cap = 'abcdefghijklmnopqrstuvwxyz'\n    character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n\n    string = str\n    do i = 1, len_trim(str)\n        ic = index(cap, str(i:i))\n        if (ic > 0) string(i:i) = low(ic:ic)\n    end do\nend function\n"}
{"instruction": "Create a Fortran function named contract_ik_jk to perform a contraction operation on two second-rank tensors. The function takes 2 input parameters of type real, dimension(3,3) and returns 1 output parameter of type real, dimension(3,3).", "input": "", "output": "  function contract_ik_jk ( a, b ) result ( c )\n    implicit none\n    real, dimension(3,3)             :: c ! returns a second-rank contraction\n    real, dimension(3,3), intent(in) :: a ! of a second-rank tensor\n    real, dimension(3,3), intent(in) :: b ! with another second-rank tensor\n    integer :: i, j\n\n    ! free indices i, j, sum over index k (if b symmetric, would be equivalent to built-in matmal)\n    do i = 1, 3\n       do j = 1, 3\n          c(i,j) = sum ( a(i,:) * b(j,:) )\n       end do\n    end do\n\n  end function contract_ik_jk\n"}
{"instruction": "Create a Fortran function named strfromlogical to convert a logical value to a corresponding string representation. The function takes 1 input argument of type logical and returns 1 output argument of type character(len=5).", "input": "", "output": "    function strfromlogical(l) result(str)\n        logical, intent(in) :: l            !! the logical to convert to a string\n        character(len=5) :: str             !! the string to return\n        if (l) then\n            str = \"true\"\n        else\n            str = \"false\"\n        end if\n    end function\n"}
{"instruction": "Create a Fortran function named icsrcasea to calculate a value based on the input parameters phih, ssh, and xk2, all of which are of type double precision. The function returns a single value of type double precision.", "input": "", "output": "           function icsrcasea(phih,ssh,xk2)\n           implicit none\n           double precision:: phih,ssh,xk2,icsrcasea\n           double precision:: bb,cc,yh,phpy\n           bb = 2*phih+phih**3/3-2*ssh\n           cc = phih**2+phih**4/12-2*ssh*phih\n           yh = (-bb+sqrt(bb*bb-4*cc))/2\n           phpy = (phih+yh)\n           icsrcasea = xk2*(-(2*phpy+phih**3)/&\n                    (phpy**2+phih**4/4)+1.0d0/ssh)\n           end function icsrcasea\n"}
{"instruction": "Create a Fortran function named reverse to recursively reverse a given string. The function takes 1 input parameter of type character (*) and returns 1 output parameter of type character (len (string)).", "input": "", "output": "  recursive function reverse (string) result (res)\n\n    implicit none\n    character (*), intent (in) :: string\n    character (len (string)) :: res\n\n    if (len (string) == 0) then\n      res = ''\n    else\n      res = string (len (string) :) // reverse (string (: len (string) - 1))\n    end if\n\n  end function reverse\n"}
{"instruction": "Create a Fortran function named string_pleural that takes an integer input argument and returns a single character output. The input argument is of type integer, and the output is of type character with a length of 1. The function's purpose is to return \"s\" if the input integer is not equal to 1, otherwise, it returns a space character.", "input": "", "output": "     function string_pleural( val )\n\n!   given an integer val, returns \"s\" if v /= 0, otherwise returns \" \"\n\n     character ( len = 1 ) :: string_pleural\n\n!--------------------------------\n!   d u m m y   a r g u m e n t\n!--------------------------------\n\n     integer, intent( in ) :: val\n\n     if ( val /= 1 ) then\n       string_pleural = \"s\"\n     else\n       string_pleural = \" \"\n     end if\n\n     return\n\n\n      end function string_pleural\n"}
{"instruction": "Write a Fortran function named convert, which takes an integer as input and returns a corresponding string based on the following rules: \n- If the input is divisible by 3, return \"pling\".\n- If the input is divisible by 5, return \"plang\".\n- If the input is divisible by 7, return \"plong\".\n- If the input does not satisfy any of the above conditions, return the input as a string.\nThe number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(20)'].", "input": "", "output": "  function convert(i)\n    implicit none\n    integer :: i\n    character(20) :: convert\n\n    convert = ''\n\n    if ( mod(i,3) .eq. 0 ) then\n      convert = 'pling'\n    end if\n    if ( mod(i,5) .eq. 0 ) then\n      convert = trim(convert)//'plang'\n    end if\n    if ( mod(i,7) .eq. 0 ) then\n      convert = trim(convert)//'plong'\n    end if\n\n    if (convert .eq. '') then\n      write( convert, '(i20)' ) i\n      convert = trim(adjustl(convert))\n    end if\n\n  end function convert\n"}
{"instruction": "Create a Fortran function called \"wrap\" to handle wrapping of integer values within a specified range. The function should accept 2 integer input parameters and return 1 integer output parameter. The input parameters should be of type integer and the output parameter should also be of type integer.", "input": "", "output": "pure function wrap(x, l)\ninteger, intent(in) :: x,l\ninteger :: wrap\n\nif (x >= l) then\n    wrap = x - l\nelse if (x < 0) then\n    wrap = x + l\nelse\n    wrap = x\nendif\nend function\n"}
{"instruction": "Write a Fortran function named finite_diff to calculate the finite difference using a 3-point stencil. The function has 6 input parameters of type real(kind=8), integer and 1 output parameter of type real(kind=8).The number of input arguments is 6 and the test_data type is [real(kind=8), real(kind=8), real(kind=8), real(kind=8), integer, integer].The number of output arguments is 1 and the test_data type is [real(kind=8)].", "input": "", "output": "pure function finite_diff(y,yp,ym,dx,maskp,maskm)\nreal(kind=8), intent(in) :: y,yp,ym,dx\ninteger, intent(in) :: maskp,maskm\nreal(kind=8) :: finite_diff\n\nif (maskm == 1 .and. maskp == 1) then\n    finite_diff = (yp-ym)/(2.*dx)\nelse if (maskm == 0 .and. maskp == 1) then\n    finite_diff = (yp-y)/dx\nelse if (maskm == 1 .and. maskp == 0) then\n    finite_diff = (y-ym)/dx\nelse\n    finite_diff = 0.\nend if\nend function\n"}
{"instruction": "Provide a Fortran function named tolower to convert a given input string to lowercase. The function should have 1 input parameter of type character(len=*), denoted as string, and 1 output parameter of type character(len=len(string)). Use the imperative tone and be concise.", "input": "", "output": "function tolower( string )\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: tolower\n\n    character(len=26), parameter :: upper = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=26), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz'\n\n    integer                    :: i\n    integer                    :: k\n    integer                    :: length\n\n    length  = len(string)\n    tolower = string\n    do i = 1,length\n        k = index( upper, string(i:i) )\n        if ( k > 0 ) then\n           tolower(i:i) = lower(k:k)\n        endif\n    enddo\nend function tolower\n"}
