[{"instruction": "Create a Fortran function named random_hermitian to generate an order n Hermitian matrix with random complex entries. The function takes 1 input argument of type integer and returns a 2D array of complex*16 type with dimensions (n, n) as the output. The input argument specifies the order of the Hermitian matrix to be generated.", "input": "", "output": "function random_hermitian(n)\n! generates an order n hermitian matrix with random entries x+iy\n! where each x and y are uniformly distributed between -1 and 1\nimplicit none\ninteger :: n, ii, jj\ncomplex*16, dimension(n,n) :: random_hermitian\nreal*8, dimension(n,n) :: a, b\n\n    call random_number(a)\n    ! rescaling into an element in (-1,1)\n    a = 2*a - 1\n    call random_number(b)\n    ! rescaling into an element in (-1,1)\n    b = 2*b - 1\n\n    ! populating the matrix\n    do ii = 1,n\n        do jj = 1,n\n            ! replacing entries in the lower triangle\n            if ((jj.gt.ii).and.(ii.lt.n)) then\n                a(jj,ii) = a(ii,jj)\n                ! the imaginary part is negative, to achieve hermicity\n                b(jj,ii) = -b(ii,jj)\n            end if\n            ! cast into a complex entry\n            random_hermitian(ii,jj) = complex(a(ii,jj),b(ii,jj))\n        end do\n    end do\n\nend function random_hermitian\n"}, {"instruction": "Create a Fortran function named count_sub_string that takes two input arguments of type character(len=*) and returns the number of occurrences of the second string within the first string as an integer. The input argument types are ['character(len=*)', 'character(len=*)'] and the output argument type is ['integer'].", "input": "", "output": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}, {"instruction": "Create a Fortran function called near to handle wrap-around correction when evaluating distances between points. The function takes 2 input parameters of type real*8, named dx and domain. It returns 1 output parameter of type real*8. When calling the function, ensure to provide the input parameters in the order (dx, domain) and capture the returned value in a variable of the appropriate type.", "input": "", "output": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}, {"instruction": "Create a Fortran function named vca_get_bath_dimension to calculate the size of a bath based on the specified inputs. The function takes 1 input argument of type integer, which is optional. The output is a single integer representing the bath size.", "input": "", "output": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}, {"instruction": "Create a Fortran function named \"foo\" that takes an integer input parameter and returns an integer result. The function adds 10 to the input parameter and assigns the result to the output parameter. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"goo\" that takes a single real number as input and returns another real number. Inside the function, add 18.5 to the input number and assign the result to the output parameter. Use the !$omp declare simd directive to declare the function for vectorization.", "input": "", "output": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}, {"instruction": "Create a Fortran function named file_line_num to determine the number of lines in a file. The function has 1 input parameter of type character (*), denoted as filename. The output of the function is a single integer representing the number of lines in the file.", "input": "", "output": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}, {"instruction": "Create a Fortran function named \"inttotext\" to convert an integer to a text representation. The function should take 1 input argument of type integer and return 1 output argument of type character with a maximum length of \"maxtextlength\".", "input": "", "output": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}, {"instruction": "Create a Fortran function named substrcount that takes two strings as input arguments with the test_data type ['character(len=*)', 'character(len=*)']. The function calculates and returns the number of occurrences of the second string within the first string as an integer with the test_data type ['integer'].", "input": "", "output": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named int2str to convert an integer to a character string. The function takes 1 input argument of type integer and returns 1 output argument of type character(12).", "input": "", "output": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}, {"instruction": "Provide a Fortran function named floorsqrt that calculates the largest integer value whose square is less than or equal to a given input integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}, {"instruction": "Create a Fortran function named floorcurt that takes an integer input and returns the largest integer whose cube does not exceed the input. The number of input parameters is 1 with a test_data type of ['integer'], and the number of output parameters is 1 with a test_data type of ['integer'].", "input": "", "output": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}, {"instruction": "Write a Fortran function named \"lower_case\" to convert a given input string to lowercase. The function takes 1 input parameter of type \"character(len=*)\" and returns 1 output parameter of type \"character(len=:), allocatable\".", "input": "", "output": "    function lower_case(string)\n        character(len=*), intent(in) :: string\n        character(len=:), allocatable :: lower_case\n\n        !! locals\n        integer :: code\n        integer :: i\n\n        allocate(lower_case, source=string)\n        do i = 1, len(string)\n            code = iachar(string(i:i))\n            select case (code)\n            case (65:90)\n                lower_case(i:i) = char(code + 32)\n            end select\n        end do\n\n    end function lower_case\n"}, {"instruction": "Write a Fortran function named arth_i that generates an arithmetic sequence of integers. The function takes 3 input parameters of type integer: first, increment, and n. It returns an array of integers of length n.", "input": "", "output": " function arth_i(first,increment,n)\n  integer, intent(in) :: first,increment,n\n  integer, dimension(n) :: arth_i\n  integer :: k,k2,temp\n  integer, parameter :: npar_arth=16,npar2_arth=8\n\n  if (n > 0) arth_i(1) = first\n  if (n <=  npar_arth) then\n   do k = 2,n\n    arth_i(k) = arth_i(k-1)+increment\n   end do\n  else\n   do k = 2,npar2_arth\n    arth_i(k) = arth_i(k-1)+increment\n   end do\n   temp = increment*npar2_arth\n   k = npar2_arth\n   do\n    if (k >=  n) exit\n    k2 = k+k\n    arth_i(k+1:min(k2,n)) = temp+arth_i(1:min(k,n-k))\n    temp = temp+temp\n    k = k2\n   end do\n  end if\n end function arth_i\n"}, {"instruction": "Create a Fortran function named outerdiff_i that takes two one-dimensional integer arrays as input. The input arrays should be of any size. The function produces one output, an integer array with dimensions equal to the sizes of the input arrays. The purpose of the function is to calculate the outer difference between the elements of the input arrays and assign the result to the output array.", "input": "", "output": " function outerdiff_i(a,b)\n implicit none\n  integer, dimension(:), intent(in) :: a,b\n  integer, dimension(size(a),size(b)) :: outerdiff_i\n  outerdiff_i  =  spread(a,dim = 2,ncopies = size(b)) - &\n  spread(b,dim = 1,ncopies = size(a))\n end function outerdiff_i\n"}, {"instruction": "Create a Fortran function named in_carpet to check if a point is inside a Sierpinski carpet. The function takes 2 input parameters of type integer and returns 1 output parameter of type logical. The input parameter test_data type is ['integer', 'integer'], and the output parameter test_data type is ['logical'].", "input": "", "output": "function in_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do\n    if(x == 0 .or. y == 0) then\n      in_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      in_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named dbend that calculates the bending of a value using the formula dbend=amp*tanh((y-0d0)/wid). The function accepts 3 input arguments of type real(8) - y, amp, and wid, and returns 1 output argument of type real(8).", "input": "", "output": "  function dbend(y,amp,wid)\n    implicit none\n    real(8)::y,amp,wid,dbend\n    dbend=amp*tanh((y-0d0)/wid)\n  end function\n"}, {"instruction": "Create a Fortran function named rtnewt that iteratively calculates the root of a function using the Newton-Raphson method. The function has 6 input parameters of type real(8) - prev, eps, nst, p, t0, and sum. It has 1 output parameter of type real(8). The function iteratively approximates the root of a given function using the provided initial guess and termination criteria. If the maximum number of iterations is reached, the function stops and outputs an error message.", "input": "", "output": "  function rtnewt(prev,eps,nst,p,t0,sum)\n    integer::j\n    integer,parameter::jmax=20\n    real(8)::rtnewt,prev,eps\n    real(8)::f,df,dx,sum,nst,p,t0\n    rtnewt=prev\n    !write(*,*) rtnewt\n    do j=1,jmax\n      x=rtnewt\n      f=x+ieta*sigma0*(mu0+(a0-b0)*log(x/vref))-vpl\n      df=1+ieta*sigma0*(a0-b0)/x\n      dx=f/df\n      rtnewt=rtnewt-dx\n      !write(*,*) rtnewt\n      if(abs(dx).lt.eps) return\n    end do\n    write(*,*) 'maximum iteration'\n    stop\n  end function\n"}, {"instruction": "Create a Fortran function named file_exist to check the existence of a file. The function takes 1 input parameter with the test data type ['character(len=*)'] and returns 1 output parameter with the test data type ['logical'].", "input": "", "output": "function file_exist(filename)\n\n\timplicit none\n\tcharacter(len=*), intent (in) :: filename\n\tlogical                       :: file_exist\n\t\n\tinquire(file=trim(adjustl(filename)), exist=file_exist)\n\n  return\nend function file_exist\n"}, {"instruction": "Create a Fortran function named arraytst with 3 input parameters of type integer. The test_data type is ['integer', 'integer', 'integer']. The function returns a 3-dimensional array of real numbers with kind=8 and allocatable dimension. The number of output parameters is 1 and the test_data type is ['real(kind=8), dimension(:,:,:), allocatable'].", "input": "", "output": "function arraytst(a,b,c)\n\n  implicit none\n  \n  real(kind=8), dimension(:,:,:), allocatable :: arraytst\n  integer, intent(in) :: a,b,c\n  \n  allocate(arraytst(a,b,c))\n  \n  arraytst = (dble(a)/dble(b))*dble(c)\n  \n  return\n  \nend function arraytst\n"}, {"instruction": "Create a Fortran function named skip_comma_and_spaces that takes two input parameters of type character and integer. The test_data type for input is ['character(*)', 'integer']. The function returns one output parameter of type logical. The function aims to skip over commas and spaces in a string, returning the remaining substring and a logical value indicating whether the operation was successful.", "input": "", "output": "  function skip_comma_and_spaces(string, pos) result (ok)\n    character(*) :: string\n    integer :: pos, length\n    logical :: ok\n    logical :: comma_ok\n    comma_ok = .true.\n    ok = .true.\n    length = len_trim(string)\n    if (pos.gt.length) then\n      ok = .true.\n      string = \"\"\n    else\n      do\n        ! only one comma\n        if (string(pos:pos).eq.\",\".and.comma_ok) then\n          comma_ok = .false.\n        ! end on a non-space\n        else if (string(pos:pos).ne.\" \") then\n          exit\n        else if (pos.eq.length) then\n          ok = .false.\n          exit\n        end if\n        pos = pos + 1\n      end do\n      string = adjustl(string(pos:))\n    end if\n  end function skip_comma_and_spaces\n"}, {"instruction": "Create a Fortran function named os_map that takes two input arguments of type double precision. The input arguments are non_lin_wt and lin_wt. The function computes and returns a single output of type double precision. The function calculates the result by performing arithmetic operations on the input arguments and assigning the result to the variable os_map.", "input": "", "output": "function os_map(non_lin_wt, lin_wt)\n\n    implicit none\n    double precision :: os_map\n    double precision, intent(in) :: non_lin_wt, lin_wt\n    double precision :: num, denom\n\n    num = non_lin_wt*(lin_wt + lin_wt*lin_wt - 3.0d0*lin_wt*non_lin_wt + non_lin_wt*non_lin_wt)\n    denom = lin_wt*lin_wt + non_lin_wt*(1.0d0-2.0d0*lin_wt)\n\n    os_map = num/denom\n\nend function os_map\n"}, {"instruction": "Create a Fortran function named test_intent_parameters_none. This function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function adds 15 to the input parameter and assigns the result to the output parameter. Finally, the function returns 0.", "input": "", "output": "                function test_intent_parameters_none(input, output)\n                        integer :: input, output\n                        integer :: test_intent_parameters_none\n\n                        output = input + 15\n\n                        test_intent_parameters_none = 0\n\n                end function test_intent_parameters_none\n"}, {"instruction": "Write a Fortran function named gr2rank to determine the rank of a given global row number based on the number of tasks and the total number of rows. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "function gr2rank( globrow ) result ( rank )\n  !-----------------------------------------------------------------------------\n  ! formal arguments\n  !-----------------------------------------------------------------------------\n  integer, intent(in) :: globrow !<row number in original input (level 1)\n  integer :: rank !<returned: rank holding the given global row\n\n  !-----------------------------------------------------------------------------\n  ! local variables\n  !-----------------------------------------------------------------------------\n  integer :: m     !average integral number of rows per processor\n  integer :: spill !spill over beyond prefect loading of rows to processors\n  integer :: p     \n  integer :: n     !<total number of rows in original input (level 1)\n\n  p = numtasks\n  n = nblk_rows\n\n  if ( (globrow .lt. 1) .or. (globrow .gt. n) ) then\n    rank = -1\n  else\n    m = n / p\n    spill = mod( n, p )\n    if ( globrow .le. (m+1)*spill ) then\n      rank = (globrow-1)/(m+1)\n    else\n      rank = (globrow-1 - (m+1)*spill)/m + spill\n    endif\n  endif\n\n  return\nend function gr2rank\n"}, {"instruction": "Provide a Fortran function named binomialcoefficient to calculate the binomial coefficient using the input integers m and n. The number of input arguments is 2, and the test_data type is ['integer', 'integer']. The number of output arguments is 1, and the test_data type is ['double precision'].", "input": "", "output": "function binomialcoefficient(m, n) result (biocoeff)\n\n    integer, intent(in)::m,n\n    double precision::biocoeff\n\n    integer, parameter::size=30\n    integer, save::bc(size,size)=0\n    logical, save::initialized=.false.;\n\n    integer::i,j,k\n\n    if (.not.initialized) then\n        do i=1,size\n        bc(i,1)=one\n        bc(i,2:size)=zero\n        end do\n        do i=2, size\n        do j=2, i\n        bc(i,j)=bc(i-1,j-1)+bc(i-1,j)\n        end do\n        end do\n\n        initialized=.true.\n    end if\n\n    biocoeff=one*bc(m,n)\n\nend function binomialcoefficient\n"}, {"instruction": "Write a Fortran function named is_dtype_format_array_c that takes one input argument of type c_ptr and returns one output argument of type integer(kind=c_int). This function is used to determine whether the input type structure is an array format. Use the bind attribute to specify the name \"is_dtype_format_array_f\" for this function.", "input": "", "output": "     function is_dtype_format_array_c(type_struct) result(out) &\n          bind(c, name=\"is_dtype_format_array_f\")\n       use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n       implicit none\n       type(c_ptr), value, intent(in) :: type_struct\n       integer(kind=c_int) :: out\n     end function is_dtype_format_array_c\n"}, {"instruction": "Create a Fortran function named create_dtype_empty_c that returns a c_ptr type. The function takes one input parameter of type logical(kind=c_bool) by value.", "input": "", "output": "     function create_dtype_empty_c(use_generic) result(out) &\n          bind(c, name=\"create_dtype_empty_f\")\n       use, intrinsic :: iso_c_binding, only: c_ptr, c_bool\n       implicit none\n       logical(kind=c_bool), value, intent(in) :: use_generic\n       type(c_ptr) :: out\n     end function create_dtype_empty_c\n"}, {"instruction": "Create a Fortran function named get_random_pos to generate a random integer between 1 and the specified size. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of test_data type ['integer'], and the output parameter is of test_data type ['integer'].", "input": "", "output": "   function get_random_pos(nsize)\n      integer, intent(in) :: nsize\n      integer :: get_random_pos\n      real :: random\n      !random number between 0 and 1\n      call random_number(random)\n      !random int between 1 and nsize\n      ! n + floor((m+1-n)*urandom)\n      get_random_pos = 1 + floor(real(nsize)*random)\n   end function get_random_pos\n"}, {"instruction": "Create a Fortran function called mandelbrot to calculate the number of iterations required for the given complex coordinates to escape the Mandelbrot set within the specified maximum iterations. The input parameters are 3, with test_data types ['real', 'real', 'integer']. The output parameter is 1, with a test_data type of ['integer'].", "input": "", "output": "  function mandelbrot(x, y, maxit) result (it)\n    implicit none\n    real,    intent(in) :: x, y\n    integer, intent(in) :: maxit\n    integer :: it\n    complex :: z, c\n    z = cmplx(0, 0)\n    c = cmplx(x, y)\n    it = 0\n    do while (abs(z) < 2.0 .and. it < maxit)\n       z = z*z + c\n       it = it + 1\n    end do\n  end function mandelbrot\n"}, {"instruction": "Write a Fortran function named is_palindro to check if a given string is a palindrome. The function should take 1 input parameter of type character(len=*), and the output should be a single logical value.", "input": "", "output": "function is_palindro(t)\n  logical :: is_palindro\n  character(len=*), intent(in) :: t\n\n  integer :: i, l\n\n  l = len(t)\n  is_palindro = .false.\n  do i=1, l/2\n     if ( t(i:i) /= t(l-i+1:l-i+1) ) return\n  end do\n  is_palindro = .true.\nend function is_palindro\n"}, {"instruction": "Write a Fortran function named is_palindro2 to check whether a given string is a palindrome. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type logical.", "input": "", "output": "function is_palindro2(t) result(isp)\n  logical :: isp\n  character(len=*), intent(in) :: t\n\n  character(len=len(t)) :: s\n  integer :: i\n\n  forall(i=1:len(t)) s(len(t)-i+1:len(t)-i+1) = t(i:i)\n  isp = ( s == t )\nend function is_palindro2\n"}, {"instruction": "Write a Fortran function named begtrm, which takes a string as input and returns the position of the first non-space character in the string. The input parameter is 1 and the test_data type is ['character(*)'], while the output parameter is 1 and the test_data type is ['integer'].", "input": "", "output": "function begtrm(val)\n!\nimplicit none\n!\n\n!\ncharacter(*) :: val\ninteger :: begtrm\n!\n! local variables\n!\ninteger :: idx\ninteger :: len\n!\n!     + + + argument declarations + + +\n!\n!     + + + argument definitions + + +\n!\n!     + + + parameters + + +\n!\n!     + + + local variables + + +\n!\n!\n!     + + + end specifications + + +\n!\ndo idx = 1,len(val)\n  if (val(idx:idx).ne.' ') then\n     begtrm = idx\n     return\n  end if\nend do\n! \nbegtrm = 1\n!\nend function begtrm\n"}, {"instruction": "Write a Fortran function named pythag that calculates the hypotenuse of a right-angled triangle using the given lengths of the two shorter sides. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "      function pythag(a,b)\n      implicit none\n      double precision ::  a, b, pythag \n      double precision :: absa, absb\n      absa=abs(a)\n      absb=abs(b)\n      if (absa > absb) then\n         pythag=absa*sqrt(1.+(absb/absa)**2)\n      else\n         if(absb == 0.) then\n            pythag=0.\n         else\n            pythag=absb*sqrt(1.+(absa/absb)**2)\n         endif\n      endif\n\n      end function pythag\n"}, {"instruction": "Create a Fortran function named binomial to compute the binomial coefficient of two given integers. The function should have 2 input parameters of type integer*8 and intent(in), and 1 output parameter of type integer*8. The input parameters should be named n and k, and the output parameter should be named binomial.", "input": "", "output": "  pure function binomial(n,k)\n    implicit none\n    integer*8, intent(in) :: n,k\n    integer*16            :: temp\n    integer*8             :: i,binomial\n\n    temp=1\n    do i=n-k+1,n\n       temp=temp*i\n    end do\n    do i=1,n-k\n       temp=temp/i\n    end do\n    binomial=temp\n  end function binomial\n"}, {"instruction": "Create a Fortran function named gcd that calculates the greatest common divisor (GCD) of two 8-byte integer numbers. The function takes 2 input arguments of type integer*8 and returns 1 output argument of type integer, representing the GCD of the input numbers.", "input": "", "output": "  pure function gcd(a0,b0)\n    implicit none\n    integer*8, intent(in) :: a0, b0\n    integer               :: a, b, t, gcd\n\n    a=a0\n    b=b0\n    do while (b /= 0)\n       t=b\n       b=mod(a,b)\n       a=t\n    end do\n    gcd=a\n  end function gcd\n"}, {"instruction": "Create a Fortran function named is_factor to determine if a given integer is a factor of another integer. The function takes 2 input parameters of type integer*8 and integer, and 1 output parameter of type logical.", "input": "", "output": "  pure function is_factor(f,n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer, intent(in)   :: f\n    logical               :: is_factor\n    is_factor = (mod(n,f)==0)\n  end function is_factor\n"}, {"instruction": "Create a Fortran function named is_prime to determine whether a given integer is a prime number. The function takes 1 input parameter of type integer*8, and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_prime(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer               :: i\n    logical               :: is_prime\n\n    if (n == 1) then\n       is_prime = .false.\n    else\n       is_prime = .true.\n       do i=2,min(n-1,ceiling(sqrt(dble(n))))\n          if (mod(n,i) == 0) then\n             is_prime = .false.\n             exit\n          end if\n       end do\n    end if\n  end function is_prime\n"}, {"instruction": "Create a Fortran function named number_length to calculate the length of a given integer number. The function takes 1 input parameter of type integer*8. The output is 1 parameter of type integer.", "input": "", "output": "  pure function number_length(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer               :: number_length\n    real*8                :: temp\n\n    temp=log10(dble(n))\n    if (mod(temp,1.0_8)==0.0_8) temp=temp+0.01\n    number_length = ceiling(temp)\n  end function number_length\n"}, {"instruction": "Create a Fortran function named sum_of_divisors to calculate the sum of divisors of a given integer. The function should take 1 input parameter of type integer*8 and return 1 output parameter of type integer*8.", "input": "", "output": "  pure function sum_of_divisors(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer*8             :: i\n    integer*8             :: sum_of_divisors\n\n    sum_of_divisors=1\n    do i=2,n-1\n       if (mod(n,i) == 0) then\n          sum_of_divisors=sum_of_divisors+i\n       end if\n    end do\n  end function sum_of_divisors\n"}, {"instruction": "Create a Fortran function named is_square to determine if a given integer is a perfect square. The function should take 1 input parameter of type integer and return 1 output parameter of type logical.", "input": "", "output": "  pure function is_square(m)\n    implicit none\n    integer, intent(in) :: m\n    logical             :: is_square\n\n    is_square=mod(sqrt(dble(m)),1.0)==0.0\n\n  end function is_square\n"}, {"instruction": "Write a Fortran function named is_heptagonal to determine if a given integer is a heptagonal number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_heptagonal(m)\n    implicit none\n    integer, intent(in) :: m\n    double precision    :: temp\n    logical             :: is_heptagonal,plus,minus\n\n    temp=(3 + sqrt(9.0 + 4*5*2*m))/10\n    plus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    temp=(3 - sqrt(9.0 + 4*5*2*m))/10\n    minus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    is_heptagonal=plus .or. minus\n\n  end function is_heptagonal\n"}, {"instruction": "Create a Fortran function named is_octagonal to determine if a given integer is an octagonal number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_octagonal(m)\n    implicit none\n    integer, intent(in) :: m\n    double precision    :: temp\n    logical             :: is_octagonal,plus,minus\n\n    temp=(2 + sqrt(4.0 + 4*3*m))/6\n    plus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    temp=(2 - sqrt(4.0 + 4*3*m))/6\n    minus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    is_octagonal=plus .or. minus\n\n  end function is_octagonal\n"}, {"instruction": "Write a Fortran function named rot_b to calculate the value of b based on the input parameters m and alpha. The number of input parameters is 2, and their data types are ['integer', 'double precision']. The number of output parameters is 1, and its data type is ['double precision'].", "input": "", "output": "  function rot_b(m, alpha) result(b)\n\n    implicit none\n\n    integer,          intent(in) :: m\n    double precision, intent(in) :: alpha\n    double precision             :: b\n\n    if (m < 0) then\n       b = cos(dble(m)*alpha)\n       if (abs(mod(m,2)) == 1) b = -b\n    else if (m > 0) then\n       b = sin(dble(m)*alpha)\n       if (abs(mod(m,2)) == 0) b = -b\n    else\n       b = 0.0d0\n    end if\n\n  end function rot_b\n"}, {"instruction": "Create a Fortran function named f1 that takes six input parameters, including three integer value parameters and three regular integer parameters. The output is a single integer. The purpose of the function is to increment each input parameter by 1, then calculate the sum of all six parameters, and return the result.", "input": "", "output": "function f1 (a, b, c, d, e, f)\n  integer, value :: a, b, c\n  integer :: d, e, f, f1\n!$omp declare simd (f1) uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n  a = a + 1\n  b = b + 1\n  c = c + 1\n  d = d + 1\n  e = e + 1\n  f = f + 1\n  f1 = a + b + c + d + e + f\nend function f1\n"}, {"instruction": "Write a Fortran function named gauss_wt to calculate the Gaussian weight based on the input parameter lag. The input parameter is of type real, and the output parameter is also of type real. Ensure that the function name, number and type of input and output parameters are as specified.", "input": "", "output": "function gauss_wt(lag)\nimplicit none\nreal                                :: lag,gauss_wt\nreal,parameter                      :: sigma=1000.0 !1000 km \n!---\ngauss_wt=exp(-(lag**2.0/(2.0*sigma**2.0)))  \n!---\nreturn\n!---\nend function gauss_wt\n"}, {"instruction": "Create a Fortran function named obs_error that takes a single input parameter of type character*128. The function returns a real number. The function retrieves the observation error corresponding to the input satellite name from a predefined lookup table and returns it.", "input": "", "output": "function obs_error(sat)\nimplicit none\n!---in\ncharacter*128                :: sat\n!---out\nreal                         :: obs_error\n!==================================================\n! observation errors are from breada et al,. (2019)\n! br\u00eada, j. p. l. f., paiva, r. c. d., bravo, j. m., passaia, o. a., & moreira, d. m. (2019). \n! assimilation of satellite altimetry data for effective river bathymetry. water resources research, \n! 55(9), 7441\u20137463. doi:10.1029/2018wr024010\n!--------------------------------------------------\n! satellite  |  error (m)\n! -----------------------\n!envisat     |   0.30\n!jason2      |   0.28\n!jason3      |   0.28\n!sentinel3a  |   0.30*\n!------------------------\n! *1.watson, c.; legresy, b.; king, m.; deane, a. absolute altimeter bias results from bass strait, \n! australia.in proceedings of the ocean surface topography science team meeting 2018, ponta delgada, \n! portugal,24\u201329 september 2018.\n! *2.bonnefond, p.; exertier, p.; laurain, o.; guinle, t.; f\u00e9m\u00e9nias, p. corsica:  \n! a 20-yr multi-mission absolutealtimeter calibration site.  in proceedings of the ocean surface \n! topography science team meeting 2018,ponta delgada, portugal, 24\u201329 september 2018.\n! *3.garcia-mondejar, a.; zhao, z.; rhines, p. sentinel-3 range and datation calibration with crete transponder.\n! in proceedings of the 25 years of progress in radar altimetry, ponta delgada, portugal, 24\u201329 september 2018.\n! *4.mertikas, s.; donlon, c.; f\u00e9m\u00e9nias, p.; mavrocordatos, c.; galanakis, d.; tripolitsiotis, a.; frantzis, x.; \n! kokolakis, c.; tziavos, i.n.; vergos, g.; guinle, t. absolute calibration of the european sentinel-3a surface \n! topography mission over the permanent facility for altimetry calibration in west crete, greece. remote sens. 2018, 10, 1808.\n! =================================================\nobs_error=0.30\nif (trim(sat) == \"envisat\") obs_error=0.30\nif (trim(sat) == \"jason2\") obs_error=0.28\nif (trim(sat) == \"jason3\") obs_error=0.28\nif (trim(sat) == \"sentinel3a\") obs_error=0.30\nreturn\nend function obs_error\n"}, {"instruction": "Write a Fortran function named calcrmks that takes two input arguments, where the first argument is an array of real numbers with kind=8 and the second argument is a real number with kind=8. The function returns a real array with kind=8 and the same size as the input array. The purpose of this function is to compute the result based on the given input for Jon's simulations. The function contains a where construct to perform calculations based on a condition.", "input": "", "output": "        function calcrmks(x1,xbr) result(r)\n          ! compute r given x1 for jon's simulations                                                                 \n          ! jad 7/24/2011\n          real(kind=8), intent(in), dimension(:) :: x1\n          real(kind=8), intent(in) :: xbr\n          real(kind=8) :: npow2\n          real(kind=8), dimension(size(x1)) :: r, xi\n          npow2=10d0\n          where(x1.gt.xbr)\n             xi=x1+(x1-xbr)**npow2\n          elsewhere\n             xi=x1\n          endwhere\n          r=exp(xi)\n        end function calcrmks\n"}, {"instruction": "Create a Fortran function named calcrmks_single to calculate the result based on the given input x1 for Jon's simulations. The function takes 2 input arguments, both of type real(kind=8), and returns 1 output argument of type real(kind=8).", "input": "", "output": "        function calcrmks_single(x1,xbr) result(r)\n          ! compute r given x1 for jon's simulations                                                                 \n          ! jad 7/24/2011\n          real(kind=8), intent(in) :: x1,xbr\n          real(kind=8) :: npow2\n          real(kind=8) :: r, xi\n          npow2=10d0\n          if(x1.gt.xbr) then\n             xi=x1+(x1-xbr)**npow2\n          else\n             xi=x1\n          endif\n          r=exp(xi)\n        end function calcrmks_single\n"}, {"instruction": "Create a Fortran function named calcet that takes 4 input parameters of type real(8) named etc, wp, fc, and sm. The function returns a single real(8) output parameter named valet. The function calculates valet based on the values of etc, wp, fc, and sm using a conditional statement. If sm is greater than wp, valet is computed using a mathematical expression; otherwise, valet is set to 0.0.", "input": "", "output": "  function calcet(etc,wp,fc,sm) result(valet)\n    real(8),intent(in) :: etc,wp,fc,sm\n    real(8)            :: valet\n    \n    if (sm .gt. wp) then\n      valet = etc * min(1d0 , 2d0*(sm-wp)/(fc-wp))\n    else\n      valet = 0.0\n    end if\n    \n  end function calcet\n"}, {"instruction": "Create a Fortran function called det that takes 4 real(8) input parameters, etc, wp, fc, and sm, and returns a single real(8) output parameter, etderiv. The function computes the value of etderiv based on conditional logic involving the input parameters etc, wp, fc, and sm. Ensure that the function is implemented using the imperative tone.", "input": "", "output": "  function det(etc,wp,fc,sm) result(etderiv)\n    real(8),intent(in) :: etc,wp,fc,sm\n    real(8)            :: etderiv\n    \n    etderiv = 0.0\n    if (sm.ge.wp .and. sm.lt.5d-1*(fc+wp)) then\n      etderiv = 2d0 * etc / (fc-wp)\n    else\n      etderiv = 0.0\n    end if\n    \n  end function det\n"}, {"instruction": "Create a Fortran function named julianday to calculate the Julian day for a given date and time. The function should have 4 input parameters with test_data type ['integer', 'integer', 'integer', 'double precision'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "  function julianday(month,day,year,hour) ! calculates time in jd for a given date\n    integer :: month,day,year,year_r,month_r\n    double precision :: hour,julianday\n    year_r = year+4800-floor((14-month)/12.0)\n    month_r = month+12*floor((14-month)/12.0)-3\n    julianday = day + floor((153*month_r+2)/5.0) + 365*year_r &\n         + floor(year_r/4.0) -floor(year_r/100.0) + &\n         floor(year_r/400.0) - 32045 + (hour-12.0)/24.0\n  end function julianday\n"}, {"instruction": "Create a Fortran function named getbilinearinterp that performs bilinear interpolation to calculate the interpolated value at a given point (x, y) based on the input parameters. There are 8 input parameters of type real and real arrays of dimension 2, and 1 output parameter of type real.", "input": "", "output": "  function getbilinearinterp(x,y,xvec,yvec,f11,f12,f21,f22)\n    !! returns bilinearly interpolated values at (x,y)\n    real, intent(in) :: x !! queried x\n    real, intent(in) :: y !! queried y\n    real, intent(in), dimension(2) :: xvec\n    real, intent(in), dimension(2) :: yvec\n    real, intent(in) :: f11, f12, f21, f22\n    real :: getbilinearinterp\n    real, dimension(2,2) :: fmat\n\n    fmat(1,:) = (/f11,f12/)\n    fmat(2,:) = (/f21,f22/)\n\n    getbilinearinterp = dot_product((/xvec(2)-x,x-xvec(1)/),matmul(fmat,(/yvec(2)-y,y-yvec(1)/)))\n    getbilinearinterp = getbilinearinterp/(xvec(2)-xvec(1))/(yvec(2)-yvec(1))\n\n  end function getbilinearinterp\n"}, {"instruction": "Write a Fortran function named gettable to read data from a CSV formatted file. The function takes 3 input parameters of types character(len=*), integer, and integer. The test_data type for input parameters is ['character(len=*)', 'integer', 'integer']. The function returns a 2D real array and has 1 output parameter of type real, dimension(rows,cols) where rows and cols are the dimensions specified in the input parameters. Remember to use the imperative tone in your instructions.", "input": "", "output": "  function gettable(filename,rows,cols)\n    !! returns data from csv formatted file\n    character(len=*), intent(in) :: filename\n    integer, intent(in) :: rows  !! no. of rows\n    integer, intent(in) :: cols  !! no. of columns \n    integer :: i, j\n    integer :: stat\n    real, dimension(rows,cols) :: gettable\n\n    open(unit=10, file=filename, status='old', action='read', iostat=stat)\n    if (stat>0) then\n      print*, 'error: '//trim(filename)//' file not found'\n      error stop \n    endif\n    do i=1,rows\n      read(10,*) (gettable(i,j),j=1,cols)\n    enddo\n    close(10)\n  end function gettable\n"}, {"instruction": "Write a Fortran function named sign_func to determine the relationship between an integer atom and two other integer atoms. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function sign_func(a,m,n)\nimplicit none\ninteger::sign_func\ninteger::a,n,m\n!\n!     distinct three cases: actual atom a is atom m, atom n or none of them\n!\nif (a .eq. m) then\n   sign_func=1\nelse if (a .eq. n) then\n   sign_func=-1\nelse \n   sign_func=0\nend if\n\nreturn\nend function sign_func\n"}, {"instruction": "Create a Fortran function named lin_interp to perform linear interpolation of a value y based on the arrays x and f. The function takes 3 input parameters of type real, dimension(:) for x and f, and a single real for y. It returns a single real value.", "input": "", "output": "  function lin_interp(x, f, y) result(g)\n    implicit none\n    real, intent(in), dimension(:) :: x\n    real, intent(in), dimension(:) :: f\n    real, intent(in) :: y\n    real :: g\n    integer :: k\n    integer :: n\n    real :: a\n    n = size(x)\n    if (y <= x(1)) then\n      k = 1\n    else if (y >= x(n)) then\n      k = n - 1\n    else\n      k = 1\n      do while (y > x(k+1) .and. k < n)\n        k = k + 1\n      end do\n    end if\n    a = ( f(k+1) - f(k) ) / ( x(k+1) - x(k) )\n    g = f(k) + a * (y - x(k))\n  end function lin_interp\n"}, {"instruction": "Write a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type real. If the input integer is negative, the function returns -1.0 to indicate an error. If the input integer is 0, the function returns 1.0 as the factorial of zero. Otherwise, the function iteratively calculates the factorial and returns the result as a real number.", "input": "", "output": "function fact(n) result(factorial)\n    integer, intent(in) :: n\n    integer :: i\n    real :: factorial, temp\n    if (n < 0) then\n        factorial = -1.0    ! error\n        else if(n == 0) then\n        factorial = 1.0     ! factorial of zero\n        else\n        temp = 1.0\n        do i = 2, n\n            temp = temp * i\n        end do\n        factorial = temp\n    end if\nend function fact\n"}, {"instruction": "Write a Fortran function named simpr to perform numerical integration using Simpson's rule. The function takes 4 input arguments of type real, real, real, and integer (optional) respectively. The output is a real number.", "input": "", "output": "  function simpr(fcn, a, b, n) result(s)\n    interface\n      function fcn(x)\n        real, intent(in) :: x\n        real :: fcn\n      end function\n    end interface\n    real, intent(in) :: a, b\n    integer, optional, intent(in) :: n\n    real :: f0, fn, fs0, fs1, h, s, x0, x1\n    integer :: i, k\n\n    k = merge(n, 3, present(n))\n    h = (b - a) / k\n    f0 = fcn(a)\n    fn = fcn(b)\n    fs0 = 0\n    fs1 = 0\n    x0 = a\n    do i = 1, k\n      x1 = x0 + h\n      if(i < k) fs0 = fs0 + fcn(x1)\n      fs1 = fs1 + fcn((x0 + x1) / 2.)\n      x0 = x1\n    end do\n    s = h / 6. * (f0 + 2. * fs0 + fn + 4. * fs1)\n  end function\n"}, {"instruction": "Create a Fortran function named hyp2f1 to calculate the hypergeometric function 2F1 with four real input parameters. The input parameters are a, b, c, and z, and the output parameter is a real number f1. Use an iterative algorithm to compute the hypergeometric function and return the result f1.", "input": "", "output": "  elemental function hyp2f1(a, b, c, z) result(f1)\n    real, intent(in) :: a, b, c, z\n    integer, parameter :: itmax = 1000\n    real :: aa, bb, cc, f1, fac, temp\n    integer :: n\n\n    fac = 1.\n    temp = fac\n    aa = a\n    bb = b\n    cc = c\n    do n = 1, itmax\n      fac = fac * ((aa * bb) / cc) * z / n\n      f1 = temp + fac\n      if(f1 == temp) return\n      temp = f1\n      aa = aa + 1.\n      bb = bb + 1.\n      cc = cc + 1.\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is denoted as intent(in).", "input": "", "output": "  pure function factorial(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: factorial,i\n\n    factorial=1\n    do i=1,n\n       factorial=factorial*i\n    end do\n    \n  end function factorial\n"}, {"instruction": "Create a Fortran function named diff3 to calculate the third divided difference of three data points. The function takes 6 input arguments of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "    function diff3(x1,x2,x3,y1,y2,y3)\n        real(8),intent(in)::x1,x2,x3\n        real(8),intent(in)::y1,y2,y3\n        real(8)::f1,f2,diff3\n        f1=(y2-y1)/(x2-x1)\n        f2=(y3-y2)/(x3-x2)\n        diff3=(f2-f1)/(x3-x1)\n    end function\n"}, {"instruction": "Create a Fortran function named pythag_triplet to determine if the given three integers form a Pythagorean triplet. The function takes 3 input arguments of type integer (kind=8) and returns a single output argument of type logical.", "input": "", "output": "        pure function pythag_triplet(a, b, c)\n\n                integer (kind=8), intent(in) :: a, b, c\n                logical :: pythag_triplet\n\n                pythag_triplet = (a ** 2 + b ** 2 == c ** 2)\n\n                return\n\n        end function pythag_triplet\n"}, {"instruction": "Write a Fortran function named compar that compares two 8-byte integers and returns an integer of 2 bytes as the result. The function takes 2 input arguments of type integer(8), and the output is a single integer(2) value.", "input": "", "output": "    function compar (arg1,arg2)\n    integer(2) :: compar\n    integer(8) :: arg1, arg2\n    if (arg1 < arg2) then\n        compar = -1\n    else if (arg1 > arg2) then\n        compar = 1\n    else\n        compar = 0\n    end if\n    end function compar\n"}, {"instruction": "Create a Fortran function named nu_m_n_k that calculates the value of nu(m, n, k) based on equation (d.51) in Johnson 1980. The function takes 3 input parameters of type integer [m, n, k] and returns 1 output parameter of type real [nu]. Ensure the function checks for even m or n and performs factorial calculations to determine the value of nu.", "input": "", "output": "    function nu_m_n_k(m, n, k) result(nu)\n        ! calculates nu(m,n,k) based on eq. (d.51) in johnson 1980\n\n        implicit none\n\n        integer,intent(in) :: m, n, k\n        real :: nu\n\n        integer :: mm, nn, kk, i\n\n        ! check for even m or n\n        if (mod(m, 2) .eq. 0 .or. mod(n, 2) .eq. 0) then\n            nu = 0\n        else\n             \n            ! initialize\n            mm = 1\n            nn = 1\n            kk = 1\n\n            ! run factorials (ish. not sure what you'd call these...)\n            if (.not. m .eq. 1) then\n                do i=1,m-2,2\n                    mm = mm*i\n                end do\n            end if\n\n            if (.not. n .eq. 1) then\n                do i=1,n-2,2\n                    nn = nn*i\n                end do\n            end if\n\n            do i=k-2,k-m-n,2\n                kk = kk*i\n            end do\n\n            ! calculate nu\n            nu = mm*nn/kk\n\n        end if\n\n    end function nu_m_n_k\n"}, {"instruction": "Create a Fortran function named get_fibonacci to calculate the nth Fibonacci number. The input parameter is an integer, and the output parameter is also an integer.", "input": "", "output": "function get_fibonacci(n) result(out)\n  integer, intent(in) :: n\n  integer :: out\n  integer :: pprev, prev, fib_no\n  pprev = 0\n  prev = 1\n  out = 1\n  fib_no = 1\n  do while (fib_no < n)\n     out = prev + pprev\n     pprev = prev\n     prev = out\n     fib_no = fib_no + 1\n  end do\nend function get_fibonacci\n"}, {"instruction": "Write a Fortran function named zerorecord that takes an integer input and converts it to a character string of length 4 by adding leading zeros if necessary. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character (len=4)].", "input": "", "output": "function zerorecord(inint)\n  implicit none\n  character (len=4) :: zerorecord, work\n  integer :: inint\n  work=\"0000\"\n  if (inint.lt.10) then\n     write(work(4:),'(i1)') inint\n  else if (inint.lt.100) then\n     write(work(3:),'(i2)') inint\n  else if (inint.lt.1000) then\n     write(work(2:),'(i3)') inint\n  else if (inint.lt.10000) then\n     write(work(1:),'(i4)') inint\n  else\n     print *, \"char error.\"\n     stop\n  endif\n  zerorecord=work\nend function zerorecord\n"}, {"instruction": "Create a Fortran function named kgen_get_newunit to generate a new unit number for file I/O. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is the seed for the random number generator.", "input": "", "output": "            function kgen_get_newunit(seed) result(new_unit)\n               integer, parameter :: unit_min=100, unit_max=1000000\n               logical :: is_opened\n               integer :: nunit, new_unit, counter\n               integer, intent(in) :: seed\n            \n               new_unit = -1\n               \n               do counter=unit_min, unit_max\n                   inquire(unit=counter, opened=is_opened)\n                   if (.not. is_opened) then\n                       new_unit = counter\n                       exit\n                   end if\n               end do\n            end function\n"}, {"instruction": "Write a Fortran function named callback1_incr that takes an integer input parameter of type c_int by value. The function also returns an integer of type c_int as the result.", "input": "", "output": "        function callback1_incr(arg0) bind(c)\n            use iso_c_binding, only : c_int\n            implicit none\n            integer(c_int), value :: arg0\n            integer(c_int) :: callback1_incr\n        end function callback1_incr\n"}, {"instruction": "Create a Fortran function named benchmarksupport that takes an integer input argument. It should return a logical value indicating whether benchmark support is available based on the comparison of the input with the value of threadsupport. The number of input arguments is 1 of type integer, and the number of output arguments is 1 of type logical.", "input": "", "output": "  function benchmarksupport(required)\n    integer, intent(in) :: required\n    logical :: benchmarksupport\n\n    if (required <= threadsupport) then\n       benchmarksupport = .true.\n    else\n       benchmarksupport = .false.\n    end if\n\n  end function benchmarksupport\n"}, {"instruction": "Create a Fortran function named workable that takes two input parameters: an 8-byte integer number and a regular integer bitmask. The function returns a single output parameter of type logical. Inside the function, the input number is divided by 10 while the bitmask is divided by 2 within a do-while loop. If the bitmask becomes greater than 0, the function returns false; otherwise, it returns true.", "input": "", "output": "  pure function workable(number,bitmask)\n    implicit none\n    integer*8, intent(in) :: number\n    integer, intent(in)   :: bitmask\n    integer*8             :: temp1\n    integer               :: temp2\n    logical               :: workable\n\n    temp1=number\n    temp2=bitmask\n    workable=.true.\n    do while(temp1>0)\n       temp1=temp1/10\n       temp2=temp2/2\n    end do\n\n    if (temp2>0) then\n       workable=.false.\n    end if\n\n  end function workable\n"}, {"instruction": "Write a Fortran function named vector_scalar_mul that multiplies each element of a 4D array by a corresponding element of a 3D array. The number of input arguments is 2, and their test_data types are ['real, dimension(:,:,:,:)', 'real, dimension(:,:,:)']. The number of output arguments is 1, and its test_data type is ['real, dimension(size(in,1),size(in,2),size(in,3),3)'].", "input": "", "output": "function vector_scalar_mul (in, in2) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(:,:,:), intent(in):: in2\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  out(:,:,:,1) = in(:,:,:,1)*in2\n  out(:,:,:,2) = in(:,:,:,2)*in2\n  out(:,:,:,3) = in(:,:,:,3)*in2\nend function\n"}, {"instruction": "Create a Fortran function named const3_vector_mul that takes two input parameters of type real, with dimensions specified by \":,:,:,:\", and \":,\" respectively. The function has one output parameter of type real, with dimensions specified by \"size(in,1),size(in,2),size(in,3),3\". The function computes the element-wise multiplication of the input 4D array with a 1D array and stores the result in a 4D array, where each element is multiplied by the corresponding element of the 1D array.", "input": "", "output": "function const3_vector_mul (in1, in) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  real, dimension(:), intent(in):: in1\n  out(:,:,:,1) = in(:,:,:,1)*in1(1)\n  out(:,:,:,2) = in(:,:,:,2)*in1(2)\n  out(:,:,:,3) = in(:,:,:,3)*in1(3)\nend function\n"}, {"instruction": "Create a Fortran function named vector_scalar_add to perform element-wise addition of a 4D array and a 3D array. The number of input arguments is 2, where the test_data type is ['real, dimension(:,:,:,:)', 'real, dimension(:,:,:)']. The number of output arguments is 1, with the test_data type as ['real, dimension(size(in,1),size(in,2),size(in,3),3)'].", "input": "", "output": "function vector_scalar_add (in, in2) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(:,:,:), intent(in):: in2\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  out(:,:,:,1) = in(:,:,:,1)+in2\n  out(:,:,:,2) = in(:,:,:,2)+in2\n  out(:,:,:,3) = in(:,:,:,3)+in2\nend function\n"}, {"instruction": "Write a Fortran function named find_data_file to search for a required data file in several locations. The input parameter is a character string with variable length. The output parameter is also a character string with a length of 1000.", "input": "", "output": "      function find_data_file(basename)\n        ! find a required data file by searching several locations.\n        ! returns the path if found; exits the program if not.\n        ! can be used directly in an open() statement, e.g.:\n        !\n        !   open(<unit>, file=find_data_file(<basename>), status='old')\n        !\n        implicit none\n        character(len=*), intent(in) :: basename\n        character(len=1000) :: find_data_file, data_home, env_home\n        character(len=100)  :: suffix\n        logical :: file_exists\n\n        ! check current directory first\n        find_data_file = basename\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! path suffix for the remaining candidates\n        suffix = '/osu-hydro/' // basename\n\n        ! check user directory: xdg_data_home or ~/.local/share if unset\n        call get_environment_variable('xdg_data_home', data_home)\n        if (len_trim(data_home) == 0) then\n          call get_environment_variable('home', data_home)\n          data_home = trim(data_home) // '/.local/share'\n        end if\n\n        find_data_file = trim(data_home) // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! check system directories\n        find_data_file = '/usr/local/share' // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        find_data_file = '/usr/share' // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! check python virtual environment [use in hic chain]\n        call get_environment_variable('conda_prefix', env_home)\n        data_home = trim(env_home) // '/share'\n        find_data_file = trim(data_home) // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        print *, basename, ' not found'\n        call exit(1)\n      end function\n"}, {"instruction": "Create a Fortran function named randint that generates a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be provided as an array representing the range [mi, ma], and the function returns a random integer x within that range.", "input": "", "output": "    function randint(mi,ma) result(x)\n        implicit none\n        \n        integer,intent(in)  :: mi,ma\n        integer             :: x\n        real    :: r\n        \n        call random_number(r)\n        x = mi + floor(r*(ma-mi+1))\n    end function        \n"}, {"instruction": "Create a Fortran function named day_of_week that takes 3 input parameters of type integer (d, m, y) and returns 1 output parameter of type integer. This function computes the day of the week for a given date using Zeller's Congruence algorithm.", "input": "", "output": "function day_of_week(d, m, y)\n  integer :: day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n\n  j = y / 100\n  k = mod(y, 100)\n  day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n\nend function day_of_week\n"}, {"instruction": "Create a Fortran function named f_combination to calculate the combination value (n choose k) using the given input parameters. The number of input parameters is 2, and their test_data type is ['integer', 'integer']. The number of output parameters is 1, and its test_data type is ['integer']. Use the imperative tone to describe the function.", "input": "", "output": "  function f_combination(n,k) result(nck)\n    integer, intent(in) :: n, k\n    integer :: i\n    integer ::nck\n\n    if(n < k)then\n      nck = 0\n      return\n    end if\n\n    nck=1\n    do i=1,k\n      nck=nck*(n-k+i)\n      nck=nck/i\n    end do\n\n  end function f_combination\n"}, {"instruction": "Write a Fortran function named compute_analog_mean to calculate the mean of elements in an array based on the indices provided in another integer array. The function takes 2 input parameters of type real, dimension(:) and integer, dimension(:), and returns 1 output parameter of type real.", "input": "", "output": "    function compute_analog_mean(input, analogs) result(mean)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real                              :: mean\n        \n        double precision :: internal_mean\n        integer :: i, n\n        \n        n = size(analogs)\n        internal_mean = 0\n        \n        do i=1,n\n            internal_mean = internal_mean + input( analogs(i) )\n        enddo\n        \n        mean = internal_mean / n\n        \n    end function compute_analog_mean\n"}, {"instruction": "Create a Fortran function named compute_analog_error to calculate the error between a set of input values and a predicted value. The function has 3 input parameters of types real, dimension(:), integer, dimension(:), and real, and 1 output parameter of type real.", "input": "", "output": "    function compute_analog_error(input, analogs, y_hat) result(error)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real,    intent(in)               :: y_hat\n        real                              :: error\n        \n        double precision :: mean\n        integer :: i, n\n        \n        n = size(analogs)\n        mean = 0\n        \n        do i=1,n\n            mean = mean + (input( analogs(i) ) - y_hat)**2\n        enddo\n        \n        error = sqrt(mean / n)\n        \n    end function compute_analog_error\n"}, {"instruction": "Create a Fortran function named compute_analog_exceedance to calculate the probability of exceeding a threshold value by the elements specified by the indices in the analogs array, from the input array. The function takes 3 input arguments of types real, dimension(:), integer, dimension(:), and real. The output parameter is a real value.", "input": "", "output": "    function compute_analog_exceedance(input, analogs, threshold) result(probability)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real,    intent(in)               :: threshold\n        real                              :: probability\n        integer :: i, n\n        \n        n = size(analogs)\n        probability = 0\n        do i = 1, n\n            if (input(analogs(i)) > threshold) then\n                probability = probability + 1\n            endif\n        end do\n        \n        probability = probability / n\n        \n    end function compute_analog_exceedance\n"}, {"instruction": "Write a Fortran function named pick_n_random_zeros that takes an array of real numbers and an integer n as input and returns an array of n randomly chosen indices corresponding to elements in the input array that are zero. The number of input arguments is 2 and the test_data type is ['real, dimension(:)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(1:n)'].", "input": "", "output": "    function pick_n_random_zeros(input, n) result(analogs)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in)     :: n\n        integer, dimension(1:n)   :: analogs\n        integer, dimension(:), allocatable :: zero_locations\n        \n        integer :: i, n_inputs, n_zeros, selected_analog\n        real :: rand\n\n        n_inputs = size(input)\n        allocate(zero_locations(n_inputs))\n        n_zeros = 0\n        do i=1,n_inputs\n            if (input(i)==0) then\n                n_zeros = n_zeros + 1\n                zero_locations(n_zeros) = i\n            end if\n        end do\n        \n        do i=1,n\n            call random_number(rand)\n            selected_analog = floor(rand * n_zeros)+1\n            analogs(i) = zero_locations(selected_analog)\n        end do\n\n    end function pick_n_random_zeros\n"}, {"instruction": "Write a Fortran function named tria_binsearch to perform a binary search on an integer array. The function takes 4 input arguments of type integer, dimension(:), integer, integer and returns 1 output argument of type integer.", "input": "", "output": "  function tria_binsearch(p_iarray, ivalue, ilbound, iubound)\n\n!<description>\n\n!</description>\n\n!<input>\n    ! the integer array to search in\n    integer, dimension(:),intent(in) :: p_iarray\n\n    ! the integer to search for\n    integer, intent(in) :: ivalue\n\n    ! the lower and uppers bounds used in the array\n    integer, intent(in) :: ilbound, iubound\n!</input>\n\n!<result>\n    integer :: tria_binsearch\n!</result>\n\n\n    ! local variables\n    integer :: imid, ilboundloc, iuboundloc\n\n    ilboundloc = ilbound\n    iuboundloc = iubound\n\n    ! standard binary search scheme...\n    do while( ilboundloc .le. iuboundloc )\n\n      imid = (ilboundloc + iuboundloc) / 2\n\n      if(p_iarray(imid) > ivalue) then\n        iuboundloc = imid-1\n      elseif(p_iarray(imid) < ivalue) then\n        ilboundloc = imid+1\n      else ! found ivalue\n        tria_binsearch = 1\n        return\n      end if\n\n    end do ! end while\n\n    ! ivalue was not found...\n    tria_binsearch = 0\n\n  end function tria_binsearch\n"}, {"instruction": "Create a Fortran function named ele_mass to calculate the mass of an element based on its symbol. The function takes 1 input parameter of type character(len=30) and returns 1 output parameter of type real(kind=8). The input parameter represents the symbol of the element, and the output parameter holds the mass of the element.", "input": "", "output": "    function ele_mass(ele) result(m)\n\n    implicit none\n\n    character(len=30),intent(in) :: ele\n    real(kind=8)    :: m\n\n    if (trim(adjustl(ele)) .eq. 'si') then\n        m = 28.0855\n    end if\n\n    end function ele_mass\n"}, {"instruction": "Write a Fortran function called is_leap_year to determine if a given year is a leap year. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the year is a leap year or not.", "input": "", "output": "  elemental function is_leap_year( year )\n    integer, intent(in) :: year\n    logical :: is_leap_year\n\n    is_leap_year = ( (mod(year,4)   == 0) .and. &\n                     (mod(year,100) /= 0)       ) .or. &\n                   (mod(year,400) == 0)\n\n  end function is_leap_year\n"}, {"instruction": "Create a Fortran function named tolower to convert the uppercase characters in a string to lowercase. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=len(a)).", "input": "", "output": "function tolower(a) result(b)\n!===============================================================================\n!  convert the uppercase characters in a string to lowercase\n   implicit none\n   character(len=*), intent(in) :: a\n   character(len=len(a)) :: b\n   integer, parameter :: capa = iachar('a'), capz = iachar('z')\n   integer :: i, ia\n   b = a\n   do i = 1, len_trim(a)\n      ia = iachar(a(i:i))\n      if (ia >= capa .and. ia <= capz) &\n         b(i:i) = achar(iachar(a(i:i)) + 32)\n   enddo\nend function tolower\n"}, {"instruction": "Create a Fortran function named \"pi\" to estimate the value of pi using a Monte Carlo method, based on the number of samples provided. The function should take 1 input parameter of type integer and return 1 output parameter of type real. The input parameter represents the number of samples to be used in the estimation. Use the imperative tone to provide the following instructions.", "input": "", "output": "    function pi(samples_num) result(pi_value)\n        ! declaring input parameter\n        integer, intent(in) :: samples_num\n        ! declaring local vaariables\n        real :: pi_value, length\n        real, dimension(2) :: coordinates\n        integer :: i, in_circle\n\n        in_circle = 0\n        do i = 1, samples_num\n            call random_number(coordinates)\n            coordinates = coordinates * 2 - 1\n            length = sqrt(coordinates(1) * coordinates(1) + coordinates(2) * coordinates(2))\n            if ( length <= 1 ) then\n                in_circle = in_circle + 1\n            end if\n        end do\n        pi_value = 4.0  * real(in_circle) / real(samples_num)\n    end function pi\n"}, {"instruction": "Create a Fortran function named pluralize that takes in a singular word of type character and a count of type integer as input, and returns the plural form of the word based on the count. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=256)'].", "input": "", "output": "        pure function pluralize(singular, i)\n            character(len=*), intent(in) :: singular\n            integer, intent(in)          :: i\n            character(len=256)          :: pluralize\n            if (i == 1) then\n                pluralize = singular\n            else\n                pluralize = trim(singular) // \"s\"\n            end if\n        end function\n"}, {"instruction": "Create a Fortran function named strfrominteger that takes an integer as input and returns a character string. The number of input arguments is 1 and the test_data type is ['integer'], while the number of output arguments is 1 and the test_data type is ['character(len=256)']. Use the imperative tone to instruct the creation of this function.", "input": "", "output": "        pure function strfrominteger(i) result(str)\n            integer, intent(in) :: i        !! the integer to convert to a string\n            character(len=256) :: str       !! the string to return\n            write(str, *)i\n            str = trim(adjustl(str))\n        end function\n"}, {"instruction": "Create a Fortran function named strfromreal that takes a real number as input and returns a string representation of the input number. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['character(len=256)'].", "input": "", "output": "        pure function strfromreal(r) result(str)\n            real, intent(in) :: r           !! the real to convert to a string\n            character(len=256) :: str       !! the string to return\n            write(str, *)r\n            str = trim(adjustl(str))\n        end function\n"}, {"instruction": "Create a Fortran function named aux_f_bc to calculate a mathematical function based on the value of a single double precision real input. The number of input arguments is 1 and the test_data type is [real * 8]. The number of output arguments is 1 and the test_data type is [real * 8]. Use an if-else condition to determine the output based on the input value.", "input": "", "output": "\tfunction aux_f_bc(q) result(f)\n\t\timplicit none\n\t\treal * 8, intent(in) :: q\n\t\treal * 8 :: f\n\t\tif (q>0.075d0) then\n\t\t\tf = 2.d0 * bessel_jn(1,q) / q\n\t\telse\n\t\t\tf = 1.d0 - (q * q / 8.d0)\n\t\tend if\n\tend function\n"}, {"instruction": "Write a Fortran function named num2str to convert an integer to a string. The function should take 1 input argument of type integer and return 1 output argument of type character(len=:),allocatable.", "input": "", "output": "    function num2str(intnum)\n    integer,intent(in) :: intnum\n    character(len=:),allocatable:: num2str\n    character(len=255):: tmpstr\n    write(tmpstr,*)intnum\n    allocate(character(len=len_trim(adjustl(tmpstr)))::num2str)\n    num2str=trim(adjustl(tmpstr))\n    end function num2str\n"}, {"instruction": "Create a Fortran function named str_f4 to convert a real(8) number to a string with a specified format. The number of input arguments is 1 and the test_data type is [real(8)]. The number of output arguments is 1 and the test_data type is [character(len=8)].", "input": "", "output": "function str_f4 (t) result (out)\n  real(8):: t\n  character(len=8):: out\n  !-----------------------------------------------------------------------------\n  write (out,'(f8.3)') t\n  out = adjustl(out)\n  out = trim(out(1:4))\nend function\n"}, {"instruction": "Create a Fortran function named spud_get_option to retrieve an option value based on the provided key and key length. The function should have 3 input parameters of types integer(c_int), character(len=1,kind=c_char) array, and type(c_ptr), and 1 output parameter of type integer(c_int).", "input": "", "output": "     function spud_get_option(key, key_len, val) bind(c)\n       use iso_c_binding\n       implicit none\n       integer(c_int), intent(in), value :: key_len\n       character(len=1,kind=c_char), dimension(key_len), intent(in) :: key\n       ! here intent(in) refers to the c_ptr, not the target!\n       type(c_ptr), value, intent(in) :: val\n       integer(c_int) :: spud_get_option\n     end function spud_get_option\n"}, {"instruction": "Create a Fortran function named plm to calculate the associated Legendre polynomials. The function takes 3 input parameters of type integer, integer, and real(kind=dp), and returns 1 output parameter of type real(kind=dp). The input parameters are l, m, and x, while the output parameter is plm. Ensure to handle the special cases of bad input arguments within the function.", "input": "", "output": "function plm(l,m,x)\n!----------------------------------------------------\n! subroutine:\n!   plm\n!\n! purpose:\n!  calculate assiociated legendre polynomials      \n!----------------------------------------------------\n  implicit none\n  integer,parameter::dp=selected_real_kind(8) !double precision\n  integer::l,m\n  integer::i,ll\n  real(kind=dp)::x,fact,pll,pmm,pmmp1,somx2\n  real(kind=dp)::plm\n  if((m.lt.0).or.(m.gt.l).or.(abs(x).gt.1.d0))then\n      write(*,*) 'bad arguments in plm'\n  endif\n  pmm=1.d0\n  if(m.gt.0)then\n     somx2=sqrt((1.d0-x)*(1.d0+x))\n     fact=1.d0\n     do 11 i=1,m\n        pmm=-pmm*fact*somx2\n        fact=fact+2.d0\n11   continue\n  endif\n  if(l.eq.m)then\n     plm=pmm\n  else\n     pmmp1=x*dble(2*m+1)*pmm\n     if(l.eq.m+1)then\n        plm=pmmp1\n     else\n        do 12 ll=m+2,l\n           pll=(x*dble(2*ll-1)*pmmp1-dble(ll+m-1)*pmm)/dble(ll-m)\n           pmm=pmmp1\n           pmmp1=pll\n12      continue\n        plm=pll\n     endif\n  endif\n  return\nend function plm\n"}, {"instruction": "Create a Fortran function named integrate to numerically integrate a given function using the trapezoidal rule. The function has 3 input parameters of type real, real array, and optional integer. The output parameter is of type real. The number of input arguments is 3 and the test_data type is [real, real, dimension(:), integer, optional]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    pure function integrate( dt, f, method ) result( ff )\n        \n        real, intent(in)                 :: dt\n        real, dimension(:), intent(in)   :: f\n        integer, optional, intent(in)    :: method\n        real :: ff\n        \n        integer :: i,il,iu\n        \n        if (present(method)) return\n     \n        if (size(f) < 2) then\n            ff = 0.0\n            return\n        end if\n        \n        il = lbound(f,1)\n        iu = ubound(f,1)\n        \n        ff = (f(il)+f(iu))/2.0\n        do i=il+1,iu-1\n            ff = ff + f(i)\n        end do\n        ff = ff * dt\n        \n        \n    end function integrate\n"}, {"instruction": "Write a Fortran function named next_copy_number that takes two input arguments, cnum of type integer and ncopies of type integer (optional). The function returns an integer value. If the optional argument ncopies is present, the function calculates the next copy number as cnum plus ncopies minus 1; otherwise, it calculates the next copy number as cnum plus 1.", "input": "", "output": "function next_copy_number(cnum, ncopies)\ninteger, intent(inout)        :: cnum\ninteger, intent(in), optional :: ncopies\ninteger :: next_copy_number\n\nif (present(ncopies)) then\n   next_copy_number = cnum + ncopies - 1\nelse\n   next_copy_number = cnum + 1\nendif\n\ncnum = next_copy_number\n\nend function next_copy_number\n"}, {"instruction": "Write a Fortran function named delta2 that computes a function value. \nThe function takes 7 input parameters: an integer, a real*8 array of dimension (no_data), another real*8 array of dimension (no_data), and four individual real*8 values. \nThe output is a single real*8 value.", "input": "", "output": "function delta2(no_data,z,p,del,alpha,z_data,sigma_data)\n implicit none\n\n  integer,intent(in) :: no_data\n  real*8,intent(in),dimension(no_data) :: z_data, sigma_data\n  real*8,intent(in) :: z,p,del,alpha\n!  real*8,parameter :: del = 1.0d0\t\t\t!type 1: power 1.5 delta 0.3 and const. 1.9  ---- type 2 delta 0.1 const 1.8\n  real*8 :: delta2\n  integer :: i\n\n  delta2 = 0.0d0\n  do i = 1,no_data\t\n\tdelta2 = delta2 + (((1.0d0)/((sigma_data(i))**2))*(exp(-1.0d0*(( (z-z_data(i))/(del))**2))))\t!for type 1 -- 2 power is 1.5\n end do\n  delta2 = (alpha)*((1.0d0/delta2)**(1.0d0/p))\n\n return\nend function delta2\n"}, {"instruction": "Create a Fortran function named dm_flat to calculate the luminosity distance for a flat universe. The function takes 3 input parameters of type real*8: x2, h0, and om. It returns a single output parameter of type real*8, which represents the luminosity distance.", "input": "", "output": "function dm_flat (x2, h0, om)\n  implicit none\n  real*8 :: dm_flat\n  integer :: i,n\n  real*8 :: x1, h_x1, sum2\n  real*8, intent (in) :: x2, h0, om\n\n  sum2 = 0.0d0\n  x1 = 0.0d0\n  n = 100\n  h_x1=(x2-x1)/float(n)\n  do i = 1, n\n     sum2 = sum2 +((1.0d0)/(sqrt((om)*((x1+1.0d0)**3)+1.0d0-om)))\n     x1=x1+h_x1\n  end do\n  sum2=(sum2)*((1.0d0+x2)*(3.0d5)*(h_x1/h0))\n  dm_flat = 5.0d0*log10(sum2) + 25.0d0\nreturn\nend function dm_flat\n"}, {"instruction": "Create a Fortran function named w that takes a single input argument of type real*8 to compute and return a real*8 value.", "input": "", "output": "function w(z)\nimplicit none\n\treal*8,parameter :: w0 = -1.0d0,wm = -0.5d0,zt = 0.5d0,delta_t = 0.5d-1\n\treal*8 :: w\n\treal*8,intent(in) :: z\n\tw = (3.0d0/(1.0d0+z))*(1.0d0+w0 + ((wm-w0)*((1.0d0+exp(1.0d0/(delta_t*(1.0d0+zt))))/(1.0d0-exp(1.0d0/delta_t)))*(1.0d0- &\n\t((exp(1.0d0/delta_t)+exp(1.0d0/(delta_t*(1.0d0+zt))))/(exp(1.0d0/(delta_t*(1.0d0+z)))+exp(1.0d0/(delta_t*(1.0d0+zt))))))))\nreturn\nend function w\n"}, {"instruction": "Write a Fortran function called f, which takes two real input parameters x and t, and returns a real output. The function computes the sum of the sine values of x and t.", "input": "", "output": "    function f(x,t)\n        implicit none\n        real, intent(in) :: x, t\n        real :: f\n        f = sin(x) + sin(t)\n    end function\n"}, {"instruction": "Create a Fortran function named df to calculate the derivative of a given real number with respect to another real number. The function accepts 2 input parameters of type real, represented as x and t. It returns 1 output parameter of type real.", "input": "", "output": "    function df(x,t)\n        implicit none\n        real, intent(in) :: x, t\n        real :: df\n        df = cos(x)\n    end function\n"}, {"instruction": "Create a Fortran function named seval that takes 5 input parameters of type integer, real, real arrays of dimension n, and outputs a single real value. This function calculates the value of x(ss) using the values of ss and pre-calculated arrays xs and s using the spline method.", "input": "", "output": "    function seval(ss, x, xs, s, n)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        integer :: n\n        real :: ss\n        real, dimension(n) :: s, x, xs\n        real :: seval\n        intent (in) n, s, ss, x, xs\n        !\n        ! local variables\n        !\n        real :: cx1, cx2, ds, t\n        integer :: i, ilow, imid\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !--------------------------------------------------\n        !     calculates x(ss)                             |\n        !     xs array must have been calculated by spline |\n        !--------------------------------------------------\n        ilow = 1\n        i = n\n        !\n        do while (i - ilow>1)\n            !\n            imid = (i + ilow) / 2\n            if (ss<s(imid)) then\n                i = imid\n            else\n                ilow = imid\n            endif\n        enddo\n        !\n        ds = s(i) - s(i - 1)\n        t = (ss - s(i - 1)) / ds\n        cx1 = ds * xs(i - 1) - x(i) + x(i - 1)\n        cx2 = ds * xs(i) - x(i) + x(i - 1)\n        seval = t * x(i) + (1.0 - t) * x(i - 1) + (t - t * t) * ((1.0 - t) * cx1 - t * cx2)\n    end function seval\n"}, {"instruction": "Create a Fortran function named curv to calculate the curvature of a splined 2D curve at a given arc length. The function takes 7 input parameters of types integer, real, and real arrays of dimension n, and returns 1 output parameter of type real.", "input": "", "output": "    function curv(ss, x, xs, y, ys, s, n)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        integer :: n\n        real :: ss\n        real :: curv\n        real, dimension(n) :: s, x, xs, y, ys\n        intent (in) n, s, ss, x, xs, y, ys\n        !\n        ! local variables\n        !\n        real :: cx1, cx2, cy1, cy2, ds, sd, t, xd, xdd, yd, ydd\n        integer :: i, ilow, imid\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !-----------------------------------------------\n        !     calculates curvature of splined 2-d curve |\n        !     at s = ss                                 |\n        !                                               |\n        !     s        arc length array of curve        |\n        !     x, y     coordinate arrays of curve       |\n        !     xs,ys    derivative arrays                |\n        !              (calculated earlier by spline)   |\n        !-----------------------------------------------\n        !\n        ilow = 1\n        i = n\n        !\n        do while (i - ilow>1)\n            !\n            imid = (i + ilow) / 2\n            if (ss<s(imid)) then\n                i = imid\n            else\n                ilow = imid\n            endif\n        enddo\n        !\n        ds = s(i) - s(i - 1)\n        t = (ss - s(i - 1)) / ds\n        !\n        cx1 = ds * xs(i - 1) - x(i) + x(i - 1)\n        cx2 = ds * xs(i) - x(i) + x(i - 1)\n        xd = x(i) - x(i - 1) + (1.0 - 4.0 * t + 3.0 * t * t) * cx1 + t * (3.0 * t - 2.0) * cx2\n        xdd = (6.0 * t - 4.0) * cx1 + (6.0 * t - 2.0) * cx2\n        !\n        cy1 = ds * ys(i - 1) - y(i) + y(i - 1)\n        cy2 = ds * ys(i) - y(i) + y(i - 1)\n        yd = y(i) - y(i - 1) + (1.0 - 4.0 * t + 3.0 * t * t) * cy1 + t * (3.0 * t - 2.0) * cy2\n        ydd = (6.0 * t - 4.0) * cy1 + (6.0 * t - 2.0) * cy2\n        !\n        sd = sqrt(xd * xd + yd * yd)\n        sd = max(sd, 0.001 * ds)\n        !\n        curv = (xd * ydd - yd * xdd) / sd**3\n        !\n    end function curv\n"}, {"instruction": "Create a Fortran function named bspline3 to calculate the value of a cubic B-spline at a given point. The function takes 3 input parameters of type integer, double precision, and double precision. The output is a double precision value.", "input": "", "output": "  function bspline3(j,r,dr)\n    implicit none\n    integer, intent(in) :: j\n    double precision, intent(in) :: r,dr\n    double precision :: bspline3\n    double precision :: raux\n    raux = (r - (j-1)*dr)/dr\n    bspline3 = 0\n    if (0<raux .and. raux<3) then\n      select case (nint(raux+5d-1))\n      case(1)\n        bspline3 = raux**2/2\n      case(2)\n        bspline3 = (2*raux*(3-raux)-3)/2\n      case(3)\n        bspline3 = (raux-3)**2/2\n      end select\n    end if\n  end function bspline3\n"}, {"instruction": "Create a Fortran function named bspline3int that takes 3 input parameters: an integer j, and two double precision numbers r and dr. The function returns a double precision result. This function calculates an integral using the B-spline algorithm and returns the result.", "input": "", "output": "  function bspline3int(j,r,dr)\n    implicit none\n    integer, intent(in) :: j\n    double precision, intent(in) :: r,dr\n    double precision :: bspline3int\n    double precision :: raux,pota,potb\n    raux = (r - (j-1)*dr)/dr\n    bspline3int = 0\n    select case(nint(raux+5d-1))\n    case(:0)\n      pota = 0\n      potb = 12 + 24*j\n    case(1)\n      pota = raux**3*(10*(-1+j)**2+15*(-1+j)*raux+6*raux**2)\n      potb = 12+(4-3*raux)*raux**3-4*j*(-6+raux**3)\n    case(2)\n      pota = 1+j*(-5+j*(10+j*(-10+j*(5+2*j)))) &\n           -10*(-1+2*j*(1+j))*(-1+j+raux)**3+15*(1+2*j)*(-1+j+raux)**4-12*(-1+j+raux)**5\n      potb = 21+4*j*(3+(-3+raux)*raux*(-3+2*raux))+2*(-3+raux)*raux*(6+raux*(-7+3*raux))\n    case(3)\n      pota = -2-j*(20+j*(20+j*(40+j*(10+j)))) &\n           +10*(2+j)**2*(-1+j+raux)**3-15*(2+j)*(-1+j+raux)**4+6*(-1+j+raux)**5\n      potb = -((-3+raux)**3*(-1+4*j+3*raux))\n    case(4:)\n      pota = 30*(1+2*j*(1+j))\n      potb = 0\n    end select\n    bspline3int = - ((dr**2/(60*(-1+j+raux))) * pota + (dr**2/24) * potb)\n  end function bspline3int\n"}, {"instruction": "Create a Fortran function named areclose to determine if two real numbers are close within a specified threshold. The function takes 3 input parameters of type real and returns 1 output parameter of type logical.", "input": "", "output": "function areclose ( a, b, threshold ) result( isclose )\n\n    implicit none\n    real :: a, b, threshold\n    logical :: isclose\n\n    isclose = .true.\n    if ( 1.0 + (a - b) - 1.0 .ne. 0.0 ) then\n\t    if ( a .ne. 0.0 ) then\n\t\tisclose = ( abs ((a - b) / a) .le. threshold )\n\t    else if ( b .ne. 0.0 ) then\n\t\tisclose = ( abs ((a - b) / b) .le. threshold )\n\t    end if\n    end if\n\nend function areclose\n"}, {"instruction": "Create a Fortran function named densdot that takes a single input parameter of type double precision and returns a single output parameter of type double precision. The function calculates the rate of change of density based on the given input density, according to the formula from Rawlings et al. 1992 for freefall collapse with a factor for the magnetic field. If the input density is less than a specified final density, the calculated rate of change is based on a complex formula; otherwise, the rate of change is set to 0.0.", "input": "", "output": "    pure function densdot(density)\n        double precision, intent(in) :: density\n        double precision :: densdot\n        !rawlings et al. 1992 freefall collapse. with factor bc for b-field etc\n        if (density .lt. finaldens) then\n             densdot=bc*(density**4./initialdens)**0.33*&\n             &(8.4d-30*initialdens*((density/initialdens)**0.33-1.))**0.5\n        else\n            densdot=0.0\n        endif\n    end function densdot\n"}, {"instruction": "Create a Fortran function named uppercase that takes a single input argument of type character (len = *) and returns a single output argument of type character (len = 1). The function converts the input character to uppercase and returns the result.", "input": "", "output": "   function uppercase(letter) result(l)\n     character (len = *), intent (in) :: letter\n     character (len = 1)              :: l\n\n     character (len = 27), parameter :: lower = \"_abcdefghijklmnopqrstuvwxyz\", &\n                                        upper = \"_abcdefghijklmnopqrstuvwxyz\"\n     integer :: k\n\n     k = index(lower, letter)\n     if (k > 0) then\n       l = upper(k:k)\n     else\n       l = letter\n     end if\n     return\n   end function uppercase\n"}, {"instruction": "Create a Fortran function named action2str that takes an integer input argument and returns a 7-character string. When the input is equal to the value of the variable padd, the function should return 'add'; otherwise, it should return 'replace'.", "input": "", "output": "      pure function action2str (action)\n        integer, intent(in) :: action\n        character(7) :: action2str\n        if (action == padd) then\n          action2str = 'add'\n        else\n          action2str = 'replace'\n        end if\n      end function action2str\n"}, {"instruction": "Write a Fortran function named lower_case that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len(string)). This function converts the input string to lowercase and assigns the result to the output argument. Use an imperative tone in the instructions.", "input": "", "output": "      elemental function lower_case(string)\n        character(len=*), intent(in) :: string\n        character(len=len(string))   :: lower_case\n\n        integer :: i\n\n        do i = 1, len (string)\n          if (      iachar ('a') <= iachar (string(i:i)) &\n              .and. iachar ('z') >= iachar (string(i:i))) then\n            lower_case(i:i) = achar (iachar (string(i:i))&\n                              + iachar ('a') - iachar ('a'))\n          else\n            lower_case(i:i) = string(i:i)\n          end if\n        end do\n      end function lower_case\n"}, {"instruction": "Create a Fortran function named kdelta to calculate the Kronecker delta. The function takes 2 integer input parameters, and the test_data type is ['integer', 'integer']. It returns 1 if the input parameters are equal; otherwise, it returns 0. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "  function kdelta(i,j)\n    integer :: i,j,kdelta\n    kdelta=0\n    if (i == j) kdelta = 1\n  end function kdelta\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer number. This function takes 1 input parameter of type integer, and returns 1 output parameter of type integer.", "input": "", "output": "  pure function factorial ( n ) result ( rslt )\n    !! compute $n!$\n    integer, intent(in) :: n\n    integer :: rslt\n    integer :: i\n    rslt = 1\n    do i = 1, n\n      rslt = rslt*i\n   end do\n end function\n"}, {"instruction": "Create a Fortran function named sum_div that takes an integer(4) as input and returns an integer(4) as output. The function calculates the sum of all divisors of the input integer, excluding the input integer itself.", "input": "", "output": "  pure function sum_div(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(4)             :: sum_div\n\n    ! local variables\n    integer(4) :: i1,i2,nmax\n\n    ! figure out max number to try\n    nmax = int(sqrt(1d0*n))\n\n    ! 1 is always a divisor\n    sum_div = 1\n    do i1=2,nmax\n       if (mod(n,i1)==0) then\n          ! work out if a perfect square\n          i2 = n/i1\n          if (i2 /= i1) then\n             sum_div = sum_div + i1 + i2\n          else\n             sum_div = sum_div + i1\n          endif\n       endif\n    enddo\n\n    return\n  end function sum_div\n"}, {"instruction": "Write a Fortran function named sint that takes a string as input and returns an integer. The input parameter is of type character with variable length, and the output parameter is of type integer. The function parses the input string and returns the corresponding integer value.", "input": "", "output": "function sint(s) result(i)\n   implicit none\n   character(len=*) :: s\n   integer :: j, i\n   i = 0\n   do j=len(s), 1, -1\n    if (.not.((i.eq.0).and.(s(j:j).eq.' '))) then\n      i = i + ichar(s(j:j)) * 10 ** (j - 1)\n    endif\n   end do\n   return\n end function sint\n"}, {"instruction": "Create a Fortran function called chkerr_log that checks for errors, prints an error message, and returns a logical value. The function takes 3 input parameters of type integer, integer, and character(len=*), and 1 output parameter of type logical.", "input": "", "output": "  function chkerr_log(ierr,str,io_unit)\n!* purpose\n!*   check for errors, print message if error, and return logical\n!*   name                    description\n!*   ierr                    error integer\n!*   str                     error message string to be written to file\n!*   io_unit                 io unit for outpute file (assumed open)\n!* author\n!*   pieter boom\n!* modification history\n!*   2021/06/16: created (pb)\n!* copyright\n!*   (c) university of manchester\n!******/\n!> author: pieter boom\n!> date: 2021/06/16\n!> check for errors and return logical\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    implicit none\n\n    !-- arguments and result --\n    logical                       :: chkerr_log   !> error logical (return)\n    integer, intent(in)           :: ierr         !> error integer\n    integer, intent(in)           :: io_unit      !> io unit\n    character(len=*), intent(in)  :: str          !> error string\n\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n! main execution\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    !-- check for errors and exit graacefully if any found --\n    if (ierr /= 0) then; write(io_unit,'(a,i5)') 'error :: '//trim(str)//&\n      ' : errcode = ',ierr; chkerr_log = .true.; else; chkerr_log = .false.\n    end if;  return\n\n  end function\n"}, {"instruction": "Write a Fortran function named factorial_impure that calculates the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is 'n' and the output parameter is 'fac'. Remember, the function modifies the value of 'n' during calculation, which is not a good practice in Fortran programming.", "input": "", "output": "function factorial_impure(n) result(fac)\r\n! poor style -- n changed upon return\r\ninteger :: n\r\ninteger :: fac\r\nif (n < 2) then\r\n   fac = 1\r\n   return\r\nend if\r\nfac = n\r\ndo\r\n   n = n - 1\r\n   if (n < 2) return\r\n   fac = fac * n\r\nend do\r\nend function factorial_impure\r\n"}, {"instruction": "Create a Fortran function named int_args_func to calculate the sum of three integer inputs of kind 1, 2, and 4, and store the result in an integer output of kind 8. The number of input arguments is 4 with test_data type ['integer(kind=1)', 'integer(kind=2)', 'integer(kind=4)', 'integer(kind=8)'], and the number of output arguments is 1 with test_data type ['integer(kind=8)'].", "input": "", "output": "function int_args_func(a,b,c,d)\n      integer(kind=8) :: int_args_func\n      integer(kind=1), intent(in) :: a\n      integer(kind=2), intent(in) :: b\n      integer(kind=4), intent(in) :: c\n      integer(kind=8), intent(out) :: d\n\n      d = a + b + c\n      int_args_func = 10\n\nend function int_args_func\n"}, {"instruction": "Create a Fortran function named util_datetime_isleapyear that takes an integer input argument representing a year. This function should return an integer value indicating whether the input year is a leap year. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function util_datetime_isleapyear(year)\n        integer, intent(in) :: year\n        integer :: util_datetime_isleapyear\n        if ((mod(year,4) == 0) .and. ((mod(year,100) .ne. 0) .or. (mod(year,400) == 0))) then\n            util_datetime_isleapyear = 2\n        else\n            util_datetime_isleapyear = 1\n        end if\n    end function util_datetime_isleapyear\n"}, {"instruction": "Create a Fortran function named util_datetime_dayofweek to determine the day of the week based on the input epoch time. The function has 1 input parameter of type real(8) and 1 output parameter of type integer.", "input": "", "output": "    function util_datetime_dayofweek(epochtime)\n        real(8), intent(in) :: epochtime\n        integer :: t, util_datetime_dayofweek\n        t = floor(epochtime) + datedelta\n        util_datetime_dayofweek = mod(t, 7)+1\n    end function\n"}, {"instruction": "Write a Fortran function named d_dedxc_s2 to calculate a specific mathematical expression. The function takes 4 input arguments of type real: a, b, c, and u. It returns a single output of type real.", "input": "", "output": "      function d_dedxc_s2(a, b, c, u)\n      implicit none\n        real, intent(in) :: a, b, c, u\n        real             :: d_dedxc_s2\n        d_dedxc_s2= (c - log(u/(1-u)))*(b*sqrt(u) - 1/sqrt(u))\n        d_dedxc_s2=d_dedxc_s2 + 2/sqrt(u)\n        d_dedxc_s2=d_dedxc_s2*exp(-a*a*u)\n      end function d_dedxc_s2\n"}, {"instruction": "Create a Fortran function named kqm1 to calculate a specific mathematical function. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input and output parameters are of type real. Ensure the function follows the Fortran syntax.", "input": "", "output": " function kqm1(x)  \n   implicit none\n   real, intent(in) :: x\n   real :: kqm1\n\n   real, parameter :: xmin=0.15e0, xmax=3.2e0 \n\n   real, parameter :: a0= 0.4329117486761496454549449429 ! 3*gamma/4\n   real, parameter :: a1= 1.2020569031595942854250431561 ! zeta(3)\n   real, parameter :: a2= 0.1487967944177345026410993331 ! zeta'(3)+gamma*\n   real, parameter :: b2=-0.0416666666666666666666666667 !-1/24  zeta(3)/2\n   real, parameter :: b4=-0.0083333333333333333333333333 !-1/120\n   real, parameter :: b6=-0.0119047619047619047619047619 !-1/84\n   real, parameter :: c0= 0.25109815055856566000\n   real, parameter :: c1=-0.02989283169766254700\n   real, parameter :: c2= 0.03339880139150325000\n   real, parameter :: c3=-0.00799128953390392700\n   real, parameter :: c4= 0.00070251863606810650\n   real, parameter :: d0=-0.18373957827052560000\n   real, parameter :: d1=-0.33121125339783110000\n   real, parameter :: d2= 0.04022076263527408400\n   real, parameter :: d3=-0.00331897950305779480\n   real, parameter :: d4= 0.00012313574797356784\n   real :: x2, lx, xi\n   if ( x .le. xmin) then                        ! x < xmin=0.15: to 0.06%\n      x2=x*x                                     ! ln(x)/2 + 3*gamma/4 +\n      lx=log(x)                                  ! zeta(3)*x^2*ln(x) +\n      kqm1=0.5e0*lx + a0 + a1*x2*lx + a2*x2      ! [zeta'(3) + gamma*\n                                                 ! zeta(3)/2]*x^2\n                                                 !\n   elseif ( x .ge. xmax ) then                   ! x > xmax=3.2: to 0.12%\n      xi=1/x                                     ! -1/24*x^2 - 1/120*x^4 -\n      x2=xi*xi                                   ! 1/84*x^6\n      kqm1=b6                                    !\n      kqm1=b4 + kqm1*x2                          !\n      kqm1=b2 + kqm1*x2                          !\n      kqm1=kqm1*x2                               !\n   else\n      xi=1/x                                     ! xmin < x , xmax\n      lx=log(x)                                  ! fit accurate to 0.2%\n      kqm1=c4                                    ! c0 + c1*x + c2*x^2 +\n      kqm1=c3+kqm1*x                             ! c3*x^3 + c4*x^4 +\n      kqm1=c2+kqm1*x                             ! d0*ln(x) +\n      kqm1=c1+kqm1*x                             ! d1/x + d2/x^2 +\n      kqm1=c0+kqm1*x + d0*lx                     ! d3/x^3 + d4/x^4\n      lx=d4                                      !\n      lx=d3+lx*xi                                !\n      lx=d2+lx*xi                                !\n      lx=d1+lx*xi                                !\n      lx=lx*xi                                   !\n      kqm1=kqm1+lx\n   endif\n end function kqm1\n"}, {"instruction": "Create a Fortran function named kqm3 that takes a single real input parameter and returns a real output. The input parameter type is real, and the output parameter type is also real. This function computes and returns a value based on the input parameter according to specified mathematical formulae and conditions.", "input": "", "output": " function kqm3(x)  \n   implicit none\n   real, intent(in) :: x\n   real :: kqm3\n\n   real, parameter :: xmin=0.15e0, xmax=2.5e0 \n   real, parameter :: a0= 0.1829117486761496454549449429 ! 3*gamma/4 - 1/4\n   real, parameter :: a2=-0.6010284515797971427073328102 !-zeta(3)/2\n   real, parameter :: b2=-0.0833333333333333333333333333 !-1/12\n   real, parameter :: b4=-0.025                          !-1/40\n   real, parameter :: b6=-0.046875                       !-3/64\n   real, parameter :: c0= 0.691191700599840900000\n   real, parameter :: c1=-1.094849572900974000000\n   real, parameter :: c2= 0.318264617154601400000\n   real, parameter :: c3=-0.060275957444801354000\n   real, parameter :: c4= 0.005112428730167831000\n   real, parameter :: d0= 0.835543536679762600000\n   real, parameter :: d1= 0.047821976622976340000\n   real, parameter :: d2= 0.000053594881446931025\n   real, parameter :: d3=-0.000268040997573199600\n   real, parameter :: d4= 0.000015765134162582942\n   real :: x2, lx, xi\n   if ( x .le. xmin) then                        ! x < xmin=0.15: to 0.1%\n      x2=x*x                                     ! ln(x)/2 + 3*gamma/4 -1/4\n      lx=log(x)                                  ! -[zeta(3)/2]*x^2\n      kqm3=0.5e0*lx + a0 + a2*x2                 ! \n                                                 ! \n                                                 !\n   elseif ( x .ge. xmax ) then                   ! x > xmax=2.5: to 0.25%\n      xi=1/x                                     ! -1/12*x^2 - 1/40*x^4 -\n      x2=xi*xi                                   ! 3/64*x^6\n      kqm3=b6                                    !\n      kqm3=b4 + kqm3*x2                          !\n      kqm3=b2 + kqm3*x2                          !\n      kqm3=kqm3*x2                               !\n   else\n      xi=1/x                                     ! xmin < x < xmax\n      lx=log(x)                                  ! fit accurate to 0.04%\n      kqm3=c4                                    ! c0 + c1*x + c2*x^2 +\n      kqm3=c3+kqm3*x                             ! c3*x^3 + c4*x^4 +\n      kqm3=c2+kqm3*x                             ! d0*ln(x) +\n      kqm3=c1+kqm3*x                             ! d1/x + d2/x^2 +\n      kqm3=c0+kqm3*x + d0*lx                     ! d3/x^3 + d4/x^4\n      lx=d4                                      !\n      lx=d3+lx*xi                                !\n      lx=d2+lx*xi                                !\n      lx=d1+lx*xi                                !\n      lx=lx*xi                                   !\n      kqm3=kqm3+lx\n   endif\n end function kqm3\n"}, {"instruction": "Create a Fortran function named assert_eq4 to compare four integer values with a given tag. The function takes 5 input parameters of type character(len=*), integer, integer, integer, and integer, and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction assert_eq4(n1,n2,n3,n4,string)\n\tcharacter(len=*), intent(in) :: string\n\tinteger, intent(in) :: n1,n2,n3,n4\n\tinteger :: assert_eq4\n\tif (n1 == n2 .and. n2 == n3 .and. n3 == n4) then\n\t\tassert_eq4=n1\n\telse\n\t\twrite (*,*) 'nrerror: an assert_eq failed with this tag:', &\n\t\t\tstring\n\t\tstop 'program terminated by assert_eq4'\n\tend if\n\tend function assert_eq4\n"}, {"instruction": "Create a Fortran function named ran2 that generates random numbers using the input integer seed idum. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input parameter should be a seed for the random number generator, and the output parameter will be a random number between 0 and 1.", "input": "", "output": "      function ran2(idum)\n!---------------------------------------------------------------------\n\n!  name\n!  parameters:\n!       idum       : random seed\n!---------------------------------------------------------------------\n      implicit none\n\n      real :: ran2\n      integer, intent(inout) :: idum\n      integer, parameter :: im1=2147483563, im2=2147483399, imm1=im1-1\n      integer, parameter :: ia1=40014, ia2=40692, iq1=53668, iq2=52774\n      integer, parameter :: ir1=12211, ir2=3791, ntab=32, ndiv=1+imm1/ntab\n      real, parameter :: am=1./im1, eps=1.2e-7, rnmx=1.-eps\n      integer :: idum2=123456789, iy=0, j, k\n      integer, dimension(ntab) :: iv\n      \n      save iv,iy,idum2\n\n\n      do j=1,ntab\n        iv(j)=0\n      enddo\n\n      if(idum.le.0) then\n        idum=max(-idum,1)\n        idum2=idum\n        do j=ntab+8,1,-1\n          k=idum/iq1\n          idum=ia1*(idum-k*iq1)-k*ir1\n          if(idum.lt.0) idum=idum+im1\n          if(j.le.ntab) iv(j)=idum\n        enddo\n        iy=iv(1)\n      endif\n      k=idum/iq1\n      idum=ia1*(idum-k*iq1)-k*ir1\n      if(idum.lt.0) idum=idum+im1\n      k=idum2/iq2\n      idum2=ia2*(idum2-k*iq2)-k*ir2\n      if(idum2.lt.0) idum2=idum2+im2\n      j=1+iy/ndiv\n      iy=iv(j)-idum2\n      iv(j)=idum\n      if(iy.lt.1) iy=iy+imm1\n      ran2=min(am*iy,rnmx)\n      \n      end function ran2\n"}, {"instruction": "Write a Fortran function named upcase to convert a given input string to uppercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(string)).", "input": "", "output": "  function upcase(string) result(upper)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: upper\n    integer :: j\n    do j = 1,len(string)\n       if(string(j:j) >= \"a\" .and. string(j:j) <= \"z\") then\n          upper(j:j) = achar(iachar(string(j:j)) - 32)\n       else\n          upper(j:j) = string(j:j)\n       end if\n    end do\n  end function upcase\n"}, {"instruction": "Create a Fortran function named get_npelec that takes two integer input parameters, ntheta and nel. This function returns an integer output parameter. The function calculates the value of get_npelec as 2 times ntheta divided by nel divided by 3.", "input": "", "output": "function get_npelec(ntheta, nel)\n  integer, intent(in) :: ntheta, nel\n  integer :: get_npelec\n\n  get_npelec = 2*ntheta/nel/3\n  return\nend function get_npelec\n"}, {"instruction": "Create a Fortran pure function named is_atof to determine if a given string represents a valid floating-point number. The function takes 1 input argument of type character(len=*), and returns 1 output argument of type logical.", "input": "", "output": "  pure function is_atof(str) result(yes)\n    implicit none\n    character(len=*), intent(in) :: str\n    logical :: yes\n    !local variables\n    integer :: ierr,is,ie\n    double precision :: rval\n\n    ie=len_trim(str)\n    is=scan(trim(str),' ')+1\n    yes=scan(str(is:ie),' ') ==0 !there is no other space in the string\n    if (yes) then\n       read(str(is:ie),*,iostat=ierr)rval\n       yes=ierr==0 .and. str(max(ie,1):ie)/='/' !the slash terminator is not allowed\n    end if\n\n  end function is_atof\n"}, {"instruction": "Write a Fortran pure function named is_atol that takes a single input argument of type character(len=*) and returns a logical output. The function checks if the input string represents a logical value and returns true if the string is 'yes', 'no', 'true', or 'false', and false otherwise.", "input": "", "output": "  pure function is_atol(str) result(yes)\n    implicit none\n    character(len=*), intent(in) :: str\n    logical :: yes\n    !local variables\n    integer :: is,ie\n    !fill the string describing the format to be used for reading\n\n    ie=len(trim(str))\n    is=max(scan(trim(str),' '),1)\n    yes=scan(str(is:ie),' ') ==0 !there is no other space in the string\n    if (yes) yes= (ie-is+1==3 .and. any(str(is:ie) == ['yes', 'yes', 'yes'])) &\n       &     .or. (ie-is+1==2 .and. any(str(is:ie) == ['no', 'no', 'no'])) &\n       &     .or. (ie-is+1==4 .and. any(str(is:ie) == ['true', 'true', 'true'])) &\n       &     .or. (ie-is+1==5 .and. any(str(is:ie) == ['false', 'false', 'false']))\n  end function is_atol\n"}, {"instruction": "Create a Fortran function named case_insensitive_equiv to compare two input strings for case-insensitive equivalence. The function should take 2 input parameters of type character with varying length and return 1 output parameter of type logical.", "input": "", "output": "  pure function case_insensitive_equiv(stra,strb)\n    implicit none\n    character(len=*), intent(in) :: stra,strb\n    logical :: case_insensitive_equiv\n    !local variables\n    integer :: i,ica,icb,ila,ilb,ilength\n    ila=len(stra)\n    ilb=len(strb)\n    ilength=min(ila,ilb)\n    ica=ichar(stra(1:1))\n    icb=ichar(strb(1:1))\n    case_insensitive_equiv=(modulo(ica-icb,32) == 0) .and. (ila==ilb)\n    do i=2,ilength\n       ica=ichar(stra(i:i))\n       icb=ichar(strb(i:i))\n       case_insensitive_equiv=case_insensitive_equiv .and. &\n            &   (modulo(ica-icb,32) == 0)\n       if (.not. case_insensitive_equiv) exit\n    end do\n\n  end function case_insensitive_equiv\n"}, {"instruction": "Write a Fortran function named combine_strings to combine two input strings into a single output string. The number of input parameters is 2, with test_data types of ['character(len=*)', 'character(len=*)']. The number of output parameters is 1, with a test_data type of ['character(len=len_trim(a)+len_trim(b))'].", "input": "", "output": "  pure function combine_strings(a,b) result(c)\n    implicit none\n    character(len=*), intent(in) :: a\n    character(len=*), intent(in) :: b\n    character(len=len_trim(a)+len_trim(b)) :: c\n    c=trim(a)//trim(adjustl(b))\n  end function combine_strings\n"}, {"instruction": "Create a Fortran function named add_two_big_nums that takes two character strings as input parameters. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The function returns a single character string as output, with the test_data type of ['character(len=:), allocatable']. The function is designed to add two large numbers represented as character strings and return the result as a character string.", "input": "", "output": "  pure function add_two_big_nums(a,b)\n    ! default\n    implicit none\n\n    ! local parameters\n    integer(4), parameter :: i_max    = int(log10(1d0*huge(int(1,kind=4))/10))-1\n    integer(4), parameter :: i_max_10 = 10**(i_max)\n\n    character(*), intent(in) :: a,b\n    character(len=:), allocatable :: add_two_big_nums\n\n    ! local variables\n    integer(4)     :: i,i1,i2,j,idx\n    integer(4)     :: carry,n_words,temp\n    integer(4)     :: a_size,b_size,o_size\n    integer(4)     :: a_words,b_words,o_words\n    logical        :: include_pad\n    character(11)  :: zero_pad\n    character(100) :: read_tag,write_tag\n\n    ! local arrays\n    integer(4), dimension(:), allocatable :: a_int,b_int,o_int\n\n    ! find the number of digits of the numbers\n    a_size = len_trim(a)\n    b_size = len_trim(b)\n\n    ! determine how many words we need\n    a_words = ceiling(1d0*a_size/i_max)\n    b_words = ceiling(1d0*b_size/i_max)\n    o_words = a_words+b_words\n\n    ! allocate necessary arrays\n    allocate(a_int(o_words))\n    allocate(b_int(o_words))\n    allocate(o_int(o_words))\n\n    ! initialize\n    a_int = 0\n    b_int = 0\n    o_int = 0\n\n    ! break the inputs into words\n    ! we actually store the numbers backwards in our arrays\n    n_words = 1 + a_size/i_max\n    write(read_tag,'(a,i12,a)') '(i',i_max,')'\n    do i=1,n_words\n       i1 = max(a_size - i*i_max + 1, 1)\n       i2 = a_size - (i-1)*i_max\n       read(a(i1:i2),trim(read_tag)) a_int(i)\n    enddo\n\n    n_words = 1 + b_size/i_max\n    do i=1,n_words\n       i1 = max(b_size - i*i_max + 1,1)\n       i2 = b_size - (i-1)*i_max\n       read(b(i1:i2),trim(read_tag)) b_int(i)\n    enddo\n\n    ! add the numbers together one word at a time, and carry the results\n    carry = 0\n    do i=1,o_words\n       temp = a_int(i) + b_int(i) + carry\n       ! only save the amount that will fit in i_max digits\n       o_int(i) = mod(temp,i_max_10)\n       ! carry the rest\n       carry = temp/i_max_10\n    enddo\n\n    ! determine the final number of digits that we need to save our number\n    ! first check to see if we over-allocated the number of words needed\n    do while (o_int(o_words) == 0)\n       o_words = o_words - 1\n    enddo\n    o_size = 1 + int(log10(1d0*o_int(o_words))) + i_max*(o_words-1)\n\n    allocate(character(len=o_size) :: add_two_big_nums)\n\n    ! write out the answer\n    write(write_tag,'(a,i11,a)') '(i',i_max,')'\n\n    ! we actually go from right-to-left, since the big number is stored in\n    !   the array as \"little-endian\" but we read the number as \"big-endian\"\n    do i=1,o_words\n       ! find the bounds of this segment\n       i1 = max(o_size - i*i_max + 1, 1)\n       i2 = o_size - (i-1)*i_max\n\n       ! find the size of the write tag to make\n       ! first, test to see if the segment is all zeros\n       if (o_int(i)==0) then\n          do idx=1,i_max\n             write(zero_pad(idx:idx),'(a)') '0'\n          enddo\n          write(write_tag,'(a,i11,a)') '(a',i_max,')'\n          write(add_two_big_nums(i1:i2),write_tag) trim(zero_pad)\n          cycle\n       endif \n\n       ! now check to see if we need to pad with leading zeros\n       include_pad = .false.\n       do j=1,i2-i1\n          ! test to see if segment needs leading zeros\n          if (mod(o_int(i),10**j)==o_int(i)) then\n             include_pad = .true.\n             write(write_tag,'(a,i11,a,i11,a)') '(a',i2-i1-j+1,',i',j,')'\n             do idx=1,i2-j+1\n                write(zero_pad(idx:idx),'(a)') '0'\n             enddo\n             exit\n          endif\n       enddo\n\n       if (include_pad) then\n          write(add_two_big_nums(i1:i2),write_tag) trim(zero_pad),o_int(i)\n       else\n          write(write_tag,'(a,i11,a)') '(i',i2-i1+1,')'\n          write(add_two_big_nums(i1:i2),write_tag) o_int(i)\n       endif\n    enddo\n\n    return\n  end function add_two_big_nums\n"}, {"instruction": "Create a Fortran function named ichoice to generate a random integer between 0 and n-1. The number of input parameters is 1 with the test_data type ['integer'], and the number of output parameters is 1 with the test_data type ['integer'].", "input": "", "output": "  function ichoice(n)\n    !-------------------------------------------\n    !\n    !-------------------------------------------\n    integer,intent(in)::n\n    integer           ::ichoice\n    real*8::rng\n    call random_number(rng)\n    ichoice = int(rng*n)\n  end function ichoice\n"}, {"instruction": "Write a Fortran function named func_apod_filter to calculate the apodization function value for a given input based on apodization parameter and filter cutoff frequency. The function accepts 3 input parameters of type real*8: x, apod, and filter_df. The output parameter is a single real*8 value. If x is less than filter_df, the function computes 1 - apod and returns the result as func_apod_filter.", "input": "", "output": "  function func_apod_filter(x, apod, filter_df)\n\n    real*8 :: func_apod_filter, x, apod, filter_df\n\n    func_apod_filter = 0\n    if (x < filter_df) then\n      func_apod_filter = 1 - apod\n    end if\n\n  end function func_apod_filter\n"}, {"instruction": "Provide a Fortran function named factorial_f that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use recursive calls to calculate the factorial.", "input": "", "output": "    recursive function factorial_f(i) result(answer)\n        integer             :: answer\n        integer, intent(in) :: i\n\n        if (i == 0) then\n            answer = 1\n        else\n            answer = i * factorial_f(i - 1)\n        end if\n    end function factorial_f\n"}, {"instruction": "Create a Fortran function named count_divisors to calculate the number of divisors of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is labeled as intent(in).", "input": "", "output": "function count_divisors(number)\n        implicit none\n        integer, intent(in) :: number\n        integer :: count_divisors\n        integer :: i\n\n        count_divisors = 1\n        do i = 2, number / 2\n            if (mod(number, i) == 0) then\n                count_divisors = count_divisors + 1\n            end if\n        end do\n\n        count_divisors = count_divisors + 1\n        \n    end function count_divisors\n"}, {"instruction": "Create a Fortran function named initialvelocity that takes two real(kind=8) input parameters, normalizedgravity and moonsemimajoraxis. It returns a single real(kind=8) output parameter. The function computes the initial velocity required for a spacecraft in a circular orbit around the moon, using the formula initialvelocity = sqrt(normalizedgravity / moonsemimajoraxis).", "input": "", "output": "function initialvelocity(normalizedgravity, moonsemimajoraxis)\n\timplicit none\n\n\treal(kind = 8), intent(in) :: normalizedgravity\n\treal(kind = 8), intent(in) :: moonsemimajoraxis\n\treal(kind = 8) :: initialvelocity\n\n\tinitialvelocity = sqrt(normalizedgravity / moonsemimajoraxis)\n\n\treturn\nend function\n"}, {"instruction": "Create a Fortran function named sigm that takes a double precision input argument and returns a double precision value. The input parameter type is ['double precision'] and the output parameter type is ['double precision']. The function calculates the value of the sigmoid function using the formula sigm = 5/(1 + exp(0.56*(6-x))).", "input": "", "output": "      function sigm(x)\n!----------------------------------------\n\n!----------------------------------------\n      implicit none\n      double precision :: sigm, x\n      sigm = 5/(1 + exp(0.56*(6-x)))\n      return\n      end function sigm\n"}, {"instruction": "Create a Fortran function named leap_year to determine if the given year is a leap year. The function takes 1 input argument of type integer and returns 1 output argument of type logical. The input test_data type is ['integer'], and the output test_data type is ['logical'].", "input": "", "output": "pure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n \n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n \nend function leap_year\n"}, {"instruction": "Write a Fortran function named blmetric_con_real to calculate the Boyer-Lindquist covariant metric components. The function takes 4 input parameters: r (real, dimension(:)), th (real, dimension(:)), a (real), and con (integer). The output parameter is blmetric (real, dimension(size(r),10)).", "input": "", "output": "        function blmetric_con_real(r,th,a,con) result(blmetric)\n        ! returns boyer-lindquist covariant metric components\n        ! jad 10/1/2008, fortran 3/28/2011\n        real, dimension(:), intent(in) :: r,th\n        real, intent(in) :: a\n        integer, intent(in) :: con\n        real, dimension(size(r),10) :: blmetric\n!        real, dimension(10,size(r)) :: gmunu\n        real, dimension(size(r)) :: cth,sth,delta, &\n        rho2,sigma\n        cth=cos(th); sth=sin(th)\n        delta=r*r-2.*r+a*a\n        rho2=r*r+a*a*cth*cth\n        sigma=(r*r+a*a)**2-a*a*delta*sth*sth\n        blmetric=0d0\n        blmetric(:,1)=-((r*r+a*a)**2-a*a*delta*sth*sth)/rho2/delta\n        blmetric(:,4)=-2*a*r/rho2/delta\n        blmetric(:,5)=delta/rho2\n        blmetric(:,8)=1./rho2\n        blmetric(:,10)=(delta-a*a*sth*sth)/delta/rho2/sth/sth\n!        gmunu=transpose(blmetric)\n        end function blmetric_con_real\n"}, {"instruction": "Create a Fortran function named ksmetric_cov to calculate the Boyer-Lindquist covariant metric components. The function takes 4 input arguments of type real(8) arrays: r, th, ph, and a. It returns 1 output argument of type real(8) array with dimensions size(r) by 10.", "input": "", "output": "        function ksmetric_cov(r,th,ph,a) result(ksmetric)\n        ! returns boyer-lindquist covariant metric components\n        ! jad 10/1/2008, fortran 3/28/2011\n        ! doesn't actually depend on ph unless you're doing tilted metric!\n        real(8), dimension(:), intent(in) :: r,th,ph\n        real(8), intent(in) :: a\n        real(8), dimension(size(r),10) :: ksmetric\n        real(8), dimension(size(r)) :: ctheta,stheta,rho2,psi4\n        ctheta=cos(th); stheta=sin(th)\n        rho2=r**2+a**2*ctheta**2\n        psi4=2d0*r/rho2\n        ksmetric=0.\n        ksmetric(:,1)=-(1.-psi4)\n        ksmetric(:,2)=psi4\n        ksmetric(:,4)=-a*stheta**2*psi4\n        ksmetric(:,5)=1.+psi4\n        ksmetric(:,7)=-a*stheta**2*(1.+psi4)\n        ksmetric(:,8)=rho2\n        ksmetric(:,10)=stheta**2*(rho2+a**2*(1.+2d0*r/rho2)*stheta**2)\n!        write(6,*) 'ksmetric kerr: ',ksmetric(1,:)\n      end function ksmetric_cov\n"}, {"instruction": "Create a Fortran function named \"mnt_ncattributes_del\" to delete attributes associated with a netCDF field. The function takes 1 input parameter of type \"type(c_ptr)\" and returns 1 output parameter of type \"integer(c_int)\".", "input": "", "output": "    function mnt_ncattributes_del(obj) &\r\n                                  bind(c, name='mnt_ncattributes_del')\r\n      ! destructor\r\n      ! @param obj instance of mntncfieldread_t (opaque handle)\r\n      ! @return 0 if successful\r\n      use, intrinsic :: iso_c_binding, only: c_int, c_double, c_ptr\r\n      implicit none\r\n      type(c_ptr), intent(inout)       :: obj ! void**\r\n      integer(c_int)                   :: mnt_ncattributes_del\r\n    end function mnt_ncattributes_del\r\n"}, {"instruction": "Create a Fortran function named c_conduit_blueprint_table_verify to verify a blueprint table. The function takes 2 input parameters of type 'type(c_ptr), value' and returns 1 output parameter of type 'logical(c_bool)'.", "input": "", "output": "        function c_conduit_blueprint_table_verify(cnode, cinfo) result(res) &\n                bind(c, name=\"conduit_blueprint_table_verify\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value, intent(in) :: cnode\n            type(c_ptr), value, intent(in) :: cinfo\n            logical(c_bool) ::res\n        end function c_conduit_blueprint_table_verify\n"}, {"instruction": "Write a Fortran function named linear_int to calculate the distance between two points in a linear interval. The function takes 3 input arguments of type real, representing the values a, b, and delta. It returns 1 output argument of type real.", "input": "", "output": " function linear_int(a,b,delta) result(dist)\n\n   real, intent(in) :: a,b,delta\n   real :: dist\n\n   dist = delta/(1.+abs(b)/abs(a))\n   \n   return\n end function linear_int\n"}, {"instruction": "Write a Fortran function called minmod to calculate the minimum of two real numbers. This function takes 2 input arguments of type real and returns 1 output argument of type real. If the product of the input numbers is greater than 0, the function returns the smaller of the two input numbers. If the product is less than or equal to 0, the function returns 0.", "input": "", "output": " function minmod(a,b) result(mm)\n\n   real, intent(in) :: a,b\n   real :: a1,b1,ab, mm\n\n   a1 = abs(a)\n   b1 = abs(b)\n   ab = a*b\n   \n   if (ab .gt. 0.) then\n      if (a1 .le. b1) then\n         mm = a\n      else\n         mm = b\n      endif\n   else\n      mm = 0.\n   endif\n   \n   return\n end function minmod\n"}, {"instruction": "Create a Fortran function named minabs that takes two real numbers as input arguments and returns the minimum absolute value of the two inputs as the output. The number of input arguments is 2 and the test_data type is [real, real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": " function minabs(a,b) result(mm)\n\n   real, intent(in) :: a,b\n   real :: a1,b1, mm\n\n   a1 = abs(a)\n   b1 = abs(b)\n   \n   if (a1 .lt. b1) then\n      mm = a\n   else\n      mm = b\n   endif\n   \n   return\n end function minabs\n"}, {"instruction": "Provide a Fortran function named timeincrement that takes an integer input argument and returns a character string. The number of input arguments is 1 with the test_data type being ['integer'], and the number of output arguments is 1 with the test_data type being ['character(20)'].", "input": "", "output": "  function timeincrement(isec) result(template)\n    implicit none\n\n    integer       :: isec\n    character(20) :: template\n\n    character(18):: tmp\n    !---------------------------------------------------------------------------\n\n    write(tmp,*) max(isec/60, 1)\n\n    template = trim(tmp)//'mn'\n\n  end function timeincrement\n"}, {"instruction": "Create a Fortran function called upcase to convert a given string to uppercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(s)). The input parameter should be a string, and the output is the same string in uppercase.", "input": "", "output": "function upcase(s) result(t)\n! returns string 's' in uppercase\ncharacter(*), intent(in) :: s\ncharacter(len(s)) :: t\ninteger :: i, diff\nt = s; diff = ichar('a')-ichar('a')\ndo i = 1, len(t)\n    if (ichar(t(i:i)) >= ichar('a') .and. ichar(t(i:i)) <= ichar('z')) then\n        ! if lowercase, make uppercase\n        t(i:i) = char(ichar(t(i:i)) + diff)\n    end if\nend do\nend function\n"}, {"instruction": "Write a Fortran function named \"compute\" that calculates the sum of two double-precision floating-point numbers. The function should have 2 input parameters of type double precision, and the test_data type is ['double precision', 'double precision']. It should also have 1 output parameter of type double precision, with the test_data type being ['double precision'].", "input": "", "output": "  function compute(x, y) result (z)\n\n    double precision :: x, y, z\n\n    min_value = min(x,y)\n    z = x + y\n\n    return\n  end function compute\n"}, {"instruction": "Write a Fortran function named d_nso2nn that converts a one-electron Hamiltonian matrix from a spin-orbit basis to a spin basis. The function takes 3 input parameters: nspin (integer), norb (integer), and hso (real(8) matrix of dimension nspin*norb x nspin*norb). It returns a single output parameter hnn (real(8) matrix of dimension nspin x nspin x norb x norb).", "input": "", "output": "  function d_nso2nn(hso,nspin,norb) result(hnn)\n    integer                                  :: nspin,norb\n    real(8),dimension(nspin*norb,nspin*norb) :: hso\n    real(8),dimension(nspin,nspin,norb,norb) :: hnn\n    integer                                  :: iorb,ispin,is\n    integer                                  :: jorb,jspin,js\n    hnn=zero\n    do ispin=1,nspin\n       do jspin=1,nspin\n          do iorb=1,norb\n             do jorb=1,norb\n                is = iorb + (ispin-1)*norb  !spin-orbit stride\n                js = jorb + (jspin-1)*norb  !spin-orbit stride\n                hnn(ispin,jspin,iorb,jorb) = hso(is,js)\n             enddo\n          enddo\n       enddo\n    enddo\n  end function d_nso2nn\n"}, {"instruction": "Create a Fortran function named uf_find to implement the union-find find algorithm. The function takes 2 input parameters with test_data type ['integer', 'integer, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "        function uf_find(x, labels) result(y)\n            !! union-find find algorithm:\n            !! find the lowest corresponding label.\n            !! relabelling is done when necessary.\n            integer, intent(in) :: x\n                !! label for which to find the lowest corresponding label.\n            integer, dimension(:), intent(inout) :: labels\n                !! list of labels. **labels(i)** points to the lowest\n                !! corresponding label of label **i**.\n            integer :: y, z, tmp\n\n            y = x\n            do while(labels(y) /= y)\n                y = labels(y)\n            end do\n\n            tmp = x\n            do while(labels(tmp) /= tmp)\n                z = labels(tmp)\n                labels(tmp) = y\n                tmp = z\n            end do\n        end function\n"}, {"instruction": "Write a Fortran function named distancesquared_capturezone to compute the distance squared between points A and C in relation to line segment AB. The number of input arguments is 6, and the test_data type is ['real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 1, and the test_data type is ['real(8)'].", "input": "", "output": "   function distancesquared_capturezone( ax, ay, bx, by, cx, cy ) result( d2 )\n\n   ! declare the arguments.\n   real(8), intent(in) :: ax, ay, bx, by, cx, cy\n   real(8)             :: d2\n\n   ! declare the local variables.\n   real(8) :: bax, bay, cax, cay\n   real(8) :: perpdot, dot\n   real(8) :: length2, alpha2, beta2\n\n   ! compute the distance squared.\n   bax = bx - ax\n   bay = by - ay\n\n   cax = cx - ax\n   cay = cy - ay\n\n   perpdot = bax*cay - bay*cax\n   dot     = bax*cax + bay*cay\n   length2 = bax*bax + bay*bay\n\n   alpha2  = perpdot*perpdot / length2\n   beta2   = dot*dot / length2\n\n   if( dot < 0 ) then\n      d2 = alpha2 + beta2\n   else if( beta2 > length2 ) then\n      d2 = alpha2 + beta2 - 2*dot + length2\n   else\n      d2 = alpha2\n   end if\n\n   end function distancesquared_capturezone\n"}, {"instruction": "Create a Fortran pure function named tostr that takes an integer input and returns a string representation of the integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=20)'].", "input": "", "output": "          pure function tostr(k) result(str)\n              integer, intent(in) :: k\n              character(len=20) :: str\n\n              write(str, *) k\n              str = adjustl(str)\n          end function tostr\n"}, {"instruction": "Create a Fortran function named f that calculates a mathematical function. The function takes 1 input parameter of real type and returns 1 output parameter of real type. The input and output test_data types are ['real'].", "input": "", "output": "function f(x)\nimplicit none\nreal :: x, f\nf = (x**2) - (2*x) + 1\n! f = (x**3) + (3*(x**2)) + (3*x) + 1\n! f = x-exp(-x/3)\nend function\n"}, {"instruction": "Create a Fortran function named near to compute the corrected distance between points. The function takes 2 input arguments with test_data type [real*8, real*8] and returns 1 output argument with test_data type [real*8]. This function corrects for wrap-around when evaluating distances between points. Use imperative tone in the instructions.", "input": "", "output": "function near(dist,domain)\n\n! to correct for wrap-around when evaluating distances\n! between points\n\nimplicit none\nreal*8, intent(in) :: dist, domain\nreal*8 :: near\nreal*8 :: hdom\n\nhdom = 0.5*domain\nnear = dist\nif (dist .ge.  hdom) near = near - domain\nif (dist .le. -hdom) near = near + domain\n\nend function near\n"}, {"instruction": "Create a Fortran function named byte_pos that takes an integer input argument and returns the position of the next record in bytes. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function byte_pos(uni)\r\n  integer:: byte_pos\r\n  integer, intent(in):: uni\r\n  integer:: i\r\n!  inquire(uni, pos= i )                    !##g95##\r\n  inquire(uni, nextrec= i )               !##lf95##\r\n  byte_pos = i\r\nend function byte_pos\r\n"}, {"instruction": "Create a Fortran function named cloud_top_pressure to calculate the extinction-weighted pressure based on the given arrays of tauincrement and pressure, and the specified taulimit. The function has 3 input parameters of type real, dimension(:), real, dimension(:), and real, and 1 output parameter of type real.", "input": "", "output": "  function cloud_top_pressure(tauincrement, pressure, taulimit) \n    real, dimension(:), intent(in) :: tauincrement, pressure\n    real,               intent(in) :: taulimit\n    real                           :: cloud_top_pressure\n    !\n    ! find the extinction-weighted pressure. assume that pressure varies linearly between \n    !   layers and use the trapezoidal rule.\n    !\n    \n    real :: deltax, totaltau, totalproduct\n    integer :: i \n    \n    totaltau = 0.; totalproduct = 0. \n    do i = 2, size(tauincrement)\n      if(totaltau + tauincrement(i) > taulimit) then \n        deltax = taulimit - totaltau\n        totaltau = totaltau + deltax\n        !\n        ! result for trapezoidal rule when you take less than a full step\n        !   tauincrement is a layer-integrated value\n        !\n        totalproduct = totalproduct           &\n                     + pressure(i-1) * deltax &\n                     + (pressure(i) - pressure(i-1)) * deltax**2/(2. * tauincrement(i)) \n\n!bloss: i think the code below has an extra factor of deltax after the plus sign.\n!bloss    the above code is taken from cosp v1.4, where this seems to have been fixed.\n!bloss        totalproduct = totalproduct + &\n!bloss                       deltax * ((pressure(i) - pressure(i-1)) * deltax**2/(2. * tauincrement(i)) + &\n!bloss                                 pressure(i-1) * deltax)\n      else\n        totaltau =     totaltau     + tauincrement(i) \n        totalproduct = totalproduct + tauincrement(i) * (pressure(i) + pressure(i-1)) / 2.\n      end if \n      if(totaltau >= taulimit) exit\n    end do \n    cloud_top_pressure = totalproduct/totaltau\n  end function cloud_top_pressure\n"}, {"instruction": "Create a Fortran function named weight_by_extinction to calculate the extinction-weighted value of f(tau) with the given parameters. The function takes 3 input arguments: two real arrays of any size (tauincrement, f) and a single real value (taulimit). The function returns a single real value as the output.", "input": "", "output": "  function weight_by_extinction(tauincrement, f, taulimit) \n    real, dimension(:), intent(in) :: tauincrement, f\n    real,               intent(in) :: taulimit\n    real                           :: weight_by_extinction\n    !\n    ! find the extinction-weighted value of f(tau), assuming constant f within each layer\n    !\n    \n    real    :: deltax, totaltau, totalproduct\n    integer :: i \n    \n    totaltau = 0.; totalproduct = 0. \n    do i = 1, size(tauincrement)\n      if(totaltau + tauincrement(i) > taulimit) then \n        deltax       = taulimit - totaltau\n        totaltau     = totaltau     + deltax\n        totalproduct = totalproduct + deltax * f(i) \n      else\n        totaltau     = totaltau     + tauincrement(i) \n        totalproduct = totalproduct + tauincrement(i) * f(i) \n      end if \n      if(totaltau >= taulimit) exit\n    end do \n    weight_by_extinction = totalproduct/totaltau\n  end function weight_by_extinction\n"}, {"instruction": "Create a Fortran pure function named interpolate_to_min. It takes 3 input parameters: x (real, dimension(:)), y (real, dimension(:)), and yobs (real). The output parameter is a real value. The function finds the value of x that minimizes the absolute difference between y and yobs. The input arrays x and y are assumed to be monotonic.", "input": "", "output": "  pure function interpolate_to_min(x, y, yobs)\n    real, dimension(:), intent(in) :: x, y \n    real,               intent(in) :: yobs\n    real                           :: interpolate_to_min\n    ! \n    ! given a set of values of y as y(x), find the value of x that minimizes abs(y - yobs)\n    !   y must be monotonic in x\n    !\n    real, dimension(size(x)) :: diff\n    real                     :: weight\n    integer                  :: npoints, mindiffloc, lowerbound, upperbound\n    ! ---------------------------------\n    npoints = size(y)\n    diff(:) = y(:) - yobs\n    mindiffloc = minloc(abs(diff), dim = 1) \n    \n    if(mindiffloc == 1) then \n      lowerbound = mindiffloc\n      upperbound = mindiffloc + 1\n    else if(mindiffloc == npoints) then\n      lowerbound = mindiffloc - 1\n      upperbound = mindiffloc\n    else\n      if(diff(mindiffloc-1) * diff(mindiffloc) < 0) then\n        lowerbound = mindiffloc-1\n        upperbound = mindiffloc\n      else \n        lowerbound = mindiffloc\n        upperbound = mindiffloc + 1\n      end if \n    end if \n    \n    if(diff(lowerbound) * diff(upperbound) < 0) then     \n      !\n      ! interpolate the root position linearly if we bracket the root\n      !\n      interpolate_to_min = x(upperbound) - & \n                           diff(upperbound) * (x(upperbound) - x(lowerbound)) / (diff(upperbound) - diff(lowerbound))\n    else \n      interpolate_to_min = re_fill\n    end if \n    \n\n  end function interpolate_to_min\n"}, {"instruction": "Create a Fortran function named replace_text that replaces occurrences of a specific text within a given string with another specified text. The number of input arguments is 3 with test_data type ['character(*)', 'character(*)', 'character(*)'], and the number of output arguments is 1 with test_data type ['character(len(s)+100)'].", "input": "", "output": "\tfunction replace_text (s,text,rep)  result(outs)\n\t\tcharacter(*)        :: s,text,rep\n\t\tcharacter(len(s)+100) :: outs     ! provide outs with extra 100 char len\n\t\tinteger             :: i, nt, nr\n\n\t\touts = s ; nt = len_trim(text) ; nr = len_trim(rep)\n\t\tdo\n\t\t   i = index(outs,text(:nt)) ; if (i == 0) exit\n\t\t   outs = outs(:i-1) // rep(:nr) // outs(i+nt:)\n\t\tend do\n\tend function replace_text\n"}, {"instruction": "Write a Fortran function named strupper to convert a given input string to uppercase. The function should take 1 input parameter of type character(*) and return 1 output parameter of type character(len(s1)).", "input": "", "output": "\tfunction strupper(s1)  result (s2)\n\t\timplicit none\n\t\tcharacter(*)       :: s1\n\t\tcharacter(len(s1)) :: s2\n\t\tcharacter          :: ch\n\t\tinteger,parameter  :: duc = ichar('a') - ichar('a')\n\t\tinteger            :: i\n\n\t\tdo i = 1,len(s1)\n\t\t   ch = s1(i:i)\n\t\t   if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)+duc)\n\t\t   s2(i:i) = ch\n\t\tend do\n\tend function strupper\n"}, {"instruction": "Create a Fortran function named strlower that takes a single input argument of type character(*) and returns a single output argument of type character(len(s1)). The function converts all characters in the input string to lowercase and returns the modified string.", "input": "", "output": "\tfunction strlower(s1)  result (s2)\n\t\timplicit none\n\t\tcharacter(*)       :: s1\n\t\tcharacter(len(s1)) :: s2\n\t\tcharacter          :: ch\n\t\tinteger,parameter  :: duc = ichar('a') - ichar('a')\n\t\tinteger            :: i\n\n\t\tdo i = 1,len(s1)\n\t\t   ch = s1(i:i)\n\t\t   if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)-duc)\n\t\t   s2(i:i) = ch\n\t\tend do\n\tend function strlower\n"}, {"instruction": "Create a Fortran function named rm_char that removes a specified character from a given string. The function takes 2 input parameters: in_str of type character(*) and target_char of type character. It returns 1 output parameter: out_str of type character(:), allocatable.", "input": "", "output": "      function rm_char(in_str, target_char) result(out_str)\n\n      character(*), intent(in) :: in_str\n\n      character :: target_char\n\n      character(:), allocatable :: out_str\n\n      character :: ch\n\n      integer :: j\n\n      out_str = ' '\n\n      do j = 1, len_trim(in_str)\n\n         ch = in_str(j : j)\n\n         if (ch .ne. target_char) out_str = trim(out_str) // ch\n\n      enddo\n\n      out_str = trim(adjustl(out_str))\n\n      return\n\n      end function rm_char\n"}, {"instruction": "Create a Fortran function named y that takes a real number as input and returns a real number as output. The function calculates the value of y using the formula y = 5*x^3 + 2*x^2 - 3*x.", "input": "", "output": "function y(x)   !defining algebric function\r\n    implicit none\r\n    real :: y   !dummy argument\r\n    real :: x   !local variable\r\n    y=5*(x**3)+2*(x**2)-3*x\nend function\r\n"}, {"instruction": "Create a Fortran function named ddy to calculate the second derivative of a given algebraic function. The function takes 1 input parameter of type real, and returns 1 output parameter of type real.", "input": "", "output": "function ddy(x) !second derivative of above algebric function\r\n    implicit none\r\n    real :: ddy   !dummy argument\r\n    real :: x   !local variable\r\n    ddy=30*x+4\nend function\r\n"}, {"instruction": "Create a Fortran function named simpson, which uses Simpson's rule to compute the definite integral of a set of data points. The function takes 3 input parameters: an integer n, and two arrays x and y of type real(kind=dp) and dimension n. It returns a real(kind=dp) value as the result of the integration.", "input": "", "output": "        function simpson(x,y,n)\n                implicit none\n                integer, parameter :: dp = selected_real_kind(14)\n                integer, intent(in) :: n\n                integer :: i\n                real(kind=dp) :: simpson\n                real(kind=dp), dimension(n), intent(in) :: x, y\n                real(kind=dp) :: sum, h\n\n                sum = 0.0d0\n                h = dabs(x(n) - x(1))/dfloat(n-1)\n                do i=1, n/2 ! since n is odd, n/2 is the same as (n-1)/2\n                        sum = sum + y(2*i-1) + 4.0d0*y(2*i) + y(2*i+1)\n                end do\n                simpson = sum*h/3.0d0\n        end function simpson\n"}, {"instruction": "Create a Fortran function named hpa that takes two real numbers as input parameters, a and e, both of type real(real64), and returns a single real number of type real(real64). The function computes the value of hpa based on the input parameters using a series of mathematical operations and returns the result.", "input": "", "output": "  function hpa (a, e)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64),   intent(in   ) :: e\n    real(real64)                  :: hpa\n\n    real(real64) :: aln, sha, z\n\n! ======================================================================\n\n    aln = log(a)\n    sha = 1.0663d0 - 0.0023d0*aln\n    z = log(e)\n    hpa = 0.0375d0*(z - 16.5d0) + sha*exp(-0.11d0*z)\n    return\n\n! ======================================================================\n  end function hpa\n"}, {"instruction": "Write a Fortran function named \"udel\" to calculate the value of a mathematical expression. The input parameter is of type real(real64), and the output parameter is also of type real(real64). The function should compute the result using the given formula and return the value.", "input": "", "output": "  function udel (a)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!    edited by lmk, xcp-3, july 2013 (included error protection).\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64)                  :: udel\n\n    real(real64) :: temp\n\n! ======================================================================\n\n    temp = 1.d0 + 0.003d0*a*a\n    udel = 5.82d0 - 0.07d0/(temp)\n    return\n\n! ======================================================================\n  end function udel\n"}, {"instruction": "Create a Fortran function named \"wha\" to compute a mathematical operation on a real number. The function takes 1 input parameter of type real(real64) and returns 1 output parameter of the same type. The function calculates the value using the logarithm and square root operations.", "input": "", "output": "  function wha (a)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64)                  :: wha\n\n    real(real64) :: ala\n\n! ======================================================================\n\n    ala = log(a)\n    wha = 0.045d0 + 0.04d0*ala*sqrt(abs(ala))\n    return\n\n! ======================================================================\n  end function wha\n"}, {"instruction": "Create a Fortran function named phi_b that takes 4 real(8) input parameters and returns a single real(8) output parameter. The function computes a value based on the input parameters, involving mathematical operations and trigonometric functions.", "input": "", "output": "  function phi_b( r, theta, di, dj )\n    implicit none\n    real(8) :: phi_b\n    real(8),intent(in)  :: r, theta, di, dj\n    real(8) :: a,b,www,ttt !,gamma,pi\n    real(8) :: ct,st,sa,sb,ca,cb,hai,haj,hbi,hbj,vai,vaj,vbi,vbj\n    real(8) :: a2,b2,cai,cbi,caj,cbj,gdidi_i,gdjdj_i\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gamma=1.396263401595464d0\n    real(8),parameter :: thr=3.0d0\n\n!    pi = acos(-1.0d0)\n!    gamma = 4.0d0*pi/9.0d0\n\n    a = r*cos(theta)\n    b = r*sin(theta)\n\n    a2=a*a\n    b2=b*b\n\n    gdidi_i = gamma/(di*di)\n    gdjdj_i = gamma/(dj*dj)\n\n    cai = a2*gdidi_i\n    cbi = b2*gdidi_i\n    caj = a2*gdjdj_i\n    cbj = b2*gdjdj_i\n!    cai = gamma*a2/(di*di)\n!    cbi = gamma*b2/(di*di)\n!    caj = gamma*a2/(dj*dj)\n!    cbj = gamma*b2/(dj*dj)\n\n!    ct = cos(theta)\n!    st = sin(theta)\n\n!    a = r*ct\n!    b = r*st\n\n!    ca = cos(a)\n!    cb = cos(b)\n!    sa = 1.0d0 ; if ( a /= 0.0d0 ) sa=sin(a)/a\n!    sb = 1.0d0 ; if ( b /= 0.0d0 ) sb=sin(b)/b\n!    sa=sin(a)/a\n!    sb=sin(b)/b\n\n!    www = ( (thr-a2)*sa-thr*ca )*cos(b) &\n!        + ( (thr-b2)*ca + (r*r-thr)*sa )*sin(b)/b\n!    www = ( (thr-a2)*sa-thr*ca )*cb + ( (thr-b2)*ca + (r*r-thr)*sa )*sb\n!    www = (thr-a2)*cb*sa + (thr-b2)*ca*sb + (r*r-thr)*sa*sb - thr*ca*cb\n!    www = (3.0d0-a2)*cb*sa + (3.0d0-b2)*ca*sb &\n!        + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb\n!    www = 2.0d0*( (3.0d0-a2)*cb*sa + (3.0d0-b2)*ca*sb &\n!                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n!    www = 2.0d0*( (3.0d0-a*a)*cb*sa + (3.0d0-b*b)*ca*sb &\n!                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n\n!    if ( di == 0.0d0 ) then\n!       hai = 0.0d0\n!       hbi = 0.0d0\n!    else\n!       hai = 1.0d0 - exp( -gamma*(a/di)**2 )\n!       hbi = 1.0d0 - exp( -gamma*(b/di)**2 )\n!       hai = 1.0d0 - exp( -cai )\n!       hbi = 1.0d0 - exp( -cbi )\n!    end if\n!    if ( dj == 0.0d0 ) then\n!       haj = 0.0d0\n!       hbj = 0.0d0\n!    else\n!       haj = 1.0d0 - exp( -gamma*(a/dj)**2 )\n!       hbj = 1.0d0 - exp( -gamma*(b/dj)**2 )\n!       haj = 1.0d0 - exp( -caj )\n!       hbj = 1.0d0 - exp( -cbj )\n!    end if\n\n!    if ( a == 0.0d0 ) then\n!       vai = di*di/(2.0d0*gamma)\n!       vaj = dj*dj/(2.0d0*gamma)\n!    else\n!       vai = a2/(2.0d0*hai)\n!       vaj = a2/(2.0d0*haj)\n!       vai = a2/( 2.0d0-2.0d0*exp(-cai) )\n!       vaj = a2/( 2.0d0-2.0d0*exp(-caj) )\n       vai = 0.5d0*a2/( 1.0d0-exp(-cai) )\n       vaj = 0.5d0*a2/( 1.0d0-exp(-caj) )\n!       vai = a2/( 1.0d0-exp(-cai) )\n!       vaj = a2/( 1.0d0-exp(-caj) )\n!    end if\n!    if ( b == 0.0d0 ) then\n!       vbi = di*di/(2.0d0*gamma)\n!       vbj = dj*dj/(2.0d0*gamma)\n!    else\n!       vbi = b2/(2.0d0*hbi)\n!       vbj = b2/(2.0d0*hbj)\n!       vbi = b2/( 2.0d0-2.0d0*exp(-cbi) )\n!       vbj = b2/( 2.0d0-2.0d0*exp(-cbj) )\n       vbi = 0.5d0*b2/( 1.0d0-exp(-cbi) )\n       vbj = 0.5d0*b2/( 1.0d0-exp(-cbj) )\n!       vbi = b2/( 1.0d0-exp(-cbi) )\n!       vbj = b2/( 1.0d0-exp(-cbj) )\n!    end if\n\n    ttt = ( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n!    ttt = ( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n!               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n!                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n!    ttt = 0.5d0*( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n!               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n!                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n\n    ca = cos(a)\n    sa = sin(a)/a\n    www = ( (thr-a2)*sa-thr*ca )*cos(b) &\n        + ( (thr-b2)*ca + (r*r-thr)*sa )*sin(b)/b\n\n    phi_b = r*www*ttt\n\n  end function phi_b\n"}, {"instruction": "Create a Fortran function named phi_c to calculate a physical quantity. The function takes 4 input parameters of type real(8) - r, theta, di, and dj. It returns 1 output parameter of type real(8).", "input": "", "output": "  function phi_c( r, theta, di, dj )\n    implicit none\n    real(8) :: phi_c\n    real(8),intent(in)  :: r, theta, di, dj\n    real(8) :: a,b,gamma,pi,www,ttt\n    real(8) :: ct,st,sa,sb,ca,cb,hai,haj,hbi,hbj,vai,vaj,vbi,vbj\n\n    pi = acos(-1.0d0)\n    gamma = 4.0d0*pi/9.0d0\n\n    ct = cos(theta)\n    st = sin(theta)\n\n    a = r*ct\n    b = r*st\n\n    ca = cos(a)\n    cb = cos(b)\n    sa = 1.0d0 ; if ( a /= 0.0d0 ) sa=sin(a)/a\n    sb = 1.0d0 ; if ( b /= 0.0d0 ) sb=sin(b)/b\n\n    www = 2.0d0*( (3.0d0-a*a)*cb*sa + (3.0d0-b*b)*ca*sb &\n                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n\n    if ( di == 0.0d0 ) then\n       hai = 0.0d0\n       hbi = 0.0d0\n    else\n       hai = 1.0d0 - exp( -gamma*(a/di)**2 )\n       hbi = 1.0d0 - exp( -gamma*(b/di)**2 )\n    end if\n    if ( dj == 0.0d0 ) then\n       haj = 0.0d0\n       hbj = 0.0d0\n    else\n       haj = 1.0d0 - exp( -gamma*(a/dj)**2 )\n       hbj = 1.0d0 - exp( -gamma*(b/dj)**2 )\n    end if\n\n    if ( a == 0.0d0 ) then\n       vai = di*di/(2.0d0*gamma)\n       vaj = dj*dj/(2.0d0*gamma)\n    else\n       vai = a*a/(2.0d0*hai)\n       vaj = a*a/(2.0d0*haj)\n    end if\n    if ( b == 0.0d0 ) then\n       vbi = di*di/(2.0d0*gamma)\n       vbj = dj*dj/(2.0d0*gamma)\n    else\n       vbi = b*b/(2.0d0*hbi)\n       vbj = b*b/(2.0d0*hbj)\n    end if\n\n    ttt = 0.5d0*( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n\n    phi_c = r*www*ttt\n\n  end function phi_c\n"}, {"instruction": "Write a Fortran function named dbilininterp to trilinearly interpolate given points. This function takes 3 input parameters of type real(kind=8), dimension(:), real(kind=8), dimension(:), and real(kind=8), dimension(size(xd),4), and returns 1 output parameter of type real(kind=8), dimension(size(xd)).", "input": "", "output": "        function dbilininterp(vv,xd,yd) result(y)\n        ! trilinearly interpolate given points (xd,yd,zd) assumed to be normalized so grid spacing is 1 in each direction.\n        ! based on formula from wikipedia.\n        ! jad 9/8/2008\n        real(kind=8), intent(in), dimension(:) :: xd,yd\n        real(kind=8), intent(in), dimension(size(xd),4) :: vv\n        real(kind=8), dimension(size(xd)) :: y,w1,w2\n        ! interpolate along y\n        w1=vv(:,1)*(1.-yd)+vv(:,2)*yd\n        w2=vv(:,3)*(1.-yd)+vv(:,4)*yd\n        ! finally, interpolate y weights along x\n        y=w1*(1.-xd)+w2*xd\n        end function dbilininterp\n"}, {"instruction": "Write a Fortran function named lagrange that calculates the Lagrange interpolating polynomial for a given set of data points. The function takes 3 input parameters: a real value x, an array of real numbers t, and an array of real numbers y. The function returns a real value as the result. Remember to ensure that the size of the arrays t and y are the same.", "input": "", "output": "    function lagrange(x, t, y) \n        implicit none \n\n        real, intent(in)               :: x\n        real, dimension(:), intent(in) :: t, y\n        real                           :: lagrange\n\n        real                           :: coefficient\n        integer                        :: j, k\n\n        ! sanity check\n        if ( size(t) /= size(y) ) stop 'incompatible number of data between x and f(x)'\n        \n        ! initialization \n        lagrange = 0 \n        \n        ! loop through n data point \n        do j = 1, size(t)\n            coefficient = 1.0     \n\n            ! kronecker delta\n            do k = 1, size(t) \n                if ( k /= j ) & \n                    coefficient = coefficient * (x - t(k)) / (t(j) - t(k))\n            end do \n\n            lagrange = lagrange + coefficient * y(j)\n        end do\n    end function lagrange\n"}, {"instruction": "Create a Fortran function named cubic_spline_index that takes two input parameters: a single real number (x) and an array of real numbers (t). The output is a single integer representing the index of the array t where x should be inserted to maintain the order.", "input": "", "output": "    function cubic_spline_index(x, t)\n        implicit none \n\n        real, intent(in)               :: x\n        real, dimension(:), intent(in) :: t\n        integer                        :: cubic_spline_index\n\n        integer                        :: a, b, m \n\n        ! initialization \n        ! preseving the index of t(:)\n        a = 1\n        b = size(t)\n\n        ! bisection \n        do while ( (b - a) > 1 )\n        !   ! mid point \n            m = (a + b) / 2 \n            if ( x > t(m) ) then \n                a = m  \n            else \n                b = m \n            end if\n        end do \n\n        ! points at the boundaries \n        if ( x == t(a) ) then \n            cubic_spline_index = 1 \n        else if ( x == t(b) ) then \n            cubic_spline_index = b-1\n        ! otherwise lower bound \n        else \n            cubic_spline_index = a \n        end if \n    end function cubic_spline_index\n"}, {"instruction": "Create a Fortran function named count_one_wrong that takes an array of integers as input, with the data type ['integer, dimension(:)']. The function should return the count of positive integers in the input array as output, with the data type ['integer'].", "input": "", "output": "    function count_one_wrong(a) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: a\n        integer :: result\n        integer :: count = 0\n        integer :: i\n        do i = 1, size(a)\n            if (a(i) > 0) count = count + 1\n        end do\n        result = count\n    end function count_one_wrong\n"}, {"instruction": "Write a Fortran function named projected_length that takes 4 input parameters of type real(8) and returns 1 output parameter of type real. The purpose of the function is to calculate the projected length of a turbine on the wind direction vector based on the given coordinates. Use the Heron's method to calculate the area of the triangle and then determine the projected length.", "input": "", "output": "function projected_length(ax,ay,bx,by)\n!...................................................................\n\n! turbine to the origin of the inflow wind\n! the distance is used to sort the turbines from ipstream to downstream\n!...................................................................\n\n    real(8) ::   ax                   ! the x coordinate of the point a (reference point)\n    real(8) ::   ay                   ! the y coordinate of the point a\n    real(8) ::   bx                   ! the x coordinate of the point b\n    real(8) ::   by                   ! the y coordinate of the point b\n    real    ::   projected_length\n    \n    real  ::   side_a               ! triangle side a length\n    real  ::   side_b               ! triangle side b length\n    real  ::   side_c               ! triangle side c length\n    real  ::   semi                 ! triangle semiperimeter\n    real  ::   area                 ! triangle area\n    real  ::   height               ! triangle height\n    \n    \n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n         ! calculate the area of the triangle whose corners are the (0,0), turbine location and the wind origin using heron's method\n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n    \n    side_a = sqrt( (bx-ax)*(bx-ax) + (by-ay)*(by-ay) )\n    side_b = sqrt( bx*bx + by*by )\n    side_c = sqrt( ax*ax + ay*ay )\n    semi = (side_a + side_b + side_c)/2\n    \n    area = sqrt(abs( semi * ( semi - side_a ) * ( semi - side_b ) * ( semi - side_c ) ))\n    \n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n         ! calculate the projected length of the turbine on the wind direction vector\n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n    \n    height = 2 * area / side_c\n    \n    projected_length = sqrt( side_a*side_a - height*height )\n    \n    \nend function projected_length\n"}, {"instruction": "Create a Fortran function named \"anglebetweenvectors\" to calculate the angle between two vectors. The function should take 4 real input parameters (x1, y1, x2, y2) representing the coordinates of the vectors, and return a single real output parameter representing the angle. Use the imperative tone to specify the number and type of input and output parameters.", "input": "", "output": "function anglebetweenvectors(x1,y1,x2,y2)\n!...................................................................\n\n! x1,y1,x2,y2 are the vector coordinates\n!...................................................................\n\n    real       ::        x1\n    real       ::        y1\n    real       ::        x2\n    real       ::        y2\n    real       ::        pi = acos( -1.0 )\n    real       ::        anglebetweenvectors\n    real       ::        cosalpha\n    real       ::        rad\n    \n    pi = acos( -1.0 )\n    \n    cosalpha = (x1*x2 + y1*y2) / ( sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2) )\n    \n    !rad = acos(cosalpha-0.00001)                         ! acos(1) = nan??!!!!\n    \n    if (cosalpha>1.0) then\n        cosalpha = 1.0\n    end if\n    \n    if (cosalpha<-1.0) then\n        cosalpha = -1.0\n    end if\n    \n    rad = acos(cosalpha)\n    \n    anglebetweenvectors = rad * 180/pi\n    \nend function anglebetweenvectors\n"}, {"instruction": "Write a Fortran function named cumsum that computes the cumulative sum of a given one-dimensional array. The function takes 2 input parameters: an integer representing the dimension of the array and a real array of kind 8 with the specified dimension. It returns 1 output parameter, which is also a real array of kind 8 with the specified dimension.", "input": "", "output": "    function cumsum(dim,vector)\n        implicit none\n        integer,      intent(in)                 :: dim\n        real(kind=8), intent(in), dimension(dim) :: vector\n        real(kind=8),             dimension(dim) :: cumsum\n\n        integer :: i\n\n        cumsum(1) = vector(1)\n        do i = 2,dim\n            cumsum(i) = cumsum(i-1) + vector(i)\n        enddo\n\n    end function cumsum\n"}, {"instruction": "Write a Fortran function named func that takes a single real input argument and returns a real value. The input data type is ['real'] and the output data type is ['real']. The function computes and returns half of the input value.", "input": "", "output": "function func(y)\n!\nimplicit none\n!\n\n!\nreal :: y\nreal :: func\n!\n\n!  and is used with trapzd.for which performs the integral\n\n!  other equations for a line can also be used if the distribution\n!  is not triangular.\n! \nfunc = 0.5*y\n! \nend function func\n"}, {"instruction": "Write a Fortran elemental function named wrap that takes 3 real input parameters and returns 1 real output parameter. The input parameters are x, mi, and ma, while the output parameter is wrap. The function computes the wrapped value of x within the range defined by mi and ma. If x is within the range, it returns x; otherwise, it returns x wrapped within the range.", "input": "", "output": "    elemental function wrap( x, mi, ma )\n        real, intent(in) :: x, mi, ma\n        real :: wrap\n        wrap = x\n        \n        if (mi .le. x .and. x .le. ma) return\n        wrap = x - floor((x-mi)/(ma-mi)) * (ma-mi)\n    end function\n"}, {"instruction": "Create a Fortran function named count_lines to count the occurrences of a substring within a given string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. The test_data type for input parameters is ['character(len=*)', 'character(len=*)'], and for the output parameter is ['integer'].", "input": "", "output": "function count_lines(str, substr) result(c)\n  implicit none\n  character(len=*) :: str\n  character(len=*) :: substr\n  integer :: c\n  integer :: k, inc, idx\n  c = 0\n  k = 1\n  inc = len_trim(substr)\n  idx = index(str(k:), substr)\n  do while (idx.ne.0)\n     c = c + 1\n     k = k + inc\n     idx = index(str(k:), substr)\n  end do\nend function count_lines\n"}, {"instruction": "Write a Fortran function named cosd that takes a single real input argument and returns a real value. The input argument should be of type real, and the output value should also be of type real. The function computes the cosine of the input angle, which is specified in degrees, and returns the result. Use the imperative tone to instruct the creation of the function.", "input": "", "output": "      function cosd(x)\n          implicit none\n          real :: cosd, umr\n          real, intent(in) :: x\n          umr  = atan(1.0)*4./180. \n          cosd = cos(x*umr)\n\n      end function cosd\n"}, {"instruction": "Create a Fortran function named \"sind\" to calculate the sine of an angle given in degrees. The function should take 1 input parameter of type real and return 1 output parameter of type real. The input parameter should be in degrees, and the output parameter will be the sine of the input angle in radians.", "input": "", "output": "      function sind(x)\n          implicit none\n          real :: sind, umr\n          real, intent(in) :: x\n          umr  = atan(1.0)*4./180. \n          sind = sin(x*umr)\n\n      end function sind\n"}, {"instruction": "Write a Fortran function named ncombinations to calculate the number of possible combinations of Higgs particles. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  function ncombinations(nhiggs)\n!--------------------------------------------------------------------\n  integer, intent(in) :: nhiggs\n  integer :: ncombinations, x\n  integer, allocatable :: s(:)\n  integer :: kk\n  ! calculate the number of possible (irreducible) higgs combinations\n  allocate(s(nhiggs+1))  \n  s(1)=0\n  do x=1,nhiggs\t\n   s(x+1)=s(x)+(x-1)\n  enddo\n  ncombinations=sum(s)+nhiggs+1 \n!new\n  deallocate(s)\n  \n  ncombinations=0\n  do kk=0,nhiggs-1\n   ncombinations = ncombinations + 2**kk \n  enddo\n\n  end function ncombinations\n"}, {"instruction": "Write a Fortran function named countsubstring to count the occurrences of a substring within a given string. The function takes 2 input arguments of type character(*) and returns 1 output argument of type integer. Use the imperative tone when providing the instructions.", "input": "", "output": "function countsubstring(s1, s2) result(c)\n  character(*), intent(in) :: s1, s2\n  integer :: c, p, posn\n\n  c = 0\n  if(len(s2) == 0) return\n  p = 1\n  do\n    posn = index(s1(p:), s2)\n    if(posn == 0) return\n    c = c + 1\n    p = p + posn + len(s2)\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named pressure to calculate the pressure in bars based on the given depth in meters. The function has 1 input parameter of type real and 1 output parameter of type real. When using this function, provide a single real value as input to compute the corresponding pressure in bars.", "input": "", "output": "function pressure(depth) result(press)\n\n! !description:\n\n!  using a mean density derived from depth-dependent global \n!  average temperatures and salinities from levitus 1994, and \n!  integrating using hydrostatic balance.\n!\n!  references:\n!\n!     levitus, s., r. burgett, and t.p. boyer, world ocean atlas \n!          1994, volume 3: salinity, noaa atlas nesdis 3, us dept. of \n!          commerce, 1994.\n!\n!     levitus, s. and t.p. boyer, world ocean atlas 1994, \n!          volume 4: temperature, noaa atlas nesdis 4, us dept. of \n!          commerce, 1994.\n!\n!     dukowicz, j. k., 2000: reduction of pressure and pressure\n!          gradient errors in ocean simulations, j. phys. oceanogr.,\n!          submitted.\n!\n! !revision history:\n!  same as module\n\n! !input parameters:\n\nreal, intent(in) :: depth    ! depth in meters\n\n! !output parameters:\n\nreal :: press   ! pressure [bars]\n\n! !local parameters:\n!  adjustment from original code which was written as 0.1_r8\n!  which the compiler disliked so constants are now pre-defined here\ndouble precision, parameter ::              &\n   pc1 = 0.059808,   &\n   pc2 = 0.025,      &\n   pc3 = 0.100766,   &\n   pc4 = 2.28405e-7, &\n   c1  = 1.0\n!eop\n!boc\n!-----------------------------------------------------------------------\n!  convert depth in meters to pressure in bars\n!-----------------------------------------------------------------------\n\npress = pc1*(exp(-pc2*depth) - c1) + pc3*depth + pc4*depth**2\n\n!return\n\nend function pressure\n"}, {"instruction": "Create a Fortran function named erfc_salmon_mid to calculate the complementary error function for a floating-point number within a specific range. It takes 1 input argument of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "  function erfc_salmon_mid(x) result(y) ! 0.46875d0 <x< 4d0\n    implicit none\n    real(8),intent(in) :: x\n    real(8) :: y\n    real(8) :: x2\n    real(8),parameter :: &\n       p(0:7) = (/  &\n       & 3.004592610201616005d2, &\n       & 4.519189537118729422d2, &\n       & 3.393208167343436870d2, &\n       & 1.529892850469404039d2, &\n       & 4.316222722205673530d1, &\n       & 7.211758250883093659d0, &\n       & 5.641955174789739711d-1, &\n       &-1.368648573827167067d-7 & \n       &/), &\n       q(0:7) = (/ &\n       & 3.004592609569832933d2, &\n       & 7.909509253278980272d2, &\n       & 9.313540948506096211d2, &\n       & 6.389802644656311665d2, &\n       & 2.775854447439876434d2, &\n       & 7.700015293522947295d1, &\n       & 1.278272731962942351d1, &\n       & 1d0 &\n       &/)\n\n    x2 = x**2\n\n    y = (p(0) + p(1)*x + p(2)*x**2 + p(3)*x**3 + p(4)*x**4 & \n         + p(5)*x**5 + p(6)*x**6 + p(7)*x**7)/ &\n         (q(0) + q(1)*x + q(2)*x**2 + q(3)*x**3 + q(4)*x**4 & \n         + q(5)*x**5 + q(6)*x**6 + q(7)*x**7)\n    y = exp(-x2)*y\n\n\n  end function erfc_salmon_mid\n"}, {"instruction": "Create a Fortran pure function named odps_get_ozone_component_id to determine the ozone component ID based on the input group index. The function takes 1 input argument of type integer and returns 1 output argument of type integer. If the group index matches a specific group, the function returns the ozone component ID; otherwise, it returns -1.", "input": "", "output": "  pure function odps_get_ozone_component_id(group_index) result( ozone_component_id )\n    integer, intent(in) :: group_index\n    integer :: ozone_component_id\n    if( group_index == group_1 .or. group_index == group_1)then\n      ozone_component_id = ozo_comid\n    else\n      ozone_component_id = -1\n    end if\n  end function odps_get_ozone_component_id\n"}, {"instruction": "Create a Fortran function named reversible to determine if an integer is palindromic in its digits. The function should take 1 input argument with test_data type ['integer'] and return 1 output argument with test_data type ['logical'].", "input": "", "output": "function reversible(num)\n  ! determine if an integer is palindromic in its digits\n\n  implicit none\n\n  logical :: reversible\n  integer, intent(in) :: num\n  integer :: len,itr\n  ! 999*999 is 998001, so only 6 characters are needed\n  character(len=6) :: str,rev\n  ! print to the string\n  write (str,\"(i6)\") num\n  len=len_trim(str)\n  ! flip the string and save to rev\n  do itr=1,len\n    rev(itr:itr)=str(len+1-itr:len+1-itr)\n  end do\n\n  reversible=str(1:len).eq.rev(1:len)\n\nend function reversible\n"}, {"instruction": "Create a Fortran function named pythag that calculates the hypotenuse of a right-angled triangle using the given lengths of the two shorter sides. The number of input arguments is 2 with test_data type ['real(kind=8)', 'real(kind=8)'], and the number of output arguments is 1 with test_data type ['real(kind=8)']. Use the imperative tone to write the instruction.", "input": "", "output": "\tfunction pythag(a,b)\n   real(kind=8) :: a,b,pythag\n   real(kind=8) :: absa,absb\n      absa=dabs(a)\n      absb=dabs(b)\n      if(absa.gt.absb)then\n        pythag=absa*dsqrt(1.+(absb/absa)**2)\n      else\n        if(absb.eq.0.d0)then\n          pythag=0.d0\n        else\n          pythag=absb*sqrt(1.d0+(absa/absb)**2)\n        endif\n      endif\n      return\n\tend function pythag\n"}, {"instruction": "Create a Fortran function named reptimecheck to determine whether a given time meets a target time for a benchmark. The function takes 2 input parameters of type double precision and integer, and returns 1 output parameter of type logical. The input test_data type is ['double precision', 'integer'], and the output test_data type is ['logical'].", "input": "", "output": "  function reptimecheck(time, numreps)\n    double precision, intent(in) :: time\n    integer, intent(in) :: numreps\n    logical :: reptimecheck\n\n    if (time < targettime) then\n       !double repstodo and repeat benchmark\n       repstodo = 2*numreps\n       reptimecheck = .false.\n    else if (time > (2*targettime)) then\n       !finish benchmark and half number of reps for next datasize\n       repstodo = max(numreps/2,1) !repstodo is at least 1 \n       reptimecheck = .true.\n    else !time is >= targettime\n       !finish benchmark and keep reps for next data size\n       reptimecheck = .true.\n    end if\n\n   \n  end function reptimecheck\n"}, {"instruction": "Write a Fortran function named ralloc to dynamically allocate memory for a 2D integer array. The number of input arguments is 3, and the test_data type is ['integer, pointer, dimension(:,:)', 'integer', 'integer']. The number of output arguments is 1, and the test_data type is ['integer, pointer, dimension(:,:)'].\nThe function allocates memory for a new 2D array, copies the existing array's elements into the new array, and deallocates the memory of the existing array if it's associated.", "input": "", "output": "  function ralloc(p, n, m)\n    integer, pointer, dimension(:,:) :: p, ralloc\n    integer, intent(in) :: n, m\n    \n    !!<local name=\"nold, mold\">the number of rows and columns in the existing array.</local>\n    !!<local name=\"ierr\">used for checking memory allocation error.</local>\n    integer :: nold, mold, ierr\n\n    allocate(ralloc(1:n,1:m), stat=ierr)\n    if (ierr/=0) stop \"allocate error in ralloc_integer_table in utilities module\"\n\n    if (.not.associated(p)) return\n    nold = min(size(p,1),n); mold = min(size(p,2),m)\n    ralloc = 0\n    ralloc(1:nold,1:mold) = p(1:nold,1:mold)\n    deallocate(p)\n  end function ralloc\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. This function should have 1 input parameter of type integer and 1 output parameter of type integer. Use \"integer, intent(in) :: n\" to specify the input parameter and \"integer :: y\" to specify the output parameter. Use a do loop to calculate the factorial.", "input": "", "output": "    function factorial(n) result (y)\n        integer, intent(in) :: n\n        integer             :: y\n        \n        integer             :: i\n\n        y = 1\n        do i = 2, n\n            y = y*i\n        end do\n    end function\n"}, {"instruction": "Create a Fortran function called fibo_naive to calculate the Fibonacci number at the given position using a naive recursive approach. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The test_data type for input is ['integer'] and for output is ['integer'].", "input": "", "output": "  recursive function fibo_naive(n) result(res)\n    integer, intent(in) :: n\n    integer :: res\n    \n    if(n <= 0) then\n       res = 0\n       return\n    end if\n    \n    if(n == 1) then\n       res = 1\n       return\n    end if\n\n    res = fibo_naive(n-1) + fibo_naive(n-2)\n\n  end function fibo_naive\n"}, {"instruction": "Write a Fortran function called fibo_tail to calculate the nth number in the Fibonacci sequence using tail recursion. The function takes 3 input arguments of type integer: prev2, prev1, and n. It returns 1 output argument of type integer.", "input": "", "output": "  recursive function fibo_tail(prev2,prev1,n) result(res)\n    integer,intent(in) :: prev2,prev1,n\n    integer :: res\n\n    if(n == 0) then\n       res = prev2\n       return\n    end if\n\n    res = fibo_tail(prev1,prev1+prev2,n-1)\n\n  end function fibo_tail\n"}, {"instruction": "Write a Fortran function named wrap to calculate the wrapped angle within the range of 0 to 359 degrees. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. When calling the function, provide a single integer value as input and the function will return the wrapped angle within 0 to 359 degrees.", "input": "", "output": "pure function wrap(angle) result(wrapped_angle)\nimplicit none \ninteger,intent(in) :: angle\ninteger :: wrapped_angle\nwrapped_angle = mod(angle, 360)\nif (wrapped_angle<0) wrapped_angle = wrapped_angle + 360\nend function wrap\n"}, {"instruction": "Create a Fortran function named vperp that calculates the perpendicular velocity. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). If the result is NaN, it sets the output parameter to 0d0.", "input": "", "output": "  function vperp(bmod)\n    !   perpendicular velocity\n    real(8) :: bmod, vperp\n    vperp = v*sqrt(eta*bmod)\n    if (isnan(vperp)) then\n       vperp = 0d0\n    end if \n  end function vperp\n"}, {"instruction": "Write a Fortran function named quadrilinear to compute a function value using a quadrilinear interpolation algorithm. The function takes 6 input parameters of type real(kind(0d0)) and dimension(0:1,0:1,0:1,0:1) for hypercube, real(kind(0d0)) and dimension(0:3) for vmid, and real(kind(0d0)) for dt, dx, dy, dz. The output parameter is a real(kind(0d0)) value. Use the imperative tone.", "input": "", "output": "   function quadrilinear(vmid,hypercube,dt,dx,dy,dz) result (f)\n\n     implicit none\n     real(kind(0d0)),dimension(0:1,0:1,0:1,0:1) :: hypercube\n     real(kind(0d0)),dimension(0:3) :: vmid\n     real(kind(0d0)) :: dt, dx, dy, dz, f\n     real(kind(0d0)) :: t, x, y, z\n     integer :: n,i,j,k\n\n     f = 0d0\n     t = vmid(0)/dt\n     x = vmid(1)/dx\n     y = vmid(2)/dy\n     z = vmid(3)/dz\n\n     do k = 0,1\n        do j = 0,1\n           do i = 0,1\n              do n = 0,1\n                 f = f + (n*t+(1-n)*(1-t))*(i*x+(1-i)*(1-x))     &\n                        *(j*y+(1-j)*(1-y))*(k*z+(1-k)*(1-z))     &\n                        *hypercube(n,i,j,k)\n\n              end do\n           end do\n        end do\n     end do\n\n   end function quadrilinear\n"}, {"instruction": "Create a Fortran function named isref that takes two input arguments of type character(len=*) and returns a logical value. This function checks if the second input argument is a substring of the first input argument.", "input": "", "output": "  function isref(ref, ref_list) result(isr)\n    implicit none\n    character(len=*), intent(in) :: ref\n    character(len=*), intent(in) :: ref_list\n    logical :: isr\n\n    isr = (index(ref, ref_list) > 0)\n\n  end function isref\n"}, {"instruction": "Create a Fortran function called parsecompvector that takes a single input argument of type character(len=*) and returns an integer. The function counts the number of components in the input character vector, where components are separated by commas or spaces. Use the imperative tone in the instructions.", "input": "", "output": "  function parsecompvector(compvector) result(nc)\n    character(len=*), intent(in) :: compvector\n    integer :: nc\n    ! locals\n    character(len=1), parameter :: delim = ','\n    character(len=1), parameter :: space = ' '\n    integer :: strlen, i, lasti\n    strlen = len(compvector)\n    nc = 0\n    lasti = 0\n    do i=2,strlen\n      if (compvector(i:i) == delim .or. compvector(i:i)== space) then\n        if (i > lasti) then\n          nc = nc + 1\n        endif\n        lasti = i\n      endif\n    enddo\n    if (strlen > lasti) then\n      nc = nc + 1\n    endif\n  end function parsecompvector\n"}, {"instruction": "Create a Fortran function named fsedmode to determine bedload and suspended load transport fractions based on specified mode options and hydrodynamic parameters. The function takes 7 input parameters of type integer and real, and returns 1 output parameter of type real. The function uses imperative logic to calculate the transport fractions based on different mode options using the input parameters.", "input": "", "output": "function fsedmode(ws,ustot,usgrn,rsndm,isndm1,isndm2,imode)\n\n  ! *** fsedmode sets bedload (imode=1) and suspended load (imode=2)\n  ! *** transport fractions (dimensionless)\n  \n  ! ***  ws\n  ! ***  ustot  - hydrodynamic shear velocity (m/s)\n  ! ***  usgrn  - grain shear velocity (m/s)\n  ! ***  rsndm  - value of ustar/wset for binary switch between bedload and suspended load (dimensionless)\n\n  implicit none\n\n  integer :: isndm1,isndm2,imode\n  real   :: fsedmode,ws,ustot,usgrn,rsndm,us,usdws,tmpval\n\n  if( ws == 0. )then\n    fsedmode=0.\n    return\n  endif\n\n  ! *** choose betweeen total stress shear velocity and grain stress\n  ! *** shear velocity\n  if( isndm2 == 0 )then\n    us=ustot\n  else\n    us=usgrn\n  endif\n  usdws = us/ws\n\n  ! *** choose between mode options\n\n  ! *** isndm1=0 set both bedload and suspended load fractions to 1.0\n  if( isndm1 == 0 ) fsedmode=1.0\n\n  ! *** isndm1=1 set bedload fraction to 1. use binary relationship for suspended\n  if( isndm1 == 1 )then\n      fsedmode=0.\n    if( imode == 1 )then\n      fsedmode=1.0\n    else\n      if( usdws >= rsndm)fsedmode=1.\n    end if\n  end if\n\n  ! *** isndm1=2 set bedload fraction to 1, use linear relationship for suspended\n  if( isndm1 == 2 )then\n    if( imode == 1 )then\n      fsedmode=1.0\n    else\n      tmpval=((usdws)-0.4)/9.6\n      tmpval=min(tmpval,1.0)\n      tmpval=max(tmpval,0.0)\n        fsedmode=tmpval\n    end if\n  end if\n\n  ! *** isndm1=3 use binary relationship for bedload and suspended load\n  if( isndm1 == 3 )then\n      fsedmode=0.\n    if( imode == 1 )then\n      if( usdws < rsndm)fsedmode=1.\n    else\n      if( usdws >= rsndm)fsedmode=1.\n    end if\n  end if\n\n  ! *** isndm1=4 use linear relationship for bedload and suspended load\n  if( isndm1 == 4 )then\n    tmpval=((usdws)-0.4)/9.6\n    tmpval=min(tmpval,1.0)\n    tmpval=max(tmpval,0.0)\n    if( imode == 1 )then\n      fsedmode=1.-tmpval\n    else\n      fsedmode=tmpval\n    end if\n  end if\n\nend function\n"}, {"instruction": "Create a Fortran function named compute_point to calculate a value based on the input parameters. The function takes 2 input arguments of type real and optional real. The output is a single real value. When the optional input is present, it is added to the computed value.", "input": "", "output": " elemental function compute_point ( t , w ) result(q)\n  real , intent(in) :: t\n  real , optional , intent(in) :: w\n  real :: q\n  real :: c\n\n  c = 5.345\n  q = q + t * c\n  if ( present ( w ) ) then\n   q = q + w\n  end if\n end function compute_point\n"}, {"instruction": "Write a Fortran function named outer to calculate the outer product of two input arrays. The number of input arguments is 2, and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1, and the test_data type is ['real, dimension(size(a), size(b))'].", "input": "", "output": "    function outer(a, b) \n        implicit none \n\n        real, dimension(:)                :: a, b \n        real, dimension(size(a), size(b)) :: outer\n\n        ! c_ij = a_i * b_j \n        outer = spread(a, dim=2, ncopies=size(b)) * spread(b, dim=1, ncopies=size(a))\n    end function outer\n"}, {"instruction": "Create a Fortran function named gather_realvector that takes two input arguments: an integer array and a real array, denoted as ['integer, dimension(:)', 'real, dimension(:)']. It returns one output argument of type real array, which is allocated dynamically, denoted as ['real, dimension(:), allocatable']. The function extracts elements from the real array based on the indices specified in the integer array and stores the result in the dynamically allocated real array. Remember to allocate memory for the output array before storing the extracted elements.", "input": "", "output": "      function gather_realvector(sparseindex,densevec) result(sparsevec)\n!\n\n!     indexing is known.\n!\n      implicit none\n      real,dimension(:),allocatable::sparsevec\n      integer,dimension(:),intent(in)::sparseindex\n      real,dimension(:),intent(in)::densevec\n      integer::i\n!\n      allocate(sparsevec(size(sparseindex)))\n      do i = 1,size(sparseindex)\n        sparsevec(i) = densevec(sparseindex(i))\n      enddo\n!\n      return\n      end function gather_realvector\n"}, {"instruction": "Create a Fortran function named v2mo that takes an integer input representing a month (1-12) and returns the corresponding month name as a character string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function v2mo(imonth) result(month_name)\n! ident_12=\"@(#)v2mo(3f): returns the month name of a common month\"\ncharacter(len=:),allocatable :: month_name                                        ! string containing month name or abbreviation.\ninteger,intent(in)           :: imonth                                            ! the number of the month(1-12)\ncharacter(len=*),parameter   :: names(12)=[ character(len=9) ::  &\n&'january  ', 'february ', 'march    ', 'april    ', 'may      ', 'june     ', &\n&'july     ', 'august   ', 'september', 'october  ', 'november ', 'december ']\n   select case(imonth)\n   case (1:12);  month_name=trim(names(imonth))\n   case default; month_name='unknown'\n   end select\nend function v2mo\n"}, {"instruction": "Create a Fortran function named temps to calculate the temperature stress factor based on daily maximum and minimum air temperatures, as well as the optimum and minimum crop growth temperatures. The number of input arguments is 4 with test_data type ['real', 'real', 'real', 'real'], and the number of output arguments is 1 with test_data type ['real'].", "input": "", "output": "function temps(bwtdmx,bwtdmn,bctopt,bctmin)\n!\nimplicit none\n!\n\n!\nreal :: bctmin,bctopt,bwtdmn,bwtdmx\nreal :: temps\n!\n! local variables\n!\nreal :: dst0,rto,tgx,x1\n!\n!     author : amare retta\n!     + + + purpose + + +\n!     to calculate the temperature stress factor\n!     this algorithms was taken from the epic subroutine cgrow.\n \n!     + + + kewords + + +\n!     temperature stress\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     bwtdmx - daily maximum air temperature\n!     bwtdmn - daily minimum air temperature\n!     bctopt - optimum crop growth temperature\n!     bctmin - minimum crop growth temperature\n\n!             stress factor\n \n!     + + + local variables + + +\n \n!     + + + local variable definitions + + +\n!     dst0 - average of max and min air temperatures\n!     rto - interim variable\n!     tgx - difference between the soil surface temperature and the minimum\n!           temperature for plant growth\n!     x1 - difference between the optimum and minimum temperatures for plant\n!          growth\n \n!     + + + end of specifications + + +\n\n!     calculate temperature stress factor\n!     following one statement to be removed when soil temperature is available\ndst0 = (bwtdmx+bwtdmn)/2.0\ntgx = dst0 - bctmin\nif (tgx.le.0.) tgx = 0.\nx1 = bctopt - bctmin\nrto = tgx/x1\ntemps = sin(1.5707*rto)\nif (rto.gt.2.) temps = 0.\n \n      ! this reduces temperature stress around the optimum\ntemps = temps**0.25\n!    print *, 'in temps, temps = ', temps\n!    \nend function temps\n"}, {"instruction": "Create a Fortran function named poor_soil_rsp that takes two input parameters of type real and integer, and returns one output parameter of type real. This function computes the quadratic response factors based on the soil fertility and response class. Make sure to use the imperative tone in your code.", "input": "", "output": "   function poor_soil_rsp(sf,nrc)\n      !  computes quadratic itpoorent response factors\n      !  by itpoorent response class (1=intol, 3=tol) and soil fertility\n      real                            :: poor_soil_rsp\n      real,              intent(inout):: sf\n      !     class(speciesdata), intent(in)  :: self\n      integer,           intent(inout):: nrc\n      !    integer,  intent(in)            :: nrc\n\n      !    integer                       :: nrc\n      real                          :: fpoor\n\n      ! soil fertility\n      real, dimension(3)            :: fert_c1, fert_c2, fert_c3\n\n      data  fert_c1 /-0.6274,-0.2352,0.2133/\n      data  fert_c2 /3.600,2.771,1.789/\n      data  fert_c3 /-1.994,-1.550,-1.014/\n\n      !this cannot be converted to a real \"method\" until it is resolved whether\n      ! the following is a bug.  as it is, it changes the avail_n as well as the\n      ! required nitrogen on each call.\n\n      !!!warning warning warning possible massive bug here\n      nrc=4-nrc\n      sf = min(sf,1.0)\n      fpoor=fert_c1(nrc)+fert_c2(nrc)*sf+fert_c3(nrc)*sf**2\n      if (fpoor.le. 0.0) fpoor=0.0\n      if (fpoor.ge. 1.0) fpoor=1.0\n      poor_soil_rsp=fpoor*sf\n\n   end function poor_soil_rsp\n"}, {"instruction": "Create a Fortran function named fdry that takes two input parameters of type real and integer, and returns a single real output. The function calculates the value of fdry based on the input parameters and the predefined array gama.", "input": "", "output": "   function fdry(dryday,k)\n      real                :: fdry\n      real,    intent(in) :: dryday\n      integer, intent(in) :: k\n\n      real                :: tmp\n      real, dimension(6)  :: gama\n      data gama/0.50,0.45,0.35,0.25,0.15,0.05/\n\n      tmp=max(gama(k)-dryday,0.0)\n      fdry=(tmp/gama(k))**0.5\n\n   end function fdry\n"}, {"instruction": "Write a Fortran function named gdk_keymap_get_entries_for_keyval that takes 4 input parameters of type c_ptr, value, integer(c_int), value, type(c_ptr), value, and type(c_ptr), value. The function returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gdk_keymap_get_entries_for_keyval(keymap, keyval, keys, n_keys) bind(c&\n&) \n  use iso_c_binding, only: c_int, c_ptr\n  integer(c_int) :: gdk_keymap_get_entries_for_keyval\n  type(c_ptr), value :: keymap\n  integer(c_int), value :: keyval\n  type(c_ptr), value :: keys\n  type(c_ptr), value :: n_keys\nend function\n"}, {"instruction": "Create a Fortran function named greeting3, which takes a single input argument of type character(5) and returns a single output argument of type character(5), which is allocatable.", "input": "", "output": "  function greeting3 (arg) result(res)\n    character(5) :: arg\n    character(5), allocatable :: res, res1\n    allocate(res, res1, source = arg) ! caused an ice\n    if (res1 .ne. res) stop 8\n  end function\n"}, {"instruction": "Create a Fortran function named power2 that takes an integer as input and returns a logical value indicating whether the input number is a power of 2 or not. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "      function power2(number)\n! returns true if the number is a power of 2, if not it returns false \n        implicit none\n        integer :: number,x\n        logical :: power2\n        x = number\n           ! write(*,*) x\n        if (x .eq. 0)then \n           power2 = .false.\n           return\n        endif\n        \n        do while(mod(x,2) .eq. 0)\n           x = x / 2\n        end do\n        if (x .gt. 1) then\n           power2 =.false.\n           return\n        else\n           power2 = .true.\n        endif\n        \n      end function power2\n"}, {"instruction": "Create a Fortran function called \"associated_laguerre\" to calculate the value of an associated Laguerre polynomial. The function takes 3 input parameters of type integer, real, and real, denoted as [\"integer\", \"real\", \"real\"], and returns 1 output parameter of type real, denoted as [\"real\"].", "input": "", "output": "   elemental function associated_laguerre(n, alpha, x)\n\n      integer, intent(in) :: n\n      real, intent(in) :: x\n      real, intent(in) :: alpha\n      integer :: k\n      real :: associated_laguerre, p, p1, p2\n\n      p1 = dble(1.0)\n      p2 = dble(1.0) + alpha - x\n\n      if (n == 0) then\n         associated_laguerre = p1\n         return\n      else if (n == 1) then\n         associated_laguerre = p2\n         return\n      end if\n\n      do k = 2, n\n         p = ((dble(2.0) * k - dble(1.0) + alpha - x) * p2 - (k - dble(1.0) + alpha) * p1) / k\n         p1 = p2\n         p2 = p\n      end do\n\n      associated_laguerre = p\n\n   end function associated_laguerre\n"}, {"instruction": "Create a Fortran function named associated_legendre to calculate the associated Legendre function for given inputs. The function takes 3 input parameters of types integer, integer, and double precision, and returns 1 output parameter of type double precision.", "input": "", "output": "   elemental function associated_legendre(l, m, x)\n\n      integer, intent(in) :: l, m\n      double precision, intent(in) :: x\n      integer :: k\n      double precision :: associated_legendre, p, p1, p2, fac\n      double precision :: pi\n\n      pi = 3.14159265359\n\n      ! to start the recursion, use that p_l^m = 0 for l < abs(m)\n      ! and p_l^l = (-1)^l*(2l-1)!!(1-x^2)^(l/2)\n      ! where (2l-1)!! = 2**l * gamma(l+0.5) / sqrt(pi)\n      p1 = 0.\n      p2 = (-1)**abs(m) * 2**abs(m) * gamma(abs(m) + 0.5) / sqrt(pi) * (1.-x**2)**(abs(m) / 2.)\n\n      if (abs(m) > l) then\n         associated_legendre = 0.\n         return\n      end if\n\n      if (l == 0) then\n         associated_legendre = 1.\n         return\n      end if\n\n      if (l == m) then\n         associated_legendre = p2\n         return\n      end if\n\n      if (l == -m) then\n         fac = (-1)**abs(m) * gamma(l - abs(m) + 1.) / gamma(l + abs(m) + 1.)\n         associated_legendre = p2 * fac\n         return\n      end if\n\n      do k = abs(m) + 1, l\n         p = ((dble(2.0) * k - dble(1.0)) * x * p2 - (k - dble(1.0) + abs(m)) * p1) / (k - abs(m))\n         p1 = p2\n         p2 = p\n      end do\n\n      if (m < 0) then\n         fac = (-1)**abs(m) * gamma(l - abs(m) + 1.) / gamma(l + abs(m) + 1.)\n         p = p * fac\n      end if\n\n      associated_legendre = p\n\n   end function associated_legendre\n"}, {"instruction": "Create a Fortran function named bin to calculate the binomial coefficient \"n choose k\". The function takes 2 input parameters of type integer(kind=4) and returns 1 output parameter of type integer(kind=4). The test_data type for input parameters is ['integer(kind=4)', 'integer(kind=4)'] and for the output parameter is ['integer(kind=4)'].", "input": "", "output": "  pure function bin(n,k) result (c)\n    implicit none\n    integer(kind=4), intent(in) :: n, k\n    integer(kind=4) :: i, c\n    c = 1\n    do i = 0, min(k,n-k) - 1\n       c = c * (n - i)\n       c = c / (i + 1)\n    end do\n  end function bin\n"}, {"instruction": "Write a Fortran function named \"taumn\" that calculates and returns a real(kind=8) value. The function should take 5 input arguments of type real(kind=8) - temp, taum, taun, wm, and wn. It should return a single real(kind=8) output value, tmn.", "input": "", "output": "function taumn(temp,taum,taun,wm,wn) result(tmn)\n    \n    implicit none\n\n    real(kind=8) :: temp,tmn,taum,taun,wm,wn\n\n    tmn = (wm+wn)**2/4/wm/wn*(taum+taun)/((taum+taun)**2+(wm-wn)**2)+&\n        (wm-wn)**2/4/wm/wn*(taum+taun)/((taum+taun)**2+(wm+wn)**2)\n\n\n\nend function\n"}, {"instruction": "Create a Fortran function named randint to generate a random integer within a specified range. The function takes 2 input arguments of type integer, where the second argument is optional. The test_data type for the input parameters is ['integer', 'integer, optional']. The function returns 1 output argument of type integer, with the test_data type being ['integer'].", "input": "", "output": "  function randint(a, b)\n\n    integer, intent(in)::a\n    integer, intent(in), optional::b\n    integer::rangemin\n    integer::rangemax\n    real::r\n    integer::randint\n\n    if (present(b)) then\n      rangemin = a\n      rangemax = b\n    else\n      rangemin = 1\n      rangemax = a\n    end if\n\n    call random_number(r)\n\n    randint = int(r*(rangemax - rangemin - 1)) + rangemin\n\n  end function randint\n"}, {"instruction": "Create a Fortran function named get_movement_totals to process a file containing submarine movement data. The number of input arguments is 1, with a test_data type of [character(len=*)]. The number of output arguments is 1, with a test_data type of [integer].", "input": "", "output": "\tfunction get_movement_totals(filename) result (total_pos)\n\t\timplicit none\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tinteger :: fileunit,io,io_err,x,total_for=0,total_up=0,total_down=0,final_depth=0\n\t\tcharacter(len=10) :: data_in\n\t\tinteger :: total_pos ! type for the returned answer\n\t\t\n\t\topen(newunit=fileunit, file=filename, action='read', position='rewind')\n\t\t\n\t\tdo\n\t\t\tread(fileunit,*,iostat=io_err) data_in,x\n\t\t\tif(io_err .ne. 0) exit\n\t\t\t\n\t\t\tselect case (trim(data_in))\n\t\t\tcase (\"forward\")\n\t\t\t\ttotal_for = total_for + x\n\t\t\tcase (\"up\")\n\t\t\t\ttotal_up = total_up + x\n\t\t\tcase (\"down\")\n\t\t\t\ttotal_down = total_down + x\n\t\t\tend select\n\t\tend do\n\t\t\n\t\tclose(fileunit)\n\n\t\tfinal_depth = total_down - total_up\n\t\t\n\t\twrite (*,'(a)') \"calculating submarine movement:\"\n\t\twrite (*,'(a,i4.4)') \" \u00bb total forward: \",total_for\n\t\twrite (*,'(a,i4.4)') \" \u00bb total up: \",total_up\n\t\twrite (*,'(a,i4.4)') \" \u00bb total down: \",total_down\n\t\twrite (*,'(a,i4.4)') \" \u00bb final depth: \",final_depth\n\t\t\n\t\ttotal_pos = final_depth * total_for\n\n\tend function get_movement_totals\n"}, {"instruction": "Create a Fortran function named improved_magnus to calculate the vapor pressure of water at a given temperature. The function takes 1 input parameter of type real, and returns 1 output parameter of type real.", "input": "", "output": "function improved_magnus(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: improved_magnus\n\nimproved_magnus = 610.94 * exp((17.625 * (t-273.15)) / (t + 243.04 - 273.15))\nend function\n"}, {"instruction": "Write a Fortran function named \"wagnerpruss\" to calculate the saturation water vapor pressure in pascals based on the input temperature in Kelvin. The number of input arguments is 1, with a test_data type of ['real']. The number of output arguments is 1, with a test_data type of ['real'].", "input": "", "output": "function wagnerpruss(t)\n\nimplicit none\nreal, intent(in) :: t\nreal :: wagnerpruss  ! saturation water vapour pressure [pa]\n\nreal, parameter :: tc = 647.096 ! critical point temperature [k]\n\nreal :: x\n\nx = (1 - (t/tc))\nwagnerpruss = 22064000.0 * exp( (tc/t) * ( &\n  - 7.85951783 * x &\n  + 1.84408259 * x**1.5 &\n  - 11.7866497 * x**3 &\n  + 22.6807411 * x**3.5 &\n  - 15.9618719 * x**4 &\n  + 1.80122502 * x**7.5 &\n  ))\n\nend function wagnerpruss\n"}, {"instruction": "Create a Fortran function named huang to calculate the Huang equation for the saturation vapor pressure. The function should take 1 input argument of type real and return 1 output argument of type real. The input argument represents the temperature in Kelvin.", "input": "", "output": "function huang(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: huang\n\nreal :: tc\n\ntc = t - 273.15  !  tc [degc]\n\nhuang = exp(34.494 - 4924.99 / (tc + 237.1)) /  (tc + 105)**1.57\n\nend function huang\n"}, {"instruction": "Write a Fortran function named huang_ice that calculates the relative electrical permittivity of ice based on the input temperature. The function takes 1 input argument of type real and returns 1 output argument of type real. The input argument represents the temperature in Kelvin. Use the provided formula to perform the calculation and return the result.", "input": "", "output": "function huang_ice(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: huang_ice\n\nreal :: tc\n\ntc = t - 273.15  !  tc [degc]\n\nhuang_ice = exp(43.494 -  6545.8 / (tc + 278)) / (tc + 868)**2\n\nend function huang_ice\n"}, {"instruction": "Create a Fortran function named sattab_l that takes an integer input parameter. The function calculates the saturation vapor pressure over liquid water at a given temperature based on the input parameter. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function sattab_l(m)\n  implicit none\n  integer, intent(in) :: m\n  real :: sattab_l, t\n  \n  t = 150.+0.2*m\n  sattab_l = exp(54.842763-6763.22/t-4.21*log(t)+0.000367*t+&\n       tanh(0.0415*(t-218.8))*(53.878-1331.22/t-9.44523*log(t)+ 0.014025*t))\nend function sattab_l\n"}, {"instruction": "Create a Fortran function named sattab_i to calculate the saturation pressure of water vapor based on the input temperature in Celsius. The function should have 1 input parameter of type integer, and the output parameter should be of type real.", "input": "", "output": "function sattab_i(m)\n  implicit none\n  integer, intent(in) :: m\n  real :: sattab_i, t\n\n  t = 150.+0.2*m\n  sattab_i = exp(9.550426-5723.265/t+3.53068*log(t)-0.00728332*t)\nend function sattab_i\n"}, {"instruction": "Create a Fortran function named cala3 to calculate the modified 4-digit thickness (a3 variable). It takes 3 input arguments of real type: a0, d1, and xmt. The output is a real value.", "input": "", "output": "pure function cala3(a0, d1, xmt) result(f)\r\n! ------------------------------------------------------------------------------\r\n! purpose - the a3 variable used for the modified 4-digit thickness   \r\n\r\n  real,intent(in):: a0,d1,xmt\r\n\r\n  real:: f\r\n  real:: omxmt\r\n  real:: v1,v2,v3                                                   \r\n!-------------------------------------------------------------------------------\r\n  omxmt= 1.0-xmt \r\n  v1=0.1/(xmt*xmt*xmt)\r\n  v2=(d1*omxmt-0.294)/(xmt*omxmt*omxmt) \r\n  v3=(3.0/8.0)*a0/(xmt**2.5) \r\n  f = v1 + v2 - v3 \r\n  return\r\nend function cala3   ! ---------------------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named leadingedgeradius4 to calculate the leading edge radius of a 4-digit thickness distribution. The function should take 1 input argument of type real and return 1 output argument of type real. The input argument represents the maximum value of t/c. Use the equation rle=a*toc**2, where \"a\" is a predefined constant, to calculate the leading edge radius.", "input": "", "output": "pure function leadingedgeradius4(toc) result(rle)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the leading edge radius of a 4-digit thickness\r\n!   distribution.\r\n\r\n  real,intent(in):: toc       ! maximum value of t/c\r\n\r\n  real:: rle\r\n  real,parameter:: a=1.1019  ! eq. 6.3, p.114 in abbott & von doenhoff\r\n!-------------------------------------------------------------------------------\r\n  rle=a*toc**2\r\n  return\r\nend function leadingedgeradius4    ! -------------------------------------------\r\n"}, {"instruction": "Create a Fortran function called leadingedgeradius4m to calculate the leading edge radius of a 4-digit-modified thickness distribution. This function takes 2 input parameters of type real, toc (maximum value of t/c) and leindex (leading edge index), and returns 1 output parameter of type real, rle (leading edge radius).", "input": "", "output": "pure function leadingedgeradius4m(toc,leindex) result(rle)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the leading edge radius of a 4-digit-modified thickness\r\n!   distribution from the thickness and the le index.\r\n! note - leindex is coded as real, although it is usually integer.\r\n\r\n  real,intent(in):: toc       ! maximum value of t/c\r\n  real,intent(in):: leindex   ! leading edge index\r\n\r\n  real:: rle\r\n  real,parameter:: a=1.1019/36.0  ! see p.117 in abbott & von doenhoff\r\n!-------------------------------------------------------------------------------\r\n  rle=a*(toc*leindex)**2\r\n  return\r\nend function leadingedgeradius4m    ! ------------------------------------------\r\n"}, {"instruction": "Create a Fortran pure function named polynomial to evaluate a polynomial with real coefficients at a given value of x. The function takes 2 input parameters of type real,dimension(:) and real, and returns 1 output parameter of type real.", "input": "", "output": "pure function polynomial(c,x) result(f)\r\n! ------------------------------------------------------------------------------\r\n! purpose - evaluate a polynomial with real coefficients at x\r\n!   f= c(1) + c(2)*x + c(3)*x**2 + c(4)*x**3 + c(5)*x**4 + ...\r\n!   straightforward application of horner's rule.\r\n\r\n  real,intent(in),dimension(:):: c\r\n  real,intent(in):: x\r\n  real:: f\r\n\r\n  real:: ff\r\n\r\n  integer:: j,n\r\n!-------------------------------------------------------------------------------\r\n  n=size(c)\r\n  ff=c(n)\r\n  do j=n-1,1,-1\r\n    ff = ff*x + c(j)\r\n  end do\r\n\r\n  f=ff\r\n  return\r\nend function polynomial   ! ----------------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named period to calculate the period of a repeating decimal when 1 is divided by the given integer value n. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "  pure function period(n)\n    implicit none\n    integer, intent(in)      :: n\n    integer, parameter       :: size=1000000\n    integer, dimension(size) :: quotients,remainders\n    integer                  :: period,i,j\n\n    quotients(1)=0\n    remainders(1)=1\n\n    ! generate sequence of (quotient,remainder) pairs.  a cycle occurs\n    ! when and only when a (quotient,remainder) pair is repeated.\n    do i=2,size\n       quotients(i)=(remainders(i-1)*10)/n\n       remainders(i)=mod(remainders(i-1)*10,n)\n       ! look for a repeated pair\n       do j=1,i-1\n          if (quotients(i)==quotients(j) .and. remainders(i)==remainders(j)) then\n             period=i-j\n             go to 1\n          end if\n       end do\n    end do\n1   continue\n\n  end function period\n"}, {"instruction": "Create a Fortran function named randi to generate a random integer within a specified range. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['integer'].", "input": "", "output": "  function randi(min,max) result(rnum)\n    ! gives a random integer between min and max\n    implicit none\n\n    integer :: min, max, rnum\n    real(4) :: rand_num\n\n    call random_number(rand_num)\n\n    rnum = floor(rand_num * (max+1 - min) + min)\n\n  end function randi\n"}, {"instruction": "Write a Fortran function named random_translation to calculate a new position by randomly translating a given vector within a specified range. The function takes 2 input arguments of type real and real, dimension(3) and returns 1 output argument of type real, dimension(3).", "input": "", "output": "        function random_translation (dr_max, vector) result (new_position)\r\n            implicit none\r\n            real, dimension(3)             :: new_position\r\n            real, intent(in)               :: dr_max\r\n            real, dimension(3), intent(in) :: vector\r\n            real, dimension(3)             :: xyz\r\n\r\n            call random_number(xyz)\r\n            xyz(:) = 2.0 * xyz(:) - 1.0\r\n\r\n            new_position(:) = vector(:) + xyz(:) * dr_max\r\n        end function random_translation\r\n"}, {"instruction": "Write a Fortran function named metropolis to determine whether a proposed change in energy, represented by the input parameter 'delta', should be accepted. The input parameter is of type real, and the output parameter is of type logical. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "        function metropolis ( delta ) result ( accept )\r\n            implicit none\r\n            logical          :: accept\r\n            real, intent(in) :: delta\r\n            real, parameter  :: exponent_guard = 75.0\r\n            real             :: randcomp\r\n\r\n            if ( delta > exponent_guard ) then\r\n                accept = .true.\r\n            else if ( delta < 0.0 ) then\r\n                accept = .false.\r\n            else\r\n                call random_number(randcomp)\r\n                accept = (1 - exp(-delta)) > randcomp\r\n            end if\r\n        end function metropolis\r\n"}, {"instruction": "Create a Fortran function named nthroot to calculate the nth root of a given real number. The function takes 3 input parameters, where the first one is an integer and the next two are real, with the second being mandatory and the third being optional. The function returns a single real number as the output.", "input": "", "output": "  function nthroot(n, a, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: a\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( a < 0 ) then\n       stop \"a < 0\"       ! we handle only real positive numbers\n    elseif ( a == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = a\n    x(2) = a/n   ! starting \"guessed\" value...\n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + a/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n"}, {"instruction": "Write a Fortran function called userfunc that calculates the sine of the sum of two double-precision floating-point numbers. The function should have 2 input parameters of type real(8), and the test_data type is ['real(8)', 'real(8)']. It should produce 1 output parameter of type real(8), and the test_data type is ['real(8)'].", "input": "", "output": "function userfunc(x, y) result(func)\n\n  implicit none\n\n  real(8) :: x, y, func\n\n  func = sin(x + y)\n\nend function userfunc\n"}, {"instruction": "Create a Fortran function named cross to calculate the cross product of two 3D vectors. The function should take 2 input parameters of type real*8, dimension(3) and output 1 parameter of type real*8, dimension(3).", "input": "", "output": "function cross(a, b)\r\n  !\r\n  ! calculates the cross product of 2 3d-vectors\r\n  !\r\n  implicit none\r\n  real*8, dimension(3) :: cross\r\n  real*8, dimension(3), intent(in) :: a, b\r\n  cross(1) = a(2) * b(3) - a(3) * b(2)\r\n  cross(2) = a(3) * b(1) - a(1) * b(3)\r\n  cross(3) = a(1) * b(2) - a(2) * b(1)\r\nend function cross\r\n"}, {"instruction": "Write a Fortran function named intersect that computes the intersection interval \"distance\" of two intervals, each defined by a greater and lesser value. The number of input arguments is 4, and the test_data type is [real, real, real, real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function intersect(begind_a,endd_a,begind_b,endd_b)\n!\nimplicit none\n!\n\n!\nreal :: begind_a,begind_b,endd_a,endd_b\nreal :: intersect\n!\n!     + + + purpose + + +\n!     returns the intersection interval \"distance\" of two intervals\n!     each defined by a greater and lesser value\n!     obviously the units must be consistent.\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     begind_a - lesser value of interval a\n!     endd_a   - greater value of interval a\n!     begind_b - lesser value of interval b\n!     endd_b   - greater value of interval b\n \n!     + + + end specifications + + +\n \nif ((endd_a.le.begind_b).or.(begind_a.ge.endd_b)) then\n  intersect = 0.0\n          ! some part of interval b intersects interval a\nelse if ((begind_a.le.begind_b).and.(endd_a.ge.endd_b)) then\n              ! interval a completely surrounds interval b\n  intersect = endd_b - begind_b\nelse if (begind_a.le.begind_b) then\n              ! top part of interval b intersects farther end of interval a\n  intersect = endd_a - begind_b\nelse if (endd_a.ge.endd_b) then\n              ! farther end of interval b intersects nearer end of interval a\n  intersect = endd_b - begind_a\nelse\n              ! interval b completely surrounds interval a\n  intersect = endd_a - begind_a\nend if\n! \nend function intersect\n"}, {"instruction": "Create a Fortran function named permutations to check if two integers are permutations of each other. The function should take 2 input arguments of type integer. The test_data type for input arguments is ['integer', 'integer']. The function should return 1 output argument of type logical. The test_data type for the output argument is ['logical'].", "input": "", "output": "  pure function permutations(a,b)\n    implicit none\n    integer, intent(in)    :: a,b\n    integer, dimension(10) :: a_ar, b_ar\n    integer                :: i,temp,a_curr,b_curr\n    logical                :: permutations\n\n    do i=1,10\n       a_ar(i)=0\n       b_ar(i)=0\n    end do\n\n    a_curr=a\n    b_curr=b\n\n    do i=1,4\n       temp=mod(a_curr,10)+1\n       a_ar(temp)=a_ar(temp)+1\n\n       temp=mod(b_curr,10)+1\n       b_ar(temp)=b_ar(temp)+1\n\n       a_curr=a_curr/10\n       b_curr=b_curr/10\n    end do\n\n    permutations=all(a_ar == b_ar,1)\n\n  end function permutations\n"}, {"instruction": "Create a Fortran function named getlen to determine the length of a character string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function getlen(string)\n implicit none\n character(len=*), intent(inout):: string\n character(len=256):: chatmp*256\n integer:: nl,getlen\n\n chatmp=adjustl(string)\n nl=len_trim(chatmp)\n string=''\n string=chatmp(1:nl)\n getlen=nl\nend function getlen\n"}, {"instruction": "Write a Fortran function named wave that calculates a complex wave value based on the input parameters. The function takes 4 input parameters of type integer and returns a single output parameter of type complex.", "input": "", "output": "function wave(nlen,kmax,iw,ic)\n implicit none\n integer, parameter :: double=kind(0.0d0)\n real(kind=double), parameter :: pi=3.1415926535897d0, &\n                   p23=2.0d0*pi/3.0d0,p43=4.0d0*pi/3.0d0\n integer, intent(in) :: nlen,kmax,iw,ic\n real(kind=double), dimension(2):: g,p\n real(kind=double):: w,hw,ww,wd,wf,wg,wp,fw\n real:: r1,r2\n integer:: i,j,k\n complex:: wave\n wd=0.0d0\n w=2.0d0*pi*real(iw-1,double)/real(kmax,double)\n hw=w*0.5d0\n ww=dabs(w)\n wave=cmplx(0.0,0.0)\n if(ww >(2.0d0*p43).or.ww < p23) return\n do i=1,2\n   wp=hw*i\n   fw=1.0d0\n   do j=1,2\n     if(j == 1)then\n       wf=-wp\n     else\n       wf=wp\n     end if\n     do k=1,2\n       if(k == 1) wd=p43-wf\n       if(k == 2) wd=wf-p23\n       if(wd <= 0.0d0)then\n         g(k)=0.0d0\n       else\n        g(k)=exp(-1.0/wd/wd)\n       end if\n     enddo\n     wg=g(1)/(g(1)+g(2))\n     fw=fw*wg\n   enddo\n   p(i)=fw\n enddo\n r1=real(hw)\n r2=real(p(1)-p(2))*float(nlen)/float(kmax)\n wave = cmplx(cos(r1),-sin(r1))*csqrt(cmplx(r2, 0.0))\n if(ic == 1) then\n!   w= 2.d0*pi*real(iw-1,double)/real(nlen*dt,double)\n!   wave=wave*cmplx(-sngl(w*w),0.0)\n else\n   wave = conjg(wave)\n endif\n return\nend function wave\n"}, {"instruction": "Create a Fortran function named polynomial to compute the value of a polynomial function for a given argument. The number of input arguments is 2, with test_data types ['integer, dimension(:)', 'real']. The number of output arguments is 1, with a test_data type of ['real'].", "input": "", "output": "  function polynomial ( c, x ) result ( f )\n    implicit none\n    integer, dimension(:), intent(in) :: c ! coefficients of x**0, x**1, x**2 etc\n    real,                  intent(in) :: x ! argument\n    real                              :: f ! result\n\n    integer :: i\n\n    f = 0.0\n    do i = size(c), 1, -1\n       f = f * x + real ( c(i) )\n    end do\n\n  end function polynomial\n"}, {"instruction": "Create a Fortran function named fact to compute the factorial of a given integer input. The input argument is 1 and the test_data type is ['integer']. The output argument is 1 and the test_data type is ['integer'].", "input": "", "output": "function fact(n)\n\n!-------------------------------------------------------------\n!\n! compute the factorial, n!\n!\n!-------------------------------------------------------------\n\nimplicit none\ninteger, intent(in) :: n\ninteger :: fact, i\n\nfact = 1\nif (n > 0) then\n   do i = 1, n\n      fact = fact*i\n   end do\nend if\n\nend function fact\n"}, {"instruction": "Write a Fortran function named get_bath_dimension_symmetries to determine the size of the bath based on the provided complex input array. The function accepts 1 input parameter of type complex(8),dimension(:,:,:,:,:,:,:), and returns 1 output parameter of type integer.", "input": "", "output": "function get_bath_dimension_symmetries(hloc_nn) result(bath_size)\n  complex(8),dimension(:,:,:,:,:,:,:),intent(in)                     :: hloc_nn\n  integer                                                            :: bath_size,ndx,isym,nsym\n  !\n  !number of symmetries\n  nsym=size(hloc_nn(1,1,1,1,1,1,:))\n  !\n  ndx=nsym\n  !\n  !for each replica we also print n_dec\n  ndx=ndx+1\n  !\n  !number of replicas\n  ndx = ndx * nbath\n  !diagonal hybridizations: vs\n  ndx = ndx + nbath\n  !\n  bath_size = ndx\n  !\nend function get_bath_dimension_symmetries\n"}, {"instruction": "Create a Fortran function named count_lines_in_file to calculate the number of lines in a specified file. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t!******************************************************************************\n\t\timplicit none\n\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\n\t\t!the file is assumed to be open already.\n\n\t\trewind(fid)\t  !rewind to beginning of the file\n\n\t\tn_lines = 0\n\t\tdo !read each line until the end of the file.\n\t\t\tread(fid,'(a1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      !end of file\n\t\t\tn_lines = n_lines + 1  !row counter\n\t\tend do\n\n\t\trewind(fid)   !rewind to beginning of the file\t\n\n\t!******************************************************************************\n\t\tend function count_lines_in_file\n"}, {"instruction": "Create a Fortran function named ordered_word to determine if a given word is ordered or not. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical.", "input": "", "output": "\t pure elemental function ordered_word(word) result(yn)\n\t!******************************************************************************\n\t! turns true if word is an ordered word, false if it is not.\n\t!******************************************************************************\n\t\n\t implicit none\n\t character(len=*),intent(in) :: word\n\t logical :: yn\n\t\n\t integer :: i\n\t\n\t yn = .true.\n\t do i=1,len_trim(word)-1\n\t \tif (ichar(word(i+1:i+1))<ichar(word(i:i))) then\n\t \t\tyn = .false.\n\t \t\texit\n\t \tend if\n\t end do\n\t\n\t!******************************************************************************\n\t end function ordered_word\n"}, {"instruction": "Write a Fortran function named f_upcase to convert a given string to uppercase. The function takes 1 input argument with the test_data type ['character(len=*)'], and returns 1 output argument with the test_data type ['character(len=len(string))'].", "input": "", "output": "    function f_upcase(string) result(upper)\n    implicit none\n\n    !i/o variables\n    character(len=*), intent(in) :: string\n    character(len=len(string)):: upper\n\n    !local variables\n    integer:: j\n\n    do j = 1,len(string)\n        if(string(j:j) >= \"a\" .and. string(j:j) <= \"z\") then\n            upper(j:j) = achar(iachar(string(j:j)) - 32)\n        else\n            upper(j:j) = string(j:j)\n        end if\n    end do\n\n    end function f_upcase\n"}, {"instruction": "Create a Fortran function named is_uppercase to determine if a given string consists of all uppercase letters. The function should take 1 input argument of type character(len=*) and return 1 output argument of type logical.", "input": "", "output": "  function is_uppercase(str)\n    logical :: is_uppercase\n    character(len=*),intent(in) :: str\n    character :: chr\n    integer :: i\n    is_uppercase = .false.\n    do i = 1,len_trim(str)\n      chr = str(i:i)\n      if (chr >= 'a' .and. chr <= 'z') then\n        is_uppercase = .false.\n        return\n      else if (chr >= 'a' .and. chr <= 'z') then\n        is_uppercase = .true.\n      end if\n    end do\n  end function is_uppercase\n"}, {"instruction": "Create a Fortran function named sum_array to calculate the sum of elements in an integer array. The function takes 2 input parameters: the size of the array (integer) and the array itself (integer, dimension(size)). It returns 1 output parameter of type integer.", "input": "", "output": "function sum_array(size,a) result(ret)\n  implicit none\n  integer :: size\n  integer, dimension(size) :: a\n  integer :: i\n  integer :: ret\n \n  ret = 0\n  \n  do i=1,size\n    ret = ret + a(i)\n  end do\n  \nend function sum_array\n"}, {"instruction": "Create a Fortran function named \"ij_code\" to determine the integer code corresponding to a given industry represented by a single character. The function takes 1 input parameter of type character(len=1) and returns 1 output parameter of type integer.", "input": "", "output": "    function ij_code(industry)\n\n        implicit none\n        character(len=1), intent(in) :: industry\n        integer :: ij_code\n\n        select case (industry)\n            case('m')\n                ij_code = 1\n            case('f')\n                ij_code = 2\n            case('u')\n                ij_code = 3\n            case('t')\n                ij_code = 4\n            case('s')\n                ij_code = 5\n            case default\n                stop 'industry does not exists'\n        end select\n\n    end function\n"}, {"instruction": "Define a Fortran function named kalbach to calculate optical model reaction cross sections using empirical parameterization. The function takes 6 input parameters of types integer(int32) and real(real64), and returns 1 output parameter of type real (real64).", "input": "", "output": "  function kalbach(kp, zp, ap, zt, at, elab)\n\n! ==============================================================================\n!\n!     written in 1982; revised 1990 by k.k. gudima\n!\n!     calculate optical model reaction cross sections\n!     using empirical parameterization\n!     of narasimha murthy, chaterjee, and gupta\n!     going over to the geometrical limit at high energy\n!\n!           proton cross sections scaled down with signor for a<100\n!           (appropriate for becchetti-greenlees potential)\n!           neutron cross sections scaled down sith signor for a<40\n!           (appropriate for mani et al potential)\n!\n!     parameter values set in subroutine sigpar\n! \n! ==============================================================================\n\n    use, intrinsic :: iso_fortran_env, only: int32, real64\n\n    implicit none\n    integer(int32), intent(in)   :: kp\n    real(real64),   intent(in)   :: zp\n    real(real64),   intent(in)   :: ap\n    real(real64),   intent(in)   :: zt\n    real(real64),   intent(in)   :: at\n    real(real64),   intent(in)   :: elab\n    real (real64)                :: kalbach\n\n    integer(int32) :: jout\n    real(real64)   :: a, ares, athrd, b, c, cut, ec, ecsq, ecut2, etest, flow, &\n         & geom, p, ra, sig, signor, signor2, spill, w, xlamb, xmu, xnu, xnulam\n    real(real64)   :: ecut\n\n! ==============================================================================\n\n    real(real64), parameter, dimension(6) :: xl0 = &\n         & [ 12.10, 0.00437, 0.00619, 0.0186, 0.00459, 0.0643 ]\n    real(real64), parameter, dimension(6) :: xl1 = &\n         & [ -11.27,  -16.58,   -7.54,  -8.90,   -8.93, -13.96 ]\n    real(real64), parameter, dimension(6) :: xm0 = &\n         & [ 234.1,   244.7,   583.5,  686.3,   611.2,  781.2 ]\n    real(real64), parameter, dimension(6) :: xm1 = &\n         & [ 38.26,   0.503,   0.337,  0.325,    0.35,   0.29 ]\n    real(real64), parameter, dimension(6) :: xn0 = &\n         & [ 1.55,   273.1,   421.8,  368.9,   473.8, -304.7 ]\n    real(real64), parameter, dimension(6) :: xn1 = &\n         & [ -106.1,  -182.4,  -474.5, -522.2,  -468.2,  -470. ]\n    real(real64), parameter, dimension(6) :: xn2 = &\n         & [ 1280.8,  -1.872,  -3.592, -4.998,  -2.225, -8.580 ]\n    real(real64), parameter, dimension(6) :: xp0 = &\n         & [ -312.,   15.72,   0.798, -21.45,   -2.88,  10.95 ]\n    real(real64), parameter, dimension(6) :: xp1 = &\n         & [ 0.,    9.65,   420.3,  484.7,   205.6, -85.21 ]\n    real(real64), parameter, dimension(6) :: xp2 = &\n         & [ 0.,   -300.,  -1651., -1608.,  -1487.,  1146. ]\n\n! ==============================================================================\n    \n    flow = 1.e-18\n    spill = 1.e+18\n    jout = nint(ap)\n    ares = at+ap\n    athrd =ares**0.3333\n    signor = 1.\n! signor reduces p and n result for light targs as per expt.\n    if (kp == 1) then\n       if (ares < 40.) signor=0.7+ares*0.0075\n       xlamb = xl0(1)/athrd + xl1(1)\n       xmu = xm0(1)*athrd + xm1(1)*athrd*athrd\n       xnu = xn0(1)*athrd*ares + xn1(1)*athrd*athrd + xn2(1)\n!       ec = 2.4\n!       ecsq = 5.76\n       ec = 0.5\n       ecsq = 0.25\n!       ec = 1.\n!       ecsq = 1.\n       p = xp0(1)\n       xnulam = 1.\n       etest = 32.\n! etest is the energy above which the rxn cross section is\n!    compared with the geometrical limit and the max taken.\n!    xnulam here is a dummy value to be used later.\n       ra = 0.\n    else\n       ra = 1.20\n       if (kp == 2) then\n          ra = 0.\n          if (ares < 60.) then\n             signor = 0.92\n          else if (ares < 100.) then\n             signor = 0.8 + ares*0.002\n          end if\n       end if\n       ec = 1.44*zp*zt/(1.5*athrd+ra)\n       ecsq = ec * ec\n       p = xp0(kp) + xp1(kp)/ec + xp2(kp)/ecsq\n       xlamb = xl0(kp)*ares + xl1(kp)\n       a = ares**xm1(kp)\n       xmu = xm0(kp) * a\n       xnu = a* (xn0(kp)+xn1(kp)*ec+xn2(kp)*ecsq)\n       if (jout == 2) ra=0.8\n       if (jout == 3) ra=0.8\n! new values of ra are for calculating the geometrical limit\n!    to the cross section.\n       if (kp == 2) then\n          c = min(3.15_real64,ec*0.5)\n          w = 0.7 * c / 3.15\n! c and w are for the global corr'n factor for elab<ec\n!    for light targs they are scaled down from global values\n       end if\n       xnulam = xnu / xlamb\n       if (xnulam > spill) xnulam=0.\n       if (xnulam < flow) go to 20\n       if (kp == 2) then\n          etest = sqrt(xnulam) + 7\n       else\n          etest = 1.2 * sqrt(xnulam)\n       end if\n       ! for xnulam > 0, sig reaches a maximum at sqrt(xnulam).\n    end if\n20  a = -2.*p*ec + xlamb - xnu/ecsq\n    b = p*ecsq + xmu + 2.*xnu/ec\n    ecut = 0.\n    cut = a*a - 4.*p*b\n    if (cut > 0.) ecut = sqrt(cut)\n    ecut = (ecut-a) / (p+p)\n    ecut2 = ecut\n\n!    if (ecut < -0.05) then\n!       c = -ecut * 0.5\n!       w = -ecut * 0.1\n!    else if (cut < 0) then\n!       ecut2 = ecut * 0.25\n!    end if\n\n    if (cut < 0) ecut2 = ecut - 2.\n\n!    sigmin = b - 0.25*a*a/p\n! ecut is the energy where sigma=0 (if cut>0).  below ecut2\n!    sigma is set identically to zero to avoid unphysical values.\n    sig = 0.\n    if (elab <= ec) then\n       if (elab > ecut2) then\n          sig = (p*elab*elab+a*elab+b) * signor\n          if (kp == 2) then\n             signor2 = (ec - elab - c) / w\n             signor2 = 1 + exp(signor2)\n             sig = sig / signor2\n\n!             if (ecut < -0.05) then\n!                if (elab < -ecut) then\n!                   signor2 = (c - elab) / w\n!                   signor2 = 1 + exp(signor2)\n!                   sig = sig / signor2\n!                end if\n!             end if\n          end if\n\n! first signor gives empirical global corr'ns at low elab\n!    second signor corrects values near elab=0; light nuclei\n       end if\n    else\n       sig = (xlamb*elab+xmu+xnu/elab) * signor\n       geom = 0.0_real64\n       if (xnulam < flow) go to 36\n       if (elab < etest) go to 36\n       geom = sqrt(ap*elab)\n       geom = 1.23*athrd + ra + 4.573/geom\n       geom = 31.416 * geom * geom\n       sig = max(geom,sig)\n    end if\n36  kalbach=sig\n    return\n\n  end function kalbach\n"}, {"instruction": "Create a Fortran function named fm that takes two integer input arguments with test_data type ['integer', 'integer'] and returns a single real output with test_data type ['real(dp)']. The function computes the value of fm using the formula sqrt( (i_ang + k_ang) * (i_ang - k_ang + 2) / 4.0d0 ). Remember to use the selected real kind dp when declaring the real variable.", "input": "", "output": "function fm(i_ang, k_ang)\n  implicit none\n  integer, parameter :: dp = selected_real_kind(14)\n  \n  integer, intent(in) :: i_ang, k_ang\n  real(dp) :: fm\n\n  fm = sqrt( (i_ang + k_ang) * (i_ang - k_ang + 2) / 4.0d0 )\n  \nend function fm\n"}, {"instruction": "Create a Fortran function named createboard that takes two input arguments of type integer representing the number of rows and columns. The function returns a logical array of 2 dimensions that is dynamically allocated.", "input": "", "output": "    function createboard(rows, cols)\n\n        logical, dimension(:,:), allocatable :: createboard\n        integer, intent(in) :: rows, cols\n        integer :: r,c\n\n        allocate( createboard(rows, cols) )\n\n        do c = 1,cols\n            do r = 1,rows\n                createboard(r,c) = (nint(rand(0)) .eq. 0)\n            end do\n        end do\n\n    end function createboard\n"}, {"instruction": "Create a Fortran function named test_xyz to determine the dimensionality of the input arrays. The function takes 3 input parameters of types real(8), dimension(:,:), real(8), dimension(:,:), and real(4), dimension(:,:), and returns 1 output parameter of type character(len=2).", "input": "", "output": "   function test_xyz(rx, ry, rz)\n      !!\n      !! testing if 2d coordinates or 1d, and if match shape of data...\n      !!\n      character(len=2) :: test_xyz\n      !!\n      real(8), dimension(:,:), intent(in) :: rx, ry\n      real(4), dimension(:,:), intent(in) :: rz\n      !!\n      integer :: ix1, ix2, iy1, iy2, iz1, iz2\n      !!\n      ix1 = size(rx,1) ; ix2 = size(rx,2)\n      iy1 = size(ry,1) ; iy2 = size(ry,2)\n      iz1 = size(rz,1) ; iz2 = size(rz,2)\n      !!\n      if ( (ix2 == 1).and.(iy2 == 1) ) then\n         !!\n         if ( (ix1 == iz1).and.(iy1 == iz2) ) then\n            test_xyz = '1d'\n         else\n            print *, 'error, mod_drown.f90 = >test_xyz 1 : longitude and latitude array do not match data!'\n            print *, ''; stop\n         end if\n         !!\n      else\n         if ( (ix1 == iz1).and.(iy1 == iz1).and.(ix2 == iz2).and.(iy2 == iz2) ) then\n            test_xyz = '2d'\n         else\n            print *, 'error, mod_drown.f90 = >test_xyz 2 : longitude and latitude array do not match data!'\n            print *, ''; stop\n         end if\n      end if\n      !!\n      !!\n   end function test_xyz\n"}, {"instruction": "Create a Fortran function named liftf to calculate the lift. The function takes 1 input argument of type real, and returns 1 output argument of type real. The input argument is the velocity (vel), and the output argument is the lift force (liftf).", "input": "", "output": "     function liftf(vel) ! calculate lift\n      real :: vel, liftf\n      liftf = cl*(1./2)*rho*(vel**2)*wparea\n      return\n      end function liftf\n"}, {"instruction": "Create a Fortran function named dragf to calculate the drag force. The function takes 1 input parameter of type real. The output is 1 parameter of type real. The formula to calculate the drag force is given by dragf = cd * (1./2) * rho * (vel**2) * wparea, where cd, rho, and wparea are assumed to be predefined. Use the return statement to return the calculated drag force.", "input": "", "output": "     function dragf(vel) ! calculate drag\n      real :: vel, dragf\n      dragf = cd*(1./2)*rho*(vel**2)*wparea\n      return\n      end function dragf\n"}, {"instruction": "Create a Fortran function named fstring_hashkey that takes a string as input and returns an integer output. The input parameter should be of type character(*) and the output parameter should be of type integer. This function calculates a hash key for the input string and returns the result as an integer.", "input": "", "output": "\tfunction fstring_hashkey( str ) result( output )\n\t\tcharacter(*), intent(in) :: str\n! \t\tlogical, optional, intent(in) :: debug\n\t\tinteger :: output\n\t\t\n\t\tinteger :: i\n\t\t\n! \t\tlogical :: effdebug\n! \t\t\n! \t\teffdebug = .false.\n! \t\tif( present(debug) ) effdebug = debug\n\t\t\n\t\toutput = 0\n\t\tdo i=1,len(str)\n! \t\t\tif( effdebug ) then\n! \t\t\t\twrite(0,*) str(i:i), \"-->\", ichar(str(i:i)), \" : \", ichar(str(i:i))*31**(len(str)-i)\n! \t\t\tend if\n\t\t\t\n\t\t\toutput = output + ichar(str(i:i))*31**(len(str)-i)\n\t\tend do\n\t\t\n! \t\tif( effdebug ) then\n! \t\t\twrite(0,*) \"key --> \", output\n! \t\tend if\n\t\t\n\tend function fstring_hashkey\n"}, {"instruction": "Create a Fortran function named cc to calculate the value of c, used in the height field computation for the Rossby-Haurwitz wave. The function takes 1 input parameter of type real (kind=rkind) and returns 1 output parameter of type real (kind=rkind). Use the following formula to calculate the value of c: cc = 0.25 * k**2.0 * cos(theta)**(2.0*r) * ((r+1.0)*cos(theta)**2.0 - r - 2.0).", "input": "", "output": "function cc(theta)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  ! c, used in height field computation for rossby-haurwitz wave\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n  implicit none\n\n  integer, parameter :: rkind  = selected_real_kind(12)\n  real (kind=rkind), parameter :: w = 7.848e-6\n  real (kind=rkind), parameter :: k = 7.848e-6\n  real (kind=rkind), parameter :: r = 4.0\n\n  real (kind=rkind), intent(in) :: theta\n  real (kind=rkind) :: cc\n\n  cc = 0.25 * k**2.0 * cos(theta)**(2.0*r) * ((r+1.0)*cos(theta)**2.0 - r - 2.0)\n\nend function cc\n"}, {"instruction": "Create a Fortran function named loadoptionalparam_int to handle the loading of an optional integer parameter with a default value. The function takes 2 input parameters: defaultvalue of type integer and iparam of type integer, which is optional. It returns a single output parameter of type integer. If the optional parameter is present, the function assigns its value to loadoptionalparam_int; otherwise, it assigns the default value to it.", "input": "", "output": "  function loadoptionalparam_int(defaultvalue,iparam)\r\n    !tue dec, 2014\r\n\n    !io\r\n    !defaultvalue -> a default value which we load if the optional parameter does not exist.\r\n    !iparam       -> the optional parameter that we want to load\r\n    implicit none\r\n    integer, intent(in)          :: defaultvalue\r\n    integer, intent(in),optional :: iparam\r\n    integer                      :: loadoptionalparam_int\r\n    if(present(iparam)) then\r\n        loadoptionalparam_int=iparam\r\n      else \r\n        loadoptionalparam_int=defaultvalue\r\n      end if\r\n  end function loadoptionalparam_int\r\n"}, {"instruction": "Create a Fortran function named loadoptionalparam_real2 to handle optional parameters. The function takes 2 input parameters of type integer and real*8, where the second parameter is optional. It returns 2 output parameters of type real*8 and loadoptionalparam_real2(defaultvalue,iparam).", "input": "", "output": "  function loadoptionalparam_real2(defaultvalue,iparam)\r\n    !tue dec, 2014\r\n\n    !io\r\n    !defaultvalue -> a default value which we load if the optional parameter does not exist.\r\n    !iparam       -> the optional parameter that we want to load\r\n    implicit none\r\n    integer, intent(in)          :: defaultvalue\r\n    real*8, intent(in),optional :: iparam\r\n    real*8                      :: loadoptionalparam_real2\r\n    if(present(iparam)) then\r\n        loadoptionalparam_real2=iparam\r\n      else \r\n        loadoptionalparam_real2=defaultvalue\r\n      end if\r\n  end function loadoptionalparam_real2\r\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci sequence. The function takes 1 input argument with the data type integer. It returns 1 output argument with the data type integer.", "input": "", "output": "recursive function fib(x) result(ret)\n  integer, intent(in) :: x\n  integer :: ret\n  \n  if (x == 1 .or. x == 2) then\n    ret = 1\n  else\n    ret = fib(x-1) + fib(x-2)\n  end if\n\nend function fib\n"}, {"instruction": "Create a recursive Fortran function named fibonacci to calculate the Fibonacci sequence for the given input integer value i. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameters are represented by the test_data type ['integer'].", "input": "", "output": "        recursive function fibonacci(i) result(fibo)\r\n         integer, intent(in) :: i\r\n         integer :: fibo\r\n\r\n           if (i <= 1) then\r\n               fibo = 1\r\n                 else\r\n               fibo = fibonacci(i-1) + fibonacci(i-2)\r\n           end if\r\n\r\n           end function fibonacci\r\n"}, {"instruction": "Write a Fortran function named lambert_w to calculate the Lambert W function. The function takes 2 input parameters of type integer and real and returns 1 output parameter of type real. Use an iterative approach to approximate the value of the Lambert W function within a specified accuracy.", "input": "", "output": "function lambert_w(x, accuracy) result(y)\n    integer :: count, i, m\n    integer :: accuracy\n    real :: x, y, str, w\n\n    w = 0\n    y = 0\n    str = 0\n    i = 0\n    count = 0\n    m = 0\n\n10  if (abs(w - x) .gt. (real(1)/accuracy) .and. m .lt. accuracy) then\n        i = i + 1\n        m = (10 ** count)\n        y = str + real(i)/m\n        w = y * exp(y)\n        if (w .gt. x) then\n            y = str + real(i-1)/m\n            str = y\n            i = 0\n            count = count + 1\n        end if\n        goto 10\n    end if\nend function lambert_w\n"}, {"instruction": "Write a Fortran function named dirac_delta to calculate the Dirac delta function. The function takes 2 input arguments of type real and returns 1 output argument of type real. The test_data type for input arguments is [real, real], and for the output argument, it is [real].", "input": "", "output": "function dirac_delta(n, x) result(y)\n    real :: x, y, n\n    if (abs(x) > 1/(2*x)) then\n        y = 0\n    else\n        y = n \n    end if\nend function dirac_delta\n"}, {"instruction": "Create a Fortran recursive function named fact to compute the factorial of an integer. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. The input parameter is denoted by test_data type ['integer'], and the output parameter by test_data type ['integer'].", "input": "", "output": "recursive function fact(n) result(answer)\nimplicit none\ninteger, intent(in) :: n\ninteger :: answer\nif (n >= 1) then\n  answer = n * fact(n-1)\nelse\n  answer = 1\nend if\nend function fact\n"}, {"instruction": "Create a Fortran function named get_kinematic_viscosity to calculate the kinematic viscosity of a fluid based on the input parameters. The function takes in 4 real(kind=8) input parameters (mu_ref, t_ref, t, rho) and returns 1 real(kind=8) output parameter (nu).", "input": "", "output": "    function get_kinematic_viscosity(mu_ref, t_ref, t, rho) result(nu)\n        implicit none\n        real(kind=8), intent(in):: mu_ref ! cp, i.e., 1e-3 kg / m /s\n        real(kind=8), intent(in):: t_ref ! celsius\n        real(kind=8), intent(in):: t ! celsius\n        real(kind=8), intent(in):: rho ! kg / m^3\n        real(kind=8):: nu\n\n        ! get dynamic viscosity at ambient temperature (unit: cp)\n        nu = mu_ref**(-0.2661d0) + (t - t_ref) / 233d0\n        nu = - dlog(nu) / 0.2661d0\n        nu = dexp(nu)\n\n        ! convert to kg / s / m\n        nu = nu * 1d-3\n\n        ! get kinematic viscosity (m^2 / s)\n        nu = nu / rho\n    end function get_kinematic_viscosity\n"}, {"instruction": "Create a Fortran function named num_group_perms that takes an array of integers as input. The input parameter should be of type integer and have an unspecified dimension. The function should return a single integer as output.", "input": "", "output": "  function num_group_perms(group)\n    implicit none\n    integer :: num_group_perms, n_members\n    integer, dimension(:) :: group\n    integer, dimension(8) :: factorial\n\n    factorial = (/ 1,2,6,24,120,720,5040,40320 /)\n    n_members = ceiling(log10(real(maxval(group))))\n    num_group_perms = factorial(n_members)\n    return\n  end function num_group_perms\n"}, {"instruction": "Create a Fortran function named combine_perms that takes two input arrays of integers and returns a new array obtained by combining the elements of the first array based on the indices specified by the elements of the second array. The number of input arguments is 2 and the test_data type is ['integer, dimension(:)', 'integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, dimension(:), allocatable'].", "input": "", "output": "  function combine_perms(vec1,vec2)\n  implicit none\n  integer, dimension(:), intent(in) :: vec1, vec2\n  integer, dimension(:), allocatable :: combine_perms\n  integer :: j\n  allocate(combine_perms(size(vec1)))\n\n  if (size(vec1) /= size(vec2)) then\n    write(*,*) \"combine_perms received vectors of mismatched lengths\"\n    call exit(1)\n  end if\n\n  do j=1,size(vec1)\n    combine_perms(j) =  vec1(vec2(j))\n  end do\n  return\n  end function combine_perms\n"}, {"instruction": "Write a Fortran function named fibonacci to calculate the Fibonacci sequence up to the given integer input. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "    recursive function fibonacci(n) result(res_cyml)\n        implicit none\n        integer, intent(in) :: n\n        integer:: res_cyml\n        if(n .le. 1) then\n            res_cyml = n\n        else\n            res_cyml = fibonacci(n - 1) + fibonacci(n - 2)\n        end if\n    end function fibonacci\n"}, {"instruction": "Create a Fortran function named wrap to ensure that an input angle is within the range of 0 to 360 degrees. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. If the input angle is negative, it will be converted to the equivalent positive angle within the 0 to 360 degree range.", "input": "", "output": "    pure function wrap(angle) result(wrapped_angle)\n    !! wrap from 0 -> 360\n    implicit none \n    integer,intent(in) :: angle\n    integer :: wrapped_angle\n    wrapped_angle = mod(angle, 360)\n    if (wrapped_angle<0) wrapped_angle = wrapped_angle + 360\n    end function wrap\n"}, {"instruction": "Create a Fortran function named fibi to calculate the nth Fibonacci number based on the input parameter n, which is an integer. The function has one input argument of type integer and one output argument of type integer.", "input": "", "output": "    function fibi(n)\n        integer, intent(in) :: n\n        integer, parameter :: fib0 = 0, fib1 = 1\n        integer            :: fibi, back1, back2, i\n\n        select case (n)\n            case (:0);      fibi = fib0\n            case (1);       fibi = fib1\n\n            case default\n                fibi = fib1\n                back1 = fib0\n                do i = 2, n\n                    back2 = back1\n                    back1 = fibi\n                    fibi   = back1 + back2\n                end do\n         end select\n    end function fibi\n"}, {"instruction": "Create a Fortran function named linspace that generates a linearly spaced array of real numbers between a specified start and stop value. The function should take 3 input parameters of types integer, real(8), and real(8), representing the number of points, the start value, and the stop value respectively. The output should be a real(8) array of size n containing the linearly spaced values.", "input": "", "output": "  function linspace(my_start, my_stop, n)\n    implicit none\n    integer :: n, i\n    real(8) :: my_start, my_stop, step\n    real(8), dimension(n) :: grid, linspace\n\n    if (n.eq.1) then\n      grid(n) = (my_start+my_stop)/2.d0\n    elseif (n.ge.2) then\n      grid(1) = my_start\n      if (n.gt.2) then\n        step = (my_stop-my_start)/(real(n-1))\n        do i = 2, n-1\n          grid(i) = grid(i-1) + step\n        end do\n      end if\n      grid(n) = my_stop\n    endif\n    linspace = grid\n  end function linspace\n"}, {"instruction": "Create a Fortran function named my_ss that computes steady-state distribution using a transition matrix. The function has 2 input parameters: an integer and a 2D array of double-precision real numbers. The output is a 1D array of double-precision real numbers.", "input": "", "output": "  function my_ss(tmatrix,gp)\n    implicit none\n    integer :: gp\n    integer :: row, col, iter\n    real(8) :: aux_sum\n    real(8), dimension(gp) :: my_ss\n    real(8), dimension(gp) :: dist, ndist\n    real(8), dimension(gp,gp) :: tmatrix\n\n    ! initialise distribution\n    dist = 1.d0/real(gp)\n\n    do iter = 1, 10000\n      ndist = 0.d0\n      do col = 1, gp\n        do row = 1, gp\n          ndist(col) = ndist(col) + (dist(row)*tmatrix(row,col))\n        end do\n      end do\n      aux_sum = sum(abs(ndist-dist))\n      dist = ndist\n      if (aux_sum.lt.1.0d-8) then\n        exit\n      end if\n    end do\n\n    my_ss = dist\n  end function my_ss\n"}, {"instruction": "Write a Fortran function named fact that calculates the factorial of a given integer. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function fact(n) result(answer)\r\n!\r\n!  purpose:\r\n\n!             | n(n-1)!    n >= 1 \r\n!       n ! = |\r\n!             | 1          n = 0\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    12/07/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n         ! value to calculate\r\ninteger :: answer                ! result variable\r\n\r\nif ( n >= 1 ) then\r\n   answer = n * fact(n-1)\r\nelse\r\n   answer = 1\r\nend if\r\n\r\nend function fact\r\n"}, {"instruction": "Create a Fortran function named adjust_timestep to calculate the adjusted time step based on the input parameters. The function takes 4 input parameters of type real(8), real(8), real(8), and integer(8). The output parameter is a real(8).", "input": "", "output": "    function adjust_timestep(dt, err, q, t_tot)\n        implicit none\n        real(8), intent(in) :: dt, err, t_tot\n        integer(8), intent(in) :: q\n        real(8) :: adjust_timestep\n        real(8) :: fac\n!        real :: facmax=6., facmin=0.01\n!        real :: fac\n        fac = 0.38**(1. / (1. + q))\n        adjust_timestep = dt * fac * err**(-1. / (1. + q))\n!        print *, \"adjust timestep\", adjust_timestep, dt, fac, err\n!        if (adjust_timestep > facmax * dt) then\n!            adjust_timestep = facmax * dt\n!        else if (adjust_timestep < facmin * dt) then\n!            adjust_timestep = facmin * dt\n        if ((adjust_timestep / t_tot < 1e-12) .or. isnan(adjust_timestep)) then\n            adjust_timestep = t_tot * 1e-12\n        end if\n    end function adjust_timestep\n"}, {"instruction": "Create a Fortran function named center_of_mass that takes in 3 input parameters: an 8-byte integer \"n\", an array of 8-byte real numbers \"masses\" with dimension \"n\", and a 2D array of 8-byte real numbers \"positions\" with dimensions \"n\" and 3. The function returns a 1D array of 8-byte real numbers \"center_of_mass\" with dimensions 3 as the output parameter. The function calculates the center of mass based on the input masses and positions.", "input": "", "output": "    function center_of_mass(n, masses, positions)\n        implicit none\n        integer(8), intent(in) :: n\n        real(8), intent(in), dimension(n) :: masses\n        real(8), intent(in), dimension(n, 3) :: positions\n        real(8), dimension(3) :: center_of_mass\n        integer(8) :: i\n        center_of_mass = 0.\n        do i=1, n\n            center_of_mass(:) = center_of_mass(:) + masses(i) * positions(i, :)\n        end do\n    end function center_of_mass\n"}, {"instruction": "Write a Fortran function named average_vel to calculate the average velocity of a system. The function takes 3 input parameters: an integer (8) 'n', an array of real (8) numbers with dimension 'n' for masses, and a 2D array of real (8) numbers with dimension 'n' by 3 for velocities. The output is a 1D array of real (8) numbers with dimension 3, representing the average velocity in each direction.", "input": "", "output": "    function average_vel(n, masses, velocities)\n        implicit none\n        integer(8), intent(in) :: n\n        real(8), intent(in), dimension(n) :: masses\n        real(8), intent(in), dimension(n, 3) :: velocities\n        real(8), dimension(3) :: average_vel\n        integer(8) :: i\n        average_vel = 0.\n        do i=1, n\n            average_vel(:) = average_vel(:) + masses(i) * velocities(i, :)\n        end do\n    end function average_vel\n"}, {"instruction": "Create a Fortran function called linspace to generate an array of evenly spaced numbers over a specified range. The function takes 3 input parameters of types double precision, double precision, and integer, and returns 1 output parameter of type double precision with dimension nx. The function calculates the step size based on the input range and the number of points, then uses parallel processing to populate the output array with evenly spaced values.", "input": "", "output": "function linspace(x0, x1, nx) result(xs)\n\n    implicit none\n\n    double precision, intent(in) :: x0\n    double precision, intent(in) :: x1\n    integer, intent(in) :: nx\n\n    double precision, dimension(nx) :: xs\n\n    integer :: i\n    double precision :: step\n\n    step = (x1 - x0) / (nx - 1)\n\n    !$omp parallel do\n    do i = 1, nx\n        xs(i) = x0 + (i - 1) * step\n    enddo\n    !$omp end parallel do\n\nend function linspace\n"}, {"instruction": "Create a Fortran function called calc_angle to calculate the angle between two vectors a, b, and c. The function takes 3 input parameters of type double precision and dimension(3) for vectors a, b, and c, and returns 1 output parameter of type double precision for the angle.", "input": "", "output": "function calc_angle(a, b, c) result(angle)\n\n    implicit none\n\n    double precision, intent(in), dimension(3) :: a\n    double precision, intent(in), dimension(3) :: b\n    double precision, intent(in), dimension(3) :: c\n\n    double precision, dimension(3) :: v1\n    double precision, dimension(3) :: v2\n\n    double precision :: cos_angle\n    double precision :: angle\n\n    v1 = a - b\n    v2 = c - b\n\n    v1 = v1 / norm2(v1)\n    v2 = v2 / norm2(v2)\n\n    cos_angle = dot_product(v1,v2)\n\n    ! clipping\n    if (cos_angle > 1.0d0) cos_angle = 1.0d0\n    if (cos_angle < -1.0d0) cos_angle = -1.0d0\n\n    angle = acos(cos_angle)\n\nend function calc_angle\n"}, {"instruction": "Create a Fortran function named calc_cos_angle that calculates the cosine of the angle between two vectors defined by three-dimensional double precision arrays. The function takes 3 input parameters of type double precision, dimension(3) representing the vectors a, b, and c, and returns 1 output parameter of type double precision representing the cosine of the angle.", "input": "", "output": "function calc_cos_angle(a, b, c) result(cos_angle)\n\n    implicit none\n\n    double precision, intent(in), dimension(3) :: a\n    double precision, intent(in), dimension(3) :: b\n    double precision, intent(in), dimension(3) :: c\n\n    double precision, dimension(3) :: v1\n    double precision, dimension(3) :: v2\n\n    double precision :: cos_angle\n\n    v1 = a - b\n    v2 = c - b\n\n    v1 = v1 / norm2(v1)\n    v2 = v2 / norm2(v2)\n\n    cos_angle = dot_product(v1,v2)\n\nend function calc_cos_angle\n"}, {"instruction": "Create a Fortran function named count_lines that takes two input parameters: filename_data of type character(len=*) and maxlines of type integer. This function counts the number of valid lines in a file specified by filename_data, up to a maximum of maxlines. The function returns the count of valid lines as an integer.", "input": "", "output": "function count_lines(filename_data, maxlines)\n    implicit none\n    character(len=*) :: filename_data   \n    integer, intent(in) :: maxlines\n    integer:: count_lines \n    integer :: i , counter\n    integer, parameter :: fid_param=251    \n    character*255 :: param_name, param_val\n    integer :: io\n\n    counter=0\n    open(fid_param,file=trim(filename_data) ,action='read')\n    do i = 1, maxlines\n        read(fid_param, *, iostat=io)  param_name, param_val\n        \n        if (io .eq. 0 ) then\n            counter=counter+1\n        else\n            exit\n        end if\n    end do\n    close(fid_param)\n    write(*,*) \"detected \", counter, \" valid lines.\"\n    count_lines=counter\n    \nend function count_lines\n"}, {"instruction": "Write a Fortran pure function named is_prime to determine whether a given integer is a prime number. The number of input arguments is 1 and the test_data type is [integer(8)]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  pure function is_prime(targ)\n    ! default\n    implicit none\n\n    integer(8), intent(in) :: targ\n    logical                :: is_prime\n\n    ! local variables\n    integer(8) :: i,max_try\n\n    ! find the max we should try\n    max_try = int(sqrt(1d0*targ))\n\n    do i=2,max_try\n       if (mod(targ,i)==0) then\n          is_prime = .false.\n          return\n       endif\n    enddo\n\n    is_prime = .true.\n    return\n  end function is_prime\n"}, {"instruction": "Create a Fortran function named formatfiletime to format date and time values into a character string. The function takes 4 input parameters of type integer representing the year, month, day, and hour. It returns 1 output parameter of type character with a length of 11. The function formats the input date and time values and stores the result in the output parameter \"sdate\".", "input": "", "output": "    function formatfiletime(iyear, imonth, iday, ihour) result(sdate)\n    \n        ! routine arguments\n        integer, intent(in) :: iyear\n        integer, intent(in) :: imonth\n        integer, intent(in) :: iday\n        integer, intent(in) :: ihour\n        character(len=11)   :: sdate\n        \n        ! locals\n        integer :: itotalyear\n        \n        ! format date\n        if(iyear > 100) then\n            write(sdate,\"(i4.4,2i2.2,'.',i2.2)\") iyear, imonth, iday, ihour\n        else\n            if(iyear < 70) then\n                itotalyear = iyear + 2000\n            else\n                itotalyear = iyear + 1900\n            end if\n            write(sdate,\"(i4.4,2i2.2,'.',i2.2)\") itotalyear, imonth, iday, ihour\n        end if\n        \n    end function formatfiletime\n"}, {"instruction": "Create a Fortran function named lowercase to convert a given string to lowercase. The function takes 1 input argument of type character (len=*) and returns 1 output argument of type character (len=len_trim(str)).", "input": "", "output": "  function lowercase(str) result(lcstr)\n\n    ! convert string to lower case\n\n    character (len=*):: str\n    character (len=len_trim(str)):: lcstr\n    integer :: ilen, ioffset, iquote, iav, iqc, i\n\n    ilen=len_trim(str)\n    ioffset=iachar('a')-iachar('a')\n    iquote=0\n    lcstr=str\n    do i=1,ilen\n      iav=iachar(str(i:i))\n      if(iquote==0 .and. (iav==34 .or.iav==39)) then\n        iquote=1\n        iqc=iav\n        cycle\n      end if\n      if(iquote==1 .and. iav==iqc) then\n        iquote=0\n        cycle\n      end if\n      if (iquote==1) cycle\n      if(iav >= iachar('a') .and. iav <= iachar('z')) then\n        lcstr(i:i)=achar(iav-ioffset)\n      else\n        lcstr(i:i)=str(i:i)\n      end if\n    end do\n    return\n\n  end function lowercase\n"}, {"instruction": "Write a Fortran function named libtetrabz_polstat_1231 to calculate the value of w using six input parameters of type real(8). The input parameters are g1, g2, g3, lng1, lng2, and lng3. The output parameter, w, is also of type real(8).", "input": "", "output": "function libtetrabz_polstat_1231(g1,g2,g3,lng1,lng2,lng3) result(w)\n  !\n  real(8),intent(in) :: g1,g2,g3,lng1,lng2,lng3\n  real(8) :: w\n  !\n  real(8) :: w2, w3\n  !\n  w2 = ((lng2 - lng1)/(g2 - g1)*g2 - 1d0)*g2**2/(g2 - g1) - g1/( &\n  &   2d0)\n  w2 = w2/(g2 - g1)\n  w3 = ((lng3 - lng1)/(g3 - g1)*g3 - 1d0)*g3**2/(g3 - g1) - g1/( &\n  &   2d0)\n  w3 = w3/(g3 - g1)\n  w = (w3 - w2)/(g3 - g2)\n  !\nend function libtetrabz_polstat_1231\n"}, {"instruction": "Create a Fortran function named libtetrabz_polstat_1233 to calculate the interpolation weight for a given set of input parameters. The function takes 6 input arguments of type real(8) and returns 1 output argument of type real(8). Provide the input arguments g1, g2, g3, lng1, lng2, and lng3, and the function will compute the interpolation weight and return the result in the variable w.", "input": "", "output": "function libtetrabz_polstat_1233(g1,g2,g3,lng1,lng2,lng3) result(w)\n  !\n  real(8),intent(in) :: g1,g2,g3,lng1,lng2,lng3\n  real(8) :: w\n  !\n  real(8) :: w2, w3\n  !\n  w2 = (lng2 - lng1)/(g2 - g1)*g2 - 1d0\n  w2 = (g2*w2)/(g2 - g1)\n  w3 = (lng3 - lng1)/(g3 - g1)*g3 - 1d0\n  w3 = (g3*w3)/(g3 - g1)\n  w2 = (w3 - w2)/(g3 - g2)\n  w3 = (lng3 - lng1)/(g3 - g1)*g3 - 1d0\n  w3 = 1d0 - (2d0*w3*g1)/(g3 - g1)\n  w3 = w3/(g3 - g1)\n  w = (g3*w3 - g2*w2)/(g3 - g2)\n  !\nend function libtetrabz_polstat_1233\n"}, {"instruction": "Create a Fortran function named \"libtetrabz_polstat_1221\" to calculate a value \"w\" based on the input parameters \"g1\", \"g2\", \"lng1\", and \"lng2\". The input parameters are of type real(8). The output parameter \"w\" is also of type real(8).", "input": "", "output": "function libtetrabz_polstat_1221(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1, g2, lng1, lng2\n  real(8) :: w\n  !\n  w = 1d0 - (lng2 - lng1)/(g2 - g1)*g1\n  w = -1d0 + (2d0*g2*w)/(g2 - g1)\n  w = -1d0 + (3d0*g2*w)/(g2 - g1)\n  w = w/(2d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1221\n"}, {"instruction": "Create a Fortran function named libtetrabz_polstat_1222 that calculates a result based on four input real(8) numbers. The input parameters are g1, g2, lng1, and lng2. The function returns a single real(8) result denoted by w.", "input": "", "output": "function libtetrabz_polstat_1222(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1, g2, lng1, lng2\n  real(8) :: w\n  !\n  w = (lng2 - lng1)/(g2 - g1)*g2 - 1d0\n  w = (2d0*g1*w)/(g2 - g1) - 1d0\n  w = (3d0*g1*w)/(g2 - g1) + 1d0\n  w = w/(2d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1222\n"}, {"instruction": "Create a Fortran function named \"libtetrabz_polstat_1211\" that takes four real(8) input parameters: g1, g2, lng1, and lng2. It returns a single real(8) output parameter. The function calculates and returns the value of \"w\" based on the input parameters using a series of mathematical operations.", "input": "", "output": "function libtetrabz_polstat_1211(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1,g2,lng1,lng2\n  real(8) :: w\n  !\n  w = -1d0 + (lng2 - lng1)/(g2 - g1)*g2\n  w = -1d0 + (2d0*g2*w)/(g2 - g1)\n  w = -1d0 + (3d0*g2*w)/(2d0*(g2 - g1))\n  w = w/(3d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1211\n"}, {"instruction": "Provide a Fortran function named frequency to calculate the resonant frequency of an RLC circuit.\nThe function should have 3 input parameters of type real: r, l, and c.\nThe function should have 1 output parameter of type real: frequency.\nThe resonant frequency is computed using the formula: \nfrequency = 1.0 / (2 * pi * (l * c) ** 0.5), where pi is a predefined constant.\nEnsure that the function returns the calculated frequency.", "input": "", "output": "function frequency(r, l, c)\n    implicit none\n    real, parameter :: pi = 3.1415926535\n    real :: r\n    real :: l\n    real :: c\n    real :: frequency\n    frequency = 1.0 / (2 * pi * (l * c) ** 0.5)\n    return\nend function\n"}, {"instruction": "Write a Fortran function named \"compute_half_step_velocity\" to calculate the velocity at half the time step from the initial velocity and force. The function should take 4 input parameters of type real(8) and dimension(3) representing initial velocity v0, force f0, mass m, and time step dt. The output parameter should be a real(8) array of dimension(3) representing the velocity at half time step, and the test_data type for input and output parameters are ['real(8), dimension(3)', 'real(8), dimension(3)', 'real(8)', 'real(8)'] and ['real(8), dimension(3)'] respectively.", "input": "", "output": "  function compute_half_step_velocity(v0,f0,m,dt) result(v_half)\n    ! velocity at half time step from initial\n    ! velocity and force\n    implicit none\n    real(8), dimension(3), intent(in) :: v0, f0\n    real(8), intent(in) :: m, dt\n    real(8), dimension(3) :: v_half\n    v_half = v0 + 0.5*f0/m*dt\n  end function compute_half_step_velocity\n"}, {"instruction": "Write a Fortran function named compute_new_position to calculate the new position based on the initial position, half-step velocity, and time step. The input parameters consist of 3 arguments of types real(8), dimension(3), real(8), dimension(3), and real(8) respectively. The output is a single argument of type real(8), dimension(3).", "input": "", "output": "  function compute_new_position(r0,v_half,dt) result(r1)\n    ! new position from initial position\n    ! and half step velocity\n    implicit none\n    real(8), dimension(3), intent(in) :: r0, v_half\n    real(8), intent(in) :: dt\n    real(8), dimension(3) :: r1\n    r1 = r0 + v_half*dt\n  end function compute_new_position\n"}, {"instruction": "Create a Fortran function named adsubcl that takes two integer input parameters and returns an integer output parameter. The number of input parameters is 2, with the test_data type as ['integer', 'integer'], and the number of output parameters is 1 with the test_data type as ['integer']. The function retrieves a specific value from a common block based on the input parameters and returns it.", "input": "", "output": "function   adsubcl( itape, isub )\n!******************************************************************\n!******************************************************************\n!** this routine was generated by automatic differentiation.     **\n!** fastopt: transformation of algorithm in fortran, taf 1.9.22  **\n!******************************************************************\n!******************************************************************\n!==============================================\n! all entries are defined explicitly\n!==============================================\nimplicit none\n\n!==============================================\n! declare common blocks\n!==============================================\ninteger :: adcomm1(1,4)\ncommon /adcomm/ adcomm1\n\n!==============================================\n! declare arguments\n!==============================================\ninteger :: adsubcl\ninteger :: isub\ninteger :: itape\n\nadsubcl = adcomm1(itape,isub)\nend function   adsubcl\n"}, {"instruction": "Create a Fortran function named checkvar to analyze the input data and compute the maximum, minimum, and mean values of a 2D array while providing a descriptive message. The function takes 3 input parameters of types integer(kind = 4), dimension(:,:), real(kind = 4), dimension(:,:), and character(len = *), optional. It returns 1 output parameter of type character(len = 200).", "input": "", "output": "    function checkvar(a2dvarvalue, a2ivarmask, svarname)   result(svarcheck)\n        \n        !------------------------------------------------------------------------------------\n        ! variable(s) declaration\n        integer(kind = 4), dimension(:,:)   :: a2ivarmask\n        real(kind = 4), dimension(:,:)      :: a2dvarvalue\n        \n        character(len = *), optional       :: svarname\n        \n        real(kind = 4)                      :: dvarmaxvalue, dvarminvalue, dvarmeanvalue\n        \n        character(len = 20)                 :: svarmaxvalue, svarminvalue, svarmeanvalue\n        character(len = 200)                :: svarcheck\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! initialize variable(s)\n        dvarmaxvalue = -9999.0; dvarminvalue = -9999.0; dvarmeanvalue = -9999.0\n        svarcheck = \"\"\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! define name if not defined\n        if (.not. present(svarname)) then\n            svarname = 'var'\n        endif\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! compute maximum value\n        dvarmaxvalue = maxval(a2dvarvalue, mask=a2ivarmask.gt.0.0)\n        write(svarmaxvalue, *) dvarmaxvalue\n        ! compute minimum value\n        dvarminvalue = minval(a2dvarvalue, mask=a2ivarmask.gt.0.0)\n        write(svarminvalue, *) dvarminvalue\n        ! compute average value\n        dvarmeanvalue = sum(a2dvarvalue, mask=a2ivarmask.gt.0.0)/max(1,count(a2ivarmask.gt.0.0))\n        write(svarmeanvalue, *) dvarmeanvalue\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! print check message\n        svarcheck = trim(svarname)//\" :: max: \"//trim(svarmaxvalue)//\" - min: \"//trim(svarminvalue)// &\n                    \" - mean: \"//trim(svarmeanvalue)\n        !------------------------------------------------------------------------------------\n        \n    end function checkvar\n"}, {"instruction": "Write a Fortran function named checkarray to analyze an array of real numbers and generate a summary report. The function takes 2 input parameters: a 1D array of 4-byte real numbers and an optional character string. It returns a character string of length 200 containing the analysis summary.\n\nEnsure that the function is capable of computing the maximum, minimum, and average values of the input array, and create a message encapsulating these statistics along with the variable's name, if provided.\n", "input": "", "output": "    function checkarray(a1dvarvalue, svarname)   result(svarcheck)\n        \n        !------------------------------------------------------------------------------------\n        ! variable(s) declaration\n        real(kind = 4), dimension(:)      :: a1dvarvalue\n        \n        character(len = *), optional       :: svarname\n        \n        real(kind = 4)                      :: dvarmaxvalue, dvarminvalue, dvarmeanvalue\n        \n        character(len = 20)                 :: svarmaxvalue, svarminvalue, svarmeanvalue\n        character(len = 200)                :: svarcheck\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! initialize variable(s)\n        dvarmaxvalue = -9999.0; dvarminvalue = -9999.0; dvarmeanvalue = -9999.0\n        svarcheck = \"\"\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! define name if not defined\n        if (.not. present(svarname)) then\n            svarname = 'var'\n        endif\n        !------------------------------------------------------------------------------------\n\n        !------------------------------------------------------------------------------------\n        ! compute maximum value\n        dvarmaxvalue = maxval(a1dvarvalue, mask=a1dvarvalue.ge.0.0)\n        write(svarmaxvalue, *) dvarmaxvalue\n        ! compute minimum value\n        dvarminvalue = minval(a1dvarvalue, mask=a1dvarvalue.ge.0.0)\n        write(svarminvalue, *) dvarminvalue\n        ! compute average value\n        dvarmeanvalue = sum(a1dvarvalue, mask=a1dvarvalue.ge.0.0)/max(1,count(a1dvarvalue.gt.0.0))\n        write(svarmeanvalue, *) dvarmeanvalue\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! print check message\n        svarcheck = trim(svarname)//\" :: max: \"//trim(svarmaxvalue)//\" - min: \"//trim(svarminvalue)// &\n                    \" - mean: \"//trim(svarmeanvalue)\n        !------------------------------------------------------------------------------------\n        \n    end function checkarray\n"}, {"instruction": "Create a Fortran function called distance that calculates the distance between two points represented by three-dimensional real arrays. The function takes 2 input parameters of type real, dimension(3) and returns 1 output parameter of type real.", "input": "", "output": "function distance(c1,c2)\n  real :: distance\n  real, dimension(3) :: c1, c2\n  \n  distance = sqrt(sum((c1-c2)**2))\n  return\nend function distance\n"}, {"instruction": "Write a Fortran function named create_randgen_c that returns a pointer to a random number generator. The function takes 1 input parameter of type integer(c_int),value, and returns 1 output parameter of type type(c_ptr).", "input": "", "output": "   function create_randgen_c(default_seed) bind(c,name=\"create_randgen\")\n   use iso_c_binding\n   implicit none\n   type(c_ptr) :: create_randgen_c\n   integer(c_int),value :: default_seed\n   end function create_randgen_c\n"}, {"instruction": "Write a Fortran function named split that takes a string and a delimiter as input. The input parameters are of type character(*) and character(1) respectively. This function returns a portion of the input string based on the delimiter. The output parameter is of type character(:), allocatable.", "input": "", "output": "pure function split(instr,  delimiter)\n\ncharacter(*), intent(in) :: instr\ncharacter(1), intent(in) :: delimiter\ncharacter(:), allocatable :: split\n\ninteger :: idx\n\nidx = scan(instr, delimiter)\nsplit = instr(1:idx-1)\n\nend function split\n"}, {"instruction": "Create a Fortran function named countinputarray to count the number of elements in an input array that have been set through a namelist call. The function takes 2 input parameters of type real and real, dimension(:), and returns 1 output parameter of type integer. The input array is initialized with a very negative value, and the function searches for the first entry in the array that still has this value to determine the count.", "input": "", "output": "pure function countinputarray(preset, a) result(n)\r\n! ------------------------------------------------------------------------------\r\n! purpose - count the number of elements of an array that have been input\r\n!   thru a namelist call. this is to save the user from the error-prone\r\n!   process of counting the number of entries in a list. the array is\r\n!   preset to a very negative value that no one would ever use for real data.\r\n!   this routine simply searches for the first entry in the array that still\r\n!   still has this value.\r\n  real,intent(in):: preset   ! the value that was originally placed in each\r\n  real,intent(in),dimension(:):: a   ! array to be counted\r\n  integer:: n\r\n\r\n  integer:: k\r\n!-------------------------------------------------------------------------------\r\n  do k=1,size(a)\r\n    if (a(k) <= preset) exit\r\n  end do\r\n  n=k-1   ! failed on k; k-1 was the last good one\r\n\r\n  return\r\nend function countinputarray   ! -----------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named greatest_common_factor to calculate the greatest common factor of two integer numbers. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "    recursive function greatest_common_factor(a, b) result(c)\n      implicit none\n      integer :: c\n      integer, intent(in) :: a, b\n      if (a.eq.b) then\n         c = a\n      else if (a.gt.b) then\n         c = greatest_common_factor(a-b,b)\n      else\n         c = greatest_common_factor(a,b-a)\n      end if\n    end function greatest_common_factor\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The number of input arguments is 1 and the test_data type is ['integer'].The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function factorial(k)\n! computes k!\n    implicit none\n\n    real :: factorial                               ! real to get more precision\n    integer, intent(in) :: k                        ! input\n    integer :: j                                    ! counter\n    factorial = 1.0\n    do j = 2,k\n        factorial = factorial * j\n    end do\n    return\nend function factorial\n"}, {"instruction": "Create a Fortran function named pr_findconnectionnumberindex that finds the index of a specified cell number in a connection list. This function takes 4 input parameters: cellnumber (integer), connectionlist (integer array), arraysize (integer), and connectioncount (integer). The output parameter is index (integer), which represents the index of the cell number in the connection list.", "input": "", "output": "  function pr_findconnectionnumberindex(cellnumber,connectionlist,arraysize,connectioncount) result(index)\n  implicit none\n  integer,intent(in) :: cellnumber,connectioncount,arraysize\n  integer,intent(in),dimension(connectioncount) :: connectionlist\n  integer :: index,n\n  \n  index = 0\n  do n = 1,arraysize\n    if(connectionlist(n) .eq. cellnumber) then\n      index = n\n      exit\n    end if\n  end do\n  \n  end function pr_findconnectionnumberindex\n"}, {"instruction": "Create a Fortran function named f1 that takes an integer input argument and returns a character string. The function initializes the string \"ab\" and returns it. The number of input arguments is 1 with test_data type ['integer'], and the number of output arguments is 1 with test_data type ['character(n)'].", "input": "", "output": "function f1(n)\n  integer :: n\n  character(n) :: f1, e1\n  f1 = \"ab\"\n  return\nentry e1(n)\n  e1 = \"xyz\"\nend function\n"}, {"instruction": "Write a Fortran function called f2 that takes an integer input argument and returns a character pointer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(n), pointer'].", "input": "", "output": "function f2(n)\n  integer :: n\n  character(n), pointer :: f2, e2\n  allocate(f2)\n  f2 = \"ab\"\n  return\nentry e2(n)\n  allocate(e2)\n  e2 = \"xyz\"\nend function\n"}, {"instruction": "Write a Fortran function named \"read_datatype\" to read a datatype name from a file. The function takes 2 input arguments of type integer and character, and 1 output argument of type integer. The number of input arguments is 2 and the test_data type is ['integer', 'character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function read_datatype( fid, datatype_name ) result( err_stat )\n    ! arguments\n    integer     , intent(in)  :: fid\n    character(*), intent(out) :: datatype_name\n\n    integer :: err_stat\n    ! local variables\n    character(1), allocatable :: dummy(:)\n    integer :: i, strlen\n    integer :: io_stat\n    integer :: alloc_stat\n\n    ! set up\n    err_stat = failure\n    datatype_name = ''\n\n    ! get the string length\n    read( fid, iostat=io_stat ) strlen\n    if ( io_stat /= 0 ) return\n    \n    ! allocate dummy string array\n    allocate( dummy(strlen), stat=alloc_stat )\n    if ( alloc_stat /= 0 ) return\n\n    ! read the string into the dummy array\n    read( fid, iostat=io_stat ) dummy\n    if ( io_stat /= 0 ) return\n\n    ! transfer array into string\n    do i = 1, min(strlen,len(datatype_name))\n      datatype_name(i:i) = dummy(i)\n    end do\n\n    ! done\n    err_stat = success\n  end function read_datatype\n"}, {"instruction": "Create a Fortran function named tolowercase that takes a single input argument of type character with variable length. The function returns a new string in all lowercase letters. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['character(len=len(string))'].", "input": "", "output": "    function tolowercase(string)\n\n        character(len=*), intent(in) :: string\n        character(len=len(string)) :: tolowercase\n\n        character(len=26) lower, upper\n        integer i, n\n\n        lower = 'abcdefghijklmnopqrstuvwxyz'\n        upper = 'abcdefghijklmnopqrstuvwxyz'\n\n        tolowercase = string\n        do i = 1, len(string)\n            n = index(upper, string(i:i))\n            if (n /= 0) tolowercase(i:i) = lower(n:n)\n        end do\n\n    end function\n"}, {"instruction": "Create a Fortran function named length_edges_box to calculate the lengths of the edges of a box in 3D space. The function takes 2 input parameters with the data types ['integer', 'double precision,dimension(nframes,3,3)'], and returns 1 output parameter with the data type ['double precision,dimension(nframes,3)'].", "input": "", "output": "  function length_edges_box(box, nframes) result(lengths)\n\n    implicit none\n    integer,intent(in)::nframes\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes,3)::lengths\n    integer::ii\n\n    lengths = 0.0d0\n\n    do ii=1,nframes\n\n        lengths(ii,1) = sqrt(box(ii,1,1)**2 + box(ii,1,2)**2 + box(ii,1,3)**2)\n        lengths(ii,2) = sqrt(box(ii,2,1)**2 + box(ii,2,2)**2 + box(ii,2,3)**2)\n        lengths(ii,3) = sqrt(box(ii,3,1)**2 + box(ii,3,2)**2 + box(ii,3,3)**2)\n\n    end do\n\n  end function length_edges_box\n"}, {"instruction": "Create a Fortran function named real_compare to compare two real numbers. The function takes 4 input parameters of type real(kind(1d0)) - r1, r2, eps, and zthr. It returns 1 output parameter of type integer.", "input": "", "output": "  function real_compare(r1,r2,eps,zthr) result(res)\n    implicit none\n    real(kind(1d0)),intent(in)::r1,r2,eps,zthr\n    real(kind(1d0))::maxr,diff\n    integer::res\n    maxr=max(abs(r1),abs(r2))\n    if(maxr.lt.zthr)then\n       res=0\n       return\n    endif\n    diff=r1-r2\n    if(abs(diff)/maxr.lt.eps)then\n       res=0\n       return\n    endif\n    if(diff.gt.0d0)then\n       res=1\n       return\n    else\n       res=-1\n       return\n    endif\n  end function real_compare\n"}, {"instruction": "Write a Fortran function named getloc that takes an array of integers and an integer element as input and returns the location of the element in the array as output. The number of input arguments is 2 and the test_data type is ['integer, dimension(:)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function getloc(arr, elm) result (loc)\n\n  !purpose: to  get location of an element in an array\n\n  integer, dimension(:), intent(in)  :: arr    ! input array\n  integer, intent(in)  :: elm                  ! element whose location is wanted to find\n  integer :: loc\n\n  integer :: i\n\n  do i = 1, size(arr)\n    if (arr(i) == elm) then\n      loc = i\n      exit\n    end if\n  end do\n\nend function getloc\n"}, {"instruction": "Create a Fortran function named wrap_timer_name that takes a single input argument of type character(len=10) and returns a single output argument of type character(len=12). The function should wrap the input argument with double quotes and assign the result to the output argument using the adjustr function.", "input": "", "output": "  function wrap_timer_name(tname) result(q_string)\n    character(len=10)::  tname\n    character(len=12)::  q_string\n\n    integer i\n\n    q_string=adjustr('\"'//trim(tname)//'\"')\n\n  end function wrap_timer_name\n"}, {"instruction": "Write a Fortran function named sending_half that takes an integer input argument and returns a logical value. The function's purpose is to check if the input integer is less than or equal to a predefined value np_half. This function should be used to process only even values of np.", "input": "", "output": "function sending_half( i) result( l)\n\ninteger, intent( in) :: i\nlogical :: l\n\ncontinue\n\n!  this must process np == even values only\n\n   l = i <= np_half\n\nreturn\n\nend function sending_half\n"}, {"instruction": "Create a Fortran function named \"par_adiab_tau\" that takes 5 input parameters of type integer, double precision, and computes a double precision output. The function computes a value based on the polynomial order specified in the input and returns the corresponding value of \"par_adiab_tau\".", "input": "", "output": "    function par_adiab_tau(poly_order,a44,b4,tau,vpar_in)\n!\n        implicit none\n!\n        integer                  :: poly_order\n        double precision         :: tau,vpar_in,par_adiab_tau,a44,b4\n!\n        select case(poly_order)\n            case(2)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2 + 3.d0*a44*b4*vpar_in + 2.d0*a44**2* vpar_in**2)\n!                            \n            case(3)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2 + 3.d0*a44*b4*vpar_in + 2.d0*a44**2*vpar_in**2) &\n                            & + 1.d0/4.d0*tau**4*(a44*b4**2 + 7.d0/3.d0*a44**2*b4*vpar_in+(4.d0*a44**3*vpar_in**2)/3.d0)\n!                \n            case(4)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2+3.d0*a44*b4*vpar_in+2.d0*a44*2.d0*vpar_in**2) &\n                            & + 1.d0/4.d0*tau**4*(a44*b4**2 + 7.d0/3.d0*a44**2*b4*vpar_in+(4.d0*a44**3*vpar_in**2)/3.d0) &\n                            & + 1.d0/60.d0*tau**5*(7.d0*a44**2*b4**2+15.d0*a44**3*b4*vpar_in + 8.d0*a44**4*vpar_in**2)\n! \n        end select\n!        \n    end function par_adiab_tau\n"}, {"instruction": "Write a Fortran function named hsurh0 that calculates the value of hsurh0 using the specified input parameters. The function should have 4 input parameters of type real(kind=8), represented as [real(kind=8), real(kind=8), real(kind=8), real(kind=8)], and 1 output parameter of type real(kind=8).", "input": "", "output": "function hsurh0(z,omega0,omegal,omegar)\n  !===========================================================================\n  implicit none\n  real(kind=8) :: z,omega0,omegal,omegar,hsurh0\n  hsurh0=sqrt(omega0*(1.d0+z)**3+omegar*(1.d0+z)**2+omegal)\nend function hsurh0\n"}, {"instruction": "Write a Fortran function named myint that takes a real number of kind=8 as input and returns an integer as output. The number of input arguments is 1 and the test_data type is ['real(kind=8)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function myint(x)\n  !=======================================================================\n\n  !=======================================================================\n  real(kind=8) :: x\n  integer :: myint\n  \n  if (x >= 0.0d0) then\n     myint=int(x)\n  else\n     myint=int(x)-1\n  endif\nend function myint\n"}, {"instruction": "Create a Fortran function named nextpow2, which calculates the next power of 2 greater than or equal to the input integer. The number of input arguments is 1 with the test_data type ['integer']. The number of output arguments is 1 with the test_data type ['integer'].", "input": "", "output": "function nextpow2(n) bind(c)\n! \u4e0d\u5c0f\u4e8en\u76842\u7684\u6574\u6570\u6b21\u5e42\n    integer, intent(in) :: n\n    integer :: nextpow2\n\n    nextpow2 = 1\n\n    do while ( nextpow2<n )\n        nextpow2 = nextpow2*2\n    end do\n    return\n\nend function nextpow2\n"}, {"instruction": "Write a Fortran function named nextpow that calculates the next power of a given base greater than or equal to a given number. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['integer'].", "input": "", "output": "function nextpow(n,base) bind(c)\n! \u4e0d\u5c0f\u4e8en\u7684base\u7684\u6574\u6570\u6b21\u5e42\n    integer, intent(in) :: n, base\n    integer :: nextpow\n\n    nextpow = 1\n\n    do while ( nextpow<n )\n        nextpow = nextpow*base\n    end do\n    return\n\nend function nextpow\n"}, {"instruction": "Write a Fortran function named dpower to compute the value of x raised to the power of n, and then calculate the m-th derivative. The number of input arguments is 3, and the test_data type is [real(8), integer, integer]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "function dpower(x,n,m) bind(c)\n! \u5bf9x^n\u6c42m\u9636\u5bfc\u6570\u540e\u7684\u503c\n    real(8), intent(in) :: x\n    integer, intent(in) :: n, m\n    real(8) :: dpower\n\n    integer :: k, l\n\n    if ( m>n ) then\n        dpower = 0.d0\n        return\n    end if\n\n    k = n\n    l = m\n    dpower = x**(n-m)\n\n    do while ( l>0 )\n        dpower = dpower*k\n        l = l - 1\n        k = k - 1\n    end do\nend function dpower\n"}, {"instruction": "Write a Fortran function named integer_to_string that converts an integer to a string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=max_number_width)'].", "input": "", "output": "    elemental function integer_to_string(i) result(s)\n      integer,intent(in) :: i\n      integer, parameter :: max_number_width = 64\n      character(len=max_number_width) :: s\n      integer :: istat\n\n      write(s,fmt='(ss,i0)',iostat=istat) i\n      if (istat==0) then\n          s = trim(adjustl(s))\n      else\n          s = '***'\n      end if\n    end function integer_to_string\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer (kind = 4). Ensure that the name of the function is \"factorial\".", "input": "", "output": "recursive function factorial(n) result(f)\n    implicit none\n    integer :: n\n    integer  (kind = 4) :: f\n    if (n<0) then\n      f=0\n    else\n      select case (n) \n          case (0)\n              f =  1\n          case (1)\n              f =  1\n          case (2)\n              f =  2\n          case ( 3)\n              f =  6\n          case ( 4)\n              f =  24\n          case ( 5)\n              f =  120\n          case ( 6)\n              f =  720\n          case ( 7)\n              f =  5040\n          case ( 8)\n              f =  40320\n          case ( 9)\n              f =  362880\n          case ( 10)\n              f =  3628800\n          case ( 11)\n              f =  39916800\n          case ( 12)\n              f =  479001600\n          case default\n              f =  n*factorial(n-1)\n      end select\n    endif\nend function factorial\n"}, {"instruction": "Create a Fortran function named doublefactorial to calculate the double factorial of a given integer. The function has 1 input parameter of type integer and 1 output parameter of type integer (kind = 4). The function should be able to handle non-negative integers and return the double factorial value.", "input": "", "output": "recursive function doublefactorial(n)  result(f)\n    integer, intent(in):: n\n    integer  (kind = 4) :: f\n    if (n<0) then\n      f=0\n      return\n    else\n      select case (n)\n        case (0)\n            f =  1\n        case (1)\n            f =  1\n        case (2)\n            f =  2\n        case (3)\n            f =  3\n        case (4)\n            f =  8\n        case (5)\n            f =  15\n        case (6)\n            f =  48\n        case (7)\n            f =  105\n        case (8)\n            f =  384\n        case (9)\n            f =  945\n        case (10)\n            f =  3840\n        case (11)\n            f =  10395\n        case (12)\n            f =  46080\n        case (13)\n            f =  135135\n        case (14)\n            f =  645120\n        case (15)\n            f =  2027025\n        case (16)\n            f =  10321920\n        case (17)\n            f =  34459425\n        case (18)\n            f =  185794560\n        case default\n            f =  n*doublefactorial(n-2)\n      end select\n    endif\nend function doublefactorial\n"}, {"instruction": "Write a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the input number is prime. The name of the function is isprime.", "input": "", "output": "function isprime(number)\n        implicit none\n        integer, intent(in) :: number\n        logical :: isprime\n        integer :: i\n\n        isprime = .true.\n        do i = 2, number / 2\n            if (mod(number, i) .eq. 0) then\n                isprime = .false.\n                exit\n            end if\n        end do\n        ! isprime = .false.\n        \n    end function isprime\n"}, {"instruction": "Create a Fortran function named histogram_median that takes an input array of integers with a dimension of 0 to 255. The function calculates the median value of the histogram and returns it as an integer. The number of input parameters is 1 with the test_data type being ['integer, dimension(0:255)'], and the number of output parameters is 1 with the test_data type being ['integer'].", "input": "", "output": "  function histogram_median(histogram)\n    integer, dimension(0:255), intent(in) :: histogram\n    integer :: histogram_median\n\n    integer :: from, to, left, right\n\n    from = 0\n    to = 255\n    left = histogram(from)\n    right = histogram(to)\n    do while ( from /= to )\n       if ( left < right ) then\n          from = from + 1\n          left = left + histogram(from)\n       else\n          to = to - 1\n          right = right + histogram(to)\n       end if\n    end do\n    histogram_median = from\n  end function histogram_median\n"}, {"instruction": "Create a Fortran function named minusonetothe to calculate -1 raised to the power of the input integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "\tfunction minusonetothe(j) result (sgn)\n\t\tinteger :: i,j\n\t\treal*8 :: sgn\n\t\t\n\t\ti=j\n\t\tif (j<=0) i=-j\n\t\tif (mod(i,2)==0) then\n\t\t\tsgn=1\n\t\telse\n\t\t\tsgn=-1\n\t\tendif\n\tend function minusonetothe\n"}, {"instruction": "Create a Fortran function named math_fact to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "\tpure function math_fact( n ) result( output )\n\t\tinteger, intent(in) :: n\n\t\tinteger :: output\n\t\t\n\t\tinteger :: i\n\t\t\n\t\toutput = 1\n\t\tdo i=n,1,-1\n\t\t\toutput = output*i\n\t\tend do\n\tend function math_fact\n"}, {"instruction": "Create a Fortran function named to_string that takes one input parameter of type class(*) and returns a string. The input parameter can be of any type.", "input": "", "output": "    function to_string(data_in) result(string_out)\n        class(*),    intent(in)  :: data_in\n\n        character(100)              :: write_internal\n        character(:),   allocatable :: string_out\n\n        string_out = ''\n\n        select type(data_in)\n\n            type is(character(len=*))\n                string_out = data_in\n\n            type is(integer)\n\n                if ( data_in == 0 ) then\n                    write_internal = '0'\n\n                ! positive integers\n                else if ( data_in < 1e1 .and. data_in > 0) then\n                    write(write_internal, '(i1.0)') data_in\n                else if ( data_in < 1e2 .and. data_in > 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( data_in < 1e3 .and. data_in > 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( data_in < 1e4 .and. data_in > 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( data_in < 1e5 .and. data_in > 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( data_in < 1e6 .and. data_in > 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( data_in < 1e7 .and. data_in > 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( data_in < 1e8 .and. data_in > 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( data_in < 1e9 .and. data_in > 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( data_in < 1e10 .and. data_in > 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( data_in < 1e11 .and. data_in > 0) then\n                    write(write_internal, '(i11.0)') data_in\n\n                ! negative integers: extra char width for neg sign\n                else if ( abs(data_in) < 1e1 .and. data_in < 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( abs(data_in) < 1e2 .and. data_in < 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( abs(data_in) < 1e3 .and. data_in < 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( abs(data_in) < 1e4 .and. data_in < 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( abs(data_in) < 1e5 .and. data_in < 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( abs(data_in) < 1e6 .and. data_in < 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( abs(data_in) < 1e7 .and. data_in < 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( abs(data_in) < 1e8 .and. data_in < 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( abs(data_in) < 1e9 .and. data_in < 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( abs(data_in) < 1e10 .and. data_in < 0) then\n                    write(write_internal, '(i11.0)') data_in\n                else if ( abs(data_in) < 1e11 .and. data_in < 0) then\n                    write(write_internal, '(i12.0)') data_in\n                else\n                    write(write_internal, '(i10.0)') data_in\n                end if\n                string_out = write_internal\n\n            type is(integer(8))\n\n                if ( data_in == 0 ) then\n                    write_internal = '0'\n\n                ! positive integers\n                else if ( data_in < 1e1 .and. data_in > 0) then\n                    write(write_internal, '(i1.0)') data_in\n                else if ( data_in < 1e2 .and. data_in > 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( data_in < 1e3 .and. data_in > 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( data_in < 1e4 .and. data_in > 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( data_in < 1e5 .and. data_in > 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( data_in < 1e6 .and. data_in > 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( data_in < 1e7 .and. data_in > 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( data_in < 1e8 .and. data_in > 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( data_in < 1e9 .and. data_in > 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( data_in < 1e10 .and. data_in > 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( data_in < 1e11 .and. data_in > 0) then\n                    write(write_internal, '(i11.0)') data_in\n\n                ! negative integers: extra char width for neg sign\n                else if ( abs(data_in) < 1e1 .and. data_in < 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( abs(data_in) < 1e2 .and. data_in < 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( abs(data_in) < 1e3 .and. data_in < 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( abs(data_in) < 1e4 .and. data_in < 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( abs(data_in) < 1e5 .and. data_in < 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( abs(data_in) < 1e6 .and. data_in < 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( abs(data_in) < 1e7 .and. data_in < 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( abs(data_in) < 1e8 .and. data_in < 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( abs(data_in) < 1e9 .and. data_in < 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( abs(data_in) < 1e10 .and. data_in < 0) then\n                    write(write_internal, '(i11.0)') data_in\n                else if ( abs(data_in) < 1e11 .and. data_in < 0) then\n                    write(write_internal, '(i12.0)') data_in\n                else\n                    write(write_internal, '(i10.0)') data_in\n                end if\n                string_out = write_internal\n\n            type is(real)\n                if (abs(data_in) > 0.1) then\n                    write(write_internal, '(f24.14)') data_in\n                else\n                    write(write_internal, '(e24.14)') data_in\n                end if\n                string_out = write_internal\n\n            type is(real(8))\n                if (abs(data_in) < 0.1) then\n                    write(write_internal, '(e24.14)') data_in\n                else if ( (abs(data_in) > 0.1) .and. (abs(data_in) < 1.e9) ) then\n                    write(write_internal, '(f24.14)') data_in\n                else\n                    write(write_internal, '(e24.14)') data_in\n                end if\n                string_out = write_internal\n\n            type is(logical(1))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            type is (logical(2))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            type is (logical(4))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            class default\n                print*, 'error: no io rule for provided data in add_to_line'\n                stop\n        end select\n\n\n    end function to_string\n"}, {"instruction": "Create a Fortran function called check_file_extension to determine if a file has a specific extension. The function takes 2 input parameters of type character(*) representing the file name and the target extension. It returns 1 output parameter of type logical. The function checks if the given extension is present in the file name and sets the logical variable extension_found accordingly.", "input": "", "output": "    function check_file_extension(file,extension) result(extension_found)\n        character(*),       intent(in)  :: file\n        character(*),       intent(in)  :: extension\n\n        integer     :: iext, extloc\n        logical     :: extension_found\n\n        ! check for extension in grid file\n        extloc = index(file, trim(extension))\n\n        ! if extloc is nonzero, then the extension was found in the filename\n        if ( extloc /= 0 ) then\n            extension_found = .true.\n        else\n            extension_found = .false.\n        end if\n\n    end function check_file_extension\n"}, {"instruction": "Write a Fortran function named string_to_lower that converts a given input string to lowercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len=len(string)).", "input": "", "output": "    function string_to_lower(string) result(string_lower)\n        character(*),   intent(in)  :: string\n\n        character(len=len(string))  :: string_lower\n        integer                         :: i, k\n\n        do i = 1,len(trim(string))\n            \n            k = iachar(string(i:i))\n\n\n            if ( k >= iachar('a') .and. k <= iachar('z') ) then\n                k = k + (iachar('a') - iachar('a'))\n                string_lower(i:i) = achar(k)\n            else\n                string_lower(i:i) = string(i:i)\n            end if\n\n        end do ! i\n    end function string_to_lower\n"}, {"instruction": "Create a Fortran function named string_to_upper that takes a single input parameter of type character(*) and returns a single output parameter of type character(len=len(string)). The function converts all lowercase letters in the input string to uppercase and leaves the other characters unchanged.", "input": "", "output": "    function string_to_upper(string) result(string_upper)\n        character(*),   intent(in)  :: string\n\n        character(len=len(string))  :: string_upper\n        integer                         :: i, k\n\n        do i = 1,len(trim(string))\n            \n            k = iachar(string(i:i))\n\n\n            if ( k >= iachar('a') .and. k <= iachar('z') ) then\n                k = k - (iachar('a') - iachar('a'))\n                string_upper(i:i) = achar(k)\n            else\n                string_upper(i:i) = string(i:i)\n            end if\n\n        end do ! i\n    end function string_to_upper\n"}, {"instruction": "Write a Fortran function named is_possible to determine if it is possible to achieve a certain condition based on the input arrays and length. The function takes 5 input parameters of types integer, real(8), real(8) arrays of dimension length, and returns 1 output parameter of type logical.", "input": "", "output": "recursive function is_possible(a, b, c, length, init) result(possible)\ninteger, intent(in) :: length\nreal(8), intent(in) :: init\nreal(8),dimension(length), intent(in) :: a\nreal(8),dimension(length), intent(in) :: b\nreal(8),dimension(length), intent(in) :: c\nreal(8),dimension(length - 1) :: passed_a\nreal(8),dimension(length - 1) :: passed_b\nreal(8),dimension(length - 1) :: passed_c\nreal(8) :: holder\nlogical :: possible\ninteger :: x, y\n\nif (length .eq. 0) then\n  possible = .true.\n  return\nend if\npossible = .false.\n\ndo x = 1, length\n  if (abs(c(x) - init) .lt. ((10 - length) * precision)) then\n    do y = 1, x - 1\n      passed_a(y) = a(y)\n      passed_b(y) = b(y)\n    end do\n    do y = x + 1, length\n      passed_a(y - 1) = a(y)\n      passed_b(y - 1) = b(y)\n    end do\n    holder = max(a(x), b(x), init)\n    if (is_possible(passed_a, passed_b, passed_c, length - 1, holder)) then\n      possible = .true.\n      return\n    end if\n  end if\nend do\nend function is_possible\n"}, {"instruction": "Create a Fortran function named poly that takes two input parameters: coeffs of type real(8) array and x of type real(8) array. The function produces one output parameter, poly, which is a real(8) array with the size of x. The function calculates a polynomial using the coefficients provided in coeffs and the values in array x.", "input": "", "output": "        function poly(x,coeffs)\n          real(8), dimension(:), intent(in) :: coeffs,x\n          real(8), dimension(size(x)) :: poly\n          integer :: i,m\n          m=size(coeffs)\n!          n=size(x)\n          if (m <= 0) then\n             poly=0.0d0\n          else !if (m < n .or. m < npar_poly) then\n             poly=coeffs(m)\n             do i=m-1,1,-1\n                poly=x*poly+coeffs(i)\n             end do\n          endif!else\n!             do i=1,n\n!                poly(i)=poly_rr(x(i),coeffs)\n!             end do\n!          end if\n        end function poly\n"}, {"instruction": "Write a Fortran function named dadtau that takes 4 real(kind=8) input parameters and returns a single real(kind=8) output parameter. The function computes the value of dadtau using the provided input parameters according to the given mathematical expression, and then returns the square root of the computed value.", "input": "", "output": "function dadtau(axp_tau,o_mat_0,o_vac_0,o_k_0) \n  real(kind=8)::dadtau,axp_tau,o_mat_0,o_vac_0,o_k_0\n  dadtau = axp_tau*axp_tau*axp_tau *  &\n       &   ( o_mat_0 + &\n       &     o_vac_0 * axp_tau*axp_tau*axp_tau + &\n       &     o_k_0   * axp_tau )\n  dadtau = sqrt(dadtau)\n  return\nend function dadtau\n"}, {"instruction": "Create a Fortran function named dadt that takes 4 real(kind=8) input parameters (axp_t, o_mat_0, o_vac_0, o_k_0) and returns a single real(kind=8) output parameter. The function computes a value using the input parameters and returns the square root of the calculated value.", "input": "", "output": "function dadt(axp_t,o_mat_0,o_vac_0,o_k_0)\n  real(kind=8)::dadt,axp_t,o_mat_0,o_vac_0,o_k_0\n  dadt   = (1.0d0/axp_t)* &\n       &   ( o_mat_0 + &\n       &     o_vac_0 * axp_t*axp_t*axp_t + &\n       &     o_k_0   * axp_t )\n  dadt = sqrt(dadt)\n  return\nend function dadt\n"}, {"instruction": "Create a Fortran function named cairo_script_interpreter_translate_stream to interact with C code. The function takes 3 input parameters of type c_ptr, c_funptr, and c_ptr. The output is an integer of type c_int.", "input": "", "output": "function cairo_script_interpreter_translate_stream(stream, write_func, closure)&\n& bind(c) \n  use iso_c_binding, only: c_int, c_ptr, c_funptr\n  integer(c_int) :: cairo_script_interpreter_translate_stream\n  type(c_ptr), value :: stream\n  type(c_funptr), value :: write_func\n  type(c_ptr), value :: closure\nend function\n"}, {"instruction": "Write a Fortran function named cairo_pdf_surface_create to create a PDF surface for drawing. The function must have 3 input parameters of type ['character(kind=c_char), dimension(*)', 'real(c_double), value', 'real(c_double), value'] and 1 output parameter of type ['type(c_ptr)'].", "input": "", "output": "function cairo_pdf_surface_create(filename, width_in_points, height_in_points) &\n&bind(c) \n  use iso_c_binding, only: c_ptr, c_char, c_double\n  type(c_ptr) :: cairo_pdf_surface_create\n  character(kind=c_char), dimension(*) :: filename\n  real(c_double), value :: width_in_points\n  real(c_double), value :: height_in_points\nend function\n"}, {"instruction": "Create a Fortran function named cairo_surface_create_similar_image to generate a new surface with the same content as a specified surface. The function takes 4 input parameters of types type(c_ptr), integer(c_int), integer(c_int), and integer(c_int), and returns 1 output parameter of type type(c_ptr).", "input": "", "output": "function cairo_surface_create_similar_image(other, format, width, height) bind(&\n&c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: cairo_surface_create_similar_image\n  type(c_ptr), value :: other\n  integer(c_int), value :: format\n  integer(c_int), value :: width\n  integer(c_int), value :: height\nend function\n"}, {"instruction": "Write a Fortran function named cairo_surface_create_for_rectangle that takes 5 input parameters of types 'type(c_ptr), value', 'real(c_double), value', 'real(c_double), value', 'real(c_double), value', 'real(c_double), value' and 1 output parameter of type 'type(c_ptr)'. This function creates a Cairo surface of a specified width and height with the top-left corner at the coordinates (x, y) on the target surface.", "input": "", "output": "function cairo_surface_create_for_rectangle(target, x, y, width, height) bind(c&\n&) \n  use iso_c_binding, only: c_ptr, c_double\n  type(c_ptr) :: cairo_surface_create_for_rectangle\n  type(c_ptr), value :: target\n  real(c_double), value :: x\n  real(c_double), value :: y\n  real(c_double), value :: width\n  real(c_double), value :: height\nend function\n"}, {"instruction": "Provide a Fortran function named r_nearless to calculate the nearest value less than a given real number. It should have 1 input parameter of type real and 1 output parameter of type real. The input parameter should be named xval, and the output parameter should be named r_nl.", "input": "", "output": "function r_nearless (xval) result (r_nl)\n!  nearest value less than given value\n! __________________________________________________________\n      real, intent (in) :: xval\n      real :: r_nl\n! __________________________________________________________\n      r_nl = nearest (xval, -1.0)\n      return\n!\nend function r_nearless\n"}, {"instruction": "Create a Fortran function named i_nearless that returns the nearest integer value less than the given integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function i_nearless (xval) result (i_nl)\n!  nearest value less than given value\n! __________________________________________________________\n      integer, intent (in) :: xval\n      integer :: i_nl\n! __________________________________________________________\n      i_nl = xval - 1\n      return\n!\nend function i_nearless\n"}, {"instruction": "Create a Fortran pure function named myfunc that takes an integer input argument. The function should allocate and return an integer array of size 3 containing the input value, twice the input value, and three times the input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(:), allocatable'].", "input": "", "output": "  pure function myfunc(x) result(y)\n    integer, intent(in) :: x\n    integer, dimension(:), allocatable :: y\n    allocate (y(3))\n    y(1) = x\n    y(2) = 2*x\n    y(3) = 3*x\n  end function myfunc\n"}, {"instruction": "Create a Fortran function named \"f\" that takes a real number as input with the test_data type ['real ( kind = rp) '] and returns a real number with the test_data type ['real (kind = rp)']. The function computes the square of the input number and divides it by 3. Use the imperative tone and specify that this is a Fortran function.", "input": "", "output": "      function f(x1) \r\n      integer, parameter :: rp =  selected_real_kind(15)\r\n      real ( kind = rp) ,intent (in) :: x1\r\n      real (kind = rp) :: f \r\n      f = (x1 ** 2 )/3\r\n      return\r\n      end function f\r\n"}, {"instruction": "Create a Fortran pure function named \"letters\" that calculates the total number of letters required to write out the numbers from 1 to the given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer. Ensure that the input argument represents the starting number for the range of numbers to be considered.", "input": "", "output": "  pure function letters(starting_n)\n    integer, intent(in) :: starting_n\n    integer             :: n,letters\n\n    n=starting_n\n    letters=0\n    \n1   select case (n)\n    case (1:2,6,10)\n       letters=letters+3 ! one, two, six, ten\n    case (4:5,9)\n       letters=letters+4 ! four, five, nine\n    case (3,7:8)\n       letters=letters+5 ! three, seven, eight\n    case (11:12)\n       letters=letters+6 ! eleven, twelve\n    case (13:14)\n       letters=letters+8 ! thirteen, fourteen\n    case (15:16)\n       letters=letters+7 ! fifteen, sixteen\n    case (17)\n       letters=letters+9 ! seventeen\n    case (18:19)\n       letters=letters+8 ! eighteen, nineteen\n    case (20:29)\n       letters=letters+6 ! twenty\n       n=n-20\n       go to 1\n    case (30:39)\n       letters=letters+6 ! thirty\n       n=n-30\n       go to 1\n    case (40:49)\n       letters=letters+5 ! forty\n       n=n-40\n       go to 1\n    case (50:59)\n       letters=letters+5 ! fifty\n       n=n-50\n       go to 1\n    case (60:69)\n       letters=letters+5 ! sixty\n       n=n-60\n       go to 1\n    case (70:79)\n       letters=letters+7 ! seventy\n       n=n-70\n       go to 1\n    case (80:89)\n       letters=letters+6 ! eighty\n       n=n-80\n       go to 1\n    case (90:99)\n       letters=letters+6 ! ninety\n       n=n-90\n       go to 1\n    case (100:999)\n       letters=letters+7 ! hundred\n       select case (n / 100)\n       case (1:2,6)\n          letters=letters+3 ! one, two, six\n       case (3,7:8)\n          letters=letters+5 ! three, seven, eight\n       case (4:5,9)\n          letters=letters+4 ! four, five, nine\n       end select\n       n=mod(n,100)\n       if (n /= 0) then\n          letters=letters+3 ! and\n          go to 1\n       end if\n    case (1000)\n       letters=letters+11 ! one thousand\n    end select\n    \n  end function letters\n"}, {"instruction": "Write a Fortran function named qincom that takes 3 real input parameters (qc, qinf, tklam) and returns a real output parameter. The function computes the incompressible speed from the compressible speed using specific formulas based on the input parameters. Use the imperative tone in your instructions.", "input": "", "output": "    function qincom(qc, qinf, tklam)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        real :: qc, qinf, tklam\n        real :: qincom\n        intent (in) qc, qinf, tklam\n        !\n        ! local variables\n        !\n        real :: tmp\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !-------------------------------------\n        !     sets incompressible speed from\n        !     karman-tsien compressible speed\n        !-------------------------------------\n        !\n        if (tklam<1.0e-4 .or. abs(qc)<1.0e-4) then\n            !----- for nearly incompressible case or very small speed, use asymptotic\n            !      expansion of singular quadratic formula to avoid numerical problems\n            qincom = qc / (1.0 - tklam)\n        else\n            !----- use quadratic formula for typical case\n            tmp = 0.5 * (1.0 - tklam) * qinf / (qc * tklam)\n            qincom = qinf * tmp * (sqrt(1.0 + 1.0 / (tklam * tmp**2)) - 1.0)\n        endif\n    end function qincom\n"}, {"instruction": "Create a Fortran function named numcol that counts the number of columns in a string separated by spaces. The function takes 1 input argument of type character(*) and returns 1 output argument of type integer(4). The input argument represents the string to be analyzed, and the output argument represents the number of columns in the string.", "input": "", "output": " function numcol(str) result(nc)\n integer(4)::n,nc,nl,nll\n character(*)::str,str1*200\n str1 = adjustl(str)\n nl = len_trim(str1)\n if (nl==0) then\n   nc=0\n   return\n endif\n \n do n=1,nl\n   if (str1(n:n)==',') str1(n:n)=' '\n enddo\n nll = len_trim(str1)\n \n nc = 1\n do n=2,nll\n   if(str1(n:n)==''.and.str1(n-1:n-1)/='') then\n     nc=nc+1\n   endif\n enddo\n end function\n"}, {"instruction": "Create a Fortran function named tab_fe to calculate the value of tab_fe, which is the sum of 1, debut, and pos. The function has 2 input parameters with test_data type ['integer', 'integer'], and 1 output parameter with test_data type ['integer'].", "input": "", "output": "function tab_fe(pos,debut)\n\timplicit none\n\tinteger :: tab_fe, pos, debut\n\ttab_fe = 1 + debut + pos\nend function\n"}, {"instruction": "Create a Fortran function named local that takes one input argument of type real, target, and dimension(:,:,:) and returns one output argument of type real, pointer, and dimension(:,:,:).", "input": "", "output": "   function local(a)\n      implicit none\n      real, target, dimension(:,:,:) :: a\n      real, pointer, dimension(:,:,:) :: local\n\n      local => a\n\n   end function local\n"}, {"instruction": "Write a Fortran function named determ to calculate the determinant of a 3x3 matrix. The number of input arguments is 1 and the test_data type is ['3x3 real array']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function determ(a) result(det)\r\n\r\n    real(kind=8)    ::  a(3,3), det\r\n\r\n    intent(in)      ::  a\r\n\r\n    det = a(1,1)*a(2,2)*a(3,3) + &\r\n            a(2,1)*a(3,2)*a(1,3) + &\r\n            a(3,1)*a(1,2)*a(2,3) - &\r\n            a(3,1)*a(2,2)*a(1,3) - &\r\n            a(1,1)*a(3,2)*a(2,3) - &\r\n            a(2,1)*a(1,2)*a(3,3)\r\n\r\n    if (abs(det) < 1.d-12) then\r\n        write(*,*) 'determinant is null!'\r\n        read(*,*)\r\n        stop\r\n    end if\r\n\r\n    end function determ\r\n"}, {"instruction": "Write a Fortran function named mnorm that calculates the Euclidean norm of a 2D array. The function takes 1 input argument of type real(kind=8) and returns 1 output argument of type real(kind=8).", "input": "", "output": "    function mnorm(a) result(norma)\r\n\r\n    integer         :: sha(2)\r\n    real(kind=8)    :: a(:,:), norma\r\n    integer         :: i, j\r\n\r\n    intent(in)      :: a\r\n\r\n    sha = shape(a)\r\n    norma = 0.d0\r\n    do i=1,sha(1)\r\n        do j=1,sha(2)\r\n            norma = norma + a(i,j)**2\r\n        end do\r\n    end do\r\n\r\n    norma = sqrt(norma)\r\n\r\n    end function mnorm\r\n"}, {"instruction": "Create a Fortran function named vdot that calculates the dot product of two arrays of double precision floating-point numbers. The function takes 2 input arguments of type real(kind=8) and produces 1 output argument of type real(kind=8).", "input": "", "output": "    pure function vdot(x,y) result(z)\r\n\r\n    real(kind=8)\t::  x(:), y(:), z\r\n    integer\t\t\t::  i\r\n\r\n    intent(in)      ::  x, y\r\n\r\n\tz = 0.d0\r\n    do i = 1, size(x)\r\n        z = z + x(i)*y(i)\r\n    end do\r\n\r\n    end function vdot\r\n"}, {"instruction": "Write a Fortran function named norm to calculate the Euclidean norm of a real(kind=8) array. The function has 1 input parameter with a test_data type of ['real(kind=8)'] and 1 output parameter with a test_data type of ['real(kind=8)'].", "input": "", "output": "    pure function norm(x) result(y)\r\n\r\n    real(kind=8)\t::  x(:), y\r\n    integer\t\t\t::  i\r\n\r\n    intent(in)      ::  x\r\n\r\n\ty = 0.d0\r\n    do i = 1, size(x)\r\n        y = y + x(i)**2\r\n    end do\r\n\ty = sqrt(y)\r\n\r\n    end function norm\r\n"}, {"instruction": "Write a Fortran function named inner that takes two 3x3 matrices as input and computes the inner product of the matrices. The number of input arguments is 2, and the test_data type is ['', '']. The number of output arguments is 1, and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function inner(a,b) result(c)\r\n\r\n    integer\t\t\t::  i, j\r\n    real(kind=8)\t::  a(3,3), b(3,3), c\r\n\r\n    intent(in)      ::  a, b\r\n\r\n\tc = 0.d0\r\n    do i = 1,3\r\n        do j = 1,3\r\n            c = c + a(i,j)*b(i,j)\r\n        end do\r\n    end do\r\n\r\n    end function inner\r\n"}, {"instruction": "Create a Fortran function named fun_convert_delta14ctod14c to convert delta 14C to d14C. The function takes 2 input arguments of type real, named dum_delta13c and dum_delta14c. It returns 1 output argument of type real.", "input": "", "output": "  function fun_convert_delta14ctod14c(dum_delta13c,dum_delta14c)\n    implicit none\n    ! result variable\n    real::fun_convert_delta14ctod14c\n    ! dummy arguments\n    real,intent(in)::dum_delta13c,dum_delta14c\n\n    ! note: see stuiver and polach [1977] (stuiver and robinson [1974])\n    fun_convert_delta14ctod14c = 1000.0* &\n         &( &\n         &   (1.0 + dum_delta14c/1000.0) * &\n         &   (0.975**2)/((1.0 + dum_delta13c/1000.0)**2) - &\n         &   1.0 &\n         & )\n  end function fun_convert_delta14ctod14c\n"}, {"instruction": "Write a Fortran function named repmat to replicate a matrix along specified dimensions. The function takes 2 input parameters of type double precision, dimension(:,:) and integer, dimension(2) respectively. It returns 1 output parameter of type double precision, dimension(:,:), allocatable.", "input": "", "output": "function repmat(m,vecdim) result(r)\n\n  implicit none\n  double precision, dimension(:,:) :: m\n  double precision, dimension(:,:), allocatable :: r\n  integer, dimension(2) :: vecdim, sizem , sizef\n  integer :: i,jr,j,ir\n\n  sizem = shape(m)\n\n  do i = 1,2 !(int i=0;i<siz.length;i++){\n      sizef(i) = sizem(i)*vecdim(i)   ! sizf[i] = siz[i]*repdim[i];\n  end do ! determine the final size desired after repmat. !} // determine the final size desired after repmat.\n\n\n  allocate(r(sizef(1),sizef(2)))\n\n  do jr = 1, vecdim(2) !for (int jr = 1; jr <= repdim[1]; jr++) {\n    do j = 1, sizem(2) ! for (int j = 0; j < siz[1]; j++) {\n      do ir = 1, vecdim(1) !for (int ir = 1; ir <= repdim[0]; ir++) {\n        do i = 1,sizem(1)   ! for (int i = 0; i < siz[0]; i++) {\n          r( (ir-1)*sizem(1)+i,(jr-1)*sizem(2)+j ) = m(i,j) ! result[ (ir-1)*siz[0]+i ][ (jr-1)*siz[1]+j ] = m[i][j];\n        end do !} // 1st dim\n      end do !} // 1st rep\n    end do  !} // 2nd dim\n  end do !} // 2nd rep\n\n\nend function repmat\n"}, {"instruction": "Create a Fortran function named ones1 that takes an integer input argument and returns an integer array of the same size filled with ones. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(s1)'].", "input": "", "output": "function ones1(s1) result(v)\n  implicit none\n  integer :: s1\n  integer, dimension(s1) :: v ! output\n  v = 1\nend function ones1\n"}, {"instruction": "Write a Fortran function named ones2 that initializes a 2D array with ones. The function takes 2 input arguments of type integer and returns a 2D integer array of size s1 x s2 as the output. The function should be named \"ones2\".", "input": "", "output": "function ones2(s1,s2) result(v)\n  implicit none\n  integer :: s1,s2\n  integer, dimension(s1,s2) :: v ! output\n  v = 1\nend function ones2\n"}, {"instruction": "Create a Fortran function named invs that takes a double precision input argument and returns the inverse of the input as a double precision output. The number of input parameters is 1, and the test_data type is ['double precision']. The number of output parameters is 1, and the test_data type is ['double precision'].", "input": "", "output": "  function  invs(ms) result(minv)\n    implicit none\n    double precision ::  ms ! input\n    double precision ::  minv ! output\n\n    minv = 1/ms\n  end function invs\n"}, {"instruction": "Write a Fortran function named linspace to generate a linearly spaced vector of real numbers between a start value and an end value, with a specified number of elements. The function takes 3 input parameters of types double precision, double precision, and integer, and returns 1 output parameter of type double precision array with dimension n.", "input": "", "output": "  function  linspace(vi,vf,n) result(m)\n    implicit none\n    double precision :: vi,vf,dx\n    integer :: n,i\n    double precision, dimension(n) :: m ! output\n\n    dx = (vf-vi)/(n-1)\n    m = (/(i, i=0,n-1, 1)/)*dx\n\n  end function linspace\n"}, {"instruction": "Write a Fortran function named incr that generates an array of integers starting from 'a' and ending at 'b', where 'a' and 'b' are input integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, allocatable, dimension(:)'].", "input": "", "output": "  function  incr(a,b) result(m)\n    implicit none\n    integer :: a,b,i,n\n    integer, allocatable, dimension(:) :: m ! output\n\n    n = b-a+1\n    allocate( m(n) )  != (/(i, i=a, b, 1)/)\n    m = (/(i, i=a, b, 1)/)\n\n  end function incr\n"}, {"instruction": "Write a Fortran function named h_1 to concatenate two input arrays m1 and m2 into a single output array m. The number of input arguments is 2 and the test_data type is ['double precision, dimension(:)', 'double precision, dimension(:)']. The number of output arguments is 1 and the test_data type is ['double precision, dimension(size(m1)+size(m2))'].", "input": "", "output": "function h_1(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:) :: m1,m2 ! input\n  double precision, dimension(size(m1)+size(m2)) :: m ! output\n\n  m = [m1,m2]\n  !m(1:size(m1,1)) = m1\n  !m(size(m1,1)+1:(size(m1,1)+size(m2,1))) = m2\n\nend function h_1\n"}, {"instruction": "Write a Fortran function called v_1real that takes two arrays of double precision values as input and returns a 2xN array where N is the size of the input arrays. The number of input arguments is 2 and the test data type is ['double precision, dimension(:)', 'double precision, dimension(:)']. The number of output arguments is 1 and the test data type is ['double precision, dimension(2,size(m1))'].", "input": "", "output": "function v_1real(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:) :: m1,m2 ! input\n  double precision, dimension(2,size(m1)) :: m ! output\n\n\n  m(1,:) = m1\n  m(2,:) = m2\n\nend function v_1real\n"}, {"instruction": "Create a Fortran function named v_2real that combines two input matrices m1 and m2 into a single output matrix m. The input parameters are both double precision matrices of unspecified size, while the output parameter is a double precision matrix with a size equal to the combined number of rows of m1 and m2, and the number of columns of m1.", "input": "", "output": "function v_2real(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:,:) :: m1,m2 ! input\n  double precision, dimension(size(m1,1)+size(m2,1),size(m1,2)) :: m ! output\n\n\n  m(1:size(m1,1),:) = m1\n  m(size(m1,1)+1:size(m1,1)+size(m2,1),:) = m2\n\nend function v_2real\n"}, {"instruction": "Create a Fortran function named \"gammln\" that calculates the natural logarithm of the absolute value of the gamma function for a double precision input parameter. The number of input arguments is 1 with a test_data type of ['double precision'], and the number of output arguments is 1 with a test_data type of ['double precision'].", "input": "", "output": "function gammln(xx)\n\n!***   taken from the \"numerical recipes\"\n\n!--------------------------------------------------\nimplicit none\ndouble precision :: xx\ndouble precision :: gammln\ninteger :: j\ndouble precision :: ser,stp,tmp,x,y\ndouble precision, dimension(6) :: cof\nsave cof,stp\ndata cof,stp/76.18009172947146d0,-86.50532032941677d0,24.01409824083091d0,  &\n            -1.231739572450155d0,.1208650973866179d-2,-.5395239384953d-5, &\n            2.5066282746310005d0/\n!\n!-------- executable code\n!\nx=xx\ny=x\ntmp=x+5.5d0\ntmp=(x+0.5d0)*dlog(tmp)-tmp\nser=1.000000000190015d0\ndo j=1,6\n   y=y+1.d0\n   ser=ser+cof(j)/y\nenddo\ngammln=tmp+dlog(stp*ser/x)\nreturn\nend function gammln\n"}, {"instruction": "Create a Fortran function named flipcount that takes 3 input parameters of type integer: a, b, and nbits. The function returns a single output parameter of type integer. This function calculates the number of bit positions at which the binary representations of integers a and b differ, up to the nth bit, and stores the count in the variable c.", "input": "", "output": "pure function flipcount(a,b,nbits) result(c)\n\n    integer, intent(in) :: a,b,nbits\n    integer             :: n,i\n    integer             :: c\n\n    c = 0\n    n = 1\n    \n    do i = 1,nbits\n        if (iand(a,n) /= iand(b,n)) c = c + 1\n        n = 2*n\n    end do\n\nend function\n"}, {"instruction": "Write a Fortran function named formatcesmdate that takes 6 input parameters of type integer: ccyy, mm, dd, hh, nn, and ss. It returns a single output parameter of type character with a length of 80. This function computes and formats a date and time into a specific format and assigns it to the output parameter formatcesmdate.", "input": "", "output": "function formatcesmdate(ccyy,mm,dd,hh,nn,ss)\ninteger, intent(in) :: ccyy\ninteger, intent(in) :: mm\ninteger, intent(in) :: dd\ninteger, intent(in) :: hh\ninteger, intent(in) :: nn\ninteger, intent(in) :: ss\ncharacter(len=80) :: formatcesmdate\n\ninteger :: fffff\n\nfffff = hh*3600 + nn*60 + ss\nwrite(formatcesmdate, '(i4.4,1a,2(i2.2,1a),i5.5)') ccyy, '-', mm, '-', dd, '-', fffff\n\nend function formatcesmdate\n"}, {"instruction": "Create a Fortran function named convertfunc that takes two integer input parameters and returns a character string of length 10. The first input parameter represents the number to be converted, and the second input parameter specifies the base for conversion. The function converts the input number to the specified base and returns the result as a character string of length 10.", "input": "", "output": "  function convertfunc(innumber, switch) result(outname)\n    implicit none\n    integer :: innumber, switch\n    character(len=10) :: outname\n\n    character(len=10) :: buf, flag\n    integer :: j, bd\n\n    bd = 0\n    if (switch == 10) then\n       flag = '(i10)'\n       bd = 10\n       write (buf,10) innumber\n10     format (i10)\n    else if (switch == 2) then\n       flag = '(i2)'\n       bd = 2\n       write (buf,20) innumber\n20     format (i2)\n    else if (switch == 4) then\n       flag = '(i4)'\n       bd = 4\n       write (buf,30) innumber\n30     format (i4)\n    end if\n\n    do j = 1, bd\n       if (buf(j:j) == ' ') buf(j:j) = '0'\n    end do\n    outname = trim(buf)\n  end function convertfunc\n"}, {"instruction": "Create a Fortran function named random_int to generate a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "  function random_int(left, right) result(rand)\n    real :: random_real\n    integer :: left, right, rand\n    call random_number(random_real)\n    rand = left + floor((right+1-left)*random_real)\n  end function random_int\n"}, {"instruction": "Create a Fortran function named dy to calculate the value of dy, given the values of t and y. The number of input arguments is 2 with the test_data type of [real, real], and the number of output arguments is 1 with the test_data type of [real]. Use the formula dy = (5 * t * t - y) / ( e ** (t + y )) to compute the result, where e is a predefined constant.", "input": "", "output": "function dy(t, y)\n    implicit none\n\n    real :: dy\n    real :: y\n    real :: t\n\n    real, parameter :: e = 2.71828\n\n    dy = (5 * t * t - y) / ( e ** (t + y ))\n    return\nend function dy\n"}, {"instruction": "Create a Fortran function named add_mixed that takes in two required integer parameters and two optional integer parameters. The function returns an integer. When called, the function computes the sum of the required parameters and, if the optional parameters are provided, adds them to the sum as well.", "input": "", "output": "    function add_mixed(a,b,c,d) result(y)\n      integer, intent(in) :: a,b ! test optional ::\n      integer, intent(in), optional :: c,d\n      integer :: y\n      y = a+b\n      if (present(c)) y = y + c\n      if (present(d)) y = y + d\n    end function add_mixed\n"}, {"instruction": "Write a Fortran function named compute_error to calculate the relative error between two matrices. The function takes 2 input arguments of type real, each with a two-dimensional array. The output is a single real value representing the relative error.", "input": "", "output": "    function compute_error(orig_a, a) result(rel_err)\n        implicit none\n        real, dimension(:, :), intent(in) :: orig_a, a\n        real :: rel_err\n        integer :: i, j\n        real :: norm\n        rel_err = 0.0\n        do j = 1, size(a, 2)\n            do i = 1, size(a, 1)\n                norm = abs(orig_a(i, j))\n                rel_err = rel_err + abs(a(i, j) - orig_a(i, j))/norm\n            end do\n        end do\n        rel_err = rel_err/(size(a, 1)*size(a, 2))\n    end function compute_error\n"}, {"instruction": "Create a Fortran function named cap to limit the input integer value to a maximum of 10. The function should take 1 input argument of type integer and return 1 output argument of type integer.", "input": "", "output": "pure function cap(x)\n  implicit none\n  integer, intent(in) :: x\n  integer :: y\n  integer :: cap\n  y = x\n  if (10 < y) then\n      y = 10\n  end if\n  cap = y\nend function\n"}, {"instruction": "Create a Fortran function named bcut_getweno3 to calculate a weighted essentially non-oscillatory (WENO) reconstruction. The function takes 3 real input parameters ('real', 'real', 'real') and returns 1 real output parameter ('real').", "input": "", "output": "function bcut_getweno3(v1, v2, v3)\n  implicit none\n  real          :: bcut_getweno3\n  real          :: v1, v2, v3\n  real          :: r\n  real          :: w\n  real          :: eps\n  eps = 0.001\n  r = (eps + (v2-v1)**2)/(eps + (v3-v2)**2)\n  w = 1.0/(1.0 + 2*r*r)\n  bcut_getweno3 = 0.5*(v2 + v3) - 0.5*w*(v1 - 2.0*v2 + v3)\n  return\nend function bcut_getweno3\n"}, {"instruction": "Create a Fortran pure function named lower to convert specified portions of a string to lowercase. The function takes 3 input parameters: str (character(*)), begin (integer, optional), and end (integer, optional). The output parameter is string (character(len(str))). The function loops through the specified portion of the input string and converts uppercase letters to lowercase. If begin and end are not specified, the function converts the entire string to lowercase.", "input": "", "output": "elemental pure function lower(str,begin,end) result (string)\n\ncharacter(*), intent(in)     :: str\ncharacter(len(str))          :: string\ninteger,intent(in),optional  :: begin, end\ninteger                      :: i\ninteger                      :: ibegin, iend\ninteger,parameter             :: diff = iachar('a')-iachar('a')\n   string = str\n   ibegin=1\n   iend=len_trim(str)\n\n   if (present(begin))then\n      ibegin = min(max(1,begin),iend)\n   endif\n\n   if (present(end))then\n      iend= max(1,min(iend,end))\n   endif\n\n   do concurrent (i = ibegin:iend)\n      select case (str(i:i))\n      case ('a':'z')\n         string(i:i) = char(iachar(str(i:i))-diff)\n      case default\n      end select\n   enddo\n\nend function lower\n"}, {"instruction": "Create a Fortran function named mean to calculate the mean value of an array of real numbers. The function should take 2 input parameters: an integer 'n' and an array of real numbers 'x' with dimension 'n'. The function should return a single real value as the mean.", "input": "", "output": "   function mean(x, n) result(m)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, intent(in), dimension(n) :: x\n\n      real :: m\n      ! processing\n      m = sum(x) / n\n   end function mean\n"}, {"instruction": "Write a Fortran function named compute_dev that takes 3 input parameters of types integer, real, and real array of dimension n, and returns 1 output parameter of type real array of dimension n. The function calculates the deviation of each element in the input array x from the value m, and stores the result in the array dev.", "input": "", "output": "   function compute_dev(x, m, n) result(dev)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, intent(in) :: m\n      real, dimension(n), intent(in) :: x\n\n      real, dimension(n) :: dev\n      ! processing\n      dev = x - m\n   end function compute_dev\n"}, {"instruction": "Create a Fortran function named phexp that takes a single real number of kind=8 as input and returns a complex number of kind=8 as output. The function computes the complex exponential value of the input real number using the cosine and sine functions.", "input": "", "output": "  function phexp(x)\n    implicit none\n\n    real(kind=8),intent(in) :: x\n    complex(kind=8) :: phexp\n\n    phexp=cmplx(cos(x),sin(x),kind=8)\n  end function phexp\n"}, {"instruction": "Create a Fortran function named iget_class to determine the class of an integer input. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of type ['integer'] and the output parameter is of type ['integer'].", "input": "", "output": "        function iget_class(m) result(ires)\r\n            integer, intent(in) :: m\r\n            integer :: ires\r\n            select case (m)\r\n            case (:-3)\r\n                ires = 1\r\n            case (-2:-1)\r\n                ires = 2\r\n            case (0)\r\n                ires = 3\r\n            case (1:2)\r\n                ires = 4\r\n            case (3:)\r\n                ires = 5\r\n            end select\r\n        end function iget_class\r\n"}, {"instruction": "Create a Fortran function named conv_sic that takes an integer input parameter and returns a character string of length 3. The input parameter should be of type integer, and the output should be of type character with a length of 3.", "input": "", "output": "  function conv_sic(i)\n    implicit none\n    character(len=3) :: conv_sic\n    integer :: i\n    integer :: i1, i2, itemp, i3\n    character(len=1) ::  a, b, c\n    if (i < 10) then\n       a = char(i + 48)\n       conv_sic = a // '  '\n    else if (i < 100) then\n       i1 = i / 10\n       i2 = i - i1 * 10\n       a = char(i1 + 48)\n       b = char(i2 + 48)\n       conv_sic = a // b // ' '\n    else\n       i1 =i / 100\n       itemp = i - 100 * i1\n       i2 = itemp / 10\n       i3 = itemp - 10 * i2\n       a = char(i1 + 48)\n       b = char(i2 + 48)\n       c = char(i3 + 48)\n       conv_sic = a // b // c\n    end if\n  end function conv_sic\n"}, {"instruction": "Write a Fortran function named new_ext to create a new file name with the specified extension. The function takes 2 input parameters of type character(len = *) and returns 1 output parameter of type character(len = 256).", "input": "", "output": "function new_ext(file_name, extension)\n\n    implicit none\n    character(len = *), intent(in)  :: file_name  ! file to add new extension to\n    character(len = *), intent(in)  :: extension  ! new extension to add\n    character(len = 256)            :: new_ext    ! file name with new extension\n    integer, dimension(2)           :: ext_pos    ! positions of extension separators\n\n    ext_pos = (/ scan(trim(file_name), '_tmp', back = .true.) - 4,  scan(trim(file_name), '.', back = .true.) - 1 /)\n    if (any(ext_pos > 0)) then\n        new_ext = file_name(1:minval(ext_pos, (ext_pos > 0))) // extension\n    else\n        new_ext = trim(file_name) // extension\n    end if\n\nend function new_ext\n"}, {"instruction": "Create a Fortran function named integrand to calculate the value of the integrand function for a given real input value. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function integrand(x)\n        \n        implicit none \n        real :: x, integrand\n\n        integrand = 4.d0/(1.d0 + x**2)\n\nend function\n"}, {"instruction": "Write a Fortran function named \"limiter\" to calculate a limited value based on the given input values and limiter type. The number of input arguments for the function is 3, with test_data types ['real(kind=8)', 'real(kind=8)', 'integer'], and the number of output arguments is 1 with test_data type ['real(kind=8)'].", "input": "", "output": "  function limiter(sm, sp, limiter_type) result(s)\n    implicit none\n    real(kind=8), intent(in)::sm, sp\n    real(kind=8) :: s\n    real(kind=8) :: epsilon\n    integer, intent(in)::limiter_type\n\n    epsilon = 1d-12\n\n    s = 0\n\n    select case (limiter_type)\n\n    case (0) ! first order upwind\n      s = 0\n\n    case (1) ! lax wendroff\n      s = sp\n\n    case (2) ! minmod\n      s = max(0.0_8, min(sm, sp))*sign(1.0_8, sm + sp)\n\n    case (3) ! harmonic\n      s = (sm*abs(sp) + abs(sm)*sp)/(abs(sm + abs(sp) + epsilon))\n\n    case (4) ! geometric\n      s = sqrt((sm*sp + abs(sm*sp))/2)*sign(1.0_8 + 0, sm + sp)\n\n    case (5) !superbee\n      s = max(0.0_8, max(min(2*abs(sm), abs(sp)), min(abs(sm), 2*abs(sp)))) &\n          *sign(1.0_8, sm + sp)\n\n    end select\n\n  end function limiter\n"}, {"instruction": "Create a Fortran pure function named to_string, which is designed to convert an integer value to a string representation. The function takes 1 input argument of type integer, and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "    pure function to_string(x) result(string)\n\n        !> \u9700\u8981\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u7684\u6574\u6570\n        !> integer to be converted to string\n        integer, intent(in) :: x\n        !> \u8f6c\u6362\u540e\u7684\u5b57\u7b26\u4e32\n        !> string after conversion\n        character(:), allocatable :: string\n\n        integer, parameter :: buffer_len = range(x) + 2\n        character(buffer_len) :: buffer\n        integer :: pos\n        integer :: n\n        character(1), parameter :: number(0:9) = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n        if (x == 0) then\n            string = number(0)\n            return\n        end if\n\n        n = abs(x)\n        buffer = \"\"\n\n        pos = buffer_len + 1\n        do while (n > 0)\n            pos = pos - 1\n            buffer(pos:pos) = number(mod(n, 10))\n            n = n/10\n        end do\n        if (x < 0) then\n            pos = pos - 1\n            buffer(pos:pos) = \"-\"\n        end if\n\n        string = buffer(pos:)\n\n    end function to_string\n"}, {"instruction": "Write a Fortran function named erf that calculates the error function (erf) for a given real number (x). The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function erf(x)\n!\nimplicit none\n!\n\n!\nreal :: x\nreal :: erf\n!\n! local variables\n!\nreal :: a,b,c,d,e,f,g,h,i,j,k,x2,x3,x4,x5,z\n!\n!**********************************************************************\n \n!     + + + purpose + + +\n\n!     written by l. hagen and coded by i. elmanyawi.\n \n!     + + + argument declarations + + +\n \n!     + + + local variables + + +\n!\n!     + + + end specifications + + +\n!\na = -0.000018936\nb = 0.030284321\nc = 1.12891921\nd = 0.37693092\ne = 0.029375235\nf = 0.088848989\ng = 0.068200064\nh = 0.022155958\ni = 0.050754183\nj = 0.038090749\nk = 0.034275052\n \nz = x\nx = abs(x)\nx2 = x*x\nx3 = x2*x\nx4 = x3*x\nx5 = x4*x\n \nerf = (a+c*x+e*x2+g*x3+i*x4+k*x5)/(1.000000+b*x+d*x2+f*x3+h*x4+j*x5)\nerf = erf*z/x\n!\nend function erf\n"}, {"instruction": "Create a Fortran function named bnc that computes the number of cells for a subdomain in one dimension. The function takes in the total number of cells for a dimension (n), the number of processes in that dimension (p), and the rank. It returns the integer number of cells for that subdomain (bnc). The input parameters are of type integer and the order is (n, p, rank), while the output parameter is also of type integer.", "input": "", "output": "function bnc(n,p,rank)\n\n!-------------------------------------------------------------\n!\n!  compute the number of cells for the subdomain, one\n!   dimension at a time.\n!  take in the number of cells total for a dimension, n, the \n!   number of processes p in that dimension, and the rank.\n!  return the integer number of cells for that sub-domain, bnc.\n!\n!  when not evenly divided, keeps all but one even, then tries\n!   tries to keep last sub-domain close\n!\n!-------------------------------------------------------------\n\nimplicit none\ninteger, intent(in) :: n, p, rank\ninteger :: bnc, tmpi1, tmpi2\nreal :: tmpr\n\n! set the values to be checked against\ntmpr = 0.5*real(p)\n\ntmpi1 = mod(n,p)\ntmpi2 = n/p\n\n! if it's evenly divisible, just use the division\nif (tmpi1 == 0) then\n   bnc = tmpi2\n\n! if not, then compare the mod result to half the number of processes and set\nelse if (real(tmpi1) < tmpr) then\n   if (rank /= p-1) then\n      bnc = tmpi2\n   else\n      bnc = n - (p-1)*tmpi2\n   end if\n\nelse if (real(tmpi1) >= tmpr) then\n   if (rank /= p-1) then\n      bnc = tmpi2 + 1\n   else\n      bnc = n - (p-1)*(tmpi2+1)\n   end if\n\nend if\n\nend function bnc\n"}, {"instruction": "Create a Fortran function named \"napetost\" to calculate the voltage based on the given temperature. The function takes 1 input argument of type real. The input test_data type is ['real']. The function returns 1 output argument of type real. The output test_data type is ['real']. If the temperature is less than 40.0, the voltage is set to 10.0; otherwise, the voltage is set to 0.0.", "input": "", "output": "    function napetost(t)\n        implicit none\n        real :: napetost, t\n\n        if (t < 40.0) then\n            napetost = 10.0\n        else\n            napetost = 0.0\n        end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named \"de\" that takes a single real number as input and returns it as output. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function de(e1)\n        implicit none\n        real :: de,e1\n        de = e1\n    end function\n"}, {"instruction": "Provide a Fortran function named de1 that assigns the value of a real input parameter to a real output parameter. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function de1(e2)\n        implicit none\n        real :: de1,e2\n        de1 = e2\n    end function\n"}, {"instruction": "Create a Fortran function named \"de2\" that takes one real number as input and returns it as the output. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "    function de2(e3)\n        implicit none\n        real :: de2,e3\n        de2 = e3\n    end function\n"}, {"instruction": "Create a Fortran function named de3 that takes one real input argument. This function assigns the value of the input argument to a variable named de3. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "    function de3(e4)\n        implicit none\n        real :: de3,e4\n        de3 = e4\n    end function\n"}, {"instruction": "Create a Fortran function named mean to calculate the mean value. This function takes 2 input parameters of type real and integer, denoted as [real, integer]. It returns 1 output parameter of type real, denoted as [real].", "input": "", "output": "function mean(summ, count) result(fn_val)\r\nimplicit none\r\n\r\nreal, intent(in)     :: summ\r\ninteger, intent(in)  :: count\r\nreal                 :: fn_val\r\n\r\nfn_val = summ / real(count)\r\n\r\nreturn\r\nend function mean\r\n"}, {"instruction": "Create a Fortran function called fact to calculate the factorial of a given integer number. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. If the input parameter is negative, the function returns 0.0.", "input": "", "output": "function fact (n) result(fn_val)\r\n\r\n!     algorithm as 304.10 appl.statist. (1996), vol.45, no.3\r\n\r\n!     returns the factorial of n or 0.0 if the parameter is negative.\r\n\r\nimplicit none\r\ninteger, intent(in) :: n\r\nreal                :: fn_val\r\n\r\ninteger  :: i\r\n\r\nif (n < 0) then\r\n  fn_val = 0.0\r\nelse\r\n  fn_val = 1.0\r\n  do i = 2, n\r\n    fn_val = fn_val * real(i)\r\n  end do\r\nend if\r\n\r\nreturn\r\nend function fact\r\n"}, {"instruction": "Create a Fortran function named f to calculate the value of f using the input parameters t and y. The input parameters t and y are both of type real(kind=kind(1.0d0)). The output parameter f is also of type real(kind=kind(1.0d0)). The function uses the formula f = t*sqrt(y).", "input": "", "output": "  function f (t,y)\n    implicit none\n    real(kind=kind(1.0d0)),intent(in) :: y,t\n    real(kind=kind(1.0d0)) :: f\n    f = t*sqrt(y)\n  end function f\n"}, {"instruction": "Create a Fortran recursive function named factorial. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function computes the factorial of the input integer using recursive multiplication.", "input": "", "output": "recursive function factorial(n) result(total)\n    implicit none\n    integer :: n, total\n    if (n .eq. 0) then\n        total = 1\n    else\n        total = n * factorial(n - 1)\n    endif\n\nend function factorial\n"}, {"instruction": "Create a Fortran function named norm to calculate the Euclidean norm of a real(kind=8) array. The input parameter is an array of real(kind=8), with intent(in) and dimension(:). The output parameter is a real(kind=8).", "input": "", "output": "    pure function norm(vector) result(res)\n        real(kind=8), dimension(:), intent(in) :: vector\n        real(kind=8) :: res\n        integer :: i\n        \n        res = 0\n        do i = 1, size(vector), 2\n            res = res + vector(i) ** 2\n        end do\n        \n        res = sqrt(res)\n    \n    end function norm\n"}, {"instruction": "Create a Fortran function named rtndt that calculates the value of rtndt based on the input parameters a, cf, fsurf, and rtndt0, all of which are of type real. The function has 4 input parameters of type real and 1 output parameter of type real.", "input": "", "output": "    function rtndt(a, cf, fsurf, rtndt0)\n\n        !variables\n        real :: rtndt, d_rtepi, d_rtndt, phi, f\n        real, intent(in) :: a, cf, fsurf, rtndt0\n\n        !calculate d_rtepi\n        call random_number(phi)\n        d_rtepi = -29.5+78.0*(-log(1-phi))**(1/1.73)\n\n        !calculate d_rtndt\n        f = fsurf*exp(-0.24*a)\n        d_rtndt = cf*f**(0.28-0.10*log10(f))\n\n        !calculate the rtndt\n        rtndt = rtndt0 + d_rtepi + d_rtndt\n\n    end function rtndt\n"}, {"instruction": "Create a Fortran function named ffun that calculates the result using the formula ffun = x + y * y. The function should take 2 input arguments of type double precision and return 1 output argument of type double precision.", "input": "", "output": "function ffun(x, y)\n    implicit none\n    !dec$ attributes dllexport, stdcall, reference :: ffun\n    double precision :: x, y, ffun\n    ffun = x + y * y\nend function\n"}, {"instruction": "Write a Fortran function named get_characteristic that takes an input argument of type integer(kind=1) and returns an output of the same type. The function computes the characteristic of the input as follows: if the input is less than 0, it adds 256 to the input; then, if the input is greater than or equal to 128, it subtracts 128 from the input. Finally, it returns the characteristic value.", "input": "", "output": "  function get_characteristic(b) result (c)\n    \n    implicit none\n    \n    integer(kind=1)                      :: c\n    integer(kind=1),         intent(in)  :: b\n    integer                              :: w\n    \n    w=b\n\n    if (w<0) w=256+w\n\n    if (w>=128) then\n      w=w-128\n    end if\n\n    c=w\n    return\n    \n  end function get_characteristic\n"}, {"instruction": "Create a Fortran function called plasma_init_c to initialize a plasma application with the specified number of cores. The function takes 1 input parameter of type integer(kind=c_int), passed by value. The output is of type integer(kind=c_int). Use the bind(c) attribute to specify the name \"plasma_init\" for the function when interfacing with C code.", "input": "", "output": "         function plasma_init_c(cores) &\n          & bind(c, name='plasma_init')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_init_c\n            integer(kind=c_int), value :: cores\n         end function plasma_init_c\n"}, {"instruction": "Create a Fortran function named \"plasma_set_c\" that sets a parameter value for a plasma system. The function takes 2 input arguments of type \"integer(kind=c_int), value\" and returns 1 output argument of type \"integer(kind=c_int)\". The function should be used to bind to the C function \"plasma_set\".", "input": "", "output": "         function plasma_set_c(param, pval) &\n          & bind(c, name='plasma_set')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_set_c\n            integer(kind=c_int), value :: param\n            integer(kind=c_int), value :: pval\n         end function plasma_set_c\n"}, {"instruction": "Create a Fortran function named plasma_get_c that returns an integer value. This function takes two input parameters: an integer parameter and a pointer to a C type. The input parameters are of type integer(kind=c_int) and type(c_ptr), both passed by value. The output parameter is also of type integer(kind=c_int).", "input": "", "output": "         function plasma_get_c(param, pval) &\n          & bind(c, name='plasma_get')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_get_c\n            integer(kind=c_int), value :: param\n            type(c_ptr), value :: pval\n         end function plasma_get_c\n"}, {"instruction": "Write a Fortran function named plasma_lapack_to_tile_c. The function takes in 3 input parameters of type 'type(c_ptr), value', 'type(c_ptr), value', and 'integer(kind=c_int), value'. The output is a single integer of kind c_int.", "input": "", "output": "         function plasma_lapack_to_tile_c(a_lpk,lda,a_pma) &\n          & bind(c, name='plasma_lapack_to_tile')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_lapack_to_tile_c\n            type(c_ptr), value :: a_lpk, a_pma\n            integer(kind=c_int), value :: lda\n         end function plasma_lapack_to_tile_c\n"}, {"instruction": "Create a Fortran function named plasma_sequence_destroy_c to destroy a plasma sequence. It takes 1 input parameter of type c_ptr and value, and returns 1 output parameter of type integer with kind c_int.", "input": "", "output": "         function plasma_sequence_destroy_c(seq) &\n          & bind(c, name='plasma_sequence_destroy')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_destroy_c\n            type(c_ptr), value :: seq\n         end function plasma_sequence_destroy_c\n"}, {"instruction": "Create a Fortran function named plasma_sequence_wait_c. The function takes 1 input parameter of type c_ptr with the attribute value. It returns an output parameter of type integer with a kind attribute of c_int.", "input": "", "output": "         function plasma_sequence_wait_c(seq) &\n          & bind(c, name='plasma_sequence_wait')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_wait_c\n            type(c_ptr), value :: seq\n         end function plasma_sequence_wait_c\n"}, {"instruction": "Write a Fortran function named plasma_sequence_flush_c that takes two input parameters of type c_ptr and value. The number of input arguments is 2 and the test_data type is ['type(c_ptr), value', 'type(c_ptr), value']. The function returns an output parameter of type integer with kind c_int. The number of output arguments is 1 and the test_data type is ['integer(kind=c_int)'].", "input": "", "output": "         function plasma_sequence_flush_c(seq,req) &\n          & bind(c, name='plasma_sequence_flush')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_flush_c\n            type(c_ptr), value :: seq\n            type(c_ptr), value :: req\n         end function plasma_sequence_flush_c\n"}, {"instruction": "Create a Fortran function named concat that takes two input arguments of type character with variable length. The number of input arguments is 2, and the test_data type is ['character (len=*)', 'character (len=*)']. The function should return a single output argument of type character with a length equal to the sum of the lengths of the input strings. The number of output parameters is 1, and the test_data type is ['character (len=(len_trim(cha) + len_trim(chb)))']. The function concatenates the two input strings and returns the result.", "input": "", "output": " function concat(cha,chb)\n implicit none\n character (len=*), intent(in) :: cha, chb \n character (len=(len_trim(cha) + len_trim(chb))) :: concat\n concat = trim(cha)//trim(chb)\n end function concat\n"}, {"instruction": "Create a Fortran function named g that takes 3 input parameters of type double precision, denoted as (t, x, y), and returns 1 output parameter of type double precision.The function computes the value of g using the given formula.", "input": "", "output": "function g(t, x, y)\n  double precision::g, t, x, y, a, c\n  !g=-x + t*x*y*0.0\n  a=-9.932e-6\n  c=1.575e-6\n  g=a*sin(x)+c*sin(2*x)\nend function g\n"}, {"instruction": "Write a Fortran function named flatten_method to calculate the interval between two points in three-dimensional space. The function takes 2 input parameters of type real, dimension (1:3), and returns 1 output parameter of type real.", "input": "", "output": "  function flatten_method(first_point_coord, second_point_coord) result(interval)\n    implicit none\n    real, dimension (1:3) :: first_point_coord, second_point_coord\n    real :: interval\n    integer :: i\n    interval = 0d0\n    do i = 1, 3\n      interval = (first_point_coord(i) - second_point_coord(i)) ** 2 + interval\n    end do\n  end function flatten_method\n"}, {"instruction": "Create a Fortran function named gettmu to calculate the value of t/mu in a cell. The function takes 3 input parameters of type real(kind=8), real(kind=8), and logical, and returns 1 output parameter of type real(kind=8).", "input": "", "output": "elemental function gettmu(rho, p, subpol)\n\n! calculate t/mu in cell\n! all in arguments are in user units and the result is in kelvin.\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::rho, p\n  logical,intent(in)::subpol\n  real(kind=8)::gettmu\n!-------------------------------------------------------------------------\n  gettmu = p/rho * unit_t2\n  if(subpol) gettmu = gettmu - t2_star*(rho*unit_nh/n_star)**(g_star-1d0)\nend function gettmu\n"}, {"instruction": "Create a Fortran function named ispolytrope to determine whether cells are polytropic or not based on the given input of density and pressure. The number of input arguments is 2, both of type real(kind=8). The number of output arguments is 1 of type real(kind=8).", "input": "", "output": "elemental function ispolytrope(rho, p)\n\n! calculate whether cells are polytropic (1.) or not (0.)\n! all in arguments are in user units\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::rho, p\n  real(kind=8)::ispolytrope\n  real(kind=8)::t2min,t2\n!-------------------------------------------------------------------------\n  t2min = t2_star*(rho*unit_nh/n_star)**(g_star-1.) + 10.d0\n  t2 = p/rho*unit_t2\n  ispolytrope=0.\n  if(t2 .lt. t2min) ispolytrope=1.\nend function ispolytrope\n"}, {"instruction": "Write a Fortran function named get_alphaa_hii to calculate the case A recombination coefficient for HII (Hui & Gnedin'97). The function takes 1 input parameter of type real(kind=8) representing temperature [K]. It returns 1 output parameter of type real(kind=8) representing the recombination coefficient [cm3 s-1].", "input": "", "output": "elemental function get_alphaa_hii(tk)\n\n! returns case a rec. coefficient [cm3 s-1] for hii (hui&gnedin'97)\n! tk           => temperature [k]\n!------------------------------------------------------------------------\n  real(kind=8),intent(in)::tk\n  real(kind=8)::get_alphaa_hii, lambda\n!------------------------------------------------------------------------\n  lambda = 315614./tk\n  get_alphaa_hii =  1.269d-13 * lambda**1.503 &\n                     / ( ( 1.d0+(lambda/0.522)**0.47 )**1.923 )\nend function get_alphaa_hii\n"}, {"instruction": "Create a Fortran function named get_collexrate_hi that computes the collisional excitation rate coefficient for the 1->2 transition in hydrogen atom energies. The input parameter should be a real number (kind=8) representing the temperature in Kelvin. The function should return a real number (kind=8) representing the collisional excitation rate coefficient in [cm3 s-1].", "input": "", "output": "elemental function get_collexrate_hi(tk)\n\n! gives collisional excitation rate coefficient for the 1->2\n! transition in hydrogen atom energies, in [cm3 s-1], according to\n! callaway, unnikrishnan & oza 1987.\n! tk      => temperatue in kelvin\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::tk\n  real(kind=8)::get_collexrate_hi\n!-------------------------------------------------------------------------\n  get_collexrate_hi =                                                   &\n       2.41d-6/sqrt(tk) * (tk/1.d4)**0.22 * exp(-1.63d-11/(kb*tk))\nend function get_collexrate_hi\n"}, {"instruction": "Create a Fortran function named getcpyy to compute the yy element of the Eddington tensor in code units. The function takes 3 input arguments of type real(kind=8) - ce, fx, and fy. It returns a single output of type real(kind=8).", "input": "", "output": "elemental function getcpyy(ce, fx, fy)\n\n! returns yy element of the eddington tensor (in code units)\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::ce, fx, fy\n  real(kind=8)::getcpyy\n  real(kind=8)::chi, fred, fmag, nbold\n!-------------------------------------------------------------------------\n  fmag = sqrt( fx**2 + fy**2 )\n  fred = fmag/ce\n  chi = (3d0 + 4d0*fred**2)/(5d0+2d0*sqrt(4d0-3d0*fred**2))\n  nbold = fy / fmag\n  getcpyy = (1d0-chi)/2d0 + (3d0*chi-1d0)/2d0 * nbold**2\n  getcpyy = getcpyy * ce\nend function getcpyy\n"}, {"instruction": "Create a Fortran function named sgnint to determine the sign of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameter data types are ['integer'].", "input": "", "output": "function sgnint(i) result(sgn)\nimplicit none\ninteger:: i, sgn\nif (i>0) then\n\tsgn = 1\nelse if (i<0) then\n\tsgn = -1\nelse\n\tsgn = 0\nendif\nend function sgnint\n"}, {"instruction": "Create a Fortran function named integral_single that calculates the value of a single-variable integral. The function takes 5 input parameters of type double precision and logical, and returns 1 output parameter of type double precision. The input parameters are p, q, v, x0, and approx, and the output parameter is integral_single. The function computes the value of the integral based on the input parameters and the logical condition.", "input": "", "output": "function integral_single( p,q , v , x0, approx )\n    double precision :: p,q\n    double precision :: x0\n    double precision :: v\n    logical , intent(in) :: approx \n    double precision :: r1, r2\n    double precision, parameter        :: pi=3.1415926535897932384d0\n    double precision :: integral_single\n    r1=0.5d0*( pi/v )**0.5d0\n    if (approx .eqv. .true. ) then\n        r2=2.d0\n    else \n        r2=erf(  ( q-x0 )*(v )**0.5d0  ) - erf(  ( p-x0)*( v)**0.5d0 )    \n    end if\n    integral_single=r1*r2\nend function integral_single\n"}, {"instruction": "Create a Fortran function named juliandateisinbetween to determine if a Julian date falls between two other Julian dates. The function takes 4 input parameters of types real(8), real(8), real(8), and logical, with the last one being optional. It returns 1 output parameter of type logical. When called, the function checks if the first Julian date is between the second and third Julian dates, and sets the optional logical output parameter to indicate if the first Julian date is less than or equal to the second Julian date.", "input": "", "output": "  function juliandateisinbetween(juliandate,juliandate1,juliandate2,lessthanjuliandate1) result(isinbetween)\n    real(8),intent(in)           :: juliandate,juliandate1,juliandate2\n    logical,optional,intent(out) :: lessthanjuliandate1\n    logical                      :: isinbetween\n\n    isinbetween = .false.\n    if (juliandate.le.juliandate1                                  .or.  &\n        (juliandate.gt.juliandate1 .and. juliandate.le.juliandate2)    ) &\n      isinbetween = .true.\n    if (present(lessthanjuliandate1)) then\n      lessthanjuliandate1 = .false.\n      if (juliandate.le.juliandate1) lessthanjuliandate1 = .true.\n    end if\n\n  end function juliandateisinbetween\n"}, {"instruction": "Write a Fortran function named ranfb that generates a random floating-point number using a linear congruential generator algorithm. The function should accept 1 input parameter of type integer and return 1 output parameter of type real. The input parameter represents the seed for the random number generator.", "input": "", "output": "function ranfb(ix)\n  real :: y,ranfb\n  integer :: ix,ix1,ix2,ia1,ia2,ic,j1,j2,j3\n\n  ia1=273\n  ia2=25301\n  ic=226908345\n  \n  if (ix.lt.0) ix=-ix\n  if (ix.gt.2**30) ix=mod(ix,2**30)\n\n  ix1=ix/(2**15)\n  ix2=ix-ix1*(2**15)\n  j1=mod(ix1*ia2,2**15)*2**15\n  j2=mod(ix2*ia1,2**15)*2**15\n  j3=ix2*ia2\n  ix=mod(j1+j2,2**30)\n  ix=mod(ix+j3,2**30)\n  ix=mod(ix+ic,2**30)\n  y=float(ix)\n\n  ranfb=y/2**30\n\nend function\n"}, {"instruction": "Write a Fortran function named derivs_1g to compute the derivative of a function, which is defined by the equation g - k * x, where g and k are constants. The function accepts 2 input parameters of type double precision: t and x. It returns 1 output parameter of type double precision.", "input": "", "output": "function derivs_1g(t, x)\n  implicit none\n  double precision :: derivs_1g\n  double precision,intent(in) :: t, x\n  double precision ::  g = (50.d0), k = (0.1d0)\n  \n  derivs_1g = g - k * x\n  \nend function derivs_1g\n"}, {"instruction": "Create a Fortran function named get_length to calculate the length of a sequence based on the input number. The input parameter is an integer. The output parameter is also an integer.", "input": "", "output": "    function get_length(number)\n        integer, intent(in) :: number\n\n        integer :: get_length\n        integer*8 :: value\n\n        ! initial value\n        get_length = 1\n        value      = number\n\n        do while (value .gt. 1)\n            if (mod(value, 2) .eq. 0) then\n                value = value / 2\n            else\n                value = (value * 3) + 1\n            end if\n\n            get_length = get_length + 1\n        end do\n    end function\n"}, {"instruction": "Write a Fortran function named u to compute the value of the equation u = x^2 + x*y - 10. The function should take 2 input arguments of type real and return 1 output argument of type real.", "input": "", "output": "function u(x, y) !primera ecuaci\u00f3n\n  implicit none\n  real::x, y, u\n  u=x**2+x*y-10\nend function u\n"}, {"instruction": "Create a Fortran function called pux to calculate the partial derivative of a function u with respect to the variable x. The function takes 2 real input parameters and returns a real output parameter. The input parameters should be provided as a list of real values, and the output parameter will also be a real value.", "input": "", "output": "function pux(x, y) !derivada parcial de u con respecto a x\n  implicit none\n  real::x, y, pux\n  pux=2*x+y\nend function pux\n"}, {"instruction": "Write a Fortran function named \"puy\" to calculate the partial derivative of a function \"u\" with respect to the variable \"y\". The function should take 2 input arguments of type real, and return 1 output argument of type real.", "input": "", "output": "function puy(x, y) !derivada parcial de u con respecto a y\n  implicit none\n  real::x, y, puy\n  puy=x\nend function puy\n"}, {"instruction": "Write a Fortran function named v to calculate the value of an equation. The function takes 2 input parameters of type real. The test_data type is ['real', 'real']. It returns 1 output parameter of type real. The test_data type is ['real'].", "input": "", "output": "function v(x, y) !segunda ecuaci\u00f3n\n  implicit none\n  real::x, y, v\n  v=y+3*x*y**2-57\nend function v\n"}, {"instruction": "Create a Fortran function named pvx to calculate the partial derivative of v with respect to x. This function takes 2 real input parameters and returns 1 real output parameter. The input parameters are of type real and real, and the output parameter is of type real.", "input": "", "output": "function pvx(x, y) !derivada parcial de v con respecto a x\n  implicit none\n  real::x, y, pvx\n  pvx=3*x**2\nend function pvx\n"}, {"instruction": "Create a Fortran function named pvy to compute the partial derivative of v with respect to y. The function takes 2 input arguments of type real and returns 1 output argument of type real. The test_data types for input are [real, real] and for output is [real].", "input": "", "output": "function pvy(x, y) !derivada parcial de v con respecto a y\n  implicit none\n  real::x, y, pvy\n  pvy=1+6*x*y\nend function pvy\n"}, {"instruction": "Write a Fortran function named tlcl to compute the temperature of the lifting condensation level (Tlcl) using Bolton's equation. The function takes 2 input parameters of type real (rh and t) and returns 1 output parameter of type real (tlcl). Ensure the function uses the imperative tone in the instructions.", "input": "", "output": "  function tlcl(t,rh)\n\n    ! computes the temperature of the lifting condensation level\n    ! given surface t and rh using bolton's equation (mwr 1980, p 1048, #22)\n\n    implicit none\n    real                               :: denom\n    real, intent(in)                   :: rh\n    real, intent(in)                   :: t\n    real                               :: term1\n    real                               :: term2\n    real                               :: tlcl\n\n    term1 = 1.0 / (t-55.0)\n    term2 = alog(rh/1.0)/2840.\n    denom = term1 - term2\n    tlcl = (1.0/denom) + 55.0\n\n  end function tlcl\n"}, {"instruction": "Create a Fortran function named celsius that takes a single real number as input to convert Fahrenheit to Celsius. The input parameter is of type real, and the output parameter is of type real.", "input": "", "output": "  function celsius(tf)\n\n    implicit none\n    real, intent(in)             :: tf\n    real                         :: celsius\n    ! converts fahrenheit to celsius\n\n    celsius = (5./9.) * (tf - 32.0)\n\n  end function celsius\n"}, {"instruction": "Write a Fortran function named wspd to calculate the wind speed from the u and v components. The function takes 2 input parameters of type real, u and v, and returns 1 output parameter of type real.", "input": "", "output": "  function wspd(u,v)\n\n    ! computes wind velocity from u/v components\n    implicit none\n    real, intent(in)        :: u\n    real, intent(in)        :: v\n    real                    :: wspd\n\n    wspd = sqrt ( (u*u) + (v*v) )\n  end function wspd\n"}, {"instruction": "Write a Fortran function named char1 that takes an array of characters as input and returns a single character string. The input parameter is of type character, dimension(:), and the output parameter is of type character(len=size(s)).", "input": "", "output": "function char1 (s) result(res)\n  character, dimension(:), intent(in) :: s\n  character(len=size(s)) :: res\n  do i = 1, size(s)\n    res(i:i) = s(i)\n  end do\nend function char1\n"}, {"instruction": "Create a Fortran function named identity to generate an identity matrix of size n by n. The input parameter is an integer (n), and the output parameter is a real matrix of dimensions (n,n).", "input": "", "output": "  function identity(n) result(b) ! return identity matrix\n    integer, intent(in) :: n\n    real, dimension(n,n) :: b\n    integer :: i\n    b = 0\n    do i=1, n\n       b(i,i) = 1\n    end do\n  end function identity\n"}, {"instruction": "Create a Fortran function named b3hs_hash_key_jenkins to hash a given key using the Jenkins algorithm. The function takes 2 input parameters of type character(*) and integer, and returns 1 output parameter of type integer. The function computes the hash code for the given key using the Jenkins algorithm described by Bob Jenkins at the specified URL. The range parameter should be a power of 2, and the 32-bit algorithm is used.", "input": "", "output": "function b3hs_hash_key_jenkins (key, range) result (code)\n  integer, parameter       :: kind_i32 = selected_int_kind(10)\n  character(*), intent(in) :: key\n  integer, intent(in)      :: range\n  integer                  :: code\n\n  integer                  :: len_key\n  integer(kind_i32)        :: a\n  integer(kind_i32)        :: b\n  integer(kind_i32)        :: c\n  integer                  :: c_i\n  integer                  :: k\n\n! hash the key into a code, using the algorithm\n! described by bob jenkins at:\n!  http://burtleburtle.net/bob/hash/doobs.html\n!\n! note that range should be a power of 2, and\n! that the 32-bit algorithm is used\n\n  len_key = len_trim(key)\n\n  a = -1640531527_kind_i32 ! 0x9e3779b9\n  b = a\n  c = 305419896_kind_i32   ! 0x12345678\n\n  k = 1\n\n  char_loop : do\n\n     if(len_key < 12) exit char_loop\n\n! pack the key into 32 bits\n\n     a = a + ichar(key(k+0:k+0))  + ishft(ichar(key(k+1:k+1)), 8) + &\n     &       ishft(ichar(key(k+2:k+2)), 16) + ishft(ichar(key(k+3:k+3)), 24)\n     b = b + ichar(key(k+4:k+4))  + ishft(ichar(key(k+5:k+5)), 8) + &\n     &       ishft(ichar(key(k+6:k+6)), 16) + ishft(ichar(key(k+7:k+7)), 24)\n     c = c + ichar(key(k+8:k+8))  + ishft(ichar(key(k+9:k+9)), 8) + &\n     &       ishft(ichar(key(k+10:k+10)), 16) + ishft(ichar(key(k+11:k+11)), 24)\n\n! mix it up\n\n     call b3hs_hash_key_jenkins_mix_()\n\n     k = k + 12\n\n     len_key = len_key - 12\n\n  end do char_loop\n\n  c = c + len_key\n\n! process remaining bits\n\n  select case(len_key)\n  case(11)\n     c = c + ishft(ichar(key(k+10:k+10)), 24) + ishft(ichar(key(k+9:k+9)), 16) + &\n     &       ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(10)\n     c = c + ishft(ichar(key(k+9:k+9)), 16) + ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(9)\n     c = c + ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(7)\n     b = b + ishft(ichar(key(k+6:k+6)), 16) + ishft(ichar(key(k+5:k+5)), 8) + &\n     &       ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(6)\n     b = b + ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(5)\n     b = b + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(4)\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(3)\n     a = a + ishft(ichar(key(k+2:k+2)), 16) + ishft(ichar(key(k+1:k+1)), 8) + &\n     &       ichar(key(k:k))\n  case(2)\n     a = a + ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(1)\n     a = a + ichar(key(k:k))\n  end select\n\n  call b3hs_hash_key_jenkins_mix_()\n\n  c_i = int(c)\n  code = iand(c_i, range - 1) + 1\n\n! finish\n\n  return\n\ncontains\n\n  subroutine b3hs_hash_key_jenkins_mix_\n\n! mix a, b and c\n\n    a = ieor(a - b - c, ishft(c, -13))\n    b = ieor(b - c - a, ishft(a, 8))\n    c = ieor(c - a - b, ishft(b, -13))\n\n    a = ieor(a - b - c, ishft(c, -12))\n    b = ieor(b - c - a, ishft(a, 16))\n    c = ieor(c - a - b, ishft(b, -5))\n\n    a = ieor(a - b - c, ishft(c, -3))\n    b = ieor(b - c - a, ishft(a, 10))\n    c = ieor(c - a - b, ishft(b, -15))\n\n! finish\n\n    return\n\n  end subroutine b3hs_hash_key_jenkins_mix_\n\nend function b3hs_hash_key_jenkins\n"}, {"instruction": "Create a Fortran function named f that takes a single input parameter of type real, dimension(1:3,1:3). The function should return a single output parameter of type real. The purpose of the function is to calculate the determinant of a 3x3 matrix using the given input matrix.", "input": "", "output": "    function f(a)\n      implicit none\n        real :: f\n        real, intent(in), dimension(1:3,1:3) :: a\n        \n          f=a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))-a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))+a(1,3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))   \n    end function f\n"}, {"instruction": "Create a Fortran function named c to calculate the cofactor matrix of a given 3x3 input matrix. The input parameter is a 3x3 matrix of real numbers, and the output is the 3x3 cofactor matrix of real numbers.", "input": "", "output": "    function c(a)\n      implicit none\n        real, dimension(1:3,1:3) :: c,co\n        real, intent(in), dimension(1:3,1:3) :: a\n        \n          co(1,1)=(-1)**(1+1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))\n          co(1,2)=(-1)**(1+2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\n          co(1,3)=(-1)**(1+3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))\n          co(2,1)=(-1)**(2+1)*(a(1,2)*a(3,3)-a(1,3)*a(3,2))\n          co(2,2)=(-1)**(2+2)*(a(1,1)*a(3,3)-a(1,3)*a(3,1))\n          co(2,3)=(-1)**(2+3)*(a(1,1)*a(3,2)-a(1,2)*a(3,1))\n          co(3,1)=(-1)**(3+1)*(a(1,2)*a(2,3)-a(1,3)*a(2,2))\n          co(3,2)=(-1)**(3+2)*(a(1,1)*a(2,3)-a(1,3)*a(2,1))\n          co(3,3)=(-1)**(3+3)*(a(1,1)*a(2,2)-a(1,2)*a(2,1))    \n      \n          c=transpose(co)\n    end function c\n"}, {"instruction": "Create a Fortran function named \"largest\" to find the largest value in an array of real numbers. The function should have 1 input parameter of type real array with unspecified size and intent \"in\" and \"target\". The output parameter should be of type real and intent \"pointer\".", "input": "", "output": "function largest(arr) result(value)\nimplicit none\nreal, dimension(:), intent(in), target :: arr\nreal, pointer :: value\ninteger :: i\nnullify(value)\nallocate(value)\nvalue => arr(1)\ndo i = 2, size(arr)\n  if (arr(i) > value) then\n    value => arr(i)\n  end if\nend do\nend function largest\n"}, {"instruction": "Write a Fortran function named round_scalar that rounds a floating-point number to a specified number of decimal digits. The function takes 2 input parameters with test_data type ['real(8)', 'integer'] and returns 1 output parameter with test_data type ['real(8)'].", "input": "", "output": "      function round_scalar(fnumb, idigits) result(res)\n      ! rounds fnumb to idigits decimal digits (scalar)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(in)  :: fnumb\n         integer, intent(in)  :: idigits\n         real(8)  :: res\n         \n         !### var ###!\n         integer :: imuldiv\n         \n         !### code ###!\n         imuldiv = 10 ** idigits\n         res = real(int(fnumb * imuldiv + 0.5d0),8) / imuldiv\n         \n      end function\n"}, {"instruction": "Write a Fortran function named nearby that checks if a given real number is within a specified distance from a range defined by two other real numbers. The number of input arguments is 3 and the test_data type is [real*8, real*8, real*8]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "      function nearby(a,b,bola)\n      implicit none\n      real*8, intent(in) :: a,b,bola\n      logical :: nearby\n      nearby = .false.\n      if ((b-bola .le. a) .and. (a .le. b+bola)) then\n        nearby = .true.\n      end if\n!     print*, b-bola, \"<=\", a, \"<=\",b+bola ,\" :: \", nearby\n      end function nearby\n"}, {"instruction": "Provide a Fortran function named to_s_int_ to convert an integer to a string. The function takes 1 input argument of type integer and returns 1 output argument of type character(len=500).", "input": "", "output": "  function to_s_int_ (value)\n    implicit none\n    character(len=500):: to_s_int_\n    integer, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_int_ = adjustl(trim(result))\n  end function to_s_int_\n"}, {"instruction": "Create a Fortran function named strip_ that takes a character string as input and returns a modified string with leading and trailing spaces removed. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type character(len=500).", "input": "", "output": "  function strip_(value)\n    implicit none\n    character(len=500):: strip_\n    character(len=*), intent(in) :: value\n    strip_ = trim(adjustl(value))\n  end function strip_\n"}, {"instruction": "Write a Fortran function named strip_length_ that takes an input string and an integer length. The input parameters are of type character(len=*) and integer respectively, and the output parameter is of type character(len= length). This function trims the input string and adjusts the length to the specified value.", "input": "", "output": "  function strip_length_(value, length)\n    implicit none\n    character(len=*), intent(in) :: value\n    integer, intent(in) :: length\n    character(len= length):: strip_length_\n    strip_length_ = trim(adjustl(value))\n  end function strip_length_\n"}, {"instruction": "Create a Fortran function named \"integerequal\" to compare two integer numbers and return a logical value indicating whether they are equal or not. The function should accept 2 integer input parameters and return 1 logical output parameter. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['logical'].", "input": "", "output": "  function integerequal (number1, number2 ) result (resultvalue)\n    integer , intent (in) :: number1, number2\n    logical :: resultvalue \n\n    resultvalue = .false.\n\n    if ( number1 .eq. number2 ) then\n       resultvalue = .true.\n    else \n       resultvalue = .false.\n    end if\n  end function integerequal\n"}, {"instruction": "Create a Fortran function named stringequal to compare two strings and return a logical value to indicate whether they are equal. The number of input arguments is 2 and the test_data type is ['character(*) ', 'character(*) ']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "  function stringequal (str1, str2 ) result (resultvalue)\n    character(*) , intent (in) :: str1, str2\n    logical :: resultvalue \n\n    resultvalue = .false.\n\n    if ( str1 .eq. str2 ) then\n       resultvalue = .true.\n    end if\n  end function stringequal\n"}, {"instruction": "Create a Fortran function named legendrep to calculate the value of the nth order Legendre polynomial at a given real value x. The function takes 2 input parameters of type real (kind=8) and integer, and returns 1 output parameter of type real (kind=8).", "input": "", "output": "function legendrep(n,x) result(fac)\n    !implicit none\n    real (kind=8) :: fac\n    real (kind=8), intent(in) :: x\n    integer, intent(in) :: n\n    real (kind=8), dimension(n+1) :: poly\n    integer :: i\n\n    select case (n)\n        case (0)\n        poly(1) = 1\n        fac = poly(1)\n\n        case (1)\n        poly(2) = x\n        fac = poly(2)\n\n        case default\n        poly(1) = 1\n        poly(2) = x\n    end select\n\n    do i=3,n+1\n        poly(i) = ((2*(i-1)-1)*x*poly(i-1) - (i-2)*poly(i-2))/(i-1)\n    end do\n    fac = poly(n+1)\nend function legendrep\n"}, {"instruction": "Create a Fortran function named g to calculate the Gaussian term. The function takes 2 input parameters of type real(kind=8) and returns 1 output parameter of type real(kind=8). The input parameters are v and v0, and the output parameter is g. The function computes g as the exponential of -(v/v0)^2d0.", "input": "", "output": "    function g(v, v0)\n        ! gaussian term\n        \n        implicit none\n\n        real(kind=8), intent(in) :: v\n        real(kind=8), intent(in) :: v0\n        real(kind=8) :: g\n\n        g = exp(-(v/v0)**2d0) \n\n    end function\n"}, {"instruction": "Create a Fortran function named remove_temp_files to generate a command that deletes temporary files based on the input filename. The function takes 1 input parameter of type character(len=*), and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    function remove_temp_files(fname) result (cmd)\n        implicit none\n        character(len=*) :: fname\n        character(len=:), allocatable :: plt\n        character(len=:), allocatable :: dat\n        character(len=:), allocatable :: cmd\n\n        plt = 'plot/'//fname//'*.plt'\n        dat = 'plot/'//fname//'*.dat'\n\n        cmd = 'rm '//plt//' '//dat\n        return\n    end function\n"}, {"instruction": "Create a Fortran function named plot_fname that takes a character string as input and returns another character string. The input parameter has a test_data type of ['character(len=*)'], and the output parameter has a test_data type of ['character(len=:), allocatable']. This function concatenates the input string with 'plot/' and '.plt' to create a file path and returns it.", "input": "", "output": "    function plot_fname(fname) result (path)\n        implicit none\n        character(len=*) :: fname\n        character(len=:), allocatable :: path\n        path = 'plot/'//fname//'.plt'\n        return\n    end function\n"}, {"instruction": "Write a Fortran function named \"predicate\" to determine if a certain mathematical predicate is true or false. The function takes 2 input parameters of type integer and returns 1 output parameter of type logical. The input parameters are n and r, and the output parameter is predicate.", "input": "", "output": "  function predicate(n,r)\n    implicit none\n    integer, intent(in) :: n, r\n    integer             :: i\n    double precision    :: temp\n    logical             :: predicate\n\n    predicate=.false.\n    temp=1.0\n    do i=1,r\n       temp=temp*(n-(r-i)) ! gets larger\n       temp=temp/(r-i+1)   ! gets smaller\n       if (temp>1000000.0) then\n          predicate=.true.\n          exit\n       end if\n    end do\n    \n  end function predicate\n"}, {"instruction": "Create a Fortran function named is_sorted to determine if an array of real numbers is sorted in ascending order. The function should take 1 input parameter of type real, dimension(:), and return 1 output parameter of type logical. The function should use the imperative tone.", "input": "", "output": "    function is_sorted(values) result(sorted_value)\n        implicit none\n        real, dimension(:), intent(in) :: values\n        logical :: sorted_value\n        integer :: i\n\n        sorted_value = .true.\n        do i = 2, size(values)\n            if (values(i) < values(i - 1)) then\n                sorted_value = .false.\n                exit\n            end if\n        end do\n    end function is_sorted\n"}, {"instruction": "Write a Fortran function named pad that takes 3 input arguments of type integer, dimension(:), integer, and integer. The function returns 1 output argument of type integer, dimension(max(len, size(a))). The function pads the input array with the specified initial value to match the specified length.", "input": "", "output": "    pure function pad(a, initval, len)\n        integer, intent(in), dimension(:) :: a\n        integer, intent(in) :: initval, len\n        integer, dimension(max(len, size(a))) :: pad\n        integer :: i\n\n        pad = initval\n\n        ! copy whatever is possible from a\n        do i=1, size(a)\n            pad(i) = a(i)\n        end do\n    end function pad\n"}, {"instruction": "Create a Fortran function named outerproduct that takes a single real number as input. The function is designed to calculate the outer product of the input real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function outerproduct(a)\nimplicit none\nreal, intent(in) :: a\nreal :: outerproduct\n    outerproduct = 0.\nend function outerproduct\n"}, {"instruction": "Create a Fortran function named comm_create_group that takes 3 integer inputs (ngid, nprocs, key) and returns an integer output (ngid_dst). The function computes ngid_dst as the sum of ngid and the product of key and nprocs.", "input": "", "output": "  function comm_create_group(ngid, nprocs, key) result(ngid_dst)\n    implicit none\n    integer, intent(in) :: ngid, nprocs, key\n    integer :: ngid_dst\n    ngid_dst = ngid + key * nprocs\n  end function\n"}, {"instruction": "Create a Fortran function called number_of_lines_in_file to determine the number of lines in a given file. The function takes 1 input parameter of type integer (assumed to be the file unit number) and returns 1 output parameter of type integer representing the number of lines in the file.", "input": "", "output": "    function number_of_lines_in_file(iunit) result(n_lines)\n\n    implicit none\n\n    integer,intent(in)  :: iunit   !! the file unit number\n                                     !! (assumed to be open)\n    integer :: n_lines   !! the number of lines in the file\n\n    character(len=1) :: tmp\n    integer :: istat\n\n    rewind(iunit)\n    n_lines = 0\n    do\n        read(iunit,fmt='(a1)',iostat=istat) tmp\n        if (is_iostat_end(istat)) exit\n        n_lines = n_lines + 1\n    end do\n    rewind(iunit)\n\n    end function number_of_lines_in_file\n"}, {"instruction": "Create a Fortran function named couple_global_id that takes 3 integer input parameters (iorb, jorb, norb) and returns 1 integer output parameter. The test_data type for the input parameters is ['integer', 'integer', 'integer'], and for the output parameter is ['integer']. The function computes a global identifier based on the input parameters and assigns the result to the output parameter, id.", "input": "", "output": "      function couple_global_id(iorb,jorb,norb) result(id)\n        implicit none\n        integer, intent(in) :: iorb,jorb,norb\n        integer :: id\n        !local variables\n        integer :: ii,jj\n        ii=max(iorb,jorb)\n        jj=min(iorb,jorb)\n\n        if (ii > norb .or. jj > norb) then\n           print *,'error',ii,jj,norb\n           stop\n        end if\n        \n        id=ii+(jj-1)*norb\n      end function couple_global_id\n"}, {"instruction": "Write a Fortran function named couple_global_id that takes 3 input arguments of type integer: iorb, jorb, and norb. It produces 1 output argument of type integer. The purpose of the function is to compute the global identifier 'id' based on the input arguments. The function uses the imperative style to define the function and perform the necessary calculations.", "input": "", "output": "      pure function couple_global_id(iorb,jorb,norb) result(id)\n        implicit none\n        integer, intent(in) :: iorb,jorb,norb\n        integer :: id\n        !local variables\n        integer :: ii,jj\n        ii=max(iorb,jorb)\n        jj=min(iorb,jorb)\n        id=ii+(jj-1)*norb\n      end function couple_global_id\n"}, {"instruction": "Create a Fortran function named to_rna that transforms a given DNA sequence into its corresponding RNA sequence. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(dna)).", "input": "", "output": "  function to_rna(dna)\n      character(*) :: dna\n      character(len(dna)) :: to_rna\n      integer :: i\n\n      do i = 1,len(dna)\n        select case (dna(i:i))\n            case ('g')\n                to_rna(i:i) = 'c'\n            case ('c')\n                to_rna(i:i) = 'g'\n            case ('t')\n                to_rna(i:i) = 'a'\n            case ('a')\n                to_rna(i:i) = 'u'\n            case default\n                to_rna = ''\n                return\n        end select\n      end do\n\n  end function to_rna\n"}, {"instruction": "Create a Fortran function named loggamma that takes a single input parameter of type double precision and returns a value of type double precision.The function computes the logarithm of the gamma function.", "input": "", "output": "  function loggamma(s)\n    double precision, intent(in) :: s\n    double precision :: loggamma\n    double precision :: x, v, w\n    x = s\n    v = 1.0d0\n    do while (x < cn)\n       v = v * x\n       x = x + 1.0d0\n    end do\n    w = 1.0d0 / (x * x)\n    loggamma = ((((((((b16 / (16.0d0 * 15.0d0)) * w &\n         + (b14 / (14.0d0 * 13.0d0))) * w &\n         + (b12 / (12.0d0 * 11.0d0))) * w &\n         + (b10 / (10.0d0 * 9.0d0))) * w &\n         + (b8 / (8.0d0 * 7.0d0))) * w &\n         + (b6 / (6.0d0 * 5.0d0))) * w &\n         + (b4 / (4.0d0 * 3.0d0))) * w &\n         + (b2 / (2.0d0 * 1.0d0))) / x &\n         + 0.5d0 * log2pi - log(v) - x + (x - 0.5d0) * log(x)\n    return\n  end function loggamma\n"}, {"instruction": "Create a Fortran function named \"psi\" that takes a double precision input parameter \"s\" and returns a double precision output. The function computes the psi (digamma) function for the input parameter \"s\" using a series expansion and logarithm calculation. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function psi(s)\n    double precision, intent(in) :: s\n    double precision :: psi\n    double precision :: x, v, w\n    x = s\n    v = 0.0d0\n    do while (x < cn)\n       v = v + 1.0d0 / x\n       x = x + 1.0d0\n    end do\n    w = 1.0d0 / (x * x)\n    v = v + ((((((((b16 / 16.0d0) * w &\n         + (b14 / 14.0d0)) * w &\n         + (b12 / 12.0d0)) * w &\n         + (b10 / 10.0d0)) * w &\n         + (b8 / 8.0d0)) * w &\n         + (b6 / 6.0d0)) * w &\n         + (b4 / 4.0d0)) * w &\n         + (b2 / 2.0d0)) * w &\n         + 0.5d0 / x\n    psi = log(x) - v\n  end function psi\n"}, {"instruction": "Create a Fortran function named polygamma to calculate the polygamma function. The function takes 2 input parameters of type integer and double precision. The output is a single value of type double precision.", "input": "", "output": "  function polygamma(n, s)\n    integer, intent(in) :: n\n    double precision, intent(in) :: s\n    double precision :: polygamma\n    integer :: k\n    double precision :: x, t, u, v, w\n    x = s\n    u = 1.0d0\n    do k = 1-n, -1\n       u = u * k\n    end do\n    v = 0.0d0\n    do while (x < cn)\n       v = v + 1.0d0 / x**(n+1)\n       x = x + 1.0d0\n    end do\n    w = x * x\n    t = (((((((b16 &\n         * (n + 15.0d0) * (n + 14.0d0) / (16.0d0 * 15.0d0 * w) + b14) &\n         * (n + 13.0d0) * (n + 12.0d0) / (14.0d0 * 13.0d0 * w) + b12) &\n         * (n + 11.0d0) * (n + 10.0d0) / (12.0d0 * 11.0d0 * w) + b10) &\n         * (n +  9.0d0) * (n +  8.0d0) / (10.0d0 *  9.0d0 * w) + b8) &\n         * (n +  7.0d0) * (n +  6.0d0) / ( 8.0d0 *  7.0d0 * w) + b6) &\n         * (n +  5.0d0) * (n +  4.0d0) / ( 6.0d0 *  5.0d0 * w) + b4) &\n         * (n +  3.0d0) * (n +  2.0d0) / ( 4.0d0 *  3.0d0 * w) + b2) &\n         * (n +  1.0d0) * n / (2.0d0 * 1.0d0 * w) + 0.5d0 * n / x + 1.0d0\n    polygamma = u * (t / x**n + n*v)\n  end function polygamma\n"}, {"instruction": "Create a Fortran function named file_size to retrieve the size of a file in bytes. The function takes 1 input argument of type character(len=*) to specify the filename and returns 1 output argument of type integer to store the file size.", "input": "", "output": "function file_size(filename) !! file size (in bytes)\ncharacter(len=*), intent(in) :: filename\ninteger  :: file_size, fstat_buff(13), status\n!! through compiler flag -d_gnuf90_, if using gnu compiler:\n#ifdef _gnuf90_\n  call stat(filename, fstat_buff, status)\n  file_size = fstat_buff(8)\n  if (status /= 0)  file_size = 0  ! file doesn't exist\n#else\n  inquire(file=filename, size=file_size)  \n  if (file_size < 0)  file_size = 0\n#endif\nend function\n"}, {"instruction": "Write a Fortran function named incr2 that takes an integer input and returns an integer output. The number of input parameters is 1, and the test_data type is ['integer(c_int), value']. The number of output parameters is 1, and the test_data type is ['integer(c_int)']. The function adds 20 to the input integer and returns the result.", "input": "", "output": "function incr2(input) bind(c)\n  use iso_c_binding\n  implicit none\n  integer(c_int), value :: input\n  integer(c_int) :: incr2\n  incr2 = input + 20\nend function incr2\n"}, {"instruction": "Write a Fortran function named optval_ll1 that returns a logical value. This function takes 2 input parameters, where the first input is optional and of type logical, and the second input is of type logical. The output parameter is a single logical value.", "input": "", "output": "    pure elemental function optval_ll1(x, default) result(y)\n    logical, intent(in), optional :: x\n    logical, intent(in) :: default\n    logical :: y\n\n    if (present(x)) then\n       y = x\n    else\n       y = default\n    end if\n  end function optval_ll1\n"}, {"instruction": "Create a pure Fortran function named optval_character to handle optional input arguments for character data types. The number of input arguments is 2, with the test data type ['character(len=*), optional', 'character(len=*)']. The number of output arguments is 1, with the test data type ['character(len=:), allocatable'].", "input": "", "output": "  pure function optval_character(x, default) result(y)\n    character(len=*), intent(in), optional :: x\n    character(len=*), intent(in) :: default\n    character(len=:), allocatable :: y\n\n    if (present(x)) then\n       y = x\n    else\n       y = default\n    end if\n  end function optval_character\n"}, {"instruction": "Create a Fortran function named dbset2dstrlen to handle the setting of 2D string length. The function takes 1 input parameter of type integer and returns an integer as output.", "input": "", "output": "\t\tfunction dbset2dstrlen(len) !! ------------------------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbset2dstrlen\n\t\t\tinteger, intent(in) :: len\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'attempt to set 2d string length is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbset2dstrlen !! -------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbmkoptlist to handle the allocation of an options list. It takes 2 input arguments of type integer: maxopts and optlist_id. It has 1 output argument of type integer. If the allocation of an options list is inconsistent with the use of the silo proxy module, the function will print an error message and exit.", "input": "", "output": "\t\tfunction dbmkoptlist(maxopts, optlist_id) !! ----------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbmkoptlist\n\t\t\tinteger, intent(in) :: maxopts\n\t\t\tinteger, intent(in) :: optlist_id\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'allocation of an options list is inconsistent ' // &\n\t\t\t\t\t\t 'with use of silo proxy module. exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbmkoptlist !! ---------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbaddiopt to add an option to an options list. The function takes 3 input parameters of type integer (optlist_id, option, ivalue) and returns an integer.", "input": "", "output": "\t\tfunction dbaddiopt(optlist_id, option, ivalue) !! -----------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbaddiopt\n\t\t\tinteger, intent(in) :: optlist_id\n\t\t\tinteger, intent(in) :: option\n\t\t\tinteger, intent(in) :: ivalue\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'adding an option to an options list is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbaddiopt !! -----------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbclose that takes an integer input argument. When called, this function will print a message indicating an inconsistency in the use of a silo proxy module and then stop the program. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "\t\tfunction dbclose(dbid) !! -----------------------------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbclose\n\t\t\tinteger, intent(in) :: dbid\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'attempt to close silo-hdf5 database file is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbclose !! -------------------------------------------------\n"}, {"instruction": "Create a Fortran function named get_model_time that takes a single real*8 input argument. Set the input argument \"t\" to the value of \"tday\" and assign a value of 0 to the output integer \"ret\".", "input": "", "output": "function get_model_time(t) result(ret)\n  integer :: ret\n  real*8 :: t\n  t=tday\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_ocean_prev_time to calculate the time difference between two ocean time variables. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function get_ocean_prev_time(t) result(ret)\n  integer :: ret\n  real*8 :: t\n  t=tocean-(tos-tosm)\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named distance_matrix that takes a 2D array of double precision numbers as input. The function computes the distance matrix based on the input coordinates. The number of input parameters is 1, with the test_data type ['double precision, dimension(:,:)']. The function returns an allocatable 2D array of double precision numbers as the distance matrix. The number of output parameters is 1, with the test_data type ['double precision, allocatable, dimension(:,:)'].", "input": "", "output": "function distance_matrix(coords) result(dmat)\n\n    double precision, dimension(:,:), intent(in) :: coords\n\n    double precision, allocatable, dimension(:,:) :: dmat\n\n    integer :: n, i, j\n\n    n = size(coords, dim=1)\n\n    allocate(dmat(n,n))\n\n    do i = 1, n\n        do j = i, n\n\n            dmat(i,j) = norm2(coords(i,:) - coords(j,:))\n            dmat(j,i) = dmat(i,j)\n\n        enddo\n    enddo\n\nend function distance_matrix\n"}, {"instruction": "Create a Fortran function named is_alpha_index that takes a single input argument of type character(len=1) and returns a single output argument of type logical. The function checks if the input character is a lowercase letter, and the result is true if it is, otherwise false.", "input": "", "output": "  pure function is_alpha_index(c) result(res)\n    character(len=1), intent(in) :: c\n    logical :: res\n    res = index( &\n        string = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', &\n        substring = c) > 0\n  end function\n"}, {"instruction": "Create a Fortran function named is_alpha_select to determine if a single character is an alphabet. The function takes 1 input argument of type character(len=1) and returns 1 output argument of type logical. The test_data types are ['character(len=1)'] and ['logical'] respectively.", "input": "", "output": "  pure function is_alpha_select(c) result(res)\n    character(len=1), intent(in) :: c\n    logical :: res\n    select case(iachar(c))\n      case (65:90, 97:122)\n        res = .true.\n      case default\n        res = .false.\n    end select\n  end function\n"}, {"instruction": "Create a Fortran function named horner to perform the Horner's method for polynomial evaluation. The function takes 2 input arguments, where the first argument is a one-dimensional array of real numbers and the second argument is a real number. The function returns a single real number as the result.", "input": "", "output": "  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = 0.0\n    do i = size (coeffs), 1, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n"}, {"instruction": "Create a Fortran function named upper_triangular to compute the upper triangular form of a given matrix. The function takes 1 input parameter of type real with the format dimension(:, :), and returns 1 output parameter of type real with the format dimension(size(mat, 1), size(mat, 2)).", "input": "", "output": "  pure function upper_triangular(mat) result(a_)\n    real, dimension(:, :), intent(in) :: mat\n    real, dimension(size(mat, 1), size(mat, 2)) :: a, a_\n    integer, dimension(size(mat, 2)) :: r  ! row permutation/index set\n    real :: scaling_factor\n    integer :: i, m, n, col, row, row_\n\n    m = size(mat, 2)\n    n = size(mat, 1)\n    a = mat\n\n    row = 1\n    col = 1\n    r = (/(i, i=1,m)/)\n\n    do while (row <= m .and. col <= n)\n      ! find row with highest magnitude in the current column\n      row_ = maxloc(abs(a(col, r(row:))), dim=1) - 1 + row\n\n      if (a(col, r(row_)) == 0.0) then\n        col = col + 1\n        cycle\n      endif\n\n      ! swap rows\n      r([row, row_]) = r([row_, row])\n\n      ! normalize row\n      scaling_factor = a(col, r(row))\n      a(col:, r(row)) = a(col:, r(row)) / scaling_factor\n\n      ! zero the pivot column for remaining rows\n      ! by subtracting off a scaled version of the current row\n      forall (i=row+1:m) a(col+1:, r(i)) = a(col+1:, r(i)) &\n          - a(col, r(i)) * a(col+1:, r(row))\n      a(col, r(row+1:)) = 0.0\n\n      row = row + 1\n      col = col + 1\n    enddo\n\n    ! perform reordering\n    forall (i=1:m) a_(:, i) = a(:, r(i))\n  end function\n"}, {"instruction": "Create a Fortran pure function named substitution to perform matrix substitution using Gaussian elimination. The function takes one input argument of type real, with a 2D array of any size. The output is a 2D array of real numbers with the same dimensions as the input array.", "input": "", "output": "  pure function substitution(mat) result(a)\n    real, dimension(:, :), intent(in) :: mat\n    real, dimension(size(mat, 1), size(mat, 2)) :: a\n    integer :: i, j, m\n\n    m = size(mat, 2)\n    a = mat\n\n    do i = m - 1, 1, -1\n      do j = i + 1, m\n        a(:, i) = a(:, i) - a(j, i) * a(:, j)\n      enddo\n    enddo\n  end function\n"}, {"instruction": "Provide a Fortran function named principal_quantum_number to calculate the principal quantum number based on an input real number. The function takes 1 input argument of type real and returns 1 output argument of type integer.", "input": "", "output": "    function principal_quantum_number(res) result(n_max)\n        implicit none\n        real :: res, tmp_res = 0\n        integer :: i = 0, j, n_max\n        do while (tmp_res<=res)\n            j = i - 2\n            do while (j>=1 .or. j>=0)\n                tmp_res = tmp_res + 2 * j + 1\n                if (tmp_res>res) exit\n                j = j - 2\n            end do\n            i = i + 1\n        end do\n        n_max = i\n    end function principal_quantum_number\n"}, {"instruction": "Create a Fortran function named azimuthal_quantum_number to calculate the azimuthal quantum number (l_max) based on the input values of res and n_max. The number of input arguments is 2, and the test_data type is [real, integer]. The number of output arguments is 1, and the test_data type is [integer].", "input": "", "output": "    function azimuthal_quantum_number(res, n_max) result(l_max)\n        implicit none\n        real :: res, tmp_res, tmp_res1 = 0, tmp_res2 = 0, diff1, diff2\n        integer :: i = 0, q = 0, w = 1, j, n_max, l_max\n        do i = 0, n_max\n            if (i==n_max) then\n                tmp_res1 = tmp_res\n                do while(tmp_res1<res)\n                    tmp_res1 = tmp_res1 + 2 * q + 1\n                    if (tmp_res1 >res) then\n                        exit\n                    end if\n                    q = q + 2\n                end do\n                tmp_res2 = tmp_res\n                do while(tmp_res2<res)\n                    tmp_res2 = tmp_res2 + 2 * w + 1\n                    if (tmp_res2 >res) then\n                        exit\n                    end if\n                    w = w + 2\n                end do\n                diff1 = abs(tmp_res1 - res)\n                diff2 = abs(tmp_res2 - res)\n                if (diff2>diff1) then\n                    l_max = q\n                else\n                    l_max = w\n                end if\n                exit\n            end if\n            j = i - 2\n            do while(j>=0 .or. j>=1)\n                tmp_res = tmp_res + 2 * j + 1\n                j = j - 2\n            end do\n        end do\n    end function azimuthal_quantum_number\n"}, {"instruction": "Write a Fortran function named improve_radius to calculate the improved radius based on the given parameters. The function takes 4 input arguments of type real, real, integer, and integer. The output is a single real value.", "input": "", "output": "    function improve_radius(rs, bor_radius, l_max, n_max) result(radius)\n        implicit none\n        real :: rs, bor_radius, radius\n        integer :: i, j, l_max, n_max, total_quantum = 0\n        do i = 0, n_max\n            if (i==n_max) then\n                j = l_max - 2\n                do while(j>=0 .or. j>=1)\n                    total_quantum = total_quantum + 2 * j + 1\n                    j = j - 2\n                end do\n                exit\n            end if\n            j = i - 2\n            do while(j>=0 .or. j>=1)\n                total_quantum = total_quantum + 2 * j + 1\n                j = j - 2\n            end do\n        end do\n        radius = (total_quantum * rs**3 * bor_radius**3)**(1.0 / 3.0)\n    end function improve_radius\n"}, {"instruction": "Create a Fortran function named comb to calculate the result of a specific mathematical combination equation. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is denoted as intent(in) and the output is denoted as result(r). Use a do loop to iteratively calculate the combination equation, with the final result assigned to the output parameter.", "input": "", "output": "function comb(n) result(r)\n\tinteger, intent(in) :: n\n\tinteger :: r, i\n\t\n\tr = 1\n\tdo i=3,n\n\t\tr = r+(i-1)\n\tend do\n\t\nend function comb\n"}, {"instruction": "Create a Fortran function named nstore_nemlmodel that takes in a single input parameter of type c_ptr and returns an integer.", "input": "", "output": "            function nstore_nemlmodel(model) bind(c)\n                  use iso_c_binding\n                  implicit none\n                  integer :: nstore_nemlmodel\n                  type(c_ptr), value :: model\n            end function\n"}, {"instruction": "Define a Fortran function named alpha_nemlmodel that takes two input parameters, a type(c_ptr) and a double precision value, and returns a double precision value. This function is intended to be used with C interface, as indicated by the \"bind(c)\" attribute.", "input": "", "output": "            function alpha_nemlmodel(model, temperature) bind(c)\n                  use iso_c_binding\n                  implicit none\n                  double precision :: alpha_nemlmodel\n                  type(c_ptr), value :: model\n                  double precision, value :: temperature\n            end function\n"}, {"instruction": "Create a Fortran function named tnx to calculate the value of the nth term in the Taylor series expansion of the trigonometric function tan(x). The function takes 2 input parameters of type real and integer, and returns 1 output parameter of type real.", "input": "", "output": "function tnx(x, n) \n    implicit none\n    real, parameter :: pi = acos(-1.0) \n    real:: x, tnx \n    integer:: n, i\n    real, dimension(0:n):: vector\n    vector(0) = 1\n    vector(1) = x \n    if(n .le. 1) then \n        tnx = vector(n)\n    else\n        do i = 1, n-1 \n            vector(i+1) = 2.0*x*vector(i) - vector(i-1) \n        enddo\n        tnx = vector(n)\n    endif\n    return\nend function tnx\n"}, {"instruction": "Create a Fortran function named optval_int to return the value of an integer option, allowing for an optional input. The function has 2 input parameters of type integer, with the first parameter being optional. The number of input arguments is 2 and the test_data type is ['integer, optional', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function optval_int(opt, default) result(val)\n        integer, intent(inout), optional :: opt\n        integer, intent(in) :: default\n        integer :: val\n\n        if (present(opt)) then\n            val = opt\n        else\n            val = default\n        end if\n\n    end function optval_int\n"}, {"instruction": "Write a Fortran function named addonebv that takes an integer value as input and returns an integer value as output. The input parameter is of type integer with the attribute value. The output parameter is also of type integer. The function adds 1 to the input integer value and assigns the result to the output parameter.", "input": "", "output": "  function addonebv(x) result(y)\n    implicit none\n    integer, value :: x\n    integer :: y\n    x = 8\n    y = x + 1\n  end function addonebv\n"}, {"instruction": "Create a Fortran function named mr_char_string_upper that takes a character string as input and returns the uppercase version of the input string. The number of input arguments is 1 and the test_data type is ['character(   *   ) ']. The number of output arguments is 1 and the test_data type is ['character( len(string) )']. Use the imperative tone and reflect the features of Fortran function in the instruction.", "input": "", "output": "  function mr_char_string_upper( string ) result( string_upper )\n\n    implicit none\n\n    character(   *   ) , intent(in ) :: string\n\n    character( len(string) )         :: string_upper\n\n    integer :: idx_ascii_char\n    integer :: i_char\n\n    do i_char = 1 , len(string)\n\n      idx_ascii_char = iachar( string(i_char:i_char) )\n\n      if( idx_ascii_char >= 97 .and. idx_ascii_char <= 122 ) then\n        string_upper(i_char:i_char) = achar( idx_ascii_char - 32 )\n      else\n        string_upper(i_char:i_char) = string(i_char:i_char)\n      end if\n\n    end do\n\n  end function mr_char_string_upper\n"}, {"instruction": "Write a Fortran function named swap_f8 that takes a single input parameter of type real(b_sz) and returns a single output parameter of type real(b_sz). This function is intended to swap the byte order of the input real number.", "input": "", "output": "        function swap_f8(input) result(output)\n            implicit none\n            integer(4), parameter  :: b_sz =  8\n            real(b_sz), intent(in) :: input \n            real(b_sz)             :: output \n\n            integer(1) :: byte_arr(b_sz), byte_arr_tmp(b_sz)\n            integer(1) :: i\n\n            byte_arr_tmp =  transfer(input, byte_arr_tmp)\n\n            do i = 1,b_sz\n                byte_arr(i) =  byte_arr_tmp(1 + b_sz - i)\n            enddo\n\n            output =  transfer(byte_arr, output)\n        end function swap_f8 \n"}, {"instruction": "Write a Fortran function named eqrange, which takes 3 input parameters of type integer: y, ygroup, and groupsize. The output parameter is an integer array of size 2*groupsize. The function calculates and returns the eqrangeout array based on the input parameters.", "input": "", "output": "pure function eqrange(y,ygroup,groupsize) result(eqrangeout)\n  integer, intent(in) :: y,ygroup,groupsize\n  integer, dimension(2*groupsize) :: eqrangeout\n  integer, parameter :: infty=huge(1)\n  integer, dimension(groupsize) :: equil,nequil\n  equil(1) = y\n  equil(2:(groupsize-ygroup))=0\n  if (ygroup > 0) then\n     equil((groupsize-ygroup+1):groupsize)=1\n  end if\n  nequil = 1 - equil\n  eqrangeout(1:groupsize) = -infty*equil+(y+ygroup)*nequil\n  eqrangeout((groupsize+1):(2*groupsize)) = (y+ygroup-1)*equil+infty*nequil\nend function eqrange\n"}, {"instruction": "Create a Fortran function named conduit_blueprint_mcarray_to_contiguous to convert a multi-dimensional C array to a contiguous array. The function takes 2 input parameters of type c_ptr, passed by value. The output parameter is a logical of type c_bool. Use the imperative tone in the instructions.", "input": "", "output": "       function conduit_blueprint_mcarray_to_contiguous(cnode,cdest) result(res) &\n                bind(c, name=\"conduit_blueprint_mcarray_to_contiguous\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value, intent(in) :: cnode\n            type(c_ptr), value, intent(in) :: cdest\n            logical(c_bool) ::res\n        end function conduit_blueprint_mcarray_to_contiguous\n"}, {"instruction": "Write a Fortran function named ocean_roughness that calculates the roughness length for the ocean surface based on the input friction velocity (ustar). The function takes 1 input argument of type real, and returns 1 output argument of type real. The test_data type for input is ['real'], and for the output is ['real'].", "input": "", "output": "    function ocean_roughness(ustar) result(z0)\n        implicit none\n        real, intent(in) :: ustar\n        real :: z0\n\n        ! approximately from beljaars (1995?) in ecmwf model\n        z0 = 8e-6 / max(ustar,1e-7)\n    end function ocean_roughness\n"}, {"instruction": "Write a Fortran function named countchar that counts the number of instances of a single character in a given character string. The number of input arguments is 2, and the test_data type is ['character(len=*)', 'character']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function countchar(str1,solo)\n! count the number of instances of the single character in a character string.\n! useful when parsing a comma-separated list, for example.\n! count the commas and add 1 to get the number of items in the list.\n\ninteger                      :: countchar\ncharacter(len=*), intent(in) :: str1\ncharacter,        intent(in) :: solo\n\ninteger :: i\n\ncountchar = 0\ndo i = 1,len_trim(str1)\n   if (str1(i:i) == solo) countchar = countchar + 1\nenddo\n\nend function countchar\n"}, {"instruction": "Create a Fortran function named failure to determine if an error occurred during program execution. The function takes 2 input parameters of type character(len=*) and integer. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The output is a single logical value.", "input": "", "output": "    function failure(msg,ierr)\n        use, intrinsic :: iso_fortran_env, only: error_unit\n        character(len=*), intent(in) :: msg\n        integer, intent(in) :: ierr\n        logical :: failure\n        \n        failure = (ierr /= 0)\n        if (failure) then\n            write(error_unit,*) trim(msg),': ierr = ',ierr\n        end if\n    end function failure\n"}, {"instruction": "Create a Fortran function named power_2_check to determine if the input integer is a power of 2. The function should take 1 input parameter of type integer and return 1 output parameter of type logical.", "input": "", "output": "  function power_2_check( n )\n    implicit none\n    logical :: power_2_check\n    integer,intent(in)  :: n\n    real(8) :: x\n    integer :: i\n    x = log(dble(n))/log(2.0d0)\n    i = nint(x)\n    if ( abs(x-i) < 1.d-10 ) then\n       power_2_check = .true.\n    else\n       power_2_check = .false.\n    end if\n  end function power_2_check\n"}, {"instruction": "Create a Fortran function named bit_reverse to calculate the bitwise reverse of an integer. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function bit_reverse( i, n )\n    implicit none\n    integer :: bit_reverse\n    integer,intent(in) :: i, n\n    integer :: len_bit,ipos,i_br\n    len_bit = nint( log(dble(n))/log(2.0d0) )\n    i_br = 0\n    do ipos=0,len_bit-1\n       call mvbits( i, ipos, 1, i_br, len_bit-1-ipos )\n    end do\n    bit_reverse = i_br\n  end function bit_reverse\n"}, {"instruction": "Create a Fortran function named bin to calculate the binomial coefficient. The function takes 2 input parameters of type integer, n and k. It returns 1 output parameter of type real*8.", "input": "", "output": "          function bin(n, k)\n\n              implicit none\n              integer, intent (in) :: n\n              integer, intent (in) :: k\n              integer :: i\n              real*8 :: bin\n\n              bin = 1\n\n              do i=1,k\n                  bin = bin * (n - i + 1) / i\n              enddo\n\n              return\n\n          end function bin\n"}, {"instruction": "Create a Fortran function named accboys that calculates the Boys function value for a given real*8 number and integer.The number of input arguments is 2 with test_data type ['real*8', 'integer']. The number of output arguments is 1 with test_data type ['real*8']. Use the imperative tone to instruct the creation of this function.", "input": "", "output": "    function accboys(x,n)\n        real*8 :: accboys\n        real*8,intent(in) :: x\n        integer,intent(in) :: n\n        integer,parameter :: nit = 4\n        real*8 :: tdts(nit)\n        real*8 :: tresults(nit)\n        integer :: ngs\n        integer :: i,n2,j\n        real*8 :: dt,t,tresult,tresult12,tresult23,tresult34,tresult123,tresult234\n        ! ================================================\n        n2 = n*2\n        ngs = 25\n        ! naive grid integral.\n        do i = 1,nit\n            ngs = ngs*4\n            dt = 1./ngs\n            if (n2 == 0) then\n                tresult = 0.5\n            else\n                tresult = 0\n            endif\n            t = dt\n            do j = 1,ngs\n                tresult = tresult+exp(-x*t*t)*(t**n2)\n                t = t+dt\n            enddo\n            tresult = tresult+exp(-x*t*t)*(t**n2)/2\n            tresult = tresult*dt\n            tdts(i) = dt\n            tresults(i) = tresult\n        enddo\n        ! neville extrapolation to zero step.\n        tresult12 = (-tdts(2))*(tresults(1)-tresults(2))/(tdts(1)-tdts(2))+tresults(2)\n        tresult23 = (-tdts(3))*(tresults(2)-tresults(3))/(tdts(2)-tdts(3))+tresults(3)\n        tresult34 = (-tdts(4))*(tresults(3)-tresults(4))/(tdts(3)-tdts(4))+tresults(4)\n        tresult123 = (-tdts(3))*(tresult12-tresult23)/(tdts(1)-tdts(3))+tresult23\n        tresult234 = (-tdts(4))*(tresult23-tresult34)/(tdts(2)-tdts(4))+tresult34\n        accboys = (-tdts(4))*(tresult123-tresult234)/(tdts(1)-tdts(4))+tresult234\n    end function\n"}, {"instruction": "Create a Fortran function named sdf_string_lowercase that takes a string as input with the type character(len=*) and returns a modified string with all letters converted to lowercase. The function has 1 input parameter and 1 output parameter, both of type character.", "input": "", "output": "  function sdf_string_lowercase(string_in) result(string_out)\n\n    character(len=*), parameter :: lwr = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=*), parameter :: upr = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=*), intent(in) :: string_in\n    character(len=len(string_in)) :: string_out\n    integer :: i, idx\n\n    string_out = string_in\n\n    do i = 1, len(string_out)\n      idx = index(upr, string_out(i:i))\n      if (idx /= 0) string_out(i:i) = lwr(idx:idx)\n    end do\n\n  end function sdf_string_lowercase\n"}, {"instruction": "Write a Fortran function called linearinterpolate that performs linear interpolation between two real numbers. The function takes 3 input arguments of type real(kind=8) (y1, y2, and mu) and returns 1 output argument of type real(kind=8).", "input": "", "output": "   function linearinterpolate(y1, y2, mu)\n      real(kind=8), intent(in)  :: y1, y2, mu\n      real(kind=8) :: linearinterpolate\n      linearinterpolate =  y1*(1.0d0 - mu) + y2*mu\n      return\n   end function linearinterpolate\n"}, {"instruction": "Create a Fortran function named get_string_value to extract a substring from a given input string. The function should take 1 input argument with the test_data type of ['character(len=*)'] and return 1 output argument with the test_data type of ['character(len=len(line))']. The function is responsible for finding the substring after the \":=\" symbol in the input string.", "input": "", "output": "function get_string_value( line ) result( keyword )\n    character(len=*)         :: line\n    character(len=len(line)) :: keyword\n\n    integer          :: k\n\n    k = index(line, ':=' )\n    k = k + 2\n    keyword = adjustl(line(k:))\n\nend function get_string_value\n"}, {"instruction": "Write a Fortran function named det3 to calculate the determinant of a 3x3 matrix using the input arrays p1, p2, and p3. The number of input arguments is 3 and the test_data type is ['double precision, dimension(3)', 'double precision, dimension(3)', 'double precision, dimension(3)']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function det3(p1, p2, p3) result(d)\n\n    implicit none\n\n    double precision, dimension(3), intent(in) :: p1, p2, p3\n    double precision :: d\n\n    d = p1(1)*p2(2)*p3(3) + p1(3)*p2(1)*p3(2) + p1(2)*p2(3)*p3(1) &\n      - p1(3)*p2(2)*p3(1) - p1(1)*p2(3)*p3(2) - p1(2)*p2(1)*p3(3)\n\n  end function det3\n"}, {"instruction": "Write a Fortran function named get_arithmetic_operations that takes a string of characters as input. The input parameter should be of type character with variable length. The function should return an integer.", "input": "", "output": "    function get_arithmetic_operations(varstring)\n    ! => create scratch files 334 and 335 containing (respectively) the lists of variables and operators\n    ! note: the first operators (corresponding to the first variable) is automatically '+'\n    ! return the number of variables/operations\n        character(len=*), intent(in):: varstring\n        integer:: get_arithmetic_operations\n        character(len=1), dimension(2), parameter:: operators = (/'+', '-'/) ! legal arithmetic operators\n        integer:: i0, i1\n        open(unit=334, status='scratch') ! individual variables\n        open(unit=335, status='scratch') ! operators\n        i0 = 1\n        i1 = 1\n        get_arithmetic_operations = 1\n        write(unit=335, fmt='(a)') '+'\n        do i1 = 1,len(varstring)\n            if (any(operators == varstring(i1:i1))) then\n                write(unit=334, fmt='(a)') trim(adjustl(varstring(i0:i1-1)))\n                write(unit=335, fmt='(a)') varstring(i1:i1)\n                i0 = i1+1\n                get_arithmetic_operations = get_arithmetic_operations + 1\n            end if\n        end do\n        write(unit=334, fmt='(a)') trim(adjustl(varstring(i0:)))\n        rewind(unit=334)\n        rewind(unit=335)\n    end function\n"}, {"instruction": "Create a Fortran function named nfeb to compute the number of days in February for a given year. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter represents the year for which the number of days in February is to be determined. Use the if-else statements to check if the year is a leap year and calculate the number of days accordingly.", "input": "", "output": "   function nfeb ( year ) result (num_days)\n   \n      ! compute the number of days in february for the given year\n   \n      integer :: year\n      integer :: num_days\n   \n      num_days = 28 ! by default, february has 28 days ...\n      if (mod(year,4).eq.0) then  \n         num_days = 29  ! but every four years, it has 29 days ...\n         if (mod(year,100).eq.0) then\n            num_days = 28  ! except every 100 years, when it has 28 days ...\n            if (mod(year,400).eq.0) then\n               num_days = 29  ! except every 400 years, when it has 29 days.\n            end if\n         end if\n      end if\n   \n   end function nfeb\n"}, {"instruction": "Create a Fortran function named r_wrap that takes 3 input arguments of type real(kind(0.d0)) and returns 1 output argument of the same type. The function computes the wrapped value of the input parameter 'r' based on the range determined by the parameters 'l' and 'l_half'. If 'r' is greater than 'l_half', 'r_wrap' is computed as 'r - l'. If 'r' is less than -'l_half', 'r_wrap' is computed as 'r + l'. Otherwise, 'r_wrap' is assigned the value of 'r'.", "input": "", "output": "pure function r_wrap(r, l, l_half)\n    real(kind(0.d0)), intent(in) :: r, l, l_half\n    real(kind(0.d0)) :: r_wrap\n\n    if (r > l_half) then \n        r_wrap = r - l\n    else if (r < -l_half) then\n        r_wrap = r + l\n    else\n        r_wrap = r\n    end if\nend function\n"}, {"instruction": "Create a Fortran function named model_function that takes a single real number as input and returns a real number as output. Ensure that the input parameter is of kind=4 and the output parameter is also of kind=4. The function should add 1.0 to the input value and display the input and output values.", "input": "", "output": "function model_function(x) result(y)\n  real(kind=4), intent(in) :: x\n  real(kind=4) :: y\n  y = x + 1.0\n  write(*, '(\"model a: \",f10.5,\" -> \",f10.5)') x, y\nend function model_function\n"}, {"instruction": "Create a Fortran function named next_position to calculate the updated position on a game board based on the current position and the result of a dice roll. The function takes 2 input arguments of type integer, position, and rollscore, and returns 1 output argument of type integer.", "input": "", "output": "    function next_position(position,rollscore)\n        implicit none\n        integer, intent(in) :: position,rollscore\n        integer :: next_position,t\n        \n        t = position + rollscore\n\t\tnext_position = mod(t,10)\n\t\t\n\t\tif (next_position == 0) then\n\t\t\tnext_position = 10\n\t\tend if\n    end function next_position\n"}, {"instruction": "Write a Fortran function named mfact that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    recursive function mfact (x) result (res)\n      integer, intent(in) :: x\n      integer :: res\n      integer i\n      i = 0\n      !$acc routine  ! { dg-error \"unexpected \\\\\\!\\\\\\$acc routine\" }\n      if (x < 1) then\n         res = 1\n      else\n         res = x * mfact (x - 1)\n      end if\n    end function mfact\n"}, {"instruction": "Create a Fortran function named to_s_int_ to convert an integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character with a length of 500.", "input": "", "output": "  function to_s_int_(value)\n    !! category: fruit_util\n    !! convert integer to string\n    character(len=500):: to_s_int_\n    integer, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_int_ = adjustl(trim(result))\n  end function to_s_int_\n"}, {"instruction": "Create a Fortran function named to_s_logical_ that takes a logical input argument and returns two output arguments. The input argument should be of type logical, and the output arguments should be of type character(len=500) and to_s_logical_(value). This function is designed to convert a logical value to a string.", "input": "", "output": "  function to_s_logical_(value)\n    !! convert logical to string\n    character(len=500):: to_s_logical_\n    logical, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_logical_ = adjustl(trim(result))\n  end function to_s_logical_\n"}, {"instruction": "Create a Fortran function named csr_index to find the index of a specific element within a compressed sparse row (CSR) matrix. The function takes 4 input parameters of type integer: i, j, ja (an array), and ia (an array). The output parameter is a single integer representing the index of the element within the CSR matrix.", "input": "", "output": "function csr_index(i,j,ja,ia) result(kij)\n  integer,intent(in)::i,j\n  integer,dimension(:),intent(in)::ja,ia\n  integer::kij\n\n  do kij=ia(i),ia(i+1)-1\n    select case(ja(kij)-j)\n    case(0)\n      return\n    end select\n  end do\n\n  kij=-1\nend function\n"}, {"instruction": "Create a Fortran function named readinputfile to read data from a binary input file and process it. The function takes 7 input parameters of types integer, character(len=*), and various dimensions of allocatable arrays of real numbers, and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction readinputfile(ilun, sinputfile, ivtime, rvu, rvv, rvw, rvt) result(iretcode)\n\t\n\t\t! routine arguments\n\t\tinteger, intent(in)\t\t\t\t\t\t\t\t:: ilun\n\t\tcharacter(len=*), intent(in)\t\t\t\t\t:: sinputfile\n\t\tinteger, dimension(:), allocatable, intent(out)\t:: ivtime\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvu\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvv\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvw\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvt\n\t\tinteger\t\t\t\t\t\t\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\tinteger\t\t:: ierrcode\n\t\tinteger\t\t:: inumdata\n\t\tinteger\t\t:: idata\n\t\tinteger(2)\t:: itimestamp, iu, iv, iw, it\n\t\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! count how many data are available, and reserve workspace based on this information\n\t\topen(ilun, file=sinputfile, status='old', action='read', access='stream', iostat=ierrcode)\n\t\tif(ierrcode /= 0) then\n\t\t\tiretcode = 1\n\t\t\tclose(ilun)\n\t\t\treturn\n\t\tend if\n\t\tinumdata = 0\n\t\tdo\n\t\t\t\n\t\t\t! get data in binary form\n\t\t\tread(10, iostat=ierrcode) itimestamp, iv, iu, iw, it\n\t\t\tif(ierrcode /= 0) exit\n\t\t\t\n\t\t\t! retain data record pertaining to sonic quadruples only\n\t\t\tif(itimestamp > 3600 .or. itimestamp < 0) cycle\n\t\t\tinumdata = inumdata + 1\n\t\t\t\n\t\tend do\n\t\tif(inumdata <= 0) then\n\t\t\tiretcode = 2\n\t\t\tclose(ilun)\n\t\t\treturn\n\t\tend if\n\t\tallocate(ivtime(inumdata), rvu(inumdata), rvv(inumdata), rvw(inumdata), rvt(inumdata))\n\t\trewind(ilun)\n\t\t\n\t\t! perform actual data read\n\t\tidata = 0\n\t\tdo\n\t\t\t\n\t\t\t! get data in binary form\n\t\t\tread(10, iostat=ierrcode) itimestamp, iu, iv, iw, it\n\t\t\tif(ierrcode /= 0) exit\n\t\t\t\n\t\t\t! retain data record pertaining to sonic quadruples only\n\t\t\tif(itimestamp > 3600 .or. itimestamp < 0) cycle\n\t\t\tidata = idata + 1\n\t\t\tivtime(idata) = itimestamp\n\t\t\tif(iu > -9990 .and. iv > -9990 .and. iw > -9990 .and. it > -9990) then\n\t\t\t\trvu(idata) = iu / 100.\n\t\t\t\trvv(idata) = iv / 100.\n\t\t\t\trvw(idata) = iw / 100.\n\t\t\t\trvt(idata) = it / 100.\n\t\t\telse\n\t\t\t\trvu(idata) = -9999.9\n\t\t\t\trvv(idata) = -9999.9\n\t\t\t\trvw(idata) = -9999.9\n\t\t\t\trvt(idata) = -9999.9\n\t\t\tend if\n\t\t\t\n\t\tend do\n\t\tclose(ilun)\n\t\t\n\tend function readinputfile\n"}, {"instruction": "Write a Fortran function named imaxloc that returns the index of the maximum value in a real, one-dimensional array. The function takes 1 input parameter with test_data type ['real, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "   function imaxloc(array)\n      real, dimension(:), intent(in) :: array\n      integer :: imaxloc\n      integer, dimension(1) :: imax\n      imax = maxloc(array)\n      imaxloc = imax(1)\n   end function imaxloc\n"}, {"instruction": "Create a Fortran pure function named dirname that takes two input arguments of type character(*), and allocatable, and returns one output argument of type character(:),allocatable. This function scans the input string for the last occurrence of the specified delimiter and returns the substring containing the directory name.", "input": "", "output": "pure function dirname(instr,  delm)\n\ncharacter(*), intent(in) :: instr\ncharacter(*), intent(in) :: delm\ncharacter(:),allocatable :: dirname\ninteger :: idx\n\nidx = scan(instr, delm, back=.true.)\ndirname = instr(1:idx-1)\n\nend function dirname\n"}, {"instruction": "Create a Fortran function named whole to determine if a given double precision number is a whole number. The function should take 1 input argument of type double precision and return 1 output argument of type logical.", "input": "", "output": "  pure function whole(x)\n    implicit none\n    double precision, intent(in) :: x\n    logical                      :: whole\n    whole = (mod(x,1.0) == 0.0)\n  end function whole\n"}, {"instruction": "Create a Fortran function named f that calculates the value of the sine function at 3 times the input parameter x minus 0.1. The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function f(x)\n\n  implicit none\n\n  real,intent(in) :: x !! funci\u00f3n con ra\u00edces desconocidas en i=[a,b]\n  real::f\n\n  f = sin(3*x-0.1)\n\n  end function\n"}, {"instruction": "Create a Fortran function named dimenumb to determine the number of digits in an integer input. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": " function dimenumb(inum)\n \n!***********************************************************************\n!     \n\n!     of an integer number\n!     originally written in jetspin by m. lauricella et al.\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n\n  implicit none\n\n  integer,intent(in) :: inum\n  integer :: dimenumb\n  integer :: i\n  real(kind=4) :: tmp\n\n  i=1\n  tmp=real(inum,kind=4)\n  do \n    if(tmp< 10.e0 )exit\n    i=i+1\n    tmp=tmp/ 10.e0\n  enddo\n\n  dimenumb=i\n\n  return\n\n end function dimenumb\n"}, {"instruction": "Provide a Fortran function named ifrac that converts a double precision real number to an integer by truncating the decimal part. The number of input arguments is 1, and the test_data type is ['double precision']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "      function ifrac(r)\r\n        implicit none\r\n        double precision :: r\r\n        integer :: ifrac\r\n\r\n        ifrac=r\r\n        if (r.ge.0) return\r\n        if (r.eq.ifrac) return\r\n        ifrac = ifrac - 1\r\n       end function ifrac\r\n"}, {"instruction": "Create a Fortran function called set_initial_timestep_src to set the initial time step value. The function takes 1 input parameter of type real*8. The output is an integer return value.", "input": "", "output": "function set_initial_timestep_src(init_timestep) result(ret)\n  integer :: ret\n  real*8 :: init_timestep\n\n  h0=init_timestep\n  ret = 0\n\nend function set_initial_timestep_src\n"}, {"instruction": "Write a Fortran function called mercury_set_rmax to set the maximum distance for a Mercury simulation. The function takes 1 input parameter of type real*8. The output is an integer.", "input": "", "output": "function mercury_set_rmax(r_max) result(ret)\n    integer :: ret\n    real*8 :: r_max\n    rmax = r_max\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function called mercury_set_cefac that takes a single real*8 input parameter and returns an integer output. The input parameter should be of type real*8, and the output parameter should be of type integer. The function sets the value of a variable called cefac to the input parameter and then sets the return value to 0.", "input": "", "output": "function mercury_set_cefac(cefac_n1) result(ret)\n    integer :: ret\n    real*8 :: cefac_n1\n    cefac = cefac_n1\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function named g that takes a real number as input and returns it as output. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "  function g(y)\n    != unit 'a :: y\n    real :: y, j, g\n    j = y\n    g = j\n  end function g\n"}, {"instruction": "Create a Fortran function named func_interpolate_real32_points to interpolate a value between two points based on given x and y values. The function takes 5 input parameters of type real(kind = real32) representing x1, x2, y1, y2, and x, and returns 1 output parameter of the same type representing the interpolated value.", "input": "", "output": "elemental function func_interpolate_real32_points(x1, x2, y1, y2, x) result(ans)\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare input variables ...\n    real(kind = real32), intent(in)                                             :: x\n    real(kind = real32), intent(in)                                             :: x1\n    real(kind = real32), intent(in)                                             :: x2\n    real(kind = real32), intent(in)                                             :: y1\n    real(kind = real32), intent(in)                                             :: y2\n\n    ! declare output variables ...\n    real(kind = real32)                                                         :: ans\n\n    ! calculate value ...\n    ans = (y1 * (x2 - x) + y2 * (x - x1)) / (x2 - x1)\nend function func_interpolate_real32_points\n"}, {"instruction": "Create a Fortran function named lsame that compares two characters and returns a logical value indicating whether they are the same or not. The function takes 2 input parameters of type character and returns 1 output parameter of type logical.", "input": "", "output": "      function lsame(ca,cb)\n      implicit none\n      character :: ca , cb\n      logical :: lsame\n      intent (in) ca , cb\n      end function lsame\n"}, {"instruction": "Create a Fortran function called file_slurp to read the contents of a file and store them in a character array. The function takes 1 input parameter of type character(len=*), representing the filename, and returns 1 output parameter of type character(len=:), allocatable, which contains the content of the file.", "input": "", "output": "\tfunction file_slurp(filename) result(file)\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tinteger :: filesize\n\t\tcharacter(len=:), allocatable :: file\n\n\t\topen(unit=10, file=filename, action=\"read\", &\n\t\t\tform=\"unformatted\", access=\"stream\")\n\t\tinquire(unit=10, size=filesize)\n\t\tallocate(character(len=filesize) :: file)\n\t\tread(10) file\n\t\tclose(10)\n\tend function\n"}, {"instruction": "Create a Fortran function named ncolumns to determine the number of columns in a string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction ncolumns(string)\n\tinteger :: ncolumns\n\tcharacter(len=*) :: string\n\tcharacter(len=1) :: ch, chprev\n\tinteger :: i, l, blanks\n\t\tl = len(trim(string))\n\t\tblanks = 1\n\t\tchprev = string(1:1)\n\t\tdo i = 2, l\n\t\t\tch = string(i:i)\t\t\t\n\t\t\tif (ch /= ' ' .and. chprev == ' ') then\n\t\t\t\tblanks = blanks + 1\n\t\t\tendif\t\t\t\n\t\t\tchprev = ch\n\t\tenddo\n\t\tncolumns = blanks - 1\n\tend function ncolumns\n"}, {"instruction": "Write a Fortran function called ez that calculates the value of the function E(z) for a given input zprime. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The function uses the cosmological parameters omegal and omegam to compute the value of E(z) according to the given formula.", "input": "", "output": "function ez(zprime)\nimplicit none\nreal*8 :: zprime,ez,omegal,omegam\nomegal=0.734\nomegam=0.266\n\nez=1.0/sqrt(omegal+omegam*(1.0+zprime)**3)\nend function\n"}, {"instruction": "Write a Fortran function named haversine to calculate the great circle distance between two geographical points. The function takes 4 input parameters of type real*8: deglon1, deglon2, deglat1, and deglat2. It returns one output parameter of type real*8: dist.", "input": "", "output": "      function haversine(deglon1,deglon2,deglat1,deglat2) result (dist)\n          ! great circle distance -- adapted from matlab \n          real*8,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real*8 :: a,c,dist,dlat,dlon,lat1,lat2\n \n          dlat = deg2rad*(deglat2-deglat1)\n          dlon = deg2rad*(deglon2-deglon1)\n          lat1 = deg2rad*(deglat1)\n          lat2 = deg2rad*(deglat2)\n          a = ( sin(0.5d0*dlat) )**2 + &\n                cos(lat1) * cos(lat2) * ( sin(0.5d0*dlon) )**2\n          c = 2d0*asin( sqrt(a) )\n          dist = rearth*c\n      end function haversine\n"}, {"instruction": "Create a Fortran function named first_x_deriv to calculate the first derivative of a one-dimensional array. The function takes 4 input parameters of types real, integer, real, and integer, and an output parameter of type real. The input parameters are an array of real numbers, an integer index, a real step size, and an integer direction. The function returns the first derivative of the array at the specified index based on the given step size and direction.", "input": "", "output": "        pure function first_x_deriv(f, i, dx, direction)\n\n                real, intent (in), dimension (:) :: f\n                integer, intent (in) :: i\n                real, intent (in) :: dx\n                integer, intent (in) :: direction\n\n                real :: first_x_deriv\n\n                first_x_deriv = 0.0\n\n                if (direction == 1) then\n                        first_x_deriv = (f(i) - f(i-1))/dx\n                else if (direction == -1) then\n                        first_x_deriv = (f(i) - f(i+1))/dx\n                end if\n\n        end function first_x_deriv\n"}, {"instruction": "Create a Fortran function named second_x_deriv to calculate the second derivative of a function with respect to x. The function takes 3 input parameters: an array of real numbers, an integer, and a real number. The output is a real number. The input parameter types are ['real, dimension(:)', 'integer', 'real'], and the output parameter type is ['real'].", "input": "", "output": "        pure function second_x_deriv(f, i, dx)\n\n                real, intent (in), dimension (:) :: f\n                integer, intent (in) :: i\n                real, intent (in) :: dx\n\n                real :: second_x_deriv\n\n                second_x_deriv = (                                     &\n                  -735*f(i-8)+15360*f(i-7)                             &\n                  -156800*f(i-6)+1053696*f(i-5)                        & \n                  -5350800*f(i-4)+22830080*f(i-3)                      & \n                  -94174080*f(i-2)+538137600*f(i-1)                    & \n                  -924708642*f(i+0)                                    & \n                  +538137600*f(i+1)-94174080*f(i+2)                    & \n                  +22830080*f(i+3)-5350800*f(i+4)                      & \n                  +1053696*f(i+5)-156800*f(i+6)                        & \n                  +15360*f(i+7)-735*f(i+8))/(302702400*dx**2)\n\n        end function second_x_deriv\n"}, {"instruction": "Create a Fortran function named dfdx that takes in four input parameters: a real, two-dimensional array 'f', an integer 'x', an integer 's', and a real, one-dimensional array 'fd_coeff'. The function returns a real value. The function calculates the derivative of 'f' with respect to 'x' using finite differencing, and the result is stored in the variable 'dfdx'.", "input": "", "output": "        pure function dfdx(f, x, s, fd_coeff)\n\n                real, intent (in), dimension (:, :) :: f\n                integer, intent (in) :: x\n                integer, intent (in) :: s\n                real, intent (in), dimension (2) :: fd_coeff\n\n                real :: dfdx\n                integer :: i\n\n                dfdx = 0.0\n\n                do i = 1, 2\n                dfdx = dfdx + fd_coeff(i) * (f(x + i, s) - f(x - i, s))\n                end do\n\n        end function dfdx\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor (GCD) of two integer numbers. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  function gcd(m0,n0)\n    implicit none\n    integer :: gcd,m0,n0\n    integer :: m,n,mtmp,loop\n\n    if ( m0 >= n0 ) then\n       m=m0\n       n=n0\n    else\n       m=n0\n       n=m0\n    end if\n\n    do loop=1,10000\n       if ( n == 0 ) exit\n       mtmp = n\n       n = mod(m,n)\n       m = mtmp\n    end do\n\n    gcd = m\n\n  end function gcd\n"}, {"instruction": "Define a Fortran function named gamma that computes the gamma function. The input parameter is a real*8 type, and the output parameter is also a real*8 type.", "input": "", "output": "  function gamma(x)\n  implicit none\n!\n! purpose:\n\n!\n! input:\n\n!\n! returns:\n!   gamma(x)\n!\n! coded:\n!   02/02/06  john haynes (haynes@atmos.colostate.edu)\n!   (original code of unknown origin)\n\n! ----- inputs -----\n  real*8, intent(in) :: x\n  \n! ----- outputs -----\n  real*8 :: gamma\n\n! ----- internal -----  \n  real*8 :: pi,ga,z,r,gr\n  real*8 :: g(26)\n  integer :: k,m1,m\n       \n  pi = acos(-1.)    \n  if (x ==int(x)) then\n    if (x > 0.0) then\n      ga=1.0\n      m1=x-1\n      do k=2,m1\n        ga=ga*k\n      enddo\n    else\n      ga=1.0+300\n    endif\n  else\n    if (abs(x) > 1.0) then\n      z=abs(x)\n      m=int(z)\n      r=1.0\n      do k=1,m\n        r=r*(z-k)\n      enddo\n      z=z-m\n    else\n      z=x\n    endif\n    data g/1.0,0.5772156649015329, &\n           -0.6558780715202538, -0.420026350340952d-1, &\n           0.1665386113822915,-.421977345555443d-1, &\n           -.96219715278770d-2, .72189432466630d-2, &\n           -.11651675918591d-2, -.2152416741149d-3, &\n           .1280502823882d-3, -.201348547807d-4, &\n           -.12504934821d-5, .11330272320d-5, &\n           -.2056338417d-6, .61160950d-8, &\n           .50020075d-8, -.11812746d-8, &\n           .1043427d-9, .77823d-11, &\n          -.36968d-11, .51d-12, &\n          -.206d-13, -.54d-14, .14d-14, .1d-15/\n    gr=g(26)\n    do k=25,1,-1\n      gr=gr*z+g(k)\n    enddo \n    ga=1.0/(gr*z)\n    if (abs(x) > 1.0) then\n      ga=ga*r\n      if (x < 0.0) ga=-pi/(x*ga*sin(pi*x))\n    endif\n  endif\n  gamma = ga\n  return\n  end function gamma\n"}, {"instruction": "Write a Fortran function named unquote to extract the content of a quoted string. The function takes 1 input argument with the test_data type of ['character(len=*)'] and returns 1 output argument with the test_data type of ['character(len=:),allocatable'].", "input": "", "output": "    pure function unquote(str) result(v)\n    character(len=*),intent(in):: str\n    character(len=:),allocatable:: v\n    integer:: l\n    if(str(1:1)=='\"' .or. str(1:1)==\"'\") then\n        l=len_trim(str)\n        v=str(2:l-1)\n    else\n        v=str\n    endif\n    end function\n"}, {"instruction": "Create a Fortran function named quote that takes a string as input and returns the string enclosed in double quotes. The input parameter is of type character(len=*) and the output parameter is of type character(len=:),allocatable.", "input": "", "output": "    pure function quote(str) result(v)\n    character(len=*),intent(in):: str\n    character(len=:),allocatable:: v\n    if(len_trim(str)==0) then\n        v='\"\"'\n        return\n    endif\n    if(str(1:1)=='\"'.or.str(1:1)==\"'\") then\n        v=str\n    else\n        v='\"'//trim(str)//'\"'\n    endif\n    end function\n"}, {"instruction": "Create a Fortran function named is_red that takes an integer input argument and returns a logical value. The input parameter is of type integer, and the output parameter is of type logical. This function checks if the input integer is equal to a predefined constant value \"red\" and returns true if it matches, or false otherwise.", "input": "", "output": "  function is_red(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == red) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_red\n"}, {"instruction": "Create a Fortran function named is_red_a that takes an integer input argument and returns a logical value. The input parameter has a test_data type of ['integer'], and the output parameter has a test_data type of ['logical']. This function checks if the input integer is equal to a predefined value red_a and returns true if it is, otherwise it returns false.", "input": "", "output": "  function is_red_a(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == red_a) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_red_a\n"}, {"instruction": "Create a Fortran function named is_green to check if the input integer value corresponds to the color green. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  function is_green(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == green) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_green\n"}, {"instruction": "Create a Fortran function named return_char2. This function takes 1 input parameter of type integer(c_int) and returns 1 output parameter of type character(c_char). The function uses the iso_c_binding module. The function converts the input integer to a character using the achar function and returns the result as a character.", "input": "", "output": "function return_char2(i) result(output) bind(c,name='return_char2')\n  use iso_c_binding\n  implicit none\n  integer(c_int) :: i\n  character(c_char) :: j\n  character(c_char) :: output\n\n  j = achar(i)\n  output = j\nend function return_char2\n"}, {"instruction": "Write a Fortran function named file_of_unit that takes an integer input argument and returns the name of the file connected to the specified unit. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character (len=1000)'].", "input": "", "output": "function file_of_unit(iu) result(file_name)\r\n! return name of file connected to unit iu, \"\" if unopened\r\ninteger, intent(in)  :: iu\r\ncharacter (len=1000) :: file_name\r\nlogical              :: opened\r\ninquire(unit=iu,opened=opened)\r\nif (opened) then\r\n   inquire (unit=iu,name=file_name)\r\nelse\r\n   file_name = \"\"\r\nend if\r\nend function file_of_unit\r\n"}, {"instruction": "Create a Fortran function named strtolcase that takes two input parameters: an integer and a character array of length n. The function returns a character array of length n. The purpose of the function is to convert the lowercase characters in the input string to uppercase.", "input": "", "output": " function strtolcase(str,n)\n !********************************************************\n    implicit none\n    integer :: strcapa = 65    ! from write(*,*) \"a:\",ichar(\"a\")\n    integer :: strcapz = 90    ! etc\n    !integer :: strlowa = 97\n    !integer :: strlowz = 122\n    integer :: casediff = 32   ! = 97-65  = 122-90\n    integer :: i,n,ich\n    character(len=n) :: strtolcase\n    character(len=n) :: str\n    !-----------------------\n\n    strtolcase = str\n\n    do i=1,n\n       ich = ichar(strtolcase(i:i))\n       if( ich>=strcapa .and. ich<=strcapz ) strtolcase(i:i) = char(ich+casediff)\n    enddo\n\n end function strtolcase\n"}, {"instruction": "Create a Fortran function called remove_from_character_onwards that takes 3 input parameters: an integer, a character string of length n, and a single character. It returns 2 output parameters: a character string of length n, and the function remove_from_character_onwards.", "input": "", "output": " function remove_from_character_onwards(string_in,n,charact)\n !********************************************************\n  implicit none\n  integer,intent(in) :: n\n  character(len=n),intent(in)::string_in\n  character(len=n) ::remove_from_character_onwards\n  integer :: position_of_charact\n  character(len=1) :: charact\n\n  position_of_charact=index(string_in, charact, .false.)!.false. means returns the position of the first substring from the left\n  !write(*,*)'start_of_comment',start_of_comment\n\n  if(position_of_charact.eq.0)then\n    remove_from_character_onwards=string_in\n  else\n    remove_from_character_onwards=string_in(:position_of_charact-1)\n  endif\n end function remove_from_character_onwards\n"}, {"instruction": "Write a Fortran function named outside that takes a real number as input and returns a real number as output. The function calculates the square of the input, passes it to a nested function named inside, doubles the result, and assigns it to the output variable. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "  function outside(x)\n    != unit 'a :: x\n    real :: x, k, m, outside\n    k = x\n    outside = inside(k) * 2\n    m = outside\n  contains\n    function inside(y)\n      != unit 'a ** 2 :: inside\n      real :: y, inside\n      inside = y * y\n    end function inside\n  end function outside\n"}, {"instruction": "Write a Fortran function named hdgrid_masked_nbrs_kernel to calculate the number of neighboring cells that satisfy a specified mask criterion. The function takes 1 input parameter of type real, dimension(1:9) and returns 1 output parameter of type real.", "input": "", "output": "function hdgrid_masked_nbrs_kernel(input_mask) result(number_nbrs)\n\nimplicit none\n\nreal, intent(in), dimension(1:9) :: input_mask\n\n!local variables\ninteger :: i  !a counter\nreal  :: number_nbrs  !the calculated flow direction to return\n number_nbrs = 0.0\n if (input_mask(5) == 1.0) then\n    do i = 1,9\n      if(i==5) cycle\n      if(input_mask(i) == 1.0) number_nbrs = number_nbrs + 1.0\n    enddo\n end if\n\nend function hdgrid_masked_nbrs_kernel\n"}, {"instruction": "Create a Fortran function named file_exists to check if a file with the given filename exists. The function should take 1 input parameter of type character(len=*) and return 1 output parameter of type logical. The input parameter represents the filename to be checked, and the output parameter indicates whether the file exists or not.", "input": "", "output": "\tfunction file_exists(filename) result (exists)\n\t\timplicit none\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tlogical :: exists\n\t\tinquire(file=filename, exist=exists)\n\tend function file_exists\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci sequence up to the given integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function fib(n) result(r)\n    implicit none\n    integer :: n, r\n\n    if (n < 2) then\n      r = n\n    else\n      r = fib(n - 1) + fib(n - 2)\n    endif\n  end function fib\n"}, {"instruction": "Write a Fortran function named fibtailauxiliary to compute the Fibonacci sequence using tail recursion. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be in the order: n, prevfib, fib, and the output argument should be named r.", "input": "", "output": "  recursive function fibtailauxiliary(n, prevfib, fib) result(r)\n    implicit none\n    integer :: n, prevfib, fib, r\n\n    if (n == 0) then\n      r = prevfib\n    else\n      r = fibtailauxiliary(n - 1, fib, prevfib + fib)\n    endif\n  end function fibtailauxiliary\n"}, {"instruction": "Write a Fortran function named random_integers that generates an array of random integers. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer array with dimension n.", "input": "", "output": "   function random_integers(n) result(z)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n\n      integer, dimension(n) :: z\n      ! local data\n      integer :: i\n      real :: r\n      ! processing\n      do i=1,n\n         call random_number(r)\n         z(i) = int(2147483448.*r)\n      end do\n   end function random_integers\n"}, {"instruction": "Provide a Fortran function code named random_reals to generate an array of random double precision numbers. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [double precision, dimension(n)].", "input": "", "output": "   function random_reals(n) result(r)\n      implicit none\n      ! dummy argumentss\n      integer, intent(in) :: n\n\n      double precision, dimension(n) :: r\n      ! local data\n      integer :: i\n      integer, allocatable :: seed(:)\n      ! processing\n      call random_number(r)\n   end function random_reals\n"}, {"instruction": "Create a Fortran function named concordance_index to calculate the concordance index for survival or reliability data. The function takes 4 input parameters of types integer, double precision array, double precision array, and double precision array. It returns a single output parameter of type double precision.", "input": "", "output": "function concordance_index (event_times, predictions, event_observed, rows) result(cindex)\n  double precision :: cindex, paircount, csum\n  integer, intent(in) :: rows\n  double precision, dimension(rows), intent(in) :: event_times, predictions, event_observed\n  double precision :: time_a, pred_a, event_a, time_b, pred_b, event_b\n  integer :: a, b\n  logical :: valid_pair\n\n  ! default values\n  paircount = 0\n  csum = 0\n  cindex = 0\n\n  do a=1, rows-1\n    time_a = event_times(a)\n    pred_a = predictions(a)\n    event_a = event_observed(a)\n    ! start at a+1 to avoid double counting\n    do b=a+1, rows\n      time_b = event_times(b)\n      pred_b = predictions(b)\n      event_b = event_observed(b)\n\n      ! check if it's a valid comparison\n      if (event_a == 1 .and. event_b == 1) then\n        ! two events can always be compared\n        valid_pair = .true.\n      else if (event_a == 1 .and. time_a < time_b) then\n        ! if b is censored, then a must have event first\n        valid_pair = .true.\n      else if (event_b == 1 .and. time_b < time_a) then\n        ! if a is censored, then b must have event first\n        valid_pair = .true.\n      else\n        ! not valid to compare this pair\n        valid_pair = .false.\n      end if\n\n      if (valid_pair) then\n        paircount = paircount + 1\n\n        ! check concordance\n        if (pred_a == pred_b) then\n          csum = csum + 0.5\n        else if (time_a < time_b .and. pred_a < pred_b) then\n          csum = csum + 1.0\n        else if (time_b < time_a .and. pred_b < pred_a) then\n          csum =csum + 1.0\n        !else\n        ! csum = csum + 0\n        end if\n      end if\n    end do\n  end do\n\n  ! calculate c-index.\n  if (paircount > 0) then\n    cindex = csum / paircount\n  else\n    cindex = 0.5\n  end if\n\nend function concordance_index\n"}, {"instruction": "Create a Fortran function named interp2 to interpolate values from a 2D grid. The function takes 5 input parameters of type real(kind=8) and dimension(:), and one output parameter of type real(kind=8). The input parameters represent grid coordinates and values, while the output parameter represents the interpolated value.", "input": "", "output": "  function interp2(x, y, v, xq, yq) result(vq)\n    real(kind = 8) :: vq\n    real(kind = 8), intent(in) :: xq, yq\n    real(kind = 8), dimension(:), intent(in) :: x, y\n    real(kind = 8), dimension(:,:), intent(in) :: v\n    integer(kind = 4) :: nx, ny, i1, i2, j1, j2\n    real(kind = 8) :: x1, x2, y1, y2, v11, v21, v12, v22\n    real(kind = 8) :: n(4), ax(4), ay(4), av(4)\n\n    nx = size(v, 1)\n    ny = size(v, 2)\n    i1 = minloc(xq - x, dim = 1, mask = xq .ge. x)\n    j1 = minloc(yq - y, dim = 1, mask = yq .ge. y)\n    i2 = i1 + 1\n    j2 = j1 + 1\n\n    if ( i1 .eq. nx .and. j1 .ne. ny ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      v11 = v(i1,j1)\n      v21 = 0.d0\n      v12 = v(i1,j2)\n      v22 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      v11 = v(i1,j1)\n      v21 = v(i2,j1)\n      v12 = 0.d0\n      v22 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      v11 = v(i1,j1)\n      v21 = 0.d0\n      v12 = 0.d0\n      v22 = 0.d0\n    else\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      v11 = v(i1,j1)\n      v21 = v(i2,j1)\n      v12 = v(i1,j2)\n      v22 = v(i2,j2)\n    end if\n\n    ax = [ x2, x1, x2, x1 ]\n    ay = [ y2, y2, y1, y1 ]\n    av = [ v11, v21, v12, v22 ]\n    n = dabs( (ax - xq) * (ay - yq) ) / dabs( (x2 - x1) * (y2 - y1) )\n    vq = dot_product(av, n)\n    return\n  end function interp2\n"}, {"instruction": "Write a Fortran function named minmod2 that calculates the minimum of the absolute values of two real(8) numbers, considering their signs. The function takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8). The function should be used to compute the minimum value between the absolute values of the input real(8) numbers while considering their signs.", "input": "", "output": "function minmod2(a, b) result(m)\n    real(8), intent(in) :: a, b\n    real(8) :: m\n    m = ( sign(1.0d0, a) + sign(1.0d0, b) )/2.0d0*&\n        min(abs(a), abs(b))\nend function minmod2\n"}, {"instruction": "Create a Fortran function named minmod3 that takes three double precision real numbers as input parameters. The input parameters should be of type real(8). The function returns a single double precision real number as the output parameter. The function calculates the minimum of the absolute values of the input parameters and returns the result after applying the minmod function.", "input": "", "output": "function minmod3(a, b, c) result(m)\n    real(8), intent(in) :: a, b, c\n    real(8) :: m\n    m = dble(int( ( sign(1.0d0, a) + sign(1.0d0, b) + sign(1.0d0, c) )/3.0d0))*&\n        min(abs(a), abs(b), abs(c))\nend function minmod3\n"}, {"instruction": "Provide a Fortran function named to_str that converts an integer to a string. The function takes 1 input argument of type integer. The output is a single string of length 20. Use the imperative tone to write the instructions.", "input": "", "output": "    function to_str(k)\n        ! {{{\n        integer, intent(in) :: k\n        ! ---\n        character(len=20) :: to_str\n        ! }}}\n        write (to_str, *) k\n        to_str = adjustl(to_str)\n    end function to_str    \n"}, {"instruction": "Create a Fortran function named load_pnm to read a PNM (Portable Any Map) image file and store its contents in a 3D array. The function takes one input parameter of type character(*) representing the filename and returns one output parameter of type integer, allocatable, and dimension(:, :, :), representing the image array.", "input": "", "output": "  function load_pnm(filename) result(img_array)\n    !!! load_pnm\n    !!!\n    !!!   input:\n    !!!     filename(character): input filename.\n    !!!   output:\n    !!!     img_array(integer, 3d): image array.\n    !!!                             even if the image is grayscale/monochrome, the array is 3d.\n    implicit none\n    character(*), intent(in) :: filename\n    integer, allocatable, dimension(:, :, :) :: img_array\n    character(len=2) :: pnm_type\n    integer :: i, j\n    integer :: width, height, max_value, n_layer\n    integer :: iostatus = 1\n    integer, allocatable :: row(:), div_row(:), mod_row(:)\n\n    open (10, file=filename, status=\"old\", action=\"read\", position=\"rewind\")\n    read (10, *, iostat=iostatus) pnm_type\n    read (10, *, iostat=iostatus) width, height\n\n    if (pnm_type == \"p1\") then\n      n_layer = 1\n    else if (pnm_type == \"p2\") then\n      n_layer = 1\n      read (10, *, iostat=iostatus) max_value\n    else if (pnm_type == \"p3\") then\n      n_layer = 3\n      read (10, *, iostat=iostatus) max_value\n    else\n      print *, \"pnm header must be in (p1, p2, p3), the header is \", pnm_type\n      stop 1 ! how raise error?\n    end if\n\n    allocate (img_array(n_layer, height, width))\n\n    allocate (row(width*n_layer))\n    div_row = ([(i, i=0, (width*n_layer) - 1)]/n_layer) + 1 ! 1, 1, 1, 2, 2, 2, ...\n    mod_row = (mod([(i, i=0, (width*n_layer) - 1)], n_layer)) + 1 ! 1, 2, 3, 1, 2, 3, ...\n    do i = 1, height\n      read (10, *, iostat=iostatus) row\n      do j = 1, size(row)\n        img_array(mod_row(j), i, div_row(j)) = row(j)\n      end do\n      if (iostatus < 0) then\n        exit\n      end if\n    end do\n    close (10)\n    deallocate (row, div_row, mod_row)\n  end function load_pnm\n"}, {"instruction": "Create a Fortran function named diag that takes a 2D array of real numbers as input and returns a 1D array containing the elements of the main diagonal of the input array. The number of input arguments is 1 and the test_data type is ['real, dimension(:,:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(min(size(a,dim=1),size(a,dim=2)))'].", "input": "", "output": "  function diag (a) result (d)\n    real, dimension(:,:), intent(in) :: a\n    real, dimension(min(size(a,dim=1),size(a,dim=2))) :: d\n    integer :: i\n    do i = 1, min(size(a, dim = 1), size(a, dim = 2))\n       d(i) = a(i,i)\n    end do\n  end function diag\n"}, {"instruction": "Create a Fortran function named project_coords to transform 3D coordinates to 2D screen coordinates. The function takes 1 input parameter of type real array with 3 elements. The output is an integer array with 2 elements.", "input": "", "output": "    function project_coords(pos)\n\n        real, dimension(3), intent(in) :: pos\n        integer, dimension(2) :: project_coords\n\n        project_coords(1) = nint(xscale * (ez * pos(1) / pos(2)) + halfw)\n        project_coords(2) = nint(-ez * pos(3) / pos(2) + halfh)\n\n    end function\n"}, {"instruction": "Create a Fortran function named get_color_number that takes a single input argument of type character(*) and returns an integer value. The function should map the input color name to a corresponding number as follows: \"white\" to 0, \"red\" to 1, \"green\" to 2, \"blue\" to 3, \"magenta\" to 4, \"yellow\" to 5, \"cyan\" to 6, and any other input to 0.", "input": "", "output": "    function get_color_number(col)\n\n        character(*), intent(in) :: col\n        integer :: get_color_number\n\n        select case (col)\n\n            case (\"white\")\n                get_color_number = 0\n            case (\"red\")\n                get_color_number = 1\n            case (\"green\")\n                get_color_number = 2\n            case (\"blue\")\n                get_color_number = 3\n            case (\"magenta\")\n                get_color_number = 4\n            case (\"yellow\")\n                get_color_number = 5\n            case (\"cyan\")\n                get_color_number = 6\n            case default\n                get_color_number = 0\n\n        end select\n\n    end function\n"}, {"instruction": "Provide a Fortran function named charfromangle that takes a single real input argument and returns a character based on the value of the input. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [character]. The function uses a select case construct to determine the character to be returned based on the input value.", "input": "", "output": "    function charfromangle(angle)\n\n        character :: charfromangle\n        real, intent(in) :: angle\n\n        select case (nint(angle*(180/pi)))\n\n            case (-23 : 23)\n                charfromangle = \"-\"\n            case (24 : 68)\n                charfromangle = \"\\\"\n            case (69 : 113)\n                charfromangle = \"|\"\n            case (114 : 165)\n                charfromangle = \"/\"\n            case (166 :)\n                charfromangle = \"-\"\n            case (-68 : -24)\n                charfromangle = \"/\"\n            case (-113 : -69)\n                charfromangle = \"|\"\n            case (-165 : -114)\n                charfromangle = \"\\\"\n            case (: -166)\n                charfromangle = \"-\"\n\n        end select\n\n    end function\n"}, {"instruction": "Create a Fortran function named get_length_needed that calculates the number of digits needed to represent an integer. The function takes 1 input argument of type integer. The number of input arguments is 1, and the test_data type is ['integer']. It returns 1 output argument of type integer. The function should be used as follows:\n```fortran\nresult = get_length_needed(input_integer)\n```", "input": "", "output": "    pure function get_length_needed(a)\n\n        integer, intent(in) :: a\n        integer :: get_length_needed\n\n        if (a < 0) then\n            get_length_needed = int(log(real(-a))/log(10.0))+2\n        else\n            get_length_needed = int(log(real(a))/log(10.0))+1\n        end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named count_lines to determine the number of lines in a file. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input parameter represents the file unit number.", "input": "", "output": "function count_lines(un_file) result(n)\nimplicit none\ninteger:: un_file, n, k\ncharacter*1:: junk\nrewind(un_file); n=0\ndo\n        read(un_file,*,iostat=k) junk\n        if (k/=0) exit\n        n=n+1\nenddo\nrewind(un_file)\nend function count_lines\n"}, {"instruction": "Create a Fortran function named selector that takes three input parameters: an optional integer, a string of variable length, and an array of strings. The function returns a single output parameter of type character with a length of 128. The purpose of the function is to display a menu with options and allow the user to select a choice. The selected choice is returned as the output of the function.", "input": "", "output": "  function selector(title, options, n) result(choice)\n    integer, optional, intent(in) :: n\n    character(len=*), intent(in) :: title\n    character(len=*),dimension(:),intent(in) :: options\n    !character(len=:), allocatable :: choice ! requires deallocation\n    !allocate(character(len=8)::choice)\n    character(len=128) :: choice\n    integer :: i, l, ios\n    l = merge(n, size(options), present(n))\n    if (l .lt. 1) stop 'silly input'\n    if (len(choice) .lt. len(options(1))) stop 'menu choices are excessively long'\n    i = 0\n    do while ((ios.ne.0) .or. ((i.lt.1) .or. (l.lt.i)))\n       write(6,*) title\n       write(6,\"(i8,': ',a)\")(i,options(i),i=1,l)\n       read(5,*,iostat=ios,end=666) i\n    end do\n    choice = options(i)\n    return\n666 continue\n    stop 'unexpected end of file'\n  end function selector\n"}, {"instruction": "Create a Fortran function named ran to generate a random number using the linear congruential method. The function takes 1 input argument of type integer(k4b) and returns 1 output argument of type real. The input parameter is intended to be modified within the function.", "input": "", "output": "      function ran(idum)\n    \n      implicit none\n      \n      integer, parameter :: k4b=selected_int_kind(9)\n      integer(k4b), intent(inout) :: idum\n      real :: ran\n      integer(k4b), parameter :: ia=16807\n      integer(k4b), parameter :: im=2147483647\n      integer(k4b), parameter :: iq=127773\n      integer(k4b), parameter :: ir=2836\n      real, save :: am\n      integer(k4b), save :: ix=1\n      integer(k4b), save :: iy=-1,k\n      \n      if (idum <= 0 .or. iy < 0) then\n          am=nearest(1.0,-1.0) / im\n          iy = ior(ieor(888889999,abs(idum)),1)\n          ix = ieor(777755555,abs(idum))\n          idum = abs(idum) + 1\n      end if\n      ix=ieor(ix,ishft(ix,13))\n      ix=ieor(ix,ishft(ix,-17))\n      ix=ieor(ix,ishft(ix,5))\n      k = iy / iq\n      iy = ia * (iy-k*iq) - ir * k\n      if (iy < 0) iy = iy + im\n      ran=am*ior(iand(im,ieor(ix,iy)),1)\n      end function ran \n"}, {"instruction": "Create a Fortran function named check_early_termination that evaluates whether the termination condition is met based on the number of evaluations, maximum allowed evaluations, and a critical estimation flag. The function takes 3 input parameters of type integer, integer, and logical. It returns 1 output parameter of type logical.", "input": "", "output": "function check_early_termination(maxfun, num_eval, crit_estimation) result(is_termination)\n\n    !/* external objects    */\n\n    logical                         :: is_termination\n\n    integer, intent(in)             :: num_eval\n    integer, intent(in)             :: maxfun\n\n    logical, intent(in)             :: crit_estimation\n\n!------------------------------------------------------------------------------\n! algorithm\n!------------------------------------------------------------------------------\n\n    is_termination = (num_eval == maxfun) .and. crit_estimation .and. (.not. maxfun == zero_int)\n\n    ! we also want to allow for a gentle termination by the user.\n    if (.not. is_termination) inquire(file='.stop.respy.scratch', exist=is_termination)\n\nend function\n"}, {"instruction": "Create a Fortran function named wrap_string_index that takes three input parameters of type character(len=*), integer, and integer, and one output parameter of type integer. This function finds the index of the last space (' ') in the substring of the input string, starting at position 'istart' and within 'width' characters. If the string is shorter than 'width', the function returns 0.", "input": "", "output": "  function wrap_string_index(string,istart,width) result(w)\n\n    ! finds last space (' ') in string at or before position 'width' of substring string(istart:)\n    ! returns index of space, or 0 if string is shorter than width.\n    character(len=*),intent(in)::string\n    integer,intent(in)::istart\n    integer,intent(in)::width\n    integer::w\n    integer::lstring,i\n    lstring=len(string)\n    if(lstring.le.istart+width-1) then\n      w=0\n    else\n      i=istart+width !because we can accept the final character of a word being at the extremity of the line\n      do while(string(i:i).ne.' ')\n        i=i-1\n        if(i.eq.0) exit\n      end do\n      if(i.eq.0) then\n        w=istart+width-1 ! if no spaces, truncate string mid-stream\n      else\n        w=i\n      end if\n    end if\n    return\n  end function wrap_string_index\n"}, {"instruction": "Create a Fortran function named opt_takes_value to check if the input argument corresponds to a specific type. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  function opt_takes_value(type) result (l)\n    integer,intent(in)::type\n    logical::l\n    l=.false.\n    if((type.eq.arg_int).or.(type.eq.arg_float).or.(type.eq.arg_char)) l=.true.\n    return\n  end function opt_takes_value\n"}, {"instruction": "Write a Fortran function named hex to convert an integer representing a byte into a hexadecimal string. The function should have 1 input parameter with the test_data type ['integer'] and 1 output parameter with the test_data type ['character(len=2)']. Use the imperative tone in the instructions.", "input": "", "output": "   function hex(byte)\n      integer, intent(in) :: byte\n      character(len=2) :: hex\n      character(len=1), parameter :: hex_digits(0:15) = (/ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' /)\n      integer :: m1, m2\n\n      m1 = mod(byte,16)\n      m2 = mod(byte/16,16)\n      hex = hex_digits(m2)//hex_digits(m1)\n      \n   end function\n"}, {"instruction": "Create a Fortran function named xorshift32 to perform the XORSHIFT32 algorithm. The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "  pure function xorshift32(i)\n    implicit none\n    integer(4), intent(in) :: i\n    integer(4) :: xorshift32\n    if (i == 0) then\n      xorshift32 = 1231767121\n    else\n      xorshift32 = i\n    end if\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, 13))\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, -17))\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, 15))\n  end function xorshift32\n"}, {"instruction": "Create a Fortran function named all_ones_consecutive to determine if an array of 18 integers contains consecutive ones. The function should take 1 input parameter of type integer, dimension(18), and return 1 output parameter of type logical.", "input": "", "output": "\tfunction all_ones_consecutive(array)\n\t\tinteger, dimension(18) :: array\n\t\tlogical :: all_ones_consecutive\n\t\tinteger :: first_one_index, last_one_index, i, sum_result\n\n\t\ti = 1\n\t\tdo while(i <= 18)\n\t\t\tif(array(i) == 1) then\n\t\t\t\tfirst_one_index = i\n\t\t\t\texit\n\t\t\tend if\n\t\t\ti = i + 1\n\t\tend do\n\n\t\ti = 18\n\t\tdo while(i >= 1)\n\t\t\tif(array(i) == 1) then\n\t\t\t\tlast_one_index = i\n\t\t\t\texit\n\t\t\tend if\n\t\t\ti = i - 1\n\t\tend do\n\n\t\tsum_result = 0\n\t\tdo i = first_one_index, last_one_index\n\t\t\tsum_result = sum_result + array(i)\n\t\tend do\n\n\t\tif(last_one_index - first_one_index + 1 == sum_result) then\n\t\t\tall_ones_consecutive = .true.\n\t\telse\n\t\t\tall_ones_consecutive = .false.\n\t\tend if\t\t\t\t\t\t\n\tend function all_ones_consecutive\n"}, {"instruction": "Create a Fortran function named lnprefsol to calculate the natural logarithm of a preference factor. The function takes 3 input parameters of types integer(8), integer(8), and real(8). The output is a single real(8) value.", "input": "", "output": "function lnprefsol(dn, n1at, vol) result(res)\n  real(8) :: res\n  ! type(solubdata), intent(in) :: sd\n  integer(8), intent(in) :: dn, n1at\n  real(8), intent(in) :: vol\n  real(8) :: pref, dnr, nar\n  integer :: i\n  pref = 1.0\n  if(abs(dn) < 10_8) then\n    if(dn > 0_8) then\n      do i  = 1,dn\n        pref = pref * vol / real(n1at + i, 8)\n      end do\n    else\n      do i = 0, -dn-1\n        pref = pref * real(n1at - i, 8) / vol\n      end do\n    end if\n    res = log(pref)\n  else\n    dnr = real(dn, 8)\n    nar = real(n1at, 8)\n    res = dnr*log(vol) - log_gamma(nar+dnr) + log_gamma(nar)\n  end if\nend function\n"}, {"instruction": "Write a Fortran function named decay that calculates the decay function for a given input array and parameters. The function takes 3 input parameters of type double precision, including a 2D array, a single value, and an integer. The output is a double precision 2D array of size natoms x natoms. Use the imperative tone and specify the input and output parameter types as requested.", "input": "", "output": "function decay(r, invrc, natoms) result(f)\n\n    implicit none\n\n    double precision, intent(in), dimension(:,:) :: r\n    double precision, intent(in) :: invrc\n    integer, intent(in) :: natoms\n    double precision, dimension(natoms, natoms) :: f\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n\n    f = 0.5d0 * (cos(pi * r * invrc) + 1.0d0)\n\n\nend function decay\n"}, {"instruction": "Create a Fortran function named concat that takes two integer arrays as input and returns a concatenated integer array as output. The number of input arguments is 2 and the test_data type is ['integer, allocatable, dimension(:)', 'integer, allocatable, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, allocatable, dimension(:)'].", "input": "", "output": " function concat (ia, ib) result (ic)\n   integer, allocatable, dimension(:) :: ia, ib, ic\n   if (allocated (ia) .and. allocated (ib)) then\n     ic = [ia, ib]\n   else if (allocated (ia)) then\n     ic = ia\n   else if (allocated (ib)) then\n     ic = ib\n   end if\n end function concat\n"}, {"instruction": "Write a Fortran function named get_index that calculates the index of a variable in a multi-dimensional array based on the given latitude, longitude, level, and variable type. The function takes 4 input parameters of type integer: lat_index, lon_index, lev_index, and var_type. It returns a single output parameter of type integer.", "input": "", "output": "function get_index(lat_index, lon_index, lev_index, var_type)\n!------------------------------------------------------------------\n!\ninteger,  intent(in) :: lat_index, lon_index, lev_index, var_type\ninteger              :: get_index\n\nget_index = 1 + var_type + (lev_index - 1)*state_num_3d      &\n                         + (lat_index - 1)*state_num_3d*nz   &\n                         + (lon_index - 1)*state_num_3d*nz*ny\n\nend function get_index\n"}, {"instruction": "Write a Fortran function named nccf_free_coord to free the memory associated with a coordinate ID. The function takes 1 input parameter of type integer(c_int) and value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "       function nccf_free_coord(coordid) result(stat) &\n         &                           bind(c, name=\"nccf_free_coord\")\n          use iso_c_binding\n          implicit none\n          integer(c_int), value     :: coordid\n          integer(c_int)            :: stat\n       end function\n"}, {"instruction": "Create a Fortran function named sils_idiag that calculates the displacement from the start of an assembled matrix, of order ix, to the diagonal entry in its row iy. The function will take 2 input parameters of type integer (ix, iy) and return an output parameter of type integer.", "input": "", "output": "       function sils_idiag( ix, iy )\n\n!  obtain the displacement from the start of the assembled matrix (of order ix)\n!  of the diagonal entry in its row iy\n\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n\n       integer :: sils_idiag\n       integer, intent( in ) :: ix, iy\n\n       sils_idiag = ( ( iy - 1 ) * ( 2 * ix - iy + 2 ) ) / 2\n       return\n\n\n       end function sils_idiag\n"}, {"instruction": "Create a Fortran function named csndset to calculate the hindered settling correction for noncohesive sediment of class ns. The function should have 3 input parameters of type integer, real, and real, and 1 output parameter of type real. The function should be defined using the imperative tone.", "input": "", "output": "function csndset(snd,sden,iopt)\n  !\n  ! change record\n  ! **  calculates hindered settling correction for class ns noncohesive\n  ! **  sediment\n\n  implicit none\n  \n  integer :: iopt\n  real :: csndset,snd,sden,ropt\n\n  ropt=float(iopt)\n  csndset=(1.-sden*snd)**ropt\n\nend function\n"}, {"instruction": "Create a Fortran function named \"kron\" to compute the Kronecker product of two matrices. The number of input arguments is 2 with the test_data type ['real(kind=8), dimension(:,:)','real(kind=8), dimension(:,:)']. The number of output arguments is 1 with the test_data type ['real(kind=8), dimension(size(a,1)*size(b,1),size(a,2)*size(b,2))'].", "input": "", "output": "function kron(a,b) result(c)\n!\n!   copyright 2017, viktor reshiak, all rights reserved.\n!\n!\n!   purpose\n!   =======\n!   kronecker product of two matrices\n!\n!\n!   in\n!   ==\n!   1) na1 - first  dimension of array a\n!   2) na2 - second dimension of array a\n!   3) a   - array\n!   4) nb1 - first  dimension of array b\n!   5) nb2 - second dimension of array b\n!   6) b   - array\n!\n!\n!   inout\n!   =====\n!   1) c  - resulting matrix\n!\n!\n\timplicit none\n\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    ! dummy arguments\n    real(kind=8), intent(in), dimension(:,:) :: a\n    real(kind=8), intent(in), dimension(:,:) :: b\n\n    real(kind=8), dimension(size(a,1)*size(b,1),size(a,2)*size(b,2))    :: c\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    integer(kind=4) :: i, j\n    integer(kind=4), dimension(2) :: sh_a, sh_b\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    sh_a = shape(a)\n    sh_b = shape(b)\n\n    do i = 1,sh_a(1)\n        do j = 1,sh_a(2)\n            c((i-1)*sh_b(1)+1:i*sh_b(1),(j-1)*sh_b(2)+1:j*sh_b(2)) = a(i,j) * b\n        enddo\n    enddo\n\nend function kron\n"}, {"instruction": "Create a Fortran function named new_ext that takes two input parameters of type character with unspecified length. This function aims to add a new file extension to the given file name. The number of input arguments is 2, and the test_data type is ['character(len = *)', 'character(len = *)']. It also returns an output parameter of type character with a length of 256. The function should be used as follows: `new_ext(file_name, extension)`.", "input": "", "output": "function new_ext(file_name, extension)\n\n    implicit none\n    character(len = *), intent(in)  :: file_name  ! file to add new extension to\n    character(len = *), intent(in)  :: extension  ! new extension to add\n    character(len = 256)            :: new_ext    ! file name with new extension\n    integer                         :: dot_pos    ! position of extension dot\n\n    dot_pos = scan(trim(file_name), '.', back = .true.)\n    if (dot_pos > 0) then\n        new_ext = file_name(1:dot_pos - 1) // extension\n    else\n        new_ext = trim(file_name) // extension\n    end if\n\nend function new_ext\n"}, {"instruction": "Create a Fortran function named s_hssw_bolt to calculate the value of s based on the given input parameters. The function takes 4 input arguments of type real*8, namely phi, t, lambda, and k. It returns 1 output argument of type real*8.", "input": "", "output": "  function s_hssw_bolt(phi,t,lambda,k) result(s)\n    implicit none\n    real * 8, intent(in) :: phi !volume fraction value\n    real * 8, intent(in) :: t !temperature\n    real * 8, intent(in) :: lambda !square well range\n    real * 8, intent (in) :: k !value of the wave vector\n    real * 8 :: s, x, lk, k3, l3\n    k3=k * k * k\n    x = exp(1.d0/t) - 1.d0\n    lk = lambda * k\n    s = 0.d0\n    if (k > 0.075d0) then\n      s = sin(lk) - sin(k) + k * cos(k) - lk * cos(lk)\n      s = s * x\n      s = s + k * cos(k) - sin(k)\n      s = s / k3\n    else\n      l3 = lambda * lambda * lambda\n      s = (x * (l3 - 1.d0) - 1.d0) / 3.d0\n    end if\n    s = 1.d0 + (24.d0 * phi * s )\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named s_hssw_stos to perform a complex mathematical computation. The function takes 4 input parameters of type real * 8 and returns 1 output parameter of type real * 8. This function implements a series of mathematical operations involving complex numbers and constants to compute a result based on the input parameters.", "input": "", "output": "  function s_hssw_stos (phi,t,lambda,k) result(s)\n    implicit none\n    integer :: i1\n    real * 8, intent(in) :: phi, t, lambda, k\n    real * 8 :: s\n    real * 8 :: a0,a01,l1,l2,s1,s2,s3,sw_tau !f(t) parameters\n    real * 8 :: alpha1,alpha2,alpha3,beta1,beta2,beta3,beta4,gamma0,gamma1,gamma2 !l2 parameters\n    real * 8 :: lam1,lam2,lam3,lam4,lam5,lam6,tau1,tau2 !convenient dummies variables\n    complex * 16 :: ftp,ftm,gtp,gtm !f(t),f(-t),g(t),g(-t)\n    real * 8 :: ftdum1,ftdum2,ftdum3\n    real * 8 dum1,dum2,dum3\n    complex * 16 :: im\n    real * 8 dumeta\n    dumeta=phi\n    im=(0.d0,1.d0)\n    !allocate (ftp(kpoints))\n    !allocate (ftm(kpoints))\n    !allocate (gtp(kpoints))\n    !allocate (gtm(kpoints))\n    lam1=lambda\n    lam2=lam1**2\n    lam3=lam1**3\n    lam4=lam1**4\n    lam5=lam1**5\n    lam6=lam1**6\n    !a0\n    a0=exp(1.d0/t)-1.d0\n    !a0 prima\n    a01=a0*((lam1-1.d0)**2)\n    !print*, \"a01=\",a01\n    !square well tau\n    sw_tau=1.d0/(12.d0*a0*lam1*(lam1-1.d0))\n    tau1=1.d0/sw_tau\n    !print*, \"tau1=\",tau1\n    tau2=1.d0/(sw_tau**2)\n    !print*, \"tau2=\",tau2\n    !alpha 1\n    alpha1=2.d0*a01*(2.d0+lam1)+((1.d0+(4.d0*lam1)+lam2-3.d0*a01)*tau1/6.d0)\n    !print*, \"alpha1\", alpha1\n    !alpha2\n    alpha2=3.d0+a01*(7.d0+2.d0*lam1-3.d0*lam2)-((7.d0+lam1+16.d0*lam2+a01*&\n    &(23.d0+15.d0*lam1+15.d0*lam2+7.d0*lam3))*tau1/12.d0)\n    !print*, \"alpha2\", alpha2\n    !alpha3\n    alpha3=-2.d0-2.d0*a01*(1.d0+2.d0*lam1+3.d0*lam2)+((7.d0+lam1-2.d0*lam2+a01*&\n    &(7.d0+15.d0*lam1+21.d0*lam2+11.d0*lam3+6.d0*lam4))*tau1/6.d0)\n    !print*, \"alpha3\", alpha3\n    !beta1\n    beta1=-4.d0-4.d0*a01*(2.d0+lam1)-(tau2/3.d0)+((5.d0+2.d0*lam1-lam2+3.d0*a01)*tau1/3.d0)\n    !print*, \"beta1\", beta1\n    !beta2\n    beta2=6.d0+6.d0*a01*(3.d0+2.d0*lam1+lam2)+4.d0*(a01**2)*((2.d0+lam1)**2)&\n    &-((9.d0*(3.d0+lam1)+a01*(59.d0+51.d0*lam1+3.d0*lam2-5.d0*lam3)&\n    &+12.d0*(a01**2)*(2.d0+lam1))*tau1/6.d0)+((31.d0+8.d0*lam1+18.d0*lam2&\n    &-4.d0*lam3+lam4+12.d0*a01*(5.d0+lam1)+9.d0*(a01**2))*tau2/36.d0)\n    !print*, \"beta2\", beta2\n    !beta3\n    beta3=-4.d0-12.d0*a01*(1.d0+lam1+lam2)-4.d0*(a01**2)*(2.d0+lam1)*(1.d0&\n    &+2.d0*lam1+3.d0*lam2)+((3.d0*(4.d0+lam1+lam2)+a01*(29.d0&\n    &+36.d0*lam1+30.d0*lam2+7.d0*lam3-3.d0*lam4)+(a01**2)&\n    &*(17.d0+43.d0*lam1+30.d0*lam2+lam3-lam4))*tau1/3.d0)-((29.d0+13.d0*lam1&\n    &+27.d0*lam2+7.d0*lam3-4.d0*lam4+a01*(68.d0+80.d0*lam1+80.d0*lam2+16.d0*lam3&\n    &+7.d0*lam4+lam5)+3.d0*(a01**2)*(13.d0+13.d0*lam1+lam2-3.d0*lam3))*tau2/36.d0)\n    !print*, \"beta3\", beta3\n    !beta4 be ware, modified from the article\n    dum1=(1.d0+a01*(1.d0+2.d0*lam1+3.d0*lam2))**2\n    dum2=2.d0*a01*(7.d0+15.d0*lam1+15.d0*lam2+5.d0*lam3+6.d0*lam4)\n    dum3= a01*a01*(1.d0+2.d0*lam1+3.d0*lam2)*(7.d0+15.d0*lam1+3.d0*lam2-lam3)\n    dum2=7.d0+lam1+4.d0*lam2+dum2+dum3\n    beta4=dum1-(dum2*tau1/6.d0)\n    dum1=49.d0+38.d0*lam1+9.d0*lam2+8.d0*lam3+16.d0*lam4\n    dum2=2.d0*a01*(49.d0+88.d0*lam1+112.d0*lam2+80.d0*lam3+35.d0*lam4-4.d0*lam5)\n    dum3=a01*a01*(49.d0+138.d0*lam1+219.d0*lam2+124.d0*lam3+27.d0*lam4+18.d0*lam5+lam6)\n    dum1=dum1+dum2+dum3\n    dum1=dum1*tau2/144.d0\n    beta4=beta4+dum1\n    !print*, \"beta4\",beta4\n    !gamma0\n    gamma0=1.d0+lam1-(tau1/6.d0)\n    !print*, \"gamma0\",gamma0\n    !gamma1\n    gamma1=2.d0*(1.d0+lam1-lam2)-((3.d0+lam3)*tau1/6.d0)\n    !print*, \"gamma1\",gamma1\n    !gamma2\n    gamma2=lam1*(-4.d0*lam1+((2.d0+3.d0*lam1+lam2+lam3)*tau1/3.d0))\n    !print*, \"gamma2\",gamma2\n    !l2\n    l2=-1.d0+(alpha1*dumeta)+(alpha2*dumeta**2)+(alpha3*dumeta**3)+((1.d0+2.d0*dumeta)*&\n    &dsqrt(1.d0+(beta1*dumeta)+(beta2*dumeta**2)+(beta3*dumeta**3)+(beta4*dumeta**4)))\n    l2=l2/(12.d0*dumeta*(gamma0+gamma1*dumeta+gamma2*dumeta**2))\n    !print*, \"l2\",l2\n    !l1\n    l1=1.d0+0.5d0*dumeta+2.d0*dumeta*(1.d0+lam1+lam2)*l2-0.5d0*dumeta*a01*(3.d0+2.d0*lam1+lam2)\n    l1=l1/(1.d0+2.d0*dumeta)\n    !print*, \"l1\",l1\n    !s1\n    s1=(-1.5d0+2.d0*(1.d0+lam1+lam2)*l2-0.5d0*(3.d0+2.d0*lam1+lam2)*a01)!care inconsistency\n    s1=s1*(dumeta/(1.d0+2.d0*dumeta))\n    !print*, \"s1\",s1\n    !s2\n    s2=(-1.d0+dumeta+2.d0*(1.d0-2.d0*dumeta*lam1*(1.d0+lam1))*l2-(1.d0-dumeta*((1.d0+lam1)**2))*a01)\n    s2=s2/(2.d0*(1.d0+2.d0*dumeta))\n    !print*, \"s2\",s2\n    !s3\n    s3=(-(((1.d0-dumeta)**2)/(12.d0*dumeta))-(0.5d0*(lam1+1.d0)-dumeta*lam2)*l2)\n    s3=s3+(4.d0+2.d0*lam1-dumeta*(3.d0*lam2+2.d0*lam1+1.d0))*(a01/12.d0)\n    s3=s3/(1.d0+2.d0*dumeta)\n    !print*, \"s3\",s3\n    !f(t)->f(ik)\n    ftdum1=l1+(l2/(lam1-1.d0))-a0*(lam1-1.d0)\n    ftdum2=l2/(lam1-1.d0)\n    ftdum3=lam1-1.d0\n    !do i1=1, kpoints\n      !ftp(i1)=cmplx(1.d0+a0,0)+cmplx(0.d0,ftdum1*k(i1))-(cmplx(a0,ftdum2*k)*exp(cmplx(0.d0,-ftdum3*k)))\n      !ftp(i1)=-ftp(i1)/cmplx((1.d0-s2*(k**2)),(s1*k-s3*(k**3)))/(12.d0*eta)\n      !ftm(i1)=cmplx(1.d0+a0,0)+cmplx(0.d0,-ftdum1*k)-(cmplx(a0,-ftdum2*k)*exp(cmplx(0.d0,ftdum3*k)))\n      !ftm(i1)=-ftp(i1)/cmplx(12.d0*eta*(1.d0-s2*(k**2)),-12.d0*eta*(s1*k-s3*(k**3)))\n      ftp=(1.d0+a0+ftdum1*(im*k))-(a0+ftdum2*(im*k))*exp(-ftdum3*(im*k))\n      ftp=ftp/(1.d0+(s1*(im*k))+(s2*(im*k)**2)+(s3*(im*k)**3))\n      ftp=-ftp/(12.d0*dumeta)\n      ftm=(1.d0+a0+ftdum1*(-im*k))-(a0+ftdum2*(-im*k))*exp(-ftdum3*(-im*k))\n      ftm=ftm/(1.d0+(s1*(-im*k))+(s2*(-im*k)**2)+(s3*(-im*k)**3))\n      ftm=-ftm/(12.d0*dumeta)\n      !g(t)->g(ik)\n      !gtp(i1)=cmplx(0.d0,k)*ftp(i1)*exp(cmplx(0.d0,-k))/(cmplx(1.d0,0.d0)+12.d0*eta*ftp(i1)*exp(cmplx(0.d0,-k)))\n      gtp=(im*k)*ftp*exp(-im*k)/(1.d0+12.d0*dumeta*ftp*exp(-im*k))\n      !g(-t)->g(-ik)\n      !gtm(i1)=cmplx(0.d0,-k)*ftm(i1)*exp(cmplx(0.d0,k))/(cmplx(1.d0,0.d0)+12.d0*eta*ftm(i1)*exp(cmplx(0.d0,k)))\n      gtm=(-im*k)*ftm*exp(im*k)/(1.d0+12.d0*dumeta*ftm*exp(im*k))\n\n      s=realpart((gtp-gtm)/(im*k))\n      s=1.d0-(12.d0*dumeta*s)\n      !s=realpart(gtm(i1))\n    !end do\n  end function\n"}, {"instruction": "Create a Fortran function named u_hssw that takes two 8-byte real numbers as input parameters, denoted as r and lambda, and returns a single 8-byte real number as the output parameter. The function checks if the value of r falls within the range of 1 and lambda; if it does, the function returns -1.0, otherwise, it returns 0.0.", "input": "", "output": "  function u_hssw(r,lambda) result(u)\n    implicit none\n    real * 8, intent(in) :: r,lambda\n    real * 8 :: u\n    if ( 1.d0 <= r .and. r <= lambda) then\n      u = -1.d0\n    else\n      u = 0.d0\n    end if\n  end function\n"}, {"instruction": "Write a Fortran function named f_phic_aux that calculates the value of a polynomial function. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The input and output parameters must be of type real*8.", "input": "", "output": "  function f_phic_aux(phi) result(f)\n    implicit none\n    real * 8, intent(in) :: phi\n    real * 8 :: f\n    real * 8 :: phi5, phi4, phi3, phi2\n    phi2 = phi  * phi\n    phi3 = phi2 * phi\n    phi4 = phi3 * phi\n    phi5 = phi4 * phi\n    f = -phi5 + 5.d0*phi4 -4.d0*phi3 -20.d0*phi2 -5.d0*phi + 1.d0\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named p_root_hssw_aux to compute the value of p based on the provided input parameters. The function has 4 input parameters of type real * 8: ft, lambda, pc, and phi, and 1 output parameter of type real * 8.", "input": "", "output": "  function p_root_hssw_aux(ft,lambda,pc,phi) result(p)\n    implicit none\n    real * 8, intent(in) :: ft, lambda, pc,phi\n    real * 8 :: p\n    real * 8 :: phi2,phi3,phim3\n    phi2 = phi * phi\n    phi3 = phi2 * phi\n    phim3 = (1.d0 - phi) ** 3\n    p = (phi * (1.d0 + phi + phi2 - phi3) / phim3) - (4.d0 * (lambda ** 3 - 1.d0)* ft * phi2) - pc\n  end function\n"}, {"instruction": "Create a Fortran function named roots_phi_s_aux that takes 3 real*8 input parameters: ft, lambda, and phi. The function calculates a result of type real*8 and returns it as the output parameter.", "input": "", "output": "  function roots_phi_s_aux(ft,lambda,phi) result(f)\n    implicit none\n    real * 8, intent(in) :: ft,lambda,phi\n    real * 8 :: f\n    real * 8 :: a\n    real * 8 :: phim4, phi2\n    phi2 = phi * phi\n    phim4 = (1.d0 - phi) ** 4\n    a = -8.d0 * ft * (lambda ** 3 - 1.d0)\n    f = a * phi * phim4 + 8.d0 * phi - 2.d0 * phi2 + phim4\n  end function\n"}, {"instruction": "Create a Fortran function named p1 that takes two 8-byte real numbers as input arguments and returns an 8-byte real number as the output. The function computes a mathematical expression based on the input values and returns the result.", "input": "", "output": "  function p1(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,k3, ka2,a2,a3\n    ka = k*a\n    k3 = k**3\n    a2 = a*a\n    ka2 = ka*ka\n    if (ka < 0.075 ) then\n        a3=a2*a\n        p = ( (10.d0 - ka2)/(30.d0) )\n        p = p * a3\n    else\n      p = ( sin(ka) - ka * cos(ka) ) / k3\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named p2 to compute the value of p based on the input parameters k and a. The input parameters are both of type real * 8. The function returns a single output parameter p, which is also of type real * 8.", "input": "", "output": "  function p2(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,k2,k4, ka2, a4\n    ka = k*a\n    k2 = k**2\n    ka2 = ka * ka\n    k4 = k2 * k2\n    a4 = a**4\n    if (ka < 0.075 ) then\n      p = (2.d0/k4) + a4*(0.25d0 - (1.d0 / 36.d0) * ka2)\n    else\n      p = ( 2.d0*ka*sin(ka) +( 2.d0-ka2 )*cos(ka) ) / k4\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named p4 that takes two double precision real numbers as input arguments. The input arguments have the test_data type ['real * 8', 'real * 8']. The function returns a double precision real number as its output, with the test_data type ['real * 8']. This function computes a mathematical operation using the input arguments and conditional statements to determine the value to be returned.", "input": "", "output": "  function p4(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,ka2,ka4,k2,k4,k6,a6,a4\n    ka = k*a\n    ka2 = ka * ka\n    ka4 = ka2 * ka2\n    k2 = k*k\n    k4 = k2 * k2\n    k6 = k4 * k2\n    ka2 = ka * ka\n    a6 = a**6\n    a4 = a**4\n    if (ka < 0.075 ) then\n      p = (-24.d0/k6) + a6 * ( (1.d0/6.d0) - (1.d0/48.d0) * ka2 )\n    else\n      p = ( (4.d0*ka*(ka2-6.d0))* sin(ka) - (ka4 - 12.d0*ka2 + 24.d0) * cos(ka) ) / k6\n    end if\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named find_sizes to calculate the sizes of clusters in a labelled matrix. The function takes two input parameters: a 2D array of integers labelled_matrix and an integer num_labels. It returns one output parameter: an allocatable 1D array of integers sizes.", "input": "", "output": "        function find_sizes(labelled_matrix, num_labels) result(sizes)\n            !! count the number of sites belonging to each cluster\n            !! in the labelled matrix.\n\n            integer, dimension(:), allocatable :: sizes\n                !! array of cluster sizes. the i'th element is the size of\n                !! the cluster with label i.\n\n            integer, dimension(:,:), intent(in) :: labelled_matrix\n                !! integer matrix with labelled clusters, resulting from\n                !! the hoshen-kopelman algorithm.\n\n            integer, intent(in) :: num_labels\n                !! the known number of clusters.\n\n            integer :: l,i,j\n\n            l = size(labelled_matrix,1)\n            allocate(sizes(num_labels))\n            sizes(:) = 0\n\n            do j=1,l\n                do i=1,l\n                    associate (label => labelled_matrix(i,j))\n                        if(label /= 0) then\n                            sizes(label) = sizes(label) + 1\n                        end if\n                    end associate\n                end do\n            end do\n        end function\n"}, {"instruction": "Write a Fortran function named compute_sum to calculate the average of a series of random floating-point numbers. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input data type is ['integer'] and the output data type is ['real'].", "input": "", "output": "    function compute_sum(n) result(r)\n        implicit none\n        integer, intent(in) :: n\n        real :: r, sum, x\n        integer :: i\n        do i = 1, n\n            call random_number(x)\n            sum = sum + x\n        end do\n        r = sum/n\n    end function compute_sum\n"}, {"instruction": "Write a Fortran pure function named usage to estimate the memory usage of an algorithm. The function takes 4 input parameters of type integer, which are n_grids, n_fd, nc_block, and accuracy. The nc_block parameter is an array of 3 integers. The function returns a single integer representing the estimated memory usage.", "input": "", "output": "  pure function usage( n_grids, n_fd, nc_block, accuracy ) result( reals )\n    !!-----------------------------------------------------------\n    !! estimate memory usage of an algorithm that needs n_grids grids\n    !! without halos and n_fd grids with halos\n    !!\n    !! written by i.j. bush\n    !!-----------------------------------------------------------\n    integer :: reals\n\n    integer,                   intent( in ) :: n_grids\n    integer,                   intent( in ) :: n_fd\n    integer, dimension( 1:3 ), intent( in ) :: nc_block\n    integer,                   intent( in ) :: accuracy\n\n    integer :: grid\n    integer :: fd\n\n    grid = n_grids * product( nc_block )\n    fd   = n_fd    * product( nc_block + 1 + accuracy )\n\n    reals = grid + fd\n\n  end function usage\n"}, {"instruction": "Create a Fortran function named sqrt_to_odd1 to find the nearest odd integer to the square root of a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function sqrt_to_odd1(n2) result(od)\ninteger  :: n2, od\ninteger  :: j, k\n! gieven input n2, find closest od >= 3, such that od^2 == n2\n\nj  = floor( (sqrt(real(n2))-1.)/2. )\nk  = j+1\n\nj  = 2*j+1  ! odd\nk  = 2*k+1  ! odd\n\nif (n2 - j**2 <= k**2 - n2) then\n  od = j\nelse\n  od = k\nend if\nod = max(1, od)\n\nend function\n"}, {"instruction": "Create a Fortran function named get_diagonal to extract the diagonal elements of a matrix. The function takes 1 input parameter of type real(kind=8), dimension(:,:), and returns 1 output parameter of type real(kind=8), dimension(minval(shape(a))).", "input": "", "output": "function get_diagonal(a) result(diag)\n\t! get diagonal elements of matrix a (general [m x n] dimensions)\n\timplicit none\n\treal(kind=8), dimension(:,:), intent(in) :: a\n\treal(kind=8), dimension(minval(shape(a))) :: diag\n\t! local variables\n\tinteger :: i\n\n\tforall (i=1:size(diag)) diag(i) = a(i,i)\n\nend function get_diagonal\n"}, {"instruction": "Create a Fortran function named ones_like_2d to generate a 2D array filled with ones that has the same dimensions as the input array. The number of input arguments is 1 and the test_data type is [real(kind=8), dimension(:,:)]. The number of output arguments is 1 and the test_data type is [real(kind=8), dimension(:,:), allocatable].", "input": "", "output": "function ones_like_2d(arr) result(ones)\n\timplicit none\n\treal(kind=8), dimension(:,:), intent(in) :: arr\n\treal(kind=8), dimension(:,:), allocatable :: ones\n\tinteger, dimension(2) :: dims\n\n\tdims = shape(arr)\n\tallocate(ones(dims(1), dims(2)))\n\tones = 1.d0\nend function ones_like_2d\n"}, {"instruction": "Create a Fortran function called linspace that generates an array of evenly spaced values within a specified range. The function takes 3 input parameters of type real(kind=8), real(kind=8), and integer, and returns 1 output parameter of type real(kind=8) with a dimension specified by the input integer.", "input": "", "output": "function linspace(xmin, xmax, num) result(x)\n    implicit none\n    real(kind=8), intent(in) :: xmin, xmax\n    integer, intent(in) :: num\n    real(kind=8), dimension(num) :: x\n    integer :: i\n    if (num == 1) then\n       if(xmin /= xmax) then\n          write(0,'(\"error: cannot call linspace with n=1 and xmin /= xmax\")')\n          stop\n       else\n          x = xmin\n       end if\n    else\n       do i=1,num\n          x(i) = (xmax-xmin) * real(i-1, kind=8) / real(num-1, kind=8) + xmin\n       end do\n    end if\nend function linspace\n"}, {"instruction": "Create a Fortran function named cuda_set_device to set the active CUDA-enabled device on which to run the subsequent CUDA kernel code. The function takes 1 input parameter of type integer(c_int), passed by value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "    function cuda_set_device(i_gpu) result(ierr) bind(c)\n      use iso_c_binding, only: c_int\n      implicit none\n      integer(c_int), value :: i_gpu\n      integer(c_int) :: ierr\n    end function\n"}, {"instruction": "Create a Fortran function named numb2str_int that converts an integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character(1024).", "input": "", "output": "      function numb2str_int (inumb) result(res)\n      ! converts an integer to string\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: inumb\n         character(1024)      :: res\n      \n         !### var ###!\n         \n         !### code ###!\n         write(res,*) inumb\n      \n      end function\n"}, {"instruction": "Write a Fortran function named \"numb2str_double\" to convert a real(8) number to a string. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type character(1024).", "input": "", "output": "      function numb2str_double (fnumb) result(res)\n      ! converts an real(8) to string\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(in)  :: fnumb\n         character(1024)      :: res\n         \n         !### var ###!\n         \n         !### code ###!\n         write(res,*) fnumb\n      \n      end function\n"}, {"instruction": "Create a Fortran function named yes_no that takes a single input argument of type character (*) and returns a logical value. The function prompts the user with the input string followed by ' [y/n]', reads the user's response, and returns .true. if the response is 'y' and .false. if the response is 'n'. If the user enters an invalid response, the function prompts the user to enter 'yes' or 'no' until a valid response is received.", "input": "", "output": "     function yes_no(string)\n\n       implicit none \n       character (*), intent(in) :: string\n       character (len = 10)      :: answer\n       character                 :: y_n, y, n \n       logical                   :: yes_no\n\n       write(*,*) trim(string), ' [y/n]'\n       read(*,*)  answer\n\n       do \n          y_n = answer(1 : 1)\n          y = 'y'\n          n = 'n'\n       \n          if (y_n .eq. y) then \n             yes_no = .true.\n             exit\n          else if (y_n .eq. n) then \n             yes_no = .false.\n             exit\n          else\n             write(*,*)\n             write(*,*) '    plaese, answer yes or no'\n             read(*,*)  answer\n          endif\n       enddo\n\n     end function yes_no\n"}, {"instruction": "Write a Fortran function named lowercase, which converts a given input word to lower case. The function must have 1 input parameter of type character (len=*), and 1 output parameter of type character (len=32). Ensure that the generated instructions use the imperative tone.", "input": "", "output": "     elemental function lowercase(word)\n!\n!-----------------------------------------------------------------------\n!\n! convert a word to lower case\n!\n      character (len=32)              :: lowercase\n      character (len=*) , intent(in) :: word\n      integer :: i,ic,nlen\n      nlen = len(word)\n      if(nlen >32) then\n        nlen=32\n      endif\n      lowercase(1:nlen)=word(1:nlen)\n      do i=1,nlen\n        ic = ichar(word(i:i))\n        if (ic >= 65 .and. ic < 91) lowercase(i:i) = char(ic+32)\n      end do\n      if(nlen<32) lowercase(nlen+1:)=' '\n!\n!-----------------------------------------------------------------------\n!\n      end function lowercase\n"}, {"instruction": "Write a Fortran function named equal_str_nocase that compares two input strings in a case-insensitive manner. The number of input arguments is 2, and the test_data type is ['character (len=*)', 'character (len=*)']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "     elemental function equal_str_nocase(str1,str2)\n!\n!-----------------------------------------------------------------------\n!\n! convert a word to lower case\n!\n      logical              :: equal_str_nocase\n      character (len=*) , intent(in) :: str1\n      character (len=*) , intent(in) :: str2\n      integer :: i,ic1,ic2,nlen\n      nlen = len(str2)\n!\n      if(len(str1)/=nlen)  then\n        equal_str_nocase=.false.\n        return\n      endif\n      equal_str_nocase=.false.\n      do i=1,nlen\n        ic1 = ichar(str1(i:i))\n        if (ic1 >= 65 .and. ic1 < 91) ic1 = ic1+32\n        ic2 = ichar(str2(i:i))\n        if (ic2 >= 65 .and. ic2 < 91) ic2 = ic2+32\n        if(ic1/=ic2) then\n           equal_str_nocase=.false.\n           return\n        endif\n      end do\n      equal_str_nocase=.true.\n!\n!-----------------------------------------------------------------------\n!\n      end function equal_str_nocase\n"}, {"instruction": "Create a Fortran function named get_variable_displacements to determine if the provided displacements are all trivial. The function takes 2 input parameters of type integer and integer array with unspecified bounds, and returns 1 output parameter of type logical. The number of input arguments is 2 and the test_data type is [integer, integer, dimension(0:)]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  function get_variable_displacements(chunk,displs) result(variable)\n    implicit none\n    integer, intent(in) :: chunk\n    integer, dimension(0:), intent(in) :: displs\n    logical :: variable\n    !local variables\n    integer :: dspl,nproc,jproc\n\n    variable=.false.\n    !control if the provided displacements are all trivial\n    dspl=0\n    nproc=size(displs)\n    do jproc=0,nproc-1\n       if (dspl /= displs(jproc)) then\n          variable=.true.\n          exit\n       end if\n       dspl=dspl+chunk\n    end do\n\n  end function get_variable_displacements\n"}, {"instruction": "Write a Fortran function named gcd_rec to calculate the greatest common divisor (GCD) of two integers. The number of input parameters is 2, and the test_data type is ['integer', 'integer']. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n\n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n"}, {"instruction": "Create a Fortran function named haversine to calculate the great circle distance in kilometers between two points on the Earth's surface, given their latitude and longitude in degrees. The function should have 4 input parameters of real type (lata, lona, latb, lonb) and 1 output parameter of real type (dist).", "input": "", "output": "    function haversine(lata,lona,latb,lonb) result (dist)\n    !\n    ! calculate great circle distance in kilometers\n    ! given latitude and longitude in degrees\n    !\n    real,intent(in) :: lata,lona,latb,lonb\n    real :: a,c,dist,delta_lat,delta_lon,lat1,lat2\n    real,parameter :: radius = 6371 ! mean earth radius in kilometers,\n    ! recommended by the international union of geodesy and geophysics\n\n    ! generate constant pi/180\n    real, parameter :: deg_to_rad = atan(1.0)/45.0\n       delta_lat = deg_to_rad*(latb-lata)\n       delta_lon = deg_to_rad*(lonb-lona)\n       lat1 = deg_to_rad*(lata)\n       lat2 = deg_to_rad*(latb)\n       a = (sin(delta_lat/2))**2 + &\n              & cos(lat1)*cos(lat2)*(sin(delta_lon/2))**2\n       c = 2*asin(sqrt(a))\n       dist = radius*c\n    end function haversine\n"}, {"instruction": "Write a Fortran function named f that computes the square root of the expression (10 - x * y). The function takes 2 input parameters of type real and returns 1 output parameter of type real.", "input": "", "output": "function f(x, y) !funci\u00f3n original\n  implicit none\n  real::f, x, y\n  f=sqrt(10-x*y)\nend function f\n"}, {"instruction": "Create a Fortran function called \"g\" to calculate the square root of the quantity (57 minus y) divided by (3 times x). The function should take 2 input arguments of type real and return 1 output argument of type real.", "input": "", "output": "function g(x, y) !funci\u00f3n con despeje\n  implicit none\n  real::g, x, y\n  g=sqrt((57-y)/(3*x))\nend function g\n"}, {"instruction": "Create a Fortran function named local2global to convert local coordinates to global cell number. The function takes 3 input parameters of type integer (ilocalx, ilocaly, ixcellnumber) and returns 1 output parameter of type integer (iglobalnumber).", "input": "", "output": "    function local2global(ilocalx,ilocaly,ixcellnumber) result(iglobalnumber)\n    implicit none\n        integer, intent(in) :: ilocalx, ilocaly, ixcellnumber\n        integer :: iglobalnumber\n\n            iglobalnumber = ixcellnumber*(ilocaly-1)+ilocalx\n\n    return\n    end function\n"}, {"instruction": "Create a Fortran function named \"ci\" to calculate the value of a string based on the occurrence of specific characters. The function takes 1 input parameter of type character(7) and returns 1 output parameter of type integer. The number of occurrences of the characters 'a' to 'g' in the input string contributes to the final integer value. Use an imperative tone.", "input": "", "output": "function ci(s) result(x)\n  character(7) :: s\n  character(len = 1) :: c\n  integer :: x\n\n  x = 0\n\n  do i = 1, 7\n     c= s(i:i)\n     if (c == \"a\") then\n        x = x + 1\n     else if (c == \"b\") then\n        x = x + 2\n     else if (c == \"c\") then\n        x = x + 4\n     else if (c == \"d\") then\n        x = x + 8\n     else if (c == \"e\") then\n        x = x + 16\n     else if (c == \"f\") then\n        x = x + 32\n     else if (c == \"g\") then\n        x = x + 64\n     end if\n  end do\n\nend function ci\n"}, {"instruction": "Create a Fortran function named bcx that takes an integer input and returns the number of set bits (binary 1s) in the input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function bcx(n) result(x)\n  integer :: n, j, x\n\n  x = 0\n\n  do j = 0, 7\n     if (and(n, ishft(1, j)) /= 0) x = x + 1\n  end do\n\nend function bcx\n"}, {"instruction": "Create a Fortran function named ilog2_8 to calculate the base-2 logarithm of an 8-byte integer. The function takes 1 input argument of type integer(kind=8), value and returns 1 output argument of type integer(kind=8).", "input": "", "output": "      function ilog2_8(i_in)\n      implicit none\n      integer(kind=8), value :: i_in\n      integer(kind=8)::ilog2_8,i\n      ilog2_8=0\n      i=i_in\n      if(i<=0) return\n      if(iand(i,i-1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_8=1\n      endif\n      if(iand(i,z'ffffffff00000000')/=0) then\n         ilog2_8=ilog2_8+32\n         i=ishft(i,-32)\n         !write(0,*) 'iand ffffffff',i,ilog2_8\n      endif\n      if(iand(i,z'00000000ffff0000')/=0) then\n         ilog2_8=ilog2_8+16\n         i=ishft(i,-16)\n         !write(0,*) 'iand ffff' ,i,ilog2_8\n      endif\n      if(iand(i,z'000000000000ff00')/=0) then\n         ilog2_8=ilog2_8+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_8\n      endif\n      if(iand(i,z'00000000000000f0')/=0) then\n         ilog2_8=ilog2_8+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_8\n      endif\n      if(iand(i,z'000000000000000c')/=0) then\n         ilog2_8=ilog2_8+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_8\n      endif\n      if(iand(i,z'0000000000000002')/=0) then\n         ilog2_8=ilog2_8+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_8\n      endif\n      end function ilog2_8\n"}, {"instruction": "Create a Fortran function named ilog2_4 to compute the logarithm base 2 of a 4-byte integer.The number of input arguments is 1 and the test_data type is [integer(kind=4), value]. The number of output arguments is 1 and the test_data type is [integer(kind=4)].", "input": "", "output": "      function ilog2_4(i_in)\n      implicit none\n      integer(kind=4), value :: i_in\n      integer(kind=4)::ilog2_4,i\n      ilog2_4=0\n      i=i_in\n      if(i<=0) return\n      if(iand(i,i-1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_4=1\n      endif\n      if(iand(i,z'ffff0000')/=0) then\n         ilog2_4=ilog2_4+16\n         i=ishft(i,-16)\n         !write(0,*) 'iand ffff' ,i,ilog2_4\n      endif\n      if(iand(i,z'0000ff00')/=0) then\n         ilog2_4=ilog2_4+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_4\n      endif\n      if(iand(i,z'000000f0')/=0) then\n         ilog2_4=ilog2_4+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_4\n      endif\n      if(iand(i,z'0000000c')/=0) then\n         ilog2_4=ilog2_4+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_4\n      endif\n      if(iand(i,z'00000002')/=0) then\n         ilog2_4=ilog2_4+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_4\n      endif\n      end function ilog2_4\n"}, {"instruction": "Write a Fortran function named ilog2_2 that calculates the base-2 logarithm of a 2-byte integer. The function takes 1 input parameter of type integer(kind=2), value and returns 1 output parameter of type integer(kind=2). The function uses bitwise operations to compute the logarithm.", "input": "", "output": "      function ilog2_2(i_in)\n      implicit none\n      integer(kind=2), value :: i_in\n      integer(kind=2)::ilog2_2,i\n      ilog2_2=0\n      i=i_in\n      if(i<=0) return\n! wps modification for the xl compiler\n!      if(iand(i,i-1)/=0) then\n      if(iand(i,i-1_2)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_2=1\n      endif\n      if(iand(i,z'ff00')/=0) then\n         ilog2_2=ilog2_2+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_2\n      endif\n      if(iand(i,z'00f0')/=0) then\n         ilog2_2=ilog2_2+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_2\n      endif\n      if(iand(i,z'000c')/=0) then\n         ilog2_2=ilog2_2+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_2\n      endif\n      if(iand(i,z'0002')/=0) then\n         ilog2_2=ilog2_2+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_2\n      endif\n      end function ilog2_2\n"}, {"instruction": "Create a Fortran function named ilog2_1 to calculate the base-2 logarithm of an integer input value of kind 1. The function takes 1 input parameter of type integer(kind=1), marked as value, and returns 1 output parameter of type integer(kind=1).", "input": "", "output": "      function ilog2_1(i_in)\n      implicit none\n      integer(kind=1), value :: i_in\n      integer(kind=1)::ilog2_1,i\n      ilog2_1=0\n      i=i_in\n      if(i<=0) return\n! wps modification for the xl compiler\n!      if(iand(i,i-1)/=0) then\n      if(iand(i,i-1_1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_1=1\n      endif\n      if(iand(i,z'f0')/=0) then\n         ilog2_1=ilog2_1+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_1\n      endif\n      if(iand(i,z'0c')/=0) then\n         ilog2_1=ilog2_1+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_1\n      endif\n      if(iand(i,z'02')/=0) then\n         ilog2_1=ilog2_1+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_1\n      endif\n      end function ilog2_1\n"}, {"instruction": "Create a Fortran function called initialize_invr to initialize a logical variable based on the input integer value. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. If the input integer is 1, the function sets the output integer to 1, otherwise it sets the output integer to 0.", "input": "", "output": "  function initialize_invr (init) \n    integer, intent(in) :: init\n    integer :: initialize_invr\n    \n    init_invr = .false.\n    if(init == 1) init_invr = .true.\n    initialize_invr = 1\n  end function initialize_invr\n"}, {"instruction": "Create a Fortran function named initialize_psi that takes one integer input argument. It initializes a variable init_psi to .false. and then checks if the input integer is equal to 1, in which case it sets init_psi to .true. The function returns an integer value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function initialize_psi (init) \n    integer, intent(in) :: init\n    integer :: initialize_psi\n    \n    init_psi = .false.\n    if(init == 1) init_psi = .true.\n    initialize_psi = 1\n  end function initialize_psi\n"}, {"instruction": "Create a Fortran function named trimlr to remove leading and trailing spaces from a character string. The function should have 1 input argument of type character(*) and 1 output argument of type character(len_trim(adjustl(char))).", "input": "", "output": "  pure function trimlr (char)\n\n    implicit none\n    character(*), intent(in) :: char\n    character(len_trim(adjustl(char))) :: trimlr\n\n    trimlr = trim(adjustl(char))\n\n  end function trimlr\n"}, {"instruction": "Please create a Fortran function named outerand that computes the outer product of two logical arrays. The function should have 2 input parameters of type 'logical, dimension(:)', and 1 output parameter of type 'logical, dimension(size(a),size(b))'. Use the spread function to perform the outer logical AND operation between the two arrays.", "input": "", "output": "  pure function outerand (a,b)\n\n    implicit none\n    logical, dimension(:), intent(in) :: a, b\n    logical, dimension(size(a),size(b)) :: outerand\n\n    outerand = spread(a,dim=2,ncopies=size(b)) .and. & \n               spread(b,dim=1,ncopies=size(a))\n\n  end function outerand\n"}, {"instruction": "Create a Fortran function named floor_pow2 that takes an integer input argument and returns the largest power of 2 that is less than or equal to the input value. The number of input arguments is 1, and the test data type is ['integer']. The number of output arguments is 1, and the test data type is ['integer'].", "input": "", "output": "  function floor_pow2(n)\n    implicit none\n    integer            :: floor_pow2\n    integer,intent(in) :: n\n    integer :: k\n\n    k = 1\n    do while(k < n)\n      k = k * 2\n    end do\n    if (k /= n) k = ishft(k, -1)\n    floor_pow2 = k\n  end function\n"}, {"instruction": "Create a Fortran function named \"jtypb\" to determine the type of coefficients b(n,k) for angular distribution calculation. The function should take 3 input parameters of type integer(int32) named ith, mb, and lamb. The output should be an integer(int32) representing the determined type.", "input": "", "output": "  function jtypb (ith, mb, lamb)\n\n! ======================================================================\n!\n!     determining type of coefficients b(n,k);\n!     for angular distribution calculation.\n!\n!     ith = 0 or 1;\n!     mb = baryon number of channel;\n!     lamb = 1 for \"recoiling\" fermi-sea nucleon,\n!            2 for first pion produced,\n!            3 for \"recoiling\" projectile,\n!          > 3 for subsequent pions for multiple pion production.\n!\n!    called by: vmnsp\n!\n!    cem95 written by s. g. mashnik\n!\n!    edited by a. j. sierk,  lanl  t-2  february, 1996.\n!    edited by ajs, july, 1997.\n!    edited by ajs, december, 1998.\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic :: iso_fortran_env, only: int32\n\n    implicit none\n    integer(int32), intent(in   ) :: ith\n    integer(int32), intent(in   ) :: mb\n    integer(int32), intent(in   ) :: lamb\n    integer(int32)                :: jtypb\n\n! ======================================================================\n\n    if (ith.ne.0) then\n!   one pion produced.\n       if (mb <= 1) then\n!   pi + n incident channel:\n          if (lamb > 1) then\n             jtypb = 6\n          else\n             jtypb = 5\n          endif\n       else\n!   n + n incident channel:\n          if (lamb <= 1 .or. lamb == 3) then\n!  nucleon:\n             jtypb = 1\n          else\n!  pion:\n             jtypb = 2\n          endif\n       endif\n    else\n!   all other pion production cross sections:\n       if (mb <= 1) then\n!   pi + n incident channel:\n          if (lamb <= 1) then\n!  nucleon:\n             jtypb = 7\n          else\n!  pion:\n             jtypb = 8\n          endif\n       else\n!   n + n incident channel:\n          if (lamb <= 1 .or. lamb == 3) then\n             jtypb = 3\n          else\n             jtypb = 4\n          endif\n       endif\n    endif\n    return\n\n! ======================================================================\n  end function jtypb\n"}, {"instruction": "Create a Fortran function named evenly_divis to check if a given integer is evenly divisible by all numbers from 1 to 20. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "        function evenly_divis (a)\n                integer :: a, i\n                logical :: evenly_divis\n\n                evenly_divis = .true.\n\n                do i = 1, 20, 1\n\n                        if(mod(a, i) /= 0) then\n                                evenly_divis = .false.\n                                exit\n                        end if\n\n                end do\n\n                return\n\n        end function evenly_divis\n"}, {"instruction": "Create a Fortran function named getoption that takes two integer input parameters. This function reads an integer from the standard input and checks if it falls within the specified range defined by the input parameters. The function returns the valid integer selected by the user. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function getoption(min, max)\n        use iso_fortran_env, only: stdin => input_unit\n\n        integer, intent(in) :: min, max\n        integer :: getoption\n        integer :: n\n\n        ! todo: should it terminate after a certain number of tries? with an error?\n        do while (.true.)\n            read(stdin,*) n\n            if(min <= n .and. n <= max) then\n                exit\n            endif\n            print '(\"invalid choice (\",i0,\"). must be \",i0,\"-\",i0,\". try again:\")', n, min, max\n        enddo\n        getoption = n\n    end function getoption\n"}, {"instruction": "Create a Fortran function named antitr to calculate the anti-transposed matrix of an input matrix. The function takes 2 input parameters with the test_data type ['integer, dimension (n, n)', 'integer'], and returns 1 output parameter with the test_data type ['integer, dimension (n, n)'].", "input": "", "output": "    function antitr (a, n) result (at)\n        ! a is input matrix, at is anti-transposed matrix.\n        integer, dimension (n, n), intent (in) :: a\n        integer, intent (in) :: n\n        integer, dimension (n, n) :: at\n\n        integer :: i\n\n        do i = 1, n\n            at(:, n - i + 1) = a(i, n:1:-1)\n        end do\n\n    end function antitr\n"}, {"instruction": "Write a Fortran function named lic that takes a double precision number as input and returns an integer of kind 2 as output. The function computes the logarithmic integral function of the input and adds 16384 to the result.", "input": "", "output": "      function lic(a) result(i)\n\n      implicit none\n\n      double precision :: a\n\n      integer (kind = 2) :: i\n\n      i = int(1000 * log10(a), 2) + 16384\n\n      return\n\n      end function\n"}, {"instruction": "Write a Fortran function called idx that takes a double precision input parameter lambda and returns an integer (kind = 4) output parameter n. The function computes the value of n based on the input value of lambda and predefined constants.", "input": "", "output": "      function idx(lambda) result(n)\n\n      implicit none\n\n      double precision :: lambda, lambda0, r\n\n      integer (kind = 4) :: n, n0\n\n      lambda0 = 8.97666d0\n\n      r = 500000.0d0\n\n      n0 = int(log10(lambda0) / log10(1.0d0 + 1.0d0 / r), 4)\n\n      n = int(log10(lambda) / log10(1.0d0 + 1.0d0 / r), 4) + 1 - n0\n\n      return\n\n      end function\n"}, {"instruction": "Create a Fortran function named friccionnewtonrapshon to calculate the friction factor using the Newton-Raphson method. The function takes 3 input parameters of type real, real, and integer, and returns 1 output parameter of type real.", "input": "", "output": "    function friccionnewtonrapshon(ksd, re,semilla_f)\n        implicit none\n        !variables externas\n        real :: friccionnewtonrapshon, ksd, semilla_f\n        integer::re\n\n        !variables internas\n        real :: fi, xi, xi_1, fx, dfx\n        integer :: i\n\n        !parameters\n        real, parameter :: e = 1e-8\n\n        if (re > 2200) then\n            fi = semilla_f\n            print\"(a10,a15,a18,a18,a18)\", \"fi\",\"x\",\"x+1\",\"f(x)\",\"df(x)\"\n            \n            xi = 1/sqrt(fi)\n\n            do i = 1,15\n\n                fx = -2 * log10((ksd / 3.7) + (2.51 * xi / re)) !ksd es ks/d, por esta razon no esta d en la formula\n                dfx = (-2 / log(10.0)) * (2.51/re)\n                dfx = dfx /((ksd/3.7)+(2.51*xi/re))\n                \n                \n                xi_1 = xi - (fx - xi)/(dfx - 1)\n                \n                print *, fi, xi,xi_1,fx,dfx\n                if (abs(xi - xi_1)<e) then\n                    exit\n                else\n                    xi = xi_1\n                end if\n            end do\n\n            friccionnewtonrapshon = 1/(xi_1 ** 2)    \n        else \n            friccionnewtonrapshon = 64/re\n\n        end if\n    end function\n"}, {"instruction": "Create a Fortran function named personaltopthree to find the top three highest scores from the given list of scores. The number of input arguments is 1 and the test_data type is ['integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, dimension(3)']. Use the imperative tone.", "input": "", "output": " function personaltopthree(score_list)\n  integer, dimension(:) :: score_list\n  logical, dimension(:) :: score_list_mask(size(score_list))\n  integer, dimension(3) :: personaltopthree\n  integer :: i\n  integer :: j\n  personaltopthree=[0,0,0]\n  score_list_mask(:) = .true.\n  do i=1,min(3, size(score_list))\n    personaltopthree(i) = maxval(score_list, mask=score_list_mask) \n    j = maxloc(score_list, dim=1, mask=score_list_mask)\n    score_list_mask(j) = .false.\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named abc that takes an integer input argument and returns a character string of length n, where n is the input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=n)'].", "input": "", "output": "  function abc(n)\n  implicit none\n  integer, intent(in) :: n\n  character(len=n) :: abc\n  character(len=26) :: alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  abc = alphabet(1:n)\n  end function abc\n"}, {"instruction": "Write a Fortran function named accel_area_velocity to calculate the velocity based on the given velocity gradient, time, and steady velocity. The number of input arguments is 3, and the test_data type is ['double precision', 'double precision', 'double precision']. The number of output arguments is 1, and the test_data type is ['double precision'].", "input": "", "output": "    function accel_area_velocity(velocity_gradient, time, steady_velocity) result(velocity)\n        implicit none\n        double precision, intent(in) :: velocity_gradient, time, steady_velocity\n        double precision :: velocity\n\n        velocity = min(velocity_gradient * time, steady_velocity)\n\n        return\n    end function accel_area_velocity\n"}, {"instruction": "Write a Fortran function called get_conn_num to determine the number of connections for a given atom in a molecular structure. The function takes 2 input parameters of type integer,dimension(:,:) and integer. The first parameter represents the connectivity matrix, and the second parameter represents the atom number. The output is a single integer representing the number of connections for the specified atom.", "input": "", "output": "function get_conn_num(atom_no,cmat) result(nbonds)\nimplicit none\n\ninteger,dimension(:,:),intent(in)   :: cmat\ninteger                 :: m !counters\ninteger                 :: atom_no,natom\ninteger                 :: nbonds\n\n\nnatom=size(cmat,1)\n!natom=nint(sqrt(real(size(cmat))))\n!write(*,*)natom\n\nnbonds=0\ndo m=1,natom\n   if(cmat(atom_no,m)>=1)then\n      nbonds=nbonds+1\n   endif\nenddo\n   \nreturn\nend function get_conn_num\n"}, {"instruction": "Create a Fortran function named num_breaks that takes a 2D array of integers as input and returns the number of breaks as an integer. The input parameter is of type integer, dimension(:,:), and the output parameter is of type integer.", "input": "", "output": "function num_breaks(cmat) result(nbreaks)\n\nimplicit none\ninteger,dimension(:,:),intent(in)   ::cmat\ninteger        :: n,m !counter\ninteger        :: natom\ninteger        :: nbreaks\n\nnbreaks=0\nnatom=size(cmat,1)\n\ndo n=1,natom\n   do m=n,natom\n!      if(cmat(n,m)==1)then\n! patch 200513 allow h-bonds\n      if(abs(cmat(n,m))==1)then\n         nbreaks=nbreaks+1\n      endif\n   enddo\nenddo\n\nreturn\nend function num_breaks\n"}, {"instruction": "Create a Fortran function named regular_coord_count that calculates the count of regular coordinates based on the maximum coordinates, shifts, and steps. The number of input arguments is 4, and the test_data type is ['integer, dimension(:)', 'integer, dimension(:), optional', 'integer, dimension(:), optional', 'integer, dimension(:), optional']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "    function regular_coord_count(ida_max, shifts, steps, ncoords) result(il_count)\n      integer, dimension(:), intent(in) :: ida_max\n      integer, dimension(:), optional, intent(in)  :: shifts, steps\n      integer, dimension(:), optional, intent(out) :: ncoords\n      integer, dimension(size(ida_max)) :: ila_shift, ila_step, ila_count\n      integer :: il_count\n\n      if( present(shifts) ) then\n        ila_shift = shifts\n      else\n        ila_shift = 1\n      end if\n      if( present(steps) ) then\n        ila_step = steps\n      else\n        ila_step = 1\n      end if\n      ila_count = 1 + (ida_max - ila_shift)/ila_step\n      il_count = product(ila_count)\n      if( present(ncoords) ) ncoords = ila_count\n    end function regular_coord_count\n"}, {"instruction": "Write a Fortran function named fibonacci to compute the nth Fibonacci number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function fibonacci(n)\n        integer::n, fibonacci,b=1, i, temp\n        fibonacci=0\n        do i=0, n-1\n            temp = fibonacci;\n            fibonacci=b;\n            b=temp+b;\n        end do\n        return\n    end function fibonacci\n"}, {"instruction": "Write a Fortran function called getarr that generates a 2D array of random integers based on a given probability. The function takes 2 input parameters: an integer n and a real(8) p. It returns a 2D integer array of size n x n. The number of input parameters is 2 and the test_data type is ['integer', 'real(8)'], while the number of output parameters is 1 and the test_data type is ['integer, dimension(n, n)'].", "input": "", "output": "    function getarr(n, p)\n        implicit none\n        integer, intent(in) :: n\n        real(8), intent (in) :: p\n        integer, dimension(n, n) :: getarr\n\n        real(8) :: rnd\n        integer :: i, j\n\n        call random_seed()\n\n        do i = 1, n\n            do j = 1, n\n                call random_number(rnd)\n                if (rnd .lt. p) then\n                    getarr(i, j) = 1\n                else\n                    getarr(i, j) = 0\n                end if\n            end do\n        end do\n    end function getarr\n"}, {"instruction": "Create a Fortran function named check_obs_seq_header that takes 2 input parameters of type integer and character with variable lengths. The function returns an integer value. The purpose of this function is to check the header of an observation sequence file to ensure it matches the expected format. If the header does not match, the function returns -1; otherwise, it returns 0. Remember to use the imperative tone.", "input": "", "output": "function check_obs_seq_header(file_id, read_format)\n \ninteger,          intent(in) :: file_id\ncharacter(len=*), intent(in) :: read_format\ninteger :: check_obs_seq_header\n\ninteger :: ios\ncharacter(len=12) :: file_header   ! 'obs_sequence'\ncharacter(len=20) :: toc_header    ! 'obs_kind_definitions' (old) or 'obs_type_definitions' (new, and correct)\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) file_header\nelse\n   read(file_id, iostat = ios) file_header\nendif\n   \nif(ios /= 0 .or. file_header /= 'obs_sequence') then\n   check_obs_seq_header = -1\n   return\nendif\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) toc_header\nelse\n   read(file_id, iostat = ios) toc_header\nendif\n   \nif(ios /= 0 .or. (toc_header /= 'obs_kind_definitions' .and. toc_header /= 'obs_type_definitions')) then\n   check_obs_seq_header = -1\n   return\nendif\n\nrewind(file_id)\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) file_header\nelse\n   read(file_id, iostat = ios) file_header\nendif\n   \ncheck_obs_seq_header = 0\n\nend function check_obs_seq_header\n"}, {"instruction": "Create a Fortran function named popcnt to count the number of set bits (1s) in the binary representation of an integer input. The function should have 1 input parameter of type integer and 1 output parameter of type integer. The input parameter should be denoted as intent(in).", "input": "", "output": "function popcnt(x)\n  integer :: popcnt\n  integer, intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 31\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\n"}, {"instruction": "Write a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical. The test_data type for input is ['integer'] and for output is ['logical'].", "input": "", "output": "function isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n\n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named ff that takes 3 real input parameters xtt, ak, and am, and returns a real value. The function computes a complex mathematical expression involving exponential, hyperbolic sine, and hyperbolic cosine functions, as well as conditional statements. The function incorporates both a conditional and computational logic to calculate the value of ff based on the provided input parameters.", "input": "", "output": "    function ff(xtt,ak,am)\n        real::xtt,ak,am\n        real::coef,tol,h,a,b,c,d,e,f,ff\n        coef=(am+ak)**2/(am**2-ak**2+ak)\n        h=xtt-am\n        tol=amax1(0.1,0.1*am)\n        if(abs(h).gt.tol)then\n            ff=(xtt+ak)*exp(xtt)/(xtt*sinh(xtt)-ak*cosh(xtt))-coef/(xtt-am)-2.\n        else\n            a=am-tol\n            b=am\n            c=am+tol\n            d=(a+ak)*exp(a)/(a*sinh(a)-ak*cosh(a))-coef/(a-am)-2\n            e=coef/(am+ak)*(am+ak+1)-(coef/(am+ak))**2*am-2\n            f=(c+ak)*exp(c)/(c*sinh(c)-ak*cosh(c))-coef/(c-am)-2\n            ff=(xtt-b)*(xtt-c)*d/((a-b)*(a-c))+(xtt-c)*(xtt-a)*e/((b-c)*(b-a))+&\n                & (xtt-a)*(xtt-b)*f/((c-a)*(c-b))\n        endif\n        return\n                                                                    \n    end function\n"}, {"instruction": "Create a Fortran function named cp2k_driver_run_type_args that takes a single input argument of type character(len=*) and returns a string of length 300. The function evaluates the input argument and generates a corresponding string based on the specified conditions.", "input": "", "output": "  function cp2k_driver_run_type_args(run_type)\n    character(len=*), intent(in) :: run_type\n    character(len=300) :: cp2k_driver_run_type_args\n\n    if (run_type(1:2) == 'mm') then\n      cp2k_driver_run_type_args = \"run_type=mm\"\n    else if (run_type(1:2) == 'qs') then\n      cp2k_driver_run_type_args = \"run_type=qs\"\n    else ! qmmm\n      cp2k_driver_run_type_args = \"run_type=qmmm\"\n      if (run_type(1:9) == 'qmmm_core') then\n        cp2k_driver_run_type_args = trim(cp2k_driver_run_type_args)//' use_buffer=f run_suffix=_core'\n      else\n        cp2k_driver_run_type_args = trim(cp2k_driver_run_type_args)//' use_buffer=t run_suffix=_extended'\n      endif\n    endif\n  end function cp2k_driver_run_type_args\n"}, {"instruction": "Create a Fortran function named catalan_number that calculates the Catalan number for a given integer input. The function should have 1 input parameter of type integer and 1 output parameter of type integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use a recursive approach to compute the Catalan number.", "input": "", "output": "    pure recursive function catalan_number(n) result(value)\n        integer, intent(in) :: n\n        integer :: value\n        integer :: i\n        if (n <= 1) then\n            value = 1\n        else\n            value = 0\n            do i = 0, n-1\n                value = value + catalan_number(i)*catalan_number(n-i-1)\n            end do\n        end if\n    end function\n"}, {"instruction": "Write a Fortran function named count to determine the number of occurrences of a specific character within a given string. The function should accept 2 input arguments with data types ['character(*)', 'character(*)'] and return 1 output argument with data type ['integer'].", "input": "", "output": "    function count(str, chr)\n        character(*), intent(in) :: str, chr\n        integer :: i, j, count\n        i = 1\n        count = 0\n        do\n            j = index(str(i:), chr)\n            if (j == 0) exit\n            count = count + 1\n            i = i + j\n        end do\n    end function\n"}, {"instruction": "Create a Fortran function named number_of_divisors to calculate the number of divisors for a given integer input. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type integer(4).", "input": "", "output": "  pure function number_of_divisors(i)\n    ! default\n    implicit none\n\n    integer(8), intent(in) :: i\n    integer(4)             :: number_of_divisors\n\n    ! local variables\n    integer(8) :: max_try,test\n\n\n    ! find max factor to try\n    max_try = nint(sqrt(1d0*i))\n\n    ! we know that 1 and the number are trivial factors\n    ! protect against the case where i==1\n    ! since we start the checks below at n==2, the case of i==2\n    !   is another special case we need to deal with properly\n    if (i==1) then\n       number_of_divisors = 1\n       return\n    else if (i==2) then\n       number_of_divisors = 2\n       return\n    else\n       number_of_divisors = 2\n    endif\n\n    ! check to see if a number is a divisor\n    ! we are testing from 2 to sqrt(i)\n    ! for each number we find, we know there is going to be a pair of factors\n    ! e.g.: for the case of i=36, we test from 2 to 6\n    !   mod(36,2)==0 (so we've found 2 factors: 2 and 18)\n    !   mod(36,3)==0 (another 2 factors: 3 and 12)\n    !   mod(36,4)==0 (4 and 9)\n    !   mod(36,5)/=0 (no factors)\n    !   mod(36,6)==0 (but! 36/6==6, so we have caught the perfect-square case)\n    ! add to this the trivial factors of 1 and 36, and we have found all\n    !   9 factors, while only having to test up through sqrt(36)\n    test = 2\n    do\n       if (mod(i,test)==0) then\n          ! test for perfect-square case\n          ! this should also be the end of the line, so we exit just in case\n          !   rounding for max_int has introduced rouding errors\n          if (i/test==test) then\n             number_of_divisors = number_of_divisors + 1\n             return\n          else\n             number_of_divisors = number_of_divisors + 2\n          endif\n       endif\n\n       test = test + 1\n       if (test > max_try) exit\n    enddo\n\n    return\n  end function number_of_divisors\n"}, {"instruction": "Write a Fortran function named f to calculate the derivative of a function. The function takes 1 input parameter of type real(8), dimension(:), and returns 1 output parameter of type real(8), dimension(size(x)).", "input": "", "output": "    function f(x) result(ddx)\n        real(8), dimension(:), intent(in) :: x\n        real(8), dimension(size(x)) :: ddx\n        ddx = -mu * x / sum(x**2)**(3d0/2d0)\n        return\n    end function\n"}, {"instruction": "Write a Fortran function named delta to determine if two integer numbers are equal. The function should have 2 input parameters with the test_data type ['integer', 'integer'], and 1 output parameter with the test_data type ['integer'].", "input": "", "output": "\tfunction delta(a,b)\n\tinteger :: a, b, delta\n\t\tdelta = 0.d0\n\t\tif (a == b) delta = 1.d0\n\tend function delta\t\t\n"}, {"instruction": "Create a Fortran function named command_argument to retrieve a command-line argument based on its position and a default value. The function takes 2 input parameters with test_data types ['integer', 'character(*)'] and 1 output parameter with test_data type ['character(:), allocatable'].", "input": "", "output": "   function command_argument(num, def) result(arg)\n      character(:), allocatable :: arg\n\n      integer, intent(in) :: num\n      character(*), intent(in) :: def\n\n      integer :: i, n, size\n\n      i = num\n      n = command_argument_count()\n\n      if (i .lt. 0) i = n + i + 1\n\n      if (i .lt. 1 .or. i .gt. n) then\n         arg = def\n      else\n         call get_command_argument(i, length=size)\n\n         allocate(character(size) :: arg)\n\n         call get_command_argument(i, value=arg)\n\n         if (arg .eq. '-') arg = def\n      end if\n   end function command_argument\n"}, {"instruction": "Create a Fortran function named randnum that generates a random real number. The function takes 2 integer inputs of type [integer, integer] and produces 1 real output of type [real(kind = double)].", "input": "", "output": "      function randnum(intx,inty)\n      implicit none\n      integer, parameter :: double = selected_real_kind(15,99)\n      integer :: i,j,intx,inty\n      real(kind = double) :: randnum \n      i = 1029*intx + 1731\n      j = i + 1029*inty + 507*intx - 1731\n      intx = mod(i,2048)\n      j = j + (i - intx)/2048\n      inty = mod(j,2048)\n      randnum = (intx + 2048*inty)/4194304.0d00\n\n      end function\n"}, {"instruction": "Create a Fortran function named convert_lower_case to convert a given input_string to lower case. The function takes 1 input parameter of type character (len=*) and returns 1 output parameter of type character (len=1).", "input": "", "output": "      function convert_lower_case (input_string) result (output_string)\n!\n      character (len=*), intent(in) :: input_string\n      character (len=1) :: output_string\n      integer :: collating_difference\n!\n      if (ichar(input_string) >= ichar(\"a\") .and. ichar(input_string) <= ichar(\"z\")) then\n          collating_difference = ichar(input_string) - ichar(\"a\")\n          output_string = char(ichar(\"a\") + collating_difference)\n      else\n          output_string = input_string\n      end if\n!\n      end function convert_lower_case\n"}, {"instruction": "Create a Fortran function named r8deg2rad to convert an angle in degrees to radians. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The test_data type for input is ['real(8)'] and for output is ['real(8)'].", "input": "", "output": " function r8deg2rad(angle)\n  implicit none\n  real(8) :: r8deg2rad,angle\n  real(8), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r8deg2rad=angle*(pi/180.0d0)\n end function r8deg2rad\n"}, {"instruction": "Write a Fortran function named r4deg2rad that takes a single real(4) input argument and returns a real(4) value. The input argument is in degrees, and the function computes and returns the corresponding value in radians.", "input": "", "output": " function r4deg2rad(angle)\n  implicit none\n  real(4) :: r4deg2rad,angle\n  real(4), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r4deg2rad=angle*(pi/180.0)\n end function r4deg2rad\n"}, {"instruction": "Create a Fortran function named r8rad2deg to convert an angle in radians to degrees. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The input parameter represents the angle in radians, and the output parameter represents the angle in degrees.", "input": "", "output": " function r8rad2deg(angle)\n  implicit none\n  real(8) :: r8rad2deg,angle\n  real(8), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r8rad2deg=angle*(180.0d0/pi)\n end function r8rad2deg\n"}, {"instruction": "Provide a Fortran function named r4rad2deg that converts an angle in radians to degrees. The function takes 1 input parameter of type real(4) and returns 1 output parameter of type real(4).", "input": "", "output": " function r4rad2deg(angle)\n  implicit none\n  real(4) :: r4rad2deg,angle\n  real(4), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r4rad2deg=angle*(180.0/pi)\n end function r4rad2deg\n"}, {"instruction": "Create a Fortran function named r8asinh to calculate the inverse hyperbolic sine of a real(8) input. The input parameter is of type real(8), and the output parameter is also of type real(8).", "input": "", "output": " function r8asinh(z)\n  implicit none\n  real(8) :: z,r8asinh\n\n  r8asinh=log(z+sqrt(1+z**2))\n end function r8asinh\n"}, {"instruction": "Create a Fortran function named r4asinh that takes one real input parameter and returns a real value. The function computes the inverse hyperbolic sine (asinh) of the input parameter using the formula r4asinh=log(z+sqrt(1+z**2)).", "input": "", "output": " function r4asinh(z)\n  implicit none\n  real :: z,r4asinh\n\n  r4asinh=log(z+sqrt(1+z**2))\n end function r4asinh\n"}, {"instruction": "Write a Fortran function named i4ispostv to determine if an input integer is positive or not. The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(4). If the input integer is less than 0, the function returns 0; otherwise, it returns 1.", "input": "", "output": " function i4ispostv(varvalue)  ! 1 is positive & 0 is negative\n  implicit none\n  integer(4) :: varvalue\n  integer(4) :: i4ispostv\n\n  if(varvalue.lt.0) then\n   i4ispostv=0\n  else\n   i4ispostv=1\n  end if\n end function i4ispostv\n"}, {"instruction": "Write a Fortran function named r4ispostv to determine if a single input value, which is a 4-byte real number, is positive or negative. The function should return an integer value indicating whether the input is positive (1) or negative (0). The number of input arguments is 1 and the test_data type is [real(4)]. The number of output arguments is 1 and the test_data type is [integer(4)].", "input": "", "output": " function r4ispostv(varvalue)  ! 1 is positive & 0 is negative\n  implicit none\n  real(4) :: varvalue\n  integer(4) :: r4ispostv\n\n  if(varvalue.lt.0.0) then\n   r4ispostv=0\n  else\n   r4ispostv=1\n  end if\n end function r4ispostv\n"}, {"instruction": "Write a Fortran function named orderof to determine the order of magnitude of a given real number. The function takes 1 input parameter of type real(4) and returns 1 output parameter of type integer(4).", "input": "", "output": " function orderof(varvalue)\n  implicit none\n  real(4)    :: varvalue,calcval\n  integer(4) :: orderof\n\n  calcval=varvalue\n  orderof=0\n  if(abs(varvalue).eq.0.0) return\n  if(abs(varvalue).gt.1.0) then\n   do while(abs(calcval).gt.10.0)\n    calcval=calcval/10.0\n    orderof=orderof+1\n   end do\n!  orderof=orderof-1\n  end if\n  if(abs(varvalue).lt.1.0) then\n   do while(abs(calcval).lt.1.0)\n    calcval=calcval*10.0\n    orderof=orderof-1\n   end do\n  end if\n end function orderof\n"}, {"instruction": "Create a Fortran function named random_integer that takes two integer input parameters, vmin and vmax. It returns a single integer output parameter, r. The function uses the random_number subroutine to generate a random integer value between vmin and vmax (inclusive).", "input": "", "output": "  function random_integer(vmin, vmax) result(r)\n    integer, intent(in) :: vmin, vmax\n    integer :: r\n    real(8) tmp\n    call random_number(tmp)\n    r = floor(tmp * (vmax - vmin + 1)) + vmin\n  end function\n"}, {"instruction": "Create a Fortran function named get_filename to extract the filename from a given file path. The function takes 2 input parameters of type character(len=*) and integer, where the integer is optional. The output is a character array that is dynamically allocated.", "input": "", "output": "  function get_filename(filestring,mext)\r\n    implicit none\r\n    character(len=*) :: filestring\r\n    character(:), allocatable :: get_filename\r\n    integer, optional :: mext\r\n    integer :: i\r\n    do i=len(filestring),1,-1\r\n       if(filestring(i:i)=='/')exit\r\n    end do\r\n    get_filename=trim(adjustl(filestring(i+1:len(filestring))))\r\n  end function get_filename\r\n"}, {"instruction": "Provide a Fortran function named int2str that converts an integer to a string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(:), allocatable'].", "input": "", "output": "  function int2str(i)\r\n    integer :: i\r\n    character(:), allocatable :: int2str\r\n    character(len=20):: dum\r\n    write(dum,*)i\r\n    int2str=trim(adjustl(dum))\r\n  end function int2str\r\n"}, {"instruction": "Create a Fortran function named p7 that multiplies the input integer by -2. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "function p7(x)\n implicit none\n integer :: x, p7\n p7 = x*(-2)\nend function\n"}, {"instruction": "Create a Fortran function named eigfuncint to compute the integral of a specific function over a given interval. The function takes 5 input arguments of type real(8) and returns 1 output argument of type real(8). The function's purpose is described in the comments as being used to integrate on KL reconstructed realizations.", "input": "", "output": "  function eigfuncint(ak,alpha,lamc,xl,xr)\n  ! used in klrxi_integral to integrate on kl reconstructed realizations\n  real(8) :: ak,alpha,lamc,xl,xr,eigfuncint\n\n  eigfuncint = ak * (         (-cos(alpha*xr)+cos(alpha*xl))/alpha &\n                       + lamc*( sin(alpha*xr)-sin(alpha*xl))           )\n  end function eigfuncint\n"}, {"instruction": "Provide a Fortran function named itoa to convert an integer to a 10-character string representation. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(10)].", "input": "", "output": "function itoa(i) result(a)\n  integer::i\n  character(10)::a\n  write(a,\"(i10)\") i\n  a=adjustl(trim(a))\nend function\n"}, {"instruction": "Create a Fortran function named file_handle to manage file units. The function takes 1 input parameter, which is an optional integer. The test_data type for the input parameter is ['integer,optional']. The function returns 1 output parameter of type integer.", "input": "", "output": "function file_handle(rel) result(ios)\n  integer,optional::rel\n  integer::i,ios\n\n  integer,parameter::n_unit=5\n  integer,dimension(n_unit),parameter::unit=(/10,20,30,40,50/)\n  logical,dimension(n_unit),save::in_use=.false.\n\n  ios=-1\n\n  if(present(rel))then\n    do i=1,n_unit\n      select case(rel-unit(i))\n      case(0)\n        in_use(i)=.false.\n        return\n      end select\n    end do\n  else\n    do i=1,n_unit\n      select case(in_use(i))\n      case(.false.)\n        ios=unit(i)\n        in_use(i)=.true.\n        return\n      end select\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named single_trial that simulates a single trial of an envelope selection game. The function takes 1 input parameter of type double precision. It returns 1 output parameter of type double precision.", "input": "", "output": "function single_trial(cutoff) result(value)\n  ! runs a single trial where an envelope is chosen.  if the chosen envelope has\n\n  ! the envelope it has chosen. returns the value of the envelope it ultimately \n  ! selects.\n  implicit none\n  double precision :: cutoff, higher_value, lower_value, value\n  logical          :: picked_lower\n \n  lower_value = rand() * 100.0d+0\n  higher_value = 2 * lower_value\n  picked_lower = (rand() < 0.5)\n  if ((picked_lower .and. lower_value >= cutoff) .or. &\n      (.not. picked_lower .and. higher_value < cutoff)) then\n    value = lower_value\n  else\n    value = higher_value\n end if\nend function single_trial\n"}, {"instruction": "Create a Fortran function named \"work\" to perform a series of operations on an array of integers based on specific input values. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function processes the input array based on specific rules and operations until completion, and then returns the resulting output value.", "input": "", "output": "function work(phasesetting, intputvalue) result (outputvalue)\n   integer :: phasesetting, intputvalue, readcount\n   integer :: outputvalue\n\n   integer, dimension(503) :: input\n   integer :: inputlength, de, a, b,c, desitionation, index, param, val1, val2\n   inputlength = 503\n\n   input = (/ 3,8,1001,8,10,8,105,1,0,0,21,34,51,68,89,98,179,260,341,422,99999,3,9,1001,9,&\n   4,9,102,4,9,9,4,9,99,3,9,1002,9,5,9,1001,9,2,9,1002,9,2,9,4,9,99,3,9,1001,9,3,9,102,3,9,&\n   9,101,4,9,9,4,9,99,3,9,102,2,9,9,101,2,9,9,1002,9,5,9,1001,9,2,9,4,9,99,3,9,102,2,9,9,4,&\n   9,99,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,&\n   9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,&\n   9,1001,9,1,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,&\n   9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,&\n   1,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,&\n   3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,&\n   9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,&\n   1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,&\n   4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,1001,&\n   9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,&\n   1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,99 /)\n\n    index = 1\n    readcount = 0\n    !inputvalue = 1 !part 1\n    loop: do while (index <= inputlength)\n\n        param = input(index) ! in the form abcde\n        de = mod(param, 100)\n        c = mod(int(param / 100),10)\n        b = mod(int(param / 1000),100)\n        a = mod(int(param / 10000),1000)\n        ! print *, param,a,b,c,de\n        if (c == 0)then\n            val1 = input(input(index + 1)+1)\n        else\n            val1 = input(index + 1)\n        end if\n\n        if (b == 0)then\n            val2 = input(input(index + 2)+1)\n        else\n            val2 = input(index + 2)\n        end if\n\n        if (a == 0)then\n            desitionation = input(index + 3)+1\n        else\n            ! this should never happen\n            desitionation = index + 3\n        end if\n\n        select case (de)\n        case (1:2)\n            ! add/multiply\n\n\n            if (de == 1) then\n                input(desitionation) = int(val1 + val2)\n            else\n                input(desitionation) = int(val1 * val2)\n            end if\n            index = index + 4\n        case (3:4)\n            ! input/output\n\n            desitionation = input(index+1)+1\n            if (de == 3) then\n                if (readcount == 0) then\n                    input(desitionation) = phasesetting\n                else if(readcount == 1)then\n                    input(desitionation) = intputvalue\n                else\n                    print *, 'too many read attemps....'\n                end if\n                readcount = readcount + 1\n            else\n                outputvalue = input(desitionation)\n            end if\n            index = index + 2\n\n        !part 2 stuff\n        case (5)\n\n            ! jump-if-true\n            if(val1 /= 0) then\n                index = val2 +1\n            else\n                index = index + 3\n            end if\n        case (6)\n\n\n            ! jump-if-false\n            if(val1 == 0) then\n                index = val2 +1\n            else\n                index = index + 3\n            end if\n        case (7)\n\n\n            ! less than\n            if(val1 < val2) then\n                input(desitionation) = 1\n            else\n                input(desitionation) = 0\n            end if\n            index = index + 4\n        case (8)\n\n            ! equals\n            if(val1 == val2) then\n                input(desitionation) = 1\n            else\n                input(desitionation) = 0\n            end if\n            index = index + 4\n        case (99)\n            ! end program\n            exit loop\n        case default\n            print *, 'unexpected op code',param,'at',index\n            exit loop\n        end select\n    end do loop\n    ! print *, outputvalue\nend function work\n"}, {"instruction": "Create a Fortran function named read_file to read the contents of a file and return it as a string. The function takes 1 input parameter of type character(*) representing the file name. It returns 1 output parameter of type character(1024) containing the contents of the file.", "input": "", "output": "  function read_file(file) result(r)\r\n    character(:), allocatable :: s\r\n    character(1024) :: r\r\n    character(*) :: file\r\n    character(len=1) :: buf\r\n    integer ios, size\r\n    integer, parameter :: end_of_file = -1    ! processor dependent\r\n    integer, parameter :: end_of_record = -2  ! processor dependent\r\n    open (unit = 21, file = file) !, status = \"old\", action = \"read\", form = \"formatted\")\r\n    do\r\n      read (unit = 21, fmt = \"(a)\", advance='no', size=size, iostat = ios) buf\r\n      if (ios == end_of_record) then\r\n        s = s//char(10)\r\n        cycle\r\n      else if (ios == end_of_file) then\r\n        r = s\r\n        exit\r\n      end if\r\n      s = s//buf\r\n    end do\r\n    close(21)\r\n  end function\r\n"}, {"instruction": "Create a Fortran function named calc_debug to perform a computation with debug information. It takes 2 input parameters: arg1 of type real and opt_format of type character with optional attribute. It returns 1 output parameter ret_val of type real.", "input": "", "output": "      function calc_debug(arg1, opt_format) result(ret_val)\n         real, intent(in) :: arg1\n         character (*), intent(in), optional :: opt_format\n         real :: ret_val\n         ret_val = 0.0\n\n         print *,\"with debug\"\n\n      end function calc_debug\n"}, {"instruction": "Provide a Fortran function named calc_normal that takes 2 input arguments of types real and character (*), where the character argument is optional. The function has 1 output argument of type real.", "input": "", "output": "      function calc_normal(arg1, opt_format) result(ret_val)\n         real, intent(in) :: arg1\n         character (*), intent(in), optional :: opt_format\n         real :: ret_val\n         ret_val = 0.0\n\n         print *,\"normal\"\n   \n      end function calc_normal\n"}, {"instruction": "Write a Fortran function named inside_circle to determine whether a point with coordinates (x, y) lies inside a circle with center coordinates (cen_x, cen_y) and a given radius. The function takes 5 input parameters of type integer: cen_x, cen_y, radius, x, and y. It returns a single output parameter of type logical indicating whether the point lies inside the circle.", "input": "", "output": "function inside_circle(cen_x, cen_y, radius, x, y) result(is_inside)\n    implicit none\n    integer, intent(in) :: cen_x, cen_y, radius, x, y\n    integer :: distance\n    logical :: is_inside\n    distance = (cen_x - x) * (cen_x - x) + (cen_y - y) * (cen_y - y)\n    is_inside = distance < radius * radius\nend function inside_circle\n"}, {"instruction": "Provide a Fortran function named chararray2string to convert a character array to a string. The function takes 1 input argument of type character(len=1), dimension(:) and returns 1 output argument of type character(len=size(chararray, 1)).", "input": "", "output": "  function chararray2string(chararray) result(text)\n    character(len=1), dimension(:) :: chararray    ! input\n    character(len=size(chararray, 1)) :: text      ! output\n    do i = 1,size(chararray,1)\n      text(i:i) = chararray (i)\n    end do\n  end function chararray2string\n"}, {"instruction": "Write a Fortran function named f2 that calculates the value of 3 times the square of a given real number. The function should take 1 input argument of type real and return 1 output argument of type real.", "input": "", "output": "function f2 (x)\n   real :: f2\n   real, intent (in) :: x\n\n   f2 = 3.0 * x**2\n\n   return\nend function f2\n"}, {"instruction": "Create a Fortran function named fancy that takes two real input parameters. The first input parameter is a function named func that takes a real parameter, and the second input parameter is a real number x. The function returns a real value.", "input": "", "output": "function fancy (func, x)\n   real :: fancy\n   real, intent (in) :: x\n\n   interface afunc\n      function func (y)\n         real :: func\n         real, intent (in) ::y\n      end function func\n   end interface afunc\n\n   fancy = func (x) + 3.3 * x\nend function fancy\n"}, {"instruction": "Write a Fortran function named counter that takes two input arguments of type integer ,pointer,dimension(:) and integer respectively. The function returns one output argument of type integer. This function counts the occurrences of a specific value in the array referenced by the pointer.", "input": "", "output": "      function counter(indx,value)\n      implicit none\n      integer ,pointer,dimension(:)::indx\n      integer ,intent(in)::value\n      integer ::counter,s,j,k\n      s=size(indx)\n      k=0\n      do j=1,s\n         if(indx(j)==value) then\n            k=k+1\n         end if\n      end do\n      counter=k\n      end function  counter\n"}, {"instruction": "Create a Fortran function named ia_row_col that takes 5 input parameters of type integer, pointer, and dimension. The input parameters are val, indx, jndx, i, and j. The function returns an output parameter of type integer. The function aims to find the value at the specified row (i) and column (j) in a matrix represented by val, indx, and jndx. If the specified row and column are found, the function returns the corresponding value; otherwise, it returns 0.", "input": "", "output": "      function ia_row_col (val,indx,jndx,i,j)\n      integer ,pointer,dimension(:)::val\n      integer ,pointer,dimension(:):: indx,jndx\n      integer,intent(in)::i,j\n      integer::k\n      logical::finder\n      integer :: ia_row_col  \n      finder=.false.\n      k=1\n      do while((k.le.size(val)).and.(.not.finder))\n         if(indx(k).eq.i.and.jndx(k).eq.j) then\n            finder=.true.\n         else\n            k=k+1\n         end if\n      end do\n      if(finder) then\n         ia_row_col  =val(k)\n      else\n         ia_row_col  =0\n      end if\n      end function ia_row_col \n"}, {"instruction": "Create a Fortran function named expand_region that takes three input parameters: two integers and a 100x100 integer array. The function returns an integer. The function's purpose is to expand a region in the 100x100 map based on the specified starting coordinates (i, j). The function iterates through the map, expanding the region in all directions and keeping count of the expanded cells.", "input": "", "output": "function expand_region(map, i, j) result(c)\n\n  integer :: i, j, x2, y2, region, found, c\n  integer, dimension(100,100) :: map\n\n  region = map(i,j)\n  found = 1\n  c = 1\n\n  ! print*, \"expand region = \", region, \"at =\", i, j, c\n\n  do while (found == 1)\n     found = 0\n     do y2 = 1, 100\n        do x2 = 1, 100\n           if (map(x2,y2) == region) then\n              ! above?\n              if (y2 > 1 .and. map(x2, y2 - 1) == 0) then\n                 map(x2, y2 - 1) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! below?\n              if (y2 < 100 .and. map(x2, y2 + 1) == 0) then\n                 map(x2, y2 + 1) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! left?\n              if (x2 > 1 .and. map(x2 - 1, y2) == 0) then\n                 map(x2 - 1, y2) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! right?\n              if (x2 < 100 .and. map(x2 + 1, y2) == 0) then\n                 map(x2 + 1, y2) = region\n                 c = c + 1\n                 found = 1\n              end if\n           end if\n        end do\n     end do\n  end do\n\nend function expand_region\n"}, {"instruction": "Provide a Fortran function named int2str to convert an integer to a string. The function takes 1 input argument of type integer and returns 1 output argument of type character(len=:),allocatable.", "input": "", "output": "function int2str(int) result(str)\nimplicit none\n    integer                         :: int\n    character(len=:),allocatable    :: str\n    character(len=20)               :: strtmp\n    \n    write(strtmp,*) int\n    str = trim(adjustl(strtmp))\n    \nend function\n"}, {"instruction": "Write a Fortran function named dbl2str that converts a double precision number to a string using the specified format. The number of input arguments is 2, and the test_data type is ['double precision', 'character(len=*), optional']. The number of output arguments is 1, and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function dbl2str(dbl, formatspec) result(str)\nimplicit none\n    double precision                :: dbl\n    character(len=*), optional      :: formatspec\n    character(len=:), allocatable   :: str\n    character(len=20)               :: formatspec_int\n    character(len=50)               :: strtmp\n    integer                         :: status\n    \n    if (present(formatspec)) then\n        formatspec_int = formatspec\n    else\n        formatspec_int = 'e15.5e3'\n    endif\n    \n    formatspec_int = '('//trim(formatspec_int)//')'\n    write(strtmp,formatspec_int, iostat=status) dbl\n    if (status/=0) then\n        write(*,*) 'formatspec = ', formatspec_int, ' not ok'\n        error stop 1\n    endif\n    \n    str = trim(adjustl(strtmp))\n    \nend function\n"}, {"instruction": "Write a Fortran function named first to return an integer result. The function takes two input arguments, one of which is optional and of type integer, and the other is of type integer. The number of input arguments is 2, and the test_data type is ['integer, optional', 'integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "  elemental function first(i, j) result(r)\n    integer, intent(in), optional :: i\n    integer, intent(in) :: j\n    integer :: r\n    if (present(i)) then\n      r = i\n    else\n      r = -5\n    end if\n  end function first\n"}, {"instruction": "Create a Fortran function named gzclose that takes in a single input parameter of type c_ptr by value. This function returns an output parameter of type integer(c_int).", "input": "", "output": "     function gzclose(file) bind(c)\n       use iso_c_binding, only: c_int, c_ptr\n       implicit none\n       type(c_ptr), value, intent(in) :: file\n       integer(c_int) :: gzclose\n     end function gzclose\n"}, {"instruction": "Create a Fortran function named area_circle to calculate the area of a circle. The function should have 1 input parameter of type real and 1 output parameter of type real. The input parameter represents the radius of the circle and is marked with the \"intent(in)\" attribute. The output parameter represents the calculated area of the circle. Use the local constant \"pi\" as 3.1415927 to perform the calculation.", "input": "", "output": "function area_circle(r)\n\nimplicit none\nreal :: area_circle\nreal, intent(in) :: r\n\n! declare local constant pi\nreal, parameter :: pi = 3.1415927\n\narea_circle = pi * r * r\n\nend function area_circle\n"}, {"instruction": "Write a Fortran function named greatest_common_divisor to calculate the greatest common divisor of two integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "        function greatest_common_divisor(x,y) result(c)\n        implicit none\n        integer, intent(in) :: x,y\n        integer             :: a,b\n        integer             :: t,c\n        a = x\n        b = y\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        c = abs(a)\n        end function\n"}, {"instruction": "Create a Fortran function named reduced that takes an array of integers as input and returns a reduced array. The input parameter should be of type integer and have a dimension of (:), while the output parameter should be of type integer, have a dimension of (:), and be allocatable.", "input": "", "output": "    function reduced (array)\n      integer, dimension(:), allocatable :: reduced\n      integer, dimension(:), intent(in) :: array\n      logical, dimension(size(array)) :: mask\n      mask = .true. \n      allocate (reduced (count (mask)))\n      reduced = pack (array, mask)\n    end function reduced\n"}, {"instruction": "Create a Fortran function named sec2ddhhmmss that takes an integer input parameter and returns an integer. The input parameter represents a time duration in seconds, and the function calculates the equivalent time in days, hours, minutes, and seconds and returns the result as a single integer.", "input": "", "output": "      function sec2ddhhmmss(sec) result (ddhhmmss)\n          !\n          ! call variables\n          !\n          integer                         , intent(in)    :: sec\n          integer                                         :: ddhhmmss\n          !\n          ! local variables\n          !\n          integer :: dd ! days\n          integer :: hh ! hours\n          integer :: mm ! minutes\n          integer :: ss ! seconds\n          !\n          !! executable statements ---------------------------------------------------\n          !\n          ! time in seconds\n          dd = sec\n          ss = mod(dd,60)\n          ! time in minutes\n          dd = (dd - ss)/60\n          mm = mod(dd,60)\n          ! time in hours\n          dd = (dd - mm)/60\n          hh = mod(dd,24)\n          ! time in days\n          dd = (dd - hh)/24\n          !\n          ddhhmmss = ss + 100*mm + 10000*hh + 1000000*dd\n      end function sec2ddhhmmss\n"}, {"instruction": "Create a Fortran function named pe to calculate the dot product of two arrays of real numbers, x and y, each with a dimension of 100. The function takes 2 input parameters of type real, dimension (1:100), and returns 1 output parameter of type real.", "input": "", "output": "function pe(x,y)\nreal :: pe, cont\nreal, dimension (1:100) :: x, y\ninteger :: c\n\ncont = 0\ndo c = 1,100\n    cont = cont + (x(c)*y(c))\n    pe = cont\nend do\n\nreturn\nend function pe\n"}, {"instruction": "Write a Fortran function named soma to calculate the sum of 100 real numbers provided in an array. The number of input parameters is 1 with the test_data type ['real, dimension (1:100)'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "function soma(x)\nreal :: soma, cont\nreal, dimension (1:100) :: x\ninteger :: c\n\ncont = 0\ndo c = 1,100\n    cont = cont + x(c)\n    soma = cont\nend do\n\nreturn\nend function soma\n"}, {"instruction": "Create a Fortran function named isdigit to check if a single character input is a digit or not. The function takes 1 input parameter of type character(1) and returns 1 output parameter of type logical. The input test_data type is ['character(1)'] and the output test_data type is ['logical'].", "input": "", "output": "    pure function isdigit(singlechar) result(stringisdigit)\n#if defined dll_enabled && !defined cfi_enabled\n        !dec$ attributes dllexport :: isdigit\n#endif\n        character(1), intent(in)    :: singlechar\n        logical                     :: stringisdigit\n        character(*), parameter     :: digit(10) = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        integer                     :: j\n        stringisdigit = .false.\n        loopoverdigit: do j = 1,10\n            if (singlechar==digit(j)) then\n                stringisdigit = .true.\n                exit loopoverdigit\n            end if\n        end do loopoverdigit\n    end function isdigit\n"}, {"instruction": "Create a Fortran function named isinteger that takes a single input argument of type character(*) and returns a logical value. The function checks whether the input string represents an integer and sets the logical output accordingly. Remember to handle the situation where the input string is empty or contains non-integer characters.", "input": "", "output": "    pure function isinteger(string) result(stringisinteger)\n#if defined dll_enabled && !defined cfi_enabled\n        !dec$ attributes dllexport :: isinteger\n#endif\n        character(*), intent(in)    :: string\n        logical                     :: stringisinteger\n        character(*), parameter     :: digit(10) = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        integer                     :: i, j\n        do i = 1,len(string)\n            stringisinteger = .false.\n            loopoverdigit: do j = 1,10\n                if (string(i:i)==digit(j)) then\n                    stringisinteger = .true.\n                    exit loopoverdigit\n                end if\n            end do loopoverdigit\n            if (.not.stringisinteger) return\n        end do\n    end function isinteger\n"}, {"instruction": "Create a Fortran function named compress that removes double whitespaces and spaces before a comma or dot in the input string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=len(a)).", "input": "", "output": "pure function compress(a) result(t)\n! ... removes all double whites and spaces before a comma or dot\n\ncharacter(len=*), intent(in)   :: a\ncharacter(len=len(a))          :: t\n\n! ... local variables\n! ...\ninteger i,n\n\n! ... remove leading whitespaces\n! ...\nt = adjustl(a)\nn = len_trim(t)\n\n! ... replace tabs by whitespaces\n! ...\ndo i=1,n\n  if (iachar(t(i:i)).eq.9) t(i:i) = ' '\nenddo\n\n! ... remove all double whites\n! ...\n10 i = index(t,'  ')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i+1:) = t(i+2:)\n     n = n - 1\n     goto 10\n   endif\n\n! ... remove space-commas\n! ...\n20 i = index(t,' ,')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i:) = t(i+1:)\n     n = n - 1\n     goto 20\n   endif\n\n! ... remove space-dots\n! ...\n30 i = index(t,' .')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i:) = t(i+1:)\n     n = n - 1\n     goto 30\n   endif\n\nend function compress\n"}, {"instruction": "Write a Fortran function named filename_append that takes 3 input parameters of type character (with optional third parameter), and returns a single output parameter of type character with a length of 280. The function appends the basename and optional extension to the path and constructs the full filename.", "input": "", "output": "pure function filename_append(path,basename,ext) result(filename)\n\ncharacter(len=*), intent(in)           :: path\ncharacter(len=*), intent(in)           :: basename\ncharacter(len=*), intent(in), optional :: ext\ncharacter(len=280)                     :: filename\n\n! ... local variables\n! ...\ninteger i\ncharacter(len=180) lpath,lbase,lext\n\nlpath = ''\nlext  = ''\n\ni = len_trim(path)\nif (i.eq.0) then\n  lpath = './'\nelse\n  if (path(i:i).eq.'/') then\n    lpath = trim(path)\n  else\n    lpath = trim(path)//'/'\n  endif\nendif\n\nif (basename(1:2).eq.'./') then\n  lbase = trim(basename(3:))\nelse\n  lbase = trim(basename)\nendif\n\nif (present(ext)) then\n  i = len_trim(ext)\n  if (i.gt.0) then\n    if (ext(1:1).eq.'.') then\n      lext = trim(ext)\n    else\n      lext = '.'//trim(ext)\n    endif\n  endif\nendif\n\nfilename = trim(lpath)//trim(lbase)//trim(lext)\n\nend function filename_append\n"}, {"instruction": "Create a Fortran function named getfieldcount to determine the number of fields in a character record delimited by a specified character. The function takes 2 input parameters of type character(*) and character, and returns 1 output parameter of type integer.", "input": "", "output": "      function getfieldcount( record, delimiter ) result( nfields )\n\n      implicit none\n\n      character(*) :: record\n      character    :: delimiter\n      integer      :: nfields\n\n      integer i\n      logical infield\n      logical isdel\n\n      nfields = 0\n      infield = .false.\n      do i = 1, len( record )\n        isdel = ( record( i:i ) .eq. delimiter )\n\n! check for start of field\n        if ( .not. infield .and. .not. isdel ) then\n           nfields = nfields+1\n           infield = .true.\n           cycle\n        end if\n\n! check for end of field\n        if ( infield .and. isdel ) then\n          infield = .false.\n          cycle\n        end if\n      end do \n       \n      return\n      end function getfieldcount\n"}, {"instruction": "Write a Fortran function named getparsednumber to count the number of fields in a character string that are separated by a specified delimiter. The function takes 2 input parameters of types character(*) and character, and returns 1 output parameter of type integer.", "input": "", "output": "      function getparsednumber( record, delimiter ) result( nfields )\n\n      implicit none\n\n      character(*) :: record\n      character    :: delimiter\n      integer      :: nfields\n\n      integer i\n\n      nfields = 1\n      do i = 1, len( record )\n        if ( index( delimiter, record( i:i ) ) .gt. 0 ) nfields = nfields+1\n      end do\n\n      return\n      end function getparsednumber\n"}, {"instruction": "Create a Fortran function named isperfect to determine if a given integer is a perfect number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical. The input parameter's test_data type is ['integer'], and the output parameter's test_data type is ['logical'].", "input": "", "output": "function isperfect(n)\n  logical :: isperfect\n  integer, intent(in) :: n\n  integer :: i, factorsum\n\n  isperfect = .false.\n  factorsum = 1\n  do i = 2, int(sqrt(real(n)))\n     if(mod(n, i) == 0) factorsum = factorsum + i + (n / i)\n  end do\n  if (factorsum == n) isperfect = .true.\nend function isperfect\n"}, {"instruction": "Create a Fortran function named \"phixxinfluence\" to calculate the Hessian matrix in global coordinates based on panel parameters and field point coordinates. The function takes 5 input parameters of type real(8) and returns 1 output parameter of type real(8), dimension (3,3).", "input": "", "output": "   function phixxinfluence (point, center, area, coordsys, qlocal) result (hessmatrix)\n\n     implicit none\n     ! fuildpoint, center of panel, result\n       real(8),dimension(3) :: point, center, plocal\n     ! matrix t with voectors i, j, k for panel\n       real(8),dimension(3,3) :: coordsys\n     ! panel comes in local coordinates\n       real(8),dimension(2,4) :: qlocal\n     ! the x and y value  \n       real(8) :: area\n       real(8), dimension (4) :: corner_x ! the x component of each corner\n       real(8), dimension (4) :: corner_y ! the y component of each corner \n     ! pi\n       real(8), parameter :: pi= 4.d0*datan(1.d0)\n     ! name k+1\n       integer, dimension(4), parameter :: kp1 = (/ 2, 3, 4, 1 /)\n       integer :: k\n       real(8), dimension (4) :: d ! length of panel side k between point q_k and q_k+1\n       real(8), dimension (4) :: m ! ratios of y and x coordinate difference of panel corners (local coordinates)\n       real(8), dimension (4) :: r ! distance from field point to the 4 corners\n       real(8), dimension (4) :: e\n       real(8), dimension (4) :: h\n       real(8), dimension (4) :: rho\n       real(8), dimension (4) :: lambda\n       real(8) :: phi_xx, phi_yx, phi_zx, phi_xy\n       real(8) :: phi_yy, phi_zy, phi_xz, phi_yz, phi_zz\n       real(8), dimension (3,3) :: hesslocal ! hessian matrix in local coordinate\n       real(8), dimension (3,3) :: hessmatrix !hessian matrix in global coordinate\n  \n     ! transfer the point p into the local coordinate system\n       plocal = matmul( transpose( coordsys), point-center)\n\n      ! x value\n      corner_x= qlocal(1,:)\n      ! y value\n      corner_y= qlocal(2,:)\n      \n      ! the length of panel side k between point q(k) and q(k+1)\n      do k = 1,4\n         d(k) = dsqrt((corner_x(kp1(k))-corner_x(k))**2 &\n                + (corner_y(kp1(k))-corner_y(k))**2)\n         \n         ! ratio of y and x coordinate differences of panel corners\n         if (d(k)==0) then \n              m(k)= 0 \n         else\n              m(k) = (corner_y(kp1(k))-corner_y(k)) &\n                      & / (corner_x(kp1(k))-corner_x(k))\n         end if\n      end do\n      \n      do k = 1,4\n         ! distance of field points form corner k\n         ! x is plocal(1)\n         ! y is plocal(2)\n         ! z is plocal(3)\n         r(k)   = dsqrt( (plocal(1)-corner_x(k))**2 &\n                   & + (plocal(2)-corner_y(k))**2 &\n                   & + plocal(3)**2)\n         e(k)   = (plocal(1)-corner_x(k))**2 + (plocal(3))**2\n         h(k)   = (plocal(1)-corner_x(k)) * (plocal(2)-corner_y(k))\n      end do  \n      \n      do k = 1,4\n        rho(k) = r(k)*r(kp1(k)) + &\n               & (plocal(1)-corner_x(k))*(plocal(1)- corner_x(kp1(k)))&\n               & + (plocal(2)-corner_y(k))*(plocal(2)-corner_y(kp1(k)))&\n               & + plocal(3)**2\n       lambda(k) = ((plocal(1)-corner_x(k))*(plocal(2)-corner_y(kp1(k)))&\n                & - (plocal(1) - corner_x(kp1(k)))*(plocal(2)-corner_y(k)))\n      end do\n      \n      ! the starting value of the second order dericatives\n       phi_xx = 0.\n       phi_xy = 0.\n       phi_xz = 0.\n       phi_yx = 0.\n       phi_yy = 0.\n       phi_yz = 0.\n       phi_zx = 0.\n       phi_zy = 0.\n       phi_zz = 0.       \n\n       do k = 1,4\n         phi_xx = phi_xx + 2*(corner_y(kp1(k))-corner_y(k)) / &\n                & ((r(k)+r(kp1(k)))**2-d(k)**2)      &\n                & *((plocal(1)-corner_x(k))/r(k) +   &\n                & (plocal(1)-corner_x(kp1(k)))/r(kp1(k)))\n       end do\n       phi_xx = -1./(4.*pi)*phi_xx\n       \n       do k= 1,4\n         phi_yx = phi_yx + (-2)*(corner_x(kp1(k))-corner_x(k)) &\n                & / ((r(k)+r(kp1(k)))**2-d(k)**2)   &\n                & *((plocal(1)-corner_x(k))/r(k)    &\n                & + (plocal(1)-corner_x(kp1(k)))/r(kp1(k)))\n       end do\n       phi_yx = -1./(4.*pi)*phi_yx\n       \n       do k = 1,4\n         phi_zx = phi_zx + plocal(3)*(corner_y(kp1(k))-corner_y(k))&\n               & *(r(k)+r(kp1(k)))/(r(k)*r(kp1(k))) / rho(k)\n       end do\n       phi_zx = -1./(4.*pi)*phi_zx    \n       \n       do k = 1,4\n         phi_xy = phi_xy + 2*(corner_y(kp1(k))-corner_y(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( (plocal(2)-corner_y(k))/r(k) &\n                & +(plocal(2)-corner_y(kp1(k)))/r(kp1(k)) )\n       end do\n       phi_xy = -1./(4.*pi)*phi_xy\n       \n       do k = 1,4\n         phi_yy = phi_yy + (-2*(corner_x(kp1(k))-corner_x(k))) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )             &\n                & *( (plocal(2)-corner_y(k))/r(k)              &\n                & + (plocal(2)-corner_y(kp1(k)))/r(kp1(k)) )\n       end do\n       phi_yy = -1./(4.*pi)*phi_yy \n       \n       do k = 1,4\n         phi_zy = phi_zy - plocal(3)*(corner_x(kp1(k))-corner_x(k)) &\n                & *(r(k)+r(kp1(k)))/(r(k)*r(kp1(k))) / rho(k)\n       end do\n       phi_zy = -1./(4.*pi)*phi_zy    \n       \n       do k = 1,4\n         phi_xz = phi_xz + 2*(corner_y(kp1(k))-corner_y(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( plocal(3)/r(k) + plocal(3)/r(kp1(k)) )\n       end do\n       phi_xz = -1./(4.*pi)*phi_xz\n       \n       do k = 1,4\n         phi_yz = phi_yz - 2*(corner_x(kp1(k))-corner_x(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( plocal(3)/r(k)+plocal(3)/r(kp1(k)) )\n       end do\n       phi_yz = -1./(4.*pi)*phi_yz\n       \n       do k = 1,4\n         phi_zz = phi_zz+lambda(k)*(r(k)+r(kp1(k))) &\n                & /(r(k)*r(kp1(k))*rho(k))\n       end do\n       phi_zz = -1./(4.*pi)*phi_zz\n       \n       hesslocal(1,1) = phi_xx\n       hesslocal(1,2) = phi_xy\n       hesslocal(1,3) = phi_xz\n       hesslocal(2,1) = phi_yx\n       hesslocal(2,2) = phi_yy\n       hesslocal(2,3) = phi_yz\n       hesslocal(3,1) = phi_zx\n       hesslocal(3,2) = phi_zy\n       hesslocal(3,3) = phi_zz\n   \n       hessmatrix = matmul(coordsys,hesslocal)\n       hessmatrix = matmul(hessmatrix,transpose(coordsys))\n       \n       ! return to caller\n       return\n\n\n  end function phixxinfluence\n"}, {"instruction": "Write a Fortran function named key_is_valid that takes a single input argument of type character(len=*) and returns a logical value. The function checks if the input contains only valid characters, including space, 0-9, A-Z, a-z, and underscore, and returns true if all characters are valid; otherwise, it returns false.", "input": "", "output": "    pure function key_is_valid(chars)\n        character(len=*), intent(in) :: chars\n        logical :: key_is_valid\n        character(len=1) :: char\n        integer :: i\n\n        do i = 1, len(chars)\n            char = chars(i:i)\n\n            select case (ichar(char))\n            case (32, 48:57, 65:90, 95, 97:122)\n                ! space, 0-9, a-z, _, a-z\n                ! key_is_valid = .true.\n            case default\n                key_is_valid = .false.\n                return\n            end select\n\n        end do\n\n        key_is_valid = .true.\n\n    end function key_is_valid\n"}, {"instruction": "Create a Fortran function named area_circle to calculate the area of a circle based on the provided radius. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. Use the formula area_circle = pi * r * r, where pi is a predefined constant and r is the radius of the circle.", "input": "", "output": "function area_circle(r)\nimplicit none\n\nreal*8, parameter :: pi = 3.1415927\nreal*8, intent(in) :: r\nreal*8 :: area_circle\n\narea_circle = pi * r * r\nreturn\n\nend function area_circle\n"}, {"instruction": "Write a Fortran function named imaxloc to find the index of the maximum value in a real array. The function should take 1 input parameter of type real, with a dimension of (:), and provide 1 output parameter of type integer.", "input": "", "output": "  function imaxloc (array)\n    real, dimension (:), intent (in) :: array\n    integer :: imaxloc\n    integer, dimension (1) :: imax\n    imax = maxloc(array)\n    imaxloc = imax(1)\n  end function imaxloc\n"}, {"instruction": "Create a Fortran function named halfadder to perform a logical half adder operation. The function takes 3 input parameters of type logical and returns 1 output parameter of type logical. The input parameters are a, b, and c, and the output parameter is c.", "input": "", "output": "function halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n"}, {"instruction": "Create a Fortran function named rform that calculates the formation rate in cubic centimeters per second. This function takes 2 input parameters of type real, representing the values of z and t. It returns a single output parameter of type real, which represents the formation rate.", "input": "", "output": "function rform(t,z) ! formation rate in cm^3 s^-1\n real :: rform,z,t\n real, parameter :: tref=102\n rform=3.5e-18*z*t**.5/(1+t/tref)**2*mu\n if(t.gt.tform) rform=0\nend function \n"}, {"instruction": "Write a Fortran function named taudiss1 that computes the dissipation time scale (tau) based on the input parameters t and n, both of type real. The function takes 2 input arguments of type real and returns 1 output argument of type real. The function uses the imperative tone and calculates the dissipation time scale according to the given parameters and conditions.", "input": "", "output": " function taudiss1(t,n) result(tau)\n  real :: tau\n  real, intent(in) :: t,n\n  real, parameter :: tref=3162,tauref=3.2e10,tmin=3000,tmax=10000\n!  if(t.lt.tmin) then\n!   tau=tauref*(tref/tmin)**12/n \n!   return\n!  endif\n  if(t.gt.tmax) then\n   tau=tauref*(tref/tmax)**12/n\n   return\n  endif  \n  tau=tauref*(tref/t)**12/n\n end function\n"}, {"instruction": "Create a Fortran function named two_n_choose_n to calculate the value of \"2n choose n\". The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(8). The input parameter represents the value of n for which the \"2n choose n\" is calculated.", "input": "", "output": "  pure function two_n_choose_n(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(8)             :: two_n_choose_n\n\n    ! local variables\n    integer(4) :: i\n\n    two_n_choose_n = 1\n    do i=1,n\n       two_n_choose_n = two_n_choose_n * (n+i)/i\n    enddo\n\n    return\n  end function two_n_choose_n\n"}, {"instruction": "Write a Fortran function named lcg to implement a linear congruential generator (LCG) algorithm. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type integer. The test_data types for input and output parameters are ['integer(8)'] and ['integer'] respectively.", "input": "", "output": "  function lcg(s)\n    integer :: lcg\n    integer(8) :: s\n    if (s == 0) then\n       s = 104729_8\n    else\n       s = mod(s, 4294967296_8)\n    end if\n    s = mod(s * 279470273_8, 4294967291_8)\n    lcg = int(mod(s, int(huge(0), 8)), kind(0))\n  end function lcg\n"}, {"instruction": "Create a Fortran function named \"number_of_divisors\" to calculate the number of divisors of a given integer. The function should have 1 input parameter with a test_data type of ['integer'] and 1 output parameter with a test_data type of ['integer']. Use the imperative tone.", "input": "", "output": "    function number_of_divisors(val) result(ret)\n        integer, intent(in) :: val\n        integer :: ret, i, x\n\n        ret = 0\n        x = int(sqrt(real(val)))\n        do i = 1, x - 1\n            if (mod(val, i) == 0) ret = ret + 2\n        end do\n        if (mod(val, x) == 0) ret = ret + 1\n    end function number_of_divisors\n"}, {"instruction": "Create a Fortran function named sum_to that calculates the sum of integers from 1 to the given input integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function sum_to(n) result(r)\n    implicit none\n    integer :: r\n    integer, intent(in) :: n\n\n    r = 0\n\n    if (n == 0) then\n      return\n    end if\n\n    r = n + sum_to(n-1)\n\n  end function sum_to\n"}, {"instruction": "Write a Fortran function named chisq to calculate the chi-square value. The function takes 3 input parameters of type double precision: x, x0, and dx. It returns 1 output parameter of type double precision. If dx is not equal to 0, the chi-square value is computed using the formula (x-x0)^2/dx^2; otherwise, a warning message is displayed and the chi-square value is set to 100000.", "input": "", "output": "function chisq(x,x0,dx)\n!------------------------------------------------------------------------------------    \n implicit none \n double precision, intent(in) :: x,x0,dx\n double precision :: chisq\n \n if(dx.ne.0) then \n  chisq=(x-x0)**2/dx**2\n else\n  write(*,*) 'warning, dx = 0'\n  chisq=100000. \n endif\n \nend function chisq\n"}, {"instruction": "Create a Fortran function named to_lower_index that takes a single input parameter of type character(len=1) and returns a single output parameter of the same type. The function converts the input character to lowercase and returns the result.", "input": "", "output": "  pure function to_lower_index(c) result(res)\n    character(len=1), intent(in) :: c\n    character(len=1) :: res\n\n    integer :: i\n    character(len=26), parameter :: &\n      upper = \"abcdefghijklmnopqrstuvwxyz\", &\n      lower = \"abcdefghijklmnopqrstuvwxyz\"\n\n    res = c\n    i = index(upper, c)\n    if (i > 0) res = lower(i:i)\n  end function\n"}, {"instruction": "Create a Fortran function named gamln1 to calculate the natural logarithm of the gamma function for a given input. The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "function gamln1 (a) result(fn_val)\n!-----------------------------------------------------------------------\n!     evaluation of ln(gamma(1 + a)) for -0.2 .le. a .le. 1.25\n!-----------------------------------------------------------------------\nimplicit none\ndouble precision, intent(in) :: a\ndouble precision             :: fn_val\n\ndouble precision :: w, x, &\n             p0 =  .577215664901533d+00, p1 =  .844203922187225d+00,  &\n             p2 = -.168860593646662d+00, p3 = -.780427615533591d+00,  &\n             p4 = -.402055799310489d+00, p5 = -.673562214325671d-01,  &\n             p6 = -.271935708322958d-02,   &\n             q1 =  .288743195473681d+01, q2 =  .312755088914843d+01,  &\n             q3 =  .156875193295039d+01, q4 =  .361951990101499d+00,  &\n             q5 =  .325038868253937d-01, q6 =  .667465618796164d-03,  &\n             r0 = .422784335098467d+00,  r1 = .848044614534529d+00,  &\n             r2 = .565221050691933d+00,  r3 = .156513060486551d+00,  &\n             r4 = .170502484022650d-01,  r5 = .497958207639485d-03,  &\n             s1 = .124313399877507d+01,  s2 = .548042109832463d+00,  &\n             s3 = .101552187439830d+00,  s4 = .713309612391000d-02,  &\n             s5 = .116165475989616d-03\n!----------------------\nif (a >= 0.6d0) go to 10\nw = ((((((p6*a + p5)*a + p4)*a + p3)*a + p2)*a + p1)*a + p0)/  &\n    ((((((q6*a + q5)*a + q4)*a + q3)*a + q2)*a + q1)*a + 1.0d0)\nfn_val = -a*w\nreturn\n\n10 x = (a - 0.5d0) - 0.5d0\nw = (((((r5*x + r4)*x + r3)*x + r2)*x + r1)*x + r0)/  &\n    (((((s5*x + s4)*x + s3)*x + s2)*x + s1)*x + 1.0d0)\nfn_val = x*w\nreturn\nend function gamln1\n"}, {"instruction": "Create a Fortran function named iday that takes three integer input parameters (yyyy, mm, dd) representing a calendar date and returns a single integer output parameter (ival) representing the day of the year. The function should calculate the day of the year based on the input date using a specific formula.", "input": "", "output": " function iday(yyyy, mm, dd) result(ival)\n!====iday is a companion to calend; given a calendar date, yyyy, mm,\n!           dd, iday is returned as the day of the year.\n!           example: iday(1984, 4, 22) = 113\n\n integer, intent(in) :: yyyy, mm, dd\n integer             :: ival\n\n ival = 3055*(mm+2)/100 - (mm+10)/13*2 -91 +  &\n       (1-(modulo(yyyy, 4)+3)/4              &\n        + (modulo(yyyy, 100) + 99)/100 -        &\n       (modulo(yyyy, 400)+399)/400)*(mm+10)/13 + dd\n\n return\n end function iday\n"}, {"instruction": "Create a Fortran function named fact_i to calculate the factorial of an input integer number. The input argument is of type integer. The output argument is of type real(kind=8).", "input": "", "output": "       function fact_i(n)\n       \n        integer, intent(in) :: n\n        real(kind=8) :: fact_i\n        integer :: i\n\n        fact_i = 1.d0\n        do i = 2, n\n            fact_i = fact_i * i\n        enddo\n        \n       end function fact_i\n"}, {"instruction": "Create a Fortran function named chomp_substring_char_char to remove a specified substring from a given string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    pure function chomp_substring_char_char(string, substring) result(chomped_string)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        character(len=:), allocatable :: chomped_string\n        integer :: last, nsub\n\n        last = len(string)\n        nsub = len(substring)\n        if (nsub > 0) then\n            do while(string(last-nsub+1:last) == substring)\n                last = last - nsub\n            end do\n        end if\n        chomped_string = string(1:last)\n\n    end function chomp_substring_char_char\n"}, {"instruction": "Write a Fortran function named starts_with_char_char that checks whether a given string starts with a specified substring. The function takes 2 input arguments with test_data type ['character(len=*)', 'character(len=*)'] and 1 output argument with test_data type ['logical'].", "input": "", "output": "    pure function starts_with_char_char(string, substring) result(match)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        logical :: match\n        integer :: nsub\n\n        nsub = len(substring)\n        if (len(string) < nsub) then\n            match = .false.\n            return\n        end if\n        match = string(1:nsub) == substring\n\n    end function starts_with_char_char\n"}, {"instruction": "Create a Fortran function named ends_with_char_char to determine if a given string ends with a specific substring. The function should take 2 input arguments of type character(len=*) and return 1 output argument of type logical. The test_data types for input and output are ['character(len=*)', 'character(len=*)'] and ['logical'] respectively.", "input": "", "output": "    pure function ends_with_char_char(string, substring) result(match)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        logical :: match\n        integer :: last, nsub\n\n        last = len(string)\n        nsub = len(substring)\n        if (last < nsub) then\n            match = .false.\n            return\n        end if\n        match = string(last-nsub+1:last) == substring\n\n    end function ends_with_char_char\n"}, {"instruction": "Create a Fortran function named padl_char_pad_with that takes 3 input parameters: a character string, an integer representing the desired output length, and a single character to pad with. The output parameter is a character with a length equal to the maximum of the input string length or the specified output length. The function aims to left-pad the input string with the specified character to achieve the desired output length.", "input": "", "output": "    pure function padl_char_pad_with(string, output_length, pad_with) result(res)\n        character(len=*), intent(in) :: string\n        integer, intent(in) :: output_length\n        character(len=1), intent(in) :: pad_with\n        character(len=max(len(string), output_length)) :: res\n        integer :: string_length\n\n        string_length = len(string)\n\n        if (string_length < output_length) then\n            res = repeat(pad_with, output_length - string_length)\n            res(output_length - string_length + 1 : output_length) = string\n        else\n            res = string\n        end if\n\n    end function padl_char_pad_with\n"}, {"instruction": "Create a Fortran pure function named n_c_r to calculate the binomial coefficient \"n choose r\" using the input parameters n and r, both of type integer. The function returns a single integer result of type integer(16).", "input": "", "output": "    pure function n_c_r(n, r) result(bin)\n        integer(16)         :: bin\n        integer, intent(in) :: n\n        integer, intent(in) :: r\n\n        integer(16)         :: num\n        integer(16)         :: den\n        integer             :: i\n        integer             :: k\n        integer, parameter  :: primes(*) = [2,3,5,7,11,13,17,19]\n        num = 1\n        den = 1\n        do i=0,r-1\n            num = num*(n-i)\n            den = den*(i+1)\n            if (i > 0) then\n                ! divide out common prime factors\n                do k=1,size(primes)\n                    if (mod(i,primes(k)) == 0) then\n                        num = num/primes(k)\n                        den = den/primes(k)\n                    end if\n                end do\n            end if\n        end do\n        bin = num/den\n    end function n_c_r\n"}, {"instruction": "Create a Fortran function named hash to generate a 32-bit integer hash value from an input text string. The function should accept 1 input parameter of type character(len=*) and return 1 output parameter of type integer.", "input": "", "output": "function hash(text) result(hashed)\n    implicit none\n    character(len=*), intent(in) :: text\n    integer                       :: hashed     ! 32-bit integers assumed\n\n    integer, parameter :: magic_numb = z'5d7a9f43'\n    integer            :: i, j\n\n    hashed = 0                              ! note: b was not initialized before\n    do i = 1, len_trim(text)\n        j = mod(i - 1, 4)*8\n        hashed = ieor(hashed, ishft(ichar(text(i:i)), j))\n    end do\n\n    hashed = abs(ieor(hashed, magic_numb))    ! why take the absolute value?\n\n    return\nend function hash\n"}, {"instruction": "Create a Fortran function named check_values_int that compares two integer values. The function takes 2 input arguments of type integer and returns 1 output argument of type logical.", "input": "", "output": "  function check_values_int( val1, val2 )\n    integer :: val1, val2\n    logical :: check_values_int\n\n    if( val1 == val2 ) then\n      check_values_int = .true.\n    else\n      check_values_int = .false.\n    endif\n  end function check_values_int\n"}, {"instruction": "Create a Fortran function named fp to calculate the derivative of a given real number. The function should take 1 input argument of type real and return 1 output argument of type real.", "input": "", "output": "function fp(x) !funci\u00f3n derivada\n  implicit none\n  real::fp, x\n  fp=cos(x)+sin(x)\nend function fp\n"}, {"instruction": "Create a Fortran function named distance that calculates the distance between two geographic coordinates on Earth. The function takes 4 input parameters of type real: lon1, lat1, lon2, and lat2. It returns a single output parameter of type real, representing the distance in meters.", "input": "", "output": "    function distance(lon1, lat1, lon2, lat2)\n    !\n    !>\\ author : fanghe zhao\n    !>\\ date : 10/2018\n    !>\\ details:\n\n    !\n        implicit none\n\n        real, parameter :: r_e = 6371 \n        real, intent(in) :: lon1, lat1, lon2, lat2\n        real :: distance\n        real :: dlon, dlat\n        real :: a, b\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n        a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n        b = 2 * atan2(sqrt(a), sqrt(1 - a))\n        distance = r_e * b * 1000\n\n        return\n    end function distance\n"}, {"instruction": "Write a Fortran function named pekerisroot that calculates the square root of a complex number. The function takes 1 input parameter of type complex (kind=8), and returns 1 output parameter of type complex (kind=8). If the real part of the input is greater than or equal to 0, the output is the square root of the input. Otherwise, the output is the square root of the negative of the input multiplied by (0.0d0, 1.0d0).", "input": "", "output": "function pekerisroot( z )\r\n\r\n  ! at one time, this was used to return the 'pekeris branch cut'     \r\n  ! which is just a particular branch of the square root that         \r\n  ! exposes many 'leaky' or 'virtual' modes.                          \r\n\r\n  ! the current version implements a particular branch that was convenient                                                   \r\n\r\n  implicit none\r\n  complex (kind=8), intent(  in ) :: z\r\n  complex (kind=8)                :: pekerisroot\r\n\r\n  if ( real( z ) >= 0.0d0 ) then \r\n     pekerisroot = sqrt( z ) \r\n  else \r\n     pekerisroot = ( 0.0d0, 1.0d0 ) * sqrt( -z ) \r\n  endif\r\n\r\nend function pekerisroot\r\n"}, {"instruction": "Write a Fortran function named ifirstchar that takes a character string as input and returns the position of the first non-space character in the string. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function ifirstchar(rec)\n    implicit none\n!\n! global variables\n!\n    integer         :: ifirstchar\n    character(*), intent(in)       :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    do i = 1, len(rec)\n       if (index(rec(i:i), ' ')==0) then\n          ifirstchar = i\n          return\n       endif\n    enddo\n    ifirstchar = 0\nend function ifirstchar\n"}, {"instruction": "Provide a Fortran function named ifirstletter, which takes a character string as input and returns the position of the first letter in the string. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function ifirstletter(rec)\n    implicit none\n!\n! global variables\n!\n    integer         :: ifirstletter\n    character(*)    :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n    integer                        :: i1\n    integer                        :: i2\n    integer                        :: i3\n    integer                        :: len_trim\n    integer                        :: l\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    !     geeft positie van eerste letter, niet nummer\n    l = len_trim(rec)\n    ifirstletter = 0\n    do i = 1, l\n       i1 = index('qwertyuiopasdfghjklzxcvbnm', rec(i:i))\n       i2 = index('qwertyuiopasdfghjklzxcvbnm', rec(i:i))\n       i3 = max(i1, i2)\n       if (i3/=0) then\n          ifirstletter = i\n          return\n       endif\n    enddo\nend function ifirstletter\n"}, {"instruction": "Create a Fortran function named pcol that takes three integer arguments of kind c_int: global_col, nblk, and np_cols. The function returns an integer of kind c_int. The purpose of the function is to compute the local column index based on the global column index, the block size, and the number of columns.", "input": "", "output": "   pure function pcol(global_col, nblk, np_cols) result(local_col)\n      use, intrinsic :: iso_c_binding, only : c_int\n      implicit none\n      integer(kind=c_int), intent(in) :: global_col, nblk, np_cols\n      integer(kind=c_int)             :: local_col\n      local_col = mod((global_col-1)/nblk,np_cols)\n   end function\n"}, {"instruction": "Create a Fortran function called prow to calculate the local row index based on the global row index, the block size, and the total number of rows. The function takes 3 input parameters of type integer(kind=c_int) and returns 1 output parameter of type integer(kind=c_int). The function should be used with imperative tone.", "input": "", "output": "   pure function prow(global_row, nblk, np_rows) result(local_row)\n      use, intrinsic :: iso_c_binding, only : c_int\n      implicit none\n      integer(kind=c_int), intent(in) :: global_row, nblk, np_rows\n      integer(kind=c_int)             :: local_row\n      local_row = mod((global_row-1)/nblk,np_rows)\n   end function\n"}, {"instruction": "Write a Fortran pure function named integer_to_string that converts an input integer to a string. The number of input arguments is 1, and the test_data type is [integer]. The number of output arguments is 1, and the test_data type is ['character(len=:),allocatable'].", "input": "", "output": "    pure function integer_to_string(i) result(s)\n\n    implicit none\n\n    integer,intent(in) :: i\n    character(len=:),allocatable :: s\n\n    integer :: istat\n\n    allocate( character(len=64) :: s )  ! should be big enough\n    write(s,fmt='(ss,i0)',iostat=istat) i\n    if (istat==0) then\n        s = trim(adjustl(s))\n    else\n        s = '***'\n    end if\n\n    end function integer_to_string\n"}, {"instruction": "Write a Fortran function named f_order to determine the order of an arithmetic operator based on the given command. The input parameter is a character string of any length, and the output parameter is an integer. The function will return the order of the arithmetic operator specified in the input command.", "input": "", "output": "  function f_order(command) result(order)\n    character(len=*), intent(in) :: command\n    integer :: order\n\n    order = 0\n    \n    select case(trim(command))\n\n    case('!=','==','>=','=>','<=','=<','=','<','>')\n       order = 1\n\n    case('+','-')\n       order = 10\n\n    case('*','/')\n       order = 100\n\n    case('**','^')\n       order = 1000\n\n    end select\n  end function f_order\n"}, {"instruction": "Create a Fortran function named calc_pi that calculates the value of pi using a Monte Carlo method. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type real(8). The input parameter represents the number of iterations to perform in the Monte Carlo simulation.", "input": "", "output": "  function calc_pi(n) result(pi)\n    implicit none\n    integer(8) :: accept\n    real(8) :: r(2), pi\n    integer(8), intent(in) :: n\n    integer(8) :: i\n\n    accept = 0\n\n    !$omp parallel do private(r,i) reduction(+:accept)\n    do i = 1, n\n       call random_number(r)\n       if (r(1)**2 + r(2)**2 <= 1) then\n          accept = accept + 1\n       end if\n    end do\n    !$omp end parallel do\n\n    pi = 4.0d0 * dble(accept)/dble(n)\n\n  end function calc_pi\n"}, {"instruction": "Create a Fortran function named \"du\" to calculate the gradient of the potential energy surface for a given set of particle positions. The function takes 2 input parameters: an integer \"nn\" representing the number of particles, and a real*8, 3-dimensional array \"pos\" representing the particle positions. It returns 1 output parameter: a real*8, 3-dimensional array \"du\" representing the gradient of the potential energy surface.", "input": "", "output": "        function du(nn,pos)\n\n            ! input\n            integer, intent(in) :: nn                   ! number of particles\n            real*8, dimension(nn,3), intent(in) :: pos  ! particle's position\n\n            ! output\n            real*8, dimension(nn,3) :: du               ! gradient of the pes\n\n            ! parameters\n            real*8, parameter :: k = 500 ! spring constant (todo: different force constant for different interactions)\n            real*8, parameter :: d = 1 ! equilibrium distance (todo: different equilibrium distance for different interactions)\n\n            ! intermediate variables\n            real*8 :: r, dx, dy, dz\n            integer :: i, j ! loop indices\n\n            du(:,:) = 0.0d0\n\n            do i = 1, nn-1\n                do j = i+1, nn\n                    dx = pos(i,1) - pos(j,1)\n                    dy = pos(i,2) - pos(j,2)\n                    dz = pos(i,3) - pos(j,3)\n\n                    r = dsqrt(dx**2 + dy**2 + dz**2)\n\n                    du(i,1) = du(i,1) - k * (d - r) / r * dx\n                    du(i,2) = du(i,2) - k * (d - r) / r * dy\n                    du(i,3) = du(i,3) - k * (d - r) / r * dz\n\n                    du(j,1) = du(j,1) + k * (d - r) / r * dx\n                    du(j,2) = du(j,2) + k * (d - r) / r * dy\n                    du(j,3) = du(j,3) + k * (d - r) / r * dz\n                end do\n            end do\n\n\n        end function\n"}, {"instruction": "Create a Fortran function named func that takes in 1 input argument of type logical. The test_data type is ['logical']. This function returns 1 output argument of type integer, which is allocatable. The test_data type is ['integer, allocatable']. The function allocates memory for the integer variable \"func\" if the input argument is true, and assigns the value 5332 to it. If \"func\" is already allocated, the function stops with an error code 8.", "input": "", "output": "  function func (alloc)\n    integer, allocatable ::  func\n    logical :: alloc\n    if (allocated (func)) stop 8\n    if (alloc) then\n      allocate(func)\n      func = 5332\n    end if\n  end function func\n"}, {"instruction": "Create a Fortran function named string_tolower, which takes a single input argument of type character with variable length. The output is a single argument of type character with the same variable length as the input. The function converts the input string to lowercase and returns the result.", "input": "", "output": "function string_tolower( string ) result (new) \n    character(len=*)           :: string \n\n    character(len=len(string)) :: new \n\n    integer                    :: i \n    integer                    :: k \n\n    length = len(string) \n    new    = string \n    do i = 1,len(string) \n        k = iachar(string(i:i)) \n        if ( k >= iachar('a') .and. k <= iachar('z') ) then \n            k = k + iachar('a') - iachar('a') \n            new(i:i) = achar(k) \n        endif \n    enddo \nend function string_tolower\n"}, {"instruction": "Create a Fortran function named xfunc to compute the value of a mathematical expression. The function takes 1 input argument of type real. The output is also of type real. The function calculates the value of (x^4)*log(x + sqrt(x^2+1)) and returns the result.", "input": "", "output": "\t  function xfunc(x)\n\t  \t\treal :: xfunc\n\t\t\treal :: x\n\t\t\txfunc = (x**4)*log(x + sqrt(x**2+1))\n\t\t\treturn\n\t  end function xfunc\n"}, {"instruction": "Create a Fortran function named iround that takes a single real number as input and returns the nearest integer value. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function iround(x) result(ival)\r\nimplicit none\r\n\r\nreal, intent(in)  :: x\r\ninteger           :: ival\r\n\r\nreal, parameter  :: half = 0.5\r\n\r\nival = int(x + sign(half,x))\r\nreturn\r\nend function iround\r\n"}, {"instruction": "Create a Fortran function named foo that takes an integer as input and returns a 4-character string. The input parameter should be of type integer, and the output parameter should be of type character with a length of 4. If the input value is less than 0, the output string should be \"1234\". Otherwise, the output string should be \"abcd\".", "input": "", "output": "  function foo (i) result (s)\n    integer, intent(in) :: i\n    character (len=4)   :: s, t\n    if (i < 0) then\n       s = \"1234\"\n    else\n       ! internal i/o, allowed recursive in f2003, see section 9.11\n       write (s, '(a)') \"abcd\"\n    end if\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"triplet\" that takes an integer input and returns an array of three integers. The input parameter should be of type integer. The output parameter should be of type integer array with dimension 3.\nThis function is designed to find a Pythagorean triplet (a set of three positive integers a, b, and c) where a^2 + b^2 = c^2, given a specific number.", "input": "", "output": "function triplet(number)\n    implicit none\n    integer, intent(in) :: number\n    integer, dimension(3) :: triplet\n    integer :: a, b, c\n\n    loopa: do a = 1, number\n        do b = a, number\n            c = number - a - b\n            if (a*a + b*b == c*c) then\n                exit loopa\n            end if\n        end do\n    end do loopa\n    \n    triplet(1) = a\n    triplet(2) = b\n    triplet(3) = c\n    \nend function triplet\n"}, {"instruction": "Write a Fortran function named model_function, which takes two input arguments of type character with variable length and pointer, and returns one output argument of type logical. The function copies the input character to the output character, allocates memory for the output, sets the output to true, and prints the output and its length.", "input": "", "output": "  function model_function(inputb, outputb) result(out)\n    character(len=*), intent(in) :: inputb\n    character(len=:), pointer :: outputb\n    logical :: out\n    out = .true.\n    allocate(character(len=len(inputb)) :: outputb)\n    outputb = inputb\n    write(*, '(\"model b: \",a,\" (length = \",i3,\")\")') outputb, len(outputb)\n  end function model_function\n"}, {"instruction": "Create a Fortran function named f that takes a real input argument and returns a real output. The function computes the value of f(x) = x - exp(-x). The function has 1 input parameter of type real and 1 output parameter of type real.", "input": "", "output": "function f(x)\r\n    implicit none\r\n    real::f !dummy variable\r\n    real::x !local variable\r\n    f=x-exp(-x)\nend function\r\n"}, {"instruction": "Create a Fortran function named \"fd\" that takes a single real input argument. This function computes a new real value using the formula: 1 + exp(-x). The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function fd(x)\r\n    implicit none\r\n    real::fd    !dummy variable\r\n    real::x     !local variable\r\n    fd=1+exp(-x)\nend function\r\n"}, {"instruction": "Write a Fortran function named dlclose that takes a single input argument of type \"type(c_ptr), value\" and returns an output of type \"integer(c_int)\". The function is intended to call the \"dlclose\" function from the C library to unload a shared library.", "input": "", "output": "      function dlclose(handle) bind(c,name=\"dlclose\")\n         ! int dlclose(void *handle);\n         use iso_c_binding\n         implicit none\n         integer(c_int) :: dlclose\n         type(c_ptr), value :: handle\n      end function\n"}, {"instruction": "Write a Fortran function named elem that takes 4 input arguments of type integer(kind=int32) and returns 1 output argument of type real(kind=real64). The function computes a value based on the input arguments according to a specific algorithm involving mathematical operations.", "input": "", "output": "    pure function elem(m, n, k, l)\r\n\r\n      use, intrinsic :: iso_fortran_env\r\n      implicit none\r\n\r\n      integer(kind=int32), intent(in) :: m, n, k, l\r\n      !real(kind=real128) :: elem\r\n      real(kind=real64) :: elem\r\n\r\n      integer(kind=int32) :: i\r\n\r\n      elem = 0.\r\n\r\n      if(m /= n - l + k) then\r\n        return\r\n      endif\r\n      if(n < l) then\r\n        return\r\n      endif\r\n      elem = 1.\r\n      ! apply creation operator\r\n      do i = 0, l - 1\r\n        !elem = elem * sqrt(real(n - i, 16))\r\n        elem = elem * sqrt(real(n - i, 8))\r\n      end do\r\n      ! apply anihilation operator\r\n      do i = 1, k\r\n        !elem = elem * sqrt(real(n - l + i, 16))\r\n        elem = elem * sqrt(real(n - l + i, 8))\r\n      end do\r\n\r\n    end function elem\r\n"}, {"instruction": "Create a Fortran function named \"nibble\" that takes an integer as input and returns a character. The input parameter is of type integer, and the output parameter is of type character. The function should convert the input integer to its corresponding hexadecimal digit and return it as a character.", "input": "", "output": "   pure function nibble(x)\n      integer, intent(in) :: x\n      character           :: nibble\n      select case (x)\n      case (0:9)\n         nibble = achar(iachar('0') + x)\n      case default\n         nibble = achar(iachar('a') - 10 + x)\n      end select\n   end function nibble\n"}, {"instruction": "Create a Fortran function named commadash that takes a string of length 25 as input and replaces any commas with dashes. The function should have 1 input parameter of type character(len=25) and 1 output parameter of type character(len=25).", "input": "", "output": "   function commadash(string)\r\n      character(len=25) :: commadash\r\n      character(len=25), intent(in) :: string \r\n      character(len=len(string)) :: temp\r\n      integer :: i\r\n\r\n      temp = string\r\n\r\n      do i=1, len(string)\r\n\r\n         if (temp(i:i)==',') temp(i:i) = '-'\r\n\r\n      end do\r\n    \r\n      commadash = temp\r\n      return         \r\n   end function commadash\r\n"}, {"instruction": "Create a Fortran function called noop_global_isum that takes an integer input argument and returns it as the output. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "        function noop_global_isum (var) result (noop_global_isum_result)\n\n        implicit none\n\n        integer, intent(in) :: var\n        integer :: noop_global_isum_result\n\n        noop_global_isum_result = var\n\n        end function noop_global_isum \n"}, {"instruction": "Create a Fortran function named noop_global_rsum to return a real value. It takes one input argument of type real and returns a real result.", "input": "", "output": "        function noop_global_rsum (var) result (noop_global_rsum_result)\n\n        implicit none\n\n        real, intent(in) :: var\n        real :: noop_global_rsum_result\n\n        noop_global_rsum_result = var\n\n        end function noop_global_rsum\n"}, {"instruction": "Write a Fortran function named fact to compute the factorial of a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "recursive function fact(n) result (fact_n)\n  implicit none\n  real :: fact_n\n  integer, intent (in) :: n\n  select case(n)\n  case(0)\n     fact_n=1.0\n  case(1:)\n     fact_n=n*fact(n-1)\n  case default\n     fact_n=0.0\n  end select\nend function fact\n"}, {"instruction": "Create a Fortran function named csedtaub to calculate the critical stress for bulk or mass erosion of cohesive material. The function takes 2 input parameters of type integer and real and returns 1 output parameter of type real. The number of input arguments is 2 and the test_data type is [integer, real].The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function csedtaub(denbulk,iopt)\n\n  ! **  calculates critial stress for bulk or mass erosion of cohesive\n\n  ! **  iopt=1  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment drodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n  ! **  iopt=2  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment drodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n\n  ! change record\n\n  implicit none\n  \n  integer :: iopt\n  real :: csedtaub,denbulk,bulkden\n\n  if( iopt == 1 )then\n    bulkden=0.001*denbulk  ! *** pmc changed to prevent\n    if( bulkden <= 1.013 )then\n      csedtaub=0.0\n    else\n      csedtaub=0.001*(9.808*bulkden-9.934)\n    endif\n  elseif( iopt == 2 )then\n    bulkden=0.001*denbulk  ! *** pmc changed to prevent\n    if( bulkden <= 1.013 )then\n      csedtaub=0.0\n    else\n      csedtaub=0.001*(9.808*bulkden-9.934)\n    endif\n  else\n    stop 'csedtaub: bad sediment critical stress option! stopping!'\n  endif\n  !\nend function\n"}, {"instruction": "Write a Fortran function named binarysearch to perform a binary search on a sorted array. The function accepts 3 input parameters of types integer, real*8 array, and real*8, and returns 1 output parameter of type integer. The input array must be sorted in ascending order.", "input": "", "output": "    function binarysearch(array, length, val)\n        implicit none\n        integer :: length\n        real*8, dimension(length) :: array\n        real*8 :: val\n\n        integer :: binarysearch, ind\n\n        integer :: left, middle, right\n\n\n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            endif\n            middle = nint((left+right) / 2.0)\n\n            if (left .eq. (right-1)) then\n                binarysearch = left\n                return\n            elseif (array(middle).le.val) then\n                left = middle\n            elseif (array(middle).gt.val) then\n                right = middle\n            end if\n        end do\n\n        binarysearch = left\n    end function binarysearch\n"}, {"instruction": "Write a Fortran function named trs2a2 that initializes a real array of size m x m to zero. The function should take 3 input arguments of type integer - j, k, and m - and the output should be a real array of size m x m.", "input": "", "output": "  function trs2a2 (j, k, m)\n    real, dimension (1:m,1:m) :: trs2a2\n    integer, intent (in)      :: j, k, m\n    nglobal = nglobal + 1\n    trs2a2 = 0.0\n  end function trs2a2\n"}, {"instruction": "Create a Fortran function named refraction to calculate the angle of refraction based on the Snell's Law. The function should take 3 input arguments with test_data type ['real', 'real', 'real'] representing the incident angle (theta1), the refractive index of the initial medium (n1), and the refractive index of the final medium (n2). The function should return one output argument with test_data type ['real'] representing the angle of refraction.", "input": "", "output": "function refraction(theta1, n1, n2) \r\n    implicit none \r\n    real :: theta1\r\n    real :: n1\r\n    real :: n2\r\n    real :: refraction \r\n    \r\n    refraction = asin(sin(theta1) * n1 / n2)\r\n    return \r\nend function \r\n"}, {"instruction": "Create a Fortran function called rad2deg to convert radians to degrees. The function takes 1 input parameter of type real and returns 1 output parameter of type real. Use the formula rad2deg = rad / pi * 180.0 to perform the conversion. Remember to include the necessary Fortran function and parameter declaration keywords.", "input": "", "output": "function rad2deg(rad)\r\n    implicit none\r\n\treal,parameter :: pi = 3.14159265358979\r\n\treal :: rad\r\n\treal :: rad2deg\r\n\r\n    rad2deg = rad / pi * 180.0\r\n    return\r\nend function\r\n"}, {"instruction": "Provide a Fortran function named f6 that takes an integer input argument and returns a character string. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(n)']. The function should be able to accept an integer argument and return a character string.", "input": "", "output": "function f6 (n)\n  integer :: n\n  character(n) :: f6, e6\nentry e6 (n)\n  e6 = \"hello1\"\nend function\n"}, {"instruction": "Create a Fortran function named nc_count to calculate the new count based on the given dimensions, start, and count. The function takes 3 input arguments of type integer arrays with optional dimensions and calculates the new count based on the given conditions. The output is an integer array of the same size as the input dimensions.", "input": "", "output": "\tfunction nc_count(dims, start, count) result(count_new)\n\t\tinteger, dimension(:), intent(in) :: dims\n\t\tinteger, dimension(:), intent(in), optional :: start\n\t\tinteger, dimension(:), intent(in), optional :: count\n\t\tinteger, dimension(size(dims)) :: count_new\n\n\t\tif (present(start) .and. present(count)) then\n\t\t\tcount_new = count\n\t\t\twhere (count == -1)\n\t\t\t\tcount_new = dims - start + 1\n\t\t\tend where\n\t\telse\n\t\t\tcount_new = dims\n\t\tend if\n\tend function\n"}, {"instruction": "Create a Fortran function named \"dlclose\" that takes one input parameter of type \"type(c_ptr), value\" and returns an output parameter of type \"integer(c_int)\". The function should be used to call the \"dlclose\" function from the C standard library using the \"iso_c_binding\" module.", "input": "", "output": "        function dlclose(handle) bind(c, name=\"dlclose\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: dlclose\n            type(c_ptr), value :: handle\n        end function\n"}, {"instruction": "Create a Fortran function named evaluate_couplings to check whether the input string \"couplings\" contains only the characters \"y\" and \"n\". The function should take 1 input argument of type character(len=13) and return 1 output argument of type logical.", "input": "", "output": "      function evaluate_couplings(couplings)    result(rez)\n!--------------------------------------------------------------------\n\n! input string \"couplings\" i.e. checks whether\n! it contains the \"y\" and \"n\" characters only \n! \n!--------------------------------------------------------------------\n!\n      character(len=13), intent(in) :: couplings\n      logical::rez\n      integer::i\n      rez=.true.\n      do i=1, nr_of_avialable_couplings, 1\n         if(couplings(i:i).ne.'y'.and.couplings(i:i).ne.'n') then\n            rez=.false.\n            exit\n         end if\n      end do\n      end function evaluate_couplings\n"}, {"instruction": "Create a Fortran function named find_nr_of_couplings to calculate the number of occurrences of the character 'y' in a given input string. The function takes 1 input parameter of type character(len=13) and returns 1 output parameter of type integer. The name of the function is find_nr_of_couplings.", "input": "", "output": "      function find_nr_of_couplings(couplings)    result(irez)\n!--------------------------------------------------------------------\n\n! requested couplings i.e. the number of\n! \"y\" characters in the input string \"couplings\" \n! \n!--------------------------------------------------------------------\n!\n      character(len=13), intent(in) :: couplings\n      integer::irez\n      integer::i\n      irez=0\n      do i=1, nr_of_avialable_couplings, 1\n         if(couplings(i:i).eq.'y') irez=irez+1\n      end do\n      end function find_nr_of_couplings\n"}, {"instruction": "Create a Fortran function called dimension_row that takes two integer input parameters and returns one integer output parameter. When the absolute value of the first input parameter m is zero, the output parameter nmax is set to the value of the second input parameter nrank. Otherwise, the output parameter nmax is calculated as nrank minus the absolute value of m plus 1.", "input": "", "output": "function dimension_row (m, nrank) result (nmax)\r\n  implicit none\r\n  integer :: m, nrank, nmax\r\n!\r\n  if (abs(m) == 0) then\r\n    nmax = nrank\r\n  else\r\n    nmax = nrank - abs(m) + 1\r\n  end if      \r\nend function dimension_row      \r\n"}, {"instruction": "Create a Fortran function named \"iloc\" to determine the position of a particular variable within an array based on its identification number. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The function uses the \"select case\" construct to assign the position based on the identification number provided.", "input": "", "output": "    pure function iloc(iarr, nparm, numgr)\n\n        implicit none\n\n        integer, intent(in) :: iarr\n        integer, intent(in) :: nparm\n        integer, intent(in) :: numgr\n        integer :: iloc\n\n        select case (iarr)\n        case (2)\n            ! 2  actdif(numgr)\n            iloc = 1\n        case (3)\n            ! 3  b(nparm+1)  (opposite v, y;  follows aa)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 13*nparm + 9\n        case (4)\n            ! 4  beta(nparm+1)  (opposite v, y;  follows b)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 14*nparm + 10\n        case (5)\n            ! 5  bndkp(nparm) (follows actdif)\n            iloc = numgr + 1\n        case (6)\n            ! 6  coef(numgr)\n            iloc = numgr + nparm + 1\n        case (7)\n            ! 7  cofbnd(nparm)\n            iloc = 2*numgr + nparm + 1\n        case (8)\n            ! 8  confun(numgr,nparm+1)  (opposite pmat1)\n            iloc = 2*numgr + 2*nparm + 1\n        case (9)\n            ! 9  d(nparm+1)  (opposite v, y;  follows beta)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 15*nparm + 11\n        case (10)\n            !  10  dvec(nparm) (follows confun)\n            iloc = numgr*nparm + 3*numgr + 2*nparm + 1\n        case (11)\n            !  11  err1(numgr+3)\n            iloc = numgr*nparm + 3*numgr + 3*nparm + 1\n        case (12)\n            !  12  funtbl(numgr,nparm+1)\n            iloc = numgr*nparm + 4*numgr + 3*nparm + 4\n        case (13)\n            !  13  iact(numgr)\n            iloc = 1\n        case (14)\n            !  14  iact1(numgr)\n            iloc = numgr + 1\n        case (15)\n            !  15  icor(nparm+1)\n            iloc = 2*numgr + 1\n        case (16)\n            !  16  icor1(nparm+1)  (does not appear in program by name)\n            iloc = 2*numgr + nparm + 2\n        case (17)\n            !  17  icntyp(numgr)\n            iloc = 2*numgr + 2*nparm + 3\n        case (18)\n            !  18  ixrct(numgr+2*nparm)\n            iloc = 3*numgr + 2*nparm + 3\n        case (19)\n            !  19  iycct(nparm+1) (opposite kpivot)\n            iloc = 4*numgr + 4*nparm + 3\n        case (20)\n            !  20  iyrct(numgr+2*nparm)\n            iloc = 4*numgr + 5*nparm + 4\n        case (21)\n            !  21  jcntyp(numgr)\n            iloc = 5*numgr + 7*nparm + 4\n        case (22)\n            !  22  kcntyp(numgr)\n            iloc = 6*numgr + 7*nparm + 4\n        case (23)\n            !  23  kpivot(nparm+1)  (opposite iycct)\n            iloc = 4*numgr + 4*nparm + 3\n        case (24)\n            !  24  param1(nparm) (follows funtbl)\n            iloc = 2*numgr*nparm + 5*numgr + 3*nparm + 4\n        case (25)\n            !  25  parprj(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 4*nparm + 4\n        case (26)\n            !  26  parser(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 5*nparm + 4\n        case (27)\n            !  27  parwrk(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 6*nparm + 4\n        case (28)\n            !  28  picor(nparm+1,nparm+1)  (opposite v, y;  follows d)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 16*nparm + 12\n        case (29)\n            !  29  pmat(nparm+1,numgr) (follows parwrk)\n            iloc = 2*numgr*nparm + 5*numgr + 7*nparm + 4\n        case (30)\n            !  30  pmat1(nparm+1,numgr)  (opposite confun)\n            iloc = 2*numgr + 2*nparm + 1\n        case (31)\n            !  31  ptnr(nparm+1) (follows pmat)\n            iloc = 3*numgr*nparm + 6*numgr + 7*nparm + 4\n        case (32)\n            !  32  ptnrr(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 8*nparm + 5\n        case (33)\n            !  33  r(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 9*nparm + 6\n        case (34)\n            !  34  save(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 10*nparm + 7\n        case (35)\n            !  35  v(numgr+2*nparm+1,nparm+2)  (with y, opposite aa, b, beta, d,\n            !    picor, zwork)\n            iloc = 3*numgr*nparm + 6*numgr + 11*nparm + 8\n        case (36)\n            !  36  vder(nparm) (follows y)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 18*nparm + 10\n        case (37)\n            !  37  vdern(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 19*nparm + 10\n        case (38)\n            !  38  vders(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 20*nparm + 10\n        case (39)\n            !  39  vec(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 21*nparm + 10\n        case (40)\n            !  40  wcoef(numgr)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 22*nparm + 11\n        case (41)\n            !  41  wcoef1(numgr)  (does not appear in the program by name)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 10*numgr + 22*nparm + 11\n        case (42)\n            !  42  wpt(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 22*nparm + 11\n        case (43)\n            !  43  wvec(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 23*nparm + 11\n        case (44)\n            !  44  x(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 24*nparm + 11\n        case (45)\n            !  45  xkeep(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 25*nparm + 12\n        case (46)\n            !  46  xrk(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 26*nparm + 13\n        case (47)\n            !  47  y(numgr+2*nparm)  (with v, opposite aa, b, beta, d, picor, zwork;  follows v)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 8*numgr + 16*nparm + 10\n        case (48)\n            !  48  zwork(nparm)  (opposite v, y;  follows picor)\n            iloc = 2*nparm**2 + 3*numgr*nparm + 6*numgr + 18*nparm + 13\n        case default\n            ! 1  aa(nparm+1,nparm+1)  (opposite v, y; starts at v starting point)\n            iloc = 3*numgr*nparm + 6*numgr + 11*nparm + 8\n        end select\n\n    end function iloc\n"}, {"instruction": "Create a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output test_data types are ['integer'].", "input": "", "output": "\t\tfunction fact(i)\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t!\n\n\t\t!\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\timplicit none\n\t\t\tinteger ::\ti, j, fact\n\t\n\t\t\tif (i == 0) then\n\t\t\t\tfact = 1\t\n\t\t\telseif (i .lt. 0) then\n\t\t\t\tprint*, \"argument to fact must be positive\"\n\t\t\t\tstop\n\t\t\telse\n\t\t\t\tfact = 1\n\t\t\t\tdo j = 1, i\n\t\t\t\t\tfact = fact * j\n\t\t\t\tenddo\n\t\t\tendif\n\t\t\t\n\t\tend function fact\n"}, {"instruction": "Write a Fortran function named prm3 that takes an integer p and an array of 3 integers as input. The number of input arguments is 2 and the test_data type is ['integer', 'integer,dimension(3)']. The number of output arguments is 1 and the test_data type is ['integer,dimension(3)']. This function uses the prm array to rearrange the elements of the input array based on the value of p and returns the rearranged array as the result.", "input": "", "output": " pure function prm3(p,a)\n  implicit none\n  integer,intent(in) :: p\n  integer,dimension(3),intent(in)  :: a\n  integer,dimension(3) :: prm3\n  integer,dimension(3,6),parameter :: prm = reshape( &\n      source=(/   1,2,3,  2,3,1,   3,1,2,  3,2,1,  1,3,2 , 2,1,3 /), &\n      shape=(/ 3 ,6 /) )\n  prm3(:)=a(prm(:,p))\n  return\n end function\n"}, {"instruction": "Create a Fortran function named bvmv to calculate the bilinear form <x, array y> for a banded matrix. The function takes 6 input parameters: n (integer), k (integer), type (character), array (real array), x (real array), and y (real array). The output parameter is bvmv (real). The input parameter types should be ['integer', 'integer', 'character(len=1)', 'real(kind=8), dimension(n, *)', 'real(kind=8), dimension(n)', 'real(kind=8), dimension(n)'], and the output parameter type should be ['real(kind=8)'].", "input": "", "output": "    function bvmv(n, k, array, type, x, y)\n!=====================================================================\n!\n!   returns bvmv = <x,array y> for the band array.\n!\n!   the original size of array is n*n. the bandwidth of array is 2k-1\n!   for the non-symmetric case, and is k for symmetric case.\n!   the lower-band column storage mode is assumed.\n!---------------------------------------------------------------------\n!\n!   on entry\n!   --------\n!       n      the leading dimension.\n!       k      the band width.\n!       array  a banded matrix in the lower-band column storage mode.\n!              its element (i,j) represents the element (i,i+j-k) of\n!              the original matrix. for a symmetric matrix, only the\n!              lower diagonals are needed.\n!       type   'g' for general;\n!              's' for symmetric;\n!              'a' for \"almost\"  symmetric, as db2\n!       x      vector with length n.\n!       y      vector with length n.\n!\n!----------------------------------------------------------------------\n\n       real(kind=8) :: bvmv\n       integer, intent(in) :: n, k\n       character(len=1), intent(in) :: type\n       real(kind=8), dimension(n, *), intent(in) :: array\n       real(kind=8), dimension(n), intent(in) :: x, y\n\n       ! .. local variables\n\n       integer :: i, j, jp, kp\n\n       bvmv = 0.d0\n\n       if (type /= 'g') then\n\n          ! .. symmetric\n\n          do jp = 1, k - 1\n             do i = k + 1 - jp, n\n                j = i + jp - k\n                bvmv = bvmv + array(i, jp)*(x(i)*y(j) + x(j)*y(i))\n             end do\n          end do\n\n          ! .. make correction for 'a' (almost symmetric)\n\n          if (type == 'a') &\n             bvmv = bvmv + x(n - 1)*y(n)*(array(1, 1) - array(n, k - 1))\n\n       else\n\n          do jp = 1, k - 1\n             do i = k - jp + 1, n\n                j = i + jp - k\n                kp = 2*k - j\n                bvmv = bvmv + array(i, jp)*x(i)*y(j)\n                bvmv = bvmv + array(j, kp)*x(j)*y(i)\n             end do\n          end do\n\n       end if\n\n       ! .. add central diagonal\n\n       bvmv = bvmv + sum(array(:, k)*x(:)*y(:))\n\n    end function bvmv\n"}, {"instruction": "Create a Fortran function named f90add to calculate the sum of two integer numbers. The function should have 2 input parameters of type integer and 1 output parameter of type integer.", "input": "", "output": "function f90add(a, b) result(ret)\n  implicit none\n  integer :: a\n  integer :: b\n  integer :: ret\n  ret = a + b\nend function f90add\n"}, {"instruction": "Create a Fortran function named obstype that takes a single input parameter of type character (len= 80) and returns a single output parameter of the same type. The function reads a line of text and extracts the string that follows the keyword 'bogus'.", "input": "", "output": "function obstype (line) result (f_obstype)\n!------------------------------------------------------------------------------!\n\n  ! read in a line the string present after keyword 'bogus'\n\n!------------------------------------------------------------------------------!\n  implicit none\n  character (len= 80), intent(in) :: line\n\n  character (len= 80) :: f_obstype\n  integer :: b,c\n!------------------------------------------------------------------------------!\n\n!  find keyword bogus\n\n  do c = 1, len_trim (line) - 5\n     if (line (c:c+4) == 'bogus') exit\n  enddo\n\n  c = c + 5\n\n!  skip blank until next word\n\n  do b = c, len_trim (line)\n     if (line (b:b) /= ' ') exit\n  enddo\n\n!  string follows\n\n  f_obstype = trim (line (b:len_trim (line)))\n\nend function obstype\n"}, {"instruction": "Create a Fortran function named sensor, which takes a single input parameter of type character (len=80). The function should extract the first non-blank, non-point, non-number character and the subsequent characters until the next space from the input string, and return the extracted string as the output.", "input": "", "output": "function sensor (line) result (f_sensor)\n\n  ! read first in a string after numbers\n\n!------------------------------------------------------------------------------!\n  implicit none\n  character (len= 80), intent(in) :: line\n\n  character (len= 80) :: f_sensor\n  integer :: b,c\n!------------------------------------------------------------------------------!\n\n!  find the first non-blank, non point and non-number character\n\n  do c = 1, len_trim (line)\n     if (((iachar (line(c:c)) /= 32)  .and. &\n          (iachar (line(c:c)) /= 46)) .and. &\n          ((iachar (line(c:c)) .lt. 48)  .or.  &   \n          (iachar (line(c:c)) .gt. 57)))      &\n          exit\n  enddo\n\n  do b = c, len_trim (line)\n     if (line (b:b) == ' ') exit\n  enddo\n\n  f_sensor = line (c:b-1)\n\nend function sensor\n"}, {"instruction": "Create a Fortran function named sum_of_proper_divisors to calculate the sum of proper divisors of an integer input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function sum_of_proper_divisors(val) result(ret)\n        integer, intent(in) :: val\n        integer :: ret, i\n\n        ret = 1\n        do i = 2, int(sqrt(real(val)))\n            if (mod(val, i) == 0) then\n                if (val/i == i) then\n                    ret = ret + i\n                else\n                    ret = ret + i + val/i\n                end if\n            end if\n        end do\n    end function sum_of_proper_divisors\n"}, {"instruction": "Create a Fortran function named normalt that takes a double precision input argument and returns a double precision result. The function computes a mathematical expression involving the input argument and assigns the result to the output parameter. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function normalt(q) result(result)\n\n    double precision, intent(in) :: q\n    double precision :: q2, tmp, sum\n    double precision :: result\n\n    q2 = q*q\n    tmp = q\n    sum = 1.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum - 1.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum + 3.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum - 15.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum + 105.0d0 / tmp\n    result = log(sum) - q2/2.0d0 - log2piover2\n  end function normalt\n"}, {"instruction": "Create a Fortran function named fun_calc_cl that takes a single real input argument. This function computes the chlorinity using the formula from Zeebe and Wolf-Gladrow (2001) and returns the result as a real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "  function fun_calc_cl(dum_s)\n    ! result variable\n    real::fun_calc_cl\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! chlorinity [zeebe and wolf-gladrow, 2001]\n    fun_calc_cl = dum_s/1.80655\n    if (fun_calc_cl < const_real_nullsmall) fun_calc_cl = const_real_nullsmall\n  end function fun_calc_cl\n"}, {"instruction": "Create a Fortran function named fun_calc_i to compute the ionic strength according to Millero [1982]. The function takes 1 input argument of type real and returns 1 output argument of type real. If the input argument is greater than a small constant, the function calculates the ionic strength using a specific formula; otherwise, it returns the small constant.", "input": "", "output": "  function fun_calc_i(dum_s)\n    ! result variable\n    real::fun_calc_i\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! the ionic strength calculated after millero [1982]\n    if (dum_s > const_real_nullsmall) then\n       fun_calc_i = 19.924*dum_s/(1000.0 - 1.005*dum_s)\n    else\n       fun_calc_i = const_real_nullsmall\n    end if\n  end function fun_calc_i\n"}, {"instruction": "Create a Fortran function named fun_calc_ca to calculate the total concentration of ca++ based on the input concentration. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  function fun_calc_ca(dum_s)\n    ! result variable\n    real::fun_calc_ca\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! total ca++ concentration estimated after millero [1982]\n    fun_calc_ca = 0.01028*dum_s/35.0\n    if (fun_calc_ca < const_real_nullsmall) fun_calc_ca = const_real_nullsmall\n  end function fun_calc_ca\n"}, {"instruction": "Create a Fortran function named fun_calc_btot to calculate the total concentration of boric acid in seawater based on the input value of seawater salinity. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone.", "input": "", "output": "  function fun_calc_btot(dum_s)\n    ! result variable\n    real::fun_calc_btot\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! total boroic acid in seawater estimated after uppstrom [1974]\n    ! note: this is to provide consistence with the 'co2sys' model of lewis and wallace\n    ! note: the alternative formulation is; btot = 0.000426*dum_s/35.0 [millero, 1982, 1995]\n    fun_calc_btot = 0.000416*dum_s/35.0\n    if (fun_calc_btot < const_real_nullsmall) fun_calc_btot = const_real_nullsmall\n  end function fun_calc_btot\n"}, {"instruction": "Write a Fortran function named fun_calc_lnkb to calculate the apparent ionization constant of boric acid. The function takes 7 input arguments of type real: dum_t, dum_rt, dum_t_ln, dum_s, dum_s_p05, dum_s_p15, dum_s_p20. It returns a single output of type real.", "input": "", "output": "  function fun_calc_lnkb(dum_t,dum_rt,dum_t_ln,dum_s,dum_s_p05,dum_s_p15,dum_s_p20)\n    ! result variable\n    real::fun_calc_lnkb\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_ln,dum_s,dum_s_p05,dum_s_p15,dum_s_p20\n    ! apparent ionization constant of boric acid [dickson, 1990]\n    ! note: total ph scale; [mol (kg-h20)-1]\n    fun_calc_lnkb = 148.0248 + 137.194*dum_s_p05 + 1.62247*dum_s &\n         & + (-8966.90 - 2890.51*dum_s_p05 - 77.942*dum_s + 1.726*dum_s_p15 - 0.0993*dum_s_p20)*dum_rt &\n         & + (-24.4344 - 25.085*dum_s_p05 - 0.2474*dum_s)*dum_t_ln &\n         & + 0.053105*dum_s_p05*dum_t\n  end function fun_calc_lnkb\n"}, {"instruction": "Create a Fortran function named fun_calc_lnksi that takes 4 real input parameters and returns a real output. The input parameters are dum_rt, dum_t_ln, dum_i, and dum_i_p05. The function calculates the dissociation constant of SiO2 using the Yao and Millero (1995) equation. The output is the calculated value of the dissociation constant.", "input": "", "output": "  function fun_calc_lnksi(dum_rt,dum_t_ln,dum_i,dum_i_p05)\n    ! result variable\n    real::fun_calc_lnksi\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_i,dum_i_p05\n    ! calculation of the dissociation constant of sio2 [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnksi = 117.40 - 8904.2*dum_rt - 19.334*dum_t_ln &\n         & + (3.5913 - 458.79*dum_rt)*dum_i_p05 + (-1.5998 + 188.74*dum_rt)*dum_i + (0.07871 - 12.1652*dum_rt)*dum_i*dum_i\n  end function fun_calc_lnksi\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkhf to calculate the dissociation constant of hydrogen fluoride. The function takes 2 input arguments of type real, and returns 1 output argument of type real. The input arguments are dummy variables representing temperature (dum_t) and ionic strength (dum_ion_p05). The function uses the Dickson and Riley (1979) equation to perform the calculation. Use the given formula to calculate the dissociation constant of HF and return the result.", "input": "", "output": "  function fun_calc_lnkhf(dum_t,dum_ion_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhf\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_ion_p05\n    ! calculation of the dissociation constant of hf [dickson and riley, 1979]\n    ! note: free ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkhf = 1590.2/dum_t - 12.641 + 1.525*dum_ion_p05\n  end function fun_calc_lnkhf\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp1 to compute the 1st dissociation constant of phosphoric acid in seawater. It takes 4 input arguments of type real: dum_t, dum_t_ln, dum_s, dum_s_p05. The output is a real value representing the calculated 1st dissociation constant.", "input": "", "output": "  function fun_calc_lnkp1(dum_t,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp1\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the 1st dissociation constant of phosphoric acid in seawater  [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp1 = 115.54 - 4576.752/dum_t - 18.453*dum_t_ln &\n         + (0.69171 - 106.736/dum_t)*dum_s_p05 + (-0.01844 - 0.65643/dum_t)*dum_s\n  end function fun_calc_lnkp1\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp2 that calculates the second dissociation constant of phosphoric acid in seawater. The function takes 4 input arguments of type real: dum_t, dum_t_ln, dum_s, and dum_s_p05. It returns a single real value as the result.", "input": "", "output": "  function fun_calc_lnkp2(dum_t,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp2\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the 2nd dissociation constant of phosphoric acid in seawater [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp2 = 172.1033 - 8814.715/dum_t - 27.927*dum_t_ln &\n         + (1.3566 - 160.340/dum_t)*dum_s_p05 + (-0.05778 + 0.37335/dum_t)*dum_s\n  end function fun_calc_lnkp2\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp3 that calculates the 3rd dissociation constant of phosphoric acid in seawater according to the Yao and Millero (1995) equation. The function has 3 input parameters of type real: dum_t, dum_s, and dum_s_p05. It returns a single real output value.", "input": "", "output": "  function fun_calc_lnkp3(dum_t,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp3\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_s,dum_s_p05\n    ! calculation of the 3rd dissociation constant of phosphoric acid in seawater [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp3 = -18.126 - 3070.75/dum_t + &\n         (2.81197 + 17.27039/dum_t)*dum_s_p05 + (-0.09984 - 44.99486/dum_t)*dum_s\n  end function fun_calc_lnkp3\n"}, {"instruction": "Write a Fortran function named fun_calc_lnkhso4 to calculate the dissociation constant of hso4 according to the Dickson 1990 formula. The function takes 6 input parameters of type real: dum_rt, dum_t_ln, dum_i_p05, dum_i, dum_i_p15, and dum_i_p20. It returns a real value.", "input": "", "output": "  function fun_calc_lnkhso4(dum_rt,dum_t_ln,dum_i_p05,dum_i,dum_i_p15,dum_i_p20)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhso4\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_i_p05,dum_i,dum_i_p15,dum_i_p20\n    ! calculation of the dissociation constant of hso4 [dickson, 1990]\n    ! note: free ph scale; [mol (kg-h2o)-1]\n    fun_calc_lnkhso4 = 141.328 - 4276.1*dum_rt - 23.093*dum_t_ln &\n         & + (324.57 - 13856.0*dum_rt - 47.986*dum_t_ln)*dum_i_p05 &\n         & + (-771.54 + 35474.0*dum_rt + 114.723*dum_t_ln)*dum_i &\n         & -2698.0*dum_rt*dum_i_p15 + 1776.0*dum_rt*dum_i_p20\n  end function fun_calc_lnkhso4\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkhso4_khoo to calculate the dissociation constant of hso4 based on the Khoo et al. 1977 formula. The function should have 2 input parameters of type real, and the output should be a real value. The function should follow the free pH scale and return the result in units of [mol (kg-sol)^-1].", "input": "", "output": "  function fun_calc_lnkhso4_khoo(dum_t,dum_i_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhso4_khoo\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_i_p05\n    ! calculation of the dissociation constant of hso4 [khoo et al. 1977]\n    ! note: free ph scale; [mol (kg-sol)-1] (???)\n    fun_calc_lnkhso4_khoo = log(10**(647.59/dum_t - 6.3451 + 0.019085*dum_t - 0.5208*dum_i_p05))\n  end function fun_calc_lnkhso4_khoo\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkh2s to calculate the dissociation constant of hs using the equation: 225.838 - 13275.3*dum_rt - 34.6435*dum_t_ln + 0.3449*dum_s_p05 - 0.0274*dum_s. The function takes 4 input arguments of type real: dum_rt, dum_t_ln, dum_s, and dum_s_p05. It returns 1 output argument of type real.", "input": "", "output": "  function fun_calc_lnkh2s(dum_rt,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkh2s\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the dissociation constant of hs [millero et al., 1988]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkh2s = 225.838 - 13275.3*dum_rt - 34.6435*dum_t_ln + 0.3449*dum_s_p05 - 0.0274*dum_s\n  end function fun_calc_lnkh2s\n"}, {"instruction": "Create a Fortran function named fun_calc_lnknh4 to calculate the dissociation constant of NH4 based on the Yao and Millero (1995) formula. The function takes 4 input arguments of type real: dum_t, dum_rt, dum_s, and dum_s_p05. It returns a single real value as the result.", "input": "", "output": "  function fun_calc_lnknh4(dum_t,dum_rt,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnknh4\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_s,dum_s_p05\n    ! calculation of the dissociation constant of nh4 [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnknh4 = -6285.33*dum_rt + 0.0001635*dum_t - 0.25444 + &\n         & (0.46532 - 123.7184*dum_rt)*dum_s_p05 + (-0.01992 + 3.17556*dum_rt)*dum_s\n  end function fun_calc_lnknh4\n"}, {"instruction": "Create a Fortran function named fun_calc_lnk1_roy that takes 5 real input parameters [dum_rt, dum_t_ln, dum_s_p05, dum_s, dum_s_p15] and returns a real output parameter. The function computes the first carbonic acid apparent ionization constant based on the provided formula. Use the intent(in) attribute to specify that the input parameters are read-only.", "input": "", "output": "  function fun_calc_lnk1_roy(dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15)\n    ! result variable\n    real::fun_calc_lnk1_roy\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15\n    ! first carbonic acid apparent ionization constant [roy et al., 1993]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnk1_roy = 2.83655 - 2307.1266*dum_rt - 1.5529413*dum_t_ln &\n         & + (-0.20760841 - 4.0484*dum_rt)*dum_s_p05 + 0.08468345*dum_s - 0.00654208*dum_s_p15\n  end function fun_calc_lnk1_roy\n"}, {"instruction": "Create a Fortran function named fun_calc_lnk2_roy that calculates the second carbonic acid apparent ionization constant according to the Roy et al. (1993) formula. The function should take 5 input arguments of type real: dum_rt, dum_t_ln, dum_s_p05, dum_s, dum_s_p15. It should return 1 output of type real.", "input": "", "output": "  function fun_calc_lnk2_roy(dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15)\n    ! result variable\n    real::fun_calc_lnk2_roy\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15\n    ! second carbonic acid apparent ionization constant [roy et al., 1993]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnk2_roy = -9.226508 - 3351.6106*dum_rt - 0.2005743*dum_t_ln &\n         & + (-0.106901773 - 23.9722*dum_rt)*dum_s_p05 + 0.1130822*dum_s - 0.00846934*dum_s_p15\n  end function fun_calc_lnk2_roy\n"}, {"instruction": "Create a Fortran function named fun_calc_lnq_co2 to calculate the natural logarithm of the equilibrium constant for the dissolution of CO2 in water. The function takes 3 input arguments of type real: dum_tr100, dum_rt, and dum_s. It returns a single output of type real.", "input": "", "output": "  function fun_calc_lnq_co2(dum_tr100,dum_rt,dum_s)\n    ! result variable\n    real::fun_calc_lnq_co2\n    ! dummy arguments\n    real,intent(in)::dum_tr100,dum_rt,dum_s\n    ! henry's law constant for co2 with concentrations as moles per kg of solution [weiss, 1974].\n    ! the dependence of the solubility coefficient on hydrostatic pressure is ignored.\n    fun_calc_lnq_co2 = -60.2409 + 93.4517*(100*dum_rt) + 23.3585*log(dum_tr100) &\n         & +dum_s*(0.023517 - 0.023656*(dum_tr100) + 0.0047036*(dum_tr100)**2)\n  end function fun_calc_lnq_co2\n"}, {"instruction": "Write a Fortran function named fun_calc_lnq_o2 that calculates the Henry's law constant for oxygen. The function takes 3 input arguments of type real: dum_tr100, dum_rt, and dum_s. It returns a single real value as the output.", "input": "", "output": "  function fun_calc_lnq_o2(dum_tr100,dum_rt,dum_s)\n    ! result variable\n    real::fun_calc_lnq_o2\n    ! dummy arguments\n    real,intent(in)::dum_tr100,dum_rt,dum_s\n    ! henry's law constant for o2 with concentrations as moles per kg of solution.\n    ! adapted from a formula from millero and sohn [1992] giving o2 solubility in units of umol kg-1,\n    ! back to a henry's law constant for o2 in units of mol kg-1 atm-1.\n    ! the dependence of the solubility coefficient on hydrostatic pressure is ignored.\n    fun_calc_lnq_o2 = -173.9894 + 255.5907*(100.0*dum_rt) + 146.4813*log(dum_tr100) - 22.2040*(dum_tr100) &\n         & + dum_s*(-0.037362 + 0.016504*(dum_tr100) - 0.0020564*(dum_tr100)**2) &\n         & - log(1.0e6) - log(0.20946)\n  end function fun_calc_lnq_o2\n"}, {"instruction": "Create a Fortran function named fun_calc_logkcal to calculate the solubility constant of calcite. This function takes 6 input arguments of real type: dum_t, dum_rt, dum_t_log, dum_s, dum_s_p05, and dum_s_p15. The output of the function is a real number. Use the following formula to compute the result: \n\nfun_calc_logkcal = -171.9065 - 0.077993*dum_t + 2839.319*dum_rt + 71.595*dum_t_log + (-0.77712 + 0.0028426*dum_t + 178.34*dum_rt)*dum_s_p05 - 0.07711*dum_s + 0.0041249*dum_s_p15", "input": "", "output": "  function fun_calc_logkcal(dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15)\n    ! result variable\n    real::fun_calc_logkcal\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15\n    ! calculation of the solubility constant of calcite.\n\n    fun_calc_logkcal = -171.9065 - 0.077993*dum_t + 2839.319*dum_rt + 71.595*dum_t_log &\n         & + (-0.77712 + 0.0028426*dum_t + 178.34*dum_rt)*dum_s_p05 - 0.07711*dum_s + 0.0041249*dum_s_p15\n  end function fun_calc_logkcal\n"}, {"instruction": "Write a Fortran function named fun_calc_logkarg that calculates the solubility constant of aragonite. The function takes 6 input arguments of type real: dum_t, dum_rt, dum_t_log, dum_s, dum_s_p05, and dum_s_p15. The output is a single real value representing the calculated solubility constant.", "input": "", "output": "  function fun_calc_logkarg(dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15)\n    ! result variable\n    real::fun_calc_logkarg\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15\n    ! calculation of the solubility constant of aragonite.\n    fun_calc_logkarg = -171.945 - 0.077993*dum_t + 2903.293*dum_rt + 71.595*dum_t_log &\n         & + (-0.068393 + 0.0017276*dum_t + 88.135*dum_rt)*dum_s_p05 - 0.10018*dum_s + 0.0059415*dum_s_p15\n  end function fun_calc_logkarg\n"}, {"instruction": "Create a Fortran function named fun_corg_rfrac to calculate carbon isotope fractionation. The function takes 5 input parameters of type real and logical, and returns 1 output parameter of type real. The function computes the carbon isotope fractionation between dissolved inorganic carbon and particulate organic carbon. Use the imperative tone to define the function.", "input": "", "output": "  function fun_corg_rfrac(dum_t,dum_conc_co2,dum_co2_r13c,dum_corg_ef,dum_14c)\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real::fun_corg_rfrac\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    real::dum_t\n    real::dum_conc_co2\n    real::dum_co2_r13c\n    real::dum_corg_ef\n    logical::dum_14c\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    real::loc_kq\n    real::loc_delta_corg\n    real::loc_alpha\n    real::loc_r\n    ! -------------------------------------------------------- !\n    ! calculate carbon isotope fractionation between dic and poc\n    ! -------------------------------------------------------- !\n    ! note: double fractionation for 14c\n    loc_kq = const_d13c_dic_corg_q2_c + const_d13c_dic_corg_q2_x*dum_t + const_d13c_dic_corg_q2_x2*dum_t**2\n    loc_delta_corg = -dum_corg_ef + (dum_corg_ef - const_d13c_dic_corg_ed)*loc_kq/dum_conc_co2\n    if (dum_14c) loc_delta_corg = 2.0*loc_delta_corg\n    loc_alpha = 1.0 + loc_delta_corg/1000.0\n    loc_r = dum_co2_r13c/(1.0 - dum_co2_r13c)\n\n    fun_corg_rfrac = loc_alpha*loc_r/(1.0 + loc_alpha*loc_r)\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_corg_rfrac\n"}, {"instruction": "Create a Fortran function named boundary_npiece to determine the number of pieces in the boundary definition. The function takes 1 input argument of type integer. The output consists of 1 integer indicating the number of pieces. If boundary_npiece is less than or equal to 0, the domain is defined by triangle data files.", "input": "", "output": "function boundary_npiece(hole)\n!        ---------------\n\n!----------------------------------------------------\n! this routine gives the number of pieces in the boundary definition.\n! if boundary_npiece <= 0 the domain is given by triangle data files.\n!----------------------------------------------------\n\n!----------------------------------------------------\n\nimplicit none\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(in) :: hole\ninteger :: boundary_npiece\n!----------------------------------------------------\n! begin executable code\n\nboundary_npiece = 0\n\nend function boundary_npiece\n"}, {"instruction": "Write a Fortran function named fib_seq to generate the nth number in the Fibonacci sequence. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter test_data type is ['integer'], and the output parameter test_data type is ['integer'].", "input": "", "output": "    function fib_seq(n)\n        integer :: fib_seq\n        integer, intent(in) :: n\n        integer :: j, f_pp, f_p, f\n\n        f_pp = 0\n        f_p  = 1\n        do j = 2, n\n            f    = f_p + f_pp\n            f_pp = f_p\n            f_p  = f\n        end do\n        fib_seq = f\n        return\n    end function fib_seq\n"}, {"instruction": "Create a Fortran function named legendobs to return a specific description for a given integer input. The function takes 2 input parameters of type integer and integer array, and returns 1 output parameter of type character with a length of 52 characters.", "input": "", "output": " function legendobs(iarg,printcodsub)\n \n!***********************************************************************\n!     \n\n!     the integer contained in the printcod array\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: printcodsub\n  \n  character(len=52) :: legendobs\n  \n  legendobs=repeat(' ',52)\n  if(printcodsub(iarg)==1)then\n    legendobs='dens1 =  mean fluid density of first component    '\n  elseif(printcodsub(iarg)==2)then\n    legendobs='dens2 =  mean fluid density of second component   '\n  elseif(printcodsub(iarg)==3)then\n    legendobs='maxd1 =  max fluid density of first component     '\n  elseif(printcodsub(iarg)==4)then\n    legendobs='maxd2 =  max fluid density of second component    '\n  elseif(printcodsub(iarg)==5)then\n    legendobs='mind1 =  min fluid density of first component     '\n  elseif(printcodsub(iarg)==6)then\n    legendobs='mind2 =  min fluid density of second component    '\n  elseif(printcodsub(iarg)==7)then\n    legendobs='maxvx =  max fluid velocity of fluid mix along x  '\n  elseif(printcodsub(iarg)==8)then\n    legendobs='minvx =  min fluid velocity of fluid mix along x  '\n  elseif(printcodsub(iarg)==9)then\n    legendobs='maxvy =  max fluid velocity of fluid mix along y  '\n  elseif(printcodsub(iarg)==10)then\n    legendobs='minvy =  min fluid velocity of fluid mix along y  '\n  elseif(printcodsub(iarg)==11)then\n    legendobs='maxvz =  max fluid velocity of fluid mix along z  '\n  elseif(printcodsub(iarg)==12)then\n    legendobs='minvz =  min fluid velocity of fluid mix along z  '\n  elseif(printcodsub(iarg)==13)then\n    legendobs='cpur  =  remaining time to the end                '\n  elseif(printcodsub(iarg)==14)then\n    legendobs='cpue  =  elapsed time                             '\n  elseif(printcodsub(iarg)==15)then\n    legendobs='cpu   =  time for every print interval            '\n  elseif(printcodsub(iarg)==16)then\n    legendobs='t     =  unscaled time                            '\n  elseif(printcodsub(iarg)==17)then\n    legendobs='engke =  particle kinetic energy                  '\n  elseif(printcodsub(iarg)==18)then\n    legendobs='engcf =  configurational energy                   '\n  elseif(printcodsub(iarg)==19)then\n    legendobs='engto =  total energy                             '\n  elseif(printcodsub(iarg)==20)then\n    legendobs='tempp =  particle temperature                     '\n  elseif(printcodsub(iarg)==21)then\n    legendobs='maxpv =  max particle velocity                    '\n  elseif(printcodsub(iarg)==22)then\n    legendobs='pvx   =  mean particle velocity along x           '\n  elseif(printcodsub(iarg)==23)then\n    legendobs='pvy   =  mean particle velocity along y           '\n  elseif(printcodsub(iarg)==24)then\n    legendobs='pvz   =  mean particle velocity along z           '\n  elseif(printcodsub(iarg)==25)then\n    legendobs='fvx   =  mean fluid velocity along x              '\n  elseif(printcodsub(iarg)==26)then\n    legendobs='fvy   =  mean fluid velocity along y              '\n  elseif(printcodsub(iarg)==27)then\n    legendobs='fvz   =  mean fluid velocity along z              '\n  elseif(printcodsub(iarg)==28)then\n    legendobs='pfx   =  mean particle force along x              '\n  elseif(printcodsub(iarg)==29)then\n    legendobs='pfy   =  mean particle force along y              '\n  elseif(printcodsub(iarg)==30)then\n    legendobs='pfz   =  mean particle force along z              '\n  elseif(printcodsub(iarg)==31)then\n    legendobs='engrt =  rotational energy                        '\n  elseif(printcodsub(iarg)==32)then\n    legendobs='engkf =  fluid kinetic energy                     '\n  elseif(printcodsub(iarg)==33)then\n    legendobs='intph =  fluid interphase volume fraction         '\n  elseif(printcodsub(iarg)==34)then\n    legendobs='rminp =  min pair distance between particles      '\n  elseif(printcodsub(iarg)==35)then\n    legendobs='pvm   =  mean particle velocity module            '\n  elseif(printcodsub(iarg)==36)then\n    legendobs='pfm   =  mean particle force module               '\n  endif\n  legendobs=adjustl(legendobs)\n  \n  return\n  \n end function legendobs\n"}, {"instruction": "Create a Fortran function named legendobs_vtk that takes two input parameters: an integer iarg and an allocatable array of integers printcodsub. The output is a character string of length 52. The function should return a description corresponding to the integer value in the printcodsub array for vtk files. The function should be described using imperative tone.", "input": "", "output": " function legendobs_vtk(iarg,printcodsub)\n \n!***********************************************************************\n!     \n\n!      tothe integer contained in the printcod array for vtk files\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification october 2019\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: printcodsub\n  \n  character(len=52) :: legendobs_vtk\n  \n  legendobs_vtk=repeat(' ',52)\n  if(printcodsub(iarg)==1)then\n    legendobs_vtk='rho1  =  fluid density of first component         '\n  elseif(printcodsub(iarg)==2)then\n    legendobs_vtk='rho2  =  fluid density of second component        '\n  elseif(printcodsub(iarg)==3)then\n    legendobs_vtk='phase =  phase field of the two fluid components  '\n  elseif(printcodsub(iarg)==4)then\n    legendobs_vtk='vel   =  vector velocity field of the fluid       '\n  elseif(printcodsub(iarg)==5)then\n    legendobs_vtk='part  =  particle positions and orientations      '\n  endif\n  legendobs_vtk=adjustl(legendobs_vtk)\n  \n  return\n  \n end function legendobs_vtk\n"}, {"instruction": "Create a Fortran function named legendobs_xyz to return a specific string description based on the integer input iarg and the integer array xyzcod. The number of input parameters is 2, with test_data type ['integer', 'integer, allocatable, dimension(:)'], and the number of output parameters is 1 with test_data type ['character(len=52)'].", "input": "", "output": " function legendobs_xyz(iarg,xyzcod)\n \n!***********************************************************************\n!     \n\n!     the integer contained in the xyzcod array\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: xyzcod\n  \n  character(len=52) :: legendobs_xyz\n  \n  legendobs_xyz=repeat(' ',52)\n!  if(xyzcod(iarg)==1)then\n!    legendobs_xyz='char =  charge of the particle                    '\n!  else\n  if(xyzcod(iarg)==2)then\n    legendobs_xyz='mass =  mass of the particle                      '\n  elseif(xyzcod(iarg)==3)then\n    legendobs_xyz='radx =  radius of the particle along x            '\n  elseif(xyzcod(iarg)==4)then\n    legendobs_xyz='rady =  radius of the particle along y            '\n  elseif(xyzcod(iarg)==5)then\n    legendobs_xyz='radz =  radius of the particle along z            '\n  elseif(xyzcod(iarg)==6)then\n    legendobs_xyz='rad  =  radius of the spherical particle          '\n  elseif(xyzcod(iarg)==7)then\n    legendobs_xyz='vx   =  particle velocity along x                 '\n  elseif(xyzcod(iarg)==8)then\n    legendobs_xyz='vy   =  particle velocity along y                 '\n  elseif(xyzcod(iarg)==9)then\n    legendobs_xyz='vz   =  particle velocity along z                 '\n  elseif(xyzcod(iarg)==10)then\n    legendobs_xyz='ox   =  particle angular velocity along x         '\n  elseif(xyzcod(iarg)==11)then\n    legendobs_xyz='oy   =  particle angular velocity along y         '\n  elseif(xyzcod(iarg)==12)then\n    legendobs_xyz='oz   =  particle angular velocity along z         '\n  elseif(xyzcod(iarg)==13)then\n    legendobs_xyz='phi  =  first euler angle [\u2212pi,pi]                '\n  elseif(xyzcod(iarg)==14)then\n    legendobs_xyz='theta=  second euler angle [\u2212pi/2,pi/2]           '\n  elseif(xyzcod(iarg)==15)then\n    legendobs_xyz='psi  =  third euler angle [\u2212pi,pi]                '\n  endif\n  legendobs_xyz=adjustl(legendobs_xyz)\n  \n  return\n  \n end function legendobs_xyz\n"}, {"instruction": "Write a Fortran function named ampere_poisson_deriv to calculate the derivatives of the given input parameters. The function takes 8 input parameters of type real and dimension(3) and 7 input parameters of type real. It returns 1 output parameter of type real and dimension(3).", "input": "", "output": "  function ampere_poisson_deriv(u, vdi, ti0, tib, vde, te0, teb, nb) result(dudx)\n    ! az = u[1]; by = u[2]; pot = u[3]\n    implicit none\n    ! output\n    real, dimension(3) :: dudx\n    ! input\n    real, dimension(3), intent(in) :: u\n    real, intent(in) :: vdi, ti0, tib, vde, te0, teb, nb\n\n    ! local data\n    real :: exp_i0, exp_e0, exp_ib, exp_eb\n\n    exp_i0 = exp((-u(3) + vdi * u(1)) / ti0)\n    exp_e0 = exp((u(3) - vde * u(1)) / te0)\n    exp_ib = exp(-u(3) / tib)\n    exp_eb = exp(u(3) / teb)\n\n    ! d/dx (az)\n    dudx(1) = -u(2)\n    ! d/dx (by)\n    dudx(2) = vdi * exp_i0 - vde * exp_e0\n    ! d/dx (pot)\n    dudx(3) = -u(2) * (vdi / ti0 * exp_i0 + vde / te0 * exp_e0) &\n      &/ (exp_i0 / ti0 + nb * exp_ib / tib + exp_e0 / te0 + nb * exp_eb / teb)\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named charge_density to calculate the total charge density in Lembege-Pellat current sheet. The function takes 9 input arguments of type real (pot, az, vdi, ti0, tib, vde, te0, teb, nb) and returns 1 output argument of type real.", "input": "", "output": "  function charge_density(pot, az, vdi, ti0, tib, vde, te0, teb, nb) result(rho)\n    ! total charge density in lembege-pellat current sheet\n    implicit none\n    ! output\n    real :: rho\n    ! input\n    real, intent(in) :: pot, az, vdi, ti0, tib, vde, te0, teb, nb\n\n    rho = exp((-pot + vdi * az) / ti0) + nb * exp(-pot / tib)&\n      & - exp((pot - vde * az) / te0) - nb * exp(pot / teb)\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named linspace that generates a set of linearly spaced numbers between a start and end value. The function should have 3 input parameters of real, real, and integer types, representing the start, end, and the number of samples respectively. The single output parameter should be an array of real numbers with a dimension defined by the number of samples.", "input": "", "output": "  function linspace(start, end, num) result(samples)\n    implicit none\n    ! input\n    real, intent(in) :: start, end\n    integer, intent(in) :: num\n    ! output\n    real, dimension(num) :: samples\n    ! local data\n    real :: step\n    integer :: j\n\n    step = (end - start) / real(num - 1)\n\n    samples = (/ (start + (j - 1) * step, j = 1, num) /)\n  end function\n"}, {"instruction": "Create a Fortran function named besself2 that calculates the value of a special function. The function should accept 4 input parameters of type integer: np, lp, n, and l. It should return a single output parameter of type real(kind=8).", "input": "", "output": "    function besself2(np,lp,n,l)\n      implicit none\n      integer, intent(in) :: np,lp,n,l\n      real(kind=8) :: besself2\n\n      besself2 = sqrt(gamma(np+lp+0.5d0) * gamma(n+l+0.5d0))\n\n    end function besself2\n"}, {"instruction": "Write a Fortran function named gammas_regular to calculate the regular part of a particular gamma factor. The function takes 5 input parameters of type integer (m, mp, l, lp, bigl) and returns 1 output parameter of type real(kind=8).", "input": "", "output": "    function gammas_regular(m,mp,l,lp,bigl)\n        implicit none\n        integer, intent(in) :: m, mp, l, lp,bigl\n        real(kind=8) :: gammas_regular\n\n        gammas_regular = gamma((l+lp+bigl+2*m+2*mp+3.d0)/2.d0) &\n            / gamma(l+m+3.d0/2.d0) / gamma(lp+mp+3.d0/2.d0)\n\n    end function gammas_regular\n"}, {"instruction": "Write a Fortran function named gammas_plusminus to compute the ratio of three gamma functions. The function takes 5 input parameters of type integer: m, mp, l, lp, and bigl. It returns 1 output parameter of type real(kind=8).", "input": "", "output": "    function gammas_plusminus(m,mp,l,lp,bigl)\n        implicit none\n        integer, intent(in) :: m, mp, l, lp, bigl\n        real(kind=8) :: gammas_plusminus\n\n        gammas_plusminus =  gamma((l+lp+bigl+2*m+2*mp+2.d0)/2.d0) &\n            / gamma(l+m+3.d0/2.d0) / gamma(lp+mp+3.d0/2.d0)\n\n    end function gammas_plusminus\n"}, {"instruction": "Write a Fortran function named grouppath to generate the path of a specific atom group based on the input integer itype. The function has 1 input parameter of type integer and 1 output parameter of type character with variable length and allocatable.", "input": "", "output": "  function grouppath(itype)\n    implicit none\n    integer,intent(in)::itype\n    character(len=:),allocatable::grouppath\n    character(len=100)::str\n    write(str,\"(a,i0,a)\") '/fleurinput/atomgroups/atomgroup[',itype,']'\n    grouppath=trim(str)\n  end function grouppath\n"}, {"instruction": "Write a Fortran function named countstringtokens that takes a single string input argument of type character(*) and returns the number of tokens in the input string as an integer output argument. The input argument should be of type ['character(*)'] and the output argument should be of type ['integer'].", "input": "", "output": "   function countstringtokens(line) result(tokencount)\n\n      implicit none\n\n      character(*), intent(in) :: line\n      integer                  :: tokencount\n\n      character(len=len(line)) :: templine\n      integer separatorindex\n\n      tokencount = 0\n\n      templine = trim(adjustl(line))\n\n      do while (templine.ne.'')\n         separatorindex = 0\n         separatorindex = index(templine,' ')\n         if (separatorindex.eq.0) then\n            templine = ''\n         else\n            templine = trim(adjustl(templine(separatorindex+1:)))\n         end if\n         tokencount = tokencount + 1\n      end do\n\n   end function countstringtokens\n"}, {"instruction": "Create a Fortran function called \"sim_geth_s\" that calculates a value based on the input parameters \"phi\" and \"d,\" both of which are real numbers. The function returns a real number as the output. If the value of \"phi\" is less than -d, the output is 0.0. If the value of \"phi\" is greater than d, the output is 1.0. Otherwise, the output is 0.5 times (phi + d) divided by d.", "input": "", "output": "function sim_geth_s(phi, d)\n  implicit none\n  real          :: sim_geth_s\n  real          :: phi\n\treal\t\t\t\t\t:: d\n\tsim_geth_s = 1.0\n\tif( phi < -d ) then\n\t\tsim_geth_s = 0.0\n\telse if( phi > d ) then\n\t\tsim_geth_s = 1.0\n\telse\n\t\tsim_geth_s = 0.5*(phi + d)/d\n\tend if\n  return\nend function sim_geth_s\n"}, {"instruction": "Create a Fortran function named sim_getminmod to calculate the minimum of two real numbers. The function should take 2 real numbers as input and return the minimum of the two numbers as a real output.", "input": "", "output": "function sim_getminmod(a, b)\n  implicit none\n  real          :: sim_getminmod\n  real          :: a, b\n!  sim_getminmod = 0.5*(sign(a, a) + sign(b, b))*min(abs(a), abs(b))\n  sim_getminmod = 0.0\n  if( abs(a) .lt. abs(b) ) then\n    sim_getminmod = a\n  else if( abs(a) .gt. abs(b) ) then\n    sim_getminmod = b\n  endif\n  return\nend function sim_getminmod\n"}, {"instruction": "Write a Fortran function named sim_getux to calculate the x-component of the velocity field. The function takes 6 input arguments of type real: x, y, z, omega, zmin, rmin. It returns 1 output argument of type real.", "input": "", "output": "function sim_getux(x, y, z, omega, zmin, rmin)\n\timplicit none\n\treal\t\t\t\t\t:: sim_getux\n\treal\t\t\t\t\t:: x, y, z, omega, zmin, rmin\n\treal\t\t\t\t\t:: r2, rl, theta\n\treal\t\t\t\t\t:: nx, ny, nz\n\treal\t\t\t\t\t:: ux, uy, uz\n\tr2 = x*x + y*y\n\trl = sqrt(r2)\n\ttheta = atan(x)\n\tnx = x/rl\n\tny = y/rl\n\tnz = z/rl\n\tux =-rl*omega*ny\n\tuy =+rl*omega*nx\n\tuz = 0.0\n\tux =-omega*y\n\tuy =+omega*x\n\tuz = 0.0\n\tif( rl < rmin .and. z > zmin ) then\n\t\tux = 0.0\n\t\tuy = 0.0\n\t\tuz = 0.0\n\tend if\n\tsim_getux = ux\n\treturn\nend function sim_getux\n"}, {"instruction": "Create a Fortran pure function named get_version_mmr to extract the major.minor.release part of a version string. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "pure function get_version_mmr(v)\n!! get the major.minor.release part of a version string\n!! cuts off further patch and arbitrary text\ncharacter(:), allocatable :: get_version_mmr\ncharacter(*), intent(in) :: v\n\ninteger :: i, j, k, e\n\nk = index(v, '.')\nj = index(v(k+1:), '.')\ni = scan(v(k+j+1:), '.-_ ')\nif (i == 0) then\n  e = len_trim(v)\nelse\n  e = k + j + i - 1\nend if\n\nget_version_mmr = v(:e)\n\nend function get_version_mmr\n"}, {"instruction": "Create a Fortran function named jfunc3 that takes three real*8 input parameters and returns a real*8 output. The function computes the value of (1 - exp(-(k + l) * t)) / (k + l).", "input": "", "output": "function jfunc3(k,l,t)\n\n    implicit none\n\n\n    real*8 :: k,l,t\n    real*8 :: jfunc3\n\n    jfunc3=(1.-exp(-(k+l)*t))/(k+l)\n\nend function jfunc3\n"}, {"instruction": "Create a Fortran function named hill_inh that calculates the Hill inhibition function. This function takes 3 input parameters of type integer, double precision, and double precision, and returns 1 output parameter of type double precision.", "input": "", "output": "function hill_inh(x, x0, n)\n   implicit none\n   integer, intent(in) :: n\n   double precision,intent(in) :: x, x0\n   double precision :: hill_inh\n   \n   double precision :: a\n   \n   a = (x/x0)**n\n   hill_inh = 1/(1+a)\n   \nend function hill_inh\n"}, {"instruction": "Create a Fortran function called root that takes an array of 10 real numbers as input and returns the sum of all the elements in the array. The input parameter should be of type real, dimension(10) and the output parameter should be of type real.", "input": "", "output": "\tfunction root(x) result(r)\n\t\treal, dimension(10) :: x\n\t\treal :: r\n\t\tinteger :: i\n\n\t\tr = 0\n\n\t\tdo i = 1, 10\n\t\t\tr = r + x(i)\n\t\tend do\n\n\tend function\n"}, {"instruction": "Create a Fortran function named l2_distance that calculates the L2 distance between two sets of points in high-dimensional space. The function takes 11 input parameters of types ['double precision, dimension(:,:)', 'double precision, dimension(:,:)', 'integer', 'integer', 'integer', 'integer', 'integer, dimension(:)', 'integer, dimension(:)', 'double precision, dimension(:)', 'double precision, dimension(:)', 'double precision, dimension(:,:)'], and returns 1 output parameter of type ['double precision'].", "input": "", "output": "function l2_distance(x1, x2, n1, n2, q1, q2, qall1, qall2, ksi1, ksi2, pd) result(aa)\n\n    implicit none\n\n    double precision, dimension(:,:), intent(in) :: x1\n    double precision, dimension(:,:), intent(in) :: x2\n\n    integer, intent(in) :: n1\n    integer, intent(in) :: n2\n\n    integer, intent(in) :: q1\n    integer, intent(in) :: q2\n\n    integer, dimension(:), intent(in) :: qall1\n    integer, dimension(:), intent(in) :: qall2\n\n    double precision, dimension(:), intent(in) :: ksi1 \n    double precision, dimension(:), intent(in) :: ksi2\n\n    double precision, dimension(:,:), intent(in) :: pd\n\n    double precision :: a, b, c, d, e\n    integer :: i, j, k, l\n\n    double precision :: aa\n    double precision :: ddist\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n    double precision, parameter :: t_width = pi / 4.0d0 ! ~0.7853981633974483\n    double precision, parameter :: d_width = 0.2d0\n    double precision, parameter :: cut_distance = 6.0d0\n    double precision, parameter :: r_width = 1.0d0\n    double precision, parameter :: c_width = 0.5d0\n\n    double precision, parameter :: inv_cut = pi / (2.0d0 * cut_distance)\n    double precision, parameter :: sqrt_pi = sqrt(pi)\n\n    double precision, parameter :: t_fast = -1.0d0 / (4.0d0 * t_width**2)\n    double precision, parameter :: d_fast = -1.0d0 / (4.0d0 * d_width**2)\n    double precision :: maxgausdist2 = (8.0d0 * d_width)**2\n\n    a = 1.0d0 / (sum(ksi1(:n1)) * sum(ksi2(:n2))) &\n        &  * sqrt_pi * d_width * r_width**4 * c_width**4 &\n        & * pd(q1, q2)\n    \n    b = 0.0d0\n\n    do i = 1,  n1\n        c = 0.0d0\n        if (x1(1,i) > cut_distance) exit\n\n        do j = 1, n2\n            d = 0.0d0\n\n            if (x2(1,j) > cut_distance) exit\n            ddist = (x1(1,i) - x2(1,j))**2\n\n            if (ddist < maxgausdist2) then\n\n                do k = 1, n1\n                    e = 0.0d0\n\n                    do l = 1, n2\n                         e = e + ksi2(l) * exp((x1(i+3,k) - x2(j+3,l))**2 * t_fast)\n\n                    enddo\n                    d = d + e * ksi1(k)\n\n                enddo\n                c = c + d * exp(ddist * d_fast) * ksi2(j) &\n                    & * pd(qall1(i), qall2(j))\n            endif\n\n        enddo\n        b = b + c * ksi1(i)\n\n    enddo\n\n    aa = a * b\n    \nend function l2_distance\n"}, {"instruction": "Create a Fortran function named count_digits to determine the number of digits in a given real*16 number. The function has 1 input parameter of type real*16. The output is an integer representing the count of digits in the input number.", "input": "", "output": "  pure function count_digits(n)\n    real*16, intent(in) :: n\n    real*16             :: temp\n    integer             :: count_digits\n\n    temp=log10(n)\n    count_digits=int(ceiling(temp))\n    if (temp==0.0) then\n       count_digits=1\n    else if (mod(temp,1.0q0)==0.0q0) then\n       count_digits=count_digits-1\n    end if\n\n  end function count_digits\n"}, {"instruction": "Create a Fortran function named matches to check if string1 is contained in string2. The function takes 2 input parameters of type character (len=*) and returns 1 output parameter of type logical. If string1 is found in string2, the function returns .true.; otherwise, it returns .false.", "input": "", "output": "function matches( string1, string2 )  \n  !-----------------------------------------------------------------------\n  !\n  ! ... .true. if string1 is contained in string2, .false. otherwise\n  !\n  implicit none\n  !\n  character (len=*), intent(in) :: string1, string2\n  logical                       :: matches\n  integer                       :: len1, len2, l  \n  !\n  !\n  len1 = len_trim( string1 )  \n  len2 = len_trim( string2 )  \n  !\n  do l = 1, ( len2 - len1 + 1 )  \n     !   \n     if ( string1(1:len1) == string2(l:(l+len1-1)) ) then  \n        !\n        matches = .true.  \n        !\n        return  \n        !\n     end if\n     !\n  end do\n  !\n  matches = .false.\n  ! \n  return\n  !\nend function matches\n"}, {"instruction": "Create a Fortran function named everett to compute the result of the Everett bilinear function. The function takes 2 input arguments of type double precision, named alpha and beta. It returns 1 output argument of type double precision. If the result is negative, it is set to 0.0d0.", "input": "", "output": "  function everett(alpha,beta )\n    ! description :\n    ! calcul de la fonction d'everett bilineaire.\n    implicit none\n    ! inputs :\n    double precision, intent(in)                            :: alpha, beta\n    ! outputs :\n    double precision                                        :: everett\n    \n    everett = -alpha*beta\n    if ( everett < 0.0d0 ) everett = 0.0d0\n    \n    return\n  end function everett\n"}, {"instruction": "Create a Fortran function named deverettdb to calculate the derivative of the bilinear Everett function. The function takes 2 input parameters of type double precision and returns 1 output parameter of type double precision. If the product of the input parameters is less than 0, the output is set to the negative value of the first input parameter; otherwise, the output is set to 0.", "input": "", "output": "  function deverettdb(alpha,beta )\n    ! description :\n    ! calcul de la derivee de la fonction d'everett bilineaire.\n    implicit none\n    ! inputs :\n    double precision, intent(in)                            :: alpha, beta\n    ! outputs :\n    double precision                                        :: deverettdb\n    \n    if ( alpha*beta < 0.0d0 ) then\n      deverettdb = -alpha\n    else\n      deverettdb = 0.0d0\n    end if\n    \n    return\n  end function deverettdb\n"}, {"instruction": "Create a Fortran function named pmod that calculates the positive remainder of a division operation. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters should be named a and b, while the output parameter should be named res.", "input": "", "output": "function pmod(a, b) result(res)\n   implicit none\n   integer, intent(in) :: a, b\n   integer :: res\n\n   res = mod(b + mod(a,b), b)\n\nend function\n"}, {"instruction": "Write a Fortran function named cleanstring that takes a single input parameter of type character(len=256) and returns a single output parameter of the same type. The function should remove any trailing whitespace from the input string and return the modified string.", "input": "", "output": "  function cleanstring(str)\n    use iso_c_binding\n    implicit none\n    character(len=256) :: cleanstring\n    character(len=256) :: str\n    cleanstring = trim(str)//c_null_char\n  end function\n"}, {"instruction": "Create a Fortran function named pi to approximate the value of pi using a Monte Carlo method. The function takes 1 input argument of type integer (samples) and returns 1 output argument of type real.", "input": "", "output": "  function pi(samples)\n    real :: pi\n    real :: coords(2), length\n    integer :: i, in_circle, samples\n\n    in_circle = 0\n    do i=1, samples\n      call random_number(coords)\n      coords = coords * 2 - 1\n      length = sqrt(coords(1)*coords(1) + coords(2)*coords(2))\n      if (length <= 1) in_circle = in_circle + 1\n    end do\n    pi = 4.0 * real(in_circle) / real(samples)\n  end function pi\n"}, {"instruction": "Create a Fortran function named quickaarr that takes one integer input argument, xind. The function returns an array of two integers as output. The input argument should be of type integer, and the output should be an integer array of dimension 2.", "input": "", "output": "  function quickaarr(xind)\n    implicit none\n    integer, dimension(2) :: quickaarr\n    integer, save :: temp(2)\n    integer,intent(in) :: xind\n    integer :: ind,q\n\n    ind=xind-1\n!orderflag 0\n    temp(2)           = mod(ind,2)+1\n!!       q=(ind-mod(ind,2))/2  no need\n    q=ind/2                   !! rounds down.\n    temp(1)           = q+1\n    quickaarr=temp\n  end function quickaarr\n"}, {"instruction": "Create a Fortran function named \"g\" that takes one real number as input and returns a real number. The function sets the output value to be equal to the input value.", "input": "", "output": "  function g(gx)\n    != unit 'b :: gx\n    real :: gx, gn, gm, g\n    gm = gx\n    gn = gm\n    g = gn\n  end function g\n"}, {"instruction": "Create a Fortran function named score to calculate the score using the given input integers. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input parameters are x and y, and the output parameter is score.", "input": "", "output": "  pure function score(x,y)\n    implicit none\n    integer, intent(in) :: x,y\n    integer             :: u,v,i,j,score\n\n    score=0\n    do i=1,x\n       u=(x+1-i)\n       do j=1,y\n          v=(y+1-j)\n          score=score+(u*v)\n       end do\n    end do\n    \n  end function score\n"}, {"instruction": "Write a Fortran function named uppercase to convert a single lowercase character to uppercase. The number of input arguments is 1, and the test_data type is ['character(len=1)']. The number of output arguments is 1, and the test_data type is ['character(len=1)'].", "input": "", "output": "function uppercase(str) result (strup)\n  character(len=1), intent(in) :: str\n  character(len=1) :: strup\n  strup=str\n  if ((ichar(str) >= ichar(\"a\")) .and. (ichar(str) <= ichar(\"z\"))) then \n     strup = char(ichar(\"a\")+ichar(str)-ichar(\"a\"))\n  end if\nend function uppercase\n"}, {"instruction": "Create a Fortran function named chease_chi_index to determine the index value for the \"chease\" code based on the input values of nchi and itheta. The function accepts 2 input parameters of type integer and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  function chease_chi_index(nchi,itheta)\n    integer, intent(in) :: nchi, itheta\n    integer :: chease_chi_index\n    ! when ichi = 0, itheta = (ntheta-1)/2 + 1\n    ! when itheta = 0, ichi = ntheta / 2\n    ! itheta  1 2 3 4 5 6 7 8 \n    ! ichi    5 6 7 8 1 2 3 4         \n    if (itheta > nchi/2) then \n       chease_chi_index = itheta - nchi/2\n    else\n       chease_chi_index = itheta + nchi/2\n    end if\n  end function chease_chi_index\n"}, {"instruction": "Create a Fortran function named roundton that rounds a real number to a specified number of decimal places. The function takes 2 input parameters of type real and integer, representing the number to be rounded and the number of decimal places, respectively. The function returns a single real value as the rounded number.", "input": "", "output": "  function roundton(x,n)\n    ! round to n decimal places\n    real,    intent(in)             :: x\n    integer, intent(in)             :: n\n    real                            :: roundton\n\n    real                            :: factor\n\n    factor=10**n\n    roundton=float(int(x * factor  + 0.5)) / factor\n\n  end function roundton\n"}, {"instruction": "Write a Fortran function named str_s1 that concatenates a given character string with a specified delimiter. The function takes in two input arguments of type character(len=*) and character(len=*), optional. It returns one output argument of type character(len=:), allocatable.", "input": "", "output": "  function str_s1(this,delim) result(res)\n    !! interfaced with str()\n  !====================================================================!\n  character(len=*), intent(in) :: this\n  character(len=*),optional, intent(in) :: delim\n  character(len=:),allocatable :: res\n  character(len=:),allocatable :: delim_\n  delim_=' '\n  if(present(delim)) delim_=delim\n  res = trim(this)//delim_\n  end function\n"}, {"instruction": "Create a Fortran function named appendstring that appends two strings together. The function takes 3 input parameters of types character(len=*) and an optional character(len=*) delimiter. It returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "  function appendstring(this,that,delim_) result(res)\n    !! append a string\n  !====================================================================!\n  character(len=*) :: this\n    !! string to append to\n  character(len=*) :: that\n    !! string to append\n  character(len=*),optional :: delim_\n    !! optional delimiter to separate the append\n  character(len=:), allocatable :: res\n    !! appended string\n  if (present(delim_)) then\n    res = trim(this)//trim(delim_)//trim(that)\n  else\n    res = trim(this)//trim(that)\n  endif\n  end function\n"}, {"instruction": "Create a Fortran function named predicate2 to check if a given condition involving two integer parameters is true. The function takes 2 input arguments of type integer and returns 1 output argument of type logical. The test_data type for input arguments is ['integer', 'integer'], and for the output argument is ['logical'].", "input": "", "output": "  pure function predicate2(n,m)\n    implicit none\n    integer, intent(in) :: n,m\n    integer             :: a,b,temp1,temp2,count\n    logical             :: predicate2\n\n    a=n\n    b=m\n    count=0\n    predicate2=.false.\n\n    temp2=mod(b,10)\n    do while (a>0)\n       temp1=mod(a,10)\n       if (temp1==temp2) then\n          b=b/10\n          temp2=mod(b,10)\n          count=count+1\n          if (count==3) then\n             predicate2=.true.\n             return\n          end if\n       end if\n       a=a/10\n    end do\n\n  end function predicate2\n"}, {"instruction": "Write a Fortran function named int2char that takes an integer as input and returns the corresponding character representation. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(:), allocatable'].", "input": "", "output": "  function int2char(i) result(res)\n    character(:),allocatable :: res\n    integer,intent(in) :: i\n    character(range(i)+2) :: tmp\n    write(tmp,'(i0)') i\n    res = trim(tmp)\n  end function int2char\n"}, {"instruction": "Create a Fortran function named f1 to perform a series of operations on an input integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function performs a loop with specific conditions and assigns a value to the output parameter based on the loop iteration.", "input": "", "output": "  function f1 (y)\n    integer, intent(in) :: y\n    integer :: i, f1, x\n    x = y\n    !$omp taskloop firstprivate(x)lastprivate(x)\n    do i = 0, 63\n      if (x .ne. 74) call abort\n      if (i .eq. 63) then\n        x = i + 4\n      end if\n    end do\n    f1 = x\n  end function f1\n"}, {"instruction": "Create a Fortran function named f3 that takes in three 64-bit integer arguments. The input arguments are of type integer(kind=8) and the test_data type is ['integer(kind=8)', 'integer(kind=8)', 'integer(kind=8)']. The function returns a single 64-bit integer result, and the test_data type is ['integer(kind=8)']. The function calculates a value by performing a taskloop and returns the result. Remember to use the imperative tone and reflect the features of Fortran function.", "input": "", "output": "  function f3 (a, b, c)\n    integer(kind=8), intent(in) :: a, b, c\n    integer(kind=8) :: i, f3\n    integer :: l\n    !$omp taskloop default(none) lastprivate (i, l)\n    do i = a, b, c\n      l = i\n    end do\n    !$omp end taskloop\n    f3 = l * 7 + i\n  end function f3\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci number at the given position. The function has 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  recursive function fib(n) result(fib_n)\n    integer:: fib_n, n\n\n    if (n < 3) then\n      fib_n = 1\n    else\n      fib_n = fib(n-1) + fib(n-2)\n    end if\n\n  end function\n"}, {"instruction": "Write a Fortran function named odd_list that takes an array of integers as input. The number of input parameters is 1, and the test_data type is ['integer, dimension(:)']. The function returns an array of logical values indicating whether each element in the input array is odd. The number of output parameters is 1, and the test_data type is ['logical, dimension(size(a))'].", "input": "", "output": "  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n"}, {"instruction": "Write a Fortran function called i4_bit_lo0 that finds the position of the lowest bit in a 4-byte integer containing a 0. The function takes 1 input parameter of type integer(kind=4) and returns 1 output parameter of type integer.", "input": "", "output": "function i4_bit_lo0(num)\n  implicit none\n\n  integer(kind=4), intent(in) :: num\n  integer :: i4_bit_lo0\n\n  do i4_bit_lo0=1,bit_size(num)\n    if (.not. btest(num,i4_bit_lo0-1)) return\n  enddo\nend function i4_bit_lo0\n"}, {"instruction": "Write a Fortran function named log2 that takes an integer input argument and returns the base-2 logarithm of the input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function log2(vin) result(r)\n  implicit none\n  integer :: r\n  integer, intent(in) :: vin\n  integer :: v\n  r = 0\n  v = vin\n  do\n     v = ishft(v, -1)\n     if ( v == 0 ) exit\n     r = r + 1\n  end do\nend function log2\n"}, {"instruction": "Please create a Fortran recursive function named fact that calculates the factorial of a given integer. The function should take 1 input parameter of type integer and return 1 output parameter of type integer. The input parameter test_data type is ['integer'], and the output parameter test_data type is ['integer'].", "input": "", "output": "recursive function fact(i) result(j)\n    integer, intent(in) :: i\n    integer :: j\n    if (i == 1) then\n        j = 1\n    else\n        j = i * fact(i - 1)\n    end if\nend function fact\n"}, {"instruction": "Write a Fortran function named test1 that takes an integer input argument and returns an empty character string. The function accepts 1 input parameter with the type integer and returns 1 output parameter with the type character(n), where n is the length of the character string to be returned.", "input": "", "output": "function test1(n)\n  integer  :: n\n  character(n) :: test1\n  character(n) :: bar1\n  test1 = \"\"\n  return\nentry bar1()\n  bar1 = \"\"\nend function test1\n"}, {"instruction": "Create a Fortran function named get_line_count to calculate the number of lines in a specified file. The function takes 1 input argument of type character(len=*), denoting the filename, and returns 1 output argument of type integer, representing the number of lines in the file.", "input": "", "output": "    function get_line_count(filename) result (lines)\n        implicit none\n        character(len=*), intent(in) :: filename\n        integer :: fileunit,io\n        integer :: lines\n        \n        open(newunit=fileunit, file=filename, action='read', position='rewind')\n        lines = 0\n        do  \n            read(fileunit,*,iostat=io)\n            if ( io /= 0 ) exit\n            lines = lines + 1\n        end do\n        close(fileunit)\n    end function get_line_count\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer, marked as value. The output is a single integer.", "input": "", "output": "    function factorial(n) result(fac)\n        implicit none\n        integer, value :: n\n        integer :: fac\n\n        fac = 1\n        do while (n > 1)\n            fac = fac*n\n            n = n - 1\n        end do\n    end function factorial\n"}, {"instruction": "Create a Fortran function named findx2harmpi to calculate the difference between the given theta value and a specific mathematical expression. The number of input arguments is 2, with test_data types ['real(kind=8)', 'real(kind=8), dimension(:)']. The number of output arguments is 1, with a test_data type of ['real(kind=8)'].", "input": "", "output": "        function findx2harmpi(x2,args) result(diff)\n        real(kind=8), intent(in) :: x2\n        real(kind=8), intent(in), dimension(:) :: args\n        real(kind=8) :: h, theta, diff\n        h=args(2); theta=args(1)\n        diff=theta-(pi/2.*(1.+x2)+((1.-h)/2.)*sin(pi*(1.+x2)))\n        end function findx2harmpi\n"}, {"instruction": "Write a Fortran function named findx2harmpi_array to calculate the difference between two arrays. The input consists of two parameters, both of real kind and arrays of different dimensions. The first input parameter is one-dimensional, and the second one is two-dimensional. The output is a one-dimensional real array of the same size as the input x2 array.", "input": "", "output": "        function findx2harmpi_array(x2,args) result(diff)\n        real(kind=8), intent(in), dimension(:) :: x2\n        real(kind=8), intent(in), dimension(:,:) :: args\n        real(kind=8) :: h\n        real(kind=8), dimension(size(x2)) :: theta, diff\n        h=args(1,2); theta=args(:,1)\n        diff=theta-(pi/2d0*(1.+x2)+((1d0-h)/2d0)*sin(pi*(1d0+x2)))\n        end function findx2harmpi_array\n"}, {"instruction": "Write a Fortran function named ftr that operates on an array of double-precision real numbers. The function takes 1 input argument of type real(kind=8), dimension(:), and returns 1 output argument of type real(kind=8), dimension(size(x)). The function computes the result based on the given input array and uses mathematical operations such as cosine and sine, and the merge function to conditionally populate the output array.", "input": "", "output": "        function ftr(x) result(res)\n          real(kind=8), intent(in), dimension(:) :: x\n          real(kind=8), dimension(size(x)) :: res\n          real(kind=8), dimension(size(x)) :: zero,one\n          zero=0.; one=1.\n          res=merge(zero,(64+cos(5*pi*x)+70*sin((pi*(-1+2*x))/2.)+5*sin((3*pi*(-1+2*x))/2.))/128.,x.le.0.)\n          res=merge(res,one,x.lt.1.)\n        end function ftr\n"}, {"instruction": "Create a Fortran function named calcrmks that computes the array r based on the input array x1 for Jon's simulations. The input parameter is a real array of kind 8 and dimension '(:)', while the output parameter is a real array of kind 8 and dimension 'size(x1)'.", "input": "", "output": "        function calcrmks(x1) result(r)\n          ! compute r given x1 for jon's simulations\n          ! jad 7/24/2011\n          real(kind=8), intent(in), dimension(:) :: x1\n!          real(kind=8), intent(in) :: xbr,npow2,cpow2,r0\n!          real(kind=8) :: npow2,cpow2,r0\n          real(kind=8), dimension(size(x1)) :: r, xi\n!          npow2=10d0\n          where(x1.gt.xbr)\n             xi=x1+cpow2*(x1-xbr)**npow2\n          elsewhere\n             xi=x1\n          endwhere\n!          write(6,*) 'calcrmks: ',r0,cpow2,npow2,xbr\n          r=r0+exp(xi)\n        end function calcrmks\n"}, {"instruction": "Create a Fortran function named calcrmks_single to compute a value based on the input x1. The input parameter is of type real(kind=8), and the output parameter is also of type real(kind=8).", "input": "", "output": "        function calcrmks_single(x1) result(r)\n          ! compute r given x1 for jon's simulations\n          ! jad 7/24/2011\n          real(kind=8), intent(in) :: x1\n!          real(kind=8), intent(in) :: xbr,npow2,cpow2,r0\n!          real(kind=8) :: npow2,cpow2,r0\n          real(kind=8)  :: r, xi\n!          npow2=10d0\n          if(x1.gt.xbr) then\n             xi=x1+cpow2*(x1-xbr)**npow2\n          else\n             xi=x1\n          endif\n          r=r0+exp(xi)\n        end function calcrmks_single\n"}, {"instruction": "Create a Fortran function named itoa to convert an integer to a character string. The function should have 1 input argument of type integer and 1 output argument of type character(:),allocatable. The input parameter is 'i' of type integer, and the output parameter is 'res' of type character(:),allocatable.", "input": "", "output": "\t\tfunction itoa(i) result(res)\n\t\t\tcharacter(:),allocatable :: res\n\t\t\tinteger,intent(in) :: i\n\t\t\tcharacter(range(i)+2) :: tmp\n\t\t\twrite(tmp,'(i0)') i\n\t\t\tres = trim(tmp)\n\t\tend function\n"}, {"instruction": "Create a Fortran function called set_boundary_innerxstate to set the inner boundary state variables. The function takes 5 input parameters of type real*8: rho_in, rhvx_in, rhvy_in, rhvz_in, and en_in. It returns a single output parameter of type integer.", "input": "", "output": "function set_boundary_innerxstate(rho_in,rhvx_in,rhvy_in,rhvz_in,en_in) result(ret)\n    implicit none\n    integer :: ret\n    real*8 :: rho_in,rhvx_in,rhvy_in,rhvz_in,en_in    \n    ret = 0\nend function  \n"}, {"instruction": "Create a Fortran function named set_parallel_decomposition to specify the parallel decomposition for a 3D domain. The function takes 3 input arguments of type integer (nx, ny, nz) to represent the domain size in the x, y, and z directions. The output parameter is an integer (ret) indicating the success of the operation.", "input": "", "output": "function set_parallel_decomposition(nx, ny, nz) result(ret)\n    implicit none\n    integer :: ret, ntotal\n    integer, intent(in) :: nx, ny, nz\n    ret = 0\nend function set_parallel_decomposition\n"}, {"instruction": "Create a Fortran function named get_timestep to retrieve the value of the output parameter outputvalue, which is an integer. The function has 1 input parameter of type integer and 1 output parameter of type integer. Set the outputvalue parameter to the desired value within the function.", "input": "", "output": "function get_timestep(outputvalue) result(ret)\n    implicit none\n    integer :: ret\n    integer, intent(out) :: outputvalue\n    ret = 0\nend function get_timestep\n"}, {"instruction": "Create a Fortran function named set_timestep to set the time step value. It takes 1 input parameter, an integer, and returns 1 output parameter, also an integer.", "input": "", "output": "function set_timestep(inputvalue) result(ret)\n    implicit none\n    integer :: ret\n    integer, intent(in) :: inputvalue\n    ret = 0\nend function set_timestep\n"}, {"instruction": "Create a Fortran function named set_gamma to assign the value 0 to the output variable. The function takes 1 input parameter of type double precision and returns 1 output parameter of type integer. The input parameter is named inputvalue and the output parameter is named ret.", "input": "", "output": "function set_gamma(inputvalue) result(ret)\n    implicit none\n    integer :: ret\n    double precision :: inputvalue\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function named get_gamma to return an integer value. The function takes one input parameter of type double precision. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_gamma(outputvalue) result(ret)\n    implicit none\n    integer :: ret\n    double precision :: outputvalue\n    ret = 0\nend function\n"}, {"instruction": "Write a Fortran function named rastrigin to calculate the value of the Rastrigin function for a given input array of real numbers. The function takes 1 input parameter of type real(kind = 8), dimension(:) and returns 1 output parameter of type real(kind = 8).", "input": "", "output": "  function rastrigin(x) result(f)\n    real(kind = 8), dimension(:), intent(in) :: x\n    integer(kind = 4) :: n_dim\n    real(kind = 8) :: f, sum1\n\n    n_dim = size(x)\n    sum1 = sum( x**2 - 10.0d0 * cos( 2.0d0 * pi * x ) )\n    f = 10.0d0 * n_dim + sum1\n    return\n  end function rastrigin\n"}, {"instruction": "Create a Fortran function named repsi1 that calculates the function value of repsi1 based on the input parameter x. The input parameter is of type real and is marked as intent(in). The output parameter is also of type real.", "input": "", "output": "      function repsi1(x)  \n        implicit none\n        real, intent(in) :: x\n        real :: repsi1\n\n        real, parameter :: xmin=0.14e0, x1=0.7e0 ,xmax=1.9e0\n        real, parameter :: zeta32=2.404113806319188 ! 2*zeta(3)\n        real, parameter :: zeta54=4.147711020573480 ! 4*zeta(5)\n        real, parameter :: a0= 0.004211521868683916\n        real, parameter :: a1= 2.314767988469241000\n        real, parameter :: a2= 0.761843932767193200\n        real, parameter :: a3=-7.498711815965575000\n        real, parameter :: a4= 7.940030433629257000\n        real, parameter :: a5=-2.749533936429732000\n        real, parameter :: b0=-0.253862873373708200\n        real, parameter :: b1= 4.600929855835432000\n        real, parameter :: b2=-6.761540444078382000\n        real, parameter :: b3= 4.467238548899841000\n        real, parameter :: b4=-1.444390097613873500\n        real, parameter :: b5= 0.185954029179227070\n        real :: xi\n        if ( x .le. xmin) then             ! x < xmin=0.14 \n           repsi1=zeta32*x - zeta54*x*x*x  ! accurate to 0.1%\n        elseif (x .le. x1) then\n           repsi1=a5                       ! xmin < x < x1=0.7\n           repsi1=a4 + repsi1*x            ! accurate to 0.002%\n           repsi1=a3 + repsi1*x            ! a0 + a1*x + a2*x^2 +\n           repsi1=a2 + repsi1*x            ! a3* x^3 + a4*x^4 + a5*x^5\n           repsi1=a1 + repsi1*x\n           repsi1=a0 + repsi1*x\n        elseif (x .le. xmax) then          ! x1 < x < xmax=1.9\n           repsi1=b5                       ! accurate to 0.1%\n           repsi1=b4+repsi1*x              ! b0 + b1*x + b2*x^2 + \n           repsi1=b3+repsi1*x              ! b3*x^3 + b4*x^4 +\n           repsi1=b2+repsi1*x              ! b5*x^5\n           repsi1=b1+repsi1*x              \n           repsi1=b0+repsi1*x            \n        else\n           xi=1/x                          ! x > xmax=1.9\n           repsi1=-1.e0/30.e0              ! accurate to 0.08%\n           repsi1=repsi1*xi                ! 1/x - 1/6x^3 - 1/30x^5\n           repsi1=-1.e0/6.d0 + repsi1*xi   ! \n           repsi1=repsi1*xi                !\n           repsi1=1.e0 + repsi1*xi         !\n           repsi1=repsi1*xi                !\n        endif\n      end function repsi1\n"}, {"instruction": "Create a Fortran function named repsi2 to calculate the value of a function based on the input real number x. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "      function repsi2(x) \n        implicit none\n        real, intent(in) :: x\n        real :: repsi2\n        real, parameter :: xmin=0.18e0, x1=1.2e0 ,xmax=2.5e0\n        real, parameter :: zeta32=2.4041138063191880 ! 2*zeta(3)\n        real, parameter :: zeta512=12.44313306172044 ! 12*zeta(5)\n        real, parameter :: zeta730=30.250478321457685! 30*zeta(7)\n        real, parameter :: a0= 2.42013533575662130\n        real, parameter :: a1=-0.41115258967949336\n        real, parameter :: a2=-8.09116694062588400\n        real, parameter :: a3=-24.9364824558827640\n        real, parameter :: a4=114.8109056152471800\n        real, parameter :: a5=-170.854545232781960\n        real, parameter :: a6=128.8402466765824700\n        real, parameter :: a7=-50.2459090010302060 \n        real, parameter :: a8= 8.09941032385266400\n        real, parameter :: b0= 4.98436272402513600\n        real, parameter :: b1=-16.6546466531059530\n        real, parameter :: b2= 20.6941300362041100\n        real, parameter :: b3=-13.3726837850936920 \n        real, parameter :: b4= 4.83094787289278800 \n        real, parameter :: b5=-0.92976482601030100\n        real, parameter :: b6= 0.07456475055097825\n        real :: xi, xx\n        if ( x .le. xmin) then\n           xx=x*x\n           repsi2=zeta32 - zeta512*xx + zeta730*xx*xx ! x < xmin=0.18\n        elseif (x .le. x1) then                       ! accurate to 0.1%\n           repsi2=a8                                  !\n           repsi2=a7 + repsi2*x                       ! xmin < x < x1=1.2\n           repsi2=a6 + repsi2*x                       ! accurate to 0.01% \n           repsi2=a5 + repsi2*x                       ! a0 + a1*x + a2*x^2 +\n           repsi2=a4 + repsi2*x                       ! a3*x^3 + a4*x^4 +\n           repsi2=a3 + repsi2*x                       ! a5*x^5 + a6*x^6 +\n           repsi2=a2 + repsi2*x                       ! a7*x&7 + a8*x^8 \n           repsi2=a1 + repsi2*x\n           repsi2=a0 + repsi2*x \n        elseif (x .le. xmax) then                     ! x1 < x < xmax=2.5\n           repsi2=b6                                  ! accurate to 0.2%\n           repsi2=b5+repsi2*x                         ! b0 + b1*x + b2*x^2 +\n           repsi2=b4+repsi2*x                         ! b3*x^3 + b4*x^4 +\n           repsi2=b3+repsi2*x                         ! b5*x^5 + b6*x^6\n           repsi2=b2+repsi2*x          \n           repsi2=b1+repsi2*x          \n           repsi2=b0+repsi2*x          \n        else\n           xi=1/x                                     ! x > xmax=2.5\n           xi=xi*xi                                   ! accurate to 0.07%\n           repsi2= 1.e0/6.e0                          ! -1/x^2 + 1/2x^4 + \n           repsi2= 0.5e0 + repsi2*xi                  ! 1/6x^6\n           repsi2=-1. + repsi2*xi                     !\n           repsi2=repsi2*xi\n        endif\n      end function repsi2\n"}, {"instruction": "Create a Fortran function named stddev that calculates the standard deviation of a one-dimensional array of real numbers. The function takes 2 input parameters: an array of real numbers and an optional real number representing the mean. The output is a single real number representing the standard deviation.", "input": "", "output": "    function stddev(input, mean_in)\n        implicit none\n        real, dimension(:) :: input\n        real, intent(in), optional :: mean_in\n        real :: stddev\n        \n        real :: mean\n        integer :: x, n\n        \n        n = size(input)\n        \n        if (present(mean_in)) then\n            mean = mean_in\n        else\n            mean = sum(input) / n\n        endif\n        \n        stddev = sqrt( sum( (input - mean)**2 ) / (n-1) )\n        \n    end function stddev\n"}, {"instruction": "Create a Fortran function named ceil_power_of_two that takes an integer as input and returns the next power of two that is greater than or equal to the input number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function ceil_power_of_two(n)\n    implicit none\n    integer,intent(in) :: n\n    integer            :: ceil_power_of_two\n    integer :: x\n    x = n\n    x = ior(x, ishft(x, 1))\n    x = ior(x, ishft(x, 2))\n    x = ior(x, ishft(x, 4))\n    x = ior(x, ishft(x, 8))\n    x = ior(x, ishft(x, 16))\n    ceil_power_of_two = x - ishft(x, 1)\n  end function\n"}, {"instruction": "Provide a Fortran function named roundup_pow2 that takes one integer input argument and returns one integer output argument. This function computes the next power of 2 greater than or equal to the input integer and stores the result in the variable \"roundup_pow2\". Use bitwise operations to efficiently compute the next power of 2.", "input": "", "output": "  function roundup_pow2(n)\n    implicit none\n    integer,intent(in) :: n\n    integer            :: roundup_pow2,k\n\n    k = n - 1\n    k = ior(k, ishft(k,-1))\n    k = ior(k, ishft(k,-2))\n    k = ior(k, ishft(k,-4))\n    k = ior(k, ishft(k,-8))\n    k = ior(k, ishft(k,-16))\n\n    roundup_pow2 = k + 1\n  end function roundup_pow2\n"}, {"instruction": "Create a Fortran function named al4san_init_c that uses the iso_c_binding module to initialize the AL4SAN runtime system. The function takes 2 input parameters of type integer(kind=c_int), passed by value. The output is an integer(kind=c_int). The function is named al4san_init and is declared using the bind attribute with the name 'al4san_init'.", "input": "", "output": "         function al4san_init_c(cpus, gpus) &\n          & bind(c, name='al4san_init')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: al4san_init_c\n            integer(kind=c_int), value :: cpus, gpus\n         end function al4san_init_c\n"}, {"instruction": "Create a Fortran function named al4san_enable_c with one input parameter of type integer(kind=c_int) and marked as value. It also has one output parameter of type integer(kind=c_int). The function is used to enable a specific feature and returns a status code indicating the success or failure of the operation.", "input": "", "output": "         function al4san_enable_c(param) &\n          & bind(c, name='al4san_enable')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: al4san_enable_c\n            integer(kind=c_int), value :: param\n         end function al4san_enable_c\n"}, {"instruction": "Write a Fortran function named al4san_init_affinity_c to initialize the affinity of computing resources such as cores and GPUs. The function takes 3 input parameters of type 'integer(kind=c_int), value', 'integer(kind=c_int), value', and 'type(c_ptr), value'. It also returns 1 output parameter of type 'integer(kind=c_int)'. The function should be named al4san_init_affinity_c.", "input": "", "output": "         function al4san_init_affinity_c(cores,gpus,bindtab) &\n          & bind(c, name='al4san_init_affinity')\n            use iso_c_binding\n            integer(kind=c_int) :: al4san_init_affinity_c\n            integer(kind=c_int), value ::  cores, gpus\n            type(c_ptr), value :: bindtab\n         end function al4san_init_affinity_c\n"}, {"instruction": "Write a Fortran function named randint to generate a random integer within a specified range. The function takes 2 input arguments of type integer(16) and returns 1 output argument of type integer(16). The test_data type is ['integer(16)', 'integer(16)'] for input parameters and ['integer(16)'] for the output parameter.", "input": "", "output": "function randint(from, to) result (random_int)\n    implicit none\n    integer(16), intent(in) :: from, to\n    integer(16) :: random_int\n    real :: rng1\n    \n    call random_seed()\n    call random_number(rng1)\n    \n    random_int = int(from + int(rng1 * (to - from + 1)))\n    \nend function randint\n"}, {"instruction": "Create a Fortran function named \"j\" that takes two integer input parameters. The test_data type for the input parameters is ['integer', 'integer']. The function should return a single integer output parameter, with the test_data type ['integer']. The function should calculate the value of \"j\" using the input parameters according to the provided formula. Use the imperative tone to specify the requirements for the function.", "input": "", "output": "  pure function j(p,n)\n    implicit none\n    integer, intent(in) :: p,n\n    integer :: j\n    j=p-((p+n)/n-1)*n\n  end function j\n"}, {"instruction": "Write a Fortran function named index2coords that takes an integer index and a 3-element integer array representing the dimensions as input parameters and returns a 3-element integer array representing the coordinates. The input parameters should be of type integer and integer array with 3 elements. The output parameter should be of type integer array with 3 elements.", "input": "", "output": "function index2coords(ind,n) result(x)\n! ... gets the x=(i,j,k) and returns its index = (k-1)*nx*ny + (j-1)*nx + i\n\ninteger, intent(in)                 :: ind\ninteger, dimension(3), intent(in)   :: n  ! = (nx,ny,nz)\ninteger, dimension(3)               :: x  ! = (i,j,k)\n\n! ...\ninteger residual\n!ind = (x(3)-1)*n(2)*n(1) + (x(2)-1)*n(1) + x(1)\nx(1) = mod(ind-1,n(1)) + 1\n\nresidual = (ind - x(1))/n(1) + 1\nx(2) = mod(residual-1,n(2)) + 1\n\nx(3) = (residual - x(2))/n(2) + 1\n\nend function index2coords\n"}, {"instruction": "Create a Fortran function named num_of_lines that takes a file path as input and returns the number of lines in the file. The number of input arguments is 1 and the test_data type is ['character (len = *)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "      function num_of_lines(path_to_file) result(line_num)\n\n      character (len = *), intent(in) :: path_to_file\n\n      integer :: file_unit, line_num, io\n\n      file_unit = 13745\n     \n      open(unit = file_unit, file = path_to_file, action = 'read')\n\n      line_num = 0; io = 0\n\n      do while (io .eq. 0)\n\n         read(file_unit, *, iostat = io)\n\n         if (io .ne. 0) exit\n\n         line_num = line_num + 1\n\n      enddo\n\n      close(file_unit)\n\n      return\n\n      end function num_of_lines\n"}, {"instruction": "Create a Fortran function named cross_product_sngl to calculate the cross product of two 3-dimensional vectors. The function takes two input parameters, both of type real (kind=4) and dimension 3. The output is a single 3-dimensional real (kind=4) array.", "input": "", "output": "  function cross_product_sngl( a, b )\r\n    real (kind=4), dimension( 3 ) :: cross_product_sngl\r\n    real (kind=4), dimension( 3 ), intent(  in ) :: a, b\r\n\r\n    cross_product_sngl( 1 ) = a( 2 ) * b( 3 ) - a( 3 ) * b( 2 )\r\n    cross_product_sngl( 2 ) = a( 3 ) * b( 1 ) - a( 1 ) * b( 3 )\r\n    cross_product_sngl( 3 ) = a( 1 ) * b( 2 ) - a( 2 ) * b( 1 )\r\n\r\n  end function cross_product_sngl\r\n"}, {"instruction": "Create a Fortran function named combinations to calculate the number of combinations of a given number of items. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is labeled as num_items and the output parameter is labeled as num_combinations.", "input": "", "output": "    pure recursive function combinations(num_items) result(num_combinations)\n        integer, intent(in) :: num_items\n        integer :: num_combinations\n\n        if (num_items <= 1) then\n            num_combinations = 0\n        else\n            num_combinations = num_items - 1 + combinations(num_items - 1)\n        end if\n    end function\n"}, {"instruction": "Create a Fortran function named random_string that generates a random string composed of specified characters of a given length. The function takes 2 input parameters of types 'character(len=*)' and 'integer', and has 1 output parameter of type 'character(len=:),allocatable'.", "input": "", "output": "     function random_string(chars,length) result(out)\n\n     !$@(#) m_random::random_string(3f): create random string composed of provided characters of specified length\n\n     character(len=*),intent(in)     :: chars\n     integer,intent(in)              :: length\n     character(len=:),allocatable    :: out\n        real                         :: x\n        integer                      :: ilen   ! length of list of characters\n        integer                      :: which\n        integer                      :: i\n        ilen=len(chars)\n        out=''\n        if(ilen.gt.0)then\n           do i=1,length\n              call random_number(x)\n              which=nint(real(ilen-1)*x)+1\n              out=out//chars(which:which)\n           enddo\n        endif\n     end function random_string\n"}, {"instruction": "Create a Fortran function named \"ksicr\" to determine the relationship between two line segments based on their coordinates. The function takes 4 input parameters of type real(8): x1, y1, x2, and y2. It returns 1 output parameter of type integer.", "input": "", "output": "function ksicr (x1,y1,x2,y2)\n  implicit none\n  integer :: ksicr\n  real(8) :: x1,x2,y1,y2\n  if (y1*y2 .gt. 0.0) goto 600\n\n  if (x1*y2 .ne. x2*y1 .or. x1*x2 .gt. 0.0) goto 100\n\n  ksicr = 4\n  return\n\n100 if (y1*y2 .lt. 0.0) goto 300\n  if (y2.eq.0.0) goto 200\n  if (x1.gt.0.0) goto 600\n  if (y2.gt.0.0) goto 700\n  goto 800\n\n200 if (y1.eq.0.0 .or. x2.gt.0.0) goto 600\n  if (y1.gt.0.0) goto 800\n  goto 700\n\n300 if (y1.gt.0.0) goto 400\n  if (x1*y2 .ge. y1*x2) goto 600\n  ksicr = 2\n  return\n\n400 if (y1*x2.ge.x1*y2) goto 600\n  ksicr = -2\n  return\n\n600 ksicr = 0\n  return\n\n700 ksicr = 1\n  return\n\n800 ksicr = -1\n  return\n\nend function ksicr\n"}, {"instruction": "Create a Fortran function named eos3_ss to calculate the speed of sound using the provided equation. The function takes 5 input parameters of type real*8: gam, p_c, arho, al, apr. It returns a single output parameter of type real*8.", "input": "", "output": "function eos3_ss(gam, p_c, arho, al, apr)\n\nreal*8, intent(in) :: gam, p_c, arho, al, apr\n\nreal*8  :: pre, eos3_ss\n\n    pre = max(apr+al*p_c, 1.0d-14);\n    if (arho .lt. 1.0d-16) then\n      if (al .le. 100.0*g_alphamin) then\n        eos3_ss = 0.0\n      else\n        write(*,*) \"error: zero/negative density encountered in speed of sound calculation: \", arho\n        write(*,*) \"  volume-fraction: \", al\n        call exit\n      end if\n    else\n      eos3_ss = dsqrt(gam *pre/arho);\n    end if\n\nend function\n"}, {"instruction": "Create a Fortran function named set_y_plus to calculate the dimensionless distance from the wall (y_plus) using the given inputs. The function has 4 input parameters with test_data type ['double precision', 'double precision', 'double precision', 'double precision'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "    function set_y_plus(rho_w, mu_w, dudy_w, y) result(y_plus)\n        implicit none\n        double precision, intent(in) :: rho_w, mu_w, dudy_w, y   ! \u58c1\u8868\u9762\u3067\u306e\u5bc6\u5ea6\uff0c\u305b\u3093\u65ad\u5fdc\u529b\uff0c\u7c98\u6027\u4fc2\u6570\uff0c\u58c1\u304b\u3089\u306e\u5782\u76f4\u8ddd\u96e2\n        double precision :: y_plus\n\n        y_plus = sqrt(rho_w / mu_w * dudy_w) * y ! \u5b9a\u7fa9\u78ba\u8a8d!\n\n        return\n    end function set_y_plus\n"}, {"instruction": "Create a Fortran function named \"f\" that computes a mathematical expression involving the given input parameters. The function takes 2 input arguments of type double precision (t, x) and returns 1 output argument of type double precision.", "input": "", "output": "  function f(t,x) result(r)\n    double precision :: t, x\n    double precision :: r\n\n    r = (peak_h - ambient_h) * (t0 / (t+t0)) * &\n         dexp(-x / (four * diffusion_coefficient * (t+t0))) + ambient_h\n\n  end function f\n"}, {"instruction": "Create a Fortran function named e_electronic that calculates the electronic energy based on the density matrix, fock operator, and core Hamiltonian matrices. The function should have 4 input parameters of types integer, real*8, and dimension(kf,kf), and 1 output parameter of type real*8.", "input": "", "output": "        function e_electronic(kf,p,f,h) result(e_el)\n            ! -\n            !\n            ! -\n            !\n            ! source:\n            !   a. szabo and n. ostlund\n            !\n            ! -\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf\n            real*8, dimension(kf,kf), intent(in) :: p   ! density matrix\n            real*8, dimension(kf,kf), intent(in) :: f   ! fock operator\n            real*8, dimension(kf,kf), intent(in) :: h   ! core hamiltonian\n\n            ! intermediate variables\n            integer :: i, j                             ! loop indices\n\n            ! output\n            real*8 :: e_el                              ! electronic energy\n\n            e_el = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    e_el = e_el + 0.5d0 * p(j,i) * (h(i,j) + f(i,j))\n                end do\n            end do\n\n        end function e_electronic\n"}, {"instruction": "Create a Fortran function named e_electronic_spin to calculate the electronic energy based on given input parameters. The function takes 6 input parameters of types integer, real*8 arrays of dimensions kf x kf, and outputs a real*8 value.", "input": "", "output": "        function e_electronic_spin(kf,pa,fa,pb,fb,h) result(e_el)\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf\n            real*8, dimension(kf,kf), intent(in) :: pa      ! density matrix (alpha spin)\n            real*8, dimension(kf,kf), intent(in) :: pb      ! density matrix (beta spin)\n            real*8, dimension(kf,kf), intent(in) :: fa      ! fock operator (alpha spin)\n            real*8, dimension(kf,kf), intent(in) :: fb      ! fock operator (beta spin)\n            real*8, dimension(kf,kf), intent(in) :: h       ! core hamiltonian\n\n            ! intermediate variables\n            integer :: i, j                                 ! loop indices\n            real*8, dimension(kf,kf) :: ptot                ! total density matrix\n\n            ! output\n            real*8 :: e_el                              ! electronic energy\n\n            ptot = pa + pb\n\n            e_el = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    e_el = e_el + ptot(j,i) * h(i,j) + pa(j,i) * fa(i,j) + pb(j,i) * fb(i,j)\n                end do\n            end do\n\n            e_el = 0.5d0 * e_el\n\n        end function e_electronic_spin\n"}, {"instruction": "Create a Fortran function named e_nuclear to calculate the nuclear energy based on the total number of nuclei, nuclear charges, and nuclear positions. The number of input arguments is 3, and the test_data type is [integer, integer array, real*8 2D array]. The number of output arguments is 1, and the test_data type is [real*8].", "input": "", "output": "        function e_nuclear(nn,rn,zn) result(e_nu)\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: nn                       ! total number of nuclei\n            integer, dimension(nn), intent(in) :: zn        ! nuclear charges\n            real*8, dimension(nn,3), intent(in) :: rn       ! nuclear positions\n\n            ! intermediate variables\n            integer :: i, j                 ! loop variables\n\n            ! output\n            real*8 :: e_nu                  ! nuclear energy\n\n            e_nu = 0.0d0\n\n            do i = 1, nn\n                do j = i + 1, nn\n                    e_nu = e_nu + zn(i) * zn(j) / norm2(rn(i,1:3) - rn(j,1:3))\n                end do\n            end do\n\n        end function e_nuclear\n"}, {"instruction": "Provide a Fortran function named factorial to calculate the factorial of a given integer. The function accepts 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "    recursive function factorial(n) result(f)\n        implicit none\n        integer, intent(in) :: n\n        integer :: f\n        if (n < 2) then\n            f = 1\n        else\n            f = n*factorial(n - 1)\n        end if\n    end function factorial\n"}, {"instruction": "Create a Fortran function named square to calculate the square of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of type integer.", "input": "", "output": "    function square(x) result(res)\n        implicit none\n        integer, intent(in) :: x\n        integer :: res\n        !integer, intent(out) :: res\n        res = x * x \n    end function square \n"}, {"instruction": "Create a Fortran function named to_upper to convert a given string to uppercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(strin)).", "input": "", "output": "    function to_upper(strin) result(strout)\n!\n!   original author: clive page\n!   utility code for conversion to upper case \n!\n     implicit none\n\n     character(len=*), intent(in) :: strin\n     character(len=len(strin)) :: strout\n     integer :: i,j\n\n     do i = 1, len(strin)\n          j = iachar(strin(i:i))\n          if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n               strout(i:i) = achar(iachar(strin(i:i))-32)\n          else\n               strout(i:i) = strin(i:i)\n          end if\n     end do\n\n    end function to_upper\n"}, {"instruction": "Write a Fortran function named bigtolittle that takes one input parameter of type integer(kind=4) and returns one output parameter of the same type. The function swaps the byte order of the input integer from big endian to little endian and assigns the result to the output parameter.", "input": "", "output": "function bigtolittle(i)\r\ninteger(kind=4), intent(in):: i\r\ninteger(kind=4):: bigtolittle\r\ninteger(kind=4):: j\r\ncall mvbits(i, 0, 8, j, 24)\r\ncall mvbits(i, 8, 8, j, 16)\r\ncall mvbits(i,16, 8, j,  8)\r\ncall mvbits(i,24, 8, j,  0)\r\nbigtolittle= j\r\nend function\r\n"}, {"instruction": "Create a Fortran function named fib that calculates the Fibonacci sequence with an input parameter of type integer and output parameter of type integer. The function should use recursion to compute the result.", "input": "", "output": "recursive function fib(n) result(r)\n!$omp declare simd(fib) inbranch\n   implicit none\n   integer  :: n, r\n\n   if (n <= 1) then\n      r = n\n   else \n      r = fib(n-1) + fib(n-2)\n   endif\n\nend function fib\n"}, {"instruction": "Write a Fortran function named model_function that takes two input arguments of type character(len=*) and character(len=:), pointer, and returns one output argument of type logical. The function copies the input string to the output string and prints the length of the output string.", "input": "", "output": "function model_function(inputa, outputa) result(out)\n  character(len=*), intent(in) :: inputa\n  character(len=:), pointer :: outputa\n  logical :: out\n  out = .true.\n  allocate(character(len=len(inputa)) :: outputa)\n  outputa = inputa\n  write(*, '(\"model a: \",a,\" (length = \",i3,\")\")') outputa, len(outputa)\nend function model_function\n"}, {"instruction": "Write a Fortran function named trim that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len_trim(x)).", "input": "", "output": "function trim(x) result(r)\ncharacter(len=*),intent(in) :: x\ncharacter(len=len_trim(x)) :: r\ninteger :: i\ndo i = 1, len(r)\n    r(i:i) = x(i:i)\nend do\nend function\n"}, {"instruction": "Create a Fortran function named smoothstep1 that takes a single real input argument. The input test_data type is ['real']. The function must return a single real value as the output. The purpose of this function is to compute the smoothstep1 function, which is defined as x * x * (3 - 2 * x).", "input": "", "output": "   pure function smoothstep1(x)\n      implicit none\n      real :: smoothstep1\n      real, intent(in) :: x\n      smoothstep1 = x * x * (3 - 2 * x)\n   end function smoothstep1\n"}, {"instruction": "Create a Fortran function named smoothstep2 to calculate the smoothstep2 function of a given real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter should be passed using the intent(in) attribute.", "input": "", "output": "   pure function smoothstep2(x)\n      implicit none\n      real :: smoothstep2\n      real, intent(in) :: x\n      smoothstep2 = x * x * x * (x * (x * 6 - 15) + 10)\n   end function smoothstep2\n"}, {"instruction": "Write a Fortran function named pascaltriangle to calculate the value of a specific entry in Pascal's triangle. The function has 2 input parameters of type integer. The test_data type for input parameters is ['integer', 'integer']. The function returns 1 output parameter of type integer, with the test_data type being ['integer'].", "input": "", "output": "   pure function pascaltriangle(a, b)\n      implicit none\n      integer :: pascaltriangle\n      integer, intent(in) :: a, b\n      integer i\n      pascaltriangle = 1\n      do i = 0, b - 1\n         pascaltriangle = pascaltriangle * (a - i) / (i + 1)\n      end do\n   end function pascaltriangle\n"}, {"instruction": "Create a Fortran function named realexp that computes the exponential value of a real number raised to an integer power. The function takes 2 input parameters of type real and integer, and returns 2 output parameters of type real and realexp.", "input": "", "output": "  function realexp (base, exponent)\n    real :: realexp\n    real, intent(in) :: base\n    integer, intent(in) :: exponent\n    integer :: i\n\n    realexp = 1.0\n    if (exponent < 0) then\n       do i = exponent, -1\n          realexp = realexp / base\n       end do\n    else\n       do i = 1, exponent\n          realexp = realexp * base\n       end do\n    end if\n  end function realexp\n"}, {"instruction": "Create a Fortran function named factorial_good to calculate the factorial of a given integer.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    function factorial_good(n) result(f)\n        implicit none\n        integer, intent(in) :: n\n        integer :: f\n        integer :: fac, i\n        fac = 1\n        do i = 2, n\n            fac = fac*i\n        end do\n        f = fac\n    end function factorial_good\n"}, {"instruction": "Create a Fortran function named func to calculate the sine of 1.0 divided by the input parameter. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function func(x)\n        implicit none\n        real :: func\n        real, intent(in) :: x\n\n        func = sin(1.0 / x) ! strongly oscillating, needs many intervals\n        return\n    end function func\n"}, {"instruction": "Create a Fortran recursive function named greatest_common_factor to calculate the greatest common factor of two integers. The function should take 2 input arguments of type integer and return 1 output argument of type integer.", "input": "", "output": "  recursive function greatest_common_factor(a, b) result (gcf)\n    integer, intent(in) :: a, b\n    integer             :: gcf\n    \n    if (b == 0) then\n       gcf = a\n    else\n       gcf = greatest_common_factor(b, mod(a,b))\n    end if\n  end function greatest_common_factor\n"}, {"instruction": "Create a Fortran function named \"to_upper\" that takes a single input argument of type character(*) and returns a single output argument of type character(len(str)). The function should capitalize each lowercase letter in the input string and return the modified string as the output. Use the imperative tone in your instructions.", "input": "", "output": "        pure function to_upper (str) result (string)\n            implicit none\n            character(*), intent(in) :: str\n            character(len(str))      :: string\n\n            integer :: ic, i\n\n            character(26), parameter :: cap = \"abcdefghijklmnopqrstuvwxyz\"\n            character(26), parameter :: low =  \"abcdefghijklmnopqrstuvwxyz\"\n\n            ! capitalize each letter if it is lowecase\n            string = str\n            do i = 1, len_trim(str)\n                ic = index(low, str(i:i))\n                if (ic > 0) string(i:i) = cap(ic:ic)\n            end do\n        end function to_upper\n"}, {"instruction": "Write a Fortran function named angle to calculate the angle between two geographic coordinates given in latitude and longitude. The function takes 4 input parameters of type double precision (lat1i, lon1i, lat2i, lon2i) and returns 1 output parameter of type double precision (angle). The input test_data type is ['double precision', 'double precision', 'double precision', 'double precision'], and the output test_data type is ['double precision'].", "input": "", "output": "function angle(lat1i,lon1i,lat2i,lon2i)\nimplicit none\ndouble precision :: angle\ndouble precision, intent(in) :: lat1i,lon1i,lat2i,lon2i\ndouble precision :: lat1,lon1,lat2,lon2\ndouble precision, parameter :: pi=3.14159265358979323846264338327950288d0\n\nlat1=lat1i*pi/1.8d2 ; lon1=lon1i*pi/1.8d2\nlat2=lat2i*pi/1.8d2 ; lon2=lon2i*pi/1.8d2\n\nangle=atan2( sqrt( (cos(lat2)*sin(lon2-lon1))**2 + (cos(lat1)*sin(lat2) - &\n                   sin(lat1)*cos(lat2)*cos(lon2-lon1))**2) , &\n            sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n\nangle=angle*1.8d2/pi\n\nend function angle\n"}, {"instruction": "Write a Fortran function named vg_se that takes 3 real input parameters, h, a, and n, and returns a real output parameter, se. The function computes the value of se using the formula se = (1 + (a * h)**n)**(-m), where m = 1 - 1 / n.", "input": "", "output": "  elemental function vg_se(h, a, n) result(se)\n    real, intent(in) :: h, a, n\n    real :: m, se\n\n    m = 1. - 1. / n\n    se = (1. + (a * h)**n)**(-m)\n  end function\n"}, {"instruction": "Create a Fortran elemental function named vg_pm to calculate the polarization magnitude of a material. The function takes 3 real input parameters (t, a, n) and returns 1 real output parameter (pm) representing the polarization magnitude.", "input": "", "output": "  elemental function vg_pm(t, a, n) result(pm)\n    real, intent(in) :: t, a, n\n    real :: m, me, pm\n\n    m = 1. - 1. / n\n    me = a * (.046 * m + 2.07 * m**2 + 19.5 * m**3) &\n       / (1. + 4.7 * m + 16. * m**2)\n    pm = 1. / a * (t**(1 / m) - 1.)**(1 / n)\n    pm = max(pm, me)\n  end function\n"}, {"instruction": "Write a Fortran function named vg_kr that calculates the value of kr using the given input parameters. The function has 3 input parameters of type real (t, a, n) and 1 output parameter of type real (kr).", "input": "", "output": "  elemental function vg_kr(t, a, n) result(kr)\n    real, intent(in) :: t, a, n\n    real :: m, kr\n\n    m = 1. - 1. / n\n    kr = sqrt(t) * (1. - (1. - t**(1. / m))**m)**2\n  end function\n"}, {"instruction": "Create a Fortran function named setstvel, which calculates the settling velocity of noncohesive sediment using Van Rijn's equations. The function takes 2 real input parameters (d and ssg) and returns 1 real output parameter (setstvel).", "input": "", "output": "function setstvel(d,ssg)\n\n  ! **  noncoheasive sediment settling and shields criteria\n  ! **  using van rijn's equations\n\n  ! change record\n\n  implicit none\n\n  real :: setstvel,d,ssg,visc,gp,gpd,sqgpd,rd,wset,tmp\n\n  visc=1.d-6\n  gp=(ssg-1.)*9.82\n  gpd=gp*d\n  sqgpd=sqrt(gpd)\n  rd=sqgpd*d/visc\n\n  ! **  settling velocity\n\n  if( d < 1.0e-4 )then\n    wset=sqgpd*rd/18.\n  endif\n  if( d >= 1.0e-4 .and. d < 1.e-3 )then\n    tmp=sqrt(1.+0.01*rd*rd)-1.\n    wset=10.0*sqgpd*tmp/rd\n  endif\n  if( d >= 1.e-3 )then\n    wset=1.1*sqgpd\n  endif\n  setstvel=wset\n\nend function\n"}, {"instruction": "Write a Fortran function named legendre that calculates the Legendre polynomial of degree n at the point x. The function has 2 input parameters of type integer and double precision, and 1 output parameter of type double precision.", "input": "", "output": "recursive function legendre(n, x)result(res)\n! provides p_n(x)\nimplicit none\ninteger, intent(in):: n\ndouble precision, intent(in) :: x\ndouble precision :: res\ninteger :: i\n\nif (n == 0) then\n res = 1.d0\nelse if (n == 1) then\n res = x\nelse\n res = ((2.d0*n-1.d0)*x*legendre(n-1, x)-(n-1)*legendre(n-2, x))/(n*1.d0)\nend if\n!\nend function legendre\n"}, {"instruction": "Write a Fortran function named matrix_combine that combines two nxn matrices into a single 2nxn matrix. The number of input arguments is 3, and the test_data type is [integer, double precision, dimension(n, n), double precision, dimension(n, n)]. The number of output arguments is 1, and the test_data type is [double precision, dimension(2*n, n)].", "input": "", "output": "function matrix_combine( n, mata, matb)result(matab)\nimplicit none\n! combine two nxn matrices\ninteger, intent(in) ::  n\ndouble precision, dimension(n, n), intent(in) :: mata, matb\ndouble precision, dimension(2*n, n) :: matab\n\nmatab(1:n, :) = mata\nmatab(n+1:2*n, : ) = matb\nend function matrix_combine\n"}, {"instruction": "Write a Fortran function named matrix_embed that embeds a smaller square matrix into a larger square matrix at specified row and column positions. The input parameters consist of 5 arguments: n (integer), mata (double precision matrix of size n x n), bign (integer), rpos (integer), and cpos (integer). The output parameter is a double precision matrix of size bign x bign.", "input": "", "output": "function matrix_embed(n, mata, bign, rpos, cpos)result(bigmatrix)\nimplicit none\ninteger, intent(in) :: n, bign, rpos, cpos\ndouble precision, dimension(n, n), intent(in) :: mata\ndouble precision, dimension(bign, bign) :: bigmatrix\nif (rpos+n-1 > bign .or. cpos+n-1 > bign) then\n print*, \"matrix sizes are not fit for embedding ... aborting execusion\"\n stop\nend if\nbigmatrix = 0.d0\nbigmatrix(rpos:, cpos:) =mata\n\nend function matrix_embed\n"}, {"instruction": "Create a Fortran function named repeat that takes an integer n and a double precision number as input. The function returns a double precision array of size n, initialized with the input number.", "input": "", "output": "function repeat(n, number)result(vector)\nimplicit none\ninteger, intent(in) :: n\ndouble precision,intent(in) :: number\ndouble precision, dimension(n) :: vector\nvector = number\nend function repeat\n"}, {"instruction": "Create a Fortran function named combine_vector to merge two arrays into one. The function takes 4 input parameters: na of type integer, va of type double precision array with dimension na, nb of type integer, and vb of type double precision array with dimension nb. The function returns a double precision array of dimension na+nb.", "input": "", "output": "function combine_vector(na, va, nb, vb)result(vab)\nimplicit none\ninteger, intent(in) ::  na, nb\ndouble precision, dimension(na), intent(in) :: va\ndouble precision, dimension(nb), intent(in) :: vb\ndouble precision, dimension(na+nb) :: vab\nvab = 0.d0\nvab(1:na) = va\nvab(na+1:nb+na) = vb\nend function combine_vector\n"}, {"instruction": "Write a Fortran function named clean to process and filter arrays of real numbers representing time, velocity, and wind components. The number of input arguments is 5, and their test_data type is ['real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable']. The number of output arguments is 1, and its test_data type is ['integer'].", "input": "", "output": "    function clean(rvtime, rvu, rvv, rvw, rvt) result(iretcode)\n\t\n        ! routine arguments\n        real, dimension(:), allocatable, intent(inout)  :: rvtime\n        real, dimension(:), allocatable, intent(inout)  :: rvu\n        real, dimension(:), allocatable, intent(inout)  :: rvv\n        real, dimension(:), allocatable, intent(inout)  :: rvw\n        real, dimension(:), allocatable, intent(inout)  :: rvt\n        integer                                         :: iretcode\n\t\t\n        ! locals\n        integer                         :: inumvalid\n        real, dimension(:), allocatable :: rvnewtime\n        real, dimension(:), allocatable :: rvnewu\n        real, dimension(:), allocatable :: rvnewv\n        real, dimension(:), allocatable :: rvneww\n        real, dimension(:), allocatable :: rvnewt\n        integer                         :: i\n        integer                         :: j\n\t\t\n        ! assume success (will falsify on failure)\n        iretcode = 0\n\t\t\n        ! check parameters (minimal)\n        if( &\n            .not.allocated(rvtime) .or. &\n            .not.allocated(rvu) .or. &\n            .not.allocated(rvv) .or. &\n            .not.allocated(rvw) .or. &\n            .not.allocated(rvt) &\n        ) then\n            iretcode = 1\n            return\n        end if\n        if(size(rvtime) <= 0 .or. size(rvu) <= 0 .or. size(rvv) <= 0 .or. size(rvw) <= 0 .or. size(rvt) <= 0) then\n            iretcode = 2\n            return\n        end if\n\t\t\n\t\t! transfer valid data\n        inumvalid = count(rvu > -9990.)\n        if(inumvalid <= 0) then\n            iretcode = 2\n            return\n        end if\n        allocate(rvnewtime(inumvalid))\n        allocate(rvnewu(inumvalid))\n        allocate(rvnewv(inumvalid))\n        allocate(rvneww(inumvalid))\n        allocate(rvnewt(inumvalid))\n        j = 0\n        do i = 1, size(rvtime)\n            if(rvu(i) > -9990.0) then\n                j = j + 1\n                rvnewtime(j) = rvtime(i)\n                rvnewu(j)    = rvu(i)\n                rvnewv(j)    = rvv(i)\n                rvneww(j)    = rvw(i)\n                rvnewt(j)    = rvt(i)\n            end if\n        end do\n\t\t\n    end function clean\n"}, {"instruction": "Create a Fortran function named \"mean\" to calculate the averages of signal values over specified time intervals. The function should have 5 input parameters of types real, dimension(:), real, real, dimension(:), allocatable, and real, dimension(:), allocatable. The output should be an integer.", "input": "", "output": "    function mean(rvtime, rvx, rdeltatime, rvavgtime, rvavgx) result(iretcode)\n\t\n        ! routine arguments\n        real, dimension(:), intent(in)                  :: rvtime       ! sequence of seconds in hour (not necessarily in ascending order)\n        real, dimension(:), intent(in)                  :: rvx          ! signal values corresponding to the times\n        real, intent(in)                                :: rdeltatime   ! time step (must be strictly positive)\n        real, dimension(:), allocatable, intent(out)    :: rvavgtime    ! seconds at beginning of each averaging step\n        real, dimension(:), allocatable, intent(out)    :: rvavgx       ! averages, on every time step\n        integer                                         :: iretcode     ! return code (0 = ok, non-zero = some problem)\n\t\t\n        ! locals\n        integer                             :: inumsteps\n        integer, dimension(:), allocatable  :: ivnumdata\n        integer                             :: i\n        integer                             :: iindex\n\t\t\n        ! assume success (will falsify on failure)\n        iretcode = 0\n\t\t\n        ! check parameters\n        if(size(rvtime) <= 0 .or. size(rvtime) /= size(rvx) .or. rdeltatime <= 0.) then\n            iretcode = 1\n            return\n        end if\n\t\t\n        ! compute number of steps and use it to reserve workspace\n        inumsteps = ceiling(3600. / rdeltatime)\n        allocate(ivnumdata(inumsteps), rvavgx(inumsteps), rvavgtime(inumsteps))\n        ivnumdata = 0\n        rvavgx    = 0.\n\t\t\n        ! sum step values\n        do i = 1, size(rvtime)\n            iindex = floor(rvtime(i) / rdeltatime) + 1\n            ivnumdata(iindex) = ivnumdata(iindex) + 1\n            rvavgx(iindex)    = rvavgx(iindex) + rvx(i)\n        end do\n\t\t\n\t\t! render averages\n        do i = 1, inumsteps\n            if(ivnumdata(i) > 0) then\n                rvavgx(i) = rvavgx(i) / ivnumdata(i)\n            else\n                rvavgx(i) = -9999.9\n            end if\n        end do\n\n        ! compute time values\n        rvavgtime = [(i*rdeltatime, i=0, inumsteps-1)]\n\t\t\n    end function mean\n"}, {"instruction": "Create a Fortran function named \"cov\" to calculate the covariance of two signals over time. The function takes 6 input parameters of types ['real, dimension(:)', 'real, dimension(:)', 'real, dimension(:)', 'real', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable'], and 1 output parameter of type ['integer'].", "input": "", "output": "    function cov(rvtime, rvx, rvy, rdeltatime, rvavgtime, rvcovxy) result(iretcode)\n\n        ! routine arguments\n        real, dimension(:), intent(in)                  :: rvtime       ! sequence of seconds in hour (not necessarily in ascending order)\n        real, dimension(:), intent(in)                  :: rvx          ! signal values x corresponding to the times\n        real, dimension(:), intent(in)                  :: rvy          ! signal values y corresponding to the times\n        real, intent(in)                                :: rdeltatime   ! time step (must be strictly positive)\n        real, dimension(:), allocatable, intent(out)    :: rvavgtime    ! seconds at beginning of each averaging step\n        real, dimension(:), allocatable, intent(out)    :: rvcovxy      ! covariance, on every time step\n        integer                                         :: iretcode     ! return code (0 = ok, non-zero = some problem)\n        \n        ! locals\n        integer                             :: inumsteps\n        integer, dimension(:), allocatable  :: ivnumdata\n        real, dimension(:), allocatable     :: rvsumx\n        real, dimension(:), allocatable     :: rvsumy\n        real, dimension(:), allocatable     :: rvsumxy\n        integer                             :: i\n        integer                             :: iindex\n        \n        ! assume success (will falsify on failure)\n        iretcode = 0\n        \n        ! check parameters\n        if(size(rvtime) <= 0 .or. size(rvtime) /= size(rvx) .or. size(rvtime) /= size(rvy) .or. rdeltatime <= 0.) then\n            iretcode = 1\n            return\n        end if\n        \n        ! compute number of steps and use it to reserve workspace\n        inumsteps = ceiling(3600. / rdeltatime)\n        allocate(ivnumdata(inumsteps), rvcovxy(inumsteps), rvavgtime(inumsteps))\n        allocate(rvsumx(inumsteps), rvsumy(inumsteps), rvsumxy(inumsteps))\n        ivnumdata = 0\n        rvsumx    = 0.\n        rvsumy    = 0.\n        rvsumxy   = 0.\n        \n        ! sum step values\n        do i = 1, size(rvtime)\n            iindex = floor(rvtime(i) / rdeltatime) + 1\n            ivnumdata(iindex) = ivnumdata(iindex) + 1\n            rvsumx(iindex)    = rvsumx(iindex)  + rvx(i)\n            rvsumy(iindex)    = rvsumy(iindex)  + rvy(i)\n            rvsumxy(iindex)   = rvsumxy(iindex) + rvx(i)*rvy(i)\n        end do\n        \n        ! render averages\n        do i = 1, inumsteps\n            if(ivnumdata(i) > 0) then\n                rvcovxy(i) = (rvsumxy(i)/ivnumdata(i) - (rvsumx(i)/ivnumdata(i))*(rvsumy(i)/ivnumdata(i)))\n            else\n                rvcovxy(i) = -9999.9\n            end if\n        end do\n        \n        ! compute time values\n        rvavgtime = [(i*rdeltatime, i=0, inumsteps-1)]\n        \n        ! leave orderly\n        deallocate(rvsumx, rvsumy, rvsumxy)\n        \n    end function cov\n"}, {"instruction": "Write a Fortran function named \"intentoutfunc\" that assigns the value 216 to the output parameter \"dummyarg\" and returns the value 343. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  function intentoutfunc(dummyarg)\n    integer, intent(out) :: dummyarg\n    integer  :: intentoutfunc\n\n    dummyarg = 216\n    intentoutfunc = 343\n  end function intentoutfunc\n"}, {"instruction": "Create a Fortran function named intentinoutfunc that takes an integer argument and returns an integer. The input argument is of type integer, and the output is also of type integer. The function sets the input argument to 216 and returns 343.", "input": "", "output": "  function intentinoutfunc(dummyarg)\n    integer, intent(inout) :: dummyarg\n    integer  :: intentinoutfunc\n\n    dummyarg = 216\n    intentinoutfunc = 343\n  end function intentinoutfunc\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  recursive function factorial(i) result (rs)\n    integer :: rs\n    integer, intent(in) :: i\n    if ( i <= 1 ) then\n      rs = 1\n    else\n      rs = i * factorial(i - 1)\n    end if\n  end function factorial\n"}, {"instruction": "Write a Fortran function named calcthmmks to calculate theta based on the input arrays x2 and x1. The number of input arguments is 2, and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1, and the test_data type is ['real, dimension(size(x2))']. Use the imperative tone to instruct the use of this function.", "input": "", "output": "        function calcthmmks(x2,x1) result(theta)\n          real, intent(in), dimension(:) :: x2, x1\n          real, dimension(size(x2)) :: theta,thetag,thetaj,d\n          real :: a,b,c\n          a=mks_smooth\n          b=poly_xt\n          c=poly_alpha\n          thetag=pi*x2+(1.-hslope)/2.*sin(2.*pi*x2)\n          thetaj=d*(2.*x2-1.)*(1.+((2.*x2-1.)/b)**c/(1.+c))+pi/2.\n          d=pi/(2.+2./(b**c+c*b**c))\n          theta=thetag+exp(-a*d*x1)\n        end function calcthmmks\n"}, {"instruction": "Write a Fortran function named output_terminal that takes a character string as input and returns another character string. The input parameter should have a length of any size, and the output parameter should have a length of 35 characters.", "input": "", "output": "\tfunction output_terminal(terminal) result(f_result)\n!***********************************************************************************\n\timplicit none\n\tcharacter(len=*),intent(in)\t:: terminal\n\tinteger, parameter\t\t:: nc=35\n\tcharacter(len=nc)\t\t:: f_result\n!***********************************************************************************\n\tselect case(terminal)\n\t\tcase('ps')\n\t\t\tf_result='postscript landscape color'\n\t\tcase default\n\t\t\tf_result=terminal\n\tend select\n!***********************************************************************************\n\tend function output_terminal\n"}, {"instruction": "Write a Fortran function called hdgrid_fdir_kernel that calculates the flow direction based on a 3x3 input orography section provided as a one-dimensional array. The input parameter is a real*8 array with dimensions (1:9), and the output parameter is a real*8 value. If multiple minimum values exist, the function selects the first unless there is another one in the center of the cell, in which case the flow direction is set to 5 (a sink point).", "input": "", "output": "function hdgrid_fdir_kernel(orog_section) result(flow_direction)\n\n!kernel for find the flow direction (given as a number from 1-9 according to\n!the directions given by a numeric keypad on a keyboard; this number must be\n!have type float64/real*8 even though it only ever takes integer values to\n!satify type checking. if muliply mimimum occur then take the first unless\n!there is another one in the centre of the cell in which case set flow to 5\n!(a sink point)\n\n!note: should ideally replace real*8 with a more modern select_real_kind based\n!kind specification\n\nimplicit none\n\n!variables with intent in\n!a 3 by 3 input orography section flattened into a single dimensional array\nreal*8, intent(in), dimension(1:9) :: orog_section\n\n!local variables\ninteger :: i               !a counter\ninteger :: min_coord       !the coordinate of the minimum value\nreal*8  :: flow_direction  !the calculated flow direction to return\n!the flow directions; simply an array initialised with counting numbers\nreal*8, dimension(1:9) :: flow_directions = [(real(i,8),i=1,9)]\n\n !find the location of the first minimum in orog_section\n min_coord = minloc(orog_section,1)\n !and use that as an index to find the flow direction\n flow_direction = flow_directions(min_coord)\n !check if this grid cell is also a minimum\n if ( orog_section(5) == minval(orog_section) ) then\n    flow_direction = 5\n end if\n\nend function hdgrid_fdir_kernel\n"}, {"instruction": "Write a Fortran function named ticker to determine the type of character to be used for a progress indicator. The function takes 1 input parameter of type integer and returns 1 output parameter of type character. The input test_data type is ['integer'], and the output test_data type is ['character'].", "input": "", "output": "  pure function ticker(ncall) result(t)\n    implicit none\n    integer, intent(in) :: ncall\n    character :: t\n    select case(modulo(ncall,4))\n    case(0)\n       t='|'\n    case(1)\n       t='/'\n    case(2)\n       t='-'\n    case(3)\n       t=achar(92) !the backslash\n    end select\n  end function ticker\n"}, {"instruction": "Create a Fortran function named bad_factorial to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "function bad_factorial(n) result(nfac)\r\ninteger, intent(in) :: n\r\ninteger             :: nfac\r\ninteger             :: j\r\ninteger             :: i = 1 ! has same effect as line below\r\n! integer, save       :: i = 1\r\ndo j=2,n\r\n   i = i*j\r\nend do\r\nnfac = i\r\nend function bad_factorial\r\n"}, {"instruction": "Create a Fortran pure function named str that converts an integer into a character string. The function takes 1 input argument of type integer and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "  pure function str(x) result(y)\n    integer, intent(in) :: x\n    character(:), allocatable :: y\n    character(128) :: tmp\n    write(tmp, '(g0)') x\n    y = trim(tmp)\n  end function str\n"}, {"instruction": "Write a Fortran function named detect_ncol_in_buf to determine the number of columns in a character buffer. The function takes 1 input parameter of type character(len=240) and returns 1 output parameter of type integer.", "input": "", "output": "function detect_ncol_in_buf(buf) result(ncol)\n implicit none\n integer :: i, ncol\n character(len=24), allocatable :: sbuf(:)\n character(len=240), intent(in) :: buf\n\n if(len_trim(buf) == 0) then\n  ncol = 0\n  return\n end if\n\n ncol = 1\n do while(.true.)\n  allocate(sbuf(ncol))\n  read(buf,*,iostat=i) sbuf(1:ncol)\n  deallocate(sbuf)\n  if(i /= 0) exit\n  ncol = ncol + 1\n end do ! for while\n\n ncol = ncol - 1\n return\nend function detect_ncol_in_buf\n"}, {"instruction": "Write a Fortran recursive function named binom to calculate the binomial coefficient \"n choose r\" where n and r are input integers. The function returns a real*8 value as the result. The number of input parameters is 2 and the test_data type is ['integer', 'integer'], while the number of output parameters is 1 with the test_data type being ['real*8'].", "input": "", "output": "      recursive function binom(n,r) result(res)\n        implicit none\n        integer :: n,r\n        real*8 :: res\n        real*8 :: tmp\n\n        if(n==r .or. r==0) then\n           res = 1.0\n        else if (r==1) then\n           res = real(n)\n        else\n           res = real(n)/real(n-r)*binom(n-1,r)\n        end if\n      end function binom\n"}, {"instruction": "Create a Fortran function named ran0 to generate a random number using the combined Marsaglia shift sequence and Park-Miller sequence. The function should accept 1 input argument of type integer(k4b) and return 1 output argument of type real.", "input": "", "output": "function ran0(idum)\n!----\n! random number generator from numerical recipes in fortran 90, press et al.\n!----\n\nimplicit none\n\n! arguments\nreal :: ran0\ninteger, parameter :: k4b = selected_int_kind(9)\ninteger(k4b), intent(inout) :: idum\n\n! local variables\ninteger(k4b), parameter :: ia=16807\ninteger(k4b), parameter :: im=2147483647\ninteger(k4b), parameter :: iq=127773\ninteger(k4b), parameter :: ir=2836\nreal, save :: am\ninteger(k4b), save :: ix = -1\ninteger(k4b), save :: iy = -1\ninteger(k4b), save :: k\n\n! initialize\nif (idum.le.0.or.iy.lt.0) then\n    am = nearest(1.0,-1.0)/real(im)\n    iy = ior(ieor(888889999,abs(idum)),1)\n    ix = ieor(777755555,abs(idum))\n\n    ! set idum positive\n    idum = abs(idum)+1\nendif\n\n! marsaglia shift sequence with period 2^32\u22121\nix = ieor(ix,ishft(ix,13))\nix = ieor(ix,ishft(ix,-17))\nix = ieor(ix,ishft(ix,5))\n\n! park-miller sequence by schrage\u2019s method, period 2^31\u22122.\nk = iy/iq\niy = ia*(iy-k*iq)-ir*k\nif (iy.lt.0) then\n    iy = iy+im\nendif\n\n! combine the two generators with masking to ensure nonzero value\nran0 = am*ior(iand(im,ieor(ix,iy)),1)\n\nend function\n"}, {"instruction": "Provide a Fortran function named myadd to calculate the sum of two integer numbers. The function should have 2 input parameters of type integer and 1 output parameter of type integer. When using this function, provide two integer numbers as input arguments, and the function will return their sum as the output.", "input": "", "output": "function myadd(iarg1, iarg2)\n  implicit none\n  integer :: myadd\n  integer, intent(in) :: iarg1, iarg2\n  myadd = iarg1 + iarg2\nend function myadd\n"}, {"instruction": "Create a Fortran function named is_digit to check if a given character is a digit. The function takes 1 input parameter of type character and returns 1 output parameter of type logical. The input parameter should be tested for the type 'character' and the output parameter for the type 'logical'.", "input": "", "output": "function is_digit(str)  result(res)\n  character     ,intent(in)     ::      str                                                                     !< input character string to be checked for didgits\n  logical                       ::      res                                                                     !< output indicator whether of not the input character is a number\n  select case   (str)\n  case  ('0':'9')\n    res =       .true.\n  case default\n    res =       .false.\n  end select\nend function\n"}, {"instruction": "Create a Fortran function named logical_to_string_0d that takes a single input parameter of type logical. The output is a character string. If the input logical value is true, the function returns \"t\"; otherwise, it returns \"f\".", "input": "", "output": "pure function logical_to_string_0d( var ) result(str)\n  logical                                               ,intent(in)     ::      var                             !< logical to be converted into a string\n  character(:)  ,allocatable                                            ::      str                             !< character corresponding to the input number\n  if ( var ) then\n    str =       \"t\"\n  else\n    str =       \"f\"\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named length_from_format to determine the length of a format string. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type integer.", "input": "", "output": "pure function length_from_format( fmt ) result(length)\n  character(*)                                          ,intent(in)     ::      fmt\n  integer                                                               ::      length\n  character(1)  ::      cdum\n  length        =       0\n  cdum  =       fmt\nend function\n"}, {"instruction": "Create a Fortran function named is_a_number to check if a given string is a valid numeric value. The function should take 1 input parameter of type character(*) and return 1 output parameter of type logical.", "input": "", "output": "pure function is_a_number( string )\n  character(*)                                  ,intent(in)     ::      string                                  !< string to be checked for validity as a numeric\n  logical                                                       ::      is_a_number                              !< indicator of numeric value stored in the input string\n  real(8)                                                       ::      number\n  integer                                                       ::      ios\n  read(string,*,iostat=ios) number                                                                                         ! converting the input string into a real number\n  is_a_number    =  ( ios == 0 )\nend function\n"}, {"instruction": "Write a Fortran function named get_triangular_number to compute the triangular number given two input integers, nstates and nranks. The number of input parameters is 2 and the test_data type is ['integer', 'integer']. The number of output parameters is 1 and the test_data type is ['integer'].", "input": "", "output": "    function get_triangular_number(nstates, nranks) result(triangular_number)\n        integer, intent(in) :: nstates, nranks\n        integer :: triangular_number\n\n        integer :: idx\n\n        triangular_number = nstates\n        do idx = 1, nranks-1\n            triangular_number = triangular_number*(nstates+idx)\n        end do\n\n        do idx = nranks, 2, -1\n            triangular_number = triangular_number/idx\n        end do\n    end function get_triangular_number\n"}, {"instruction": "Create a Fortran function named count_collatz that takes an integer input parameter and returns the number of steps required to reach the value 1 in the Collatz sequence. The input parameter is of type integer(4), and the output parameter is also of type integer(4).", "input": "", "output": "  pure function count_collatz(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(4)             :: count_collatz\n\n    ! local variables\n    integer(4) :: nsteps\n    integer(8) :: n1\n\n    ! compute length of collatz chain\n    n1     = n\n    nsteps = 0\n    do while (n1 /= 1)\n       if (mod(n1,2)==0) then\n          n1 = n1/2\n       else\n          n1 = 3*n1+1\n       endif\n       nsteps = nsteps + 1\n    enddo\n\n    count_collatz = nsteps\n    return\n  end function count_collatz\n"}, {"instruction": "Write a Fortran function named iseq_v to compare each element of a double precision vector with a scalar value, using a specified tolerance level. The number of input arguments is 3, and the test_data type is ['double precision, dimension(:)', 'double precision', 'integer']. The number of output arguments is 1, and the test_data type is ['logical, dimension(size(x1))'].", "input": "", "output": "function iseq_v(x1,x2,n) !comparison between a vector and a scalar\n\timplicit none\n\tdouble precision, dimension(:), intent(in) :: x1\n\tdouble precision, intent(in) :: x2\n\tinteger, intent(in) :: n\t\n\tinteger i\n\tlogical, dimension(size(x1)) :: iseq_v\n\t\n\tdo i=1,size(x1)\n\t\tif (abs(x1(i)-x2).lt.0.5d0*10.**(-n)) then\n\t\t\tiseq_v(i)=.true.\n\t\telse\n\t\t\tiseq_v(i)=.false.\n\t\tend if\n\tend do\n\t\n\treturn\nend function iseq_v\n"}, {"instruction": "Write a Fortran function called iseq_vv to compare two vectors and return a logical array indicating element-wise equality. The function takes 3 input parameters of type double precision, dimension(:), double precision, dimension(:), and integer. The output parameter is a logical array of the same size as the input vectors. Use the imperative tone to describe the function's purpose and signature.", "input": "", "output": "function iseq_vv(x1,x2,n) !comparison between two vectors\n\timplicit none\n\tdouble precision, dimension(:), intent(in) :: x1,x2\n\tinteger, intent(in) :: n\t\n\tinteger i\n\tlogical, dimension(size(x1)) :: iseq_vv\n\t\n\tdo i=1,size(x1)\n\t\tif (abs(x1(i)-x2(i)).lt.0.5d0*10.**(-n)) then\n\t\t\tiseq_vv(i)=.true.\n\t\telse\n\t\t\tiseq_vv(i)=.false.\n\t\tend if\n\tend do\n\t\n\treturn\nend function iseq_vv\n"}, {"instruction": "Create a Fortran function named ifactorial to calculate the factorial of a given integer. The function should take 1 input parameter of type integer and return 1 output parameter of type integer.", "input": "", "output": "function ifactorial(n)\n!===============================================================================\n\n!===============================================================================\n  integer, intent(in) :: n\n  integer             :: ifactorial,i\n  ifactorial=1\n  do i=1,n\n    ifactorial=ifactorial*i\n  enddo\n  return\nend function ifactorial\n"}, {"instruction": "Create a Fortran pure function named step that takes an integer*16 input and returns an integer*16 output. The function computes the step number based on the input value and returns the result as output.", "input": "", "output": "  pure function step(n)\n    implicit none\n    integer*16, intent(in) :: n\n    integer                :: i, digits\n    real*16                :: temp\n    integer*16             :: step\n\n    temp=n*1.0\n    step=n\n    digits=int(ceiling(log10(temp)))\n    do i=1,digits\n       step=step+mod(n/10_16**(digits-i),10)*(10_16**(i-1))\n    end do\n\n  end function step\n"}, {"instruction": "Create a Fortran function named stdiag to generate a structured diagonal matrix based on the given stencil vector and dimension. The function takes 3 input parameters: an integer n, a real array s, and an integer err. It returns a real array stdiag of dimensions n x n as output.", "input": "", "output": "        function stdiag(n, s, err)\n            implicit none\n            ! dimension of returned stdiag\n            integer(4), intent(in) :: n\n            ! stencil vector\n            real(8), dimension(:), intent(in) :: s\n            ! errornumber\n            integer(4), intent(out) :: err\n\n            ! result\n            real(8), dimension(n, n) :: stdiag\n            real(8), dimension(n*n) :: tmp\n            ! size of s, middle index, size of tmp\n            integer(4) :: l, m, nn\n            ! loop indices\n            integer(4) :: i, k\n\n            stdiag = 0\n            l = size(s)\n            ! checking conditions\n            if (mod(l, 2) == 0) then\n                err = -1\n                return\n            else if (n <= l/2) then\n                err = -2\n                return\n            end if\n            err = 0\n            ! if s contains one element, return diag(s(1))\n            if (l == 1) then\n                do i=1, n\n                    stdiag(i, i) = s(1)\n                end do\n                return\n            end if\n\n            tmp = 0\n            nn = size(tmp)\n            m = (l-1) / 2\n            k = 0\n            ! fill upper and lower elements of stdiag with slices of s\n            do i = 1, n*m, n\n                tmp(i : i+m+k) = s(m+1-k : l)           ! upper \n                tmp(nn-i-(m+k) : nn-i) = s(0 : m+1+k)   ! lower\n                k = k + 1       ! extend slice of s by 1 for next iter\n            end do\n            ! fill rest of stdiag with copies of s along the diagonal\n            do i = n*m+1, n*(n-m), n+1\n                tmp(i:i+l) = s\n            end do\n\n            stdiag = reshape(tmp, [n, n])\n        end function stdiag\n"}, {"instruction": "Write a Fortran function named f1 that takes an integer input parameter and returns a character string consisting of 'a' repeated the number of times specified by the input parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(len=n)].", "input": "", "output": "function f1(n) result(r)\ninteger, intent(in) :: n\ncharacter(len=n) :: r\ninteger :: i\ndo i = 1, n\n    r(i:i) = \"a\"\nend do\nend function\n"}, {"instruction": "Write a Fortran function named get_intlength to determine the number of digits in an integer input. The function should take 1 input argument of type integer and return 1 output argument of type integer. The input test_data type is ['integer'] and the output test_data type is ['integer']. Use the imperative tone in your instructions.", "input": "", "output": "function get_intlength(myinteger) result(mylen)\n\ninteger        ::myinteger,mylen\n\nmylen=1\nif(myinteger<10)then\n   mylen=1\nelseif((myinteger>=10).and.(myinteger<100))then\n   mylen=2\nelseif((myinteger>=100).and.(myinteger<1000))then\n   mylen=3\nendif\nreturn\nend function get_intlength\n"}, {"instruction": "Write a Fortran function named hipranddestroygenerator that takes an input parameter of type integer(c_size_t) by value. The function returns an output parameter of type integer(c_int). This function should follow the features of Fortran.", "input": "", "output": "        function hipranddestroygenerator(generator) &\n        bind(c, name=\"hipranddestroygenerator\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hipranddestroygenerator\n            integer(c_size_t), value :: generator\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandsetstream to set the random number generator stream for the HIP platform. The function has 2 input parameters of type integer(c_size_t), passed by value. It returns a single output parameter of type integer(c_int). The function should be called using the bind(C) attribute and the name \"hiprandsetstream\".", "input": "", "output": "        function hiprandsetstream(generator, stream) &\n        bind(c, name=\"hiprandsetstream\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetstream\n            integer(c_size_t), value :: generator\n            integer(c_size_t), value :: stream\n        end function\n"}, {"instruction": "Write a Fortran function named hiprandsetpseudorandomgeneratorseed to set the seed for a pseudorandom number generator. The function should have 2 input parameters of type integer(c_size_t) and integer(kind=8), both passed by value. The function should return an output parameter of type integer(c_int). The name of the function is hiprandsetpseudorandomgeneratorseed.", "input": "", "output": "        function hiprandsetpseudorandomgeneratorseed(generator, seed) &\n        bind(c, name=\"hiprandsetpseudorandomgeneratorseed\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetpseudorandomgeneratorseed\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: seed\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandsetgeneratoroffset to set the offset of a random number generator. The function takes 2 input parameters of type integer(c_size_t) and integer(kind=8) passed by value. It returns an output parameter of type integer(c_int).", "input": "", "output": "        function hiprandsetgeneratoroffset(generator, offset) &\n        bind(c, name=\"hiprandsetgeneratoroffset\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetgeneratoroffset\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: offset\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandgetversion to retrieve the version number of the hipRAND library. The function should take 1 input parameter of type integer(c_int) and return 1 output parameter of type integer(c_int). The input parameter represents the version number, and the output parameter will store the retrieved version number. Use the imperative tone to specify these requirements.", "input": "", "output": "        function hiprandgetversion(version) &\n        bind(c, name=\"hiprandgetversion\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandgetversion\n            integer(c_int) :: version\n        end function\n"}, {"instruction": "Create a Fortran function named hipranddestroydistribution to destroy a discrete random number generator distribution. The function takes 1 input parameter of type integer(c_size_t), passed by value. The output is an integer(c_int). The test data types for input and output parameters are ['integer(c_size_t), value'] and ['integer(c_int)'] respectively.", "input": "", "output": "        function hipranddestroydistribution(discrete_distribution) &\n        bind(c, name=\"hipranddestroydistribution\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hipranddestroydistribution\n            integer(c_size_t), value :: discrete_distribution\n        end function\n"}, {"instruction": "Write a Fortran function named is_in to check if a given character is present in a string. The function should take 2 input parameters of type character(len=1) and character(len=*), and return 1 output parameter of type logical.", "input": "", "output": "function is_in(c, str) result(is)\n    character(len=1), intent(in) :: c\n    character(len=*), intent(in) :: str\n    logical :: is\n\n    integer :: i\n\n    is = .false.\n    do i = 1, len(str)\n        if (c == str(i:i)) then\n            is = .true.\n            exit\n        end if\n    end do\nend function is_in\n"}, {"instruction": "Create a Fortran function named \"gases\" to compute the 2-way gaseous attenuation through a volume in microwave. This function takes 4 input parameters of type real*8: pressure (pres_mb), temperature (t), relative humidity (rh), and frequency (f). It returns 1 output parameter of type real*8, which represents the 2-way gaseous attenuation in decibels per kilometer.", "input": "", "output": "  function gases(pres_mb,t,rh,f)\n  implicit none\n  \n! purpose:\n!   compute 2-way gaseous attenuation through a volume in microwave\n!\n! inputs:\n!   [pres_mb]   pressure (mb) (hpa)\n!   [t]         temperature (k)\n!   [rh]        relative humidity (%)\n!   [f]         frequency (ghz), < 300 ghz\n!\n! returns:\n!   2-way gaseous attenuation (db/km)\n!\n! reference:\n!   uses method of liebe (1985)\n!\n! created:\n!   12/09/05  john haynes (haynes@atmos.colostate.edu)\n! modified:\n!   01/31/06  port from idl to fortran 90\n\n  integer, parameter :: &\n  nbands_o2 = 48 ,&\n  nbands_h2o = 30\n  real*8, intent(in) :: pres_mb, t, rh, f\n  real*8 :: gases, th, e, p, sumo, gm0, a0, ap, term1, term2, term3, &\n            bf, be, term4, npp\n  real*8, dimension(nbands_o2) :: v0, a1, a2, a3, a4, a5, a6\n  real*8, dimension(nbands_h2o) :: v1, b1, b2, b3\n  real*8 :: e_th,one_th,pth3,eth35,aux1,aux2,aux3,aux4\n  real*8 :: gm,delt,x,y,gm2\n  real*8 :: fpp_o2,fpp_h2o,s_o2,s_h2o\n  integer :: i\n  \n! // table1 parameters  v0, a1, a2, a3, a4, a5, a6  \n  data v0/49.4523790,49.9622570,50.4742380,50.9877480,51.5033500, &\n  52.0214090,52.5423930,53.0669060,53.5957480,54.1299999,54.6711570, &\n  55.2213650,55.7838000,56.2647770,56.3378700,56.9681000,57.6124810, &\n  58.3238740,58.4465890,59.1642040,59.5909820,60.3060570,60.4347750, &\n  61.1505580,61.8001520,62.4112120,62.4862530,62.9979740,63.5685150, &\n  64.1277640,64.6789000,65.2240670,65.7647690,66.3020880,66.8368270, &\n  67.3695950,67.9008620,68.4310010,68.9603060,69.4890210,70.0173420, &\n  118.7503410,368.4983500,424.7631200,487.2493700,715.3931500, &\n  773.8387300, 834.1453300/\n  data a1/0.0000001,0.0000003,0.0000009,0.0000025,0.0000061,0.0000141, &\n  0.0000310,0.0000641,0.0001247,0.0002280,0.0003918,0.0006316,0.0009535, &\n  0.0005489,0.0013440,0.0017630,0.0000213,0.0000239,0.0000146,0.0000240, &\n  0.0000211,0.0000212,0.0000246,0.0000250,0.0000230,0.0000193,0.0000152, &\n  0.0000150,0.0000109,0.0007335,0.0004635,0.0002748,0.0001530,0.0000801, &\n  0.0000395,0.0000183,0.0000080,0.0000033,0.0000013,0.0000005,0.0000002, &\n  0.0000094,0.0000679,0.0006380,0.0002350,0.0000996,0.0006710,0.0001800/\n  data a2/11.8300000,10.7200000,9.6900000,8.8900000,7.7400000,6.8400000, &\n  6.0000000,5.2200000,4.4800000,3.8100000,3.1900000,2.6200000,2.1150000, &\n  0.0100000,1.6550000,1.2550000,0.9100000,0.6210000,0.0790000,0.3860000, &\n  0.2070000,0.2070000,0.3860000,0.6210000,0.9100000,1.2550000,0.0780000, &\n  1.6600000,2.1100000,2.6200000,3.1900000,3.8100000,4.4800000,5.2200000, &\n  6.0000000,6.8400000,7.7400000,8.6900000,9.6900000,10.7200000,11.8300000, &\n  0.0000000,0.0200000,0.0110000,0.0110000,0.0890000,0.0790000,0.0790000/\n  data a3/0.0083000,0.0085000,0.0086000,0.0087000,0.0089000,0.0092000, &\n  0.0094000,0.0097000,0.0100000,0.0102000,0.0105000,0.0107900,0.0111000, &\n  0.0164600,0.0114400,0.0118100,0.0122100,0.0126600,0.0144900,0.0131900, &\n  0.0136000,0.0138200,0.0129700,0.0124800,0.0120700,0.0117100,0.0146800, &\n  0.0113900,0.0110800,0.0107800,0.0105000,0.0102000,0.0100000,0.0097000, &\n  0.0094000,0.0092000,0.0089000,0.0087000,0.0086000,0.0085000,0.0084000, &\n  0.0159200,0.0192000,0.0191600,0.0192000,0.0181000,0.0181000,0.0181000/\n  data a4/0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.6000000,0.6000000,0.6000000,0.6000000,0.6000000,0.6000000/\n  data a5/0.0056000,0.0056000,0.0056000,0.0055000,0.0056000,0.0055000, &\n  0.0057000,0.0053000,0.0054000,0.0048000,0.0048000,0.0041700,0.0037500, &\n  0.0077400,0.0029700,0.0021200,0.0009400,-0.0005500,0.0059700,-0.0024400, &\n  0.0034400,-0.0041300,0.0013200,-0.0003600,-0.0015900,-0.0026600, &\n  -0.0047700,-0.0033400,-0.0041700,-0.0044800,-0.0051000,-0.0051000, &\n  -0.0057000,-0.0055000,-0.0059000,-0.0056000,-0.0058000,-0.0057000, &\n  -0.0056000,-0.0056000,-0.0056000,-0.0004400,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000/\n  data a6/1.7000000,1.7000000,1.7000000,1.7000000,1.8000000,1.8000000,&\n  1.8000000,1.9000000,1.8000000,2.0000000,1.9000000,2.1000000,2.1000000, &\n  0.9000000,2.3000000,2.5000000,3.7000000,-3.1000000,0.8000000,0.1000000, &\n  0.5000000,0.7000000,-1.0000000,5.8000000,2.9000000,2.3000000,0.9000000, &\n  2.2000000,2.0000000,2.0000000,1.8000000,1.9000000,1.8000000,1.8000000, &\n  1.7000000,1.8000000,1.7000000,1.7000000,1.7000000,1.7000000,1.7000000, &\n  0.9000000,1.0000000,1.0000000,1.0000000,1.0000000,1.0000000,1.0000000/\n\n! // table2 parameters  v1, b1, b2, b3\n  data v1/22.2350800,67.8139600,119.9959400,183.3101170,321.2256440, &\n  325.1529190,336.1870000,380.1973720,390.1345080,437.3466670,439.1508120, &\n  443.0182950,448.0010750,470.8889740,474.6891270,488.4911330,503.5685320, &\n  504.4826920,556.9360020,620.7008070,658.0065000,752.0332270,841.0735950, &\n  859.8650000,899.4070000,902.5550000,906.2055240,916.1715820,970.3150220, &\n  987.9267640/\n  data b1/0.1090000,0.0011000,0.0007000,2.3000000,0.0464000,1.5400000, &\n  0.0010000,11.9000000,0.0044000,0.0637000,0.9210000,0.1940000,10.6000000, &\n  0.3300000,1.2800000,0.2530000,0.0374000,0.0125000,510.0000000,5.0900000, &\n  0.2740000,250.0000000,0.0130000,0.1330000,0.0550000,0.0380000,0.1830000, &\n  8.5600000,9.1600000,138.0000000/\n  data b2/2.1430000,8.7300000,8.3470000,0.6530000,6.1560000,1.5150000, &\n  9.8020000,1.0180000,7.3180000,5.0150000,3.5610000,5.0150000,1.3700000, &\n  3.5610000,2.3420000,2.8140000,6.6930000,6.6930000,0.1140000,2.1500000, &\n  7.7670000,0.3360000,8.1130000,7.9890000,7.8450000,8.3600000,5.0390000, &\n  1.3690000,1.8420000,0.1780000/\n  data b3/0.0278400,0.0276000,0.0270000,0.0283500,0.0214000,0.0270000, &\n  0.0265000,0.0276000,0.0190000,0.0137000,0.0164000,0.0144000,0.0238000, &\n  0.0182000,0.0198000,0.0249000,0.0115000,0.0119000,0.0300000,0.0223000, &\n  0.0300000,0.0286000,0.0141000,0.0286000,0.0286000,0.0264000,0.0234000, &\n  0.0253000,0.0240000,0.0286000/\n  \n! // conversions\n  th = 300./t       ! unitless\n  e = (rh*th**5)/(41.45*10**(9.834*th-10))   ! kpa\n  p = pres_mb/10.-e ! kpa\n  e_th = e*th\n  one_th = 1 - th\n  pth3 = p*th**(3)\n  eth35 = e*th**(3.5)\n\n! // term1\n  sumo = 0.\n  aux1 = 1.1*e_th\n  do i=1,nbands_o2\n    aux2 = f/v0(i)\n    aux3 = v0(i)-f\n    aux4 = v0(i)+f\n    gm = a3(i)*(p*th**(0.8-a4(i))+aux1)\n    gm2 = gm**2\n    delt = a5(i)*p*th**a6(i)\n    x = aux3**2+gm2\n    y = aux4**2+gm2\n    fpp_o2 = (((1./x)+(1./y))*(gm*aux2) - (delt*aux2)*((aux3/(x))-(aux4/(x))))\n    s_o2 = a1(i)*pth3*exp(a2(i)*one_th)\n    sumo = sumo + fpp_o2 * s_o2\n  enddo\n  term1 = sumo\n\n! // term2\n  gm0 = 5.6e-3*(p+1.1*e)*th**(0.8)\n  a0 = 3.07e-4\n  ap = 1.4*(1-1.2*f**(1.5)*1e-5)*1e-10\n  term2 = (2*a0*(gm0*(1+(f/gm0)**2)*(1+(f/60.)**2))**(-1) + ap*p*th**(2.5)) &\n          * f*p*th**2\n\n! // term3\n  sumo = 0.\n  aux1 = 4.8*e_th\n  do i=1,nbands_h2o\n    aux2 = f/v1(i)\n    aux3 = v1(i)-f\n    aux4 = v1(i)+f\n    gm = b3(i)*(p*th**(0.8)+aux1)\n    gm2 = gm**2\n    x = aux3**2+gm2\n    y = aux4**2+gm2\n    !delt = 0.\n    fpp_h2o = ((1./x)+(1./y))*(gm*aux2) ! - (delt*aux2)*((aux3/(x))-(aux4/(x)))\n    s_h2o = b1(i)*eth35*exp(b2(i)*one_th)\n    sumo = sumo + fpp_h2o * s_h2o\n  enddo\n  term3 = sumo\n\n! // term4\n  bf = 1.4e-6\n  be = 5.41e-5\n  term4 = (bf*p+be*e*th**3)*f*e*th**(2.5)\n\n! // summation and result\n  npp = term1 + term2 + term3 + term4\n  gases = 0.182*f*npp\n\n  end function gases\n"}, {"instruction": "Write a Fortran function named clip that takes 4 input parameters of types integer, double precision, double precision, and double precision array of dimension n, and 1 output parameter of type double precision array of dimension n. The function is designed to clip the values of the input array x within the range specified by the inputs a and b, and store the clipped values in the output array y. The function uses a do loop to iterate through the elements of the input array and applies the clipping logic.", "input": "", "output": "        function clip(x, n, a, b) result (y)\r\n            integer, intent(in) :: n\r\n            integer :: k\r\n            double precision, intent(in) :: a, b\r\n            double precision, dimension(n), intent(in) :: x\r\n            double precision, dimension(n) :: y\r\n\r\n            do k=1, n\r\n                if ((a <= x(k)) .and. (x(k) <= b)) then\r\n                    y(k) = x(k)\r\n                else\r\n                    y(k) = dnan\r\n                end if\r\n            end do\r\n            return\r\n        end function\r\n"}, {"instruction": "Write a Fortran function named outer_product to calculate the outer product of two vectors. The number of input parameters is 3, with test_data types ['integer', 'double precision, dimension(n)', 'double precision, dimension(n)']. The number of output parameters is 1, with a test_data type of ['double precision, dimension(n, n)']. Use the imperative tone and ensure the correct understanding and summary of the function.", "input": "", "output": "        function outer_product(x, y, n) result (a)\r\n            implicit none\r\n            integer :: n\r\n            double precision, dimension(n), intent(in) :: x, y\r\n            double precision, dimension(n, n) :: a\r\n            integer :: i, j\r\n            do i=1,n\r\n                do j=1,n\r\n                    a(i, j) = x(i) * y(j)\r\n                end do\r\n            end do\r\n            return\r\n        end function\r\n"}, {"instruction": "Create a Fortran function named det to recursively calculate the determinant of a square matrix. The number of input arguments is 2, with test data types ['integer', 'double precision, dimension(n, n)'], and the number of output arguments is 1 with a test data type ['double precision'].", "input": "", "output": "        recursive function det(a, n) result (d)\r\n            implicit none\r\n            integer :: n\r\n            double precision, dimension(n, n) :: a\r\n            double precision, dimension(n-1, n-1) :: x\r\n            integer :: i\r\n            double precision :: d, s\r\n\r\n            if (n == 1) then\r\n                d = a(1, 1)\r\n                return\r\n            elseif (n == 2) then\r\n                d = a(1, 1) * a(2, 2) - a(1, 2) * a(2, 1)\r\n                return\r\n            else\r\n                d = 0.0d0\r\n                s = 1.0d0\r\n                do i = 1, n\r\n!                   compute submatrix x\r\n                    x(:,  :i-1) = a(2:,    :i-1)\r\n                    x(:, i:   ) = a(2:, i+1:   )\r\n                    d = s * det(x, n-1) * a(1, i) + d\r\n                    s = -s\r\n                end do\r\n            end if\r\n            return\r\n        end function\r\n"}, {"instruction": "Write a Fortran function named floatfac that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function floatfac(in)\n  implicit none\n  integer,intent(in) :: in\n  integer ::  i\n  real*8 :: floatfac, sum\n  sum=1.d0\n  do i=1,in\n     sum=sum*i\n  enddo\n  floatfac=sum\nend function floatfac\n"}, {"instruction": "Create a Fortran function named myisnan to determine if a given double precision floating point number is NaN (Not a Number). The function should take 1 input argument of type real*8 and return 1 output argument of type logical. The test_data type for input is ['real*8'] and for output is ['logical'].", "input": "", "output": "function myisnan(input)\n  implicit none\n  real*8,intent(in) :: input\n  logical :: myisnan\n  if ((input+1.0d0.eq.input)) then\n     myisnan=.true.\n  else\n     myisnan=.false.\n  endif\nend function myisnan\n"}, {"instruction": "Write a Fortran function named mod97 to calculate the modulo 97 of a given string of integers. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer. The name of the function is mod97.", "input": "", "output": "    function mod97(strint) result(res)\n        character(len=*), intent(in) :: strint\n        integer :: i, num, res\n        res = 0\n        do  i=1, len(trim(strint))\n            read(strint(i:i),*) num\n            res = mod((res*10 + num),97);\n        end do\n    end function mod97\n"}, {"instruction": "Write a Fortran function named sum_ to calculate the sum of all elements in an array. The function takes 1 input parameter of type integer, allocatable, dimension(: ), and returns 1 output parameter of type integer.", "input": "", "output": "    function sum_(x) result(y)\n    integer ,allocatable, dimension(: ), intent(in):: x\n    integer:: y\n    integer:: i\n    integer:: i_cyml0\n    y = 0\n    do i_cyml0 = 1, size(x)\n        i = x(i_cyml0)\n        y = y + i\n    end do\n    end function sum_\n"}, {"instruction": "Write a Fortran function named replace_asterisk_with_step to create a new filename by replacing the asterisk (*) in the input filename with the specified step value. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "        function replace_asterisk_with_step(filename, step) result(new_filename)\n            character(len=*), intent(in) :: filename\n            integer, intent(in) :: step\n            character(len=:), allocatable :: new_filename\n\n            character(len=:), allocatable :: prefix, suffix\n            integer :: new_length, asterisk_location\n\n            asterisk_location = index(filename, \"*\")\n\n            prefix = filename(1:asterisk_location-1)\n            suffix = filename(asterisk_location+1:)\n\n            if (step == 0) then\n                new_length = 1\n            else\n                new_length = floor(log10(1.0d0*step)) + 1\n            end if\n\n            new_length = new_length + len(prefix) + len(suffix)\n\n            allocate(character(len=new_length) :: new_filename)\n\n            write(new_filename, '(a,i0,a)') prefix, step, suffix\n\n        end function\n"}, {"instruction": "Create a Fortran function named local_to_global_param that converts a local parameter to the global domain within the specified range (a <= u <= b).\nThe function takes 3 input parameters of type double precision: a (lower global parameter), b (upper global parameter), and ul (local parameter).\nIt produces 1 output parameter, ug, of type double precision, which represents the global parameter.\nEnsure that the local parameter ul is constrained within the range [0.0, 1.0].", "input": "", "output": "function local_to_global_param(a, b, ul) result(ug)\n    !> convert the local parameter to the global domain\n    !> (a <= u <= b).\n    !> a - lower global parameter.\n    !> b - upper global parameter.\n    !> ul - local parameter.\n    !> ug - global parameter.\n    \n    ! input\n    double precision, intent(in) :: a, b, ul\n    \n    ! output\n    double precision :: ug\n    \n    ! working\n    double precision :: ui\n    \n    ui = ul\n    if (ui .lt. 0.0d0) then\n        ui = 0.0d0\n    else if (ui .gt. 1.0d0) then\n        ui = 1.0d0\n    end if\n    ug = a + ui * (b - a)\n    \nend function local_to_global_param\n"}, {"instruction": "Create a Fortran function named getcodeforcolor to retrieve the ANSI escape code for a given color. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(8). The input arguments should be of test_data type ['character(*)'], and the output should be of test_data type ['character(8)'].", "input": "", "output": "    function getcodeforcolor(color) result(code)\n        character(*)    :: color\n        character(8)    :: code\n        select case (color)\n            case (\"lightblue\")\n                code = \"\\x1b[94m\"\n            case (\"yellow\")\n                code = \"\\x1b[33m\"\n            case (\"green\")\n                code = \"\\x1b[32m\"\n            case default\n                code = \"\"\n        end select\n    end function\n"}, {"instruction": "Create a Fortran function named firstlocation to find the first occurrence of a specified character in a given string. The function takes 3 input parameters: a character, a search string, and an optional logical parameter. The input parameter types are ['character(len=1)', 'character(len=*)', 'logical, optional']. The function has 1 output parameter of type ['integer'].", "input": "", "output": "  function firstlocation(acharacter,searchstring,back) result(location)\n    character(len=1),intent(in)::acharacter\n    character(len=*),intent(in)::searchstring\n    logical,intent(in),optional::back\n    integer::location\n\n    !local variables\n    logical::localback\n    localback=.false.\n    if (present(back)) localback=back\n\n    location=0 !default: 0 means character is not found in the search string \n    location=scan(searchstring,acharacter,back=localback)      \n\n  end function firstlocation\n"}, {"instruction": "Provide a Fortran function named countoccurance to count the occurrences of a specific character within a given string. The function takes 2 input arguments with data types ['character(len=1)', 'character(len=*)'] and 1 output argument with data type ['integer'].", "input": "", "output": "  function countoccurance(acharacter,searchstring) result(numberofoccurance)\n    character(len=1),intent(in)::acharacter\n    character(len=*),intent(in)::searchstring\n    integer::numberofoccurance\n\n    integer::indx\n\n    numberofoccurance=0  !default\n    do indx=1,len(searchstring)\n      if (searchstring(indx:indx).eq.acharacter) numberofoccurance=numberofoccurance+1\n    end do\n    \n  end function countoccurance\n"}, {"instruction": "Provide a Fortran function named texttoint to convert a string of characters representing a number into an integer. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function texttoint(astring) result(number)\n    character(len=*)::astring\n    integer::number\n\n    character(len=10), parameter ::intchar = '0123456789' \n    integer :: k    ! loop counter\n    integer :: loc  ! position in character version of numbers\n    integer :: poweroften\n\n    number=0  !initialize\n    poweroften=0\n\n    do k = len_trim(astring),1,-1      !  to change letters\n      loc = index(intchar,astring (k:k))                   ! locate\n      if (loc.ne.0) then\n        loc=loc-1\n        number = number + loc*(10**poweroften)             ! calculate\n      end if\n      poweroften=poweroften+1\n    end do \n\n  end function texttoint\n"}, {"instruction": "Create a Fortran function named tolerance to calculate the tolerance for comparing two real numbers. The function takes 2 input parameters of type real(8), and returns 1 output parameter of type real(8).", "input": "", "output": "  function tolerance(r1,r2) result(toler)\n    real(8),intent(in)::r1,r2\n    real(8)::toler\n\n    !local variables\n    integer::dg1,dg2,prec1,prec2\n    real(8)::err1,err2,absr1,absr2\n\n    !initialize\n    prec1 = precision(r1)\n    prec2 = precision(r2)\n    absr1 = abs(r1)\n    absr2 = abs(r2)\n\n    !find the number of digits on the left side of decimal point for r1\n    do dg1=prec1,1,-1\n      if (int(absr1/10d0**(dg1-1)) .gt. 0d0) exit\n    end do\n\n    !find the number of digits on the left side of decimal point for r2\n    do dg2=prec2,1,-1\n      if (int(absr2/10d0**(dg2-1)) .gt. 0d0) exit\n    end do\n\n    !tolernace for each number\n    err1 = 10d0**(-(prec1-dg1+1))\n    err2 = 10d0**(-(prec2-dg2+1))\n\n    !final tolerance is the larger of the two tolerances\n    toler = max(err1,err2)\n\n  end function tolerance\n"}, {"instruction": "Create a Fortran function named fun_find_str_i that finds the position of a specified string within an array of strings. The function takes 2 input parameters of type character(len=*) and character(len=*),dimension(:), and returns 1 output parameter of type integer.", "input": "", "output": "  function fun_find_str_i(dum_str,dum_data)\n    ! common blocks\n    implicit none\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    integer::fun_find_str_i\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    character(len=*),intent(in)::dum_str\n    character(len=*),dimension(:),intent(in)::dum_data\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::i,loc_imax\n    ! -------------------------------------------------------- !\n    ! find i\n    ! -------------------------------------------------------- !\n    loc_imax = size(dum_data)\n    i = 0\n    do i=1,loc_imax\n       if (dum_str == dum_data(i)) exit \n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n    fun_find_str_i = i\n    ! -------------------------------------------------------- !\n  end function fun_find_str_i\n"}, {"instruction": "Create a Fortran function named fun_calc_isotope_fractionr to calculate the isotope fraction. It takes 2 input arguments of type real: dum_delta and dum_standard. The output is a single real value. The function returns dum_standard multiplied by (1.0 + dum_delta/1000.0).", "input": "", "output": "  function fun_calc_isotope_fractionr(dum_delta,dum_standard)\n    implicit none\n    ! result variable\n    real::fun_calc_isotope_fractionr\n    ! dummy arguments\n    real,intent(in)::dum_delta,dum_standard\n\n    fun_calc_isotope_fractionr = dum_standard*(1.0 + dum_delta/1000.0)\n  end function fun_calc_isotope_fractionr\n"}, {"instruction": "Create a Fortran function called fun_calc_isotope_abundancer0 to calculate the isotope abundance ratio based on the total abundance and the two isotope ratios. Ensure that the function has 3 input parameters of type real: dum_totabundance, dum_r1, dum_r2, and 1 output parameter of type real.", "input": "", "output": "  function fun_calc_isotope_abundancer0(dum_totabundance,dum_r1,dum_r2)\n    implicit none\n    ! result variable\n    real::fun_calc_isotope_abundancer0\n    ! dummy arguments\n    real,intent(in)::dum_totabundance,dum_r1,dum_r2\n\n    fun_calc_isotope_abundancer0 = dum_totabundance/(1.0 + dum_r1 + dum_r2)\n  end function fun_calc_isotope_abundancer0\n"}, {"instruction": "Create a Fortran function named fun_corr_p to calculate a corrected pressure value based on given input parameters. The function takes 4 input arguments of type real and real, with the last argument being an array of 5 real numbers. The output is a single real value.", "input": "", "output": "  function fun_corr_p(dum_tc,dum_p,dum_rrtimest,dum_dp)\n    ! result variable\n    real::fun_corr_p\n    ! dummy arguments\n    real,intent(in)::dum_tc,dum_p,dum_rrtimest\n    real,intent(in),dimension(5)::dum_dp\n\n    fun_corr_p = &\n         & ( &\n         &   -(dum_dp(1) + dum_dp(2)*dum_tc + dum_dp(3)*dum_tc*dum_tc) + &\n         &   (5.0e-4*(dum_dp(4) + dum_dp(5)*dum_tc))*dum_p &\n         & )*dum_p*dum_rrtimest\n  end function fun_corr_p\n"}, {"instruction": "Create a Fortran function named fun_get_grid_lone that takes an integer input argument. The function returns an array of real numbers with a dimension of 1 to dum_n_i+1.", "input": "", "output": "  function fun_get_grid_lone(dum_n_i)\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    integer,intent(in)::dum_n_i                                  !\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real,dimension(1:dum_n_i+1)::fun_get_grid_lone            !\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::i\n    ! -------------------------------------------------------- !\n    ! calculate and return grid variable\n    ! -------------------------------------------------------- !\n    do i=1,dum_n_i+1\n       fun_get_grid_lone(i) = (360.0/dum_n_i)*real(i-1) + par_grid_lon_offset\n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_get_grid_lone\n"}, {"instruction": "Create a Fortran function named fun_get_grid_z to calculate grid vector for ocean depths. The function takes 2 input arguments of type integer and real, and returns 1 output argument of type real with dimension 1 to dum_n_k.", "input": "", "output": "  function fun_get_grid_z(dum_n_k,dum_dsc)\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    integer,intent(in)::dum_n_k                                !\n    real,intent(in)::dum_dsc                                   ! max ocean depth (m)\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real,dimension(1:dum_n_k)::fun_get_grid_z                  ! equivalent to goldstein variable zro\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::k                                                 ! local counting variable\n    real::loc_ez0\n    real::loc_z1\n    real::loc_tv1,loc_tv2,loc_tv3,loc_tv4,loc_tv5\n    real,dimension(1:dum_n_k)::loc_dz,loc_dza\n    ! -------------------------------------------------------- !\n    ! initialize local variables\n    ! -------------------------------------------------------- ! for variable (exponential) dz use ez0 > 0, else use ez0 < 0\n    loc_ez0 = 0.1\n    ! -------------------------------------------------------- !\n    ! calculate and return grid vector\n    ! -------------------------------------------------------- !\n    ! tv3 is the depth of the kth w level from the top\n    ! tv5 is the depth of the k+1th density level from the top\n    loc_z1 = loc_ez0*((1.0 + 1.0/loc_ez0)**(1.0/real(dum_n_k)) - 1.0)\n    loc_tv1 = 0.0\n    loc_tv2 = 0.0\n    loc_tv4 = loc_ez0*((loc_z1/loc_ez0 + 1.0)**0.5 - 1.0)\n    do k=1,dum_n_k\n       if (loc_ez0 > 0.0) then\n          loc_tv3 = loc_ez0*((loc_z1/loc_ez0+1)**real(k) - 1.0)\n          loc_dz(dum_n_k-k+1) = loc_tv3 - loc_tv2\n          loc_tv2 = loc_tv3\n          loc_tv5 = loc_ez0*((loc_z1/loc_ez0+1)**(real(k)+0.5) - 1.0)\n          if(k < dum_n_k) then\n             loc_dza(dum_n_k-k) = loc_tv5 - loc_tv4\n          else\n             loc_dza(k) = loc_dz(dum_n_k)/2.0\n          end if\n          loc_tv4 = loc_tv5\n          loc_tv1 = loc_tv1 + loc_dz(dum_n_k-k+1)\n       else\n          loc_dz(k)  = 1.0/real(dum_n_k)\n          loc_dza(k) = 1.0/real(dum_n_k)\n       endif\n    enddo\n    do k=1,dum_n_k\n       fun_get_grid_z(k) = dum_dsc*sum(loc_dza(k:dum_n_k))\n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_get_grid_z\n"}, {"instruction": "Create a Fortran function named bar that takes an array of integers as input. The input parameter should be a one-dimensional array of any size. The function should return a two-dimensional array of integers with the first row filled with 1s and the second row containing the elements of the input array.", "input": "", "output": "  function bar(x) result(a)\n    integer, dimension(:), intent(in) :: x\n    integer, dimension(2,size(x)) :: a\n    a(1,:) = 1\n    a(2,:) = x\n  end function\n"}, {"instruction": "Provide a Fortran function named gammln to calculate the natural logarithm of the absolute value of the gamma function. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function gammln(xx)\n!\nimplicit none\n!\n\n!\nreal :: xx\nreal :: gammln\n!\n! local variables\n!\nreal*8,dimension(6) :: cof\nreal*8 :: dble\nreal*8 :: fpf,half,one,ser,stp,tmp,x\ninteger :: j\n!\n!     + + + purpose + + +\n\n!     full accuracy is obtained for xx > 1\n!     for 0 < xx < 1, the reflection formula (6.1.4) can be used first.\n!\n!     based on:\n!     'numerical recipes - the art of scientific computing',\n!     w.h. press, b.p. flannery, s.a. teukolsky, w.t. vetterling\n!     cambridge university press, 1986\n!     pg 157\n!\n!     + + + keywords + + +\n\n!\n!     + + + argument declarations + + +\n!\n!\n!     + + + argument definitions + + +\n!     xx     - real value for values > 0\n!\n!     + + + local variables + + +\n!\ndata cof,stp/76.18009173d0, - 86.50532033d0,24.01409822d0, - 1.231739516d0,     &\n   & 0.120858003d-2, - 0.536382d-5,2.50662827465d0/\ndata half,one,fpf/0.5d0,1.0d0,5.5d0/\n!\n!     + + + end specifications + + +\n!\nx = dble(xx) - one\ntmp = x + fpf\ntmp = (x+half)*log(tmp) - tmp\nser = one\ndo j = 1,6\n  x = x + one\n  ser = ser + cof(j)/x\nend do\n!\ngammln = tmp + log(stp*ser)\n! \nend function gammln\n"}, {"instruction": "Write a Fortran function named int_in_array to check if a given integer is present in an array of integers. The function takes 2 input parameters with test data types ['integer', 'integer, dimension(:)'] and returns 1 output parameter with a test data type of ['logical'].", "input": "", "output": "function int_in_array(number, array) \n integer, intent(in) :: number\n integer, dimension(:), intent(in) :: array\n logical :: int_in_array\n \n integer :: i\n \n int_in_array = .false.\n \n do i=lbound(array,dim=1),ubound(array,dim=1)\n  if(number.eq.array(i)) int_in_array = .true.\n enddo \n \nend function int_in_array\n"}, {"instruction": "Create a Fortran function called derivative2d1 to calculate the first derivative of a 2D array with respect to the first dimension. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). The number of input arguments is 2, and the test_data type is ['real(8), dimension(:,:)', 'real(8), dimension(:)']. The number of output arguments is 1, and the test_data type is ['real(8), dimension(1:size(f,1),1:size(f,2))']. Use the provided backward differences in the input to compute the derivatives.", "input": "", "output": "  function derivative2d1(f,dx1)\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx1    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix2\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d1\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix2=1,lx2\n      derivative2d1(1,ix2)=(f(2,ix2)-f(1,ix2))/dx1(2)\n      derivative2d1(2:lx1-1,ix2)=(f(3:lx1,ix2)-f(1:lx1-2,ix2))/(dx1(3:lx1)+dx1(2:lx1-1))\n      derivative2d1(lx1,ix2)=(f(lx1,ix2)-f(lx1-1,ix2))/dx1(lx1)\n    end do\n  end function derivative2d1\n"}, {"instruction": "Create a Fortran function named derivative2d2 that computes the second derivative of a 2D array with respect to the second dimension using backward differences. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). The function uses parallelization and assumes that ghost cells are not present.", "input": "", "output": "  function derivative2d2(f,dx2)\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx2    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix1\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d2\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix1=1,lx1\n      derivative2d2(ix1,1)=(f(ix1,2)-f(ix1,1))/dx2(2)\n      derivative2d2(ix1,2:lx2-1)=(f(ix1,3:lx2)-f(ix1,1:lx2-2))/(dx2(3:lx2)+dx2(2:lx2-1))\n      derivative2d2(ix1,lx2)=(f(ix1,lx2)-f(ix1,lx2-1))/dx2(lx2)\n    end do\n  end function derivative2d2\n"}, {"instruction": "Create a Fortran function named derivative2d2p that computes the second derivative of a two-dimensional array representing a periodic domain. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)).", "input": "", "output": "  function derivative2d2p(f,dx2)\n\n    !derivative on a periodic domain\n\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx2    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix1\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d2p\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix1=1,lx1\n      derivative2d2p(ix1,1)=(f(ix1,2)-f(ix1,lx2))/(dx2(2)+dx2(1))\n      derivative2d2p(ix1,2:lx2-1)=(f(ix1,3:lx2)-f(ix1,1:lx2-2))/(dx2(3:lx2)+dx2(2:lx2-1))\n      derivative2d2p(ix1,lx2)=(f(ix1,1)-f(ix1,lx2-1))/(dx2(1)+dx2(lx2))\n    end do\n\n  end function derivative2d2p\n"}, {"instruction": "Create a Fortran function named integral2d2 to compute a 2-dimensional integral. The function accepts two input parameters of type real(8), dimension(:,:) and real(8), dimension(1:size(f,2)) respectively. It returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). Make sure that ghost cells have been removed from the input arrays before passing them into this routine. Use backward differences for the second input parameter.", "input": "", "output": "  function integral2d2(f,dx2)\n\n    !------------------------------------------------------------\n    !-------compute an integral along the 2-dim.  it is expected that \n    !-------ghost cells will have been trimmed from arrays before\n    !-------they are passed into this routine\n    !------------------------------------------------------------\n\n    real(8), dimension(:,:), intent(in) :: f\n    real(8), dimension(1:size(f,2)), intent(in) :: dx2  !presumed backward diffs. (1:lx2)\n\n    integer :: ix2,lx2\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: integral2d2\n\n    lx2=size(f,2)\n\n    integral2d2(:,1)=0d0\n    do ix2=2,lx2\n      integral2d2(:,ix2)=integral2d2(:,ix2-1)+0.5d0*(f(:,ix2)+f(:,ix2-1))*dx2(ix2)\n    end do\n\n  end function integral2d2\n"}, {"instruction": "Create a Fortran function named minmod to calculate the minimum of two real(8) numbers. The function takes 2 input arguments of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "  function minmod(a,b)\n    real(8), intent(in) :: a,b\n    real(8) :: minmod\n\n    if (a*b <= 0.) then\n      minmod=0.\n    else if (abs(a) < abs(b)) then\n      minmod=a\n    else\n      minmod=b\n    end if\n  end function minmod\n"}, {"instruction": "Create a Fortran function named string_in_test to check if the input string matches 'test string'. The function takes 1 input parameter of type character(len=20) and returns a single output parameter of type logical.", "input": "", "output": "  function string_in_test(s) result(t)\n    character(len=20), intent(in) :: s\n    logical :: t\n    if (s == 'test string') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_test\n"}, {"instruction": "Create a Fortran function named string_in_cutoff to determine if the input string matches the value 'test s'. The function takes 1 input parameter of type character(len=6) and returns 1 output parameter of type logical. The function should be called with the input string, and the output will indicate whether the input matches 'test s' as true or false.", "input": "", "output": "  function string_in_cutoff(s) result(t)\n    character(len=6), intent(in) :: s\n    logical :: t\n    if (s == 'test s') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_cutoff\n"}, {"instruction": "Create a Fortran function named string_in_assumed_len. This function takes 3 input arguments of types character(len=*), character(len=*), and integer, and returns 1 output argument of type logical. The function checks if the first input string is 'test string 1' and the second input string is 'string 2', and returns true if both conditions are met; otherwise, it returns false.", "input": "", "output": "  function string_in_assumed_len(s1,x,s2) result(t)\n    character(len=*), intent(in) :: s1, s2\n    integer, intent(in) :: x ! dummy\n    logical :: t\n    if (s1=='test string 1' .and. s2=='string 2') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_assumed_len\n"}, {"instruction": "Create a Fortran function named stat_object to compute statistical properties of a series of real numbers. The function takes 2 input parameters of type real and character(len=*), where the character parameter is optional. The output is a real number. The function utilizes recursion and supports various statistical commands such as \"stddev\", \"variance\", \"count\", \"mean\", and \"reset\" based on the input command.", "input": "", "output": "  recursive function stat_object(a, cmd) result(stddev)\n    real :: stddev\n    real, intent(in) :: a\n    character(len=*), intent(in), optional :: cmd\n\n    real, save :: summa = 0.0, summa2 = 0.0\n    integer, save :: num = 0\n\n    real :: m\n\n    if ( .not. present(cmd) ) then\n       num = num + 1\n       summa = summa + a\n       summa2 = summa2 + a*a\n       stddev = stat_object(0.0, \"stddev\")\n    else\n       select case(cmd)\n       case(\"stddev\")\n          stddev = sqrt(stat_object(0.0, \"variance\"))\n       case(\"variance\")\n          m = stat_object(0.0, \"mean\")\n          if ( num > 0 ) then\n             stddev = summa2/real(num) - m*m\n          else\n             stddev = 0.0\n          end if\n       case(\"count\")\n          stddev = real(num)\n       case(\"mean\")\n          if ( num > 0 ) then\n             stddev = summa/real(num)\n          else\n             stddev = 0.0\n          end if\n       case(\"reset\")\n          summa = 0.0\n          summa2 = 0.0\n          num = 0\n       case default\n          stddev = 0.0\n       end select\n    end if\n\n  end function stat_object\n"}, {"instruction": "Write a Fortran function named vmin to calculate the minimum velocity required for a specified orbit. The function takes 3 input arguments of type double precision (e, a, m_x) and returns 1 output argument of type double precision.", "input": "", "output": "function vmin(e, a, m_x)\n    double precision :: e,a,m_x,vmin\n    !double precision :: hour,julianday\n    \n    double precision :: m_a, mu\n    m_a = a*0.9315\n    mu =  (m_a*m_x)/(m_a+m_x)\n    vmin = 3d5*sqrt((e/1d6)*(m_a)/(2*mu*mu))\nend function vmin\n"}, {"instruction": "Write a Fortran function called reduced_m that takes two double precision input parameters, a and m_x. It calculates the value of m_a as 0.9315 times a, then computes the value of reduced_m using the formula (m_a * m_x)/(m_a + m_x). The function returns a double precision value as the output.", "input": "", "output": "function reduced_m(a, m_x)\n    double precision :: a, m_x, m_a, reduced_m\n    \n    m_a = 0.9315*a\n    reduced_m =  (m_a * m_x)/(m_a + m_x)\nend function reduced_m  \n"}, {"instruction": "Create a Fortran pure function named cpi_t that takes 3 input real numbers and returns 1 real number. The input parameters are k, rtndt, and t. The function uses the parameters to calculate and return the value of cpi_t.", "input": "", "output": "  pure function cpi_t(k, rtndt, t)\n\n    real :: cpi_t\n    real, intent(in) :: k, rtndt, t\n    real, parameter :: ckic = 4.0\n\n    associate( &\n      akic => 19.35+8.335*exp(0.02254*(t-rtndt)), &\n      bkic => 15.61+50.132*exp(0.008*(t-rtndt)) &\n    )\n      cpi_t = merge(0.0,1-exp(-((k-akic)/bkic)**ckic), k < akic)\n    end associate\n\n  end function cpi_t\n"}, {"instruction": "Create a Fortran function named \"bar\" that takes two integer input parameters and returns a single integer output. The input parameters should be of type \"integer\" and passed with the intent \"in.\" The output parameter should also be of type \"integer.\" The function should compute a value based on the input parameters and other local variables.", "input": "", "output": "  function bar (a, b)\n    integer, intent (in) :: a, b\n    integer :: bar\n    common /blk/ q, e\n    integer :: q, r, d, s\n    logical :: e\n    s = 7\n!$omp taskloop lastprivate (s)\n    do d = a, b - 1\n      if (d < 12 .or. d > 17) then\n!$omp atomic write\n        e = .true.\n      end if\n      s = d\n    end do\n!$omp end taskloop\n    bar = s\n  end function bar\n"}, {"instruction": "Create a Fortran function named \"score\" to calculate a score based on an integer input. The function takes 1 input parameter with the test_data type ['integer*8'] and returns 1 output parameter with the test_data type ['integer*8']. The score is computed by multiplying prime numbers based on the digits of the input number.", "input": "", "output": "  pure function score(n)\n    implicit none\n    integer*8, intent(in)             :: n\n    integer*8                         :: temp,score\n    integer, parameter, dimension(10) :: primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]\n\n    score=1\n    temp=n\n    do while (temp > 0)\n       score=score*primes(mod(temp,10)+1)\n       temp=temp/10\n    end do\n    \n  end function score\n"}, {"instruction": "Create a Fortran function named stoch_dist to calculate the stochastic distance based on the input parameters d1, d2, w1, and w2, all of which are of type double precision. The function returns a single double precision value.", "input": "", "output": "function stoch_dist(d1, d2, w1, w2) result(a)\n\n    implicit none\n\n    double precision, intent(in) :: d1\n    double precision, intent(in) :: d2\n    double precision, intent(in) :: w1\n    double precision, intent(in) :: w2\n\n    double precision :: a\n\n    a = w1**2/(w1**2 + d1**2) * w2**2/(w2**2 + d2**2)\n\nend function stoch_dist\n"}, {"instruction": "Write a Fortran function named dist that calculates a distance metric based on the input parameters. The function takes 4 input arguments of type double precision and returns 1 output argument of type double precision. The input parameters are x1, x2, w1, and w2.", "input": "", "output": "function dist(x1, x2, w1, w2) result(a)\n\n    implicit none\n\n    double precision, intent(in) :: x1\n    double precision, intent(in) :: x2\n    double precision, intent(in) :: w1\n    double precision, intent(in) :: w2\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n\n    double precision :: a\n\n    a = exp(-((x1-x2)**2)/(4.0d0*w1**2)) *  (1.0d0 - sin(pi * x1/(2.0d0 * w2))) * &\n        & (1.0d0 - sin(pi * x2/(2.0d0 * w2)))\n\nend function dist\n"}, {"instruction": "Create a Fortran function named \"skalarprodukt\" to calculate the scalar product of two real arrays. The function should have 2 input parameters of type real arrays and 1 output parameter of type real. Use the \"intent(in)\" attribute for the input parameters.", "input": "", "output": "  pure function skalarprodukt(vec_1,vec_2)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    real :: skalarprodukt\n    real :: vec_1(:)\n    real :: vec_2(:)\n    intent(in) :: vec_1,vec_2\n    !--------------------------------------------------------------------------\n    skalarprodukt=sum(vec_1(:)*vec_2(:))\n    !                                                  !\n  end function skalarprodukt\n"}, {"instruction": "Create a Fortran function named determinant2d to calculate the determinant of a 2x2 matrix. The function takes 2 input parameters of type real and returns 1 output parameter of type real. Use the imperative tone and ensure that the number and type of input and output parameters are specified in the instruction.", "input": "", "output": "  pure function determinant2d(a,b)\n    !------------------------------------------------------------------------!\n    implicit none\n    !------------------------------------------------------------------------!\n    real              :: determinant2d\n    real              :: a(2),b(2)\n    !------------------------------------------------------------------------!\n    intent(in)        :: a,b\n    !------------------------------------------------------------------------!\n\n    determinant2d=a(1)*b(2)-a(2)*b(1)\n\n  end function determinant2d\n"}, {"instruction": "Write a pure Fortran function named determinant3d to calculate the determinant of a 3x3 matrix. The function should have 3 input parameters of type real, named a, b, and c. The output should be a single real value representing the determinant of the matrix.", "input": "", "output": "  pure function determinant3d(a,b,c)\n    !------------------------------------------------------------------------!\n    implicit none\n    !------------------------------------------------------------------------!\n    real              :: determinant3d\n    real              :: a(3),b(3),c(3)\n    !------------------------------------------------------------------------!\n    intent(in)        :: a,b,c\n    !------------------------------------------------------------------------!\n    determinant3d=a(1)*b(2)*c(3)-a(1)*b(3)*c(2)+a(2)*b(3)*c(1)-a(2)*b(1)*c(3) &\n                  +a(3)*b(1)*c(2)-a(3)*b(2)*c(1)\n  end function determinant3d\n"}, {"instruction": "Create a Fortran function named morlet to calculate the Morlet wavelet with two input parameters of type real, and one output parameter of type complex. The input parameters are s and fa, and the output parameter is morlet. If fa is equal to 0, set morlet to (0,0); otherwise, calculate morlet using the formula provided. Remember to use the constants pi, w0, and pi14 in the calculation.", "input": "", "output": "  function morlet ( s, fa )\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    real,     parameter  :: pi = 3.14159265359\n    real,     parameter  :: w0 = 6. \n    real, parameter      :: pi14 =  0.7511255444649\n    real,     intent(in) :: s, fa\n    complex              :: morlet\n    !--------------------------------------------------------------------------\n    if (fa == 0.) then \n      morlet = (0.,0.)\n    else\n      morlet = cmplx(pi14*exp( (-(s*2.*pi*fa-w0)**2) / 2.),0.)\n    endif\n\n  end function morlet\n"}, {"instruction": "Create a Fortran function named xyintriangle to determine if a point (x,y) lies within a triangle defined by three vertices. The function takes 5 input parameters of type real and returns 1 output parameter of type logical. The input parameters are x, y, xtri(3), ytri(3), epsilon. The function uses the imperative tone to calculate the volume and check if the point lies within the triangle using the given epsilon tolerance.", "input": "", "output": "  function xyintriangle(x,y,xtri,ytri,epsilon)\n     implicit none\n\n     logical :: xyintriangle\n     real x,y,xtri(3),ytri(3),epsilon\n     real xi, eta\n     real volume\n     intent(in) :: x,y,xtri,ytri,epsilon\n\n     ! compute volume\n     volume = 0.5*( (xtri(2)-xtri(1))*(ytri(3)-ytri(1))-(xtri(3)-xtri(1))*(ytri(2)-ytri(1)) )\n\n     xi  = 0.5/volume*( ( xtri(3)*ytri(1) - xtri(1)*ytri(3) ) + &\n         x*(ytri(3)-ytri(1)) + &\n         y*(xtri(1)-xtri(3)) )\n     eta = 0.5/volume*( ( xtri(1)*ytri(2) - xtri(2)*ytri(1) ) + &\n         x*(ytri(1)-ytri(2)) + &\n         y*(xtri(2)-xtri(1)) )\n\n     ! because of numerical errors, it is possible that a point which lies     !\n     ! exactly on the boundary is considered outside the element               !\n     ! so we set a tolerance value of epsilon which allows points lo lie       !\n     ! slightly out of the element. this is necessary because fluxes are       !\n     ! calculated on boundary points!                                          !\n     ! for epsilon we choose 1e-5                                              !\n\n     if((xi.lt.(0.-epsilon)).or.(eta.lt.(0.-epsilon)).or. &\n         (eta.gt.(1.-xi+epsilon))) then\n         xyintriangle = .false.\n     else\n         xyintriangle = .true.\n     endif\n\n   end function xyintriangle\n"}, {"instruction": "Write a Fortran function named ky that takes an integer dimf and an array lyap of real numbers as input. It returns a real number as output. The number of input parameters is 2, with test_data type ['integer', 'real(kind=8),dimension(dimf)'], and the number of output parameters is 1, with test_data type ['real(kind=8)']. The function calculates the value of ky based on the input parameters and returns the result.", "input": "", "output": "function ky(lyap,dimf)\r\ninteger :: dimf,i\r\nreal(kind=8) :: ky\r\nreal(kind=8),dimension(dimf) :: lyap\r\nky=0.0d0\r\ni=0\r\ndo while (ky.ge.0 .and. i<dimf)\r\n  i=i+1\r\n  ky=ky+lyap(i)\r\nend do\r\nky=i-1+(ky-lyap(i))/(lyap(i))\r\nreturn\r\nend function\r\n"}, {"instruction": "Create a Fortran function named get_ndigit to calculate the number of digits in an integer value. The function takes 1 input argument of type integer(8) and returns 1 output argument of type integer.", "input": "", "output": "  function get_ndigit(value) result(ndigit)\n    implicit none\n\n    integer(8), intent(in) :: value\n    integer :: ndigit\n\n    ndigit = floor(log10(real(value)) + 1)\n  end function get_ndigit\n"}, {"instruction": "Write a Fortran function called in_list to check if a specific string is present in another string. The function takes 3 input arguments of type character(len=*), character(len=*), and character (optional) respectively. The output parameter is of type logical. Ensure that the function is named in_list.", "input": "", "output": "  function in_list(string, search, delim) result(found)\n\n    implicit none\n\n    character(len=*),    intent(in) :: string, search\n    character, optional, intent(in) :: delim\n    logical                         :: found\n\n    character :: c\n    integer   :: i1, i2\n    integer   :: slen\n\n    if (present(delim)) then\n       c = delim\n    else\n       c = ':'\n    end if\n\n    slen = len_trim(string)\n\n    found = .false.\n    i1    = 1\n    i2    = scan(string, c)\n    \n    do while(i2 >= i1)\n       if (trim(adjustl(string(i1:i2-1))) == trim(adjustl(search))) then\n          found = .true.\n          exit\n       end if\n       i1 = i2 + 1\n       i2 = i1 + scan(string(i1:slen), c) - 1\n    end do\n\n    if (trim(adjustl(string(i1:slen))) == trim(adjustl(search))) then\n       found = .true.\n    end if\n\n  end function in_list\n"}, {"instruction": "Create a Fortran function named mnt_regridedges_build to initialize a regridding object. The function takes 4 input parameters of type c_ptr, integer(c_int), real(c_double), and integer(c_int). The function returns an output of type integer(c_int).", "input": "", "output": "    function mnt_regridedges_build(obj, num_cells_per_bucket, periodx, debug) &\r\n                                   bind(c, name='mnt_regridedges_build')\r\n      use, intrinsic :: iso_c_binding, only: c_int, c_double, c_ptr\r\n      implicit none\r\n      type(c_ptr), intent(inout)       :: obj !> void**\r\n      integer(c_int), value            :: num_cells_per_bucket\r\n      real(c_double), value            :: periodx\r\n      integer(c_int), value            :: debug\r\n      integer(c_int)                   :: mnt_regridedges_build\r\n    end function mnt_regridedges_build\r\n"}, {"instruction": "Create a Fortran function named tr_m to calculate the trace of a square matrix. The input parameter is a 2D array of double precision, and the output parameter is a double precision value. The function iterates through the diagonal elements of the input matrix to compute the trace. If the input matrix is not square, an error message is displayed.", "input": "", "output": "function tr_m(a) result (tra)\nimplicit none\n\n      integer i\n      double precision, dimension(:,:), intent (in) :: a\n      double precision :: tra      \n      if(size(a,2).ne.size(a,1))then\n        write(*,*) 'not square matrix in us_trm_f';read(*,*)\n      else\n        tra=0.d0;do i=1,size(a,1);tra=tra+a(i,i);enddo\n      endif \n            \nend function \n"}, {"instruction": "Create a Fortran pure function named ineligible to determine if the sum of the number of digits in two integers and the number of digits in their product is greater than 9. The function takes 2 input arguments of type integer and returns 1 output argument of type logical.", "input": "", "output": "  pure function ineligible(a,b)\n    implicit none\n    integer, intent(in) :: a,b\n    logical             :: ineligible\n\n    ineligible=(digits(a)+digits(b)+digits(a*b) > 9)\n  end function ineligible\n"}, {"instruction": "Create a Fortran function named pandigital that takes two integer input parameters. The test_data type for the input parameters should be ['integer', 'integer']. The function returns a single logical output parameter. The test_data type for the output parameter is ['logical']. The function checks if the concatenation of the input numbers and their product results in a pandigital number (containing all the digits from 1 to 9 exactly once) and returns a logical value accordingly.", "input": "", "output": "  pure function pandigital(a,b)\n    implicit none\n    integer, intent(in)   :: a,b\n    integer               :: i,j,k,temp\n    integer, dimension(9) :: d\n    logical               :: pandigital\n\n    if (digits(a)+digits(b)+digits(a*b) /= 9) then\n       pandigital=.false.\n       go to 1\n    end if\n\n    do i=1,9\n       d(i)=0\n    end do\n\n    i=a\n    j=b\n    k=a*b\n\n    do while (i > 0)\n       temp=mod(i,10)\n       d(temp)=d(temp)+1\n       i=i/10\n    end do\n\n    do while (j > 0)\n       temp=mod(j,10)\n       d(temp)=d(temp)+1\n       j=j/10\n    end do\n\n    do while (k > 0)\n       temp=mod(k,10)\n       d(temp)=d(temp)+1\n       k=k/10\n    end do\n\n    do i=1,9\n       if (d(i) /= 1) then\n          pandigital=.false.\n          go to 1\n       end if\n    end do\n\n    pandigital=.true.\n\n1 end function pandigital\n"}, {"instruction": "Create a Fortran function called randomspin to generate a random integer representing a spin on a lattice. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument, n, represents the number of lattice sites, and the output argument, randomspin, represents the randomly chosen spin.", "input": "", "output": "    function randomspin(n)\n    integer :: n, count, randomspin\n    real :: rand, scaled\n    call random_number(rand)\n    scaled = rand * n !scales to number of sites\n    do count=1,(n+1) !picks spin corresponding to scaled random number\n        if (scaled>=(count-1) .and. scaled<count) randomspin = count\n    end do\n    end function randomspin\n"}, {"instruction": "Write a Fortran function named kd that takes two integer input parameters and returns an integer output. The number of input parameters in this code is 2, and the test_data type is ['integer', 'integer']. The number of output parameters is 1, and the test_data type is ['integer']. This function sets the output integer kd to 1 if the input integers i and j are equal; otherwise, it sets kd to 0.", "input": "", "output": "pure function kd(i,j)\ninteger, intent(in) :: i,j\ninteger :: kd\nkd=0\nif(i.eq.j) then\nkd = 1\nelse \nkd = 0\nend if\nend function kd\n"}, {"instruction": "Create a Fortran function named \"per\" to determine the parity of a permutation based on the input integers i, j, and k. The number of input parameters is 3 with test data type ['integer', 'integer', 'integer'], and the number of output parameters is 1 with test data type ['integer']. If the permutation is even, the function returns 1; if the permutation is odd, the function returns -1; otherwise, it returns 0.", "input": "", "output": "pure function per(i,j,k)\ninteger,intent(in) :: i,j,k\ninteger :: per\nper=0\nif((i.eq.1).and.(j.eq.2).and.(k.eq.3)) then\nper = 1\nelse if((i.eq.2).and.(j.eq.3).and.(k.eq.1)) then\nper = 1\nelse if((i.eq.3).and.(j.eq.1).and.(k.eq.2)) then\nper = 1\nelse if((i.eq.1).and.(j.eq.3).and.(k.eq.2)) then\nper = -1\nelse if((i.eq.2).and.(j.eq.1).and.(k.eq.3)) then\nper = -1\nelse if((i.eq.3).and.(j.eq.2).and.(k.eq.1)) then\nper = -1\nelse\n        per=0\nend if\nend function per\n"}, {"instruction": "Create a Fortran function named chr_lpad that takes a string and a size as input. The input parameters should have the test_data type ['character(len=*)', 'integer']. The function should return a padded string as output with the test_data type ['character(len=:), allocatable'].", "input": "", "output": "function chr_lpad(thestring, thesize) result(retstring)\n  character(len=*), intent(in)  :: thestring\n  integer,          intent(in)  :: thesize\n  character(len=:), allocatable :: retstring\n  integer                       :: insize\n  insize = len(thestring)\n  if(insize > 0 .and. insize < thesize) then\n    retstring = repeat(\" \",thesize-insize)//thestring(1:insize)\n  else\n    retstring = thestring\n  end if\nend function chr_lpad\n"}, {"instruction": "Create a Fortran function named chr_rpad that takes a string and a size as input. The input parameters should be of type character(len=*) and integer, respectively. The function should return a string with a length that is either the length of the input string or the specified size, whichever is larger. The output parameter should be of type character(len=:), allocatable.", "input": "", "output": "function chr_rpad(thestring, thesize) result(retstring)\n  character(len=*), intent(in)  :: thestring\n  integer,          intent(in)  :: thesize\n  character(len=:), allocatable :: retstring\n  integer                       :: insize\n  insize = len(thestring)\n  if(insize > 0 .and. insize < thesize) then\n    retstring = thestring(1:insize)//repeat(\" \",thesize-insize)\n  else\n    retstring = thestring\n  end if\nend function chr_rpad\n"}, {"instruction": "Write a Fortran function named chr_lpadcut to adjust the length of a string by padding or cutting it as needed. The function takes 2 input parameters of type character(len=*) and integer, and returns 1 output parameter of type character(len=thesize). The function uses the imperative tone.", "input": "", "output": "function chr_lpadcut(thestring, thesize) result(retstring)\n  character(len=*), intent(in) :: thestring\n  integer,          intent(in) :: thesize\n  character(len=thesize) :: retstring\n  integer                :: insize\n  insize = len(thestring)\n  if(insize > thesize) then\n    retstring = thestring(1:thesize)\n  elseif(insize > 0) then\n    retstring = repeat(\" \",thesize-insize)//thestring(1:insize)\n  else\n    retstring = repeat(\" \",thesize)\n  end if\nend function chr_lpadcut\n"}, {"instruction": "Write a Fortran function named chr_instr to count the occurrences of a specific character within a given string. The number of input arguments is 2, with test_data types ['character(len=*)', 'character(len=1)']. The number of output arguments is 1, with a test_data type of ['integer'].", "input": "", "output": "function chr_instr(thestring, theneedle) result(nneedle)\n\n  character(len=*), intent(in)  :: thestring\n  character(len=1), intent(in)  :: theneedle\n  integer                       :: nneedle\n\n  integer ch\n\n  nneedle = 0\n  do ch=1, len(thestring)\n    if(thestring(ch:ch) == theneedle) then\n      nneedle = nneedle + 1\n    end if\n  end do\n\nend function chr_instr\n"}, {"instruction": "Write a Fortran function named t2pott to calculate the potential temperature based on the input parameters temperature (real), salinity (real), and pressure (real). The potential temperature is returned as output of type real.", "input": "", "output": "  function t2pott(t, s, p)\n    implicit none\n    real                              :: s        ! [psu]\n    real                              :: p        ! [dbar]\n    real                              :: t        ! [c] temperature\n    real                              :: t2pott   ! [c] potential temperature    \n    real                              :: s_rel\n    real  :: a_a1 = 3.6504e-4, a_a2 = 8.3198e-5, a_a3 = 5.4065e-7, a_a4 = 4.0274e-9\n    real  :: a_b1 = 1.7439e-5, a_b2 = 2.9778e-7\n    real  :: a_c1 = 8.9309e-7, a_c2 = 3.1628e-8, a_c3 = 2.1987e-10\n    real  :: a_d = 4.1057e-9, a_e1 = 1.6056e-10, a_e2 = 5.0484e-12\n    real  :: aa, bb, cc, cc1, dd\n\n    s_rel = s - 35.0;\n\n    aa = (a_a1+ t *(a_a2 - t*(a_a3 - a_a4*t)));\n    bb = s_rel*(a_b1 -a_b2*t)     ;\n    cc = (a_c1 + t*(-a_c2 + a_c3*t));\n    cc1 = a_d*s_rel;\n    dd = (-a_e1 + a_e2*t);\n\n    t2pott = t - p * ( aa + bb + p * (cc - cc1 + p * dd) )\n\n  end function t2pott\n"}, {"instruction": "Write a Fortran function named dist_sq to calculate the squared distance between two line segments. The function takes 5 input parameters of type real: rij_sq, rei, rej, eij, and ell. It returns 1 output parameter of type real: sij_sq.", "input": "", "output": "  function dist_sq ( rij_sq, rei, rej, eij, ell ) result ( sij_sq )\n    implicit none\n    real             :: sij_sq ! returns squared distance between line segments\n    real, intent(in) :: rij_sq ! squared centre-centre distance\n    real, intent(in) :: rei    ! scalar product rij.ei where ei is unit vector along i\n    real, intent(in) :: rej    ! scalar product rij.ej where ej is unit vector along j\n    real, intent(in) :: eij    ! scalar product ei.ej\n    real, intent(in) :: ell    ! line segment length\n\n    real            :: sin_sq, ci, cj, ai, aj, di, dj, ell2\n    real, parameter :: tol = 1.e-6\n\n    sin_sq = 1.0 - eij**2 ! squared sine of angle between line segments\n    ell2   = ell / 2.0    ! half the line segment length\n\n    if ( sin_sq < tol ) then ! guard against nearly-parallel lines\n       ci = -rei\n       cj =  rej\n    else\n       ci = ( - rei + eij * rej ) / sin_sq\n       cj = (   rej - eij * rei ) / sin_sq\n    endif\n\n    ai = abs ( ci )\n    aj = abs ( cj )\n    if ( ai > ell2 ) ci = sign ( ell2, ci )\n    if ( aj > ell2 ) cj = sign ( ell2, cj )\n\n    if ( ai > aj ) then\n       cj =  rej + ci * eij\n    else\n       ci = -rei + cj * eij\n    endif\n\n    ai = abs ( ci )\n    aj = abs ( cj )\n    if ( ai > ell2 ) ci = sign ( ell2, ci )\n    if ( aj > ell2 ) cj = sign ( ell2, cj )\n\n    di =  2.0 * rei + ci - cj * eij\n    dj = -2.0 * rej + cj - ci * eij\n\n    sij_sq = rij_sq + ci * di + cj * dj\n\n  end function dist_sq\n"}, {"instruction": "Write a Fortran function named gaspari_cohn_mid to calculate the Gaspari-Cohn correlation function value based on the input parameters z and c. The function should take 2 input arguments of type real(kind=8) and return 1 output argument of type real(kind=8).", "input": "", "output": "  function gaspari_cohn_mid(z, c) result(f)\n    real(kind=8), intent(in)::z, c\n    real(kind=8)::f\n    f = 1./12*(z/c)**5 - 0.5*(z/c)**4 + 5./8*(z/c)**3 &\n        + 5./3*(z/c)**2 - 5*z/c - 2./3*c/z + 4\n  end function gaspari_cohn_mid\n"}, {"instruction": "Write a Fortran function named rmsd to calculate the Root Mean Square Deviation (RMSD) of an array of double precision numbers. The function takes 2 input parameters: an array of double precision numbers and an integer representing the array size. The output is a single double precision value representing the RMSD.", "input": "", "output": "function rmsd(array, n) result(var)\n\ndouble precision, dimension(:), intent(in) :: array\ninteger, intent(in) :: n\ndouble precision :: var\n\ndouble precision, dimension(n) :: dev\ndouble precision :: mean\n\nmean = sum(array) / n\n\n!allocate(dev(n))\ndev = array - mean\nvar = sqrt(sum(dev*dev) / n)\n!deallocate(dev)\n\nend function\n"}, {"instruction": "Create a Fortran function named fuel to calculate the fuel required based on the mass of an object. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. The input parameter is of type ['integer'] and the output parameter is of type ['integer'].", "input": "", "output": "function fuel(mass) result(f)\n    implicit none\n    integer :: f\n    integer, intent(in) :: mass\n    f = 0\n    if (mass.gt.6) then\n        f = int(real(mass) / 3.0 - 2)\n    end if\nend function fuel\n"}, {"instruction": "Write a Fortran function named stringfromint to convert a positive integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function stringfromint(x)\n            !! make a string of \"correct\" length from a positive integer.\n            character(len=:), allocatable :: stringfromint\n                !! string containing the given integer, without spaces.\n            integer, intent(in) :: x\n                !! positive integer to be converted.\n            integer :: numdigits\n\n            numdigits = int(log10(real(x))) + 1\n            allocate(character(len=numdigits) :: stringfromint)\n            write(unit=stringfromint, fmt=\"(i0)\") x\n        end function\n"}, {"instruction": "Create a Fortran function called find_intersection to find the common element in two arrays, given the total number of unique elements. The function takes 3 input parameters of type integer, dimension(:), integer, and returns 1 output parameter of type integer. The test_data type for input parameters is ['integer, dimension(:)', 'integer, dimension(:)', 'integer'], and for the output parameter, it is ['integer'].", "input": "", "output": "        function find_intersection(array1, array2, num_labels) result(intersect_label)\n            !! find the common element in two arrays, given a total of\n            !! **num_labels** unique elements. used by [[find_spanning_cluster]].\n            integer, dimension(:), intent(in) :: array1, array2\n                !! array to analyse.\n            integer, intent(in) :: num_labels\n                !! the known number of unique non-zero elements.\n            integer :: intersect_label\n                !! the first non-zero common element.\n            integer :: l, i\n            logical, dimension(:), allocatable :: label_found\n\n            l = size(array1)\n\n            allocate(label_found(0:num_labels))\n            !/intersectsnippetstart/!\n            label_found(0:num_labels) = .false.\n\n            do i=1,l\n                label_found(array1(i)) = .true.\n            end do\n\n            do i=1,l\n                if(array2(i) /= 0 .and. label_found(array2(i))) then\n                    intersect_label = array2(i)\n                    return\n                end if\n            end do\n            !/intersectsnippetend/!\n\n            intersect_label = -1\n        end function\n"}, {"instruction": "Create a Fortran function named logi that takes an integer input argument and returns a complex number of kind(1d0). The function should convert the input integer to a real number, compute its natural logarithm, and return the result as a complex number. The number of input arguments is 1 and the test_data type is ['integer'], and the number of output arguments is 1 and the test_data type is ['complex(kind(1d0))'].", "input": "", "output": "function logi(x)\r\n  complex(kind(1d0))::logi\r\n  integer,intent(in)::x\r\n  real(kind(1d0))::xx\r\n  xx=x\r\n  logi=dlog(xx)\r\n  return\r\nend function logi\r\n"}, {"instruction": "Write a Fortran function named logr that takes a real number as input and returns the natural logarithm of the input as a complex number. The number of input arguments is 1 and the test_data type is [real(kind(1d0))]. The number of output arguments is 1 and the test_data type is [complex(kind(1d0))].", "input": "", "output": "function logr(x)\r\n  complex(kind(1d0))::logr\r\n  real(kind(1d0)),intent(in)::x\r\n  logr=dlog(x)\r\n  return\r\nend function logr\r\n"}, {"instruction": "Create a Fortran function named logc that takes a single input argument of type complex(kind(1d0)) and returns a single output argument of the same type. The purpose of this function is to compute the complex natural logarithm of the input value.", "input": "", "output": "function logc(x)\r\n  complex(kind(1d0))::logc\r\n  complex(kind(1d0)),intent(in)::x\r\n  logc=cdlog(x)\r\n  return\r\nend function logc\r\n"}, {"instruction": "Write a Fortran function named csqrtr to compute the square root of a real number, returning a complex result. The function should accept 1 input parameter of type real(kind(1d0)) and return 1 output parameter of type complex(kind(1d0)).", "input": "", "output": "function csqrtr(x)\r\n  implicit none\r\n  complex(kind(1d0))::csqrtr\r\n  real(kind(1d0)),intent(in)::x\r\n  complex(kind(1d0))::xx\r\n  if(x.ge.0d0)then\r\n     csqrtr=dcmplx(dsqrt(x))\r\n  else\r\n     xx=x\r\n     csqrtr=cdsqrt(xx)\r\n  endif\r\n  return\r\nend function csqrtr\r\n"}, {"instruction": "Write a Fortran function named csqrtc that computes the square root of a complex number. The function should take 1 input parameter of type complex(kind(1d0)) and return 1 output parameter of the same type.", "input": "", "output": "function csqrtc(x)\r\n  implicit none\r\n  complex(kind(1d0))::csqrtc\r\n  complex(kind(1d0)),intent(in)::x\r\n  csqrtc=cdsqrt(x)\r\n  return\r\nend function csqrtc\r\n"}, {"instruction": "Create a Fortran function named determinant_3x3_real to calculate the determinant of a 3x3 real*8 matrix. The input parameter is a 3x3 real*8 array, and the output parameter is a real*8 value.", "input": "", "output": "  pure function determinant_3x3_real(a) result(det)\n    real*8, dimension(3,3), intent(in) :: a\n    real*8 :: det\n    !\n    det = a(1,1)*(a(2,2)*a(3,3) - a(3,2)*a(2,3)) &\n        + a(1,2)*(a(3,1)*a(2,3) - a(2,1)*a(3,3)) &\n        + a(1,3)*(a(2,1)*a(3,2) - a(3,1)*a(2,2))\n  end function\n"}, {"instruction": "Create a Fortran function named f_enthal that takes two input arguments of type real(kind(0.d0)) and returns one output argument of the same type. The function computes and returns the value of f_enthal based on the input parameters cpinf and cpbw.", "input": "", "output": "  function f_enthal( cpinf,cpbw )\n\n    real(kind(0.d0)), intent(in) :: cpinf\n    real(kind(0.d0)), intent(in) :: cpbw\n    real(kind(0.d0)) :: tmp1, tmp2, tmp3\n    real(kind(0.d0)) :: f_enthal\n\n    tmp1 = ( n_tait-1.d0 )/n_tait\n    tmp2 = (  cpbw/(1.d0+b_tait)+1.d0 )**tmp1\n    tmp3 = ( cpinf/(1.d0+b_tait)+1.d0 )**tmp1\n    f_enthal = ( tmp2-tmp3 )*n_tait*( 1.d0+b_tait )/( n_tait-1.d0 )\n\n  end function f_enthal\n"}, {"instruction": "Write a Fortran function named f that takes two input parameters, a real number t and an array of two real numbers x. The function computes two real numbers and returns them as an array. The input parameters are of type real and real, dimension(2), and the output parameter is of type real, dimension(2).", "input": "", "output": "    function f(x, t)\n        implicit none\n        real, intent(in) :: t\n        real, dimension(2), intent(in) :: x\n        real, dimension(2) :: f\n\n        f(1) = x(2) \n        f(2) = -x(1) \n    end function\n"}, {"instruction": "Write a Fortran function called gcd to calculate the greatest common divisor of two integers. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. Use the following signature for the function: \n\n```fortran\nfunction gcd(a, b) result(tempb)\n  implicit none\n  integer, intent(in) :: a, b\n  integer :: tempa, tempb, place_holder\n  ...\nend function gcd\n```", "input": "", "output": "function gcd(a, b) result (tempb)\n    implicit none\n    integer, intent(in) :: a, b\n    integer :: tempa, tempb, place_holder\n    \n    tempa = a\n    tempb = b\n    \n    do while (.not.tempa.eq.0)\n    \n        place_holder = tempa\n    \n        if (tempa.eq.0) then\n            exit\n        end if\n    \n        tempa = mod(tempb,tempa)\n        tempb = place_holder\n    \n    end do\n    \nend function gcd\n"}, {"instruction": "Write a Fortran function named all_caps to convert a given input string to all uppercase letters. The function takes 1 input parameter of type character(len=*), and returns 1 output parameter of type character(len=len(string)).", "input": "", "output": "function all_caps( string ) result(caps)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: caps\n\n    character(len=1)             :: ch\n    integer                      :: i\n\n    integer, parameter :: shift = iachar('a') - iachar('a')\n\n    do i = 1,len(string)\n        ch = string(i:i)\n        if ( iachar(ch) >= iachar('a') .and. iachar(ch) <= iachar('z') ) then\n            caps(i:i) = achar(iachar(ch)+shift)\n        else\n            caps(i:i) = ch\n        endif\n    enddo\nend function all_caps\n"}, {"instruction": "Create a Fortran function named leapy to determine if a given year is a leap year. The function takes 1 input parameter of type real, representing the year. It returns 1 output parameter of type logical, indicating whether the year is a leap year or not.", "input": "", "output": "function leapy(yr)\n  implicit none\n  logical           :: leapy\n  real, intent(in)  :: yr\n\n  if (mod(yr, 4.0) .ne. 0) then\n     leapy = .false.\n  elseif(mod(yr, 25.0) .ne. 0) then\n     leapy = .true.\n  elseif(mod(yr, 16.0) .ne. 0) then\n     leapy = .false.\n  else\n     leapy = .true.\n  endif\n\nend function leapy\n"}, {"instruction": "Write a Fortran function named cut_function that takes 3 input parameters of type double precision: r, cut_start, and cut_distance. The function returns a single output parameter of type double precision. The function computes a damping factor based on the input parameters, where the damping factor is 1.0 when r is less than the product of cut_start and cut_distance, 0.0 when r is greater than cut_distance, and a smoothly varying function of r between these limits.", "input": "", "output": "pure function cut_function(r, cut_start, cut_distance) result(f)\n\n    implicit none\n\n    ! distance\n    double precision, intent(in) :: r\n\n    ! lower limit of damping\n    double precision, intent(in) :: cut_start\n\n    ! upper limit of damping\n    double precision, intent(in) :: cut_distance\n\n    ! intermediate variables\n    double precision :: x\n    double precision :: rl\n    double precision :: ru\n\n    double precision :: f\n\n    ru = cut_distance\n    rl = cut_start * cut_distance\n\n    if (r > ru) then\n\n        f = 0.0d0\n\n    else if (r < rl) then\n\n        f = 1.0d0\n\n    else\n\n        x = (ru - r) / (ru - rl)\n        f = (10.0d0 * x**3) - (15.0d0 * x**4) + (6.0d0 * x**5)\n\n    endif\n\nend function cut_function\n"}, {"instruction": "Create a Fortran function named var_kind that takes one integer input argument and returns an integer output argument. The input argument's data type should be 'integer', and the output argument's data type should also be 'integer'. This function determines the kind of a variable based on the input kind value and returns the appropriate kind value.", "input": "", "output": "  function var_kind(vkind) result(varkind)\n    integer:: vkind\n    integer:: varkind\n    if(vkind<=pm_null) then\n       varkind=pm_pointer\n    else  if(vkind>=pm_string) then\n       varkind=pm_pointer\n    else\n       varkind=vkind\n    endif\n  end function var_kind\n"}, {"instruction": "Create a Fortran function named \"ufn\" to calculate the value of \"ufn\" using the input parameters \"gammz\", \"z1\", and \"z2\", which are real(8) data types. The output parameter \"ufn\" is also of type real(8).", "input": "", "output": " function ufn(gammz,z1,z2)\n\n\t \n implicit none\n\n real(8), intent(in) :: gammz, z1, z2\n real(8) :: ufn\n \n ufn = ( ( (3.0+gammz**2)*z1 + 2.0*gammz*z2 ) / &\n       gammz**2 / (1.0-gammz**2) )\n  \n return\n\n end function\n"}, {"instruction": "Create a Fortran function named compute_pi to estimate the value of pi using the Monte Carlo method. The function has 1 input parameter of type integer. The output parameter is 1, of type real(kind=8).", "input": "", "output": "function compute_pi(n) result(pi)\n    integer, intent(in) :: n\n    real(kind=8) :: pi, x, y\n    integer :: i\n\n    do i = 1, n\n        call random_number(x)\n        call random_number(y)\n        if (x**2.0d00 + y**2.0d00 <= 1.0d00) then\n            pi = pi + 1.0d00\n        end if\n    end do\n    pi = 4.0d00*pi/n\nend function compute_pi\n"}, {"instruction": "Write a Fortran function named stringcompare to compare two strings of characters up to a specified length. The number of input arguments is 3, and the test_data type is ['character*80', 'character*80', 'integer']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "function stringcompare(string1,string2,len)\n  implicit none\n  character*80 :: string1,string2\n  integer :: len\n  integer :: i\n  logical :: stringcompare\n  !\n  if(len > 80) stop\n  if(len <= 0) then\n     stringcompare=.false.\n     return\n  endif\n  stringcompare=.true.\n  do i=1,len\n     if(string1(i:i) /= string2(i:i)) stringcompare=.false.\n  enddo\n  return\nend function stringcompare\n"}, {"instruction": "Create a Fortran function named interp3 to perform trilinear interpolation. The function takes 7 input parameters of real(kind = 8) type, which are x, y, z, v, xq, yq, and zq. The output parameter is a real(kind = 8) type.", "input": "", "output": "  function interp3(x, y, z, v, xq, yq, zq) result(vq)\n    real(kind = 8) :: vq\n    real(kind = 8), intent(in) :: xq, yq, zq\n    real(kind = 8), dimension(:), intent(in) :: x, y, z\n    real(kind = 8), dimension(:,:,:), intent(in) :: v\n    integer(kind = 4) :: nx, ny, nz, i1, i2, j1, j2, k1, k2\n    real(kind = 8) :: x1, x2, y1, y2, z1, z2, v111, v211, v121, v221, &\n      v112, v212, v122, v222\n    real(kind = 8) :: n(8), ax(8), ay(8), az(8), av(8)\n\n    nx = size(v, 1)\n    ny = size(v, 2)\n    nz = size(v, 3)\n    i1 = minloc(xq - x, dim = 1, mask = xq .ge. x)\n    j1 = minloc(yq - y, dim = 1, mask = yq .ge. y)\n    k1 = minloc(zq - z, dim = 1, mask = zq .ge. z)\n    i2 = i1 + 1\n    j2 = j1 + 1\n    k2 = k1 + 1\n\n    if ( i1 .eq. nx .and. j1 .ne. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = v(i1,j2,k1)\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = 0.d0\n      v122 = v(i1,j2,k2)\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = v(i2,j1,k2)\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .ne. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = v(i1,j2,k1)\n      v221 = v(i2,j2,k1)\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .ne. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = v(i1,j2,k1)\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = v(i1,j2,k1)\n      v221 = v(i2,j2,k1)\n      v112 = v(i1,j1,k2)\n      v212 = v(i2,j1,k2)\n      v122 = v(i1,j2,k2)\n      v222 = v(i2,j2,k2)\n    end if\n\n    ax = [ x2, x1, x2, x1, x2, x1, x2, x1 ]\n    ay = [ y2, y2, y1, y1, y2, y2, y1, y1 ]\n    az = [ z2, z2, z2, z2, z1, z1, z1, z1 ]\n    av = [ v111, v211, v121, v221, v112, v212, v212, v222 ]\n    n = dabs( (ax - xq) * (ay - yq) * (az - zq) ) / dabs( (x2 - x1) * (y2 - y1) * (z2 -z1) )\n    vq = dot_product(av, n)\n    return\n  end function interp3\n"}, {"instruction": "Provide a Fortran function named f5 that takes a single character input and returns a character string. The input parameter should have a length of 1 to 8 characters. The output parameter should have a length specified by the result of the scan function. Use a do loop to assign characters to the output string based on the position of the characters in the input string.", "input": "", "output": "  function f5 (c)\r\n    character(len=1_8) :: c\r\n    character(len=scan('123456789', c)) :: f5\r\n    integer :: i\r\n    do i = 1, len (f5)\r\n       f5(i:i) = char (i+96)\r\n    end do\r\n  end function f5\r\n"}, {"instruction": "Create a Fortran function named sigmav_ion that calculates the ionization rate coefficient (sigmav_ion) based on the input electron temperature (te). The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision']. Use the provided code as the function definition.", "input": "", "output": "function sigmav_ion(te)\n  implicit none\n  double precision, parameter :: tm=2.d0 !ev\n  double precision :: sigmav_ion, te, x,y\n  if(te .lt. tm) then\n     sigmav_ion = 0.d0\n     return\n  endif\n  x = log(te)\n  y=-3.271396786375d+01+x*(1.353655609057d+01+x*(-5.739328757388d+00            &\n    +x*(1.563154982022d+00+x*(-2.877056004391d-01+x*(3.482559773737d-02         &\n    +x*(-2.631976175590d-03+x*(1.119543953861d-04+x*(-2.039149852002d-06))))))))\n  sigmav_ion = exp(y)\n return\nend function sigmav_ion\n"}, {"instruction": "Write a Fortran function named lnsig that calculates the length of a string excluding trailing whitespace characters. The input parameter is a character string, and the output parameter is an integer representing the length of the string.", "input": "", "output": "function lnsig(title)\n  implicit none\n  character(len=*) :: title\n  integer :: lnsig, ilen, i\n\n  ilen = len(title)\n  do i = ilen, 1, -1\n     if (title(i:i) /= ' ') exit\n  end do\n  lnsig = i\n  if (i > 0) then\n     if (ichar(title(i:i)) == 0) lnsig = i - 1\n  end if\nend function lnsig\n"}, {"instruction": "Write a Fortran function named lnsig1 to calculate the length of a character string excluding trailing and leading blank spaces. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function lnsig1(text)\n  implicit none\n  integer :: lnsig1, ilen, ii, iend, ibeg, iii\n  character(len=*) :: text\n\n  ilen = len(text)\n  do ii = ilen, 1, -1\n     if (text(ii:ii) /= ' ') exit\n  end do\n  if (ii > 0) then\n     if (ichar(text(ii:ii)) == 0) ii = ii - 1\n  end if\n\n  iend = ii\n  if (iend /= 0) then\n     do ii = 1, iend\n        if (text(ii:ii) /= ' ') exit\n     end do\n     ibeg = ii\n     text(1:iend-ibeg+1) = text(ibeg:iend)\n     if (iend-ibeg+1 /= ilen) then\n        do iii = iend-ibeg+2, ilen\n           text(iii:iii) = ' '\n        end do\n     end if\n     lnsig1 = iend-ibeg+1\n  else\n     lnsig1 = 1\n  end if\nend function lnsig1\n"}, {"instruction": "Create a Fortran function named does_start_with to check if a given string starts with a specified pattern. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type logical. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "  function does_start_with(str,pattern) result (r)\n\n    character(len=*), intent(in) :: str\n    character(len=*), intent(in) :: pattern\n    logical :: r\n\n    if (len(str)<len(pattern)) then       ! if str is shorter than pattern\n      r = .false.  \n    else    \n      r = (str(1:len(pattern))==pattern)  ! otherwise, compare \n    end if\n \n  end function does_start_with\n"}, {"instruction": "Create a Fortran function called normalize to calculate the normalized form of a given vector. The function takes 1 input parameter of type real*8, dimension(:), and intent(in), and returns 1 output parameter of type real*8, dimension(1:size(vector)).", "input": "", "output": "   function normalize( vector )\n   real*8, dimension(:), intent(in) :: vector\n   real*8, dimension(1:size(vector)) :: normalize\n   integer :: n\n   real*8 :: fact\n\n   n = size( vector )\n   fact = sqrt( dot_product( vector(1:n), vector(1:n) ) )\n   if ( fact > 0.0d0 ) normalize = vector / fact\n   end function normalize\n"}, {"instruction": "Create a Fortran function named random_vector that generates an array of random double-precision floating-point numbers. The function takes 1 input argument of type integer, and the test_data type is ['integer']. It returns an array of random double-precision floating-point numbers with a dimension of 1 to n, where n is the input argument. The output test_data type is ['real*8, dimension(1:n)'].", "input": "", "output": "   function random_vector( n )\n   integer, intent(in) :: n\n   real*8, dimension(1:n) :: random_vector\n   integer :: i\n\n   call random_seed\n   do i = 1, n\n       call random_number( random_vector(i) )\n   end do\n   end function random_vector\n"}, {"instruction": "Provide a Fortran function named find_match. The function takes 3 input parameters of type real, real array, and optional integer, and returns 1 output parameter of type real array of size 2. The function searches for a match in the sorted array z for the given value zin and returns the indices where the match is found or the closest indices if no match is found.", "input": "", "output": "    function find_match(zin,z,guess)\n\n        implicit none\n        real, intent(in) :: zin\n        real, intent(in),dimension(:) :: z\n        integer, optional, intent(inout)::guess\n        real,dimension(2) :: find_match\n        integer::n,i,endpt\n\n        n=size(z)\n        find_match(1)=-1\n\n        if (.not.present(guess)) then\n            guess=n/2\n        endif\n\n        if (z(guess)>=zin) then\n            ! then we should search downward from z(guess)\n            endpt=1\n            i=guess\n            do while ((i>=endpt).and.(find_match(1)==-1))\n                if (z(i)<=zin) then\n                    find_match(1)=i\n                    if (i==n) then\n                        ! should only happen if z(i)=zin\n                        find_match(2)=i\n                    else\n                        find_match(2)=i+1\n                    endif\n                endif\n                i=i-1\n            end do\n        else\n            ! then we should search upward from z(guess)\n            endpt=n\n            i=guess\n            do while ((i<=endpt).and.(find_match(1)==-1))\n                if (z(i)>zin) then\n                    find_match(1)=i-1\n                    find_match(2)=i\n                endif\n                i=i+1\n            end do\n\n            if (find_match(1)==-1) then\n                find_match(1)=-2\n            endif\n        endif\n\n    end function find_match\n"}, {"instruction": "Create a Fortran function named map_set_random_seed to set the random seed for the random number generator. The function takes 1 input parameter of type integer. The output is also an integer. Use the imperative tone to indicate the action to be performed.", "input": "", "output": "function map_set_random_seed(rs) result(ret)\n  integer :: rs,ret\n  randomseed=rs\n  ret=0\nend function \n"}, {"instruction": "Write a Fortran function named crossprod that calculates the cross product of two three-dimensional vectors. The function takes 2 input parameters of type real(8), dimension(3) and returns 1 output parameter of type real(8), dimension(3).", "input": "", "output": "   function crossprod(u,v) result (w)\n     implicit none\n\n     type(real(8)), dimension(3), intent(in) :: u, v\n     type(real(8)), dimension(3) :: w\n\n     w(1) = u(2)*v(3)-u(3)*v(2)\n     w(2) = u(3)*v(1)-u(1)*v(3)\n     w(3) = u(1)*v(2)-u(2)*v(1)\n\n   end function\n"}, {"instruction": "Create a Fortran function named mappbc that takes in 4 input parameters of type real(8) with dimensions of 3. The input parameters are labeled as p, n, xa, and a. The output parameter is a single parameter of type real(8) with dimensions of 3, labeled as pmap. This function computes pmap based on the conditional logic inside the function. Use the dot_product and dsqrt functions to perform the necessary calculations.", "input": "", "output": "   function mappbc(p,n,xa,a) result(pmap)\n     type(real(8)),dimension(3), intent(in) :: p, n, xa,a\n     type(real(8)), dimension(3) :: pmap\n     integer i\n\n     if( ((dot_product(xa-p,n)/dabs(dot_product(xa-p,n)) ) .ge. 0.d0) .and. ( dsqrt(dot_product(xa-p,xa-p)).gt.0.d-10 )) then\n        pmap = xa + a\n     else\n        pmap = xa\n     end if\n   end function\n"}, {"instruction": "Write a Fortran function named fun to calculate the value of a mathematical function. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The input parameter is denoted by intent(in) and named x. The function returns the negation of the product of x and the cosine of x squared. The function name is fun.", "input": "", "output": "    function fun(x) result(f)\r\n\n        ! the unique global minimum is at x = 4.691893 \r\n        ! variables\r\n        real(8), intent(in) :: x\r\n        real(8) :: f\r\n        ! body of fun\r\n        f = x*cos(x*x)\r\n        \r\n        f = -f\r\n        \r\n    end function fun\r\n"}, {"instruction": "Provide a Fortran function named gcd to calculate the greatest common divisor of two 64-bit integer numbers. The function takes 2 input arguments of type integer(8) and returns 1 output argument of type integer(8).", "input": "", "output": "  recursive function gcd(x,y) result(z)\n    implicit none\n    integer(8), intent(in) :: x, y\n    integer(8) :: z\n    if (x.lt.y) then\n      z = gcd(y,x)\n      return\n    end if\n    z = x\n    if (y.eq.0_8) return\n    z = gcd(y,mod(x,y))\n    return\n  end function gcd\n"}, {"instruction": "Write a recursive Fortran function named common_factor to find the greatest common factor of two integers. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The input arguments are n, m, and ifact, while the output argument is val.", "input": "", "output": "      recursive function common_factor(n,m,ifact) result(val)\n      implicit none\n      integer, intent(in) :: n\n      integer, intent(in) :: m\n      integer, intent(in) :: ifact\n      integer:: val\n\n      val = 0\n      if (mod(n,m)==0) then\n         val = m\n      else\n         val = common_factor(n,m+ifact,ifact)\n      end if\n\n      end function common_factor\n"}, {"instruction": "Write a Fortran function named decibel to calculate the decibel value of a complex number. The function takes 1 input argument of type complex (kind = 8) and returns 1 output argument of type real (kind = 8). The input parameter should be named x, and the output parameter should be named res. Ensure the input argument is declared with the \"intent(in)\" attribute.", "input": "", "output": "function decibel(x) result(res)\nimplicit none\ncomplex (kind = 8), intent(in) :: x\nreal    (kind = 8) :: res, tmp\ntmp = max(1.0d-20, abs(x))\nres = 20.0d0 * log10(tmp)\nreturn\nend function decibel\n"}, {"instruction": "Create a Fortran function named get_var to retrieve the value of an environment variable or return a default value if the environment variable is not set. The function has 2 input arguments of type character (len=*) and 1 output argument of type character (len=:), allocatable.", "input": "", "output": "        function get_var(var, dflt) result(l)\n            character (len=*), intent(in):: var\n            character (len=*), intent(in):: dflt\n            character (len=:), allocatable:: l\n\n            character (len=1000):: raw\n            integer:: n, s\n\n            call get_environment_variable(name=var, value=raw, & \n                                          length=n, status=s)\n            if (s .eq. 0) then\n                ! value var exists and either has no value or its value is \n                ! assigned to raw\n                if (n .gt. 0) then \n                    allocate(character (len=n):: l)\n                    l = trim(raw)\n                    return\n                end if\n            end if\n            ! in case the env.var not set or empty, return its default value\n            n = len(dflt)\n            allocate(character (len=n):: l)\n            l = dflt\n            return\n        end function get_var\n"}, {"instruction": "Create a Fortran function named cross that calculates the cross product of two 3-dimensional real arrays. The function should take 2 input arguments of type real, dimension(3) and return 1 output argument of type real, dimension(3).", "input": "", "output": "    pure function cross(a, b)\n      real, dimension(3), intent(in) :: a,b\n      real, dimension(3) :: cross\n\n     cross = (/ a(2) * b(3) - a(3) * b(2), &\n           a(3) * b(1) - a(1) * b(3), &\n           a(1) * b(2) - a(2) * b(1) /)\n    end function cross\n"}, {"instruction": "Create a Fortran function named \"zfnc\" to calculate the value of a function. The function takes 2 input parameters of type real, named \"enrgy\" and \"enrgymax\". It returns 1 output parameter of type real. The function calculates the value of 2 times the square root of \"enrgy\" divided by \"enrgymax\" minus 1.", "input": "", "output": "  function zfnc (enrgy, enrgymax)\n    \n    implicit none\n    \n    real, intent(in) :: enrgy, enrgymax\n    real :: zfnc\n    \n    zfnc = 2.*sqrt(enrgy/enrgymax)-1.\n    \n    return\n    \n  end function zfnc\n"}, {"instruction": "Create a Fortran function named rootlay to determine the layer in which a root is located based on the root depth, layer thickness, and number of layers. The number of input arguments is 3 and the test_data type is [integer,real,real,dimension(nlay)]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function rootlay(rtdepth,lthick,nlay)\n!\nimplicit none\n!\n\n!\ninteger :: nlay\nreal :: rtdepth\nreal,dimension(nlay) :: lthick\ninteger :: rootlay\n!\n! local variables\n!\nreal :: d\ninteger :: i\n!\nif ((rtdepth*1000.0).lt.lthick(1)) then\n  rootlay = 1\n  go to 99999\nend if\nd = lthick(1)\ndo i = 2,nlay\n  d = d + lthick(i)\n  if ((rtdepth*1000.0).lt.d) then\n     if ((d-(rtdepth*1000.)).lt.((rtdepth*1000.)-(d-lthick(i)))) then\n        rootlay = i\n     else\n        rootlay = i - 1\n     end if\n     go to 99999\n  end if\n  rootlay = nlay\nend do\n!\n99999 end function rootlay\n"}, {"instruction": "Create a Fortran function named str2int to convert a given character string to an integer. The function should accept 1 input argument of type character(len=*) and return 1 output argument of type integer. Ensure that the input string represents a valid integer within 9 digits. If the string is longer than 9 digits, the function should print an error message and stop.", "input": "", "output": "function str2int(str) result(intv)\n\ncharacter(len=*), intent(in) :: str\n\ninteger :: strlength\ninteger :: intv\n\nstrlength = len_trim(adjustl(str))\nif (strlength > 9) then\n   print *,'error: integer string length is greater than 9 digits long.'\n   stop\nend if \n\nread(str,*) intv\n\nend function str2int\n"}, {"instruction": "Write a Fortran function named bc_get_u that calculates the velocity component u at a given position. The function takes 3 input parameters of type real, dimension(3) and returns one output parameter of type real.", "input": "", "output": "function bc_get_u(x0, x1, um)\n\timplicit none\n\treal\t\t\t\t\t:: bc_get_u\n\treal, dimension(3)\t:: x0\n\treal, dimension(3)\t:: x1\n\treal\t\t\t\t\t:: rx, ry, rz, r2, r\n\treal\t\t\t\t\t:: um\n\treal\t\t\t\t\t:: u\n\tbc_get_u = 0.0\n\n! for poiseuille.conf\n!\tx1 = x0\n!\ty1 = 0.0\n!\tz1 = 0.0\n\n! for elbow-6a.conf\n!\tx1 = x0\n!\ty1 = 0.0\n!\tz1 = -3.0\n\n\trx = x0(1) - x0(1)\n\try = x0(2) - x1(2)\n\trz = x0(3) - x1(3)\n\tr2 = rx*rx + ry*ry + rz*rz\n\tr = sqrt(r2)\n\n\tu = um*2.0*(1.0 - r*r/(0.5*0.5))\n\tif( r > 0.5 ) then\n\t\tu = 0.0\n\tend if\n\n\tbc_get_u = u\n\treturn\nend function bc_get_u\n"}, {"instruction": "Create a Fortran function named bjoin that takes 2 input arguments, where the first argument is an integer and the second argument is an array of integers of size ntot. The function returns a single integer as the output. This function is designed to perform a binary join operation on the input array to compute a decimal value based on the binary representation of the array elements.", "input": "", "output": "  function bjoin(ib,ntot) result(i)\n    integer                 :: ntot\n    integer,dimension(ntot) :: ib\n    integer                 :: i,j\n    i=0\n    do j=0,ntot-1\n       i=i+ib(j+1)*2**j\n    enddo\n  end function bjoin\n"}, {"instruction": "Write a Fortran function named tcl_get_var to retrieve the value of a Tcl variable. The function takes 3 input parameters of type c_ptr (pass-by-value), c_ptr (pass-by-value), and c_int (pass-by-value). The output parameter is a single c_ptr.", "input": "", "output": "     function tcl_get_var(interp, name, flags) &\n          bind(c, name=\"tcl_getvar\")\n       use iso_c_binding, only: c_int, c_ptr\n       type(c_ptr), value :: interp, name\n       integer(c_int), value :: flags\n       type(c_ptr) :: tcl_get_var\n     end function tcl_get_var\n"}, {"instruction": "Write a Fortran function named ispalindrome to determine whether a given string is a palindrome. The function takes 1 input parameter of type character(len=16) and returns 1 output parameter of type logical.", "input": "", "output": "    function ispalindrome(str) result(r)\n        character(len=16) :: str\n        logical :: r\n        integer :: left\n        integer :: right\n        integer :: strlen\n        integer :: halflen\n        character :: leftch, rightch\n        \n        strlen = len_trim(str)\n        halflen = strlen / 2\n        \n        do left=1, halflen\n            right = strlen - left + 1\n            leftch = str(left:left+1)\n            rightch = str(right:right+1)\n            if (leftch .ne. rightch) then\n                r = .false.\n                return\n            end if\n        end do\n        \n        r = .true.\n        \n    end function ispalindrome\n"}, {"instruction": "Create a Fortran function named hui_hii_recombb that computes the recombination coefficient for hydrogen and ionized helium. The function takes 1 input argument of type real. The output is a single real value.", "input": "", "output": "  function hui_hii_recombb(t)\n    real :: t\n    real :: hui_hii_recombb, lambda\n    real, parameter :: t_hi=1.57807d5\n\n    lambda = 2.d0 * t_hi / t\n    hui_hii_recombb = 2.753d-14 * lambda**1.500d0 / &\n         ( 1.d0 + (lambda/2.740d0)**0.407d0 )**2.242d0\n\n  end function hui_hii_recombb\n"}, {"instruction": "Write a Fortran function named tolower to convert the input string to lowercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(string)). The input string is converted to lowercase, and the result is returned.", "input": "", "output": "function tolower(string)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: tolower\n\n    integer                      :: i\n    integer                      :: ch\n\n    tolower = string\n    do i = 1,len(string)\n        ch = iachar(string(i:i))\n        if ( ch >= 65 .and. ch <= 90 ) then\n            tolower(i:i) = achar(ch + 32)\n        endif\n    enddo\nend function tolower\n"}, {"instruction": "Create a Fortran function named toupper to convert all lowercase characters in the input string to uppercase. The function should take 1 input argument of type character(len=*) and produce 1 output argument of type character(len=len(string)).", "input": "", "output": "function toupper(string)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: toupper\n\n    integer                      :: i\n    integer                      :: ch\n\n    toupper = string\n    do i = 1,len(string)\n        ch = iachar(string(i:i))\n        if ( ch >= 97 .and. ch <= 122 ) then\n            toupper(i:i) = achar(ch - 32)\n        endif\n    enddo\nend function toupper\n"}, {"instruction": "Create a Fortran function named j2norm that takes one integer input argument and returns an integer output. The input argument should be declared with the intent(in) attribute. The function should compute the value of the output by adding 1 to the input argument and assigning it to the output.", "input": "", "output": "    function j2norm(two_j)\n        implicit none\n        integer, intent(in) :: two_j\n        integer :: j2norm\n    \n        j2norm = two_j + 1\n    \n    end function j2norm\n"}, {"instruction": "Write a Fortran function named qnorm to calculate the square root of (2 * j + 1) where j is an input integer argument. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function qnorm(j)\n        implicit none\n        integer, intent(in) :: j\n        real(kind=8)  :: qnorm\n\n        if (j<0) stop \"qnorm error: negative j\"\n\n        qnorm = sqrt(2d0 * j + 1d0)\n\n    end function qnorm\n"}, {"instruction": "Create a Fortran function named q2norm to calculate the square root of (two_j + 1d0) when given the input parameter two_j of type integer. The output parameter q2norm should be of type real(kind=8). Ensure that q2norm is returned as the result of the computation. If the input parameter two_j is negative, an error message \"qnorm error: negative j\" should be displayed.", "input": "", "output": "    function q2norm(two_j)\n        implicit none\n        integer, intent(in) :: two_j\n        real(kind=8) :: q2norm\n        if (two_j<0) stop \"qnorm error: negative j\"\n\n        q2norm = sqrt(two_j + 1d0)\n    \n    end function q2norm    \n"}, {"instruction": "Write a Fortran function named j that takes one integer input argument and returns one integer output. The input argument is of type integer, and the output is also of type integer. The function selects a value from an array based on the input argument and returns it, or returns 0 if the input argument is out of range.", "input": "", "output": "function j(k)\ninteger :: k\ninteger :: j\ninteger, parameter :: i(2) = (/1,2/)\n\nselect case(k)\ncase (1:size(i))\n    j = i(k)\ncase default\n    j = 0\nend select\nend function\n"}, {"instruction": "Create a Fortran function named golden_number to calculate the golden number based on the given year. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "function golden_number(year)\n\n      implicit none\n\n      integer :: year, golden_number\n\n      golden_number = modulo(year + 1, 19)\n\nend function golden_number\n"}, {"instruction": "Create a Fortran function named cal_vi that calculates the velocity in a specific context. It takes 6 input parameters of type real: l, ks, nu, g, d, and hf1. It returns 1 output parameter of type real.", "input": "", "output": "     function cal_vi(l,ks,nu,g,d,hf1) !velocidad ec 2.3\n         implicit none\n         real :: cal_vi,l,ks,nu,g,d,hf1\n\n         cal_vi = (2.51 * nu * sqrt(l)) / (d * sqrt(2 * g * d * hf1))\n         cal_vi = (ks / (3.7 * d)) + cal_vi\n         cal_vi = (-2 * sqrt(2 * g * d * hf1) / sqrt(l)) * log10(cal_vi)\n\n     end function cal_vi\n"}, {"instruction": "Create a Fortran function named \"cal_hfi_1\" to calculate the value of \"cal_hfi_1\" using the formula: h - zy - sigma_km * ((vi ** 2) / (2 * g)). The function should have 5 input parameters of type real: h, zy, sigma_km, vi, and g. The output parameter should also be of type real.", "input": "", "output": "     function cal_hfi_1(h,zy,sigma_km,vi,g) \n         implicit none\n         real ::cal_hfi_1,h,zy,sigma_km,vi,g\n         cal_hfi_1 = h - zy - sigma_km * ((vi ** 2) / (2 * g))\n     end function cal_hfi_1\n"}, {"instruction": "Create a Fortran function named starts to check if the second input string starts with the first input string. The function takes 2 input parameters of type character(len=*) and returns 1 if the second string starts with the first one; otherwise, it returns 0.", "input": "", "output": "   function  starts(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(1:len(string2))==string2) answer = 1\n   end function starts\n"}, {"instruction": "Create a Fortran function called has to find the first occurrence of one character string within another. The function takes two input arguments of type character(len=*) and returns one output argument of type integer. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "   function  has(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      character(len=:),allocatable :: temp\n      integer :: answer, add\n      character(len=*), parameter :: fmt= '(a6,x,i0)'\n      answer = 0\n      add = 0\n      if(len(string2)>len(string1)) return\n      answer = index(string1, string2)\n      if(answer==0) return\n      !     print the location of the match for part 2\n      write(*,fmt) \" at \", answer\n      !     handle multiple occurrences of a string for part 2.\n      add = answer\n      temp = string1(answer+1:)\n      do while(answer>0)\n         answer = index(temp, string2)\n         add = add + answer\n         if(answer>0) write(*,fmt) \" at \", add\n         !          deallocate(temp)\n         temp = string1(add+1:) ! auto reallocation\n      enddo\n      answer = 1\n   end function has\n"}, {"instruction": "Create a Fortran function named \"ends\" to check if one character string ends with another character string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. If the second string is found at the end of the first string, the output is set to 1; otherwise, it is set to 0.", "input": "", "output": "   function  ends(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(len(string1)-len(string2)+1:)==string2) answer = 1\n   end function ends\n"}, {"instruction": "Create a Fortran function named work2 that takes 4 input parameters of type integer, integer, integer, and logical. The function should return a single output parameter of type logical. The function aims to analyze a sequence of digits and determine if they are in decreasing order and contain at most two adjacent identical digits. Use an imperative tone when providing the instructions.", "input": "", "output": "recursive function work2(num, previous,seenpair, seencount) result (result)\n\n  integer, intent(in) :: num, previous, seencount\n  logical , intent(in) :: seenpair\n  logical ::result, digitsdescreasing,seenpairstillvalid\n  integer::digit, newseencount\n\n  seenpairstillvalid = seenpair\n\n  digit = mod(num,10)\n\n  digitsdescreasing = (digit <= previous)\n\n  if (digit == previous)then\n    newseencount = seencount + 1\n  else\n    if (seencount == 2) then\n      seenpairstillvalid = .true.\n    end if\n    newseencount = 1\n  end if\n\n  if (num >= 10) then\n    result = digitsdescreasing .and. work2(int(num / 10), digit, seenpairstillvalid,newseencount )\n  else\n    result = digitsdescreasing .and. (seenpairstillvalid .or.newseencount == 2)\n  end if\nend function work2\n"}, {"instruction": "Create a Fortran function named \"g\" that takes a single real number as input, and returns a real number. The function simply assigns the input to a variable m, then assigns m to a variable n, and finally assigns n to a variable g.", "input": "", "output": "  function g(x)\n    != unit 'b :: x\n    real :: x, n, m, g\n    m = x\n    n = m\n    g = n\n  end function g\n"}, {"instruction": "Write a Fortran function named rand_normal to generate a random number from a normal distribution with the given mean and standard deviation. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "function rand_normal(mean,stdev) result(c)\n  implicit none\n  double precision, parameter :: pi=3.141592653589793238462d0\n  double precision :: mean,stdev,c,temp(2), r, theta\n  if(stdev <= 0.0d0) then\n\n    write(*,*) \"standard deviation must be +ve\"\n  else\n    call random_number(temp)\n    r = (-2.0d0 * log(temp(1)))**5.0d-1\n    theta = 2.0d0*pi*temp(2)\n    c = mean + stdev * r * sin(theta)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named gsumf that calculates the sum of all elements in an array of integers. The function takes 1 input parameter of type integer array and returns 1 output parameter of type integer. The input parameter is of type ['integer, dimension(:)'] and the output parameter is of type ['integer'].", "input": "", "output": "function gsumf(x) result(y)\n    implicit none  \n    integer , dimension(: ), intent(in) :: x\n    integer:: y\n    integer:: i\n    integer:: i_cyml0\n    y = 0\n    do i_cyml0 = 1, size(x)\n        i = x(i_cyml0)\n        y = y + i\n    end do\nend function gsumf\n"}, {"instruction": "Write a Fortran function named roman that takes an integer input and returns a string representing the input value in Roman numerals. The input parameter is 1 of type integer, and the output parameter is 1 of type character (32).", "input": "", "output": "function roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'m ', 'cm', 'd ', 'cd', 'c ', 'xc', 'l ', 'xl', 'x ', 'ix', 'v ', 'iv', 'i '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n"}, {"instruction": "Write a Fortran function named \"csedress\" to calculate the surface erosion rate of cohesive sediment based on different input options. The number of input arguments is 6 and the test_data type is ['integer', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function csedress(denbulk,wrspo,vdro,vdr,vdrc,iopt)\n\n  ! change record\n\n  ! **  calculates surface erosion rate of cohesive\n\n  ! **  iopt=1  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment erodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n  ! **  iopt=2  based on j. m. hamrick's modification of\n  ! **\n  ! **  sanford, l.p., and j. p. y. maa, 2001: a unified erosion formulation\n  ! **  for fine sediment, marine geology, 179, 9-23.\n  !\n  ! **  iopt=4 & 5 based on j. m. hamrick's parameterization of sedflume\n  !     test data\n  ! **\n\n  implicit none\n\n  integer :: iopt\n  real :: csedress,denbulk,wrspo,vdro,vdr,vdrc\n  real :: bulkden,tmp,tmpval,factor\n\n  if( iopt == 1 )then\n    bulkden=0.001*denbulk    ! *** to prevent corrupting the denbulk variable\n    if( bulkden <= 1.065 )then\n      csedress=0.62\n    else\n      tmp=0.198/(bulkden-1.0023)\n      tmp=exp(tmp)\n      csedress=6.4e-4*(10.**tmp)\n    endif\n  elseif( iopt == 2 )then\n    csedress=wrspo*(1.+vdro)/(1.+vdr)\n  elseif( iopt == 3 )then\n    csedress=wrspo*(1.+vdro)/(1.+vdrc)\n  elseif( iopt == 4 )then\n    tmpval=(1.+vdro)/(1.+vdr)\n    factor=exp(-tmpval)\n    csedress=factor*wrspo*(1.+vdro)/(1.+vdr)\n  elseif( iopt == 5 )then\n    tmpval=(1.+vdro)/(1.+vdrc)\n    factor=exp(-tmpval)\n    csedress=factor*wrspo*(1.+vdro)/(1.+vdrc)\n  elseif( iopt >= 99 )then\n    csedress=wrspo\n  endif\n\nend function\n"}, {"instruction": "Create a Fortran function named \"get_num_triangles_c\" that takes one input parameter of type \"type(c_ptr), value\" and returns one output parameter of type \"integer(c_int)\".", "input": "", "output": "    function get_num_triangles_c(obj) bind(c, name=\"get_num_triangles\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_num_triangles_c\n        type(c_ptr), value :: obj\n    end function\n"}, {"instruction": "Create a Fortran function named get_2pt_size_c. This function takes 1 input argument of type c_ptr with the value attribute. The output parameter is of type integer(c_int). This function serves to bind to a C function named \"get_2pt_size\".", "input": "", "output": "    function get_2pt_size_c(obj) bind(c, name=\"get_2pt_size\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_2pt_size_c\n        type(c_ptr), value :: obj\n    end function\n"}, {"instruction": "Create a Fortran function named get_2pt_c that accepts two input parameters: a value of type c_ptr and an array of real numbers of type c_double. The function should return an integer value of type c_int.", "input": "", "output": "    function get_2pt_c(obj, twopoint) bind(c, name=\"get_2pt\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_2pt_c\n        type(c_ptr), value :: obj\n        real(c_double), dimension(:) :: twopoint\n    end function\n"}, {"instruction": "Create a Fortran function named get_3pt_c, which binds to C and has the name \"get_3pt\". The function takes 2 input parameters: one of type c_ptr, passed by value, and another of type real(c_double), with an unspecified dimension. The function has 1 output parameter of type integer(c_int).", "input": "", "output": "    function get_3pt_c(obj, threepoint) bind(c, name=\"get_3pt\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_3pt_c\n        type(c_ptr), value :: obj\n        real(c_double), dimension(:) :: threepoint\n    end function\n"}, {"instruction": "Create a Fortran function named \"simplex_3d\" to convert a 3-dimensional vector into a projection onto a 3-simplex. The input parameter is a real array of size 3, and the output parameter is a real array of size 2. Use the imperative tone to create the function.", "input": "", "output": "  function simplex_3d(x) result(y)\n  ! convert x,y,z into projection onto 3-simplex\n    implicit none\n    real, dimension(3) :: x\n    real, dimension(2) :: y\n    real               :: rac2, rac6\n\n    rac2=sqrt(2.0)\n    rac6=sqrt(6.0)\n\n    y(1)=-(x(1)-1./3.)/rac2+(x(2)-1./3.)/rac2\n    y(2)=-(x(1)-1./3.)/rac6-(x(2)-1./3.)/rac6+2*(x(3)-1./3.)/rac6\n\n  end function simplex_3d\n"}, {"instruction": "Create a Fortran function named f_intrpvalue to calculate an interpolated value based on the input parameters. The function takes 6 input parameters of types integer, real(kind=8), real(kind=8), real(kind=8), real(kind=8), real(kind=8), and returns 1 output parameter of type real(kind=8).", "input": "", "output": "function f_intrpvalue (wvalp0,wvalp1,vlev,vcp0,vcp1,icase)\n\n    implicit none\n\n    integer, intent(in) :: icase\n    real(kind=8), intent(in) :: wvalp0,wvalp1,vlev,vcp0,vcp1\n    real(kind=8) :: f_intrpvalue\n\n    real(kind=8) :: valp0,valp1,rvalue\n    real(kind=8) :: chkdiff\n\n    real(kind=8), parameter :: rgas=287.04d0\n    real(kind=8), parameter :: ussalr=0.0065d0\n    real(kind=8), parameter :: sclht=rgas*256.d0/9.81d0\n\n    valp0 = wvalp0\n    valp1 = wvalp1\n    if ( icase .eq. 2) then  !ght\n       valp0=exp(-wvalp0/sclht)\n       valp1=exp(-wvalp1/sclht)\n    end if\n\n    ! todo:  remove this stop\n    chkdiff = vcp1 - vcp0\n    if(chkdiff .eq. 0) then\n        print *,\"bad difference in vcp's\"\n        stop\n    end if\n\n    rvalue = (vlev-vcp0)*(valp1-valp0)/(vcp1-vcp0)+valp0\n    if (icase .eq. 2) then  !ght\n        f_intrpvalue = -sclht*log(rvalue)\n    else\n        f_intrpvalue = rvalue\n    end if\n\n    return\n\nend function f_intrpvalue\n"}, {"instruction": "Create a Fortran function named accumulate, which takes two integer input parameters and one integer output parameter. The input parameters should be of type integer, and the output parameter should also be of type integer. The function should compute the sum of the two input integers and return the result.", "input": "", "output": "  impure elemental function accumulate (a, s)\n    integer, intent(in) :: a\n    integer, intent(inout) :: s\n    integer :: accumulate\n    \n    s = s + a\n    accumulate = s\n  end function accumulate\n"}, {"instruction": "Write a Fortran function named f_h that takes four real(kind(0d0)) input parameters (fcpbw, fcpinf, fntait, fbtait) and returns one real(kind(0d0)) output parameter. The function computes the value of f_h based on the provided input parameters using a series of calculations.", "input": "", "output": "        function f_h( fcpbw, fcpinf, fntait, fbtait )\n\n            real(kind(0d0)), intent(in) :: fcpbw, fcpinf, fntait, fbtait\n            \n            real(kind(0d0))             :: tmp1,tmp2,tmp3\n            real(kind(0d0))             :: f_h\n            \n            tmp1 = ( fntait-1.d0 )/fntait\n            tmp2 = (  fcpbw/(1.d0+fbtait)+1.d0 )**tmp1\n            tmp3 = ( fcpinf/(1.d0+fbtait)+1.d0 )**tmp1\n            \n            f_h = ( tmp2 - tmp3 )*fntait*( 1.d0+fbtait )/( fntait-1.d0 )\n\n        end function f_h\n"}, {"instruction": "Create a Fortran function named f_rddot_rp to calculate the value of rddot using the given formula rddot = (1/r) * ( -3/2 * rdot^2 + ((r0/r)^3\\gamma - cp)/rho ). The function takes 6 input parameters of type real(kind(0d0)) and returns a single output parameter of the same type. The input parameters are fcp, frho, fr, fv, fr0, and fcpbw, and the output parameter is f_rddot_rp.", "input": "", "output": "        function f_rddot_rp( fcp, frho, fr, fv, fr0, fcpbw )\n\n            real(kind(0d0)), intent(in) :: fcp, frho, fr, fv, fr0, fcpbw\n            real(kind(0d0))             :: f_rddot_rp\n\n            !! rddot = (1/r) (  -3/2 rdot^2 + ((r0/r)^3\\gamma - cp)/rho )\n            !! rddot = (1/r) (  -3/2 rdot^2 + (tmp1 - cp)/rho )\n            !! rddot = (1/r) (  tmp2 )\n\n            f_rddot_rp = (-1.5d0*(fv**2d0) + (fcpbw - fcp)/frho)/fr\n\n            if (re_inv /= dflt_real) f_rddot_rp = f_rddot_rp - 4d0*re_inv*fv/(fr**2d0)/frho\n\n        end function f_rddot_rp\n"}, {"instruction": "Write a Fortran function named f_rddot to calculate the value of f_rddot based on the input parameters fcpbw, fr, fv, fh, fhdot, fcgas, fntait, and fbtait. The input parameters are all of type real(kind(0d0)). The function returns a single real(kind(0d0)) value.", "input": "", "output": "        function f_rddot( fcpbw, fr, fv, fh, fhdot, fcgas, fntait, fbtait )\n\n            real(kind(0d0)), intent(in) :: fcpbw, fr, fv, fh, fhdot\n            real(kind(0d0)), intent(in) :: fcgas, fntait, fbtait\n            \n            real(kind(0d0))             :: tmp1, tmp2, tmp3\n            real(kind(0d0))             :: f_rddot\n\n            tmp1 = fv/fcgas\n            tmp2 = 1.d0 + 4.d0*re_inv/fcgas/fr*( fcpbw/(1.d0+fbtait)+1.d0 ) &\n                        **( -1.d0/fntait )\n            tmp3 = 1.5d0*fv**2d0*( tmp1/3.d0-1.d0 ) + fh*( 1.d0+tmp1 ) &\n                        + fr*fhdot*( 1.d0-tmp1 )/fcgas\n\n            f_rddot = tmp3/( fr*(1.d0-tmp1)*tmp2 )\n\n        end function f_rddot\n"}, {"instruction": "Create a Fortran function named fcgd to calculate a value based on the input argument. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The function involves a computation using the input parameter and several internal real variables. Ensure that the computed value is not less than 0.", "input": "", "output": "    function fcgd(xx)\n    \n      implicit none\n      \n      real :: fcgd          !             |\n      real :: tn            !             |\n      real :: top           !             |\n      real :: tx            !             |\n      real :: qq            !             |\n      real :: xx            !             |\n      \n      tn = -5.\n\t  top = 35.\n      tx = 50.\n      qq = (tn - top)/(top - tx)\n\t  fcgd = ((xx-tn)**qq)*(tx-xx)/(((top-tn)**qq)*(tx-top))\n      if (fcgd < 0.) fcgd = 0.\n    end function\n"}, {"instruction": "Write a Fortran function named distance_between_points to calculate the distance between two 3D points. The function should have 6 input parameters of type double precision representing the coordinates of the two points. The output parameter should also be of type double precision.", "input": "", "output": "function distance_between_points(x0,y0,z0,x1,y1,z1)\n    implicit none\n    double precision :: distance_between_points\n    double precision :: x0,y0,z0,x1,y1,z1\n    double precision :: dx,dy,dz\n    dx = x1 - x0\n    dy = y1 - y0\n    dz = z1 - z0\n    distance_between_points = sqrt(dx * dx  + dy * dy + dz * dz)\nend function\n"}, {"instruction": "Write a Fortran function named is_palindro_r to check if the input string is a palindrome. The function takes 1 input parameter of type character (*) and returns 1 output parameter of type logical. The input parameter should be a string.", "input": "", "output": "  recursive function is_palindro_r (t) result (isp)\n\n    implicit none\n    character (*), intent (in) :: t\n    logical :: isp\n\n    isp = len (t) == 0 .or. t (: 1) == t (len (t) :) .and. is_palindro_r (t (2 : len (t) - 1))\n\n  end function is_palindro_r\n"}, {"instruction": "Create a Fortran function named ydn to perform a calculation on a 3D array. The function takes 1 input parameter of type real with dimensions (:,:,:) and returns 1 output parameter of type real with dimensions size(a,1), size(a,2), size(a,3).", "input": "", "output": "  function ydn(a) result (b)\n    real, dimension(:,:,:):: a\n    real, dimension(size(a,1),size(a,2),size(a,3)):: b\n    do k=1,size(a,3)\n    do j=2,size(a,2)\n    do i=1,size(a,1)\n      b(i,j,k)=half*(a(i,j-1,k)+a(i,j,k))\n    end do\n    end do\n    end do\n    b(:,1,:) = a(:,1,:)\n  end function\n"}, {"instruction": "Write a Fortran function named zdn that takes a 3D array of real numbers as input and computes a new 3D array of real numbers as output. The input parameter should be of type real, dimension(:,:,:), and the output parameter should be of type real, dimension(size(a,1),size(a,2),size(a,3)).", "input": "", "output": "  function zdn(a) result (b)\n    real, dimension(:,:,:):: a\n    real, dimension(size(a,1),size(a,2),size(a,3)):: b\n    do k=2,size(a,3)\n    do j=1,size(a,2)\n    do i=1,size(a,1)\n      b(i,j,k)=half*(a(i,j,k-1)+a(i,j,k))\n    end do\n    end do\n    end do\n    b(:,:,1) = a(:,:,1)\n  end function\n"}, {"instruction": "Create a Fortran function named upper to convert a given string to uppercase. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(len(s1)). The test_data type for the input is ['character(*)'] and for the output is ['character(len(s1))'].", "input": "", "output": "function upper(s1)  result (s2)\n  character(*) :: s1\n  character(len(s1)) :: s2\n  character :: ch\n  integer,parameter :: duc=ichar('a')-ichar('a')\n  integer :: i\n  do i=1,len(s1)\n     ch = s1(i:i)\n     if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)+duc)\n     s2(i:i) = ch\n  end do\nend function upper\n"}, {"instruction": "Create a Fortran function named crheat_f3 that takes a single real input argument and returns a real value. The function computes a specific mathematical expression using the input argument and assigns the result to the output variable. The number of input arguments is 1 and the test_data type is ['real'], while the number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": " function crheat_f3(x) result(f3)\n  real :: x,logx,f3\n  logx=log10(x)\n  f3=-.265*(-2.37+logx)*(4.69+logx)*(15.62+7.21*logx+logx**2)\n end function\n"}, {"instruction": "Write a Fortran function named max_pow_of_2 that takes an integer input and returns the largest power of 2 that is less than the input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function max_pow_of_2(n) result(p)\n    implicit none\n    integer, intent(in) :: n\n    integer :: p\n    p = 1\n    do while (2*p.lt.n)\n      p = 2*p\n    end do\n    return\n  end function max_pow_of_2\n"}, {"instruction": "Create a Fortran function named \"cq\" to perform complex division. The function takes 2 input parameters of type real*8, each with a dimension of 2. The output is a single real*8 parameter with a dimension of 2. The function performs complex division based on the provided inputs and returns the result. Use the imperative tone to create the function.", "input": "", "output": "       function cq( x,y )\n       implicit none\n       real*8, dimension(2) :: cq,z1,z2\n       real*8, intent(in), dimension(2) :: x,y\n       real*8 theta\n       if(x(2).eq.0.d0.and.y(2).eq.0.d0) then\n        cq(1)= x(1)/y(1)\n        cq(2)= 0.d0\n        return\n       endif\n       if(abs(x(2)).eq.1.d0.and.abs(y(2)).eq.1.d0) then\n        cq(1)= x(1)/y(1)\n        cq(2)= 0.d0\n       else\n        if(abs(x(2)).eq.1.d0) then\n         z1(1)= x(1)\n         z1(2)= 0.d0\n         z2(1)= y(1)\n         z2(2)= y(2)         \n        elseif(abs(y(2)).eq.1.d0) then\n         z1(1)= x(1)\n         z1(2)= x(2)\n         z2(1)= y(1)\n         z2(2)= 0.d0         \n        else\n         z1= x\n         z2= y\n        endif\n        if(abs(z2(1)) > abs(z2(2))) then\n         theta= z2(2)/z2(1)\n         cq(1)= (z1(1)+theta*z1(2))/(theta*z2(2)+z2(1))\n         cq(2)= (z1(2)-theta*z1(1))/(theta*z2(2)+z2(1))\n        else\n         theta= z2(1)/z2(2)\n         cq(1)= (theta*z1(1)+z1(2))/(theta*z2(1)+z2(2))\n         cq(2)= (theta*z1(2)-z1(1))/(theta*z2(1)+z2(2)) \n        endif     \n       endif\n       end function cq\n"}, {"instruction": "Write a Fortran function named cr that takes 2 input parameters of type real*8, and returns an array of real*8 values of size 2. If the first input parameter (x) is greater than 0.d0, the function sets the first element of the output array to the square root of x and the second element to 0.d0. If x is less than or equal to 0.d0, the function sets the first element of the output array to 0.d0 and the second element to ep times the square root of the absolute value of x, where ep is the second input parameter.", "input": "", "output": "       function cr(x,ep)\n       implicit none\n       real*8, dimension(2) :: cr\n       real*8, intent(in) :: x,ep\n       if(x > 0.d0) then \n        cr(1)= sqrt(x)\n        cr(2)= 0.d0       \n       else\n        cr(1)= 0.d0\n        cr(2)= ep*sqrt(abs(x))\n       endif\n       end function cr\n"}, {"instruction": "Create a Fortran function named selectindexesbasedonmask to generate a subarray of indexes based on a logical mask. The function takes 1 input argument of type ['logical, dimension(:)'] and returns 1 output argument of type ['integer, dimension(:), allocatable'].", "input": "", "output": "        function selectindexesbasedonmask(mask) result(subarray)\n            implicit none\n            logical, dimension(:) :: mask\n            integer, dimension(:), allocatable :: subarray\n            integer :: nelements, i, index\n            \n            nelements = count(mask)\n            allocate(subarray(nelements))\n            index = 1\n            do i = 1, size(mask)\n                if(mask(i)) then\n                    subarray(index) = i\n                    index = index + 1\n                endif\n            enddo\n        end function\n"}, {"instruction": "Create a Fortran function named predicate to check if a given number is an Armstrong number. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the input number is an Armstrong number.", "input": "", "output": "  pure function predicate(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: current,sum\n    logical             :: predicate\n\n    current=n\n    sum=0\n    do while (current > 0)\n       sum=sum+(mod(current,10)**5)\n       current=current/10\n    end do\n    predicate=(sum == n)\n\n  end function predicate\n"}, {"instruction": "Write a Fortran function named d1_tan to calculate the derivative of the tangent function. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "    pure function d1_tan(x) result(r)\n        real(8) :: r\n        real(8), intent(in) :: x\n        real(8) :: y\n        y = tan(x)\n        r = 1 + y**2\n    end function d1_tan\n"}, {"instruction": "Write a Fortran function named random_int that generates a random integer within a given range. The function takes 2 input parameters of type integer representing the lowest and highest integers in the range. It returns 1 output parameter of type integer representing the randomly generated integer.", "input": "", "output": "function random_int(first,last) result(rand_int)\nuse,intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ninteger,intent(in)   :: first,last ! lowest and highest integer in range of integers to get\ninteger, allocatable :: seed(:)\ninteger              :: n\ninteger              :: rand_int\nreal(kind=dp)        :: rand_val\nlogical,save         :: called=.false.\n   if(.not.called)then\n   ! initialize seed\n      call random_seed(size = n)\n      allocate(seed(n))\n      call random_seed(get=seed)\n      called=.true.\n   endif\n\n   ! to have a discrete uniform distribution on the integers {first, first+1,\n   ! ..., last-1, last} carve the continuous distribution up into last+1-first\n   ! equal sized chunks, mapping each chunk to an integer. one way is:\n   !\n   ! get real number from 0 up to but not including 1 (ie. [0,1)).\n   call random_number(rand_val)\n   ! use random value to choose an integer from first to last\n   rand_int = first + floor((last-first+1)*rand_val)\nend function random_int\n"}, {"instruction": "Create a Fortran function named chi2uniformdistance that takes an array of real numbers as input. The input parameter must be of type real, dimension(:), and it's intended for input. The function must return a single real number. The function calculates the chi-squared uniform distance based on the input array and returns the result.", "input": "", "output": "function chi2uniformdistance(ds)\n  real :: chi2uniformdistance\n  real, dimension(:), intent(in) :: ds\n\n  real :: expected, summa = 0.0\n\n  expected = sum(ds) / size(ds)\n  summa = sum( (ds - expected) ** 2 )\n\n  chi2uniformdistance = summa / expected\nend function chi2uniformdistance\n"}, {"instruction": "Create a Fortran function named \"atlabel\" that takes a single input argument of type character(*) to represent an atomic element symbol. The function should return an integer label corresponding to the input element symbol. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  pure function atlabel(atype) result(lbl)\r\n    character(*), intent(in) :: atype\r\n    integer :: lbl\r\n    \r\n    select case(atype)\r\n      case('h')\r\n        lbl = 1\r\n      case('he')\r\n        lbl = 2\r\n      case('li')\r\n        lbl = 3\r\n      case('be')\r\n        lbl = 4\r\n      case('b')\r\n        lbl = 5\r\n      case('c')\r\n        lbl = 6\r\n      case('n')\r\n        lbl = 7\r\n      case('o')\r\n        lbl = 8\r\n      case('f')\r\n        lbl = 9\r\n      case('ne')\r\n        lbl = 10\r\n      case('na')\r\n        lbl = 11\r\n      case('mg')\r\n        lbl = 12\r\n      case('al')\r\n        lbl = 13\r\n      case('si')\r\n        lbl = 14\r\n      case('p')\r\n        lbl = 15\r\n      case('s')\r\n        lbl = 16\r\n      case('cl')\r\n        lbl = 17\r\n      case('ar')\r\n        lbl = 18\r\n      case default\r\n        lbl = 19\r\n    end select\r\n  end function\r\n"}, {"instruction": "Write a Fortran function named hipmemcpy to perform memory copy operation using the HIP API. The function takes 4 input parameters of types type(c_ptr), value, type(c_ptr), value, integer(c_size_t), value, and integer(c_int), value. It returns 1 output parameter of type integer(c_int). The function is named hipmemcpy.", "input": "", "output": "        function hipmemcpy(dst, src, length, dir) bind(c, name = \"hipmemcpy\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value :: dst, src\n            integer(c_size_t), value :: length\n            integer(c_int), value :: dir\n            integer(c_int) :: hipmemcpy\n            end function\n"}, {"instruction": "Create a Fortran function named f that takes two input parameters, a real number theta and an array 'a' of size 3. The function returns an array of size 3. The purpose of this function is to compute the matrix multiplication of the input array 'a' with a 3x3 rotation matrix defined by the angle theta.", "input": "", "output": "      function f(a,theta)\n        implicit none\n          real, intent(in) :: theta\n          real, dimension(1:3) :: a,f\n          real, dimension(1:3,1:3) :: d\n\n          !d = [cos(theta) -sin(theta) 0]\n          !    [sin(theta)  cos(theta  0]\n          !    [    0           0      1]\n\n          d= reshape( (/cos(theta),sin(theta),0.0,-sin(theta),cos(theta),0.0,0.0,0.0,1.0/), (/3,3/) )\n          f=matmul(a,d)\n      end function f\n"}, {"instruction": "Write a Fortran function named g that takes 3 real input parameters and a 1x3 real array as input.The function returns a 1x3 real array as output. The function multiplies the input 1x3 array by a 3x3 matrix and returns the result as the output array.", "input": "", "output": "      function g(i,j,k)\n        implicit none\n          real, intent(in) :: k,j\n          real, dimension(1:3) :: g,i\n          real, dimension(1:3,1:3) :: h\n\n          !h = [ 1 0 j ]\n          !    [ 0 1 k ]\n          !    [ 0 0 1 ]\n\n          h= reshape( (/1.0,0.0,j,0.0,1.0,k,0.0,0.0,1.0/), (/3,3/) )\n          g=matmul(i,h)\n      end function g\n"}, {"instruction": "Write a Fortran function named m2x2det to calculate the determinant of a 2x2 matrix. The function takes 1 input parameter of type real(kind(1d0)), dimension(2,2) and provides 1 output parameter of type real(kind(1d0)).", "input": "", "output": "  function m2x2det(a) result(det)\n    implicit none\n    real(kind(1d0)),dimension(2,2),intent(in)::a\n    real(kind(1d0))::det    \n    det = a(1,1)*a(2,2)-a(1,2)*a(2,1)\n    return\n  end function m2x2det\n"}, {"instruction": "Create a Fortran function named m3x3det to calculate the determinant of a 3x3 matrix. The function takes one input parameter of type real(kind(1d0)), dimension(3,3) and returns one output parameter of type real(kind(1d0)).", "input": "", "output": "  function m3x3det(a) result(det)    \n    implicit none\n    real(kind(1d0)),dimension(3,3),intent(in)::a\n    real(kind(1d0))::det\n    det =  a(1,1)*a(2,2)*a(3,3)  &\n         - a(1,1)*a(2,3)*a(3,2)  &\n         - a(1,2)*a(2,1)*a(3,3)  &\n         + a(1,2)*a(2,3)*a(3,1)  &\n         + a(1,3)*a(2,1)*a(3,2)  &\n         - a(1,3)*a(2,2)*a(3,1)\n    return\n  end function m3x3det\n"}, {"instruction": "Create a Fortran function named m4x4det to calculate the determinant of a 4x4 matrix. The function should accept one input parameter of type real(kind(1d0)), dimension(4,4) and return one output parameter of type real(kind(1d0)). When calling the function, pass a 4x4 matrix as the input argument, and the determinant of the matrix will be returned as the output.", "input": "", "output": "  function m4x4det(a) result(det)    \n    implicit none\n    real(kind(1d0)),dimension(4,4),intent(in)::a\n    real(kind(1d0))::det\n    det =  a(1,1)*(a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)- &\n         a(3,3)*a(4,2)))-a(1,2)*(a(2,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+ &\n         a(2,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1)))+a(1,3)*(a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)- &\n         a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))-a(1,4)*(a(2,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+ &\n         a(2,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(2,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))    \n    return\n  end function m4x4det\n"}, {"instruction": "Create a Fortran function named m6x6det to calculate the determinant of a 6x6 matrix. The input parameter is a 6x6 real(kind(1d0)) array, and the output parameter is a real(kind(1d0)).", "input": "", "output": "  function m6x6det(a) result(det)\n    implicit none\n    real(kind(1d0)),dimension(6,6),intent(in)::a\n    real(kind(1d0)):: det, a11, a12, a13, a14, a15, a16, a21, a22, a23, a24, &\n         a25, a26, a31, a32, a33, a34, a35, a36, a41, a42, a43, a44, a45, a46,   &\n         a51, a52, a53, a54, a55, a56, a61, a62, a63, a64, a65, a66\n    \n    a11=a(1,1); a12=a(1,2); a13=a(1,3); a14=a(1,4); a15=a(1,5); a16=a(1,6)\n    a21=a(2,1); a22=a(2,2); a23=a(2,3); a24=a(2,4); a25=a(2,5); a26=a(2,6)\n    a31=a(3,1); a32=a(3,2); a33=a(3,3); a34=a(3,4); a35=a(3,5); a36=a(3,6)\n    a41=a(4,1); a42=a(4,2); a43=a(4,3); a44=a(4,4); a45=a(4,5); a46=a(4,6)\n    a51=a(5,1); a52=a(5,2); a53=a(5,3); a54=a(5,4); a55=a(5,5); a56=a(5,6)\n    a61=a(6,1); a62=a(6,2); a63=a(6,3); a64=a(6,4); a65=a(6,5); a66=a(6,6)\n\n    det = -(a16*a25*a34*a43*a52-a15*a26*a34*a43*a52-a16*a24*a35*a43*             &\n         a52+a14*a26*a35*a43*a52+a15*a24*a36*a43*a52-a14*a25*a36*a43*a52-a16*a25*  &\n         a33*a44*a52+a15*a26*a33*a44*a52+a16*a23*a35*a44*a52-a13*a26*a35*a44*      &\n         a52-a15*a23*a36*a44*a52+a13*a25*a36*a44*a52+a16*a24*a33*a45*a52-a14*a26*  &\n         a33*a45*a52-a16*a23*a34*a45*a52+a13*a26*a34*a45*a52+a14*a23*a36*a45*      &\n         a52-a13*a24*a36*a45*a52-a15*a24*a33*a46*a52+a14*a25*a33*a46*a52+a15*a23*  &\n         a34*a46*a52-a13*a25*a34*a46*a52-a14*a23*a35*a46*a52+a13*a24*a35*a46*      &\n         a52-a16*a25*a34*a42*a53+a15*a26*a34*a42*a53+a16*a24*a35*a42*a53-a14*a26*  &\n         a35*a42*a53-a15*a24*a36*a42*a53+a14*a25*a36*a42*a53+a16*a25*a32*a44*      &\n         a53-a15*a26*a32*a44*a53-a16*a22*a35*a44*a53+a12*a26*a35*a44*a53+a15*a22*  &\n         a36*a44*a53-a12*a25*a36*a44*a53-a16*a24*a32*a45*a53+a14*a26*a32*a45*      &\n         a53+a16*a22*a34*a45*a53-a12*a26*a34*a45*a53-a14*a22*a36*a45*a53+a12*a24*  &\n         a36*a45*a53+a15*a24*a32*a46*a53-a14*a25*a32*a46*a53-a15*a22*a34*a46*      &\n         a53+a12*a25*a34*a46*a53+a14*a22*a35*a46*a53-a12*a24*a35*a46*a53+a16*a25*  &\n         a33*a42*a54-a15*a26*a33*a42*a54-a16*a23*a35*a42*a54+a13*a26*a35*a42*      &\n         a54+a15*a23*a36*a42*a54-a13*a25*a36*a42*a54-a16*a25*a32*a43*a54+a15*a26*  &\n         a32*a43*a54+a16*a22*a35*a43*a54-a12*a26*a35*a43*a54-a15*a22*a36*a43*      &\n         a54+a12*a25*a36*a43*a54+a16*a23*a32*a45*a54-a13*a26*a32*a45*a54-a16*a22*  &\n         a33*a45*a54+a12*a26*a33*a45*a54+a13*a22*a36*a45*a54-a12*a23*a36*a45*      &\n         a54-a15*a23*a32*a46*a54+a13*a25*a32*a46*a54+a15*a22*a33*a46*a54-a12*a25*  &\n         a33*a46*a54-a13*a22*a35*a46*a54+a12*a23*a35*a46*a54-a16*a24*a33*a42*      &\n         a55+a14*a26*a33*a42*a55+a16*a23*a34*a42*a55-a13*a26*a34*a42*a55-a14*a23*  &\n         a36*a42*a55+a13*a24*a36*a42*a55+a16*a24*a32*a43*a55-a14*a26*a32*a43*      &\n         a55-a16*a22*a34*a43*a55+a12*a26*a34*a43*a55+a14*a22*a36*a43*a55-a12*a24*  &\n         a36*a43*a55-a16*a23*a32*a44*a55+a13*a26*a32*a44*a55+a16*a22*a33*a44*      &\n         a55-a12*a26*a33*a44*a55-a13*a22*a36*a44*a55+a12*a23*a36*a44*a55+a14*a23*  &\n         a32*a46*a55-a13*a24*a32*a46*a55-a14*a22*a33*a46*a55+a12*a24*a33*a46*      &\n         a55+a13*a22*a34*a46*a55-a12*a23*a34*a46*a55+a15*a24*a33*a42*a56-a14*a25*  &\n         a33*a42*a56-a15*a23*a34*a42*a56+a13*a25*a34*a42*a56+a14*a23*a35*a42*      &\n         a56-a13*a24*a35*a42*a56-a15*a24*a32*a43*a56+a14*a25*a32*a43*a56+a15*a22*  &\n         a34*a43*a56-a12*a25*a34*a43*a56-a14*a22*a35*a43*a56+a12*a24*a35*a43*      &\n         a56+a15*a23*a32*a44*a56-a13*a25*a32*a44*a56-a15*a22*a33*a44*a56+a12*a25*  &\n         a33*a44*a56+a13*a22*a35*a44*a56-a12*a23*a35*a44*a56-a14*a23*a32*a45*      &\n         a56+a13*a24*a32*a45*a56+a14*a22*a33*a45*a56-a12*a24*a33*a45*a56-a13*a22*  &\n         a34*a45*a56+a12*a23*a34*a45*a56)*a61+(a16*a25*a34*a43*a51-a15*a26*a34*    &\n         a43*a51-a16*a24*a35*a43*a51+a14*a26*a35*a43*a51+a15*a24*a36*a43*a51-a14*  &\n         a25*a36*a43*a51-a16*a25*a33*a44*a51+a15*a26*a33*a44*a51+a16*a23*a35*a44*  &\n         a51-a13*a26*a35*a44*a51-a15*a23*a36*a44*a51+a13*a25*a36*a44*a51+a16*a24*  &\n         a33*a45*a51-a14*a26*a33*a45*a51-a16*a23*a34*a45*a51+a13*a26*a34*a45*      &\n         a51+a14*a23*a36*a45*a51-a13*a24*a36*a45*a51-a15*a24*a33*a46*a51+a14*a25*  &\n         a33*a46*a51+a15*a23*a34*a46*a51-a13*a25*a34*a46*a51-a14*a23*a35*a46*      &\n         a51+a13*a24*a35*a46*a51-a16*a25*a34*a41*a53+a15*a26*a34*a41*a53+a16*a24*  &\n         a35*a41*a53-a14*a26*a35*a41*a53-a15*a24*a36*a41*a53+a14*a25*a36*a41*      &\n         a53+a16*a25*a31*a44*a53-a15*a26*a31*a44*a53-a16*a21*a35*a44*a53+a11*a26*  &\n         a35*a44*a53+a15*a21*a36*a44*a53-a11*a25*a36*a44*a53-a16*a24*a31*a45*      &\n         a53+a14*a26*a31*a45*a53+a16*a21*a34*a45*a53-a11*a26*a34*a45*a53-a14*a21*  &\n         a36*a45*a53+a11*a24*a36*a45*a53+a15*a24*a31*a46*a53-a14*a25*a31*a46*      &\n         a53-a15*a21*a34*a46*a53+a11*a25*a34*a46*a53+a14*a21*a35*a46*a53-a11*a24*  &\n         a35*a46*a53+a16*a25*a33*a41*a54-a15*a26*a33*a41*a54-a16*a23*a35*a41*      &\n         a54+a13*a26*a35*a41*a54+a15*a23*a36*a41*a54-a13*a25*a36*a41*a54-a16*a25*  &\n         a31*a43*a54+a15*a26*a31*a43*a54+a16*a21*a35*a43*a54-a11*a26*a35*a43*      &\n         a54-a15*a21*a36*a43*a54+a11*a25*a36*a43*a54+a16*a23*a31*a45*a54-a13*a26*  &\n         a31*a45*a54-a16*a21*a33*a45*a54+a11*a26*a33*a45*a54+a13*a21*a36*a45*      &\n         a54-a11*a23*a36*a45*a54-a15*a23*a31*a46*a54+a13*a25*a31*a46*a54+a15*a21*  &\n         a33*a46*a54-a11*a25*a33*a46*a54-a13*a21*a35*a46*a54+a11*a23*a35*a46*      &\n         a54-a16*a24*a33*a41*a55+a14*a26*a33*a41*a55+a16*a23*a34*a41*a55-a13*a26*  &\n         a34*a41*a55-a14*a23*a36*a41*a55+a13*a24*a36*a41*a55+a16*a24*a31*a43*      &\n         a55-a14*a26*a31*a43*a55-a16*a21*a34*a43*a55+a11*a26*a34*a43*a55+a14*a21*  &\n         a36*a43*a55-a11*a24*a36*a43*a55-a16*a23*a31*a44*a55+a13*a26*a31*a44*      &\n         a55+a16*a21*a33*a44*a55-a11*a26*a33*a44*a55-a13*a21*a36*a44*a55+a11*a23*  &\n         a36*a44*a55+a14*a23*a31*a46*a55-a13*a24*a31*a46*a55-a14*a21*a33*a46*      &\n         a55+a11*a24*a33*a46*a55+a13*a21*a34*a46*a55-a11*a23*a34*a46*a55+a15*a24*  &\n         a33*a41*a56-a14*a25*a33*a41*a56-a15*a23*a34*a41*a56+a13*a25*a34*a41*      &\n         a56+a14*a23*a35*a41*a56-a13*a24*a35*a41*a56-a15*a24*a31*a43*a56+a14*a25*  &\n         a31*a43*a56+a15*a21*a34*a43*a56-a11*a25*a34*a43*a56-a14*a21*a35*a43*      &\n         a56+a11*a24*a35*a43*a56+a15*a23*a31*a44*a56-a13*a25*a31*a44*a56-a15*a21*  &\n         a33*a44*a56+a11*a25*a33*a44*a56+a13*a21*a35*a44*a56-a11*a23*a35*a44*      &\n         a56-a14*a23*a31*a45*a56+a13*a24*a31*a45*a56+a14*a21*a33*a45*a56-a11*a24*  &\n         a33*a45*a56-a13*a21*a34*a45*a56+a11*a23*a34*a45*a56)*a62-(a16*a25*a34*    &\n         a42*a51-a15*a26*a34*a42*a51-a16*a24*a35*a42*a51+a14*a26*a35*a42*a51+a15*  &\n         a24*a36*a42*a51-a14*a25*a36*a42*a51-a16*a25*a32*a44*a51+a15*a26*a32*a44*  &\n         a51+a16*a22*a35*a44*a51-a12*a26*a35*a44*a51-a15*a22*a36*a44*a51+a12*a25*  &\n         a36*a44*a51+a16*a24*a32*a45*a51-a14*a26*a32*a45*a51-a16*a22*a34*a45*      &\n         a51+a12*a26*a34*a45*a51+a14*a22*a36*a45*a51-a12*a24*a36*a45*a51-a15*a24*  &\n         a32*a46*a51+a14*a25*a32*a46*a51+a15*a22*a34*a46*a51-a12*a25*a34*a46*      &\n         a51-a14*a22*a35*a46*a51+a12*a24*a35*a46*a51-a16*a25*a34*a41*a52+a15*a26*  &\n         a34*a41*a52+a16*a24*a35*a41*a52-a14*a26*a35*a41*a52-a15*a24*a36*a41*      &\n         a52+a14*a25*a36*a41*a52+a16*a25*a31*a44*a52-a15*a26*a31*a44*a52-a16*a21*  &\n         a35*a44*a52+a11*a26*a35*a44*a52+a15*a21*a36*a44*a52-a11*a25*a36*a44*      &\n         a52-a16*a24*a31*a45*a52+a14*a26*a31*a45*a52+a16*a21*a34*a45*a52-a11*a26*  &\n         a34*a45*a52-a14*a21*a36*a45*a52+a11*a24*a36*a45*a52+a15*a24*a31*a46*      &\n         a52-a14*a25*a31*a46*a52-a15*a21*a34*a46*a52+a11*a25*a34*a46*a52+a14*a21*  &\n         a35*a46*a52-a11*a24*a35*a46*a52+a16*a25*a32*a41*a54-a15*a26*a32*a41*      &\n         a54-a16*a22*a35*a41*a54+a12*a26*a35*a41*a54+a15*a22*a36*a41*a54-a12*a25*  &\n         a36*a41*a54-a16*a25*a31*a42*a54+a15*a26*a31*a42*a54+a16*a21*a35*a42*      &\n         a54-a11*a26*a35*a42*a54-a15*a21*a36*a42*a54+a11*a25*a36*a42*a54+a16*a22*  &\n         a31*a45*a54-a12*a26*a31*a45*a54-a16*a21*a32*a45*a54+a11*a26*a32*a45*      &\n         a54+a12*a21*a36*a45*a54-a11*a22*a36*a45*a54-a15*a22*a31*a46*a54+a12*a25*  &\n         a31*a46*a54+a15*a21*a32*a46*a54-a11*a25*a32*a46*a54-a12*a21*a35*a46*      &\n         a54+a11*a22*a35*a46*a54-a16*a24*a32*a41*a55+a14*a26*a32*a41*a55+a16*a22*  &\n         a34*a41*a55-a12*a26*a34*a41*a55-a14*a22*a36*a41*a55+a12*a24*a36*a41*      &\n         a55+a16*a24*a31*a42*a55-a14*a26*a31*a42*a55-a16*a21*a34*a42*a55+a11*a26*  &\n         a34*a42*a55+a14*a21*a36*a42*a55-a11*a24*a36*a42*a55-a16*a22*a31*a44*      &\n         a55+a12*a26*a31*a44*a55+a16*a21*a32*a44*a55-a11*a26*a32*a44*a55-a12*a21*  &\n         a36*a44*a55+a11*a22*a36*a44*a55+a14*a22*a31*a46*a55-a12*a24*a31*a46*      &\n         a55-a14*a21*a32*a46*a55+a11*a24*a32*a46*a55+a12*a21*a34*a46*a55-a11*a22*  &\n         a34*a46*a55+a15*a24*a32*a41*a56-a14*a25*a32*a41*a56-a15*a22*a34*a41*      &\n         a56+a12*a25*a34*a41*a56+a14*a22*a35*a41*a56-a12*a24*a35*a41*a56-a15*a24*  &\n         a31*a42*a56+a14*a25*a31*a42*a56+a15*a21*a34*a42*a56-a11*a25*a34*a42*      &\n         a56-a14*a21*a35*a42*a56+a11*a24*a35*a42*a56+a15*a22*a31*a44*a56-a12*a25*  &\n         a31*a44*a56-a15*a21*a32*a44*a56+a11*a25*a32*a44*a56+a12*a21*a35*a44*      &\n         a56-a11*a22*a35*a44*a56-a14*a22*a31*a45*a56+a12*a24*a31*a45*a56+a14*a21*  &\n         a32*a45*a56-a11*a24*a32*a45*a56-a12*a21*a34*a45*a56+a11*a22*a34*a45*a56)* &\n         a63+(a16*a25*a33*a42*a51-a15*a26*a33*a42*a51-a16*a23*a35*a42*a51+a13*a26* &\n         a35*a42*a51+a15*a23*a36*a42*a51-a13*a25*a36*a42*a51-a16*a25*a32*a43*      &\n         a51+a15*a26*a32*a43*a51+a16*a22*a35*a43*a51-a12*a26*a35*a43*a51-a15*a22*  &\n         a36*a43*a51+a12*a25*a36*a43*a51+a16*a23*a32*a45*a51-a13*a26*a32*a45*      &\n         a51-a16*a22*a33*a45*a51+a12*a26*a33*a45*a51+a13*a22*a36*a45*a51-a12*a23*  &\n         a36*a45*a51-a15*a23*a32*a46*a51+a13*a25*a32*a46*a51+a15*a22*a33*a46*      &\n         a51-a12*a25*a33*a46*a51-a13*a22*a35*a46*a51+a12*a23*a35*a46*a51-a16*a25*  &\n         a33*a41*a52+a15*a26*a33*a41*a52+a16*a23*a35*a41*a52-a13*a26*a35*a41*      &\n         a52-a15*a23*a36*a41*a52+a13*a25*a36*a41*a52+a16*a25*a31*a43*a52-a15*a26*  &\n         a31*a43*a52-a16*a21*a35*a43*a52+a11*a26*a35*a43*a52+a15*a21*a36*a43*      &\n         a52-a11*a25*a36*a43*a52-a16*a23*a31*a45*a52+a13*a26*a31*a45*a52+a16*a21*  &\n         a33*a45*a52-a11*a26*a33*a45*a52-a13*a21*a36*a45*a52+a11*a23*a36*a45*      &\n         a52+a15*a23*a31*a46*a52-a13*a25*a31*a46*a52-a15*a21*a33*a46*a52+a11*a25*  &\n         a33*a46*a52+a13*a21*a35*a46*a52-a11*a23*a35*a46*a52+a16*a25*a32*a41*      &\n         a53-a15*a26*a32*a41*a53-a16*a22*a35*a41*a53+a12*a26*a35*a41*a53+a15*a22*  &\n         a36*a41*a53-a12*a25*a36*a41*a53-a16*a25*a31*a42*a53+a15*a26*a31*a42*      &\n         a53+a16*a21*a35*a42*a53-a11*a26*a35*a42*a53-a15*a21*a36*a42*a53+a11*a25*  &\n         a36*a42*a53+a16*a22*a31*a45*a53-a12*a26*a31*a45*a53-a16*a21*a32*a45*      &\n         a53+a11*a26*a32*a45*a53+a12*a21*a36*a45*a53-a11*a22*a36*a45*a53-a15*a22*  &\n         a31*a46*a53+a12*a25*a31*a46*a53+a15*a21*a32*a46*a53-a11*a25*a32*a46*      &\n         a53-a12*a21*a35*a46*a53+a11*a22*a35*a46*a53-a16*a23*a32*a41*a55+a13*a26*  &\n         a32*a41*a55+a16*a22*a33*a41*a55-a12*a26*a33*a41*a55-a13*a22*a36*a41*      &\n         a55+a12*a23*a36*a41*a55+a16*a23*a31*a42*a55-a13*a26*a31*a42*a55-a16*a21*  &\n         a33*a42*a55+a11*a26*a33*a42*a55+a13*a21*a36*a42*a55-a11*a23*a36*a42*      &\n         a55-a16*a22*a31*a43*a55+a12*a26*a31*a43*a55+a16*a21*a32*a43*a55-a11*a26*  &\n         a32*a43*a55-a12*a21*a36*a43*a55+a11*a22*a36*a43*a55+a13*a22*a31*a46*      &\n         a55-a12*a23*a31*a46*a55-a13*a21*a32*a46*a55+a11*a23*a32*a46*a55+a12*a21*  &\n         a33*a46*a55-a11*a22*a33*a46*a55+a15*a23*a32*a41*a56-a13*a25*a32*a41*      &\n         a56-a15*a22*a33*a41*a56+a12*a25*a33*a41*a56+a13*a22*a35*a41*a56-a12*a23*  &\n         a35*a41*a56-a15*a23*a31*a42*a56+a13*a25*a31*a42*a56+a15*a21*a33*a42*      &\n         a56-a11*a25*a33*a42*a56-a13*a21*a35*a42*a56+a11*a23*a35*a42*a56+a15*a22*  &\n         a31*a43*a56-a12*a25*a31*a43*a56-a15*a21*a32*a43*a56+a11*a25*a32*a43*      &\n         a56+a12*a21*a35*a43*a56-a11*a22*a35*a43*a56-a13*a22*a31*a45*a56+a12*a23*  &\n         a31*a45*a56+a13*a21*a32*a45*a56-a11*a23*a32*a45*a56-a12*a21*a33*a45*      &\n         a56+a11*a22*a33*a45*a56)*a64-(a16*a24*a33*a42*a51-a14*a26*a33*a42*        &\n         a51-a16*a23*a34*a42*a51+a13*a26*a34*a42*a51+a14*a23*a36*a42*a51-a13*a24*  &\n         a36*a42*a51-a16*a24*a32*a43*a51+a14*a26*a32*a43*a51+a16*a22*a34*a43*      &\n         a51-a12*a26*a34*a43*a51-a14*a22*a36*a43*a51+a12*a24*a36*a43*a51+a16*a23*  &\n         a32*a44*a51-a13*a26*a32*a44*a51-a16*a22*a33*a44*a51+a12*a26*a33*a44*      &\n         a51+a13*a22*a36*a44*a51-a12*a23*a36*a44*a51-a14*a23*a32*a46*a51+a13*a24*  &\n         a32*a46*a51+a14*a22*a33*a46*a51-a12*a24*a33*a46*a51-a13*a22*a34*a46*      &\n         a51+a12*a23*a34*a46*a51-a16*a24*a33*a41*a52+a14*a26*a33*a41*a52+a16*a23*  &\n         a34*a41*a52-a13*a26*a34*a41*a52-a14*a23*a36*a41*a52+a13*a24*a36*a41*      &\n         a52+a16*a24*a31*a43*a52-a14*a26*a31*a43*a52-a16*a21*a34*a43*a52+a11*a26*  &\n         a34*a43*a52+a14*a21*a36*a43*a52-a11*a24*a36*a43*a52-a16*a23*a31*a44*      &\n         a52+a13*a26*a31*a44*a52+a16*a21*a33*a44*a52-a11*a26*a33*a44*a52-a13*a21*  &\n         a36*a44*a52+a11*a23*a36*a44*a52+a14*a23*a31*a46*a52-a13*a24*a31*a46*      &\n         a52-a14*a21*a33*a46*a52+a11*a24*a33*a46*a52+a13*a21*a34*a46*a52-a11*a23*  &\n         a34*a46*a52+a16*a24*a32*a41*a53-a14*a26*a32*a41*a53-a16*a22*a34*a41*      &\n         a53+a12*a26*a34*a41*a53+a14*a22*a36*a41*a53-a12*a24*a36*a41*a53-a16*a24*  &\n         a31*a42*a53+a14*a26*a31*a42*a53+a16*a21*a34*a42*a53-a11*a26*a34*a42*      &\n         a53-a14*a21*a36*a42*a53+a11*a24*a36*a42*a53+a16*a22*a31*a44*a53-a12*a26*  &\n         a31*a44*a53-a16*a21*a32*a44*a53+a11*a26*a32*a44*a53+a12*a21*a36*a44*      &\n         a53-a11*a22*a36*a44*a53-a14*a22*a31*a46*a53+a12*a24*a31*a46*a53+a14*a21*  &\n         a32*a46*a53-a11*a24*a32*a46*a53-a12*a21*a34*a46*a53+a11*a22*a34*a46*      &\n         a53-a16*a23*a32*a41*a54+a13*a26*a32*a41*a54+a16*a22*a33*a41*a54-a12*a26*  &\n         a33*a41*a54-a13*a22*a36*a41*a54+a12*a23*a36*a41*a54+a16*a23*a31*a42*      &\n         a54-a13*a26*a31*a42*a54-a16*a21*a33*a42*a54+a11*a26*a33*a42*a54+a13*a21*  &\n         a36*a42*a54-a11*a23*a36*a42*a54-a16*a22*a31*a43*a54+a12*a26*a31*a43*      &\n         a54+a16*a21*a32*a43*a54-a11*a26*a32*a43*a54-a12*a21*a36*a43*a54+a11*a22*  &\n         a36*a43*a54+a13*a22*a31*a46*a54-a12*a23*a31*a46*a54-a13*a21*a32*a46*      &\n         a54+a11*a23*a32*a46*a54+a12*a21*a33*a46*a54-a11*a22*a33*a46*a54+a14*a23*  &\n         a32*a41*a56-a13*a24*a32*a41*a56-a14*a22*a33*a41*a56+a12*a24*a33*a41*      &\n         a56+a13*a22*a34*a41*a56-a12*a23*a34*a41*a56-a14*a23*a31*a42*a56+a13*a24*  &\n         a31*a42*a56+a14*a21*a33*a42*a56-a11*a24*a33*a42*a56-a13*a21*a34*a42*      &\n         a56+a11*a23*a34*a42*a56+a14*a22*a31*a43*a56-a12*a24*a31*a43*a56-a14*a21*  &\n         a32*a43*a56+a11*a24*a32*a43*a56+a12*a21*a34*a43*a56-a11*a22*a34*a43*      &\n         a56-a13*a22*a31*a44*a56+a12*a23*a31*a44*a56+a13*a21*a32*a44*a56-a11*a23*  &\n         a32*a44*a56-a12*a21*a33*a44*a56+a11*a22*a33*a44*a56)*a65+(a15*a24*a33*    &\n         a42*a51-a14*a25*a33*a42*a51-a15*a23*a34*a42*a51+a13*a25*a34*a42*a51+a14*  &\n         a23*a35*a42*a51-a13*a24*a35*a42*a51-a15*a24*a32*a43*a51+a14*a25*a32*a43*  &\n         a51+a15*a22*a34*a43*a51-a12*a25*a34*a43*a51-a14*a22*a35*a43*a51+a12*a24*  &\n         a35*a43*a51+a15*a23*a32*a44*a51-a13*a25*a32*a44*a51-a15*a22*a33*a44*      &\n         a51+a12*a25*a33*a44*a51+a13*a22*a35*a44*a51-a12*a23*a35*a44*a51-a14*a23*  &\n         a32*a45*a51+a13*a24*a32*a45*a51+a14*a22*a33*a45*a51-a12*a24*a33*a45*      &\n         a51-a13*a22*a34*a45*a51+a12*a23*a34*a45*a51-a15*a24*a33*a41*a52+a14*a25*  &\n         a33*a41*a52+a15*a23*a34*a41*a52-a13*a25*a34*a41*a52-a14*a23*a35*a41*      &\n         a52+a13*a24*a35*a41*a52+a15*a24*a31*a43*a52-a14*a25*a31*a43*a52-a15*a21*  &\n         a34*a43*a52+a11*a25*a34*a43*a52+a14*a21*a35*a43*a52-a11*a24*a35*a43*      &\n         a52-a15*a23*a31*a44*a52+a13*a25*a31*a44*a52+a15*a21*a33*a44*a52-a11*a25*  &\n         a33*a44*a52-a13*a21*a35*a44*a52+a11*a23*a35*a44*a52+a14*a23*a31*a45*      &\n         a52-a13*a24*a31*a45*a52-a14*a21*a33*a45*a52+a11*a24*a33*a45*a52+a13*a21*  &\n         a34*a45*a52-a11*a23*a34*a45*a52+a15*a24*a32*a41*a53-a14*a25*a32*a41*      &\n         a53-a15*a22*a34*a41*a53+a12*a25*a34*a41*a53+a14*a22*a35*a41*a53-a12*a24*  &\n         a35*a41*a53-a15*a24*a31*a42*a53+a14*a25*a31*a42*a53+a15*a21*a34*a42*      &\n         a53-a11*a25*a34*a42*a53-a14*a21*a35*a42*a53+a11*a24*a35*a42*a53+a15*a22*  &\n         a31*a44*a53-a12*a25*a31*a44*a53-a15*a21*a32*a44*a53+a11*a25*a32*a44*      &\n         a53+a12*a21*a35*a44*a53-a11*a22*a35*a44*a53-a14*a22*a31*a45*a53+a12*a24*  &\n         a31*a45*a53+a14*a21*a32*a45*a53-a11*a24*a32*a45*a53-a12*a21*a34*a45*      &\n         a53+a11*a22*a34*a45*a53-a15*a23*a32*a41*a54+a13*a25*a32*a41*a54+a15*a22*  &\n         a33*a41*a54-a12*a25*a33*a41*a54-a13*a22*a35*a41*a54+a12*a23*a35*a41*      &\n         a54+a15*a23*a31*a42*a54-a13*a25*a31*a42*a54-a15*a21*a33*a42*a54+a11*a25*  &\n         a33*a42*a54+a13*a21*a35*a42*a54-a11*a23*a35*a42*a54-a15*a22*a31*a43*      &\n         a54+a12*a25*a31*a43*a54+a15*a21*a32*a43*a54-a11*a25*a32*a43*a54-a12*a21*  &\n         a35*a43*a54+a11*a22*a35*a43*a54+a13*a22*a31*a45*a54-a12*a23*a31*a45*      &\n         a54-a13*a21*a32*a45*a54+a11*a23*a32*a45*a54+a12*a21*a33*a45*a54-a11*a22*  &\n         a33*a45*a54+a14*a23*a32*a41*a55-a13*a24*a32*a41*a55-a14*a22*a33*a41*      &\n         a55+a12*a24*a33*a41*a55+a13*a22*a34*a41*a55-a12*a23*a34*a41*a55-a14*a23*  &\n         a31*a42*a55+a13*a24*a31*a42*a55+a14*a21*a33*a42*a55-a11*a24*a33*a42*      &\n         a55-a13*a21*a34*a42*a55+a11*a23*a34*a42*a55+a14*a22*a31*a43*a55-a12*a24*  &\n         a31*a43*a55-a14*a21*a32*a43*a55+a11*a24*a32*a43*a55+a12*a21*a34*a43*      &\n         a55-a11*a22*a34*a43*a55-a13*a22*a31*a44*a55+a12*a23*a31*a44*a55+a13*a21*  &\n         a32*a44*a55-a11*a23*a32*a44*a55-a12*a21*a33*a44*a55+a11*a22*a33*a44*a55)* &\n         a66\n      return\n    end function m6x6det\n"}, {"instruction": "Create a Fortran function named minor to extract a minor matrix from a given matrix based on the specified row and column indices. The function should take 4 input arguments of type integer, integer, integer, and real(kind(1d0)),dimension(n,n), and return 1 output argument of type real(kind(1d0)),dimension(n-1,n-1).", "input": "", "output": "    function minor(n,a,i,j)\n      implicit none\n      integer,intent(in)::n,i,j\n      real(kind(1d0)),dimension(n,n),intent(in)::a\n      real(kind(1d0)),dimension(n-1,n-1)::minor\n      integer::k1,k2,i0,j0\n      i0=1\n      do k1=1,n\n         if(k1.eq.i)cycle\n         j0=1\n         do k2=1,n\n            if(k2.eq.j)cycle\n            minor(i0,j0)=a(k1,k2)\n            j0=j0+1\n         enddo\n         i0=i0+1\n      enddo\n      return\n    end function minor\n"}, {"instruction": "Write a Fortran function named ldot, which calculates the linear dot product of two given arrays. The function should accept four input parameters: two integers n1 and n2, a 2D real array a of size n1 by n2, and a 1D real array b of size n1. The output should be a 1D real array ldot of size n2.", "input": "", "output": "    function ldot(n1,n2,a,b)\n      ! b.a \n      implicit none\n      integer,intent(in)::n1,n2\n      real(kind(1d0)),dimension(n1,n2),intent(in)::a\n      real(kind(1d0)),dimension(n1),intent(in)::b\n      real(kind(1d0)),dimension(n2)::ldot\n      integer::i,j\n      do i=1,n2\n         ldot(i)=0d0\n          do j=1,n1\n            ldot(i)=ldot(i)+a(j,i)*b(j)\n         enddo\n      enddo\n      return\n    end function ldot\n"}, {"instruction": "Write a Fortran function named hdeltabar that checks if an array element at index j is non-zero. The number of input parameters is 3 with test_data type ['integer', 'integer', 'integer,dimension(n)'], and the number of output parameters is 1 with test_data type ['integer'].", "input": "", "output": "    function hdeltabar(n,x,j)\n      implicit none\n      integer,intent(in)::n,j\n      integer,dimension(n),intent(in)::x\n      integer::hdeltabar\n      integer::i\n      do i=1,n\n         if(x(i).ne.0.and.i.eq.j)then\n            hdeltabar=0\n            return\n         endif\n      enddo\n      hdeltabar=1\n      return\n    end function hdeltabar\n"}, {"instruction": "Create a Fortran function named \"chap\" that calculates the Chapman function value based on a real input parameter. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "      function chap(zeta)\n        real :: zeta\n        real :: rm\n        integer :: i\n        real :: y(22)\n        real :: chap\n        data (y(i),i=1,22)/3.800, 4.055, 4.348, 4.687, 5.083, 5.551, 6.113, &\n          6.799, 7.650, 8.732, 10.144, 12.051, 14.730, 18.686, 24.905, 35.466, &\n          55.211, 96.753, 197., 485., 1476., 9999./\n        do 10 i = 75, 96\n          rm = i\n          if (zeta<rm) go to 20\n10 continue\n20 chap = y(i-75) + (y(i-74)-y(i-75))*(zeta-(rm-1.))\n      end function chap\n"}, {"instruction": "Create a Fortran function named split_string to split a string based on a specified separator character. The function takes 2 input arguments with the test_data type ['character(len=*)', 'character(1)'] and returns 1 output parameter with the test_data type ['character(len=len(string)), dimension(:), allocatable'].", "input": "", "output": "    function split_string(string,separator)\n        implicit none\n        character(len=*),intent(in) :: string\n        character(1),intent(in) :: separator\n        character(len=len(string)), dimension(:), allocatable :: split_string\n\n        character(len=len(string)), dimension(:), allocatable :: temp_split_string\n\n        integer :: i,j,k\n\n\n        allocate(split_string(0))\n        temp_split_string = split_string\n        i = 0\n        k = 0\n        do \n            j = index(string(i+1:),separator)\n            if(trim(adjustl(string(i+1:i+j)))=='') exit\n\n            k = k+1 \n            deallocate(split_string)\n            allocate(split_string(k))\n            split_string(:k-1) = temp_split_string\n            deallocate(temp_split_string)\n            split_string(k) = trim(adjustl(string(i+1:i+j))) \n            temp_split_string = split_string\n\n            i = i+j\n        end do\n\n    end function split_string\n"}, {"instruction": "Write a Fortran function named interp_gxp that performs interpolation. This function has 6 input parameters of types real(kind=8), dimension(:), real(kind=8), dimension(:), real(kind=8), dimension(:), real(kind=8), dimension(:), integer, dimension(:), and integer, dimension(:). It has 1 output parameter of type real(kind=8), dimension(size(x)). This function performs interpolation using the input data and returns the interpolated values in the output parameter.", "input": "", "output": "      function interp_gxp(x,p,ix,iy,xv,yv) result(yy)\n          real(kind=8), dimension(:), intent(in) :: x,p,xv\n          real(kind=8), dimension(:), intent(in) :: yv\n          integer, dimension(:), intent(in) :: ix,iy\n          integer, dimension(size(ix)) :: indx\n          real(kind=8), dimension(size(x)) :: yy,slope,yix,xix,yix1,xix1,xx\n          xx=log(x); \n\n          indx=iy*size(xv)+ix\n          ! then interpolate between these to choose appropriate p:\n          yix=yv(indx) ; yix1=yv(indx+1) ; \n          xix=xv(ix) ; xix1=xv(ix+1)\n          slope=(yix1-yix)/(xix1-xix)\n          yy=yix+slope*(xx-xix)\n          yy=exp(yy)\n      end function interp_gxp\n"}, {"instruction": "Create a Fortran function named eval_a that takes two input parameters of type integer. Calculate a real*8 result using the formula eval_a = 1.d0 / (0.5d0 * ((di + dj) * (di + dj + 1.d0)) + di + 1.d0), where di and dj are the real*8 representations of the input integers i and j. The function returns a single real*8 result.", "input": "", "output": "pure function eval_a(i, j)\nreal*8 :: eval_a\ninteger, intent(in) :: i, j\nreal*8 :: di, dj\ninteger :: d\ndi = real(i,8)\ndj = real(j,8)\neval_a = 1.d0 / (0.5d0 * ((di + dj) * (di + dj + 1.d0)) + di + 1.d0)\nend function\n"}, {"instruction": "Create a Fortran function named qconj to calculate the conjugate of a quaternion represented by a 4-element real array. The function should take 1 input argument of type real, dimension(0:3) and return 1 output argument of type real, dimension(0:3).", "input": "", "output": " pure function qconj(qs)\n  implicit none      \n  real, intent(in), dimension(0:3) :: qs      \n  real, dimension(0:3) :: qconj\n  \n  qconj(0) = qs(0)\n  qconj(1:3) = -qs(1:3)\n end function qconj\n"}, {"instruction": "Write a Fortran function called dimenumb that calculates the number of digits in a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": " function dimenumb(inum)\n  implicit none\n  integer,intent(in) :: inum\n  integer :: dimenumb, i\n  real :: tmp\n\n  i=1\n  tmp = real(inum)\n  do\n    if (tmp<10.0) exit\n    i = i+1\n    tmp = tmp / 10.0\n  enddo\n\n  dimenumb = i\n end function dimenumb\n"}, {"instruction": "Create a Fortran function named compare to compare two integer values. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type is ['integer', 'integer'] for input and ['integer'] for output.", "input": "", "output": "    function compare(f,g)\n      implicit none\n      integer               :: f,g\n      integer               :: compare\n      if(f<g) then\n         compare=-1\n      else\n         compare=1\n      endif\n    end function compare\n"}, {"instruction": "Create a Fortran function named sub2ind that calculates the linear index of a multidimensional array given its dimensions and subscripts. The function takes 2 input parameters of type 'integer, dimension(:)' representing the dimensions of the array and the subscripts, and returns 1 output parameter of type 'integer' representing the linear index.", "input": "", "output": "function sub2ind(dims, subs) result (ind)\n    !+ calculates the linear index of an array with dimensions `dims` and\n    !+ subcripts `subs`\n    integer, dimension(:), intent(in) :: dims\n        !+ dimension of array\n    integer, dimension(:), intent(in) :: subs\n        !+ subscripts to convert\n    integer :: ind\n        !+ linear index\n\n    integer :: k, l, p\n\n    ind = subs(1)\n    do k=2,size(dims)\n        p = dims(1)\n        do l=2, k-1\n            p = p*dims(l)\n        enddo\n        ind = ind + p*(subs(k)-1)\n    enddo\n\nend function sub2ind\n"}, {"instruction": "Create a Fortran function named get_index_of_first_particle, which takes an integer input parameter and returns an integer output. The function's purpose is to return the index of the first particle.", "input": "", "output": "function get_index_of_first_particle(index_of_the_particle)\n  implicit none\n  integer :: get_index_of_first_particle\n  integer :: index_of_the_particle\n  get_index_of_first_particle=0\nend function\n"}, {"instruction": "Create a Fortran function named get_total_radius that takes a double precision input parameter named radius. The function returns an integer value.", "input": "", "output": "function get_total_radius(radius)\n  implicit none\n  integer :: get_total_radius\n  double precision :: radius\n  get_total_radius=0\nend function\n"}, {"instruction": "Write a Fortran function named get_potential_at_point to calculate the potential at a given point. The function takes 5 input parameters of type double precision: eps, x, y, z, and phi. It returns 1 output parameter of type integer.", "input": "", "output": "function get_potential_at_point(eps, x, y, z, phi)\n  implicit none\n  integer :: get_potential_at_point\n  double precision :: eps, x, y, z, phi\n  get_potential_at_point=0\nend function\n"}, {"instruction": "Create a Fortran function named set_eps2 that takes a double precision input parameter to set the value of epsilon squared. The function returns an integer value indicating the success of the operation. The number of input parameters is 1 with a test_data type of ['double precision'], and the number of output parameters is 1 with a test_data type of ['integer'].", "input": "", "output": "function set_eps2(epsilon_squared)\n  implicit none\n  integer :: set_eps2\n  double precision :: epsilon_squared\n  set_eps2=0\nend function\n"}, {"instruction": "Write a Fortran function named get_eps2 that takes a double precision input argument and returns an integer. The input argument type is ['double precision'] and the output argument type is ['integer'].", "input": "", "output": "function get_eps2(epsilon_squared)\n  implicit none\n  integer :: get_eps2\n  double precision :: epsilon_squared\n  get_eps2=0\nend function\n"}, {"instruction": "Create a Fortran function named get_potential to retrieve the potential for a particle based on its index. This function takes 2 input parameters of type integer and double precision. The output is a single integer.", "input": "", "output": "function get_potential(index_of_the_particle, potential)\n  implicit none\n  integer ::get_potential\n  integer :: index_of_the_particle\n  double precision :: potential\n  get_potential=0\nend function\n"}, {"instruction": "Create a Fortran function named set_acceleration to set the acceleration components for a particle. The function takes 4 input parameters: index_of_the_particle (integer), ax (double precision), ay (double precision), and az (double precision). It returns a single output parameter of type integer.", "input": "", "output": "function set_acceleration(index_of_the_particle, ax, ay, az)\n  implicit none\n  integer :: set_acceleration\n  integer :: index_of_the_particle\n  double precision :: ax, ay, az\n  set_acceleration=0\nend function\n"}, {"instruction": "Create a Fortran function named get_center_of_mass_position to calculate the center of mass position in three-dimensional space. The function takes 3 input parameters of type double precision representing the x, y, and z coordinates, and returns an output value of type integer.", "input": "", "output": "function get_center_of_mass_position(x, y, z)\n  implicit none\n  integer :: get_center_of_mass_position\n  double precision :: x, y, z\n  get_center_of_mass_position=0\nend function\n"}, {"instruction": "Create a Fortran function named get_center_of_mass_velocity to calculate the center of mass velocity components in three dimensions. Accept 3 input parameters of type double precision (vx, vy, vz) and return 1 output parameter of type integer. The test_data type for input is ['double precision', 'double precision', 'double precision'] and for the output is ['integer'].", "input": "", "output": "function get_center_of_mass_velocity(vx, vy, vz)\n  implicit none\n  integer :: get_center_of_mass_velocity\n  double precision :: vx, vy, vz\n  get_center_of_mass_velocity=0\nend function\n"}, {"instruction": "Create a Fortran function named get_acceleration to retrieve the acceleration components (ax, ay, az) of a particle specified by its index. The function takes 4 input parameters of type integer, double precision, double precision, and double precision respectively. The output is an integer indicating the status of the function.", "input": "", "output": "function get_acceleration(index_of_the_particle, ax, ay, az)\n  implicit none\n  integer :: get_acceleration\n  integer :: index_of_the_particle\n  double precision :: ax, ay, az\n  get_acceleration=0\nend function\n"}, {"instruction": "Create a Fortran function named pm_spectrum that calculates the Pierson-Moskowitz spectrum for a given frequency, significant wave height, and peak period. The function should have 3 input parameters of type real(kind=long) representing the frequency, significant wave height, and peak period, and 1 output parameter of type real(kind=long) representing the Pierson-Moskowitz spectrum.", "input": "", "output": " function pm_spectrum(freq, hs, tp)\n!\n\n! for the frequency freq, significant wave height hs, and peak period\n! tp.\n\n   implicit none\n   integer, parameter :: long=selected_real_kind(12,99)\n   real(kind=long) :: pm_spectrum, hs, tp, a, b, freq, t02,   &\n        four=4._long, pi, zero=0._long, one=1._long\n   pi = acos (-one)\n\n   t02=.71*tp\n   a = hs*hs/(four*pi*t02**4)\n   b = one/(pi*t02**4)\n   if (freq.le.zero) then\n      pm_spectrum = zero\n   else\n      pm_spectrum = a/freq**5 * exp (-b/freq**4)\n   endif\n   return\n end function pm_spectrum\n"}, {"instruction": "Create a Fortran function named char2int that converts a character string to an integer. The function takes 1 input parameter of type character (*) and returns 1 output parameter of type integer. The function should use the \"intent (in)\" attribute for the input parameter.", "input": "", "output": "   function char2int(c) result (i)\n      implicit none\n      character (*), intent (in) :: c\n      integer :: i\n      character (20) :: ifmt\n      write (ifmt,'(\"(i\",i0,\")\")') len_trim(c)\n      read (c,fmt=ifmt) i\n   end function char2int\n"}, {"instruction": "Create a Fortran function called neighbors to determine if two arrays of integers, knn1 and knn2, share any common elements. The function should return a logical value indicating whether there are any common elements in the arrays. The input parameters include two integer arrays, knn1 and knn2, both of which are of unspecified size. The output parameter is a single logical value.", "input": "", "output": "    function neighbors(knn1,knn2) result(same_list)\n        implicit none\n        integer,intent(in), dimension(:) :: knn1\n        integer,intent(in), dimension(:) :: knn2 \n\n        logical :: same_list\n\n        ! check to see if they're in each others neighbors lists\n        same_list= any(knn1==knn2(1)) .or. any(knn2==knn1(1))\n\n    end function neighbors\n"}, {"instruction": "Create a Fortran function named matches to compare two integer arrays and count the number of matching elements. The function takes 2 input parameters of type integer arrays with unspecified dimension and returns 1 output parameter of type integer.", "input": "", "output": "    function matches(knn1,knn2)\n        implicit none\n        integer,intent(in), dimension(:) :: knn1\n        integer,intent(in), dimension(:) :: knn2 \n\n        integer :: matches\n\n        integer i,j\n\n        matches = count( [( [( knn1(i)==knn2(j), i=1,size(knn1) )], j=1,size(knn2) )] )\n\n    end function matches\n"}, {"instruction": "Write a Fortran function named cbrt that calculates the cube root of an integer input. The number of input parameters is 1 and the test_data type is ['integer(4)']. The number of output parameters is 1 and the test_data type is ['real(8)'].", "input": "", "output": "function cbrt(mant)\n    implicit none\n\n    integer(4), intent(in) :: mant\n    real(8) :: expo,cbrt\n\n    expo=1./3.\n    cbrt=mant**expo\n    return\nend function cbrt\n"}, {"instruction": "Write a Fortran function named bias to generate a random number between 0 and 1. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used to determine the bias of the random number generation. If the random number is greater than 1 divided by the input integer, the output is 0; otherwise, it is 1.", "input": "", "output": "function bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named fprobdep to calculate the probability of deposition using a probability integral. The function takes 2 input parameters of type real, and returns 1 output parameter of type real. The inputs are tauddd and taubbb, and the output is fprobdep.", "input": "", "output": "function fprobdep(tauddd,taubbb)\n\n  !**********************************************************************c\n  !\n  ! **  fprobdep calculates probability of deposition using probability\n  ! **  integral\n  !\n  ! **  this subroutine is part of  efdc-full version 1.0a\n  !\n  ! **  last modified by john hamrick on 1 november 2001\n  !\n  !----------------------------------------------------------------------c\n  !\n  ! change record\n  ! date modified     by                 date approved    by\n  !\n  !----------------------------------------------------------------------c\n  !\n  !**********************************************************************c\n  !\n\n  implicit none\n\n  integer :: ineg\n  real   :: fprobdep,yval,xval,polyx,expy,funy,tmpval\n  real, intent(in) :: tauddd,taubbb\n\n\n  ! *** evaluation assumes taubbb > tauddd\n  yval=2.04*log(0.25*((taubbb/tauddd)-1.)*exp(1.27*tauddd))\n  ineg=0\n  if( yval < 0.0 )then\n    ineg=1\n    yval=abs(yval)\n  endif\n  xval=1.0/(1.0+0.3327*yval)\n  polyx=xval*(0.4632-0.1202*xval+0.9373*xval*xval)\n  expy=-0.5*yval*yval\n  funy=0.3989*exp(expy)\n  tmpval=1.0-funy*polyx\n  if( ineg == 1 ) tmpval=1.0-tmpval\n  fprobdep=1.0-tmpval\n\n  ! **  notes\n  !     0.3989=1/sqrt(2*pi)\n\nend function\n"}, {"instruction": "Create a Fortran function named quantile that takes two input arguments: an integer k and a one-dimensional real array a. The output is a single real value. The function computes the quantile of the input array a at the specified position k and returns the corresponding value.", "input": "", "output": "    pure recursive function quantile(k, a) result(value)\n        integer, intent(in)  :: k          ! position in array\n        real, dimension(:), intent(in)  :: a\n\n        real                              :: value      ! output value of quantile\n        integer                           :: j\n        real                              :: ak\n\n        ak = a(k)\n        j = count(a < ak)                              ! how many a(:) < ak\n\n        if (j .ge. k) then\n            value = quantile(k, pack(a, a < ak))\n        else\n            j = count(a > ak) + k - size(a)\n\n            if (j .gt. 0) then\n                value = quantile(j, pack(a, a > ak))\n            else\n                value = ak\n            end if\n        end if\n    end function quantile\n"}, {"instruction": "Create a Fortran function named rev_order to reverse the order of elements in an integer array. The number of input arguments is 1 with the test_data type ['integer,dimension(:)'], and the number of output arguments is 1 with the test_data type ['integer,dimension(size(v1))'].", "input": "", "output": "function rev_order(v1) result(v)\n  integer,dimension(:),intent(in)::v1\n  integer,dimension(size(v1))::v\n  integer::i,j\n  j=0\n  do i=size(v1),1,-1\n    j=j+1\n    v(i)=v1(j)\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named ifthenelse_s that returns a character pointer based on a logical condition. The function takes 3 input parameters: a logical flag, and two target character strings. The output is a pointer to a character string. The number of input arguments is 3 and the test_data type is ['logical', 'character(len=*), target', 'character(len=*), target']. The number of output arguments is 1 and the test_data type is ['character(len=:), pointer'].", "input": "", "output": "    function ifthenelse_s(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    character(len=:), pointer :: ifthenelse\n    character(len=*), target :: either, or\n\n    if (flag) then\n        ifthenelse => either\n    else\n        ifthenelse => or\n    end if\n\n    end function\n"}, {"instruction": "Write a Fortran function named ifthenelse_l to evaluate a conditional expression based on the value of a logical flag. The function should accept 3 input arguments of type logical and return 1 output argument of type logical. The test_data type for input arguments is ['logical', 'logical', 'logical'], and for the output argument is ['logical'].", "input": "", "output": "    function ifthenelse_l(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    logical :: ifthenelse, either, or\n\n    if (flag) then\n        ifthenelse = either\n    else\n        ifthenelse = or\n    end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named ifthenelse_r that returns a real number based on a logical flag and two real numbers. The number of input arguments is 3 with test_data types ['logical', 'real', 'real'], and the number of output arguments is 1 with a test_data type of ['real'].", "input": "", "output": "    function ifthenelse_r(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    real :: ifthenelse, either, or\n\n    if (flag) then\n        ifthenelse = either\n    else\n        ifthenelse = or\n    end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named fast_exp to efficiently compute the exponentiation of an array of double precision numbers. The function should take 4 input arguments of types double precision array, integer, integer, and double precision. The output is a double precision array. The function utilizes the \"where\" construct to ensure convergence and a do loop to iterate the exponentiation.", "input": "", "output": "function fast_exp(x, n, m, k) result(val)\n    double precision, dimension(n), intent(in) :: x\n    integer, intent(in) :: n\n    integer, intent(in) :: m\n    double precision, intent(in) :: k\n\n    integer :: i\n    double precision, dimension(n) :: val\n\n    val = (1.0d0+k*x)\n\n    ! makes sure the expression converges\n    where (val < 0.0d0) val = 0.0d0\n\n    do i=2, m\n        val = val * val\n    enddo\n\n    ! exact\n    !val = exp(x)\n\n\nend function fast_exp\n"}, {"instruction": "Create a Fortran function named nr_change_coins to calculate the minimum number of coins needed to make change for a given amount. The function takes 2 input parameters with test_data type ['integer, value', 'integer, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "    function nr_change_coins(amount, coins) result(nr_coins)\n        implicit none\n        integer, value :: amount\n        integer, dimension(:), intent(in) :: coins\n        integer :: nr_coins\n        integer :: coin_nr, coin\n\n        nr_coins = 0\n        do coin_nr = size(coins), 1, -1\n            coin = coins(coin_nr)\n            nr_coins = nr_coins + amount/coin\n            amount = mod(amount, coin)\n        end do\n    end function nr_change_coins\n"}, {"instruction": "Create a Fortran function named getvarbymode to retrieve a value based on a specified mode. The function takes 3 input arguments of type integer: mode, num, and mem (an array). It returns a single output argument of type integer. If the mode is 1, the output is the value of num; otherwise, it retrieves the value from the mem array using the index num + 1.", "input": "", "output": "  function getvarbymode(mem, mode, num) result(r)\n    integer, intent(in) :: mode, num\n    integer :: r\n    integer, dimension(:), intent(in) :: mem\n    if(mode == 1) then\n        r = num\n    else\n        r = mem(num + 1)\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named gettriplepointpropindex that takes a single input argument of type character(len=*) and returns an integer index. The function maps the input to a specific index based on the value of the input parameter using a select case construct.", "input": "", "output": "  function gettriplepointpropindex(comid) result(index)\n    implicit none\n    character(len=*), intent(in) :: comid\n    integer :: index\n    select case (comid)\n    case(\"c1\")\n       index = 1\n    case(\"c2\")\n       index = 2\n    case(\"c3\")\n       index = 3\n    case(\"o2\")\n       index = 4\n    case(\"n2\")\n       index = 5\n    case(\"r152a\")\n       index = 6\n    case(\"h2o\")\n       index = 7\n    case(\"nc7\")\n       index = 8\n    case(\"nh3\")\n       index = 9\n    case(\"f2\")\n       index = 10\n    case(\"he\")\n       index = 11\n    case(\"r134a\")\n       index = 12\n    case default\n       index = 0\n    end select\n  end function gettriplepointpropindex\n"}, {"instruction": "Create a Fortran function named gcd that calculates the greatest common divisor (GCD) of two integer values. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The input arguments should be passed using the \"intent(in)\" attribute.", "input": "", "output": "function gcd(v, t)\n  integer :: gcd\n  integer, intent(in) :: v, t\n  integer :: c, b, a\n\n  b = t\n  a = v\n  do\n     c = mod(a, b)\n     if ( c == 0) exit\n     a = b\n     b = c\n  end do\n  gcd = b ! abs(b)\nend function gcd\n"}, {"instruction": "Write a Fortran function named foo that takes a string as input and returns a modified string. The input parameter should be of type character(*) and intent(in), and the output parameter should be of type character(len=len(string)+2). If the input string contains double quotes, the function should add single quotes around the string and return the modified string.", "input": "", "output": "    function foo(string)\n    character(*), intent(in) :: string\n    character(len=len(string)+2) :: foo\n    if (index(trim(string), '\"').ne.0) then\n      foo = \"'\" // trim(string) // \"'\"\n    end if\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"get_file_length\" with one input parameter of type \"character(len=*)\" to represent the file name. The output parameter, \"lines,\" is of type \"integer.\" This function is designed to determine the number of lines in a specified file by reading the file line by line until the end is reached, excluding empty lines and lines that start with '#'. Make sure to include the necessary error handling for cases where the file cannot be read.", "input": "", "output": "  function get_file_length(file) result(lines)\n    integer           :: lines\n    character(len=*)  :: file\n    integer           :: ifile,ierr,pos\n    logical           :: iofile,bool,bool1,bool2\n    character(len=256)::buffer\n    inquire(file=trim(file),exist=iofile)\n    lines=0\n    if(.not.iofile)then\n       write(*,*) 'cannot read +'//trim(file)//'. skip file_size'\n       return\n    endif\n    open(99,file=trim(file))\n    ierr=0\n    do while(ierr==0)\n       lines=lines+1\n       read(99,*,iostat=ierr)buffer\n       bool1=scan(buffer,\"#\").ne.0\n       bool2=len_trim(buffer).eq.0       \n       if(bool1 .or. bool2)lines=lines-1\n    enddo\n    lines=lines-1\n    rewind(99)\n    close(99)\n  end function get_file_length\n"}, {"instruction": "Write a Fortran function called blocks_to_matrix that takes 3 input parameters: vblocks of type complex(8) and dimension (nlat, nso, nso), nlat of type integer, and nso of type integer, and returns 1 output parameter matrix of type complex(8) and dimension (nlat*nso, nlat*nso). The function's purpose is to convert a set of blocks into a matrix. Use the imperative tone in the instructions.", "input": "", "output": "  function blocks_to_matrix(vblocks,nlat,nso) result(matrix)\n    complex(8),dimension(nlat,nso,nso)      :: vblocks\n    integer                                 :: nlat,nso\n    complex(8),dimension(nlat*nso,nlat*nso) :: matrix\n    integer                                 :: i,j,ip\n    matrix=zero\n    do ip=1,nlat\n       i = 1 + (ip-1)*nso\n       j = ip*nso\n       matrix(i:j,i:j) =  vblocks(ip,:,:)\n    enddo\n  end function blocks_to_matrix\n"}, {"instruction": "Create a Fortran function named gf_funca that takes a single real*8 input argument. The function should calculate a value using a series of algebraic operations and return a single real*8 output. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [real*8].", "input": "", "output": "function gf_funca(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\ta0,a1,a2,a3,a4\n\treal*8\t\t\t\t\t::\ta5,a6,a7,a8,a9\n\treal*8\t\t\t\t\t::\tgf_funca\n\n\tdata\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9\t\t\t&\n\t\t/\t+1.21d0,\t-13.328d0,\t+215.896d0,\t\t&\n\t\t\t-1763.96d0,\t+8418.94d0,\t-24314.21d0,\t&\n\t\t\t+42002.57d0,-41592.9d0,\t21859.0d0,\t\t&\n\t\t\t-4838.6d0\t/\n\n\tgf_funca\t=\t(a8+a9*tt)*tt\n\tgf_funca\t=\t(a7+gf_funca)*tt\n\tgf_funca\t=\t(a6+gf_funca)*tt\n\tgf_funca\t=\t(a5+gf_funca)*tt\n\tgf_funca\t=\t(a4+gf_funca)*tt\n\tgf_funca\t=\t(a3+gf_funca)*tt\n\tgf_funca\t=\t(a2+gf_funca)*tt\n\tgf_funca\t=\t(a1+gf_funca)*tt\n\tgf_funca\t=\ta0+gf_funca\n\n\treturn\nend function gf_funca\n"}, {"instruction": "Create a Fortran function named gf_funcb that takes a single real*8 input parameter. The input parameter is of type real*8. The function should return a single real*8 output parameter. The function computes a complex mathematical expression based on the input parameter.", "input": "", "output": "function gf_funcb(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tb0,b1,b2,b3,b4\n\treal*8\t\t\t\t\t::\tb5,b6,b7,b8,b9\n\treal*8\t\t\t\t\t::\tgf_funcb\n\n\tdata\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9\t\t\t&\n\t\t/\t+0.938d0,\t+5.373d0,\t-67.92d0,\t\t&\n\t\t\t+796.534d0,\t-4780.77d0,\t+17137.74d0,\t&\n\t\t\t-36618.81d0,+44894.06d0,-29030.24d0,\t&\n\t\t\t+7671.22d0\t/\n\n\tgf_funcb\t=\t(b8+b9*tt)*tt\n\tgf_funcb\t=\t(b7+gf_funcb)*tt\n\tgf_funcb\t=\t(b6+gf_funcb)*tt\n\tgf_funcb\t=\t(b5+gf_funcb)*tt\n\tgf_funcb\t=\t(b4+gf_funcb)*tt\n\tgf_funcb\t=\t(b3+gf_funcb)*tt\n\tgf_funcb\t=\t(b2+gf_funcb)*tt\n\tgf_funcb\t=\t(b1+gf_funcb)*tt\n\tgf_funcb\t=\tb0+gf_funcb\n\n\treturn\nend function gf_funcb\n"}, {"instruction": "Write a Fortran function named gf_funcc to calculate a specific mathematical function based on the given input value. The input argument is of type real*8. The function returns a result of type real*8.", "input": "", "output": "function gf_funcc(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tc0,c1,c2,c3,c4\n\treal*8\t\t\t\t\t::\tc5,c6,c7\n\treal*8\t\t\t\t\t::\tgf_funcc\n\n\tdata\tc0,c1,c2,c3,c4,c5,c6,c7\t\t\t\t\t&\n\t\t/\t+1.268d0,\t-9.747d0,\t+209.653d0,\t\t&\n\t\t\t-1397.89d0,\t+5155.67d0,\t-9844.35d0,\t\t&\n\t\t\t+9136.4d0,\t-3272.62d0\t\t/\n\n\tgf_funcc\t=\t(c6+c7*tt)*tt\n\tgf_funcc\t=\t(c5+gf_funcc)*tt\n\tgf_funcc\t=\t(c4+gf_funcc)*tt\n\tgf_funcc\t=\t(c3+gf_funcc)*tt\n\tgf_funcc\t=\t(c2+gf_funcc)*tt\n\tgf_funcc\t=\t(c1+gf_funcc)*tt\n\tgf_funcc\t=\tc0+gf_funcc\n\n\treturn\nend function gf_funcc\n"}, {"instruction": "Write a Fortran function named gf_funcd that takes a real*8 input parameter tt and returns a real*8 output parameter.", "input": "", "output": "function gf_funcd(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\td0,d1,d2,d3,d4\n\treal*8\t\t\t\t\t::\td5,d6,d7,d8,d9\n\treal*8\t\t\t\t\t::\tgf_funcd\n\t\t\t\n\tdata\td0,d1,d2,d3,d4,d5,d6,d7,d8,d9\t\t\t&\n\t\t/\t+0.632d0,\t-40.97d0,\t+667.16d0,\t\t&\n\t\t\t-6072.07d0,\t+31127.39d0,-96293.05d0,\t&\n\t\t\t+181856.75d0,\t\t\t-205690.43d0,\t&\n\t\t\t+128170.2d0,-33744.6d0\t/\n    \n\tgf_funcd\t=\t(d8+d9*tt)*tt\n\tgf_funcd\t=\t(d7+gf_funcd)*tt\n\tgf_funcd\t=\t(d6+gf_funcd)*tt\n\tgf_funcd\t=\t(d5+gf_funcd)*tt\n\tgf_funcd\t=\t(d4+gf_funcd)*tt\n\tgf_funcd\t=\t(d3+gf_funcd)*tt\n\tgf_funcd\t=\t(d2+gf_funcd)*tt\n\tgf_funcd\t=\t(d1+gf_funcd)*tt\n\tgf_funcd\t=\td0+gf_funcd\n\n\treturn\nend function gf_funcd\n"}, {"instruction": "Create a Fortran function named gf_dfunca that takes a single real*8 input parameter and returns a real*8 output. The function computes a polynomial expression using the input parameter and pre-defined coefficients, and then returns the result.", "input": "", "output": "function gf_dfunca(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\ta0,a1,a2,a3,a4\n\treal*8\t\t\t\t\t::\ta5,a6,a7,a8,a9\n\treal*8\t\t\t\t\t::\tgf_dfunca\n\t\t\t\n\tdata\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9\t\t\t&\n\t\t/\t+2.948d0,\t-24.53d0,\t+249.69d0,\t\t&\n\t\t\t-754.85d0,\t-1187.71d0,\t+16370.75d0,\t&\n\t\t\t-48811.41d0,+68220.87d0,-46688.0d0,\t\t&\n\t\t\t+12622.25d0\t/\n\n\tgf_dfunca\t=\t(a8+a9*tt)*tt\n\tgf_dfunca\t=\t(a7+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a6+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a5+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a4+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a3+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a2+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a1+gf_dfunca)*tt\n\tgf_dfunca\t=\ta0+gf_dfunca\n\n\treturn\nend function gf_dfunca\n"}, {"instruction": "Provide a Fortran function named gf_dfuncb that takes one 64-bit real number as input. The function calculates a value using a series of mathematical operations. The number of input arguments is 1 and the test_data type is ['real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function gf_dfuncb(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tb0,b1,b2,b3,b4\n\treal*8\t\t\t\t\t::\tb5,b6,b7,b8,b9\n\treal*8\t\t\t\t\t::\tgf_dfuncb\n\t\t\t\n\tdata\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9\t\t\t&\n\t\t/\t+1.11d0,\t+2.894d0,\t-76.765d0,\t\t&\n\t\t\t+1565.35d0,\t-11336.19d0,+44270.15d0,\t&\n\t\t\t-97014.11d0,+118879.26d0,-76209.82d0,\t&\n\t\t\t+19923.28d0\t/\n    \n\tgf_dfuncb\t=\t(b8+b9*tt)*tt\n\tgf_dfuncb\t=\t(b7+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b6+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b5+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b4+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b3+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b2+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b1+gf_dfuncb)*tt\n\tgf_dfuncb\t=\tb0+gf_dfuncb\n\n\treturn\nend function gf_dfuncb\n"}, {"instruction": "Create a Fortran function named gf_dfuncc to calculate a specific mathematical function. The function takes 1 input parameter of type real*8. The output is also a real*8 value. Use the imperative tone to define the function and specify the input and output parameters.", "input": "", "output": "function gf_dfuncc(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tc0,c1,c2,c3,c4,c5\n\treal*8\t\t\t\t\t::\tgf_dfuncc\n\t\t\t\n\tdata\tc0,c1,c2,c3,c4,c5\t\t\t\t\t\t&\n\t\t/\t+14.19d0,\t-148.24d0,\t+847.8d0,\t\t&\n\t\t\t-2318.58d0,\t+3168.35d0,\t-1590.27d0\t\t/\n    \n\tgf_dfuncc\t=\t(c4+c5*tt)*tt\n\tgf_dfuncc\t=\t(c3+gf_dfuncc)*tt\n\tgf_dfuncc\t=\t(c2+gf_dfuncc)*tt\n\tgf_dfuncc\t=\t(c1+gf_dfuncc)*tt\n\tgf_dfuncc\t=\tc0+gf_dfuncc\n\n\treturn\nend function gf_dfuncc\n"}, {"instruction": "Create a Fortran function named \"pythag\" that takes two real(8) input parameters and returns a real(8) output. This function calculates the hypotenuse of a right-angled triangle using the input parameters as the lengths of the two shorter sides.", "input": "", "output": "  function pythag ( a, b )\n    implicit none\n    real(8) :: a\n    real(8) :: b\n    real(8) :: p\n    real(8) :: pythag\n    real(8) :: r\n    real(8) :: s\n    real(8) :: t\n    real(8) :: u\n    p = max ( abs ( a ), abs ( b ) )\n    if ( p /= 0.0d+00 ) then\n       r = ( min ( abs ( a ), abs ( b ) ) / p )**2\n       do\n          t = 4.0d+00 + r\n          if ( t == 4.0d+00 ) then\n             exit\n          end if\n          s = r / t\n          u = 1.0d+00 + 2.0d+00 * s\n          p = u * p\n          r = ( s / u )**2 * r\n       end do\n    end if\n    pythag = p\n    return\n  end function pythag\n"}, {"instruction": "Create a Fortran function named fibonacciiterate to calculate the Fibonacci number at a specific position using an iterative approach. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "    function fibonacciiterate(position) result(fibonacci)\r\n        integer, intent(in) :: position\r\n        integer :: fibonacci\r\n\r\n        integer, dimension(10), save :: buffer\r\n        integer, save                :: index  = 3\r\n        buffer(1) = 1\r\n        buffer(2) = 1\r\n\r\n        if (buffer(position) == 0) then\r\n            do index = index, position\r\n                buffer(index) = buffer(index - 1) + buffer(index - 2)\r\n            end do\r\n        end if\r\n\r\n        fibonacci = buffer(position)\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named get_grid_dims to retrieve the grid dimensions from the environment variable 'gocean_omp_grid'. The function takes 2 input arguments of type integer and returns a logical output. The input parameters should be of type ['integer', 'integer'], and the output parameter should be of type ['logical'].", "input": "", "output": "  function get_grid_dims(nx, ny) result(success)\n    implicit none\n    integer, intent(inout) :: nx, ny\n    logical :: success\n    character(len=20) :: lstr\n    integer :: idx, ierr\n\n    success = .false.\n\n    call get_environment_variable(name='gocean_omp_grid', value=lstr, &\n                                  status=ierr)\n\n    if(ierr /= 0)return\n\n    ! we expect the string to have the format 'axb' where a and b are\n    ! integers.\n    idx = index(lstr, 'x')\n    if(idx == 0)then\n       write (*,\"(/'shallow_omp_mod::get_grid_dims: failed to parse ' &\n                 &  'gocean_omp_grid string: ',(a))\") trim(lstr)\n       write (*,\"('   -  will use defaults for dimensions of tiling grid')\")\n       return\n    endif\n\n    read(lstr(1:idx-1),*,iostat=ierr) nx\n    if(ierr /= 0)return\n\n    read(lstr(idx+1:),*,iostat=ierr) ny\n    if(ierr == 0)success = .true.\n\n  end function get_grid_dims\n"}, {"instruction": "Create a Fortran function named is_palindrome to determine whether a given phrase is a palindrome. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type logical. The input parameter represents the phrase to be checked. The output parameter will be true if the phrase is a palindrome, and false otherwise.", "input": "", "output": "    function is_palindrome(phrase) result(palindrome)\n        implicit none\n        character(len=*), intent(in) :: phrase\n        logical :: palindrome\n        integer :: i, n\n\n        n = len_trim(phrase)\n        palindrome = .true.\n        do i = 1, n/2\n            if (phrase(i:i) /= phrase(n-i+1:n-i+1)) then\n                palindrome = .false.\n                exit\n            end if\n        end do\n    end function is_palindrome\n"}, {"instruction": "Create a Fortran function named c_connect with 8 input parameters and 1 output parameter. The input parameters are of the types type(c_ptr), character(c_char) arrays, integer(c_int), and type(c_ptr). The output parameter is of the type type(c_ptr). This function is bound to the C function \"mysql_real_connect\" and is used for connecting to a MySQL database using the provided connection details.", "input": "", "output": "    function c_connect (mysql, host, user, pwd, db, port, socket, flags) &\n    bind(c, name='mysql_real_connect')\n      use iso_c_binding\n      implicit none\n      type(c_ptr) :: c_connect\n      type(c_ptr), value :: mysql\n      character(c_char), dimension(*) :: host, user, pwd, db\n      integer(c_int), value :: port\n      type(c_ptr), value :: socket\n      integer(c_int), value :: flags\n    end function c_connect\n"}, {"instruction": "Create a Fortran function named c_init_mysql, which will initialize a MySQL data structure. The function should take 1 input parameter of type c_ptr with value attribute, and it should return 1 output parameter of type c_ptr. The function should be declared with the bind attribute \"bind(c, name='mysql_init')\" and should specify the calling convention using attributes stdcall for both gcc and dec compilers.", "input": "", "output": "    function c_init_mysql (mysql) &\n    bind(c, name='mysql_init')\n      use iso_c_binding\n      implicit none\n      type(c_ptr) :: c_init_mysql\n      type(c_ptr), value :: mysql\n      !gcc$ attributes stdcall:: c_init_mysql\n      !dec$ attributes stdcall:: mysql_init\n    end function c_init_mysql\n"}, {"instruction": "Create a Fortran function named c_fetch_row, which binds to the C function mysql_fetch_row. The function takes 1 input parameter of type c_ptr with the attribute value. It returns 1 output parameter of type c_ptr.", "input": "", "output": "    function c_fetch_row (res) &\n    bind(c, name='mysql_fetch_row')\n      use iso_c_binding\n      implicit none\n      type(c_ptr), value :: res\n      type(c_ptr) :: c_fetch_row\n    end function c_fetch_row\n"}, {"instruction": "Create a Fortran function named adjustc that centers a text string within a specified length. The function takes 2 input parameters: a character string and an optional integer specifying the length of the centered text. The output is a dynamically allocated character string of the specified length.", "input": "", "output": "pure function adjustc(string,length)\n\n!character(len=*),parameter::ident_32=\"@(#)m_strings::adjustc(3f): center text\"\n\n!>\n!! procedure   adjustc(3f)\n!! description center text using implicit or explicit length\n!!##version     2.0, 20160711\n!! author      john s. urban\n!===================================================================================================================================\n!-----------------------------------------------------------------------------------------------------------------------------------\ncharacter(len=*),intent(in)  :: string         ! input string to trim and center\ninteger,intent(in),optional  :: length         ! line length to center text in\ncharacter(len=:),allocatable :: adjustc        ! output string\ninteger                      :: inlen\ninteger                      :: ileft          ! left edge of string if it is centered\n!-----------------------------------------------------------------------------------------------------------------------------------\n   if(present(length))then                     ! optional length\n      inlen=length                             ! length will be requested length\n      if(inlen.le.0)then                       ! bad input length\n         inlen=len(string)                     ! could not use input value, fall back to length of input string\n      endif\n   else                                        ! output length was not explicitly specified, use input string length\n      inlen=len(string)\n   endif\n   allocate(character(len=inlen):: adjustc)    ! create output at requested length\n   adjustc(1:inlen)=' '                        ! initialize output string to all blanks\n!-----------------------------------------------------------------------------------------------------------------------------------\n   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it\n   if(ileft.gt.0)then                          ! if string will fit centered in output\n      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string\n   else                                        ! input string will not fit centered in output string\n      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can\n   endif\nend function adjustc\n"}, {"instruction": "Create a Fortran function named expint_1 that calculates the exponential integral function. It takes 2 input parameters of type integer and real(8), and returns 1 output parameter of type real(8). Ensure the input integer parameter is non-negative and the real parameter is non-negative if the integer parameter is greater than 1. The function implements the exponential integral function using a combination of continued fraction and series methods.", "input": "", "output": "  function expint_1(n,x) result(expint)\n    implicit none\n    integer,intent(in) :: n\n    real(8),intent(in) :: x\n    real(8) :: expint\n    integer,parameter :: maxit=200\n    real(8),parameter :: esp=1.d-12, big=huge(x)*esp\n    real(8),parameter :: euler=0.577215664901532860606512d0\n    integer :: i,nm1,j\n    real(8) :: a,b,c,d,del,fact,h,arsum\n \n    if ( .not.(n>=0.and.x>=0.d0.and.(x>0.d0.or.n>1)) ) then\n       write(*,*) 'bad arguments in expint.f'\n       stop\n    end if\n \n    if ( n==0 ) then\n       expint=exp(-x)/x\n       return\n    end if\n    nm1=n-1\n    if ( x==0.d0 ) then\n       expint=1.d0/nm1\n    else if ( x>1.d0 ) then\n       b=x+n\n       c=big\n       d=1.d0/b\n       h=d\n       do i=1,maxit\n          a=-i*(nm1+i)\n          b=b+2.d0\n          d=1.d0/(a*d+b)\n          c=b+a/c\n          del=c*d\n          h=h*del\n          if ( abs(del-1.d0)<=esp ) exit\n       end do\n       if ( i>maxit ) then\n          write(*,*) 'continued fraction failed in expint.f'\n          stop\n       end if\n       expint=h*exp(-x)\n    else\n       if ( nm1/=0 ) then\n          expint=1.d0/nm1\n       else\n          expint=-log(x)-euler\n       end if\n       fact=1.d0\n       do i=1,maxit\n          fact=-fact*x/i\n          if ( i/=nm1 ) then\n             del=-fact/(i-nm1)\n          else\n             arsum = 0.d0\n             do j=1,nm1\n                arsum = arsum + 1.d0/j\n             end do\n             del = fact*(-log(x)-euler+arsum)\n          end if\n          expint=expint+del\n          if ( abs(del)<abs(expint)*esp ) exit\n       end do\n       if ( i>maxit ) then\n          write(*,*) 'series failed in expint.f'\n          stop\n       end if\n    end if\n\n  end function expint_1\n"}, {"instruction": "Create a Fortran function named det to compute the determinant or permanent of a square matrix. The function takes 3 input parameters: a real matrix of dimension n x n, an integer n, and an integer permanent. The output is a real value. The input parameter \"permanent\" determines whether the function computes the determinant (set to -1) or the permanent (set to 1).", "input": "", "output": "  recursive function det(a,n,permanent) result(accumulation)\n    ! setting permanent to 1 computes the permanent.\n    ! setting permanent to -1 computes the determinant.\n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n"}, {"instruction": "Write a Fortran function named grayencode that takes an integer as input and returns the Gray code equivalent. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  function grayencode(i)\n    implicit none\n    ! passed variables\n    integer, intent(in) :: i\n    ! return value\n    integer :: grayencode\n    grayencode = ieor(i, ishft(i,-1))\n  end function grayencode\n"}, {"instruction": "Write a Fortran function named graydecode that takes an integer as input and returns another integer as output. The function should decode a Gray code to its binary equivalent. The input parameter should be of type integer and intent(in), while the output parameter should also be of type integer.", "input": "", "output": "  function graydecode(gn)\n    implicit none\n    ! passed variables\n    integer, intent(in) :: gn\n    ! return value\n    integer :: graydecode\n    ! local variables\n    integer :: bn, ii\n    bn = gn\n    ii = 1\n    do while (ishft(gn, -ii) > 0)\n       bn = ieor(bn, ishft(gn, -ii))\n       ii = ii + 1\n    end do\n    graydecode = bn\n  end function graydecode\n"}, {"instruction": "Create a Fortran function named \"minlen\" to calculate the minimum length of a number when expressed in a given base. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters are \"n\" and \"base,\" and the output parameter is \"minlen.\"", "input": "", "output": "  function minlen(n, base)\n    implicit none\n    ! passed parameters\n    integer, intent(in) :: n, base\n    ! returned value\n    integer :: minlen\n    ! local variable\n    integer :: num\n    num = n\n    minlen = 1\n    do while (num >= base)\n       num = num / base\n       minlen = minlen + 1\n    end do\n  end function minlen\n"}, {"instruction": "Create a Fortran function named evaluatefirst to process the input string and integer, and return a real number. The function accepts 2 input parameters with test_data types ['character(len =*)', 'integer,optional'], and returns 1 output parameter with test_data type ['real'].", "input": "", "output": "        function evaluatefirst(s,n)result(number)\n          implicit none\n          character(len =*), intent(inout) :: s\n          integer,optional                 :: n\n          real                             :: number\n          number = 1.1\n        end function\n"}, {"instruction": "Write a Fortran function named sum_string to calculate the sum of ASCII values of all characters in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "  elemental function sum_string(str) result(sig)\n    character(len=*), intent(in)   :: str\n    integer                        :: sig\n    character, dimension(len(str)) :: tmp\n    integer :: i\n\n    forall (i=1:len(str))\n       tmp(i) = str(i:i)\n    end forall\n    sig = sum(ichar(tmp))\n  end function sum_string\n"}, {"instruction": "Create a Fortran function called distance that calculates the distance between two points in a 2D plane. The function takes 4 input arguments of type real (ax, ay, bx, by) and returns 1 output argument of type real.", "input": "", "output": "function distance(ax, ay, bx, by)\n    implicit none\n    real :: ax\n    real :: ay\n    real :: bx\n    real :: by\n    real :: distance\n    distance = ((bx - ax) ** 2 + (by - ay) ** 2) ** 0.5\n    return\nend function\n"}, {"instruction": "Create a Fortran function named get_lower_case to convert a given character string to lowercase. The function takes 2 input parameters: an integer representing the character string length and a character string to convert. The output is a character string of the same length as the input.", "input": "", "output": "  function get_lower_case(length,inputstr) result (lowcasestring)\r\n    \r\n    !argument declarations\r\n    integer, intent(in) :: length  !<character string length\r\n    character(len=length), intent(in) :: inputstr  !<character string to convert\r\n    character(len=length) :: lowcasestring  !<lower case string\r\n    \r\n    !local variables\r\n    integer i\r\n\r\n    lowcasestring = inputstr\r\n    do i=1,length\r\n      if(ichar(lowcasestring(i:i)).ge.65 .and. ichar(lowcasestring(i:i)).le.90)then\r\n        lowcasestring(i:i)=char(ichar(lowcasestring(i:i))+32)\r\n      endif\r\n    enddo\r\n    \r\n  end function get_lower_case\r\n"}, {"instruction": "Create a Fortran function named trim to remove trailing spaces from a character string. The function should have 1 input parameter of type character(len=*), and 1 output parameter of type character(len=len_trim(x)).", "input": "", "output": "function trim(x) result(r)\ncharacter(len=*),intent(in) :: x\ncharacter(len=len_trim(x)) :: r\n! this does not work yet in lfortran:\n!r = x(1:len(r))\n! so we do this workaroud that works:\ninteger :: i\ndo i = 1, len(r)\n    r(i:i) = x(i:i)\nend do\nend function\n"}, {"instruction": "Create a Fortran function named unique to return only the unique values from the input integer array. The function should have 1 input parameter of type integer array and intent(in), and 1 output parameter of type integer array with allocatable dimension.", "input": "", "output": "function unique(vec) result(vec_unique)\n! return only the unique values from vec.\n\nimplicit none\n\ninteger,dimension(:),intent(in) :: vec\ninteger,dimension(:),allocatable :: vec_unique\n\ninteger :: i,num\nlogical,dimension(size(vec)) :: mask\n\nmask = .false.\n\ndo i=1,size(vec)\n\n    !count the number of occurrences of this element:\n    num = count( vec(i)==vec )\n\n    if (num==1) then\n        !there is only one, flag it:\n        mask(i) = .true.\n    else\n        !flag this value only if it hasn't already been flagged:\n        if (.not. any(vec(i)==vec .and. mask) ) mask(i) = .true.\n    end if\n\nend do\n\n!return only flagged elements:\nallocate( vec_unique(count(mask)) )\nvec_unique = pack( vec, mask )\n\n!if you also need it sorted, then do so.\n! for example, with slatec routine:\n!call isort (vec_unique, [0], size(vec_unique), 1)\n\nend function unique\n"}, {"instruction": "Create a Fortran function named f to determine the value of a real number based on the input integer value. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input test_data type is ['integer'], and the output test_data type is ['real'].", "input": "", "output": "function f(n)\n  integer, intent(in) :: n\n  real                :: f\n\n  select case (n)\n    case (:-1); f = -1.0\n    case (0);   f =  0.0\n    case (1:);  f =  1.0\n  end select\nend function\n"}, {"instruction": "Create a Fortran function named pder to estimate pressure derivatives. It takes 2 input parameters of type real, dimension(:,:,:), and real. It returns 1 output parameter of type real, dimension(:,:,:), allocatable. The function uses one-sided derivatives at the top and bottom levels with second and fourth-order accuracy.", "input": "", "output": "  function pder(f,dp) result (dfdp)\n    !   estimation of pressure derivatives.\n    !   one-sided derivatives are used at top and bottom levels\n    !   accuracy=1 means second-order accuracy\n    !   accuracy=2 fourth-order accuracy\n    implicit none\n\n    real,dimension(:,:,:),intent(in) :: f\n    real,                 intent(in) :: dp\n    real,dimension(:,:,:),allocatable :: dfdp\n    real :: inv_dp\n    integer :: nlon,nlat,nlev,accuracy,k\n\n    nlon=size(f,1); nlat=size(f,2); nlev=size(f,3)\n    allocate(dfdp(nlon,nlat,nlev))\n    inv_dp = 1.0 / (2.*dp)\n    accuracy=1\n    select case (accuracy)\n\n    case(1)\n       dfdp(:,:,2:nlev-1)=f(:,:,3:nlev)-f(:,:,1:nlev-2)\n       dfdp(:,:,2:nlev-1)=dfdp(:,:,2:nlev-1)*inv_dp\n\n       dfdp(:,:,1)=(f(:,:,2)-f(:,:,1))/dp\n       dfdp(:,:,nlev)=(f(:,:,nlev)-f(:,:,nlev-1))/dp\n    case(2)\n       do k=3,nlev-2\n          dfdp(:,:,k)=f(:,:,k-2)-8.*f(:,:,k-1)+8.*f(:,:,k+1) &\n               -f(:,:,k+2)\n          dfdp(:,:,k)=dfdp(:,:,k)/(12.*dp)\n       enddo\n       dfdp(:,:,2)=(dfdp(:,:,3)-dfdp(:,:,1))/(2.*dp)\n       dfdp(:,:,nlev-1)=(dfdp(:,:,nlev)-dfdp(:,:,nlev-2))/(2.*dp)\n       dfdp(:,:,1)=(f(:,:,2)-f(:,:,1))/dp\n       dfdp(:,:,nlev)=(f(:,:,nlev)-f(:,:,nlev-1))/dp\n\n    end select\n\n  end function pder\n"}, {"instruction": "Create a Fortran function named factorial to compute the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Ensure the function checks for errors when the input is less than 0 or greater than 12.", "input": "", "output": "  recursive function factorial(i) result(fac)\n    implicit none\n    integer::fac\n    integer,intent(in)::i\n    integer::init=0,j\n    logical,dimension(12)::lfacsave\n    integer,dimension(12)::facsave\n    save facsave,init,lfacsave\n    if(init.eq.0)then\n       lfacsave(1:12)=.false.\n       init=1\n    endif\n    if(i.lt.0)then\n       write(*,*)\"error: i<0 in factorial with i=\",i\n       stop\n    endif\n    if(i.gt.12)then\n       write(*,*)\"error: i > 12, please take long type (kind=lint) integer\"\n       stop\n    endif\n    if(i.eq.0)then\n       fac=1\n    else\n       if(lfacsave(i))then\n          fac=facsave(i)\n       else\n          fac=i*factorial(i-1)\n          facsave(i)=fac\n          lfacsave(i)=.true.\n       endif\n    endif\n  end function factorial\n"}, {"instruction": "Create a Fortran function named number_coefs_for_rank to calculate the total number of coefficients for a given rank. The function takes 1 input argument of type integer. The output is also of type integer.", "input": "", "output": "  function number_coefs_for_rank(rank) result(res)\n    implicit none\n    integer,intent(in)::rank\n    integer::res,i\n    if(rank.lt.0)res=0\n    res=0\n    do i=0,rank\n       res=res+((3+i)*(2+i)*(1+i))/6\n    enddo\n    return\n  end function number_coefs_for_rank\n"}, {"instruction": "Create a Fortran function named mirror_about_plane that takes a 3D vector and an integer representing a plane index as input. The function returns a 3D vector that is the mirror image of the input vector about the specified plane. The number of input arguments is 2 and the test_data type is ['real,dimension(3)', 'integer']. The number of output arguments is 1 and the test_data type is ['real,dimension(3)'].", "input": "", "output": "    function mirror_about_plane(vec, plane) result(mirrored_vec)\n        ! returns a version of the given vector mirrored about the given plane\n        ! the plane number is the component index which is normal to the plane (i.e. 1: yz plane, etc.)\n\n        implicit none\n\n        real,dimension(3),intent(in) :: vec\n        integer,intent(in) :: plane\n        real,dimension(3) :: mirrored_vec\n\n        mirrored_vec = vec\n        mirrored_vec(plane) = -vec(plane)\n        \n    end function mirror_about_plane\n"}, {"instruction": "Create a Fortran function named smt_get that takes an array of characters as input and returns a character array of the same size. The input parameter should be of type character and have a dimension of (:), while the output parameter should be of type character with a size equal to the input array. Use a do loop to populate the output array with the elements of the input array, and return the result.", "input": "", "output": "     function smt_get( array )\n\n!  dummy arguments\n\n     character, dimension( : ) :: array\n     character( size( array ) ) :: smt_get\n\n!  local variables\n\n     integer :: i\n\n     do i = 1, size( array )\n        smt_get( i : i ) = array( i )\n     end do\n\n     return\n\n\n     end function smt_get\n"}, {"instruction": "Create a Fortran function named compute_pi to calculate an approximate value of pi using the Leibniz formula. The function takes 1 input parameter of type integer. The output is a real*8 value.", "input": "", "output": "function compute_pi(segments)\n  implicit none\n\n  integer, intent(in) :: segments\n  real*8 :: compute_pi\n\n  real*8 :: polygon_edge_length_squared\n  integer :: polygon_sides\n  integer :: i\n\n  polygon_edge_length_squared = 2.0\n  polygon_sides = 2\n  do i = 1, segments\n    polygon_edge_length_squared = -sqrt(1 - polygon_edge_length_squared / 4) * 2 + 2\n    polygon_sides = polygon_sides * 2\n  end do\n  compute_pi = sqrt(polygon_edge_length_squared) * polygon_sides\n  return\nend function\n"}, {"instruction": "Create a Fortran function named fl5_qe1 to calculate the result of a mathematical function. The function takes 1 input argument of type double precision and returns 1 output argument of type double precision. The function computes the result using the formula y = x ** 3 + dexp(-x).", "input": "", "output": "    function fl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** 3 + dexp(-x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named dfl5_qe1 to calculate the value of a quadratic equation, Y = 3 * X^2 - dexp(-X). The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "    function dfl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 3 * x ** 2 - dexp(-x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function called \"fl5_qe2\" that takes a double precision input parameter and returns a double precision output parameter. The function computes the result by raising the input to the power of 1/3 and adding the natural logarithm of the input.", "input": "", "output": "    function fl5_qe2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** (1.0d0/3.0d0) + dlog(x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function called dfl5_qe2 to compute the value of a mathematical expression. The function takes 1 input parameter of type double precision. The output is also a double precision value. The function computes the expression 1 / (3 * x ** (2.0d0/3.0d0)) + (1 / x) and returns the result.", "input": "", "output": "    function dfl5_qe2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 1 / (3 * x ** (2.0d0/3.0d0)) + (1 / x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named fl5_qe3 that takes a double precision input argument and returns a double precision output. The function computes the value of y using the formula y = 1 - dexp(-(x ** 2) / 25).", "input": "", "output": "    function fl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 1 - dexp(-(x ** 2) / 25)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named dfl5_qe3 that takes a double precision input parameter and returns a double precision result. The function computes the value of y using the formula y = (2 * x) / (25 * dexp((x ** 2) / 25)).", "input": "", "output": "    function dfl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = (2 * x) / (25 * dexp((x ** 2) / 25))\r\n        return\r\n    end function\r\n"}, {"instruction": "Write a Fortran function named f2 that takes a double precision input argument and returns a double precision output. The function computes the value of 4 times the cosine of the input minus the exponential function raised to the power of 2 times the input. The number of input arguments is 1 and the test_data type is ['double precision'], and the number of output arguments is 1 with the test_data type ['double precision']. Use the \"return\" statement to return the result.", "input": "", "output": "    function f2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 4 * dcos(x) - dexp(2 * x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Write a Fortran elemental function named last_character_c to return the last character of the input string. The number of input arguments is 1 of type character(len=*), and the number of output arguments is 1 of type character(len=1).", "input": "", "output": "    elemental function last_character_c(string) result(char_)\n        character(len=*), intent(in) :: string\n        character(len=1) :: char_\n\n        integer :: length\n\n        length = len(string)\n        char_ = string(length:length)\n    end function\n"}, {"instruction": "Create a Fortran function named \"ring\" that calculates the sum of a sequence of numbers in a ring pattern. The function should take 2 input parameters of type integer and return 1 output parameter of type integer. The input parameters should be named \"start\" and \"k,\" and the output parameter should be named \"ring.\"", "input": "", "output": "  pure function ring(start,k)\n    implicit none\n    integer, intent(in) :: start,k\n    integer             :: i,j\n    integer             :: ring\n\n    j=0\n    ring=0\n    do i=start+k+k+(k-2)+(k-2)-1,start,-1\n       if (mod(j,k-1) == 0) then\n          ring=ring+i\n       end if\n       j=j+1\n    end do\n  end function ring\n"}, {"instruction": "Create a Fortran function named to_string that takes two integer input parameters and returns a character string of specified length. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [character(len=length)].", "input": "", "output": "    function to_string(int, length) result(str)\n        integer, intent(in) :: int\n        integer, intent(in) :: length\n        character(len=length) :: str\n        character(len=13) :: fmt\n        write(fmt, \"(a,i10,a)\") \"(i\", length, \")\"\n        write(str, fmt) int\n        return\n    end function to_string\n"}, {"instruction": "Create a Fortran function named get_unit that assigns an unused I/O unit number to the variable get_unit. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used for dummy purposes and the output argument stores the assigned I/O unit number.", "input": "", "output": "function get_unit(dummy)\n  integer :: get_unit,dummy\n\n  integer :: u\n  logical :: used\n\n  do u=7,99\n    inquire(unit=u,opened=used)\n    if(.not.used)then\n      exit\n    endif\n  enddo\n\n  get_unit=u\n\nend function get_unit\n"}, {"instruction": "Create a Fortran function named djscaled to calculate the scaled value of a given real*8 input parameter. The number of input arguments is 1 with a test_data type of ['real*8'], and the number of output arguments is 1 with a test_data type of ['real*8'].", "input": "", "output": "function djscaled(xval)\n  implicit none\n  real*8 :: djscaled,xval,pixval\n  real*8, parameter :: pi = 3.14159265358979323844d0 !!temp\n\n  if (xval.lt.0d0.or.xval.gt.1d0) then\n     print *, \"scalederr f\",xval; stop\n  endif\n  pixval=pi*xval\n  djscaled = 0.75d0 * pi * sin(pixval)**3 \n\nend function djscaled\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor of two integers.The number of input arguments is 2 and the test_data type is [integer, integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n"}, {"instruction": "Create a Fortran function named tridiag_solve that solves a tridiagonal linear system of equations. The function should have 5 input parameters of types integer, real array of dimension n, real, real, and real, and 1 output parameter of type real array of dimension n. The function should calculate the solution for the tridiagonal system and store the result in the output array.", "input": "", "output": "function tridiag_solve(l, d, r, b, n)\n    implicit none\n    integer, intent(in) :: n\n    ! input array\n    real,  dimension(n), intent(in) :: b\n    real, intent(in) :: l, d, r\n    ! return value will be stored in this array\n    real, dimension(n) :: tridiag_solve\n\n    real,  dimension(n) :: bhat, rhat\n    integer :: i\n\n    rhat(1) = r / d\n    bhat(1) = b(1) / d\n    do i=2,n\n        rhat(i) = r / (d - l * rhat(i - 1))\n        bhat(i) = (b(i) - l * bhat(i-1)) / (d - l * rhat(i-1))\n    enddo\n\n    ! compute the solution, starting from n, then n-1, n-2, ...\n    tridiag_solve(n) = bhat(n)\n    do i=1,n-1\n        tridiag_solve(n - i) = bhat(n - i) - rhat(n - i) * tridiag_solve(n - i + 1)\n    end do\n\nend function\n"}, {"instruction": "Create a Fortran function named int2str to convert an integer to a string. The function takes 3 input parameters: n (integer), nc (integer), myform (character string). It returns a single output parameter int2str (character string) of length nc. Use the imperative tone when providing the instruction for this function.", "input": "", "output": "  function int2str(n,nc,myform)\r\n    implicit none\r\n    integer :: n,nc\r\n    character(len=nc)::int2str\r\n    character(len=*)::myform\r\n    write(int2str,myform)n\r\n  end function int2str\r\n"}, {"instruction": "Create a Fortran function named func0 that takes an integer input argument and returns a double precision result. The function computes the value of 2 times the input integer plus 2, and assigns the result to the function name. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function func0(i)\n    implicit none\n    double precision :: func0\n    integer, intent(in) :: i\n    func0 = dble(2*(i+1))\n  end function func0\n"}, {"instruction": "Create a Fortran function named inc_cptr that accepts a pointer of type c_ptr and an offset in bytes as input arguments. The number of input arguments is 2 and the test_data type is ['type(c_ptr),value', 'integer(c_size_t),value']. The function returns a new pointer of type c_ptr as the output. The number of output arguments is 1 and the test_data type is ['type(c_ptr)'].", "input": "", "output": "    function inc_cptr(ptr,offset_bytes) bind(c,name=\"inc_cptr\")\n      use iso_c_binding\n      implicit none\n      type(c_ptr),intent(in),value :: ptr\n      integer(c_size_t),value      :: offset_bytes\n      !\n      type(c_ptr) :: inc_cptr\n    end function\n"}, {"instruction": "Create a Fortran function called myiter to calculate the iteration for the Poisson solver. The function takes two input parameters: a real, two-dimensional array p and a real value h. It returns a two-dimensional real array of the same size as p.", "input": "", "output": "    function myiter(p,h)\n    ! calculate the iteration for the poisson solver. note that this is exactly\n    ! the same as the laplacian, but without the final -4*u term, and\n    ! non-periodic boundaries on the left and right (it uses neumann bcs\n    ! instead)\n\n        real, dimension(:,:), intent(in) :: p\n        real, intent(in) :: h\n        real, dimension(size(p,1),size(p,2)) :: myiter\n        integer :: nnx\n\n        nnx = size(p,1)\n\n        myiter = (cshift(p,shift=+1, dim=2) &\n             +cshift(p,shift=-1,dim=2) &\n             +cshift(p,shift=+1,dim=1) &\n             +cshift(p,shift=-1,dim=1))\n        myiter(1,:) = myiter(1,:)-p(nnx,:)\n        myiter(nnx,:) = myiter(nnx,:)-p(1,:)\n    end function\n"}, {"instruction": "Create a Fortran function named norm2_c that calculates the 2-norm of a complex vector. The function takes one input parameter of type complex(8) and dimension(:), and returns one output parameter of type real(8).", "input": "", "output": "function norm2_c(val)\n  character(len=*),parameter :: this_sub_name = 'norm2'\n\n  complex(8),dimension(:),intent(in) :: val\n\n  real(8) :: norm_real\n  real(8) :: norm_complex\n\n  real(8) :: norm2_c\n\n  norm_real = norm2(real(val))\n  norm_complex = norm2(aimag(val))\n\n  norm2_c = (norm_real**2 + norm_complex**2)**(0.5)\nend function norm2_c\n"}, {"instruction": "Write a Fortran function named dot_product_c that computes the dot product of two complex arrays. The function takes 2 input parameters of type complex(8) arrays and returns 1 output parameter of type complex(8).", "input": "", "output": "function dot_product_c(val1,val2)\n  character(len=*),parameter :: this_sub_name = 'dot_product_c'\n\n  complex(8),dimension(:),intent(in) :: val1\n  complex(8),dimension(:),intent(in) :: val2\n\n  complex(8) :: dot_product_c\n\n  integer :: n_elem_1\n  integer :: n_elem_2\n  integer :: ielem\n\n  n_elem_1 = size(val1)\n  n_elem_2 = size(val2)\n\n  dot_product_c = 0\n\n  do ielem = 1,n_elem_1\n    dot_product_c = dot_product_c + val1(ielem)*val2(ielem)\n  enddo\nend function dot_product_c\n"}, {"instruction": "Create a Fortran function named multiply_two_numbers to calculate the product of two real numbers. Define 2 input parameters of type real and labeled as intent(in). The output parameter should also be of type real. The number of input parameters is 2 with test_data type ['real', 'real'], and the number of output parameters is 1 with test_data type ['real'].", "input": "", "output": "  function multiply_two_numbers(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a * b\n    return\n  end function multiply_two_numbers\n"}, {"instruction": "Create a Fortran function named dist that computes the Cartesian distance between two 3-dimensional points. The function has 2 input parameters of type real, dimension(3) and the test_data type is ['real,dimension(3)', 'real,dimension(3)']. It also has 1 output parameter of type real and the test_data type is ['real'].", "input": "", "output": "function dist(a, b) result(c)\r\n  ! calculates the cartesian distance between 2 points\r\n\r\n    implicit none\r\n\r\n    real,dimension(3),intent(in) :: a, b\r\n    real :: c\r\n\r\n    c = sqrt(sum((a-b)**2))\r\n\r\nend function dist\r\n"}, {"instruction": "Create a Fortran function named inner that computes the 3D Euclidean inner product of two input vectors. The input parameters consist of two 3-dimensional real arrays. The output parameter is a single real value.", "input": "", "output": "function inner(a, b) result(c)\r\n  ! calculates the 3d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(3) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)+a(3)*b(3)\r\n\r\nend function inner\r\n"}, {"instruction": "Create a Fortran function named inner2 to compute the 2D Euclidean inner product. The function takes 2 input parameters of type real, dimension(2) and returns 1 output parameter of type real. The name of the function is inner2.", "input": "", "output": "function inner2(a, b) result(c)\r\n  ! calculates the 2d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(2) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)\r\n\r\nend function inner2\r\n"}, {"instruction": "Create a Fortran function called outer to compute the outer product of two 3-dimensional real arrays. This function takes 2 input parameters of type real, dimension(3) and the test_data type is [real,dimension(3)', 'real,dimension(3)']. It returns 1 output parameter of type real, dimension(3,3) and the test_data type is ['real,dimension(3,3)'].", "input": "", "output": "function outer(a, b) result(c)\r\n  ! calculates the outer product of two vectors\r\n\r\n  implicit none\r\n\r\n  real,dimension(3) :: a, b\r\n  real,dimension(3,3) :: c\r\n\r\n  integer :: i\r\n\r\n  c = 0.\r\n\r\n  do i=1,3\r\n    c(i,:) = a(i)*b(:)\r\n  end do\r\n\r\nend function\r\n"}, {"instruction": "Create a Fortran function named det3 to calculate the determinant of a 3x3 matrix. The function takes 1 input parameter of type real, dimension(3,3), and returns 1 output parameter of type real.", "input": "", "output": "function det3(a) result(c)\r\n  ! calculates the determinant of a 3x3 matrix\r\n\r\n  implicit none\r\n\r\n  real,dimension(3,3) :: a\r\n  real :: c\r\n\r\n  c = a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))\r\n  c = c - a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\r\n  c = c + a(1,3)*(a(2,1)*a(3,2)-a(3,1)*a(2,2))\r\n\r\nend function det3\r\n"}, {"instruction": "Write a Fortran function named dot to compute the dot product of two 3-dimensional real arrays. The function should have 2 input parameters of type real (kind=8), dimension(3) and 1 output parameter of type real (kind=8). The function must return the dot product of the two input arrays.", "input": "", "output": "    function dot(v1, v2)\n      real (kind=8), intent(in), dimension(3) :: v1, v2\n      integer(kind=4) :: i, length\n      real (kind=8) :: cp, dot\n    \t\n      length = size(v1)\n      cp = 0.0;\n    \t\n      do i=1,length\n        cp = cp + v1(i)*v2(i)\n      enddo\n    \t\n      dot = cp\n      return\n    end function dot\n"}, {"instruction": "Create a Fortran function named cross that calculates the cross product of two 3-dimensional vectors. The function takes 2 input parameters of type real (kind=8), dimension(3) and returns 1 output parameter of type real (kind=8), dimension(3).", "input": "", "output": "    function cross(v1, v2)\n      real (kind=8), intent(in), dimension(3) :: v1, v2\n      real (kind=8), dimension(3) :: cross\n\t\t\n      cross(1) = v1(2)*v2(3)-v1(3)*v2(2)\n      cross(2) = v1(3)*v2(1)-v1(1)*v2(3)\n      cross(3) = v1(1)*v2(2)-v1(2)*v2(1)\n    \t\n      return\n    end function cross\n"}, {"instruction": "Write a Fortran function named scalevec to scale a vector by a scalar value. The function takes 2 input parameters: an array of real numbers with kind=8 and dimension(:), and a single real number with kind=8. The output is an allocatable array of real numbers with kind=8 and dimension(:).", "input": "", "output": "    function scalevec(sc, v1)\n      real (kind=8), intent(in), dimension(:) :: v1\n      real (kind=8), intent(in) :: sc\n      integer(kind=4) :: i, length\n      real (kind=8), allocatable, dimension(:) :: scalevec\n      length = size(v1)\n     \n      allocate(scalevec(length))\n      scalevec(1:length) = sc*v1(1:length)\n        \n      return\n    end function scalevec\n"}, {"instruction": "Create a Fortran function named file_name that extracts the file name from a given path. The function takes 2 input parameters of type character(*) and character(1), the second one being optional. The output is 1 parameter of type character(:), allocatable.", "input": "", "output": "pure function file_name(instr, filesep)\n\ncharacter(*), intent(in) :: instr\ncharacter(1), intent(in), optional :: filesep\ncharacter(:), allocatable :: file_name\n\ncharacter(1) :: sep\ninteger :: i\n\nsep = '/'\nif(present(filesep)) sep = filesep\n\ni = scan(instr, sep, back=.true.)\nfile_name = instr(i+1:len(instr))\n\nend function file_name\n"}, {"instruction": "Write a Fortran function named rerf to compute the relative error function (rerf) for a given real number. The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function rerf(y)\n!\nimplicit none\n!\n\n!\nreal :: y\nreal :: rerf\n!\n! local variables\n!\nreal :: a,a1,a2,alogy,b,b1,b2,base,c,c1,c2,d,d1,e,er1,er2,f,g,h,i,j,sqy,y2,y3,  &\n      & y4,y5,z\nreal :: alog\n!\n!**********************************************************************\n!     + + +  purpose + + +\n\n\n!     written by l. hagen and coded by i. elmanyawi\n \n!     + + +  argument declarations + + +\n \n!     + + + local variables + + +\n!     + + + end specifications + + +\n!\na = 0.000009477\nb = -2.76913995\nc = 0.88589485\nd = 2.30199509\ne = -2.44996884\nf = -0.14332263\ng = 2.246990417\nh = -0.54046067\ni = -0.68292239\nj = 0.15092933\nz = y\ny = abs(y)\n!\na1 = 2857.5463\nb1 = -0.00016423\nc1 = -5717.0696\nd1 = -2857.5783\na2 = 69161.649\nb2 = -277330.28\nc2 = 208168.95\n!\nsqy = sqrt(y)\nalogy = alog(y)\ny2 = y*y\ny3 = y2*y\ny4 = y3*y\ny5 = y4*y\n!\nbase = (a+c*y+e*y2+g*y3+i*y4)/(1.000000+b*y+d*y2+f*y3+h*y4+j*y5)\n!\nif (y.le.0.966105) then\n  rerf = base\nelse if (y.gt.0.999311) then\n!\n  er2 = a2 + b2*y*sqy + c2*y2\n  rerf = base - er2\nelse\n!\n  er1 = a1 + b1/alogy + c1*alogy/y + d1/y2\n  rerf = base - er1\nend if\nrerf = rerf*z/y\nend function rerf\n"}, {"instruction": "Create a Fortran function named predicate that takes an integer input argument and returns a logical value. The input argument should be of type integer, and the output should be of type logical. The function computes whether the square root of the input number is a whole number and returns true if it is, and false if it is not. Use the imperative tone to instruct the creation of a Fortran function with the mentioned specifications.", "input": "", "output": "  pure function predicate(n)\n    implicit none\n    integer, intent(in) :: n\n    logical             :: predicate\n\n    predicate=mod(sqrt(dble(n)),1.0)/=0.0\n\n  end function predicate\n"}, {"instruction": "Create a Fortran function named quote that takes in a string and an optional quote character. The input parameters are of type 'character(len=*)' and 'character(len=*), optional'. The function returns a single output parameter of type 'character(len=:), allocatable'. The function concatenates the input string with the specified quote character and returns the result.", "input": "", "output": "        function quote(s, q) result (r)\n            character(len=*), intent(in) :: s\n            character(len=*), optional, intent(in) :: q\n            character(len=:), allocatable :: t_q\n            character(len=:), allocatable :: r\n\n            if (.not. present(q)) then\n                t_q = '\"'\n            else\n                t_q = q\n            end if\n\n            r = t_q//s//t_q\n        end function\n"}, {"instruction": "Write a Fortran function named dlog2 to calculate the base-2 logarithm of a double precision number. The function should have 1 input parameter of type double precision and 1 output parameter of type double precision. The input parameter should be declared with the intent(in) attribute.", "input": "", "output": "        function dlog2(x) result (y)\n            implicit none\n            double precision, intent(in) :: x\n            double precision :: y\n\n            y = dlog(x) / dlog(2.0d0)\n            return\n        end function\n"}, {"instruction": "Create a Fortran function named drand to generate a random double precision number within the specified range. The function takes 2 input arguments of type double precision and returns 1 output argument of type double precision. The input arguments are the lower and upper bounds of the range.", "input": "", "output": "        function drand(a, b) result (y)\n            implicit none\n            double precision :: a, b, x, y\n            ! x in [0, 1)            \n            call random_number(x)\n            y = (x * (b - a)) + a\n            return\n        end function\n"}, {"instruction": "Create a Fortran function called \"str\" to convert an integer to a string. The function should have 1 input parameter of type integer and 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function str(k) result (t)\n!       \"convert an integer to string.\"\n            integer, intent(in) :: k\n            character(len=128) :: s\n            character(len=:), allocatable :: t\n            write(s, *) k\n            t = trim(adjustl(s))\n            return\n            return\n        end function\n"}, {"instruction": "Write a Fortran function named dstr that converts a double precision number to a string representation. The function takes 1 input parameter of type double precision and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function dstr(x) result (q)\n            integer :: j, k\n            double precision, intent(in) :: x\n            character(len=64) :: s\n            character(len=:), allocatable :: p, q\n            \n            if (isnan(x)) then\n                q = '?'\n                return\n            else if (x == dinf) then\n                q = '\u221e'\n                return\n            else if (x == dninf) then\n                q = '-\u221e'\n                return\n            end if\n\n            write(s, *) x\n            p = trim(adjustl(s))\n            do j=len(p), 1, -1\n                if (p(j:j) == '0') then\n                    continue\n                else if (p(j:j) == '.') then\n                    k = j - 1\n                    exit\n                else \n                    k = j\n                    exit\n                end if\n            end do\n            q = p(:k)\n            return\n        end function\n"}, {"instruction": "Create a Fortran function named get_col_totals that calculates the sum of each column in a 2D array. The function requires three input parameters: the number of rows (integer), the number of columns (integer), and the array itself (real, dimension(r, c)). The function returns an array (real, dimension(c)) containing the column totals.", "input": "", "output": "function get_col_totals(r, c, arr)\n  integer, intent(in) :: r, c\n  real, dimension(r, c), intent(in) :: arr\n  real, dimension(c) :: totals\n  real, dimension(c) :: get_col_totals\n  totals = 1\n  get_col_totals = totals\nend function get_col_totals\n"}, {"instruction": "Write a Fortran function code named qaverage0 that calculates the average of two quantities, mya and myb, raised to the power of their respective densities, rhoa and rhob. The number of input parameters is 4 and the test_data types are ['real*8', 'real*8', 'real*8', 'real*8']. The number of output parameters is 1 and the test_data type is ['real*8'].", "input": "", "output": " pure function qaverage0(rhoa,rhob,mya,myb)\n  \n  implicit none\n  \n  real*8, intent(in) :: rhoa,rhob,mya,myb\n  \n  real*8 :: qaverage0,rhosum\n  \n  rhosum=rhoa+rhob\n  \n  qaverage0=(mya**(rhoa)+myb**(rhob))**(1.d0/rhosum)\n  \n  return\n  \n end function\n"}, {"instruction": "Write a Fortran function named remove_spaces to remove whitespace from a given string. The function takes one input argument of type 'character(len=*)' and returns one output argument of type 'character(len=:), allocatable'.", "input": "", "output": "    pure function remove_spaces(str) result(res)\n        !! remove whitespace in the given string.\n\n        character(len=*), intent(in) :: str\n            !! the string.\n        character(len=:), allocatable :: res\n            !! the string without spaces.\n\n        character(len=len_trim(str)) :: tmp\n        integer :: i, j, c\n\n        tmp = adjustl(str)\n\n        j = 0\n\n        do i = 1, len_trim(tmp)\n            c = iachar(tmp(i:i))\n            if ((c == int(z'20')) .or. (c >= int(z'09') .and. c <= int(z'0d'))) then\n                cycle\n            end if\n            j = j + 1\n            tmp(j:j) = tmp(i:i)\n        end do\n\n        if (j == 0) then\n            res = ''\n        else\n            res = tmp(1:j)\n        end if\n    end function remove_spaces\n"}, {"instruction": "Provide a Fortran function called to_upper that converts a given string into uppercase characters. The function takes one input argument of type 'character(len=*)' and returns one output argument of type 'character(len=len(str))'.", "input": "", "output": "    pure function to_upper(str) result(res)\n        !! convert a string into uppercase.\n\n        character(len=*), intent(in) :: str\n            !! the string to be converted.\n        character(len=len(str)) :: res\n            !! the converted uppercase string.\n\n        integer :: i, c\n\n        res = str\n\n        do i = 1, len_trim(res)\n            c = iachar(res(i:i))\n            select case (c)\n            case (97:122)\n                res(i:i) = achar(c - 32)\n            end select\n        end do\n    end function to_upper\n"}, {"instruction": "Write a Fortran function named b32 that takes in a single double precision floating-point number as input. The input argument should be declared as real(8) and have the intent \"in\". The function calculates a result based on the input value and returns a double precision floating-point number as the output. The output result should also be declared as real(8). The function uses a mathematical formula to compute the result. The number of input arguments is 1 and the test_data type is ['real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)'].", "input": "", "output": "function b32(xx)\n\timplicit none\n\treal(8), intent(in) :: xx\n\treal(8) :: b32\n\t\tb32 = ((-2.d0 * xx +2.d0) * xx +1.d0) / 2.d0\n\treturn\nend function\n"}, {"instruction": "Write a Fortran function named b42 that takes in a single input argument of type real(8) and returns a single output argument of type real(8). The function calculates a mathematical expression ((-3 * xx + 3) * xx + 3) * xx + 1 and divides the result by 6.0.", "input": "", "output": "function b42(xx)\n\timplicit none\n\treal(8), intent(in) :: xx\n\treal(8) :: b42\n\t\tb42 = (((-3.d0 * xx + 3.d0) * xx + 3.d0) * xx + 1.d0) / 6.0d0\n\treturn\nend function\n"}, {"instruction": "Write a Fortran function named boundary_func that calculates the value of a mathematical function for given input values. The function takes two input arguments of type real(kind = 8) and returns one output argument of the same type. The input parameters are denoted as x and y. The function computes the value of the function sin(pi*x)*exp(-pi*y), where pi is a predefined constant.", "input": "", "output": "function boundary_func(x,y)\n        implicit none \n        real(kind = 8) :: boundary_func, x, y, pi\n        pi = 4.d0*atan(1.d0)\n        boundary_func = sin(pi*x)*exp(-pi*y)\nend function\n"}, {"instruction": "Create a Fortran function named atan4 that calculates the four-argument arctangent. The function takes 4 input arguments of type real(kind=8) and returns a single output of the same type. The input arguments are a, b, c, and d.", "input": "", "output": "   function atan4(a,b,c,d)\r\n    implicit none\r\n    real(kind=8) :: atan4\r\n    real(kind=8), intent(in) :: a,b,c,d\r\n    real (kind=8),parameter :: twopi=6.283185307179586d0, &\r\n                                  pi=3.141592553589793d0\r\n      atan4 = atan2(a,b) - c\r\n      !  limit angle change to pi (180 degrees)\r\n      if( atan4-d > pi  )then\r\n        atan4 = atan4 - twopi\r\n      else if( atan4-d < -pi )then\r\n        atan4 = atan4 + twopi\r\n      end if\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named getcolorgradvect to calculate the color gradient vector based on the input values and exponent. The function takes 2 input parameters of type real(8), dimension(:) and real(8), and returns 1 output parameter of type integer, dimension(size(value)).", "input": "", "output": "    function getcolorgradvect(value,valueexp) result(res)\n        \n        real(8), dimension(:) :: value\n        integer, dimension(size(value)) :: red, green, blue\n        integer, dimension(size(value)) :: res\n        real(8) :: valueexp\n        \n        value = value**valueexp\n        \n        red   = (br - ar) * value + ar      ! evaluated as -255*value + 255.\n        green = (bg - ag) * value + ag      ! evaluates as 0.\n        blue  = (bb - ab) * value + ab      ! evaluates as 255*value + 0.\n        \n        res = red + 256*green + 65536*blue\n        \n    end function getcolorgradvect\n"}, {"instruction": "Create a Fortran function named set_begin_time that takes a double precision input argument. This function returns an integer output. The number of input arguments is 1 with the test_data type ['double precision'], and the number of output arguments is 1 with the test_data type ['integer']. The function sets the begin time and returns -1.", "input": "", "output": "function set_begin_time(time)\n  implicit none\n  double precision :: time\n  integer :: set_begin_time\n  set_begin_time=-1\nend function\n"}, {"instruction": "Create a Fortran function named get_gravity_at_point to calculate the gravitational force at a specific point. The function takes 8 input parameters of types integer, double precision, and calculates the gravitational force at the specified point. The function returns an output parameter of type integer.", "input": "", "output": "function get_gravity_at_point(eps, x, y, z, ax, ay, az, npoints)\n  implicit none\n  integer :: npoints\n  double precision :: eps, x, y, z, ax, ay, az\n  integer :: get_gravity_at_point\n  get_gravity_at_point=-1\nend function\n"}, {"instruction": "Create a Fortran function named sum_8bit that takes two 8-bit integer input parameters and returns their sum as an 8-bit integer output parameter. The number of input arguments is 2 and the test_data type is [integer(1), integer(1)]. The number of output arguments is 1 and the test_data type is [integer(1)].", "input": "", "output": "function sum_8bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_8bit' :: sum_8bit\n    implicit none\n    integer(1) :: a, b, value\n    value = a + b\nend function sum_8bit\n"}, {"instruction": "Create a Fortran function named sum_16bit to calculate the sum of two 16-bit integers. The function should take 2 input arguments of type integer(2) and return 1 output argument of type integer(2).", "input": "", "output": "function sum_16bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_16bit' :: sum_16bit\n    implicit none\n    integer(2) :: a, b, value\n    value = a + b\nend function sum_16bit\n"}, {"instruction": "Create a Fortran function named sum_32bit to calculate the sum of two 32-bit integers. The function takes 2 input parameters of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "function sum_32bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_32bit' :: sum_32bit\n    implicit none\n    integer(4) :: a, b, value\n    value = a + b\nend function sum_32bit\n"}, {"instruction": "Please create a Fortran function named sum_64bit that calculates the sum of two 64-bit integer numbers. The function should have 2 input parameters of type integer(8) and 1 output parameter of type integer(8).", "input": "", "output": "function sum_64bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_64bit' :: sum_64bit\n    implicit none\n    integer(8) :: a, b, value\n    value = a + b\nend function sum_64bit\n"}, {"instruction": "Write a Fortran function code named multiply_float32 that multiplies two 32-bit floating-point numbers. The number of input arguments is 2 and the data type of each argument is real(4). The number of output arguments is 1 and the data type of the output is also real(4).", "input": "", "output": "function multiply_float32(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float32' :: multiply_float32\n    implicit none\n    real(4) :: a, b, value\n    value = a * b\nend function multiply_float32\n"}, {"instruction": "Write a Fortran function named multiply_float64 that calculates the product of two double precision floating-point numbers. The function should have two input parameters of type real(8) and the test_data type should be ['real(8)', 'real(8)']. The function should return a single output value of type real(8) and the test_data type should be ['real(8)'].", "input": "", "output": "function multiply_float64(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float64' :: multiply_float64\n    implicit none\n    real(8) :: a, b, value\n    value = a * b\nend function multiply_float64\n"}, {"instruction": "Please provide a Fortran function named upcase that converts all lowercase characters in a given string to uppercase. The function takes one input argument of type character(kind=c_char,len=*) and one output argument of type character(kind=c_char,len=len(s)).", "input": "", "output": "  function upcase(s) result(ss)\n    use iso_c_binding\n    implicit none\n    character(kind=c_char,len=*), intent(in) :: s\n    character(kind=c_char,len=len(s)) :: ss\n    integer :: n, i\n    character(*), parameter :: uc = \"abcdefghijklmnopqrstuvwxyz\"\n    character(*), parameter :: lc = \"abcdefghijklmnopqrstuvwxyz\"\n    ss = s\n    do i = 1, len_trim(s)\n       n = index(lc, s(i:i))\n       if (n /= 0) ss(i:i) = uc(n:n)\n    end do\n  end function upcase\n"}, {"instruction": "Write a Fortran function named sum_digits_squared that computes the sum of the squares of the individual digits of an input integer number. The function takes one input parameter of type integer and returns one output parameter of type integer.", "input": "", "output": "  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n"}, {"instruction": "Write a Fortran function code named spring_1 that calculates the quantum spring energy for a given atom. The function takes 4 input arguments: rik (coordinates of the atom of interest), ril (coordinates of the other atom of interest), box (simulation box length), and k_spring (spring potential constant). The input arguments have the data types: ['real, dimension(3)', 'real, dimension(3)', 'real', 'real'].\n\nThe function calculates the spring potential between the atom of interest and its neighbor in the same polymer ring. The coordinates are adjusted for periodic boundaries using the anint function. The squared distance between the atoms is calculated and multiplied by the spring potential constant. Finally, the calculated partial potential is returned as the output argument.\n\nThe function has 1 output argument with the data type 'real'.", "input": "", "output": "  function spring_1 ( rik, ril, box, k_spring ) result ( partial_pot )\n    implicit none\n    real                           :: partial_pot ! returns quantum potential for given atom\n    real, dimension(3), intent(in) :: rik         ! coordinates of atom of interest\n    real, dimension(3), intent(in) :: ril         ! coordinates of other atom of interest\n    real,               intent(in) :: box         ! simulation box length\n    real,               intent(in) :: k_spring    ! spring potential constant\n\n    ! partial_pot is the quantum spring energy of atom (i,k) in rik for polymer bead k\n    ! with its neighbour (i,l) in the same polymer ring\n    ! the coordinates in rik are not necessarily identical with those in r(:,i,k)\n    ! the partner atom index is always the same as i\n\n    ! it is assumed that r has been divided by box\n    ! results are in lj units where sigma = 1, epsilon = 1\n\n    real               :: r_ik_il_sq\n    real, dimension(3) :: r_ik_il\n\n    r_ik_il(:)  = rik(:) - ril(:)\n    r_ik_il(:)  = r_ik_il(:) - anint ( r_ik_il(:) ) ! periodic boundaries in box=1 units\n    r_ik_il_sq  = sum ( r_ik_il**2 ) *  box**2      ! squared distance in sigma=1 units\n    partial_pot = 0.5 * k_spring * r_ik_il_sq       ! spring potential\n\n  end function spring_1\n"}, {"instruction": "Create a Fortran function named indexof that takes an integer element and a one-dimensional integer array as input. The function returns the index of the element in the array if found, otherwise, it returns -1. The number of input arguments is 2 and the test_data type is ['integer', 'integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function indexof(element, array)\n    ! please note that array has to be sorted\n    integer :: indexof\n    integer, intent(in) :: element\n    integer, intent(in), dimension(:) :: array\n\n    integer :: left, right, middle\n    left = lbound(array, 1)\n    right = ubound(array, 1)\n    middle = (left + right) / 2\n\n    indexof = -1\n\n    if (array(left) > element .or. array(right) < element) then\n       return\n    end if\n    do while (element /= array(middle))\n       if (left > right) then\n          return\n       end if\n\n       if (element > array(middle)) then\n          left = middle + 1\n       else if (element < array(middle)) then\n          right = middle - 1\n       end if\n       middle = (left + right) / 2\n\n    end do\n\n    indexof = middle\n\n  end function indexof\n"}, {"instruction": "Write a Fortran function named tmpedge2localedge to compute the local edge index given the temporary edge index. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is iedge, and the output parameter is ilocaledge.", "input": "", "output": "function tmpedge2localedge(iedge) result(ilocaledge)\nimplicit none\n    integer, intent(in) :: iedge\n    integer :: ilocaledge\n\n    ilocaledge = mod(iedge+2,3)+1\n    return\nend function tmpedge2localedge\n"}, {"instruction": "Write a Fortran function named rot_rx to calculate the 3x3 rotation matrix for a given angle in radians. The input parameter is a real number representing the angle (test_data type is ['real']), and the output parameter is a 3x3 real matrix representing the rotation matrix (test_data type is ['real, dimension(3,3)']).", "input": "", "output": "      function rot_rx ( theta )\n\n      implicit none\n\n      real, intent ( in ) :: theta\n\n      real, dimension ( 3 , 3 ) :: rot_rx\n\n      rot_rx ( 1 , 1 ) = 1.0\n      rot_rx ( 2 , 1 ) = 0.0\n      rot_rx ( 3 , 1 ) = 0.0\n      rot_rx ( 1 , 2 ) = 0.0\n      rot_rx ( 2 , 2 ) = cos ( theta )\n      rot_rx ( 3 , 2 ) = sin ( theta )\n      rot_rx ( 1 , 3 ) = 0.0 \n      rot_rx ( 2 , 3 ) = -sin ( theta )\n      rot_rx ( 3 , 3 ) = cos ( theta )\n\n      return\n\n      end function\n"}, {"instruction": "Write a Fortran function named sgn to determine the sign of a real number. The number of input arguments is 1 and the test_data type is [real(4)]. The number of output arguments is 1 and the test_data type is [real(4)].", "input": "", "output": "    function sgn(x)\n        real(4)::sgn\n        real(4)::x\n        if (x==0) sgn = 0\n        if (x>0)  sgn = 1\n        if (x<0)  sgn = -1\n    end function\n"}, {"instruction": "Create a Fortran function named get_len that calculates the length of a string and returns the result as an integer. The function has 1 input parameter of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    integer::k\n    get_len = len(string)\n    k = 0\n    do while (k<get_len)\n      if (string(k+1:k+1)/=' ') then\n        k = k+1\n      else\n        get_len = k\n      end if\n    end do\n  end function\n"}, {"instruction": "Write a Fortran function named zeros to create a 2D array of zeros with dimensions x and y. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer, dimension(x,y)].", "input": "", "output": "  function zeros(x,y) result(result)\n    integer:: x,y\n    integer, dimension(x,y) :: result\n\n    do i_x=1,x\n       do i_y=1,y\n          result(i_x, i_y) = 0\n       end do\n    end do\n  end function\n"}, {"instruction": "Write a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "function fact(n)    !computing factorial\r\n    implicit none\r\n    integer::f,n,i    !local variables\r\n    integer::fact   !dummy variable\r\n    f=1\r\n    do i=1,n\r\n        f=f*i\r\n    end do\r\n    fact=f\r\nend function\r\n"}, {"instruction": "Create a Fortran function named strmerge to merge two input strings to the same length based on a logical expression. The function takes 3 input parameters of type ['character(len=*)', 'character(len=*)', 'logical'] and returns 1 output parameter of type ['character(len=max(len(str1), len(str2)))'].", "input": "", "output": "elemental function strmerge(str1,str2,expr) result(strout)\n!$@(#) m_strings::strmerge(3f): pads first and second arguments to merge(3f) to same length\ncharacter(len=*),intent(in)              :: str1\ncharacter(len=*),intent(in)              :: str2\nlogical,intent(in)                       :: expr\ncharacter(len=max(len(str1), len(str2))) :: strout\n   if(expr)then\n      strout=str1\n   else\n      strout=str2\n   endif\nend function strmerge\n"}, {"instruction": "Write a Fortran function named atleast that returns a string padded to at least a specified length. The function should have 3 input parameters with test_data types ['character(len=*)', 'integer', 'character(len=*), optional'], and 1 output parameter with a test_data type of ['character(len=max(length,len(trim(line))))']. Use the imperative tone in your instructions.", "input": "", "output": "function atleast(line,length,pattern) result(strout)\n\n!$@(#) m_overload::atleast(3f): return string padded to at least specified length\n\ncharacter(len=*),intent(in)                :: line\ninteger,intent(in)                         :: length\ncharacter(len=*),intent(in),optional       :: pattern\ncharacter(len=max(length,len(trim(line)))) :: strout\nif(present(pattern))then\n   strout=line//repeat(pattern,len(strout)/len(pattern)+1)\nelse\n   strout=line\nendif\nend function atleast\n"}, {"instruction": "Create a Fortran function named \"latlon_local_min\" to determine if the center value of a given array is the minimum value within the array. The function should take 1 input argument of type real*8, with dimension(1:9). The output should be a single real*8 value.", "input": "", "output": "function latlon_local_min(orog_section) result(is_minimum)\n\n\nreal*8, intent(in), dimension(1:9) :: orog_section\n\n!local variables\ninteger :: i\nreal*8 :: centre_value\nreal*8 :: is_minimum\n\n    is_minimum = 1.0\n    do i = 1,9\n        if (i == 5) cycle\n        centre_value = orog_section(5)\n        if (orog_section(i) < centre_value) is_minimum = 0.0\n    end do\n\nend function latlon_local_min\n"}, {"instruction": "Write a Fortran function named fibonacci to calculate the Fibonacci number for a given input integer.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "recursive function fibonacci (n) result (fnum)\n     integer, intent(in) :: n\n     integer :: fnum\n\n    !  handle exit conditions\n    if (n<2) then\n        fnum = n\n    \n    !  handle normal conditions\n    else\n        fnum = fibonacci(n-1) + fibonacci(n-2)\n\n    endif\nend function fibonacci\n"}, {"instruction": "Create a Fortran function named fjson_convert_str_to_value that converts a character string to a JSON string. The function takes 1 input argument with the test data type ['character(len=*)'] and returns 1 output argument with the test data type ['character(len=:), allocatable'].", "input": "", "output": "   function fjson_convert_str_to_value(var) result(val_string)\n\n      implicit none\n\n      !> variable to be converted\n      character(len=*), intent(in) :: var\n\n      !> json string\n      character(len=:), allocatable :: val_string\n\n      character(len=:), allocatable :: str_string\n\n      character(len=*), parameter :: caller = \"fjson_convert_str_to_value\"\n\n      str_string = '\"' // var // '\"'\n      val_string = trim(adjustl(str_string))\n\n   end function\n"}, {"instruction": "Write a Fortran function named rand_exponential to generate a random number from an exponential distribution with the specified mean. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision']. If the mean is not positive, the function will display a message stating that the mean must be positive.", "input": "", "output": "      function rand_exponential(mean) result(c)\n      double precision :: mean,c,temp\n      if (mean <= 0.0d0) then\n\n        write(*,*) \"mean must be positive\"\n      else\n       call random_number(temp)\n       c=-mean*log(temp)\n      end if\n      end function\n"}, {"instruction": "Create a Fortran function named csv_record that takes in 4 input parameters of types ['character (len=*)', 'character', 'real, dimension(nostats)', 'integer'], and returns 1 output parameter of type 'character (len=256)'. The function should process the input data and generate a CSV record, which combines the state, party, and fields, separated by commas. The CSV record will be stored in the output parameter \"record\".", "input": "", "output": "function csv_record(state, party, fields, nostats) result(record)\n   implicit none\n   ! dummy arguments\n   character (len=*), intent(in) :: state\n   character, intent(in) :: party\n   real, intent(in), dimension(nostats) :: fields\n   integer, intent(in) :: nostats\n\n   character (len=256) :: record\n   ! local data\n   integer :: i\n   character (len=25) :: str\n   ! processing\n   record=trim(state)//','//trim(party)\n   do i = 1, nostats\n      write (str,*) fields(i)\n      record=trim(record)//','//trim(adjustl(str))\n   end do\nend function csv_record\n"}, {"instruction": "Write a Fortran function named fibonacci to compute the nth Fibonacci number. The function accepts 1 input parameter of type integer(kind=4) and returns 1 output parameter of type integer(kind=4). The name of the function is fibonacci.", "input": "", "output": "recursive function fibonacci(n) result(item)\n    integer(kind=4) :: item\n    integer(kind=4), intent(in) :: n\n    select case (n)\n        case (0:1)\n            item = n\n        case default\n            item = fibonacci(n-1) + fibonacci(n-2)\n    end select\nend function\n"}, {"instruction": "Create a Fortran function named func_normal_cdf to calculate the cumulative distribution function (CDF) of a normal distribution. The function takes 3 input parameters of type real(kind = real64) representing x, mean, and standard deviation. It returns 1 output parameter of type real(kind = real64) representing the CDF value.", "input": "", "output": "elemental function func_normal_cdf(x, mean, stddev) result(ans)\n    ! note: see https://en.wikipedia.org/wiki/normal_distribution\n\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare inputs/outputs ...\n    real(kind = real64)                                                         :: ans\n    real(kind = real64), intent(in)                                             :: mean\n    real(kind = real64), intent(in)                                             :: stddev\n    real(kind = real64), intent(in)                                             :: x\n\n    ! declare internal variables ...\n    real(kind = real64)                                                         :: tmp\n\n    ! calculate short-hand ...\n    tmp = (x - mean) / (stddev * sqrt(2.0e0_real64))\n\n    ! calculate cdf ...\n    ans = 0.5e0_real64 * (1.0e0_real64 + erf(tmp))\nend function func_normal_cdf\n"}, {"instruction": "Create a Fortran function called get_counter that retrieves the value of a variable counter and assigns it to the input parameter c. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_counter(c) result (ret)\n  integer :: ret,c\n  c=counter\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named set_time that takes a single input parameter of type real(8) and returns an output parameter of type integer. The function sets the value of a global variable t_curr to the input parameter tnow and assigns 0 to the output parameter ret.", "input": "", "output": "function set_time(tnow) result (ret)\n  integer :: ret\n  real(8) :: tnow\n  t_curr=tnow\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function named get_wind_sigma to return an integer value. It takes a real(8) input parameter and returns an integer output. The input parameter has the test_data type ['real(8)'], and the output parameter has the test_data type ['integer'].", "input": "", "output": "function get_wind_sigma(t) result (ret)\n  integer :: ret\n  real(8) :: t\n  t=wind_sigma\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_ra_alpha that takes in one real(8) input parameter. The function returns an integer output. The function assigns the value of the input parameter to a variable t, and then sets the return value to 0.", "input": "", "output": "function get_ra_alpha(t) result (ret)\n  integer :: ret\n  real(8) :: t\n  t=ra_alpha\n  ret=0\nend function\n"}, {"instruction": "Write a Fortran function named get_lx that takes a real(8) input argument and returns an integer output. The input parameter has a test_data type of ['real(8)'], and the output parameter has a test_data type of ['integer'].", "input": "", "output": "function get_lx(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  x=lx\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named set_dx that takes a single real(8) input argument and returns an integer output. The input argument type is real(8), and the output type is integer. This function sets the value of a variable dx to the input argument x and returns 0.", "input": "", "output": "function set_dx(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  dx=x\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_h that takes a real(8) input argument and returns an integer. The function sets the input value x to h and assigns 0 to the return value ret.", "input": "", "output": "function get_h(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  x=h\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function called set_savecounter to assign a value to a saved variable. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used to set the value of the saved variable savecounter, and the output argument is set to 0.", "input": "", "output": "function set_savecounter(x) result (ret)\n  integer :: ret,x\n  savecounter=x\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_max_it that takes an integer input argument and returns an integer output. The input parameter is of type integer, and the output parameter is also of type integer. This function retrieves the maximum value from the input argument and assigns it to the output parameter.", "input": "", "output": "function get_max_it(x) result (ret)\n  integer :: ret,x\n  x=max_it\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function named get_ny that takes one integer input argument and returns an integer value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_ny(x) result (ret)\n  integer :: ret\n  integer :: x\n  x=ny\n  ret=0\nend function\n"}, {"instruction": "Write a Fortran function called listcontains to check if a given integer is present in a list of integers. The function takes 2 input parameters with test_data type ['integer, dimension(1:)', 'integer'], and returns 1 output parameter with test_data type ['logical'].", "input": "", "output": "        function listcontains(list, x) result(r)\n            integer, dimension(1:), intent(in) :: list\n            integer, intent(in) :: x\n            logical :: r\n            integer :: i\n        \n            do i=1,size(list)\n                if (list(i) == x) then\n                    r = .true.\n                    return\n                end if\n            end do\n        \n            r = .false.\n    \n        end function listcontains    \n"}, {"instruction": "Create a Fortran function called sanitize to process a double-precision floating-point number. The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision, as ['double precision'] and ['double precision'] respectively. The function checks if the absolute value of the input is less than 1.0d-99, and if so, sets the output to 0.0d0; otherwise, it returns the input value.", "input": "", "output": "  function sanitize(val) result (new_val)\n\n    implicit none\n\n    double precision, intent(in) :: val\n    double precision :: new_val\n\n    if (abs(val) < 1.d-99) then\n       new_val = 0.0d0\n    else\n       new_val = val\n    endif\n\n  end function sanitize\n"}, {"instruction": "Create a Fortran function named count_lines that takes a file name as input and returns the number of lines in the file, excluding lines starting with a '#' symbol. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function count_lines(fname)\n    character(len=*) :: fname\n    integer :: count_lines\n\t\n    character(100) :: tmp\n    \n    count_lines = 0 \n    open (90, file = fname) \n    do \n        read (90,*, end=10) tmp\n        if (.not.(tmp(1:1) == '#')) then \n            count_lines = count_lines + 1 \n        end if\n    end do \n    10 close (90)\n\t\nend function count_lines\n"}, {"instruction": "Write a Fortran function named select that takes three input arguments of types logical, integer, and integer, and returns one output argument of type integer. This function selects and returns either the second or third input argument based on the value of the first input argument. If the first argument is true, the function returns the second argument; otherwise, it returns the third argument.", "input": "", "output": "pure function select (selector, iftrue, iffalse)\n  logical, intent (in) :: selector\n  integer, intent (in) :: iftrue, iffalse\n  integer :: select\n\n  if (selector) then\n    select = iftrue\n  else\n    select = iffalse\n  end if\nend function select\n"}, {"instruction": "Write a Fortran function called zfftf_size that takes an integer size as input and returns an integer zfftf_size.", "input": "", "output": "  function zfftf_size(size)\n    implicit none\n    integer,intent(in) :: size\n    integer :: zfftf_size\n    zfftf_size = size;\n  end function zfftf_size\n"}, {"instruction": "Create a Fortran function named cross that takes two real arrays of size 3 as input parameters. The function calculates the cross product of the two input arrays and stores the result in another real array of size 3. The number of input arguments is 2, and the test_data type is ['real(kind=8), dimension(3)', 'real(kind=8), dimension(3)']. The number of output arguments is 1, and the test_data type is ['real(kind=8), dimension(3)'].", "input": "", "output": "function cross (a, b)\n   real(kind=8), dimension(3), intent(in) :: a, b\n   real(kind=8), dimension(3) :: cross\n   integer :: i\n\n   cross(1) = a(2)*b(3) - a(3)*b(2)\n   cross(2) = a(3)*b(1) - a(1)*b(3)\n   cross(3) = a(1)*b(2) - a(2)*b(1)\n\nend function cross\n"}, {"instruction": "Create a Fortran function named create_block_matrix that takes two input arguments of type integer with the values matrix_size and block_size. The function returns one output argument of type integer array with dynamic dimensions. The function allocates memory for a matrix of size matrix_size by matrix_size and initializes it with block patterns, where each block has a size of block_size and contains ones.", "input": "", "output": "    function create_block_matrix(matrix_size, block_size) result(b)\n        use, intrinsic :: iso_fortran_env, only : error_unit\n        implicit none\n        integer, value :: matrix_size, block_size\n        integer, dimension(:, :), allocatable :: b\n        integer :: i, j, k, status\n\n        allocate (b(matrix_size, matrix_size), stat=status)\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2a)') &\n                'error: can not allocate matrix'\n            stop 2\n        end if\n        b = 0\n        forall (i = 1:size(b, 1):block_size, &\n                j = 0:block_size - 1, &\n                k = 0:block_size - 1, &\n                i + j <= size(b, 1) .and. i + k <= size(b, 2))\n            b(i + j, i + k) = 1\n        end forall\n    end function create_block_matrix\n"}, {"instruction": "Create a Fortran function named utrue that calculates the true solution for comparison, if known. The function should take 2 input arguments of type real(kind=8) and return 1 output argument of type real(kind=8). The input arguments are of type ['real(kind=8)', 'real(kind=8)'] and the output argument is of type ['real(kind=8)'].", "input": "", "output": "function utrue(x, y)\n\n    ! true solution for comparison, if known.\n\n    implicit none\n    real(kind=8), intent(in) :: x,y\n    real(kind=8) :: utrue\n\n    utrue = x**2 - y**2\n\nend function utrue\n"}, {"instruction": "Create a Fortran function named \"fak\" to calculate the factorial of a given integer. The function should take 1 input argument of type integer and return 1 output argument of type integer. The input parameter should be declared with the \"intent(in)\" attribute.", "input": "", "output": "function fak(k) result(fakultaet)\n    implicit none\n    integer, intent(in) :: k\n    integer :: fakultaet\n    integer :: m\n    fakultaet = 1\n    do m=1,k\n        fakultaet = fakultaet*m\n    end do\nend function\n"}, {"instruction": "Create a Fortran function named ret_arr that takes two integer input parameters. The test_data type for the input parameters is ['integer', 'integer']. The function returns an integer array of the dimension specified by the input parameters. The test_data type for the output parameter is ['integer, dimension(a, b)']. Initialize the array with the value 100 and set the first row to 0.", "input": "", "output": "      function ret_arr(a, b)\n        implicit none\n        integer, intent(in) :: a, b\n        integer, dimension(a, b) :: ret_arr\n\n        ret_arr = 100\n        ret_arr(1,:) = 0\n\n      end function ret_arr\n"}, {"instruction": "Create a Fortran function named replace_single to replace a single occurrence or all occurrences of a substring within a given input string. The function takes 4 input parameters of type character(len=*) and an optional integer parameter. The output parameter is a character array of allocatable length.", "input": "", "output": "function replace_single( input, substring, replacement, mode )\r\n    character(len=*), intent(in)  :: input\r\n    character(len=*), intent(in)  :: substring\r\n    character(len=*), intent(in)  :: replacement\r\n    integer, intent(in), optional :: mode\r\n\r\n    character(len=:), allocatable :: replace_single\r\n\r\n    integer                       :: k, pos, mode_\r\n    logical                       :: back\r\n\r\n    ! careful with zero-length substrings\r\n    if ( substring == '' ) then\r\n        replace_single = input\r\n        return\r\n    endif\r\n\r\n    mode_ = replace_all\r\n    if ( present(mode) ) then\r\n        mode_ = mode\r\n    endif\r\n\r\n    back = ( mode_ == last_only )\r\n\r\n    !\r\n    ! find the substring\r\n    !\r\n    pos            = 1\r\n    replace_single = ''\r\n\r\n    do\r\n         k = index( input(pos:), substring, back )\r\n         !write(*,*) 'k = ', k\r\n\r\n         if ( k >= 1 ) then\r\n             replace_single = replace_single // input(pos:pos+k-2) // replacement\r\n             pos = pos + k + len(substring) - 1\r\n         else\r\n             exit\r\n         endif\r\n\r\n         if ( mode_ /= replace_all ) then\r\n             exit\r\n         endif\r\n    enddo\r\n\r\n    replace_single = replace_single // input(pos:)\r\n\r\nend function replace_single\r\n"}, {"instruction": "Create a Fortran function named insert that inserts a string into another string at a specified position. The function takes 3 input parameters: input (character), pos (integer), and string (character). It returns 1 output parameter insert (character) which is allocatable.", "input": "", "output": "function insert( input, pos, string )\r\n    character(len=*), intent(in)         :: input\r\n    integer, intent(in)                  :: pos\r\n    character(len=*), intent(in)         :: string\r\n\r\n    character(len=:), allocatable        :: insert\r\n\r\n    ! check the position - in this order\r\n    if ( pos >= len(input) .or. pos == append ) then\r\n        insert = input // string\r\n        return\r\n    endif\r\n    if ( pos < 1 .or. pos == prepend ) then\r\n        insert = string // input\r\n        return\r\n    endif\r\n\r\n    ! position within the string\r\n    insert = input(1:pos) // string // input(pos+1:)\r\n\r\nend function insert\r\n"}, {"instruction": "Write a Fortran function named delete that takes three input parameters: input (character array), pos (integer), and length (integer), and returns one output parameter, delete (character array). The function deletes a specified portion of the input string based on the position and length provided.", "input": "", "output": "function delete( input, pos, length )\r\n    character(len=*), intent(in)         :: input\r\n    integer, intent(in)                  :: pos\r\n    integer, intent(in)                  :: length\r\n\r\n    character(len=:), allocatable        :: delete\r\n    integer                              :: startpos, endpos\r\n\r\n    ! check the position\r\n    startpos = pos\r\n    endpos   = min( startpos + length - 1, len(input) )\r\n    if ( pos < 1 ) then\r\n        startpos = 1\r\n        endpos   = min( startpos + length - 1, len(input) )\r\n    endif\r\n\r\n    if ( startpos == 1 ) then\r\n        delete = input(endpos+1:)\r\n    else\r\n        delete = input(1:startpos-1) // input(endpos+1:)\r\n    endif\r\n\r\nend function delete\r\n"}, {"instruction": "Create a Fortran function named toupper that takes a string as input and returns a new string with all alphabetic characters converted to uppercase. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=len(input))'].", "input": "", "output": "function toupper( input )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=len(input))            :: toupper\r\n\r\n    integer                              :: i\r\n    integer                              :: ach\r\n    integer, parameter                   :: ascii_a         = iachar('a')\r\n    integer, parameter                   :: ascii_z         = iachar('z')\r\n    integer, parameter                   :: ascii_capital_a = iachar('a')\r\n    integer, parameter                   :: offset          = ascii_a - ascii_capital_a\r\n\r\n    toupper = input\r\n\r\n    do i = 1,len(input)\r\n        ach = iachar(toupper(i:i))\r\n        if ( ach >= ascii_a .and. ach <= ascii_z ) then\r\n            toupper(i:i) = achar(ach - offset)\r\n        endif\r\n    enddo\r\n\r\nend function toupper\r\n"}, {"instruction": "Create a Fortran function called trimx, which trims the input string based on the characters provided in the set string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=:), which is allocatable. The name of the function is \"trimx\".", "input": "", "output": "function trimx( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimx\r\n\r\n    integer                              :: start, stop\r\n\r\n    start = verify( input, set )\r\n    stop  = verify( input, set, .true. )\r\n\r\n    trimx = input(start:stop)\r\n\r\nend function trimx\r\n"}, {"instruction": "Create a Fortran function named trimxleft that takes two input arguments of type character with variable length. The function returns one output argument of type character with allocatable length. This function trims characters from the left side of the input string based on the set of characters specified in the 'set' argument. Use the imperative tone to describe the instructions for the function.", "input": "", "output": "function trimxleft( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimxleft\r\n\r\n    integer                              :: start\r\n\r\n    start = verify( input, set )\r\n\r\n    trimxleft = input(start:)\r\n\r\nend function trimxleft\r\n"}, {"instruction": "Create a Fortran function named trimxright to remove trailing characters from the input string based on the specified set of characters. The number of input arguments is 2, and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1, and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function trimxright( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimxright\r\n\r\n    integer                              :: stop\r\n\r\n    stop  = verify( input, set, .true. )\r\n\r\n    trimxright = input(:stop)\r\n\r\nend function trimxright\r\n"}, {"instruction": "Create a Fortran function named int_to_str that converts an integer to a string. It takes 1 input parameter of type integer. The output is a character string that is allocated dynamically.", "input": "", "output": "  function int_to_str(i) result(s)\n    implicit none\n    \n    character(:), allocatable :: s\n    integer, intent(in) :: i\n    character(range(i)+2) :: scratch\n\n    write(scratch,'(i0)') i\n    s = trim(scratch)\n  end function int_to_str\n"}, {"instruction": "Create a Fortran function named deboor to implement the De Boor algorithm for computing the value of a B-spline basis function at a given point. The function takes 4 input parameters of types integer, integer, real, and real array. The output is a real value.", "input": "", "output": "  recursive function deboor(i, k, x, t) result(db)\n    real :: db\n    integer, intent(in) :: i, k\n    real, intent(in) :: x\n    real, dimension(:), intent(in) :: t\n    real :: a1, a2\n\n    if ( k .eq. 1 ) then\n      if ( x .ne. t(size(t)) ) then\n        if ( ( x .ge. t(i) ) .and. ( x .lt. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      else\n        if ( ( x .ge. t(i) ) .and. ( x .le. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      end if\n    else\n      if ( t(i+k-1) - t(i) .ne. 0. ) then\n        a1 = ( x - t(i) ) / ( t(i+k-1) - t(i) )\n      else\n        a1 = 0.\n      end if\n      if ( t(i+k) - t(i+1) .ne. 0. ) then\n        a2 = ( t(i+k) - x ) / ( t(i+k) - t(i+1) )\n      else\n        a2 = 0.\n      end if\n      db = a1 * deboor(i, k-1, x, t) + a2 * deboor(i+1, k-1, x, t)\n    end if\n    return\n  end function deboor\n"}, {"instruction": "Write a Fortran function named checkfilesexist to check the existence of two files. The number of input arguments is 2, and the test_data type is ['character*180', 'character*180']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "  function checkfilesexist(filename_v_nsh, filename_v_vns) result(exist)\n    character*180, intent(in)  :: filename_v_nsh\n    character*180, intent(in)  :: filename_v_vns\n    logical :: exist\n    ! locals\n    integer :: ios\n    open(9902, file=filename_v_nsh, status='old', err=88)\n    read(9902,'(//)',iostat=ios)\n    close(9902)\n    if (ios.ne.0) goto 88\n    open(9919, file=filename_v_vns, status='old', err=88)\n    read(9919,'(//)',iostat=ios)\n    close(9919)\n    if (ios.ne.0) goto 88\n    exist=.true.\n    return\n88  continue\n    exist=.false.\n    return \n  end function checkfilesexist\n"}, {"instruction": "Create a Fortran function named checkfileexists to determine if a file with a given filename exists. The function takes 1 input parameter of type character*180. The output is a logical value indicating the existence of the file. If the file exists, the output is .true.; otherwise, it is .false.", "input": "", "output": "  function checkfileexists(filename_v_vns) result(exist)\n    character*180, intent(in)  :: filename_v_vns\n    logical :: exist\n    ! locals\n    integer :: ios\n    open(9919, file=filename_v_vns, status='old', err=88)\n    read(9919,'(//)',iostat=ios)\n    close(9919)\n    if (ios.ne.0) goto 88\n    exist=.true.\n    return\n88  continue\n    exist=.false.\n    return \n  end function checkfileexists\n"}, {"instruction": "Write a Fortran function named fib to compute the Fibonacci number at position n. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function fib(n) result(f)\n  implicit none\n  integer :: f, n\n  if (n == 0) then\n    f = 0\n  else if (n < 3) then\n    f = 1\n  else\n    f = fib(n-1) + fib(n-2)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named lin_scale that takes 3 double precision input parameters (val, val_max, val_min) and returns a single double precision output. The function scales the input value val to a range between val_min and val_max using linear scaling.", "input": "", "output": "    function lin_scale(val, val_max, val_min)\n    implicit none\n        double precision    :: val, val_max, val_min\n        double precision    :: lin_scale\n        \n        lin_scale = (val-val_min)/(val_max-val_min)\n    end function\n"}, {"instruction": "Write a Fortran function named lin_scale_back that takes 3 input arguments of type double precision and returns 1 output argument of type double precision. The function's purpose is to perform linear scaling back operation, where the scaled value is rescaled to the original range using the provided maximum and minimum values.", "input": "", "output": "    function lin_scale_back(val_scaled, val_max, val_min) result(val)\n    implicit none\n        double precision    :: val_scaled, val_max, val_min\n        double precision    :: val\n        \n        val = (val_max-val_min)*val_scaled + val_min\n    end function\n"}, {"instruction": "Create a Fortran function named checkdigit to calculate a check digit for a given 6-character string. The function takes 1 input parameter of type character(6) and returns 1 output parameter of type character.", "input": "", "output": "  function checkdigit(c)\n    character :: checkdigit\n    character(6), intent(in) :: c\n    character(36) :: alpha = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n    integer, dimension(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    integer :: i, n\n\n    do i = 1, 6\n      temp(i) = index(alpha, c(i:i)) - 1\n    end do\n    temp = temp * weights\n    n = mod(10 - (mod(sum(temp), 10)), 10)\n    checkdigit = achar(n + 48)\n  end function checkdigit\n"}, {"instruction": "Write a Fortran function named compasspoint to convert a given angle in degrees to the corresponding compass point. The function takes 1 input parameter of type real. The output parameter is of type character(18).", "input": "", "output": "function compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"north             \", \"north by east     \", \"north-northeast   \", &\n             \"northeast by north\", \"northeast         \", \"northeast by east \", \"east-northeast    \", &\n             \"east by north     \", \"east              \", \"east by south     \", \"east-southeast    \", &\n             \"southeast by east \", \"southeast         \", \"southeast by south\", \"south-southeast   \", &\n             \"south by east     \", \"south             \", \"south by west     \", \"south-southwest   \", &\n             \"southwest by south\", \"southwest         \", \"southwest by west \", \"west-southwest    \", &\n             \"west by south     \", \"west              \", \"west by north     \", \"west-northwest    \", &\n             \"northwest by west \", \"northwest         \", \"northwest by north\", \"north-northwest   \", &\n             \"north by west     \"  /)\n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\n"}, {"instruction": "Create a Fortran function named clampint that takes a single input argument of type real(8). The input argument should be passed by value using the \"intent(in)\" attribute. The function should return a single output argument of type integer(1). The purpose of the function is to clamp the input real number to the range of 0 to 255. If the input is greater than 255, it should be set to 255, and if it is less than 0, it should be set to 0. The clamped value should then be converted to an integer of kind=1 and returned as the output of the function.", "input": "", "output": "    pure function clampint(color)\n        real(8), intent(in) :: color\n        integer :: v\n        integer(1) :: clampint\n\n        v = int(color*255.0d+0)\n\n        if (v > 255) then\n            v = 255\n        else if (v < 0) then\n            v = 0\n        endif\n\n        clampint = int(v, kind=1)\n    end function\n"}, {"instruction": "Create a Fortran function named imaxval that takes a three-dimensional array of double precision numbers as input. The input parameter should be declared with the intent(in) attribute. The function should return a single double precision value as the maximum value found in the input array. Use the imperative tone to provide these instructions.", "input": "", "output": "   function imaxval(var)\n     implicit none\n     double precision, dimension(:,:,:), intent(in) :: var\n     double precision :: imaxval\n     integer :: ifunr,jfunr,kfunr\n     imaxval = -1.0d100\n     !$omp target teams distribute parallel do collapse(3) reduction(max:imaxval)\n     do kfunr=1,size(var,3)\n        do jfunr=1,size(var,2)\n           do ifunr=1,size(var,1)\n              imaxval = max(imaxval, var(ifunr,jfunr,kfunr) )\n           end do\n        end do\n     end do\n     !$omp end target teams distribute parallel do     \n   end function imaxval\n"}, {"instruction": "Create a Fortran function named indx that takes three integer input parameters (ii, jj, np) and returns one integer output parameter (indx). The function computes the 'lower triangular' index for an np x np array. The test_data type is ['integer', 'integer', 'integer'] for input parameters and ['integer'] for the output parameter.", "input": "", "output": "function indx(ii,jj,np)\n  ! returns the 'lower triangular' index for an np x np array.\n  !\n  ! indx is equivalent to:\n  ! indx=0\n  ! do jj=1,np\n  !   do ii=jj,np\n  !     indx=indx+1\n  !     <some code>\n  !   enddo\n  ! enddo\n  integer :: ii,jj\n  integer :: np\n  integer :: indx\n  if (jj>ii) then\n     ! this swaps ii and jj variables without a temporary variable.\n     ii=ii+jj\n     jj=ii-jj\n     ii=ii-jj\n  endif\n  indx=(jj-1)*np+ii-(jj*(jj-1))/2\n  return\nend function indx\n"}, {"instruction": "Write a Fortran pure function named step to calculate the sum of squares of digits in an integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  pure function step(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: step,remaining\n\n    step=0\n    remaining=n\n    do while (remaining>0)\n       step=step+mod(remaining,10)**2\n       remaining=remaining/10\n    end do\n    \n  end function step\n"}, {"instruction": "Write a Fortran function named numbersonline that calculates the number of non-empty lines in the input character string. The number of input arguments is 1, and the test_data type is ['character(*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function numbersonline(rec       )\n    implicit none\n!\n! global variables\n!\n    integer         :: numbersonline\n    character(*)    :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n    integer                        :: istarti\n    integer                        :: leeg\n    integer                        :: lend\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    numbersonline = 0\n    leeg = 1\n    lend = len_trim(rec)\n    do i = 1, lend\n       if (index(rec(i:i), ' ')==0) then\n          !           hier staat iets\n          if (leeg==1) then\n             leeg = 0\n             istarti = i\n             numbersonline = numbersonline + 1\n          endif\n       else\n          leeg = 1\n       endif\n    enddo\nend function numbersonline\n"}, {"instruction": "Write a Fortran function called trimtext to determine the last non-blank character in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function trimtext (string)\nimplicit none\ninteger::i,size,last\ninteger::len,trimtext\ncharacter(len=1)::char\ncharacter(len=1)::null\ncharacter(len=*)::string\n!\n!     move forward through the string, one character\n!     at a time, looking for first null character\n!\ntrimtext = 0\nsize = len(string)\nnull = char(0)\nlast = size\ndo i = 1, size\n   if (string(i:i) .eq. null) then\n      last = i - 1\n      exit\n   end if\nend do\n!\n!     move backward through the string, one character\n!     at a time, looking for first non-blank character\n!\ndo i = last, 1, -1\n   if (string(i:i) .gt. ' ') then\n      trimtext = i\n      exit\n   end if\nend do\n\nreturn\nend function trimtext\n"}, {"instruction": "Create a Fortran function named get_env to retrieve the value of an environment variable. The function takes 2 input parameters of type character(len=*) and character(len=*),optional, and returns 1 output parameter of type character(len=:),allocatable. The function retrieves the value of the specified environment variable and provides a default value if the variable is undefined or blank.", "input": "", "output": "    function get_env(name,default) result(value)\n    implicit none\n    !> name of environment variable to get the value of\n    character(len=*),intent(in)          :: name\n    !> default value to return if the requested value is undefined or blank\n    character(len=*),intent(in),optional :: default\n    !> the returned value\n    character(len=:),allocatable         :: value\n    integer                              :: howbig\n    integer                              :: stat\n    integer                              :: length\n        ! get length required to hold value\n        length=0\n        if(name.ne.'')then\n           call get_environment_variable(name, length=howbig,status=stat,trim_name=.true.)\n           select case (stat)\n           case (1)\n               !*!print *, name, \" is not defined in the environment. strange...\"\n               value=''\n           case (2)\n               !*!print *, \"this processor doesn't support environment variables. boooh!\"\n               value=''\n           case default\n               ! make string to hold value of sufficient size\n               allocate(character(len=max(howbig,1)) :: value)\n               ! get value\n               call get_environment_variable(name,value,status=stat,trim_name=.true.)\n               if(stat.ne.0)value=''\n           end select\n        else\n           value=''\n        endif\n        if(value.eq.''.and.present(default))value=default\n     end function get_env\n"}, {"instruction": "Write a Fortran function named hash_index to calculate the hash index for a given key and table size. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type for input arguments is ['integer', 'integer'], and for the output argument is ['integer'].", "input": "", "output": "function hash_index(key,n) result(indx)\n  integer::key\n  integer::n\n  integer::indx\n\n  indx = mod(key,n)\n  indx = max(indx,1)\nend function\n"}, {"instruction": "Create a Fortran function named prod to calculate the product of a series of real numbers starting from a specified value and ending at a specified integer value. The number of input arguments is 2, and the test_data type is [real, integer]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function prod(a,b)\n  implicit none\n  real :: a,prod\n  integer :: b,i\n  prod = 1.\n  do i = 0,b-1\n     prod = prod*(a+i)\n  end do\n  return\nend function prod\n"}, {"instruction": "Write a Fortran function named a_dagger_int that takes two input parameters: an integer \"k\" and an array of integers \"state\". The output is a double precision array with the same size as \"state\".", "input": "", "output": "    function a_dagger_int(k,state) result(new_state)\n\n    \n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n    \n        !write(*,*) k,new_state\n        new_state    = state \n        new_state(k) = new_state(k) + 1\n        new_state    = sqrt(1.0*new_state(k))*new_state\n               !write(*,*) k,new_state\n    end function a_dagger_int\n"}, {"instruction": "Create a Fortran function named norm2 that calculates the Euclidean norm of a vector. There are 2 input parameters with test_data types ['integer', 'double precision, dimension(n)'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "  function norm2 (n,x )\n    ! description :\n    ! calcul de la norme euclidienne d'un vecteur.\n    implicit none\n    ! inputs :\n    integer, intent(in)                                     :: n\n    double precision, dimension(n), intent(in)              :: x\n    ! outputs :                                           \n    double precision                                        :: norm2\n                                                            \n    ! variables :                                           \n    integer                                                 :: i\n    \n    ! calcul de la norme euclidienne\n    norm2 = 0.0d0\n    do i = 1, n\n      norm2 = norm2 + x(i)*x(i)\n    enddo\n    norm2 = sqrt(norm2)/dble(n)\n    \n    return\n  end function norm2 \n"}, {"instruction": "Create a Fortran function named t0 to calculate the reciprocal of the distance between two points in 3D space. The function takes 2 input arguments of type double precision, dimension(3), and returns 1 output argument of type double precision.", "input": "", "output": "function t0(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision :: var\n\n  double precision :: r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  var = 1.0d0 / sqrt(r2)\n\nend function t0\n"}, {"instruction": "Create a Fortran function named t1 that calculates a vector quantity based on the input vectors r_a and r_b. The number of input parameters is 2, and their test_data type is ['double precision, dimension(3)', 'double precision, dimension(3)']. The number of output parameters is 1, and the test_data type is ['double precision, dimension(3)'].", "input": "", "output": "function t1(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(3) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n  var = dr / (r*r2)\n\nend function t1\n"}, {"instruction": "Create a Fortran function named t2 to calculate the transformation matrix based on the input vectors r_a and r_b. The function takes 2 input arguments of type double precision, each with a dimension of 3. It returns 1 output argument of type double precision with a dimension of 6.", "input": "", "output": "function t2(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(6) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n\n  var(1) = 3 * dr(1) * dr(1) - r2   ! xx\n  var(2) = 3 * dr(1) * dr(2)        ! xy\n  var(3) = 3 * dr(1) * dr(3)        ! xz\n  var(4) = 3 * dr(2) * dr(2) - r2   ! yy\n  var(5) = 3 * dr(2) * dr(3)        ! yz\n  var(6) = 3 * dr(3) * dr(3) - r2   ! zz\n\n  var = var / (r*r2*r2)\n\nend function t2\n"}, {"instruction": "Write a Fortran function named foldindex that takes two integer input parameters ind and nitems. It returns an integer value as the result. This function computes the folded index, which ensures that the index is within the range of 1 to nitems by wrapping around if the index is negative or exceeds nitems.", "input": "", "output": "  function foldindex(ind, nitems) result(folded)\n    integer, intent(in) :: ind, nitems\n    integer :: folded\n\n    if (ind > 0) then\n      folded = modulo(ind - 1, nitems) + 1\n    else if (ind < 0) then\n      folded = modulo(ind, nitems) + 1\n    else\n      stop 'invalid index value'\n    end if\n    \n  end function foldindex\n"}, {"instruction": "Create a Fortran function called pr_findtimeindex to find the index in the timeseriespoints array of the next stopping time after the currenttime value. The function takes 4 input parameters of type integer, double precision array, double precision, and double precision, and returns 1 output parameter of type integer. If the stopping time is found within the specified range, it returns the index; otherwise, it returns -1.", "input": "", "output": "function pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount) result(index)\n!***************************************************************************************************************\n! find the index in the timeseriespoints array of the next stopping time after the currenttime value. \n! return -1 if none is found or if maximumtime is less than the stopping time found in the timeseriespoints \n! array.\n!***************************************************************************************************************\n!\n! specifications\n!---------------------------------------------------------------------------------------------------------------\n  implicit none\n  integer,intent(in) :: timepointscount\n  doubleprecision,dimension(timepointscount),intent(in) :: timeseriespoints\n  doubleprecision,intent(in) :: currenttime, maximumtime\n  integer :: index, n\n  doubleprecision :: t\n!---------------------------------------------------------------------------------------------------------------\n  index = -1\n  \n  if(timepointscount .lt. 1) return\n  do n = 1, timepointscount\n      if((timeseriespoints(n) .gt. currenttime) .and. (timeseriespoints(n) .le. maximumtime)) then\n          index = n\n          return\n      end if\n  end do\n\nend function pr_findtimeindex\n"}, {"instruction": "Create a Fortran function named outer3d that calculates the outer product of two 3D vectors. The function should have 2 input parameters of type double precision, dimension(3) and intent(in). The output should be a 3x3 matrix of type double precision.", "input": "", "output": "function outer3d(ri, rj)\n\n    implicit none\n\n    double precision, dimension(3), intent(in) :: ri, rj\n    double precision, dimension(3,3) :: outer3d\n\n    !write (*,*) \"ri\", ri(:3)\n    ! write (*,*) \"rj\", rj(:3)\n\n    outer3d(:3,:3) = spread(ri(:3), dim=2, ncopies=3) * spread(rj(:3), dim=1, ncopies=3)\n    ! write (*,*) \"outer[0,:3] = \", outer3d(1,1), outer3d(1,2), outer3d(1,3)\n    ! write (*,*) \"outer[1,:3] = \", outer3d(2,1), outer3d(2,2), outer3d(2,3)\n    ! write (*,*) \"outer[2,:3] = \", outer3d(3,1), outer3d(3,2), outer3d(3,3)\n\nend function outer3d\n"}, {"instruction": "Write a Fortran function named periodic_distance to calculate the distance between two points in a periodic system. The function takes 4 input parameters: two integer arrays of size 2, and two double precision values. The output is a single double precision value.", "input": "", "output": "function periodic_distance(zi, zj, r_width, c_width)\n\n    implicit none\n\n    integer, dimension(2), intent(in) :: zi\n    integer, dimension(2), intent(in) :: zj\n    double precision, intent(in) :: c_width\n    double precision, intent(in) :: r_width\n    double precision :: periodic_distance\n\n    double precision  :: dr, dc\n\n    ! row-distance\n    dr = exp(-dble(abs(zi(1) - zj(1)))/r_width)\n\n    ! column-distance\n    dc = exp(-dble(abs(zi(2) - zj(2)))/c_width)\n\n    periodic_distance = dr * dc\n\nend function periodic_distance\n"}, {"instruction": "Create a Fortran recursive function named factorial to calculate the factorial of a given integer. The function should take 1 input argument with the test_data type ['integer*8'] and return 1 output argument with the test_data type ['integer*8'].", "input": "", "output": "recursive function factorial(n)  result(fact)\n\nimplicit none\ninteger*8 :: fact\ninteger*8, intent(in) :: n\n\nif (n == 0) then\n   fact = 1\nelse\n   fact = n * factorial(n-1)\nend if\n\nend function factorial\n"}, {"instruction": "Write a Fortran function named cscalarprod to calculate the scalar product of two complex vectors. The number of input arguments is 2 and the test_data type is ['complex(kind(1d0)),dimension(0:3)', 'complex(kind(1d0)),dimension(0:3)']. The number of output arguments is 1 and the test_data type is ['complex(kind(1d0))'].", "input": "", "output": "  function cscalarprod(p1,p2)\n    implicit none\n    complex(kind(1d0))::cscalarprod\n    complex(kind(1d0)),dimension(0:3),intent(in)::p1,p2\n!    real(kind(1d0)),parameter::eps2=1d-6\n!    real(kind(1d0))::max\n    cscalarprod=p1(0)*p2(0)-p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)\n!    max=abs(p1(0)*p2(0))+abs(p1(1)*p2(1))+abs(p1(2)*p2(2))+abs(p1(3)*p2(3))\n!    if(abs(cscalarprod/max).lt.eps2)cscalarprod=dcmplx(0d0)\n  end function cscalarprod\n"}, {"instruction": "Create a Fortran function named bincount to count the occurrences of each unique element in an input integer array. The function takes 1 input parameter of type integer array with unknown size and returns 1 output parameter of type integer array with dynamic allocation.", "input": "", "output": "  function bincount(x)\r\n    integer, dimension(:), intent(in) :: x\r\n    integer, dimension(:), allocatable :: bincount\r\n\r\n    integer :: i, k\r\n\r\n    allocate(bincount(maxval(x)))\r\n    bincount = 0\r\n\r\n    do i = 1, size(x)\r\n       k = x(i)\r\n       bincount(k) = bincount(k) + 1\r\n    end do\r\n  end function bincount\r\n"}, {"instruction": "Create a Fortran function named cumsum_i to calculate the cumulative sum of an array of integers. The function takes 1 input parameter of type integer array with unspecified size, and returns 1 output parameter of type integer array with the size equal to the input array.", "input": "", "output": "  function cumsum_i(x) result (cumsum)\r\n    integer, dimension(:), intent(in) :: x\r\n    integer, dimension(size(x)) :: cumsum\r\n\r\n    integer :: i\r\n\r\n    cumsum(1) = x(1)\r\n    do i = 2, size(x)\r\n       cumsum(i) = cumsum(i - 1) + x(i)\r\n    end do\r\n  end function cumsum_i\r\n"}, {"instruction": "Create a Fortran function named l to find the index of the first positive integer in an array up to a specified position. The function takes 2 input arguments of type 'integer, dimension(:)' and 'integer'. The output is a single integer.", "input": "", "output": "function l(a,j)\n  implicit none\n\n  integer, dimension(:), intent(in) :: a\n  integer :: l,j,i,k\n\n  do i=1,j\n    k=a(i)\n    if (k>0) exit\n  end do\nl=i\nend function l\n"}, {"instruction": "Create a Fortran function named get_len that takes a single input argument of type character(len=*) and returns an integer. This function calculates the length of the input string and returns the result as an integer.", "input": "", "output": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    get_len = 0\n    do while (string(get_len+1:get_len+1)/=' ')\n      get_len = get_len+1\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named equalto to compare two double precision floating-point numbers for approximate equality. The function takes 3 input parameters of type double precision, where the third parameter is optional. The output is a logical value indicating whether the two numbers are approximately equal.", "input": "", "output": "function equalto(a, b, abs_tol) result(equal_to)\n    !> check if two floats are almost equal.\n    !> a - first float.\n    !> b - other float.\n    !> abs_tol - absolute toleranace.\n    \n    ! input\n    double precision, intent(in) :: a, b\n    double precision, intent(in), optional :: abs_tol\n    \n    ! output\n    logical :: equal_to\n    \n    ! working\n    double precision :: atol, diff\n    \n    ! in case they are exact.\n    if (a .eq. b) then\n        equal_to = .true.\n        return\n    end if\n    \n    ! set defaults.\n    atol = 1.0d-8\n    if (present(abs_tol)) then\n        atol = abs_tol\n    end if\n    \n    diff = dabs(b - a)\n    ! absolute comparison.\n    if (diff .le. atol) then\n        equal_to = .true.\n        return\n    end if\n    equal_to = .false.\nend function equalto\n"}, {"instruction": "Create a Fortran function named replace_text to replace all occurrences of a specified text within a string with another text. The function takes 3 input arguments of type character(*), representing the original string, the text to be replaced, and the replacement text. It returns 1 output argument of type character(len=len(str)) which holds the modified string.", "input": "", "output": "   function replace_text(str, text, rep) result(outs)\n      character(*) :: str, text, rep\n      character(len=len(str)) :: outs\n      integer :: i, nt, nr\n\n      outs = str\n      nt = len_trim(text)\n      nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt))\n         if (i == 0) exit\n         outs = outs(:i-1) // rep(:nr) // outs(i+nt:)\n      end do\n   end function replace_text\n"}, {"instruction": "Create a Fortran function called smoothstep1 that takes a single real input argument. The function returns a single real output, computed as x*x*(3-2*x). The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "  pure function smoothstep1 (x)\n    implicit none\n    real :: smoothstep1\n    real, intent (in) :: x\n    smoothstep1 = x*x*(3-2*x)\n  end function smoothstep1\n"}, {"instruction": "Create a Fortran function named pascaltriangle that calculates a specific value in Pascal's triangle based on the provided inputs. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  pure function pascaltriangle (a,b)\n    implicit none\n    integer :: pascaltriangle\n    integer, intent (in) :: a,b\n    integer i\n    pascaltriangle = 1\n    do i = 0, b-1\n      pascaltriangle = pascaltriangle*(a-i)/(i+1)\n    end do\n  end function pascaltriangle\n"}, {"instruction": "Create a Fortran function named random_int to generate a random integer within a specified range. The function should have 2 input parameters of type integer, value, and the test_data type is ['integer ,value', 'integer ,value']. The function should have 1 output parameter of type integer, and the test_data type is ['integer'].", "input": "", "output": "    function random_int(from_val, to_val) result(r_int)\n        implicit none\n        integer ,value :: from_val, to_val\n        integer ::  r_int\n        real :: r\n        \n        call random_number(r)\n        r_int = int(from_val + r*(to_val - from_val))\n    end function random_int\n"}, {"instruction": "Create a Fortran function named notinlist to determine if an integer value is not present in an array of integers. The function takes 3 input parameters: two integers and an array of integers with dimension n. The output parameter is a logical value. If the integer is not found in the array, the logical value is set to true; otherwise, it is set to false.", "input": "", "output": "  function notinlist(l,p,n) result(notinit)\r\n    integer  :: l,n\r\n    integer, dimension(n) :: p\r\n\r\n    logical  :: notinit\r\n\r\n    integer  :: i\r\n\r\n    notinit = .true.\r\n    if (n.eq.0) then\r\n        notinit = .true.\r\n    else\r\n        do i = 1,n\r\n            if (p(i).eq.l) notinit = .false.\r\n        end do\r\n    end if\r\n\r\n  end function notinlist\r\n"}, {"instruction": "Create a Fortran function named io_str_get_num_tokens to count the number of tokens in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function io_str_get_num_tokens(str)\n  implicit none\n\n  integer                       ::  io_str_get_num_tokens\n  character(len=*), intent(in)  ::  str\n\n  character(len=1), parameter ::  space = ' '\n  integer ::  i, j, strlen\n\n  ! if we assume that we have used str_shrink before then we can just count the spaces..\n  strlen = len_trim(str)\n  io_str_get_num_tokens = 1 ! always n-1 spaces to n tokens\n  i = 1 ! get into loop\n  j = 1\n  do while (i .gt. 0)\n    i = index(str(j:strlen), space)\n    j = j+i\n    if (i .gt. 0) io_str_get_num_tokens = io_str_get_num_tokens + 1\n  end do\nend function io_str_get_num_tokens\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_animation_new_from_stream to create a new animation from a stream. The function takes 3 input parameters of type 'type(c_ptr), value' for the stream, cancellable, and error. It returns 1 output parameter of type 'type(c_ptr)'.", "input": "", "output": "function gdk_pixbuf_animation_new_from_stream(stream, cancellable, error) bind(&\n&c) \n  use iso_c_binding, only: c_ptr\n  type(c_ptr) :: gdk_pixbuf_animation_new_from_stream\n  type(c_ptr), value :: stream\n  type(c_ptr), value :: cancellable\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_scale_simple that takes 4 input parameters of type c_ptr, integer(c_int), integer(c_int), and integer(c_int) as values. The function returns a single output parameter of type c_ptr. This function is intended to scale a GDK Pixbuf image to the specified width and height using the specified interpolation type.", "input": "", "output": "function gdk_pixbuf_scale_simple(src, dest_width, dest_height, interp_type) bin&\n&d(c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: gdk_pixbuf_scale_simple\n  type(c_ptr), value :: src\n  integer(c_int), value :: dest_width\n  integer(c_int), value :: dest_height\n  integer(c_int), value :: interp_type\nend function\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_new_from_inline to interface with C code. The function takes 4 input parameters of types integer(c_int), type(c_ptr), integer(c_int), and type(c_ptr) as specified. The output is a single parameter of type type(c_ptr).", "input": "", "output": "function gdk_pixbuf_new_from_inline(data_length, data, copy_pixels, error) bind&\n&(c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: gdk_pixbuf_new_from_inline\n  integer(c_int), value :: data_length\n  type(c_ptr), value :: data\n  integer(c_int), value :: copy_pixels\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named toupper, which converts all lowercase letters in a given string to uppercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(str)).", "input": "", "output": "elemental function toupper(str)\n!! ascii letters to uppercase\ncharacter(*), intent(in) :: str\ncharacter(len(str)) :: toupper\ncharacter(*), parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\", &\n                            upper=\"abcdefghijklmnopqrstuvwxyz\"\ninteger :: i,j\n\ntoupper = str\n\n!do concurrent (i = 1:len(str))  ! fixme: flang\ndo i = 1,len(str)\n  j = index(lower,str(i:i))\n  if (j > 0) toupper(i:i) = upper(j:j)\nend do\n\nend function toupper\n"}, {"instruction": "Create a Fortran function named cyc to determine if the iterator is a multiple of the cycle_size. The function should take 2 input arguments of type integer, and the test_data type should be ['integer', 'integer']. It should return 1 output argument of type logical, and the test_data type should be ['logical'].", "input": "", "output": "    function cyc(iterator,cycle_size)\n        implicit none\n        integer, intent(in) :: iterator\n        integer, intent(in) :: cycle_size\n        logical :: cyc\n\n        if(cycle_size<=0) then\n            cyc = .false.\n        else\n            cyc = mod(iterator,cycle_size)==0\n        end if\n\n    end function cyc\n"}, {"instruction": "Create a Fortran function named func to increment the input integer by one. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function should be used with the imperative tone.", "input": "", "output": "    function func (n) result (rc)\n    !$acc routine\n    integer, intent (in) :: n\n    integer :: rc\n\n    rc = n\n    rc = rc + 1\n\n    end function\n"}, {"instruction": "Create a Fortran function named curl_easy_perform to execute a single transfer with the given handle. The function takes 1 input parameter of type c_ptr and returns 1 output parameter of type integer(c_int).", "input": "", "output": "     function curl_easy_perform(handle) &\n          bind(c, name=\"curl_easy_perform\")\n       use iso_c_binding, only: c_int, c_ptr\n       type(c_ptr), value :: handle\n       integer(c_int) :: curl_easy_perform\n     end function curl_easy_perform\n"}, {"instruction": "Create a Fortran function named lacz_gamma to calculate the gamma function of a given real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    ! these precomputed values are taken by the sample code in wikipedia,\n    ! and the sample itself takes them from the gnu scientific library\n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n"}, {"instruction": "Write a Fortran function named strcmp that compares two strings and returns an integer value. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function strcmp(string1, string2)\n    !\n    ! compares two strings, a-la c\n    !\n    integer :: strcmp\n    character(*) :: string1\n    character(*) :: string2\n\n    if (lgt(trim(string1), trim(string2))) then\n       strcmp = 1\n    else if (lgt(trim(string2), trim(string1))) then\n       strcmp = -1\n    else\n       strcmp = 0\n    end if\n  end function strcmp\n"}, {"instruction": "Create a Fortran function called true2 that takes in 4 input parameters of type double precision, double precision, integer, and integer. The function should return a single output of type double precision. The function computes the value of (1-x)^5 + y^5 and assigns it to the output variable true2.", "input": "", "output": "function true2(x,y,comp,eigen)\nimplicit none\ndouble precision, intent(in) :: x,y\ninteger, intent(in) :: comp,eigen\ndouble precision :: true2\ntrue2 = (1-x)**5 + y**5\nend function true2\n"}, {"instruction": "Write a recursive Fortran function named ackermann to calculate the Ackermann function. The function takes 2 input parameters, both of type integer, and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  recursive function ackermann(m, n) result(ack)\n    integer :: ack, m, n\n\n    if (m == 0) then\n      ack = n + 1\n    else if (n == 0) then\n      ack = ackermann(m - 1, 1)\n    else\n      ack = ackermann(m - 1, ackermann(m, n - 1))\n    end if\n  end function ackermann\n"}, {"instruction": "Write a Fortran function named \"wr\" to calculate the value of \"wr\" based on the input parameter \"nr\", which is of type real(8). The function should return a real(8) value.", "input": "", "output": "pure function wr(nr)\n    real(8), intent(in) :: nr\n    real(8) :: wr\n    wr = 0.0\n    if (nr <= 1.0) then\n        wr = 1.0 - nr\n    endif\nend function\n"}, {"instruction": "Create a Fortran function named freefall to calculate the velocity of an object in free fall from a given height. The function should take 1 input parameter of type real and return 1 output parameter of type real. The input parameter represents the height from which the object is falling, and the output parameter represents the velocity of the object in free fall. Use the formula: velocity = square root of (2 * g * height), where g is the gravitational acceleration. Remember to use the \"return\" statement to return the computed velocity.", "input": "", "output": "function freefall(high)\r\n\timplicit none\r\n\treal,parameter :: g = 9.80665\r\n    real :: high\r\n\treal :: freefall\r\n\tfreefall = (2 * g * high) ** 0.5\r\n\treturn\r\nend function\r\n"}, {"instruction": "Create a Fortran function named circarea to calculate the area of a circle based on the provided radius. The function takes 1 input parameter of type real and returns 1 output parameter of type real. Use the formula area = pi * radius * radius to calculate the area.", "input": "", "output": "  function circarea(radius) result(area)\n    real,intent(in)::radius\n    real::area\n    \n    area = pi * radius * radius\n    return\n  end function circarea\n"}, {"instruction": "Create a Fortran function named circperi to calculate the circumference of a circle. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter represents the radius of the circle, and the output parameter stores the calculated circumference.", "input": "", "output": "  function circperi(radius) result(circumference)\n    real,intent(in)::radius\n    real::circumference\n    \n    circumference = 2 * pi * radius\n    return\n  end function circperi\n"}, {"instruction": "Create a Fortran function named trs2a2 that takes in 5 input parameters: two real matrices of dimensions 1:m, an integer j, an integer k, and an integer m. The function returns a real matrix of dimensions 1:m. The function calculates an intermediate transition matrix starting from k without descending below j, using the formula r = iju(i-ik)dij, with ii = deltajj, where j >= i. The function uses nested loops to perform the computation and assigns the result to the output matrix trs2a2.", "input": "", "output": "      function trs2a2 (j, k, u, d, m)\n!      matrice de transition intermediaire, partant de k sans descendre\n!      sous j. r = iju(i-ik)dij, avec ii = deltajj, j >= i.\n!      alternative: trs2a2 = 0\n!                   trs2a2 (j:k-1, j:k-1) = matmul (utrsft (j:k-1,j:k-1),\n!                                                   dtrsft (j:k-1,j:k-1))\n!\n      real, dimension (1:m,1:m) :: trs2a2  ! resultat\n      real, dimension (1:m,1:m) :: u, d    ! matrices utrsft, dtrsft\n      integer, intent (in)      :: j, k, m ! niveaux vallee pic\n!\n!##### following line replaced by prentice to make less system dependent\n!      real (kind = kind (1.0d0)) :: dtmp\n      real (kind = selected_real_kind (10,50)) :: dtmp\n!\n      trs2a2 = 0.0\n      do iclw1 = j, k - 1\n         do iclw2 = j, k - 1\n            dtmp = 0.0d0\n            do iclww = j, k - 1\n               dtmp = dtmp + u (iclw1, iclww) * d (iclww, iclw2)\n            enddo\n            trs2a2 (iclw1, iclw2) = dtmp\n         enddo\n      enddo\n      return\n      end function trs2a2\n"}, {"instruction": "Create a Fortran function named is_leap_year to determine if a given year is a leap year. The function takes 2 input parameters, an integer \"year\" and an optional logical \"has_error\". The output is a logical value indicating whether the input year is a leap year.", "input": "", "output": "    function is_leap_year(year, has_error) result(is_leap)\n        implicit none\n        integer, intent(in) :: year\n        logical, optional, intent(out) :: has_error\n        logical :: is_leap\n\n        if (present(has_error)) then\n            has_error = year <= 1582\n        end if\n        if (mod(year, 4) == 0) then\n            if (mod(year, 100) == 0) then\n                if (mod(year, 400) == 0) then\n                    is_leap = .false.\n                else\n                    is_leap = .true.\n                end if\n            else\n                is_leap = .true.\n            end if\n        else\n            is_leap = .false.\n        end if\n    end function is_leap_year\n"}, {"instruction": "Create a Fortran function named aave to calculate the area mean of a two-dimensional real array in Cartesian coordinates. This function should have 1 input parameter of type real, dimension(:,:), and intent(in), and 1 output parameter of type real.", "input": "", "output": "function aave(f) result(res)\n  !   calculation of area mean (res) of field f in cartesian coordinates.\n  !   simplest possible way.\n  !\n  real,dimension(:,:),intent(in) :: f\n  real :: res,sum,wsum\n  integer :: i,j,nlon,nlat\n  nlon=size(f,1)\n  nlat=size(f,2)\n\n  sum=0\n  wsum=0\n  do j=1,nlat\n     do i=1,nlon\n        sum=sum+f(i,j)\n        wsum=wsum+1.\n     enddo\n  enddo\n  res=sum/wsum\n\nend function aave\n"}, {"instruction": "Write a Fortran function named p2der that estimates the second pressure derivatives of a three-dimensional real array at different levels. The function takes 2 input parameters of type real, dimension(:,:,:), and real, and returns 1 output parameter of type real, dimension(:,:,:), allocatable.", "input": "", "output": "function p2der(f,dp) result(df2dp2)\n  !   estimation of second pressure derivatives.\n  !   at top and bottom levels, these are set to zero\n  !\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),allocatable :: df2dp2\n  real,intent(in) :: dp\n  integer :: nlon,nlat,nlev,c,k\n\n  nlon=size(f,1)\n  nlat=size(f,2)\n  nlev=size(f,3)\n  allocate(df2dp2(nlon,nlat,nlev))\n  c=1\n  select case(c)\n\n  case(1)\n     df2dp2(:,:,2:nlev-1)=(f(:,:,3:nlev)+f(:,:,1:nlev-2) &\n          -2*f(:,:,2:nlev-1))/(dp*dp)\n     df2dp2(:,:,1)=0.\n     df2dp2(:,:,nlev)=0.\n  case(2)\n     do k=3,nlev-2\n        df2dp2(:,:,k)=(-1./12.)*f(:,:,k-2)+(4./3.)*f(:,:,k-1)&\n             -(5./2.)*f(:,:,k)+(4./3.)*f(:,:,k+1)-(1./12.)*f(:,:,k+2)\n        df2dp2(:,:,k)=df2dp2(:,:,k)/(dp*dp)\n     enddo\n     df2dp2(:,:,2)=(f(:,:,3)+f(:,:,1)-2.*f(:,:,2))/(dp*dp)\n     df2dp2(:,:,nlev-1)=(f(:,:,nlev)+f(:,:,nlev-2)-2.*f(:,:,nlev-1))/(dp*dp)\n     df2dp2(:,:,1)=0.\n     df2dp2(:,:,nlev)=0.\n  end select\nend function p2der\n"}, {"instruction": "Create a Fortran function named binomial to calculate the binomial coefficient using the given input parameters. The number of input arguments is 2, and the test_data type is ['integer(kind=16)', 'integer(kind=16)']. The number of output arguments is 1, and the test_data type is ['integer(kind=16)'].", "input": "", "output": "  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named nextdiffid that takes 3 input parameters: an integer, an array of real numbers with dimension n, and a logical array with dimension n. The function returns an integer representing the position of the minimum value in the input array, excluding the elements marked as 'true' in the logical array.", "input": "", "output": "function nextdiffid(dist,n,checksecondary)\n! find the minimum value in dist skipping the vertex checked yet and returns\n! its position (id)\n\n  integer :: nextdiffid,n\n  real, dimension(n) :: dist\n  logical, dimension(n) :: checksecondary\n\n  integer :: i\n  real :: vmin\n\n  nextdiffid=0\n  vmin=infinity\n  do i=1,n\n     if (checksecondary(i)) cycle\n     if (dist(i) < vmin) then\n        vmin=dist(i)\n        nextdiffid=i\n     endif\n  enddo\n  return\nend function nextdiffid\n"}, {"instruction": "Create a Fortran function named dplane that computes the position of a point in a plane based on geometric calculations. The function takes 5 input parameters of type real: d12, d13, d23, r1, r2, and returns 1 output parameter of type real.", "input": "", "output": "function dplane(d12,d13,d23,r1,r2)\n\n  real :: dplane,d12,d13,d23,r1,r2\n\n  real :: x,y,xc,yc\n  real :: dr,xn,yn,dn,d13n,d23n\n\n! position of v3\n  x=(d12**2-d23**2+d13**2)/(2*d12)\n  y=sqrt(max(d13**2-x**2,0.))\n! difference of distance at the base\n  dr=abs(r1-r2)\n! computation of the new base length\n  dn=sqrt(d12**2.-dr**2.)\n  if (r1 < r2) then\n! case where v2 remains and v1 is changed\n     xn=(d12**2-dn**2+dr**2)/(2*d12)\n     yn=(sqrt(max(dr**2-xn**2,0.)))\n     d13n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23**2+d13n**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13n**2-x**2,0.))\n        dplane=r2+y\n     else\n        dplane=infinity\n     endif\n  else\n! case where v1 remains and v2 is changed\n     xn=(d12**2-dr**2+dn**2)/(2*d12)\n     yn=(sqrt(max(dn**2-xn**2,0.)))\n     d23n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23n**2+d13**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13**2-x**2,0.))\n        dplane=r1+y\n     else\n        dplane=infinity\n     endif\n  endif\nend function dplane\n"}, {"instruction": "Create a Fortran function named strip_comments that takes two input arguments of type character(len=*) and character(len=1) and returns one output argument of type character(len=len(str)). The function removes any comments indicated by the specified comment character from the input string and returns the modified string.", "input": "", "output": "\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c !comment character\n\t character(len=len(str)) :: str2\n\t\n\t integer :: i\n\t\n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t\n\t end function strip_comments\n"}, {"instruction": "Create a Fortran function named std that calculates the standard deviation for each row of a 2D array of real(8) numbers. The function takes 2 input parameters: a 2D array of real(8) numbers with unspecified dimensions and an integer representing the number of columns. It returns 1 output parameter, a 1D array of real(8) numbers with a size equal to the number of rows in the input array.", "input": "", "output": "    function std(x, n)\n        real(8), dimension(:,:), intent(in) :: x\n        integer, intent(in) :: n\n        real(8), dimension(n) :: std\n        real(8), dimension(n) :: mean\n        integer :: s, i\n        s = size(x, 2)\n        do i=1,n\n            mean(i) = sum(x(i,:)) / s\n            std(i) = sqrt(sum((x(i,:) - mean(i))**2)) / s\n        end do\n    end function std\n"}, {"instruction": "Create a Fortran function named arg that takes an integer input argument and returns an allocatable character string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable']. This function retrieves a command line argument based on the input integer index and assigns it to the allocatable character string.", "input": "", "output": "    function arg(i)\n        integer, intent(in) :: i\n        character(len=:), allocatable :: arg\n        integer :: len\n\n        call get_command_argument(i, arg, len)\n        allocate(character(len=len) :: arg)\n        call get_command_argument(i, arg, len)\n    end function\n"}, {"instruction": "Create a Fortran function named findface to determine the face of a unit cube that a given point (x, y, z) lies on. The function takes 3 input arguments of type double precision (x, y, z) and returns 1 output argument of type integer (face) indicating the face of the cube that the point lies on.", "input": "", "output": "  function findface(x, y, z) result(face)\r\n  implicit none\r\n  doubleprecision,intent(in) :: x, y, z\r\n  integer :: face\r\n  \r\n  face = 0\r\n  if(x .eq. 0.0d0) then\r\n      face = 1\r\n  else if(x .eq. 1.0d0) then\r\n      face = 2\r\n  else if(y .eq. 0.0d0) then\r\n      face = 3\r\n  else if(y .eq. 1.0d0) then\r\n      face =4\r\n  else if(z .eq. 0.0d0) then\r\n      face = 5\r\n  else if(z .eq. 1.0d0) then\r\n      face = 6\r\n  end if\r\n  \r\n  end function findface\r\n"}, {"instruction": "Create a Fortran function named area to calculate the area of a triangle using the given three sides. The function should have 3 input parameters of type real, and the test_data type is ['real', 'real', 'real']. It should have 1 output parameter of type real, and the test_data type is ['real'].", "input": "", "output": "function area(x, y, z) result(res)\n    implicit none\n    real :: res\n    real, intent(in) :: x, y, z\n    real :: theta, height\n    theta = acos((x**2 + y**2 - z**2)/(2.0*x*y))\n    height = x*sin(theta)\n    res = 0.5*y*height\nend function area\n"}, {"instruction": "Write a Fortran function named frind that takes 3 integer arguments as input, denoted as i, j, and n. The function calculates a result of type integer and returns it. The input arguments are of type integer, and the output parameter is also of type integer.", "input": "", "output": "function frind(j,i,n) result(res)\n  implicit none\n\n  integer, intent(in) :: i,j,n\n  integer :: res\n\n  res = i + (j-1)*(2*n - j)/2\n\nend function frind\n"}, {"instruction": "Write a Fortran function named dot_product_arr to calculate the dot product of two arrays of double-precision real numbers. The function takes 2 input arguments of type real(kind=8), dimension(:,:), and returns 1 output argument of type real(kind=8), dimension(size(a,1)).", "input": "", "output": "       pure function dot_product_arr(a,b) result(dot)\n       real(kind=8), dimension(:,:), intent(in) :: a,b\n       real(kind=8), dimension(size(a,1)) :: dot\n       integer :: i\n       dot=0d0\n       do i=1,size(a,2); dot=dot+a(:,i)*b(:,i); enddo\n       end function dot_product_arr\n"}, {"instruction": "Create a Fortran function named cum_sum to calculate the cumulative sum of an array up to a specified index. The function takes 2 input parameters of type real(kind=8), dimension(:) and integer, and returns 1 output parameter of type real(kind=8), dimension(size(x)).", "input": "", "output": "       function cum_sum(x,cumu)\n       real(kind=8), intent(in), dimension(:) :: x\n       real(kind=8), dimension(size(x)) :: cum_sum\n       integer :: i\n       integer, intent(in) :: cumu\n       do i=1,size(x)\n         cum_sum(i)=sum(x(1:i))\n       enddo\n       end function cum_sum\n"}, {"instruction": "Create a Fortran function named std to calculate the standard deviation of a list of real numbers. The function should take 2 input parameters, where the first parameter is an integer and the second parameter is an array of real numbers. The output should be a single real number representing the standard deviation. Remember to use real,dimension(n) to indicate that the second input parameter is an array of real numbers with a length specified by the first input parameter.", "input": "", "output": "function std(list,n)\nimplicit none\n!--\ninteger               :: n\nreal,dimension(n)     :: list\n!--\ninteger               :: i\nreal                  :: var,std,mean\n!--\nvar=0.0d0\nmean=sum(list)/(real(n)+1.0e-20)\n!--\ndo i=1, n\n    var=var+(list(i)-mean)**2\nend do\n!--\nstd=sqrt((var)/(real(n)+1.0e-20))\n!--\nreturn\nend function\n"}, {"instruction": "Write a Fortran function named cov to calculate the covariance between two sets of data. The function takes 3 input parameters: an integer n, and two arrays of real numbers x and y, both of size n. The function returns a single real number as the output, representing the covariance. Remember to use the imperative tone for the instructions.", "input": "", "output": "function cov(x,y,n)\nimplicit none\n!--\ninteger                :: n\nreal,dimension(n)      :: x,y\nreal                   :: cov\n!--\nreal                   :: x_mean,y_mean\nreal                   :: c\ninteger                :: i\n!--\nx_mean=sum(x)/(real(n)+1.0e-20)\ny_mean=sum(y)/(real(n)+1.0e-20)\n!--\nc=0.0d0\n!--\ndo i=1,n\n    c=c+(x(i)-x_mean)*(y(i)-y_mean)\nend do\ncov=c/((n-1)+1.0e-20)\n!--\nreturn\n!--\nend function cov\n"}, {"instruction": "Create a Fortran function named predicate to determine if a triangle with side lengths represented by integer inputs is a Pythagorean triple. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  pure function predicate(a,b,c)\n    implicit none\n    integer, intent(in) :: a,b,c\n    real*16             :: path1,path2,path3,best_path\n    logical             :: predicate\n\n    path1=sqrt(dble((a+b)**2 + c**2))\n    path2=sqrt(dble((a+c)**2 + b**2))\n    path3=sqrt(dble((b+c)**2 + a**2))\n    best_path=min(path1,min(path2,path3))\n\n    predicate=(mod(best_path,1.0)==0.0)\n    \n  end function predicate\n"}, {"instruction": "Create a Fortran function named foo that takes an integer input argument. The function should return an array of integers of the same length as the input argument. The input argument type should be integer(4), and the output argument type should be integer(4), allocatable, dimension(:).", "input": "", "output": "  function foo (n) result(res)\n    integer(4), allocatable, dimension(:) :: res\n    integer(4) :: n\n    allocate (res(n))\n    res = [((i + 15), i = 1, n)]\n  end function foo\n"}, {"instruction": "Write a Fortran function named fomp_get_ancestor_thread_num that takes one integer input parameter. The function returns an integer value and is intended to obtain the thread number of the ancestor at a specified level.", "input": "", "output": "function fomp_get_ancestor_thread_num(level)\n\n    implicit none\n\n    !f2py threadsafe\n\n    integer, intent(in) :: level\n    integer :: fomp_get_ancestor_thread_num\n    if (.false.) print *, level\n\n    fomp_get_ancestor_thread_num = -1\n\nend function fomp_get_ancestor_thread_num\n"}, {"instruction": "Create a Fortran function named dot that calculates the dot product of two vectors. The function takes 3 input parameters: an integer*4, an array of real*8 with dimension n, and another array of real*8 with dimension n. The output parameter is a real*8.", "input": "", "output": "function dot(a,b,n)\n  ! compute the dot product of a and b\n    implicit none\n    real*8 :: dot ! return  value\n  !-----------------------------------------------\n\n    integer*4              , intent(in)    :: n\n    real*8   , dimension(n), intent(in)    :: a,b\n  !-----------------------------------------------\n  ! declare local variables\n    integer*4 :: i\n  !-----------------------------------------------'\n    dot = 0.\n    do i=1,n\n        dot = dot + a(i) * b(i)\n    end do\nend function dot\n"}, {"instruction": "Create a Fortran function named sameedgedifferentpolygon to compare edges of different polygons. The function takes 4 input parameters of types integer, integer, real(kind(0d0)),dimension(0:3,3,96), and real(kind(0d0)),dimension(0:3,3,96). The output parameter is of type logical. The function checks if the edges of two polygons are the same and returns a logical value.", "input": "", "output": "   function sameedgedifferentpolygon(j,i,edge,edge2) result (sedp)\n\n     implicit none\n     logical :: sedp\n     integer :: j,i\n     real(kind(0d0)),dimension(0:3,3,96) :: edge, edge2\n\n     sedp = all(edge(:,1:2,j).eq.edge2(:,1:2,i)).or.     &\n            (all(edge(:,1,j).eq.edge2(:,2,i)).and.         &\n             all(edge(:,2,j).eq.edge2(:,1,i)))\n\n   end function sameedgedifferentpolygon\n"}, {"instruction": "Write a Fortran function named nextedgesamepolygon to compare two sets of edges from polygons. The function takes 4 input parameters of type integer, integer, real(kind(0d0)),dimension(0:3,3,96), and real(kind(0d0)),dimension(0:3,3,96). The output is a single logical value.", "input": "", "output": "   function nextedgesamepolygon(j,i,edge,edge2) result (nesp)\n\n     implicit none\n     logical :: nesp\n     integer :: j,i\n     real(kind(0d0)),dimension(0:3,3,96) :: edge, edge2\n\n     nesp = ((all(edge(:,1,j).eq.edge2(:,1,i)).or.       &\n              all(edge(:,1,j).eq.edge2(:,2,i))).and.       &\n             all(edge(:,3,j).eq.edge2(:,3,i)))\n\n   end function nextedgesamepolygon\n"}, {"instruction": "Write a Fortran function named \"istep\" to compute the Heaviside step function for a given real(8) input value. The number of input arguments is 1, and the test_data type is [real(8)]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "  elemental function istep(x) result(out)\n    real(8),intent(in) :: x\n    real(8)            :: out\n    if(x < 0.d0) then\n       out = 1.0d0\n    elseif(x==0.d0)then\n       out = 0.50d0\n    else\n       out = 0.0d0\n    endif\n  end function istep\n"}, {"instruction": "Create a Fortran function called random_normal that generates a random number from a normal distribution with a given mean and standard deviation. The function should have 2 input parameters of type real(8) for mean and standard deviation, and 1 output parameter of type real(8) for the generated random number.", "input": "", "output": "  function random_normal(mean,stdev) result(c)\n\n    real(8), intent(in) :: mean,stdev\n    real(8)             :: c, r, theta\n    real(8)             :: temp(2)\n    real(8), parameter  :: pi = 4.d0*datan(1.d0)\n\n    call random_number(temp)\n\n    r = (-2.0d0*log(temp(1)))**0.5    \n    theta = 2.0d0*pi*temp(2)\n\n    c = mean+stdev*r*sin(theta)\n\n  end function random_normal\n"}, {"instruction": "Create a Fortran function named generate_rand_int that returns a random integer within a specified range. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument specifies the upper limit of the range from which the random integer will be generated.", "input": "", "output": "  function generate_rand_int(out_of)\n\n    implicit none\n    integer, parameter :: dp=selected_real_kind(15,300)\n    real(kind=dp) :: rand\n    integer :: generate_rand_int\n    integer :: out_of\n\n    call random_number(rand)\n    generate_rand_int=ceiling(real(out_of,dp)*rand)\n\n  end function generate_rand_int\n"}, {"instruction": "Create a Fortran function named map2d that takes an integer and an array of real(8) numbers as input. The number of input arguments is 2 and the test_data type is ['integer', 'real(8), dimension(:)']. The function should output a 3x3 array of real(8) numbers. The number of output arguments is 1 and the test_data type is ['real(8), dimension(1:3,1:3)']. The function reshapes the input array and populates the 3x3 array based on specific calculations.", "input": "", "output": "      function map2d(a,ntens)\n        implicit none\n        real(8),  dimension(1:3,1:3) :: map2d\n        integer, intent(in) :: ntens\n        real(8), intent(in), dimension(:) :: a\n        real(8),dimension(1:6) :: b = 0\n        b(1:ntens) = a(1:ntens)\n        map2d = reshape( [b(1), b(4)/2, b(5)/2, &\n               b(4)/2,b(2),b(6)/2, b(5)/2,b(6)/2, b(3)],[3,3] )\n      end function map2d\n"}, {"instruction": "Create a Fortran function named map2stress that takes a 3x3 array of real(8) numbers and an integer as input. The number of input arguments is 2, and the test_data type is ['real(8), dimension(1:3,1:3)', 'integer']. The function returns a 1D array of real(8) numbers with a length specified by the input integer. The number of output arguments is 1, and the test_data type is ['real(8), dimension(1:ntens)']. The function calculates the stress components from the input 3x3 array and returns the specified number of stress components.", "input": "", "output": "      function map2stress(a,ntens)\n        implicit none\n        real(8), intent(in), dimension(1:3,1:3) :: a\n        integer, intent(in) :: ntens\n        real(8),  dimension(1:ntens) :: map2stress\n        real(8), dimension(1:6) :: b\n        b = [a(1,1),a(2,2),a(3,3),a(1,2),a(1,3),a(2,3)]\n        map2stress = b(1:ntens)\n      end function map2stress\n"}, {"instruction": "Create a Fortran function named map2t that takes an integer and an array of real(8) as input, and returns a 3x3 array of real(8). The input parameters should be of type integer and real(8) array, while the output parameter should be a 3x3 array of real(8). The function should reshape the input array and assign specific elements of it to a new array, which is then reshaped into a 3x3 array and returned.", "input": "", "output": "      function map2t(a,ntens)\n        implicit none\n        real(8),  dimension(1:3,1:3) :: map2t\n        integer, intent(in) :: ntens\n        real(8), intent(in), dimension(:) :: a\n        real(8), dimension(1:6) :: b= 0\n        b(1:ntens) = a(1:ntens)\n        map2t = reshape( [b(1),b(4),b(5), &\n            b(4),b(2),b(6),  b(5),b(6),b(3) ],[3,3] )\n      end function map2t\n"}, {"instruction": "Write a Fortran function named inv33 to calculate the inverse of a 3x3 matrix. The function should take one input parameter of type real(8), dimension(3,3) and return one output parameter of type real(8), dimension(3,3).", "input": "", "output": "      function inv33( a )  !==================contained in get_increment\n      implicit none\n      real(8), dimension(3,3), intent(in) :: a\n      real(8), dimension(3,3) :: b\n      real(8), dimension(3,3) :: inv33\n      real(8) :: det\n      det = - a(1,3)*a(2,2)*a(3,1) + a(1,2)*a(2,3)*a(3,1) + &\n               a(1,3)*a(2,1)*a(3,2) - a(1,1)*a(2,3)*a(3,2) - &\n               a(1,2)*a(2,1)*a(3,3) + a(1,1)*a(2,2)*a(3,3)\n      b= reshape( &\n         [-a(2,3)*a(3,2)+ a(2,2)*a(3,3), a(1,3)*a(3,2)-a(1,2)*a(3,3), &\n        -a(1,3)*a(2,2) + a(1,2)*a(2,3),  a(2,3)*a(3,1)- a(2,1)*a(3,3), &\n        -a(1,3)*a(3,1) + a(1,1)*a(3,3),  a(1,3)*a(2,1)- a(1,1)*a(2,3), &\n        -a(2,2)*a(3,1)  + a(2,1)*a(3,2), a(1,2)*a(3,1)- a(1,1)*a(3,2), &\n       -a(1,2)*a(2,1) + a(1,1)*a(2,2)]    ,[3,3]    )\n      inv33 = transpose(b)/det\n      end function inv33\n"}, {"instruction": "Write a Fortran function named cross_product that takes two 3-dimensional arrays of double precision numbers as input and returns a 3-dimensional array of double precision numbers as output. The input parameters should have the \"intent(in)\" attribute. The function calculates the cross product of the two input arrays and stores the result in the output array.", "input": "", "output": "\tpure function cross_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3) :: cross_product\n\t\t\n\t\tcross_product(1) = a(2) * b(3) - a(3) * b(2)\n\t\tcross_product(2) = a(3) * b(1) - a(1) * b(3)\n\t\tcross_product(3) = a(1) * b(2) - a(2) * b(1)\n\t\t\n\tend function cross_product\n"}, {"instruction": "Create a Fortran function named tensor_product to calculate the tensor product of two input arrays. The function takes 2 input parameters of type double precision, dimension (3) and returns 1 output parameter of type double precision, dimension (3, 3).", "input": "", "output": "\tpure function tensor_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3, 3) :: tensor_product\n\t\tinteger :: i, j\n\t\t\n\t\tdo i = 1, 3\n\t\t\tdo j = 1, 3\n\t\t\t\ttensor_product (i, j) = a (i) * b (j)\n\t\t\tend do\n\t\tend do\n\t\t\n\tend function tensor_product\n"}, {"instruction": "Create a Fortran function named skew that takes in a 3-element array of double precision as input. The function should return a 3x3 array of double precision. The purpose of this function is to generate a skew-symmetric matrix based on the input array.", "input": "", "output": "\tpure function skew (r)\n\t\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: r\n\t\tdouble precision, dimension (3, 3) :: skew\n\t\t\n\t\tskew (1, 1) = 0.0d0\n\t\tskew (1, 2) = - r (3)\n\t\tskew (1, 3) = r (2)\n\t\tskew (2, 1) = r (3)\n\t\tskew (2, 2) = 0.0d0\n\t\tskew (2, 3) = - r (1)\n\t\tskew (3, 1) = - r (2)\n\t\tskew (3, 2) = r (1)\n\t\tskew (3, 3) = 0.0d0\n\t\t\n\tend function skew\n"}, {"instruction": "Create a Fortran function named skew2 to generate a 3x3 skew-symmetric matrix based on the input 3-element vector. The input parameter is of type double precision, dimension(3), and the output parameter is of type double precision, dimension(3, 3).", "input": "", "output": "\tpure function skew2 (r)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: r\n\t\tdouble precision, dimension (3, 3) :: skew2\n\t\t\n\t\tskew2 (1, 1) = - (r (2) ** 2 + r (3) ** 2)\n\t\tskew2 (1, 2) = r (1) * r (2)\n\t\tskew2 (1, 3) = r (1) * r (3)\n\t\tskew2 (2, 1) = r (1) * r (2)\n\t\tskew2 (2, 2) = - (r (1) ** 2 + r (3) ** 2)\n\t\tskew2 (2, 3) = r (2) * r (3)\n\t\tskew2 (3, 1) = r (1) * r (3)\n\t\tskew2 (3, 2) = r (2) * r (3)\n\t\tskew2 (3, 3) = - (r (1) ** 2 + r (2) ** 2)\n\t\t\n\tend function skew2\n"}, {"instruction": "Create a Fortran function named case2 to generate an array of real numbers based on the input parameters. The number of input arguments is 3 with test data types ['integer', 'integer', 'integer']. The number of output arguments is 1 with a test data type of ['real, dimension(n)']. The function generates an array of real numbers where the elements within the range specified by n_min and n_max are set to 1, and all other elements are set to 0.", "input": "", "output": "    function case2(n, n_min, n_max) result(rvcase2)\n    \n        ! routine arguments\n        integer, intent(in)             :: n\n        integer, intent(in)             :: n_min\n        integer, intent(in)             :: n_max\n        real, dimension(n)              :: rvcase2\n        \n        ! locals\n        integer :: i\n        \n        ! generate the information desired\n        rvcase2 = 0.\n        do i = 1, n\n            if(i >= n_min .and. i <= n_max) then\n                rvcase2(i) = 1.\n            end if\n        end do\n        \n    end function case2\n"}, {"instruction": "Create a Fortran function named nbody_coeffs to calculate the value of a using the input integers k, m, and n. The number of input arguments is 3, and the test_data type is [integer, integer, integer]. The number of output arguments is 1, and the test_data type is [integer]. Use the imperative tone.", "input": "", "output": "function nbody_coeffs(k, m, n) result(a)\n    integer, intent(in) :: k, m, n\n    integer :: a\n\n    integer :: i\n\n    a = 1\n    do i = n-m+1, n-k\n        a = a*i\n    end do\n    do i = 1, m-k\n        a = a/i\n    end do\nend function nbody_coeffs\n"}, {"instruction": "Create a Fortran function named isfinished to determine if a game is finished based on the matrix of game results. The function takes 3 input parameters: nline (integer), ntube (integer), and matrix (integer, dimension(ntube,nline)). It returns 1 output parameter win (logical).", "input": "", "output": "function isfinished(nline, ntube, matrix) result(win)\n  implicit none\n  integer :: nline, ntube\n  integer, dimension(ntube,nline) :: matrix\n  logical :: win\n  integer :: i\n  win = .true.\n  do i = 1, ntube\n     win = win .and. all(matrix(i,:) == matrix(i,1))\n  end do\nend function isfinished\n"}, {"instruction": "Create a Fortran function named \"ph\" to calculate the value of a mathematical function. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The test data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "recursive function ph(a, n) result(res)\n  integer, intent(in) :: a, n\n  integer :: res\n  if (n == 0 ) then\n     res = 1\n  else\n     res = a * ph(a + 1, n - 1)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named number that takes a single input argument of type character(*) and returns an output argument of type integer. The function calculates a numerical value based on the characters in the input string and returns the result.", "input": "", "output": "  pure function number(word)\n    character(*), intent(in) :: word\n    integer                  :: number,i\n\n    number=0\n    do i=1,len_trim(word)\n       number=number+(ichar(word(i:i+1))-ichar('a')+1)\n    end do\n\n  end function number\n"}, {"instruction": "Create a Fortran function named is_triangle that takes an integer input argument and returns a logical output. The input argument is of type integer, and the output is of type logical. The function implements the quadratic formula to determine if the given integer forms a triangular number. Use the imperative tone to create the function-level code.", "input": "", "output": "  pure function is_triangle(n)\n    integer, intent(in) :: n\n    double precision    :: x1,x2\n    logical             :: is_triangle\n\n    ! quadratic formula\n    x1 = (-1 - sqrt(dble(1+8*n))) / 2\n    x2 = (-1 + sqrt(dble(1+8*n))) / 2\n\n    is_triangle=.false.\n    if (x1 > 0 .and. (mod(x1,1.0)==0.0)) is_triangle=.true.\n    if (x2 > 0 .and. (mod(x2,1.0)==0.0)) is_triangle=.true.\n\n  end function is_triangle\n"}, {"instruction": "Create a Fortran function named set_rearth to convert the input real*8 number x from degrees to radians and assign the result to the variable lendeg. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function set_rearth(x) result(ret)\n  integer :: ret\n  real*8 :: x\n  rearth=x\n  lendeg = rearth * pi / 180.\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named bmw_parallel_context_i to calculate the parallel context index using the given index and the total number of parallel contexts. The function should take 2 input arguments of type integer, and the test_data type is ['integer', 'integer']. It should return 1 output argument of type integer, and the test_data type is ['integer'].", "input": "", "output": "      pure function bmw_parallel_context_i(index, num_i)\n\n      implicit none\n\n!  declare arguments\n      integer :: bmw_parallel_context_i\n      integer, intent(in) :: index\n      integer, intent(in) :: num_i\n\n!  start of executable code\n      bmw_parallel_context_i = mod(index - 1, num_i) + 1\n\n      end function\n"}, {"instruction": "Write a Fortran function named scramble that takes an integer number_of_values as input and returns an array of shuffled integers. The input argument is of type integer, while the output argument is an allocatable array of integers.", "input": "", "output": "    function scramble( number_of_values ) result(array)\n        integer, intent(in) :: number_of_values\n        integer, dimension(:), allocatable   :: array\n        integer :: i, j, k, m, n\n        integer :: temp\n        real :: u\n\n        array=[(i,i=1,number_of_values)]\n\n        n=1\n        m=number_of_values\n        do k=1,2\n            do i=1,m\n                call random_number(u)\n                j = n + floor((m+1-n)*u)\n                temp=array(j)\n                array(j)=array(i)\n                array(i)=temp\n            end do\n        end do\n\n    end function scramble\n"}, {"instruction": "Write a Fortran function named \"gdk_pixbuf_new_from_file_at_size_utf8\" that binds to a C function and takes 4 input parameters of types character(kind=c_char) array, integer(c_int), integer(c_int), and type(c_ptr), and returns 1 output parameter of type type(c_ptr). This function is responsible for creating a new GdkPixbuf from a file with the specified width and height, and handles any errors using the error parameter.", "input": "", "output": "function gdk_pixbuf_new_from_file_at_size(filename, width, height, error) bind(&\n&c, name='gdk_pixbuf_new_from_file_at_size_utf8') \n  use iso_c_binding, only: c_ptr, c_char, c_int\n  type(c_ptr) :: gdk_pixbuf_new_from_file_at_size\n  character(kind=c_char), dimension(*) :: filename\n  integer(c_int), value :: width\n  integer(c_int), value :: height\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gtk_ui_manager_add_ui_from_file_utf8 to bind to the C function gtk_ui_manager_add_ui_from_file. It takes 3 input parameters of type c_ptr, value, character(kind=c_char), dimension(*), and type c_ptr, value. It returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gtk_ui_manager_add_ui_from_file(self, filename, error) bind(c, name='g&\n&tk_ui_manager_add_ui_from_file_utf8') \n  use iso_c_binding, only: c_int, c_ptr, c_char\n  integer(c_int) :: gtk_ui_manager_add_ui_from_file\n  type(c_ptr), value :: self\n  character(kind=c_char), dimension(*) :: filename\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Write a Fortran function named gtk_window_set_default_icon_from_file that takes two input parameters of type character(kind=c_char), dimension(*) and type(c_ptr), and one output parameter of type integer(c_int). This function is bound to C with the name 'gtk_window_set_default_icon_from_file_utf8'.", "input": "", "output": "function gtk_window_set_default_icon_from_file(filename, err) bind(c, name='gtk&\n&_window_set_default_icon_from_file_utf8') \n  use iso_c_binding, only: c_int, c_char, c_ptr\n  integer(c_int) :: gtk_window_set_default_icon_from_file\n  character(kind=c_char), dimension(*) :: filename\n  type(c_ptr), value :: err\nend function\n"}, {"instruction": "Create a Fortran function named gtk_file_chooser_add_shortcut_folder_utf8 that binds to C, with the purpose of adding a shortcut folder to a file chooser dialog. The function takes 3 input parameters of type c_ptr, value, character(kind=c_char), dimension(*), and type(c_ptr), value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gtk_file_chooser_add_shortcut_folder(chooser, folder, error) bind(c, n&\n&ame='gtk_file_chooser_add_shortcut_folder_utf8') \n  use iso_c_binding, only: c_int, c_ptr, c_char\n  integer(c_int) :: gtk_file_chooser_add_shortcut_folder\n  type(c_ptr), value :: chooser\n  character(kind=c_char), dimension(*) :: folder\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gtk_file_chooser_list_shortcut_folders, which is bound to C and has the name 'gtk_file_chooser_list_shortcut_folders_utf8'. The function takes 1 input parameter of type 'type(c_ptr), value' and returns 1 output parameter of type 'type(c_ptr)'.", "input": "", "output": "function gtk_file_chooser_list_shortcut_folders(chooser) bind(c, name='gtk_file&\n&_chooser_list_shortcut_folders_utf8') \n  use iso_c_binding, only: c_ptr\n  type(c_ptr) :: gtk_file_chooser_list_shortcut_folders\n  type(c_ptr), value :: chooser\nend function\n"}, {"instruction": "Create a Fortran function named julia to calculate the Julia set for a given complex number. The function takes 9 input parameters of types integer, integer, integer, integer, real, real, real, complex, and integer, and returns 1 output parameter of type integer.", "input": "", "output": "    function julia(x, y, width, height, zoom, mx, my, c, max_iter)\n        integer, intent(in) :: x, y, width, height\n        real,    intent(in) :: zoom, mx, my\n        complex, intent(in) :: c\n        integer, intent(in) :: max_iter\n        integer             :: i, julia\n        complex             :: z\n\n        julia = 0\n\n        z = cmplx(1.5 * (x - width / 2) / (0.5 * zoom * width) + mx, &\n                  1.0 * (y - height / 2) / (0.5 * zoom * height) + my)\n\n        do i = 1, max_iter\n            z = z**2 + c\n\n            if (abs(z) > 2) then\n                julia = i\n                exit\n            end if\n        end do\n    end function julia\n"}, {"instruction": "Create a Fortran function named get_model_time to calculate the model time based on the given time value. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type integer. When calling this function, ensure to provide the time value in seconds as the input argument.", "input": "", "output": "function get_model_time(tout) result(ret)\n  integer :: ret\n  real(8) :: tout  \n  tout = statim*86400.d0+dtdp*(itime_bgn-1)\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_timestep that takes in one input parameter of type real(8) and returns an output parameter of type integer. The function sets the value of dtout to the value of dtdp and returns 0 as the result.", "input": "", "output": "function get_timestep(dtout) result(ret)\n  integer :: ret\n  real(8) :: dtout  \n  dtout = dtdp  \n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_number_of_nodes to determine the number of nodes. The input argument is an integer, and the output argument is also an integer.", "input": "", "output": "function get_number_of_nodes(nout) result(ret)\n  integer :: ret,nout\n  nout=np\n  ret=0  \nend function\n"}, {"instruction": "Provide a Fortran function named get_number_of_elements to determine the number of elements in an array. The function takes 1 input parameter with the data type integer. It returns 1 output parameter with the data type integer.", "input": "", "output": "function get_number_of_elements(nout) result(ret)\n  integer :: ret,nout\n  nout=ne\n  ret=0  \nend function\n"}, {"instruction": "Create a Fortran function named get_number_of_elevation_boundary_segments to determine the number of elevation boundary segments. The function takes 1 input parameter of type integer. The output is a single integer value. Ensure that the function returns the correct count of elevation boundary segments.", "input": "", "output": "function get_number_of_elevation_boundary_segments(nout) result(ret)\n  integer :: ret, nout\n  nout=nope\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named isinmset to determine if a complex number belongs to the Mandelbrot set. The function takes 2 input parameters of type complex and integer, and returns 1 output parameter of type logical. The input parameter test_data type is ['complex', 'integer'], and the output parameter test_data type is ['logical']. Use an imperative tone in the instructions.", "input": "", "output": "pure function isinmset(c, maxiter)\n\n    complex, intent(in) :: c\n    integer, intent(in) :: maxiter\n    integer :: n\n    complex :: z\n    logical :: isinmset\n    \n    z = cmplx(0,0)\n    n = 0\n    if(((abs(c - cmplx(-1,0))) < 0.25) .or. ((abs(1.0 - sqrt(1-(4*c)))) < 1.0)) then\n        isinmset = .true.\n    end if\n\n    do while(abs(z) < 4 .and. (n < maxiter))\n        z = z*z+c\n        n = n+1\n    end do\n\n    if(n >= maxiter) then\n        isinmset = .true.\n    else\n        isinmset = .false.\n    end if    \n\nend function isinmset\n"}, {"instruction": "Write a Fortran pure function named colon to generate an array of consecutive integers between given values inclusive. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer, dimension(1:b-a+1)].", "input": "", "output": "\tpure function colon(a,b)\r\n\t\timplicit none\r\n\t\tinteger, intent(in) :: a,b\r\n\t\tinteger, dimension(1:b-a+1) :: colon\r\n\t\tinteger :: i\r\n\t\tdo i = a,b\r\n\t\t\tcolon(i-a+1) = i\r\n\t\tend do\r\n\tend function colon\r\n"}, {"instruction": "Create a Fortran function named makenumberstring that takes a single real number as input and returns a string of length 20. The function should raise the input number to the power of 2, assign the result to an integer variable, and then assign an empty string to the output.", "input": "", "output": "      function makenumberstring(x)\n      implicit none\n      real, intent(in)     :: x\n      character(len=20)      :: makenumberstring\n      integer             :: xx\n      xx = x**2  ! << ice\n      makenumberstring = ''\n      end function\n"}, {"instruction": "Write a Fortran function named calc_ep to calculate the value of ep based on the given input parameters. The function takes 3 input arguments of type real*8: fx0, ep0, and fx. It returns 1 output argument of type real*8: ep.", "input": "", "output": "function calc_ep(fx0,ep0,fx) result(ep)\n\n      real*8,intent(in) :: fx0,ep0,fx\n      real*8 :: ep\n      real*8 :: a,b,c,d\n      real*8 :: r1,r2,dratio,k\n\n      !ep = 1.d0-(1.d0-fx0)*(1.d0-ep0)/(1.d0-fx)\n      !ep = fx0*(1-ep0)+ep0-fx\n\n      dratio=2.0\n\n      k = (fx0/(1-fx0) + dratio)/(1-ep0)\n\n      a = k;\n      b = -(dratio+k*fx);\n      c = dratio*fx - fx;\n\n      d = b*b - 4.d0*a*c\n\n      r1 = 0.5*(-b + sqrt(d))/a\n      r2 = 0.5*(-b - sqrt(d))/a\n\n      !print *,\"r1,r2:\",r1,r2\n\n      if(r1 > 0) then\n\t      ep=(1-r1)\n      else if(r2 > 0) then\n\t      ep=(1-r2)\n      else\n\t      print *,\"error, r1 and r2:\",r1,r2\n\t      ep=ep0\n      endif\n\n\nend function calc_ep\n"}, {"instruction": "Create a Fortran function named ladjusted_int8 that takes an 8-byte integer as input. The function should return a character string containing the left-aligned representation of the input integer. The number of input arguments is 1 and the test_data type is ['integer(kind=8)']. The number of output arguments is 1 and the test_data type is ['character(len=len_max_int)'].", "input": "", "output": "  function ladjusted_int8(i) result(retchar)\n    integer, parameter :: len_max_int = 20  ! maximum length of chars required for integer*8\n      ! note: if you change this value, make sure to change the value in write() in the code below.\n\n    integer(kind=8), intent(in) :: i  ! integer to be left-adjusted\n\n    character(len=len_max_int) :: chari\n    character(len=len_max_int) :: retchar ! ok up to integer*8\n\n    write(chari, '(i20)') i\n    retchar = trim(adjustl(chari))\n  end function ladjusted_int8\n"}, {"instruction": "Create a Fortran function named dump_int1_binary to convert a 1-byte integer into its binary representation. The function takes 1 input parameter of type integer(kind=1) and returns 1 output parameter of type character(len=8).", "input": "", "output": "  function dump_int1_binary(i1) result(retc)\n    integer(kind=1), intent(in) :: i1\n    character(len=8) :: retc\n    integer :: j, k\n\n    retc(:) = '00000000'\n    do j=0, 7\n      k = 8-j\n      if (btest(i1, j)) retc(k:k) = '1'\n    end do\n  end function dump_int1_binary\n"}, {"instruction": "Create a Fortran function named dump_int2_binary that takes an integer of kind=2 as input and returns a character string of length ikind*8+ikind-1. The function converts the input integer into a binary string and returns it as a character string.", "input": "", "output": "  function dump_int2_binary(i2) result(retc)\n    integer, parameter :: ikind = 2\n    integer(kind=2), intent(in) :: i2\n    character(len=8), dimension(ikind) :: tmpc\n    character(len=ikind*8+ikind-1) :: retc\n    integer :: ir, j, k\n\n    tmpc(:) = '00000000'\n    do ir=1, ikind\n      do j=0, 7\n        k = 8-j\n        if (btest(i2, j+(ir-1)*8)) tmpc(ir)(k:k) = '1'\n      end do\n    end do\n\n    retc = tmpc(ikind)\n    do j = ikind-1, 1, -1\n      retc = trim(retc)//'_'//tmpc(j)\n    end do\n  end function dump_int2_binary\n"}, {"instruction": "Write a Fortran function named norma to calculate the norm of the difference between two double precision arrays. The function should have 2 input parameters of type double precision arrays and 1 output parameter of type double precision. The input parameters should be of dimension (:), and allocatable.", "input": "", "output": "    function norma(vec1,vec2) result(y)\n\n        implicit none\n\n        \n        double precision, dimension(:), allocatable :: vec1, vec2\n        double precision :: y\n\n        \n        y = maxval(abs(vec1 - vec2))\n\n    end function norma \n"}, {"instruction": "Create a Fortran function named get_guess to receive a string input representing a guess. The function takes 1 input parameter of type integer and returns 1 output parameter of type character with a length of 10. When using the function, provide an integer as the input and the function will prompt the user to enter a string of the specified length.", "input": "", "output": "function get_guess(wlen)\n  character(len=10) :: get_guess\n\n  integer, intent(in) :: wlen\n  logical :: valid\n\n  !read guess as a single string\n  write(*, \"(a13,i1,a9)\") \"enter guess (\", wlen, \" letters)\"\n  get_guess = \"\"\n  valid = .false.\n  do while(.true.)\n    read(*, *) get_guess\n    valid = (len(adjustl(trim(get_guess))) == wlen)\n    if(valid) then\n      exit\n    else\n      print*, \"please guess correct number of letters!\"\n    end if\n  end do\n\nend function\n"}, {"instruction": "Create a Fortran function named random_integer to generate a random integer within a specified range. The function has 2 input parameters of type integer, vmin and vmax, and 1 output parameter of type integer. When called, the function will return a random integer value within the range specified by vmin and vmax.", "input": "", "output": "        function random_integer(vmin, vmax) result(val)\n                integer, intent(in)  :: vmin, vmax\n                integer              :: val\n\n                call random_number(random_real)\n                val = vmin + floor( (vmax+1-vmin)*random_real )\n\n        end function random_integer\n"}, {"instruction": "Create a Fortran function called check_uuid to validate whether the input string conforms to the UUID format specified in the RFC. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical. The input parameter represents the UUID string to be validated, and the output parameter returns true if the string adheres to the UUID format defined in the RFC; otherwise, it returns false.", "input": "", "output": "function check_uuid(chars) result(lout)\n\n! return true if the string is permitted by the uuid bfn in rfc\n\ncharacter(len=*) :: chars\ncharacter(len=22), parameter :: hex = '0123456789abcdefabcdef'\nlogical :: lout\n\n   lout = (len_trim(chars) == 36)\n   if (lout) then\n       lout = lout.and.(verify(chars(1:8), hex) == 0)\n       lout = lout.and.(verify(chars(9:9), '-') == 0)\n       lout = lout.and.(verify(chars(10:13), hex) == 0)\n       lout = lout.and.(verify(chars(14:14), '-') == 0)\n       lout = lout.and.(verify(chars(15:18), hex) == 0)\n       lout = lout.and.(verify(chars(19:19), '-') == 0)\n       lout = lout.and.(verify(chars(20:23), hex) == 0)\n       lout = lout.and.(verify(chars(24:24), '-') == 0)\n       lout = lout.and.(verify(chars(25:36), hex) == 0)\n   endif\n\nend function check_uuid\n"}, {"instruction": "Write a Fortran function named rational_abs that takes an array of two integers as input and returns an array of two integers, where each element is the absolute value of the corresponding input element. The number of input arguments is 1 and the test_data type is ['integer,dimension(2)']. The number of output arguments is 1 and the test_data type is ['integer,dimension(2)'].", "input": "", "output": "  function rational_abs(r1)\n    integer,dimension(2) :: rational_abs, r1\n    rational_abs(1) = abs(r1(1))\n    rational_abs(2) = abs(r1(2))\n  end function\n"}, {"instruction": "Write a Fortran function named rational_to_pow that takes two integer arrays of size 2 and an integer exponent as input. The function computes the power of each element in the input array r1 based on the exponent ex and stores the results in the output array rational_to_pow. The number of input arguments is 2 and the test_data type is ['integer,dimension(2)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer,dimension(2)'].", "input": "", "output": "  function rational_to_pow(r1, ex)\n    integer,dimension(2) :: rational_to_pow, r1\n    integer :: ex\n    !(a1 * b2 + a2 * b1) / (b1 * b2)\n    rational_to_pow(1) = r1(1)**ex\n    rational_to_pow(2) = r1(2)**ex\n  end function\n"}, {"instruction": "Create a Fortran function called real_to_rational_pow to calculate the result of raising a real number to a rational power. The function takes 2 input parameters: an integer array of size 2 and a real number. The output consists of 2 parameters: a real number and the result of raising the real number to the rational power. Use the imperative tone to write the instructions.", "input": "", "output": "  function real_to_rational_pow(ex,r1)\n    integer,dimension(2) ::  r1\n    real :: real_to_rational_pow,ex\n    !(a1 * b2 + a2 * b1) / (b1 * b2)\n    if ( r1(1)==0 ) then\n      real_to_rational_pow=0.0\n    else  \n      real_to_rational_pow = ex**(real(r1(1))/real(r1(2)))\n    endif\n  end function\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor (GCD) of two integer numbers. The function takes 2 input arguments of type integer and returns 1 output argument of type integer.", "input": "", "output": "  function gcd(m,n)\n    integer,intent(in)  :: m, n\n    integer :: gcd,irest,ifirst\n    ifirst=abs(m)\n    gcd=abs(n)\n    if(gcd==0)then\n      gcd=ifirst\n    else\n      do\n        irest = mod(ifirst,gcd)\n        if(irest == 0)  exit\n        ifirst = gcd\n        gcd = irest\n      enddo\n      gcd= abs(gcd)\n    endif\n  end function\n"}, {"instruction": "Write a Fortran function named next_ccw to determine the next counterclockwise index in a sequence. The function should take 2 integer input arguments and return 1 integer output argument. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "function next_ccw( i, n ) result(next)\ninteger :: i,n,next\nnext=mod(i,n)+1\nif( next.le.0 )then\n  next=next+n\nend if\nend function next_ccw\n"}, {"instruction": "Create a Fortran function named capital, which takes one input parameter of type character with a length of 1 and returns one output parameter of the same type and length. This function converts a lowercase character to its uppercase equivalent and returns the result.", "input": "", "output": "function capital( in_char )  \n  !-----------------------------------------------------------------------\n  !\n  ! ... converts character to capital if lowercase\n  ! ... copy character to output in all other cases\n  !\n  implicit none  \n  !\n  character(len=1), intent(in) :: in_char\n  character(len=1)             :: capital\n  character(len=26), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz', &\n                                  upper = 'abcdefghijklmnopqrstuvwxyz'\n  integer                      :: i\n  !\n  !\n  do i=1, 26\n     !\n     if ( in_char == lower(i:i) ) then\n        !\n        capital = upper(i:i)\n        !\n        return\n        !\n     end if\n     !\n  end do\n  !\n  capital = in_char\n  !\n  return \n  !\nend function capital\n"}, {"instruction": "Write a Fortran function named \"toupper\" to convert a given string to uppercase. The function should take 1 input parameter of type character (len=*) and return 1 output parameter of type character (len=len(string)).", "input": "", "output": "function toupper(string) result (toupper_result)\n\n  implicit none\n  character (len=*), intent(in) :: string\n  character (len=len(string)) :: toupper_result\n  integer         :: i,ii\n\n  do i=1,len(string)\n    ii=iachar(string(i:i))\n    select case (ii)\n      case (97:122)\n        toupper_result(i:i)=achar(ii-32)\n      case default\n        toupper_result(i:i)=string(i:i)\n    end select\n  enddo\n\nend function toupper\n"}, {"instruction": "Provide a Fortran function named isitanint to determine if a given input string represents an integer number. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type logical. The input argument represents the string to be checked, and the output argument indicates whether the input string represents an integer.", "input": "", "output": "function isitanint(instring) result(isitanint_result)\n\n  implicit none\n\n  character(len=*), intent(in) :: instring\n  logical :: isitanint_result\n\n  integer         :: i,ii\n\n  isitanint_result=.true.\n\n  do i=1,len(instring)\n    ii=iachar(instring(i:i))\n    select case(ii)\n      case (43,45,48:57)\n        if(i.ne.1) then\n          if(ii.eq.43 .or.ii.eq.45) isitanint_result=.false.\n        endif\n      case default\n        isitanint_result=.false.\n    end select\n  enddo\n\nend function isitanint\n"}, {"instruction": "Write a Fortran function named ran to generate a random number using the linear congruential method. The function takes 1 input argument of type integer and returns 1 output argument of type real.", "input": "", "output": "  function ran(idum)\n  implicit none\n  integer, intent(inout) :: idum\n  integer, parameter     :: k4b=selected_int_kind(9)\n  real                   :: ran\n  integer, parameter     :: ia=16807,im=2147483647,iq=127773,ir=2836\n  real, save             :: am\n  integer(k4b), save     :: ix=-1,iy=-1,k\n  if (idum <= 0 .or. iy < 0) then\n    am=nearest(1.0,-1.0)/im\n    iy=ior(ieor(888889999,abs(idum)),1)\n    ix=ieor(777755555,abs(idum))\n    idum=abs(idum)+1\n  end if\n  ix=ieor(ix,ishft(ix,13))\n  ix=ieor(ix,ishft(ix,-17))\n  ix=ieor(ix,ishft(ix,5))\n  k=iy/iq\n  iy=ia*(iy-k*iq)-ir*k\n  if (iy < 0) iy=iy+im\n  ran=am*ior(iand(im,ieor(ix,iy)),1)\n  end function ran  \n"}, {"instruction": "Create a Fortran function named vtk_areatri that calculates the area of a triangle using the input coordinates of its vertices. The function takes 6 input parameters of type real(8) representing the x and y coordinates of the triangle vertices. It returns 1 output parameter of type real(8) representing the area of the triangle.", "input": "", "output": "      function vtk_areatri(ax,ay,bx,by,cx,cy)\n      implicit none\n      real(8) :: vtk_areatri\n      real(8) :: ax,ay,bx,by,cx,cy\n      real(8) :: tmp\n\n      tmp=ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)\n      vtk_areatri=abs(tmp)*0.5d0\n\n      return\n      end function vtk_areatri\n"}, {"instruction": "Create a Fortran function named gaussian_kernel to calculate the Gaussian kernel value based on the input arrays a and b. The input parameters are two one-dimensional arrays of double precision values. The output parameter is a single double precision value representing the kernel result. The function utilizes the features of Fortran, including array operations and the exp function.", "input": "", "output": "function gaussian_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n    integer :: i\n    double precision :: temp\n    double precision :: sigma\n   \n    kernel = 0.0d0 \n    sigma = 724.0d0\n\n    do i = 1, size(a)\n        temp = a(i) - b(i)\n        kernel = kernel + temp * temp\n    enddo\n\n    kernel = exp(-0.5d0 * sqrt(kernel) / (sigma*sigma))\n\nend function gaussian_kernel\n"}, {"instruction": "Create a Fortran function named laplace_kernel to calculate the Laplace kernel value. The function takes 2 input parameters of type double precision arrays and returns a single output of type double precision. The input parameters are intent(in) and have an undefined size, denoted by dimension(:). The function computes the kernel value using the absolute difference and exponential functions.", "input": "", "output": "function laplace_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n\n    kernel = sum(abs(a(:) - b(:)))\n    kernel = exp(-0.00025118864315095795d0 * kernel)\n\nend function laplace_kernel\n"}, {"instruction": "Create a Fortran function named convert_lower_case to convert a single input character to lower case. The function takes 1 input parameter of type character (len=1) and returns 1 output parameter of type character (len=1).", "input": "", "output": "          function convert_lower_case (input_string) result (output_string)\n!\n          character (len=1) :: input_string, output_string\n          integer :: collating_difference\n!\n          if (ichar(input_string) >= ichar('a') .and. ichar(input_string) <= ichar('z')) then\n              collating_difference = ichar(input_string) - ichar('a')\n              output_string = char(ichar('a') + collating_difference)\n          else\n              output_string = input_string\n          end if\n!\n          end function convert_lower_case\n"}, {"instruction": "Create a Fortran function named factorial that calculates the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is the number to calculate the factorial of, and the output parameter is the factorial value.", "input": "", "output": "  function factorial(number) result(fact)\n\n    !> number to calculate the factorial of\n    integer, intent(in) :: number\n\n    !> factorial\n    integer :: fact\n\n    integer :: ii\n\n    fact = 1\n    do ii = 2, number\n      fact = fact * ii\n    end do\n\n  end function factorial\n"}, {"instruction": "Create a Fortran function named logequal to generate an array of equally spaced logarithmically distributed values between the given start and end points. The function requires 3 input parameters of types real(kind=8), real(kind=8), and integer(kind=4) representing the start point, end point, and the number of steps respectively. The output is an array of equally spaced logarithmically distributed values of type real(kind=8) with a dimension of steps.", "input": "", "output": "\tpure function logequal(start,fin,steps) result(grid)\n\t\t! data dictionary\n\t\treal(kind=8), intent(in) :: start\n\t\treal(kind=8), intent(in) :: fin\n\t\tinteger(kind=4), intent(in) :: steps\n\t\treal(kind=8),dimension(steps) :: grid\n\t\tinteger(kind=4) :: ii\n\t\treal(kind=8) :: tmp\n\n\t\ttmp = log(start)\n\t\tgrid_loop: do ii = 1, steps\n\t\t\ttmp = (log(fin)-log(start))/steps + tmp\n\t\t\tgrid(ii) = exp(tmp) \n\t\tend do grid_loop\n\t\treturn\n\tend function logequal\n"}, {"instruction": "Create a Fortran function named \"f\" to calculate the exponential of the negative square of a real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "function f(x)\n  implicit none\n  real::x, f\n  f=exp(-x**2)\nend function f\n"}, {"instruction": "Write a Fortran function named count_substring to count the occurrences of a substring within a string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. The name of the function is count_substring.", "input": "", "output": "function count_substring(string,substring) result(count)\n\n   implicit none\n\n   character(len=*), intent(in) :: string,substring\n   integer :: i,count,position\n\n   count=0\n   if(len(substring).eq.0) return\n\n   i=1\n   do \n      position=index(string(i:),substring)\n      if(position.eq.0) return\n      count=count+1\n      i=i+position+len(substring)\n   end do\n\nend function count_substring\n"}, {"instruction": "Create a Fortran function named integer_to_string that takes an integer as input and returns a string representation of the integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "    pure function integer_to_string(number) result(string)\n        integer, intent(in) :: number\n        character(len=:), allocatable :: string\n\n        character(len=11) :: temp\n\n        write(temp, '(i0)') number\n        string = trim(temp)\n    end function\n"}, {"instruction": "Create a Fortran function named \"contract_i_i\" to calculate the zero-rank contraction of two first-rank tensors. The function takes 2 input parameters of type real, dimension(3) and returns 1 output parameter of type real. The function computes the sum over index i, equivalent to the built-in dot_product, and assigns the result to the output parameter \"c\".", "input": "", "output": "  function contract_i_i ( a, b ) result (c)\n    implicit none\n    real                           :: c ! returns a zero-rank contraction\n    real, dimension(3), intent(in) :: a ! of a first-rank tensor\n    real, dimension(3), intent(in) :: b ! with a first-rank tensor\n\n    ! sum over index i, equivalent to built-in dot_product\n    c = dot_product ( a, b )\n\n  end function contract_i_i\n"}, {"instruction": "Create a Fortran function named contract_ij_ij to calculate the zero-rank contraction of two second-rank tensors. The function should have 2 input parameters of type real, dimension(3,3), and an output parameter of type real.", "input": "", "output": "  function contract_ij_ij ( a, b ) result ( c )\n    implicit none\n    real                              :: c ! returns a zero-rank contraction\n    real, dimension(3,3), intent(in)  :: a ! of a second-rank tensor\n    real, dimension(3,3), intent(in)  :: b ! with another second-rank tensor\n\n    ! sum over indices i, j\n    c = sum ( a * b )\n\n  end function contract_ij_ij\n"}, {"instruction": "Create a Fortran function named contract_ijk_k to perform a contraction operation. The function takes two input parameters of type real, dimension(3,3,3) and real, dimension(3), and returns one output parameter of type real, dimension(3,3).", "input": "", "output": "  function contract_ijk_k ( a, b ) result ( c )\n    implicit none\n    real, dimension(3,3)                :: c ! returns a second-rank contraction of \n    real, dimension(3,3,3), intent(in)  :: a ! a third-rank tensor\n    real, dimension(3),     intent(in)  :: b ! and a first-rank tensor\n\n    integer :: i, j\n\n    ! free indices i, j, sum over index k.\n    do i = 1, 3\n       do j = 1, 3\n          c(i,j) = sum ( a(i,j,:) * b(:) )\n       end do\n    end do\n\n  end function contract_ijk_k\n"}, {"instruction": "Create a Fortran function named skew that takes a 3x3 matrix of real numbers as input and returns a 3-element vector of real numbers as output. The function computes the cross product of the input matrix and returns the resulting vector.", "input": "", "output": "  function skew ( a ) result ( b )\n\n    implicit none\n    real, dimension(3)   :: b ! returns a first-rank tensor by contracting the levi-civita symbol with\n    real, dimension(3,3) :: a ! a second-rank tensor\n\n    b(1) = a(2,3) - a(3,2)\n    b(2) = a(3,1) - a(1,3)\n    b(3) = a(1,2) - a(2,1)\n\n  end function skew\n"}, {"instruction": "Create a Fortran function named cpi_t to calculate the chemical performance index (CPI) at a given temperature and reaction time. The function takes 3 input arguments of type real: k, rtndt, and t. It returns 1 output argument of type real.", "input": "", "output": "    function cpi_t(k, rtndt, t)\n\n        !variables\n        real :: cpi_t\n        real, intent(in) :: k, rtndt, t\n        real :: akic, bkic, ckic\n\n        !calculate akic, bkic, ckic\n        akic = 19.35+8.335*exp(0.02254*(t-rtndt))\n        bkic = 15.61+50.132*exp(0.008*(t-rtndt))\n        ckic = 4.0\n\n        !calculate cpi_t\n        if (k < akic) then\n            cpi_t = 0.0\n        else\n            cpi_t = 1-exp(-((k-akic)/bkic)**ckic)\n        end if\n\n    end function cpi_t\n"}, {"instruction": "Write a Fortran function named dist to calculate the Euclidean distance between two points in a 2D space. The function should take 2 input parameters of type real, dimension(2) and return 1 output parameter of type real. The input parameters will represent the coordinates of the two points, and the output parameter will store the calculated distance.", "input": "", "output": "function dist(pt1,pt2)\n    implicit none\n    real::dist\n    real, dimension(2) :: pt1,pt2\n    dist = sqrt((pt1(1)-pt2(1))**2+(pt1(2)-pt2(2))**2)\nend function dist\n"}, {"instruction": "Create a Fortran function named param_name_string. The function takes 1 input argument with a test_data type of ['character(len=*)']. It returns 1 output argument with a test_data type of ['character(len=strlen)'].", "input": "", "output": "  function param_name_string(name)\n    integer, parameter :: strlen = 30\n    character(len=strlen) :: param_name_string\n    character(len=*), intent(in) :: name\n    integer :: inlen, padl, padr\n    inlen = len_trim(name)\n    padl = 3\n    padr = strlen - inlen - padl ! strlen = padl + inlen + padr\n    if (padr < 0) write(0,'(a,a)') 'len(name) too large in param_name_string, name =',name\n    param_name_string(1:strlen) = repeat(' ',strlen)\n    param_name_string(padl+1:padl+inlen) = trim(name)\n  end function param_name_string\n"}, {"instruction": "Create a Fortran function named icsrcaseb to calculate a value based on the input parameters. The function takes 2 input arguments of type double precision and returns one output argument of type double precision. The function computes a mathematical expression involving the input parameters and assigns the result to the output argument.", "input": "", "output": "           function icsrcaseb(ssh,xk2)\n           implicit none\n           double precision:: ssh,xk2,icsrcaseb\n           double precision:: aa,uuh\n           aa = sqrt(64.0+144.0d0*ssh**2)\n           uuh = (aa+12*ssh)**(1.0d0/3.0d0)-(aa-12*ssh)**(1.0d0/3.0d0)\n           icsrcaseb = xk2*(-4*uuh*(uuh**2+8)/ &\n                    ((uuh**2+4.0d0)*(uuh**2+12.0d0)))\n           end function icsrcaseb\n"}, {"instruction": "Create a Fortran function named icsrcasec that takes four input parameters of type double precision, phimh, xxbarh, ssh, and xk2, and returns a single output parameter of type double precision. The function calculates a complex mathematical expression involving the input parameters and assigns the result to the output parameter.", "input": "", "output": "           function icsrcasec(phimh,xxbarh,ssh,xk2)\n           implicit none\n           double precision:: phimh,xxbarh,ssh,xk2,icsrcasec\n           double precision:: bb,cc,yh,phpxya,phpxyb\n           bb = 2*(phimh+xxbarh)-2*ssh+phimh**3/3+phimh**2*xxbarh\n           cc = (phimh+xxbarh)**2+phimh**2*(phimh**2+4*phimh*xxbarh)/12-&\n                      2*ssh*(phimh+xxbarh)\n           yh = (-bb+sqrt(bb*bb-4*cc))/2\n           phpxya = (phimh+xxbarh+yh)\n           phpxyb = phimh*xxbarh+phimh*phimh/2.d0\n           icsrcasec = xk2*(-2.d0*(phpxya+phimh*phpxyb)/ &\n                          (phpxya**2+phpxyb**2)+1.0d0/ssh)\n           end function icsrcasec\n"}, {"instruction": "Create a Fortran function named atomic_read which reads the value of an integer parameter atomically. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. Ensure that the entire value of the input parameter is read atomically, and no part of it can change during the read operation. Use the imperative tone in the instructions.", "input": "", "output": "       function atomic_read(p)\n       integer :: atomic_read\n       integer, intent(in) :: p\n! guarantee that the entire value of p is read atomically. no part of\n! p can change during the read operation.\n\n!$omp atomic read\n       atomic_read = p\n       return\n       end function atomic_read\n"}, {"instruction": "Create a Fortran function named str2int that takes a string input and converts it to an integer. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "   function str2int(str) result(int)\n      implicit none\n      character(len=*), intent(in) :: str\n      integer                      :: int\n      integer                      :: stat\n\n      read(str, *, iostat=stat) int\n      if(stat /= 0) then\n         write(*, *) \"str reading failed\", str\n         stop 9\n      endif\n   end function str2int\n"}, {"instruction": "Create a Fortran function named replace_text that takes three input parameters of type character(*): s, text, and rep. It returns one output parameter of type character(len(s) + 100). The function replaces occurrences of the string 'text' within the string 's' with the string 'rep', and stores the modified string in 'outs'.", "input": "", "output": "   function replace_text(s, text, rep) result(outs)\n      character(*)           :: s, text, rep\n      character(len(s) + 100) :: outs     ! provide outs with extra 100 char len\n      integer                 :: i, nt, nr\n\n      outs = s; nt = len_trim(text); nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt)); if (i == 0) exit\n         outs = outs(:i - 1)//rep(:nr)//outs(i + nt:)\n      end do\n   end function replace_text\n"}, {"instruction": "Create a Fortran function named modifiedagsupplyreq to calculate the modified agricultural supply requirement. The function takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8). The number of input arguments is 2 and the test_data type is [real(8), real(8)].The number of output arguments is 1 and the test_data type is [real(8)].", "input": "", "output": "  function modifiedagsupplyreq(ragshortprevious,ragsupreq) result(ragsupreqmod)\n    real(8),intent(in) :: ragshortprevious,ragsupreq\n    real(8)            :: ragsupreqmod\n    \n    if (ragshortprevious .le. 0.0) then\n        ragsupreqmod = ragsupreq\n    else\n        if (ragsupreq .gt. ragshortprevious) then\n            ragsupreqmod = ragsupreq - ragshortprevious\n        else\n            ragsupreqmod = ragsupreq\n        end if\n    end if\n    \n  end function modifiedagsupplyreq\n"}, {"instruction": "Create a Fortran function named readfilelist to read a list of file names from a given file. The function takes 2 input parameters of type character(len=256) and character(len=256), dimension(:), allocatable. It returns 1 output parameter of type integer.", "input": "", "output": "    function readfilelist(sfilename, svfiles) result(iretcode)\n    \n        ! routine arguments\n        character(len=256), intent(in)                              :: sfilename\n        character(len=256), dimension(:), allocatable, intent(out)  :: svfiles\n        integer                                                     :: iretcode\n        \n        ! locals\n        integer             :: ilun\n        integer             :: ierrcode\n        integer             :: inumfiles\n        integer             :: ifile\n        character(len=256)  :: sbuffer\n        \n        ! assume success (will falsify on failure)\n        iretcode = 0\n        \n        ! first step: count lines in input file\n        inumfiles = 0\n        open(newunit=ilun, file=sfilename, status='old', action='read', iostat=ierrcode)\n        if(ierrcode /= 0) then\n            iretcode = 1\n            return\n        end if\n        do\n            read(ilun, \"(a)\", iostat=ierrcode) sbuffer\n            if(ierrcode /= 0) exit\n            inumfiles = inumfiles + 1\n        end do\n        if(inumfiles <= 0) then\n            iretcode = 2\n            close(ilun)\n            return\n        end if\n        if(allocated(svfiles)) deallocate(svfiles)\n        allocate(svfiles(inumfiles))\n        \n        ! second step: actual read\n        rewind(ilun)\n        do ifile = 1, inumfiles\n            read(ilun, \"(a)\") svfiles(ifile)\n        end do\n        close(ilun)\n        \n    end function readfilelist\n"}, {"instruction": "Create a Fortran function named basename to extract the base name from a given full path or file name. The function takes 2 input parameters of type character(len=256) and character (optional), and returns 1 output parameter of type character(len=256).", "input": "", "output": "    function basename(sfullname, cseparator) result(sbasename)\n    \n        ! routine arguments\n        character(len=256), intent(in)  :: sfullname\n        character, intent(in), optional :: cseparator\n        character(len=256)              :: sbasename\n        \n        ! local variables\n        integer :: ipos\n        \n        ! locate the last occurrence of path separator character\n        ipos = index(sfullname, cseparator, back=.true.)\n        if(ipos <= 0) then\n            sbasename = sfullname\n        else\n            sbasename = sfullname(ipos+1:)\n        end if\n        \n    end function basename\n"}, {"instruction": "Write a Fortran recursive function named fibr to calculate the Fibonacci number for a given input integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameters should be of type ['integer'].", "input": "", "output": "    recursive function fibr(n) result(fib)\n        integer, intent(in) :: n\n        integer             :: fib\n\n        select case (n)\n            case (:0);      fib = 0\n            case (1);       fib = 1\n            case default;   fib = fibr(n-1) + fibr(n-2)\n        end select\n    end function fibr\n"}, {"instruction": "Create a Fortran function named resolution that takes two double precision input parameters and returns a double precision output parameter. The input parameters should be of type ['double precision', 'double precision'], and the output parameter should be of type ['double precision']. The function computes the resolution based on the input parameters and certain conditions specified in the code.", "input": "", "output": "function resolution(e1,e2)\n    double precision :: e1, e2, resolution\n\n    if ((e1 < 0).or.(e2 < 0).or.((e1-e2)**2 > (nclip*sigma_e)**2)) then\n        resolution = 0\n        return\n    end if\n\n    resolution = exp(-(e1-e2)**2/(2.0*sigma_e**2))/sqrt(2.0*pi*sigma_e**2)\n\n    !clip below zero...\n    !if (resolution < 0) then\n    !    resolution = 0\n    !end if\n\n\nend function resolution\n"}, {"instruction": "Create a Fortran function named biggamma that takes one input parameter of type real*8. The output should also be of type real*8. This function computes the value of biggamma using a series calculation and returns the result. The number of input arguments is 1 and the test_data type is ['real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function biggamma(tau)\n    implicit none\n    real*8, intent(in) :: tau\n    real*8 :: biggamma\n\n    integer :: order, i\n\n    order = 20\n    biggamma = 0.0d0\n\n    do i=order, 1, -1\n        biggamma = i / (1.0d0 + i / (tau + biggamma))\n    end do \n\n    biggamma = 1.0d0 / (tau + biggamma)\nend function biggamma\n"}, {"instruction": "Write a Fortran function named gfc to calculate a three-element real*8 array based on the input integer parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [real*8, dimension(3)].", "input": "", "output": "      function gfc(n) result(g)\n\n      integer, intent(in) :: n\n\n      real*8, dimension(3) :: g\n\n      if (n .eq. 1) then\n\n         g = (/1.1330d0, -0.4059d0, 0.07014d0/)\n\n      elseif (n .eq. 2) then\n\n         g = (/1.0785d0, -0.2319d0, 0.02947d0/)\n\n      else\n\n         g(1) = 0.9935d0 + 0.2328d0 / n - 0.1296d0 / n / n\n\n         g(2) = (-0.6282d0 + 0.5598d0 / n - 0.5299d0 / n / n) / n\n\n         g(3) = (0.3887d0 - 1.181d0 / n + 1.470d0 / n / n) / n / n\n\n      endif\n\n      return\n\n      end function gfc\n"}, {"instruction": "Write a Fortran function named pbc_d_max_origin to calculate the maximum distance from the origin in a periodic boundary condition system. The function takes 3 input parameters: an integer (natoms), a 3xnatoms double precision array (coo), and a 3x3 double precision array (avec). It returns 1 output parameter of type double precision, representing the maximum distance.", "input": "", "output": "  function pbc_d_max_origin(natoms, coo, avec) result(d_max)\n\n    implicit none\n\n    integer,                                intent(in) :: natoms\n    double precision, dimension(3, natoms), intent(in) :: coo\n    double precision, dimension(3,3),       intent(in) :: avec\n    double precision                                   :: d_max\n    \n    integer                        :: iat\n    double precision, dimension(3) :: cart\n\n    d_max = 0.0d0\n    do iat = 1, natoms\n       cart(1:3) = coo(1,iat)*avec(1:3,1) &\n                 + coo(2,iat)*avec(1:3,2) &\n                 + coo(3,iat)*avec(1:3,3)\n       d_max = max(d_max, sum(cart*cart))\n    end do\n    d_max = sqrt(d_max)\n\n  end function pbc_d_max_origin\n"}, {"instruction": "Create a Fortran function named \"pbc_number_of_tvecs\" to calculate the number of translation vectors within a given cutoff radius. The function takes 3 input parameters of type double precision and dimension(3,3), representing the radial cutoff, maximum distance, and lattice vectors. It returns 1 output parameter of type integer.", "input": "", "output": "  function pbc_number_of_tvecs(r_cut, d_max, avec) result(ntvecs)\n\n    implicit none\n\n    !------------------------------------------------------------------!\n    ! r_cut    : radial cut-off                                        !\n    ! d_max    : max. distance of a point/atom from the origin         !\n    ! avec(i,j): i-th component of the j-th lattice vector             !\n    !------------------------------------------------------------------!\n\n    double precision,                 intent(in) :: r_cut\n    double precision,                 intent(in) :: d_max\n    double precision, dimension(3,3), intent(in) :: avec\n    integer                                      :: ntvecs\n\n    integer                        :: ia, ib, ic\n    logical                        :: lasta, lastb, lastc\n    double precision, dimension(3) :: cart\n    double precision               :: r2, rcut2\n\n    rcut2 = r_cut + 2.0d0*d_max\n    rcut2 = rcut2*rcut2\n\n    ntvecs = 0\n    \n    ic = 0\n    c_do : do\n       lastc = .false.\n       ib = 0\n       b_do : do\n          lastb = .false.\n          ia = 0\n          a_do : do\n             lasta = .false.\n             if ((ic==0) .and. (ib==0) .and. (ia==0)) then\n                ia = ia + 1\n                cycle a_do\n             end if\n             \n             ! (+ia, +ib, +ic)\n             cart(1:3) = dble(ia)*avec(1:3,1) &\n                       + dble(ib)*avec(1:3,2) &\n                       + dble(ic)*avec(1:3,3) \n             r2 = sum(cart*cart)\n             if (r2 <= rcut2) then\n                lasta = .true.\n                ntvecs = ntvecs + 1\n             end if\n\n             if ((ia /= 0) .and. (ib /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n                if (ic /= 0) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n                   ! (-ia, -ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(-ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n\n                end if ! c /= 0\n\n             else if ((ia /= 0) .and. (ic /= 0)) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n             else if ((ib /= 0) .and. (ic /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n             end if\n\n             if (.not. lasta) exit a_do\n             lastb = .true.\n             ia = ia + 1\n          end do a_do\n          if (.not. lastb) exit b_do\n          lastc = .true.\n          ib = ib + 1\n       end do b_do\n       if (.not. lastc) exit c_do\n       ic = ic + 1\n    end do c_do\n  \n  end function pbc_number_of_tvecs\n"}, {"instruction": "Create a Fortran function named eta to calculate the value of eta based on the given input parameters. The function takes 5 input arguments with the test_data type ['real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)'] and outputs a single value of type real(8).", "input": "", "output": "function eta(x,eta0,etainf,tau,r)\n    implicit none\n    real(8):: eta,eta0,etainf,tau,r,x\n\n    eta = eta0-(eta0-etainf)*(1.0e0-exp(-((x/tau)**r)))\n\nend function eta\n"}, {"instruction": "Create a Fortran function named distance, which takes a single real input argument and returns an integer output. The function computes the distance of the input number from the nearest perfect square, and then returns the distance as the output.", "input": "", "output": "function distance(i) result(j)\n    real, intent(in) :: i ! input\n    integer :: j ! output\n\n    integer :: num\n    integer :: offset\n\n    num = floor(real(ceiling(sqrt(i))) / 2)\n    offset = mod(int(i - ((2 * num - 1) ** 2)), 2 * num)\n\n    j = num + abs(offset - num)\n end function distance\n"}, {"instruction": "Create a Fortran function named get_random_double_precision_with_range to generate a random double precision number within a specified range. The function has 2 input parameters with the test_data type ['double precision', 'double precision'], and 1 output parameter with the test_data type ['double precision'].", "input": "", "output": "    function get_random_double_precision_with_range(start, end_) result(random_double)\n        double precision, intent(in) :: start\n        double precision, intent(in) :: end_\n        double precision :: random_double\n\n        call random_number(random_double)\n        random_double = start + (end_ - start) * random_double\n    end function\n"}, {"instruction": "Create a Fortran function named get_random_integer_with_range to generate a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be named start and end_, and the output argument should be named random_integer.", "input": "", "output": "    function get_random_integer_with_range(start, end_) result(random_integer)\n        integer, intent(in) :: start\n        integer, intent(in) :: end_\n        integer :: random_integer\n\n        double precision :: random_real\n\n        call random_number(random_real)\n        random_integer = start + floor((end_ + 1 - start) * random_real)\n    end function\n"}, {"instruction": "Write a Fortran function named count_non_empty to calculate the number of non-empty elements in a 2D integer array. The function should take 1 input argument of type integer, dimension(:, :), and return 1 output argument of type integer.", "input": "", "output": "    function count_non_empty(counts) result(nr_non_empty)\n        implicit none\n        integer, dimension(:, :), intent(in) :: counts\n        integer :: nr_non_empty\n\n        nr_non_empty = size(counts) - count(counts == 0)\n    end function count_non_empty\n"}, {"instruction": "Write a Fortran function named pi to estimate the value of pi using a Monte Carlo method. The function takes 1 input parameter of type integer and returns 1 output parameter of type real(8). The input parameter n specifies the number of random points to be generated for the estimation. Use the random points to calculate the value of pi and return the result.", "input": "", "output": "        function  pi(n)\n        integer :: n\n        real(8) :: x(2,n),pi\n        call random_number(x)\n        pi = 4.d0 * dble( count( hypot(x(1,:),x(2,:)) <= 1.d0 ) ) / n\n        end function\n"}, {"instruction": "Create a Fortran function named mod2pi that takes a single real number as input and returns the value of the input number modulo 2\u03c0. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "   function mod2pi(theta)\n\n      real, intent(in) :: theta\n      real :: pi, th, mod2pi\n      real, parameter :: theta_tol = 1.e-6\n      logical :: out\n\n      pi = 2.*acos(0.)\n\n      if (theta <= pi .and. theta >= -pi) then\n         mod2pi = theta\n         return\n      end if\n\n      if (theta - theta_tol <= pi .and. theta >= -pi) then\n         mod2pi = pi\n         return\n      end if\n\n      if (theta <= pi .and. theta + theta_tol >= -pi) then\n         mod2pi = -pi\n         return\n      end if\n\n      th = theta\n      out = .true.\n      do while (out)\n         if (th > pi) th = th - 2.*pi\n         if (th < -pi) th = th + 2.*pi\n         if (th <= pi .and. th >= -pi) out = .false.\n      end do\n      mod2pi = th\n\n   end function mod2pi\n"}, {"instruction": "Create a Fortran function named downcase, which takes a character string as input and returns a new string with all alphabetic characters converted to lowercase. The number of input arguments is 1, with the test_data type being ['character(*)'], and the number of output arguments is 1, with the test_data type being ['character(len(string))'].", "input": "", "output": "  function downcase(string)\n\n    character(*), intent(in) :: string\n    character(len(string))   :: downcase\n\n    character(1) :: c\n    integer      :: i\n\n    continue\n\n    downcase = string\n\n    do i = 1,len(string)\n      c = string(i:i)\n      if ( c >= 'a' .and. c <= 'z') downcase(i:i) = achar(iachar(c) + 32)\n    end do\n\n  end function downcase\n"}, {"instruction": "Write a Fortran function named rocrand_set_stream to set the stream for a ROCRAND generator. The function takes 2 input parameters of type integer(c_size_t) with the value attribute. The output is a single integer(c_int) value.", "input": "", "output": "        function rocrand_set_stream(generator, stream) &\n        bind(c, name=\"rocrand_set_stream\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_set_stream\n            integer(c_size_t), value :: generator\n            integer(c_size_t), value :: stream\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_set_seed to set the seed for a random number generator. The function takes 2 input parameters of type integer and outputs an integer value. The number of input arguments is 2 and the test_data type is ['integer(c_size_t), value', 'integer(kind=8), value']. The number of output arguments is 1 and the test_data type is ['integer(c_int)'].", "input": "", "output": "        function rocrand_set_seed(generator, seed) &\n        bind(c, name=\"rocrand_set_seed\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_set_seed\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: seed\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_get_version to retrieve the version of the ROC-RNG library. The function must have 1 input parameter of type integer(c_int) and 1 output parameter of type integer(c_int). The input parameter stores the version number, and the output parameter retrieves the version information from the library. Use the imperative tone to define the function and its parameters.", "input": "", "output": "        function rocrand_get_version(version) &\n        bind(c, name=\"rocrand_get_version\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_get_version\n            integer(c_int) :: version\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_destroy_discrete_distribution, which is used to destroy a discrete distribution. The function takes 1 input parameter of type integer(c_size_t) by value. It returns 1 output parameter of type integer(c_int). Use the bind(c, name=\"rocrand_destroy_discrete_distribution\") to ensure compatibility with C.", "input": "", "output": "        function rocrand_destroy_discrete_distribution(discrete_distribution) &\n        bind(c, name=\"rocrand_destroy_discrete_distribution\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_destroy_discrete_distribution\n            integer(c_size_t), value :: discrete_distribution\n        end function\n"}, {"instruction": "Create a Fortran function named f to compute the derivatives of a given vector y with respect to time t. The function takes 2 input parameters of type ['complex*16, dimension(:)', 'double precision'] and returns 1 output parameter of type ['complex*16, dimension(size(y))'].", "input": "", "output": "  function f(t,y) result(k)\n    !use interaction_interface\n    \n    implicit none\n    complex*16,       dimension(:), intent(in) :: y\n    !double precision, dimension(:), intent(in) :: beta_ijkl\n    !double precision, dimension(:), intent(in) :: beta_ijkl_map\n    double precision,               intent(in) ::  t\n    complex*16,       dimension(size(y))       :: k    \n    \n    !k(1) =  y(2) \n    !k(2) = -y(1)!-0.25*y(2)  \n    \n    k(1) = -2.0*y(2)!4.0-y(1)*y(1)-4*y(2)*y(2)\n    k(2) = 0.4 + y(1) + 0.3*y(1)*y(1) - 0.6*y(2)*y(2)!y(2)*y(2) - y(1)*y(1) + 1.0\n\n\n    !k(1) = dcmplx(0.0,-1.0)*(0.5*y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(2) + y(1))\n    !k(2) = dcmplx(0.0,-1.0)*(sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(1))\n    !k(3) = dcmplx(0.0,-1.0)*(-y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(2)+0.5*y(1))\n    !call interactionterm(size(y), y, k, beta_ijkl,beta_ijkl_map)    \n    !write(*,*) k(2)\n    \n  end function f\n"}, {"instruction": "Write a Fortran function named number_of_occupied_adjacent_sets to calculate the number of occupied adjacent sets in a 2D integer array. The function takes 3 input parameters with test_data types ['integer', 'integer', 'integer,dimension(:,:)'] and returns 1 output parameter with a test_data type of ['integer'].", "input": "", "output": "    function number_of_occupied_adjacent_sets(i, j, iarray) result(n_occupied)\n    !! for part 1\n    implicit none\n    integer,intent(in) :: i, j !! index to check\n    integer,dimension(:,:),intent(in) :: iarray\n    integer :: n_occupied, ii, jj\n\n    integer :: n, m\n\n    n = size(iarray,1)\n    m = size(iarray,2)\n\n    n_occupied = 0\n\n    ! ###\n    ! #x#\n    ! ###\n\n    do ii = i-1, i+1\n        do jj = j-1, j+1\n            if (ii==i .and. jj==j) cycle\n            if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n                if (iarray(ii,jj)==1) n_occupied = n_occupied + 1\n            end if\n        end do\n    end do\n\n    end function number_of_occupied_adjacent_sets\n"}, {"instruction": "Create a Fortran function named number_of_occupied_adjacent_sets_2 to calculate the number of occupied adjacent sets surrounding a specified index in a two-dimensional integer array. The function takes 3 input parameters of type integer, integer, and integer array, and returns 1 output parameter of type integer.", "input": "", "output": "    function number_of_occupied_adjacent_sets_2(i, j, iarray) result(n_occupied)\n    !! for part 2\n\n    implicit none\n\n    integer,intent(in) :: i, j !! index to check\n    integer,dimension(:,:),intent(in) :: iarray\n\n    integer :: n_occupied, ii, jj, k\n    integer :: n, m\n\n    n = size(iarray,1)\n    m = size(iarray,2)\n\n    n_occupied = 0\n\n    ! ###\n    ! #x#\n    ! ###\n\n    do ii = i-1, 1, -1\n        select case (iarray(ii,j))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! up\n    do ii = i+1, n\n        select case (iarray(ii,j))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! down\n    do jj = j-1, 1, -1\n        select case (iarray(i,jj))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! left\n    do jj = j+1, m\n        select case (iarray(i,jj))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! right\n\n    ! up->left\n    do k = 1, max(i-1,j-1)\n        ii = i - k\n        jj = j - k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! up->right\n    do k = 1, max(i-1,m-j)\n        ii = i - k\n        jj = j + k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! down->left\n    do k = 1, max(n-i,j-1)\n        ii = i + k\n        jj = j - k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! down->right\n    do k = 1, max(n-i,m-j)\n        ii = i + k\n        jj = j + k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n\n    end function number_of_occupied_adjacent_sets_2\n"}, {"instruction": "Create a Fortran pure recursive function called indent_newlines that takes two input parameters: a character string (chars) and an integer (n). The function returns one output parameter, an allocatable character string (indented). The function's purpose is to add indentation to each newline character found in the input string based on the value of the integer parameter. If no newline character is found, the original string is returned.", "input": "", "output": "    recursive pure function indent_newlines(chars, n) result(indented)\n        character(len=*), intent(in) :: chars\n        integer, intent(in) :: n\n        character(len=:), allocatable :: indented\n\n        integer :: idx\n\n        idx = index(chars, new_line('c'))\n        if (idx <= 0) then\n            indented = chars\n        else\n            indented = chars(1:idx)    &\n                // repeat(' ', n) // indent_newlines(chars(idx + 1:), n)\n        end if\n    end function\n"}]