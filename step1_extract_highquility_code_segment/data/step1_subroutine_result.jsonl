{"id": 0, "subroutine": "            subroutine nonlinear_optimization(n,qref,f0,point,poids,    &\n     &f_min,f_max)\n              integer(kind=4), intent(in) :: n\n              real(kind=8), intent(in) :: qref\n              real(kind=8), intent(in) :: f0\n              real(kind=8), intent(out) :: point(1:n)\n              real(kind=8), intent(out) :: poids(1:n)\n              real(kind=8), intent(in) :: f_min\n              real(kind=8), intent(in) :: f_max\n            end subroutine nonlinear_optimization\n"}
{"id": 1, "subroutine": "    subroutine core_guess(kf,hc,f)\n        ! ----------------------------\n        ! core hamiltonian\n        ! ----------------------------\n        !\n        ! source:\n        !   a. szabo and n. s. ostlund\n        !   modern quantum chemistry\n        !   dover\n        !   1996\n        !\n        !-----------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        ! initial guess: core hamiltonian\n        f = hc\n\n    end subroutine core_guess\n"}
{"id": 2, "subroutine": "    subroutine huckel_guess(kf,hc,s,f,cst)\n        ! -----------------------------------------------------\n        ! extended h\u00fcckel theory\n        ! -----------------------------------------------------\n        !\n        ! source:\n        !   extended h\u00fcckel and slater\u2019s rule initial guess for\n        !       real space grid-based density functional theory\n        !   m. lee, k. leiter, c. eisner, j. crone and j. knap\n        !   computational and theoretical chemistry\n        !   2015\n        !\n        !------------------------------------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf),intent(in) :: s    ! overlap matrix\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n        real*8, intent(in) :: cst                   ! multiplicative constant in h\u00fcckel model\n\n        ! intermediate variables\n        integer :: i, j                             ! loop indices\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        f(:,:) = 0.0d0\n\n        do i = 1,kf\n            do j = 1,kf\n                f(i,j) = cst * s(i,j) * 0.5d0 * (hc(i,i) + hc(j,j))\n            end do\n        end do\n\n    end subroutine huckel_guess\n"}
{"id": 3, "subroutine": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"}
{"id": 4, "subroutine": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"}
{"id": 5, "subroutine": "subroutine inject(ff,cf,ccf,ccc,nx,ny,nnx,nny)\n\n  ! inject data from a fine grid to a coarser grid\n  ! using full area weighting for phi\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny),ccf(ny),ccc(ny)\n  real*8, intent(out) :: cf(nx,ny)\n  integer :: i, i2, j, j2, i2m, i2p, j2m, j2p\n\n\n  do j = 1, nny/2\n     j2 = j + j\n     j2m = modulo(j2-2,nny) + 1\n     j2p = modulo(j2,nny) + 1\n     do i = 1, nnx/2\n        i2 = i + i\n        i2m = modulo(i2-2,nnx) + 1\n        i2p = modulo(i2,nnx) + 1\n\n        ! basic version\n        cf(i,j) = 0.25*( &\n             (ff(i2m,j2m) + ff(i2,j2m))*ccf(j2m) &\n             + (ff(i2m,j2 ) + ff(i2,j2 ))*ccf(j2 ) &\n             )/ccc(j)\n\n     enddo\n  enddo\n\nend subroutine inject\n"}
{"id": 6, "subroutine": "subroutine prolong(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! cheap version using linear fitting\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: i, i2, j, j2, im, jm, ip, i2m, jp, j2m, hnnx, hnny\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n        ff(i2m,j2m) = 0.0625*(cf(im,jm) + 3*cf(i,jm) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2m,j2 ) = 0.0625*(cf(im,jp) + 3*cf(i,jp) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2 ,j2m) = 0.0625*(cf(ip,jm) + 3*cf(i,jm) + 3*cf(ip,j) + 9*cf(i,j))\n        ff(i2 ,j2 ) = 0.0625*(cf(ip,jp) + 3*cf(i,jp) + 3*cf(ip,j) + 9*cf(i,j))\n     enddo\n  enddo\n\nend subroutine prolong\n"}
{"id": 7, "subroutine": "subroutine prolong2(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! accurate version using cubic fitting\n\n  implicit none\n\n  real*8, parameter :: a = -0.1318, b = 0.8439, c = 0.4575, d = -0.1696\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: hnnx, hnny, i, im, imm, ip, ipp, j, jm, jmm, jp, jpp, &\n       i2, i2m, j2, j2m\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jmm = modulo(jm-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     jpp = modulo(jp,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        imm = modulo(im-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        ipp = modulo(ip,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n\n        ff(i2 ,j2 ) = a*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + d*(a*cf(ipp,jm) + b*cf(ipp,j) + c*cf(ipp,jp) + d*cf(ipp,jpp))\n\n        ff(i2m,j2 ) = a*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + d*(a*cf(imm,jm) + b*cf(imm,j) + c*cf(imm,jp) + d*cf(imm,jpp))\n\n        ff(i2 ,j2m) = a*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + d*(a*cf(ipp,jp) + b*cf(ipp,j) + c*cf(ipp,jm) + d*cf(ipp,jmm))\n\n        ff(i2m,j2m) = a*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + d*(a*cf(imm,jp) + b*cf(imm,j) + c*cf(imm,jm) + d*cf(imm,jmm))\n\n     enddo\n  enddo\n\n\nend subroutine prolong2\n"}
{"id": 8, "subroutine": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}
{"id": 9, "subroutine": "subroutine uvatphi(nx,ny,u,v,up,vp)\n\n  ! to average u and v to phi points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: up(nx,ny), vp(nx,ny)\n\n  integer :: i, ip, j, jp\n\n  ! assume polar values of v have been defined by a previous\n  ! call to polar, e.g. within cgridave\n\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        ip = i+1\n        if ( i == nx ) ip = 1\n        up(i,j) = 0.5*(u(i,j) + u(ip,j))\n        vp(i,j) = 0.5*(v(i,j) + v(i,jp))\n     enddo\n  enddo\n\nend subroutine uvatphi\n"}
{"id": 10, "subroutine": "subroutine sph2cart (lon, lat, x, y, z )\n  !------------------------------------------------------------------------------------\n  ! sph2cart\n  !\n  !     transforms geographical coordinates (lat,lon) to cartesian coordinates.\n  !     similar to stripack's trans\n  !\n  !    input: lat, latitudes of the node in radians [-pi/2,pi/2]\n  !           lon, longitudes of the nodes in radians [-pi,pi]\n  !\n  !    output:  x, y, z, the coordinates in the range -1 to 1.\n  !                    x**2 + y**2 + z**2 = 1\n  !\n  !   p. peixoto 2015\n  !---------------------------------------------------------------------\n  real (8), intent(in) :: lon\n  real (8), intent(in) :: lat\n  real (8), intent(out) :: x\n  real (8), intent(out) :: y\n  real (8), intent(out) :: z\n  real (8):: coslat\n\n  coslat = dcos (lat)\n  x = coslat * dcos (lon)\n  y = coslat * dsin (lon)\n  z = dsin (lat)\n\n  return\nend subroutine sph2cart\n"}
{"id": 11, "subroutine": "subroutine gldtm(f,fbar,akp,day,a,da,gdel,ff0,xlon)\n  !***********************************************************************\n  ! sb 21/10/2020\n  ! corrections et nouveaux inconnus\n  !*rol calcul de la fonction g(l) evoluee pour dtm_2013 & 2020_oper\n  !\n  !     gdel=resultat du calcul de g(l)\n  !***********************************************************************\n  !\n  ! \n  !.. implicit declarations .. \n  implicit none\n  ! \n  !.. parameters .. \n  integer, parameter :: nlatm = 96\n  ! \n  !.. formal arguments .. \n  real, intent(in) :: day,ff0,xlon\n  real, intent(out) :: gdel\n  real, dimension(2), intent(in) :: f,fbar\n  real, dimension(4), intent(in) :: akp\n  real, dimension(nlatm), intent(in) :: a\n  real, dimension(nlatm), intent(inout) :: da\n  ! \n  !.. local scalars .. \n  integer :: i,ikpm\n  integer :: ikp = 0\n  real :: a74,a77,a78,a88,f1f,fp\n  real :: c2fi = 0.0\n  real :: clfl,cos2te,coste,dakp,dakpm,dkp,dkpm,f0,fp1, &\n          rsin2te,slfl,rsinte\n  real :: rot = .017214206,rot2 = .034428412,roth = .261799387, &\n          rots = 7.27220e-05\n  ! \n  !.. local arrays .. \n  real, dimension(2) :: fbm150 = 0.0,fmfb = 0.0\n  ! \n  common /hlocal/ hl,ch,sh,c2h,s2h,c3h,s3h\n  real :: c2h,c3h,ch,hl,s2h,s3h,sh\n  common /plgdtm/ p10,p20,p30,p40,p50,p60,p11,p21,p31,p41,p51,p22,p32,p42,p52, &\n                  p62,p33,p10mg,p20mg,p40mg,p11mg,p22mg,p31mg,p50mg,p60mg\n  real :: p10,p10mg,p11,p20,p20mg,p21,p22,p30,p31,p32,p33,p40,p40mg,p41,p42, &\n          p50,p51,p52,p60,p62,p11mg,p22mg,p31mg,p50mg,p60mg\n  ! \n  da(2) = p20\n  da(3) = p40\n  da(74) = p10\n  da(77) = p30\n  da(78) = p50\n  da(79) = p60\n  fmfb(1) = f(1) - fbar(1)\n  fmfb(2) = f(2) - fbar(2)\n  fbm150(1) = fbar(1) - 150.\n  fbm150(2) = fbar(2)\n  da(4) = fmfb(1)\n  da(6) = fbm150(1)\n  da(5) = da(4) * da(4)\n  da(69) = da(6) * da(6)\n  da(82) = da(4) * p10\n  da(83) = da(4) * p20\n  da(84) = da(4) * p30\n  da(85) = da(6) * p20\n  da(86) = da(6) * p30\n  da(87) = da(6) * p40\n    ikp = 62\n    ikpm = 67\n    c2fi = 1. - p10mg*p10mg\n    dkp = akp(1) + (a(ikp)+c2fi*a(ikp+1))*akp(2)\n    dakp = a(7) + a(8)*p20mg + a(68)*p40mg + &\n           2.*dkp*(a(60)+a(61)*p20mg+a(75)*2.*dkp*dkp)\n    da(ikp) = dakp * akp(2)\n    da(ikp+1) = da(ikp) * c2fi\n    dkpm = akp(3) + a(ikpm)*akp(4)\n    dakpm = a(64) + a(65)*p20mg + a(72)*p40mg + &\n            2.*dkpm*(a(66)+a(73)*p20mg+a(76)*2.*dkpm*dkpm)\n    da(ikpm) = dakpm * akp(4)\n  da(7) = dkp\n  da(8) = p20mg * dkp\n  da(68) = p40mg * dkp\n  da(60) = dkp * dkp\n  da(61) = p20mg * da(60)\n  da(75) = da(60) * da(60)\n  da(64) = dkpm\n  da(65) = p20mg * dkpm\n  da(72) = p40mg * dkpm\n  da(66) = dkpm * dkpm\n  da(73) = p20mg * da(66)\n  da(76) = da(66) * da(66)\n  f0 = a(4)*da(4) + a(5)*da(5) + a(6)*da(6) + a(69)*da(69) + a(82)*da(82) + &\n       a(83)*da(83) + a(84)*da(84) + a(85)*da(85) + a(86)*da(86) + &\n       a(87)*da(87)\n  f1f = 1. + f0*ff0\n  ! \n  f0 = f0 + a(2)*da(2) + a(3)*da(3) + a(74)*da(74) + a(77)*da(77) + a(7)*da(7) + &\n       a(8)*da(8) + a(60)*da(60) + a(61)*da(61) + a(68)*da(68) + a(64)*da(64) &\n       + a(65)*da(65) + a(66)*da(66) + a(72)*da(72) + a(73)*da(73) + &\n       a(75)*da(75) + a(76)*da(76) + a(78)*da(78) + a(79)*da(79)\n  da(9) = cos(rot*(day-a(11)))\n  da(10) = p20 * da(9)\n  da(12) = cos(rot2*(day-a(14)))\n  da(13) = p20 * da(12)\n  coste = cos(rot*(day-a(18)))\n  da(15) = p10 * coste\n  da(16) = p30 * coste\n  da(17) = da(6) * da(15)\n  cos2te = cos(rot2*(day-a(20)))\n  da(19) = p10 * cos2te\n  da(39) = p30 * cos2te\n  da(59) = da(6) * da(19)\n  da(21) = p11 * ch\n  da(22) = p31 * ch\n  da(23) = da(6) * da(21) \n  da(24) = da(21) * coste\n  da(25) = p21 * ch * coste\n  da(26) = p11 * sh\n  da(27) = p31 * sh\n  da(28) = da(6) * da(26)\n  da(29) = da(26) * coste\n  da(30) = p21 * sh * coste\n  da(94)=p51*ch  \n  da(95)=p51*sh  \n  da(31) = p22 * c2h\n  da(37) = p42 * c2h\n  da(32) = p32 * c2h * coste\n  da(33) = p22 * s2h\n  da(38) = p42 * s2h\n  da(34) = p32 * s2h * coste\n  da(88) = p32 * c2h \n  da(89) = p32 * s2h\n  da(90) = da(6) * da(31)\n  da(91) = da(6) * da(33)\n  da(92) = p62 * c2h\n  da(93) = p62 * s2h\n  da(35) = p33 * c3h\n  da(36) = p33 * s3h\n  fp = a(9)*da(9) + a(10)*da(10) + a(12)*da(12) + a(13)*da(13) + a(15)*da(15) &\n       + a(16)*da(16) + a(17)*da(17) + a(19)*da(19) + a(21)*da(21) + &\n       a(22)*da(22) + a(23)*da(23) + a(24)*da(24) + a(25)*da(25) + &\n       a(26)*da(26) + a(27)*da(27) + a(28)*da(28) + a(29)*da(29) + &\n       a(30)*da(30) + a(31)*da(31) + a(32)*da(32) + a(33)*da(33) + &\n       a(34)*da(34) + a(35)*da(35) + a(36)*da(36) + a(37)*da(37) + &\n       a(38)*da(38) + a(39)*da(39) + a(59)*da(59) + a(88)*da(88) + a(89)*da(89) + &\n       a(90)*da(90) + a(91)*da(91) + a(92)*da(92) + a(93)*da(93) + &\n       a(94)*da(94) + a(95)*da(95) \n  !\n  da(40) = p10 * coste * dkp\n  da(41) = p30 * coste * dkp\n  da(42) = p50 * coste * dkp\n  da(43) = p11 * ch * dkp\n  da(44) = p31 * ch * dkp\n  da(45) = p51 * ch * dkp\n  da(46) = p11 * sh * dkp\n  da(47) = p31 * sh * dkp\n  da(48) = p51 * sh * dkp\n  !\n  fp = fp + a(40)*da(40) + a(41)*da(41) + a(42)*da(42) + a(43)*da(43) + &\n       a(44)*da(44) + a(45)*da(45) + a(46)*da(46) + a(47)*da(47) + &\n       a(48)*da(48)\n  !\n    dakp = (a(40)*p10+a(41)*p30+a(42)*p50)*coste + &\n           (a(43)*p11+a(44)*p31+a(45)*p51)*ch + &\n           (a(46)*p11+a(47)*p31+a(48)*p51)*sh\n    da(ikp) = da(ikp) + dakp*akp(2)\n    da(ikp+1) = da(ikp) + dakp*c2fi*akp(2)\n    clfl = cos(xlon)\n    da(49) = p11 * clfl\n    da(50) = p21 * clfl\n    da(51) = p31 * clfl\n    da(52) = p41 * clfl\n    da(53) = p51 * clfl\n    slfl = sin(xlon)\n    da(54) = p11 * slfl\n    da(55) = p21 * slfl\n    da(56) = p31 * slfl\n    da(57) = p41 * slfl\n    da(58) = p51 * slfl\n    !\n    fp = fp + a(49)*da(49) + a(50)*da(50) + a(51)*da(51) + a(52)*da(52) + &\n         a(53)*da(53) + a(54)*da(54) + a(55)*da(55) + a(56)*da(56) + &\n         a(57)*da(57) + a(58)*da(58)\n  !\n  gdel = f0 + fp*f1f\n  !\nend subroutine gldtm\n"}
{"id": 12, "subroutine": "      subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n"}
{"id": 13, "subroutine": "subroutine bondseek(n,positions,r0,r1,bn)\n\n    implicit none\n\n    integer*4, intent(in)       :: n\n    real*8,    intent(in)       :: r0,r1\n    real*8,    intent(in)       :: positions(n,3)\n\n    integer*4 :: i,j,k\n    integer*4, intent(out) :: bn\n\n    real*8 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n\n    bn = 0\n\n    do i = 1, (n - 1)\n        xi = positions(i,1)\n        yi = positions(i,2)\n        zi = positions(i,3)\n        do j = 1, n\n            if (i .ge. j) cycle\n            xj = positions(j,1)\n            yj = positions(j,2)\n            zj = positions(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = sqrt(dx * dx + dy * dy + dz * dz)\n\n            if (mdl .ge. r0 .and. mdl .le. r1) bn = bn + 1\n\n        end do\n    end do\n    return\nend subroutine bondseek\n"}
{"id": 14, "subroutine": "subroutine calc_xika(xika0,xi,rho,nui,nk,delta,obj_func,xika,ncomp,nbeads,nsitemax)\n    implicit none\n    integer,intent(in) :: ncomp, nbeads, nsitemax\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika0\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    real(8), intent(in) :: rho\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: obj_func\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: xika\n    integer :: i,k,a,j,l,b\n    \n    !initialize xika to 1.0\n    xika=1.0\n    \n    do i=0, ncomp-1\n        do k=0, nbeads-1\n            do a=0, nsitemax-1\n                do j=0, ncomp-1\n                    do l=0, nbeads-1\n                        do b=0, nsitemax-1\n                            xika(i,k,a)=xika(i,k,a) + (rho * xi(j) * nui(j,l) * nk(l,b) * xika0(j,l,b) * delta(i,j,k,l,a,b))\n                        enddo\n                    enddo\n                enddo\n            enddo\n        enddo\n    enddo\n    xika = (1.0/xika)\n    \n    obj_func = xika - xika0\n    \nend subroutine\n"}
{"id": 15, "subroutine": "  subroutine bilin(old,xi,yi,ns,new,xo,yo)\n\n! assume: xo = (xi-1)*ns + 1, xi=50, xo=49*3+1=148\n!         yo = (yi-1)*ns + 1\n\n    implicit none\n\n    integer,                 intent(in) :: xi,yi,xo,yo\n    real, dimension(xi,yi),  intent(in) :: old\n    integer,                 intent(in) :: ns\n    real, dimension(xo,yo),  intent(out):: new\n\n    real  :: im(1:ns+1,2)\n!    real  :: imm(1:ns+3,2)\n    integer:: i,j,jm1,im1,ix1,ix2,iy1,iy2\n\n    forall(i=1:ns+1) im(i,2) = real(i-1)/ns\n      im(:,1) = 1 - im(:,2)\n\n    do j=2,yi\n      jm1 = j - 1\n      iy2 = jm1 * ns + 1\n      iy1 = iy2 - ns\n      do i=2,xi\n        im1 = i - 1\n        ix2 = im1 * ns + 1\n        ix1 = ix2 - ns\n        new(ix1:ix2,iy1:iy2) = matmul(im,matmul(old(im1:i,jm1:j),transpose(im)))\n      end do\n    end do\n\n\n   !   ns = ns + 2\n   ! forall(i=1:ns+1) imm(i,2) = real(i-1)/ns\n   !   imm(:,1) = 1 - imm(:,2)\n!\n!      j=yi\n!      jm1 = j - 1\n!      iy2 = jm1 * ns + 1\n!      iy1 = iy2 - ns\n!\n!      i=xi\n!        im1 = i - 1\n!        ix2 = im1 * ns + 1\n!        ix1 = ix2 - ns\n!        new(ix1:ix2,iy1:iy2) = matmul(imm,matmul(old(im1:i,jm1:j),transpose(imm)))\n!      end do\n!    end do\n\n  end subroutine bilin\n"}
{"id": 16, "subroutine": "subroutine vertvel(rr,ia,ja,ka,imt,jmt,km,ff,uflux,vflux,do3d,wflux)\n!====================================================================\n! calculate the vertical flux based on the uflux and vflux\n!\n!  input:\n!    rr             : time interpolation constant between 0 and 1. controls how much\n!                   : of earlier time step is used in interpolation.\n!    ia,ja,ka       : original position in integers\n!    imt,jmt,km     : grid index sizing constants in (x,y,z), are for \n!                     horizontal and vertical rho grid [scalar]\n!    ff             : time direction. ff=1 forward, ff=-1 backward\n!    uflux          : u velocity (zonal) flux field, two time steps [ixjxkxt]\n!    vflux          : v velocity (meridional) flux field, two time steps [ixjxkxt]\n!    do3d           : flag to set whether to use 3d velocities or not\n!\n!  output:\n!    wflux          : w velocity (vertical) flux field, two time steps [kxt]\n!\n!  other parameters used in function:\n!    rg             : rg=1-rr for time interpolation between time steps. controls how much\n!                   : of later time step is used in interpolation.\n!    uu             : time-interpolated flux at ia/ja/ka (depending on ijk)\n!    um             : time-interpolated flux at ia-1/ja-1/ka-1 (depending on ijk)\n!    nsm=1,nsp=2    : time index. nsm picks out the earlier bounding time step and \n!                     nsp picks out the later bounding time step for interpolation.\n!    iam            : generic index for grid index -1 for whichever direction, ijk. \n!                     is only used in the i direction for whatever reason.\n!    k              : index for looping through depth layers\n!    n              : index for looping through times (1 and 2)\n!\n!  notes:\n!    computes the vertical velocity by integrating the continuity eq. from the bottom \n!    for the nsm and nsp velocity time steps.\n!    this is set up to use neither the -full_wflux nor -explicit_w flags currently, \n!    just the default w flux option.\n!====================================================================\n  \nimplicit none\n  \ninteger,        intent(in)                                      :: ff,ia,ja,ka,imt,jmt,km\ninteger,        intent(in)                                      :: do3d\nreal(kind=8),   intent(in)                                      :: rr\nreal(kind=8),   intent(in),     dimension(imt-1,jmt,km,2)       :: uflux\nreal(kind=8),   intent(in),     dimension(imt,jmt-1,km,2)       :: vflux\nreal(kind=8),   intent(out),    dimension(0:km,2)               :: wflux\nreal(kind=8)                                                    :: rg\n! real(kind=8)                                                    :: uu,um,rg\ninteger                                                         :: nsm=1,nsp=2,k,n,iam\n   \n\nrg=1.d0-rr\nwflux=0.d0\niam=ia-1 \n\n! print *,'in vertvel'\n! print '(a,i3,a,i3,a,i3)','ia=',ia,&\n!     ' ja=',ja,' ka=',ka\n! print *,'imt=',imt,' jmt=',jmt,' km=',km\n! print *,'size(uflux)=',size(uflux,1),' size(vflux)=',size(vflux,1)\n\n\nif(do3d==0) then\n    return\n  \n! start 3d code\nelse\n    kloop: do k=1,ka\n  ! these only need to be defined if we use full_wflux, which we aren't doing right now\n!      uu=rg*uflux(ia ,ja  ,k,nsp)+rr*uflux(ia ,ja  ,k,nsm)\n!      um=rg*uflux(iam,ja  ,k,nsp)+rr*uflux(iam,ja  ,k,nsm)\n!      vv=rg*vflux(ia ,ja  ,k,nsp)+rr*vflux(ia ,ja  ,k,nsm)\n!      vm=rg*vflux(ia ,ja-1,k,nsp)+rr*vflux(ia ,ja-1,k,nsm)\n\n! ! start ifs code\n! #if defined ifs\n!     do n=nsm,nsp\n!      wflux(k,n) = wflux(k-1,n) - ff * &\n!      ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n)  &\n!      + (dzt(ia,ja,k,nsp)-dzt(ia,ja,k,nsm))*dxdy(ia,ja)/tseas )  ! time change of the mass the in grid box\n!     enddo\n! #endif\n! ! end ifs code\n\n! start ocean code\n! #ifdef  full_wflux\n!      wflux(ia,ja,k,nsm)=wflux(ia,ja,k-1,nsm) - ff * ( uu - um + vv - vm )\n! #else\n        do n=nsm,nsp\n            wflux(k,n) = wflux(k-1,n) - ff * &\n                        ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + &\n                        vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n) )\n        enddo\n! #endif\n!end ocean code\n    end do kloop\n\nendif\n! end 3d code\n  \n!#endif\n  return\nend subroutine vertvel\n"}
{"id": 17, "subroutine": "      subroutine el32int(jjja,jjjb,ja,jb,jja,jjb,jjc,jjd,icolbrei,     &\n                                                               interact)\n      integer, intent(in) :: jjja,jjjb,ja,jb,jja,jjb,jjc,jjd,icolbrei\n      integer, intent(out) :: interact\n      end subroutine\n"}
{"id": 18, "subroutine": "    subroutine lttb_downsize(data, threshold, series)\n        implicit none\n\n        real, intent(in) :: data(:)\n        integer, intent(in) :: threshold\n        real, intent(out), allocatable :: series(:)\n\n        ! internal variables\n        integer i, sampledindex, a, nexta, datalength\n        real maxareapoint, maxarea, area, every\n\n        datalength = size(data)\n\n        ! just copy the data 'as-is'\n        if (datalength .le. threshold) then\n            print *, 'no downsizing needed, copying time-series'\n\n            allocate (series(datalength))\n            series(:) = data(:)\n\n            return\n        end if\n\n        print *, 'downsizing time-series with largest-triangle-three-buckets'\n\n        allocate (series(threshold))\n\n        ! always add the first point\n        series(1) = data(1)\n        sampledindex = 1\n        a = 0\n        nexta = 0\n        maxareapoint = 0.0\n\n        ! bucket size. leave room for start and end data points\n        every = real(datalength - 2)/real(threshold - 2)\n\n        do i = 0, threshold - 2 - 1\n            block\n                integer avgrangestart, avgrangeend, avgrangelength\n                real avgx, avgy, pointax, pointay\n                integer rangeoffs, rangeto\n\n                avgrangestart = floor((i + 1)*every) + 1\n                avgrangeend = floor((i + 2)*every) + 1\n                avgrangeend = min(avgrangeend, datalength)\n                avgrangelength = avgrangeend - avgrangestart\n\n                avgx = 0.0\n                avgy = 0.0\n\n                do while (avgrangestart < avgrangeend)\n                    avgx = avgx + avgrangestart\n                    avgy = avgy + data(1 + avgrangestart)\n                    avgrangestart = avgrangestart + 1\n                end do\n\n                avgx = avgx/avgrangelength\n                avgy = avgy/avgrangelength\n\n                ! get the range for this bucket\n                rangeoffs = floor((i + 0)*every) + 1\n                rangeto = floor((i + 1)*every) + 1\n\n                ! point a\n                pointax = a\n                pointay = data(1 + a)\n\n                maxarea = -1\n\n                do while (rangeoffs < rangeto)\n                    ! calculate triangle area over three buckets\n                    area = abs((pointax - avgx)*(data(1 + rangeoffs) - pointay) -&\n                    &(pointax - rangeoffs)*(avgy - pointay))*0.5\n\n                    if (area .gt. maxarea) then\n                        maxarea = area\n                        maxareapoint = data(1 + rangeoffs)\n                        nexta = rangeoffs ! next a is this b\n                    end if\n\n                    rangeoffs = rangeoffs + 1\n                end do\n\n                series(1 + sampledindex) = maxareapoint ! pick this point from the bucket\n                sampledindex = sampledindex + 1\n                a = nexta ! this a is the next a (chosen b)\n            end block\n        end do\n\n        ! always add the last element\n        series(1 + sampledindex) = data(datalength)\n        sampledindex = sampledindex + 1\n\n    end subroutine lttb_downsize\n"}
{"id": 19, "subroutine": "subroutine coordinatepacking(d,a,v,r,c,index,info)\n  implicit none\n  integer,intent(in):: d\n  complex*16,dimension(d,d),intent(in)  :: a\n  complex*16,dimension(d*d),intent(out) :: v\n  integer, dimension(d*d),  intent(out) :: r,c\n  integer, intent(out)   :: index\n  integer, intent(inout) :: info\n  \n  integer i,j\n  v=0\n  r=0\n  c=0\n  \n  index = 1\n  do i=1,d\n     do j=1,d\n        if(abs(a(i,j)).gt.0) then\n           v(index) = a(i,j)\n           r(index) = i\n           c(index) = j\n           index = index+1\n        end if\n     end do\n  end do\n  index = index-1\nend subroutine coordinatepacking\n"}
{"id": 20, "subroutine": "subroutine analyt( cp, cs, rho, medium, n1 )\r\n\r\n  !     munk profile\r\n\r\n  !     returns\r\n  !        cs, cp, rho at depths i*h i = 1, n\r\n  !        depths of interfaces\r\n\r\n  implicit none\r\n  integer,           intent(in)  :: medium, n1\r\n  real     (kind=8), intent(out) :: rho( * )\r\n  complex  (kind=8), intent(out) :: cp( * ), cs( * )\r\n  integer                        :: i, n\r\n  real     (kind=8), parameter   :: eps = 0.00737\r\n  real     (kind=8)              :: h, x, z\r\n\r\n  n = n1 - 1\r\n\r\n  select case ( medium )\r\n\r\n  case ( 1 )   ! the ocean\r\n     h = 5000.0 / n\r\n     do i = 1, n1\r\n        z = ( i - 1 ) * h\r\n        x = 2.0 * ( z - 1300.0 ) / 1300.0\r\n        cp(  i ) = 1500.0 * ( 1.0 + eps * ( x - 1.0 + exp( -x ) ) )\r\n        cs(  i ) = 0.0\r\n        rho( i ) = 1.0\r\n     end do\r\n     return\r\n\r\n  case ( 2 )   ! the fluid half-space\r\n     cp(  1 ) = 1551.91\r\n     cs(  1 ) = 0.0\r\n     rho( 1 ) = 1.0e20\r\n     return\r\n\r\n  case( 9 )  ! an elastic layer\r\n     h = 1000.0 / n\r\n     z = 5000.0\r\n\r\n     do i = 1,n+1\r\n        cp( i ) = 4700.0 + ( z - 5000.0 ) / 10.0\r\n        cs( i ) = 2000.0 + ( z - 5000.0 ) / 10.0\r\n        cp( i ) = 4700.0\r\n        cs( i ) = 2000.0\r\n        rho( i ) = 2.0\r\n        z = z + h\r\n     end do\r\n  end select\r\n\r\nend subroutine analyt\r\n"}
{"id": 21, "subroutine": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"}
