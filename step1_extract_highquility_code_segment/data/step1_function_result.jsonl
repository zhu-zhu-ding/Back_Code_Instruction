{"id": 0, "function": "    elemental function effectively_zero(a)\n        double precision, intent(in) :: a\n        logical :: effectively_zero\n\n        effectively_zero = abs(a) < machine_epsilon\n    end function\n"}
{"id": 1, "function": "    pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n"}
{"id": 2, "function": "  pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n"}
{"id": 3, "function": "  pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n"}
{"id": 4, "function": "function multmod ( a, s, m )\n\n!*****************************************************************************80\n!\n!! multmod carries out modular multiplication.\n!\n!  discussion:\n!\n!    this procedure returns \n!\n!      ( a * s ) mod m\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    26 march 2013\n!\n!  author:\n!\n!    original pascal version by pierre l'ecuyer, serge cote.\n!    fortran90 version by john burkardt.\n!\n!  reference:\n!\n!    pierre lecuyer, serge cote,\n!    implementing a random number package with splitting facilities,\n!    acm transactions on mathematical software,\n!    volume 17, number 1, march 1991, pages 98-111.\n!\n!  parameters:\n!\n!    input, integer ( kind = 4 ) a, s, m, the arguments.\n!\n!    output, integer ( kind = 4 ) multmod, the value of the product of a and s, \n!    modulo m.\n!\n  implicit none\n\n  integer ( kind = 4 ) a\n  integer ( kind = 4 ) a0\n  integer ( kind = 4 ) a1\n  integer ( kind = 4 ), parameter :: h = 32768\n  integer ( kind = 4 ) k\n  integer ( kind = 4 ) m\n  integer ( kind = 4 ) multmod\n  integer ( kind = 4 ) p\n  integer ( kind = 4 ) q\n  integer ( kind = 4 ) qh\n  integer ( kind = 4 ) rh\n  integer ( kind = 4 ) s\n\n  if ( a <= 0 ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  a <= 0.'\n    stop 1\n  end if\n\n  if ( m <= a ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  m <= a.'\n    stop 1\n  end if\n\n  if ( s <= 0 ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  s <= 0.'\n    stop 1\n  end if\n\n  if ( m <= s ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  m <= s.'\n    stop 1\n  end if\n\n  if ( a < h ) then\n\n    a0 = a\n    p = 0\n\n  else\n\n    a1 = a / h\n    a0 = a - h * a1\n    qh = m / h\n    rh = m - h * qh\n\n    if ( h <= a1 ) then\n   \n      a1 = a1 - h\n      k = s / qh\n      p = h * ( s - k * qh ) - k * rh\n\n      do while ( p < 0 )\n        p = p + m\n      end do\n\n    else\n\n      p = 0\n\n    end if\n\n    if ( a1 /= 0 ) then\n\n      q = m / a1\n      k = s / q\n      p = p - k * ( m - a1 * q )\n\n      if ( 0 < p ) then\n        p = p - m\n      end if\n\n      p = p + a1 * ( s - k * q )\n\n      do while ( p < 0 )\n        p = p + m\n      end do\n\n    end if\n\n    k = p / qh\n    p = h * ( p - k * qh ) - k * rh\n\n    do while ( p < 0 )\n      p = p + m\n    end do\n\n  end if\n\n  if ( a0 /= 0 ) then\n\n    q = m / a0\n    k = s / q\n    p = p - k * ( m - a0 * q )\n\n    if ( 0 < p ) then\n      p = p - m\n    end if\n\n    p = p + a0 * ( s - k * q )\n\n    do while ( p < 0 )\n      p = p + m\n    end do\n\n  end if\n\n  multmod = p\n\n  return\nend function multmod\n"}
{"id": 5, "function": "      function fun()\n         use iso_c_binding\n         implicit none\n         type(c_funptr) fun\n      end function fun\n"}
{"id": 6, "function": "function fun()\n   use iso_c_binding\n   implicit none\n   type(c_funptr) fun\n   fun = transfer(32512_c_intptr_t,fun)\nend function fun \n"}
{"id": 7, "function": "function random_hermitian(n)\n! generates an order n hermitian matrix with random entries x+iy\n! where each x and y are uniformly distributed between -1 and 1\nimplicit none\ninteger :: n, ii, jj\ncomplex*16, dimension(n,n) :: random_hermitian\nreal*8, dimension(n,n) :: a, b\n\n    call random_number(a)\n    ! rescaling into an element in (-1,1)\n    a = 2*a - 1\n    call random_number(b)\n    ! rescaling into an element in (-1,1)\n    b = 2*b - 1\n\n    ! populating the matrix\n    do ii = 1,n\n        do jj = 1,n\n            ! replacing entries in the lower triangle\n            if ((jj.gt.ii).and.(ii.lt.n)) then\n                a(jj,ii) = a(ii,jj)\n                ! the imaginary part is negative, to achieve hermicity\n                b(jj,ii) = -b(ii,jj)\n            end if\n            ! cast into a complex entry\n            random_hermitian(ii,jj) = complex(a(ii,jj),b(ii,jj))\n        end do\n    end do\n\nend function random_hermitian\n"}
{"id": 8, "function": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}
{"id": 9, "function": "    function x(n, m)\n      integer, optional :: m\n      if (present(m)) then\n        x = real(n)**m\n      else\n        x = 0.0\n      end if\n    end function\n"}
{"id": 10, "function": "            function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n"}
{"id": 11, "function": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}
{"id": 12, "function": "  function get_manual_control_least_used_cpus_flag() result(r)\n    logical :: r\n    r = manual_control_least_used_cpus\n  end function get_manual_control_least_used_cpus_flag\n"}
{"id": 13, "function": "  real function math_mod_distance(x_a, y_a, z_a, x_b, y_b, z_b)\n!----------------------------------------------------------------------!\n!  calculates distance between two points in three-dimensional space.  !\n!----------------------------------------------------------------------!\n  implicit none\n!-----------------------------[arguments]------------------------------!\n  real :: x_a, y_a, z_a, x_b, y_b, z_b\n!======================================================================!\n\n  math_mod_distance = sqrt(   (x_a-x_b)*(x_a-x_b) &\n                            + (y_a-y_b)*(y_a-y_b) &\n                            + (z_a-z_b)*(z_a-z_b) )\n\n  end function\n"}
{"id": 14, "function": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}
{"id": 15, "function": "double precision function mean(a, n)\n  double precision, intent(in) :: a(n)\n  integer i\n  mean = 0\n  do i=1, n\n    mean = mean + a(i)\n  enddo\n  mean = mean/n\nend function mean\n"}
{"id": 16, "function": "      integer function get_index_kq(ikpt,iqpt,nkpts)\n      implicit none\n      integer,intent(in) :: ikpt,iqpt,nkpts\n      get_index_kq = ikpt+(iqpt-1)*nkpts\n      end function get_index_kq\n"}
{"id": 17, "function": "      integer function get_index_q(ikqpt,nkpts)\n      implicit none\n      integer,intent(in) :: ikqpt,nkpts\n      get_index_q = (ikqpt-1)/nkpts + 1\n      end function get_index_q\n"}
{"id": 18, "function": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 19, "function": "    elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 20, "function": "    elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 21, "function": "    elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 22, "function": "    elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 23, "function": "   function vol1(a,b)\n      real vol,a,b\n   end function vol1\n"}
{"id": 24, "function": "   function vol2(a,b)\n      real vol,a,b\n   end function vol2\n"}
{"id": 25, "function": "    double precision function xpos(i) result(x)\n        integer,intent(in) :: i\n        !x = dh * i\n        x = -xmax + dh * ( i - 1 )\n    end function\n"}
{"id": 26, "function": "    double precision function ypos(j) result(y)\n        integer,intent(in) :: j\n        !y = dh * j\n        y = -ymax + dh * ( j - 1 )\n    end function\n"}
{"id": 27, "function": "    double precision function zpos(k_) result(z)\n        integer,intent(in) :: k_\n        !z = dh * k\n        z = -zmax + dh * ( k_ - 1 ) \n    end function\n"}
{"id": 28, "function": "    pure elemental double precision function phase_complex(z)\n        complex(kind(0d0)),intent(in) :: z\n        phase_complex = atan2(aimag(z), real(z))\n    end function\n"}
{"id": 29, "function": "    double precision function phase_coordinates(y, x)\n        double precision,intent(in) :: x, y\n        phase_coordinates = atan2(y, x)\n    end function\n"}
{"id": 30, "function": "    function create_wavenumber(n) result(k_)\n        integer,intent(in)  :: n\n        double precision    :: k_(1:n)\n        double precision    :: coe\n        integer             :: i\n        coe = 2d0 * pi / ( n * dh )\n        if ( n > 1 ) then\n            do i = 1, n\n                if (i <= n / 2) then\n                    k_(i) = i - 1\n                else\n                    k_(i) = i - n - 1\n                end if\n            end do\n            k_ = k_ * coe\n        else\n            k_ = 0d0\n        end if\n    end function\n"}
{"id": 31, "function": "        integer function nfact2_(i)\n          implicit none\n          integer,intent(in)::i\n          integer,parameter::mx=5,nls(mx)=(/1,1,3,15,105/)\n          if (i+1>mx) then\n            write(*,'(\"error: out of range: nfact2_()\")')\n            stop 1\n          end if\n          nfact2_=nls(i+1)\n        end function\n"}
{"id": 32, "function": "        function c_ezcu_dev_find(idx) bind(c, name=\"ezcu_dev_find\")\n            use iso_c_binding, only: c_ptr, c_int\n            integer(kind=c_int), value, intent(in) :: idx\n        end function c_ezcu_dev_find\n"}
{"id": 33, "function": "  integer function lpyr(yr)\n\n  implicit none\n\n  integer yr\n!\n!---- returns 1 if leap year\n!\n  lpyr=0\n  if(mod(yr,400) == 0) then\n    lpyr=1\n  else if(mod(yr,4) == 0) then\n    lpyr=1\n    if(mod(yr,100) == 0) lpyr=0\n  endif\n\n  end function lpyr\n"}
{"id": 34, "function": "  integer function idaywk(jdayno)\n\n! idaywk = compute the day of the week given the julian day number,\n!          version 1.0.\n\n  implicit none\n\n! input variable\n  integer, intent(in) :: jdayno\n! jdayno = julian day number starting at noon of the day in question.\n\n! idaywk = day of the week, where 0=sunday, 1=monday, ..., 6=saturday.\n\n!----------\n! compute the day of the week given the julian day number.\n! you can find the julian day number given (day,month,year)\n! using subroutine calndr below.\n! example: for the first day of the gregorian calendar,\n! friday 15 october 1582, compute the julian day number (option 3 of\n! subroutine calndr) and compute the day of the week.\n!     call calndr (3, 15, 10, 1582, jdayno)\n!     write(*,*) jdayno, idaywk(jdayno)\n! the numbers printed should be 2299161 and 5, where 5 refers to friday.\n!\n! copyright (c) 1999 jon ahlquist.\n! issued under the second gnu general public license.\n! see www.gnu.org for details.\n! this program is distributed in the hope that it will be useful,\n! but without any warranty; without even the implied warranty of\n! merchantability or fitness for a particular purpose.\n! if you find any errors, please notify:\n! jon ahlquist <ahlquist@met.fsu.edu>\n! dept of meteorology\n! florida state university\n! tallahassee, fl 32306-4520\n! 15 march 1999.\n!\n!-----\n\n! converted to fortran90 by dimitri komatitsch,\n! university of pau, france, january 2008.\n\n! jdsun is the julian day number starting at noon on any sunday.\n! i arbitrarily chose the first sunday after julian day 1,\n! which is julian day 6.\n  integer, parameter :: jdsun = 6\n\n  idaywk = mod(jdayno-jdsun,7)\n\n! if jdayno-jdsun < 0, then we are taking the modulus of a negative\n\n! when the argument is negative.  in that case, we adjust the result\n! to a positive value.\n  if (idaywk < 0) idaywk = idaywk + 7\n\n  end function idaywk\n"}
{"id": 35, "function": "  function c_krm_solver_get_fmt() result(val)\n    implicit none\n    character(len=32)  :: val\n\n    val = \"krm solver\"\n  end function c_krm_solver_get_fmt\n"}
{"id": 36, "function": "  function c_krm_solver_is_iterative() result(val)\n    implicit none\n    logical  :: val\n\n    val = .true.\n  end function c_krm_solver_is_iterative\n"}
{"id": 37, "function": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}
{"id": 38, "function": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}
{"id": 39, "function": "  pure elemental logical function is_leap_year(year)\n    ! returns .true. if input year is a leap year,\n    ! and .false. otherwise.\n    integer, intent(in) :: year\n    is_leap_year = (mod(year, 4) == 0 .and. .not. mod(year, 100) == 0)&\n              .or. (mod(year, 400) == 0)\n  end function is_leap_year\n"}
{"id": 40, "function": " function abc()\n  character(len=5) :: abc\n  abc = 'abcde'\n end function abc\n"}
{"id": 41, "function": "      function contex(ii,x,y,ncon,icomp,n)\n! ----------------------------------------------------------\n\n!     with the output-subroutine for odex. it provides an\n!     approximation to the ii-th component of the solution at x.\n! ----------------------------------------------------------\n      implicit double precision (a-h,o-z)\n      implicit integer (i-n)\n      dimension y(ncon),icomp(n)\n      common /conodx/xold,h,imit\n! ----- compute place of ii-th component \n      i=0 \n      do 5 j=1,n \n      if (icomp(j).eq.ii) i=j\n   5  continue\n      if (i.eq.0) then\n         write (6,*) ' no dense output available for comp.',ii \n         return\n      end if  \n! ----- compute the interpolated value \n      theta=(x-xold)/h\n      theta1=1.d0-theta\n      phthet=y(i)+theta*(y(n+i)+theta1*(y(2*n+i)*theta+y(3*n+i)*theta1))\n      if (imit.lt.0) then\n          contex=phthet\n          return\n      end if\n      thetah=theta-0.5d0\n      contex=y(n*(imit+4)+i)\n      do 70 im=imit,1,-1\n  70  contex=y(n*(im+3)+i)+contex*thetah/im\n      contex=phthet+(theta*theta1)**2*contex\n      return\n      end function\n"}
{"id": 42, "function": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}
{"id": 43, "function": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}
{"id": 44, "function": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}
{"id": 45, "function": "pure function fmt_char_int() result(format_char)\n  character(len = 50) :: format_char\n  integer :: r\n  character(len = 50) :: w_char\n  r = range(r)\n  write(w_char, *) 1 + r !! sign + range\n  write(format_char, *) 'i' // trim(adjustl(w_char))\n  format_char = trim(adjustl(format_char))\nend function\n"}
{"id": 46, "function": "integer function x()\n   implicit none\n   x = -5\nend function x\n"}
{"id": 47, "function": "    logical function all_indexes_are_used(c_inds, a_inds, b_inds)\n        integer, dimension(:), intent(in) :: c_inds, a_inds, b_inds\n\n        integer :: idx, num_indices\n        logical, dimension(:), allocatable :: index_used\n\n        num_indices = maxval( [maxval(c_inds), maxval(a_inds), maxval(b_inds)] )\n        allocate(index_used(num_indices))\n\n        index_used = .false.\n        do idx = 1, size(a_inds)\n            index_used(a_inds(idx)) = .true.\n        end do\n        do idx = 1, size(b_inds)\n            index_used(b_inds(idx)) = .true.\n        end do\n        do idx = 1, size(c_inds)\n            index_used(c_inds(idx)) = .true.\n        end do\n\n        all_indexes_are_used = all(index_used)\n        deallocate(index_used)\n    end function all_indexes_are_used\n"}
{"id": 48, "function": "    integer function get_number_of_times_used(inds, idx)\n        integer, dimension(:), intent(in) :: inds\n        integer, intent(in) :: idx\n\n        integer :: i\n\n        get_number_of_times_used = 0\n        do i = 1, size(inds)\n            if (inds(i) == idx ) get_number_of_times_used = get_number_of_times_used + 1\n        end do\n    end function get_number_of_times_used\n"}
{"id": 49, "function": "    logical function has_index(inds, idx)\n        integer, dimension(:), intent(in) :: inds\n        integer, intent(in) :: idx\n\n        integer :: i\n\n        has_index = .true.\n        do i = 1, size(inds)\n            if ( inds(i) == idx ) return\n        end do\n        has_index = .false.\n    end function has_index\n"}
{"id": 50, "function": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}
{"id": 51, "function": "  function comparearray(arrayone,arraytwo,n) result(arraysmatch)\n\n    implicit none\n    integer :: n\n    integer :: arrayone(1:n),arraytwo(1:n)\n    logical :: arraysmatch\n    ! local\n    integer :: i,thesumofdiffs\n\n    thesumofdiffs = 0\n\n    do i = 1,n\n      thesumofdiffs = thesumofdiffs + abs(arrayone(i) - arraytwo(i))\n    end do\n\n    if (thesumofdiffs == 0) then\n      arraysmatch = .true.\n    else\n      arraysmatch = .false.\n    end if\n\n  end function comparearray\n"}
{"id": 52, "function": "  integer function newunit(thisunit)\n\n    implicit none\n    integer,intent(out),optional :: thisunit\n    ! local\n    integer,parameter :: unitmin = 100,unitmax = 1000\n    logical :: isopened\n    integer :: iunit\n\n    newunit = -1\n\n    do iunit = unitmin,unitmax\n      ! check to see if this unit is opened\n      inquire (unit=iunit,opened=isopened)\n      if (.not. isopened) then\n        newunit = iunit\n        exit\n      end if\n    end do\n\n    if (present(thisunit)) thisunit = newunit\n\n  end function newunit\n"}
{"id": 53, "function": "  function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n"}
{"id": 54, "function": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}
{"id": 55, "function": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}
{"id": 56, "function": "  function get_cols() result(cols)\n\n    character(len=1000) :: str_arg\n    integer :: cols, err\n\n    if (command_argument_count() /= 1) then\n      call get_command_argument(0,str_arg)\n      print *, 'usage : ',trim(str_arg),' <number_of_matrix_elements>'\n      stop\n    end if\n\n    call get_command_argument(1,str_arg)\n    read(str_arg, *, iostat=err) cols\n\n    if (err /= 0) then\n      print *, 'number of matrix elements specified must be an integer!'\n      stop\n    end if\n  end function get_cols\n"}
