{"id": 0, "function": "function addspace_bh(n) result(p)\n  include 'globals.h'\n  integer p,n\n\n  if(nbodies+n.gt.nbodsmax) call terror('add_bh: exceed nbodsmax')\n\n  pordercount=pordercount+1\n\n  p=nbodies+1\n  call zeropart(p,n)\n  nbodies=nbodies+n\n  nbh=nbh+n\n  nstar=nstar+n\n \nend function\n"}
{"id": 1, "function": "function addspace_star(n) result(p)\n  include 'globals.h'\n  integer i,p,n\n\n  if(nbodies+n.gt.nbodsmax) call terror('add_star: exceed nbodsmax')\n\n  pordercount=pordercount+1\n\n  do i=1,min(n,nbh)\n    call copypart(nbodies-nbh+i,nbodies+n-min(n,nbh)+i)\n  enddo\n\n  p=nbodies-nbh+1\n  call zeropart(p,n)\n  nbodies=nbodies+n\n  nstar=nstar+n\nend function\n"}
{"id": 2, "function": "function addspace_dm(n) result(p)\n  include 'globals.h'\n  integer i,p,n\n\n  if(nbodies+n.gt.nbodsmax) call terror('add_dm: exceed nbodsmax')\n\n  pordercount=pordercount+1\n\n  do i=1,min(n,nbh)\n    call copypart(nbodies-nbh+i,nbodies+n-min(n,nbh)+i)\n  enddo\n\n  do i=1,min(n,nstar-nbh)\n    call copypart(nbodies-nstar+i,nbodies-nbh+n-min(n,nstar-nbh)+i)\n  enddo\n\n  p=nbodies-nstar+1\n  call zeropart(p,n)\n  nbodies=nbodies+n \nend function\n"}
{"id": 3, "function": "function addspace_gas(n) result(p)\n  include 'globals.h'\n  integer i,p,n\n\n  if(nbodies+n.gt.nbodsmax.or.nsph+n.gt.nsphmax) &\n    call terror('add_gas: exceed nbodsmax')\n\n  pordercount=pordercount+1\n\n  do i=1,min(n,nbh)\n    call copypart(nbodies-nbh+i,nbodies+n-min(n,nbh)+i)\n  enddo\n\n  do i=1,min(n,nstar-nbh)\n    call copypart(nbodies-nstar+i,nbodies-nbh+n-min(n,nstar-nbh)+i)\n  enddo\n\n  do i=1,min(n,nbodies-nsph-nstar)\n    call copypart(nsph+i,nbodies-nstar+n-min(n,nbodies-nsph-nstar)+i)\n  enddo\n\n  p=nsph+1\n  call zerosph(p,n)\n  nbodies=nbodies+n\n  nsph=nsph+n \nend function\n"}
{"id": 4, "function": "   function t_work_package_owner_nk(work_pack, nk) result(owner) \n      use m_types_hybmpi\n      implicit none \n      class(t_work_package), intent(in) :: work_pack\n      integer, intent(in)               :: nk\n      integer                           :: owner\n\n      owner = modulo(nk-1, work_pack%size)\n   end function t_work_package_owner_nk\n"}
{"id": 5, "function": "   function t_work_package_has_nk(work_pack, nk) result(has_nk) \n      implicit none \n      class(t_work_package), intent(in) :: work_pack\n      integer, intent(in)               :: nk\n      logical                           :: has_nk\n      integer :: i \n\n      has_nk = .false.\n      do i = 1, work_pack%n_kpacks \n         if (work_pack%k_packs(i)%nk == nk) then\n            has_nk = .true.\n            exit\n         endif\n      enddo\n   end function t_work_package_has_nk\n"}
{"id": 6, "function": "    elemental function effectively_zero(a)\n        double precision, intent(in) :: a\n        logical :: effectively_zero\n\n        effectively_zero = abs(a) < machine_epsilon\n    end function\n"}
{"id": 7, "function": "    pure function equal_within_absolute(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_absolute\n\n        equal_within_absolute = abs(a - b) < tolerance\n    end function\n"}
{"id": 8, "function": "    pure function equal_within_relative(a, b, tolerance)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        double precision, intent(in) :: tolerance\n        logical :: equal_within_relative\n\n        if (effectively_zero(a) .and. effectively_zero(b)) then\n            equal_within_relative = .true.\n        else\n            equal_within_relative = &\n                    (abs(a - b) / max(abs(a), abs(b))) < tolerance\n        end if\n    end function\n"}
{"id": 9, "function": "    function parse_space(state_) result(result_)\n        type(state_t), intent(in) :: state_\n        type(parser_output_t) :: result_\n\n        result_ = parse_char(\" \", state_)\n    end function\n"}
{"id": 10, "function": "    elemental function safe_eq(a, b)\n        double precision, intent(in) :: a\n        double precision, intent(in) :: b\n        logical :: safe_eq\n\n        safe_eq = equal_within_relative(a, b, machine_epsilon)\n    end function\n"}
{"id": 11, "function": "function get_compiler_id(compiler) result(id)\n    character(len=*), intent(in) :: compiler\n    integer(kind=compiler_enum) :: id\n\n    if (check_compiler(compiler, \"gfortran\")) then\n        id = id_gcc\n        return\n    end if\n\n    if (check_compiler(compiler, \"f95\")) then\n        id = id_f95\n        return\n    end if\n\n    if (check_compiler(compiler, \"caf\")) then\n        id = id_caf\n        return\n    end if\n\n    if (check_compiler(compiler, \"ifort\")) then\n        select case (get_os_type())\n        case (os_linux, os_solaris, os_freebsd)\n            id = id_intel_classic_nix\n        case (os_macos)\n            id = id_intel_classic_mac\n        case (os_windows, os_cygwin)\n            id = id_intel_classic_windows\n        case default\n            id = id_intel_classic_unknown\n        end select\n        return\n    end if\n\n    if (check_compiler(compiler, \"ifx\")) then\n        select case (get_os_type())\n        case (os_linux, os_solaris, os_freebsd)\n            id = id_intel_llvm_nix\n        case (os_windows, os_cygwin)\n            id = id_intel_llvm_windows\n        case default\n            id = id_intel_llvm_unknown\n        end select\n        return\n    end if\n\n    if (check_compiler(compiler, \"nvfortran\")) then\n        id = id_nvhpc\n        return\n    end if\n\n    if (check_compiler(compiler, \"pgfortran\") &\n        & .or. check_compiler(compiler, \"pgf90\") &\n        & .or. check_compiler(compiler, \"pgf95\")) then\n        id = id_pgi\n        return\n    end if\n\n    if (check_compiler(compiler, \"nagfor\")) then\n        id = id_nag\n        return\n    end if\n\n    if (check_compiler(compiler, \"flang\")) then\n        id = id_flang\n        return\n    end if\n\n    if (check_compiler(compiler, \"xlf90\")) then\n        id = id_ibmxl\n        return\n    end if\n\n    if (check_compiler(compiler, \"crayftn\")) then\n        id = id_cray\n        return\n    end if\n\n    if (check_compiler(compiler, \"lfc\")) then\n        id = id_lahey\n        return\n    end if\n\n    if (check_compiler(compiler, \"lfort\")) then\n        id = id_lfortran\n        return\n    end if\n\n    id = id_unknown\n\nend function get_compiler_id\n"}
{"id": 12, "function": "function check_compiler(compiler, expected) result(match)\n    character(len=*), intent(in) :: compiler\n    character(len=*), intent(in) :: expected\n    logical :: match\n    match = compiler == expected\n    if (.not. match) then\n        match = index(basename(compiler), expected) > 0\n    end if\nend function check_compiler\n"}
{"id": 13, "function": "function is_unknown_compiler(compiler) result(is_unknown)\n    character(len=*), intent(in) :: compiler\n    logical :: is_unknown\n    is_unknown = get_compiler_id(compiler) == id_unknown\nend function is_unknown_compiler\n"}
{"id": 14, "function": "function flat_index(sl, ix, iy, iz) result(i)\n  type(simplelist), intent(in) :: sl\n  integer, intent(in) :: ix, iy, iz\n  integer :: i\n  ! check indices\n  if (0 <= ix .and. ix < sl%nx .and. 0 <= iy .and. iy < sl%ny .and. &\n       0 <= iz .and. iz < sl%nz) then\n     i = ix + iy * sl%nx + iz * sl%nx * sl%ny\n  else\n     i = -1\n  end if\nend function flat_index\n"}
{"id": 15, "function": "            function poly_deriv_glj(i,j,zglj,nz)\n              integer(kind=4) :: nz\n              integer(kind=4) :: i\n              integer(kind=4) :: j\n              real(kind=8) :: zglj(0:nz-1)\n              real(kind=8) :: poly_deriv_glj\n            end function poly_deriv_glj\n"}
{"id": 16, "function": "    function pr2r(x)\n      !! real -> real\n      real, intent(in) :: x\n      real :: pr2r\n    end function pr2r\n"}
{"id": 17, "function": "  function newton(f, df, x0, tol) result(x)\n    !! find root of f(x) via newton's method\n    procedure(pr2r) :: f, df\n    real, intent(in) :: x0, tol\n    real :: x, y\n\n    x = x0\n    y = f(x)\n\n    do while (tol < abs(y))\n      x = x - y / df(x)\n      y = f(x)\n    end do\n  end function\n"}
{"id": 18, "function": "  pure function f1(x)\n\n    real, intent(in) :: x\n    real :: f1\n\n    f1 = x**3 - x + 0.25\n  end function\n"}
{"id": 19, "function": "  pure function df1(x)\n\n    real, intent(in) :: x\n    real :: df1\n\n    df1 = 3.0 * x**2 - 1.0\n  end function\n"}
{"id": 20, "function": "c        function str2ten_2(e,ndi,nshear,ngens)\nc         implicit none\nc         \nc         integer :: ndi,nshear,ngens\nc         real(kind=8), dimension(ngens) :: e\nc         type(tensor2) :: str2ten_2\nc         integer, dimension(3) :: ii, jj\nc         integer :: i\nc         \nc         str2ten_2 = identity2(str2ten_2)\nc         \nc         do i=1,ndi\nc          str2ten_2%ab(i,i) = e(i)\nc         enddo\nc         \nc         ii = (/1,2,3/)\nc         jj = (/2,3,1/)\nc         \nc         do i=1,nshear\nc          str2ten_2%ab(ii(i),jj(i)) = e(i+ndi)/2.\nc         end do\n\nc        end function str2ten_2\n"}
{"id": 21, "function": "       function str2ten_2s(e,ndi,nshear,ngens)\n        implicit none\n        \n        integer :: ndi, nshear, ngens\n        real(kind=8), dimension(ngens) :: e\n        type(tensor2s) :: str2ten_2s\n        integer :: i\n        \n        str2ten_2s = identity2(str2ten_2s)\n        \n        do i=1,ndi\n         str2ten_2s%a6(i) = e(i)\n        enddo\n        \n        do i=1,nshear\n         str2ten_2s%a6(i+3) = e(i+ndi)/2.\n        end do\n\n       end function str2ten_2s\n"}
{"id": 22, "function": "    function integrate(self, f, a, b) result(r)\n        use :: quad_func_interface\n        implicit none\n        class(gen_gauss_type), intent(in) :: self\n        procedure(quad_func_type) :: f\n        real(kind=dp), intent(in) :: a, b\n        real(kind=dp) :: r\n        real(kind=dp) :: x, delta\n        integer :: i\n        x = 0.5*(a + b)\n        delta = 0.5*(b - a)\n        r = 0.0_dp\n        do i = 1, size(self%xs)\n            r = r + self%ws(i)*f(x + self%xs(i)*delta)\n        end do\n        r = r*delta\n    end function integrate\n"}
{"id": 23, "function": "  function cross(a,b)\n    use amr_parameters, only:dp\n    real(dp),dimension(1:3)::a,b\n    real(dp),dimension(1:3)::cross\n    !computes the cross product c= a x b\n    cross(1)=a(2)*b(3)-a(3)*b(2)\n    cross(2)=a(3)*b(1)-a(1)*b(3)\n    cross(3)=a(1)*b(2)-a(2)*b(1)\n  end function cross\n"}
{"id": 24, "function": "  elemental logical pure function is_dm(typep)\n    type(part_t), intent(in) :: typep\n    is_dm = typep%family == fam_dm\n  end function is_dm\n"}
{"id": 25, "function": "  elemental logical pure function is_star(typep)\n    type(part_t), intent(in) :: typep\n    is_star = typep%family == fam_star\n  end function is_star\n"}
{"id": 26, "function": "  elemental logical pure function is_cloud(typep)\n    type(part_t), intent(in) :: typep\n    is_cloud = typep%family == fam_cloud\n  end function is_cloud\n"}
{"id": 27, "function": "  elemental logical pure function is_not_tracer(typep)\n    type(part_t), intent(in) :: typep\n    is_not_tracer = typep%family > 0\n  end function is_not_tracer\n"}
{"id": 28, "function": "  elemental logical pure function is_not_dm(typep)\n    type(part_t), intent(in) :: typep\n    is_not_dm = typep%family /= fam_dm\n  end function is_not_dm\n"}
{"id": 29, "function": "  elemental function part2int (part)\n    ! convert a particle into an integer\n    ! this saves some space e.g. when communicating\n    integer :: part2int\n    type(part_t), intent(in) :: part\n\n    ! this is the largest value for integer(1)\n    integer, parameter :: a = 128, b = 2*a\n\n    part2int = (int(part%family) + a) * b + (int(part%tag) + a)\n  end function part2int\n"}
{"id": 30, "function": "  elemental function int2part(index)\n    ! convert from an index to particle type\n    type(part_t) :: int2part\n    integer, intent(in) :: index\n\n    ! this is the largest value for integer(1)\n    integer, parameter :: a = 128, b = 2*a\n\n    int2part%family = int(index / b - a, 1)\n    int2part%tag = int(mod(index, b) - a, 1)\n  end function int2part\n"}
{"id": 31, "function": "  function props2type(idpii, tpii, mpii)\n    use amr_commons\n    use pm_parameters, only : part_t\n\n    ! converts from \"old\" ramses to \"new\" ramses\n    !\n    ! here's the match, add yours here for backward compatibility purposes\n    ! dm     tpii == 0\n    ! stars  tpii != 0 and idpii > 0\n    ! sinks  tpii != 0 and idpii < 0\n    !\n    ! this is mostly for support of graffic i/o.\n    ! the reason we use idpii instead of idp is to prevent name clashes\n    real(dp), intent(in) :: tpii, mpii\n    integer, intent(in)  :: idpii\n\n    type(part_t) :: props2type\n\n    if (tpii == 0) then\n       props2type%family = fam_dm\n    else if (idpii > 0) then\n       props2type%family = fam_star\n    else if (idpii < 0) then\n       props2type%family = fam_cloud\n    else if (mpii == 0) then\n       props2type%family = fam_tracer_gas\n    end if\n    props2type%tag = 0\n  end function props2type\n"}
{"id": 32, "function": "function antithetic_get ( )\n\n!*****************************************************************************80\n!\n!! antithetic_get queries the antithetic value for a given generator.\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    31 march 2013\n!\n!  author:\n!\n!    john burkardt\n!\n!  parameters:\n!\n!    output, logical antithetic_get, is true if generator g is antithetic.\n!\n  implicit none\n\n  logical antithetic_get\n  integer ( kind = 4 ) i\n  logical value\n\n  i = -1\n  call antithetic_memory ( i, value )\n\n  antithetic_get = value\n\n  return\nend function antithetic_get\n"}
{"id": 33, "function": "function cgn_get ( )\n\n!*****************************************************************************80\n!\n!! cgn_get gets the current generator index.\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    30 march 2013\n!\n!  author:\n!\n!    john burkardt\n!\n!  parameters:\n!\n!    output, integer ( kind = 4 ) cgn_get, the current generator index.\n!    1 <= cgn_get <= 32.\n!\n  implicit none\n\n  integer ( kind = 4 ) cgn_get\n  integer ( kind = 4 ) g\n  integer ( kind = 4 ) i\n\n  i = -1\n  call cgn_memory ( i, g )\n\n  cgn_get = g\n\n  return\nend function cgn_get\n"}
{"id": 34, "function": "function i4_uni ( )\n\n!*****************************************************************************80\n!\n!! i4_uni generates a random positive integer.\n!\n!  discussion:\n!\n!    this procedure returns a random integer following a uniform distribution \n!    over (1, 2147483562) using the current generator.\n!\n\n\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    05 august 2013\n!\n!  author:\n!\n!    original pascal version by pierre l'ecuyer, serge cote.\n!    fortran90 version by john burkardt.\n!\n!  reference:\n!\n!    pierre lecuyer, serge cote,\n!    implementing a random number package with splitting facilities,\n!    acm transactions on mathematical software,\n!    volume 17, number 1, march 1991, pages 98-111.\n!\n!  parameters:\n!\n!    output, integer ( kind = 4 ) i4_uni, the random integer.\n!\n  implicit none\n\n  integer ( kind = 4 ), parameter :: a1 = 40014\n  integer ( kind = 4 ), parameter :: a2 = 40692\n!  logical antithetic_get\n  integer ( kind = 4 ) cg1\n  integer ( kind = 4 ) cg2\n!  integer ( kind = 4 ) cgn_get\n  integer ( kind = 4 ) g\n  integer ( kind = 4 ) i4_uni\n!  logical initialized_get\n  integer ( kind = 4 ) k\n  integer ( kind = 4 ), parameter :: m1 = 2147483563\n  integer ( kind = 4 ), parameter :: m2 = 2147483399\n  logical value\n  integer ( kind = 4 ) z\n!\n!  check whether the package must be initialized.\n!\n  if ( .not. initialized_get ( ) ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'i4_uni - note:'\n    write ( *, '(a)' ) '  initializing rnglib package.'\n    call initialize ( )\n  end if\n!\n!  get the current generator index.\n!\n  g = cgn_get ( )\n!\n!  retrieve the seeds for the current generator.\n!\n  call cg_get ( g, cg1, cg2 )\n!\n!  update the seeds.\n!\n  k = cg1 / 53668\n  cg1 = a1 * ( cg1 - k * 53668 ) - k * 12211\n\n  if ( cg1 < 0 ) then\n    cg1 = cg1 + m1\n  end if\n\n  k = cg2 / 52774\n  cg2 = a2 * ( cg2 - k * 52774 ) - k * 3791\n\n  if ( cg2 < 0 ) then\n    cg2 = cg2 + m2\n  end if\n!\n!  store the updated seeds.\n!\n  call cg_set ( g, cg1, cg2 )\n!\n!  construct the random integer from the seeds.\n!\n  z = cg1 - cg2\n\n  if ( z < 1 ) then\n    z = z + m1 - 1\n  end if\n!\n!  if the generator is in antithetic mode, we must reflect the value.\n!\n  value = antithetic_get ( )\n\n  if ( value ) then\n    z = m1 - z\n  end if\n\n  i4_uni = z\n\n  return\nend function i4_uni\n"}
{"id": 35, "function": "function initialized_get ( )\n\n!*****************************************************************************80\n!\n!! initialized_get queries the initialized value.\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    28 march 2013\n!\n!  author:\n!\n!    john burkardt\n!\n!  parameters:\n!\n!    output, logical initialized_get, is true if the package has \n!    been initialized.\n!\n  implicit none\n\n  integer ( kind = 4 ) i\n  logical initialized\n  logical initialized_get\n\n  i = -1\n  call initialized_memory ( i, initialized )\n\n  initialized_get = initialized\n\n  return\nend function initialized_get\n"}
{"id": 36, "function": "function multmod ( a, s, m )\n\n!*****************************************************************************80\n!\n!! multmod carries out modular multiplication.\n!\n!  discussion:\n!\n!    this procedure returns \n!\n!      ( a * s ) mod m\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    26 march 2013\n!\n!  author:\n!\n!    original pascal version by pierre l'ecuyer, serge cote.\n!    fortran90 version by john burkardt.\n!\n!  reference:\n!\n!    pierre lecuyer, serge cote,\n!    implementing a random number package with splitting facilities,\n!    acm transactions on mathematical software,\n!    volume 17, number 1, march 1991, pages 98-111.\n!\n!  parameters:\n!\n!    input, integer ( kind = 4 ) a, s, m, the arguments.\n!\n!    output, integer ( kind = 4 ) multmod, the value of the product of a and s, \n!    modulo m.\n!\n  implicit none\n\n  integer ( kind = 4 ) a\n  integer ( kind = 4 ) a0\n  integer ( kind = 4 ) a1\n  integer ( kind = 4 ), parameter :: h = 32768\n  integer ( kind = 4 ) k\n  integer ( kind = 4 ) m\n  integer ( kind = 4 ) multmod\n  integer ( kind = 4 ) p\n  integer ( kind = 4 ) q\n  integer ( kind = 4 ) qh\n  integer ( kind = 4 ) rh\n  integer ( kind = 4 ) s\n\n  if ( a <= 0 ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  a <= 0.'\n    stop 1\n  end if\n\n  if ( m <= a ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  m <= a.'\n    stop 1\n  end if\n\n  if ( s <= 0 ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  s <= 0.'\n    stop 1\n  end if\n\n  if ( m <= s ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'multmod - fatal error!'\n    write ( *, '(a)' ) '  m <= s.'\n    stop 1\n  end if\n\n  if ( a < h ) then\n\n    a0 = a\n    p = 0\n\n  else\n\n    a1 = a / h\n    a0 = a - h * a1\n    qh = m / h\n    rh = m - h * qh\n\n    if ( h <= a1 ) then\n   \n      a1 = a1 - h\n      k = s / qh\n      p = h * ( s - k * qh ) - k * rh\n\n      do while ( p < 0 )\n        p = p + m\n      end do\n\n    else\n\n      p = 0\n\n    end if\n\n    if ( a1 /= 0 ) then\n\n      q = m / a1\n      k = s / q\n      p = p - k * ( m - a1 * q )\n\n      if ( 0 < p ) then\n        p = p - m\n      end if\n\n      p = p + a1 * ( s - k * q )\n\n      do while ( p < 0 )\n        p = p + m\n      end do\n\n    end if\n\n    k = p / qh\n    p = h * ( p - k * qh ) - k * rh\n\n    do while ( p < 0 )\n      p = p + m\n    end do\n\n  end if\n\n  if ( a0 /= 0 ) then\n\n    q = m / a0\n    k = s / q\n    p = p - k * ( m - a0 * q )\n\n    if ( 0 < p ) then\n      p = p - m\n    end if\n\n    p = p + a0 * ( s - k * q )\n\n    do while ( p < 0 )\n      p = p + m\n    end do\n\n  end if\n\n  multmod = p\n\n  return\nend function multmod\n"}
{"id": 37, "function": "function r4_uni_01 ( )\n\n!*****************************************************************************80\n!\n!! r4_uni_01 returns a uniform random real number in [0,1].\n!\n!  discussion:\n!\n!    this procedure returns a random floating point number from a uniform \n!    distribution over (0,1), not including the endpoint values, using the\n!    current random number generator.\n!\n!  licensing:\n!\n!    this code is distributed under the gnu lgpl license.\n!\n!  modified:\n!\n!    05 august 2013\n!\n!  author:\n!\n!    original pascal version by pierre l'ecuyer, serge cote.\n!    fortran90 version by john burkardt.\n!\n!  reference:\n!\n!    pierre lecuyer, serge cote,\n!    implementing a random number package with splitting facilities,\n!    acm transactions on mathematical software,\n!    volume 17, number 1, march 1991, pages 98-111.\n!\n!  parameters:\n!\n!    output, real ( kind = 4 ) r4_uni_01, a uniform random value in [0,1].\n!\n  implicit none\n\n  integer ( kind = 4 ) i\n!  integer ( kind = 4 ) i4_uni\n!  logical initialized_get\n  real ( kind = 4 ) r4_uni_01\n!\n!  check whether the package must be initialized.\n!\n  if ( .not. initialized_get ( ) ) then\n    write ( *, '(a)' ) ' '\n    write ( *, '(a)' ) 'r4_uni_01 - note:'\n    write ( *, '(a)' ) '  initializing rnglib package.'\n    call initialize ( )\n  end if\n!\n!  get a random positive integer.\n!\n  i = i4_uni ( )\n!\n!  scale it to a random real in [0,1].\n!\n  r4_uni_01 = real ( i, kind = 4 ) * 4.656613057e-10\n\n  return\nend function r4_uni_01\n"}
{"id": 38, "function": "      function fun()\n         use iso_c_binding\n         implicit none\n         type(c_funptr) fun\n      end function fun\n"}
{"id": 39, "function": "function fun()\n   use iso_c_binding\n   implicit none\n   type(c_funptr) fun\n   fun = transfer(32512_c_intptr_t,fun)\nend function fun \n"}
{"id": 40, "function": "    function surf_soil2gw(msurf, msoil, mgw) result(code)\n        type (bmi_prms_surface), intent(inout) :: msurf\n        type (bmi_prms_soil), intent(in) :: msoil\n        type (bmi_prms_groundwater), intent(inout) :: mgw\n        real, allocatable, dimension(:) :: r32var\n        integer, allocatable, dimension(:) :: i32var\n        double precision, allocatable, dimension(:) :: r64var\n        integer :: code\n        integer :: gridid1,gridid2, nelem, nelem1, nelem2\n\n        !double precision\n        nelem  = getvarsize2(msurf, mgw, 'pkwater_equiv')\n        call allocr64var(r64var, nelem)\n        code = msurf%get_value('pkwater_equiv', r64var)\n        code = mgw%set_value('pkwater_equiv', r64var)\n        \n        nelem = getvarsize2(msurf, mgw, 'dprst_seep_hru')\n        call allocr64var(r64var, nelem)\n        code = msurf%get_value('dprst_seep_hru', r64var)\n        code = mgw%set_value('dprst_seep_hru', r64var)\n\n        nelem = getvarsize2(msurf, mgw, 'dprst_stor_hru')\n        call allocr64var(r64var, nelem)\n        code = msurf%get_value('dprst_stor_hru', r64var)\n        code = mgw%set_value('dprst_stor_hru', r64var)\n        \n        !single precision\n        nelem  = getvarsize2(msurf, mgw, 'hru_intcpstor')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_intcpstor', r32var)\n        code = mgw%set_value('hru_intcpstor', r32var)\n\n        nelem  = getvarsize2(msurf, mgw, 'hru_impervstor')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_impervstor', r32var)\n        code = mgw%set_value('hru_impervstor', r32var)\n        \n        nelem  = getvarsize2(msurf, mgw, 'sroff')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('sroff', r32var)\n        code = mgw%set_value('sroff', r32var)\n\n        ! single precision from soil module\n        nelem  = getvarsize3(msoil, mgw, 'soil_moist_tot')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('soil_moist_tot', r32var)\n        code = mgw%set_value('soil_moist_tot', r32var)\n\n        nelem  = getvarsize3(msoil, mgw, 'soil_to_gw')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('soil_to_gw', r32var)\n        code = mgw%set_value('soil_to_gw', r32var)\n\n        nelem  = getvarsize3(msoil, mgw, 'ssr_to_gw')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('ssr_to_gw', r32var)\n        code = mgw%set_value('ssr_to_gw', r32var)\n\n        nelem  = getvarsize3(msoil, mgw, 'ssres_flow')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('ssres_flow', r32var)\n        code = mgw%set_value('ssres_flow', r32var)\n\n    end function surf_soil2gw\n"}
{"id": 41, "function": "    function soil2surface(msoil, msurf) result(code)\n        type (bmi_prms_surface), intent(inout) :: msurf\n        type (bmi_prms_soil), intent(in) :: msoil\n        real, allocatable, dimension(:) :: r32var\n        integer, allocatable, dimension(:) :: i32var\n        double precision, allocatable, dimension(:) :: r64var\n        integer :: code\n        integer :: gridid1,gridid2, nelem, nelem1, nelem2\n        \n        !double precision\n        !reals\n\n        nelem  = getvarsize(msurf, msoil, 'infil')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('infil', r32var)\n        code = msurf%set_value('infil', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'sroff')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('sroff', r32var)\n        code = msurf%set_value('sroff', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_rechr')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('soil_rechr', r32var)\n        code = msurf%set_value('soil_rechr', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_moist')\n        call allocr32var(r32var, nelem)\n        code = msoil%get_value('soil_moist', r32var)\n        code = msurf%set_value('soil_moist', r32var)\n        \n    end function soil2surface\n"}
{"id": 42, "function": "    function surface2soil(msurf, msoil) result(code)\n        type (bmi_prms_surface), intent(in) :: msurf\n        type (bmi_prms_soil), intent(inout) :: msoil\n        real, allocatable, dimension(:) :: r32var\n        integer, allocatable, dimension(:) :: i32var\n        double precision, allocatable, dimension(:) :: r64var\n        integer :: code\n        integer :: gridid1,gridid2, nelem, nelem1, nelem2\n\n        nelem  = getvarsize(msurf, msoil, 'hru_ppt')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_ppt', r32var)\n        code = msoil%set_value('hru_ppt', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'hru_area_perv')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_area_perv', r32var)\n        code = msoil%set_value('hru_area_perv', r32var)\n        \n        nelem  = getvarsize(msurf, msoil, 'hru_frac_perv')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_frac_perv', r32var)\n        code = msoil%set_value('hru_frac_perv', r32var)\n        \n        nelem  = getvarsize(msurf, msoil, 'dprst_evap_hru')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('dprst_evap_hru', r32var)\n        code = msoil%set_value('dprst_evap_hru', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'dprst_seep_hru')\n        call allocr64var(r64var, nelem)\n        code = msurf%get_value('dprst_seep_hru', r64var)\n        code = msoil%set_value('dprst_seep_hru', r64var)\n\n        nelem  = getvarsize(msurf, msoil, 'infil')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('infil', r32var)\n        code = msoil%set_value('infil', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'sroff')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('sroff', r32var)\n        code = msoil%set_value('sroff', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'potet')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('potet', r32var)\n        code = msoil%set_value('potet', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'transp_on')\n        call alloci32var(i32var, nelem)\n        code = msurf%get_value('transp_on', i32var)\n        code = msoil%set_value('transp_on', i32var)\n\n        nelem  = getvarsize(msurf, msoil, 'hru_intcpevap')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_intcpevap', r32var)\n        code = msoil%set_value('hru_intcpevap', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'snow_evap')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('snow_evap', r32var)\n        code = msoil%set_value('snow_evap', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'snowcov_area')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('snowcov_area', r32var)\n        code = msoil%set_value('snowcov_area', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_rechr')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_rechr', r32var)\n        code = msoil%set_value('soil_rechr', r32var)\n        \n        nelem  = getvarsize(msurf, msoil, 'soil_rechr_max')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_rechr_max', r32var)\n        code = msoil%set_value('soil_rechr_max', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_moist')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_moist', r32var)\n        code = msoil%set_value('soil_moist', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_moist_max')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_moist_max', r32var)\n        code = msoil%set_value('soil_moist_max', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'hru_impervevap')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('hru_impervevap', r32var)\n        code = msoil%set_value('hru_impervevap', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_moist_chg')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_moist_chg', r32var)\n        code = msoil%set_value('soil_moist_chg', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'soil_rechr_chg')\n        call allocr32var(r32var, nelem)\n        code = msurf%get_value('soil_rechr_chg', r32var)\n        code = msoil%set_value('soil_rechr_chg', r32var)\n\n        nelem  = getvarsize(msurf, msoil, 'srunoff_updated_soil')\n        call alloci32var(i32var, nelem)\n        code = msurf%get_value('srunoff_updated_soil', i32var)\n        code = msoil%set_value('srunoff_updated_soil', i32var)\n        \n    end function surface2soil\n"}
{"id": 43, "function": "    function getvarsize(msurf, msoil, vname) result(size)\n        type (bmi_prms_surface), intent(in) :: msurf\n        type (bmi_prms_soil), intent(in) :: msoil\n        character(len=*), intent(in) :: vname\n        integer :: gridid1, gridid2\n        integer :: size, nelem1, nelem2\n        integer code\n        code = msurf%get_var_grid(vname, gridid1)\n        code = msoil%get_var_grid(vname, gridid2)\n        code = msurf%get_grid_size(gridid1, nelem1)\n        code = msoil%get_grid_size(gridid2, nelem2)\n        if(nelem1.ne.nelem2) then\n            write(*,*) 'not equal number of hrus'\n            stop bmi_failure\n        else\n            size = nelem1\n        endif\n    end function getvarsize\n"}
{"id": 44, "function": "    function getvarsize2(msurf, mgw, vname) result(size)\n        type (bmi_prms_surface), intent(in) :: msurf\n        type (bmi_prms_groundwater), intent(in) :: mgw\n        character(len=*), intent(in) :: vname\n        integer :: gridid1, gridid2\n        integer :: size, nelem1, nelem2\n        integer code\n        code = msurf%get_var_grid(vname, gridid1)\n        code = mgw%get_var_grid(vname, gridid2)\n        code = msurf%get_grid_size(gridid1, nelem1)\n        code = mgw%get_grid_size(gridid2, nelem2)\n        if(nelem1.ne.nelem2) then\n            write(*,*) 'not equal number of hrus'\n            stop bmi_failure\n        else\n            size = nelem1\n        endif\n    end function getvarsize2\n"}
{"id": 45, "function": "    function getvarsize3(msoil, mgw, vname) result(size)\n        type (bmi_prms_soil), intent(in) :: msoil\n        type (bmi_prms_groundwater), intent(in) :: mgw\n        character(len=*), intent(in) :: vname\n        integer :: gridid1, gridid2\n        integer :: size, nelem1, nelem2\n        integer code\n        code = msoil%get_var_grid(vname, gridid1)\n        code = mgw%get_var_grid(vname, gridid2)\n        code = msoil%get_grid_size(gridid1, nelem1)\n        code = mgw%get_grid_size(gridid2, nelem2)\n        if(nelem1.ne.nelem2) then\n            write(*,*) 'not equal number of hrus'\n            stop bmi_failure\n        else\n            size = nelem1\n        endif\n    end function getvarsize3\n"}
{"id": 46, "function": "  function bnlog_c( irank ,xx ) result(rslt)\n!*******************************************************************\n!*******************************************************************\n  integer ,intent(in) :: irank\n  include 'avh_olo_complex.h90'\n    ,intent(in) :: xx\n  include 'avh_olo_complex.h90'\n    :: rslt,yy,omx\n  include 'avh_olo_real.h90'\n    :: aa,rex,imx\n  integer :: ii,nn\n!\n  rex = areal(xx)\n  imx = aimag(xx)\n!\n  if (abs(imx).le.epsn*abs(rex)) then\n    rslt = bnlog_r( irank ,rex ,sgnre(imx,1) )\n    return\n  endif\n!\n  if (abs(xx-1).le.epsn*10) then\n    aa = 1\n    rslt = -1\n    do ii=2,irank+1\n      rslt = rslt - aa/ii\n    enddo\n    return\n  endif\n!\n  yy = olog(1-1/xx,0)\n  aa = abs(yy)\n  if     (aa.ge.thrs(6,irank,prcpar)) then\n     omx = 1\n    rslt = acoef(irank,irank)\n    do ii=irank,1,-1\n       omx = 1 + xx*omx\n      rslt = acoef(ii-1,irank) + xx*rslt\n    enddo\n     omx = (1-xx)*omx\n    rslt = omx*yy - rslt/acoef(irank,irank)\n!    if     (irank.eq.0) then\n!      rslt = (1-xx)*yy - 1\n!    elseif (irank.eq.1) then\n!      rslt = (1-xx)*(1+xx)*yy - (1+xx*2)/2\n!    elseif (irank.eq.2) then\n!      rslt = (1-xx)*(1+xx*(1+xx))*yy - (2+xx*(3+xx*6))/6\n!    elseif (irank.eq.3) then\n!      rslt = (1-xx)*(1+xx*(1+xx*(1+xx)))*yy &\n!           - (3+xx*(4+xx*(6+xx*12)))/12\n!    elseif (irank.eq.4) then\n!      rslt = (1-xx)*(1+xx*(1+xx*(1+xx*(1+xx))))*yy &\n!           - (12+xx*(15+xx*(20+xx*(30+xx*60))))/60\n!    endif\n    return\n  elseif (aa.ge.thrs(5,irank,prcpar)) then ;nn=ntrm(6,irank,prcpar)\n  elseif (aa.ge.thrs(4,irank,prcpar)) then ;nn=ntrm(5,irank,prcpar)\n  elseif (aa.ge.thrs(3,irank,prcpar)) then ;nn=ntrm(4,irank,prcpar)\n  elseif (aa.ge.thrs(2,irank,prcpar)) then ;nn=ntrm(3,irank,prcpar)\n  elseif (aa.ge.thrs(1,irank,prcpar)) then ;nn=ntrm(2,irank,prcpar)\n                                      else ;nn=ntrm(1,irank,prcpar)\n  endif\n!\n  rslt = coeff(nn,irank)\n  do ii=nn-1,2+irank,-1\n    rslt = coeff(ii,irank) + yy*rslt\n  enddo\n  rslt = -(irank+1)*rslt*yy*(yy*xx)**(irank+1)\n!\n  aa = areal(rslt)\n  if (abs(aimag(rslt)).le.epsn*abs(aa)) rslt = acmplx(aa)\n!\n  end function\n"}
{"id": 47, "function": "  function bnlog_r( irank ,xx ,sgn ) result(rslt)\n!*******************************************************************\n!*******************************************************************\n  integer ,intent(in) :: irank\n  include 'avh_olo_real.h90'\n          ,intent(in) :: xx\n  integer ,intent(in) :: sgn\n  include 'avh_olo_complex.h90'\n    :: rslt\n  include 'avh_olo_real.h90'\n    :: yy,aa,omx\n  integer :: ii,nn\n  logical :: y_lt_0\n!\n  if (abs(xx).eq.rzro) then\n    if (eunit.gt.0) write(eunit,*) 'error in oneloop bnlog_r: ' &\n      ,'argument xx=',trim(myprint(xx,8)),', returning 0'\n    rslt = 0\n    return\n  elseif (abs(xx-1).le.epsn*10) then\n    aa = 1\n    rslt = -1\n    do ii=2,irank+1\n      rslt = rslt - aa/ii\n    enddo\n    return\n  endif\n!\n  yy = 1-1/xx\n  y_lt_0 = (yy.lt.rzro)\n  if (y_lt_0) then \n    yy = log(-yy)\n    aa = sqrt(yy*yy+onepi*onepi)\n  else\n    yy = log( yy)\n    aa = abs(yy)\n  endif\n!\n  omx = 1\n  do ii=irank,1,-1\n    omx = 1+xx*omx\n  enddo\n  omx = (1-xx)*omx ! (1-x^{rank+1})\n!\n  if     (aa.ge.thrs(6,irank,prcpar)) then\n    rslt = acoef(irank,irank)\n    do ii=irank,1,-1\n      rslt = acoef(ii-1,irank) + xx*rslt\n    enddo\n    rslt = omx*yy - rslt/acoef(irank,irank)\n!    if     (irank.eq.0) then\n!      rslt = omx*yy - 1\n!    elseif (irank.eq.1) then\n!      rslt = omx*yy - (1+xx*2)/2\n!    elseif (irank.eq.2) then\n!      rslt = omx*yy - (2+xx*(3+xx*6))/6\n!    elseif (irank.eq.3) then\n!      rslt = omx*yy - (3+xx*(4+xx*(6+xx*12)))/12\n!    elseif (irank.eq.4) then\n!      rslt = omx*yy - (12+xx*(15+xx*(20+xx*(30+xx*60))))/60\n!    endif\n    if (y_lt_0) rslt = rslt + sgn*omx*ipi\n    return\n  elseif (aa.ge.thrs(5,irank,prcpar)) then ;nn=ntrm(6,irank,prcpar)\n  elseif (aa.ge.thrs(4,irank,prcpar)) then ;nn=ntrm(5,irank,prcpar)\n  elseif (aa.ge.thrs(3,irank,prcpar)) then ;nn=ntrm(4,irank,prcpar)\n  elseif (aa.ge.thrs(2,irank,prcpar)) then ;nn=ntrm(3,irank,prcpar)\n  elseif (aa.ge.thrs(1,irank,prcpar)) then ;nn=ntrm(2,irank,prcpar)\n                                      else ;nn=ntrm(1,irank,prcpar)\n  endif\n!\n  aa = coeff(nn,irank)\n  do ii=nn-1,2+irank,-1\n    aa = coeff(ii,irank) + yy*aa\n  enddo\n  rslt = -(irank+1)*aa*yy*(yy*xx)**(irank+1)\n  if (y_lt_0) rslt = rslt + sgn*omx*ipi\n!  \n  end function\n"}
{"id": 48, "function": "    function random_hermitian(n)\n    integer :: n\n    complex*16, dimension(1:n,1:n) :: random_hermitian\n    end function\n"}
{"id": 49, "function": "function random_hermitian(n)\n! generates an order n hermitian matrix with random entries x+iy\n! where each x and y are uniformly distributed between -1 and 1\nimplicit none\ninteger :: n, ii, jj\ncomplex*16, dimension(n,n) :: random_hermitian\nreal*8, dimension(n,n) :: a, b\n\n    call random_number(a)\n    ! rescaling into an element in (-1,1)\n    a = 2*a - 1\n    call random_number(b)\n    ! rescaling into an element in (-1,1)\n    b = 2*b - 1\n\n    ! populating the matrix\n    do ii = 1,n\n        do jj = 1,n\n            ! replacing entries in the lower triangle\n            if ((jj.gt.ii).and.(ii.lt.n)) then\n                a(jj,ii) = a(ii,jj)\n                ! the imaginary part is negative, to achieve hermicity\n                b(jj,ii) = -b(ii,jj)\n            end if\n            ! cast into a complex entry\n            random_hermitian(ii,jj) = complex(a(ii,jj),b(ii,jj))\n        end do\n    end do\n\nend function random_hermitian\n"}
{"id": 50, "function": "function weight_k(kk,gg,vv) result(y)\n\nuse view_struct\nuse config\nuse util\n\nimplicit none\n\nreal(kind=8) :: kk(3),gg(3)\ncomplex(kind=8) :: vv(:)\ninteger(kind=4) :: ii,jj,i,j,k\ncomplex(kind=8) :: y3(natm*3)\nreal(kind=8) :: y\n\ny3 = 0.0d0\ndo ii=1,natm\n    do jj = 1,3\n        do i = 1,nx_sc\n            do j = 1,ny_sc\n                do k = 1,nz_sc\n                    y3(3*(ii-1)+jj) = y3(3*(ii-1)+jj) + &\n                    vv((i-1)*ny_sc*nz_sc*natm*3 &\n                           +(j-1)*nz_sc*natm*3 &\n                           +(k-1)*natm*3 &\n                           +(ii-1)*3+jj) &\n                           *exp(-i_imag*dot_product( &\n                           pos_sc((i-1)*ny_sc*nz_sc*natm &\n                           +(j-1)*nz_sc*natm &\n                           +(k-1)*natm+ii,:)&\n                            -pos(ii,:),gg+kk))\n                end do\n            end do\n        end do\n    end do\nend do\ny = dot_product(y3,y3)\n\nend function\n"}
{"id": 51, "function": "function f_maxdiff_i0(a,b,n) result(maxdiff)\n  use f_utils, only: f_diff\n  implicit none\n  integer(f_integer), intent(inout) :: a\n  integer(f_integer), intent(inout) :: b\n  integer(f_integer) :: maxdiff\n  integer, intent(in), optional :: n\n  !local variables\n  integer(f_long) :: ns,nd,cnt\n  ns=-1\n  nd=-1\n  include 'f_maxdiff-base-inc.f90'\nend function f_maxdiff_i0\n"}
{"id": 52, "function": "function f_maxdiff_r0(a,b,n) result(maxdiff)\n  use f_utils, only: f_diff\n  implicit none\n  real, intent(inout) :: a\n  real, intent(inout) :: b\n  real :: maxdiff\n  integer, intent(in), optional :: n\n  !local variables\n  integer(f_long) :: ns,nd,cnt\n  ns=-1\n  nd=-1\n  include 'f_maxdiff-base-inc.f90'\nend function f_maxdiff_r0\n"}
{"id": 53, "function": "function f_maxdiff_c0i1(a,b,n) result(maxdiff)\n  use f_utils, only: f_diff\n  implicit none\n  character(len=*), intent(in) :: a\n  integer(f_integer), dimension(:), intent(in) :: b\n  integer(f_integer) :: maxdiff\n  integer, intent(in), optional :: n\n  !local variables\n  integer(f_long) :: ns,nd,cnt\n  ns=f_sizeof(a)\n  nd=f_sizeof(b)\n  include 'f_maxdiff-base-inc.f90'\nend function f_maxdiff_c0i1\n"}
{"id": 54, "function": "function f_maxdiff_d2d1(a,b,n) result(maxdiff)\n  use f_utils, only: f_diff\n  implicit none\n  double precision, dimension(:,:), intent(in) :: a \n  double precision, dimension(:), intent(in) :: b\n  double precision :: maxdiff\n  integer, intent(in), optional :: n\n  !local variables\n  integer(f_long) :: ns,nd,cnt\n  nd=f_sizeof(a)\n  ns=f_sizeof(b)\n  include 'f_maxdiff-base-inc.f90'\nend function f_maxdiff_d2d1\n"}
{"id": 55, "function": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}
{"id": 56, "function": "  character(len=len_time_string_short) function getrefframeepoch(iframe) result(cepoch)\n\n    integer, intent(in)    :: iframe\n\n    character(len=*), parameter :: csubid = 'getrefframeepoch'\n    character(len=3) :: ctemp\n\n    if(iscontrolled()) then\n      if(hastoreturn()) return\n      call checkin(csubid)\n    end if\n\n    cepoch = \"0000-00-00t00:00:00\"\n\n    select case (iframe)\n\n      case (ref_frame_j2000)\n        cepoch = \"2000-01-01t12:00:00\"\n\n      case default\n\n        write(ctemp,'(i3)') iframe\n        call seterror(e_frame, fatal, (/ctemp/))\n        return\n\n    end select\n\n    !** done\n    if(iscontrolled()) then\n      call checkout(csubid)\n    end if\n\n    return\n\n  end function getrefframeepoch\n"}
{"id": 57, "function": "  integer function getframecenterid(cname) result(iout)\n\n    character(len=*), intent(in)    :: cname\n\n    character(len=*), parameter :: csubid = 'getframecenterid'\n\n    iout = -1\n\n    if(iscontrolled()) then\n      if(hastoreturn()) return\n      call checkin(csubid)\n    end if\n\n\n    select case (touppercase(trim(cname)))\n\n      case (c_frame_center_earth)  !** earth\n        iout = frame_center_earth\n\n      case (c_frame_center_earth_barycenter) !** earth barycenter\n        iout = frame_center_earth_barycenter\n\n      case default !** unknown\n\n        call seterror(e_frame_center, fatal, (/cname/))\n        return\n\n    end select\n\n    !** done\n    if(iscontrolled()) then\n      call checkout(csubid)\n    end if\n\n    return\n\n  end function getframecenterid\n"}
{"id": 58, "function": "  character(len=len(c_frame_center_earth_barycenter)) function getframecentername(icenter) result(ccenter)\n\n    integer, intent(in)    :: icenter  ! center counter\n\n    character(len=*), parameter :: csubid = 'getframecentername'\n    character(len=3) :: ctemp\n\n    if(iscontrolled()) then\n      if(hastoreturn()) return\n      call checkin(csubid)\n    end if\n\n    select case(icenter)\n\n      case(frame_center_earth)\n        ccenter = c_frame_center_earth\n\n      case(frame_center_earth_barycenter)\n        ccenter = c_frame_center_earth_barycenter\n\n      case default\n\n        write(ctemp,'(i3)') icenter\n        call seterror(e_frame_center, fatal, (/ctemp/))\n        return\n\n    end select\n\n    !** done\n    if(iscontrolled()) then\n      call checkout(csubid)\n    end if\n\n    return\n\n  end function getframecentername\n"}
{"id": 59, "function": "character(len=max_id_length) function getframename(id)\n\n  integer, intent(in) :: id\n\n  character(len=20) :: cid\n  character(len=*), parameter :: csubid = 'getframename'\n\n  if(iscontrolled()) then\n    if(hastoreturn()) return\n    call checkin(csubid)\n  end if\n\n  write(cid,'(i20)') id\n\n  select case(id)\n    case(frame_not_available)\n      getframename = c_frame_not_available\n\n    case(ref_frame_eci)\n      getframename = c_ref_frame_eci\n\n    case(ref_frame_gcrf)\n      getframename = c_ref_frame_gcrf\n\n    case(ref_frame_itrf_2000)\n      getframename = c_ref_frame_itrf_2000\n\n    case(ref_frame_itrf_2005)\n      getframename = c_ref_frame_itrf_2005\n\n    case(ref_frame_uvw)\n      getframename = c_ref_frame_uvw\n\n    case(ref_frame_wgs84)\n      getframename = c_ref_frame_wgs84\n\n    case(ref_frame_j2000)\n      getframename = c_ref_frame_j2000\n\n    case(ref_frame_ocrf)\n      getframename = c_ref_frame_ocrf\n\n    case(ref_frame_rsw)\n      getframename = c_ref_frame_rsw\n\n    case(ref_frame_teme)\n      getframename = c_ref_frame_teme\n\n    case default\n      call seterror(e_unknown_parameter, fatal, (/cid/))\n      return\n  end select\n\n  !** done!\n  if(iscontrolled()) then\n    call checkout(csubid)\n  end if\n\n  return\n\nend function getframename\n"}
{"id": 60, "function": "integer function getframeid(cname)\n\n  character(len=*), intent(in) :: cname\n\n  character(len=*), parameter :: csubid = 'getframeid'\n  character(len=len(cname)) :: cuname   ! uppercase version of cname\n\n  getframeid = 0\n\n  if(iscontrolled()) then\n    if(hastoreturn()) return\n    call checkin(csubid)\n  end if\n\n  cuname = touppercase(cname)\n\n  select case(cuname)\n    case(c_frame_not_available)\n      getframeid = 0\n\n    case(c_ref_frame_eci)\n      getframeid = ref_frame_eci\n\n    case(c_ref_frame_itrf_2000, c_ref_frame_itr00)\n      getframeid = ref_frame_itrf_2000\n\n    case(c_ref_frame_itrf_2005, c_ref_frame_itr05)\n      getframeid = ref_frame_itrf_2005\n\n    case(c_ref_frame_gcrf)\n      getframeid = ref_frame_gcrf\n\n    case(c_ref_frame_uvw)\n      getframeid = ref_frame_uvw\n\n    case(c_ref_frame_wgs84)\n      getframeid = ref_frame_wgs84\n\n    case(c_ref_frame_j2000)\n      getframeid = ref_frame_j2000\n\n    case(c_ref_frame_ocrf)\n      getframeid = ref_frame_ocrf\n\n    case(c_ref_frame_rsw)\n      getframeid = ref_frame_rsw\n\n    case(c_ref_frame_teme)\n      getframeid = ref_frame_teme\n\n    case default\n      call seterror(e_unknown_parameter, fatal, (/cname/))\n      return\n\n  end select\n\n  !** done!\n  if(iscontrolled()) then\n    call checkout(csubid)\n  end if\n\nend function getframeid\n"}
{"id": 61, "function": "    function x(n, m)\n      integer, optional :: m\n      if (present(m)) then\n        x = real(n)**m\n      else\n        x = 0.0\n      end if\n    end function\n"}
{"id": 62, "function": "    type (yca_vpd_type) function yca_vpd_type_constructor(weather, control, soilprop)\r\n        implicit none\r\n        \r\n        \r\n        type (controltype), intent (in) :: control    ! defined in moduledefs\r\n        type (weathertype), intent (in) :: weather    ! defined in moduledefs\r\n        type (soiltype), intent (in) ::   soilprop   ! defined in moduledefs\r\n        \r\n        yca_vpd_type_constructor%weather = weather\r\n        yca_vpd_type_constructor%control = control\r\n        yca_vpd_type_constructor%soilprop= soilprop\r\n        \r\n    end function yca_vpd_type_constructor    \r\n"}
{"id": 63, "function": "    integer function get_yca_dap()\r\n        use yca_first_trans_m\r\n        implicit none\r\n        \r\n        get_yca_dap = dap\r\n    end function get_yca_dap\r\n"}
{"id": 64, "function": "    real function get_yca_phsv()\r\n        use yca_first_trans_m\r\n        implicit none\r\n        \r\n        get_yca_phsv = phsv\r\n    end function get_yca_phsv\r\n"}
{"id": 65, "function": "    real function get_yca_phtv()\r\n        use yca_first_trans_m\r\n        implicit none\r\n        \r\n        get_yca_phtv = phtv\r\n    end function get_yca_phtv\r\n"}
{"id": 66, "function": "    real function get_yca_vpdfphr(this, hour)\r\n        use moduledefs\r\n        use yca_growth_vpd\r\n        \r\n        implicit none\r\n        class (yca_vpd_type), intent(in) :: this\r\n        integer, intent(in) :: hour\r\n        \r\n        get_yca_vpdfphr = get_growth_vpdfphr(get_yca_phsv(), get_yca_phtv(),  this%weather % tdew, this%weather % tmin, this%weather % tairhr,hour)\r\n    end function get_yca_vpdfphr\r\n"}
{"id": 67, "function": "    real function get_yca_vpdfp(this,lai)\r\n        use moduledefs\r\n        use yca_growth_vpd\r\n        \r\n        implicit none\r\n        class (yca_vpd_type), intent(in) :: this\r\n        real lai\r\n        \r\n        get_yca_vpdfp = get_growth_vpdfp(get_yca_dap(), lai, get_yca_phsv(), get_yca_phtv(),  this%weather, this%control, this%soilprop)\r\n        \r\n    end function get_yca_vpdfp\r\n"}
{"id": 68, "function": "\treal(dp) pure function d0_fd_stat(e_band, e_fermi,\tt_kelvin) \n\t\treal(dp), \t\tintent(in)\t\t\t::\te_band, e_fermi, t_kelvin\n\t\treal(dp)\t\t\t\t\t\t\t::\tt_smear\n\t\t!\n\t\td0_fd_stat\t\t=\t0.0_dp\n\t\t!\n\t\tif(\t t_kelvin > min_temp ) \t\t\t\tthen\n\t\t\t!\n\t\t\t!\tfinite temperature\n\t\t\tt_smear\t\t\t=\tkboltz_eh_k\t\t*\tt_kelvin\n\t\t\td0_fd_stat\t\t \t= \t1.0_dp\t/\t(\t1.0_dp\t+\texp(\t(e_band\t- e_fermi)\t/\t(t_smear)))\n\t\t\t!\n\t\t\t!\n\t\telse if(\te_band < e_fermi\t)  \t\tthen\n\t\t\t!\t\n\t\t\t!\tzero temperature\n\t\t\td0_fd_stat\t=\t1.0_dp\n\t\tend if\n\t\t!\n\t\t!\n\t\treturn\n\tend function\n"}
{"id": 69, "function": "logical function coupling(atoma,atomb,coupling_mat)\n    use modcommons\n    implicit none\n    type(qatom) :: atoma,atomb\n    complex*16  :: coupling_mat(:,:) ! you must overwrite this variable\n    ! local variables\n    integer         :: xdiff,ydiff\n    doubleprecision :: dydiff,dxdiff,t0,mu,delta\n\n    ! calculate distance between atoms in units of dx.\n    dxdiff = (atoma%atom_pos(1)-atomb%atom_pos(1))/dx\n    dydiff = (atoma%atom_pos(2)-atomb%atom_pos(2))/dx\n    ! convert it to integers\n    xdiff = nint(dxdiff)\n    ydiff = nint(dydiff)\n    ! default return value\n    coupling       = .false.\n    coupling_mat   = 0.0\n\n    t0    = 1.0 ! hoping energy\n    mu    = 0.7 ! chemical potential\n    delta = 0.1 ! superconducting order parameter\n\n    if( xdiff == 0 .and. ydiff == 0 ) then\n        coupling     = .true.\n        coupling_mat = (4*t0 - mu)* mat_sz + delta*mat_sx\n    else if( abs(xdiff) ==  1 .and. ydiff == 0 ) then\n        coupling     = .true.\n        coupling_mat = -t0 *(mat_sz)\n    else if( xdiff ==  0 .and. abs(ydiff) == 1 ) then\n        coupling     = .true.\n        coupling_mat = -t0 *(mat_sz)\n    endif\nend function coupling\n"}
{"id": 70, "function": "    real function foo (x)\n      !$omp declare target\n      real, intent(in) :: x\n    end function foo\n"}
{"id": 71, "function": "    impure elemental function add_tt(t1, t2) result(t)\n        type(tree_t), intent(in) :: t1, t2\n        type(tree_t) :: t\n\n        t = t1%node%value + t2%node%value\n\n        t%node%left => t1%node\n        t%node%right => t2%node\n\n        t%node%left_grad = 1.0_rk\n        t%node%right_grad = 1.0_rk\n\n    end function add_tt\n"}
{"id": 72, "function": "    impure elemental function add_tr(t1, r) result(t)\n        type(tree_t), intent(in) :: t1\n        real(rk), intent(in) :: r\n        type(tree_t) :: t\n\n        t = add_rt(r, t1)\n\n    end function add_tr\n"}
{"id": 73, "function": "    impure elemental function add_rt(r, t1) result(t)\n        real(rk), intent(in) :: r\n        type(tree_t), intent(in) :: t1\n        type(tree_t) :: t\n\n        t = t1%node%value + r\n\n        t%node%left => t1%node\n        t%node%left_grad = 1.0_rk\n\n    end function add_rt\n"}
{"id": 74, "function": "    impure elemental function sub_tt(t1, t2) result(t)\n        type(tree_t), intent(in) :: t1, t2\n        type(tree_t) :: t\n\n        t = add_tt(t1, mul_rt(-1.0_rk, t2))\n\n    end function sub_tt\n"}
{"id": 75, "function": "    impure elemental function sub_rt(r, t1) result(t)\n        real(rk), intent(in) :: r\n        type(tree_t), intent(in) :: t1\n        type(tree_t) :: t\n\n        t = add_rt(r, mul_rt(-1.0_rk, t1))\n\n    end function sub_rt\n"}
{"id": 76, "function": "    impure elemental function mul_rt(r, t1) result(t)\n        real(rk), intent(in) :: r\n        type(tree_t), intent(in) :: t1\n        type(tree_t) :: t\n\n        t = t1%node%value*r\n\n        t%node%left => t1%node\n        t%node%left_grad = r\n\n    end function mul_rt\n"}
{"id": 77, "function": "    impure elemental function pow_tt(t1, t2) result(t)\n        type(tree_t), intent(in) :: t1, t2\n        type(tree_t) :: t\n\n        t = t1%node%value**t2%node%value\n\n        t%node%left => t1%node\n        t%node%right => t2%node\n\n        ! t%node%left_grad = t2%node%value*t1%node%value**(t2%node%value-1.0_rk)\n        ! t%node%right_grad = t1%node%value**t2%node%value*log(t1%node%value)\n        t%node%left_grad = t%node%value*(log(t1%node%value) + t2%node%value/t1%node%value)\n        t%node%right_grad = t%node%value*(log(t1%node%value) + t2%node%value/t1%node%value)\n\n    end function pow_tt\n"}
{"id": 78, "function": "    impure elemental function pow_ti(t1, i) result(t)\n        type(tree_t), intent(in) :: t1\n        integer, intent(in) :: i\n        type(tree_t) :: t\n\n        t = t1%node%value**i\n\n        t%node%left => t1%node\n        t%node%left_grad = i*t%node%value**(i - 1)\n\n    end function pow_ti\n"}
{"id": 79, "function": "            function getrealarray( inputline ) result(x)\n               use smconstants\n               implicit none\n               real(kind=rp), dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getrealarray\n"}
{"id": 80, "function": "            function getintarray( inputline ) result(x)\n               implicit none\n               integer, dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getintarray\n"}
{"id": 81, "function": "pure function lagrange_polynomial(n, nodes, j, x) result(lp)\n    \n    integer, intent(in) :: n\n    real(dp), intent(in)    :: nodes(n)\n    integer, intent(in) :: j\n    real(dp), intent(in)    :: x\n\n    real(dp)    :: lp\n    integer :: i\n\n    lp = 1.0_dp\n\n    if (abs(x-nodes(j)) < 10.0_dp*tol) return !! kronecker property\n\n    do i = 1,n\n        if (i == j) cycle\n        lp = lp * (x - nodes(i))/(nodes(j) - nodes(i))\n    end do\n     \nend function\n"}
{"id": 82, "function": "pure function lagrange_basis(n, nodes, x) result(lp)\n    \n    integer, intent(in) :: n\n    real(dp), intent(in)    :: nodes(n)\n    real(dp), intent(in)    :: x\n\n    real(dp)    :: lp(n)\n    integer :: i\n\n    !! kronecker property\n    if (any(abs(x-nodes) < 10*tol)) then\n        lp = merge(1.0_dp,0.0_dp,abs(x-nodes) < 10.0_dp*tol)\n        return\n    end if\n\n    do i = 1,n\n        lp(i) = lagrange_polynomial(n, nodes, i, x)\n    end do\n     \nend function\n"}
{"id": 83, "function": "      function dilog(x)\n!--------------------------------------------------------------------\n!\n\n!\n!--------------------------------------------------------------------\n      implicit real (16)      (a-h,o-z)\n      real (16), parameter :: zero = 0.0q0\n      real (16), parameter :: one  = 1.0q0\n      real (16), parameter :: half = 0.5q0\n      real (16), parameter :: pi = 3.141592653589793238462643383279502884q0\n!\n      pi2  = pi**2/6\n\n!\t  if (x == -0.5q0) then\n!\t\tdilog = -0.44841420692364620244306440591577\n!\t\treturn\n!\t  endif \n!\n      if (x.eq.zero) then\n         dilog = pi2\n         return\n      else if (x.eq.one) then\n         dilog = zero\n         return\n      end if\n      if (abs(one-x) <= one .and. x >= half) then\n         y = -log(x)\n         dilog = debay(y)\n      else if (abs(x) <= one .and. x < half) then\n         y = -log(one-x)\n\t\t cc = log(x)\n         cc = pi2-log(one-x)*log(x)\n         dilog = cc-debay(y)\n      else\n         xx = one/x\n         y = -log(one-xx)\n         cc = pi2-log(one-xx)*log(xx)\n         cc = cc-debay(y)\n         dilog = -half*log(xx)**2-cc\n      end if\n!\n      return\n\ncontains\n\nfunction debay(z)\n!----------------------------------------------------------------------\n!\n\n!                         argument using taylor's series at z=0\n!\n!----------------------------------------------------------------------\nimplicit real (16) (a-h,o-z)\nreal (16), save      :: b(30)\nreal (16), parameter :: zero = 0.0q0\nreal (16), parameter :: one  = 1.0q0\nreal (16), parameter :: fourth = 0.25q0\nlogical,     save      :: notinit= .true.\n\nif (notinit) then\n   b( 1) =  2.7777777777777777777777777777777777777777777777778q-02\n   b( 2) = -2.7777777777777777777777777777777777777777777777778q-04\n   b( 3) =  4.7241118669690098261526832955404383975812547241119q-06\n   b( 4) = -9.1857730746619635508524397413286302175191064079953q-08\n   b( 5) =  1.8978869988970999072009173019274029375039476049577q-09\n   b( 6) = -4.0647616451442255268059093862919666745470571274397q-11\n   b( 7) =  8.9216910204564525552179873167527488515142836130490q-13\n   b( 8) = -1.9939295860721075687236443477937897056306947496539q-14\n   b( 9) =  4.5189800296199181916504765528555932283968190144666q-16\n   b(10) = -1.0356517612181247014483411542218656665960912381687q-17\n   b(11) =  2.3952186210261867457402837430009803816789490019430q-19\n   b(12) = -5.5817858743250093362830745056254199055670546676444q-21\n   b(13) =  1.3091507554183212858123073991865923017498498387833q-22\n   b(14) = -3.0874198024267402932422797648664624315955652561327q-24\n   b(15) =  7.3159756527022034203579056092521485910334010636909q-26\n   b(16) = -1.7408456572340007409890551477597025453408414217543q-27\n   b(17) =  4.1576356446138997196178996207752266734882541595116q-29\n   b(18) = -9.9621484882846221031940067024558388498548600173945q-31\n   b(19) =  2.3940344248961653005211679878937495629342791569329q-32\n   b(20) = -5.7683473553673900842917931618776542440723323179263q-34\n   b(21) =  1.3931794796470079778278866039115483317324116256734q-35\n   b(22) = -3.3721219654850894704684736352549309589797428916565q-37\n   b(23) =  8.1782087775621026217647772148728342678761894624955q-39\n   b(24) = -1.9870108311523859255648206692347865675418589958247q-40\n   b(25) =  4.8357785180405508962870593731153782076944653694208q-42\n   b(26) = -1.1786937248718384326695767537213903193540705623059q-43\n   b(27) =  2.8770964081172571450019667396886617096883686589417q-45\n   b(28) = -7.0320590981560280149649336675824257240019745278063q-47\n   b(29) =  1.7208603145033146290899515161658919198419990913276q-48\n   b(30) = -4.2160723905604454916800318192859916156937012298717q-50\n   notinit = .false.\nend if\n\nz2 = z*z\nsm = zero\nyk = one\ndo k=1,30\n   yk = yk*z2\n   test = sm\n   sm = sm+b(k)*yk\n   if (test.eq.sm) exit\nend do\ndebay = z*(one-fourth*z+sm)\n\nreturn\nend function debay\n\nend function dilog\n"}
{"id": 84, "function": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}
{"id": 85, "function": "  function is_an_inf (val) result(r)\n\n    real(dp_t), intent(in) :: val\n    logical                :: r\n\n    integer :: rc\n\n    interface\n       subroutine val_is_inf(v, res)\n         use bl_types\n         real(dp_t), intent(in)  :: v\n         integer,    intent(out) :: res\n       end subroutine val_is_inf\n    end interface\n\n    r = .false.\n\n    call val_is_inf(val,rc)\n\n    if (rc == 1) r = .true.\n    \n  end function is_an_inf\n"}
{"id": 86, "function": "  function contains_nan_c(fb,c,nc) result(r)\n\n    use bl_error_module\n\n    logical               :: r\n    type(fab), intent(in) :: fb\n    integer,   intent(in) :: c, nc\n\n    integer                  :: sz, rc\n    real(kind=dp_t), pointer :: pp(:,:,:,:)\n\n    interface\n       subroutine fab_contains_nan(dptr, count, res)\n         use bl_types\n         integer,    intent(in)  :: count\n         real(dp_t), intent(in)  :: dptr(count)\n         integer,    intent(out) :: res\n       end subroutine fab_contains_nan\n    end interface\n\n    if ( (c+nc-1) > fb%nc ) call bl_error('contains_nan_c: not enough components')\n\n    r = .false.\n\n    pp => dataptr(fb)\n\n    sz = volume(get_pbox(fb)) * nc\n\n    call fab_contains_nan(pp(:,:,:,c), sz, rc)\n\n    if (rc == 1) r = .true.\n\n  end function contains_nan_c\n"}
{"id": 87, "function": "  function contains_nan_allc(fb) result(r)\n    logical               :: r\n    type(fab), intent(in) :: fb\n    r = contains_nan_c(fb,1,ncomp(fb))\n  end function contains_nan_allc\n"}
{"id": 88, "function": "  function contains_nan_bx_c(fb,bx,c,nc) result(r)\n\n    logical               :: r\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    integer,   intent(in) :: c, nc\n\n    integer                      :: sz, rc, i, j, k, n, idx, lo(4), hi(4)\n    real(kind=dp_t), allocatable :: d(:)\n    real(kind=dp_t), pointer     :: pp(:,:,:,:)\n\n    interface\n       subroutine fab_contains_nan(dptr, count, res)\n         use bl_types\n         integer,    intent(in)  :: count\n         real(dp_t), intent(in)  :: dptr(count)\n         integer,    intent(out) :: res\n       end subroutine fab_contains_nan\n    end interface\n\n    r = .false.\n\n    sz = volume(bx) * nc\n\n    allocate(d(sz))\n\n    pp => dataptr(fb,bx,c,nc)\n\n    lo = lbound(pp)\n    hi = ubound(pp)\n\n    idx = 1\n    do n = lo(4), hi(4)\n       do k = lo(3), hi(3)\n          do j = lo(2), hi(2)\n             do i = lo(1), hi(1)\n                d(idx) = pp(i,j,k,n)\n                idx = idx + 1\n             end do\n          end do\n       end do\n    end do\n\n    call fab_contains_nan(d,sz,rc)\n\n    if (rc == 1) r = .true.\n\n  end function contains_nan_bx_c\n"}
{"id": 89, "function": "  function least_used_cpus () result(r)\n\n    use parallel\n    use sort_i_module\n\n    integer, pointer     :: r(:)\n    integer              :: i, nprocs\n    integer, allocatable :: snd(:), rcv(:), idx(:)\n\n    integer(ll_t) :: val  ! number of double precision values stored in fabs on this cpu.\n    \n    nprocs = parallel_nprocs()\n\n    allocate(r(0:nprocs-1))\n\n    allocate(snd(1), rcv(nprocs))\n\n    if (manual_control_least_used_cpus) then\n       val = mcluc_vol\n    else\n       val = fab_ms%num_alloc - fab_ms%num_dealloc\n    end if\n\n    snd(1) = int(val)\n\n    call parallel_allgather(snd, rcv, 1)\n\n    allocate(idx(nprocs))\n    call stable_sort(rcv, idx)\n    r = idx - 1\n\n    if ( .false. .and. parallel_ioprocessor() ) then\n       print*, '*** least_used_cpus(): '\n       do i = 0, nprocs-1\n          print*, i, ' : ', r(i)\n       end do\n    end if\n\n  end function least_used_cpus\n"}
{"id": 90, "function": "  function fab_mem_stats() result(r)\n    type(mem_stats) :: r\n    r = fab_ms\n  end function fab_mem_stats\n"}
{"id": 91, "function": "  function zfab_mem_stats() result(r)\n    type(mem_stats) :: r\n    r = zfab_ms\n  end function zfab_mem_stats\n"}
{"id": 92, "function": "  function ifab_mem_stats() result(r)\n    type(mem_stats) :: r\n    r = ifab_ms\n  end function ifab_mem_stats\n"}
{"id": 93, "function": "  function lfab_mem_stats() result(r)\n    type(mem_stats) :: r\n    r = lfab_ms\n  end function lfab_mem_stats\n"}
{"id": 94, "function": "  function fab_get_high_water_mark() result(r)\n    integer(ll_t) :: r\n    r = fab_high_water_mark\n  end function fab_get_high_water_mark\n"}
{"id": 95, "function": "  function fab_volume(fb, all) result(r)\n    integer(kind=ll_t) :: r\n    type(fab), intent(in) :: fb\n    logical, intent(in), optional :: all\n    if ( all ) then\n       r = volume(get_pbox(fb))\n    else\n       r = volume(get_box(fb))\n    end if\n    r = r * fb%nc\n  end function fab_volume\n"}
{"id": 96, "function": "  function ifab_volume(fb, all) result(r)\n    integer(kind=ll_t) :: r\n    type(ifab), intent(in) :: fb\n    logical, intent(in), optional :: all\n    if ( all ) then\n       r = volume(get_pbox(fb))\n    else\n       r = volume(get_box(fb))\n    end if\n    r = r * fb%nc\n  end function ifab_volume\n"}
{"id": 97, "function": "  pure function fab_lwb(fb) result(r)\n    type(fab), intent(in) :: fb\n    integer :: r(fb%dim)\n    r = lwb(fb%bx)\n  end function fab_lwb\n"}
{"id": 98, "function": "  pure function fab_lwb_n(fb,dim) result(r)\n    type(fab), intent(in) :: fb\n    integer, intent(in) :: dim\n    integer :: r\n    r = lwb(fb%bx,dim)\n  end function fab_lwb_n\n"}
{"id": 99, "function": "  pure function zfab_lwb(fb) result(r)\n    type(zfab), intent(in) :: fb\n    integer :: r(fb%dim)\n    r = lwb(fb%bx)\n  end function zfab_lwb\n"}
{"id": 100, "function": "  pure function zfab_lwb_n(fb,dim) result(r)\n    type(zfab), intent(in) :: fb\n    integer, intent(in) :: dim\n    integer :: r\n    r = lwb(fb%bx,dim)\n  end function zfab_lwb_n\n"}
{"id": 101, "function": "  pure function fab_ilwb(fb) result(r)\n    type(fab), intent(in) :: fb\n    integer :: r(fb%dim)\n    r = lwb(fb%ibx)\n  end function fab_ilwb\n"}
{"id": 102, "function": "  pure function ifab_ilwb(fb) result(r)\n    type(ifab), intent(in) :: fb\n    integer :: r(fb%dim)\n    r = lwb(fb%ibx)\n  end function ifab_ilwb\n"}
{"id": 103, "function": "  pure function ifab_iupb(fb) result(r)\n    type(ifab), intent(in) :: fb\n    integer :: r(fb%dim)\n    r = upb(fb%ibx)\n  end function ifab_iupb\n"}
{"id": 104, "function": "  pure function zfab_ncomp(fb) result(r)\n    integer :: r\n    type(zfab), intent(in) :: fb\n    r = fb%nc\n  end function zfab_ncomp\n"}
{"id": 105, "function": "  pure function lfab_ncomp(fb) result(r)\n    integer :: r\n    type(lfab), intent(in) :: fb\n    r = fb%nc\n  end function lfab_ncomp\n"}
{"id": 106, "function": "  pure function zfab_get_box(fb) result(r)\n    type(zfab), intent(in) :: fb\n    type(box) :: r\n    r = fb%bx\n  end function zfab_get_box\n"}
{"id": 107, "function": "  pure function lfab_get_box(fb) result(r)\n    type(lfab), intent(in) :: fb\n    type(box) :: r\n    r = fb%bx\n  end function lfab_get_box\n"}
{"id": 108, "function": "  pure function fab_get_pbox(fb) result(r)\n    type(fab), intent(in) :: fb\n    type(box) :: r\n    r = fb%pbx\n  end function fab_get_pbox\n"}
{"id": 109, "function": "  pure function zfab_get_pbox(fb) result(r)\n    type(zfab), intent(in) :: fb\n    type(box) :: r\n    r = fb%pbx\n  end function zfab_get_pbox\n"}
{"id": 110, "function": "  pure function fab_get_ibox(fb) result(r)\n    type(fab), intent(in) :: fb\n    type(box) :: r\n    r = fb%ibx\n  end function fab_get_ibox\n"}
{"id": 111, "function": "  pure function zfab_get_ibox(fb) result(r)\n    type(zfab), intent(in) :: fb\n    type(box) :: r\n    r = fb%ibx\n  end function zfab_get_ibox\n"}
{"id": 112, "function": "  pure function ifab_get_ibox(fb) result(r)\n    type(ifab), intent(in) :: fb\n    type(box) :: r\n    r = fb%ibx\n  end function ifab_get_ibox\n"}
{"id": 113, "function": "  pure function lfab_get_ibox(fb) result(r)\n    type(lfab), intent(in) :: fb\n    type(box) :: r\n    r = fb%ibx\n  end function lfab_get_ibox\n"}
{"id": 114, "function": "  pure function fab_built_q(fb) result(r)\n    type(fab), intent(in) :: fb\n    logical :: r\n    r = fb%dim /= 0\n  end function fab_built_q\n"}
{"id": 115, "function": "  pure function zfab_built_q(fb) result(r)\n    type(zfab), intent(in) :: fb\n    logical :: r\n    r = fb%dim /= 0\n  end function zfab_built_q\n"}
{"id": 116, "function": "  pure function ifab_built_q(fb) result(r)\n    type(ifab), intent(in) :: fb\n    logical :: r\n    r = fb%dim /= 0\n  end function ifab_built_q\n"}
{"id": 117, "function": "  pure function lfab_built_q(fb) result(r)\n    type(lfab), intent(in) :: fb\n    logical :: r\n    r = fb%dim /= 0\n  end function lfab_built_q\n"}
{"id": 118, "function": "  function fab_dataptr(fb) result(r)\n    type(fab), intent(in) :: fb\n    real(kind=dp_t), pointer :: r(:,:,:,:)\n    r => fb%p\n  end function fab_dataptr\n"}
{"id": 119, "function": "  function zfab_dataptr(fb) result(r)\n    type(zfab), intent(in) :: fb\n    complex(kind=dp_t), pointer :: r(:,:,:,:)\n    r => fb%p\n  end function zfab_dataptr\n"}
{"id": 120, "function": "  function ifab_dataptr(fb) result(r)\n    type(ifab), intent(in) :: fb\n    integer, pointer :: r(:,:,:,:)\n    r => fb%p\n  end function ifab_dataptr\n"}
{"id": 121, "function": "  function lfab_dataptr(fb) result(r)\n    type(lfab), intent(in) :: fb\n    logical, pointer :: r(:,:,:,:)\n    r => fb%p\n  end function lfab_dataptr\n"}
{"id": 122, "function": "  function fab_dataptr_bx(fb, bx) result(r)\n    use bl_error_module\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    real(kind=dp_t), pointer :: r(:,:,:,:)\n    if ( .not. contains(fb%pbx, bx) ) call bl_error('fab_dataptr_bx: bx is too large')\n    select case (fb%dim)\n    case (1)\n       r => fb%p(bx%lo(1):bx%hi(1),:,:,:)\n    case (2)\n       r => fb%p(bx%lo(1):bx%hi(1),bx%lo(2):bx%hi(2),:,:)\n    case (3)\n       r => fb%p(bx%lo(1):bx%hi(1),bx%lo(2):bx%hi(2),bx%lo(3):bx%hi(3),:)\n    end select\n  end function fab_dataptr_bx\n"}
{"id": 123, "function": "  function fab_dataptr_c(fb, c, nc) result(r)\n    use bl_error_module\n    type(fab), intent(in) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    real(kind=dp_t), pointer :: r(:,:,:,:)\n    integer :: lnc\n    lnc = 1; if ( present(nc) ) lnc = nc\n    if ( (c+lnc-1) > fb%nc ) call bl_error('fab_dataptr_c: not enough components')\n    r => fb%p(:,:,:,c:c+lnc-1)\n  end function fab_dataptr_c\n"}
{"id": 124, "function": "  function lfab_dataptr_c(fb, c, nc) result(r)\n    use bl_error_module\n    type(lfab), intent(in) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    logical, pointer :: r(:,:,:,:)\n    integer :: lnc\n    lnc = 1; if ( present(nc) ) lnc = nc\n    if ( (c+lnc-1) > fb%nc ) call bl_error('lfab_dataptr_c: not enough components')\n    r => fb%p(:,:,:,c:c+lnc-1)\n  end function lfab_dataptr_c\n"}
{"id": 125, "function": "  function fab_dataptr_bx_c(fb, bx, c, nc) result(r)\n    use bl_error_module\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    real(kind=dp_t), pointer :: r(:,:,:,:)\n    integer :: lnc\n    lnc = 1; if ( present(nc) ) lnc = nc\n    if ( (c+lnc-1) > fb%nc ) call bl_error('fab_dataptr_bx_c: not enough components')\n    if ( .not. contains(fb%pbx, bx) ) call bl_error('fab_dataptr_bx_c: bx is too large')\n    select case (fb%dim)\n    case (1)\n       r => fb%p(bx%lo(1):bx%hi(1),:,:,c:c+lnc-1)\n    case (2)\n       r => fb%p(bx%lo(1):bx%hi(1),bx%lo(2):bx%hi(2),:,c:c+lnc-1)\n    case (3)\n       r => fb%p(bx%lo(1):bx%hi(1),bx%lo(2):bx%hi(2),bx%lo(3):bx%hi(3),c:c+lnc-1)\n    end select\n  end function fab_dataptr_bx_c\n"}
{"id": 126, "function": "  function fab_minval_doit(ap) result(r)\n\n    real(dp_t), pointer :: ap(:,:,:,:)\n    real(dp_t)          :: r, r1\n\n    integer :: i, j, k, n, lo(4), hi(4)\n\n    lo = lbound(ap)\n    hi = ubound(ap)\n\n    ! minval(ap)\n\n    r1 = huge(r)\n\n    do n = lo(4), hi(4)\n       do k = lo(3), hi(3)\n          do j = lo(2), hi(2)\n             do i = lo(1), hi(1)\n                r1 = min(r1,ap(i,j,k,n))\n             end do\n          end do\n       end do\n    end do\n\n    r = r1\n\n  end function fab_minval_doit\n"}
{"id": 127, "function": "  function fab_max_val(fb, all) result(r)\n    real(kind=dp_t) :: r\n    type(fab), intent(in) :: fb\n    logical, intent(in), optional :: all\n    logical :: lall\n    real(dp_t), pointer :: mp(:,:,:,:)\n    lall = .false.; if ( present(all) ) lall = all\n    if ( lall ) then\n       mp => dataptr(fb, get_pbox(fb))\n    else\n       mp => dataptr(fb, get_ibox(fb))\n    end if\n    r = fab_maxval_doit(mp)\n  end function fab_max_val\n"}
{"id": 128, "function": "  function fab_max_val_c(fb, c, nc, all) result(r)\n    real(kind=dp_t) :: r\n    type(fab), intent(in) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    logical, intent(in), optional :: all\n    logical :: lall\n    real(dp_t), pointer :: mp(:,:,:,:)\n    lall = .false.; if ( present(all) ) lall = all\n    if ( lall ) then\n       mp => dataptr(fb, get_pbox(fb), c, nc)\n    else\n       mp => dataptr(fb, get_ibox(fb), c, nc)\n    end if\n    r = fab_maxval_doit(mp)\n  end function fab_max_val_c\n"}
{"id": 129, "function": "  function fab_max_val_bx(fb, bx) result(r)\n    real(kind=dp_t) :: r\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    real(dp_t), pointer :: mp(:,:,:,:)\n    mp => dataptr(fb, bx)\n    r = fab_maxval_doit(mp)\n  end function fab_max_val_bx\n"}
{"id": 130, "function": "  function fab_max_val_bx_c(fb, bx, c, nc) result(r)\n    real(kind=dp_t) :: r\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    real(dp_t), pointer :: mp(:,:,:,:)\n    mp => dataptr(fb, bx, c, nc)\n    r = fab_maxval_doit(mp)\n  end function fab_max_val_bx_c\n"}
{"id": 131, "function": "  function ifab_max_val_bx(fb, bx) result(r)\n    integer :: r\n    type(ifab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    integer, pointer :: mp(:,:,:,:)\n    mp => dataptr(fb, bx)\n    r = maxval(mp)\n  end function ifab_max_val_bx\n"}
{"id": 132, "function": "  function fab_min_val_bx(fb, bx) result(r)\n    real(kind=dp_t) :: r\n    type(fab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    real(dp_t), pointer :: mp(:,:,:,:)\n    mp => dataptr(fb, bx)\n    r = fab_minval_doit(mp)\n  end function fab_min_val_bx\n"}
{"id": 133, "function": "  function ifab_min_val_c(fb, c, nc, all) result(r)\n    integer :: r\n    type(ifab), intent(in) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    logical, intent(in), optional :: all\n    logical :: lall\n    integer, pointer :: mp(:,:,:,:)\n    lall = .false.; if ( present(all) ) lall = all\n    if ( lall ) then\n       mp => dataptr(fb, get_pbox(fb), c, nc)\n    else\n       mp => dataptr(fb, get_ibox(fb), c, nc)\n    end if\n    r = minval(mp)\n  end function ifab_min_val_c\n"}
{"id": 134, "function": "  function ifab_min_val_bx_c(fb, bx, c, nc) result(r)\n    integer :: r\n    type(ifab), intent(in) :: fb\n    type(box), intent(in) :: bx\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    integer, pointer :: mp(:,:,:,:)\n    mp => dataptr(fb, bx, c, nc)\n    r = minval(mp)\n  end function ifab_min_val_bx_c\n"}
{"id": 135, "function": "  function lfab_count(fb, all) result(r)\n    integer :: r\n    type(lfab), intent(in) :: fb\n    logical, intent(in), optional :: all\n    logical, pointer :: lp(:,:,:,:)\n    logical :: lall\n    lall = .false. ; if ( present(all) ) lall = all\n    if ( lall ) then\n       lp => dataptr(fb, get_pbox(fb))\n    else\n       lp => dataptr(fb, get_ibox(fb))\n    end if\n    r = count(lp)\n  end function lfab_count\n"}
{"id": 136, "function": "  function get_manual_control_least_used_cpus_flag() result(r)\n    logical :: r\n    r = manual_control_least_used_cpus\n  end function get_manual_control_least_used_cpus_flag\n"}
{"id": 137, "function": "  function get_luc_vol() result(r)\n    integer(kind=ll_t) :: r\n    r = mcluc_vol\n  end function get_luc_vol\n"}
{"id": 138, "function": "    function util_output_must_report() result(report)\n        !%------------------------------------------------------------------\n        !% description:\n        !% determines whether report is needed for report.thisstep report at \n        !% interval report.timeinterval\n        !%------------------------------------------------------------------\n            logical :: report\n            integer, pointer :: reportstep\n            real(8) :: timenow, reportdt, startreport\n        !%------------------------------------------------------------------\n        reportstep  => setting%output%report%thisstep\n        timenow     = setting%time%now\n        reportdt    = setting%output%report%timeinterval\n        startreport = setting%output%report%starttime\n\n\n        if ((timenow >= reportdt * (reportstep + 1)) .and. (timenow > startreport))then\n            report = .true.\n        else if (timenow == startreport) then\n            report = .true.\n            reportstep = -1\n        else\n            report = .false.\n        end if\n\n    end function util_output_must_report\n"}
{"id": 139, "function": "  real function math_mod_distance(x_a, y_a, z_a, x_b, y_b, z_b)\n!----------------------------------------------------------------------!\n!  calculates distance between two points in three-dimensional space.  !\n!----------------------------------------------------------------------!\n  implicit none\n!-----------------------------[arguments]------------------------------!\n  real :: x_a, y_a, z_a, x_b, y_b, z_b\n!======================================================================!\n\n  math_mod_distance = sqrt(   (x_a-x_b)*(x_a-x_b) &\n                            + (y_a-y_b)*(y_a-y_b) &\n                            + (z_a-z_b)*(z_a-z_b) )\n\n  end function\n"}
{"id": 140, "function": "      real(kind(0.0d0)) function dasum (n, dx, incx) \r\n      use vast_kind_param,only: double \r\n      integer, intent(in) :: n, incx\r\n      real(double), dimension(incx*n), intent(in) :: dx \r\n      end function  \r\n"}
{"id": 141, "function": "    function check_consistency(symbol, components) result(fallible_components)\n        type(element_symbol_t), intent(in) :: symbol\n        type(element_component_t), intent(in) :: components(:)\n        type(fallible_element_components_t) :: fallible_components\n\n        character(len=*), parameter :: procedure_name = \"check_consistency\"\n\n        associate( &\n                isotopes => components%isotope(), &\n                fractions => components%fraction_())\n            if (all(isotopes%is(symbol)))then\n                if (all(fractions > 0.0d0)) then\n                    if (fractions.sumsto.1.0d0) then\n                        allocate(fallible_components%components_, source = components)\n                    else\n                        fallible_components%messages_ = message_list_t(info_t( &\n                                normalized_fractions, &\n                                module_t(module_name), &\n                                procedure_t(procedure_name), &\n                                \"attempted to create composition with component\" &\n                                // \" fractions that did not sum to 1.0.\"))\n                        allocate(fallible_components%components_, source = element_component_t( &\n                                isotopes, fractions / sum(fractions)))\n                    end if\n                else\n                    fallible_components%errors_ = error_list_t(internal_t( &\n                            invalid_argument, &\n                            module_t(module_name), &\n                            procedure_t(procedure_name), &\n                            \"all fractions must be greater than 0.\"))\n                end if\n            else\n                fallible_components%errors_ = error_list_t(internal_t( &\n                        mismatch, &\n                        module_t(module_name), &\n                        procedure_t(procedure_name), &\n                        \"attempted to create an element with an isotope not of that element.\" &\n                        // \" element: \" // symbol%to_string() // \", isotopes: [\" &\n                        // join(isotopes%to_string(), \", \") // \"]\"))\n            end if\n        end associate\n    end function\n"}
{"id": 142, "function": "    function from_json(json) result(fallible_element_components)\n        type(json_array_t), intent(in) :: json\n        type(fallible_element_components_t) :: fallible_element_components\n\n        associate(maybe_components => fallible_element_component_t(json%get_elements()))\n            if (any(maybe_components%failed())) then\n                fallible_element_components%errors_ = error_list_t( &\n                        maybe_components%errors(), &\n                        module_t(module_name), &\n                        procedure_t(\"from_json\"))\n            else\n                allocate(fallible_element_components%components_, source = &\n                        maybe_components%element_component())\n            end if\n        end associate\n    end function\n"}
{"id": 143, "function": "    pure function failed(self)\n        class(fallible_element_components_t), intent(in) :: self\n        logical :: failed\n\n        failed = self%errors_%has_any()\n    end function\n"}
{"id": 144, "function": "    pure function components(self)\n        class(fallible_element_components_t), intent(in) :: self\n        type(element_component_t), allocatable :: components(:)\n\n        components = self%components_\n    end function\n"}
{"id": 145, "function": "    function messages(self)\n        class(fallible_element_components_t), intent(in) :: self\n        type(message_list_t) :: messages\n\n        messages = self%messages_\n    end function\n"}
{"id": 146, "function": "    function errors(self)\n        class(fallible_element_components_t), intent(in) :: self\n        type(error_list_t) :: errors\n\n        errors = self%errors_\n    end function\n"}
{"id": 147, "function": "real(kind=rk) function f(dim)\r\n    integer(kind=ik), intent(in) :: dim\r\n    integer(kind=ik) :: k\r\n    real(kind=rk), dimension(dim) :: arr\r\n    real(kind=rk) :: sq\r\n\r\n    !generate a list of random points on interval [-r, r] based on given dimension\r\n    arr=[((r*(2*genrand64_real1()-1))**2, k=1, dim, 1)]\r\n\r\n    !check if the random coordinates hit inside the sphere\r\n    sq=sum(arr)\r\n    if(sq<(r*r)) then\r\n        f=1     !hit\r\n    else\r\n        f=0     !no hit\r\n    end if\r\nend function f\r\n"}
{"id": 148, "function": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}
{"id": 149, "function": "   function check_bath_dimension(bath_) result(bool)\n      real(8),dimension(:)           :: bath_\n      integer                        :: ntrue\n      logical                        :: bool\n      ntrue = vca_get_bath_dimension()\n      bool  = ( size(bath_) == ntrue )\n   end function check_bath_dimension\n"}
{"id": 150, "function": "    function sn_equals(sn1,sn2) result(is_equals)\n        class(splay_node),intent(in):: sn1, sn2\n        logical:: is_equals\n\n        is_equals = .true.\n        is_equals = is_equals .and. associated(sn1%left, sn2%left)\n        is_equals = is_equals .and. associated(sn1%right, sn2%right)\n        is_equals = is_equals .and. associated(sn1%parent, sn2%parent)\n        is_equals = is_equals .and. sn1%value == sn2%value\n        is_equals = is_equals .and. sn1%size == sn2%size\n    end function\n"}
{"id": 151, "function": "    function sn_has_left(sn)\n        class(splay_node),intent(in):: sn\n        logical:: sn_has_left\n\n        sn_has_left = associated(sn%left)\n    end function\n"}
{"id": 152, "function": "    function sn_has_right(sn)\n        class(splay_node),intent(in):: sn\n        logical:: sn_has_right\n\n        sn_has_right = associated(sn%right)\n    end function\n"}
{"id": 153, "function": "    function sn_has_parent(sn)\n        class(splay_node),intent(in):: sn\n        logical:: sn_has_parent\n\n        sn_has_parent = associated(sn%parent)\n    end function\n"}
{"id": 154, "function": "    function sn_state(sn)\n        class(splay_node),intent(in):: sn\n        integer(int32):: sn_state\n\n        sn_state=0\n        if (associated(sn%parent)) then\n            if (sn%parent%left == sn) sn_state=1\n            if (sn%parent%right == sn) sn_state=-1\n        end if\n    end function\n"}
{"id": 155, "function": "    function sn_get(sn, ind)\n        class(splay_node),intent(in):: sn\n        type(splay_node):: now, sn_get\n        integer(prec),value:: ind\n        integer(int32):: now_ind\n\n        now = sn\n        do while(.true.)\n            now_ind = 0\n            if (now%has_left()) now_ind = sn%left%size + 1\n            if (ind < now_ind) then\n                now = now%left\n            end if\n            if (ind == now_ind) then\n                call now%splay()\n                sn_get = now\n            end if\n            if (ind > now_ind) then\n                now = now%right\n                ind = ind-now_ind\n            end if\n        end do\n    end function\n"}
{"id": 156, "function": "double precision function mean(a, n)\n  double precision, intent(in) :: a(n)\n  integer i\n  mean = 0\n  do i=1, n\n    mean = mean + a(i)\n  enddo\n  mean = mean/n\nend function mean\n"}
{"id": 157, "function": "double precision function stddev(a, n)\n  double precision, intent(in) :: a(n)\n  double precision mu, mean\n  integer i\n  mu = mean(a, n)\n  stddev = 0\n  do i=1, n\n    stddev = stddev + (a(i)-mu)**2\n  enddo\n  stddev = sqrt(stddev/(n-1))\nend function stddev\n"}
{"id": 158, "function": "double precision function corr(a, n)\n  double precision, intent(in) :: a(n)\n  double precision mu, sig, mean, stddev, ct\n  integer i, k\n  mu = mean(a, n)\n  sig = stddev(a, n)\n  if (abs(sig)<tiny(sig)) then\n    corr = huge(corr)\n    return\n  endif\n  corr = 0\n  do k=1,n\n    ct = 0\n    do i=1, n-k\n      ct = ct + (a(i)-mu)*(a(i+k)-mu)\n    enddo\n    ct = ct/sig**2/(n-k)\n    if (ct .le. 0) then\n      exit\n    endif\n    corr = corr + 2*ct\n  enddo\n  corr = corr + 1\nend function corr\n"}
{"id": 159, "function": "double precision function error(a, n)\n  double precision, intent(in) :: a(n)\n  double precision mu, sig, mean, stddev, kappa, corr\n  mu = mean(a, n)\n  sig = stddev(a, n)\n  if (abs(sig)<tiny(sig)) then\n    erorr = 0\n    return\n  endif\n  kappa = corr(a, n)\n  error = sig/sqrt(n/kappa)\nend function error\n"}
{"id": 160, "function": "      integer function get_index_kq(ikpt,iqpt,nkpts)\n      implicit none\n      integer,intent(in) :: ikpt,iqpt,nkpts\n      get_index_kq = ikpt+(iqpt-1)*nkpts\n      end function get_index_kq\n"}
{"id": 161, "function": "      integer function get_index_k(ikqpt,nkpts)\n      implicit none\n      integer,intent(in) :: ikqpt,nkpts\n      get_index_k = ikqpt -(get_index_q(ikqpt,nkpts)-1)*nkpts\n      end function get_index_k\n"}
{"id": 162, "function": "      integer function get_index_q(ikqpt,nkpts)\n      implicit none\n      integer,intent(in) :: ikqpt,nkpts\n      get_index_q = (ikqpt-1)/nkpts + 1\n      end function get_index_q\n"}
{"id": 163, "function": "      integer function get_index_nn_k(bpt,nntot,ikpt_b,gb_kq,gb,dim)\n      implicit none\n      integer,intent(in) :: nntot,ikpt_b,dim\n      integer,intent(in) :: bpt(nntot)\n      integer,intent(in) :: gb(3,nntot),gb_kq(dim)\n      integer :: nn\n\nc      if(any(gb_kq(4:).ne.0)) write(*,*)'problem get_index_nn_k'\n\n      do nn=1,nntot\n         if((bpt(nn).eq.ikpt_b) .and. (gb(1,nn).eq.gb_kq(1))\n     >            .and.(gb(2,nn).eq.gb_kq(2))\n     >            .and.(gb(3,nn).eq.gb_kq(3))) exit\n      enddo\n      if((nn.eq.(nntot+1)).or.(any(gb_kq(4:).ne.0))) then\nc       write(*,*)'nn not found!'\n       nn=-1\n      endif\n\n      get_index_nn_k = nn\n      end function get_index_nn_k\n"}
{"id": 164, "function": "      integer function get_index_nn_q(bpt,nntot,ikpt_b,gb_kq,gb,\n     >                                dim,shift,l_dim)\n      implicit none\n      integer,intent(in) :: nntot,ikpt_b,dim,shift(3)\n      integer,intent(in) :: bpt(nntot)\n      integer,intent(in) :: gb(3,nntot),gb_kq(dim)\n      logical,intent(in) :: l_dim(3)\n      integer :: nn,ind(3),g(3)\n\n      g = 0\n      do nn=1,3\n         ind(nn)=4+shift(nn)\n         if(l_dim(nn))g(nn)=gb_kq(ind(nn))\n      enddo\n\nc      if(any(gb_kq(1:3).ne.0)) write(*,*)'problem get_index_nn_q'\n\n      do nn=1,nntot\n         if((bpt(nn).eq.ikpt_b) .and. (gb(1,nn).eq.g(1))\n     >              .and.(gb(2,nn).eq.g(2)).and.(gb(3,nn).eq.g(3))) exit\n      enddo\n      if((nn.eq.(nntot+1)).or.(any(gb_kq(1:3).ne.0))) then\nc       write(*,*)'nn not found!'\n       nn=-1\n      endif\n\n      get_index_nn_q = nn\n      end function get_index_nn_q\n"}
{"id": 165, "function": "  function ut__i2c3(i)\n    !! \u6574\u6570\u3092\u6587\u5b57\u5217\uff083\u6587\u5b57\u56fa\u5b9a\uff09\u306b\u5909\u63db\u3059\u308b\n    !!\n    !!  convert an integer into 3 characters.\n    !!\n    !!             e.g., i=10 --> str3=\"010\"\n    !!\n    integer(si), intent(in) :: i\n    character(len=3)        :: ut__i2c3\n    if (i>999) then\n       ut__i2c3 = 'xxx'\n    else\n       write(ut__i2c3,'(i3.3)') i\n    end if\n  end function ut__i2c3\n"}
{"id": 166, "function": "  pure function left_prime(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer*8             :: temp\n    logical               :: left_prime\n\n    left_prime=.true.\n    temp=n\n    do while(temp>0)\n       if (.not. is_prime(temp)) then\n          left_prime=.false.\n          exit\n       end if\n       temp=mod(temp,10**(number_length(temp)-1))\n    end do\n\n  end function left_prime\n"}
{"id": 167, "function": "      function surface_commandline_parser_construct(parallel)\n\n      implicit none\n\n!  declare arguments\n      class (surface_commandline_parser_class), pointer ::                     &\n     &   surface_commandline_parser_construct\n      class (bmw_parallel_context_class), intent(in)    :: parallel\n\n!  local variables\n      character (len=max_length) :: temp\n      integer                    :: num_args\n      integer                    :: i\n      integer                    :: value_index\n      real (rprec)               :: start_time\n\n!  start of executable code\n      start_time = profiler_get_start_time()\n\n      temp = ''\n      num_args = 0\n      value_index = 0\n      allocate(surface_commandline_parser_construct)\n\n!  read the zeroith arg to get the number of arguments. this should also be the\n!  command name.\n      call getcarg(0, surface_commandline_parser_construct%command,            &\n     &             num_args)\n\n!  allocate the arrays and\n      allocate(surface_commandline_parser_construct%arg(num_args))\n      allocate(surface_commandline_parser_construct%value(num_args))\n\n!  loop through the command line arguments, and setup the argument and value\n!  arrays\n      do i = 1, num_args\n         call getcarg(i, temp, num_args)\n\n!  check for a - as the first character.\n         if (temp(1:1) .eq. '-') then\n            value_index = index(temp, '=')\n            if (value_index .eq. 0) then\n!  check for help command.\n               if (trim(temp) .eq. '-h' .and.                                  &\n     &             parallel%offset .eq. 0) then\n                  call surface_commandline_parser_print_help\n               end if\n\n               surface_commandline_parser_construct%arg(i) = trim(temp)\n               surface_commandline_parser_construct%value(i) = ''\n            else\n               surface_commandline_parser_construct%arg(i) =                   &\n     &            temp(1:value_index - 1)\n               surface_commandline_parser_construct%value(i) =                 &\n     &            temp(value_index + 1:len_trim(temp))\n            end if\n          end if\n\n          call surface_commandline_parser_flag_requires_value(                 &\n     &            surface_commandline_parser_construct, i)\n      end do\n\n      call profiler_set_stop_time(                                             &\n     &        'surface_commandline_parser_construct', start_time)\n\n      end function\n"}
{"id": 168, "function": "      function surface_commandline_parser_get_string(this, arg)\n\n      implicit none\n\n!  declare arguments\n      character (len=path_length) ::                                           &\n     &   surface_commandline_parser_get_string\n      class (surface_commandline_parser_class), intent(in) :: this\n      character (len=*), intent(in)                        :: arg\n\n!  local arguments\n      integer                                              :: i\n      real (rprec)                                         :: start_time\n\n!  start of executable code\n      start_time = profiler_get_start_time()\n\n!  loop through the arguments until the correct arg is found.\n      surface_commandline_parser_get_string = ''\n\n      if (associated(this%arg)) then\n         do i = 1, size(this%arg)\n            if (trim(this%arg(i)) .eq. trim(arg)) then\n               surface_commandline_parser_get_string = this%value(i)\n\n               call profiler_set_stop_time(                                    &\n     &                 'surface_commandline_parser_get_string',                &\n     &                 start_time)\n\n               return\n            end if\n         end do\n      end if\n\n      call profiler_set_stop_time(                                             &\n     &        'surface_commandline_parser_get_string', start_time)\n\n      end function\n"}
{"id": 169, "function": "      function surface_commandline_parser_get_integer(this, arg,               &\n     &                                                default_value)\n\n      implicit none\n\n!  declare arguments\n      integer :: surface_commandline_parser_get_integer\n      class (surface_commandline_parser_class), intent(in) :: this\n      character (len=*), intent(in) :: arg\n      integer, intent(in)           :: default_value\n\n!  local arguments\n      character (len=path_length)   :: value\n      integer                       :: status\n      real (rprec)                  :: start_time\n\n!  start of executable code\n      start_time = profiler_get_start_time()\n\n      value = this%get(arg)\n\n      if (trim(value) .eq. '') then\n         surface_commandline_parser_get_integer = default_value\n\n         call profiler_set_stop_time(                                          &\n     &           'surface_commandline_parser_get_integer', start_time)\n\n         return\n      end if\n\n      read (value,1000,iostat=status)                                          &\n     &   surface_commandline_parser_get_integer\n\n      if (status .ne. 0) then\n         surface_commandline_parser_get_integer = default_value\n      end if\n\n      call profiler_set_stop_time(                                             &\n     &   'surface_commandline_parser_get_integer', start_time)\n\n1000  format(i20)\n\n      end function\n"}
{"id": 170, "function": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 171, "function": "    elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 172, "function": "    elemental function get_default_ll(logic, default) result(ret)\n        logical, intent(in), optional :: logic\n        logical, intent(in) :: default\n        logical :: ret\n\n        if (present(logic)) then\n            ret = logic\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 173, "function": "    elemental function get_default_xx(comp, default) result(ret)\n        complex, intent(in), optional :: comp\n        complex, intent(in) :: default\n        complex :: ret\n\n        if (present(comp)) then\n            ret = comp\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 174, "function": "    elemental function get_default_cc(c, default) result(ret)\n        character, intent(in), optional :: c\n        character, intent(in) :: default\n        character :: ret\n\n        if (present(c)) then\n            ret = c\n        else\n            ret = default\n        end if\n    end function\n"}
{"id": 175, "function": "   function vol1(a,b)\n      real vol,a,b\n   end function vol1\n"}
{"id": 176, "function": "   function vol2(a,b)\n      real vol,a,b\n   end function vol2\n"}
{"id": 177, "function": "    double precision function xpos(i) result(x)\n        integer,intent(in) :: i\n        !x = dh * i\n        x = -xmax + dh * ( i - 1 )\n    end function\n"}
{"id": 178, "function": "    double precision function ypos(j) result(y)\n        integer,intent(in) :: j\n        !y = dh * j\n        y = -ymax + dh * ( j - 1 )\n    end function\n"}
{"id": 179, "function": "    double precision function zpos(k_) result(z)\n        integer,intent(in) :: k_\n        !z = dh * k\n        z = -zmax + dh * ( k_ - 1 ) \n    end function\n"}
{"id": 180, "function": "    function integrate_real(f) result(result)\n        double precision,intent(in)  :: f(1:nl)\n        double precision             :: result\n        result = sum(f) * dv\n    end function\n"}
{"id": 181, "function": "    function integrate_real_radius(f, r) result(result)\n        double precision,intent(in)  :: f(1:nl)\n        double precision,intent(in)  :: r\n        double precision             :: result\n        integer                      :: ix, iy, iz, i\n        double precision             :: x, y, z\n        result = 0d0\n        do iz = 1, nz\n            z = zpos(iz)\n            do iy = 1, ny\n                y = ypos(iy)\n                do ix = 1, nx\n                    x = xpos(ix)\n                    i = ixyz2i(ix, iy, iz)\n                    \n                    if (x * x + y * y + z * z  < r * r) then\n                        result = result + f(i) * dv\n                    end if\n                end do\n            end do\n        end do\n    end function\n"}
{"id": 182, "function": "    function integrate_complex(f) result(result)\n        complex(kind(0d0)),intent(in)  :: f(1:nl)\n        double precision               :: result\n        result = sum( dble(f) ) * dv\n    end function\n"}
{"id": 183, "function": "    double precision function calc_mu(phi, pot, omega_z)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        double precision,intent(in)    :: pot(1:nl)\n        double precision,intent(in)    :: omega_z(1:nz)\n\n        ! <phi|h|phi> = <h>\n        ! chemical potential and total energy per particle are different.\n        call h(phi, abs(phi)**2, pot, omega_z)\n        calc_mu = integrate( conjg(phi) * hphi ) / integrate( abs(phi)**2 )\n    end function\n"}
{"id": 184, "function": "    function calc_energies(phi, pot, omega_z) result(energies)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        double precision,intent(in)    :: pot(1:nl)\n        double precision,intent(in)    :: omega_z(1:nz)\n        double precision               :: energies(1:4)\n        double precision               :: t1, t2\n        complex(kind(0d0))             :: temp(1:nl)\n\n        call laplacian(phi)\n        energies(1) = 0.5d0 * integrate( -conjg(phi) * zlap )\n        energies(2) = integrate( pot * abs(phi)**2 )\n        call gradient(phi)\n        call lzphi(phi, zgrad)\n        i = 1\n        do iz = 1, nz\n            do iy = 1, ny\n                do ix = 1, nx\n                    temp(i) = conjg(phi(i)) * omega_z(iz) * zlzphi(i)\n                    i = i + 1\n                end do\n            end do\n        end do\n        energies(4) = integrate( temp )\n        energies(3) = 0.5d0*integrate( abs(phi)**4 )\n    end function\n"}
{"id": 185, "function": "    function calc_total_energy(phi, pot, omega_z) result(total_energy)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        double precision,intent(in)    :: pot(1:nl)\n        double precision,intent(in)    :: omega_z(1:nz)\n        double precision               :: total_energy\n        double precision               :: energies(0:3)\n        energies = calc_energies(phi, pot, omega_z)\n        total_energy = sum( energies )\n    end function\n"}
{"id": 186, "function": "    pure elemental double precision function phase_complex(z)\n        complex(kind(0d0)),intent(in) :: z\n        phase_complex = atan2(aimag(z), real(z))\n    end function\n"}
{"id": 187, "function": "    double precision function phase_coordinates(y, x)\n        double precision,intent(in) :: x, y\n        phase_coordinates = atan2(y, x)\n    end function\n"}
{"id": 188, "function": "    double precision function calc_lz(phi)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        call gradient(phi)\n        call lzphi(phi, zgrad)\n        calc_lz = dble( integrate(conjg(phi)*zlzphi) )\n        calc_lz = calc_lz / particlen\n    end function \n"}
{"id": 189, "function": "    function calc_lall(phi) result(l)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        double precision               :: l(1:3)\n        call gradient(phi)\n        call lallphi(phi, zgrad)\n        l(1) = dble( integrate(conjg(phi)*zlxphi) )\n        l(2) = dble( integrate(conjg(phi)*zlyphi) )\n        l(3) = dble( integrate(conjg(phi)*zlzphi) )\n        l = l / particlen\n    end function \n"}
{"id": 190, "function": "    function calc_flux(phi) result(flux)\n        complex(kind(0d0)),intent(in) :: phi(1:nl)\n        double precision              :: flux(1:nl, 1:3)\n        integer                       :: i, id\n        double precision              :: t2, t1\n        call gradient(phi)\n        do id = 1, 3\n            flux(:,id) = aimag( conjg(phi(:))*zgrad(:,id) )\n        end do\n    end function\n"}
{"id": 191, "function": "    double precision function circulation_flux(phi, flux)\n        complex(kind(0d0)),intent(in) :: phi(1:nl)\n        double precision,  intent(in) :: flux(1:nl, 1:3)\n        integer                       :: ix, iy\n        double precision              :: sum\n        integer                       :: lx, ux, ly, uy\n        lx = floor(0.25d0 * nx)\n        ux = ceiling(0.75d0 * nx)\n        ly = floor(0.25d0 * ny)\n        uy = ceiling(0.75d0 * ny)\n\n        sum = 0d0\n        ! c1\n        do ix = lx, ux\n            sum = sum + v_dr_(phi, flux, ix, ly, +1, 0)\n        end do\n        ! c2\n        do iy = ly, uy\n            sum = sum + v_dr_(phi, flux, ux, iy, 0, +1)\n        end do\n        ! c3\n        do ix = ux, lx, -1\n            sum = sum + v_dr_(phi, flux, ix, uy, -1, 0)\n        end do\n        ! c4\n        do iy = uy, ly, -1\n            sum = sum + v_dr_(phi, flux, lx, iy, 0, -1)\n        end do\n        circulation_flux = sum\n    end function\n"}
{"id": 192, "function": "    double precision function v_dr_(phi, flux, ix, iy, coe_dx, coe_dy)\n        complex(kind(0d0)), intent(in) :: phi(1:nl)\n        double precision,   intent(in) :: flux(1:nl, 1:3)\n        integer,            intent(in) :: ix, iy, coe_dx, coe_dy\n        integer                        :: i\n\n        i = ixyz2i(ix, iy, 1)\n        v_dr_ = coe_dx * flux(i, 1) / abs(phi(i))**2 + coe_dy * flux(i, 2) / abs(phi(i))**2\n        v_dr_ = v_dr_ * dh\n    end function\n"}
{"id": 193, "function": "    double precision function circulation_phase(phi)\n        complex(kind(0d0)),intent(in) :: phi(1:nl)\n        integer                       :: ix, iy, istart, iend\n        double precision              :: sum\n        integer                       :: lx, ux, ly, uy\n        lx = floor(0.25d0 * nx)\n        ux = ceiling(0.75d0 * nx)\n        ly = floor(0.25d0 * ny)\n        uy = ceiling(0.75d0 * ny)\n\n        sum = 0d0\n        ! c1\n        do ix = lx, ux\n            istart = ixyz2i(ix-1, ly, 1)\n            iend = ixyz2i(ix+1, ly, 1)\n\n            if(phase( phi(iend) ) - phase( phi(istart) ) < 0) then\n                sum = sum + 0.5d0 * ( ( phase( phi(iend) ) + 2d0 * pi ) - phase( phi(istart) ) )\n            else\n                sum = sum + v_dr(phi, ix, ly, +1, 0)\n            end if\n        end do\n        ! c2\n        do iy = ly, uy\n            istart = ixyz2i(ux, iy-1, 1)\n            iend = ixyz2i(ux, iy+1, 1)\n\n            if(phase( phi(iend) ) - phase( phi(istart) ) < 0) then\n                sum = sum + 0.5d0 * ( ( phase( phi(iend) ) + 2d0 * pi ) - phase( phi(istart) ) )\n            else\n                sum = sum + v_dr(phi, ux, iy, 0, +1)\n            end if\n        end do\n        ! c3\n        do ix = ux, lx, -1\n            istart = ixyz2i(ix+1, uy, 1)\n            iend = ixyz2i(ix-1, uy, 1)\n\n            if( phase( phi(iend) ) - phase( phi(istart) ) < 0) then\n                sum = sum - 0.5d0*( ( phase( phi(iend) ) ) - ( phase( phi(istart) ) + 2d0 * pi ) )\n            else\n                sum = sum + v_dr(phi, ix, uy, -1, 0)\n            end if\n        end do\n        ! c4\n        do iy = ux, lx, -1\n            istart = ixyz2i(lx, iy+1, 1)\n            iend = ixyz2i(lx, iy-1, 1)\n\n            if (phase(phi(iend)) - phase(phi(istart)) < 0) then\n                sum = sum - 0.5d0 * ( ( phase( phi(iend) ) ) - ( phase( phi(istart) ) + 2d0 * pi ) )\n            else\n                sum = sum + v_dr(phi, lx, iy, 0, -1)\n            end if\n        end do\n        circulation_phase = sum\n    end function\n"}
{"id": 194, "function": "    double precision function v_dr(phi, ix, iy, coe_dx, coe_dy)\n        complex(kind(0d0)),intent(in) :: phi(1:nl)\n        integer,           intent(in) :: ix, iy, coe_dx, coe_dy\n        integer                       :: istart, iend\n\n        istart = ixyz2i(ix-1, iy, 1)\n        iend   = ixyz2i(ix+1, iy, 1)\n        v_dr = coe_dx*(phase(phi(iend))-phase(phi(istart)))\n        \n        istart = ixyz2i(ix, iy-1, 1)\n        iend   = ixyz2i(ix, iy+1, 1)\n        v_dr = v_dr + coe_dy*(phase(phi(iend))-phase(phi(istart)))\n        v_dr = 0.5d0 * v_dr\n    end function\n"}
{"id": 195, "function": "    function transform_fftw(in) result(out)\n        complex(kind(0d0)),intent(in) :: in(1:nl)\n        complex(kind(0d0))            :: out(1:nl)\n        call dfftw_execute_dft( plan_f, in, out )\n    end function\n"}
{"id": 196, "function": "    function revert_fftw(in) result(out)\n        complex(kind(0d0)),intent(in) :: in(1:nl)\n        complex(kind(0d0))            :: out(1:nl)\n        call dfftw_execute_dft( plan_b, in, out )\n        out = out / nl\n    end function\n"}
{"id": 197, "function": "    function create_wavenumber(n) result(k_)\n        integer,intent(in)  :: n\n        double precision    :: k_(1:n)\n        double precision    :: coe\n        integer             :: i\n        coe = 2d0 * pi / ( n * dh )\n        if ( n > 1 ) then\n            do i = 1, n\n                if (i <= n / 2) then\n                    k_(i) = i - 1\n                else\n                    k_(i) = i - n - 1\n                end if\n            end do\n            k_ = k_ * coe\n        else\n            k_ = 0d0\n        end if\n    end function\n"}
{"id": 198, "function": "        integer function nfact2_(i)\n          implicit none\n          integer,intent(in)::i\n          integer,parameter::mx=5,nls(mx)=(/1,1,3,15,105/)\n          if (i+1>mx) then\n            write(*,'(\"error: out of range: nfact2_()\")')\n            stop 1\n          end if\n          nfact2_=nls(i+1)\n        end function\n"}
{"id": 199, "function": "        integer function nbin_(m,l)\n          ! binomial constant.\n          implicit none\n          integer,intent(in)::m,l\n          integer,parameter::mx=7,nls(mx,mx)=reshape((/\n     &      1,0,0,0,0,0,0,\n     &      1,1,0,0,0,0,0,\n     &      1,2,1,0,0,0,0,\n     &      1,3,3,1,0,0,0,\n     &      1,4,6,4,1,0,0,\n     &      1,5,10,10,5,1,0,\n     &      1,6,15,20,15,6,1\n     &      /),(/mx,mx/))\n          if (l+1>mx.or.m+1>mx) then\n            write(*,'(\"error: out of range: nbin_()\")')\n            stop 1\n          end if\n          nbin_=nls(l+1,m+1)\n        end function\n"}
{"id": 200, "function": "        real(8) function pgn_(l1,e1i) result(vn)\n\n          implicit none\n          integer,intent(in)::l1(3)\n          real(8),intent(in)::e1i\n          integer::i\n          vn=2d0**(2d0*sum(l1)+1.5d0)\n          vn=vn*e1i**(sum(l1)+1.5d0)\n          do i=1,3\n            vn=vn/nfact2_(l1(i))\n          end do\n          vn=vn/pi**1.5\n          vn=vn**0.5d0\n        end function\n"}
{"id": 201, "function": "        recursive real(8) function fboys_(n,x) result(v)\n\n          implicit none\n          integer,intent(in)::n\n          real(8),intent(in)::x\n          real(8)::expmx\n          if (n==0) then\n            v=sqrt(pi/x)*erf(sqrt(x))/2d0\n          else\n            ! avoiding underflow:\n            expmx=0d0\n            if (x<1d3) then\n              expmx=exp(-x)\n            end if\n            v=((2*n-1)*fboys_(n-1,x)-expmx)/(2d0*x)\n          end if\n        end function\n"}
{"id": 202, "function": "        integer function nfact_(i)\n          implicit none\n          integer,intent(in)::i\n          integer,parameter::\n     &      mx=10,nls(mx)=(/1,1,2,6,24,120,720,5040,40320,362880/)\n          if (i+1>mx) then\n            write(*,'(\"error: out of range: ncact()\")')\n            stop 1\n          end if\n          nfact_=nls(i+1)\n        end function\n"}
{"id": 203, "function": "        function c_ezcu_dev_find(idx) bind(c, name=\"ezcu_dev_find\")\n            use iso_c_binding, only: c_ptr, c_int\n            integer(kind=c_int), value, intent(in) :: idx\n        end function c_ezcu_dev_find\n"}
{"id": 204, "function": "  function tapnext(self) result(next)\n    type(tap), pointer :: self, next\n    if (.not. associated(self)) then\n      next => null()\n      return\n    end if\n    if (associated(self%nextelem)) then\n      next => self%nextelem\n    else\n      next => null()\n    end if\n  end function tapnext\n"}
{"id": 205, "function": "  function tapprevious(self) result(previous)\n    type(tap), pointer :: self, previous\n\n    if (associated(self%prevelem)) then\n      previous => self%prevelem\n    else\n      previous => null()\n    end if\n  end function tapprevious\n"}
{"id": 206, "function": "  function taplength(self) result(n)\n    type(tap), pointer :: self, current\n    integer :: n\n\n    if (associated(self)) then\n      current => self\n      ! go to the first element\n      do while(associated(current%prevelem))\n        current => current%prevelem\n      end do\n      n = 1\n      do while(associated(current%nextelem))\n        current => current%nextelem\n        n = n + 1\n      end do\n    else\n      n = 0\n    end if\n\n  end function taplength\n"}
{"id": 207, "function": "  function tapi(self,i) result(ith)\n    type(tap), pointer :: self, ith\n    integer, intent(in) :: i\n\n    integer j\n\n    if (i .gt. taplength(self)) then\n      ith => null()\n    else\n      ! go to the first\n      ith => self\n      do while(associated(ith%prevelem))\n        ith => ith%prevelem\n      end do\n      ! take i-1 steps\n      do j=1,i-1\n        ith => ith%nextelem\n      end do\n    end if\n  end function tapi\n"}
{"id": 208, "function": "        function glisenabled(cap) bind(c, name='glisenabled')\n            import :: glboolean, glenum\n            integer(kind=glenum), intent(in), value :: cap\n            integer(kind=glboolean)                 :: glisenabled\n        end function glisenabled\n"}
{"id": 209, "function": "        function glislist(list) bind(c, name='glislist')\n            import :: glboolean, gluint\n            integer(kind=gluint), intent(in), value :: list\n            integer(kind=glboolean)                 :: glislist\n        end function glislist\n"}
{"id": 210, "function": "        function glaretexturesresident(n, textures, residences) bind(c, name='glaretexturesresident')\n            import :: glboolean, glsizei, gluint\n            integer(kind=glsizei),   intent(in), value :: n\n            integer(kind=gluint),    intent(in)        :: textures(*)\n            integer(kind=glboolean), intent(in)        :: residences\n            integer(kind=glboolean)                    :: glaretexturesresident\n        end function glaretexturesresident\n"}
{"id": 211, "function": "        function glistexture(texture) bind(c, name='glistexture')\n            import :: glboolean, gluint\n            integer(kind=gluint), intent(in), value :: texture\n            integer(kind=glboolean)                 :: glistexture\n        end function glistexture\n"}
{"id": 212, "function": "        function glgeterror() bind(c, name='glgeterror')\n            import :: glenum\n            integer(kind=glenum) :: glgeterror\n        end function glgeterror\n"}
{"id": 213, "function": "        function glrendermode(mode) bind(c, name='glrendermode')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: mode\n            integer(kind=glint)                     :: glrendermode\n        end function glrendermode\n"}
{"id": 214, "function": "        function glgetstring(name) bind(c, name='glgetstring')\n            import :: glenum, glubyte, c_ptr\n            integer(kind=glenum), intent(in), value :: name\n            type(c_ptr)                             :: glgetstring\n        end function glgetstring\n"}
{"id": 215, "function": "        function glgenlists(range) bind(c, name='glgenlists')\n            import :: glsizei, gluint\n            integer(kind=glsizei), intent(in), value :: range\n            integer(kind=gluint)                     :: glgenlists\n        end function glgenlists\n"}
{"id": 216, "function": "    function test_position() result(tests)\n        type(test_item_t) :: tests\n\n        tests = describe( &\n                \"position_t\", &\n                [ it( &\n                        \"normal characters only increment the column\", &\n                        check_simple_char) &\n                , it( &\n                        \"tab characters increment the column to the next multiple of 8\", &\n                        check_tab) &\n                , it( &\n                        \"newlines increment the line and reset the column\", &\n                        check_newline) &\n                ])\n    end function\n"}
{"id": 217, "function": "    function check_simple_char() result(result_)\n        type(result_t) :: result_\n\n        type(parser_output_t) :: parse_result\n\n        parse_result = parse_everything(new_state(var_str(\"a\")))\n\n        result_ = assert_equals(1, parse_result%position%line, &\n                        var_str(\"don't change line\")) &\n                .and. &\n                assert_equals(2, parse_result%position%column, &\n                        var_str(\"increment column\"))\n    end function\n"}
{"id": 218, "function": "    function check_tab() result(result_)\n        type(result_t) :: result_\n\n        type(parser_output_t) :: parse_result\n\n        parse_result = parse_everything( &\n                new_state(var_str(\"a\" // char(9))))\n\n        result_ = assert_equals(1, parse_result%position%line, &\n                        var_str(\"don't change line\")) &\n                .and. &\n                assert_equals(9, parse_result%position%column, &\n                        var_str(\"increment column\"))\n    end function\n"}
{"id": 219, "function": "    function check_newline() result(result_)\n        type(result_t) :: result_\n\n        type(parser_output_t) :: parse_result\n\n        parse_result = parse_everything( &\n                new_state(var_str('a' // new_line('a'))))\n\n        result_ = assert_equals(2, parse_result%position%line, &\n                            var_str(\"increment line\")) &\n                    .and. &\n                    assert_equals(1, parse_result%position%column, &\n                            var_str(\"reset column\"))\n    end function\n"}
{"id": 220, "function": "    function parse_everything(the_state) result(the_result)\n        type(state_t) :: the_state\n        type(parser_output_t) :: the_result\n\n        the_result = many(parse_anything, the_state)\n    contains\n        function parse_anything(state_) result(result_)\n            type(state_t), intent(in) :: state_\n            type(parser_output_t) :: result_\n\n            result_ = satisfy(match_everything, state_)\n        end function\n\n        pure function match_everything(char_) result(matches)\n            character(len=1), intent(in) :: char_\n            logical :: matches\n\n            ! suppress 'unused dummy argument' warning\n            matches = char_.eq.char_\n        end function\n    end function\n"}
{"id": 221, "function": "        function comf_interface(x, iz, c, a, bh) &\n            result (return_value)\n            import :: ip, wp\n\n            ! dummy arguments\n            integer(ip), intent(in) :: iz\n            real(wp),    intent(in) :: x\n            real(wp),    intent(in) :: c(*)\n            real(wp),    intent(in) :: a(*)\n            real(wp),    intent(in) :: bh(*)\n            real(wp)                :: return_value\n        end function comf_interface\n"}
{"id": 222, "function": "    pure function ppsgf(x, iz, c, a, bh) &\n        result (return_value)\n\n        ! dummy arguments\n        integer(ip),    intent(in)    :: iz\n        real(wp),       intent(in)    :: x\n        real(wp),       intent(in)    :: c(*)\n        real(wp),       intent(in)    :: a(*)\n        real(wp),       intent(in)    :: bh(*)\n        real(wp)                      :: return_value\n\n        return_value = sum(one/(x - bh(1:iz))**2)\n\n    end function ppsgf\n"}
{"id": 223, "function": "    pure function psgf(x, iz, c, a, bh) &\n        result (return_value)\n\n        ! dummy arguments\n        integer(ip),    intent(in)    :: iz\n        real(wp),       intent(in)    :: x\n        real(wp),       intent(in)    :: c(*)\n        real(wp),       intent(in)    :: a(*)\n        real(wp),       intent(in)    :: bh(*)\n        real(wp)                      :: return_value\n\n        ! local variables\n        integer(ip) :: j\n        real(wp)    :: fsg, hsg, dd\n\n        fsg = one\n        hsg = one\n\n        do j = 1, iz\n            dd = one/(x - bh(j))\n            fsg = fsg * a(j) * dd\n            hsg = hsg * c(j) * dd\n        end do\n\n        select case (mod(iz,2))\n            case (0)\n                return_value = one - fsg - hsg\n            case default\n                return_value = one + fsg + hsg\n        end select\n\n    end function psgf\n"}
{"id": 224, "function": "    function bsrh(self, xll, xrr, iz, c, a, bh, sgn, f) &\n        result (return_value)\n\n        ! dummy arguments\n        class(generalizedcyclicreductionutility), intent(inout) :: self\n        real(wp),         intent(in)    :: xll\n        real(wp),         intent(in)    :: xrr\n        integer(ip),      intent(in)    :: iz\n        real(wp),         intent(in)    :: c(:)\n        real(wp),         intent(in)    :: a(:)\n        real(wp),         intent(in)    :: bh(:)\n        real(wp),         intent(in)    :: sgn\n        procedure(comf_interface)       :: f\n        real(wp)                        :: return_value\n\n        ! local variables\n        real(wp) :: r1, xl, xr, dx, x\n\n        common_variables: associate( &\n            npp => self%npp, &\n            k => self%k, &\n            nm => self%nm, &\n            ncmplx=> self%ncmplx, &\n            ik => self%ik, &\n            cnv => self%cnv &\n            )\n\n            xl = xll\n            xr = xrr\n            dx = abs(xr - xl)/2\n            x = (xl + xr)/2\n            r1 = sgn * f(x, iz, c, a, bh)\n\n            if (r1 >= zero) then\n                if (r1 == zero) then\n                    return_value = (xl + xr)/2\n                    return\n                end if\n                xr = x\n            else\n                xl = x\n            end if\n\n            dx = dx/2\n\n            do\n                if (dx - cnv > zero) exit\n                x = (xl + xr)/2\n                r1 = sgn * f(x, iz, c, a, bh)\n                if (r1 >= zero) then\n                    if (r1 == zero) then\n                        return_value = (xl + xr)/2\n                        return\n                    end if\n                    xr = x\n                else\n                    xl = x\n                end if\n                dx = dx/2\n            end do\n\n            return_value = (xl + xr)/2\n        end associate common_variables\n\n    end function bsrh\n"}
{"id": 225, "function": "  function is_same(a, b, eps) result(lvalue)\n    ! -- return variable\n    logical(lgp) :: lvalue                 !< boolean indicating if a and b are the same\n    ! -- dummy variables\n    real(dp), intent(in)   :: a            !< first number to evaluate \n    real(dp), intent(in)   :: b            !< second number to evaluate\n    real(dp), intent(in), optional :: eps  !< optional maximum difference between a abd b (default=dsame)\n    ! -- local variables\n    real(dp) :: epsloc\n    real(dp) :: denom\n    real(dp) :: rdiff\n    !\n    ! -- evaluate optioanl arguments\n    if (present(eps)) then\n      epsloc = eps\n    else\n      epsloc = dsame\n    endif\n    lvalue = .false.\n    if (a == b) then\n      lvalue = .true.\n    else\n      if (abs(b) > abs(a)) then\n        denom = b\n      else\n        denom = a\n        if (abs(denom) == dzero) then\n          denom = dprec\n        end if\n      end if\n      rdiff = abs( (a - b) / denom )\n      if (rdiff <= epsloc) then\n        lvalue = .true.\n      end if\n    end if\n    !\n    ! -- return\n    return\n  end function is_same\n"}
{"id": 226, "function": "  integer function julian_day(yr,mo,da)\n\n  implicit none\n\n  integer yr,mo,da\n\n  integer mon(12)\n  integer lpyr\n  data mon /0,31,59,90,120,151,181,212,243,273,304,334/\n\n  julian_day = da + mon(mo)\n  if(mo>2) julian_day = julian_day + lpyr(yr)\n\n  end function julian_day\n"}
{"id": 227, "function": "  integer function lpyr(yr)\n\n  implicit none\n\n  integer yr\n!\n!---- returns 1 if leap year\n!\n  lpyr=0\n  if(mod(yr,400) == 0) then\n    lpyr=1\n  else if(mod(yr,4) == 0) then\n    lpyr=1\n    if(mod(yr,100) == 0) lpyr=0\n  endif\n\n  end function lpyr\n"}
{"id": 228, "function": "  logical function is_leap_year(yr)\n\n  implicit none\n\n  integer yr\n\n  integer, external :: lpyr\n\n  if(lpyr(yr) == 1) then\n    is_leap_year = .true.\n  else\n    is_leap_year = .false.\n  endif\n\n  end function is_leap_year\n"}
{"id": 229, "function": "  integer function idaywk(jdayno)\n\n! idaywk = compute the day of the week given the julian day number,\n!          version 1.0.\n\n  implicit none\n\n! input variable\n  integer, intent(in) :: jdayno\n! jdayno = julian day number starting at noon of the day in question.\n\n! idaywk = day of the week, where 0=sunday, 1=monday, ..., 6=saturday.\n\n!----------\n! compute the day of the week given the julian day number.\n! you can find the julian day number given (day,month,year)\n! using subroutine calndr below.\n! example: for the first day of the gregorian calendar,\n! friday 15 october 1582, compute the julian day number (option 3 of\n! subroutine calndr) and compute the day of the week.\n!     call calndr (3, 15, 10, 1582, jdayno)\n!     write(*,*) jdayno, idaywk(jdayno)\n! the numbers printed should be 2299161 and 5, where 5 refers to friday.\n!\n! copyright (c) 1999 jon ahlquist.\n! issued under the second gnu general public license.\n! see www.gnu.org for details.\n! this program is distributed in the hope that it will be useful,\n! but without any warranty; without even the implied warranty of\n! merchantability or fitness for a particular purpose.\n! if you find any errors, please notify:\n! jon ahlquist <ahlquist@met.fsu.edu>\n! dept of meteorology\n! florida state university\n! tallahassee, fl 32306-4520\n! 15 march 1999.\n!\n!-----\n\n! converted to fortran90 by dimitri komatitsch,\n! university of pau, france, january 2008.\n\n! jdsun is the julian day number starting at noon on any sunday.\n! i arbitrarily chose the first sunday after julian day 1,\n! which is julian day 6.\n  integer, parameter :: jdsun = 6\n\n  idaywk = mod(jdayno-jdsun,7)\n\n! if jdayno-jdsun < 0, then we are taking the modulus of a negative\n\n! when the argument is negative.  in that case, we adjust the result\n! to a positive value.\n  if (idaywk < 0) idaywk = idaywk + 7\n\n  end function idaywk\n"}
{"id": 230, "function": "function f()\n  integer :: i = irand()     ! { dg-error \"not permitted in an initialization expression\" }\n  f = i\nend function\n"}
{"id": 231, "function": "  integer function random_get_seed(state)\n    implicit none\n    type(random_state), intent(in) :: state\n\n    random_get_seed = state%x\n  end function random_get_seed\n"}
{"id": 232, "function": "  real(wp) function random_real(state, positive)\n    implicit none\n    type(random_state), intent(inout) :: state\n    logical, optional, intent(in) :: positive\n\n    logical :: pos\n\n    pos = .false.\n    if (present(positive)) pos = positive\n\n    ! x_{n+1} = (ax_n + c) mod m\n    state%x = int(mod(a*state%x+c, m))\n\n    ! convert to a random real\n    if (pos) then\n       random_real = real(state%x,wp) / real(m,wp)\n    else\n       random_real = 1.0 - 2.0*real(state%x,wp)/real(m,wp)\n    end if\n  end function random_real\n"}
{"id": 233, "function": "  integer(long) function random_integer64(state, n)\n    implicit none\n    type(random_state), intent(inout) :: state\n    integer(long), intent(in) :: n\n\n    if (n .le. 0) then\n       random_integer64 = n\n       return\n    end if\n\n    ! x_{n+1} = (ax_n + c) mod m\n    state%x = int(mod(a*state%x+c, m))\n      \n    ! take modulo n for return value\n    random_integer64 = int(state%x * (real(n,wp)/real(m,wp)), long) + 1\n  end function random_integer64\n"}
{"id": 234, "function": "  integer function random_integer32(state, n)\n    implicit none\n    type(random_state), intent(inout) :: state\n    integer, intent(in) :: n\n\n    ! just call 64-bit version with type casts\n    random_integer32 = int(random_integer64(state, int(n,long)))\n  end function random_integer32\n"}
{"id": 235, "function": "  logical function random_logical(state)\n    implicit none\n    type(random_state), intent(inout) :: state\n\n    integer :: test\n\n    test = random_integer(state, 2)\n    random_logical = (test .eq. 1)\n  end function random_logical\n"}
{"id": 236, "function": "  function c_krm_solver_get_nzeros(sv) result(val)\n\n    implicit none\n    ! arguments\n    class(amg_c_krm_solver_type), intent(in) :: sv\n    integer(psb_epk_) :: val\n\n    val = sv%prec%get_nzeros()\n\n    return\n  end function c_krm_solver_get_nzeros\n"}
{"id": 237, "function": "  function c_krm_solver_sizeof(sv) result(val)\n\n    implicit none\n    ! arguments\n    class(amg_c_krm_solver_type), intent(in) :: sv\n    integer(psb_epk_) :: val\n\n    val = sv%prec%sizeof() + sv%desc_local%sizeof() + sv%a_local%sizeof()\n\n    return\n  end function c_krm_solver_sizeof\n"}
{"id": 238, "function": "  function c_krm_solver_get_fmt() result(val)\n    implicit none\n    character(len=32)  :: val\n\n    val = \"krm solver\"\n  end function c_krm_solver_get_fmt\n"}
{"id": 239, "function": "  function c_krm_solver_is_global(sv) result(val)\n    implicit none\n    class(amg_c_krm_solver_type), intent(in) :: sv\n    logical  :: val\n\n    val = (sv%global)\n  end function c_krm_solver_is_global\n"}
{"id": 240, "function": "  function c_krm_solver_is_iterative() result(val)\n    implicit none\n    logical  :: val\n\n    val = .true.\n  end function c_krm_solver_is_iterative\n"}
{"id": 241, "function": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}
{"id": 242, "function": "  function myaddint(a, b, n) result(r)\n    implicit none\n    integer :: a(*), b(*), n, r\n    integer :: i\n\n    !$omp simd\n    do i=1, n\n        a(i) = foo(b(i))  ! foo is not called under a condition\n    end do\n    r = a(n)\n\n  end function myaddint\n"}
{"id": 243, "function": "  function myaddint_ref(a, b, n) result(r)\n    implicit none\n    integer :: a(*), b(*), n, r\n    integer :: i\n\n    do i=1, n\n        a(i) = foo(b(i))\n    end do\n    r = a(n)\n\n  end function myaddint_ref\n"}
{"id": 244, "function": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}
{"id": 245, "function": "  function myaddfloat(x, y, n) result(r)\n    implicit none\n    real :: x(*), y(*), r\n    integer :: n\n    integer :: i\n\n    !$omp simd\n    do i=1, n\n       if (x(i) > y(i)) then\n          x(i) = goo(y(i))\n          ! goo is called under the condition (or within a branch)\n       else\n          x(i) = y(i)\n       endif\n    end do\n\n    r = x(n)\n  end function myaddfloat\n"}
{"id": 246, "function": "  function myaddfloat_ref(x, y, n) result(r)\n    implicit none\n    real :: x(*), y(*), r\n    integer :: n\n    integer :: i\n\n    do i=1, n\n       if (x(i) > y(i)) then\n          x(i) = goo(y(i))\n       else\n          x(i) = y(i)\n       endif\n    end do\n\n    r = x(n)\n  end function myaddfloat_ref\n"}
{"id": 247, "function": "elemental function gsw_enthalpy_ice (t, p)\n!==========================================================================\n!\n! calculates the specific enthalpy of ice (h_ih). \n!\n!  t  =  in-situ temperature (its-90)                             [ deg c ]\n!  p  =  sea pressure                                              [ dbar ]\n!        ( i.e. absolute pressure - 10.1325 dbar ) \n!\n!  gsw_enthalpy_ice  :  specific enthalpy of ice                   [ j/kg ]\n!--------------------------------------------------------------------------\n\nuse gsw_mod_teos10_constants, only : gsw_t0, db2pa\n\nuse gsw_mod_gibbs_ice_coefficients\n\nuse gsw_mod_kinds\n\nimplicit none\n\nreal (r8), intent(in) :: t, p\n\nreal (r8) :: gsw_enthalpy_ice\n\nreal (r8) :: tau, dzi, g0\ncomplex (r8) :: r2, sqtau_t1, sqtau_t2, g\n\ntau = (t + gsw_t0)*rec_tt\n\ndzi = db2pa*p*rec_pt\n\ng0 = g00 + dzi*(g01 + dzi*(g02 + dzi*(g03 + g04*dzi)))\n\nr2 = r20 + dzi*(r21 + r22*dzi)\n\nsqtau_t1 = (tau/t1)**2\nsqtau_t2 = (tau/t2)**2\n\ng = r1*t1*(log(1.0_r8 - sqtau_t1) + sqtau_t1) &\n    + r2*t2*(log(1.0_r8 - sqtau_t2) + sqtau_t2)\n\ngsw_enthalpy_ice = g0 + tt*real(g) \n\nreturn\nend function\n"}
{"id": 248, "function": "      function ccum_normal(x,mean,sd,status,check_input)\n\n        real (dpkind) :: ccum_normal\n! ..\n! .. scalar arguments ..\n        real (dpkind), optional :: mean, sd\n        real (dpkind) :: x\n        integer, optional, intent (out) :: status\n        logical, optional, intent (in) :: check_input\n! ..\n        call cdf_normal(which=1,ccum=ccum_normal,x=x,mean=mean,sd=sd, &\n          status=status,check_input=check_input)\n\n        return\n\n      end function ccum_normal\n"}
{"id": 249, "function": "  function polarization_copy (pol_in) result (pol)\n    type(polarization_t) :: pol\n    type(polarization_t), intent(in) :: pol_in\n    !!! type(state_matrix_t) :: state_dummy\n    pol%polarized = pol_in%polarized\n    pol%spin_type = pol_in%spin_type\n    pol%multiplicity = pol_in%multiplicity\n    !!! state_dummy = state_matrix_copy (pol_in%state)\n    !!! pol%state = state_dummy\n    pol%state = state_matrix_copy (pol_in%state)\n  end function polarization_copy\n"}
{"id": 250, "function": "  function state_matrix_copy (state_in) result (state)\n    type(state_matrix_t) :: state\n    type(state_matrix_t), intent(in), target :: state_in\n  end function state_matrix_copy\n"}
{"id": 251, "function": "  pure elemental type(timedelta) function datetime_minus_datetime(d1, d2) result(t)\n\n    class(datetime),intent(in) :: d1, d2\n    real(real64) :: days_diff, ndays1, ndays2, sgn\n    integer :: days, hours, minutes, seconds, year\n\n    real, parameter :: d2h = 24.       ! day -> hour\n    real, parameter :: h2d = 1. / d2h  ! hour -> day\n    real, parameter :: d2m = d2h * 60  ! day -> minute\n    real, parameter :: m2d = 1. / d2m  ! minute -> day\n    real, parameter :: s2d = m2d / 60. ! second -> day\n    real, parameter :: d2s = 1. / s2d  ! day -> second\n\n    ndays1 = 1.0_real64 &\n           * sum([(days_in_year(year), year = 1, d1 % year - 1)])&\n           + yearday(d1 % year, d1 % month, d1 % day)            &\n           + d1 % hour * h2d                                     &\n           + d1 % minute * m2d                                   &\n           + d1 % second * s2d\n\n    ndays2 = 1.0_real64 &\n           * sum([(days_in_year(year), year = 1, d2 % year - 1)])&\n           + yearday(d2 % year, d2 % month, d2 % day)            &\n           + d2 % hour * h2d                                     &\n           + d2 % minute * m2d                                   &\n           + d2 % second * s2d\n\n    days_diff = ndays1 - ndays2\n\n    sgn = sign(1.0_real64, days_diff)\n\n    days = int(abs(days_diff))\n    hours = int((abs(days_diff) - days) * d2h)\n    minutes = int((abs(days_diff) - days - hours * h2d) * d2m)\n    seconds = int((abs(days_diff) - days - hours * h2d & \n                 - minutes * m2d) * d2s)\n\n    t = timedelta(sgn * days, sgn * hours, sgn * minutes, sgn * seconds)\n\n  end function datetime_minus_datetime\n"}
{"id": 252, "function": "  pure elemental integer function days_in_month(month, year)\n    ! given input month and year, \n    ! returns the number of days in the month.\n    integer, intent(in) :: month, year\n    integer, parameter :: days(*) = [31, 28, 31, 30, 31, 30, &\n                                     31, 31, 30, 31, 30, 31]\n    if (month < 1 .or. month > 12) then\n      days_in_month = 0\n    else if (month == 2 .and. is_leap_year(year)) then\n      days_in_month = 29\n    else\n      days_in_month = days(month)\n    end if\n  end function days_in_month\n"}
{"id": 253, "function": "  pure elemental integer function days_in_year(year)\n    ! given input year, returns the number of days in year.\n    integer, intent(in) :: year\n    if (is_leap_year(year)) then\n      days_in_year = 366\n    else\n      days_in_year = 365\n    end if\n  end function days_in_year\n"}
{"id": 254, "function": "  pure elemental logical function is_leap_year(year)\n    ! returns .true. if input year is a leap year,\n    ! and .false. otherwise.\n    integer, intent(in) :: year\n    is_leap_year = (mod(year, 4) == 0 .and. .not. mod(year, 100) == 0)&\n              .or. (mod(year, 400) == 0)\n  end function is_leap_year\n"}
{"id": 255, "function": "  type(datetime) function current_time() result(res)\n    integer :: values(8)\n    call date_and_time(values=values)\n    res = datetime(year = values(1), month = values(2),&\n                   day = values(3), hour = values(5),&\n                   minute = values(6), second = values(7))\n  end function current_time\n"}
{"id": 256, "function": "  pure elemental integer function yearday(year, month, day)\n    ! given input year, month, and day,\n    ! returns the number of day in the year.\n    integer, intent(in) :: year, month, day \n    integer :: m\n    yearday = sum([(days_in_month(m, year), m = 1, month - 1)]) + day\n  end function yearday\n"}
{"id": 257, "function": "    function markets(x)\n\n        use toolbox\n\n        implicit none\n        real*8, intent(in) :: x(:)\n        real*8 :: markets(size(x, 1))\n        real*8 :: mat(4, 4), vec(4)\n        integer :: i\n\n        ! copy producer prices and taxes\n        w(1)      = 1d0\n        w(2)      = x(1)\n        r         = x(2)\n        tauc(1,1) = x(3)\n        tauc(1,2) = x(4)\n        tauc(2,:) = tauc(1,:)\n\n        ! 1. calculate k/y and l/y\n        do i = 1, 2\n            ky(:,i) = a0*((1d0-beta(:,i))/beta(:,i)*w(i)/r)**beta(:,i)\n            ly(:,i) = a0*(beta(:,i)/(1d0-beta(:,i))*r/w(i))**(1d0-beta(:,i))\n        enddo\n\n        ! 2. determine producer prices\n        q(:,1) = w(1)*ly(:,1)+r*ky(:,1)\n        call lu_solve(id-transpose(a), q(:,1))\n        q(1,2) = (a(2,1)*q(2,1)+w(2)*ly(1,2)+r*ky(1,2))/(1d0-a(1,1))\n        q(2,2) = q(2,1)\n\n        ! 3. consumer prices and demands\n        do i = 1, 2\n            p(:,i) = q(:,i)*(1d0+tauc(:,i))\n            wn(i) = w(i)*(1d0-tauw(i))\n            rn(i) = r*(1d0-taur(i))\n            ybarn(i) = wn(i)*tbar(i)+rn(i)*kbar(i)\n            xd(:,i) = alpha/p(:,i)*ybarn(i)\n            ell(i)  = (1d0-alpha(1)-alpha(2))/wn(i)*ybarn(i)\n        enddo\n\n        ! 4. determine output levels\n        vec(1) = xd(1,1)+g\n        vec(2) = xd(2,1)+xd(2,2)\n        vec(3) = xd(1,2)+g\n        vec(4) = tbar(1)-ell(1)\n\n        mat(1, :) = (/1d0-a(1,1), -a(1,2), 0d0, 0d0/)\n        mat(2, :) = (/-a(2,1), 1d0-a(2,2), -a(2,1), 1d0-a(2,2)/)\n        mat(3, :) = (/0d0, 0d0, 1d0-a(1,1), -a(1,2)/)\n        mat(4, :) = (/ly(1,1), ly(2,1), 0d0, 0d0/)\n\n        call lu_solve(mat, vec)\n        y(1,1) = vec(1)\n        y(2,1) = vec(2)\n        y(1,2) = vec(3)\n        y(2,2) = vec(4)\n\n        ! 5. compute k and l\n        k = ky*y\n        l = ly*y\n\n        ! 6. check markets and budget\n        markets(1) = l(1,2)+l(2,2)-(tbar(2)-ell(2))\n        markets(2) = sum(k)-sum(kbar)\n        markets(3) = q(1,1)*g-sum(tauc(:,1)*q(:,1)*xd(:,1))-&\n            tauw(1)*w(1)*(tbar(1)-ell(1))-taur(1)*r*kbar(1)\n        markets(4) = q(1,2)*g-sum(tauc(:,2)*q(:,2)*xd(:,2))-&\n            tauw(2)*w(2)*(tbar(2)-ell(2))-taur(2)*r*kbar(2)\n\n    end function\n"}
{"id": 258, "function": "  function calc_plancktemptorad( channel, temperature ) result( radiance )\n\n    !--- interface\n\n    integer      ,intent(in) :: channel         ! ch seq #\n    real(fp_kind),intent(in) :: temperature     ! temperature (k)\n    real(fp_kind)            :: radiance        ! radiance\n\n    !--- local variables\n\n    real(fp_kind) :: effective_temperature\n\n\n    !--- apply the polychromaticity correction\n    !--- to obtain an effective temperature\n\n    effective_temperature = spccoeff%band_c1( channel ) &\n                                + ( spccoeff%band_c2( channel ) * temperature )\n\n\n    !--- calculate the planck radiance\n\n    radiance =                  spccoeff%planck_c1( channel )  / &\n    !          ----------------------------------------------------------------------\n               ( exp( spccoeff%planck_c2( channel ) / effective_temperature ) - one )\n\n  end function calc_plancktemptorad\n"}
{"id": 259, "function": "  function calc_planckradtotemp( channel, radiance ) result( temperature )\n\n    !--- interface\n\n    integer      ,intent(in) :: channel         ! ch seq #\n    real(fp_kind),intent(in) :: radiance        ! radiance\n    real(fp_kind)            :: temperature     ! temperature (k)\n\n    !--- local variables\n\n    real(fp_kind) :: effective_temperature\n\n\n    !--- calculate the effective temperature\n\n    effective_temperature =              spccoeff%planck_c2( channel )  / &\n    !                       ---------------------------------------------------------\n                            log( ( spccoeff%planck_c1( channel ) / radiance ) + one )\n\n\n    !--- apply the polychromatic correction to \n    !--- obtain the true temperature\n\n    temperature = ( effective_temperature - spccoeff%band_c1( channel ) ) / &\n    !             ---------------------------------------------------------\n                                spccoeff%band_c2( channel )\n\n  end function calc_planckradtotemp\n"}
{"id": 260, "function": "  function rootzone_v50_islanduseupdated(rootzone) result(lupdated)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    logical                             :: lupdated\n    \n    lupdated = rootzone%agrootzone%subregioncropareadatafile%lupdated   .or.  &\n               rootzone%agrootzone%elemagareadatafile%lupdated          .or.  &\n               rootzone%urbanrootzone%landusedatafile%lupdated          .or.  &\n               rootzone%nvrvrootzone%landusedatafile%lupdated\n    \n  end function rootzone_v50_islanduseupdated\n"}
{"id": 261, "function": "  function rootzone_v50_getndatalist_atlocationtype(rootzone,ilocationtype) result(ndata)\n     class(rootzone_v50_type),intent(in) :: rootzone\n     integer,intent(in)                  :: ilocationtype\n     integer                             :: ndata\n     \n     !initialize\n     ndata = 0\n     \n     select case (ilocationtype)\n         case (f_ilocationtype_subregion)\n             !land and water use budget\n             if (rootzone%flags%lwusebudrawfile_defined) then\n                 ndata = 1\n             end if\n             \n             !root zone budget\n             if (rootzone%flags%rootzonebudrawfile_defined) then\n                 ndata = ndata + 1\n             end if\n                          \n             \n         case (f_ilocationtype_zone)\n             !land and water use zone budget\n             if (rootzone%flags%lwusezonebudrawfile_defined) then\n                 ndata = 1\n             end if\n             \n             !root zone zone budget\n             if (rootzone%flags%rootzonezonebudrawfile_defined) then\n                 ndata = ndata + 1\n             end if\n                                       \n    end select\n     \n  end function rootzone_v50_getndatalist_atlocationtype\n"}
{"id": 262, "function": "  pure function rootzone_v50_getnagcrops(rootzone) result(nagcrops)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    integer                             :: nagcrops\n    \n    nagcrops = rootzone%agrootzone%ncrops\n    \n  end function rootzone_v50_getnagcrops\n"}
{"id": 263, "function": "  pure function rootzone_v50_getndemandlocations(rootzone) result(nlocations)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    integer                             :: nlocations\n    \n    nlocations = size(rootzone%watersupply)\n    \n  end function rootzone_v50_getndemandlocations\n"}
{"id": 264, "function": "  function rootzone_v50_getversion(rootzone) result(cvrs)\n    class(rootzone_v50_type) :: rootzone\n    character(:),allocatable :: cvrs\n    \n    if (.not. rootzone%version%isdefined())   &\n        rootzone%version = rootzone%version%new(ilenversion,cversion,crevision)\n\n    cvrs = rootzone%version%getversion()\n    \n  end function rootzone_v50_getversion\n"}
{"id": 265, "function": "  function rootzone_v50_getpercall(rootzone,appgrid) result(perc)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8)                             :: perc(appgrid%nelements)\n\n    !local variables\n    integer :: indxelem,iregion,isoil,indx,ielem\n    \n    !initialize\n    perc = 0.0\n    \n    associate (pflags       => rootzone%flags                  , &\n               pelemsoil    => rootzone%elemsoiltype           , &\n               pag          => rootzone%agrootzone             , &\n               purban       => rootzone%urbanrootzone          , &\n               pnvrv        => rootzone%nvrvrootzone           , &\n               purbelemtogw => rootzone%urbanrootzone%elemtogw )\n        \n        do indxelem=1,appgrid%nelements\n            iregion = appgrid%appelement(indxelem)%subregion\n            isoil   = pelemsoil(indxelem)\n   \n            !ag lands\n            if (pflags%lag_defined) perc(indxelem) = (pag%agdata(isoil,iregion)%perc + pag%agdata(isoil,iregion)%percch) * pag%elementalarea(indxelem)\n\n            !urban \n            if (pflags%lurban_defined) perc(indxelem) = perc(indxelem) + (purban%urbdata(isoil,iregion)%perc + purban%urbdata(isoil,iregion)%percch) * purban%elementalarea(indxelem)\n\n            !native and riparian vegetation areas\n            if (pflags%lnvrv_defined) perc(indxelem) = perc(indxelem) + (pnvrv%nativeveg(isoil,iregion)%perc   + pnvrv%nativeveg(isoil,iregion)%percch) * pnvrv%elementalarea_nv(indxelem)   &\n                                                                      + (pnvrv%riparianveg(isoil,iregion)%perc + pnvrv%riparianveg(isoil,iregion)%percch) * pnvrv%elementalarea_rv(indxelem) \n\n        end do\n        \n        !include urban surface runoff in perc if it goes to groundwater\n        if (pflags%lurban_defined) then\n            do indx=1,size(purbelemtogw)\n                ielem       = purbelemtogw(indx)\n                if (purban%elementalarea(ielem) .eq. 0.0) cycle\n                iregion     = appgrid%appelement(ielem)%subregion\n                isoil       = pelemsoil(ielem)\n                perc(ielem) = perc(ielem) + (purban%urbdata(isoil,iregion)%runoff + purban%urbdata(isoil,iregion)%returnflow) * purban%elementalarea(ielem)\n            end do\n        end if\n        \n    end associate\n               \n  end function rootzone_v50_getpercall\n"}
{"id": 266, "function": "  function rootzone_v50_getpercelement(rootzone,ielem,appgrid) result(perc)\n    class(rootzone_v50_type),intent(in)   :: rootzone\n    integer,intent(in)                    :: ielem\n    type(appgridtype),optional,intent(in) :: appgrid\n    real(8)                               :: perc\n    \n    !local variables\n    integer :: isoil,iregion\n    \n    !initialize\n    perc = 0.0\n    \n    iregion = appgrid%appelement(ielem)%subregion\n    isoil   = rootzone%elemsoiltype(ielem)\n   \n    !ag lands\n    if (rootzone%flags%lag_defined) perc = (rootzone%agrootzone%agdata(isoil,iregion)%perc + rootzone%agrootzone%agdata(isoil,iregion)%percch) * rootzone%agrootzone%elementalarea(ielem)\n\n    !urban\n    if (rootzone%flags%lurban_defined) perc = perc+ (rootzone%urbanrootzone%urbdata(isoil,iregion)%perc + rootzone%urbanrootzone%urbdata(isoil,iregion)%percch) * rootzone%urbanrootzone%elementalarea(ielem)\n\n    !native and riparian vegetation areas\n    if (rootzone%flags%lnvrv_defined) perc = perc + (rootzone%nvrvrootzone%nativeveg(isoil,iregion)%perc   + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%percch) * rootzone%nvrvrootzone%elementalarea_nv(ielem)   &\n                                                  + (rootzone%nvrvrootzone%riparianveg(isoil,iregion)%perc + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%percch) * rootzone%nvrvrootzone%elementalarea_rv(ielem) \n    \n    !include urban surface runoff in perc if it goes to groundwater\n    if (rootzone%flags%lurban_defined) then\n        if (rootzone%urbanrootzone%elementalarea(ielem) .eq. 0.0) return\n        if (locateinlist(ielem,rootzone%urbanrootzone%elemtogw) .gt. 0) then\n            iregion  = appgrid%appelement(ielem)%subregion\n            isoil    = rootzone%elemsoiltype(ielem)\n            perc     = perc + (rootzone%urbanrootzone%urbdata(isoil,iregion)%runoff + rootzone%urbanrootzone%urbdata(isoil,iregion)%returnflow) * rootzone%urbanrootzone%elementalarea(ielem)\n        end if\n    end if\n\n  end function rootzone_v50_getpercelement\n"}
{"id": 267, "function": "  function regionaldemand(nregions,rootzone,luindex) result(rdemand)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rdemand(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rdemand(1:nregions) = rootzone%agrootzone%subregionaldemand\n          else\n              rdemand = 0.0\n              return\n          end if\n   \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rdemand(1:nregions) = rootzone%urbanrootzone%demand\n          else\n              rdemand = 0.0\n              return\n          end if\n      \n      !otherwise\n      case default\n        rdemand = 0.0\n        return\n      \n    end select\n    \n    !model-wide demand\n    rdemand(nregions+1) = sum(rdemand(1:nregions))\n\n  end function regionaldemand\n"}
{"id": 268, "function": "  function regionalagrawdemand(nregions,rootzone) result(rdemandraw)\n    integer,intent(in)                 :: nregions\n    type(rootzone_v50_type),intent(in) :: rootzone\n    real(8)                            :: rdemandraw(nregions+1)\n    \n    if (rootzone%flags%lag_defined) then\n        rdemandraw(1:nregions) = sum(rootzone%agrootzone%agdata%demandraw , dim=1)\n        rdemandraw(nregions+1) = sum(rdemandraw(1:nregions))\n    else\n        rdemandraw = 0.0\n    end if\n    \n  end function regionalagrawdemand\n"}
{"id": 269, "function": "  function regionaletaw(nregions,rootzone) result(retaw)\n    integer,intent(in)                 :: nregions\n    type(rootzone_v50_type),intent(in) :: rootzone\n    real(8)                            :: retaw(nregions+1)\n    \n    if (rootzone%flags%lag_defined) then\n        retaw(1:nregions) = sum(rootzone%agrootzone%agdata%etaw * rootzone%agrootzone%agdata%area , dim=1)\n        retaw(nregions+1) = sum(retaw(1:nregions))\n    else\n        retaw = 0.0\n    end if\n\n  end function regionaletaw\n"}
{"id": 270, "function": "  function regionaletp(nregions,rootzone) result(retp)\n    integer,intent(in)                 :: nregions\n    type(rootzone_v50_type),intent(in) :: rootzone\n    real(8)                            :: retp(nregions+1)\n    \n    if (rootzone%flags%lag_defined) then\n        retp(1:nregions) = sum(rootzone%agrootzone%agdata%etp * rootzone%agrootzone%agdata%area , dim=1)\n        retp(nregions+1) = sum(retp(1:nregions))\n    else\n        retp = 0.0\n    end if\n\n  end function regionaletp\n"}
{"id": 271, "function": "  function regionaletoth(nregions,rootzone) result(retoth)\n    integer,intent(in)                 :: nregions\n    type(rootzone_v50_type),intent(in) :: rootzone\n    real(8)                            :: retoth(nregions+1)\n    \n    if (rootzone%flags%lag_defined) then\n        retoth(1:nregions) = sum(rootzone%agrootzone%agdata%etoth * rootzone%agrootzone%agdata%area, dim=1)\n        retoth(nregions+1) = sum(retoth(1:nregions))\n    else\n        retoth = 0.0\n    end if\n\n  end function regionaletoth\n"}
{"id": 272, "function": "  function regionalreuse(nregions,rootzone,luindex) result(rreuse)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rreuse(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n        if (rootzone%flags%lag_defined) then\n            rreuse(1:nregions) = sum(rootzone%agrootzone%agdata%reuse * rootzone%agrootzone%agdata%area, dim=1)\n        else\n            rreuse = 0.0\n            return\n        end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rreuse(1:nregions) = sum(rootzone%urbanrootzone%urbdata%reuse * rootzone%urbanrootzone%urbdata%area , dim=1)\n          else\n              rreuse = 0.0\n              return\n          end if\n        \n      !otherwise\n      case default\n          rreuse = 0.0\n          return\n      \n    end select\n        \n    !model-wide reuse\n    rreuse(nregions+1) = sum(rreuse(1:nregions))\n\n  end function regionalreuse\n"}
{"id": 273, "function": "  function regionalprecip(nregions,rootzone,luindex) result(rprecip)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rprecip(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rprecip(1:nregions) = sum(rootzone%soilregionprecip * rootzone%agrootzone%agdata%area , dim=1)\n          else\n              rprecip = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rprecip(1:nregions) = sum(rootzone%soilregionprecip * rootzone%urbanrootzone%urbdata%area , dim=1)\n          else \n              rprecip = 0.0\n              return\n          end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              rprecip(1:nregions) = sum(rootzone%soilregionprecip * (rootzone%nvrvrootzone%nativeveg%area + rootzone%nvrvrootzone%riparianveg%area), dim=1)\n          else\n              rprecip = 0.0\n              return\n          end if\n    end select\n    \n    !model-wide precip\n    rprecip(nregions+1) = sum(rprecip(1:nregions))\n\n  end function regionalprecip\n"}
{"id": 274, "function": "  function regionalgenericmoistinflow(nregions,rootzone,luindex) result(rgenericmoist)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rgenericmoist(nregions+1)\n    \n    !local variables\n    integer :: indxsoil,indxregion\n    \n    !initialize\n    rgenericmoist = 0.0\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (.not. rootzone%flags%lag_defined) return\n          associate (prgenericmoisture => rootzone%genericmoisturedata%rgenericmoisture , &\n                     prootdepth        => rootzone%agrootzone%avgcrop%rootdepth         , &\n                     pagdata           => rootzone%agrootzone%agdata                    )\n              do indxregion=1,nregions\n                  do indxsoil=1,rootzone%nsoils\n                      rgenericmoist(indxregion) = rgenericmoist(indxregion) + (prgenericmoisture(indxsoil,indxregion) * prootdepth(indxregion) - pagdata(indxsoil,indxregion)%gmexcess) * pagdata(indxsoil,indxregion)%area\n                  end do\n              end do\n          end associate\n        \n      !urban\n      case (f_ilanduse_urban)\n          if (.not. rootzone%flags%lurban_defined) return\n          associate (prgenericmoisture => rootzone%genericmoisturedata%rgenericmoisture , &\n                     prootdepth        => rootzone%urbanrootzone%rootdepth              , &\n                     pperviousfrac     => rootzone%urbanrootzone%perviousfrac           , &\n                     purbdata          => rootzone%urbanrootzone%urbdata                )\n              do indxregion=1,nregions\n                  do indxsoil=1,rootzone%nsoils\n                      rgenericmoist(indxregion) = rgenericmoist(indxregion) + (prgenericmoisture(indxsoil,indxregion) * prootdepth - purbdata(indxsoil,indxregion)%gmexcess) * purbdata(indxsoil,indxregion)%area * pperviousfrac(indxregion)\n                  end do\n              end do\n          end associate\n        \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (.not. rootzone%flags%lnvrv_defined) return\n          associate (prgenericmoisture => rootzone%genericmoisturedata%rgenericmoisture , &\n                     prootdepth_nv     => rootzone%nvrvrootzone%rootdepth_native        , &\n                     prootdepth_rv     => rootzone%nvrvrootzone%rootdepth_riparian      , &\n                     pnativeveg        => rootzone%nvrvrootzone%nativeveg               , &\n                     priparianveg      => rootzone%nvrvrootzone%riparianveg             )\n              do indxregion=1,nregions\n                  do indxsoil=1,rootzone%nsoils\n                      rgenericmoist(indxregion) = rgenericmoist(indxregion)                                                                                                                                   &\n                                                + (prgenericmoisture(indxsoil,indxregion) * prootdepth_nv - pnativeveg(indxsoil,indxregion)%gmexcess)   * pnativeveg(indxsoil,indxregion)%area   &\n                                                + (prgenericmoisture(indxsoil,indxregion) * prootdepth_rv - priparianveg(indxsoil,indxregion)%gmexcess) * priparianveg(indxsoil,indxregion)%area                          \n                  end do\n              end do\n          end associate\n        \n    end select\n    \n    !accumulate generic moisture inflow for the entire model area\n    rgenericmoist(nregions+1) = sum(rgenericmoist(1:nregions))\n\n  end function regionalgenericmoistinflow\n"}
{"id": 275, "function": "  function regionalsoilmchange(nregions,rootzone,luindex) result(rsoilmch)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rsoilmch(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rsoilmch(1:nregions) = sum(rootzone%agrootzone%agdata%soilmch, dim=1)\n          else\n              rsoilmch = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rsoilmch(1:nregions) = sum(rootzone%urbanrootzone%urbdata%soilmch , dim=1)\n          else\n              rsoilmch = 0.0\n              return\n          end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              rsoilmch(1:nregions) = sum(rootzone%nvrvrootzone%nativeveg%soilmch + rootzone%nvrvrootzone%riparianveg%soilmch, dim=1)\n          else\n              rsoilmch = 0.0\n              return\n          end if\n      \n    end select\n    \n    !model-wide soil moisture change due to land use change\n    rsoilmch(nregions+1) = sum(rsoilmch(1:nregions))\n\n  end function regionalsoilmchange\n"}
{"id": 276, "function": "  function regionaleta(nregions,rootzone,luindex) result(reta)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: reta(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              reta(1:nregions) = sum(rootzone%agrootzone%agdata%eta * rootzone%agrootzone%agdata%area, dim=1)\n          else\n              reta = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              reta(1:nregions) = sum(rootzone%urbanrootzone%urbdata%eta * rootzone%urbanrootzone%urbdata%area, dim=1)\n          else\n              reta = 0.0\n              return\n          end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              reta(1:nregions) = sum(rootzone%nvrvrootzone%nativeveg%eta * rootzone%nvrvrootzone%nativeveg%area + rootzone%nvrvrootzone%riparianveg%eta * rootzone%nvrvrootzone%riparianveg%area , dim=1)\n          else\n              reta = 0.0\n              return\n          end if\n      \n    end select\n    \n    !model-wide actual et\n    reta(nregions+1) = sum(reta(1:nregions))\n\n  end function regionaleta\n"}
{"id": 277, "function": "  function regionalperc(appgrid,rootzone,luindex) result(rperc)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)       :: appgrid\n    integer,intent(in)                 :: luindex\n    real(8)                            :: rperc(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: indx,ielem,isoil,iregion,nregions\n    \n    !initialize\n    nregions = appgrid%nsubregions\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rperc(1:nregions) = sum((rootzone%agrootzone%agdata%perc + rootzone%agrootzone%agdata%percch) * rootzone%agrootzone%agdata%area , dim=1)\n          else\n              rperc = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rperc(1:nregions) = sum((rootzone%urbanrootzone%urbdata%perc + rootzone%urbanrootzone%urbdata%percch) * rootzone%urbanrootzone%urbdata%area , dim=1)\n              !add surface runoff to perc if surface runoff goes to groundwater\n              do indx=1,size(rootzone%urbanrootzone%elemtogw)\n                  ielem = rootzone%urbanrootzone%elemtogw(indx)\n                  if (rootzone%urbanrootzone%elementalarea(ielem) .eq. 0.0) cycle\n                  isoil          = rootzone%elemsoiltype(ielem)\n                  iregion        = appgrid%appelement(ielem)%subregion\n                  rperc(iregion) = rperc(iregion) + (rootzone%urbanrootzone%urbdata(isoil,iregion)%runoff + rootzone%urbanrootzone%urbdata(isoil,iregion)%returnflow) * rootzone%urbanrootzone%elementalarea(ielem)\n              end do\n          else\n              rperc = 0.0\n              return\n          end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              rperc(1:nregions) = sum( (rootzone%nvrvrootzone%nativeveg%perc   + rootzone%nvrvrootzone%nativeveg%percch) * rootzone%nvrvrootzone%nativeveg%area             &\n                                      +(rootzone%nvrvrootzone%riparianveg%perc + rootzone%nvrvrootzone%riparianveg%percch) * rootzone%nvrvrootzone%riparianveg%area  , dim=1)\n          else\n              rperc = 0.0\n              return\n          end if\n      \n    end select\n    \n    !model-wide percolation\n    rperc(nregions+1) = sum(rperc(1:nregions))\n\n  end function regionalperc\n"}
{"id": 278, "function": "  function regionalinfiltration(appgrid,rootzone,luindex) result(rinfilt)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)       :: appgrid\n    integer,intent(in)                 :: luindex\n    real(8)                            :: rinfilt(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: indx,ielem,isoil,iregion,nregions\n    \n    !initialize\n    nregions = appgrid%nsubregions\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rinfilt(1:nregions) = sum((rootzone%agrootzone%agdata%precipinfilt + rootzone%agrootzone%agdata%iriginfilt) *  rootzone%agrootzone%agdata%area , dim=1)\n          else\n              rinfilt = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rinfilt(1:nregions) = sum((rootzone%urbanrootzone%urbdata%precipinfilt + rootzone%urbanrootzone%urbdata%iriginfilt) * rootzone%urbanrootzone%urbdata%area , dim=1)\n              !add surface runoff to infiltration if surface runoff goes to groundwater\n              do indx=1,size(rootzone%urbanrootzone%elemtogw)\n                  ielem = rootzone%urbanrootzone%elemtogw(indx)\n                  if (rootzone%urbanrootzone%elementalarea(ielem) .eq. 0.0) cycle\n                  isoil            = rootzone%elemsoiltype(ielem)\n                  iregion          = appgrid%appelement(ielem)%subregion\n                  rinfilt(iregion) = rinfilt(iregion) + (rootzone%urbanrootzone%urbdata(isoil,iregion)%runoff + rootzone%urbanrootzone%urbdata(isoil,iregion)%returnflow) * rootzone%urbanrootzone%elementalarea(ielem)\n              end do\n          else\n              rinfilt = 0.0\n              return\n          end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              rinfilt(1:nregions) = sum(rootzone%nvrvrootzone%nativeveg%precipinfilt * rootzone%nvrvrootzone%nativeveg%area + rootzone%nvrvrootzone%riparianveg%precipinfilt * rootzone%nvrvrootzone%riparianveg%area , dim=1)\n          else\n              rinfilt = 0.0\n              return\n          end if\n      \n    end select\n    \n    !model-wide infiltration\n    rinfilt(nregions+1) = sum(rinfilt(1:nregions))\n\n  end function regionalinfiltration\n"}
{"id": 279, "function": "  function regionalluarea(nregions,rootzone,luindex) result(rluarea)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rluarea(nregions+1)\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n        if (rootzone%flags%lag_defined) then\n            rluarea(1:nregions) = rootzone%agrootzone%subregionalarea\n        else\n            rluarea = 0.0\n            return\n        end if\n    \n      !urban\n      case (f_ilanduse_urban)\n        if (rootzone%flags%lurban_defined) then\n            rluarea(1:nregions) = rootzone%urbanrootzone%subregionalarea\n        else\n            rluarea = 0.0\n            return\n        end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n        if (rootzone%flags%lnvrv_defined) then\n            rluarea(1:nregions) = rootzone%nvrvrootzone%subregionalarea_nv +  rootzone%nvrvrootzone%subregionalarea_rv\n        else\n            rluarea = 0.0\n            return\n        end if\n      \n    end select\n    \n    !entire model area\n    rluarea(nregions+1) = sum(rluarea(1:nregions))\n\n  end function regionalluarea\n"}
{"id": 280, "function": "  function regionalluarea_forsingleregion(iregion,rootzone,luindex) result(area)\n    integer,intent(in)                 :: iregion,luindex\n    type(rootzone_v50_type),intent(in) :: rootzone\n    real(8)                            :: area\n    \n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n        if (rootzone%flags%lag_defined) then\n            area = rootzone%agrootzone%subregionalarea(iregion)\n        else\n            area = 0.0\n        end if\n    \n      !urban\n      case (f_ilanduse_urban)\n        if (rootzone%flags%lurban_defined) then\n            area = rootzone%urbanrootzone%subregionalarea(iregion)\n        else\n            area = 0.0\n        end if\n      \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n        if (rootzone%flags%lnvrv_defined) then\n            area = rootzone%nvrvrootzone%subregionalarea_nv(iregion) + rootzone%nvrvrootzone%subregionalarea_rv(iregion)\n        else\n            area = 0.0\n        end if\n      \n    end select\n    \n  end function regionalluarea_forsingleregion\n"}
{"id": 281, "function": "  function regionalrunoff(appgrid,rootzone,luindex) result(rrunoff)\n    type(appgridtype),intent(in)       :: appgrid\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: luindex\n    real(8)                            :: rrunoff(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: nregions,indx,ielem,isoil,iregion\n    \n    !initialize\n    nregions = appgrid%nsubregions\n\n    select case (luindex)\n    \n      !ag lands\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rrunoff(1:nregions) = sum(rootzone%agrootzone%agdata%runoff * rootzone%agrootzone%agdata%area , dim=1)\n          else\n              rrunoff = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rrunoff(1:nregions) = sum(rootzone%urbanrootzone%urbdata%runoff * rootzone%urbanrootzone%urbdata%area, dim=1)\n              !substract runoff that becomes gw recharge\n              do indx=1,size(rootzone%urbanrootzone%elemtogw)\n                  ielem = rootzone%urbanrootzone%elemtogw(indx)\n                  if (rootzone%urbanrootzone%elementalarea(ielem) .eq. 0.0) cycle\n                  isoil            = rootzone%elemsoiltype(ielem)\n                  iregion          = appgrid%appelement(ielem)%subregion\n                  rrunoff(iregion) = rrunoff(iregion) - rootzone%urbanrootzone%urbdata(isoil,iregion)%runoff * rootzone%urbanrootzone%elementalarea(ielem)\n              end do\n          else\n              rrunoff = 0.0\n              return\n          end if\n          \n      !native and riparian vegetation\n      case (f_ilanduse_nvrv)\n          if (rootzone%flags%lnvrv_defined) then\n              rrunoff(1:nregions) = sum(rootzone%nvrvrootzone%nativeveg%runoff * rootzone%nvrvrootzone%nativeveg%area + rootzone%nvrvrootzone%riparianveg%runoff * rootzone%nvrvrootzone%riparianveg%area  ,  dim=1)\n          else\n              rrunoff = 0.0\n              return\n          end if\n      \n    end select\n          \n    !accumulate to entire domain\n    rrunoff(nregions+1) = sum(rrunoff(1:nregions))\n    \n  end function regionalrunoff\n"}
{"id": 282, "function": "  function regionalreturn(appgrid,rootzone,luindex) result(rreturn)\n    type(appgridtype),intent(in)       :: appgrid\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: luindex\n    real(8)                            :: rreturn(appgrid%nsubregions+1)\n\n    !local variables\n    integer :: ielem,indx,isoil,iregion,nregions\n    \n    !initialize\n    nregions = appgrid%nsubregions\n    \n    select case (luindex)\n    \n      !ag land\n      case (f_ilanduse_ag)\n          if (rootzone%flags%lag_defined) then\n              rreturn(1:nregions) = sum(rootzone%agrootzone%agdata%returnflow * rootzone%agrootzone%agdata%area, dim=1)\n          else\n              rreturn = 0.0\n              return\n          end if\n    \n      !urban\n      case (f_ilanduse_urban)\n          if (rootzone%flags%lurban_defined) then\n              rreturn(1:nregions) = sum(rootzone%urbanrootzone%urbdata%returnflow * rootzone%urbanrootzone%urbdata%area, dim=1)\n              !subtract return flow that becomes recharge to groundwater\n              do indx=1,size(rootzone%urbanrootzone%elemtogw)\n                  ielem = rootzone%urbanrootzone%elemtogw(indx)\n                  if (rootzone%urbanrootzone%elementalarea(ielem) .eq. 0.0) cycle\n                  isoil            = rootzone%elemsoiltype(ielem)\n                  iregion          = appgrid%appelement(ielem)%subregion\n                  rreturn(iregion) = rreturn(iregion) - rootzone%urbanrootzone%urbdata(isoil,iregion)%returnflow * rootzone%urbanrootzone%elementalarea(ielem)\n              end do\n          else\n              rreturn = 0.0\n              return\n          end if\n      \n      !otherwise\n      case default\n          rreturn = 0.0\n          return\n        \n    end select\n          \n    !accumulate to entire domain\n    rreturn(nregions+1) = sum(rreturn(1:nregions))\n    \n  end function regionalreturn\n"}
{"id": 283, "function": "  function regionalpumping(nregions,rootzone,luindex) result(rpump)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rpump(nregions+1)\n    \n    select case (luindex)\n      \n      !ag\n      case (f_ilanduse_ag)\n       rpump(1:nregions) = rootzone%watersupply%pumping_ag\n      \n      !urban\n      case (f_ilanduse_urban)\n        rpump(1:nregions) = rootzone%watersupply%pumping_urb\n        \n      !otherwise\n      case default\n        rpump(1:nregions) = 0.0\n        \n    end select\n    \n    !accumulate to entire domain\n    rpump(nregions+1) = sum(rpump(1:nregions))\n        \n  end function regionalpumping\n"}
{"id": 284, "function": "  function regionaldeliveries(nregions,rootzone,luindex) result(rdeli)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8)                            :: rdeli(nregions+1)\n    \n    select case (luindex)\n      \n      !ag lands\n      case (f_ilanduse_ag)\n        rdeli(1:nregions) = rootzone%watersupply%diversion_ag\n      \n      !urban\n      case (f_ilanduse_urban)\n        rdeli(1:nregions) = rootzone%watersupply%diversion_urb\n        \n      !otherwise\n      case default\n        rdeli(1:nregions) = 0.0\n        \n    end select\n    \n    !accumulate to entire domain\n    rdeli(nregions+1) = sum(rdeli(1:nregions))\n    \n  end function regionaldeliveries\n"}
{"id": 285, "function": "  function regionalmoiststorage(nsubregions,rootzone) result(rsoilm)\n    integer,intent(in)      :: nsubregions\n    type(rootzone_v50_type) :: rootzone\n    real(8)                 :: rsoilm(nsubregions+1,f_ingrouplanduse)\n    \n    !local variables\n    integer :: indxsoil,indxregion\n    \n    !initialize\n    rsoilm = 0.0\n    \n    associate (pflags        => rootzone%flags                      , &\n               pag           => rootzone%agrootzone%agdata          , &\n               purban        => rootzone%urbanrootzone%urbdata      , &\n               pperviousfrac => rootzone%urbanrootzone%perviousfrac , &\n               pnv           => rootzone%nvrvrootzone%nativeveg     , &\n               prv           => rootzone%nvrvrootzone%riparianveg   ) \n        \n      if (pflags%lag_defined) then\n          rsoilm(1:nsubregions,f_ilanduse_ag) = sum((pag%soilm_precip + pag%soilm_aw + pag%soilm_oth) * pag%area , dim=1)\n      else\n          rsoilm(:,f_ilanduse_ag) = 0.0\n      end if\n      \n      if (pflags%lurban_defined) then\n          do indxregion=1,nsubregions\n              do indxsoil=1,rootzone%nsoils\n                  rsoilm(indxregion,f_ilanduse_urban) = rsoilm(indxregion,f_ilanduse_urban)  & \n                                                      + (purban(indxsoil,indxregion)%soilm_precip + purban(indxsoil,indxregion)%soilm_aw + purban(indxsoil,indxregion)%soilm_oth) * purban(indxsoil,indxregion)%area * pperviousfrac(indxregion)\n              end do\n          end do\n      else\n          rsoilm(:,f_ilanduse_urban) = 0.0\n      end if\n      \n      if (pflags%lnvrv_defined) then\n          rsoilm(1:nsubregions,f_ilanduse_nvrv) = sum((pnv%soilm_precip + pnv%soilm_aw + pnv%soilm_oth) * pnv%area + (prv%soilm_precip + prv%soilm_aw + prv%soilm_oth) * prv%area , dim=1)\n      else\n          rsoilm(:,f_ilanduse_nvrv) = 0.0\n      end if\n\n    end associate \n    \n    !moisture storage for the entire domain\n    rsoilm(nsubregions+1,:) = sum(rsoilm(1:nsubregions,:) , dim=1)\n    \n  end function regionalmoiststorage\n"}
{"id": 286, "function": "  function rootzone_v50_regionalperc(rootzone,appgrid) result(rperc)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8)                             :: rperc(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: nregions\n\n    !initialize\n    nregions = appgrid%nsubregions\n    rperc    = 0.0\n    \n    associate (pflags => rootzone%flags)\n               \n      !ag lands\n      if (pflags%lag_defined) rperc(1:nregions) = sum(rootzone%agrootzone%agdata%perc * rootzone%agrootzone%agdata%area , dim=1)    \n\n      !urban\n      if (pflags%lurban_defined) rperc(1:nregions) = rperc(1:nregions) + sum(rootzone%urbanrootzone%urbdata%perc * rootzone%urbanrootzone%urbdata%area , dim=1)    \n      \n      !native and riparian veg\n      if (pflags%lnvrv_defined) rperc(1:nregions) = rperc(1:nregions) + sum(rootzone%nvrvrootzone%nativeveg%perc * rootzone%nvrvrootzone%nativeveg%area + rootzone%nvrvrootzone%riparianveg%perc * rootzone%nvrvrootzone%riparianveg%area  ,  dim=1)   \n    \n      !compute perc for the entire model area\n      rperc(nregions+1) = sum(rperc(1:nregions))\n      \n    end associate\n\n  end function rootzone_v50_regionalperc\n"}
{"id": 287, "function": "  function upstrmrunofftolanduse(rootzone,appgrid,ilandusetype) result(upstrmrunoff)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)       :: appgrid\n    integer,intent(in)                 :: ilandusetype\n    real(8)                            :: upstrmrunoff(appgrid%nsubregions)\n    \n    !local variables\n    integer :: indxregion\n    real(8) :: areafrac(3,appgrid%nsubregions)\n    \n    !compute area fractions to make sure that they are calculated properly in case ther are lakes\n    do indxregion=1,appgrid%nsubregions\n        areafrac(:,indxregion) = [rootzone%agrootzone%subregionalarea(indxregion) , rootzone%urbanrootzone%subregionalarea(indxregion) , rootzone%nvrvrootzone%subregionalarea_nv(indxregion)+rootzone%nvrvrootzone%subregionalarea_rv(indxregion)]\n        call normalizearray(areafrac(:,indxregion))\n    end do\n    \n    select case (ilandusetype)\n        !ag lands\n        case (f_ilanduse_ag)\n            if (rootzone%flags%lag_defined) then\n                upstrmrunoff = rootzone%watersupply%upstrmrunoff * areafrac(1,:)\n            else\n                upstrmrunoff = 0.0\n            end if\n            \n        !urban lands\n        case (f_ilanduse_urban)\n            if (rootzone%flags%lurban_defined) then\n                upstrmrunoff = rootzone%watersupply%upstrmrunoff * areafrac(2,:)\n            else\n                upstrmrunoff = 0.0\n            end if\n           \n        !native and riparian vegetation lands\n        case (f_ilanduse_nvrv)\n            if (rootzone%flags%lnvrv_defined) then\n                upstrmrunoff = rootzone%watersupply%upstrmrunoff * areafrac(3,:)\n            else\n                upstrmrunoff = 0.0\n            end if\n    end select\n    \n  end function upstrmrunofftolanduse\n"}
{"id": 288, "function": "  function inv3x3( a ) result( inva )\n\n    ! --- performs a direct calculation of the inverse of a 3\u00d73 matrix ---\n\n    real(dp), intent(in) :: a   (3,3)\n    real(dp)             :: inva(3,3)\n    real(dp)             :: invdet\n\n    ! --- calculate the inverse of the determinant of the matrix ---\n\n    invdet = one / ( a(1,1)*a(2,2)*a(3,3) - a(1,1)*a(2,3)*a(3,2)     &\n                       - a(1,2)*a(2,1)*a(3,3) + a(1,2)*a(2,3)*a(3,1) &\n                       + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1) )\n\n    ! --- calculate the inverse of the matrix ---\n\n    inva(1,1) = +invdet * ( a(2,2)*a(3,3) - a(2,3)*a(3,2) )\n    inva(2,1) = -invdet * ( a(2,1)*a(3,3) - a(2,3)*a(3,1) )\n    inva(3,1) = +invdet * ( a(2,1)*a(3,2) - a(2,2)*a(3,1) )\n    inva(1,2) = -invdet * ( a(1,2)*a(3,3) - a(1,3)*a(3,2) )\n    inva(2,2) = +invdet * ( a(1,1)*a(3,3) - a(1,3)*a(3,1) )\n    inva(3,2) = -invdet * ( a(1,1)*a(3,2) - a(1,2)*a(3,1) )\n    inva(1,3) = +invdet * ( a(1,2)*a(2,3) - a(1,3)*a(2,2) )\n    inva(2,3) = -invdet * ( a(1,1)*a(2,3) - a(1,3)*a(2,1) )\n    inva(3,3) = +invdet * ( a(1,1)*a(2,2) - a(1,2)*a(2,1) )\n\n    return\n  end function inv3x3\n"}
{"id": 289, "function": "  real(dp) function lorentzfactor( psi, v )\n\n    real(dp), intent(in) :: psi, v\n\n    lorentzfactor = one / sqrt( one - psi**4 * ( v / speedoflight )**2 )\n\n    return\n  end function lorentzfactor\n"}
{"id": 290, "function": "  real(dp) function density( vs, dr, vr, vl )\n\n    real(dp), intent(in) :: vs, dr, vr, vl\n\n    real(dp) :: wr, wl\n\n    wr = lorentzfactor( one, vr )\n    wl = lorentzfactor( one, vl )\n\n    density = dr * ( wr * ( vr - vs ) ) / ( wl * ( vl - vs ) )\n\n    return\n  end function density\n"}
{"id": 291, "function": "  real(dp) function pressure( vs, dr, vr, pr, dl, vl )\n\n    real(dp), intent(in) :: vs, dr, vr, pr, dl, vl\n\n    real(dp) :: wr, wl, tau\n\n    wr = lorentzfactor( one, vr )\n    wl = lorentzfactor( one, vl )\n\n    tau = gamma_ideal / ( gamma_ideal - one )\n\n    pressure = ( pr * ( one + tau * wr**2 * vr * ( vr - vs ) ) &\n                 - dl * wl**2 * vl**2 + dr * wr**2 * vr**2 &\n                 + vs * ( dl * wl**2 * vl - dr * wr**2 * vr ) ) &\n               / ( one + tau * wl**2 * vl * ( vl - vs ) )\n\n    return\n  end function pressure\n"}
{"id": 292, "function": " function abc()\n  character(len=5) :: abc\n  abc = 'abcde'\n end function abc\n"}
{"id": 293, "function": "      function contex(ii,x,y,ncon,icomp,n)\n! ----------------------------------------------------------\n\n!     with the output-subroutine for odex. it provides an\n!     approximation to the ii-th component of the solution at x.\n! ----------------------------------------------------------\n      implicit double precision (a-h,o-z)\n      implicit integer (i-n)\n      dimension y(ncon),icomp(n)\n      common /conodx/xold,h,imit\n! ----- compute place of ii-th component \n      i=0 \n      do 5 j=1,n \n      if (icomp(j).eq.ii) i=j\n   5  continue\n      if (i.eq.0) then\n         write (6,*) ' no dense output available for comp.',ii \n         return\n      end if  \n! ----- compute the interpolated value \n      theta=(x-xold)/h\n      theta1=1.d0-theta\n      phthet=y(i)+theta*(y(n+i)+theta1*(y(2*n+i)*theta+y(3*n+i)*theta1))\n      if (imit.lt.0) then\n          contex=phthet\n          return\n      end if\n      thetah=theta-0.5d0\n      contex=y(n*(imit+4)+i)\n      do 70 im=imit,1,-1\n  70  contex=y(n*(im+3)+i)+contex*thetah/im\n      contex=phthet+(theta*theta1)**2*contex\n      return\n      end function\n"}
{"id": 294, "function": "function get_clock( label )\n  !----------------------------------------------------------------------------\n  !\n  use kinds,     only : dp\n  use io_global, only : stdout\n  use mytime,    only : no, nclock, clock_label, walltime, &\n                        notrunning, called, t0wall, t0cpu\n!\n! ... see comments in subroutine print_this_clock about parallel case\n!\n!  use mp,        only : mp_max\n!  use mp_global, only : intra_image_comm\n  !\n  implicit none\n  !\n  real(dp)         :: get_clock\n  character(len=*) :: label\n  integer          :: n\n  !\n  real(dp), external :: cclock\n  !\n  !\n  if ( no ) then\n     !\n     if ( label == clock_label(1) ) then\n        !\n        get_clock = cclock()\n        !\n     else\n        !\n        get_clock = notrunning\n        !\n     endif\n     !\n     return\n     !\n  endif\n  !\n  do n = 1, nclock\n     !\n     if ( label == clock_label(n) ) then\n        !\n        if ( t0cpu(n) == notrunning ) then\n           !\n           get_clock = walltime(n)\n           !\n        else\n           !\n           get_clock = walltime(n) + cclock() - t0wall(n)\n           !\n        endif\n        !\n        ! ... see comments in subroutine print_this_clock about parallel case\n        !\n        ! call mp_max( get_clock, intra_image_comm )\n        !\n        return\n        !\n     endif\n     !\n  enddo\n  !\n  ! ... clock not found\n  !\n  get_clock = notrunning\n  !\n  return\n  !\nend function get_clock\n"}
{"id": 295, "function": "    function psb_z_linmap(map_kind,desc_x, desc_y, map_x2y, map_y2x,iaggr,naggr)\n      use psb_z_mat_mod, only : psb_zspmat_type\n      import :: psb_ipk_, psb_zlinmap_type, psb_desc_type, psb_lpk_\n      implicit none \n      type(psb_zlinmap_type)                  :: psb_z_linmap    \n      type(psb_desc_type), target             :: desc_x, desc_y\n      type(psb_zspmat_type), intent(inout)    :: map_x2y, map_y2x\n      integer(psb_ipk_), intent(in)           :: map_kind\n      integer(psb_lpk_), intent(in), optional :: iaggr(:), naggr(:)\n    end function psb_z_linmap\n"}
{"id": 296, "function": "  function z_map_sizeof(map) result(val)\n    implicit none \n    class(psb_zlinmap_type), intent(in) :: map\n    integer(psb_epk_) :: val\n\n    val = map%psb_base_linmap_type%sizeof()\n    val = val + map%map_x2y%sizeof()\n    val = val + map%map_y2x%sizeof()\n\n  end function z_map_sizeof\n"}
{"id": 297, "function": "  function z_is_asb(map) result(val)\n    implicit none \n    class(psb_zlinmap_type), intent(in) :: map\n    logical  :: val\n\n    val = map%psb_base_linmap_type%is_asb() .and. &\n         & map%map_x2y%is_asb() .and.map%map_y2x%is_asb() \n    \n  end function z_is_asb\n"}
{"id": 298, "function": "    function fpp_choice()\n\n        use unfound_mod, only : not_there\n\n        implicit none\n\n        character(3) :: fpp_choice\n\n        fpp_choice = \"two\"\n\n    end function fpp_choice\n"}
{"id": 299, "function": "    function test_isdir_1() result(assertion)\n        use constants_mod, only: rk\n        implicit none\n        logical         :: assertion\n        assertion = isdir(\"../\")\n    end function test_isdir_1\n"}
{"id": 300, "function": "    function test_query_1() result(assertion)\n\n        !use string_mod, only: num2str\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path\n\n        path = path_type(inputpath=\"\")\n        assertion = .not. path%err%occurred\n        if (.not. assertion) return\n\n        deallocate(path%original)\n        call path%query()\n        assertion = path%err%occurred\n\n    end function test_query_1\n"}
{"id": 301, "function": "    function test_query_3() result(assertion)\n\n        use system_mod, only: os_type\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path1, path2\n        type(os_type)   :: os\n\n        call os%query()\n        assertion = .not. os%err%occurred\n        if (.not. assertion) return\n\n        path1 = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\")\n        assertion = .not. path1%err%occurred\n        if (.not. assertion) return\n\n        path2 = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\", os = os)\n        assertion = .not. path2%err%occurred\n        if (.not. assertion) return\n\n        assertion = path1%modified == path2%modified\n\n    end function test_query_3\n"}
{"id": 302, "function": "    function test_constructpath() result(assertion)\n\n        !use string_mod, only: num2str\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path\n\n        path = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\")\n        assertion = .not. path%err%occurred\n        if (.not. assertion) return\n\n        assertion = path%original == \"./temp\\ folder/\\{inside\\}\\/\"\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%original  :\", path%original\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%modified  :\", path%modified\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%shellslash:\", path%shellslash\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%dir       :\", path%dir\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%name      :\", path%name\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%ext       :\", path%ext\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_constructpath\n"}
{"id": 303, "function": "    function test_winify_1() result(assertion)\n\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path\n\n        path = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\")\n        assertion = .not. path%err%occurred\n        if (.not. assertion) return\n\n        path%original = \"./temp\\ folder/\\{inside\\}/\"\n        path%modified = winify(path%original)\n\n        assertion = path%modified == '\".\\temp folder\\{inside}\\\"'\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\") path%original\n            write(test%outputunit,\"(*(g0,:,' '))\") path%modified\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_winify_1\n"}
{"id": 304, "function": "    function test_winify_2() result(assertion)\n\n        implicit none\n        logical                     :: assertion\n        character(:), allocatable   :: modified\n        character(:), allocatable   :: original\n        original = \"\\\\\\\"\n        modified = winify(original)\n        assertion = modified == \"\\\"\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\") original\n            write(test%outputunit,\"(*(g0,:,' '))\") modified\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_winify_2\n"}
{"id": 305, "function": "    function test_linify_1() result(assertion)\n\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path\n\n        path = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\")\n        assertion = .not. path%err%occurred\n        if (.not. assertion) return\n\n        path%original = '\".\\temp folder\\{inside}\\\"'\n        path%modified = linify(path%original)\n\n        assertion = path%modified == \"./temp\\ folder/\\{inside\\}/\"\n\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%original     :\", path%original\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%modified     :\", path%modified\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%shellslash   :\", path%shellslash\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%dir          :\", path%dir\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%name         :\", path%name\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%ext          :\", path%ext\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_linify_1\n"}
{"id": 306, "function": "    function test_getdirnameext_2() result(assertion)\n\n        implicit none\n        logical         :: assertion\n        type(path_type) :: path\n\n        assertion = .true.\n\n        path = path_type(inputpath=\"./temp\\ folder/\\{inside\\}\\/\")\n        assertion = .not. path%err%occurred\n        if (.not. assertion) return\n\n        path%original = \".\\temp folder\\{inside}\\temp.txt\"\n        call path%getdirnameext(path%original,\"\\\",path%dir,path%name,path%ext)\n\n        assertion = assertion .and. path%dir == \".\\temp folder\\{inside}\\\"\n        assertion = assertion .and. path%name == \"temp\"\n        assertion = assertion .and. path%ext == \".txt\"\n\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%dir :\", path%dir\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%name:\", path%name\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"path%ext :\", path%ext\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_getdirnameext_2\n"}
{"id": 307, "function": "    function test_getnameext_1() result(assertion)\n\n        implicit none\n        logical                     :: assertion\n        character(:), allocatable   :: name, ext, filename\n\n        assertion = .true.\n\n        filename = \".paramonte\"\n        call getnameext(filename, name, ext)\n\n        assertion = assertion .and. name == \"\"\n        assertion = assertion .and. ext == filename\n\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"filename  :\", filename\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"name      :\", name\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"ext       :\", ext\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_getnameext_1\n"}
{"id": 308, "function": "    function test_modify_1() result(assertion)\n\n        use system_mod, only: os_type\n        use err_mod, only: err_type\n        implicit none\n        logical                     :: assertion\n        character(:), allocatable   :: original, modified, modified_ref\n        type(err_type)              :: err\n        type(os_type)               :: os\n\n        original = \".\\paramonte\\dir1 \\\"\n        call modify(original,modified,err)\n        assertion = .not. os%err%occurred\n        if (.not. assertion) return ! lcov_excl_line\n\n        call os%query()\n        assertion = .not. os%err%occurred\n        if (.not. assertion) return ! lcov_excl_line\n\n        if (os%shell%isunix) then\n            modified_ref = \"./paramonte/dir1\\ /\"\n            assertion = assertion .and. modified == modified_ref\n#if defined os_is_windows\n        else\n            modified_ref = modified\n            assertion = assertion .and. modified == modified\n#endif\n        end if\n\n        if (test%isverbosemode .and. .not. assertion) then\n        ! lcov_excl_start\n            write(test%outputunit,\"(*(g0,:,' '))\")\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"modified_ref  :\", '\"'//modified_ref//'\"'\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"modified      :\", '\"'//modified//'\"'\n            write(test%outputunit,\"(*(g0,:,' '))\")   \"original      :\", '\"'//original//'\"'\n            write(test%outputunit,\"(*(g0,:,' '))\")\n        end if\n        ! lcov_excl_stop\n\n    end function test_modify_1\n"}
{"id": 309, "function": "    function test_mkdir_1() result(assertion)\n\n        use constants_mod, only: rk\n        use system_mod, only: randomfilename_type, os_type\n        implicit none\n        logical                     :: assertion\n        type(randomfilename_type)   :: rfn\n        type(os_type)               :: os\n\n        rfn = randomfilename_type(key=\"test_mkdir_1\")\n        assertion = .not. rfn%err%occurred\n        if (.not. assertion) return\n\n        call os%query()\n        assertion = .not. os%err%occurred\n        if (.not. assertion) return\n\n        rfn%err = mkdir(rfn%path, os%shell%isunix, .true.)\n        assertion = .not. rfn%err%occurred\n        if (.not. assertion) return\n\n    end function test_mkdir_1\n"}
{"id": 310, "function": "    function test_mkdir_3() result(assertion)\n\n        use system_mod, only: randomfilename_type\n        use constants_mod, only: rk\n        implicit none\n        logical                     :: assertion\n        type(randomfilename_type)   :: rfn\n\n        rfn = randomfilename_type(key=\"test_mkdir_3\")\n        assertion = .not. rfn%err%occurred\n        if (.not. assertion) return\n\n        rfn%err = mkdir(rfn%path)\n        assertion = .not. rfn%err%occurred\n        if (.not. assertion) return\n\n    end function test_mkdir_3\n"}
{"id": 311, "function": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}
{"id": 312, "function": "  function psb_z_diag_sizeof(prec) result(val)\n    class(psb_z_diag_prec_type), intent(in) :: prec\n    integer(psb_long_int_k_) :: val\n    \n    val = (2*psb_sizeof_dp) * prec%get_nzeros()\n    return\n  end function psb_z_diag_sizeof\n"}
{"id": 313, "function": "  function psb_z_diag_get_nzeros(prec) result(val)\n    class(psb_z_diag_prec_type), intent(in) :: prec\n    integer(psb_long_int_k_) :: val\n\n    val = 0\n    if (allocated(prec%dv)) val = val + prec%dv%get_nrows()\n    return\n  end function psb_z_diag_get_nzeros\n"}
{"id": 314, "function": "   pure integer function d(h)\n     use m\n     implicit none\n     integer, intent(in) :: h\n     d = h\n   end function\n"}
{"id": 315, "function": "   pure integer function d(h)\n     use m, only : a          ! { dg-error \"cannot be an equivalence object\" }\n     implicit none\n     integer, intent(in) :: h\n     d = h\n   end function\n"}
{"id": 316, "function": "        function tellisoninterface(zi)\n        real*8 :: zi\n        end function tellisoninterface\n"}
{"id": 317, "function": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}
{"id": 318, "function": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}
{"id": 319, "function": "pure function unitvec(orientation, position)\n  intrinsic atan2\n  real(dp), dimension(3), intent(in) :: orientation\n  real(dp), dimension(3), intent(in), optional :: position\n  real(dp), dimension(3) :: unitvec\n  real(dp) :: uro, utheta, uz\n  real(dp) :: nx, ny, nz, theta\n  theta = atan2(position(2), position(1))\n  nx = 0._dp\n  ny = 0._dp\n  nz = 1._dp\n  call rotate_vector(orientation(1), orientation(2), orientation(3), nx, ny, nz, &\n  theta, uro, utheta, uz)\n  unitvec = (/uro, utheta, uz/)\nend function\n"}
{"id": 320, "function": "pure function cross_product(a, b) result(c)\n  real(dp), intent(in) :: a(3), b(3)\n  real(dp) :: c(3)\n  c = 0._dp\n  c(1) = a(2) * b(3) - a(3) * b(2)\n  c(2) = -a(1) * b(3) + a(3) * b(1)\n  c(3) = a(1) * b(2) - a(2) * b(1)\nend function\n"}
{"id": 321, "function": "pure function crossproduct(a, b) result(c)\n  !\n  ! calculates (ax,ay,az) x (bx,by,bz) = (cz,cy,cz)\n  !\n  real(dp), dimension(3), intent(in) :: a, b\n  real(dp), dimension(3) :: c\n  c(1) = a(2) * b(3) - a(3) * b(2)\n  c(2) = a(3) * b(1) - a(1) * b(3)\n  c(3) = a(1) * b(2) - a(2) * b(1)\nend function\n"}
{"id": 322, "function": "pure function fmt_char_int() result(format_char)\n  character(len = 50) :: format_char\n  integer :: r\n  character(len = 50) :: w_char\n  r = range(r)\n  write(w_char, *) 1 + r !! sign + range\n  write(format_char, *) 'i' // trim(adjustl(w_char))\n  format_char = trim(adjustl(format_char))\nend function\n"}
{"id": 323, "function": "pure function fmt_char_dp() result(format_char)\n  integer :: e\n  integer :: w\n  integer :: d\n  real(dp) :: u \n  character(len = 50) :: w_char !! width of field\n  character(len = 50) :: d_char !! width of decimal field\n  character(len = 50) :: e_char !! width of exponent\n  character(len = 50) :: format_char\n  e = int(log10(real(range(u)))) + 1\n  d = precision(u)\n  w = 3 + d + 2 + e\n  write(w_char, *) w\n  write(e_char, *) e\n  write(d_char, *) d\n  write(format_char, *) 'g' // trim(adjustl(w_char)) // '.' // trim(adjustl(d_char)) // 'e' // trim(adjustl(e_char)) \n  format_char = trim(adjustl(format_char))\nend function\n"}
{"id": 324, "function": "pure function fmt_char_dp_array(array_size) result(format_char)\n  integer, intent(in) :: array_size\n  character(len = 50) :: format_char\n  write(format_char, *) '(', array_size - 1, '(' // trim(adjustl(fmt_char_dp())) // ',1x),' // trim(adjustl(fmt_char_dp())) // ')'\n  format_char = trim(adjustl(format_char))\nend function\n"}
{"id": 325, "function": "  logical function grid_exists(group, name)\n    implicit none\n    integer(hid_t),intent(in) :: group\n    character(len=*),intent(in) :: name\n    grid_exists = mp_path_exists(group, name)\n  end function grid_exists\n"}
{"id": 326, "function": "    integer function sub()\n    end function sub\n"}
{"id": 327, "function": "integer function x()\n   implicit none\n   x = -5\nend function x\n"}
{"id": 328, "function": "    function build(self,blueprint) result(scalar_advection_diffusion_ale_eqn)\n        class(scalar_advection_diffusion_ale),  intent(in)  :: self\n        character(*),                       intent(in)  :: blueprint\n\n        character(:),       allocatable     :: user_msg\n        type(equation_set_t)                :: scalar_advection_diffusion_ale_eqn\n        \n\n        !\n        ! set equationset name.\n        !\n        call scalar_advection_diffusion_ale_eqn%set_name(\"scalar advection diffusion ale\")\n\n\n        !\n        ! add spatial operators\n        !\n        select case (trim(blueprint))\n\n            case('default')\n                call scalar_advection_diffusion_ale_eqn%add_operator('scalar advection ale boundary average operator')\n                call scalar_advection_diffusion_ale_eqn%add_operator('scalar advection ale volume operator')\n                call scalar_advection_diffusion_ale_eqn%add_operator('scalar advection ale laxfriedrichs operator')\n                call scalar_advection_diffusion_ale_eqn%add_operator('scalar advection ale bc operator')\n                call scalar_advection_diffusion_ale_eqn%add_operator(\"scalar diffusion ale boundary average operator\")\n                call scalar_advection_diffusion_ale_eqn%add_operator(\"scalar diffusion ale volume operator\")\n                call scalar_advection_diffusion_ale_eqn%add_operator(\"scalar diffusion ale bc operator\")\n\n\n            case default\n                user_msg = \"build_scalar_advection_diffusion_ale: i didn't recogvize the &\n                            construction parameter that was passed to build the equation &\n                            set.\"\n                call chidg_signal_one(fatal, user_msg, blueprint)\n\n        end select\n\n\n    end function build\n"}
{"id": 329, "function": "    function build(self,blueprint) result(rans_efficient_eqns)\n        class(rans_efficient),    intent(in)  :: self\n        character(*),   intent(in)  :: blueprint\n\n        type(equation_set_t)            :: rans_efficient_eqns\n        type(fluid_pseudo_timestep_t)   :: fluid_pseudo_time\n\n\n        integer         :: unit, msg\n        logical         :: file_exists\n\n\n\n        ! set equation set name\n        call rans_efficient_eqns%set_name('rans efficient')\n        \n        ! add spatial operators\n        select case (trim(blueprint))\n\n            case('default')\n\n\n                ! check if input from 'models.nml' is available.\n                !   1: if available, read \n                !   2: if not available, do nothing and turbulence_model retains default value\n                inquire(file='models.nml', exist=file_exists)\n                if (file_exists) then\n                    open(newunit=unit,form='formatted',file='models.nml')\n                    read(unit,nml=fluid,iostat=msg)\n                    close(unit)\n                end if\n\n\n\n                ! add models dependent upon namelist input in models.nml\n                call rans_efficient_eqns%add_model(trim(state_equation))\n                call rans_efficient_eqns%add_model(trim(viscosity_model))\n\n\n                call rans_efficient_eqns%add_operator('rans boundary average advection')\n                call rans_efficient_eqns%add_operator('rans boundary average diffusion')\n                call rans_efficient_eqns%add_operator('rans bc advection')\n                call rans_efficient_eqns%add_operator('rans bc diffusion')\n                call rans_efficient_eqns%add_operator('rans volume advection')\n                call rans_efficient_eqns%add_operator('rans volume diffusion')\n                call rans_efficient_eqns%add_operator('rans upwind operator')\n                call rans_efficient_eqns%add_operator('rans volume source')\n\n                call rans_efficient_eqns%add_pseudo_timestep(fluid_pseudo_time)\n\n            case default\n                call chidg_signal_one(fatal, \"build_rans_efficient: i didn't recognize the &\n                                              construction parameter that was passed to build &\n                                              the equation set.\", blueprint)\n\n        end select\n\n\n    end function build\n"}
{"id": 330, "function": "\tfunction inverse( this ) result( inv )\n\t\tclass(matrix), intent(in) :: this\n\t\ttype(matrix) :: inv\n\t\t\n\t\tinteger, allocatable :: pivotind(:)\n\t\treal(8), allocatable :: workspace(:)\n! \t\treal(8), allocatable :: test(:,:)\n\t\tinteger :: i, ssize, info\n\t\treal(8) :: trace\n\t\t\n\t\tif( this.type /= square_matrix ) then\n\t\t\twrite(*,*) \"### error ### matrix.inverse: this operation only is defined for square matrices\"\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tssize = this.nrows\n\t\t\n\t\tif( ssize == 2 ) then\n\t\t\tinv = this.inverse2x2()\n\t\t\treturn\n\t\telse if( ssize == 3 ) then\n\t\t\tinv = this.inverse3x3()\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tinv = this\n\t\t\n\t\tallocate( pivotind( ssize ) )\n\t\t\n\t\t!! factorizacion lu\n\t\tcall dgetrf( ssize, ssize, inv.data, ssize, pivotind, info )\n\t\tif ( info /= 0 ) then\n\t\t\twrite(*,*) \"### error ### matrix.inverse: get matrix lu factorization failed\"\n\t\t\twrite(*,*) \"a = \"\n\t\t\tcall this.show( formatted=.true. )\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tallocate( workspace( ssize ) )\n\t\t\n\t\t!! invierte la matriz\n\t\tcall dgetri( ssize, inv.data, ssize, pivotind, workspace, ssize, info )\n\t\tif ( info /= 0 ) then\n\t\t\twrite(*,*) \"### error ### matrix.inverse: get inverse matrix failed\"\n\t\t\twrite(*,*) \"a = \"\n\t\t\tcall this.show( formatted=.true. )\n\t\t\tstop\n\t\tend if\n\t\t\n! \t\tallocate( test( ssize, ssize ) )\n! \t\ttest = matmul(matrix,inv)\n! \t\t\n! \t\ttrace = 0.0_8\n! \t\tdo i=1,ssize\n! \t\t\ttrace = trace + test(i,i)\n! \t\tend do\n! \t\t\n! \t\tif( abs( sum(test)-trace ) > 1e-10 ) stop \"get inverse matrix failed 2 a*a^-1\"\n\t\t\n\t\t!! libera memoria \n\t\tdeallocate(workspace)\n\t\tdeallocate(pivotind)\n! \t\tdeallocate(test)\n\tend function inverse\n"}
{"id": 331, "function": "\tfunction inverse2x2( this ) result( inv )\n\t\tclass(matrix) :: this\n\t\ttype(matrix) :: inv\n\t\t\n\t\ttype(matrix) :: i\n\t\treal(8) :: deta\n\t\t\n\t\tif( this.isdiagonal() ) then\n\t\t\tcall inv.init( 2, 2, val=0.0_8 )\n\t\t\t\n\t\t\tinv.data(1,1) = 1.0_8/this.data(1,1)\n\t\t\tinv.data(2,2) = 1.0_8/this.data(2,2)\n\t\t\t\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tdeta = this.determinant2x2()\n\t\t\n\t\tif( abs(deta) < 1d-16 ) then\n\t\t\twrite(*,*) \"### warning ### matrix.inverse2x2: singular matrix detected ( deta < 1e-16 )\"\n\t\t\twrite(*,*) \"                it will try to fix by tikhonov regularization ( lambda = 1d-3 )\"\n\t\t\tcall i.identity( 2, 2 )\n\t\t\tthis = this + i*1d-3  ! tikhonov regularization\n\t\tend if\n\t\t\n\t\tif( abs(deta) < 1d-16 ) then\n\t\t\twrite(*,*) \"### error ### matrix.inverse2x2: singular matrix detected ( deta < 1e-16 )\"\n\t\t\twrite(*,*) \"a = \"\n\t\t\tcall this.show( formatted=.true. )\n\t\t\twrite(*,*) \"\"\n\t\t\twrite(*,*) \"det(a) = \", deta\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tcall inv.init( 2, 2 )\n\t\t\n#define a(i,j) this.data(i,j)\n#define b(i,j) inv.data(i,j)\n\t\tb(1,1) =  a(2,2)\n\t\tb(1,2) = -a(1,2)\n\t\tb(2,1) = -a(2,1)\n\t\tb(2,2) =  a(1,1)\n#undef a\n#undef b\n\t\t\n\t\tinv = inv/deta\n\tend function inverse2x2\n"}
{"id": 332, "function": "\tfunction determinant( this ) result( det )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8) :: det\n\t\t\n\t\tinteger :: ssize\n\t\t\n\t\tssize = this.nrows\n\t\t\n\t\tif( ssize == 2 ) then\n\t\t\tdet= this.determinant2x2()\n\t\telse if( ssize == 3 ) then\n\t\t\tdet = this.determinant3x3()\n\t\telse\n\t\t\twrite(*,*) \"### error ### matrix.determinant() size>3 is not implemented yet\"\n\t\t\tstop\n\t\tend if\n\tend function determinant\n"}
{"id": 333, "function": "\tpure function determinant2x2( this ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8) :: output\n\t\t\n#define a(i,j) this.data(i,j)\n\t\toutput = a(1,1)*a(2,2)-a(1,2)*a(2,1)\n#undef a\n\tend function determinant2x2\n"}
{"id": 334, "function": "\tpure function determinant3x3( this ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8) :: output\n\t\t\n#define a(i,j) this.data(i,j)\n\t\toutput=a(1,1)*a(2,2)*a(3,3) &\n\t\t\t  +a(2,1)*a(3,2)*a(1,3) &\n\t\t\t  +a(3,1)*a(1,2)*a(2,3) &\n\t\t\t  -a(1,1)*a(3,2)*a(2,3) &\n\t\t\t  -a(3,1)*a(2,2)*a(1,3) &\n\t\t\t  -a(2,1)*a(1,2)*a(3,3)\n#undef a\n\tend function determinant3x3\n"}
{"id": 335, "function": "\tfunction trace( this ) result ( output )\n\t\tclass(matrix) , intent(in) :: this\n\t\treal(8) :: output\n\t\t\n\t\tinteger :: i\n\t\t\n\t\toutput = 0.0_8\n\t\tdo i=1,this.ncols\n\t\t\toutput = output + this.data( i, i )\n\t\tend do\n\tend function trace\n"}
{"id": 336, "function": "\treal(8) function norm2( this )\n\t\tclass(matrix) , intent(in) :: this\n\t\t\n\t\ttype(matrix) :: u\n\t\t\n\t\tu = this.transpose()*this\n\t\tnorm2 = sqrt( u.trace() )\n\tend function norm2\n"}
{"id": 337, "function": "\tfunction diagonal( this ) result( diag )\n\t\tclass(matrix), intent(in) :: this\n\t\ttype(matrix) :: diag\n\t\t\n\t\tinteger :: i\n\t\t\n\t\tselect case( this.type )\n\t\t\tcase( column_matrix )\n\t\t\t\tcall diag.init( this.nrows, this.nrows )\n\t\t\t\t\n\t\t\t\tdo i=1,this.nrows\n\t\t\t\t\tcall diag.set( i, i, this.get(i,1) )\n\t\t\t\tend do\n\t\t\t\t\n\t\t\tcase( row_matrix )\n\t\t\t\tcall diag.init( this.ncols, this.ncols )\n\t\t\t\t\n\t\t\t\tdo i=1,this.ncols\n\t\t\t\t\tcall diag.set( i, i, this.get(1,i) )\n\t\t\t\tend do\n\t\t\t\t\n\t\t\tcase( square_matrix )\n\t\t\t\tcall diag.init( this.ncols, this.ncols )\n\t\t\t\t\n\t\t\t\tdo i=1,this.ncols\n\t\t\t\t\tcall diag.set( i, i, this.get(i,i) )\n\t\t\t\tend do\n\t\t\t\t\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"### error ### matrix.diagonal: the procedure is not defined for this matrix type\"\n\t\tend select\n\tend function diagonal\n"}
{"id": 338, "function": "\tfunction trans( this ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.init( this.ncols, this.nrows )\n\t\toutput.data = transpose( this.data )\n\tend function trans\n"}
{"id": 339, "function": "\tfunction str( this, formatted, prefix, precision ) result( output )\n\t\tclass(matrix) :: this \n\t\tcharacter(:), allocatable :: output\n\t\tlogical, optional :: formatted\n\t\tcharacter(*), optional :: prefix\n\t\tinteger, optional :: precision\n\t\t\n\t\tinteger :: ncoleff = 10\n\t\t\n\t\tlogical :: effformatted\n\t\tcharacter(:), allocatable :: effprefix\n\t\tinteger :: effprecision\n\t\t\n\t\tinteger :: fmt\n\t\tcharacter(20000) :: fstr\n\t\tinteger :: i, j, k, upper\n\t\t\n\t\tinteger :: auxcolnum\n\t\tinteger :: lowerlimit\n\t\tinteger :: upperlimit\n\t\t\n\t\tinteger :: maxipart\n\t\t\n\t\teffformatted = .false.\n\t\tif( present(formatted) ) effformatted = formatted\n\t\t\n\t\teffprefix = \"\"\n\t\tif( present(prefix) ) effprefix = prefix\n\t\t\n\t\teffprecision = 6\n\t\tif( present(precision) ) effprecision = precision\n\t\t\n\t\toutput = \"\"\n\t\t\n\t\tif( .not. effformatted ) then\n#define rfmt(v) int(log10(max(abs(v),1.0)))+merge(1,2,v>=0)\n\n#define items(l,v) output = trim(output)//effprefix//trim(l)//trim(adjustl(v))\n#define itemi(l,v) output = trim(output)//l; fmt = rfmt(v); write(fstr, \"(i<fmt>)\") v; output = trim(output)//trim(fstr)\n#define itemr(l,v) output = trim(output)//l; fmt = rfmt(v); write(fstr, \"(f<fmt+7>.6)\") v; output = trim(output)//trim(fstr)\n\t\t\n\t\t\toutput = trim(output)//\"<matrix:\"\n! \t\t\titemi( \"min=\", this.min )\n! \t\t\titemr( \",size=\", this.size )\n#undef items\n#undef itemi\n#undef itemr\n\t\t\toutput = trim(output)//\">\"\n\t\telse\n#define line(l) output = trim(output)//effprefix//l//new_line('')\n#define items(l,v) output = trim(output)//effprefix//l; write(fstr, \"(x,a)\") trim(v); output = trim(output)//trim(fstr)//new_line('')\n#define itemi(l,v) output = trim(output)//effprefix//l; write(fstr, \"(i10)\") v; output = trim(output)//trim(fstr)//new_line('')\n#define itemr(l,v) output = trim(output)//effprefix//l; write(fstr, \"(f10.5)\") v; output = trim(output)//trim(fstr)//new_line('')\n\n! \t\t\tline(\"matrix\")\n! \t\t\tline(\"---------\")\n! \t\t\tline(\"\")\n! \t\t\tmaxipart = rfmt( maxval( this.data, mask=( this.data .lt. math_inf .and. .not. ieee_is_nan(this.data) ) ) )\n\t\t\tmaxipart = min( rfmt( maxval( this.data, mask=( ieee_is_finite(this.data) ) ) ), 15 )\n\t\t\t\n\t\t\tdo k=1, ceiling( (this.ncols*1.0)/(ncoleff*1.0) )\n\t\t\t\n\t\t\t\tlowerlimit = ncoleff*(k-1)+1\n\t\t\t\tupperlimit = ncoleff*k\n\t\t\t\tauxcolnum = ncoleff\n\t\t\t\t\n\t\t\t\tif ( upperlimit > this.ncols ) then\n\t\t\t\t\tauxcolnum =  ncoleff-upperlimit+this.ncols\n\t\t\t\t\tupperlimit = this.ncols\n\t\t\t\tend if\n\t\t\t\t\n\t\t\t\tif( k /= 1 ) then\n\t\t\t\t\tline(\"\")\n\t\t\t\tend if\n\t\t\t\t\n! \t\t\t\tif( present( columnkeys ) ) then\n! \t\t\t\t\tif( tmpflags == with_column_keys .or. tmpflags == with_both_keys ) then\n! \t\t\t\t\t\twrite (6,\"(21x,<auxcolnum>a15)\") ( columnkeys(i), i = lowerlimit, upperlimit )\n! \t\t\t\t\tend if\n! \t\t\t\telse\n! \t\t\t\t\tif( tmpflags /= without_keys ) then\n! \t\t\t\t\t\tif( tmpflags == with_column_keys .or. tmpflags == with_both_keys ) then\n! \t\t\t\t\t\t\twrite(fstr,\"(i5,<upper>f10.4)\") i, ( this.data(i,k), k=ncoleff*(j-1)+1,upper )\n\t\t\t\t\t\t\twrite (fstr,\"(5x,<auxcolnum>i<maxipart+5+effprecision>)\") ( i,i=lowerlimit,upperlimit )\n\t\t\t\t\t\t\toutput = trim(output)//trim(fstr)//new_line('')\n! \t\t\t\t\t\tend if\n! \t\t\t\t\tend if\n! \t\t\t\tend if\n\t\t\t\t\t\n! \t\t\t\tline(\"\")\n\t\t\t\t\n! \t\t\t\tif( present( rowkeys ) ) then\n! \t\t\t\t\n! \t\t\t\t\tif( tmpflags == with_row_keys .or. tmpflags == with_both_keys ) then\n! \t\t\t\t\t\twrite (6,\"(a18,<auxcolnum>f15.6)\") ( rowkeys(i), ( this.values(i,j), j=lowerlimit,upperlimit ), i = 1, this.nrows )\n! \t\t\t\t\telse\n! \t\t\t\t\t\twrite (6,\"(5x,<auxcolnum>f15.6)\") ( ( this.values(i,j), j=lowerlimit,upperlimit ), i = 1, this.nrows )\n! \t\t\t\t\tend if\n! \t\t\t\t\t\n! \t\t\t\telse\n! \t\t\t\t\tif( tmpflags /= without_keys ) then\n\t\t\t\t\t\n! \t\t\t\t\t\tif( ( tmpflags == with_row_keys .or. tmpflags == with_both_keys ) .and. tmpflags /= without_keys ) then\n\t\t\t\t\tdo i=1,this.nrows\n\t\t\t\t\t\twrite (fstr,\"(i5,<auxcolnum>f<maxipart+5+effprecision>.<effprecision>)\") i, ( this.data(i,j), j=lowerlimit,upperlimit )\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( i /= this.nrows ) then\n\t\t\t\t\t\t\toutput = trim(output)//trim(fstr)//new_line('')\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\toutput = trim(output)//trim(fstr)\n\t\t\t\t\t\tend if\n\t\t\t\t\tend do\n! \t\t\t\t\t\t\twrite (fstr,\"(i5,<auxcolnum>f15.6)\") ( i, ( this.data(i,j), j=lowerlimit,upperlimit ), i=1,this.nrows )\n! \t\t\t\t\t\t\toutput = trim(output)//trim(fstr)//new_line('')\n! \t\t\t\t\t\telse\n! \t\t\t\t\t\t\twrite (6,\"(5x,<auxcolnum>f15.6)\") ( ( this.values(i,j), j=lowerlimit,upperlimit ), i = 1, this.nrows )\n! \t\t\t\t\t\tend if\n\t\t\t\t\t\t\n! \t\t\t\t\telse\n! \t\t\t\t\t\n! \t\t\t\t\t\twrite (fstr,\"(5x,<auxcolnum>f15.6)\") ( ( this.data(i,j), j=lowerlimit,upperlimit ), i=1,this.nrows )\n! \t\t\t\t\t\toutput = trim(output)//trim(fstr)//new_line('')\n! \n! \t\t\t\t\tend if\n! \t\t\t\tend if\n\t\t\t\t\n\t\t\t\tif( k /= ceiling( (this.ncols*1.0)/(ncoleff*1.0) ) ) then\n\t\t\t\t\tline(\"\")\n\t\t\t\tend if\n\t\t\t\t\n\t\t\tend do\n#undef rfmt\n\n#undef line\n#undef items\n#undef itemi\n#undef itemr\n\t\tend if\n\tend function str\n"}
{"id": 340, "function": "\tfunction get( this, i, j ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tinteger, intent(in) :: i, j\n\t\treal(8) :: output\n\t\t\n\t\toutput = this.data(i,j)\n\tend function get\n"}
{"id": 341, "function": "\tfunction column( this, i ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tinteger, intent(in) :: i\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.init( this.nrows, 1 )\n\t\toutput.data(:,1) = this.data(:,i)\n\tend function column\n"}
{"id": 342, "function": "\tfunction row( this, i ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tinteger, intent(in) :: i\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.init( 1, this.ncols )\n\t\toutput.data(1,:) = this.data(i,:)\n\tend function row\n"}
{"id": 343, "function": "\tfunction iszero( this, tol ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), optional, intent(in) :: tol\n\t\tlogical :: output\n\t\t\n\t\treal(8) :: efftol\n\t\t\n\t\tinteger i, j\n\t\t\n\t\tefftol = 1d-16\n\t\tif( present(tol) ) efftol = tol\n\t\t\n\t\tif( sum( this.data )/size(this.data) > efftol ) then\n\t\t\toutput = .false.\n\t\telse\n\t\t\toutput = .true.\n\t\tend if\n\tend function iszero\n"}
{"id": 344, "function": "\tfunction isdiagonal( this, tol ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), optional, intent(in) :: tol\n\t\tlogical :: output\n\t\t\n\t\treal(8) :: efftol\n\t\t\n\t\tinteger i, j\n\t\t\n\t\tefftol = 1d-16\n\t\tif( present(tol) ) efftol = tol\n\t\t\n\t\tdo i=1,this.nrows\n\t\t\tdo j=i+1,this.ncols\n\t\t\t\tif( abs(this.data(i,j)) > efftol .or. abs(this.data(j,i)) > efftol ) then\n\t\t\t\t\toutput = .false.\n\t\t\t\t\treturn\n\t\t\t\tend if\n\t\t\tend do\n\t\tend do\n\t\t\n\t\toutput = .true.\n\tend function isdiagonal\n"}
{"id": 345, "function": "\tfunction raddition( this, other ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tclass(matrix), intent(in) :: other\n\t\ttype(matrix) :: output\n\t\t\n\t\tif( this.ncols /= other.ncols .or. this.nrows /= other.nrows ) then\n\t\t\twrite(*,*) \"## error ## matrix.raddition: the matrices have not the same size\"\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tcall output.copymatrix( this )\n\t\toutput.data = this.data + other.data\n\tend function raddition\n"}
{"id": 346, "function": "\tfunction radditionbyreal( this, constant ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), intent(in) :: constant\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.copymatrix( this )\n\t\toutput.data = this.data + constant\n\tend function radditionbyreal\n"}
{"id": 347, "function": "\tfunction rmultiplication( this, other ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tclass(matrix), intent(in) :: other\n\t\ttype(matrix) :: output\n\t\t\n\t\tif( this.ncols /= other.nrows ) then\n\t\t\twrite(*,*) \"## error ## matrix.rmultiplication: matrices with incompatible sizes\"\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tcall output.init( this.nrows, other.ncols )\n\t\toutput.data = matmul( this.data, other.data )\n\tend function rmultiplication\n"}
{"id": 348, "function": "\tfunction rexponentiation( this, other ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\tclass(matrix), intent(in) :: other\n\t\ttype(matrix) :: output\n\t\t\n\t\twrite(*,*) \"## error ## matrix.rexponentiation is not implemented\"\n\t\tstop\n\tend function rexponentiation\n"}
{"id": 349, "function": "\tfunction rexponentiationbyreal( this, constant ) result( output )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), intent(in) :: constant\n\t\ttype(matrix) :: output\n\t\t\n\t\twrite(*,*) \"## error ## matrix.rexponentiation is not implemented\"\n\t\tstop\n\tend function rexponentiationbyreal\n"}
{"id": 350, "function": "\tfunction projectionontonewaxes( this, axes ) result( vprime )\n\t\tclass(matrix), intent(in) :: this\n\t\ttype(matrix), intent(in) :: axes\n\t\ttype(matrix) :: vprime\n\t\t\n\t\ttype(matrix) :: u\n\t\tinteger :: i\n\t\t\n\t\tif( this.type == column_matrix ) then\n\t\t\tvprime = this\n\t\t\t\n\t\t\tdo i=1,axes.ncols\n\t\t\t\tu = axes.column(i)\n\t\t\t\tcall vprime.set( i, 1, matrix_get( this.transpose()*u, 1, 1 )/u.norm2() )\n\t\t\tend do\n\t\telse\n\t\t\twrite(*,*) \"### error ### the matrix.projectionontonewaxes method is only implemented for column matrices\"\n\t\tend if\n\tend function projectionontonewaxes\n"}
{"id": 351, "function": "\treal(8) function matrix_get( m, i, j )\n\t\ttype(matrix) , intent(in) :: m\n\t\tinteger :: i, j\n\t\t\n\t\tmatrix_get = m.data(i,j)\n\tend function matrix_get\n"}
{"id": 352, "function": "\treal(8) function matrix_trace( m )\n\t\ttype(matrix) , intent(in) :: m\n\t\t\n\t\tmatrix_trace = m.trace()\n\tend function matrix_trace\n"}
{"id": 353, "function": "\treal(8) function matrix_norm2( m )\n\t\ttype(matrix) , intent(in) :: m\n\t\t\n\t\tmatrix_norm2 = sqrt( matrix_trace( m.transpose()*m ) )\n\tend function matrix_norm2\n"}
{"id": 354, "function": "\tfunction matrix_columnvector( nelems, val, values ) result( output )\n\t\tinteger, intent(in) :: nelems\n\t\treal(8), optional, intent(in) :: val\n\t\treal(8), optional, intent(in) :: values(:)\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.columnvector( nelems, val, values )\n\tend function matrix_columnvector\n"}
{"id": 355, "function": "\tfunction matrix_lmultiplicationbyreal( constant, m ) result( output )\n\t\treal(8), intent(in) :: constant\n\t\ttype(matrix), intent(in) :: m\n\t\ttype(matrix) :: output\n\t\t\n\t\tcall output.copymatrix( m )\n\t\toutput.data = m.data*constant\n\tend function matrix_lmultiplicationbyreal\n"}
{"id": 356, "function": "    function constructor_empty() result(this)\n        type(tc_descriptor) :: this\n\n        call this%clear()\n    end function constructor_empty\n"}
{"id": 357, "function": "    function constructor(c_inds, a_inds, b_inds) result(this)\n        integer, dimension(:), intent(in) :: c_inds, a_inds, b_inds\n        type(tc_descriptor) :: this\n\n        if ( .not. this%is_valid(c_inds, a_inds, b_inds) ) then\n            error stop \"tc_descriptor::constructor:not valid.\"\n        end if\n\n        this = tc_descriptor()\n        call this%allocate_arrays( size(c_inds), size(a_inds), size(b_inds) )\n\n        this%c_indices(:) = c_inds(:)\n        this%a_indices(:) = a_inds(:)\n        this%b_indices(:) = b_inds(:)\n\n        this%num_unique_indices = maxval( [maxval(c_inds), maxval(a_inds), maxval(b_inds)] )\n        this%num_external_indices = size(c_inds)\n        this%num_internal_indices = this%num_unique_indices - this%num_external_indices\n    end function constructor\n"}
{"id": 358, "function": "    function get_inverse(this, indices) result(inverse)\n        class(tc_descriptor), intent(in) :: this\n        integer, dimension(:), intent(in) :: indices\n        integer, dimension(:), allocatable :: inverse\n\n        integer :: idx\n\n        allocate(inverse(this%num_unique_indices))\n        inverse = 0\n        do idx = 1, size(indices)\n            inverse(indices(idx)) = idx\n        end do\n    end function get_inverse\n"}
{"id": 359, "function": "    logical function all_indexes_are_used(c_inds, a_inds, b_inds)\n        integer, dimension(:), intent(in) :: c_inds, a_inds, b_inds\n\n        integer :: idx, num_indices\n        logical, dimension(:), allocatable :: index_used\n\n        num_indices = maxval( [maxval(c_inds), maxval(a_inds), maxval(b_inds)] )\n        allocate(index_used(num_indices))\n\n        index_used = .false.\n        do idx = 1, size(a_inds)\n            index_used(a_inds(idx)) = .true.\n        end do\n        do idx = 1, size(b_inds)\n            index_used(b_inds(idx)) = .true.\n        end do\n        do idx = 1, size(c_inds)\n            index_used(c_inds(idx)) = .true.\n        end do\n\n        all_indexes_are_used = all(index_used)\n        deallocate(index_used)\n    end function all_indexes_are_used\n"}
{"id": 360, "function": "    integer function get_number_of_times_used(inds, idx)\n        integer, dimension(:), intent(in) :: inds\n        integer, intent(in) :: idx\n\n        integer :: i\n\n        get_number_of_times_used = 0\n        do i = 1, size(inds)\n            if (inds(i) == idx ) get_number_of_times_used = get_number_of_times_used + 1\n        end do\n    end function get_number_of_times_used\n"}
{"id": 361, "function": "    logical function external_indexes_are_used_exactly_once( c_inds, a_inds, b_inds)\n        integer, dimension(:), intent(in) :: c_inds, a_inds, b_inds\n\n        integer :: i, ntimes\n\n        external_indexes_are_used_exactly_once = .false.\n        do i = 1, size(c_inds)\n            ntimes = get_number_of_times_used(a_inds, c_inds(i)) + get_number_of_times_used(b_inds, c_inds(i))\n            if ( ntimes /= 1 ) return\n        end do\n        external_indexes_are_used_exactly_once = .true.\n    end function external_indexes_are_used_exactly_once\n"}
{"id": 362, "function": "    logical function has_index(inds, idx)\n        integer, dimension(:), intent(in) :: inds\n        integer, intent(in) :: idx\n\n        integer :: i\n\n        has_index = .true.\n        do i = 1, size(inds)\n            if ( inds(i) == idx ) return\n        end do\n        has_index = .false.\n    end function has_index\n"}
{"id": 363, "function": "    logical function internal_indexes_are_used_exactly_twice(c_inds, a_inds, b_inds)\n        integer, dimension(:), intent(in) :: c_inds, a_inds, b_inds\n\n        integer :: i, times_used\n\n        internal_indexes_are_used_exactly_twice = .false.\n\n        do i = 1, size(a_inds)\n            if ( has_index(c_inds, a_inds(i)) ) cycle ! external\n            times_used = get_number_of_times_used(a_inds, a_inds(i)) + get_number_of_times_used(b_inds, a_inds(i))\n            if ( times_used /= 2 ) return\n        end do\n\n        do i = 1, size(b_inds)\n            if ( has_index(c_inds, b_inds(i)) ) cycle\n            times_used = get_number_of_times_used(a_inds, b_inds(i)) + get_number_of_times_used(b_inds, b_inds(i))\n            if ( times_used /= 2 ) return\n        end do\n        internal_indexes_are_used_exactly_twice = .true.\n    end function internal_indexes_are_used_exactly_twice\n"}
{"id": 364, "function": "    logical function is_valid(this, c_inds, a_inds, b_inds)\n        class(tc_descriptor), intent(in) :: this\n        integer, dimension(:) :: c_inds, a_inds, b_inds\n\n        is_valid = all_indexes_are_used(c_inds, a_inds, b_inds) .and. &\n            external_indexes_are_used_exactly_once(c_inds, a_inds, b_inds) .and. &\n            internal_indexes_are_used_exactly_twice(c_inds, a_inds, b_inds)\n    end function is_valid\n"}
{"id": 365, "function": "function matrix_partial_tracemult_dd(a, b, a_t, b_t)\n  type(matrixd), intent(in) :: a, b\n  logical, intent(in), optional :: a_t, b_t\n  real(dp) :: matrix_partial_tracemult_dd(a%n)\n\n  logical u_a_t, u_b_t\n  integer i, j, g_i, g_j\n\n  if (a%scalapack_info_obj%active .neqv. b%scalapack_info_obj%active) then\n    call system_abort(\"can't do partial tracemult for mixed dense regular and scalapack matrices\")\n  endif\n\n  u_a_t = optional_default(.false., a_t)\n  u_b_t = optional_default(.false., b_t)\n\n  if (a%scalapack_info_obj%active .or. b%scalapack_info_obj%active) then\n    if (u_a_t .and. .not. u_b_t) then\n      matrix_partial_tracemult_dd = 0.0_dp\n      do j=1, a%l_m\n        call coords_local_to_global(a%scalapack_info_obj, 1, j, g_i, g_j)\n        matrix_partial_tracemult_dd(g_j) = sum(a%data(:,j)*b%data(:,j))\n      end do\n    else if (.not. u_a_t .and. u_b_t) then\n      matrix_partial_tracemult_dd = 0.0_dp\n      do i=1, a%l_n\n        call coords_local_to_global(a%scalapack_info_obj, i, 1, g_i, g_j)\n        matrix_partial_tracemult_dd(g_i) = sum(a%data(i,:)*b%data(i,:))\n      end do\n    else\n      call system_abort(\"can only do partial_tracemult for scalapack matrices if one is transposed and the other not\")\n    endif\n  else\n    if (.not. u_a_t .and. .not. u_b_t) then\n      do i=1, a%n\n        matrix_partial_tracemult_dd(i) = sum(a%data(i,:)*b%data(:,i))\n      end do\n    else if (u_a_t .and. u_b_t) then\n      do i=1, a%n\n        matrix_partial_tracemult_dd(i) = sum(a%data(:,i)*b%data(i,:))\n      end do\n    else if (.not. u_a_t .and. u_b_t) then\n      matrix_partial_tracemult_dd(:) = 0.0_dp\n      do i=1, a%n\n        matrix_partial_tracemult_dd(:) = matrix_partial_tracemult_dd(:) + a%data(:,i)*b%data(:,i)\n      end do\n    else\n      do i=1, a%n\n        matrix_partial_tracemult_dd(i) = sum(a%data(:,i)*b%data(:,i))\n      end do\n    endif\n  endif\n\nend function matrix_partial_tracemult_dd\n"}
{"id": 366, "function": "function matrix_partial_tracemult_zz(a, b, a_h, b_h)\n  type(matrixz), intent(in) :: a\n  type(matrixz), intent(in) :: b\n  logical, intent(in), optional :: a_h, b_h\n  complex(dp) :: matrix_partial_tracemult_zz(a%n)\n\n  logical u_a_h, u_b_h\n  integer i, j, g_i, g_j\n\n  if (a%scalapack_info_obj%active .neqv. b%scalapack_info_obj%active) then\n    call system_abort(\"can't do partial tracemult for mixed dense regular and scalapack matrices\")\n  endif\n\n  u_a_h = optional_default(.false., a_h)\n  u_b_h = optional_default(.false., b_h)\n\n  if (a%scalapack_info_obj%active .or. b%scalapack_info_obj%active) then\n    if (u_a_h .and. .not. u_b_h) then\n      matrix_partial_tracemult_zz = 0.0_dp\n      do j=1, a%l_m\n        call coords_local_to_global(a%scalapack_info_obj, 1, j, g_i, g_j)\n        matrix_partial_tracemult_zz(g_j) = sum(conjg(a%data(:,j))*b%data(:,j))\n      end do\n    else if (.not. u_a_h .and. u_b_h) then\n      matrix_partial_tracemult_zz = 0.0_dp\n      do i=1, a%l_n\n        call coords_local_to_global(a%scalapack_info_obj, i, 1, g_i, g_j)\n        matrix_partial_tracemult_zz(g_i) = sum(a%data(i,:)*conjg(b%data(i,:)))\n      end do\n    else\n      call system_abort(\"can only do partial_tracemult for scalapack matrices if one is transposed and the other not\")\n    endif\n  else\n    if (.not. u_a_h .and. .not. u_b_h) then\n      do i=1, a%n\n        matrix_partial_tracemult_zz(i) = sum(a%data(i,:)*b%data(:,i))\n      end do\n    else if (u_a_h .and. u_b_h) then\n      do i=1, a%n\n        matrix_partial_tracemult_zz(i) = sum(conjg(a%data(:,i))*conjg(b%data(i,:)))\n      end do\n    else if (.not. u_a_h .and. u_b_h) then\n      matrix_partial_tracemult_zz(:) = 0.0_dp\n      do i=1, a%n\n        matrix_partial_tracemult_zz(:) = matrix_partial_tracemult_zz(:) + a%data(:,i)*conjg(b%data(:,i))\n      end do\n    else\n      do i=1, a%n\n        matrix_partial_tracemult_zz(i) = sum(conjg(a%data(:,i))*b%data(:,i))\n      end do\n    endif\n  endif\n\nend function matrix_partial_tracemult_zz\n"}
{"id": 367, "function": "function matrix_partial_tracemult_spinor_zz(a, b, a_h, b_h)\n  type(matrixz), intent(in) :: a\n  type(matrixz), intent(in) :: b\n  logical, intent(in), optional :: a_h, b_h\n  complex(dp) :: matrix_partial_tracemult_spinor_zz(2,2,a%n/2)\n\n  logical u_a_h, u_b_h\n  integer i, j, g_i, g_j\n\n  if (a%scalapack_info_obj%active .neqv. b%scalapack_info_obj%active) then\n    call system_abort(\"can't do partial tracemult for mixed dense regular and scalapack matrices\")\n  endif\n\n  u_a_h = optional_default(.false., a_h)\n  u_b_h = optional_default(.false., b_h)\n\n  if (a%scalapack_info_obj%active .or. b%scalapack_info_obj%active) then\n    if (u_a_h .and. .not. u_b_h) then\n      matrix_partial_tracemult_spinor_zz = 0.0_dp\n      do j=1, a%l_m\n        call coords_local_to_global(a%scalapack_info_obj, 1, j, g_i, g_j)\n        matrix_partial_tracemult_spinor_zz(1,1,(g_j-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,j))*b%data(1:a%l_n:2,j))\n        matrix_partial_tracemult_spinor_zz(1,2,(g_j-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,j))*b%data(2:a%l_n:2,j))\n        matrix_partial_tracemult_spinor_zz(2,1,(g_j-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,j+1))*b%data(1:a%l_n:2,j+1))\n        matrix_partial_tracemult_spinor_zz(2,2,(g_j-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,j+1))*b%data(2:a%l_n:2,j+1))\n      end do\n    else if (.not. u_a_h .and. u_b_h) then\n      matrix_partial_tracemult_spinor_zz = 0.0_dp\n      do i=1, a%l_n, 2\n        call coords_local_to_global(a%scalapack_info_obj, i, 1, g_i, g_j)\n        matrix_partial_tracemult_spinor_zz(1,1,(g_i-1)/2+1) = sum(a%data(i,1:a%l_m:2)*conjg(b%data(i,1:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(1,2,(g_i-1)/2+1) = sum(a%data(i,2:a%l_m:2)*conjg(b%data(i,2:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(2,1,(g_i-1)/2+1) = sum(a%data(i+1,1:a%l_m:2)*conjg(b%data(i+1,1:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(2,2,(g_i-1)/2+1) = sum(a%data(i+1,2:a%l_m:2)*conjg(b%data(i+1,2:b%l_m:2)))\n      end do\n    else\n      call system_abort(\"can only do partial_tracemult_spinor for scalapack matrices if one is transposed and the other not\")\n    endif\n  else\n    if (.not. u_a_h .and. .not. u_b_h) then\n      do i=1, a%n, 2\n        matrix_partial_tracemult_spinor_zz(1,1,(i-1)/2+1) = sum(a%data(i,1:a%l_m:2)*b%data(1:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(1,2,(i-1)/2+1) = sum(a%data(i,2:a%l_m:2)*b%data(2:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(2,1,(i-1)/2+1) = sum(a%data(i+1,1:a%l_m:2)*b%data(1:b%l_n:2,i+1))\n        matrix_partial_tracemult_spinor_zz(2,2,(i-1)/2+1) = sum(a%data(i+1,2:a%l_m:2)*b%data(2:b%l_n:2,i+1))\n      end do\n    else if (u_a_h .and. u_b_h) then\n      do i=1, a%n, 2\n        matrix_partial_tracemult_spinor_zz(1,1,(i-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,i))*conjg(b%data(i,1:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(1,2,(i-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,i))*conjg(b%data(i,2:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(2,1,(i-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,i+1))*conjg(b%data(i+1,1:b%l_m:2)))\n        matrix_partial_tracemult_spinor_zz(2,2,(i-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,i+1))*conjg(b%data(i+1,2:b%l_m:2)))\n      end do\n    else if (.not. u_a_h .and. u_b_h) then\n      matrix_partial_tracemult_spinor_zz(:,:,:) = 0.0_dp\n      do i=1, a%n, 2\n        matrix_partial_tracemult_spinor_zz(1,1,:) = matrix_partial_tracemult_spinor_zz(1,1,:) + a%data(1:a%l_n:2,i)*conjg(b%data(1:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(1,2,:) = matrix_partial_tracemult_spinor_zz(1,2,:) + a%data(1:a%l_n:2,i+1)*conjg(b%data(1:b%l_n:2,i+1))\n        matrix_partial_tracemult_spinor_zz(2,1,:) = matrix_partial_tracemult_spinor_zz(2,1,:) + a%data(2:a%l_n:2,i)*conjg(b%data(2:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(2,2,:) = matrix_partial_tracemult_spinor_zz(2,2,:) + a%data(2:a%l_n:2,i+1)*conjg(b%data(2:b%l_n:2,i+1))\n      end do\n    else\n      do i=1, a%n, 2\n        matrix_partial_tracemult_spinor_zz(1,1,(i-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,i))*b%data(1:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(1,2,(i-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,i))*b%data(2:b%l_n:2,i))\n        matrix_partial_tracemult_spinor_zz(2,1,(i-1)/2+1) = sum(conjg(a%data(1:a%l_n:2,i+1))*b%data(1:b%l_n:2,i+1))\n        matrix_partial_tracemult_spinor_zz(2,2,(i-1)/2+1) = sum(conjg(a%data(2:a%l_n:2,i+1))*b%data(2:b%l_n:2,i+1))\n      end do\n    endif\n  endif\n\nend function matrix_partial_tracemult_spinor_zz\n"}
{"id": 368, "function": "function matrix_tracemult_dd(a, b, w, a_t, b_t)\n  type(matrixd), intent(in) :: a, b\n  real(dp), intent(in), optional :: w(:)\n  logical, intent(in), optional :: a_t, b_t\n  real(dp) :: matrix_tracemult_dd\n\n  if (present(w)) then\n    matrix_tracemult_dd = sum(partial_tracemult(a, b, a_t, b_t)*w)\n  else\n    matrix_tracemult_dd = sum(partial_tracemult(a, b, a_t, b_t))\n  endif\n\nend function matrix_tracemult_dd\n"}
{"id": 369, "function": "function matrix_tracemult_dz(a, b, w, a_t, b_h)\n  type(matrixd), intent(in) :: a\n  type(matrixz), intent(in) :: b\n  real(dp), intent(in), optional :: w(:)\n  logical, intent(in), optional :: a_t, b_h\n  complex(dp) :: matrix_tracemult_dz\n\n  if (present(w)) then\n    matrix_tracemult_dz = sum(partial_tracemult(a, b, a_t, b_h)*w)\n  else\n    matrix_tracemult_dz = sum(partial_tracemult(a, b, a_t, b_h))\n  endif\n\nend function matrix_tracemult_dz\n"}
{"id": 370, "function": "function matrix_tracemult_zz(a, b, w, a_h, b_h)\n  type(matrixz), intent(in) :: a\n  type(matrixz), intent(in) :: b\n  real(dp), intent(in), optional :: w(:)\n  logical, intent(in), optional :: a_h, b_h\n  complex(dp) :: matrix_tracemult_zz\n\n  if (present(w)) then\n    matrix_tracemult_zz = sum(partial_tracemult(a, b, a_h, b_h)*w)\n  else\n    matrix_tracemult_zz = sum(partial_tracemult(a, b, a_h, b_h))\n  endif\n\nend function matrix_tracemult_zz\n"}
{"id": 371, "function": "function matrix_re_diagz(a)\n  type(matrixz), intent(in) :: a\n  real(dp) :: matrix_re_diagz(a%n)\n\n  integer i\n\n  if (a%scalapack_info_obj%active) then\n    matrix_re_diagz = re_diag(a%scalapack_info_obj, a%data)\n  else\n    do i=1, a%n\n      matrix_re_diagz(i) = real(a%data(i,i))\n    end do\n  endif\nend function matrix_re_diagz\n"}
{"id": 372, "function": "function matrix_re_diagd(a)\n  type(matrixd), intent(in) :: a\n  real(dp) :: matrix_re_diagd(a%n)\n\n  integer i\n\n  if (a%scalapack_info_obj%active) then\n    matrix_re_diagd = re_diag(a%scalapack_info_obj, a%data)\n  else\n    do i=1, a%n\n      matrix_re_diagd(i) = a%data(i,i)\n    end do\n  endif\nend function matrix_re_diagd\n"}
{"id": 373, "function": "function matrix_diag_spinorz(a)\n  type(matrixz), intent(in) :: a\n  complex(dp) :: matrix_diag_spinorz(2,2,a%n/2)\n\n  integer i\n\n  if (a%scalapack_info_obj%active) then\n    matrix_diag_spinorz = diag_spinor(a%scalapack_info_obj, a%data)\n  else\n    matrix_diag_spinorz = 0.0_dp\n    do i=1, a%n,2\n      matrix_diag_spinorz(:,:,(i-1)/2+1) = a%data(i:i+1,i:i+1)\n    end do\n  endif\nend function matrix_diag_spinorz\n"}
{"id": 374, "function": "function matrix_diag_spinord(a)\n  type(matrixd), intent(in) :: a\n  complex(dp) :: matrix_diag_spinord(2,2,a%n/2)\n\n  integer i\n\n  if (a%scalapack_info_obj%active) then\n    matrix_diag_spinord = diag_spinor(a%scalapack_info_obj, a%data)\n  else\n    matrix_diag_spinord = 0.0_dp\n    do i=1, a%n, 2\n      matrix_diag_spinord(:,:,(i-1)/2+1) = a%data(i:i+1,i:i+1)\n    end do\n  endif\nend function matrix_diag_spinord\n"}
{"id": 375, "function": "real function rptore(srt)\n  parameter (pimass=0.140, etam=0.5475, arho=0.77)\n  common /ppb1/ene, factr2(6), fsum, ppinnb, s, wtot\n  common /ppmm/pprr, ppee, pppe, rpre, xopoe, rree\n  save\n  s2 = srt**2\n  pf2 = (s2-(arho+etam)**2)*(s2-(arho-etam)**2)/2/sqrt(s2)\n  pi2 = (s2-(arho+pimass)**2)*(s2-(arho-pimass)**2)/2/sqrt(s2)\n  rptore = 1./3.*pf2/pi2*retorp(srt)\n  return\nend function rptore\n"}
{"id": 376, "function": "function get_model_size()\ninteger(i8) :: get_model_size\n\n! number of state variables is twice the model size if forcing is assumed\n! this was computed in the static_init_model() routine\nget_model_size = model_size\n\nend function get_model_size\n"}
{"id": 377, "function": "function shortest_time_between_assimilations()\n\ntype(time_type) :: shortest_time_between_assimilations\n\nshortest_time_between_assimilations = time_step\n\nend function shortest_time_between_assimilations\n"}
{"id": 378, "function": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}
{"id": 379, "function": "  function float2str(anumber) result(astring)\n    implicit none\n    real(prec) :: anumber\n    character(12) :: astring\n\n    write (astring,'(e12.4)') anumber\n\n  end function float2str\n"}
{"id": 380, "function": "  function almostequal_r64(a,b) result(aisb)\n\n    implicit none\n    real(real64) :: a,b\n    logical :: aisb\n\n    if (a == 0.0_real64 .or. b == 0.0_real64) then\n      if (abs(a - b) <= epsilon(1.0_real64)) then\n        aisb = .true.\n      else\n        aisb = .false.\n      end if\n    else\n      if ((abs(a - b) <= epsilon(1.0_real64)*abs(a)) .or. (abs(a - b) <= epsilon(1.0_real64)*abs(b))) then\n        aisb = .true.\n      else\n        aisb = .false.\n      end if\n    end if\n\n  end function almostequal_r64\n"}
{"id": 381, "function": "  function almostequal_r32(a,b) result(aisb)\n\n    implicit none\n    real(real32) :: a,b\n    logical :: aisb\n\n    if (a == 0.0_real32 .or. b == 0.0_real32) then\n      if (abs(a - b) <= epsilon(1.0_real32)) then\n        aisb = .true.\n      else\n        aisb = .false.\n      end if\n    else\n      if ((abs(a - b) <= epsilon(1.0_real32)*abs(a)) .or. (abs(a - b) <= epsilon(1.0_real32)*abs(b))) then\n        aisb = .true.\n      else\n        aisb = .false.\n      end if\n    end if\n\n  end function almostequal_r32\n"}
{"id": 382, "function": "  function comparearray(arrayone,arraytwo,n) result(arraysmatch)\n\n    implicit none\n    integer :: n\n    integer :: arrayone(1:n),arraytwo(1:n)\n    logical :: arraysmatch\n    ! local\n    integer :: i,thesumofdiffs\n\n    thesumofdiffs = 0\n\n    do i = 1,n\n      thesumofdiffs = thesumofdiffs + abs(arrayone(i) - arraytwo(i))\n    end do\n\n    if (thesumofdiffs == 0) then\n      arraysmatch = .true.\n    else\n      arraysmatch = .false.\n    end if\n\n  end function comparearray\n"}
{"id": 383, "function": "  integer function newunit(thisunit)\n\n    implicit none\n    integer,intent(out),optional :: thisunit\n    ! local\n    integer,parameter :: unitmin = 100,unitmax = 1000\n    logical :: isopened\n    integer :: iunit\n\n    newunit = -1\n\n    do iunit = unitmin,unitmax\n      ! check to see if this unit is opened\n      inquire (unit=iunit,opened=isopened)\n      if (.not. isopened) then\n        newunit = iunit\n        exit\n      end if\n    end do\n\n    if (present(thisunit)) thisunit = newunit\n\n  end function newunit\n"}
{"id": 384, "function": "  function uniformpoints(a,b,firstind,lastind) result(xu)\n\n    implicit none\n    real(prec) :: a,b\n    integer    :: firstind,lastind\n    real(prec) :: xu(firstind:lastind)\n    ! local\n    real(prec)    :: dx\n    integer :: i\n\n    dx = (b - a)/real((lastind - firstind),prec)\n\n    do i = firstind,lastind\n\n      xu(i) = a + dx*real(i - firstind,prec)\n\n    end do\n\n  end function uniformpoints\n"}
{"id": 385, "function": "  recursive function determinant(a,n) result(d)\n\n    implicit none\n    integer    :: n\n    real(prec) :: a(1:n,1:n)\n    real(prec) :: d\n    ! local\n    real(prec) :: m(1:n - 1,1:n - 1)\n    integer    :: j\n\n    if (n == 2) then\n      d = a(1,1)*a(2,2) - a(1,2)*a(2,1)\n      return\n    else\n      d = 0.0_prec\n      do j = 1,n\n        m = getminor(a,1,j,n)\n        d = d + (-1.0_prec)**(j + 1)*a(1,j)*determinant(m,n - 1)\n      end do\n    end if\n\n  end function determinant\n"}
{"id": 386, "function": "  function getminor(a,i,j,n) result(m)\n\n    implicit none\n    integer    :: i,j,n\n    real(prec) :: a(1:n,1:n)\n    real(prec) :: m(1:n - 1,1:n - 1)\n    ! local\n    integer :: row,col\n    integer :: thisrow,thiscol\n\n    thisrow = 0\n    do row = 1,n ! loop over the rows of a\n      if (row /= i) then\n        thisrow = thisrow + 1\n        thiscol = 0\n        do col = 1,n ! loop over the columns of a\n          if (col /= j) then\n            thiscol = thiscol + 1\n            m(thisrow,thiscol) = a(row,col)\n          end if\n        end do ! col, loop over the columns of a\n      end if\n    end do ! row, loop over the rows of a\n\n  end function getminor\n"}
{"id": 387, "function": "  function invert_2x2(a) result(ainv)\n\n    implicit none\n    real(prec) :: a(1:2,1:2)\n    real(prec) :: ainv(1:2,1:2)\n    ! local\n    real(prec) :: deta\n\n    deta = determinant(a,2)\n\n    ainv(1,1) = a(2,2)/deta\n    ainv(2,2) = a(1,1)/deta\n    ainv(1,2) = -a(1,2)/deta\n    ainv(2,1) = -a(2,1)/deta\n\n  end function invert_2x2\n"}
{"id": 388, "function": "  function invert_3x3(a) result(ainv)\n    !\n    ! =============================================================================================== !\n    implicit none\n    real(prec) :: a(1:3,1:3)\n    real(prec) :: ainv(1:3,1:3)\n    ! local\n    real(prec) :: deta\n    real(prec) :: submat(1:2,1:2)\n    real(prec) :: detsubmat\n\n    deta = determinant(a,3)\n\n    ! row 1 column 1 of inverse (use submatrix neglecting row 1 and column 1 of a)\n    submat = a(2:3,2:3)\n    detsubmat = determinant(submat,2)\n    ainv(1,1) = detsubmat/deta\n\n    ! row 1 column 2 of inverse (use submatrix neglecting row 2 and column 1 of a)\n    submat = a(1:3:2,2:3)\n    detsubmat = determinant(submat,2)\n    ainv(1,2) = -detsubmat/deta\n\n    ! row 1 column 3 of inverse (use submatrix neglecting row 3 and column 1 of a)\n    submat = a(1:2,2:3)\n    detsubmat = determinant(submat,2)\n    ainv(1,3) = detsubmat/deta\n\n    ! row 2 column 1 of inverse (use submatrix neglecting row 1 and column 2 of a)\n    submat = a(2:3,1:3:2)\n    detsubmat = determinant(submat,2)\n    ainv(2,1) = -detsubmat/deta\n\n    ! row 2 column 2 of inverse (use submatrix neglecting row 2 and column 2 of a)\n    submat = a(1:3:2,1:3:2)\n    detsubmat = determinant(submat,2)\n    ainv(2,2) = detsubmat/deta\n\n    ! row 2 column 3 of inverse (use submatrix neglecting row 3 and column 2 of a)\n    submat = a(1:2,1:3:2)\n    detsubmat = determinant(submat,2)\n    ainv(2,3) = -detsubmat/deta\n\n    ! row 3 column 1 of inverse (use submatrix neglecting row 1 and column 3 of a)\n    submat = a(2:3,1:2)\n    detsubmat = determinant(submat,2)\n    ainv(3,1) = detsubmat/deta\n\n    ! row 3 column 2 of inverse (use submatrix neglecting row 2 and column 3 of a)\n    submat = a(1:3:2,1:2)\n    detsubmat = determinant(submat,2)\n    ainv(3,2) = -detsubmat/deta\n\n    ! row 3 column 3 of inverse (use submatrix neglecting row 3 and column 3 of a)\n    submat = a(1:2,1:2)\n    detsubmat = determinant(submat,2)\n    ainv(3,3) = detsubmat/deta\n\n  end function invert_3x3\n"}
{"id": 389, "function": "  function invertspectralopmatrix(a,n) result(ainv)\n    ! inverts an (n+1)x(n+1) matrix using a polynomial representation of the\n    ! inverse\n    implicit none\n    integer :: n\n    real(prec) :: a(0:n,0:n)\n    real(prec) :: ainv(0:n,0:n)\n    ! local\n    integer    :: row,col,j,iter\n    real(prec) :: i(0:n,0:n)\n    real(prec) :: ainv_ij,maxchange\n\n    ainv = 0.0_prec\n    i = 0.0_prec\n    do row = 0,n\n      ainv(row,row) = 1.0_prec\n      i(row,row) = 1.0_prec\n    end do\n\n    do iter = 1,maxinverseiters\n\n      maxchange = 0.0_prec\n      do col = 0,n\n        do row = 0,n\n\n          ainv_ij = 0.0_prec\n          do j = 0,n\n            ainv_ij = ainv_ij + ainv(j,col)*(i(row,j) - a(row,j))\n          end do\n          maxchange = max(abs(ainv(row,col) - ainv_ij),maxchange)\n          ainv(row,col) = ainv_ij\n\n        end do\n      end do\n\n      if (maxchange <= tolerance) then\n        print *, ' invertspectralopmatrix : converged in ',iter,' iterations.'\n        exit\n      end if\n\n    end do\n\n    if (maxchange > tolerance) then\n      print *, 'invertspectralopmatrix : did not converge.',maxchange\n    end if\n\n  end function invertspectralopmatrix\n"}
{"id": 390, "function": "  function uppercase(str) result(upper)\n\n    implicit none\n    character(*),intent(in) :: str\n    character(len(str))      :: upper\n\n    integer :: ic,i\n\n    character(27),parameter :: cap = 'abcdefghijklmnopqrstuvwxyz '\n    character(27),parameter :: low = 'abcdefghijklmnopqrstuvwxyz '\n\n    do i = 1,len(str)\n      ic = index(low,str(i:i))\n      if (ic > 0) then\n        upper(i:i) = cap(ic:ic)\n      else\n        upper(i:i) = str(i:i)\n      end if\n    end do\n\n  end function uppercase\n"}
{"id": 391, "function": "  function getintforchar(charflag) result(intflag)\n  !! this method is used to return the integer flag from a char for constants\n  !! defined in self_constants.f90\n  !!\n    implicit none\n    character(*),intent(in) :: charflag\n    integer :: intflag\n\n    select case( uppercase(trim(charflag)) )\n\n      case (\"gauss\")\n        intflag = gauss\n\n      case (\"gauss-lobatto\")\n        intflag = gauss_lobatto\n\n      case (\"chebyshev-gauss\")\n        intflag = chebyshev_gauss\n\n      case (\"chebyshev-gauss-lobatto\")\n        intflag = chebyshev_gauss_lobatto\n\n      case (\"uniform\")\n        intflag = uniform\n\n    end select\n\n  end function getintforchar\n"}
{"id": 392, "function": "  function timestamp(time,units) result(timestampstring)\n    implicit none\n    real(prec)    :: time\n    character(1)  :: units\n    character(13) :: timestampstring\n    ! local\n    integer      :: day,minute,hour,second,millisecond\n    character(4) :: daystamp\n    character(2) :: hourstamp,minutestamp,secondstamp\n    character(3) :: millisecondstamp\n    real(real64) :: time_real64\n\n    time_real64 = real(time,real64)\n    ! units in \"seconds\"\n    if (units(1:1) == 's') then\n\n      ! obtain the day\n      day = int(time_real64/86400.0_real64)\n      hour = int((time_real64 &\n                  - 86400.0_real64*day)/3600.0_real64)\n      minute = int((time_real64 &\n                    - 3600.0_real64*hour &\n                    - 86400.0_real64*day)/60.0_real64)\n      second = int((time_real64 &\n                    - 60.0_real64*minute &\n                    - 3600.0_real64*hour &\n                    - 86400.0_real64*day))\n      millisecond = nint(((time_real64 &\n                           - 60.0_real64*minute &\n                           - 3600.0_real64*hour &\n                           - 86400.0_real64*day) &\n                          - real(second,real64))*1000.0_real64)\n\n      if( millisecond >= 1000 )then\n        millisecond = millisecond - 1000\n        second = second + 1\n      endif\n\n      if( second >= 60 )then\n        second = second - 60\n        minute = minute + 1\n      endif\n\n      if( minute >= 60 )then\n        minute = minute - 60\n        hour = hour + 1\n      endif\n\n      if( hour >= 24 )then\n        hour = hour - 24\n        day = day + 1\n      endif\n\n      write (daystamp,'(i4.4)') day\n      write (hourstamp,'(i2.2)') hour\n      write (minutestamp,'(i2.2)') minute\n      write (secondstamp,'(i2.2)') second\n      write (millisecondstamp,'(i3.3)') millisecond\n      timestampstring = daystamp//hourstamp//minutestamp//secondstamp//millisecondstamp\n\n      ! minutes\n    elseif (units(1:1) == 'm') then\n\n      ! hours\n    elseif (units(1:1) == 'h') then\n\n    end if\n\n  end function timestamp\n"}
{"id": 393, "function": "  logical function isinf(a)\n    implicit none\n    real(prec) :: a\n\n    if (a > huge(prec)) then\n      isinf = .true.\n    else\n      isinf = .false.\n    end if\n    return\n\n  end function isinf\n"}
{"id": 394, "function": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}
{"id": 395, "function": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}
{"id": 396, "function": "  function get_cols() result(cols)\n\n    character(len=1000) :: str_arg\n    integer :: cols, err\n\n    if (command_argument_count() /= 1) then\n      call get_command_argument(0,str_arg)\n      print *, 'usage : ',trim(str_arg),' <number_of_matrix_elements>'\n      stop\n    end if\n\n    call get_command_argument(1,str_arg)\n    read(str_arg, *, iostat=err) cols\n\n    if (err /= 0) then\n      print *, 'number of matrix elements specified must be an integer!'\n      stop\n    end if\n  end function get_cols\n"}
{"id": 397, "function": "  function psb_z_howmany(heap) result(res)\n    implicit none \n    class(psb_z_heap), intent(in) :: heap\n    integer(psb_ipk_) :: res\n    res  = heap%last\n  end function psb_z_howmany\n"}
{"id": 398, "function": "  function psb_z_idx_howmany(heap) result(res)\n    implicit none \n    class(psb_z_idx_heap), intent(in) :: heap\n    integer(psb_ipk_) :: res\n    res  = heap%last\n  end function psb_z_idx_howmany\n"}
