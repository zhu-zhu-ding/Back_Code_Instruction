{"id": 0, "subroutine": "subroutine clean\n  include 'globals.h'\n  integer :: p,j,ndel\n  real :: tm,cm(3),cmv(3)\n  logical del\n  ndel=0\n  do p=1,nbodies\n    del=.false.\n    do j=1,ndim\n      if(pos(p,j).gt.pboxsize/2.or.pos(p,j).lt.-pboxsize/2) then\n        del=.true.\n      endif\n    enddo\n    if(del)then \n      ndel=ndel+1\n      templist(ndel)=p\n    endif\n  enddo\n\n  if(periodic.and.ndel.gt.0) then\n    print*,ndel\n    call terror(' particles outside box?') \n  endif\n\n  if((nsph.gt.0.and.ndel.gt.nsph/2).or.ndel.gt.nbodies/2) then\n    print*,\"** warning: particle erasure (box size ok?) **\"\n    print*, ndel,nbodies,nsph\n  endif\n\n  tm=0;cm=0;cmv=0 \n  do j=1,ndel\n    p=templist(j)\n    tm=tm+mass(p)\n    cm(1:ndim)=cm(1:ndim)+mass(p)*pos(p,1:ndim)\n    cmv(1:ndim)=cmv(1:ndim)+mass(p)*vel(p,1:ndim)\n    mass(p)=0.\n  enddo\n\n  if(ndel.gt.0) then\n    if(verbosity.gt.0) print*,' mass erased:',tm\n    open(unit=erasenr,file=trim(outputfile)//'.del',status='unknown',position='append')\n    write(erasenr,*) tnow,tm,cm/tm,cmv/tm\n    close(erasenr)\n  endif \n\nend subroutine\n"}
{"id": 1, "subroutine": "subroutine copysph(p,i) ! copy sph part p to spot i\n  include 'globals.h'\n  integer i,p\n\n  if(i.gt.nsphmax.or.p.gt.nsphmax) then\n    print*, p,i\n    call terror(' sph part copy error')\n  endif\n  call copypart(p,i)\n  rho(i)=rho(p)\n  drhodh(i)=drhodh(p)\n  csound(i)=csound(p)\n  derad(i)=derad(p)\n  hsmdivv(i)=hsmdivv(p)\n  mumaxdvh(i)=mumaxdvh(p)\n  hsmcurlv(i)=hsmcurlv(p)\n  veltpos(i,1)=veltpos(p,1)\n  veltpos(i,2)=veltpos(p,2)\n  veltpos(i,3)=veltpos(p,3)\n  fuvheat(i)=fuvheat(p)\n  tcollaps(i)=tcollaps(p)\n  esnthdt(i)=esnthdt(p)\n  temperat(i)=temperat(p)\n  elecfrac(i)=elecfrac(p)\n  ethold(i)=ethold(p)\n  dethold(i)=dethold(p)\n  h2frac(i)=h2frac(p)\n  vdisp(i)=vdisp(p)\n  entropy(i)=entropy(p) ! equiv ethermal\n  dentdt(i)=dentdt(p)   ! equiv dethdt  \nend subroutine\n"}
{"id": 2, "subroutine": "subroutine copypart(p,i) ! copy part p to spot i\n  include 'globals.h'\n  integer i,p\n  if(i.gt.nbodsmax.or.p.gt.nbodsmax) then\n    print*, p,i\n    call terror(' sph part copy error')\n  endif\n  mass(i)=mass(p)\n  pos(i,1)=pos(p,1)\n  pos(i,2)=pos(p,2)\n  pos(i,3)=pos(p,3)\n  vel(i,1)=vel(p,1)\n  vel(i,2)=vel(p,2)\n  vel(i,3)=vel(p,3)\n  acc(i,1)=acc(p,1)\n  acc(i,2)=acc(p,2)\n  acc(i,3)=acc(p,3)\n  acc(i,4)=acc(p,4)\n  phi(i)=phi(p)\n  phiext(i)=phiext(p)\n  epsgrav(i)=epsgrav(p)\n  itimestp(i)=itimestp(p)\n  otimestp(i)=otimestp(p)\n  tform(i)=tform(p)\n  starfuv(i)=starfuv(p)\n  tfeedb(i)=tfeedb(p)\n  tvel(i)=tvel(p)\n  snentropy(i)=snentropy(p)\n  hsmooth(i)=hsmooth(p)\n  nbexist(i)=nbexist(p)\nend subroutine\n"}
{"id": 3, "subroutine": "subroutine partremoval\n  include 'globals.h'\n  integer i,lastsph,lastdm,laststar,lastbh \n  integer onsph,onstar,onbh\n  integer nnewremovals\n  \n  pordercount=pordercount+1\n  nnewremovals=0\n  do i=1,nsph\n    if(mass(i).lt.tiny) then\n      removedidssph(nremovals+1) = nbexist(i)\n      nremovals=nremovals+1\n      nnewremovals=nnewremovals+1\n    endif\n  enddo\n  \n  lastsph=nsph\n  lastdm=nbodies-nstar\n  laststar=nbodies-nbh\n  lastbh=nbodies\n  i=1\n  do while(i.le.lastsph) \n    if(mass(i).lt.tiny) then\n      if(mass(lastsph).ge.tiny) then\n        call copysph(lastsph,i)\n        mass(lastsph)=0\n      endif\n      lastsph=lastsph-1\n    else\n      i=i+1\n    endif \n  enddo\n\n  do while(i.le.lastdm) \n    if(mass(i).lt.tiny) then\n      if(mass(lastdm).ge.tiny) then\n        call copypart(lastdm,i)\n        mass(lastdm)=0\n      endif\n      lastdm=lastdm-1\n    else\n      i=i+1\n    endif \n  enddo\n\n  do while(i.le.laststar) \n    if(mass(i).lt.tiny) then\n      if(mass(laststar).ge.tiny) then\n        call copypart(laststar,i)\n        mass(laststar)=0\n      endif\n      laststar=laststar-1\n    else\n      i=i+1\n    endif \n  enddo\n\n  do while(i.le.lastbh) \n    if(mass(i).lt.tiny) then\n      if(mass(lastbh).ge.tiny) then\n        call copypart(lastbh,i)\n        mass(lastbh)=0\n      endif\n        lastbh=lastbh-1\n    else\n      i=i+1\n    endif \n  enddo\n  \n  if(nsph.ne.nnewremovals+lastsph) call terror('partremoval count mismatch')\n   \n  nsph=lastsph\n  nstar=lastbh-lastdm ! bh is also a star\n  nbh=lastbh-laststar\n  nbodies=lastbh \nend subroutine \n"}
{"id": 4, "subroutine": "subroutine zeropart(p,n)\n  include 'globals.h'\n  integer p,n\n\n  mass(p:p+n-1)=0\n  pos(p:p+n-1,1)=0\n  pos(p:p+n-1,2)=0\n  pos(p:p+n-1,3)=0\n  vel(p:p+n-1,1)=0\n  vel(p:p+n-1,2)=0\n  vel(p:p+n-1,3)=0\n  acc(p:p+n-1,1)=0\n  acc(p:p+n-1,2)=0\n  acc(p:p+n-1,3)=0\n  acc(p:p+n-1,4)=0\n  phi(p:p+n-1)=0\n  phiext(p:p+n-1)=0\n  epsgrav(p:p+n-1)=0\n  itimestp(p:p+n-1)=0\n  otimestp(p:p+n-1)=0\n  tform(p:p+n-1)=0\n  starfuv(p:p+n-1)=0\n  tfeedb(p:p+n-1)=0\n  tvel(p:p+n-1)=0\n  snentropy(p:p+n-1)=0\n  hsmooth(p:p+n-1)=0\n  nbexist(p:p+n-1)=0\nend subroutine\n"}
{"id": 5, "subroutine": "subroutine zerosph(p,n)\n  include 'globals.h'\n  integer p,n\n\n  call zeropart(p,n)\n\n  rho(p:p+n-1)=0\n  drhodh(p:p+n-1)=0\n  csound(p:p+n-1)=0\n  derad(p:p+n-1)=0\n  hsmdivv(p:p+n-1)=0\n  mumaxdvh(p:p+n-1)=0\n  hsmcurlv(p:p+n-1)=0\n  veltpos(p:p+n-1,1)=0\n  veltpos(p:p+n-1,2)=0\n  veltpos(p:p+n-1,3)=0\n  fuvheat(p:p+n-1)=0\n  tcollaps(p:p+n-1)=0\n  esnthdt(p:p+n-1)=0\n  temperat(p:p+n-1)=0\n  elecfrac(p:p+n-1)=0\n  ethold(p:p+n-1)=0\n  dethold(p:p+n-1)=0\n  h2frac(p:p+n-1)=0\n  vdisp(p:p+n-1)=0\n  entropy(p:p+n-1)=0\n  dentdt(p:p+n-1)=0\nend subroutine\n"}
{"id": 6, "subroutine": "\tsubroutine localdrawframe(ps,cx,cy,crad,iview,sp,cella,cellb,orel)\n\n\tuse local\n\tuse typedefs\n\tuse io\n\tuse postscript\n\n\n\ttype(postscript_type),intent(inout)\t:: ps\n\treal(kind=sgl),intent(in)               :: cx, cy, crad\n\tinteger(kind=irg),intent(inout)\t\t:: iview(3)\n\tcharacter(1),intent(in)\t\t       \t:: sp\n\ttype(unitcell),pointer       \t\t:: cella,cellb\n\ttype(orientation),intent(in)  \t\t:: orel\n\n\tend subroutine localdrawframe\n"}
{"id": 7, "subroutine": "subroutine localdrawframe(ps,cx,cy,crad,iview,sp,cella,cellb,orel)\n\nuse local\nuse typedefs\nuse io\nuse postscript\n\nimplicit none\n\ntype(postscript_type),intent(inout)\t:: ps\nreal(kind=sgl),intent(in)               :: cx, cy, crad\ninteger(kind=irg),intent(inout)\t\t:: iview(3)\ncharacter(1),intent(in)\t\t       \t:: sp\ntype(unitcell),pointer       \t\t:: cella,cellb\ntype(orientation),intent(in)  \t\t:: orel\n\ncharacter(17)      \t\t\t:: str\ncharacter(12)      \t\t\t:: instr\ninteger(kind=irg)            \t\t:: hkl(3)\n\n call ps_newpage(ps,.false.,'stereographic projection')\n call ps_setlinewidth(0.016)\n call ps_circle(cx,cy,crad)\n call ps_setlinewidth(0.004)\n call ps_line(cx-crad,cy,cx+crad,cy)\n call ps_line(cx,cy-crad,cx,cy+crad)\n call ps_setfont(psfonts(2),0.08)\n call ps_text(cx-crad-0.07,cy-0.025,'a')\n call ps_text(cx+crad+0.03,cy-0.025,'b')\n call ps_text(cx-0.03,cy-crad-0.09,'m''')\n call ps_text(cx-0.03,cy+crad+0.07,'m\"')\n call ps_setfont(psfonts(2),0.12/ps % psscale)\n call ps_text(0.35,8.30,'crystal a : '//cella % fname)\n call ps_filledcircle(0.0,8.30,0.015,0.0)\n call dumpindices(ps,cella%hexset,sp,0,0,0,1,0.0,8.30,.true.)\n call ps_setfont(psfonts(2),0.12)\n call ps_text(0.35,8.10,'crystal b : '//cellb % fname)\n call ps_filledsquare(0.0,8.10,0.035,0.0)\n call dumpindices(ps,cellb%hexset,sp,0,0,0,2,0.0,8.10,.true.)\n call ps_setfont(psfonts(2),0.12)\n call indexstring(cella%hexset,instr,iview,'d')\n call ps_text(0.0,7.90,'viewing direction '//instr//' [a]')\n\n if (sp.eq.'d') then \n  str='direct space'\n else\n  str='reciprocal space'\n endif\n call ps_text(0.0,7.70,'projection of '//str)\n\n call ps_text(cx,8.20,'orientation relation ')\n hkl(1:3)=int(orel % ga(1:3))\n\n call indexstring(cella%hexset,instr,hkl,'r')\n call ps_text(cx,8.00,'\\(hkl\\) : ')\n call ps_text(cx+0.4,8.00,'a-'//instr)\n hkl(1:3)=int(orel % gb(1:3))\n\n call indexstring(cellb%hexset,instr,hkl,'r')\n call ps_text(cx+0.9,8.00,'|| b-'//instr)\n\n! space=.true.\n hkl(1:3)=int(orel % ta(1:3))\n call indexstring(cella%hexset,instr,hkl,'d')\n call ps_text(cx,7.80,'[uvw] : ')\n call ps_text(cx+0.4,7.80,'a-'//instr)\n hkl(1:3)=int(orel % tb(1:3))\n call indexstring(cellb%hexset,instr,hkl,'d')\n call ps_text(cx+0.9,7.80,'|| b-'//instr)\n \nend subroutine localdrawframe\n"}
{"id": 8, "subroutine": "subroutine read_input\n\n  character(len=128) :: arg\n  character(len=4) ::opt\n  integer(kind=4)                         :: unitfile,i,ilun\n  character(len=256) :: inputfile,fileloc\n  integer::narg\n  character(len=200)          :: line,name,value\n    \n!---------------------------------------------------------------------------read input file\nnarg=iargc()\ndo i=1,narg\n   call getarg(i,opt)\n   call getarg(i+1,arg)\n   select case (opt)\n   case('-nzi')\n      read(arg,*) nout   !!output considered\n   case('-res')\n      read(arg,*) nres\n   case('-ncl')\n      read(arg,*) ncluster\n   case('-pix')\n      read(arg,*) sigpix            \n   end select\nend do\n!----------------------------------------------------------------------------\n\nif(sigpix.eq.0)sigpix=2\n\nntotal=0\ninputfile='input_params.dat'\nopen(unit=5,file=inputfile,status='old',form='formatted')  \nread(5,*) input_dir        \nread(5,*) output_dir\n\nclose(5)\n\n\nreturn\nend subroutine read_input\n"}
{"id": 9, "subroutine": "  subroutine title(n,nchar0)\n  \n    implicit none\n\n    integer(kind=4) :: n\n    character*3   ::  nchar0\n    character*1     :: nchar1\n    character*2     :: nchar2\n    character*3     :: nchar3\n\n\n\n    if(n.ge.100)then\n       write(nchar3,'(i3)') n\n       nchar0 = nchar3\n    elseif(n.ge.10)then\n       write(nchar2,'(i2)') n\n       nchar0 = '0'//nchar2\n    else\n       write(nchar1,'(i1)') n\n       nchar0 = '00'//nchar1\n    endif\n\n  end subroutine title\n"}
{"id": 10, "subroutine": "  subroutine title2(n,nchar0)\n  \n    implicit none\n\n    integer(kind=4) :: n\n    character*4     :: nchar0\n    character*1     :: nchar1\n    character*2     :: nchar2\n    character*3     :: nchar3\n    character*4     :: nchar4\n\n    \n\n   \n    if(n.ge.1000)then\n       write(nchar4,'(i4)') n\n       nchar0 = nchar4\n    elseif(n.ge.100)then\n       write(nchar3,'(i3)') n\n       nchar0 = '0'//nchar3\n    elseif(n.ge.10)then\n       write(nchar2,'(i2)') n\n       nchar0 = '00'//nchar2\n    else\n       write(nchar1,'(i1)') n\n       nchar0 = '000'//nchar1\n    endif\n\n  end subroutine title2\n"}
{"id": 11, "subroutine": "subroutine z_unifact_deflationcheck(n,q,d,zero)\n\n  implicit none\n  \n  ! input variables\n  integer, intent(in) :: n\n  integer, intent(inout) :: zero\n  real(8), intent(inout) :: q(3*(n-1)), d(2*n)\n\n  ! compute variables\n  integer :: ii, jj, down\n  real(8), parameter :: tol = eiscor_dbl_eps\n  real(8) :: dr, di, qr, qi, s, nrm\n\n  ! intialize zero\n  zero = 0\n  \n  ! check for deflation\n  do ii=1,(n-1)\n  \n    ! deflate if subdiagonal is small enough\n    nrm = abs(q(3*(n-ii)))\n    if(nrm < tol)then\n        \n      ! set zero\n      zero = max(0,n-ii)  ! why 0?\n\n      ! extract diagonal\n      qr = q(3*zero-2)\n      qi = q(3*zero-1)\n\n      ! set rotation to identity\n      q(3*zero-2) = 1d0\n      q(3*zero-1) = 0d0\n      q(3*zero) = 0d0\n        \n      ! update first diagonal\n      dr = d(2*zero-1)\n      di = d(2*zero)\n        \n      nrm = qr*dr - qi*di\n      di = qr*di + qi*dr\n      dr = nrm\n      call d_rot2_vec2gen(dr,di,d(2*zero-1),d(2*zero),nrm)\n        \n      ! deflate downward\n      do jj = 1,(n-1-zero)\n     \n        ! set downward index\n        down = zero+jj\n\n        ! update q\n        dr = q(3*down-2)\n        di = q(3*down-1)\n        s = q(3*down)\n              \n        nrm = qr*dr + qi*di\n        di = qr*di - qi*dr\n        dr = nrm\n\n        call z_rot3_vec3gen(dr,di,s,q(3*down-2),q(3*down-1),q(3*down),nrm) \n      \n      end do\n           \n      ! update second diagonal\n      dr = d(2*n-1)\n      di = d(2*n)\n           \n      nrm = qr*dr + qi*di\n      di = qr*di - qi*dr\n      dr = nrm\n      call d_rot2_vec2gen(dr,di,d(2*n-1),d(2*n),nrm)\n        \n      ! exit loop  \n      exit\n\n    end if\n\n  end do\n  \nend subroutine z_unifact_deflationcheck\n"}
{"id": 12, "subroutine": "    subroutine initialize(this, pf,level_index)\n      class(ad_sweeper_t), intent(inout) :: this\n      type(pf_pfasst_t),   intent(inout),target :: pf\n      integer, intent(in) :: level_index\n      \n      integer ::  nx,nnodes\n      class(pf_level_t), pointer :: lev\n        \n\n      lev => pf%levels(level_index)\n      this%nx=lev%lev_shape(1)\n      nx=this%nx\n      nnodes=lev%nnodes\n\n      ! call superclass initialize\n      call this%exp_initialize(pf,level_index)\n      \n      ! decide if phi will be recomputed\n      this%use_phib=.true.   !  false means they will not be recomputed \n\n      \n      ! allocate space for phi functions\n      allocate(this%phi(lev%nnodes+1, nx))\n      allocate(this%swp_phi(lev%nnodes - 1, lev%nnodes+1, nx))\n      allocate(this%res_phi(lev%nnodes - 1, lev%nnodes+1, nx))\n      allocate(this%yhat(nx))\n      allocate(this%bhat(nx))\n      \n      ! allocate fft & differentiation matrices\n      allocate(this%fft_tool)\n      call this%fft_tool%fft_setup([nx],1)\n      allocate(this%lap(nx))\n      allocate(this%ddx(nx))\n      call this%fft_tool%make_lap(this%lap)\n      call this%fft_tool%make_deriv(this%ddx)\n    end subroutine initialize\n"}
{"id": 13, "subroutine": "     subroutine destroy(this,pf,level_index)\n       class(ad_sweeper_t), intent(inout) :: this\n       type(pf_pfasst_t),   intent(inout),target :: pf\n       integer,             intent(in)    :: level_index\n\n       call this%exp_destroy(pf,level_index)\n       \n       ! deallocate arrays\n       deallocate(this%phi)\n       deallocate(this%swp_phi)\n       deallocate(this%res_phi)\n       deallocate(this%lap)\n       deallocate(this%ddx)\n       deallocate(this%yhat)\n       deallocate(this%bhat)\n       call this%fft_tool%fft_destroy()\n       deallocate(this%fft_tool)\n       \n    end subroutine destroy\n"}
{"id": 14, "subroutine": "      subroutine assign_pointer(this, a)\n         type (mytype), intent(out) :: this\n         real, target, intent(in) :: a\n         this%pr => a\n      end subroutine assign_pointer\n"}
{"id": 15, "subroutine": "  subroutine ml_fill_all_fluxes(ss, flux, uu, mm)\n\n    use bl_prof_module\n    use multifab_module\n    use stencil_util_module, only : is_ibc_stencil\n\n    type( multifab), intent(in   ) :: ss\n    type( multifab), intent(inout) :: flux(:)\n    type( multifab), intent(inout) :: uu\n    type(imultifab), intent(in   ) :: mm\n\n    integer :: dim, i, ngu, ngf, ndims\n\n    real(kind=dp_t), pointer :: fp(:,:,:,:)\n    real(kind=dp_t), pointer :: up(:,:,:,:)\n    real(kind=dp_t), pointer :: sp(:,:,:,:)\n    integer        , pointer :: mp(:,:,:,:)\n\n    type(bl_prof_timer), save :: bpt\n    call build(bpt, \"ml_fill_all_fluxes\")\n\n    ngu = nghost(uu)\n    ndims = get_dim(uu)\n\n    if ( ncomp(uu) /= ncomp(flux(1)) ) then\n       call bl_error(\"ml_fill_all_fluxes: uu%nc /= flux%nc\")\n    end if\n\n    call multifab_fill_boundary(uu)\n\n    do dim = 1, ndims\n       do i = 1, nfabs(flux(dim))\n          ngf = nghost(flux(dim))\n          fp => dataptr(flux(dim), i)\n          up => dataptr(uu, i)\n          sp => dataptr(ss, i)\n\n          if (is_ibc_stencil(ss,i)) then\n             select case (ndims)\n             case (2)\n                call stencil_all_flux_ibc_2d(sp(dim+1,1,1,1), fp(:,:,1,1), ngf, up(:,:,1,1), ngu, dim)\n             case (3)\n                call stencil_all_flux_ibc_3d(sp(dim+1,1,1,1), fp(:,:,:,1), ngf, up(:,:,:,1), ngu, dim)\n             end select\n          else\n             mp => dataptr(mm, i)\n             select case(ndims)\n             case (1)\n                call stencil_all_flux_1d(sp(:,:,1,1), fp(:,1,1,1), up(:,1,1,1), &\n                                         mp(:,1,1,1), ngu, ngf)\n             case (2)\n                call stencil_all_flux_2d(sp(:,:,:,1), fp(:,:,1,1), up(:,:,1,1), &\n                                         mp(:,:,1,1), ngu, ngf, dim)\n             case (3)\n                call stencil_all_flux_3d(sp(:,:,:,:), fp(:,:,:,1), up(:,:,:,1), &\n                                         mp(:,:,:,1), ngu, ngf, dim)\n             end select\n          end if\n       end do\n    end do\n\n    call destroy(bpt)\n\n  end subroutine ml_fill_all_fluxes\n"}
{"id": 16, "subroutine": "  subroutine stencil_apply_1d(ss, dd, ng_d, uu, ng_u, mm, lo, hi, skwd)\n\n    integer, intent(in) :: ng_d, ng_u, lo(:), hi(:)\n    real (kind = dp_t), intent(in)  :: ss(0:,lo(1) :)\n    real (kind = dp_t), intent(out) :: dd(lo(1)-ng_d:)\n    real (kind = dp_t), intent(in)  :: uu(lo(1)-ng_u:)\n    integer           , intent(in)  :: mm(lo(1):)\n    logical           , intent(in), optional   :: skwd\n\n    integer, parameter :: xbc = 3\n    logical :: lskwd\n    integer :: i\n   \n    lskwd = .true.; if ( present(skwd) ) lskwd = skwd\n\n    do i = lo(1),hi(1)\n       dd(i) = ss(0,i)*uu(i) + ss(1,i)*uu(i+1) + ss(2,i)*uu(i-1)\n    end do\n\n    if ( lskwd ) then\n       if (hi(1) > lo(1)) then\n          i = lo(1)\n          if (bc_skewed(mm(i),1,+1)) then\n             dd(i) = dd(i) + ss(xbc,i)*uu(i+2)\n          end if\n  \n          i = hi(1)\n          if (bc_skewed(mm(i),1,-1)) then\n             dd(i) = dd(i) + ss(xbc,i)*uu(i-2)\n          end if\n       end if\n    end if\n\n  end subroutine stencil_apply_1d\n"}
{"id": 17, "subroutine": "  subroutine stencil_flux_1d(ss, flux, uu, mm, ng, ratio, face, dim, skwd)\n\n    integer, intent(in) :: ng\n    real (kind = dp_t), intent(in)  :: ss(0:,:)\n    real (kind = dp_t), intent(out) :: flux(:)\n    real (kind = dp_t), intent(in)  :: uu(1-ng:)\n    integer           , intent(in)  :: mm(:)\n    logical, intent(in), optional :: skwd\n    integer, intent(in) :: ratio, face, dim\n    integer nx\n    integer i\n    integer, parameter :: xbc = 3\n\n    real (kind = dp_t) :: fac\n\n    logical :: lskwd\n\n    lskwd = .true. ; if ( present(skwd) ) lskwd = skwd\n\n    nx = size(ss,dim=2)\n\n    !   this factor is dx^fine / dx^crse\n    fac = one / real(ratio, kind=dp_t)\n\n    if ( dim == 1 ) then\n       if ( face == -1 ) then\n          i = 1\n          if (bc_dirichlet(mm(1),1,-1)) then\n             flux(1) = ss(1,i)*(uu(i+1)-uu(i)) + ss(2,i)*(uu(i-1)-uu(i)) &\n                  - ss(2,i+1)*(uu(i+1)-uu(i))\n             if (bc_skewed(mm(i),1,+1)) then\n                flux(1) =  flux(1) + ss(xbc,i)*uu(i+2)\n             end if\n          else \n             flux(1) = huge(flux)\n          end if\n          flux(1) = fac*flux(1)\n       else if ( face == 1 ) then\n          i = nx\n          if (bc_dirichlet(mm(i),1,+1)) then\n             flux(1) = ss(1,i)*(uu(i+1)-uu(i)) + ss(2,i)*(uu(i-1)-uu(i)) &\n                  - ss(1,i-1)*(uu(i-1)-uu(i))\n             if (bc_skewed(mm(i),1,-1)) then\n                flux(1) =  flux(1) + ss(xbc,i)*uu(i-2)\n             end if\n          else \n             flux(1) = huge(flux)\n          end if\n          flux(1) = fac*flux(1)\n       end if\n    end if\n\n  end subroutine stencil_flux_1d\n"}
{"id": 18, "subroutine": "  subroutine stencil_apply_2d(ss, dd, ng_d, uu, ng_u, mm, lo, hi, skwd)\n\n    integer           , intent(in   ) :: ng_d, ng_u, lo(:), hi(:)\n    real (kind = dp_t), intent(in   ) :: ss(0:,lo(1):,lo(2):)\n    real (kind = dp_t), intent(  out) :: dd(lo(1)-ng_d:,lo(2)-ng_d:)\n    real (kind = dp_t), intent(in   ) :: uu(lo(1)-ng_u:,lo(2)-ng_u:)\n    integer           , intent(in   ) :: mm(lo(1):,lo(2):)\n    logical           , intent(in   ), optional :: skwd\n\n    integer i,j\n\n    integer, parameter :: xbc = 5, ybc = 6\n\n    logical :: lskwd\n\n    lskwd = .true.; if ( present(skwd) ) lskwd = skwd\n\n    ! this is the minion 4th order cross stencil.\n    if (size(ss,dim=1) .eq. 9) then\n\n       do j = lo(2),hi(2)\n          do i = lo(1),hi(1)\n            dd(i,j) = &\n                   ss(0,i,j) * uu(i,j) &\n                 + ss(1,i,j) * uu(i-2,j) + ss(2,i,j) * uu(i-1,j) &\n                 + ss(3,i,j) * uu(i+1,j) + ss(4,i,j) * uu(i+2,j) &\n                 + ss(5,i,j) * uu(i,j-2) + ss(6,i,j) * uu(i,j-1) &\n                 + ss(7,i,j) * uu(i,j+1) + ss(8,i,j) * uu(i,j+2)\n          end do\n       end do\n\n    ! this is the minion 4th order full stencil.\n    else if (size(ss,dim=1) .eq. 25) then\n\n       do j = lo(2),hi(2)\n          do i = lo(1),hi(1)\n            dd(i,j) = ss( 0,i,j) * uu(i,j) &\n                    + ss( 1,i,j) * uu(i-2,j-2) + ss( 2,i,j) * uu(i-1,j-2) & ! at j-2\n                    + ss( 3,i,j) * uu(i  ,j-2) + ss( 4,i,j) * uu(i+1,j-2) & ! at j-2\n                    + ss( 5,i,j) * uu(i+2,j-2)                            & ! at j-2\n                    + ss( 6,i,j) * uu(i-2,j-1) + ss( 7,i,j) * uu(i-1,j-1) & ! at j-1\n                    + ss( 8,i,j) * uu(i  ,j-1) + ss( 9,i,j) * uu(i+1,j-1) & ! at j-1\n                    + ss(10,i,j) * uu(i+2,j-1)                            & ! at j-1\n                    + ss(11,i,j) * uu(i-2,j  ) + ss(12,i,j) * uu(i-1,j  ) & ! at j\n                    + ss(13,i,j) * uu(i+1,j  ) + ss(14,i,j) * uu(i+2,j  ) & ! at j\n                    + ss(15,i,j) * uu(i-2,j+1) + ss(16,i,j) * uu(i-1,j+1) & ! at j+1\n                    + ss(17,i,j) * uu(i  ,j+1) + ss(18,i,j) * uu(i+1,j+1) & ! at j+1\n                    + ss(19,i,j) * uu(i+2,j+1)                            & ! at j+1\n                    + ss(20,i,j) * uu(i-2,j+2) + ss(21,i,j) * uu(i-1,j+2) & ! at j+2\n                    + ss(22,i,j) * uu(i  ,j+2) + ss(23,i,j) * uu(i+1,j+2) & ! at j+2\n                    + ss(24,i,j) * uu(i+2,j+2)                              ! at j+2\n          end do\n       end do\n\n    ! this is our standard 5-point laplacian with a possible correction at boundaries\n    else \n\n       do j = lo(2),hi(2)\n          do i = lo(1),hi(1)\n             dd(i,j) = ss(0,i,j)*uu(i,j) &\n                  + ss(1,i,j)*uu(i+1,j  ) + ss(2,i,j)*uu(i-1,j  ) &\n                  + ss(3,i,j)*uu(i  ,j+1) + ss(4,i,j)*uu(i  ,j-1)\n          end do\n       end do\n\n       if ( lskwd ) then\n       ! corrections for skewed stencils\n       if (hi(1) > lo(1)) then\n          do j = lo(2),hi(2)\n\n             i = lo(1)\n             if (bc_skewed(mm(i,j),1,+1)) then\n                dd(i,j) = dd(i,j) + ss(xbc,i,j)*uu(i+2,j)\n             end if\n\n             i = hi(1)\n             if (bc_skewed(mm(i,j),1,-1)) then\n                dd(i,j) = dd(i,j) + ss(xbc,i,j)*uu(i-2,j)\n             end if\n          end do\n       end if\n\n       if (hi(2) > lo(2)) then\n          do i = lo(1),hi(1)\n\n             j = lo(2)\n             if (bc_skewed(mm(i,j),2,+1)) then\n                dd(i,j) = dd(i,j) + ss(ybc,i,j)*uu(i,j+2)\n             end if\n\n             j = hi(2)\n             if (bc_skewed(mm(i,j),2,-1)) then\n                dd(i,j) = dd(i,j) + ss(ybc,i,j)*uu(i,j-2)\n             end if\n\n          end do\n       end if\n       end if\n    end if\n\n  end subroutine stencil_apply_2d\n"}
{"id": 19, "subroutine": "  subroutine stencil_apply_ibc_2d(ss, dd, ng_d, uu, ng_u, lo, hi)\n\n    integer           , intent(in   ) :: ng_d, ng_u, lo(:), hi(:)\n    real (kind = dp_t), intent(in   ) :: ss(0:)\n    real (kind = dp_t), intent(  out) :: dd(lo(1)-ng_d:,lo(2)-ng_d:)\n    real (kind = dp_t), intent(in   ) :: uu(lo(1)-ng_u:,lo(2)-ng_u:)\n\n    integer i,j\n\n    ! this is our standard 5-point laplacian without correction at boundaries\n    do j = lo(2),hi(2)\n       do i = lo(1),hi(1)\n          dd(i,j) = ss(0)*uu(i,j) &\n               +    ss(1)*(uu(i-1,j) + uu(i+1,j)) &\n               +    ss(2)*(uu(i,j-1) + uu(i,j+1))\n       end do\n    end do\n\n  end subroutine stencil_apply_ibc_2d\n"}
{"id": 20, "subroutine": "  subroutine stencil_flux_2d(ss, flux, uu, mm, ng, ratio, face, dim, skwd)\n    integer, intent(in) :: ng\n    real (kind = dp_t), intent(in ) :: uu(1-ng:,1-ng:)\n    real (kind = dp_t), intent(out) :: flux(:,:)\n    real (kind = dp_t), intent(in ) :: ss(0:,:,:)\n    integer           , intent(in)  :: mm(:,:)\n    logical, intent(in), optional :: skwd\n    integer, intent(in) :: ratio, face, dim\n    integer nx,ny\n    integer i,j,ic,jc\n    real (kind = dp_t) :: fac\n    integer, parameter :: xbc = 5, ybc = 6\n    logical :: lskwd\n\n    lskwd = .true. ; if ( present(skwd) ) lskwd = skwd\n\n    nx = size(ss,dim=2)\n    ny = size(ss,dim=3)\n\n    !   note that one factor of ratio is the tangential averaging, while the\n    !     other is the normal factor\n    fac = one/real(ratio*ratio, kind=dp_t)\n\n!   lo i face\n    if ( dim == 1 ) then\n       if (face == -1) then\n\n          i = 1\n          flux(1,:) = zero\n          do j = 1,ny\n             jc = (j-1)/ratio+1\n             if (bc_dirichlet(mm(i,j),1,-1)) then\n                flux(1,jc) = flux(1,jc)  &\n                     + ss(1,i,j)*(uu(i+1,j)-uu(i,j)) &\n                     + ss(2,i,j)*(uu(i-1,j)-uu(i,j)) - ss(2,i+1,j)*(uu(i+1,j)-uu(i,j))\n                if (bc_skewed(mm(i,j),1,+1)) &\n                     flux(1,jc) = flux(1,jc) + ss(xbc,i,j)*(uu(i+2,j)-uu(i,j)) \n             else   \n                flux(1,jc) = huge(flux)\n             end if\n          end do\n          flux(1,:) = fac * flux(1,:)\n\n!      hi i face\n       else if (face == 1) then\n\n          i = nx\n          flux(1,:) = zero\n          do j = 1,ny\n             jc = (j-1)/ratio+1\n             if (bc_dirichlet(mm(i,j),1,+1)) then\n\n                flux(1,jc) = flux(1,jc) &\n                     + ss(1,i,j)*(uu(i+1,j)-uu(i,j)) &\n                     + ss(2,i,j)*(uu(i-1,j)-uu(i,j)) - ss(1,i-1,j)*(uu(i-1,j)-uu(i,j))\n                if (bc_skewed(mm(i,j),1,-1)) &\n                     flux(1,jc) = flux(1,jc) + ss(xbc,i,j)*(uu(i-2,j)-uu(i,j))\n             else \n                flux(1,jc) = huge(flux)\n             end if\n          end do\n          flux(1,:) = fac * flux(1,:)\n\n       end if\n\n!   lo j face\n    else if ( dim == 2 ) then\n       if (face == -1) then\n\n          j = 1\n          flux(:,1) = zero\n          do i = 1,nx\n             ic = (i-1)/ratio+1\n             if (bc_dirichlet(mm(i,j),2,-1)) then\n                flux(ic,1) = flux(ic,1)  &\n                     + ss(3,i,j)*(uu(i,j+1)-uu(i,j)) &\n                     + ss(4,i,j)*(uu(i,j-1)-uu(i,j)) - ss(4,i,j+1)*(uu(i,j+1)-uu(i,j))\n                if (bc_skewed(mm(i,j),2,+1)) &\n                     flux(ic,1) =  flux(ic,1) + ss(ybc,i,j)*(uu(i,j+2)-uu(i,j))\n             else \n                flux(ic,1) = huge(flux)\n             end if\n          end do\n          flux(:,1) = fac * flux(:,1)\n\n\n!      hi j face\n       else if (face == 1) then\n\n          j = ny\n          flux(:,1) = zero\n          do i = 1,nx\n             ic = (i-1)/ratio+1\n             if (bc_dirichlet(mm(i,j),2,+1)) then\n                flux(ic,1) = flux(ic,1)  &\n                     + ss(3,i,j)*(uu(i,j+1)-uu(i,j)) &\n                     + ss(4,i,j)*(uu(i,j-1)-uu(i,j)) - ss(3,i,j-1)*(uu(i,j-1)-uu(i,j))\n                if (bc_skewed(mm(i,j),2,-1)) &\n                     flux(ic,1) = flux(ic,1) + ss(ybc,i,j)*(uu(i,j-2)-uu(i,j))\n             else\n                flux(ic,1) = huge(flux)\n             end if\n          end do\n          flux(:,1) = fac * flux(:,1)\n\n       end if\n    end if\n\n  end subroutine stencil_flux_2d\n"}
{"id": 21, "subroutine": "  subroutine stencil_apply_3d(ss, dd, ng_d, uu, ng_u, mm, skwd, bottom_solver)\n\n    integer           , intent(in ) :: ng_d,ng_u\n    real (kind = dp_t), intent(in ) :: ss(0:,:,:,:)\n    real (kind = dp_t), intent(out) :: dd(1-ng_d:,1-ng_d:,1-ng_d:)\n    real (kind = dp_t), intent(in ) :: uu(1-ng_u:,1-ng_u:,1-ng_u:)\n    integer           , intent(in ) :: mm(:,:,:)\n    logical           , intent(in ), optional :: skwd, bottom_solver\n\n    integer            :: nx,ny,nz,i,j,k\n    integer, parameter :: xbc = 7, ybc = 8, zbc = 9\n    logical            :: lskwd, lbottom_solver\n\n    lskwd          = .true.;   if ( present(skwd)          ) lskwd          = skwd\n    lbottom_solver = .false. ; if ( present(bottom_solver) ) lbottom_solver = bottom_solver\n\n    nx = size(ss,dim=2)\n    ny = size(ss,dim=3)\n    nz = size(ss,dim=4)\n\n    !$omp parallel private(i,j,k) if(.not.lbottom_solver)\n\n    if ( size(ss,dim=1) .eq. 13 ) then\n       !\n       ! this is the minion 4th order cross stencil.\n       ! \n       !$omp do\n       do k = 1,nz\n          do j = 1,ny\n             do i = 1,nx\n                dd(i,j,k) = ss(0,i,j,k) * uu(i,j,k) &\n                     + ss( 1,i,j,k) * uu(i-2,j,k) + ss( 2,i,j,k) * uu(i-1,j,k) &\n                     + ss( 3,i,j,k) * uu(i+1,j,k) + ss( 4,i,j,k) * uu(i+2,j,k) &\n                     + ss( 5,i,j,k) * uu(i,j-2,k) + ss( 6,i,j,k) * uu(i,j-1,k) &\n                     + ss( 7,i,j,k) * uu(i,j+1,k) + ss( 8,i,j,k) * uu(i,j+2,k) &\n                     + ss( 9,i,j,k) * uu(i,j,k-2) + ss(10,i,j,k) * uu(i,j,k-1) &\n                     + ss(11,i,j,k) * uu(i,j,k+1) + ss(12,i,j,k) * uu(i,j,k+2)\n             end do\n          end do\n       end do\n       !$omp end do\n\n    else if ( size(ss,dim=1) .eq. 61 ) then\n       !\n       ! this is the 4th order cross stencil for variable coefficients.\n       !\n       !$omp do\n       do k = 1,nz\n          do j = 1,ny\n             do i = 1,nx\n                dd(i,j,k) = &\n                       ss( 0,i,j,k) * uu(i  ,j  ,k  ) &\n                       ! contributions from k-2\n                     + ss( 1,i,j,k) * uu(i  ,j-2,k-2) + ss( 2,i,j,k) * uu(i  ,j-1,k-2) &\n                     + ss( 3,i,j,k) * uu(i-2,j  ,k-2) + ss( 4,i,j,k) * uu(i-1,j  ,k-2) &\n                     + ss( 5,i,j,k) * uu(i  ,j  ,k-2) + ss( 6,i,j,k) * uu(i+1,j  ,k-2) &\n                     + ss( 7,i,j,k) * uu(i+2,j  ,k-2) + ss( 8,i,j,k) * uu(i  ,j+1,k-2) &\n                     + ss( 9,i,j,k) * uu(i  ,j+2,k-2)                                  &\n                       ! contributions from k-1\n                     + ss(10,i,j,k) * uu(i  ,j-2,k-1) + ss(11,i,j,k) * uu(i  ,j-1,k-1) &\n                     + ss(12,i,j,k) * uu(i-2,j  ,k-1) + ss(13,i,j,k) * uu(i-1,j  ,k-1) &\n                     + ss(14,i,j,k) * uu(i  ,j  ,k-1) + ss(15,i,j,k) * uu(i+1,j  ,k-1) &\n                     + ss(16,i,j,k) * uu(i+2,j  ,k-1) + ss(17,i,j,k) * uu(i  ,j+1,k-1) &\n                     + ss(18,i,j,k) * uu(i  ,j+2,k-1)                                  &\n                       ! contributions from j-2,k\n                     + ss(19,i,j,k) * uu(i-2,j-2,k  ) + ss(20,i,j,k) * uu(i-1,j-2,k  ) &\n                     + ss(21,i,j,k) * uu(i  ,j-2,k  ) + ss(22,i,j,k) * uu(i+1,j-2,k  ) &\n                     + ss(23,i,j,k) * uu(i+2,j-2,k  )                                  &\n                       ! contributions from j-1,k\n                     + ss(24,i,j,k) * uu(i-2,j-1,k  ) + ss(25,i,j,k) * uu(i-1,j-1,k  ) &\n                     + ss(26,i,j,k) * uu(i  ,j-1,k  ) + ss(27,i,j,k) * uu(i+1,j-1,k  ) &\n                     + ss(28,i,j,k) * uu(i+2,j-1,k  )                                  &\n                       ! contributions from j  ,k\n                     + ss(29,i,j,k) * uu(i-2,j  ,k  ) + ss(30,i,j,k) * uu(i-1,j  ,k  ) &\n                                                      + ss(31,i,j,k) * uu(i+1,j  ,k  ) &\n                     + ss(32,i,j,k) * uu(i+2,j  ,k  )                                  &\n                       ! contributions from j+1,k\n                     + ss(33,i,j,k) * uu(i-2,j+1,k  ) + ss(34,i,j,k) * uu(i-1,j+1,k  ) &\n                     + ss(35,i,j,k) * uu(i  ,j+1,k  ) + ss(36,i,j,k) * uu(i+1,j+1,k  ) &\n                     + ss(37,i,j,k) * uu(i+2,j+1,k  )                                  &\n                       ! contributions from j+2,k\n                     + ss(38,i,j,k) * uu(i-2,j+2,k  ) + ss(39,i,j,k) * uu(i-1,j+2,k  ) &\n                     + ss(40,i,j,k) * uu(i  ,j+2,k  ) + ss(41,i,j,k) * uu(i+1,j+2,k  ) &\n                     + ss(42,i,j,k) * uu(i+2,j+2,k  )                                  &\n                       ! contributions from k+1\n                     + ss(43,i,j,k) * uu(i  ,j-2,k+1) + ss(44,i,j,k) * uu(i  ,j-1,k+1) &\n                     + ss(45,i,j,k) * uu(i-2,j  ,k+1) + ss(46,i,j,k) * uu(i-1,j  ,k+1) &\n                     + ss(47,i,j,k) * uu(i  ,j  ,k+1) + ss(48,i,j,k) * uu(i+1,j  ,k+1) &\n                     + ss(49,i,j,k) * uu(i+2,j  ,k+1) + ss(50,i,j,k) * uu(i  ,j+1,k+1) &\n                     + ss(51,i,j,k) * uu(i  ,j+2,k+1)                                  &\n                       ! contributions from k+2\n                     + ss(52,i,j,k) * uu(i  ,j-2,k+2) + ss(53,i,j,k) * uu(i  ,j-1,k+2) &\n                     + ss(54,i,j,k) * uu(i-2,j  ,k+2) + ss(55,i,j,k) * uu(i-1,j  ,k+2) &\n                     + ss(56,i,j,k) * uu(i  ,j  ,k+2) + ss(57,i,j,k) * uu(i+1,j  ,k+2) &\n                     + ss(58,i,j,k) * uu(i+2,j  ,k+2) + ss(59,i,j,k) * uu(i  ,j+1,k+2) &\n                     + ss(60,i,j,k) * uu(i  ,j+2,k+2)\n             end do\n          end do\n       end do\n       !$omp end do\n\n    else\n       !\n       ! this is the 2nd order cross stencil.\n       !\n       !$omp do\n       do k = 1,nz\n          do j = 1,ny\n             do i = 1,nx\n                dd(i,j,k) = &\n                     ss(0,i,j,k)*uu(i,j,k)       + &\n                     ss(1,i,j,k)*uu(i+1,j  ,k  ) + &\n                     ss(2,i,j,k)*uu(i-1,j  ,k  ) + &\n                     ss(3,i,j,k)*uu(i  ,j+1,k  ) + &\n                     ss(4,i,j,k)*uu(i  ,j-1,k  ) + &\n                     ss(5,i,j,k)*uu(i  ,j  ,k+1) + &\n                     ss(6,i,j,k)*uu(i  ,j  ,k-1)\n             end do\n          end do\n       end do\n       !$omp end do\n\n    end if\n\n    if ( lskwd ) then\n       !\n       ! corrections for skewed stencils\n       !\n       if (nx > 1) then\n          !$omp do\n          do k = 1, nz\n             do j = 1, ny\n                i = 1\n                if (bc_skewed(mm(i,j,k),1,+1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(xbc,i,j,k)*uu(i+2,j,k)\n                end if\n\n                i = nx\n                if (bc_skewed(mm(i,j,k),1,-1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(xbc,i,j,k)*uu(i-2,j,k)\n                end if\n             end do\n          end do\n          !$omp end do\n       end if\n\n       if (ny > 1) then\n          !$omp do\n          do k = 1,nz\n             do i = 1,nx\n                j = 1\n                if (bc_skewed(mm(i,j,k),2,+1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(ybc,i,j,k)*uu(i,j+2,k)\n                end if\n\n                j = ny\n                if (bc_skewed(mm(i,j,k),2,-1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(ybc,i,j,k)*uu(i,j-2,k)\n                end if\n             end do\n          end do\n          !$omp end do\n       end if\n\n       if (nz > 1) then\n          !$omp do\n          do j = 1,ny\n             do i = 1,nx\n                k = 1\n                if (bc_skewed(mm(i,j,k),3,+1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(zbc,i,j,k)*uu(i,j,k+2)\n                end if\n\n                k = nz\n                if (bc_skewed(mm(i,j,k),3,-1)) then\n                   dd(i,j,k) = dd(i,j,k) + ss(zbc,i,j,k)*uu(i,j,k-2)\n                end if\n             end do\n          end do\n          !$omp end do\n       end if\n    end if\n\n    !$omp end parallel\n\n  end subroutine stencil_apply_3d\n"}
{"id": 22, "subroutine": "  subroutine stencil_apply_ibc_3d(ss, dd, ng_d, uu, ng_u, lo, hi)\n\n    integer           , intent(in ) :: ng_d,ng_u, lo(:), hi(:)\n    real (kind = dp_t), intent(in   ) :: ss(0:)\n    real (kind = dp_t), intent(  out) :: dd(lo(1)-ng_d:,lo(2)-ng_d:,lo(3)-ng_d:)\n    real (kind = dp_t), intent(in   ) :: uu(lo(1)-ng_u:,lo(2)-ng_u:,lo(3)-ng_u:)\n\n    integer i,j,k\n\n    ! this is our standard 7-point laplacian without correction at boundaries\n    !$omp parallel do private(i,j,k) collapse(2)\n    do k = lo(3),hi(3)\n       do j = lo(2),hi(2)\n          do i = lo(1),hi(1)\n             dd(i,j,k) = ss(0)*uu(i,j,k) &\n                  +      ss(1)*(uu(i-1,j,k) + uu(i+1,j,k)) &\n                  +      ss(2)*(uu(i,j-1,k) + uu(i,j+1,k)) &\n                  +      ss(3)*(uu(i,j,k-1) + uu(i,j,k+1))\n          end do\n       end do\n    end do\n    !$omp end parallel do\n\n  end subroutine stencil_apply_ibc_3d\n"}
{"id": 23, "subroutine": "  subroutine surf_mod_allocate(surf, flow)\n!------------------------------------------------------------------------------!\n!   surface genesis                                                            !\n!------------------------------------------------------------------------------!\n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  type(surf_type),  target :: surf\n  type(field_type), target :: flow\n!----------------------------------[locals]------------------------------------!\n  integer :: v, e, s\n!==============================================================================!\n\n  ! take aliases to object vertex flow around\n  surf % pnt_flow => flow\n  surf % pnt_grid => flow % pnt_grid\n\n  ! allocate logical array if cell holds vertices \n  ! (not sure if this will be needed)\n  allocate(surf % cell_has_vertex(surf % pnt_grid % n_cells))\n  surf % cell_has_vertex(:) = .false.\n\n  ! allocate memory for working arrays\n  allocate(i_work(surf % n_verts * n_i_vars))\n  allocate(l_work(surf % n_verts * n_l_vars))\n  allocate(r_work(surf % n_verts * n_r_vars))\n\n  !-----------------------------!\n  !   initialize all elements   !\n  !-----------------------------!\n  allocate(surf % elem(max_surface_elements))\n  do e = 1, max_surface_elements\n    surf % elem(e) % nne = 0\n    surf % elem(e) %   i = 0\n    surf % elem(e) %   j = 0\n    surf % elem(e) %   k = 0\n    surf % elem(e) %  ei = 0\n    surf % elem(e) %  ej = 0\n    surf % elem(e) %  ek = 0\n    surf % elem(e) %  si = 0\n    surf % elem(e) %  sj = 0\n    surf % elem(e) %  sk = 0\n  end do\n  surf % n_elems = 0\n\n  !-----------------------------!\n  !   initialize all vertices   !\n  !-----------------------------!\n  allocate(surf % vert(max_surface_vertices))\n  do v = 1, max_surface_vertices\n\n    surf % vert(v) % nne = 0\n\n    ! set initial velocity to zero\n    surf % vert(v) % u = 0.0\n    surf % vert(v) % v = 0.0\n    surf % vert(v) % w = 0.0\n\n    ! set initial coordinates to zero\n    surf % vert(v) % x_n = 0.0\n    surf % vert(v) % y_n = 0.0\n    surf % vert(v) % z_n = 0.0\n\n    surf % vert(v) % x_o = 0.0\n    surf % vert(v) % y_o = 0.0\n    surf % vert(v) % z_o = 0.0\n\n    ! set initial cell, node and boundary cell to zero\n    surf % vert(v) % cell     = 0\n    surf % vert(v) % node     = 0\n    surf % vert(v) % bnd_cell = 0\n    surf % vert(v) % bnd_face = 0\n\n    ! assume vertex is in the domain\n    ! (a smarter way could be worked out, depending ...\n    ! ... on the result of the call to find_nearest_cell)\n    surf % vert(v) % escaped   = .false.\n\n    ! is vertex in this processor?\n    surf % vert(v) % proc = 0\n    surf % vert(v) % buff = 0\n\n  end do\n  surf % n_verts = 0\n\n  !--------------------------!\n  !   initialize all sides   !\n  !--------------------------!\n  allocate(surf % side(max_surface_elements * 3))\n  do s = 1, max_surface_elements * 3\n    surf % side(s) % a        = 0\n    surf % side(s) % b        = 0\n    surf % side(s) % c        = 0\n    surf % side(s) % d        = 0\n    surf % side(s) % ei       = 0\n    surf % side(s) % ea       = 0\n    surf % side(s) % eb       = 0\n    surf % side(s) % length   = 0.0\n    surf % side(s) % boundary = .false.\n  end do\n  surf % n_sides = 0\n\n  end subroutine\n"}
{"id": 24, "subroutine": "   subroutine t_work_package_free(work_pack)\n      implicit none \n      class(t_work_package), intent(inout) :: work_pack \n      integer :: i\n\n      if(allocated(work_pack%k_packs)) then \n         do i = 1, size(work_pack%k_packs)\n            call work_pack%k_packs(i)%free() \n         enddo\n         deallocate(work_pack%k_packs)\n      endif\n   end subroutine t_work_package_free \n"}
{"id": 25, "subroutine": "   subroutine t_k_package_free(k_pack)\n      implicit none \n      class(t_k_package), intent(inout) :: k_pack \n      integer :: i\n\n      if(allocated(k_pack%q_packs)) then \n         do i = 1, size(k_pack%q_packs)\n            call k_pack%q_packs(i)%free()\n         enddo \n         deallocate(k_pack%q_packs)\n      endif\n   end subroutine t_k_package_free \n"}
{"id": 26, "subroutine": "   subroutine t_q_package_free(q_pack) \n      implicit none \n      class(t_q_package), intent(inout) :: q_pack \n\n      if(allocated(q_pack%band_packs)) deallocate(q_pack%band_packs)\n   end subroutine t_q_package_free\n"}
{"id": 27, "subroutine": "   subroutine t_work_package_init(work_pack, fi, hybdat, wp_mpi, jsp, rank, size) \n      implicit none \n      class(t_work_package), intent(inout) :: work_pack\n      type(t_fleurinput), intent(in)       :: fi\n      type(t_hybdat), intent(in)           :: hybdat \n      type(t_hybmpi), intent(in)           :: wp_mpi\n      integer, intent(in)                  :: rank, size, jsp\n\n      work_pack%rank    = rank\n      work_pack%size    = size\n      work_pack%submpi  = wp_mpi\n\n      call split_into_work_packages(work_pack, fi, hybdat, jsp)\n\n   end subroutine t_work_package_init\n"}
{"id": 28, "subroutine": "   subroutine t_k_package_init(k_pack, fi, hybdat, k_wide_mpi, jsp, nk)\n      implicit none \n      class(t_k_package), intent(inout) :: k_pack\n      type(t_fleurinput), intent(in)    :: fi\n      type(t_hybdat), intent(in)        :: hybdat\n      type(t_hybmpi), intent(in)        :: k_wide_mpi\n      integer, intent(in) :: nk, jsp\n      integer             :: iq, jq\n\n      k_pack%submpi = k_wide_mpi\n      k_pack%nk = nk\n      allocate(k_pack%q_packs(fi%kpts%eibz(nk)%nkpt)) \n      do iq = 1,fi%kpts%eibz(nk)%nkpt\n         jq = fi%kpts%eibz(nk)%pointer(iq)\n         call k_pack%q_packs(iq)%init(fi, hybdat, k_pack%submpi, jsp, nk, iq, jq)\n      enddo\n   end subroutine t_k_package_init\n"}
{"id": 29, "subroutine": "   subroutine t_q_package_init(q_pack, fi, hybdat, q_wide_mpi, jsp, nk, rank, ptr)\n      implicit none \n      class(t_q_package), intent(inout) :: q_pack \n      type(t_fleurinput), intent(in)    :: fi\n      type(t_hybdat), intent(in)        :: hybdat\n      type(t_hybmpi), intent(in)        :: q_wide_mpi\n      integer, intent(in)               :: rank, ptr, jsp, nk\n\n      real                 :: target_psize\n      integer              :: n_parts, ikqpt, i\n      integer, allocatable :: start_idx(:), psize(:)\n\n      q_pack%submpi = q_wide_mpi\n      q_pack%rank   = rank \n      q_pack%size   = fi%kpts%eibz(nk)%nkpt\n      q_pack%ptr    = ptr\n\n   ! arrays should be less than 5 gb\n      if(fi%sym%invs) then\n         target_psize = 5e9/( 8.0 * maxval(hybdat%nbasm) * min(fi%hybinp%bands1, fi%input%neig)) \n      else\n         target_psize = 5e9/(16.0 * maxval(hybdat%nbasm) * min(fi%hybinp%bands1, fi%input%neig)) \n      endif\n\n      ikqpt = fi%kpts%get_nk(fi%kpts%to_first_bz(fi%kpts%bkf(:,nk) + fi%kpts%bkf(:,ptr)))\n\n      n_parts = ceiling(hybdat%nobd(ikqpt, jsp)/target_psize)\n      if(mod(n_parts, q_pack%submpi%size) /= 0) then\n         n_parts = n_parts + q_pack%submpi%size - mod(n_parts,  q_pack%submpi%size)\n      endif\n      allocate(start_idx(n_parts), psize(n_parts))\n      allocate(q_pack%band_packs(n_parts))\n\n      call split_band_loop(hybdat%nobd(ikqpt, jsp), n_parts, start_idx, psize)\n\n      do i = 1, n_parts\n         call q_pack%band_packs(i)%init(start_idx(i), psize(i), i, n_parts)\n      enddo\n   end subroutine t_q_package_init\n"}
{"id": 30, "subroutine": "   subroutine t_band_package_init(band_pack, start_idx, psize, rank, size)\n      implicit none \n      class(t_band_package), intent(inout) :: band_pack \n      integer, intent(in)                  :: rank, size, start_idx, psize\n\n      band_pack%start_idx = start_idx\n      band_pack%psize     = psize \n      band_pack%rank      = rank\n      band_pack%size      = size\n   end subroutine t_band_package_init\n"}
{"id": 31, "subroutine": "   subroutine t_work_package_print(work_pack)\n      implicit none\n      class(t_work_package), intent(inout) :: work_pack\n      integer :: i \n\n      write (*,*) \"wp (\" // int2str(work_pack%rank) // \"/\" // int2str(work_pack%size) // \") has: \"\n      do i = 1,size(work_pack%k_packs)\n         call work_pack%k_packs(i)%print()\n      enddo\n   end subroutine t_work_package_print \n"}
{"id": 32, "subroutine": "   subroutine t_k_package_print(k_pack)\n      implicit none \n      class(t_k_package), intent(in) :: k_pack \n\n      write (*,*) \"kpoint: \"\n      write (*,*) \"nk = \", k_pack%nk\n   end subroutine t_k_package_print\n"}
{"id": 33, "subroutine": "   subroutine split_into_work_packages(work_pack, fi, hybdat, jsp)\n      implicit none \n      class(t_work_package), intent(inout) :: work_pack\n      type(t_fleurinput), intent(in)       :: fi\n      type(t_hybdat), intent(in)           :: hybdat\n      integer, intent(in)                  :: jsp\n      integer :: k_cnt, i \n      \n      if(work_pack%rank < modulo(fi%kpts%nkpt, work_pack%size)) then\n         work_pack%n_kpacks = ceiling(1.0*fi%kpts%nkpt / work_pack%size)\n      else \n         work_pack%n_kpacks = floor(1.0*fi%kpts%nkpt / work_pack%size)\n      endif\n\n      allocate(work_pack%k_packs(work_pack%n_kpacks))\n      \n      ! get my k-list\n      k_cnt = 1\n      do i = work_pack%rank+1, fi%kpts%nkpt, work_pack%size\n         work_pack%k_packs(k_cnt)%rank = k_cnt -1\n         work_pack%k_packs(k_cnt)%size = work_pack%n_kpacks\n\n         call work_pack%k_packs(k_cnt)%init(fi, hybdat, work_pack%submpi, jsp, i)\n         k_cnt = k_cnt + 1\n      enddo\n   end subroutine split_into_work_packages\n"}
{"id": 34, "subroutine": "   subroutine split_band_loop(n_total, n_parts, start_idx, psize)\n      use m_types\n      implicit none\n      integer, intent(in)                 :: n_total, n_parts\n      integer, allocatable, intent(inout) :: start_idx(:), psize(:)\n\n      integer             :: i, big_size, small_size, end_idx\n\n      if(allocated(start_idx)) deallocate(start_idx)\n      if(allocated(psize)) deallocate(psize)\n      allocate(start_idx(n_parts), psize(n_parts))\n\n      if(n_parts == 0) call judft_error(\"you need more than 0 parts\")\n\n      small_size = floor((1.0*n_total)/n_parts)\n      big_size = small_size +1\n\n      end_idx = 0\n      do i = 1,n_parts\n         psize(i) = merge(big_size, small_size,i <= mod(n_total, n_parts))\n\n         start_idx(i) = end_idx + 1\n         end_idx = start_idx(i) + psize(i) - 1\n      enddo\n   end subroutine split_band_loop\n"}
{"id": 35, "subroutine": "subroutine sckb(m,n,c,df,ck)\n\n!     ======================================================\n!     purpose: compute the expansion coefficients of the\n!     prolate and oblate spheroidal functions, c2k\n!     input :  m  --- mode parameter\n!     n  --- mode parameter\n!     c  --- spheroidal parameter\n!     df(k) --- expansion coefficients dk\n!     output:  ck(k) --- expansion coefficients ck;\n!     ck(1), ck(2), ... correspond to\n!     c0, c2, ...\n!     ======================================================\n\n\ninteger, intent(in)                      :: m\ninteger, intent(in)                      :: n\ndouble precision, intent(in out)         :: c\ndouble precision, intent(in)             :: df(200)\ndouble precision, intent(out)            :: ck(200)\nimplicit double precision (a-h,o-z)\n\n\nsw=0.0\nif (c <= 1.0d-10) c=1.0d-10\nnm=25+int(0.5*(n-m)+c)\nip=1\nif (n-m == 2*int((n-m)/2)) ip=0\nfac=-0.5d0**m\nreg=1.0d0\nif (m+nm > 80) reg=1.0d-200\ndo  k=0,nm-1\n  fac=-fac\n  i1=2*k+ip+1\n  r=reg\n  do  i=i1,i1+2*m-1\n    r=r*i\n  end do\n  i2=k+m+ip\n  do  i=i2,i2+k-1\n    r=r*(i+0.5d0)\n  end do\n  sum=r*df(k+1)\n  do  i=k+1,nm\n    d1=2.0d0*i+ip\n    d2=2.0d0*m+d1\n    d3=i+m+ip-0.5d0\n    r=r*d2*(d2-1.0d0)*i*(d3+k)/(d1*(d1-1.0d0)*(i-k)*d3)\n    sum=sum+r*df(i+1)\n    if (dabs(sw-sum) < dabs(sum)*1.0d-14) exit\n    sw=sum\n  end do\n  25    r1=reg\n  do  i=2,m+k\n    r1=r1*i\n  end do\n  ck(k+1)=fac*sum/r1\nend do\nreturn\nend subroutine sckb\n"}
{"id": 36, "subroutine": "subroutine sdmn(m,n,c,cv,kd,df)\n\n!     =====================================================\n!     purpose: compute the expansion coefficients of the\n!     prolate and oblate spheroidal functions\n!     input :  m  --- mode parameter\n!     n  --- mode parameter\n!     c  --- spheroidal parameter\n!     cv --- characteristic value\n!     kd --- function code\n!     kd=1 for prolate; kd=-1 for oblate\n!     output:  df(k) --- expansion coefficients dk;\n!     df(1), df(2), ... correspond to\n!     d0, d2, ... for even n-m and d1,\n!     d3, ... for odd n-m\n!     =====================================================\n\n\ninteger, intent(in)                      :: m\ninteger, intent(in)                      :: n\ndouble precision, intent(in)             :: c\ndouble precision, intent(in out)         :: cv\ninteger, intent(in)                      :: kd\ndouble precision, intent(out)            :: df(200)\nimplicit double precision (a-h,o-z)\ndimension a(200),d(200),g(200)\n\nsw=0.0\nfl=0.0\nnm=25+int(0.5*(n-m)+c)\nif (c < 1.0d-10) then\n  do  i=1,nm\n    df(i)=0d0\n  end do\n  df((n-m)/2+1)=1.0d0\n  return\nend if\ncs=c*c*kd\nip=1\nif (n-m == 2*int((n-m)/2)) ip=0\ndo  i=1,nm+2\n  if (ip == 0) k=2*(i-1)\n  if (ip == 1) k=2*i-1\n  dk0=m+k\n  dk1=m+k+1\n  dk2=2*(m+k)\n  d2k=2*m+k\n  a(i)=(d2k+2.0)*(d2k+1.0)/((dk2+3.0)*(dk2+5.0))*cs\n  d(i)=dk0*dk1+(2.0*dk0*dk1-2.0*m*m-1.0)/((dk2-1.0) *(dk2+3.0))*cs\n  g(i)=k*(k-1.0)/((dk2-3.0)*(dk2-1.0))*cs\nend do\nfs=1.0d0\nf1=0.0d0\nf0=1.0d-100\nkb=0\ndf(nm+1)=0.0d0\ndo  k=nm,1,-1\n  f=-((d(k+1)-cv)*f0+a(k+1)*f1)/g(k+1)\n  if (dabs(f) > dabs(df(k+1))) then\n    df(k)=f\n    f1=f0\n    f0=f\n    if (dabs(f) > 1.0d+100) then\n      do  k1=k,nm\n        df(k1)=df(k1)*1.0d-100\n      end do\n      f1=f1*1.0d-100\n      f0=f0*1.0d-100\n    end if\n  else\n    kb=k\n    fl=df(k+1)\n    f1=1.0d-100\n    f2=-(d(1)-cv)/a(1)*f1\n    df(1)=f1\n    if (kb == 1) then\n      fs=f2\n    else if (kb == 2) then\n      df(2)=f2\n      fs=-((d(2)-cv)*f2+g(2)*f1)/a(2)\n    else\n      df(2)=f2\n      do  j=3,kb+1\n        f=-((d(j-1)-cv)*f2+g(j-1)*f1)/a(j-1)\n        if (j <= kb) df(j)=f\n        if (dabs(f) > 1.0d+100) then\n          do  k1=1,j\n            df(k1)=df(k1)*1.0d-100\n          end do\n          f=f*1.0d-100\n          f2=f2*1.0d-100\n        end if\n        f1=f2\n        f2=f\n      end do\n      fs=f\n    end if\n    exit\n  end if\nend do\n35   su1=0.0d0\nr1=1.0d0\ndo  j=m+ip+1,2*(m+ip)\n  r1=r1*j\nend do\nsu1=df(1)*r1\ndo  k=2,kb\n  r1=-r1*(k+m+ip-1.5d0)/(k-1.0d0)\n  su1=su1+r1*df(k)\nend do\nsu2=0.0d0\ndo  k=kb+1,nm\n  if (k /= 1) r1=-r1*(k+m+ip-1.5d0)/(k-1.0d0)\n  su2=su2+r1*df(k)\n  if (dabs(sw-su2) < dabs(su2)*1.0d-14) exit\n  sw=su2\nend do\n55   r3=1.0d0\ndo  j=1,(m+n+ip)/2\n  r3=r3*(j+0.5d0*(n+m+ip))\nend do\nr4=1.0d0\ndo  j=1,(n-m-ip)/2\n  r4=-4.0d0*r4*j\nend do\ns0=r3/(fl*(su1/fs)+su2)/r4\ndo  k=1,kb\n  df(k)=fl/fs*s0*df(k)\nend do\ndo  k=kb+1,nm\n  df(k)=s0*df(k)\nend do\nreturn\nend subroutine sdmn\n"}
{"id": 37, "subroutine": "subroutine segv(m,n,c,kd,cv,eg)\n\n!     =========================================================\n!     purpose: compute the characteristic values of spheroidal\n!     wave functions\n!     input :  m  --- mode parameter\n!     n  --- mode parameter\n!     c  --- spheroidal parameter\n!     kd --- function code\n!     kd=1 for prolate; kd=-1 for oblate\n!     output:  cv --- characteristic value for given m, n and c\n!     eg(l) --- characteristic value for mode m and n'\n!     ( l = n' - m + 1 )\n!     =========================================================\n\n\ninteger, intent(in)                      :: m\ninteger, intent(in)                      :: n\ndouble precision, intent(in)             :: c\ninteger, intent(in)                      :: kd\ndouble precision, intent(out)            :: cv\ndouble precision, intent(out)            :: eg(200)\nimplicit double precision (a-h,o-z)\ndimension b(100),h(100),d(300),e(300),f(300),cv0(100),a(300) ,g(300)\n\nif (c < 1.0d-10) then\n  do  i=1,n\n    eg(i)=(i+m)*(i+m-1.0d0)\n  end do\nelse\n  icm=int((n-m+2)/2)\n  nm=10+int(0.5*(n-m)+c)\n  cs=c*c*kd\n  do  l=0,1\n    do  i=1,nm\n      if (l == 0) k=2*(i-1)\n      if (l == 1) k=2*i-1\n      dk0=m+k\n      dk1=m+k+1\n      dk2=2*(m+k)\n      d2k=2*m+k\n      a(i)=(d2k+2.0)*(d2k+1.0)/((dk2+3.0)*(dk2+5.0))*cs\n      d(i)=dk0*dk1+(2.0*dk0*dk1-2.0*m*m-1.0)/((dk2-1.0) *(dk2+3.0))*cs\n      g(i)=k*(k-1.0)/((dk2-3.0)*(dk2-1.0))*cs\n    end do\n    do  k=2,nm\n      e(k)=dsqrt(a(k-1)*g(k))\n      f(k)=e(k)*e(k)\n    end do\n    f(1)=0.0d0\n    e(1)=0.0d0\n    xa=d(nm)+dabs(e(nm))\n    xb=d(nm)-dabs(e(nm))\n    nm1=nm-1\n    do  i=1,nm1\n      t=dabs(e(i))+dabs(e(i+1))\n      t1=d(i)+t\n      if (xa < t1) xa=t1\n      t1=d(i)-t\n      if (t1 < xb) xb=t1\n    end do\n    do  i=1,icm\n      b(i)=xa\n      h(i)=xb\n    end do\n    do  k=1,icm\n      do  k1=k,icm\n        if (b(k1) < b(k)) then\n          b(k)=b(k1)\n          exit\n        end if\n      end do\n      35      if (k /= 1.and.h(k) < h(k-1)) h(k)=h(k-1)\n      do while (1==1)\n        40       x1=(b(k)+h(k))/2.0d0\n        cv0(k)=x1\n        if (dabs((b(k)-h(k))/x1) < 1.0d-14) exit\n        j=0\n        s=1.0d0\n        do  i=1,nm\n          if (s == 0.0d0) s=s+1.0d-30\n          t=f(i)/s\n          s=d(i)-t-x1\n          if (s < 0.0d0) j=j+1\n        end do\n        if (j < k) then\n          h(k)=x1\n        else\n          b(k)=x1\n          if (j >= icm) then\n            b(icm)=x1\n          else\n            if (h(j+1) < x1) h(j+1)=x1\n            if (x1 < b(j)) b(j)=x1\n          end if\n        end if\n      end do\n      50      cv0(k)=x1\n      if (l == 0) eg(2*k-1)=cv0(k)\n      if (l == 1) eg(2*k)=cv0(k)\n    end do\n  end do\nend if\n70   cv=eg(n-m+1)\nreturn\nend subroutine segv\n"}
{"id": 38, "subroutine": "   subroutine setpointerscomputenonlinearsubscales(itask)\n      implicit none\n      integer(ip) :: itask\n      \n      select case (itask)   \n      \n      case(0)\n         allocate(kfl_isset)\n         call a%memor%allocobj(0,'kfl_isset','initprocedurepointer',1)\n         kfl_isset = -1\n      \n      case(1)\n         if (kfl_isset == -1) then\n            kfl_isset = 1\n            \n            call concatenateprocedures(prochook_nsc_initializations,nonlinearsubscalesinitializations)\n            \n            !set iteration counter to zero\n            call concatenateprocedures(prochook_nsc_ingauss,nonlinearsubscalesiitertozero)\n            !we need to compute the subscales at the gausspoints\n            call setpointerscomputesubscales(1)\n            !compute residual and decide if we need to continue iterating\n            call concatenateprocedures(prochook_nsc_ingausselmats,nonlinearsubscalesingausselmats)\n            call concatenateprocedures(prochook_nsc_finalizations,nonlinearsubscalesfinalizations)\n         endif  \n      case(100)\n         deallocate(kfl_isset)\n         call a%memor%deallocobj(0,'kfl_isset','initprocedurepointer',1)\n      \n      end select   \n   end subroutine   \n"}
{"id": 39, "subroutine": "   subroutine nonlinearsubscalesinitializations\n      implicit none\n      \n      sgsmaxresidual = 0.0_rp\n   end subroutine\n"}
{"id": 40, "subroutine": "   subroutine nonlinearsubscalesfinalizations\n      implicit none\n      \n      if (a%mpirank == a%mpiroot) write(a%lun_nolin,*) 'step: ', a%istep, ' iteration: ', a%itera, ' non linear subscales maximum residual: ', sgsmaxresidual\n      if (a%kfl_flush == 1) call flush(a%lun_nolin)\n   end subroutine\n"}
{"id": 41, "subroutine": "   subroutine nonlinearsubscalesiitertozero\n      implicit none\n      \n      iiternolsgs = 0\n      \n      !we copy the subscales at the previous iteration\n     gpsgs_i(1:e%ndime)   = a%mosgs(ielem)%a(1:e%ndime,1,e%igaus)\n     gpsgs_i(4)   = a%cosgs(ielem)%a(1,e%igaus)\n     gpsgs_i(5)   = a%ensgs(ielem)%a(1,e%igaus)\n\n\n   end subroutine\n"}
{"id": 42, "subroutine": "   subroutine nonlinearsubscalesingausselmats\n      implicit none\n      \n!      real(rp) :: sgsnorm\n!      real(rp) :: sgsresidual(e%ndime)\n!      real(rp) :: sgsresidualnorm\n!      \n!      real(rp) :: matrix(e%ndime,e%ndime),invmatrix(e%ndime,e%ndime), rhs(e%ndime),deter\n!      integer(ip) :: idime,jdime\n!      real(rp) :: residualterm(e%ndime), tau_1, tauderiv(e%ndime),tau_1deriv(e%ndime)\n      \n      \n!      if (a%kfl_nolsgnewtonraphson == 1 .and. gpvno > 0.0_rp) then\n         !if newton-raphson\n         !\\delta \\tilde u +tau_t*\\delta \\tilde u \u00b7 \\nabla u = \\tau_t (r(\\tilde u) - \\ro \\tilde u *dtinv)) - \\tilde u\n!         residualterm = (gpmsgspaceresidual(1:e%ndime) + acden*a%vesgs(ielem)%a(1:e%ndime,2,e%igaus)*referencedtinv) for dss\n!         residualterm = gpmsgspaceresidual(1:e%ndime) \n!         tau_1deriv = gpden*a%staco(2)/chale(1)*gpadv/gpvno\n!         tauderiv = -timom(2)*timom(2)*tau_1deriv\n!         tau_1 = 1/timom(2)\n!         \n!         !system matrix\n!         matrix = 0.0_rp\n!         \n!         !identity term\n!         do idime = 1,e%ndime\n!            matrix(idime,idime) = 1.0_rp\n!         enddo\n!         \n!         !tau_t times convective term\n!         do idime = 1,e%ndime\n!            do jdime = 1,e%ndime\n!               matrix(idime,jdime) = matrix(idime,jdime) + gpden*timom(2)*grvel(idime,jdime)\n!            enddo\n!         enddo\n!         \n!         !tau_t times residual term\n!         do idime = 1,e%ndime\n!            do jdime = 1,e%ndime\n!               matrix(idime,jdime) = matrix(idime,jdime) -tauderiv(jdime)*residualterm(idime)\n!            enddo\n!         enddo\n!         \n!         !rhs\n!         rhs = timom*residualterm - gpsgs_i(1:e%ndime)\n!         \n!         !now we invert and solve\n!         call invmtx(matrix,invmatrix,deter,e%ndime)\n!         a%vesgs(ielem)%a(1:e%ndime,1,e%igaus) = matmul(invmatrix,rhs) + gpsgs_i(1:e%ndime)\n!\n!      endif\n!      \n      a%mosgs(ielem)%a(1:e%ndime,1,e%igaus) = gpsgs(1:e%ndime) \n      a%cosgs(ielem)%a(1,e%igaus) = gpsgs(4) \n      a%ensgs(ielem)%a(1,e%igaus) = gpsgs(5) \n\n      !relaxation parameter\n      if (a%subrelax /= 1.0_rp) then\n!         a%mosgs(ielem)%a(1:e%ndime,1,e%igaus) = a%subrelax*a%mosgs(ielem)%a(1:e%ndime,1,e%igaus) + (1-a%subrelax)*gpsgs_i(1:e%ndime)\n!         a%cosgs(ielem)%a(1,e%igaus) = a%subrelax*a%cosgs(ielem)%a(1,e%igaus) + (1-a%subrelax)*gpsgs_i(4)\n!         a%ensgs(ielem)%a(1,e%igaus) = a%subrelax*a%ensgs(ielem)%a(1,e%igaus) + (1-a%subrelax)*gpsgs_i(5)\n         a%mosgs(ielem)%a(1:e%ndime,1,e%igaus) = a%subrelax*gpsgs(1:e%ndime) + (1-a%subrelax)*gpsgs_i(1:e%ndime)\n         a%cosgs(ielem)%a(1,e%igaus) = a%subrelax*gpsgs(4) + (1-a%subrelax)*gpsgs_i(4)\n         a%ensgs(ielem)%a(1,e%igaus) = a%subrelax*gpsgs(5) + (1-a%subrelax)*gpsgs_i(5)\n      endif\n!      \n!      !convergence check\n!      sgsresidual(1:e%ndime) = a%vesgs(ielem)%a(1:e%ndime,1,e%igaus) - gpsgs_i(1:e%ndime) \n!      call vecnor(a%vesgs(ielem)%a(1:e%ndime,1,e%igaus),e%ndime,sgsnorm,2)\n!      call vecnor(sgsresidual(1:e%ndime),e%ndime,sgsresidualnorm,2)\n!      \n!      if (sgsnorm == 0.0_rp) then\n!         sgsresidualnorm = 0.0_rp\n!      else\n!         sgsresidualnorm = sgsresidualnorm/sgsnorm\n!      end if\n!      \n!      !tolerance criteria\n!      if (sgsresidualnorm < a%tosgs) then\n!         !exit the non-linear subscales loop\n!         kfl_goiteingauss = 0\n!      endif\n!      \n!      !maximum number of iterations criteria\n!      iiternolsgs = iiternolsgs + 1\n!      if (iiternolsgs >= a%mtrit) then\n!         kfl_goiteingauss = 0\n!      endif\n!      \n!      !if not done, continue\n!      if (kfl_goiteingauss /= 0) then \n!         kfl_goiteingauss = 2\n!      else\n!         !maximum residual for the subscales\n!         sgsmaxresidual = max(sgsmaxresidual,sgsresidualnorm)\n!      endif\n!      \n!      !keep the subscales value for the next convergence check\n!      gpsgs_i(1:e%ndime) = a%vesgs(ielem)%a(1:e%ndime,1,e%igaus)\n   end subroutine\n"}
{"id": 43, "subroutine": "subroutine get_default_compile_flags(compiler, release, flags)\n    character(len=*), intent(in) :: compiler\n    logical, intent(in) :: release\n    character(len=:), allocatable, intent(out) :: flags\n    integer :: id\n\n    id = get_compiler_id(compiler)\n    if (release) then\n        call get_release_compile_flags(id, flags)\n    else\n        call get_debug_compile_flags(id, flags)\n    end if\n\nend subroutine get_default_compile_flags\n"}
{"id": 44, "subroutine": "subroutine get_release_compile_flags(id, flags)\n    integer(compiler_enum), intent(in) :: id\n    character(len=:), allocatable, intent(out) :: flags\n\n    select case(id)\n    case default\n        flags = \"\"\n    case(id_caf)\n        flags='&\n            & -o3&\n            & -wimplicit-interface&\n            & -fpic&\n            & -fmax-errors=1&\n            & -funroll-loops&\n            &'\n    case(id_gcc)\n        flags='&\n            & -o3&\n            & -wimplicit-interface&\n            & -fpic&\n            & -fmax-errors=1&\n            & -funroll-loops&\n            & -fcoarray=single&\n            &'\n    case(id_f95)\n        flags='&\n            & -o3&\n            & -wimplicit-interface&\n            & -fpic&\n            & -fmax-errors=1&\n            & -ffast-math&\n            & -funroll-loops&\n            &'\n    case(id_nvhpc)\n        flags = '&\n            & -mbackslash&\n            &'\n    case(id_intel_classic_nix, id_intel_classic_unknown)\n        flags = '&\n            & -fp-model precise&\n            & -pc64&\n            & -align all&\n            & -error-limit 1&\n            & -reentrancy threaded&\n            & -nogen-interfaces&\n            & -assume byterecl&\n            &'\n    case(id_intel_classic_mac)\n        flags = '&\n            & -fp-model precise&\n            & -pc64&\n            & -align all&\n            & -error-limit 1&\n            & -reentrancy threaded&\n            & -nogen-interfaces&\n            & -assume byterecl&\n            &'\n    case(id_intel_classic_windows)\n        flags = '&\n            & /fp:precise&\n            & /align:all&\n            & /error-limit:1&\n            & /reentrancy:threaded&\n            & /nogen-interfaces&\n            & /assume:byterecl&\n            &'\n    case(id_intel_llvm_nix, id_intel_llvm_unknown)\n        flags = '&\n            & -fp-model=precise&\n            & -pc64&\n            & -align all&\n            & -error-limit 1&\n            & -reentrancy threaded&\n            & -nogen-interfaces&\n            & -assume byterecl&\n            &'\n    case(id_intel_llvm_windows)\n        flags = '&\n            & /fp:precise&\n            & /align:all&\n            & /error-limit:1&\n            & /reentrancy:threaded&\n            & /nogen-interfaces&\n            & /assume:byterecl&\n            &'\n    case(id_nag)\n        flags = ' &\n            & -o4&\n            & -coarray=single&\n            & -pic&\n            &'\n    end select\nend subroutine get_release_compile_flags\n"}
{"id": 45, "subroutine": "subroutine get_debug_compile_flags(id, flags)\n    integer(compiler_enum), intent(in) :: id\n    character(len=:), allocatable, intent(out) :: flags\n\n    select case(id)\n    case default\n        flags = \"\"\n    case(id_caf)\n        flags = '&\n            & -wall&\n            & -wextra&\n            & -wimplicit-interface&\n            & -fpic -fmax-errors=1&\n            & -g&\n            & -fcheck=bounds&\n            & -fcheck=array-temps&\n            & -fbacktrace&\n            &'\n    case(id_gcc)\n        flags = '&\n            & -wall&\n            & -wextra&\n            & -wimplicit-interface&\n            & -fpic -fmax-errors=1&\n            & -g&\n            & -fcheck=bounds&\n            & -fcheck=array-temps&\n            & -fbacktrace&\n            & -fcoarray=single&\n            &'\n    case(id_f95)\n        flags = '&\n            & -wall&\n            & -wextra&\n            & -wimplicit-interface&\n            & -fpic -fmax-errors=1&\n            & -g&\n            & -fcheck=bounds&\n            & -fcheck=array-temps&\n            & -wno-maybe-uninitialized -wno-uninitialized&\n            & -fbacktrace&\n            &'\n    case(id_nvhpc)\n        flags = '&\n            & -minform=inform&\n            & -mbackslash&\n            & -g&\n            & -mbounds&\n            & -mchkptr&\n            & -mchkstk&\n            & -traceback&\n            &'\n    case(id_intel_classic_nix, id_intel_classic_unknown)\n        flags = '&\n            & -warn all&\n            & -check all&\n            & -error-limit 1&\n            & -o0&\n            & -g&\n            & -assume byterecl&\n            & -traceback&\n            &'\n    case(id_intel_classic_mac)\n        flags = '&\n            & -warn all&\n            & -check all&\n            & -error-limit 1&\n            & -o0&\n            & -g&\n            & -assume byterecl&\n            & -traceback&\n            &'\n    case(id_intel_classic_windows)\n        flags = '&\n            & /warn:all&\n            & /check:all&\n            & /error-limit:1&\n            & /od&\n            & /z7&\n            & /assume:byterecl&\n            & /traceback&\n            &'\n    case(id_intel_llvm_nix, id_intel_llvm_unknown)\n        flags = '&\n            & -warn all&\n            & -check all&\n            & -error-limit 1&\n            & -o0&\n            & -g&\n            & -assume byterecl&\n            & -traceback&\n            &'\n    case(id_intel_llvm_windows)\n        flags = '&\n            & /warn:all&\n            & /check:all&\n            & /error-limit:1&\n            & /od&\n            & /z7&\n            & /assume:byterecl&\n            &'\n    case(id_nag)\n        flags = '&\n            & -g&\n            & -c=all&\n            & -o0&\n            & -gline&\n            & -coarray=single&\n            & -pic&\n            &'\n    end select\nend subroutine get_debug_compile_flags\n"}
{"id": 46, "subroutine": "subroutine get_module_flags(compiler, modpath, flags)\n    character(len=*), intent(in) :: compiler\n    character(len=*), intent(in) :: modpath\n    character(len=:), allocatable, intent(out) :: flags\n    integer(compiler_enum) :: id\n\n    id = get_compiler_id(compiler)\n\n    select case(id)\n    case default\n        flags=' -module '//modpath//' -i '//modpath\n\n    case(id_caf, id_gcc, id_f95, id_cray)\n        flags=' -j '//modpath//' -i '//modpath\n\n    case(id_nvhpc, id_pgi, id_flang)\n        flags=' -module '//modpath//' -i '//modpath\n\n    case(id_intel_classic_nix, id_intel_classic_mac, id_intel_classic_unknown, id_intel_llvm_nix, id_intel_llvm_unknown)\n        flags=' -module '//modpath//' -i'//modpath\n\n    case(id_intel_classic_windows, id_intel_llvm_windows)\n        flags=' /module:'//modpath//' /i'//modpath\n\n    case(id_lahey)\n        flags=' -m '//modpath//' -i '//modpath\n\n    case(id_nag)\n        flags=' -mdir '//modpath//' -i '//modpath !\n\n    case(id_ibmxl)\n        flags=' -qmoddir '//modpath//' -i '//modpath\n\n    end select\n\nend subroutine get_module_flags\n"}
{"id": 47, "subroutine": "subroutine get_default_c_compiler(f_compiler, c_compiler)\n    character(len=*), intent(in) :: f_compiler\n    character(len=:), allocatable, intent(out) :: c_compiler\n    integer(compiler_enum) :: id\n\n    id = get_compiler_id(f_compiler)\n\n    select case(id)\n\n    case(id_intel_classic_nix, id_intel_classic_mac, id_intel_classic_windows, id_intel_classic_unknown)\n        c_compiler = 'icc'\n\n    case(id_intel_llvm_nix,id_intel_llvm_windows, id_intel_llvm_unknown)\n        c_compiler = 'icx'\n\n    case(id_flang)\n        c_compiler='clang'\n\n    case(id_ibmxl)\n        c_compiler='xlc'\n\n    case default\n        ! fall-back to using fortran compiler\n        c_compiler = f_compiler\n    end select\n\nend subroutine get_default_c_compiler\n"}
{"id": 48, "subroutine": "subroutine mc_nucleosome_slide(ib1, ib2, it1, it2, rand_stat, success)\n! this move will \"slide\" a nucleosome bead some fractional basepair\n! this is implemented by changed the discretization of the neighboring beads\n! i.e. if you move a nucleosome +1bp along the chain, then the discretization to\n! downstream the nucleosome will shorten to adjust for this and the discretization\n! of the linker upstream will increase. likewise the nucleosome is then shifted\n! along its u-vector in the direction of this change. this move was intended for\n! simulations with linker discretization (i.e. wlc_p__include_discretize_linker==true),\n! but it should in *theory* work for simulations that discretize per nucleosome\n   use params, only: wlc_v, wlc_r, wlc_rp, wlc_ab, wlc_u &\n                     , wlc_up, wlc_abp, wlc_vp, wlc_pointsmoved, wlc_npointsmoved, &\n                     wlc_nucleosomewrap, wlc_basepairs, wlc_nbend, wlc_bendpoints, &\n                     wlc_basepairs_prop\n\n   use mersenne_twister\n   use params, only: dp\n   use windowtools, only: exponential_random_int\n   use polydispersity, only: get_ip, first_bead_of_chain, last_bead_of_chain\n   use nucleosome, only: nucleosome_prop\n\n   implicit none\n   integer, intent(out) :: ib1   ! test bead position 1\n   integer, intent(out) :: it1   ! index of test bead 1\n   integer, intent(out) :: ib2   ! test bead position 2\n   integer, intent(out) :: it2   ! index of test bead 2\n   logical, intent(out) :: success ! success of move to take place\n\n! things for random number generator\n   type(random_stat), intent(inout) :: rand_stat  ! status of random number generator\n   real(dp) urand(1) ! single random number\n   real(dp) :: mcamp ! amplitude of random change\n   real(dp) dr    ! displacement for slide move (integer bps)\n   real(dp), parameter :: optratio = 0.25 ! max ratio of average discretization to allow for bp slide\n   integer i ! test bead\n   integer ii, jj, kk, j ! test indices\n   integer max_bp\n   integer prevnuc, nextnuc, linkersum\n   integer nnucs\n   integer nucarray(wlc_p__nt)\n   real(dp), parameter :: eps = 0.00001 ! rescale to avoid urand vals of 0\n\n! initialize\n   success = .false.\n   max_bp = 15\n\n! find nucs\n   kk = 1\n   do ii = 1, wlc_p__nt\n      if (wlc_nucleosomewrap(ii) == 1) cycle\n      nucarray(kk) = ii\n      kk = kk + 1\n   enddo\n   nnucs = kk - 1\n\n! select nuc to move\n   call random_number(urand, rand_stat)\n   kk = ceiling(nnucs*(urand(1) + eps)/(1 + 1.1*eps))\n   i = nucarray(kk)\n\n! select distance to move (in bp)\n   dr = 0.0_dp\n   mcamp = max(nint(optratio*sum(wlc_basepairs)/wlc_p__nt), 3)\n\n!call random_number(urand,rand_stat)\n!if (urand(1)>=0.5) then ! 10 bp slide (half of moves)\n!    call random_number(urand,rand_stat)\n!    dr = 10*(-1)**nint(urand(1))\n!else ! few bp slide\n   call random_number(urand, rand_stat)\n   dr = mcamp*(urand(1) - 0.5_dp)\n!endif\n\n! find neighboring nuclesomes\n   prevnuc = kk - 1\n   if (prevnuc > 0) then\n      prevnuc = nucarray(prevnuc)\n      if (get_ip(prevnuc) /= get_ip(i)) then\n         prevnuc = first_bead_of_chain(get_ip(i))\n      endif\n   else\n      prevnuc = 1\n   endif\n   nextnuc = kk + 1\n   if (nextnuc <= nnucs) then\n      nextnuc = nucarray(nextnuc)\n      if (get_ip(nextnuc) /= get_ip(i)) then\n         nextnuc = last_bead_of_chain(get_ip(i)) - 1\n      endif\n   else\n      nextnuc = wlc_p__nt - 1\n   endif\n\n   wlc_basepairs_prop = wlc_basepairs\n! change distance between beads\n   outer1: do ii = 1, i - prevnuc ! explore the previous linker space\n      inner1: do jj = 0, (nextnuc - 1) - i ! explore the next linker space\n         if ((wlc_basepairs(i - ii) + dr > 3) .and. (wlc_basepairs(i - ii) + dr < max_bp) .and. &\n             (wlc_basepairs(i + jj) - dr > 3) .and. (wlc_basepairs(i + jj) - dr < max_bp)) then\n            wlc_basepairs_prop(i - ii) = wlc_basepairs(i - ii) + dr\n            wlc_basepairs_prop(i + jj) = wlc_basepairs(i + jj) - dr\n            success = .true.\n            exit outer1\n         endif\n      enddo inner1\n   enddo outer1\n\n! piece-wise movement of linker rather than just on one bead\n   linkersum = 0\n!if (success .eqv. .false.) then\n!    outer2: do ii = 1, i-prevnuc ! explore the previous linker space\n!        inner2: do jj = 0, (nextnuc-1)-i ! explore the next linker space\n!            if ((wlc_basepairs(i-ii)+dr/(i-prevnuc) > 3) .and. (wlc_basepairs(i-ii)+dr/(i-prevnuc) < max_bp) .and. &\n!            (wlc_basepairs(i+jj)-dr/(i-prevnuc) > 3) .and. (wlc_basepairs(i+jj)-dr/(i-prevnuc) < max_bp) ) then\n!                wlc_basepairs_prop(i-ii) = wlc_basepairs(i-ii) + dr/(i-prevnuc)\n!                wlc_basepairs_prop(i+jj) = wlc_basepairs(i+jj) - dr/(i-prevnuc)\n!                linkersum = linkersum + abs(dr/(i-prevnuc))\n!                if (linkersum>=10) then\n!                    success = .true.\n!                    !print*, 'woo'\n!                    exit outer2\n!                endif\n!            endif\n!        enddo inner2\n!    enddo outer2\n!endif\n\n   if (success) then\n      ib1 = i - ii\n      ib2 = i + jj\n      it1 = ib1 + 1\n      it2 = ib2 - 1\n      if (ib1 >= 1) then\n         wlc_nbend = wlc_nbend + 1\n         wlc_bendpoints(wlc_nbend) = ib1\n         j = ib1\n         wlc_rp(:, j) = wlc_r(:, j)\n         wlc_up(:, j) = wlc_u(:, j)\n         wlc_vp(:, j) = wlc_v(:, j)\n         wlc_npointsmoved = wlc_npointsmoved + 1\n         wlc_pointsmoved(wlc_npointsmoved) = j\n      endif\n      if (ib2 < wlc_p__nt) then\n         wlc_nbend = wlc_nbend + 1\n         wlc_bendpoints(wlc_nbend) = ib2\n         do j = ib2, ib2 + 1\n            wlc_rp(:, j) = wlc_r(:, j)\n            wlc_up(:, j) = wlc_u(:, j)\n            wlc_vp(:, j) = wlc_v(:, j)\n            wlc_npointsmoved = wlc_npointsmoved + 1\n            wlc_pointsmoved(wlc_npointsmoved) = j\n         enddo\n      endif\n      do kk = it1, it2\n         wlc_rp(:, kk) = wlc_r(:, kk) + wlc_u(:, kk)*wlc_p__length_per_bp*(wlc_basepairs_prop(kk) - wlc_basepairs(kk))\n         wlc_up(:, kk) = wlc_u(:, kk)\n         wlc_vp(:, kk) = wlc_v(:, kk)\n         wlc_npointsmoved = wlc_npointsmoved + 1\n         wlc_pointsmoved(wlc_npointsmoved) = kk\n      enddo\n   else\n      wlc_basepairs_prop = wlc_basepairs\n   endif\n\nend subroutine\n"}
{"id": 49, "subroutine": "subroutine mk3cse(iband,ikk,lossfn, &\n& vol,pi,nwpt,wmax,nbcore,nbocc,ncband,ngkpt,natom,xred,projwf,nlmn, &\n& test_bands_se, &\n& pwmatel,tpwmatel, &\n& kg,kgq,enrgy,enrgyq,cg,cgq,npwt,npwtq,bantot,bantotq,ncg,ncgq, &\n& indxkpw,indxkpwq,indxkbnd,indxkbndq,indxkcg,indxkcgq,npwarr,npwarrq, &\n& kpt,kptq,nkpt,nkptq,nqpt,nsymk,nsymkq,symk,symkq,nsym,nsymq,symrel,syminv, &\n& ihlf,ihlfq,lvtrans,lvtransq,bmet,blat,ipaw,itetrahedron, &\n& ipwx,ipwndx,npwndx,ntpwndx,napwndx, &\n& npwc,npwx,invpw2ndx,pwsymndx,iqsymndx, &\n& igmx,igmn,igndx,igndxq,ikndx,ikndxq,iqndx,isymndx,isymndxq,isymg,npw,npwq, &\n& nband,nbandq,nsppol,shiftk,shiftkq,zz,cse,xse)\nimplicit none\ninteger :: iband,ikk(3),nwpt,nbcore,nbocc,ncband,ngkpt(3),natom,nlmn\ninteger :: igmn(3),igmx(3)\ninteger :: npwt,npwtq,bantot,bantotq,ncg,ncgq,nkpt,nkptq,nqpt,nsym,nsymq,nsppol\ninteger :: npw,npwc,npwx,npwq,ipw1,npwndx,ntpwndx,napwndx,ipaw,itetrahedron\ndouble precision :: vol,pi,wmax,xred(3,natom)\ndouble complex :: lossfn(nwpt,nqpt+9,ntpwndx)\ninteger :: test_bands_se(2)\ndouble complex :: projwf(natom,nlmn,nkpt,ncband)\ninteger :: kg(3,npwt),kgq(3,npwtq)\ndouble precision :: enrgy(bantot),enrgyq(bantotq)\ndouble complex :: cg(ncg),cgq(ncgq)\ninteger :: indxkpw(nkpt),indxkpwq(nkptq),indxkbnd(nkpt),indxkbndq(nkptq)\ninteger :: indxkcg(nkpt),indxkcgq(nkptq),npwarr(nkpt),npwarrq(nkptq)\ndouble precision :: kpt(3,nkpt),kptq(3,nkptq),shiftk(3),shiftkq(3)\ninteger :: nsymk(nkpt),nsymkq(nkptq),symk(nkpt,nsym*2),symkq(nkptq,nsymq*2)\ninteger :: symrel(3,3,nsym),syminv(3,3,nsymq)\ninteger :: lvtrans(3,ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: lvtransq(3,ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: ihlf(nkpt),ihlfq(nkptq)\ndouble precision :: bmet(3,3),blat(3,3)\ninteger :: ipwx(3,npwx),ipwndx(2,napwndx)\ninteger :: igndx(nkpt,igmn(1):igmx(1),igmn(2):igmx(2),igmn(3):igmx(3))\ninteger :: igndxq(nkptq,igmn(1):igmx(1),igmn(2):igmx(2),igmn(3):igmx(3))\ninteger :: ikndx(ngkpt(1),ngkpt(2),ngkpt(3)),ikndxq(ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: iqndx(ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: isymndx(ngkpt(1),ngkpt(2),ngkpt(3)),isymndxq(ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: isymg(3,nkpt,nsym),igsymk(3),igsymq(3)\ninteger :: nband(nkpt*nsppol),nbandq(nkptq*nsppol)\ndouble complex :: sei,seipw,seiold,seibc,csepw,cseold,csebc\ndouble complex, allocatable :: ssi(:)\ndouble complex :: ssc(-nwpt:nwpt),cse,dcse,cse0,dcse0,cse1(-nwpt:nwpt),zz,ctest,cse2(-nwpt:nwpt)\ndouble precision :: xse,xse0,ssx,ssx1,ssx2,xse2,ssx3\ninteger :: ii,jj,kk,ix,iy,iz,iskip,ocsign\ninteger :: iqq(3),iqqp(3),jka(3),jkb(3),jkk(3),iqv(3),ictr(3)\ninteger :: ikpt,ikptq,iks(3),ikslf1(3),ikslf2(3)\ninteger :: igg(3),igh(3),igg0(3),isym,isymq,ibp,iqpt,iqsym,iw,iww,ie,je,ies,iqctr\ndouble precision :: xck(3),xckq(3),qadj(6)\ndouble complex :: cmatel,cmatel2,amatel,amatel2\ndouble complex :: vqmat2(ngkpt(1),ngkpt(2),ngkpt(3))\ndouble complex :: xmat2(ngkpt(1),ngkpt(2),ngkpt(3))\ndouble complex :: vfactor(ngkpt(1),ngkpt(2),ngkpt(3),nwpt),vfv(8,nwpt),vfx(8)\ndouble precision :: vq2(8),vqvtx0(4),vqvtx(4),qkcvt(3,3)\ndouble precision :: omega(ngkpt(1),ngkpt(2),ngkpt(3))\ndouble precision :: whi,wlo,wwhi,wwlo,ww,www,wwwlo,wwwhi,enval(8),dw,eshift,evtx0(4),evtx(4)\ndouble precision :: rrpyr(3,4),kvtx(3,4),xk(3,4),rg(3,3),tvol,xpyr0(4),xpyr(4)\ndouble complex :: vpyr0(4,nwpt),vpyr(4)\ndouble precision :: de21,de31,de32,de41,de42,de43,thresh\ndouble precision :: fbx(4),fb(4),cmx(3,4),cm(3,4),xkt(3,3)\ndouble complex :: aa0(nwpt),av(3,nwpt)\ndouble precision :: xme,xv(3)\ndouble precision :: avec(3),bgrad(3),xmult\ndouble precision :: abr,rlr\ninteger :: iwh,iwl,ibmin,ibmax,iwhi,iwlo,iehi,ielo\ninteger :: indxe(4),iwwlim(4)\ndouble precision :: vq(ngkpt(1),ngkpt(2),ngkpt(3)),qq(3),qp(3),qq2,qp2,qs(3),ek,ekmq\ndouble precision :: stvec(ngkpt(3)),stvec2(ngkpt(3)),temparray(ngkpt(1),ngkpt(2),ngkpt(3))\ninteger :: iipw,jjpw\ninteger :: iqsymndx(ngkpt(1),ngkpt(2),ngkpt(3)),invpw2ndx(npwx,npwx)\ninteger :: pwsymndx(npwc,2*nsym)\ninteger :: ipw2,jw,iqcentr,jqcentr\ndouble precision :: eps1,eps2,eps\ndouble precision :: eval,brd,esprd\ndouble precision :: gfo,gamma(3),pln(3),dist(3)\ndouble precision :: sint1,sint1a,sint1b,svec(3),sveca(3),svecb(3)\ndouble complex :: wint,wint0,w2int,w2int0,gterm,vcentr\ndouble precision :: wcentr(-nwpt:nwpt),wgrid(nwpt)\ndouble complex :: pwmatel(nlmn,nlmn,npwx,ngkpt(1),ngkpt(2),ngkpt(3)), &\n&                tpwmatel(nlmn,nlmn,npwx,ngkpt(1),ngkpt(2),ngkpt(3))\nlogical :: lqsing,lqcentr\ninteger :: idum\nlogical :: lx,lc\ndouble precision :: xdum,vdum(3)\ndouble precision :: linterp\ndouble precision :: rr(3,8)\ninteger :: ivndx(4,6),itet,iv\ninteger :: nsing\ndouble precision :: wsing(20)\ncharacter*4 :: label\nexternal linterp\ndata rr(1:3,1) /0.0d0,0.0d0,0.0d0/\ndata rr(1:3,2) /1.0d0,0.0d0,0.0d0/\ndata rr(1:3,3) /0.0d0,1.0d0,0.0d0/\ndata rr(1:3,4) /1.0d0,1.0d0,0.0d0/\ndata rr(1:3,5) /0.0d0,0.0d0,1.0d0/\ndata rr(1:3,6) /1.0d0,0.0d0,1.0d0/\ndata rr(1:3,7) /0.0d0,1.0d0,1.0d0/\ndata rr(1:3,8) /1.0d0,1.0d0,1.0d0/\ndata ivndx(1:4,1) /1,2,3,5/\ndata ivndx(1:4,2) /3,5,6,7/\ndata ivndx(1:4,3) /2,3,5,6/\ndata ivndx(1:4,4) /2,3,4,6/\ndata ivndx(1:4,5) /3,4,6,7/\ndata ivndx(1:4,6) /4,6,7,8/\ndouble precision :: aa,bb,cc,dd,ee,ff\ninteger :: iter \ncommon /fn/ aa,bb,cc,dd,ee,ff,iter \ndata iter /30/  \n\nabr=1.d-6\nrlr=1.d-6\nsei=0.d0\nctest=(0.d0,0.d0)\ncse=(0.d0,0.d0)\ndcse=(0.d0,0.d0)\nzz=(0.d0,0.d0)\nigg0=(/0,0,0/)\ndo ie=-nwpt,nwpt\n  cse1(ie)=(0.d0,0.d0)\nenddo\nxse=0.d0\ndw=wmax/dble(nwpt)\ndo iw=1,nwpt\n  wgrid(iw)=iw*dw\nenddo\nikpt=ikndx(ikk(1),ikk(2),ikk(3))\nisym=isymndx(ikk(1),ikk(2),ikk(3))\nigsymk=isymg(:,ikpt,isym)\nek=enrgy(indxkbnd(ikpt)+iband)\ndo ii=1,3\ndo jj=1,3\n  qkcvt(ii,jj)=blat(ii,jj)/dble(ngkpt(ii))\nenddo\nenddo\nictr=(/ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2/)\niqctr=iqndx(ictr(1),ictr(2),ictr(3))\n\ndo ix=1,ngkpt(1)\ndo iy=1,ngkpt(2)\ndo iz=1,ngkpt(3)\n  temparray(ix,iy,iz)=(0.d0,0.d0)\nenddo\nenddo\nenddo\n\ngamma=(blat(1,:)+blat(2,:)+blat(3,:))/2.d0\ndo ii=1,3\n  jj=mod(ii,3)+1\n  kk=mod(ii+1,3)+1\n  pln(1)=blat(jj,2)*blat(kk,3)-blat(jj,3)*blat(kk,2)\n  pln(2)=-blat(jj,1)*blat(kk,3)+blat(jj,3)*blat(kk,1)\n  pln(3)=blat(jj,1)*blat(kk,2)-blat(jj,2)*blat(kk,1)\n  dist(ii)=dot_product(gamma,pln)/norm2(pln)\nenddo\ngfo=minval(dist)\n\n!ipaw=0\n!write(6,'(a)') '      finding contibutions from:'\n!write(6,'(a)') 'band  plane waves    correlation                exchange'\ndo ibp=test_bands_se(1),test_bands_se(2)\n!do ibp=2,2\n!do ibp=iband,iband\n  write(6,'(3(a,i4))') 'quasiparticle band ',iband,', polarized band ',ibp,' out of ',test_bands_se(2)\n  seibc=sei\n  cse2=cse1\n  xse2=xse\n  if (ibp.gt.nbocc) then\n    ocsign=-1\n  else\n    ocsign=1\n  endif\n  do iipw=1,napwndx\n!  do iipw=napwndx,napwndx\n!  do iipw=1,1 \n!  do iipw=15,15\n!    write(6,'(a,i4)') 'iipw ',iipw\n    seipw=sei\n    do ie=-nwpt,nwpt\n      ssc(ie)=(0.d0,0.d0)\n    enddo\n    ipw1=ipwndx(1,iipw)\n    ipw2=ipwndx(2,iipw)\n!    if (ipw1.ne.ipw2) cycle\n!    write(6,'(1x,i3,4x,2i4)') ibp,ipw1,ipw2 \n    lx=ipw1.eq.ipw2.and.ibp.le.nbocc  ! do exchange\n    lc=iipw.le.ntpwndx  ! do correlation\n    if ((.not.lx).and.(.not.lc)) cycle\n\n! step 1: compute matrix elements\n    do ix=1,ngkpt(1)\n    do iy=1,ngkpt(2)\n    do iz=1,ngkpt(3)\n!    do ix=1,1\n!    do iy=10,10\n!    do iz=10,10\n      iqq=(/ix,iy,iz/)\n!write(6,*) '>>>>> iqq = ',iqq\n!write(6,'(a,3f10.5)') 'kpt = ',kpt(:,ikpt)\n      iks=iqq-ngkpt/2\n      jka=ikk-iks\n      jkk=mod(jka,ngkpt)\n      do ii=1,3\n        if (jkk(ii).le.0) jkk(ii)=jkk(ii)+ngkpt(ii)\n      enddo\n      ikptq=ikndxq(jkk(1),jkk(2),jkk(3))\n      isymq=isymndx(jkk(1),jkk(2),jkk(3))\n      igsymq=isymg(:,ikptq,isymq)\n      if (iks(1).eq.0.and.iks(2).eq.0.and.iks(3).eq.0) then\n!      if (.true.) then\n        jkb=nint(kptq(:,ikptq)*dble(ngkpt))+ngkpt/2\n        qq=kpt(:,ikpt)-kptq(:,ikptq)\n!write(6,'(a,3f10.5)') 'kptq = ',kptq(:,ikptq)\n      else\n        ikptq=ikndx(jkk(1),jkk(2),jkk(3))\n        jkb=nint(kpt(:,ikptq)*dble(ngkpt))+ngkpt/2\n        qq=kpt(:,ikpt)-kpt(:,ikptq)\n!write(6,'(a,3f10.5)') 'kptq = ',kptq(:,ikptq)\n      endif\n      igg=nint(dble(jkb-jka)/dble(ngkpt))\n      qp=qq+igg+ipwx(:,ipw2)\n      qq=qq+igg+ipwx(:,ipw1)\n      qq2=0.d0\n      qp2=0.d0\n      do ii=1,3\n      do jj=1,3\n        qq2=qq2+qq(ii)*bmet(ii,jj)*qq(jj)\n        qp2=qp2+qp(ii)*bmet(ii,jj)*qp(jj)\n      enddo\n      enddo\n      vq(ix,iy,iz)=4.d0*pi/sqrt(qq2*qp2)\n!write(6,'(a,3f10.5)') 'qq = ',qq\n!write(6,'(a,3f10.5)') 'qp = ',qp\n!write(6,'(a,3f10.5)') 'qq2 = ',qq2\n!write(6,'(a,3f10.5)') 'qp2 = ',qp2\n!write(6,*) 'vq = ',vq(ix,iy,iz)\n!write(6,*) 'jka = ',jka\n!write(6,*) 'jkk = ',jkk\n!write(6,*) 'jkb = ',jkb\n!write(6,*) 'igg = ',igg\n!write(6,*) 'ikpt = ',ikpt\n!write(6,*) 'ikptq = ',ikptq\n      if (iks(1).eq.0.and.iks(2).eq.0.and.iks(3).eq.0) then\n        call mkmatelx(ibp,iband,ikpt,ikptq,ipwx(:,ipw1),igg, &\n&         ncg,ncgq,nkpt,nkptq,npwt,npwtq,igmx,igmn,igndx,igndxq, &\n&         isym,isymq,symrel,syminv,nsym,nsymq,ihlf,ihlfq,kpt,kptq, &\n&         lvtrans(1:3,ikk(1),ikk(2),ikk(3)),lvtransq(1:3,ikk(1),ikk(2),ikk(3)), &\n&         cg,cgq,indxkcg,indxkcgq,indxkpw,indxkpwq,npwarr,npwarrq,kg,kgq, &\n&         cmatel)\n        if (ipaw.ne.0) then\n!          call mkmatelp(pi,xred,natom,ibp,iband,ikpt,ikptq,qq,igg0,ngkpt, &\n!&               pwmatel(:,:,ipw1,ix,iy,iz),tpwmatel(:,:,ipw1,ix,iy,iz), &\n!&               projwf,nlmn,nkpt,nkptq,ncband,amatel)\n        else\n          amatel=(0.d0,0.d0)\n        endif\n        if (ipw1.eq.ipw2) then\n          cmatel2=cmatel\n          amatel2=amatel\n        else\n          call mkmatelx(ibp,iband,ikpt,ikptq,ipwx(:,ipw2),igh, &\n&         ncg,ncgq,nkpt,nkptq,npwt,npwtq,igmx,igmn,igndx,igndxq, &\n&         isym,isymq,symrel,syminv,nsym,nsymq,ihlf,ihlfq,kpt,kptq, &\n&         lvtrans(1:3,ikk(1),ikk(2),ikk(3)),lvtransq(1:3,ikk(1),ikk(2),ikk(3)), &\n&         cg,cgq,indxkcg,indxkcgq,indxkpw,indxkpwq,npwarr,npwarrq,kg,kgq, &\n&         cmatel2)\n          if (ipaw.ne.0) then\n!            call mkmatelp(pi,xred,natom,ibp,iband,ikpt,ikptq,qp,igg0,ngkpt, &\n!&                 pwmatel(:,:,ipw2,ix,iy,iz),tpwmatel(:,:,ipw2,ix,iy,iz), &\n!&                 projwf,nlmn,nkpt,nkptq,ncband,amatel2)\n          else\n            amatel2=(0.d0,0.d0)\n          endif\n        endif\n        omega(ix,iy,iz)=enrgyq(indxkbndq(ikptq)+ibp)-ek+dw/2\n      else\n        call mkmatelx(ibp,iband,ikpt,ikptq,ipwx(:,ipw1),igg, &\n&         ncg,ncg,nkpt,nkpt,npwt,npwt,igmx,igmn,igndx,igndx, &\n&         isym,isymq,symrel,syminv,nsym,nsym,ihlf,ihlf,kpt,kpt, &\n&         lvtrans(1:3,ikk(1),ikk(2),ikk(3)),lvtrans(1:3,ikk(1),ikk(2),ikk(3)), &\n&         cg,cg,indxkcg,indxkcg,indxkpw,indxkpw,npwarr,npwarr,kg,kg, &\n&         cmatel)\n        if (ipaw.ne.0) then\n!          call mkmatelp(pi,xred,natom,ibp,iband,ikpt,ikptq,qq,igg0,ngkpt, &\n!&               pwmatel(:,:,ipw1,ix,iy,iz),tpwmatel(:,:,ipw1,ix,iy,iz), &\n!&               projwf,nlmn,nkpt,nkpt,ncband,amatel)\n        else\n          amatel=(0.d0,0.d0)\n        endif\n        if (ipw1.eq.ipw2) then\n          cmatel2=cmatel\n          amatel2=amatel\n        else\n          call mkmatelx(ibp,iband,ikpt,ikptq,ipwx(:,ipw2),igh, &\n&         ncg,ncg,nkpt,nkpt,npwt,npwt,igmx,igmn,igndx,igndx, &\n&         isym,isymq,symrel,syminv,nsym,nsym,ihlf,ihlf,kpt,kpt, &\n&         lvtrans(1:3,ikk(1),ikk(2),ikk(3)),lvtrans(1:3,ikk(1),ikk(2),ikk(3)), &\n&         cg,cg,indxkcg,indxkcg,indxkpw,indxkpw,npwarr,npwarr,kg,kg, &\n&         cmatel2)\n          if (ipaw.ne.0) then\n!            call mkmatelp(pi,xred,natom,ibp,iband,ikpt,ikptq,qp,igg0,ngkpt, &\n!&                 pwmatel(:,:,ipw2,ix,iy,iz),tpwmatel(:,:,ipw2,ix,iy,iz), &\n!&                 projwf,nlmn,nkpt,nkpt,ncband,amatel2)\n          else\n            amatel2=(0.d0,0.d0)\n          endif\n        endif\n        omega(ix,iy,iz)=enrgy(indxkbnd(ikptq)+ibp)-ek+dw/2\n      endif\n      xmat2(ix,iy,iz)=(cmatel+amatel)*conjg(cmatel2+amatel2)\n      vqmat2(ix,iy,iz)=xmat2(ix,iy,iz)*vq(ix,iy,iz)\n!write(6,*) 'cmatel  = ',cmatel\n!write(6,*) 'amatel  = ',amatel\n!write(6,*) 'cmatel+amatel  = ',cmatel+amatel\n!write(6,*) '|cmatel+amatel|^2  = ',dble((cmatel+amatel)*conjg(cmatel+amatel))\n!write(6,*) 'cmatel2 = ',cmatel2\n!write(6,*) 'vqmat2 = ',vqmat2(iqq(1),iqq(2),iqq(3))\n!write(56,*) '>>>>>',iqq,vqmat2(iqq(1),iqq(2),iqq(3))\n!      stvec(iqq(3))=vq(ix,iy,iz)\n!      stvec(iqq(3))=sqrt(qq2)\n!      stvec(iqq(3))=dble(vqmat2(iqq(1),iqq(2),iqq(3)))\n!      stvec2(iqq(3))=dimag(vqmat2(iqq(1),iqq(2),iqq(3)))\n!      stvec(iqq(3))=dble(cmatel)\n!      stvec2(iqq(3))=dimag(cmatel)\n!      stvec(iqq(3))=dble(cmatel2)\n!      stvec2(iqq(3))=dimag(cmatel2)\n!      stvec(iqq(3))=dble(cmatel*conjg(cmatel))\n!      stvec(iqq(3))=dble(amatel*conjg(amatel))\n!      stvec(iqq(3))=dble((cmatel+amatel)*conjg(cmatel+amatel))\n!      temparray(ix,iy,iz)=temparray(ix,iy,iz)+stvec(iqq(3))\n    enddo\n!    write(76,'(10f8.2)') stvec(:)\n!    write(76,'(10es8.1)') stvec(:)\n!    write(76,'(10es8.1)') stvec2(:)\n!    write(76,'(10f8.5)') 10.d0**(log10(stvec(:))-int(log10(stvec(:))))\n!    write(76,*) \n    enddo\n!    write(76,*) iqq(1)+1,'--------------------------------------------------',ibp\n    enddo\n!stop\n\n    if (itetrahedron.eq.0) then\n! sum over points - faster, less accurate\n! doesn't work yet, needs debugging\n      brd=dw ! broadening for sum\n      wint0=(0.d0,0.d0)\n      w2int0=(0.d0,0.d0)\n      cse0=(0.d0,0.d0)\n      dcse0=(0.d0,0.d0)\n      xse0=0.d0\n\n! determine if singular integration is required\n      if (ipw1.eq.1.or.ipw2.eq.1) then\n        ix=ngkpt(1)/2\n        iy=ngkpt(2)/2\n        iz=ngkpt(3)/2\n        qadj(1)=abs(vqmat2(ix,iy,iz)/vqmat2(ix+1,iy,iz))\n        qadj(2)=abs(vqmat2(ix,iy,iz)/vqmat2(ix-1,iy,iz))\n        qadj(3)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy+1,iz))\n        qadj(4)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy-1,iz))\n        qadj(5)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy,iz+1))\n        qadj(6)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy,iz-1))\n        if (qadj(1).gt.1.d1.and.qadj(2).gt.1.d1.and.qadj(3).gt.1.d1.and.  &\n&           qadj(4).gt.1.d1.and.qadj(5).gt.1.d1.and.qadj(6).gt.1.d1) then\n          lqsing=.true.\n          iqq=(/ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2/)\n          iqpt=iqndx(iqq(1),iqq(2),iqq(3))\n          call locateelement(iqq,ipw1,ipw2,ngkpt,iqsymndx,npwc,npwx,nsym,pwsymndx,invpw2ndx,jjpw)\n          if (jjpw.ne.0) then\n            do iw=1,nwpt\n              ww=iw*dw\n              eval=omega(iqq(1),iqq(2),iqq(3))-ocsign*ww-dw/2\n              wint0=wint0+dw*dimag(lossfn(iw,iqpt,jjpw))/cmplx(eval,brd)\n              w2int0=w2int0-dw*dimag(lossfn(iw,iqpt,jjpw))/cmplx(eval,brd)**2\n            enddo\n          endif\n        else\n          lqsing=.false.\n        endif\n      else\n        lqsing=.false.\n      endif\n      \n      if (lc) then\n        do ix=1,ngkpt(1)\n        do iy=1,ngkpt(2)\n        do iz=1,ngkpt(3)\n          iqq=(/ix,iy,iz/)\n          iqpt=iqndx(iqq(1),iqq(2),iqq(3))\n          call locateelement(iqq,ipw1,ipw2,ngkpt,iqsymndx,npwc,npwx,nsym,pwsymndx,invpw2ndx,jjpw)\n          wint=(0.d0,0.d0)\n          w2int=(0.d0,0.d0)\n          do iw=1,nwpt\n            ww=iw*dw\n            eval=omega(ix,iy,iz)-ocsign*ww-dw/2\n            wint=wint+dw*dimag(lossfn(iw,iqpt,jjpw))/cmplx(eval,brd)\n            w2int=w2int-dw*dimag(lossfn(iw,iqpt,jjpw))/cmplx(eval,brd)**2\n          enddo\n          if (lqsing) then\n            qq2=4.d0*pi/vq(ix,iy,iz)\n            if (sqrt(qq2).lt.gfo) then\n              if (ix.eq.ngkpt(1)/2.and.iy.eq.ngkpt(2)/2.and.iz.eq.ngkpt(3)/2) cycle\n              gterm=xmat2(ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2)*(1+cos(pi*sqrt(qq2)/gfo))/(2.d0)\n              if (lx) xse0=xse0+vqmat2(ix,iy,iz)-gterm*vq(ix,iy,iz)\n              cse0=cse0+wint*vqmat2(ix,iy,iz)-wint0*gterm*vq(ix,iy,iz)\n              dcse0=dcse0+w2int*vqmat2(ix,iy,iz)-w2int0*gterm*vq(ix,iy,iz)\n            else\n              if (lx) xse0=xse0+vqmat2(ix,iy,iz)\n              cse0=cse0+wint*vqmat2(ix,iy,iz)\n              dcse0=dcse0+w2int*vqmat2(ix,iy,iz)\n            endif\n          else\n            if (lx) xse0=xse0+vqmat2(ix,iy,iz)\n            cse0=cse0+wint*vqmat2(ix,iy,iz)\n            dcse0=dcse0+w2int*vqmat2(ix,iy,iz)\n          endif\n        enddo\n        enddo\n        enddo\n        cse0=cse0/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol*pi)\n        dcse0=dcse0/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol*pi)\n        if (lx) xse0=xse0/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol*pi)\n      elseif (lx) then\n        do ix=1,ngkpt(1)\n        do iy=1,ngkpt(2)\n        do iz=1,ngkpt(3)\n          if (lqsing) then\n            qq2=4.d0*pi/vq(ix,iy,iz)\n            if (sqrt(qq2).lt.gfo) then\n              if (ix.eq.ngkpt(1)/2.and.iy.eq.ngkpt(2)/2.and.iz.eq.ngkpt(3)/2) cycle\n              gterm=xmat2(ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2)*(1+cos(pi*sqrt(qq2)/gfo))/(2.d0)\n              xse0=xse0+vqmat2(ix,iy,iz)-gterm*vq(ix,iy,iz)\n            else\n              xse0=xse0+vqmat2(ix,iy,iz)\n            endif\n          else\n            xse0=xse0+vqmat2(ix,iy,iz)\n          endif\n        enddo\n        enddo\n        enddo\n        xse0=xse0/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol*pi)\n      endif\n\n      if (lqsing) then\n        if (lx) xse0=xse0+xmat2(ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2)*8.d0*pi*gfo/((2.d0*pi)**3)\n        if (lc) cse0=cse0+wint0*xmat2(ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2)*8.d0*pi*gfo/((2.d0*pi)**3)\n        if (lc) dcse0=dcse0+w2int0*xmat2(ngkpt(1)/2,ngkpt(2)/2,ngkpt(3)/2)*8.d0*pi*gfo/((2.d0*pi)**3)\n      endif\n\n      if (lc) cse=cse-cse0\n      if (lc) dcse=dcse-dcse0\n      if (lx) xse=xse-xse0*pi\n\n    else \n! tetrahedron integration\n\n! don't waste time integrating over energies with no contribution\n      do ix=1,ngkpt(1)\n      do iy=1,ngkpt(2)\n      do iz=1,ngkpt(3)\n        iqq=(/ix,iy,iz/)\n        call fhilo(omega,iqq,ngkpt,whi,wlo)\n        if (ix.eq.1.and.iy.eq.1.and.iz.eq.1) then\n          wwhi=whi\n          wwlo=wlo\n        else\n          wwhi=max(wwhi,whi)\n          wwlo=min(wwlo,wlo)\n        endif\n      enddo\n      enddo\n      enddo\n\n      iwlo=nint(wwlo*dble(nwpt)/wmax)\n      iwhi=nint(wwhi*dble(nwpt)/wmax)\n      if (ibp.gt.nbocc) then\n        ielo=iwlo+1\n        iehi=iwhi+nwpt\n      else\n        ielo=iwlo-nwpt\n        iehi=iwhi-1\n      endif\n      allocate (ssi(ielo:iehi))\n      do ie=ielo,iehi\n        ssi(ie)=0.d0\n      enddo\n      ssx=0.d0\n\n      if (lc) then\n        do iw=1,nwpt\n          do ix=1,ngkpt(1)\n          do iy=1,ngkpt(2)\n          do iz=1,ngkpt(3)\n            iqq=(/ix,iy,iz/)\n            iqpt=iqndx(iqq(1),iqq(2),iqq(3))\n            call locateelement(iqq,ipw1,ipw2,ngkpt,iqsymndx,npwc,npwx,nsym,pwsymndx,invpw2ndx,jjpw)\n            if (jjpw.ne.0) then\n              vfactor(iqq(1),iqq(2),iqq(3),iw)=vqmat2(iqq(1),iqq(2),iqq(3))*max(dimag(lossfn(iw,iqpt,jjpw)),0.d0)\n            else\n              vfactor(iqq(1),iqq(2),iqq(3),iw)=(0.d0,0.d0)\n            endif\n          enddo\n          enddo\n          enddo\n        enddo\n      endif\n\n! determine if singular integration is required\n      if (ipw1.eq.1.or.ipw2.eq.1) then\n        ix=ngkpt(1)/2\n        iy=ngkpt(2)/2\n        iz=ngkpt(3)/2\n        qadj(1)=abs(vqmat2(ix,iy,iz)/vqmat2(ix+1,iy,iz))\n        qadj(2)=abs(vqmat2(ix,iy,iz)/vqmat2(ix-1,iy,iz))\n        qadj(3)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy+1,iz))\n        qadj(4)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy-1,iz))\n        qadj(5)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy,iz+1))\n        qadj(6)=abs(vqmat2(ix,iy,iz)/vqmat2(ix,iy,iz-1))\n        if (qadj(1).gt.1.d1.and.qadj(2).gt.1.d1.and.qadj(3).gt.1.d1.and.  &\n&           qadj(4).gt.1.d1.and.qadj(5).gt.1.d1.and.qadj(6).gt.1.d1) then\n          lqsing=.true.\n        else\n          lqsing=.false.\n        endif\n      else\n        lqsing=.false.\n      endif\n  \n! do the integration\n      do ix=1,ngkpt(1)\n      do iy=1,ngkpt(2)\n      do iz=1,ngkpt(3)\n!      do ix=1,1\n!      do iy=1,1\n!      do iz=9,9\n!      do ix=1,1\n!      do iy=1,1\n!      do iz=1,1\n        iqq=(/ix,iy,iz/)\n        ssx1=ssx\n        call fval(omega,iqq,iqqp,ngkpt,enval)\n        if (lqsing) call fval(vq,iqq,iqqp,ngkpt,vq2)\n        if (lc) then\n          do iw=1,nwpt\n            call fpol(vfactor(:,:,:,iw),ngkpt,iqq,iqqp,vfv(:,iw))\n          enddo\n        endif\n        if (lx) call fpol(vqmat2(:,:,:),ngkpt,iqq,iqqp,vfx)\n        do itet=1,6\n!        do itet=2,2\n          ssx2=ssx\n          lqcentr=.false.\n!          lqcentr=.true.\n          do iv=1,4\n            evtx0(iv)=enval(ivndx(iv,itet))\n            rrpyr(1:3,iv)=rr(1:3,ivndx(iv,itet))\n            if (lc) then\n              do iw=1,nwpt\n                vpyr0(iv,iw)=vfv(ivndx(iv,itet),iw)\n              enddo\n            endif\n            if (lx) xpyr0(iv)=vfx(ivndx(iv,itet))\n            if (lqsing) vqvtx0(iv)=vq2(ivndx(iv,itet))\n            if (lqsing.and..not.lqcentr) then\n              iqv=iqq+nint(rrpyr(:,iv))\n              if (iqv(1).eq.ictr(1).and.iqv(2).eq.ictr(2).and.iqv(3).eq.ictr(3)) then\n                lqcentr=.true.\n                iqcentr=iv\n              endif\n            endif\n          enddo\n          call indxhpsort(4,4,evtx0,indxe)\n          evtx=evtx0(indxe)    ! order vertices by energy\n          jqcentr=indxe(iqcentr)\n!          kvtx(1:3,1:4)=rrpyr(1:3,indxe)\n          do ii=1,4\n            jj=indxe(ii)\n!            kvtx(:,ii)=rrpyr(:,jj)+iqq-ictr\n            do kk=1,3\n              kvtx(kk,ii)=dot_product(iqq+rrpyr(:,jj)-ictr,qkcvt(:,kk))\n!              kvtx(kk,ii)=dot_product(iqq+rrpyr(:,jj)-ictr+ipwx(:,ipw1)*ngkpt,qkcvt(:,kk))\n            enddo\n          enddo\n          xk(1:3,1)=(/0.d0,0.d0,0.d0/)\n          do ii=2,4\n            xk(1:3,ii)=kvtx(1:3,ii)-kvtx(1:3,1)\n          enddo\n          call cross(xk(:,3),xk(:,4),vdum)\n          tvol=dot_product(vdum,xk(:,2))\n          do jj=1,3  ! make contragradient\n            call cross(xk(1:3,mod(jj,3)+2),xk(1:3,mod(jj+1,3)+2),rg(1:3,jj))\n          enddo\n          rg=rg/tvol\n          tvol=abs(tvol)\n          iwwlim=nint(evtx/dw)\n          de21=evtx(2)-evtx(1)\n          de31=evtx(3)-evtx(1)\n          de32=evtx(3)-evtx(2)\n          de41=evtx(4)-evtx(1)\n          de42=evtx(4)-evtx(2)\n          de43=evtx(4)-evtx(3)\n          thresh=1.d-5*de41\n          if (lqcentr) then\n            bgrad=(/0.d0,0.d0,0.d0/)   ! energy gradient\n            do jj=1,3\n              bgrad=bgrad+(evtx(jj+1)-evtx(1))*rg(:,jj)\n            enddo\n            xmult=4.d0*pi/norm2(bgrad)\n            if (lc) then\n              do iw=1,nwpt\n                aa0(iw)=xmat2(ictr(1),ictr(2),ictr(3))*max(dimag(lossfn(iw,iqctr,1)),0.d0)\n                vpyr0(:,iw)=vpyr0(:,iw)-aa0(iw)*vqvtx0(:)\n                vpyr0(iqcentr,iw)=0.d0\n              enddo\n            endif\n            if (lx) then\n              xme=dble(xmat2(ictr(1),ictr(2),ictr(3)))\n              xpyr0=xpyr0-xme*vqvtx0\n              xpyr0(iqcentr)=0.d0\n            endif\n            do iww=iwwlim(1),iwwlim(2) ! energies between evtx(1) & evtx(2)\n              wwwlo=max(dw*(iww-0.5d0),evtx(1))\n              wwwhi=min(dw*(iww+0.5d0),evtx(2))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              call wsinggrater(wwwlo,wwwhi,1,0,xk,kvtx(:,1),evtx,abr,rlr,sint1)\n              sint1=sint1*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ssi(iww-ocsign*iw)=ssi(iww-ocsign*iw)+aa0(iw)*sint1\n                enddo\n              endif\n              if (lx) ssx=ssx+xme*sint1\n            enddo\n            do iww=iwwlim(2),iwwlim(3) ! energies between evtx(2) & evtx(3)\n              wwwlo=max(dw*(iww-0.5d0),evtx(2))\n              wwwhi=min(dw*(iww+0.5d0),evtx(3))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              if (de21.lt.thresh.and.de43.lt.thresh) then\n                call  w2singgrater(wwwlo,wwwhi,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n                sint1a=0.d0\n              elseif (de21.ge.de43) then\n                call wsinggrater(wwwlo,wwwhi,2,0,xk,kvtx(:,1),evtx,abr,rlr,sint1a)\n                call wsinggrater(wwwlo,wwwhi,1,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n              else\n                call wsinggrater(wwwlo,wwwhi,3,0,xk,kvtx(:,1),evtx,abr,rlr,sint1a)\n                call wsinggrater(wwwlo,wwwhi,4,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n              endif\n              sint1=(sint1b-sint1a)*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ssi(iww-ocsign*iw)=ssi(iww-ocsign*iw)+aa0(iw)*sint1\n                enddo\n              endif\n              if (lx) ssx=ssx+xme*sint1\n            enddo\n            do iww=iwwlim(3),iwwlim(4) ! energies between evtx(3) & evtx(4)\n              wwwlo=max(dw*(iww-0.5d0),evtx(3))\n              wwwhi=min(dw*(iww+0.5d0),evtx(4))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              call wsinggrater(wwwlo,wwwhi,4,0,xk,kvtx(:,1),evtx,abr,rlr,sint1)\n              sint1=sint1*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ssi(iww-ocsign*iw)=ssi(iww-ocsign*iw)+aa0(iw)*sint1\n                enddo\n              endif\n              if (lx) ssx=ssx+xme*sint1\n            enddo\n          endif\n!          if (lqcentr) then            ! integral around coulomb singularity\n!          if (.true.) then\n          if (.false.) then\n            bgrad=(/0.d0,0.d0,0.d0/)   ! energy gradient\n            do jj=1,3\n              bgrad=bgrad+(evtx(jj+1)-evtx(1))*rg(:,jj)\n            enddo\n            xmult=4.d0*pi/norm2(bgrad)\n            if (lc) then\n              do iw=1,nwpt\n                vpyr(:)=vpyr0(:,iw)/vqvtx0\n                aa0(iw)=vpyr(indxe(1))\n                av(1:3,iw)=(/0.d0,0.d0,0.d0/)\n                do jj=1,3\n                  av(1:3,iw)=av(1:3,iw) &\n&                           +(vpyr(indxe(jj+1))-vpyr(indxe(1)))*rg(1:3,jj)\n                enddo\n              enddo\n            endif\n            if (lx) then\n              xpyr=xpyr0/vqvtx0\n              xme=xpyr(indxe(1))\n              xv=(/0.d0,0.d0,0.d0/)\n              do jj=1,3\n                xv=xv+(xpyr(indxe(jj+1))-xpyr(indxe(1)))*rg(:,jj)\n              enddo\n            endif\n            do iww=iwwlim(1),iwwlim(2) ! energies between evtx(1) & evtx(2)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(1))\n              wwwhi=min(dw*(iww+0.5d0),evtx(2))\n              call wsinggrater(wwwlo,wwwhi,1,0,xk,kvtx(:,1),evtx,abr,rlr,sint1)\nwrite(6,*) iww\n              call wsinggrater(wwwlo,wwwhi,1,1,xk,kvtx(:,1),evtx,abr,rlr,svec(1))\n              call wsinggrater(wwwlo,wwwhi,1,2,xk,kvtx(:,1),evtx,abr,rlr,svec(2))\n              call wsinggrater(wwwlo,wwwhi,1,3,xk,kvtx(:,1),evtx,abr,rlr,svec(3))\n              sint1=sint1*xmult\n              svec=svec*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') '1  t',itet,iww,ssx-ssx3\n            enddo\n            do iww=iwwlim(2),iwwlim(3) ! energies between evtx(2) & evtx(3)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(2))\n              wwwhi=min(dw*(iww+0.5d0),evtx(3))\n              if (de21.lt.thresh.and.de43.lt.thresh) then\nlabel='2a t'\n                call  w2singgrater(wwwlo,wwwhi,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n                call  w2singgrater(wwwlo,wwwhi,1,xk,kvtx(:,1),evtx,abr,rlr,svecb(1))\n                call  w2singgrater(wwwlo,wwwhi,2,xk,kvtx(:,1),evtx,abr,rlr,svecb(2))\n                call  w2singgrater(wwwlo,wwwhi,3,xk,kvtx(:,1),evtx,abr,rlr,svecb(3))\n                sint1a=0.d0\n                sveca=(/0.d0,0.d0,0.d0/)\n              elseif (de21.ge.de43) then\nlabel='2b t'\n                call wsinggrater(wwwlo,wwwhi,2,0,xk,kvtx(:,1),evtx,abr,rlr,sint1a)\n                call wsinggrater(wwwlo,wwwhi,2,1,xk,kvtx(:,1),evtx,abr,rlr,sveca(1))\n                call wsinggrater(wwwlo,wwwhi,2,2,xk,kvtx(:,1),evtx,abr,rlr,sveca(2))\n                call wsinggrater(wwwlo,wwwhi,2,3,xk,kvtx(:,1),evtx,abr,rlr,sveca(3))\n                call wsinggrater(wwwlo,wwwhi,1,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n                call wsinggrater(wwwlo,wwwhi,1,1,xk,kvtx(:,1),evtx,abr,rlr,svecb(1))\n                call wsinggrater(wwwlo,wwwhi,1,2,xk,kvtx(:,1),evtx,abr,rlr,svecb(2))\n                call wsinggrater(wwwlo,wwwhi,1,3,xk,kvtx(:,1),evtx,abr,rlr,svecb(3))\n              else\nlabel='2c t'\n                call wsinggrater(wwwlo,wwwhi,3,0,xk,kvtx(:,1),evtx,abr,rlr,sint1a)\n                call wsinggrater(wwwlo,wwwhi,3,1,xk,kvtx(:,1),evtx,abr,rlr,sveca(1))\n                call wsinggrater(wwwlo,wwwhi,3,2,xk,kvtx(:,1),evtx,abr,rlr,sveca(2))\n                call wsinggrater(wwwlo,wwwhi,3,3,xk,kvtx(:,1),evtx,abr,rlr,sveca(3))\n                call wsinggrater(wwwlo,wwwhi,4,0,xk,kvtx(:,1),evtx,abr,rlr,sint1b)\n                call wsinggrater(wwwlo,wwwhi,4,1,xk,kvtx(:,1),evtx,abr,rlr,svecb(1))\n                call wsinggrater(wwwlo,wwwhi,4,2,xk,kvtx(:,1),evtx,abr,rlr,svecb(2))\n                call wsinggrater(wwwlo,wwwhi,4,3,xk,kvtx(:,1),evtx,abr,rlr,svecb(3))\n              endif\n              sint1=(sint1b-sint1a)*xmult\n              svec=(svecb-sveca)*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') label,itet,iww,ssx-ssx3\n            enddo\n            do iww=iwwlim(3),iwwlim(4) ! energies between evtx(3) & evtx(4)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(3))\n              wwwhi=min(dw*(iww+0.5d0),evtx(4))\n              call wsinggrater(wwwlo,wwwhi,4,0,xk,kvtx(:,1),evtx,abr,rlr,sint1)\n              call wsinggrater(wwwlo,wwwhi,4,1,xk,kvtx(:,1),evtx,abr,rlr,svec(1))\n              call wsinggrater(wwwlo,wwwhi,4,2,xk,kvtx(:,1),evtx,abr,rlr,svec(2))\n              call wsinggrater(wwwlo,wwwhi,4,3,xk,kvtx(:,1),evtx,abr,rlr,svec(3))\n              sint1=sint1*xmult\n              svec=svec*xmult\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') '3  t',itet,iww,ssx-ssx3\n            enddo\n          else                         ! non-singular, tetrahedron method\n            fbx(1)=tvol/(6.d0*de21*de31*de41)\n            if (de21.ge.de43) then\n              fbx(2)=tvol/(6.d0*de21*de32*de42)\n            else\n              fbx(3)=tvol/(6.d0*de31*de32*de43)\n            endif\n            fbx(4)=tvol/(6.d0*de41*de42*de43)\n            do ii=1,4\n              cmx(1:3,ii)=(/0.d0,0.d0,0.d0/)\n              do jj=1,4\n                if (jj.ne.ii) cmx(1:3,ii)=cmx(1:3,ii)+(xk(1:3,jj)-xk(1:3,ii)) &\n&                                                    /(4*(evtx(jj)-evtx(ii)))\n              enddo\n            enddo\n            if (lc) then\n              do iw=1,nwpt\n                aa0(iw)=vpyr0(indxe(1),iw)   ! base value of function\n                av(1:3,iw)=(/0.d0,0.d0,0.d0/) ! gradient of function\n                do jj=1,3\n                  av(1:3,iw)=av(1:3,iw) &\n&                           +(vpyr0(indxe(jj+1),iw)-vpyr0(indxe(1),iw))*rg(1:3,jj)\n                enddo\n              enddo\n            endif\n            if (lx) then\n              xme=xpyr0(indxe(1))\n              xv=(/0.d0,0.d0,0.d0/)\n              do jj=1,3\n                xv=xv+(xpyr0(indxe(jj+1))-xpyr0(indxe(1)))*rg(:,jj)\n              enddo\n            endif\n            do iww=iwwlim(1),iwwlim(2) ! energies between evtx(1) & evtx(2)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(1))\n              wwwhi=min(dw*(iww+0.5d0),evtx(2))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              sint1=fbx(1)*((wwwhi-evtx(1))**3-(wwwlo-evtx(1))**3)\n              svec=xk(:,1)*sint1 &\n&                 +fbx(1)*cmx(:,1)*((wwwhi-evtx(1))**4-(wwwlo-evtx(1))**4)\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') '1  f',itet,iww,ssx-ssx3\n            enddo\n            do iww=iwwlim(2),iwwlim(3) ! energies between evtx(2) & evtx(3)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(2))\n              wwwhi=min(dw*(iww+0.5d0),evtx(3))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              if (de21.lt.thresh.and.de43.lt.thresh) then\nlabel='2a f'\n                sint1=(tvol/(6.d0*de31**2)) &\n&                    *(3.d0*((wwwhi-evtx(1))**2-(wwwlo-evtx(1))**2) &\n&                     -2.d0*((wwwhi-evtx(1))**3-(wwwlo-evtx(1))**3)/de31)\n                svec=xk(:,2)*sint1 &\n&                   -(tvol/(24.d0*de31**4)) &\n&                    *((wwwhi-evtx(1))**4-(wwwlo-evtx(1))**4) &\n&                    *(xk(:,3)+xk(:,4)-2.d0*xk(:,2))\n              elseif (de21.ge.de43) then\nlabel='2b f'\n                fb(1)=fbx(1)*((wwwhi-evtx(1))**3-(wwwlo-evtx(1))**3)\n                fb(2)=fbx(2)*((wwwhi-evtx(2))**3-(wwwlo-evtx(2))**3)\n                sint1=fb(1)-fb(2)\n                svec=xk(:,1)*fb(1)-xk(:,2)*fb(2) &\n&                   +fbx(1)*cmx(:,1)*((wwwhi-evtx(1))**4-(wwwlo-evtx(1))**4) &\n&                   -fbx(2)*cmx(:,2)*((wwwhi-evtx(2))**4-(wwwlo-evtx(2))**4)\n              else\nlabel='2c f'\n                fb(3)=fbx(3)*((wwwhi-evtx(3))**3-(wwwlo-evtx(3))**3)\n                fb(4)=fbx(4)*((wwwhi-evtx(4))**3-(wwwlo-evtx(4))**3)\n                sint1=fb(4)-fb(3)\n                svec=xk(:,4)*fb(4)-xk(:,3)*fb(3) &\n&                   +fbx(4)*cmx(:,4)*((wwwhi-evtx(4))**4-(wwwlo-evtx(4))**4) &\n&                   -fbx(3)*cmx(:,3)*((wwwhi-evtx(3))**4-(wwwlo-evtx(3))**4)\n              endif\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') label,itet,iww,ssx-ssx3\n            enddo\n            do iww=iwwlim(3),iwwlim(4) ! energies between evtx(3) & evtx(4)\n!ssx3=ssx\n              wwwlo=max(dw*(iww-0.5d0),evtx(3))\n              wwwhi=min(dw*(iww+0.5d0),evtx(4))\n              if (abs(wwwhi-wwwlo)*1.d14.lt.max(abs(wwwhi),abs(wwwlo),dw)) cycle\n              sint1=fbx(4)*((wwwhi-evtx(4))**3-(wwwlo-evtx(4))**3)\n              svec=xk(:,4)*sint1 &\n&                 +fbx(4)*cmx(:,4)*((wwwhi-evtx(4))**4-(wwwlo-evtx(4))**4)\n              if (lc) then\n                do iw=1,nwpt\n                  ie=iww-ocsign*iw\n                  ssi(ie)=ssi(ie)+(aa0(iw)*sint1+dot_product(av(:,iw),svec))\n                enddo\n              endif\n              if (lx) ssx=ssx+(xme*sint1+dot_product(xv,svec))\n!write(6,'(a,2i3,f16.8)') '3  f',itet,iww,ssx-ssx3\n            enddo\n          endif\n!if (lqcentr) then\n!write(48,'(3i3,3x,i3,f16.8,3x,a)') ix,iy,iz,itet,ssx-ssx2,'t'\n!else\n!write(48,'(3i3,3x,i3,f16.8,3x,a)') ix,iy,iz,itet,ssx-ssx2,'f'\n!endif\n        enddo\n!      temparray(ix,iy,iz)=(ssx-ssx1)/((2*pi)**3)\n      enddo\n      enddo\n      enddo\n!    if (lc) ssi=-ssi/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol*pi)\n!    if (lx) ssx=-ssx/(dble(ngkpt(1)*ngkpt(2)*ngkpt(3))*vol)\n      if (lc) ssi=-ocsign*ssi/((2*pi)**3*pi)\n      if (lx) ssx=-ssx/((2*pi)**3)\n  \n      if (lc) then\n        do ie=-nwpt,nwpt\n          eps1=dble(ie)*dw-dw/2\n!        ssc(ie)=(0.d0,0.d0)\n          do je=ielo,iehi\n            if (ie.eq.je) then\n              ssc(ie)=ssc(ie)+(0.d0,1.d0)*pi*ssi(je)\n            else\n              eps2=dble(je)*dw-dw/2\n              ssc(ie)=ssc(ie)+ocsign*ssi(je)*dw/(eps2-eps1)\n            endif\n!if (ie.eq.0) write(16,'(2i4,2f10.3,es12.3,2(2x,2es11.3))') ie,je,eps1*27.2114,eps2*27.2114,1/(eps2-eps1),ssc(ie)*27.2114,dble(ssi(je)*27.2114)\n          enddo\n        enddo\n      endif\n      deallocate (ssi)\n\n      if (lc) cse1=cse1+ssc\n      if (lx) xse=xse+ssx\n!      if (lx.and.lc) then\n!        write(6,'(i4,4x,i5,2i3,3x,3i3,5x,\"(\",f10.6,\",\",f10.6,\")\",5x,f10.6)')  &\n!&            ibp,iipw,ipw1,ipw2,ipwx(:,ipw1),((ssc(1)+ssc(0))/2)*27.2114,dble(ssx)*27.2114\n!      elseif (lc) then\n!        write(6,'(i4,4x,i5,2i3,3x,3i3,5x,\"(\",f10.6,\",\",f10.6,\")\")') ibp,iipw,ipw1,ipw2,ipwx(:,ipw1), &\n!&            ((ssc(1)+ssc(0))/2)*27.2114\n!      else\n!        write(6,'(i4,4x,i5,2i3,3x,3i3,28x,5x,f10.6)')  &\n!&            ibp,iipw,ipw1,ipw2,ipwx(:,ipw1),dble(ssx)*27.2114\n!      endif\n    endif\n\n  enddo\n!  if (lx) then\n!    write(6,'(i4,5x,\"(\",f10.6,\",\",f10.6,\")\",5x,f10.6)') ibp, &\n!& (cse1(1)+cse1(0)-cse2(1)-cse2(0))*27.2114/2.d0, &\n!& dble(xse-xse2)*27.2114\n!  else\n!    write(6,'(i4,5x,\"(\",f10.6,\",\",f10.6,\")\",f10.6)') ibp, &\n!& (cse1(1)+cse1(0)-cse2(1)-cse2(0))*27.2114/2.d0\n!  endif\nenddo\n\ndo ie=-nwpt,nwpt\n  eps1=dble(ie)*dw-dw/2\n!  write(12,'(i4,f10.3,2(3x,2es12.3))') ie,eps1*27.2114,cse1(ie)*27.2114\nenddo\nif (itetrahedron.eq.1) then\n  cse=(cse1(0)+cse1(1))/2\n  dcse=(cse1(1)-cse1(0))/dw\nendif\nzz=1.d0/(1.d0-dcse)\n!write(6,*) cse*27.2114\n!write(6,*) xse*27.2114\n!write(6,*) zz\n!write(6,*) dble(zz)*dimag(cse)*27.2114\n\n!temparray=log10(temparray)\n!temparray=10**(temparray-int(temparray))\n!do ix=1,ngkpt(1)\n!  write(76,*) ix,'--------------------------------------------------'\n!  do iy=1,ngkpt(2)\n!!    write(76,'(10es8.1)') dble(temparray(ix,iy,:))\n!    write(76,'(10f8.5)') dble(temparray(ix,iy,:))\n!  enddo\n!enddo\n\nreturn\nend subroutine mk3cse\n"}
{"id": 50, "subroutine": "subroutine wsinggrater(wmin,wmax,ive,isn,xk,xkvtx,evtx,abr,rlr,sint)\nimplicit none\ninteger :: numcal,maxns,mx,nstack,ii,jj,kk,icount,ive,isn\nparameter (mx=1500)\ndouble precision :: xk(3,4),xkvtx(3),evtx(4),sint\ndouble precision :: value,valu,fval(3,mx)\ndouble precision :: wmin,wmax,del,del1,dif,frac\ndouble precision :: abr,rlr,error\ndouble precision :: wleft(mx),dw(3),wt(3),ww\ndouble precision :: wt9(9)\nlogical :: atsing\nsave dw,wt,wt9\ndata dw /0.1127016653792583,0.5,0.8872983346207417/\ndata wt /0.277777777777777778,0.4444444444444444444,0.2777777777777777778/\ndata wt9 /0.0616938806304841571,0.108384229110206161,         &\n&           0.0398463603260281088,0.175209035316976464,      &\n&           0.229732989232610220,0.175209035316976464,       &\n&           0.0398463603260281088,0.108384229110206161,      &\n&           0.0616938806304841571  /\n\n! nstack is the number of different intervals into which the\n! integration region is currently divided. the number of regions can\n! grow if more accuracy is needed by dividing the right-most region\n! into three regions. the number of regions shrinks when the integral\n! over the right-most region is accurate enough, in which case that\n! integral is added to the total (stored in grater) and the region\n! is removed from consideration (and a new region is the right-most)\n  nstack=1\n  maxns=nstack\n  error=0.d0\n  sint=0.d0\n! the array xleft stores the boundary points of the regions.\n  wleft(1)=wmin\n  wleft(2)=wmax\n! for each region, calculate the function and store at three selected points.\n  do ii=1,nstack\n    del=wleft(ii+1)-wleft(ii)\n    do jj=1,3\n      ww=wleft(ii)+del*dw(jj)\n      call sing1int(ive,isn,ww,xk,xkvtx,evtx,fval(jj,ii))\n    enddo\n  enddo\n  numcal=nstack*3\n  do\n    if(nstack+3.ge.mx) then\n      write(6,*) 'wsinggrater: too many regions'\n      stop\n    endif\n! divide the rightmost region into three subregions.\n    del=wleft(nstack+1)-wleft(nstack)\n    wleft(nstack+3)=wleft(nstack+1)\n    wleft(nstack+1)=wleft(nstack)+del*dw(1)*2.d0\n    wleft(nstack+2)=wleft(nstack+3)-del*dw(1)*2.d0\n! the three data points already found for the region become the\n! middle data points (number 2 in first index of fval) for each region.\n    fval(2,nstack+2)=fval(3,nstack)\n    fval(2,nstack+1)=fval(2,nstack)\n    fval(2,nstack)=fval(1,nstack)\n! now do the integral over the right-most region in two different ways-\n! a three point integral (valu) over each of the three subregions\n! and a more accurate nine-point integral (value) over whole region.\n! valu is used only for the error estimate.\n    icount=0\n    value=0.d0\n    valu=0.d0\n    do jj=nstack,nstack+2\n      del1=wleft(jj+1)-wleft(jj)\n      ww=wleft(jj)+dw(1)*del1\n      call sing1int(ive,isn,ww,xk,xkvtx,evtx,fval(1,jj))\n      ww=wleft(jj)+dw(3)*del1\n      call sing1int(ive,isn,ww,xk,xkvtx,evtx,fval(3,jj))\n      numcal=numcal+2\n!if (numcal.gt.1000) stop\n      do kk=1,3\n        icount=icount+1\n        value=value+wt9(icount)*fval(kk,jj)*del\n        valu=valu+fval(kk,jj)*wt(kk)*del1\n      enddo\n    enddo\n    dif=abs(value-valu)\n! if the following condition is true, add in this integral to the total,\n! and reduce the number of regions under consideration.\n    frac=del/(wmax-wmin)\n    atsing=.false.\n    if (frac.le.1.0d-8) atsing=.true.\n    if (dif.le.abr*frac.or.dif.le.rlr*abs(value).or. &\n&        (atsing.and.(frac.le.1.0d-15.or.dif.le.abr*0.1))) then\n      sint=sint+value\n      error=error+abs(dif)\n      nstack=nstack-1\n! if no more regions, we are done.\n      if(nstack.le.0) return\n    else\n! if the integration is insufficiently accurate, make each of the\n! three subregions of the right-most region into regions.\n! on next pass the right-most of these is the new current region.\n      nstack=nstack+2\n      maxns = max(maxns,nstack)\n    endif\n  enddo\nend subroutine wsinggrater\n"}
{"id": 51, "subroutine": "subroutine sing1int(ive,isn,ww,xk,xkvtx,evtx,sint)\nimplicit none\ninteger :: ive,isn\ndouble precision :: xk(3,4),xkvtx(3),evtx(4),ww\ndouble precision :: xkp(3,3),xq1(3),xq2(3),xkv0(3),xcvt\ndouble precision :: aa,bb,cc,dd,ee,ff,qq,delta\ndouble precision :: xmin,xmax,abr,rlr,xsing(20),error\ndouble precision :: xfn1,xfn2,xfn3,grater\ndouble precision :: sint,root1,root2,sint1,sint2,sint3\ndouble precision :: xnorm(3),area\ndouble precision :: xdum,xmx,rlxk\ninteger :: ii,jj,kk,ll\ninteger :: nsing,numcal,maxns,nroots\ninteger :: iter \ncommon /fn/ aa,bb,cc,dd,ee,ff,iter \nexternal xfn1,xfn2,xfn3,grater\n\n! broadening: 1/|q|^2 -> 1/(|q|^2+delta^2)\n  delta=min(dot_product(xk(:,2),xk(:,2)),dot_product(xk(:,3),xk(:,3)),dot_product(xk(:,4),xk(:,4)))*1.d-4\n  if (ive.eq.1) then\n    xkp(:,1)=(ww-evtx(1))*xk(:,2)/(evtx(2)-evtx(1))\n    xkp(:,2)=(ww-evtx(1))*xk(:,3)/(evtx(3)-evtx(1))\n    xkp(:,3)=(ww-evtx(1))*xk(:,4)/(evtx(4)-evtx(1))\n  elseif (ive.eq.2) then\n    xkp(:,1)=(ww-evtx(1))*xk(:,2)/(evtx(2)-evtx(1))\n    xkp(:,2)=(ww-evtx(2))*(xk(:,3)-xk(:,2))/(evtx(3)-evtx(2)) + xk(:,2)\n    xkp(:,3)=(ww-evtx(2))*(xk(:,4)-xk(:,2))/(evtx(4)-evtx(2)) + xk(:,2)\n  elseif (ive.eq.3) then\n    xkp(:,1)=(ww-evtx(1))*xk(:,3)/(evtx(3)-evtx(1))\n    xkp(:,2)=(ww-evtx(2))*(xk(:,3)-xk(:,2))/(evtx(3)-evtx(2)) + xk(:,2)\n    xkp(:,3)=(ww-evtx(3))*(xk(:,4)-xk(:,3))/(evtx(4)-evtx(3)) + xk(:,3)\n  else\n    xkp(:,1)=(ww-evtx(2))*(xk(:,4)-xk(:,2))/(evtx(4)-evtx(2)) + xk(:,2)\n    xkp(:,2)=(ww-evtx(3))*(xk(:,4)-xk(:,3))/(evtx(4)-evtx(3)) + xk(:,3)\n    xkp(:,3)=(ww-evtx(1))*xk(:,4)/(evtx(4)-evtx(1))\n  endif\n  xq1=xkp(:,1)-xkp(:,3)\n  xq2=xkp(:,2)-xkp(:,3)\n  xkv0=xkp(:,3)+xkvtx\n  call cross(xq1,xq2,xnorm)\n  area=norm2(xnorm)\n  aa=dot_product(xq1,xq1)\n  bb=2*dot_product(xq1,xkv0)\n  cc=2*dot_product(xq1,xq2)\n  dd=2*dot_product(xq2,xkv0)\n  ee=dot_product(xq2,xq2)\n  ff=dot_product(xkv0,xkv0)+delta**2\n!  ff=dot_product(xkv0,xkv0)\n  nsing=0\n  call rquadroots(ee,dd,ff,nroots,root1,root2)\n  if (nroots.gt.0.and.root1.gt.0.d0.and.root1.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root1\n  endif\n  if (nroots.gt.1.and.root2.gt.0.d0.and.root2.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root2\n  endif\n  call rquadroots(1.d0+cc/2+ee,bb/2+dd,ff,nroots,root1,root2)\n  if (nroots.gt.0.and.root1.gt.0.d0.and.root1.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root1\n  endif\n  if (nroots.gt.1.and.root2.gt.0.d0.and.root2.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root2\n  endif\n  call rquadroots(4.d0*aa*ee-cc**2,4.d0*aa*dd-2.d0*bb*cc,4.d0*aa*ff-bb**2,nroots,root1,root2)\n  if (nroots.gt.0.and.root1.gt.0.d0.and.root1.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root1\n  endif\n  if (nroots.gt.1.and.root2.gt.0.d0.and.root2.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root2\n  endif\n  call hpsort(nsing,nsing,xsing(1:nsing))\n  xmin=0.d0\n  xmax=1.d0\n  abr=1.d-12\n  rlr=1.d-6\n  sint1=grater(xfn1,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n  if (isn.ge.1.and.isn.le.3) then\n    sint2=grater(xfn2,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n    sint3=grater(xfn3,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n    sint=xkp(isn,ll)*sint1+xq1(isn)*(sint2-bb*sint1-cc*sint3)/(2*aa)+xq2(isn)*sint3\n  else\n    sint=sint1\n  endif\n!  svec=xkp(:,3)*sint1+xq1*(sint2-bb*sint1-cc*sint3)/(2*aa)+xq2*sint3\n!  iter=iter+1 \nend subroutine sing1int\n"}
{"id": 52, "subroutine": "subroutine sing2int(isn,xk,xkvtx,evtx,sint)\nimplicit none\ninteger :: isn\ndouble precision :: xk(3,4),xkvtx(3),evtx(4),ww\ndouble precision :: xkp(3,3),xq1(3),xq2(3),xkv0(3),xcvt\ndouble precision :: aa,bb,cc,dd,ee,ff,qq,delta\ndouble precision :: xmin,xmax,abr,rlr,xsing(20),error\ndouble precision :: xfn4,xfn5,xfn6,grater\ndouble precision :: sint1,sint2,sint3,svec(3),root1,root2,sint\ndouble precision :: xnorm(3),area\ndouble precision :: xdum\ninteger :: ii,jj,ll\ninteger :: nsing,numcal,maxns,nroots\ninteger :: iter \ncommon /fn/ aa,bb,cc,dd,ee,ff,iter \nexternal xfn4,xfn5,xfn6,grater\n\n! broadening: 1/|q|^2 -> 1/(|q|^2+delta^2)\n  delta=min(dot_product(xk(:,2),xk(:,2)),dot_product(xk(:,3),xk(:,3)),dot_product(xk(:,4),xk(:,4)))*1.d-4\n  xkp(:,1)=(ww-evtx(1))*xk(:,3)/(evtx(3)-evtx(1))\n  xkp(:,2)=(ww-evtx(1))*xk(:,4)/(evtx(4)-evtx(1))\n  xkp(:,3)=(ww-evtx(2))*(xk(:,4)-xk(:,2))/(evtx(4)-evtx(2)) + xk(:,2)\n  xq1=xkp(:,1)-xkp(:,3)\n  xq2=xkp(:,2)-xkp(:,3)\n  xkv0=xkp(:,3)+xkvtx\n  call cross(xq1,xq2,xnorm)\n  area=norm2(xnorm)\n  aa=dot_product(xq1,xq1)\n  bb=2*dot_product(xq1,xkv0)\n  cc=2*dot_product(xq1,xq2)\n  dd=2*dot_product(xq2,xkv0)\n  ee=dot_product(xq2,xq2)\n  ff=dot_product(xkv0,xkv0)+delta**2\n  nsing=0\n  call rquadroots(ee,dd,ff,nroots,root1,root2)\n  if (nroots.gt.0.and.root1.gt.0.d0.and.root1.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root1\n  endif\n  if (nroots.gt.1.and.root2.gt.0.d0.and.root2.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root2\n  endif\n  call rquadroots(1.d0+cc/2+ee,bb/2+dd,ff,nroots,root1,root2)\n!write(6,'(i4,2es15.5)') nroots,root1,root2\n  if (nroots.gt.0.and.root1.gt.0.d0.and.root1.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root1\n  endif\n  if (nroots.gt.1.and.root2.gt.0.d0.and.root2.lt.1.d0) then\n    nsing=nsing+1\n    xsing(nsing)=root2\n  endif\n  call hpsort(nsing,nsing,xsing(1:nsing))\n  xmin=0.d0\n  xmax=1.d0\n  abr=1.d-12\n  rlr=1.d-6\n  sint1=grater(xfn4,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n  if (isn.ge.1.and.isn.le.3) then\n    sint2=grater(xfn5,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n    sint3=grater(xfn6,xmin,xmax,abr,rlr,nsing,xsing,error,numcal,maxns)*area\n    sint=xkp(isn,3)*sint1+xq1(isn)*(sint2-bb*sint1-cc*sint3)/(2*aa)+xq2(isn)*sint3\n  else\n    sint=sint1\n  endif\n\nend subroutine sing2int\n"}
{"id": 53, "subroutine": "    subroutine compute_nnodes_gq(spacedim,nterms_s,nterms_c,nnodes_face,nnodes_vol)\n        use mod_io,                     only: gq_rule\n        integer(ik), intent(in)         :: spacedim\n        integer(ik), intent(in)         :: nterms_s, nterms_c\n        integer(ik), intent(out)        :: nnodes_face, nnodes_vol\n\n        integer(ik)                     :: nterms1d, nnodes1d, nnodes2d, nnodes3d\n\n        !\n        ! find number of terms in the 1d expansion\n        !\n        nterms1d = 0\n\n        if ( spacedim == 3 ) then\n\n            do while (nterms1d*nterms1d*nterms1d /= nterms_s)\n                nterms1d = nterms1d + 1\n            end do\n            if (nterms1d*nterms1d*nterms1d > nterms_s) call chidg_signal(fatal, \"incorrect number of terms counted when computing quadrature nodes\")\n\n        else if ( spacedim == 2 ) then\n\n            do while (nterms1d*nterms1d /= nterms_s)\n                nterms1d = nterms1d + 1\n            end do\n            if (nterms1d*nterms1d > nterms_s) call chidg_signal(fatal, \"incorrect number of terms counted when computing quadrature nodes\")\n\n        else\n            call chidg_signal(fatal,\"mod_quadrature: invalid spacedim\")\n\n        end if\n\n\n        !\n        ! compute number of 1d nodes, based on integration rule\n        !\n        select case (gq_rule)\n            case(1)\n                !\n                ! collocation quadrature\n                !\n                nnodes1d = nterms1d\n            case(2)\n                nnodes1d = ceiling(3._rk*real(nterms1d,rk)/2._rk)\n            case(3)\n                nnodes1d = 2*nterms1d + 1\n            case(4)\n                nnodes1d = 3*nterms1d + 1\n            case(5)\n                nnodes1d = 5*nterms1d + 1\n            case default\n                call chidg_signal(fatal, \"compute_nnodes_integration: value for gq_rule, specifying the rule for selecting number of quadrature points was not valid. recognized values are gq_rule = (1, 2, 3)\")\n\n        end select\n\n\n        !\n        ! compute face and volume nodes\n        !\n        nnodes2d = nnodes1d*nnodes1d\n        nnodes3d = nnodes1d*nnodes1d*nnodes1d\n\n        \n        if ( spacedim == 3 ) then\n            nnodes_face = nnodes2d\n            nnodes_vol  = nnodes3d\n        else if ( spacedim == 2 ) then\n            nnodes_face = nnodes1d\n            nnodes_vol  = nnodes2d\n        else\n            call chidg_signal(fatal,\"mod_quadrature: invalid spacedim\")\n        end if\n\n\n    end subroutine compute_nnodes_gq\n"}
{"id": 54, "subroutine": "    subroutine get_quadrature(spacedim,nterms,nn_v,nn_f,gqout)\n        integer(ik),    intent(in)      :: spacedim\n        integer(ik),    intent(in)      :: nterms\n        integer(ik),    intent(in)      :: nn_v\n        integer(ik),    intent(in)      :: nn_f\n        integer(ik),    intent(inout)   :: gqout\n\n        integer(ik) :: igq\n        logical     :: has_correct_nodes_terms\n        logical     :: is_correct_spacedim\n\n\n\n        !\n        ! loop through the quadrature instances that exist and get the index of one \n        ! that matches the requirement.\n        !\n        do igq = 1,size(gq)\n\n\n\n            if (gq(igq)%isinitialized) then\n                !\n                ! if we are here, check if the current gq(igq) has the right terms and nodes.\n                !\n                has_correct_nodes_terms = (gq(igq)%nterms == nterms) .and. &\n                                          (gq(igq)%nnodes_v == nn_v)\n                is_correct_spacedim     = ( gq(igq)%spacedim == spacedim )\n\n                if (has_correct_nodes_terms .and. is_correct_spacedim) then\n                    gqout = igq\n                    exit\n                end if\n\n            else\n                !\n                ! if we are here, then no initialized gq instance was found that met \n                ! the requirements, so, we initialize a new one.\n                !\n                call gq(igq)%init(spacedim,nn_f,nn_v,nterms)\n                gqout = igq\n                exit\n\n            end if\n\n\n\n        end do\n\n    end subroutine get_quadrature\n"}
{"id": 55, "subroutine": "  subroutine setup_pseudo_info\n\n    use datatypes\n    use numbers,        only: zero, rd_err, two\n    use pao_format,     only: pao\n    use species_module, only: n_species, species_label, species_file, species_from_files\n    use species_module, only: npao_species, nsf_species, type_species, charge, charge_up, charge_dn, mass\n    use global_module,  only: iprint_pseudo, flag_multisite\n    use dimens,         only: radiussupport, radiusatomf, radiusms, invsrange, atomicnum\n    use gencomms,       only: inode, ionode, cq_abort, gcopy\n    use pseudopotential_common, only: pseudo_type, siesta, abinit\n    use sfc_partitions_module, only: gap_threshold\n    use maxima_module,  only: maxnsf\n\n    implicit none\n\n    !local\n    integer :: stat, ispecies, l, zeta\n    real(double) :: max_rc\n    character(len=80) :: filename\n    integer :: ii\n\n    if(allocated(pseudo)) then\n       if(iprint_pseudo>2.and.inode==ionode) write(io_lun,fmt='(10x,\" setup_pseudo_info is skipped because it is already called\")')\n    else\n       call start_timer(tmr_std_allocation)\n       allocate(pseudo(n_species),stat=stat)\n       if(stat /= 0) call cq_abort ('allocating pseudo in setup_pseudo_info',stat)\n       allocate(pao(n_species),stat=stat)\n       if(stat /= 0) call cq_abort ('allocating pao in setup_pseudo_info',stat)\n       call stop_timer(tmr_std_allocation)\n       flag_pcc_global = .false.\n       max_rc = zero\n       do ispecies=1,n_species\n          if(pseudo_type==siesta) then\n             pseudo(ispecies)%tm_loc_pot = loc_chg\n          else if(pseudo_type==abinit) then\n             pseudo(ispecies)%tm_loc_pot = loc_pot\n          else\n             call cq_abort(\"error in pseudopotential type: \",pseudo_type)\n          end if\n          !**<lat>** 2014/10/12\n          if ( species_from_files ) then\n             write(filename,'(a,a)') trim(species_file(ispecies))\n          else\n             write(filename,'(a,a)') trim(species_label(ispecies)),\".ion\"\n          end if\n          if(iprint_pseudo>3.and.inode==ionode) &\n               write(io_lun,fmt='(10x,\"ispecies = \",i5,\" file = \",a)') ispecies, filename\n\n          pseudo(ispecies)%filename = filename\n          call read_ion_ascii_tmp(pseudo(ispecies),pao(ispecies))\n\n          npao_species(ispecies) = pao(ispecies)%count\n          ! set nsf if not set by user\n          if(nsf_species(ispecies)==0) nsf_species(ispecies) = pao(ispecies)%count\n          maxnsf = max(maxnsf,nsf_species(ispecies))\n          ! find radius for atom functions\n          do l=0,pao(ispecies)%greatest_angmom\n             do zeta=1,pao(ispecies)%angmom(l)%n_zeta_in_angmom\n                radiusatomf(ispecies) = max(radiusatomf(ispecies), &\n                     pao(ispecies)%angmom(l)%zeta(zeta)%cutoff)\n             end do\n          end do\n          ! set sf radius if not set by user\n          if(abs(radiussupport(ispecies))<rd_err) radiussupport(ispecies) = radiusatomf(ispecies)\n          if(abs(invsrange(ispecies))<rd_err) invsrange(ispecies) = radiussupport(ispecies)\n          if (flag_multisite) radiussupport(ispecies) = radiussupport(ispecies) + radiusms(ispecies)\n          max_rc = max(radiussupport(ispecies),max_rc)\n          atomicnum(ispecies)    = pseudo(ispecies)%z\n          ! valence charge\n          charge(ispecies)       = pseudo(ispecies)%zval\n          if(mass(ispecies) < zero) charge(ispecies) = zero\n          ! test spin polarised initialisation\n          if (abs(charge_up(ispecies)+charge_dn(ispecies))>rd_err) then\n             if (abs(charge_up(ispecies)+charge_dn(ispecies)-charge(ispecies))>rd_err) &\n                  call cq_abort('read_input: sum of number of electrons &\n                  &in spin channels is different from total &\n                  &number of electrons for this species ', &\n                  charge_up(ispecies)+charge_dn(ispecies),charge(ispecies))\n          end if\n          ! for p.c.c.\n          if (pseudo(ispecies)%flag_pcc) flag_pcc_global = .true.\n          !for ghost atoms\n          if(type_species(ispecies) < 0) then\n             pseudo(ispecies)%zval = zero\n             if(pseudo(ispecies)%n_pjnl > 0) then\n                do ii=1, pseudo(ispecies)%n_pjnl\n                   call init_rad(pseudo(ispecies)%pjnl(ii))\n                enddo\n             endif\n             if(pseudo_type==abinit) call init_rad(pseudo(ispecies)%vlocal)\n             if(pseudo_type==siesta) call init_rad(pseudo(ispecies)%chlocal)\n             if(pseudo(ispecies)%flag_pcc) call init_rad(pseudo(ispecies)%chpcc)\n             pseudo(ispecies)%n_pjnl      = 0\n             pseudo(ispecies)%flag_pcc    = .false.\n             pseudo(ispecies)%pjnl_l(:)   = 0\n             pseudo(ispecies)%pjnl_n(:)   = 0\n             pseudo(ispecies)%pjnl_ekb(:) = zero\n             ! pseudo(ispecies)%alpha\n             ! pseudo(ispecies)%prefac\n          endif\n\n          if(npao_species(ispecies)<nsf_species(ispecies)) &\n               call cq_abort(\"error ! fewer paos than sfs.  decrease numberofsupports: \", &\n               npao_species(ispecies),nsf_species(ispecies))\n          !%%! cutoff = zero\n          !%%! do l=0,pao(ispecies)%greatest_angmom\n          !%%!    if(pao(ispecies)%angmom(l)%n_zeta_in_angmom>0) then\n          !%%!       do zeta = 1,pao(ispecies)%angmom(l)%n_zeta_in_angmom\n          !%%!          cutoff = max(cutoff,pao(ispecies)%angmom(l)%zeta(zeta)%cutoff)\n          !%%!       end do\n          !%%!    end if\n          !%%! end do\n          !%%! if(cutoff>radiussupport(ispecies)) then\n          !%%!    if(inode==ionode.and.iprint_pseudo>0) &\n          !%%!         write(io_lun,fmt='(10x,\"warning ! species \",i3,\" support radius less than pao radius \",f8.3)') ispecies,cutoff\n          !%%!    !radiussupport(ispecies) = cutoff\n          !%%! endif\n       enddo\n       ! this isn't ideal, but replaces a read for gap_threshold with default of two*max_rc\n       if(abs(gap_threshold)<rd_err) gap_threshold = two*max_rc\n    endif\n    !call gcopy(flag_pcc_global)\n    !call gcopy(gap_threshold)\n    !call gcopy(maxnsf)\n    if (iprint_pseudo>0.and.inode==ionode .and.flag_pcc_global) &\n         write (io_lun,fmt='(10x,a)') \"p.c.c. is taken into account.\"\n    return\n  end subroutine setup_pseudo_info\n"}
{"id": 56, "subroutine": "  subroutine alloc_pseudo_info(ps_info,n)\n\n    use memory_module, only: reg_alloc_mem, type_int, type_dbl    \n\n    implicit none\n\n    integer, intent(in) :: n\n    type(pseudo_info),intent(out):: ps_info\n\n    integer :: stat\n\n    ps_info%n_pjnl = n\n    call start_timer(tmr_std_allocation)\n    allocate(ps_info%pjnl(n), stat=stat)  \n    if(stat /= 0) call cq_abort('alloc pjnl in alloc_pseudo_info',stat)\n    allocate(ps_info%pjnl_l(n), ps_info%pjnl_n(n), stat=stat)  \n    if(stat /= 0) call cq_abort('alloc pjnl_l&n in alloc_pseudo_info',stat)\n    call reg_alloc_mem(area_pseudo,n,type_int)\n    allocate(ps_info%pjnl_ekb(n), stat=stat)  \n    if(stat /= 0) call cq_abort('alloc pjnl_ekb in alloc_pseudo_info',stat)\n    call reg_alloc_mem(area_pseudo,n,type_dbl)\n    call stop_timer(tmr_std_allocation)\n\n    return\n  end subroutine alloc_pseudo_info\n"}
{"id": 57, "subroutine": "  subroutine rad_alloc(func,n)\n\n    use memory_module, only: reg_alloc_mem, type_dbl    \n\n    implicit none\n\n    type(rad_func), intent(out)    :: func\n    integer, intent(in)        :: n\n    integer :: stat\n\n    func%n = n\n    call start_timer(tmr_std_allocation)\n    allocate(func%f(n),func%d2(n),stat=stat)\n    if(stat /= 0) call cq_abort('allocating radial func in rad_alloc',stat)\n    call reg_alloc_mem(area_pseudo,2*n,type_dbl)\n    call stop_timer(tmr_std_allocation)\n    return\n  end subroutine rad_alloc\n"}
{"id": 58, "subroutine": "  subroutine rad_dealloc(func)\n\n    use memory_module, only: reg_dealloc_mem, type_dbl    \n\n    implicit none\n\n    type(rad_func), intent(inout)    :: func\n\n    integer :: stat\n\n    call start_timer(tmr_std_allocation)\n    deallocate(func%f,func%d2,stat=stat)\n    if(stat /= 0) call cq_abort('deallocating radial func in rad_alloc',stat)\n    call reg_dealloc_mem(area_pseudo,2*func%n,type_dbl)\n    nullify(func%f, func%d2)\n    call stop_timer(tmr_std_allocation)\n    return\n  end subroutine rad_dealloc\n"}
{"id": 59, "subroutine": "  subroutine init_rad(func)\n\n    use numbers, only: zero\n    implicit none\n\n    type(rad_func), intent(inout)    :: func\n\n    func%n = 0\n    func%cutoff = zero\n    func%delta = zero\n    func%f(:) = zero\n    func%d2(:) = zero\n    return\n  end subroutine init_rad\n"}
{"id": 60, "subroutine": "  subroutine radial_read_ascii(op,lun)\n\n    use numbers, only: big, zero, rd_err\n    use splines, only: spline\n    use global_module, only: iprint_pseudo\n    use gencomms, only: myid, cq_warn\n\n    implicit none\n\n    ! passed variables\n    type(rad_func),intent(out) :: op\n    integer,intent(in)         :: lun\n\n    ! local variables\n    character(len=80) :: sub_name = \"radial_read_ascii\"\n    integer :: j, npts\n    real(double) :: dummy, r0, r1\n    real(double) :: yp1, ypn\n    real(double) :: delta, cutoff\n\n    !ori read(lun,'(i4,2g25.15)') npts, op%delta, op%cutoff\n    !    read(lun,'(i4,2g25.15)') npts, delta, cutoff\n    read(lun,*) npts, delta, cutoff\n    ! drb 2018/03/08 adding consistency check between cutoff and delta\n    if(abs(cutoff - delta*real(npts-1,double))>rd_err) then\n       call cq_warn(sub_name, \"in ion file, cutoff and step inconsistent, cutoff will be adjusted: \",&\n            cutoff,delta*real(npts-1,double))\n       cutoff=delta*real(npts-1,double)\n    end if\n    if(myid==0.and.iprint_pseudo>3) write(io_lun,fmt='(10x,\"radius: \",f15.10)') cutoff\n    op%delta = delta\n    op%cutoff= cutoff\n    call rad_alloc(op,npts)\n    ! test step size in radial grid is consistent\n    read(lun,*) r0, op%f(1)\n    read(lun,*) r1, op%f(2)\n    if(abs(r1-r0-delta)>rd_err) then\n       call cq_warn(sub_name, \"radial grid and step inconsistent ! \",r1-r0,delta)\n       ! drb 2018/03/08 10:55\n       ! i can see an argument to abort here - if the step size and grid are inconsistent we may have problems\n    end if\n    do j=3,npts\n       read(lun,*) dummy, op%f(j)\n    enddo\n    !ori call rad_setup_d2(op)\n    ! conquest version \n    !  yp1= big * 1.1\n    !  ypn= big * 1.1\n    yp1= (op%f(2)-op%f(1))/delta!zero\n    ypn= (op%f(npts)-op%f(npts-1))/delta!zero\n    call spline(op%n, op%delta, op%f, yp1, ypn, op%d2)\n    return\n  end subroutine radial_read_ascii\n"}
{"id": 61, "subroutine": "  subroutine read_ion_ascii_tmp(ps_info,pao_info)\n\n    use numbers, only: six, half, zero, pi, one\n    use global_module, only: numprocs, iprint_pseudo\n    use gencomms, only: inode, ionode, gcopy, cq_warn, cq_abort\n    use pao_format, only: species_pao\n    use splines, only : spline\n    use memory_module, only: reg_alloc_mem, type_dbl    \n    use functions, only: erfc_cq\n    use input_module, only: io_assign, io_close\n    use pseudopotential_common, only: pseudo_type, siesta, abinit\n    use maxima_module, only: lmax_pao, lmax_ps\n\n    implicit none\n\n    ! passed variables\n    type(pseudo_info),intent(inout) :: ps_info\n    type(species_pao),intent(inout) :: pao_info\n\n    ! local variables\n    character(len=80) :: sub_name = \"read_ion_ascii_tmp\"    \n    type(rad_func), dimension(:), allocatable :: dummy_rada\n    type(rad_func) :: dummy_rad\n\n    character(len=80) :: filename\n    integer :: i, lun , i1, i2, i3, i4, z\n    real(double) :: dummy, a, r\n    integer :: n_orbnl, n_pjnl\n    real(double) :: zval, yp1, ypn, erfarg, tmpv\n    real(double), parameter :: ln10 = 2.302585092994_double\n\n    integer :: iproc, lmax, maxz, alls, nzeta, l, count,tzl, xc_func, ps_type\n    real(double), allocatable :: thispop(:)\n    integer, allocatable :: thisl(:), thisn(:), thisz(:), zl(:), indexlz(:,:)\n\n    if(inode==ionode) then\n       filename=ps_info%filename\n       call io_assign(lun)\n       open(lun,file=filename,status='old',form='formatted')\n       rewind(lun)\n\n       xc_func = 0\n       ps_type = 0\n       call read_header_tmp(n_orbnl,lmax,n_pjnl, zval, z, lun, xc_func, ps_type)\n       if(xc_func/=0) then\n          ps_info%functional = xc_func\n       end if\n       if(ps_type/=0) then\n          ps_info%ps_type = ps_type\n          if(ps_info%ps_type/=pseudo_type) &\n               call cq_abort(\"error: ion file pseudopotential type incompatible with input file \", &\n               ps_info%ps_type, pseudo_type)\n       else\n          call cq_warn(sub_name, \"pseudopotential type not detected from ion file\")\n       end if\n       call alloc_pseudo_info(ps_info, n_pjnl)\n       call start_timer(tmr_std_allocation)\n       allocate(dummy_rada(n_orbnl),thisl(n_orbnl),thisn(n_orbnl),thisz(n_orbnl),thispop(n_orbnl),zl(0:lmax))\n       call stop_timer(tmr_std_allocation)\n\n       ps_info%z = z\n       ps_info%zval = zval\n\n       read(lun,*)\n       zl = 0\n       maxz = 0\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading paos\")')\n       do i=1,n_orbnl\n          read(lun,*) i1,i2,i3,i4, dummy\n          thisl(i)=i1\n          thisn(i)=i2\n          !thisz(i)=i3\n          thispop(i)=dummy\n          zl(thisl(i)) = zl(thisl(i))+1\n          thisz(i)=zl(thisl(i))\n          !if(thisz(i)>zl(thisl(i))) zl(thisl(i))=thisz(i)\n          maxz = max(maxz,thisz(i))\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"l: \",i3,\" z: \",i3)') i1,i3\n          call radial_read_ascii(dummy_rada(i),lun)\n       enddo\n       allocate(indexlz(maxz,0:lmax))\n       indexlz = 0\n       do i=1,n_orbnl\n          indexlz(thisz(i),thisl(i)) = i\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"indexlz: \",3i5)') thisz(i),thisl(i),i\n       end do\n       ! now store data\n       pao_info%greatest_angmom = lmax\n       call start_timer(tmr_std_allocation)\n       allocate(pao_info%angmom(0:lmax),stat=alls)\n       call stop_timer(tmr_std_allocation)\n       count = 0\n       if(alls/=0) call cq_abort('failed to allocate paos')\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"storing paos lmax: \",i5)') lmax\n       do l=0,lmax\n          pao_info%angmom(l)%n_zeta_in_angmom = zl(l)\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"l, zl: \",2i5)') l,zl(l)\n          if(zl(l)>0) then\n             call start_timer(tmr_std_allocation)\n             allocate(pao_info%angmom(l)%zeta(zl(l)),pao_info%angmom(l)%prncpl(zl(l)), &\n                  pao_info%angmom(l)%occ(zl(l)),pao_info%angmom(l)%semicore(zl(l)),stat=alls)\n             pao_info%angmom(l)%semicore(:) = 0\n             if(alls/=0) call cq_abort('failed to allocate paos zeta')\n             call stop_timer(tmr_std_allocation)\n             count = count + zl(l)*(2*l+1)\n             do nzeta = 1,zl(l)\n                i = indexlz(nzeta,l)\n                if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"i,z,l: \",3i5)') i,nzeta,l\n                pao_info%angmom(l)%zeta(nzeta)%length = dummy_rada(i)%n\n                pao_info%angmom(l)%zeta(nzeta)%cutoff = dummy_rada(i)%cutoff\n                pao_info%angmom(l)%zeta(nzeta)%delta = dummy_rada(i)%delta\n                pao_info%angmom(l)%prncpl(nzeta) = thisn(i)\n                pao_info%angmom(l)%occ(nzeta) = thispop(i)\n                if(pao_info%angmom(l)%zeta(nzeta)%length>=1) then\n                   call start_timer(tmr_std_allocation)\n                   allocate(pao_info%angmom(l)%zeta(nzeta)%table(pao_info%angmom(l)%zeta(nzeta)%length),stat=alls)\n                   if(alls/=0) call cq_abort('failed to allocate paos zeta')\n                   call reg_alloc_mem(area_pseudo,pao_info%angmom(l)%zeta(nzeta)%length,type_dbl)\n                   call stop_timer(tmr_std_allocation)\n                   pao_info%angmom(l)%zeta(nzeta)%table(1:dummy_rada(i)%n) = dummy_rada(i)%f(1:dummy_rada(i)%n)\n                   call start_timer(tmr_std_allocation)\n                   allocate(pao_info%angmom(l)%zeta(nzeta)%table2(pao_info%angmom(l)%zeta(nzeta)%length),stat=alls)\n                   if(alls/=0) call cq_abort('failed to allocate paos zeta')\n                   call reg_alloc_mem(area_pseudo,pao_info%angmom(l)%zeta(nzeta)%length,type_dbl)\n                   call stop_timer(tmr_std_allocation)\n                else\n                   call cq_abort('pao with zero length: ',l,nzeta)\n                end if\n                yp1 = (pao_info%angmom(l)%zeta(nzeta)%table(2)-pao_info%angmom(l)%zeta(nzeta)%table(1))/ &\n                     dummy_rada(i)%delta\n                ypn = (pao_info%angmom(l)%zeta(nzeta)%table(dummy_rada(i)%n)-&\n                     pao_info%angmom(l)%zeta(nzeta)%table(dummy_rada(i)%n-1))/ &\n                     dummy_rada(i)%delta\n                call spline(dummy_rada(i)%n,dummy_rada(i)%delta,pao_info%angmom(l)%zeta(nzeta)%table, &\n                     yp1,ypn,pao_info%angmom(l)%zeta(nzeta)%table2)\n             end do\n          end if\n       end do\n       pao_info%count = count\n       deallocate(indexlz)\n       do i=1,n_orbnl\n          call rad_dealloc(dummy_rada(i))\n       end do\n       deallocate(dummy_rada,thisl,thisn,thisz,thispop,zl)\n\n       ! kbs\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading kb projectors \")')\n       read(lun,*)\n       ps_info%lmax = 0\n       do i=1,ps_info%n_pjnl\n          !          read(lun,'(2i3,f22.16)') &\n          read(lun,*) &\n               ps_info%pjnl_l(i), ps_info%pjnl_n(i), ps_info%pjnl_ekb(i)\n          !!   25/jul/2002 tm : rydberg units -> hartree units\n          ps_info%pjnl_ekb(i) = half* ps_info%pjnl_ekb(i)\n          if(iprint_pseudo>1.and.inode==ionode) write(io_lun,fmt='(10x,\"pseudo_tm: i, l,n, ekb = \",2i3,f22.16)') &\n               ps_info%pjnl_l(i), ps_info%pjnl_n(i),ps_info%pjnl_ekb(i)\n          if(ps_info%pjnl_l(i)>ps_info%lmax) ps_info%lmax = ps_info%pjnl_l(i)\n          call radial_read_ascii(ps_info%pjnl(i),lun)\n       enddo\n       !vlocal\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading vna \")')\n       read(lun,*)\n       ! read and store local potential; it may be local part of pseudo, or neutral atom\n       ! drb 2017/02/21 switch here: after vna, get vlocal for hamann, chlocal for siesta\n       ! drb 2017/02/21 this is the na potential\n       if(pseudo_type==siesta) then\n          call radial_read_ascii(ps_info%vna,lun)\n          ps_info%vna%f  = half*ps_info%vna%f  ! siesta works in ry\n          ps_info%vna%d2 = half*ps_info%vna%d2 ! siesta works in ry\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading chlocal \")')\n          read(lun,*)\n          call radial_read_ascii(ps_info%chlocal,lun)\n       else if(pseudo_type==abinit) then\n          call radial_read_ascii(ps_info%vna,lun)\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading vlocal \")')\n          read(lun,*)\n          call radial_read_ascii(ps_info%vlocal,lun)\n       end if\n       !sets up gaussian which is used to calculate g=0 term\n       !  exp( - alpha * cutoff **2 ) = 10 **(-six) \n       if(ps_info%tm_loc_pot==loc_pot) then\n          ps_info%alpha = six * ln10 / (ps_info%vlocal%cutoff ** 2)\n          ps_info%prefac = (ps_info%alpha/pi)**1.5_double\n          ! remove long-range part from short-range part\n          a = sqrt(ps_info%alpha)\n          !r = ps_info%vlocal%delta\n          r = 1.0e-7_double\n          erfarg = one - erfc_cq(a*r)\n          !erfarg = derf(a*r)\n          tmpv = ps_info%vlocal%f(1)\n          ps_info%vlocal%f(1) = ps_info%vlocal%f(1) + ps_info%zval * erfarg/r\n          !write(52,*) r,ps_info%vlocal%f(1),tmpv,ps_info%zval * erfarg/r!ps_info%zval * derf(a*r)/r\n          do i=2,ps_info%vlocal%n\n             r = ps_info%vlocal%delta*real(i-1,double)\n             erfarg = one - erfc_cq(a*r)\n             tmpv = ps_info%vlocal%f(i)\n             ps_info%vlocal%f(i) = ps_info%vlocal%f(i) + ps_info%zval * erfarg/r\n             !write(52,*) r,ps_info%vlocal%f(i), tmpv,ps_info%zval * erfarg/r!,ps_info%zval * derf(a*r)/r\n          end do\n          call spline(ps_info%vlocal%n, ps_info%vlocal%delta, ps_info%vlocal%f, zero, zero, ps_info%vlocal%d2)\n       else\n          ps_info%alpha = six * ln10 / (ps_info%chlocal%cutoff ** 2)\n       endif\n       !core\n       ! 2017/03/17 dave\n       ! i'm removing this because we read the pcc flag from the pseudopotential header\n       !ps_info%flag_pcc = .false.\n       !! i *really* don't like this, but we'll stay with it for now\n       !read(lun,*,end=9999)\n       if(ps_info%flag_pcc) then\n          read(lun,*)\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\"reading pcc \")')\n          call radial_read_ascii(ps_info%chpcc,lun)\n       end if\n       !ps_info%flag_pcc = .true.\n\n       !9999   continue\n       call io_close(lun)\n    endif !  (inode == ionode) then\n    ! now broadcast the information\n    call gcopy(lmax   )\n    if(lmax>lmax_pao) lmax_pao = lmax    \n    call gcopy(n_pjnl )\n    call gcopy(zval)\n    call gcopy(xc_func)\n    call gcopy(z)\n    if(inode/=ionode) then\n       call alloc_pseudo_info(ps_info, n_pjnl)\n       ps_info%zval = zval\n       ps_info%z = z\n       if(xc_func/=0) ps_info%functional = xc_func\n       pao_info%greatest_angmom = lmax\n       allocate(pao_info%angmom(0:lmax),stat=alls)\n    end if\n    if(numprocs>1) then\n       count = 0\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,*) 'paos'\n       do l=0,lmax\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(10x,\" l is \",i5)') l\n          call gcopy(pao_info%angmom(l)%n_zeta_in_angmom)\n          tzl = pao_info%angmom(l)%n_zeta_in_angmom\n          if(tzl>0) then\n             if(inode/=ionode) then\n                call start_timer(tmr_std_allocation)\n                allocate(pao_info%angmom(l)%zeta(tzl),pao_info%angmom(l)%prncpl(tzl),&\n                     pao_info%angmom(l)%occ(tzl),pao_info%angmom(l)%semicore(tzl),stat=alls)\n                if(alls/=0) call cq_abort('failed to allocate paos zeta')\n                call stop_timer(tmr_std_allocation)\n             end if\n             count = count + tzl*(2*l+1)\n             do nzeta = 1,tzl\n                call gcopy(pao_info%angmom(l)%zeta(nzeta)%length)\n                call gcopy(pao_info%angmom(l)%zeta(nzeta)%cutoff)\n                call gcopy(pao_info%angmom(l)%zeta(nzeta)%delta)\n                call gcopy(pao_info%angmom(l)%prncpl(nzeta))\n                call gcopy(pao_info%angmom(l)%occ(nzeta))\n                call gcopy(pao_info%angmom(l)%semicore(nzeta))\n                if(inode/=ionode) then\n                   if(pao_info%angmom(l)%zeta(nzeta)%length>=1) then\n                      call start_timer(tmr_std_allocation)\n                      allocate(pao_info%angmom(l)%zeta(nzeta)%table(pao_info%angmom(l)%zeta(nzeta)%length),stat=alls)\n                      if(alls/=0) call cq_abort('failed to allocate paos zeta',pao_info%angmom(l)%zeta(nzeta)%length)\n                      call reg_alloc_mem(area_pseudo,pao_info%angmom(l)%zeta(nzeta)%length,type_dbl)\n\n                      allocate(pao_info%angmom(l)%zeta(nzeta)%table2(pao_info%angmom(l)%zeta(nzeta)%length),stat=alls)\n                      if(alls/=0) call cq_abort('failed to allocate paos zeta ',pao_info%angmom(l)%zeta(nzeta)%length)\n                      call reg_alloc_mem(area_pseudo,pao_info%angmom(l)%zeta(nzeta)%length,type_dbl)\n                      call stop_timer(tmr_std_allocation)\n                   end if\n                end if\n                call gcopy(pao_info%angmom(l)%zeta(nzeta)%table,pao_info%angmom(l)%zeta(nzeta)%length)\n                call gcopy(pao_info%angmom(l)%zeta(nzeta)%table2,pao_info%angmom(l)%zeta(nzeta)%length)\n             end do\n          end if\n       end do\n       pao_info%count = count\n       if(inode/=ionode) ps_info%lmax = 0\n       if(iprint_pseudo>3.and.inode==ionode) write(io_lun,*) 'pps'\n       do i=1,ps_info%n_pjnl\n          if(iprint_pseudo>3.and.inode==ionode) write(io_lun,fmt='(2x,\"projector number: \",i3)') i\n          call gcopy(ps_info%pjnl_l(i))\n          call gcopy(ps_info%pjnl_n(i))\n          call gcopy(ps_info%pjnl_ekb(i))\n          if(inode/=ionode.and.ps_info%pjnl_l(i)>ps_info%lmax) ps_info%lmax = ps_info%pjnl_l(i)\n          call gcopy(ps_info%pjnl(i)%delta)\n          call gcopy(ps_info%pjnl(i)%cutoff)\n          call gcopy(ps_info%pjnl(i)%n)\n          if(inode/=ionode) call rad_alloc(ps_info%pjnl(i),ps_info%pjnl(i)%n)\n          call gcopy(ps_info%pjnl(i)%f,ps_info%pjnl(i)%n)\n          call gcopy(ps_info%pjnl(i)%d2,ps_info%pjnl(i)%n)\n       end do\n       if(ps_info%lmax>lmax_ps) lmax_ps = ps_info%lmax\n       if(pseudo_type==siesta) then\n          !chlocal\n          call gcopy(ps_info%tm_loc_pot)\n          call gcopy(ps_info%chlocal%n)\n          call gcopy(ps_info%chlocal%cutoff)\n          call gcopy(ps_info%chlocal%delta)\n          if(inode/=ionode) call rad_alloc(ps_info%chlocal,ps_info%chlocal%n)\n          call gcopy(ps_info%chlocal%f,ps_info%chlocal%n)\n          call gcopy(ps_info%chlocal%d2,ps_info%chlocal%n)\n          ! vna\n          call gcopy(ps_info%vna%n)\n          call gcopy(ps_info%vna%cutoff)\n          call gcopy(ps_info%vna%delta)\n          if(inode/=ionode) call rad_alloc(ps_info%vna,ps_info%vna%n)\n          call gcopy(ps_info%vna%f,ps_info%vna%n)\n          call gcopy(ps_info%vna%d2,ps_info%vna%n)\n       else if(pseudo_type==abinit) then\n          !vlocal\n          call gcopy(ps_info%tm_loc_pot)\n          call gcopy(ps_info%vlocal%n)\n          call gcopy(ps_info%vlocal%cutoff)\n          call gcopy(ps_info%vlocal%delta)\n          if(inode/=ionode) call rad_alloc(ps_info%vlocal,ps_info%vlocal%n)\n          call gcopy(ps_info%vlocal%f,ps_info%vlocal%n)\n          call gcopy(ps_info%vlocal%d2,ps_info%vlocal%n)\n          ! vna\n          call gcopy(ps_info%vna%n)\n          call gcopy(ps_info%vna%cutoff)\n          call gcopy(ps_info%vna%delta)\n          if(inode/=ionode) call rad_alloc(ps_info%vna,ps_info%vna%n)\n          call gcopy(ps_info%vna%f,ps_info%vna%n)\n          call gcopy(ps_info%vna%d2,ps_info%vna%n)\n       end if\n       if(inode/=ionode) then\n          if(ps_info%tm_loc_pot==loc_pot) then\n             ps_info%alpha = six * ln10 / (ps_info%vlocal%cutoff ** 2)\n             ps_info%prefac = (ps_info%alpha/pi)**1.5_double\n          else\n             ps_info%alpha = six * ln10 / (ps_info%chlocal%cutoff ** 2)\n          end if\n       end if\n       call gcopy(ps_info%flag_pcc)\n       if(ps_info%flag_pcc) then\n          call gcopy(ps_info%chpcc%n)\n          call gcopy(ps_info%chpcc%cutoff)\n          call gcopy(ps_info%chpcc%delta)\n          if(inode/=ionode) call rad_alloc(ps_info%chpcc,ps_info%chpcc%n)\n          call gcopy(ps_info%chpcc%f,ps_info%chpcc%n)\n          call gcopy(ps_info%chpcc%d2,ps_info%chpcc%n)\n       end if\n    end if ! numprocs>1\n  contains\n\n    subroutine read_header_tmp(n_orbnl, lmax_basis, n_pjnl, zval, z, unit, xc_func, pseudo_type)\n\n      use global_module, only: iprint_pseudo\n      use input_module, only: leqi\n      use xc, only: functional_lda_pw92, functional_gga_pbe96, functional_gga_pbe96_rev98, &\n           functional_gga_pbe96_r99, functional_gga_pbe96_wc\n\n      implicit none\n\n      integer, intent(in)         :: unit\n      integer, intent(out) :: n_orbnl, n_pjnl, z, xc_func, pseudo_type\n      real(double), intent(out) :: zval\n\n      character(len=78) :: line, trim_line\n\n      character(len=2)  :: symbol\n      character(len=20) :: label\n      integer :: lmax_basis, lmax_projs, zval_int\n      real(double) :: mass, self_energy\n\n      ! for judging p.c.c.\n      character(len=2) :: symbol2, xc_code\n      character(len=3) :: rel\n      character(len=4) :: pcc\n\n      xc_func = 0\n      pseudo_type = 0\n      ! judge if p.c.c. is considered\n      read(unit,'(a)') line\n      trim_line = trim(line)\n      if (leqi(trim_line(1:10),'<preamble>')) then\n         read(unit,'(a)') line\n         trim_line = trim(line)\n         do while(.not.leqi(trim_line(1:11),'</preamble>'))\n            read(unit,'(a)') line\n            trim_line = trim(line)\n            if (leqi(trim_line(1:24),'<pseudopotential_header>')) then\n               read (unit, '(1x,a2,1x,a2,1x,a3,1x,a4)') symbol2, xc_code, rel, pcc\n               if (leqi(pcc,'pcec')) then\n                  ps_info%flag_pcc = .true.\n               else !if (pcc .ne. 'pcec') then\n                  ps_info%flag_pcc = .false.\n               endif\n               ! set xc functional\n               if(xc_func==0) then\n                  if(leqi(xc_code,'ca')) then      ! lda; atom code uses pz81 but use pw92\n                     xc_func = functional_lda_pw92\n                  else if(leqi(xc_code,'pb')) then ! pbe\n                     xc_func = functional_gga_pbe96\n                  else if(leqi(xc_code,'rv')) then ! revpbe\n                     xc_func = functional_gga_pbe96_rev98\n                  else if(leqi(xc_code,'rp')) then ! rpbe\n                     xc_func = functional_gga_pbe96_r99\n                  else if(leqi(xc_code,'wc')) then ! wu-cohen\n                     xc_func = functional_gga_pbe96_wc\n                  end if\n               end if\n               read(unit,'(a)') line\n               trim_line = trim(line)\n               if(.not.leqi(trim_line(1:25),'</pseudopotential_header>')) then\n                  if(leqi(trim_line(2:4),'atm')) pseudo_type = 1 ! siesta-type\n               end if\n            else if (leqi(trim_line(1:14),'<conquest_pseu')) then\n               read(unit,'(a)') line ! check this for hamann\n               if(leqi(line(3:8),'hamann')) pseudo_type = 3\n               if(leqi(line(3:10),'hamann c')) read(unit,'(a)') line\n               read(unit,'(a)') line ! core radii\n               read(unit,'(a)') line ! valence shells\n               read(unit,'(a26,i7)') line, xc_func\n            endif\n         end do\n      endif\n\n      if(iprint_pseudo>1) then\n         read(unit,'(a2)') symbol\n         write(io_lun,fmt='(10x,\"symbol = \",a2)') symbol\n         read(unit,'(a20)') label\n         write(io_lun,fmt='(10x,\"label = \",a20)') label\n         read(unit,*) z\n         write(io_lun,fmt='(10x,\"z = \",i5)') z\n         read(unit,*) zval\n         write(io_lun,fmt='(10x,\"zval_int, zval = \",f12.5)') zval\n         read(unit,*) mass\n         write(io_lun,fmt='(10x,\"mass = \",g25.15)') mass\n         read(unit,*) self_energy\n         write(io_lun,fmt='(10x,\"self_energy = \",g25.15)') self_energy\n         read(unit,'(2i4)') lmax_basis, n_orbnl\n         write(io_lun,fmt='(10x,\"lmax_basis, n_orbnl = \",2i4)') lmax_basis, n_orbnl\n         read(unit,'(2i4)') lmax_projs, n_pjnl\n         write(io_lun,fmt='(10x,\"lmax_projs, n_pjnl = \",2i4)') lmax_projs, n_pjnl\n         if(xc_func/=0) write(io_lun,fmt='(10x,\"xc functional code = \",i8)') xc_func\n      else\n         read(unit,'(a2)') symbol\n         read(unit,'(a20)') label\n         read(unit,*) z\n         read(unit,*) zval!_int\n         !zval=zval_int\n         read(unit,'(g25.15)') mass\n         read(unit,'(g25.15)') self_energy\n         read(unit,'(2i4)') lmax_basis, n_orbnl\n         read(unit,'(2i4)') lmax_projs, n_pjnl\n      end if\n    end subroutine read_header_tmp\n  end subroutine read_ion_ascii_tmp\n"}
{"id": 62, "subroutine": "  subroutine new_simplelist(sl, simbox, particles, min_length, &\n       min_boundary_width, is_nx_even, is_ny_even, is_nz_even)\n    type(poly_box), intent(in) :: simbox\n    class(point), intent(in) :: particles(:)\n    real(dp), intent(in) :: min_length\n    real(dp), intent(in) :: min_boundary_width\n    logical, intent(in), optional :: is_nx_even, is_ny_even, is_nz_even\n    type(simplelist), intent(out) :: sl\n    sl%cached_box = simbox\n    sl%min_length = min_length\n    sl%min_boundary_width = min_boundary_width\n    if(present(is_nx_even)) sl%is_nx_even = is_nx_even\n    if(present(is_ny_even)) sl%is_ny_even = is_ny_even\n    if(present(is_nz_even)) sl%is_nz_even = is_nz_even\n    call calculate_dimensions(sl, simbox)\n    call simplelist_allocate(sl, size(particles))\n    !! :todo: could make the indices list size parameterizable or optimizable\n    call simplelist_populate(sl, simbox, particles)\n  end subroutine new_simplelist\n"}
{"id": 63, "subroutine": "  subroutine simplelist_allocate(sl, n)\n    type(simplelist), intent(inout) :: sl\n    integer, intent(in) :: n\n    allocate(sl%indices(n, 0:sl%nx - 1, 0:sl%ny - 1, 0:sl%nz - 1))\n    allocate(sl%counts(0:sl%nx - 1, 0:sl%ny - 1, 0:sl%nz - 1))\n    allocate(sl%coords(n, 3))\n    allocate(sl%xyzlist(n, 3))\n  end subroutine simplelist_allocate\n"}
{"id": 64, "subroutine": "  subroutine calculate_dimensions(sl, simbox)\n    type(simplelist), intent(inout) :: sl\n    type(poly_box), intent(in) :: simbox\n    \n    sl%nx = max(int(getx(simbox) / sl%min_length), 1)\n    sl%ny = max(int(gety(simbox) / sl%min_length), 1)\n    sl%nz = max(int(getz(simbox) / sl%min_length), 1)\n    \n    if (sl%is_nx_even) sl%nx = (sl%nx / 2) * 2\n    if (sl%is_ny_even) sl%ny = (sl%ny / 2) * 2\n    if (sl%is_nz_even) sl%nz = (sl%nz / 2) * 2\n    \n    if (sl%nx < 3) sl%nx = 1\n    if (sl%ny < 3) sl%ny = 1\n    if (sl%nz < 3) sl%nz = 1\n    \n    if (sl%nx < 4 .and. isxperiodic(simbox)) sl%nx = 1\n    if (sl%ny < 4 .and. isyperiodic(simbox)) sl%ny = 1\n    if (sl%nz < 4 .and. iszperiodic(simbox)) sl%nz = 1\n    \n    !! calculate cell side lengths\n    sl%lx = getx(simbox) / sl%nx\n    sl%ly = gety(simbox) / sl%ny\n    sl%lz = getz(simbox) / sl%nz\n    !! compute threshold from cell dimensions\n    sl%threshold = 0.5 * (minval([sl%lx, sl%ly, sl%lz]) - &\n         sl%min_length +  sl%min_boundary_width)\n  end subroutine calculate_dimensions\n"}
{"id": 65, "subroutine": "  subroutine simplelist_update(sl, simbox, particles)\n    type(simplelist), intent(inout) :: sl\n    type(poly_box), intent(in) :: simbox\n    class(point), dimension(:), intent(in) :: particles\n    real(dp) :: maxdiff\n    integer :: i\n    type(simplelist) :: temp\n    logical :: update_needed\n    maxdiff = 0.0\n    \n    !! check if simbox should have a different decomposition compared to cached\n    !! box.\n    temp%min_length = sl%min_length\n    call calculate_dimensions(temp, simbox)\n    update_needed = temp%nx /= sl%nx .or. temp%ny /= sl%ny .or. temp%nz /= sl%nz\n    \n    if (.not. update_needed) then\n       !! find out the particle that has moved the most in one direction:\n       !$omp parallel do shared(sl, particles), reduction(max:maxdiff), private(i)\n       do i = 1, size(particles)\n          maxdiff = maxval([maxval(abs(sl%xyzlist(i, :) - &\n               particles(i)%position())), maxdiff])\n       end do\n       !$omp end parallel do\n    end if\n    \n    if (update_needed .or. maxdiff > sl%threshold) then\n       sl%cached_box = simbox\n       call simplelist_deallocate(sl)\n       call calculate_dimensions(sl, simbox)\n       call simplelist_allocate(sl, size(particles))\n       call simplelist_populate(sl, simbox, particles)\n    end if\n  end subroutine simplelist_update\n"}
{"id": 66, "subroutine": "  subroutine simplelist_deallocate(sl)\n    type(simplelist), intent(inout) :: sl\n    if (allocated(sl%indices)) deallocate(sl%indices)\n    if (allocated(sl%counts)) deallocate(sl%counts)\n    if (allocated(sl%coords)) deallocate(sl%coords)\n    if (allocated(sl%xyzlist)) deallocate(sl%xyzlist)\n  end subroutine simplelist_deallocate\n"}
{"id": 67, "subroutine": "  subroutine simplelist_populate(sl, simbox, particles)\n    type(simplelist), intent(inout) :: sl\n    type(poly_box), intent(in) :: simbox\n    class(point), dimension(:), intent(in) :: particles\n    integer :: ix, iy, iz\n    integer :: iparticle\n    integer :: err\n    sl%indices = 0\n    sl%counts = 0\n    do iparticle = 1, size(particles)\n       !! calculate cell index assuming that the coordinates are centered\n       !! at the origin\n       !! we also assume that the coordinates have been transformed as\n       !! if (particle%x >= getx(simbox) / 2) then\n       !!     particle%x = particle%x - getx(simbox)\n       !! end if\n       !ix = int((particles(iparticle)%x / getx(simbox) + 0.5) * sl%nx)\n       !iy = int((particles(iparticle)%y / gety(simbox) + 0.5) * sl%ny)\n       !iz = int((particles(iparticle)%z / getz(simbox) + 0.5) * sl%nz)\n       call cell_index(sl, particles(iparticle), simbox, ix, iy, iz, err)\n       if (err /= 0) then\n          write(error_unit, *) 'error: particle coordinates '\n          call particles(iparticle)%to_unit(error_unit)\n          write(error_unit, *) 'are outside the box '\n          call simbox%to_unit(error_unit)\n          stop 'simplelist_populate unable to continue. (invalid cell index)'\n       end if\n       !! add to the right position in simplelist\n       sl%counts(ix, iy, iz) = sl%counts(ix, iy, iz) + 1\n       sl%indices(sl%counts(ix, iy, iz), ix, iy, iz) = iparticle\n       sl%coords(iparticle, :) = (/ix, iy, iz/)\n       sl%xyzlist(iparticle, :) = particles(iparticle)%position()\n    end do\n  end subroutine simplelist_populate\n"}
{"id": 68, "subroutine": "  elemental subroutine cell_index(sl, p, simbox, ix, iy, iz, err)\n    type(simplelist), intent(in) :: sl\n    class(point), intent(in) :: p\n    type(poly_box), intent(in) :: simbox\n    integer, intent(out) :: ix, iy, iz\n    integer, intent(out), optional :: err\n    if (present(err)) err = 0\n    ix = int((p%x / getx(simbox) + 0.5) * sl%nx)\n    iy = int((p%y / gety(simbox) + 0.5) * sl%ny)\n    iz = int((p%z / getz(simbox) + 0.5) * sl%nz)\n    if (present(err)) then\n       if (ix < 0 .or. ix >= sl%nx .or. iy < 0 .or. iy >= sl%ny .or. &\n            iz < 0 .or. iz >= sl%nz) then\n          err = -9\n       end if\n    end if\n  end subroutine cell_index\n"}
{"id": 69, "subroutine": "  pure subroutine simplelist_nbrmask(sl, simbox, i, mask)\n    type(simplelist), intent(in) :: sl\n    type(poly_box), intent(in) :: simbox\n    integer, intent(in) :: i \n    logical, intent(out) :: mask(:)\n    integer :: ix,iy,iz !! cell indices of particle i\n    mask=.false.\n    ix = sl%coords(i,1)\n    iy = sl%coords(i,2)\n    iz = sl%coords(i,3)\n    call simplelist_cell_nbrmask(sl, simbox, ix, iy, iz, mask)\n    mask(i)=.false.\n  end subroutine simplelist_nbrmask\n"}
{"id": 70, "subroutine": "  pure subroutine simplelist_cell_nbrmask(sl, simbox, ix, iy, iz, cell_nbrmask)\n    implicit none\n    type(simplelist), intent(in) :: sl\n    type(poly_box), intent(in) :: simbox\n    integer, intent(in) :: ix,iy,iz !! cell indices\n    logical, intent(out) :: cell_nbrmask(:)\n    integer :: x, y, z    !! iteration indices through neighbouring cell\n    integer :: xl, yl, zl\n    cell_nbrmask=.false.\n    do x=ix-1,ix+1\n       xl=x\n       if (isxperiodic(simbox)) xl=mod(sl%nx+xl,sl%nx)\n       if (xl>=0 .and. xl<=sl%nx-1) then\n          do y=iy-1,iy+1\n             yl=y\n             if (isyperiodic(simbox)) yl=mod(sl%ny+yl,sl%ny)\n             if (yl>=0 .and. yl<=sl%ny-1) then\n                do z=iz-1,iz+1\n                   zl=z\n                   if (iszperiodic(simbox)) zl=mod(sl%nz+zl,sl%nz)\n                   if (zl>=0 .and. zl<=sl%nz-1) then\n                      cell_nbrmask(&\n                           sl%indices(1:sl%counts(xl,yl,zl),xl,yl,zl))=.true.\n                   end if\n                end do\n             end if\n          end do\n       end if\n    end do\n  end subroutine simplelist_cell_nbrmask\n"}
{"id": 71, "subroutine": "subroutine simplelist_nbr_cells(sl, ix, iy, iz, nbr_cells, n_nbr_cells)\n  type(simplelist), intent(in) :: sl\n  integer, intent(in) :: ix, iy, iz\n  integer, intent(out) :: nbr_cells(3, 27)\n  integer, intent(out) :: n_nbr_cells\n  integer :: x, xl, y, yl, z, zl, k\n  logical :: is_new\n  associate(simbox => sl%cached_box)\n    n_nbr_cells = 0\n    nbr_cells = -1\n    do x=ix-1,ix+1\n       xl=x\n       if (isxperiodic(simbox)) xl=mod(sl%nx+xl,sl%nx)\n       if (xl>=0 .and. xl<=sl%nx-1) then\n          do y=iy-1,iy+1\n             yl=y\n             if (isyperiodic(simbox)) yl=mod(sl%ny+yl,sl%ny)\n             if (yl>=0 .and. yl<=sl%ny-1) then\n                do z=iz-1,iz+1\n                   zl=z\n                   if (iszperiodic(simbox)) zl=mod(sl%nz+zl,sl%nz)\n                   if (zl>=0 .and. zl<=sl%nz-1) then\n                      !! check if this cell is already in:\n                      is_new = .true.\n                      do k = 1, n_nbr_cells\n                         if (all(nbr_cells(:, k) == [xl, yl, zl])) then\n                            is_new = .false.\n                            exit\n                         end if\n                      end do\n                      if (is_new) then\n                         n_nbr_cells = n_nbr_cells + 1\n                         nbr_cells(:, n_nbr_cells) = [xl, yl, zl]\n                      end if\n                   end if\n                end do\n             end if\n          end do\n       end if\n    end do\n  end associate\nend subroutine simplelist_nbr_cells\n"}
{"id": 72, "subroutine": "  subroutine invoke_compute_z(zfld, pfld, ufld, vfld)\n    implicit none\n    type(r2d_field), intent(inout) :: zfld\n    type(r2d_field), intent(in)    :: pfld, ufld, vfld\n    ! locals\n    integer :: i, j\n    real(go_wp) :: dx, dy\n\n    dx = zfld%grid%dx\n    dy = zfld%grid%dy\n\n    do j=zfld%internal%ystart, zfld%internal%ystop, 1\n       do i=zfld%internal%xstart, zfld%internal%xstop, 1\n\n          call compute_z_code(i, j,      &\n                              zfld%data, &\n                              pfld%data, &\n                              ufld%data, &\n                              vfld%data, &\n                              dx, dy)\n\n       end do\n    end do\n\n  end subroutine invoke_compute_z\n"}
{"id": 73, "subroutine": "  subroutine compute_z_code(i, j, z, p, u, v, dx, dy)\n    implicit none\n    integer,  intent(in) :: i, j\n    real(go_wp), intent(in) :: dx, dy\n    real(go_wp), intent(inout), dimension(:,:) :: z\n    real(go_wp), intent(in),  dimension(:,:) :: p, u, v\n\n    ! original code looked like:\n    ! do j=1,n\n    !    do i=1,m\n    !       z(i+1,j+1) =(fsdx*(v(i+1,j+1)-v(i,j+1))-fsdy*(u(i+1,j+1) & \n    !                    -u(i+1,j)))/(p(i,j)+p(i+1,j)+p(i+1,j+1)+p(i,j+1))\n\n    z(i,j) =( (4.0d0/dx)*( v(i,j)-v(i-1,j))-    &\n              (4.0d0/dy)*( u(i,j)-u(i,j-1)) ) / &\n            (p(i-1,j-1)+p(i,j-1)+ p(i,j)+p(i-1,j))\n\n  end subroutine compute_z_code\n"}
{"id": 74, "subroutine": "subroutine omp_private(p)\n  integer :: a(10), b(10), c(10)\n  integer, pointer, intent(in) :: p\n\n  a = 10\n  b = 20\n\n  !error: pointer 'p' with the intent(in) attribute may not appear in a private clause\n  !$omp parallel private(p)\n  c = a + b + p\n  !$omp end parallel\n\n  print *, c\n\nend subroutine omp_private\n"}
{"id": 75, "subroutine": "subroutine matoutput(comment,rowname,unitmat,mat)\r\nimplicit none\r\ncharacter(len=*),intent(in)::comment\r\ncharacter(len=*),intent(in)::rowname(:)\r\ninteger,intent(in)::unitmat\r\nreal(kind=8),intent(in)::mat(:,:)\r\n!\tbuffers\r\ncharacter(len=4)::buffer\r\ncharacter(len=25)::buff(size(rowname))\r\n!\twrite format\r\ncharacter(len=9)::writefmt\r\n!\tcol counts columns.\r\n!\tio indicates write error.\r\n!\trow counts rows.\r\ninteger::col,io,row\r\nwrite(buffer,'(i4)')2*size(rowname)\r\nwritefmt='(a,'//trim(adjustl(buffer))//'a)'\r\nwrite(unitmat,'(a)') comment\r\nwrite(unit=unitmat,fmt=writefmt,iostat=io) \"row name\",(\",\",trim(adjustl(rowname(col))),col=1,size(rowname))\r\nif(io/=0) stop \"failure to write matrix.\"\r\ndo row=1,size(rowname)\r\n\tdo col=1,size(rowname)\r\n\t\twrite(buff(col),'(g25.16e3)') mat(row,col)\r\n\tend do\r\n\twrite(unit=unitmat,fmt=writefmt,iostat=io)&\r\n\t\t\t\ttrim(adjustl(rowname(row))),&\r\n\t\t\t\t(\",\",trim(adjustl(buff(col))),&\r\n\t\t\t\tcol=1,size(rowname))\r\n\tif(io/=0) stop \"failure to write matrix.\"\r\nend do\t\t\r\nreturn\r\nend subroutine matoutput\r\n"}
{"id": 76, "subroutine": "      subroutine sol_cls( iout )\n!-----------------------------------------------------------------------\n!\t... map solution species to solution method groups\n!-----------------------------------------------------------------------\n\n      use io\n      use var_mod, only : spccnt => new_nq, spcsym => new_solsym, clscnt, clsmap\n\n      implicit none\n\n!-----------------------------------------------------------------------\n!\t... dummy args\n!-----------------------------------------------------------------------\n      character(len=80), intent(inout) :: iout(*)\n\n!-----------------------------------------------------------------------\n!\t... local variables\n!-----------------------------------------------------------------------\n      integer, parameter ::  symlen = 8\n\n      integer  ::  kpar, i, parsw(5), nchar\n      integer  ::  toklen(20)\n      integer  ::  j, l\n      integer  ::  no_tokens\n      integer  ::  class\n      character(len=16) :: tokens(20)\n      character(len=10) :: clshdr(5) =  (/ 'explicit  ', 'ebi       ', &\n\t\t\t\t\t   'hov       ', 'implicit  ', &\n\t\t\t\t\t   'rodas     ' /)\n      character(len=11) :: clsend(5) =  (/ 'endexplicit', 'endebi     ', &\n\t\t\t\t\t   'endhov     ', 'endimplicit', &\n\t\t\t\t\t   'endrodas   ' /)\n      character(len=1)  :: char\n      logical  :: found\n\n      integer :: inilist\n\n!-----------------------------------------------------------------------\n!\t... initialization\n!-----------------------------------------------------------------------\n      parsw(:)  = 0 ; clscnt(:) = 0 ; clsmap(:,:,:) = 0\n\n      call cardin( lin, buff, nchar )\n      buffh = buff\n      call upcase( buffh )\n      if( buffh /= 'solutionclasses' ) then\n         call errmes( '\"solution classes\" card missing; run terminated@', &\n                      lout, char, 1, buff )\n      end if\n\n      do\n         call cardin(lin, buff, nchar )\n         buffh = buff\n         call upcase( buffh )\n         if( buffh == 'endsolutionclasses' ) then\n!-----------------------------------------------------------------------\n!       ... check for all species in class\n!-----------------------------------------------------------------------\n\t    if( sum( clscnt(:) ) /= spccnt ) then\n\t       write(lout,*) ' '\n\t       write(lout,*) 'following species not in a class'\n\t       write(lout,*) ' '\n\t       do l = 1,spccnt\n\t\t  found = .false.\n\t          do class = 1,5\n\t\t     if( clscnt(class) /= 0 ) then\n\t\t        j = inilist( l, clsmap(1,class,2), clscnt(class) )\n\t\t        if( j /= 0 ) then\n\t\t\t   found = .true.\n\t\t\t   exit\n\t\t        end if\n\t\t     end if\n\t          end do\n\t\t  if( .not. found ) then\n\t             write(lout,*) trim(spcsym(l))\n\t          end if\n\t       end do\n\t       stop 'abort'\n\t    end if\n            exit\n         end if\n\n\t found = .false.\n         do kpar = 1,5\n           if( buffh == clshdr(kpar) ) then\n\t      found = .true.\n\t      exit\n\t   end if\n         end do\n\t if( .not. found ) then\n            call errmes( '# is an invalid class header@',  &\n                         lout, &\n                         buff(:8), &\n                         8, &\n                         buff )\n         else if( parsw(kpar) /= 0 ) then\n            call errmes( '# solution class already declared@', &\n                      lout, &\n                      clshdr(kpar), &\n                      len_trim(clshdr(kpar)), &\n                      buff )\n         else\n            parsw(kpar) = 1\n         end if\n\n!-----------------------------------------------------------------------\n!       ... read the solution class members\n!-----------------------------------------------------------------------\nmethods : &\n         do\n            call cardin(lin, buff, nchar)\n            buffh = buff\n            call upcase( buffh )\n            if( buffh /= clsend(kpar) ) then\n               if( buffh(:nchar) == 'all' ) then\n\t\t  clscnt(:5) = 0\n                  clscnt(kpar) = spccnt\n\t\t  clsmap(:,:,:) = 0\n                  do j = 1,spccnt\n                     clsmap(j,kpar,1) = j\n                     clsmap(j,kpar,2) = j\n                  end do\n                  cycle\n\t       else if( buffh(:nchar) == 'allothers' ) then\n\t\t  clscnt(kpar) = 0\n\t\t  clsmap(:,kpar,:) = 0\n                  do j = 1,spccnt\n\t\t     if( sum( clsmap(j,:5,1) ) == 0 ) then\n\t\t\tclscnt(kpar) = clscnt(kpar) + 1\n                        clsmap(j,kpar,1) = clscnt(kpar)\n                        clsmap(clscnt(kpar),kpar,2) = j\n\t\t     end if\n                  end do\n                  cycle\n               end if\n               call gettokens( buff, &\n                               nchar, &\n                               ',', &\n                               symlen, &\n                               tokens, &\n                               toklen, &\n                               20, &\n                               no_tokens )\n               if( no_tokens == 0 ) then\n                  call errmes( ' species input line in error@', lout, buff, 1, ' ' )\n               end if\n\ntok_loop:      do j = 1,no_tokens\n                  do l = 1,spccnt\n                     if( trim(tokens(j)) == trim(spcsym(l)) ) then\n                        clscnt(kpar) = clscnt(kpar) + 1\n                        if( clscnt(kpar) > spccnt ) then\n                           call errmes( ' species count exceeds limit@', &\n                                        lout, &\n                                        buff, 1, buff )\n                        end if\n\t\t\tif( sum( clsmap(l,:5,1) ) /= 0 ) then\n                           call errmes( ' # in two or more classes@', &\n                                        lout, &\n                                        tokens(j), &\n                                        toklen(j), &\n                                        buff )\n\t\t        end if\n                        clsmap(l,kpar,1)            = clscnt(kpar)\n                        clsmap(clscnt(kpar),kpar,2) = l\n                        cycle tok_loop\n                     end if\n                  end do\n                  call errmes( ' class member # not in solution list@', &\n                               lout, &\n                               tokens(j), &\n                               toklen(j), &\n                               buff )\n               end do tok_loop\n\t    else\n\t       exit\n            end if\n\t end do methods\n      end do\n\n      end subroutine sol_cls\n"}
{"id": 77, "subroutine": "      subroutine dtran2 (r, t, ioper) \r\n      use vast_kind_param,only: double \r\n      real(double), dimension(3,3), intent(inout) :: r \r\n      real(double), dimension(5,5,12), intent(inout) :: t \r\n      integer, intent(in) :: ioper \r\n      end subroutine  \r\n"}
{"id": 78, "subroutine": "      subroutine initial\n      use global\n      implicit none\n!---------------------------------------------------------------------\n!     variables\n!---------------------------------------------------------------------\n!\n      allocate( ni(2,nxp4),        &\n     &          ne(2,nxp4))  \n!\n      allocate( pi(2,nxp4),        &\n     &          pe(2,nxp4)) \n!\n      allocate( vxi(2,nxp4),       &\n     &          vxe(2,nxp4))  \n !    \n      allocate( ph(2,nxp4),        &\n     &          ex(2,nxp4))\n!\n      allocate( fd0(1,nxp4),       &\n     &          fd1(2,nxp4),       &\n     &          fd2(2,nxp4))\n!\n      ni(:,:)   = ni(:,:)*0\n      ne(:,:)   = ne(:,:)*0\n      pi(:,:)   = pi(:,:)*0\n      pe(:,:)   = pe(:,:)*0\n      vxi(:,:)  = vxi(:,:)*0\n      vxe(:,:) = vxe(:,:)*0\n      ph(:,:)   = ph(:,:)*0\n      ex(:,:)   = ex(:,:)*0\n      fd0(:,:)  = fd0(:,:)*0\n      fd1(:,:)  = fd1(:,:)*0\n      fd2(:,:)  = fd2(:,:)*0\n      call system('mkdir -p ./data/n')\n      call system('mkdir -p ./data/vx')\n      call system('mkdir -p ./data/p')\n      call system('mkdir -p ./data/ex')\n!\n      end subroutine initial\n"}
{"id": 79, "subroutine": "  subroutine find_surface(dom, n1, n2, n3, n4, block, face) \n!------------------------------------------------------------------------------!\n!   searches for a block where the surface defined by n1, n2, n3, n4 is.       !\n!------------------------------------------------------------------------------!\n!----------------------------------[modules]-----------------------------------!\n  use domain_mod\n!------------------------------------------------------------------------------! \n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  type(domain_type)    :: dom\n  integer, intent(in)  :: n1, n2, n3, n4\n  integer, intent(out) :: block, face\n!-----------------------------------[locals]-----------------------------------!\n  integer :: b, fc, p1, p2, p3, p4\n!==============================================================================!\n\n  do b = 1, size(dom % blocks)\n    do fc = 1, 6\n      p1=dom % blocks(b) % faces(fc, 1)\n      p2=dom % blocks(b) % faces(fc, 2)\n      p3=dom % blocks(b) % faces(fc, 3)\n      p4=dom % blocks(b) % faces(fc, 4) \n      if( ((p1 == n1).and.(p3 == n3)) .or.  &\n          ((p1 == n4).and.(p3 == n2)) .or.  &\n          ((p1 == n3).and.(p3 == n1)) .or.  &\n          ((p1 == n2).and.(p3 == n4)) ) goto 1\n    end do     \n  end do \n\n  print *, '# error message from generator'\n  print *, '# you tried to define the surface', n1, n2, n3, n4\n  print *, '# but it doesn''t exists in the block specifications.'\n  print *, '# exiting !'\n  stop\n\n1 block=b\n  face =fc\n\n  end subroutine\n"}
{"id": 80, "subroutine": "      subroutine vex_init ( vexinit , nxa , nxb , nxbc , nya , nyb , nybc , nza , nzb , nzbc , xo , yo , zo , ro , fx , fy , fz , &\n         & wx , wy , wz , wr , x , y , z , vex3 )\n\n      implicit none\n\n      integer, intent ( in ) :: vexinit\n      integer, intent ( in ) :: nxa \n      integer, intent ( in ) :: nxb \n      integer, intent ( in ) :: nxbc\n      integer, intent ( in ) :: nya \n      integer, intent ( in ) :: nyb \n      integer, intent ( in ) :: nybc\n      integer, intent ( in ) :: nza \n      integer, intent ( in ) :: nzb \n      integer, intent ( in ) :: nzbc\n\n      real, intent ( in ) :: xo\n      real, intent ( in ) :: yo\n      real, intent ( in ) :: zo\n      real, intent ( in ) :: ro\n      real, intent ( in ) :: fx\n      real, intent ( in ) :: fy\n      real, intent ( in ) :: fz\n      real, intent ( in ) :: wx\n      real, intent ( in ) :: wy\n      real, intent ( in ) :: wz\n      real, intent ( in ) :: wr \n\n      real, dimension ( nxa - nxbc : nxb + nxbc ), intent ( in ) :: x\n      real, dimension ( nya - nybc : nyb + nybc ), intent ( in ) :: y\n      real, dimension ( nza - nzbc : nzb + nzbc ), intent ( in ) :: z\n      real, dimension ( nxa - nxbc : nxb + nxbc , nya - nybc : nyb + nybc , nza - nzbc : nzb + nzbc ), intent ( inout ) :: vex3\n\n      if ( vexinit == 0 ) then \n\n         call vex_3d_lin ( nxa , nxb , nxbc , nya , nyb , nybc , nza , nzb , nzbc , xo , yo , zo , fx , fy , fz , x , y , z , vex3 )\n\n      else if ( vexinit == 1 ) then \n\n         call vex_3d_sho ( nxa , nxb , nxbc , nya , nyb , nybc , nza , nzb , nzbc , xo , yo , zo , wx , wy , wz , x , y , z , vex3 )\n\n      else if ( vexinit == 2 ) then \n\n         call vex_3d_shor ( nxa , nxb , nxbc , nya , nyb , nybc , nza , nzb , nzbc , xo , yo , zo , ro , wr , wz , x , y , z , &\n            & vex3 )\n\n      else \n\n         write ( unit = error_unit , fmt = * ) 'gpse : vex : vex_init : error - vexinit not supported.'\n\n      end if\n\n      return\n\n      end subroutine\n"}
{"id": 81, "subroutine": "      subroutine vex_3d_lin ( nxa , nxb , nxbc , nya , nyb , nybc , nza , nzb , nzbc , xo , yo , zo , fx , fy , fz , x , y , z , &\n         & vex3 )\n\n      implicit none\n\n      integer, intent ( in ) :: nxa\n      integer, intent ( in ) :: nxb\n      integer, intent ( in ) :: nxbc\n      integer, intent ( in ) :: nya\n      integer, intent ( in ) :: nyb\n      integer, intent ( in ) :: nybc\n      integer, intent ( in ) :: nza\n      integer, intent ( in ) :: nzb\n      integer, intent ( in ) :: nzbc\n\n      real, intent ( in ) :: xo\n      real, intent ( in ) :: yo\n      real, intent ( in ) :: zo\n      real, intent ( in ) :: fx\n      real, intent ( in ) :: fy\n      real, intent ( in ) :: fz\n\n      real, dimension ( nxa - nxbc : nxb + nxbc ), intent ( in ) :: x\n      real, dimension ( nya - nybc : nyb + nybc ), intent ( in ) :: y\n      real, dimension ( nza - nzbc : nzb + nzbc ), intent ( in ) :: z\n      real, dimension ( nxa - nxbc : nxb + nxbc , nya - nybc : nyb + nybc , nza - nzbc : nzb + nzbc ), intent ( inout ) :: vex3\n\n      integer :: j , k , l\n\n!$omp parallel do if ( nza /= nzb ) default ( shared ) schedule ( static )\n      do l = nza , nzb\n\n!$omp    parallel do if ( nza == nzb ) default ( shared ) schedule ( static )\n         do k = nya , nyb\n\n            do j = nxa , nxb\n\n               vex3 ( j , k , l ) = vex3 ( j , k , l ) + fx * ( x ( j ) - xo ) + fy * ( y ( k ) - yo ) + fz * ( z ( l ) - zo )\n\n            end do\n\n         end do\n!$omp    end parallel do\n\n      end do\n!$omp end parallel do\n\n      return\n\n      end subroutine\n"}
{"id": 82, "subroutine": "      subroutine zeit_usage(progname)\n      implicit none\n      character*7 progname\n      if(progname.eq.'zeit_pr')then\n      print*,'usage:     zeit_pr.x [-i fname] [-o out_fname] [-d] [-h]'\n         print*,'-i         indicate use of a users registry file'\n         print*,'fname      input registry file. default is .zeit'\n         print*,'-o         indicate name of output file'\n         print*,'out_fname  output file to write current timings'\n         print*,'           default is standard output'\n         print*,'-d         option to remove registry when finished'\n         print*,'-h         option to print usage message'\n      elseif(progname.eq.'zeit_ci')then\n         print*,'usage is:   zeit_ci.x [-r fname] [-v] [name]'\n         print*,'-r fname    time register file name,' \n         print*,'            default is .zeit'\n         print*,'-v          verbose mode: prints wallclock'\n         print*,'            time'\n         print*,'name        name of program to be timed'\n      elseif(progname.eq.'zeit_co')then\n         print*,'usage is:   zeit_co.x [-r fname] [-v] [name]'\n         print*,'-r fname    time register file name,' \n         print*,'            default is .zeit'\n         print*,'-v          verbose mode: prints wallclock'\n         print*,'            time'\n         print*,'name        name of program to be timed'\n      endif\n      return\n      stop\n      end subroutine zeit_usage\n"}
{"id": 83, "subroutine": "   subroutine par_sc(dtm, dtp, psim, psi0, psip)\n   real*8, intent(in) :: dtm, dtp\n   real*8, intent(inout) :: psim, psi0, psip\n   real*8 :: exu, u0, u1 ,u2, d2, d3, d4\n         if (dtm.ge.trick) then\n            exu=dexp(-dtm)\n            u0=1.d0-exu\n            u1=dtm-1.d0+exu\n            u2=dtm**2-2.d0*dtm+2.d0-2.d0*exu\n         else\n            d2=dtm**2\n            d3=dtm**3\n            d4=dtm**4\n            u0=dtm-(d2/2.d0)\n            u1=(d2/2.d0)-(d3/6.d0)\n            u2=(d3/3.d0)-(d4/12.d0)\n        endif\n\n        if (dtm * dtp /= 0.d0 .and. dtm**2 /= 0.d0 .and. dtp**2 /= 0.d0) then\t\t\t  \n\t\t\t  psim=(u2-u1*(dtp+2.d0*dtm))/(dtm*(dtm+dtp))+u0\n      \t  psi0=(u1*(dtm+dtp)-u2)/(dtm*dtp)\n      \t  psip=(u2-dtm*u1)/(dtp*(dtm+dtp))\n\t \t  else\n\t\t  \t  psim = 0.d0\n\t\t\t  psi0 = 0.d0\n\t\t\t  psip = 0.d0\n\t\t  endif\n\t\t  \n   end subroutine par_sc\n"}
{"id": 84, "subroutine": "   subroutine lin_sc(dtm, psim, psi0)\n   real*8, intent(in) :: dtm\n\treal*8, intent(inout) :: psim, psi0\n   real*8 :: exu, u0, u1, c0, cm, d2\n\n      if (dtm.ge.trick) then\n         exu=dexp(-dtm)\n         u0=1.d0-exu\n         u1=dtm-1.d0+exu\n\n         c0=u1/dtm\n         cm=u0-c0\n      else   \n         d2=dtm**2.d0\n         c0=(dtm/2.d0)-(d2/6.d0)\n         cm=(dtm/2.d0)-(d2/3.d0)\n      endif\n\t\tpsi0 = c0\n\t\tpsim = cm\n\n   end subroutine lin_sc\n"}
{"id": 85, "subroutine": "subroutine g\ndo\n    a = a + i\n    b = 3\nenddo\n\ndo, i = 1, 5\n    a = a + i\nend do\n\nn = 0\ndo 50, i = 1, 10\n  j = i\n  do k = 1, 5\n    l = k\n    n = n + 1  ! this statement executes 50 times\n  end do       ! nonlabeled do inside a labeled do\n50 continue\n\nend subroutine\n"}
{"id": 86, "subroutine": "subroutine fileout (sz, g, psz4dex, s, dh, org, fname)\n  implicit none\n  integer                                                       :: nn, ix, jx, kx, i, j, k, g, l, lx\n  integer, dimension(4)                                         :: sz, psz4dex\n  real, dimension(sz(4)+psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3), 1-g:sz(3)+g+psz4dex(4)):: s\n  real                                                          :: rtime, dh\n  real, dimension(3)                                            :: org\n  character*20                                                  :: fname, tname\n\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = sz(4)\n\n  nn = 0\n  rtime = 0.0\n\n  do l=1,lx\n     write(tname,'(i3.3,\"_\",a10)') l,fname\n     open (unit=22, file=tname, form='unformatted')\n     write (22) 1, 1\n     write (22) ix, jx, kx\n     write (22) org(1), org(2), org(3)\n     write (22) dh, dh, dh\n     write (22) nn, rtime\n     write (22) (((s(l,i,j,k),i=1,ix),j=1,jx),k=1,kx)\n     close (unit=22)\n  end do\n\n  return\nend subroutine fileout\n"}
{"id": 87, "subroutine": "subroutine bc (sz, g, psz4dex, p, dh, vec_tag, vec_cnt)\n  implicit none\n  integer                                                        :: i, j, k, ix, jx, kx, g, l, lx, vec_cnt\n  integer, dimension(4)                                          :: sz, psz4dex\n  real, dimension(sz(4)+psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3), 1-g:sz(3)+g+psz4dex(3)) :: p\n  real                                                           :: pi, x, y, z, dh\n  integer, dimension(sz(4))                                      :: vec_tag\n\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = vec_cnt\n\n  pi = 2.0*asin(1.0)\n\n  do l=1,lx\n     if(mod(vec_tag(l),32)==1) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==2) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.1*sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.1*sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==3) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*sin(pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==4) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==5) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.1*sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.1*sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==6) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*sin(0.5*pi*x)*sin(pi*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==7) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==8) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.1*x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.1*x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==9) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*x*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==10) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==11) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 2.0*x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 2.0*x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==12) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*x*x*y*y\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==13) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.1*(x+y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.1*(x+y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==14) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.2*(x+y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.2*(x+y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==15) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*abs(sin(pi*x*4.0))\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*abs(sin(pi*x*4.0))\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(mod(vec_tag(l),32)==0) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.5*sin(pi*x)*sin(pi*x)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = 0.5*sin(pi*x)*sin(pi*x)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n       ! xplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,ix+1,j,k) = 0.0 !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0, k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,jx+1,k) = 0.0 !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(vec_tag(l)<0) then\n        ! zminus dirichlet\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, pi, dh) &\n        !$omp private(x, y)\n\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,0) = 0.0\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! zplus dirichlet\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx, pi, dh) &\n        !$omp private(x, y)\n\n        !$omp do schedule(static) collapse(2)\n        do j=1,jx\n           do i=1,ix\n              x = dh*real(i)\n              y = dh*real(j)\n              p(l,i,j,kx+1) = sin(x*y)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xminus\n        !$omp parallel &\n        !$omp firstprivate(jx, kx)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              p(l,0,   j,k) = 0.0 !-p(1, j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! xplus\n\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx) &\n        !$omp private(z, y)        \n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do j=1,jx\n              z = dh*real(k)\n              y = dh*real(j)\n              p(l,ix+1,j,k) = sin(y*z) !-p(ix,j,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n        ! yminus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx)\n\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              p(l,i,0,   k) = 0.0 !-p(i,1, k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n\n\n        ! yplus\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx) &\n        !$omp private(x, z)\n        !$omp do schedule(static) collapse(2)\n        do k=1,kx\n           do i=1,ix\n              x = dh*real(i)\n              z = dh*real(k)\n              p(l,i,jx+1,k) = sin(x*z) !-p(i,jx,k)\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n  end do\n\n  return\nend subroutine bc\n"}
{"id": 88, "subroutine": "subroutine exact (sz, g, e, dh)\n  implicit none\n  integer                                                      ::  i, j, k, ix, jx, kx, g, l, lx, n, m\n  integer, dimension(4)                                        ::  sz\n  real, dimension(sz(4),1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g) ::  e\n  real                                                         ::  dh, pi, r2, x, y, z\n  double precision                                             :: a,sum,w\n\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = sz(4)\n  r2 = sqrt(2.0)\n  pi = 2.0*asin(1.0)\n\n  do l=1,lx\n     if(l>0) then\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx) &\n        !$omp private(x, y, z)\n        !$omp do schedule(static) collapse(2)\n        do k=1, kx\n           do j=1, jx\n             do i=1, ix\n                 x = dh*real(i)\n                 y = dh*real(j)\n                 z = dh*real(k)\n                 e(l,i,j,k) = sin(pi*x)*sin(pi*y) / sinh(r2*pi) * ( sinh(r2*pi*z)-sinh(r2*pi*(z-1.0))  )\n              end do\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n\n     if(l<0) then\n        !$omp parallel &\n        !$omp firstprivate(ix, jx, kx) &\n        !$omp private(x, y, z)\n        !$omp do schedule(static) collapse(2)\n        do k=1, kx\n           do j=1, jx\n              do i=1, ix\n                 x = dh*real(i)\n                 y = dh*real(j)\n                 z = dh*real(k)\n                 e(l,i,j,k) = sin(x*y*z)\n              end do\n           end do\n        end do\n        !$omp end do\n        !$omp end parallel\n     end if\n  end do\n  return\nend subroutine exact\n"}
{"id": 89, "subroutine": "subroutine err (sz, g, dh, d, p, e, gosa)\n  implicit none\n  include \"cbc_f_params.h\"\n  integer                                                      ::  i, j, k, ix, jx, kx, g, l, lx\n  integer, dimension(4)                                        ::  sz\n  real, dimension(sz(4)+1,1-g:sz(1)+g+1, 1-g:sz(2)+g, 1-g:sz(3)+g) ::  p, e, gosa\n  real                                                         ::  r2, pi, x, y, z, r, dh\n  double precision,dimension(sz(4))                            ::  d\n\n  d=0.0d0\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = sz(4)\n\n  r2 = sqrt(2.0)\n  pi = 2.0*asin(1.0)\n\n  !$omp parallel &              \n  !$omp reduction(max:d) &\n  !$omp private(r) &   \n  !$omp firstprivate(ix, jx, kx, lx, dh,pi)       \n  !$omp do schedule(static) collapse(2)\n  do k=1, kx\n     do j=1, jx\n        do i=1, ix\n           do l=1, lx\n              r = p(l,i,j,k) -  e(l,i,j,k)\n              gosa(l,i,j,k) = r\n              d(l) = max(d(l), abs(dble(r)))\n           end do\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n\n  return\nend subroutine err\n"}
{"id": 90, "subroutine": "subroutine set_bcindex (sz, g, bp)\n  implicit none\n  integer                                                :: i, j, k, ix, jx, kx, g, l, lx\n  integer, dimension(3)                                  :: sz\n  real, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g,8) :: bp\n\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = 8\n\n  !$omp parallel &\n  !$omp firstprivate(ix, jx, kx)\n  !$omp do schedule(static) collapse(2)\n  do k=1-g,kx+g\n     do j=1-g,jx+g\n        do i=1-g,ix+g\n           bp(i,j,k,1) = 0!e\n           bp(i,j,k,2) = 0!w\n           bp(i,j,k,3) = 0!n\n           bp(i,j,k,4) = 0!s\n           bp(i,j,k,5) = 0!t\n           bp(i,j,k,6) = 0!b\n           bp(i,j,k,7) = 1!dig\n           bp(i,j,k,8) = 0!active\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n\n\n  !$omp parallel &\n  !$omp firstprivate(ix, jx, kx)\n  !$omp do schedule(static) collapse(2)\n  do k=1,kx\n     do j=1,jx\n        do i=1,ix\n           bp(i,j,k,1) = 1!e\n           bp(i,j,k,2) = 1!w\n           bp(i,j,k,3) = 1!n\n           bp(i,j,k,4) = 1!s\n           bp(i,j,k,5) = 1!t\n           bp(i,j,k,6) = 1!b\n           bp(i,j,k,7) = 6!dig\n           bp(i,j,k,8) = 1!active\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n\n  do k=1,kx\n     do j=1,jx\n        bp(1,j,k,2) = 0!w\n        bp(ix,j,k,1) = 0!e\n     end do\n  end do\n\n  do k=1,kx\n     do i=1,ix\n        bp(i,1,k,4) = 0!s\n        bp(i,jx,k,3) = 0!n\n     end do\n  end do\n\n  do j=1,jx\n     do i=1,ix\n        bp(i,j,1,6) = 0!t\n        bp(i,j,kx,5) = 0!b\n     end do\n  end do\n\n  do k=1,kx\n     bp(1,1,k,2) = 0!\n     bp(1,1,k,4) = 0!\n\n     bp(1,jx,k,2) = 0!\n     bp(1,jx,k,3) = 0!\n\n     bp(ix,1,k,1) = 0!\n     bp(ix,1,k,4) = 0!\n\n     bp(ix,jx,k,1) = 0!\n     bp(ix,jx,k,3) = 0!\n  end do\n\n  do j=1,jx\n     bp(1,j,1,2) = 0!\n     bp(1,j,1,6) = 0!\n\n     bp(1,j,kx,2) = 0!\n     bp(1,j,kx,5) = 0!\n     bp(ix,j,1,1) = 0!\n     bp(ix,j,1,6) = 0!\n\n     bp(ix,j,kx,1) = 0!\n     bp(ix,j,kx,5) = 0!\n  end do\n\n  do i=1,ix\n     bp(i,1,1,4) = 0!\n     bp(i,1,1,6) = 0!\n\n     bp(i,1,kx,4) = 0!\n     bp(i,1,kx,5) = 0!\n\n     bp(i,jx,1,3) = 0!\n     bp(i,jx,1,6) = 0!\n\n     bp(i,jx,kx,3) = 0!\n     bp(i,jx,kx,5) = 0!\n  end do\n\n  bp(1,1,1,2) = 0!\n  bp(1,1,1,4) = 0!\n  bp(1,1,1,6) = 0!\n\n  bp(1,1,kx,2) = 0!\n  bp(1,1,kx,4) = 0!\n  bp(1,1,kx,5) = 0!\n\n  bp(1,jx,1,2) = 0!\n  bp(1,jx,1,3) = 0!\n  bp(1,jx,1,6) = 0!\n\n  bp(1,jx,kx,2) = 0!\n  bp(1,jx,kx,3) = 0!\n  bp(1,jx,kx,5) = 0!\n\n  bp(ix,1,1,1) = 0!\n  bp(ix,1,1,4) = 0!\n  bp(ix,1,1,6) = 0!\n\n  bp(ix,1,kx,1) = 0!\n  bp(ix,1,kx,4) = 0!\n  bp(ix,1,kx,5) = 0!\n\n  bp(ix,jx,1,1) = 0!\n  bp(ix,jx,1,3) = 0!\n  bp(ix,jx,1,6) = 0!\n\n  bp(1,jx,kx,2) = 0!\n  bp(1,jx,kx,3) = 0!\n  bp(1,jx,kx,5) = 0!\n\n  bp(ix,1,1,1) = 0!\n  bp(ix,1,1,4) = 0!\n  bp(ix,1,1,6) = 0!\n\n  bp(ix,1,kx,1) = 0!\n  bp(ix,1,kx,4) = 0!\n  bp(ix,1,kx,5) = 0!\n\n  bp(ix,jx,1,1) = 0!\n  bp(ix,jx,1,3) = 0!\n  bp(ix,jx,1,6) = 0!\n\n  bp(ix,jx,kx,1) = 0!\n  bp(ix,jx,kx,3) = 0!\n  bp(ix,jx,kx,5) = 0!\n\n  return\nend subroutine set_bcindex\n"}
{"id": 91, "subroutine": "subroutine get_vec_sz (sz)\n  implicit none\n  include \"cbc_f_params.h\"\n  integer, dimension(4)                                       :: sz\n\n  sz(1) = grid_size\n  sz(2) = grid_size\n  sz(3) = grid_size\n  sz(4) = vector_num\n\n  return\nend subroutine get_vec_sz\n"}
{"id": 92, "subroutine": "subroutine change (sz, g, psz4dex, p, ch, vec_cnt)\n  implicit none\n  integer                    ::  i, j, k, ix, jx, kx,g, l, lx,ch, vec_cnt\n  integer,dimension(4)       ::  sz, psz4dex\n  real, dimension(sz(4)+psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) :: p\n  real                       ::  tmp\n\n  ix = sz(1)\n  jx = sz(2) \n  kx = sz(3)\n  lx = sz(4)\n  !$omp parallel &\n  !$omp private(tmp) &\n  !$omp firstprivate(ix, jx, kx, ch, vec_cnt)\n  !$omp do schedule(static) collapse(2)\n do k=1-g, kx+g+psz4dex(4)\n     do j=1-g, jx+g+psz4dex(3)\n        do i=1-g, ix+g+psz4dex(2)\n           tmp =  p(ch,i,j,k)\n           p(ch,i,j,k) = p(vec_cnt,i,j,k)\n           p(vec_cnt,i,j,k) = tmp\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n  return\nend subroutine change\n"}
{"id": 93, "subroutine": "subroutine array_reshape (sz, g, psz4dex, p0, p1, p, vec_cnt, table_con, num_con, table_not_con, num_not_con)\n  implicit none\n  integer                    ::  i, j, k, ix, jx, kx, g, l, lx, vec_cnt, offset\n  integer,dimension(4)       ::  sz, psz4dex\n  integer,dimension(256)     ::  table_con, table_not_con\n  integer                    ::  num_con, num_not_con\n  real, dimension(vec_cnt    +psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) ::  p0\n  real, dimension(num_not_con+psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) ::  p1\n  real, dimension(sz(4)      +psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) ::  p\n\n  ix = sz(1)\n  jx = sz(2) \n  kx = sz(3)\n  lx = sz(4)\n  offset = sz(4) - vec_cnt \n\n  !print *,\"re\",vec_cnt,table_con(1:sz(4)),num_con,table_not_con(1:sz(4)),num_not_con\n\n  !$omp parallel &\n  !$omp firstprivate(ix, jx, kx, vec_cnt, g, num_con, num_not_con, offset, table_con, table_not_con)\n  !$omp do schedule(static) collapse(2)\n  do k=1-g, kx+g+psz4dex(4)\n     do j=1-g, jx+g+psz4dex(3)\n        do i=1-g, ix+g+psz4dex(2)\n           do l=1,num_not_con\n              p1(l,i,j,k)= p0(table_not_con(l),i,j,k)\n           end do           \n           \n           do l=1,num_con\n              p(l+offset,i,j,k)=p0(table_con(l),i,j,k)\n           end do\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n  return\nend subroutine array_reshape\n"}
{"id": 94, "subroutine": "subroutine array_small (sz, g, psz4dex, p0, p1, vec_cnt, table_not_con, num_not_con)\n  implicit none\n  integer                    ::  i, j, k, ix, jx, kx, g, l, lx, vec_cnt\n  integer,dimension(4)       ::  sz, psz4dex\n  integer,dimension(256)     ::  table_not_con\n  integer                    ::  num_not_con\n  real, dimension(vec_cnt    +psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) ::  p0\n  real, dimension(num_not_con+psz4dex(1),1-g:sz(1)+g+psz4dex(2), 1-g:sz(2)+g+psz4dex(3),1-g:sz(3)+g+psz4dex(4)) ::  p1\n\n  ix = sz(1)\n  jx = sz(2) \n  kx = sz(3)\n  lx = sz(4)\n  !print *,\"small\",vec_cnt,num_not_con\n  !print *,\"     \",num_not_con,\":\",table_not_con(1:8)\n  \n  !$omp parallel &\n  !$omp firstprivate(ix, jx, kx, g, vec_cnt, table_not_con, num_not_con)\n  !$omp do schedule(static) collapse(2)\n  do k=1-g, kx+g+psz4dex(4)\n     do j=1-g, jx+g+psz4dex(3)\n        do i=1-g, ix+g+psz4dex(2)\n           do l=1,num_not_con\n              p1(l,i,j,k)=p0(table_not_con(l),i,j,k)\n           end do\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n  return\nend subroutine array_small\n"}
{"id": 95, "subroutine": "subroutine init_array (sz, g, p)\n  implicit none\n  integer                    ::  i, j, k, ix, jx, kx, g, l, lx\n  integer,dimension(4)       ::  sz\n  real, dimension(sz(4)    +1,1-g:sz(1)+g+1, 1-g:sz(2)+g,1-g:sz(3)+g) ::  p\n\n  ix = sz(1)\n  jx = sz(2)\n  kx = sz(3)\n  lx = sz(4)\n  !print *,\"small\",vec_cnt,num_not_con\n  !print *,\"     \",num_not_con,\":\",table_not_con(1:8)\n\n  !$omp parallel &\n  !$omp firstprivate(ix, jx, kx, g)\n  !$omp do schedule(static) collapse(2)\n  do k=1-g, kx+g\n     do j=1-g, jx+g\n        do i=1-g, ix+g+1\n           do l=64,sz(4)\n              p(l,i,j,k)=1.0\n           end do\n        end do\n     end do\n  end do\n  !$omp end do\n  !$omp end parallel\n  return\nend subroutine init_array\n"}
{"id": 96, "subroutine": "  subroutine q1()\n    !! find roots via newton's method\n    print \"(a)\", \"1. roots of x^3 - x + 0.25 = 0:\"\n    print \"(f12.6)\", newton(f1, df1, x0=-1.0, tol=1e-6)\n    print \"(f12.6)\", newton(f1, df1, x0= 0.0, tol=1e-6)\n    print \"(f12.6)\", newton(f1, df1, x0= 1.0, tol=1e-6)\n    print *\n  end subroutine\n"}
{"id": 97, "subroutine": "subroutine slabrange(maxzn,ximat,yimat,zimat,sourcemlat,xnrange,ynrange)\n\n!takes in a subgrid and the max altitude of interest for neutral interpolation and then computes\n!what the maximum xn and yn will be for that slab\n! zzz - also this is specific to dipole grids right now...\n\nreal(wp), intent(in) :: maxzn\nreal(wp), dimension(:,:,:), intent(in) :: ximat,yimat,zimat\nreal(wp), intent(in) :: sourcemlat\nreal(wp), dimension(2), intent(out) :: xnrange,ynrange     !for min and max\n\nreal(wp), dimension(:,:,:), allocatable :: xitmp,yitmp,zitmp\ninteger :: lx1tmp\ninteger, dimension(size(ximat,2),size(ximat,3)) :: ix1stmp\ninteger :: ix1tmp\nlogical :: flagsh\ninteger :: ix1\n\n\n!in what hemisphere is our source?\nif (sourcemlat<=0) then\n  flagsh=.true.\nelse\n  flagsh=.false.\nend if\n\n\n!peel the grid in half (source hemisphere if closed dipole)\nif (gridflag==0) then    !closed dipole grid\n\n  ix1=maxloc(pack(zimat(:,1,1),.true.),1)    !apex is by definition the highest altitude along a given field line\n  if (flagsh) then\n    lx1tmp=ix1                  !first piece of arrays\n  else\n    lx1tmp=lx1-ix1    !second (end) piece of arrays\n  end if\n  allocate(xitmp(lx1tmp,lx2,lx3),yitmp(lx1tmp,lx2,lx3),zitmp(lx1tmp,lx2,lx3))   !could this be done more less wastefully with pointers???\n\n  if(flagsh) then    !southern hemisphere\n    xitmp=ximat(1:ix1,1:lx2,1:lx3)          !select beginning of the array - the southern half\n    yitmp=yimat(1:ix1,1:lx2,1:lx3)\n    zitmp=zimat(1:ix1,1:lx2,1:lx3)\n  else               !northern hemisphere\n      xitmp=ximat(ix1+1:lx1,1:lx2,1:lx3)    !select end half of the array\n      yitmp=yimat(ix1+1:lx1,1:lx2,1:lx3)\n      zitmp=zimat(ix1+1:lx1,1:lx2,1:lx3)\n  end if\nelse     !this is not an interhemispheric grid so our approach is to just use all of the data\n  lx1tmp=lx1\n  allocate(xitmp(lx1tmp,lx2,lx3),yitmp(lx1tmp,lx2,lx3),zitmp(lx1tmp,lx2,lx3))   !could this be done more less wastefully with pointers?\n  xitmp=ximat(1:lx1,1:lx2,1:lx3)\n  yitmp=yimat(1:lx1,1:lx2,1:lx3)\n  zitmp=zimat(1:lx1,1:lx2,1:lx3)\n!  flagsh=.true.    !treat is as southern, doesn't really matter in this case...\nend if\n\n\n!the min and max x are simply determined by longitude...\nxnrange(1)=minval(xitmp)\nxnrange(2)=maxval(xitmp)\n\n\n!situation is more complicated for latitude due to dipole grid, need to determine by l-shell\nif (flagsh) then\n  ix1=minloc(zitmp(:,1,1)-maxzn,1,zitmp(:,1,1)-maxzn > 0)    !find the min distance from maxzn subject to constraint that it is > 0, just use the first longitude slice since they will all have the same l-shell-field line relations\n  ynrange(2)=yitmp(ix1,1,1)\n  ix1=minloc(zitmp(:,lx2,1),1,zitmp(:,lx2,1) < 0)\n  ynrange(1)=yitmp(ix1,lx2,1)\nelse    !things are swapped around in nh\n  ix1=minloc(zitmp(:,1,1)-maxzn,1,zitmp(:,1,1)-maxzn > 0)    !find the min distance from maxzn subject to constraint that it is > 0; this is the southernmost edge of the neutral slab we need\n  ynrange(1)=yitmp(ix1,1,1)\n  ix1=minloc(zitmp(:,lx2,1),1,zitmp(:,lx2,1) < 0)\n  ynrange(2)=yitmp(ix1,lx2,1)\nend if\n\ndeallocate(xitmp,yitmp,zitmp)\n\nend subroutine slabrange\n"}
{"id": 98, "subroutine": "subroutine range2inds(ranges,zn,xnall,ynall,indices)\n\n!! determine where the slab described by ranges falls within the global neutral grid\n\nreal(wp), dimension(6), intent(in) :: ranges\nreal(wp), dimension(:), intent(in) :: zn,xnall,ynall\ninteger, dimension(6), intent(out) :: indices\n\nreal(wp) :: minzn,maxzn,minxn,maxxn,minyn,maxyn\ninteger :: ixn,iyn\n\n\n!for clarity\nminzn=ranges(1)\nmaxzn=ranges(2)\nminxn=ranges(3)\nmaxxn=ranges(4)\nminyn=ranges(5)\nmaxyn=ranges(6)\n\n\n!always use the full z-range\nindices(1)=1\nindices(2)=lzn\n\n\n!x-range\nixn=1\ndo while (ixn<lxnall .and. xnall(ixn)<minxn)\n  ixn=ixn+1\nend do\nindices(3)=max(ixn-1,1)    !just to be sure go back one index so that we cover the min range, don't let index fall below zero\ndo while (ixn<lxnall .and. xnall(ixn)<maxxn)\n  ixn=ixn+1\nend do\nindices(4)=ixn\n\n\n!y-range\niyn=1\ndo while (iyn<lynall .and. ynall(iyn)<minyn)\n  iyn=iyn+1\nend do\nindices(5)=max(iyn-1,1)    !just to be sure go back one index so that we cover the min range\ndo while (iyn<lynall .and. ynall(iyn)<maxyn)\n  iyn=iyn+1\nend do\nindices(6)=iyn\n\nprint*, '!!!!!!!!!!!!!!!!!'\nprint*, mpi_cfg%myid\nprint*, ranges\nprint*, indices\nprint*, lxnall,lynall\nprint*, xnall(indices(3)),xnall(indices(4))\nprint*, ynall(indices(5)),ynall(indices(6))\nprint*, '!!!!!!!!!!!!!!!!!'\n\n\n!corner cases - range is not at all within the neutral grid...  manifests as both indices being either 1 or lxi, interpolation should zero these out...\n\nend subroutine range2inds\n"}
{"id": 99, "subroutine": "        pure subroutine givens(a, d, i, j, c, s, t, tau)\n            double precision, intent(in)  :: a(n, n), d(n)\n            integer,          intent(in)  :: i, j\n            double precision, intent(out) :: c, s, t, tau\n            double precision              :: theta, g, h, aij\n\n            aij = a(i, j)\n            g = hundred * dabs(aij)\n            h = d(j) - d(i)\n            if (dabs(h) + g == dabs(h)) then\n                ! sign(a, b) returns a with the sign of b\n                ! we need to add epsilon with the proper sign\n                ! since h might be -epsilon causing a division by zero.\n                t = aij / (h + sign(epsilon(h), h))\n            else\n                ! sign(a, b) returns a with the sign of b\n                ! we need to add epsilon with the proper sign\n                ! since aij might be -epsilon causing a division by zero.\n                theta = f12 * h / (aij + sign(epsilon(aij), aij))\n                t = one / (dabs(theta) + dsqrt(one + theta ** 2))\n                if (theta < zero) then\n                    t = -t\n                endif\n            endif\n\n            ! c = cos(theta)\n            c = one / dsqrt(one + t ** 2)\n\n            ! s = sin(theta)\n            s = t * c\n\n            tau = s / (one + c)\n        end subroutine\n"}
{"id": 100, "subroutine": "        pure subroutine apply_rotation_av(a, d, z, i, j, v)\n            double precision, intent(inout) :: a(n, n), d(n), z(n)\n            integer,          intent(in)    :: i, j\n            double precision, intent(inout) :: v(n, n)\n            double precision                :: c, s, t, tau\n            integer                         :: k\n            double precision                :: g, h\n\n            ! compute the rotation angle theta\n            ! reference:    rutishauser, h. the jacobi method for real symmetric matrices.\n            !               numer. math. 9, 1-10 (1966). https://doi.org/10.1007/bf02165223\n\n            call givens(a, d, i, j, c, s, t, tau)\n\n            !\n            ! apply givens rotation to matrix\n            !\n\n            h = t * a(i, j)\n            z(i) = z(i) - h\n            z(j) = z(j) + h\n            d(i) = d(i) - h\n            d(j) = d(j) + h\n            a(i, j) = zero\n\n            do k = 1, i-1\n                g = a(k, i)\n                h = a(k, j)\n                a(k, i) = g - s * (h + g * tau)\n                a(k, j) = h + s * (g - h * tau)\n            enddo\n\n            do k = i+1, j-1\n                g = a(i, k)\n                h = a(k, j)\n                a(i, k) = g - s * (h + g * tau)\n                a(k, j) = h + s * (g - h * tau)\n            enddo\n\n            do k = j+1, n\n                g = a(i, k)\n                h = a(j, k)\n                a(i, k) = g - s * (h + g * tau)\n                a(j, k) = h + s * (g - h * tau)\n            enddo\n\n            do k = 1, n\n                ! accumulate eigenvector\n                g = v(k, i)\n                h = v(k, j)\n                v(k, i) = c * g - s * h\n                v(k, j) = s * g + c * h\n            enddo\n        end subroutine apply_rotation_av\n"}
{"id": 101, "subroutine": "        pure subroutine jacobi_diagonalise(a, d, v)\n            double precision, intent(inout) :: a(n, n)\n            double precision, intent(out)   :: d(n)\n            double precision, intent(out)   :: v(n, n)\n            double precision                :: b(n), z(n)\n            integer                         :: i, j\n            double precision                :: sm\n\n            ! initialise eigenvector matrix to identity matrix\n            do j = 1, n\n                d(j) = a(j, j)\n                b(j) = d(j)\n                z(j) = zero\n                do i = 1, n\n                    v(i, j) = zero\n                    if (i == j) then\n                        v(i, j) = one\n                    endif\n                enddo\n            enddo\n\n\n            ! sum of off-diagonal entries\n            ! sm should convergence to zero\n            sm = dabs(a(1, 2)) + dabs(a(1, 3)) + dabs(a(2, 3))\n\n            do while (sm >= atol)\n\n                do i = 1, n-1\n                    do j = i+1, n\n                        call apply_rotation_av(a, d, z, i, j, v)\n                    enddo\n                enddo\n\n                b = b + z\n                d = b\n                z = zero\n                ! update sum of off-diagonals\n                sm = dabs(a(1, 2)) + dabs(a(1, 3)) + dabs(a(2, 3))\n            enddo\n\n            call sort_descending(d, v)\n\n        end subroutine jacobi_diagonalise\n"}
{"id": 102, "subroutine": "        pure subroutine sort_descending(d, v)\n            double precision, intent(inout) :: d(n)\n            double precision, intent(inout) :: v(n, n)\n            double precision                :: teval, tevec(n)\n\n            if (d(2) > d(1)) then\n                teval = d(1)\n                d(1) = d(2)\n                d(2) = teval\n                tevec = v(:, 1)\n                v(:, 1) = v(:, 2)\n                v(:, 2) = tevec\n            endif\n\n            if (d(3) > d(2)) then\n                teval = d(2)\n                d(2) = d(3)\n                d(3) = teval\n                tevec = v(:, 2)\n                v(:, 2) = v(:, 3)\n                v(:, 3) = tevec\n            endif\n\n            if (d(2) > d(1)) then\n                teval = d(1)\n                d(1) = d(2)\n                d(2) = teval\n                tevec = v(:, 1)\n                v(:, 1) = v(:, 2)\n                v(:, 2) = tevec\n            endif\n        end subroutine sort_descending\n"}
{"id": 103, "subroutine": "        pure subroutine sort_eigenvalues(d)\n            double precision, intent(inout) :: d(n)\n            double precision                :: teval\n\n            if (d(2) > d(1)) then\n                teval = d(1)\n                d(1) = d(2)\n                d(2) = teval\n            endif\n\n            if (d(3) > d(2)) then\n                teval = d(2)\n                d(2) = d(3)\n                d(3) = teval\n            endif\n\n            if (d(2) > d(1)) then\n                teval = d(1)\n                d(1) = d(2)\n                d(2) = teval\n            endif\n        end subroutine sort_eigenvalues\n"}
{"id": 104, "subroutine": "subroutine initair(obj,temp,co2,o2)\n    class(air_),intent(inout) :: obj\n    real(real64),optional,intent(in) :: temp,co2,o2\n\n    obj%temp = input(default=304.0d0, option=temp)\n    obj%co2 = input(default=380.0d0, option=co2)\n    obj%o2 = input(default=202000.0d0, option=o2)\n\nend subroutine\n"}
{"id": 105, "subroutine": "subroutine initialise_storage( this, capacity )\r\n    class(universal_storage), intent(inout) :: this\r\n    integer, intent(in)                     :: capacity\r\n\r\n    allocate( this%element(capacity) )\r\n\r\nend subroutine initialise_storage\r\n"}
{"id": 106, "subroutine": "subroutine add_storage( this, idx, item )\r\n    class(universal_storage), intent(inout) :: this\r\n    integer, intent(in)                     :: idx\r\n    class(*), intent(in)                    :: item\r\n\r\n    if ( .not. allocated(this%element) ) then\r\n        write(*,*) 'storage not initialised!'\r\n        stop\r\n    endif\r\n\r\n    if ( idx < 1 .or. idx > size(this%element) ) then\r\n        write(*,*) 'index out of range for the storage!'\r\n        stop\r\n    endif\r\n\r\n    if ( allocated( this%element(idx)%data ) ) then\r\n        deallocate( this%element(idx)%data )\r\n    endif\r\n\r\n    !\r\n    ! use sourced allocation: adopt the dynamic type and copy the value\r\n    !\r\n    allocate( this%element(idx)%data, source = item )\r\n\r\nend subroutine add_storage\r\n"}
{"id": 107, "subroutine": "subroutine get_storage_real( this, idx, item, success )\r\n    class(universal_storage), intent(inout) :: this\r\n    integer, intent(in)                     :: idx\r\n    real, intent(out)                       :: item\r\n    logical, intent(out)                    :: success\r\n\r\n    if ( .not. allocated(this%element) ) then\r\n        write(*,*) 'storage not initialised!'\r\n        stop\r\n    endif\r\n\r\n    if ( idx < 1 .or. idx > size(this%element) ) then\r\n        write(*,*) 'index out of range for the storage!'\r\n        stop\r\n    endif\r\n\r\n    ! no data item stored at given index\r\n    if (.not. allocated( this%element(idx)%data ) ) then\r\n        success = .false.\r\n        return\r\n    endif\r\n\r\n\r\n    success = .true.\r\n\r\n    select type ( v => this%element(idx)%data )\r\n        type is (real)\r\n            item = v\r\n        class default\r\n            success = .false. ! wrong type\r\n    end select\r\n\r\nend subroutine get_storage_real\r\n"}
{"id": 108, "subroutine": "    subroutine init_gauss10(self)\n        implicit none\n        class(gauss_type), intent(inout) :: self\n        call self%init_vectors(nr_points)\n        self%ws(1)  = 0.2955242247147529; self%xs(1)  = -0.1488743389816312\n        self%ws(2)  = 0.2955242247147529; self%xs(2)  =  0.1488743389816312\n        self%ws(3)  = 0.2692667193099963; self%xs(3)  = -0.4333953941292472\n        self%ws(4)  = 0.2692667193099963; self%xs(4)  =  0.4333953941292472\n        self%ws(5)  = 0.2190863625159820; self%xs(5)  = -0.6794095682990244\n        self%ws(6)  = 0.2190863625159820; self%xs(6)  =  0.6794095682990244\n        self%ws(7)  = 0.1494513491505806; self%xs(7)  = -0.8650633666889845\n        self%ws(8)  = 0.1494513491505806; self%xs(8)  =  0.8650633666889845\n        self%ws(9)  = 0.0666713443086881; self%xs(9)  = -0.9739065285171717\n        self%ws(10) = 0.0666713443086881; self%xs(10) =  0.9739065285171717\n    end subroutine init_gauss10\n"}
{"id": 109, "subroutine": "    subroutine init_vectors(self, n, stat)\n        implicit none\n        class(gen_gauss_type), intent(inout) :: self\n        integer, intent(in) :: n\n        integer, intent(inout), optional :: stat\n        integer :: istat\n        allocate(self%xs(n), stat=istat)\n        if (istat /= 0) then\n            if (present(stat)) then\n                stat = istat\n                return\n            else\n                stop 'can not allocate x values'\n            end if\n        end if\n        allocate(self%ws(n), stat=istat)\n        if (istat /= 0) then\n            if (present(stat)) then\n                stat = istat\n                return\n            else\n                stop 'can not allocate w values'\n            end if\n        end if\n    end subroutine init_vectors\n"}
{"id": 110, "subroutine": "    subroutine init_gen_gauss(self, n, precision, stat)\n        implicit none\n        class(gen_gauss_type), intent(inout) :: self\n        integer, intent(in) :: n\n        real(kind=dp), intent(in), optional :: precision\n        integer, intent(inout), optional :: stat\n        integer :: istat, i\n        real(kind=dp) :: z, z1, pp\n        if (present(precision)) then\n            self%precision = precision\n        else\n            self%precision = default_precision\n        end if\n        call self%init_vectors(n)\n        do i = 1, n\n            z = cos(pi*(i - 0.25_dp)/(n + 0.5_dp))\n            call compute_zs(z, z1, pp, n)\n            do while ((z - z1) > self%precision)\n                call compute_zs(z, z1, pp, n)\n            end do\n            self%xs(i) = -z\n            self%ws(i) = 2.0_dp/((1.0_dp - z**2)*pp**2)\n        end do\n        \n    contains\n\n        subroutine compute_zs(z, z1, pp, n)\n            implicit none\n            real(kind=dp), intent(inout) :: z\n            real(kind=dp), intent(out) :: z1, pp\n            integer, intent(in) :: n\n            integer :: i\n            real(kind=dp) :: p1, p2, p3 \n            p1 = 1.0_dp\n            p2 = 0.0_dp\n            do i = 1, n\n                p3 = p2\n                p2 = p1\n                p1 = ((2*i - 1)*z*p2 - (i - 1)*p3)/i\n            end do\n            pp = n*(z*p1 - p2)/(z**2 - 1.0_dp)\n            z1 = z\n            z = z1 - p1/pp\n        end subroutine compute_zs\n\n    end subroutine init_gen_gauss\n"}
{"id": 111, "subroutine": "    subroutine print_params(self)\n        implicit none\n        class(gen_gauss_type), intent(in) :: self\n        integer :: i\n        do i = 1, size(self%xs)\n            print '(2f20.15)', self%xs(i), self%ws(i)\n        end do\n    end subroutine print_params\n"}
{"id": 112, "subroutine": "      subroutine elmout ( int_elem_id, dum_bug, case_num, opt )\n\n \n      use pentium_ii_kind, only       :  byte, long, double\n      use iount1, only                :  wrt_err, wrt_log, bug, f04\n      use scontr, only                :  blnk_sub_nam, eldt_bug_dat1_bit, eldt_bug_dat2_bit, eldt_bug_me_bit, eldt_bug_p_t_bit,  &\n                                         eldt_bug_se_bit, eldt_bug_ke_bit, eldt_bug_u_p_bit, mbug, mdt, melgp, metype,             &\n                                         mematr, mematc, meprop, mpress, nsub, ntsub, sol_name\n      use timdat, only                :  tsec\n      use subr_begend_levels, only    :  elmout_begend\n      use constants_1, only           :  conv_rad_deg, zero\n      use params, only                :  cbmin3, cbmin4, elforcen, quadaxis, quad4typ\n      use nonlinear_params, only      :  load_istep\n      use model_stuf, only            :  agrid, bgrid, be1, be2, be3, bensum, bmeant, can_elem_type_offset, dofpin, dt, elas_comp, &\n                                         eid, eb, em, es, et, elem_len_ab, eldof, elmtyp, elgp, emat, eprop, fconv, hbar, ke, ked, &\n                                         me, mxwarp, num_plies, num_sei, offdis, offset, pcomp_props, peb, peg, pel, phi_sq,       &\n                                         ppe, press, psi_hat, pte, quad_delta, quad_gamma, quad_theta, se1, se2, se3,              &\n                                         shell_t, shrsum, ste1, ste2, ste3, thetam, te, type, ueb, ueg, uel, xeb, xel, scnum,      &\n                                         sublod, ult_stre, ult_strn\n      implicit none\n \n      character(len=*), intent(in)    :: opt(6)              ! array of emg option indicators explained above\n      character( 1*byte)              :: found               ! used in determining if we found something we were looking for\n      character(60*byte)              :: name1               ! text used for output print purposes\n      character(21*byte)              :: name2               ! text used for output print purposes\n      character(12*byte)              :: name3               ! text used for output print purposes\n  \n      integer(long), intent(in)       :: int_elem_id         ! internal element id for which\n      integer(long), intent(in)       :: case_num            ! can be subcase number (e.g. for uel, pel output)\n      integer(long), intent(in)       :: dum_bug(0:mbug-1)   ! indicator for output of elem data to bug file\n      integer(long), parameter        :: subr_begend = elmout_begend\n\n      end subroutine elmout\n"}
{"id": 113, "subroutine": "            subroutine choose_model\n            end subroutine choose_model\n"}
{"id": 114, "subroutine": "subroutine randomize_model(params, nodes, modelin, modelout)\n  use param_structure\n  use nodes_information\n  use model_structure\n  implicit none\n  type (nodes_info) :: nodes\n  type (parameters) :: params\n  type (model) :: modelin, modelout\n  integer :: i, j, idx\n  real :: kk\n  logical, save :: firsttime = .true.\n!\n  if(firsttime) then\n     call random_seed\n     firsttime = .false.\n  end if\n!\n  modelout=modelin\n\n  if (nodes%n_nodes_t .gt. 0) then\n     call random_number(kk)\n     modelout%temp=modelout%temp + (kk-0.5)*600.\n  end if\n\n  if (nodes%n_nodes_v .gt. 0) then\n     call random_number(kk)\n     modelout%v_los=modelout%v_los + (kk-.5)*5.e5\n  end if\n\n  if (nodes%n_nodes_mic .gt. 0) then\n     call random_number(kk)\n     modelout%v_mic=modelout%v_mic + kk*3.e5\n  end if\n\n  if (nodes%n_nodes_blong .gt. 0) then\n     call random_number(kk)\n     modelout%b_long=modelout%b_long + (kk-.5)*1000.\n  end if\n\n  if (nodes%n_nodes_bx .gt. 0) then\n     call random_number(kk)\n     modelout%b_x=modelout%b_x + (kk-.5)*1000.\n  end if\n\n  if (nodes%n_nodes_by .gt. 0) then\n     call random_number(kk)\n     modelout%b_y=modelout%b_y + (kk-.5)*1000.\n  end if\n\n  if (nodes%n_nodes_stray .gt. 0) then\n     call random_number(kk)\n     modelout%stray=kk*.7\n  end if\n\n  if (nodes%n_nodes_ffactor .gt. 0) then\n     call random_number(kk)\n     modelout%ffactor=kk*.5\n  end if\n\n  if (nodes%n_nodes_mac .gt. 0) then\n     call random_number(kk)\n     modelout%v_mac=kk*2.e5\n  end if\n\n  if (nodes%n_nodes_ab .gt. 0) then\n     do idx=1, nodes%n_nodes_ab\n        call random_number(kk)\n        modelout%abundance(nodes%i_nodes_ab(idx))= &\n             modelout%abundance(nodes%i_nodes_ab(idx))+(kk-0.5)*.2\n     end do\n  end if\n\n  ! debug\n  !  modelout%v_mac=modelin%v_mac\n  ! modelout%v_mac=2.e5  \n  \nend subroutine randomize_model\n"}
{"id": 115, "subroutine": "subroutine bug1\n   use iso_c_binding\n   implicit none\n   type(c_ptr) :: m\n   type mytype\n     integer a, b, c\n   end type mytype\n   type(mytype) x\n   print *, transfer(32512, x)  ! works.\n   print *, transfer(32512, m)  ! caused ice.\nend subroutine bug1 \n"}
{"id": 116, "subroutine": "subroutine bug6\n   use iso_c_binding\n   implicit none\n   interface\n      function fun()\n         use iso_c_binding\n         implicit none\n         type(c_funptr) fun\n      end function fun\n   end interface\n   type(c_ptr) array(2)\n   type(c_funptr) result\n   integer(c_intptr_t), parameter :: const(*) = [32512,32520]\n\n   result = fun()\n   array = transfer([integer(c_intptr_t)::32512,32520],array)\n!   write(*,*) transfer(result,const)\n!   write(*,*) transfer(array,const)\nend subroutine bug6\n"}
{"id": 117, "subroutine": "  subroutine nst_init_()\n     implicit none\n  end subroutine nst_init_\n"}
{"id": 118, "subroutine": "  subroutine nst_read_(mype_io)\n     use kinds,         only: i_kind\n     implicit none\n\n     integer(i_kind), intent(in   ) :: mype_io\n     \n  end subroutine nst_read_\n"}
{"id": 119, "subroutine": "  subroutine nst_final_()\n     implicit none\n  end subroutine nst_final_\n"}
{"id": 120, "subroutine": "  subroutine skindepth_(obstype, zob)\n     use kinds,   only: r_kind\n     implicit none\n\n     character(10), intent(in)  :: obstype\n     real(r_kind),  intent(out) :: zob\n  end subroutine skindepth_\n"}
{"id": 121, "subroutine": "  subroutine deter_nst_(dlat_earth,dlon_earth,obstime,zob,tref,dtw,dtc,tz_tr)\n     use kinds,   only: r_kind\n     implicit none\n\n     real(r_kind), intent(in ) :: dlat_earth,dlon_earth,obstime,zob\n     real(r_kind), intent(out) :: tref,dtw,dtc,tz_tr\n  end subroutine deter_nst_\n"}
{"id": 122, "subroutine": "subroutine gsi_nstcoupler_init_nml\n\n  use mpimod, only: mype\n\n  implicit none\n  \n  if ( mype == 0 ) &\n    write(6,*)'nst_init_nml_: initializing default nst namelist variables'\n\n  nst_gsi   = 0          ! 0 = no nst info at all in gsi\n                         ! 1 = read nst info but not applied\n                         ! 2 = read nst info, applied to tb simulation but no tr analysis\n                         ! 3 = read nst info, applied to tb simulation and do tr analysis\n  nstinfo   = 0          ! number of nst fields used in tr analysis\n  zsea1     = 0          ! upper depth to do the mean\n  zsea2     = 0          ! lower depth to do the mean\n  fac_dtl   = 1          ! indicator to apply dtl model\n  fac_tsl   = 1          ! indicator to apply tsl model\n\n  return\n\nend subroutine gsi_nstcoupler_init_nml\n"}
{"id": 123, "subroutine": "  subroutine foo(bar)\n    integer bar(..)\n  end subroutine\n"}
{"id": 124, "subroutine": "    subroutine allocr64var(var, size)\n        double precision, allocatable, intent(inout) :: var(:)\n        integer, intent(in) :: size\n        if (allocated(var)) deallocate(var)\n        allocate(var(size))\n        var = 0.0d0\n    end subroutine\n"}
{"id": 125, "subroutine": "      subroutine transf (f, g, c, norb) \r\n      use vast_kind_param,only: double \r\n      integer, intent(in) :: norb \r\n      real(double), dimension(norb,norb), intent(in) :: f \r\n      real(double), dimension(norb,norb), intent(out) :: g \r\n      real(double), dimension(norb,norb), intent(in) :: c       \r\n      end subroutine  \r\n"}
{"id": 126, "subroutine": "  subroutine m_register_sdden(m_name,a)\n    implicit none\n\n    !**** input ***********************************!\n\n    real(dp), intent(in), target :: a(:,:) ! two-dimensional array containing the matrix elements\n\n    !**** inout ***********************************!\n\n    type(matrix), intent(inout) :: m_name ! matrix to be allocated\n\n    !**** internal ********************************!\n\n    integer :: dim(2)\n\n    !**********************************************!\n\n    dim=shape(a)\n    m_name%dim1=dim(1)\n    m_name%dim2=dim(2)\n    if (m_name%dim1==m_name%dim2) then\n       m_name%is_square=.true.\n    else\n       m_name%is_square=.false.\n    end if\n    m_name%str_type='den'\n    m_name%is_serial=.true.\n    m_name%is_real=.true.\n    m_name%is_sparse=.false.\n\n    m_name%dval => a\n\n    m_name%is_initialized=.true.\n\n  end subroutine m_register_sdden\n"}
{"id": 127, "subroutine": "  subroutine fini(x)\n     type(t) :: x\n     if (cnt == -1) call abort ()\n     cnt = cnt + 1\n  end subroutine fini\n"}
{"id": 128, "subroutine": "  subroutine stokes2d_1_mg\n  \n!<description>\n  ! this is an all-in-one stokes solver for directly solving a stokes\n  ! problem without making use of special features like collections\n  ! and so on. the routine performs the following tasks:\n  !\n  ! 1.) read in parametrisation\n  ! 2.) read in triangulation\n  ! 3.) set up rhs\n  ! 4.) set up matrix\n  ! 5.) create solver structure\n  ! 6.) solve the problem\n  ! 7.) write solution to gmv file\n  ! 8.) release all variables, finish\n!</description>\n\n\n    ! definitions of variables.\n    !\n    ! we need a couple of variables for this problem. let us see...\n    !\n    ! an array of problem levels for the multigrid solver\n    type(t_level), dimension(:), pointer :: rlevels\n\n    ! an object for saving the domain:\n    type(t_boundary) :: rboundary\n\n    ! an object specifying the discretisation.\n    ! this contains also information about trial/test functions,...\n    type(t_blockdiscretisation) :: rprjdiscretisation\n    \n    ! a bilinear and linear form describing the analytic problem to solve\n    type(t_bilinearform) :: rform\n    type(t_linearform) :: rlinform\n\n    ! a block matrix and a couple of block vectors. these will be filled\n    ! with data for the linear solver.\n    type(t_vectorblock) :: rvector,rrhs,rtempblock,rprjvector\n    \n    ! a set of variables describing the analytic and discrete boundary\n    ! conditions.\n    type(t_boundaryregion) :: rboundaryregion\n    type(t_discretebc), target :: rprjdiscretebc\n\n    ! a solver node that accepts parameters for the linear solver\n    type(t_linsolnode), pointer :: p_rsolvernode,p_rpreconditioner,&\n                                   p_rcoarsegridsolver,p_rsmoother\n\n    ! an array for the system matrix(matrices) during the initialisation of\n    ! the linear solver.\n    type(t_matrixblock), dimension(:), pointer :: rmatrices\n\n    ! one level of multigrid\n    type(t_linsolmg2levelinfo), pointer :: p_rlevelinfo\n    \n    ! nlmin receives the level of the coarse grid.\n    integer :: nlmin\n\n    ! nlmax receives the level where we want to solve.\n    integer :: nlmax\n    \n    ! viscosity parameter nu = 1/re\n    real(dp) :: dnu\n    \n    ! error indicator during initialisation of the solver\n    integer :: ierror\n    \n    ! output block for ucd output to gmv file\n    type(t_ucdexport) :: rexport\n    character(len=sys_strlen) :: sucddir\n    real(dp), dimension(:), pointer :: p_ddata,p_ddata2\n\n    ! a counter variable\n    integer :: i\n\n    ! path to the mesh\n    character(len=sys_strlen) :: spredir\n\n    ! a collection structure for post-processing\n    type(t_collection) :: rcollection\n\n    ! error data structures for post-processing\n    type(t_errorscvec) :: rerroru, rerrorp\n\n    ! error arrays for post-processing\n    real(dp), dimension(2), target :: derrorul2, derroruh1\n    real(dp), dimension(1), target :: derrorpl2\n\n    ! ok, let us start.\n    !\n    ! we want to solve our stokes problem on level...\n    nlmin = 2\n    nlmax = 7\n    \n    ! viscosity parameter:\n    dnu = 1.0_dp\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! read the domain, read the mesh, refine\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! allocate memory for all levels\n    allocate(rlevels(nlmin:nlmax))\n\n    ! get the path $predir from the environment, where to read .prm/.tri files\n    ! from. if that does not exist, write to the directory \"./pre\".\n    if (.not. sys_getenv_string(\"predir\", spredir)) spredir = \"./pre\"\n\n    ! at first, read in the parametrisation of the boundary and save\n    ! it to rboundary.\n    call boundary_read_prm(rboundary, trim(spredir)//\"/quad.prm\")\n        \n    ! now read in the basic triangulation into our coarse level.\n    call tria_readtrifile2d (rlevels(nlmin)%rtriangulation, &\n                             trim(spredir)//\"/quad.tri\", rboundary)\n    \n    ! refine the mesh up to the minimum level\n    call tria_quickrefine2levelordering (nlmin-1,&\n        rlevels(nlmin)%rtriangulation,rboundary)\n    \n    ! and create information about adjacencies and everything one needs\n    ! from a triangulation.\n    call tria_initstandardmeshfromraw (rlevels(nlmin)%rtriangulation,&\n        rboundary)\n    \n    ! now refine the grid for the fine levels.\n    do i = nlmin+1, nlmax\n\n      ! refine the grid using the 2-level-ordering algorithm\n      call tria_refine2levelordering(rlevels(i-1)%rtriangulation,&\n          rlevels(i)%rtriangulation,rboundary)\n      \n      ! create a standard mesh\n      call tria_initstandardmeshfromraw(rlevels(i)%rtriangulation,&\n          rboundary)\n    \n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up a discretisation structure which tells the code which\n    ! finite element to use\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! now we can start to initialise the discretisation. at first, set up\n    ! a block discretisation structure that specifies 3 blocks in the\n    ! solution vector.\n    do i = nlmin, nlmax\n      call spdiscr_initblockdiscr (rlevels(i)%rdiscretisation, 3, &\n                                   rlevels(i)%rtriangulation, rboundary)\n    end do\n\n    ! rdiscretisation%rspatialdiscr is a list of scalar\n    ! discretisation structures for every component of the solution vector.\n    ! we have a solution vector with three components:\n    !  component 1 = x-velocity\n    !  component 2 = y-velocity\n    !  component 3 = pressure\n    do i = nlmin, nlmax\n      ! for simplicity, we set up one discretisation structure for the\n      ! velocity...\n      call spdiscr_initdiscr_simple (&\n          rlevels(i)%rdiscretisation%rspatialdiscr(1),&\n          el_em30, rlevels(i)%rtriangulation, rboundary)\n                  \n      ! ...and copy this structure also to the discretisation structure\n      ! of the 2nd component (y-velocity). this needs no additional memory,\n      ! as both structures will share the same dynamic information afterwards.\n      call spdiscr_duplicatediscrsc (&\n          rlevels(i)%rdiscretisation%rspatialdiscr(1),&\n          rlevels(i)%rdiscretisation%rspatialdiscr(2))\n\n      ! for the pressure (3rd component), we set up a separate discretisation\n      ! structure, as this uses different finite elements for trial and test\n      ! functions.\n      call spdiscr_derivesimplediscrsc (rlevels(i)%rdiscretisation%rspatialdiscr(1), &\n          el_q0, rlevels(i)%rdiscretisation%rspatialdiscr(3))\n    \n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up an cubature info structure to tell the code which cubature\n    ! formula to use\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n                 \n    do i = nlmin, nlmax\n      ! create an cubature information structure which tells the code\n      ! the cubature formula to use. standard: gauss 3x3.\n      call spdiscr_createdefcubstructure(&  \n          rlevels(i)%rdiscretisation%rspatialdiscr(1),&\n          rlevels(i)%rcubatureinfo,cub_gen_auto_g3)\n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! create a 3x3 block matrix with the operator\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    do i = nlmin, nlmax\n    \n      ! initialise the block matrix with default values based on\n      ! the discretisation.\n      call lsysbl_creatematblockbydiscr (rlevels(i)%rdiscretisation,&\n                                         rlevels(i)%rmatrix)\n      \n      ! inform the matrix that we build a saddle-point problem.\n      ! normally, imatrixspec has the value lsysbs_mspec_general,\n      ! but probably some solvers can use the special structure later.\n      rlevels(i)%rmatrix%imatrixspec = lsysbs_mspec_saddlepoint\n      \n      ! now as the discretisation is set up, we can start to generate\n      ! the structure of the system matrix which is to solve.\n      ! we create that directly in the block (1,1) of the block matrix\n      ! using the discretisation structure of the first block.\n      !\n      ! create the matrix structure of the x-velocity.\n      call bilf_creatematrixstructure (&\n          rlevels(i)%rdiscretisation%rspatialdiscr(1),&\n          lsyssc_matrix9, rlevels(i)%rmatrix%rmatrixblock(1,1))\n\n      ! in the stokes problem, the matrix for the y-velocity is identical to\n      ! the matrix for the x-velocity; both are laplace-matrices!\n      ! therefore, we can simply make a copy of the matrix for the x-velocity.\n      ! this we do later after the entries are created.\n      !\n      ! in the global system, there are two coupling matrices b1 and b2.\n      ! both have the same structure.\n      !\n      !    ( a         b1 )\n      !    (      a    b2 )\n      !    ( b1^t b2^t    )\n      !\n      ! create the matrices structure of the pressure using the 3rd\n      ! spatial discretisation structure in p_rdiscretisation%rspatialdiscr.\n      call bilf_creatematrixstructure (&\n          rlevels(i)%rdiscretisation%rspatialdiscr(3),&\n          lsyssc_matrix9, rlevels(i)%rmatrixb1,&\n          rlevels(i)%rdiscretisation%rspatialdiscr(1))\n                \n      ! duplicate the b1 matrix structure to the b2 matrix, so use\n      ! lsyssc_duplicatematrix to create b2. share the matrix\n      ! structure between b1 and b2 (b1 is the parent and b2 the child).\n      ! do not create a content array yet, it will be created by\n      ! the assembly routines later.\n      call lsyssc_duplicatematrix (rlevels(i)%rmatrixb1, rlevels(i)%rmatrixb2,&\n                                   lsyssc_dup_copy, lsyssc_dup_remove)\n                                       \n      ! and now to the entries of the matrix. for assembling of the entries,\n      ! we need a bilinear form, which first has to be set up manually.\n      ! we specify the bilinear form (grad psi_j, grad phi_i) for the\n      ! scalar system matrix in 2d.\n      rform%itermcount = 2\n      rform%idescriptors(1,1) = der_deriv_x\n      rform%idescriptors(2,1) = der_deriv_x\n      rform%idescriptors(1,2) = der_deriv_y\n      rform%idescriptors(2,2) = der_deriv_y\n\n      ! in the standard case, we have constant coefficients:\n      rform%ballcoeffconstant = .true.\n      rform%dcoefficients(1)  = dnu\n      rform%dcoefficients(2)  = dnu\n\n      ! now we can build the matrix entries.\n      ! we specify the callback function coeff_laplace for the coefficients.\n      ! as long as we use constant coefficients, this routine is not used.\n      ! by specifying ballcoeffconstant = .false. above,\n      ! the framework will call the callback routine to get analytical data.\n      !\n      ! we pass our collection structure as well to this routine,\n      ! so the callback routine has access to everything what is\n      ! in the collection.\n      !\n      ! build the x-velocity matrix:\n      call bilf_buildmatrixscalar (rform,.true.,&\n          rlevels(i)%rmatrix%rmatrixblock(1,1), rlevels(i)%rcubatureinfo, coeff_stokes_2d)\n      \n      ! duplicate the matrix to the y-velocity matrix, share structure and\n      ! content between them (as the matrices are the same).\n      call lsyssc_duplicatematrix (rlevels(i)%rmatrix%rmatrixblock(1,1),&\n          rlevels(i)%rmatrix%rmatrixblock(2,2),lsyssc_dup_share,lsyssc_dup_share)\n      \n      ! manually change the discretisation structure of the y-velocity\n      ! matrix to the y-discretisation structure.\n      ! ok, we use the same discretisation structure for both, x- and y-velocity,\n      ! so this is not really necessary - we do this for sure...\n      call lsyssc_assigndiscretisation (rlevels(i)%rmatrix%rmatrixblock(2,2),&\n          rlevels(i)%rdiscretisation%rspatialdiscr(2))\n                                  \n      ! build the first pressure matrix b1.\n      ! again first set up the bilinear form, then call the matrix assembly.\n      rform%itermcount = 1\n      rform%idescriptors(1,1) = der_func\n      rform%idescriptors(2,1) = der_deriv_x\n\n      ! in the standard case, we have constant coefficients:\n      rform%ballcoeffconstant = .true.\n      rform%dcoefficients(1)  = -1.0_dp\n      \n      call bilf_buildmatrixscalar (rform,.true.,rlevels(i)%rmatrixb1,&\n          rlevels(i)%rcubatureinfo,coeff_pressure_2d)\n\n      ! build the second pressure matrix b2.\n      ! again first set up the bilinear form, then call the matrix assembly.\n      rform%itermcount = 1\n      rform%idescriptors(1,1) = der_func\n      rform%idescriptors(2,1) = der_deriv_y\n\n      ! in the standard case, we have constant coefficients:\n      rform%ballcoeffconstant = .true.\n      rform%dcoefficients(1)  = -1.0_dp\n      \n      call bilf_buildmatrixscalar (rform,.true.,rlevels(i)%rmatrixb2,&\n          rlevels(i)%rcubatureinfo,coeff_pressure_2d)\n                                  \n      ! the b1/b2 matrices exist up to now only in our local problem structure.\n      ! put a copy of them into the block matrix.\n      !\n      ! note that we share the structure of b1/b2 with those b1/b2 of the\n      ! block matrix, while we create copies of the entries. the reason is\n      ! that these matrices are modified for boundary conditions later.\n      call lsyssc_duplicatematrix (rlevels(i)%rmatrixb1, &\n          rlevels(i)%rmatrix%rmatrixblock(1,3),lsyssc_dup_share,lsyssc_dup_copy)\n\n      call lsyssc_duplicatematrix (rlevels(i)%rmatrixb2, &\n          rlevels(i)%rmatrix%rmatrixblock(2,3),lsyssc_dup_share,lsyssc_dup_copy)\n      \n      ! furthermore, put b1^t and b2^t to the block matrix.\n      call lsyssc_transposematrix (rlevels(i)%rmatrixb1, &\n          rlevels(i)%rmatrix%rmatrixblock(3,1),lsyssc_tr_virtual)\n\n      call lsyssc_transposematrix (rlevels(i)%rmatrixb2, &\n          rlevels(i)%rmatrix%rmatrixblock(3,2),lsyssc_tr_virtual)\n\n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! create rhs and solution vectors\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! next step: create a rhs vector, a solution vector and a temporary\n    ! vector. all are filled with zero.\n    call lsysbl_createvectorblock (rlevels(nlmax)%rdiscretisation,rrhs,.true.)\n    call lsysbl_createvectorblock (rlevels(nlmax)%rdiscretisation,rvector,.true.)\n    call lsysbl_createvectorblock (rlevels(nlmax)%rdiscretisation,rtempblock,.true.)\n\n    ! the vector structure is ready but the entries are missing.\n    ! so the next thing is to calculate the content of that vector.\n    !\n    ! at first set up the corresponding linear form (f,phi_j):\n    rlinform%itermcount = 1\n    rlinform%idescriptors(1) = der_func\n    \n    ! ... and then discretise the rhs to the first two subvectors of\n    ! the block vector using the discretisation structure of the\n    ! corresponding blocks.\n    !\n    ! note that the vector is unsorted after calling this routine!\n    call linf_buildvectorscalar (&\n        rlinform,.true.,rrhs%rvectorblock(1),rlevels(nlmax)%rcubatureinfo,coeff_rhs_x_2d)\n\n    call linf_buildvectorscalar (&\n        rlinform,.true.,rrhs%rvectorblock(2),rlevels(nlmax)%rcubatureinfo,coeff_rhs_y_2d)\n                                \n    ! the third subvector must be zero - as it represents the rhs of\n    ! the equation \"div(u) = 0\".\n    call lsyssc_clearvector(rrhs%rvectorblock(3))\n                                \n    ! clear the solution vector on the finest level.\n    call lsysbl_clearvector(rvector)\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! assembly of matrices/vectors finished\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! discretise the boundary conditions and apply them to the matrix/rhs/sol.\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    do i = nlmin, nlmax\n\n      ! for implementing boundary conditions, we use a `filter technique with\n      ! discretised boundary conditions`. this means, we first have to calculate\n      ! a discrete version of the analytic bc, which we can implement into the\n      ! solution/rhs vectors using the corresponding filter.\n      !\n      ! create a t_discretebc structure where we store all discretised boundary\n      ! conditions.\n      call bcasm_initdiscretebc(rlevels(i)%rdiscretebc)\n      \n      ! we first set up the boundary conditions for the x-velocity, then those\n      ! of the y-velocity.\n      !\n      ! we \"know\" already (from the problem definition) that we have four boundary\n      ! segments in the domain. each of these, we want to use for enforcing\n      ! some kind of boundary condition.\n      !\n      ! we ask the boundary routines to create a \"boundary region\" - which is\n      ! simply a part of the boundary corresponding to a boundary segment.\n      ! a boundary region roughly contains the type, the min/max parameter value\n      ! and whether the endpoints are inside the region or not.\n      call boundary_createregion(rboundary,1,1,rboundaryregion)\n      \n      ! the endpoint of this segment should also be dirichlet. we set this by\n      ! changing the region properties in rboundaryregion.\n      rboundaryregion%iproperties = bdr_prop_withstart + bdr_prop_withend\n      \n      ! we use this boundary region and specify that we want to have dirichlet\n      ! boundary there. the following call does the following:\n      ! - create dirichlet boundary conditions on the region rboundaryregion.\n      !   we specify icomponent=\"1\" to indicate that we set up the\n      !   dirichlet bc`s for the first (here: one and only) component in the\n      !   solution vector.\n      ! - discretise the boundary condition so that the bc`s can be applied\n      !   to matrices and vectors\n      ! - add the calculated discrete bc`s to rlevels(i)%rdiscretebc for later use.\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,1,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n                               \n      ! edge 2 is neumann boundary, so it is commented out.\n      ! call boundary_createregion(rboundary,1,2,rboundaryregion)\n      ! call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,1,&\n      !                                    rboundaryregion,rlevels(i)%rdiscretebc,&\n      !                                    getboundaryvalues_2d)\n                               \n      ! edge 3 of boundary component 1.\n      call boundary_createregion(rboundary,1,3,rboundaryregion)\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,1,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n      \n      ! edge 4 of boundary component 1. that is it.\n      call boundary_createregion(rboundary,1,4,rboundaryregion)\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,1,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n\n      ! now continue with defining the boundary conditions of the y-velocity:\n      !\n      ! define edge 1.\n      call boundary_createregion(rboundary,1,1,rboundaryregion)\n      \n      ! edge with start- and endpoint.\n      rboundaryregion%iproperties = bdr_prop_withstart + bdr_prop_withend\n      \n      ! as we define the y-velocity, we now set icomponent=2 in the following call.\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,2,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n                               \n      ! edge 2 is neumann boundary, so it is commented out.\n      ! call boundary_createregion(rboundary,1,2,rboundaryregion)\n      ! call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,2,&\n      !                                    rboundaryregion,rlevels(i)%rdiscretebc,&\n      !                                    getboundaryvalues_2d)\n                               \n      ! edge 3 of boundary component 1.\n      call boundary_createregion(rboundary,1,3,rboundaryregion)\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,2,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n      \n      ! edge 4 of boundary component 1. that is it.\n      call boundary_createregion(rboundary,1,4,rboundaryregion)\n      call bcasm_newdirichletbconrealbd (rlevels(i)%rdiscretisation,2,&\n                                        rboundaryregion,rlevels(i)%rdiscretebc,&\n                                        getboundaryvalues_2d)\n\n      ! next step is to implement boundary conditions into the matrix.\n      ! this is done using a matrix filter for discrete boundary conditions.\n      ! the discrete boundary conditions are already attached to the\n      ! matrix. call the appropriate matrix filter that modifies the matrix\n      ! according to the boundary conditions.\n      call matfil_discretebc (rlevels(i)%rmatrix,rlevels(i)%rdiscretebc)\n    \n      ! create a filter chain for the solver that implements boundary conditions\n      ! during the solution process.\n      call filter_initfilterchain (rlevels(i)%rfilterchain,rlevels(i)%nfilters)\n      call filter_newfilterdiscbcdef (&\n          rlevels(i)%rfilterchain,rlevels(i)%nfilters,rlevels(i)%rdiscretebc)\n\n    end do\n\n    ! also implement the discrete boundary conditions on the finest level\n    ! onto our right-hand-side and solution vectors.\n\n    call vecfil_discretebcrhs (rrhs,rlevels(nlmax)%rdiscretebc)\n    call vecfil_discretebcsol (rvector,rlevels(nlmax)%rdiscretebc)\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up a linear solver\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! now we have to build up the level information for multigrid.\n    !\n    ! create a multigrid-solver. attach the above filter chain\n    ! to the solver, so that the solver automatically filters\n    ! the vector during the solution process.\n    call linsol_initmultigrid2 (p_rsolvernode,nlmax-nlmin+1)\n    \n    ! set up a bicgstab solver with vanka preconditioning as coarse grid solver:\n    call linsol_initvanka (p_rpreconditioner,1.0_dp,linsol_vanka_2dnavst)\n    call linsol_initbicgstab (p_rcoarsegridsolver,p_rpreconditioner,&\n        rlevels(nlmin)%rfilterchain)\n    \n    ! the coarse grid in multigrid is always grid 1!\n    call linsol_getmultigrid2level (p_rsolvernode,1,p_rlevelinfo)\n    p_rlevelinfo%p_rcoarsegridsolver => p_rcoarsegridsolver\n    p_rlevelinfo%p_rfilterchain => rlevels(nlmin)%rfilterchain\n\n    ! now set up the other levels...\n    do i = nlmin+1, nlmax\n    \n      ! set up the vanka smoother.\n      call linsol_initvanka (p_rsmoother,1.0_dp,linsol_vanka_2dnavst)\n      \n      ! we will use 4 smoothing steps with damping parameter 0.7\n      call linsol_converttosmoother(p_rsmoother, 4, 0.7_dp)\n      \n      ! and add this multi-grid level. we will use the same smoother\n      ! for pre- and post-smoothing.\n      call linsol_getmultigrid2level (p_rsolvernode,i-nlmin+1,p_rlevelinfo)\n      p_rlevelinfo%p_rpresmoother => p_rsmoother\n      p_rlevelinfo%p_rpostsmoother => p_rsmoother\n      p_rlevelinfo%p_rfilterchain => rlevels(i)%rfilterchain\n      \n    end do\n    \n    ! set the output level of the solver to 2 for some output\n    p_rsolvernode%ioutputlevel = 2\n    \n    ! attach the system matrices to the solver.\n    !\n    ! we copy our matrices to a big matrix array and transfer that\n    ! to the setmatrices routines. this intitialises then the matrices\n    ! on all levels according to that array. note that this does not\n    ! allocate new memory, we create only \"links\" to existing matrices\n    ! into rmatrices(:)!\n    allocate(rmatrices(nlmin:nlmax))\n    do i = nlmin, nlmax\n      call lsysbl_duplicatematrix (rlevels(i)%rmatrix,&\n          rmatrices(i),lsyssc_dup_share,lsyssc_dup_share)\n    end do\n    \n    call linsol_setmatrices(p_rsolvernode,rmatrices(nlmin:nlmax))\n\n    ! we can release rmatrices immediately -- as long as we do not\n    ! release rlevels(i)%rmatrix!\n    do i=nlmin,nlmax\n      call lsysbl_releasematrix (rmatrices(i))\n    end do\n    deallocate(rmatrices)\n\n    ! initialise structure/data of the solver. this allows the\n    ! solver to allocate memory / perform some precalculation\n    ! to the problem.\n    call linsol_initstructure (p_rsolvernode, ierror)\n    \n    if (ierror .ne. linsol_err_noerror) then\n      call output_line(\"matrix structure invalid!\",ou_class_error)\n      call sys_halt()\n    end if\n\n    call linsol_initdata (p_rsolvernode, ierror)\n    \n    if (ierror .ne. linsol_err_noerror) then\n      call output_line(\"matrix singular!\",ou_class_error)\n      call sys_halt()\n    end if\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! solve the system\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! finally solve the system. as we want to solve ax=b with\n    ! b being the real rhs and x being the real solution vector,\n    ! we use linsol_solveadaptively. if b is a defect\n    ! rhs and x a defect update to be added to a solution vector,\n    ! we would have to use linsol_preconddefect instead.\n    call linsol_solveadaptively (p_rsolvernode,rvector,rrhs,rtempblock)\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! postprocessing of the solution\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! the solution vector is probably not in the way paraview likes it!\n    ! paraview for example does not understand q1~ vectors!\n    ! therefore, we first have to convert the vector to a form that\n    ! paraview understands.\n    ! paraview understands only q1 solutions! so the task is now to create\n    ! a q1 solution from p_rvector and write that out.\n    !\n    ! for this purpose, first create a \"derived\" simple discretisation\n    ! structure based on q1 by copying the main guiding block discretisation\n    ! structure and modifying the discretisation structures of the\n    ! two velocity subvectors:\n    \n    call spdiscr_duplicateblockdiscr (rlevels(nlmax)%rdiscretisation,&\n                                      rprjdiscretisation)\n    \n    call spdiscr_derivesimplediscrsc (&\n        rlevels(nlmax)%rdiscretisation%rspatialdiscr(1), &\n        el_q1, rprjdiscretisation%rspatialdiscr(1))\n\n    call spdiscr_derivesimplediscrsc (&\n        rlevels(nlmax)%rdiscretisation%rspatialdiscr(2), &\n        el_q1, rprjdiscretisation%rspatialdiscr(2))\n                 \n    ! the pressure discretisation substructure stays the old.\n    !\n    ! now set up a new solution vector based on this discretisation,\n    ! allocate memory.\n    call lsysbl_createvecblockbydiscr (rprjdiscretisation,rprjvector,.false.)\n    \n    ! then take our original solution vector and convert it according to the\n    ! new discretisation:\n    call spdp_projectsolution (rvector,rprjvector)\n    \n    ! discretise the boundary conditions according to the q1/q1/q0\n    ! discretisation.\n    !\n    ! create a t_discretebc structure where we store all discretised boundary\n    ! conditions.\n    call bcasm_initdiscretebc(rprjdiscretebc)\n    !\n    ! edge 1 of boundary component 1, x-velocity.\n    call boundary_createregion(rboundary,1,1,rboundaryregion)\n\n    ! edge with start- and endpoint.\n    rboundaryregion%iproperties = bdr_prop_withstart + bdr_prop_withend\n    \n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,1,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n\n    ! edge 2 is neumann boundary, so it is commented out.\n    ! call boundary_createregion(rboundary,1,2,rboundaryregion)\n    ! call bcasm_newdirichletbconrealbd (rprjdiscretisation,1,&\n    !                                    rboundaryregion,rprjdiscretebc,&\n    !                                    getboundaryvalues_2d)\n                             \n    ! edge 3 of boundary component 1.\n    call boundary_createregion(rboundary,1,3,rboundaryregion)\n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,1,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n    \n    ! edge 4 of boundary component 1. that is it.\n    call boundary_createregion(rboundary,1,4,rboundaryregion)\n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,1,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n\n    ! edge 1 of boundary component 1, y-velocity.\n    call boundary_createregion(rboundary,1,1,rboundaryregion)\n  \n    ! edge with start- and endpoint.\n    rboundaryregion%iproperties = bdr_prop_withstart + bdr_prop_withend\n    \n    ! as we define the y-velocity, we now set icomponent=2 in the following call.\n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,2,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n                             \n    ! edge 2 is neumann boundary, so it is commented out.\n    ! call boundary_createregion(rboundary,1,2,rboundaryregion)\n    ! call bcasm_newdirichletbconrealbd (rprjdiscretisation,2,&\n    !                                    rboundaryregion,rprjdiscretebc,&\n    !                                    getboundaryvalues_2d)\n                             \n    ! edge 3 of boundary component 1.\n    call boundary_createregion(rboundary,1,3,rboundaryregion)\n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,2,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n    \n    ! edge 4 of boundary component 1. that is it.\n    call boundary_createregion(rboundary,1,4,rboundaryregion)\n    call bcasm_newdirichletbconrealbd (rprjdiscretisation,2,&\n                                       rboundaryregion,rprjdiscretebc,&\n                                       getboundaryvalues_2d)\n\n    ! send the vector to the boundary-condition implementation filter.\n    ! this modifies the vector according to the discrete boundary\n    ! conditions.\n    call vecfil_discretebcsol (rprjvector,rprjdiscretebc)\n    \n    ! get the path for writing postprocessing files from the environment variable\n    ! $ucddir. if that does not exist, write to the directory \"./gmv\".\n    if (.not. sys_getenv_string(\"ucddir\", sucddir)) sucddir = \"./gmv\"\n\n    ! now we have a q1/q1/q0 solution in rprjvector.\n    ! we can now start the postprocessing.\n    ! start ucd export to vtk file:\n    call ucd_startvtk (rexport,ucd_flag_standard,&\n        rlevels(nlmax)%rtriangulation,trim(sucddir)//\"/u2d_1_mg.vtk\")\n\n    ! write velocity field\n    call lsyssc_getbase_double (rprjvector%rvectorblock(1),p_ddata)\n    call lsyssc_getbase_double (rprjvector%rvectorblock(2),p_ddata2)\n    \n    ! in case we use the vtk exporter, which supports vector output, we will\n    ! pass the x- and y-velocity at once to the ucd module.\n    call ucd_addvarvertbasedvec(rexport,\"velocity\",p_ddata,p_ddata2)\n\n    ! if we use the gmv exporter, we might replace the line above by the\n    ! following two lines:\n    !call ucd_addvariablevertexbased (rexport,\"x-vel\",ucd_var_xvelocity, p_ddata)\n    !call ucd_addvariablevertexbased (rexport,\"y-vel\",ucd_var_yvelocity, p_ddata2)\n        \n    ! write pressure\n    call lsyssc_getbase_double (rprjvector%rvectorblock(3),p_ddata)\n    call ucd_addvariableelementbased (rexport,\"pressure\",ucd_var_standard, p_ddata)\n    \n    ! write the file to disc, that is it.\n    call ucd_write (rexport)\n    call ucd_release (rexport)\n\n    ! store the viscosity parameter nu in the collection\"s quick access array\n    rcollection%dquickaccess(1) = dnu\n\n    ! set up the error structure for velocity\n    rerroru%p_rveccoeff => rvector%rvectorblock(1:2)\n    rerroru%p_derrorl2 => derrorul2\n    rerroru%p_derrorh1 => derroruh1\n\n    ! set up the error structure for pressure\n    rerrorp%p_rveccoeff => rvector%rvectorblock(3:3)\n    rerrorp%p_derrorl2 => derrorpl2\n\n    ! calculate errors of velocity and pressure against analytic solutions.\n    call pperr_scalarvec(rerroru, funcvelocity2d, rcollection, rlevels(nlmax)%rcubatureinfo)\n    call pperr_scalarvec(rerrorp, funcpressure2d, rcollection, rlevels(nlmax)%rcubatureinfo)\n\n    ! print the errors.\n    call output_lbrk()\n    call output_line(\"|u - u_h|_l2 = \" // trim(sys_sdel(derrorul2(1), 10)) &\n                                // \" \" // trim(sys_sdel(derrorul2(2), 10)))\n    call output_line(\"|u - u_h|_h1 = \" // trim(sys_sdel(derroruh1(1), 10)) &\n                                // \" \" // trim(sys_sdel(derroruh1(2), 10)))\n    call output_line(\"|p - p_h|_l2 = \" // trim(sys_sdel(derrorpl2(1), 10)))\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! clean up\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    \n    ! we are finished - but not completely!\n    ! now, clean up so that all the memory is available again.\n    !\n    ! release solver data and structure\n    call linsol_donedata (p_rsolvernode)\n    call linsol_donestructure (p_rsolvernode)\n    \n    ! release the solver node and all subnodes attached to it (if at all):\n    call linsol_releasesolver (p_rsolvernode)\n    \n    ! release the filter chain\n    do i=nlmin,nlmax\n      call filter_donefilterchain (rlevels(i)%rfilterchain,rlevels(i)%nfilters)\n    end do\n\n    ! release the block matrix/vectors\n    call lsysbl_releasevector (rprjvector)\n    call lsysbl_releasevector (rtempblock)\n    call lsysbl_releasevector (rvector)\n    call lsysbl_releasevector (rrhs)\n    do i = nlmax, nlmin, -1\n      call lsysbl_releasematrix (rlevels(i)%rmatrix)\n    end do\n    \n    ! release b1 and b2 matrix\n    do i = nlmax, nlmin, -1\n      call lsyssc_releasematrix (rlevels(i)%rmatrixb2)\n      call lsyssc_releasematrix (rlevels(i)%rmatrixb1)\n    end do\n    \n    ! release the cubature info structures.\n    do i = nlmax, nlmin, -1\n      call spdiscr_releasecubstructure(rlevels(i)%rcubatureinfo)\n    end do\n\n    ! release our discrete version of the boundary conditions\n    call bcasm_releasediscretebc (rprjdiscretebc)\n    do i = nlmax, nlmin, -1\n      call bcasm_releasediscretebc (rlevels(i)%rdiscretebc)\n    end do\n\n    ! release the discretisation structure and all spatial discretisation\n    ! structures in it.\n    call spdiscr_releaseblockdiscr(rprjdiscretisation)\n    do i = nlmax, nlmin, -1\n      call spdiscr_releaseblockdiscr(rlevels(i)%rdiscretisation)\n    end do\n    \n    ! release the triangulation.\n    do i = nlmax, nlmin, -1\n      call tria_done (rlevels(i)%rtriangulation)\n    end do\n    \n    deallocate(rlevels)\n    \n    ! finally release the domain, that is it.\n    call boundary_release (rboundary)\n\n  end subroutine\n"}
{"id": 129, "subroutine": "  subroutine update_bnlog\n!***********************************************************************\n!***********************************************************************\n  include 'avh_olo_real.h90'\n    :: tt\n  integer :: nn,ii,jj,n1,nmax,irank\n  logical :: highestsofar\n!  real(kind(1d0)) :: xx(6) !debug\n!\n  if (allocated(thrs)) then\n    call shift3( thrs ,prcpar )\n    call shift3( ntrm ,prcpar )\n  else\n    allocate(thrs(1:nstp,0:rank,1:1))\n    allocate(ntrm(1:nstp,0:rank,1:1))\n    if (prcpar.ne.1) then\n      if (eunit.gt.0) write(eunit,*) 'error in oneloop update_bnlog'\n      stop\n    endif\n  endif\n!\n  highestsofar = prcpar.eq.ubound(ntrm,3)\n!\n  if (highestsofar) then\n    if (allocated(coeff)) deallocate(coeff)\n    allocate(coeff(0:-1,0:2)) ! allocate at size=0\n  endif\n!\n  nmax = 0\n!\n  do irank=0,rank\n!\n    n1 = 2+irank\n!\n    if (prcpar.gt.1) then ;nn=ntrm(nstp,irank,prcpar-1)-1\n                     else ;nn=n1\n    endif\n!  \n    do\n      nn = nn+1\n      if (highestsofar.and.nn.gt.ubound(coeff,1)) call update_coeff( 2*nn )\n      tt = 1\n      tt = (epsn*abs(coeff(n1,irank)/coeff(nn,irank)))**(tt/(nn-n1))\n      if (8*(irank+1)*tt.gt.rone) exit\n    enddo\n!\n    if (nn.gt.nmax) nmax=nn\n!  \n    ntrm(nstp,irank,prcpar) = nn\n    thrs(nstp,irank,prcpar) = tt\n    nn = max(1,nint(nn*1d0/nstp))\n    do ii=nstp-1,1,-1\n      ntrm(ii,irank,prcpar) = ntrm(ii+1,irank,prcpar)-nn\n      if (ntrm(ii,irank,prcpar).le.n1) then\n        do jj=1,ii\n          ntrm(jj,irank,prcpar) = max(n1,ntrm(ii,irank,prcpar))\n          thrs(jj,irank,prcpar) = 0 \n        enddo\n        exit\n      endif\n      jj = ntrm(ii,irank,prcpar)\n      tt = 1\n      tt = (epsn*abs(coeff(n1,irank)/coeff(jj,irank)))**(tt/(jj-n1))\n      thrs(ii,irank,prcpar) = tt\n    enddo\n!  \n  enddo!irank=1,nrank\n!  \n  if (highestsofar) call resize( coeff ,2,nmax ,0,rank )\n!\n!  do ii=lbound(thrs,3),ubound(thrs,3)        !debug\n!  do irank=0,rank                            !debug\n!    do jj=1,nstp                             !debug\n!      xx(jj) = thrs(jj,irank,ii)             !debug\n!    enddo                                    !debug\n!    write(*,'(i2,99e10.3)') irank,xx(:)      !debug\n!    write(*,'(2x,99i10)'  ) ntrm(:,irank,ii) !debug\n!  enddo                                      !debug\n!  enddo                                      !debug\n  end subroutine\n"}
{"id": 130, "subroutine": "  subroutine update_coeff( ncf )\n!*******************************************************************\n! coefficients of the expansion of\n!   f(n,x) = -int( t^n*log(1-t*x) ,t=0..1 )\n! in terms of log(1-x)\n!*******************************************************************\n  integer ,intent(in) :: ncf\n  integer :: ii,jj\n  include 'avh_olo_real.h90'\n    :: fact,tt(rank)\n!\n  call enlarge( coeff ,2,ncf ,0,rank )\n!\n  do jj=0,rank\n  do ii=2,1+jj\n    coeff(ii,jj) = 0\n  enddo\n  enddo\n  fact = 1\n  do ii=1,rank ;tt(ii)=1 ;enddo\n  do ii=2,ncf\n    fact = fact*ii\n    coeff(ii,0) = (ii-1)/fact\n    if (ii.eq.2) cycle\n    do jj=1,rank ;tt(jj)=tt(jj)*(jj+1) ;enddo\n    coeff(ii,1) = coeff(ii,0)*(1-tt(1))\n    if (ii.eq.3) cycle\n    coeff(ii,2) = coeff(ii,0)*(1-2*tt(1)+tt(2))\n    if (ii.eq.4) cycle\n    coeff(ii,3) = coeff(ii,0)*(1-3*tt(1)+3*tt(2)-tt(3))\n    if (ii.eq.5) cycle\n    coeff(ii,4) = coeff(ii,0)*(1-4*tt(1)+6*tt(2)-4*tt(3)+tt(4))\n!   if (ii.eq.n+1) cycle\n!   coeff(ii,n) = coeff(ii,0)\n!               * ( 1 - binom(n,1)*tt(1) + binom(n,2)*tt(2)...)\n  enddo\n!\n  end subroutine\n"}
{"id": 131, "subroutine": "      subroutine obs2chd7ar(iuchob,igrid)\nc     ******************************************************************\nc     allocate and read data for flow observations at constant-head\nc     boundary cells\nc     ******************************************************************\nc        specifications:\nc     ------------------------------------------------------------------\n      use global, only: ncol,nrow,nlay,nper,nstp,perlen,tsmult,issflg,\n     1                  iout,itrss\n      use obschdmodule\n      use simmodule, only: ustop\n      use utl7module, only: urdcom, urword\nc\n      character*200 line\n      double precision :: dum\nc     ------------------------------------------------------------------\n      allocate(nqch,nqtch,nqcch,iuchobsv,iprt)\nc\nc1------initialize variablea.\n      zero=0.0\n      ierr=0\n      nt=0\n      nc=0\nc\nc2------identify process\n      write(iout,14) iuchob\n   14 format(/,' obs2chd7 -- constant-head boundary flow observations',\n     &    /,' version 2.0, 02/28/2006       input read from unit ',i3)\nc\nc3------item 1\n      call urdcom(iuchob,iout,line)\n      lloc = 1\n      call urword(line,lloc,istart,istop,2,nqch,dum,iout,iuchob)\n      call urword(line,lloc,istart,istop,2,nqcch,dum,iout,iuchob)\n      call urword(line,lloc,istart,istop,2,nqtch,dum,iout,iuchob)\n      call urword(line,lloc,istart,istop,2,iuchobsv,dum,iout,iuchob)\n      call urword(line,lloc,istart,istop,1,idum,dum,iout,iuchob)\n      iprt=1\n      if(line(istart:istop).eq.'noprint') then\n        iprt=0\n        write(iout,*) 'noprint option for constant-head observations'\n      end if\n      write (iout,17) nqch, nqcch, nqtch\n   17 format (/,\n     &    ' number of flow-observation constant-head-cell groups:',i5,/,\n     &    '   number of cells in constant-head-cell groups......:',i5,/,\n     &    '   number of constant-head-cell flows................:',i5)\n      if(nqtch.le.0) then\n         write(iout,*) ' nqtch less than or equal to 0'\n         call ustop(' ')\n      end if\n      if(iuchobsv.gt.0) then\n         write(iout,21) iuchobsv\n   21    format(1x,\n     1      'ch observations will be saved on unit...............:',i5)\n      else\n         write(iout,22)\n   22    format(1x,'ch observations will not be saved in a file')\n      end if\nc\nc4------allocate arrays\n      allocate (nqobch(nqch))\n      allocate (nqclch(nqch))\n      allocate (iobts(nqtch))\n      allocate (flwsim(nqtch))\n      allocate (flwobs(nqtch))\n      allocate (toff(nqtch))\n      allocate (otime(nqtch))\n      allocate (qcell(4,nqcch))\n      allocate (obsnam(nqtch))\n      do 19 n=1,nqtch\n      otime(n)=zero\n      flwsim(n)=zero\n   19 continue\nc\nc5------read and write time-offset multiplier for flow-observation times\n      read(iuchob,*) tomultch\n      if(iprt.ne.0) write (iout,520) tomultch\n  520 format (/,' observed constant-head-cell flow data',/,\n     &' -- time offsets are multiplied by: ',g12.5)\nc\nc6------loop through cell groups.\n      do 120 iq = 1,nqch\nc\nc7------read item 3\n        read (iuchob,*) nqobch(iq), nqclch(iq)\n        if(iprt.ne.0) write (iout,525) iq, 'chd', nqclch(iq), nqobch(iq)\n  525   format (/,'   group number: ',i3,'   boundary type: ',a,\n     &         '   number of cells in group: ',i5,/,\n     &         '   number of flow observations: ',i5,//,\n     &         40x,'observed',/,\n     &         20x,'refer.',12x,'boundary flow',/,\n     &      7x,'observation',2x,'stress',4x,'time',5x,'gain (-) or',/,\n     &         2x,'obs#    name',6x,'period   offset',5x,'loss (+)')\nc\nc8------set flag for setting all factors to 1\n        ifctflg = 0\n        if (nqclch(iq).lt.0) then\n          ifctflg = 1\n          nqclch(iq) = -nqclch(iq)\n        endif\nc\nc9------read time steps, measured flows, and weights.\n        nt1 = 1 + nt\n        nt2 = nqobch(iq) + nt\n        do 30 n = nt1, nt2\nc\nc10-----read item 4\n          read (iuchob,*) obsnam(n), irefsp, toffset, flwobs(n)\n          if(iprt.ne.0) write (iout,535) n, obsnam(n), irefsp, toffset,\n     1                                   flwobs(n)\n  535     format(1x,i5,1x,a12,2x,i4,2x,g11.4,1x,g11.4)\n          call uobsti(obsnam(n),iout,issflg,itrss,nper,nstp,irefsp,\n     &                iobts(n),perlen,toff(n),toffset,tomultch,tsmult,1,\n     &                otime(n))\n   30   continue\nc\nc11-----read layer, row, column, and factor (item 5)\n        nc1 = nc + 1\n        nc2 = nc + nqclch(iq)\n        if(iprt.ne.0) write (iout,540)\n  540   format (/,'       layer  row  column    factor')\n        do 40 l = nc1, nc2\n          read (iuchob,*) (qcell(i,l),i=1,4)\n          if(qcell(4,l).eq.0. .or. ifctflg.eq.1) qcell(4,l) = 1.\n          if(iprt.ne.0) write (iout,550) (qcell(i,l),i=1,4)\n  550     format (4x,f8.0,f6.0,f7.0,f9.2)\n          k = qcell(1,l)\n          i = qcell(2,l)\n          j = qcell(3,l)\n          if (k.le.0 .or. k.gt.nlay .or .j.le.0 .or. j.gt.ncol .or.\n     &        i.le.0 .or. i.gt.nrow) then\n            write (iout,590)\n  590       format (/,' row or column number invalid',\n     &        ' -- stop execution (obs2chd7ar)',/)\n            ierr = 1\n          endif\n   40   continue\nc\nc12-----update counters.\n        nc = nc2\n        nt = nt2\n  120 continue\nc\nc13-----stop if there were any errors while reading.\n      if (ierr.gt.0) then\n        write(iout,620)\n  620   format (/,' error:  see above for error message and \"stop',\n     &        ' execution\" (obs2chd7ar)')\n        call ustop(' ')\n      endif\nc\nc14-----return.\n      call sobs2chd7psv(igrid)\n      return\n      end subroutine obs2chd7ar\n"}
{"id": 132, "subroutine": "      subroutine obs2chd7da(igrid)\nc  deallocate obschd memory\n      use obschdmodule\nc\n      deallocate(nqch)\n      deallocate(nqtch)\n      deallocate(nqcch)\n      deallocate(iuchobsv)\n      deallocate(iprt)\n      deallocate(nqobch)\n      deallocate(nqclch)\n      deallocate(iobts)\n      deallocate(flwsim)\n      deallocate(flwobs)\n      deallocate(toff)\n      deallocate(otime)\n      deallocate(qcell)\n      deallocate(obsnam)\nc\n      return\n      end subroutine obs2chd7da\n"}
{"id": 133, "subroutine": "      subroutine sobs2chd7pnt(igrid)\nc  change obschd data to a different grid.\n      use obschdmodule\nc\n      nqch=>obschddat(igrid)%nqch\n      nqtch=>obschddat(igrid)%nqtch\n      nqcch=>obschddat(igrid)%nqcch\n      iuchobsv=>obschddat(igrid)%iuchobsv\n      iprt=>obschddat(igrid)%iprt\n      nqobch=>obschddat(igrid)%nqobch\n      nqclch=>obschddat(igrid)%nqclch\n      iobts=>obschddat(igrid)%iobts\n      flwsim=>obschddat(igrid)%flwsim\n      flwobs=>obschddat(igrid)%flwobs\n      toff=>obschddat(igrid)%toff\n      otime=>obschddat(igrid)%otime\n      qcell=>obschddat(igrid)%qcell\n      obsnam=>obschddat(igrid)%obsnam\nc\n      return\n      end subroutine sobs2chd7pnt\n"}
{"id": 134, "subroutine": "      subroutine sobs2chd7psv(igrid)\nc  save obschd data for a grid.\n      use obschdmodule\nc\n      obschddat(igrid)%nqch=>nqch\n      obschddat(igrid)%nqtch=>nqtch\n      obschddat(igrid)%nqcch=>nqcch\n      obschddat(igrid)%iuchobsv=>iuchobsv\n      obschddat(igrid)%iprt=>iprt\n      obschddat(igrid)%nqobch=>nqobch\n      obschddat(igrid)%nqclch=>nqclch\n      obschddat(igrid)%iobts=>iobts\n      obschddat(igrid)%flwsim=>flwsim\n      obschddat(igrid)%flwobs=>flwobs\n      obschddat(igrid)%toff=>toff\n      obschddat(igrid)%otime=>otime\n      obschddat(igrid)%qcell=>qcell\n      obschddat(igrid)%obsnam=>obsnam\nc\n      return\n      end subroutine sobs2chd7psv\n"}
{"id": 135, "subroutine": "subroutine zstencil_microac_typical_seq(is_array,ie_array,is,ie,idx,idy,idz,igs,ige &\n                                       ,tpsi,htpsi,v_local,ac,div_ac,lap0,lapt,nabt,k &\n                                       )\n  use math_constants,only : zi\n  implicit none\n\n  integer,intent(in) :: is_array(3),ie_array(3),is(3),ie(3)\n  integer,intent(in) :: idx(is(1)-4:ie(1)+4),idy(is(2)-4:ie(2)+4),idz(is(3)-4:ie(3)+4)\n  integer,intent(in) :: igs(3),ige(3)\n\n  complex(8),intent(in)  :: tpsi   (is_array(1):ie_array(1),is_array(2):ie_array(2),is_array(3):ie_array(3))\n  complex(8),intent(out) :: htpsi  (is_array(1):ie_array(1),is_array(2):ie_array(2),is_array(3):ie_array(3))\n  real(8),   intent(in)  :: v_local(is(1):ie(1),is(2):ie(2),is(3):ie(3))\n  real(8),   intent(in)  :: ac(3,is(1):ie(1),is(2):ie(2),is(3):ie(3))\n  real(8),   intent(in)  :: div_ac(is(1):ie(1),is(2):ie(2),is(3):ie(3))\n  real(8),   intent(in)  :: lap0\n  real(8),   intent(in)  :: lapt(4,3), nabt(4,3)\n  real(8),   intent(in)  :: k(3)\n\n  integer    :: ix,iy,iz\n  real(8)    :: kac(3),div\n  complex(8) :: w(3),v,psi0\n\n  do iz=igs(3),ige(3)\n  do iy=igs(2),ige(2)\n  do ix=igs(1),ige(1)\n    psi0 = tpsi(ix,iy,iz)\n    kac = k + ac(:,ix,iy,iz)\n    div = div_ac(ix,iy,iz)\n\n  ! laplacian of psi\n    v =  lapt(1,1)*(tpsi(dx(1)) + tpsi(dx(-1))) &\n      & +lapt(2,1)*(tpsi(dx(2)) + tpsi(dx(-2))) &\n      & +lapt(3,1)*(tpsi(dx(3)) + tpsi(dx(-3))) &\n      & +lapt(4,1)*(tpsi(dx(4)) + tpsi(dx(-4)))\n\n    v =  lapt(1,2)*(tpsi(dy(1)) + tpsi(dy(-1))) &\n      & +lapt(2,2)*(tpsi(dy(2)) + tpsi(dy(-2))) &\n      & +lapt(3,2)*(tpsi(dy(3)) + tpsi(dy(-3))) &\n      & +lapt(4,2)*(tpsi(dy(4)) + tpsi(dy(-4))) + v\n\n    v =  lapt(1,3)*(tpsi(dz(1)) + tpsi(dz(-1))) &\n      & +lapt(2,3)*(tpsi(dz(2)) + tpsi(dz(-2))) &\n      & +lapt(3,3)*(tpsi(dz(3)) + tpsi(dz(-3))) &\n      & +lapt(4,3)*(tpsi(dz(4)) + tpsi(dz(-4))) + v\n\n  ! gradient of psi\n    w(1) =  nabt(1,1)*(tpsi(dx(1)) - tpsi(dx(-1))) &\n         & +nabt(2,1)*(tpsi(dx(2)) - tpsi(dx(-2))) &\n         & +nabt(3,1)*(tpsi(dx(3)) - tpsi(dx(-3))) &\n         & +nabt(4,1)*(tpsi(dx(4)) - tpsi(dx(-4)))\n\n    w(2) =  nabt(1,2)*(tpsi(dy(1)) - tpsi(dy(-1))) &\n         & +nabt(2,2)*(tpsi(dy(2)) - tpsi(dy(-2))) &\n         & +nabt(3,2)*(tpsi(dy(3)) - tpsi(dy(-3))) &\n         & +nabt(4,2)*(tpsi(dy(4)) - tpsi(dy(-4)))\n\n    w(3) =  nabt(1,3)*(tpsi(dz(1)) - tpsi(dz(-1))) &\n         & +nabt(2,3)*(tpsi(dz(2)) - tpsi(dz(-2))) &\n         & +nabt(3,3)*(tpsi(dz(3)) - tpsi(dz(-3))) &\n         & +nabt(4,3)*(tpsi(dz(4)) - tpsi(dz(-4)))\n\n    htpsi(ix,iy,iz) = ( v_local(ix,iy,iz) + lap0 )* psi0 - 0.5d0* v           &\n                    & + 0.5d0* ( kac(1)**2 + kac(2)**2 + kac(3)**2 ) * psi0   &\n                    & - zi* ( kac(1) * w(1) + kac(2) * w(2) + kac(3) * w(3) ) &\n                    & - zi*0.5d0* div * psi0 ! deviation from the coulomb gauge condition (for numerical stability)\n  end do\n  end do\n  end do\nend subroutine\n"}
{"id": 136, "subroutine": "  subroutine save_debug_vtu_scalar(grid, in_1, in_2, var_name, val)\n!------------------------------------------------------------------------------!\n!   writes one real scalar defined over cells.                                 !\n!------------------------------------------------------------------------------!\n!----------------------------------[modules]-----------------------------------!\n  use comm_mod, only: this_proc, n_proc\n  use grid_mod\n!------------------------------------------------------------------------------!\n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  type(grid_type)  :: grid\n  character(len=*) :: in_1, in_2\n  character(len=*) :: var_name\n  real             :: val(1:grid % n_cells)\n!-----------------------------------[locals]-----------------------------------!\n  integer :: c\n!==============================================================================!\n\n  ! header\n  if(n_proc > 1 .and. this_proc .eq. 1) then\n    write(800,'(4a)') in_1,                                 & \n                      '<pdataarray type=\"float64\" name=\"',  &\n                      trim(var_name),                       &\n                    '\" format=\"ascii\"/>'\n  end if\n  write(900,'(4a)') in_1,                                & \n                    '<dataarray type=\"float64\" name=\"',  &\n                    trim(var_name),                      &\n                    '\" format=\"ascii\">'\n\n  ! data\n  do c = 1, grid % n_cells - grid % comm % n_buff_cells\n    write(900,'(a,1pe16.6e4)') in_2, val(c)\n  end do  \n\n  ! footer\n  write(900,'(a,a)') in_1, '</dataarray>'\n\n  end subroutine\n"}
{"id": 137, "subroutine": "      subroutine chisq_limiter(target,sigma,niter,iflag)\n!-----------------------------------------------------------------------\n!     libraries\n!-----------------------------------------------------------------------\n      use stellopt_runtime\n      use stellopt_targets\n      use equil_utils\n      \n!-----------------------------------------------------------------------\n!     input/output variables\n!\n!-----------------------------------------------------------------------\n      implicit none\n      real(rprec), intent(in)    ::  target(nu_max,nv_max)\n      real(rprec), intent(in)    ::  sigma(nu_max,nv_max)\n      integer,     intent(in)    ::  niter\n      integer,     intent(inout) ::  iflag\n      \n!-----------------------------------------------------------------------\n!     local variables\n!\n!-----------------------------------------------------------------------\n      integer :: u, u2, v, nv2, ier, dex, nu_val\n      real(rprec) :: s, xu, xv, r1, z1, r2, z2, dist, temp, lim_sgn, &\n                     ra, za, rho_plasma, rho_limiter, rp, zp, rn, zn, &\n                     rd, zd, rx, zx\n      real(rprec) :: d1(nu_max)\n!----------------------------------------------------------------------\n\n!----------------------------------------------------------------------\n      if (iflag < 0) return\n      dex = sum(count(sigma_limiter < bigno,dim=1))\n      if (iflag == 1) write(iunit_out,'(a,2(2x,i5.5))') 'limiter ',dex,6\n      if (iflag == 1) write(iunit_out,'(a)') 'target  sigma  dist  r  phi  z'\n      if (niter >= 0) then\n         xu = 0.0\n         xv = 0.0\n         s  = 0.0\n         call get_equil_rz(s,xu,xv,ra,za,ier)\n         r1 = r_limiter(1,1)\n         z1 = z_limiter(1,1)\n         r2 = r_limiter(2,1)\n         z2 = z_limiter(2,1)\n         xu = atan2(z1-za,r1-ra)\n         xv = atan2(z2-za,r2-ra)\n         lim_sgn = 1.0\n         if (xv < xu) lim_sgn = -1.0\n         do v = 1, nv_max\n            nu_val = maxloc(sigma_limiter(:,v),dim=1)\n            !print *,'nu_val',nu_val\n            do u = 1, nu_val-2\n               if (sigma_limiter(u,v) >= bigno) cycle\n               s  = 1.0_rprec\n               xv = phi_limiter(u,v)\n               if (xv < 0.0) xv = xv + pi2\n               xv = mod(nfp*xv,pi2)\n               r1 = r_limiter(u,v)\n               z1 = z_limiter(u,v)\n               r2 = r_limiter(u+1,v)\n               z2 = z_limiter(u+1,v)\n               rn = lim_sgn*z2-z1\n               zn = -lim_sgn*(r2-r1)\n               rd = r2-r1\n               zd = z2-z1\n               temp = sqrt(rd*rd+zd*zd)\n               rd = rd/temp\n               zd = zd/temp\n               d1 = 0.0\n               !print *,'r1,z1',r1,z1\n               !print *,'r2,z2',r2,z2\n               !print *,'rd,zd',rd,zd\n               !print *,'rd,zd',rn,zn\n               do u2 = 1, nu_max\n                  ier = 0\n                  xu = pi2*real(u2-1)/real(nu_max)\n                  call get_equil_rz(s,xu,xv,rp,zp,ier)\n                  ! now x1 is the first point x2 is the second point an xp is the plasma point\n                  dist =   abs( (r2-r1)*(z1-zp)-(r1-rp)*(z2-z1) ) &\n                         / sqrt( (r2-r1)*(r2-r1)+(z2-z1)*(z2-z1) )\n                  ! now (rn, zn) points out of the vessel\n                  ! and (rd, zd) points along the vessel\n                  ! then x = p - x1 + ((p-x1).d)d points from the line to the point p and is normal to the line segment\n                  rx = rp - (r1 + ((rp-r1)*rd+(zp-z1)*zd)*rd)\n                  zx = zp - (z1 + ((rp-r1)*rd+(zp-z1)*zd)*zd)\n                  ! so if x.n is positive  the point is outside, if x.n is negative the point is inside\n                  temp = rx*rn + zx*zn\n                  d1(u2) = dist\n                  if (temp > 0) d1(u2) = -dist\n                  !print *,'dist',u2,d1(u2)\n               end do\n               dist = minval(d1,dim=1)\n               mtargets = mtargets + 1\n               targets(mtargets) = target(u,v)\n               sigmas(mtargets)  = sigma(u,v)\n               if (dist < target(u,v)) then\n                  vals(mtargets) = dist\n               else\n                  vals(mtargets) = target(u,v)\n               end if\n               if (iflag == 1) write(iunit_out,'(6es22.12e3)') target(u,v),sigma(u,v),vals(mtargets),r1,phi_limiter(u,v),z1\n            end do\n         end do\n      else\n         do v = 1, nv_max\n            do u = 1, nu_max\n               if (sigma_limiter(u,v) >= bigno) cycle\n               mtargets = mtargets + 1\n               if (niter == -2) target_dex(mtargets)=jtarget_limiter\n            end do\n         end do\n      end if\n      return\n!----------------------------------------------------------------------\n\n!----------------------------------------------------------------------\n      end subroutine chisq_limiter\n"}
{"id": 138, "subroutine": "subroutine r_spiola_viscous(xot,vel)\n  use r_common\n  use fluid_variables, only: mu => vis_liq\n  use solid_variables, only: nen_solid,nsd => nsd_solid\n  implicit none\n\n  real(8),intent(in) :: xot(1:nsd,1:nsd)\n  real(8),intent(in) :: vel(1:nsd,1:nen_solid)\n\n  integer :: nos,isd,jsd,ksd\n  real(8) :: sigma(1:nsd,1:nsd),ui_j(1:nsd,1:nsd) !,press\n\n\n  sigma(:,:) = 0.0\n  ui_j(:,:) = 0.0\n  do nos = 1,nen_solid\n     do isd = 1,nsd\n        do jsd = 1,nsd\n           ui_j(isd,jsd) = ui_j(isd,jsd) + bd_curr(jsd,nos)*vel(isd,nos)\n        end do\n     end do\n  end do\n  do isd = 1,nsd\n     do jsd = 1,nsd\n        sigma(isd,jsd) = mu*(ui_j(isd,jsd)+ui_j(jsd,isd))\n     end do\n  end do\n\n  do isd = 1,nsd\n     do jsd = 1,nsd\n        do ksd = 1,nsd\n           pk1str_tens(isd,jsd) = pk1str_tens(isd,jsd) - xot(isd,ksd)*sigma(ksd,jsd)\n        enddo\n     enddo\n  enddo\n\n  return\nend subroutine r_spiola_viscous\n"}
{"id": 139, "subroutine": "      subroutine elem22 (task, elsnam, dtime,                    &\r\n     &                   ttime, istop, flag2 )\r\n\r\n      use ele22_db\r\n      use ctrl_db, only:  tscal, ndime, npoin, npoio, ndofn\r\n      use npo_db\r\n      use outp_db, only: sumat, iwrit\r\n      implicit none\r\n\r\n      character(len=*),intent(in):: task\r\n\r\n      ! optional parameters\r\n      logical, optional :: flag2\r\n      character (len=*), optional :: elsnam\r\n      integer (kind=4), optional :: istop\r\n      real (kind=8), optional :: dtime,ttime\r\n\r\n      integer (kind=4) :: nelem,nreqs,narch,ngaus,nnode\r\n      character(len=mnam) :: sname\r\n\r\n      type (ele22_set), pointer :: elset, anter\r\n\r\n      interface\r\n        include 'surf05.h'\r\n        include 'lumas5.h'\r\n      end interface\r\n\r\n      if ( .not.associated (head) ) return\r\n\r\n      nullify (anter)\r\n      elset => head\r\n\r\n      do\r\n\r\n        call comm22(1,nelem,nreqs,narch,nnode,ngaus,sname, elset)\r\n\r\n        select case (trim(task))\r\n\r\n        case ('gaussc')\r\n          call gaus22 (nelem,ngaus,nnode,elset%lnods,coora,elset%posgp, &\r\n     &                 elset%weigp,elset%shape,elset%deriv,istop)\r\n\r\n        case ('tlmass')\r\n          call luma22(ngaus,nelem,elset%matno,elset%lnods, &\r\n     &                elset%weigp,elset%shape,elset%deriv,nnode, &\r\n     &                coora,ndime,tmass)\r\n\r\n        case ('tresid')\r\n          call heat22(ngaus,nelem,elset%matno,elset%lnods, &\r\n     &                elset%weigp,elset%shape,elset%deriv, &\r\n     &                elset%lcur,elset%hgs, &\r\n     &                nnode,tempe(1,:),coora,ndime,tresi,ttime)\r\n\r\n        case ('tincdt')\r\n          call code22(nnode,nelem,ndime,dtime,elset%lnods,elset%matno, &\r\n     &                coora)\r\n\r\n        case ('new','nstra1','nstra2')\r\n        call acvd22 (nelem,nnode,elset%lnods)\r\n        !elset%narch = narch\r\n\r\n        case ('wrtpos')\r\n        call mase22(nnode,nelem,elset%matno,elset%lnods,elset%sname )\r\n\r\n        case ('lumass')\r\n          call lumas5(ndofn,npoin,nelem,ngaus,nnode,elset%lnods, &\r\n     &                elset%matno,coora,emass,elset%weigp, &\r\n     &                elset%shape,elset%deriv,iwrit,sumat)\r\n        case ('surfac')\r\n          if( flag2 )exit\r\n          flag2 = trim(elsnam) == trim(sname)\r\n          if (flag2) then\r\n            ! get surface definition from the element set\r\n            call surf05 (elset%lnods,elset%nelem,nnode)\r\n            exit\r\n          end if\r\n\r\n        case ('updlon' )\r\n        call updl22 (nelem,nnode,elset%lnods,oldlb)\r\n\r\n        case default\r\n\r\n        end select\r\n\r\n        if ( associated (elset%next) ) then\r\n          elset => elset%next\r\n        else\r\n          exit\r\n        endif\r\n\r\n      end do\r\n\r\n      return\r\n\r\n      end subroutine elem22\r\n"}
{"id": 140, "subroutine": "subroutine gen_dyn()\n\nuse util\nuse config\nuse view_struct\n\nimplicit none\n\ninteger(kind=4) :: nscx,nscy,nscz\ninteger(kind=4) :: a,b,c\ninteger(kind=4) :: i,ii,j,jj,k,kk,ir,counts,m1,m2,m3,ie\nreal(kind=8) :: kpoint1(3),kpoint2(3),kpoint3(3)\nreal(kind=8),allocatable :: kps(:,:)\nreal(kind=8),allocatable :: kabs(:)\ncomplex(kind=8),allocatable :: dynmat(:,:,:),dynmat_g(:,:,:)\ncomplex(kind=8),allocatable :: matmat(:,:) \ncomplex(kind=8),allocatable :: velx(:,:) \ncomplex(kind=8),allocatable :: vely(:,:) \ncomplex(kind=8),allocatable :: velz(:,:) \nreal(kind=8),allocatable    :: omega(:,:)\nreal(kind=8),allocatable    :: pr(:,:)\nreal(kind=8),allocatable    :: prd(:,:)\ncomplex(kind=8),allocatable :: evs(:,:)\ncomplex(kind=8),allocatable :: evs0(:,:)\nreal(kind=8)    :: rws(124,3),rd(124)\nreal(kind=8)    :: gmax,alpha,geg,exp_g\nreal(kind=8)    :: g(1,3),g_old(3),zig(1,3),zjg(1,3),auxi(3),gr,gtemp(1,3)\nreal(kind=8)    :: pos_i(3),pos_j(3),pos_i_pc(3),pos_j_pc(3),total_weight,weight\nreal(kind=8)    :: dr(3),ixyz(3),df\ninteger(kind=4) :: ipol,jpol,iat,jat,iidim,jdim,ik,nreq\ninteger(kind=4) :: aa,bb,cc,t1,t2,t3,m,n,nn,ll,ikz\nreal(kind=8)    :: kpoint(3),ktemp(3),mi,mj\nreal(kind=8),allocatable  :: ggrid(:,:,:,:),weightk(:,:,:)\nreal(kind=8),allocatable :: spectral(:,:,:,:,:)\nreal(kind=8),allocatable :: spectral_proj(:,:,:,:,:,:,:)\nreal(kind=8),allocatable :: kmeshx(:,:,:,:,:),kmeshy(:,:,:,:,:),kmeshz(:,:,:,:,:)\nreal(kind=8),allocatable :: emesh(:,:,:,:,:)\nreal(kind=8),allocatable :: datamesh(:,:)\nreal(kind=8),allocatable :: datamesh_proj(:,:,:,:)\nreal(kind=8)             :: cm2\ninteger(kind=4) :: ib\ncharacter(len=8) :: fmt,x1\n\n! cm-2\ncm2 = elevolt/1.0d-20/mass_proton/(1.0d12*2.0d0*pi)**2*33.35641**2*(13.605662285137/0.529177249**2)\nfmt = '(i6.6)'\n\nkpoint1 = (/0.0,0.0,0.0/)\nkpoint2 = (/0.0,0.0,-0.5/)\nkpoint3 = (/0.0,0.0,0.5/)\n\nnscx = ceiling(dble(nx)/dble(nx_sc))\nnscy = ceiling(dble(ny)/dble(ny_sc))\nnscz = ceiling(dble(nz)/dble(nz_sc))\n\nif (dos.ne.0) then\n    nk = ndosx*ndosy*ndosz\nend if\n\nallocate(kps(nk,3))\nallocate(kabs(nk))\nkps = 0.0d0\nkabs = 0.0d0\nif (dos.eq.0) then\n    do i = 1,3\n        kps(1:(nk)/2+1,i) = linspace(kpoint2(i),kpoint1(i),(nk)/2+1,1)    \n    end do\n    do i = 1,(nk)/2+1\n        kabs(i) = sqrt(dot_product(kps(i,:)-kpoint2,kps(i,:)-kpoint2))\n    end do\n    do i = 1,3\n        kps((nk)/2+1:nk,i) = linspace(kpoint1(i),kpoint3(i),(nk)/2,0)    \n    end do\n    do i = 1,(nk)/2\n       kabs(i+(nk)/2) = kabs((nk)/2+1)+sqrt(dot_product(kps(i+(nk)/2,:)-kpoint1,kps(i+(nk)/2,:)-kpoint1))\n    end do\nelse\n    counts = 1\n    do i= 1,ndosx\n        do j = 1,ndosy\n            do k=1,ndosz\n                kps(counts,:) =(/dble(i-1)/dble(ndosx),dble(j-1)/dble(ndosy),dble(k-1)/dble(ndosz)/)\n                counts = counts + 1\n            end do\n        end do\n    end do\nend if\n\nallocate(omega(nk,natm_sc*3))\nallocate(matmat(3*natm_sc,3*natm_sc))\nallocate(pr(nk,natm_sc*3))\nallocate(prd(nk,natm_sc*3))\nallocate(evs(natm_sc*3,natm_sc*3))\nallocate(velx(natm_sc*3,natm_sc*3))\nallocate(vely(natm_sc*3,natm_sc*3))\nallocate(velz(natm_sc*3,natm_sc*3))\n\nrws = 0.0d0\nrd = 0.0d0\nj = 1\ndo m1=-2,2\n    do m2=-2,2\n        do m3=-2,2\n             if ((m1.eq.0) .and. (m2.eq.0) .and. (m3.eq.0)) then\n                 cycle\n             end if\n             do i=1,3\n                rws(j,i)=cell_sc_dfpt(1,i)*m1+cell_sc_dfpt(2,i)*m2+cell_sc_dfpt(3,i)*m3\n             end do \n             rd(j)=0.5*dot_product(rws(j,1:3),rws(j,1:3))\n             j=j+1\n         end do\n    end do\nend do\n\n\nif (unfold.ne.0)then\n\n    allocate(dynmat(nk,natm_sc*3,natm_sc*3))\n    allocate(dynmat_g(nk,natm_sc*3,natm_sc*3))\n\n\n    cell_g = reci_cell_sc/angbohr\n    gmax = 14.0d0\n    alpha= (2.0*pi/sqrt(dot_product(cell_sc(1,:),cell_sc(1,:)))/angbohr)**2\n    geg=gmax*4.*alpha\n    do i = 1,3\n        cell_g_len(i) = sqrt(dot_product(cell_g(i,:),cell_g(i,:)))\n    end do\n    do i = 1,3\n        ncell_g(i)=nint(sqrt(geg)/cell_g_len(i))+1\n    end do\n    do m1=-ncell_g(1),ncell_g(1)\n      do m2=-ncell_g(2),ncell_g(2)\n         do m3=-ncell_g(3),ncell_g(3)\n            g(1,:) =dble(m1)*cell_g(1,1:3)+dble(m2)*cell_g(2,1:3)+dble(m3)*cell_g(3,1:3)\n            gtemp = transpose(matmul(epsil,transpose(g)))\n            geg=dot_product(g(1,:),gtemp(1,:))\n            if ((geg.gt.0.0d0) .and. (geg/alpha/4.0d0.lt.gmax)) then\n                exp_g=exp(-geg/alpha/4.0d0)/geg\n                do iat=1,natm_sc\n                   zig = matmul(g,born(idx_scpc(iat),1:3,1:3))\n                   auxi =  0.0\n                   do jat=1,natm_sc\n                       gr=dot_product(g(1,:),pos_sc(jat,:)-pos_sc(iat,:))\n                       zjg = matmul(g,born(idx_scpc(jat),1:3,1:3))\n                       auxi(1:3)=auxi(1:3)+zjg(1,1:3)*real(exp(-i_imag*gr*angbohr))\n                    end do\n                    do ipol=1,3\n                     iidim=(iat-1)*3+ipol\n                     do jpol=1,3\n                        jdim=(iat-1)*3+jpol\n                        dynmat_g(1:nk,iidim,jdim)=dynmat_g(1:nk,iidim,jdim)-exp_g*zig(1,ipol)*auxi(jpol)\n                     end do\n                    end do\n                 end do\n            end if\n            g_old(1:3)=g(1,1:3)\n            do ik=1,nk\n               g(1,1:3)=g_old(1:3)+matmul(kps(ik,1:3),reci_cell_sc)/angbohr\n               gtemp = transpose(matmul(epsil,transpose(g)))\n               geg=dot_product(g(1,:),gtemp(1,:))\n               if ((geg.gt.0.0d0).and.(geg/alpha/4.0d0.lt.gmax)) then\n                  exp_g=exp(-geg/alpha/4.0d0)/geg\n                  do iat=1,natm_sc\n                     zig = matmul(g,born(idx_scpc(iat),1:3,1:3))\n                     do jat=1,natm_sc\n                        gr=dot_product(g(1,:),pos_sc(jat,:)-pos_sc(iat,:))\n                        zjg =matmul(g,born(idx_scpc(jat),1:3,1:3))\n                        do ipol=1,3\n                           iidim=(iat-1)*3+ipol\n                           do jpol=1,3\n                              jdim=(jat-1)*3+jpol\n                              dynmat_g(ik,iidim,jdim)=dynmat_g(ik,iidim,jdim)+exp_g*zig(1,ipol)*zjg(1,jpol)*exp(-i_imag*gr*angbohr)\n                           end do\n                        end do\n                      end do\n                   end do\n                 end if \n            end do\n         end do\n       end do\n    end do\n    dynmat_g = 8*pi*dynmat_g/volume/angbohr**3\n\n    do ik = 1,nk\n        kpoint = kps(ik,:)\n        do a = -nscx,nscx\n            do b = -nscy,nscy\n                do c = -nscz,nscz\n                    do i = 1,natm_sc\n                       pos_i = pos_sc(i,:)\n                       pos_i_pc = pos(idx_scpc(i),:)\n                       do j = 1,natm_sc\n                           pos_j = pos_sc(j,:)\n                           pos_j_pc = pos(idx_scpc(j),:)\n                           total_weight = 0.0\n                           g(1,:) = matmul(kpoint,reci_cell_sc)\n                           weight = 0.0d0\n                           dr = -matmul((/dble(a),dble(b),dble(c)/),cell_sc) &\n                           +pos_j-pos_i\n                           ixyz = matmul(dr-(pos_j_pc-pos_i_pc),ivcell)\n                           nreq = 1\n                           jj = 0\n                           do ir = 1,124\n                               df = dot_product(dr,rws(ir,1:3))-rd(ir)\n                               if (df.gt.1.0d-5) then\n                                   jj = 1\n                                   cycle\n                               end if\n                               if (abs(df).lt.1.0d-5) then\n                                   nreq = nreq+1\n                               end if\n                           end do\n                           aa = -nint(ixyz(1))\n                           bb = -nint(ixyz(2))\n                           cc = -nint(ixyz(3))\n                           if (jj.eq.0) then\n                               weight = 1.0/dble(nreq)\n                           end if\n                           if (weight.gt.0) then\n                               t1 = mod(aa+1,nx)\n                               if (t1.le.0) then\n                                   t1 = t1+nx\n                               end if\n                               t2 = mod(bb+1,ny)\n                               if (t2.le.0) then\n                                   t2 = t2+ny\n                               end if\n                               t3 = mod(cc+1,nz)\n                               if (t3.le.0) then\n                                   t3 = t3+nz\n                               end if\n                               do m = 1,3\n                                   do n = 1,3\n                                        dynmat(ik,(i-1)*3+m,(j-1)*3+n) = dynmat(ik,(i-1)*3+m,(j-1)*3+n)&\n                                    +weight*fc(m,n,idx_scpc(i),idx_scpc(j),t1,t2,t3)&\n                                    *exp(i_imag*dot_product(dr-(pos_j-pos_i),matmul(kpoint,reci_cell_sc)))\n                                   end do\n                                end do\n\n\n\n                           end if\n                       end do\n                    end do\n                end do\n            end do\n        end do\n    end do\n    do ik = 1,nk\n        do iat = 1,natm_sc\n            mi = mass_sc(iat)\n            do jat = 1,natm_sc\n                mj = mass_sc(jat)\n                do ipol = 1,3\n                    do jpol = 1,3\n                        dynmat(ik,(iat-1)*3+ipol,(jat-1)*3+jpol) = &\n                        dynmat(ik,(iat-1)*3+ipol,(jat-1)*3+jpol)/sqrt(mi*mj)\n                    end do\n                end do\n            end do\n        end do\n    end do\n\n\n\n    ! possible reciprocal lattice vectors g\n    allocate(ggrid(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,3))\n    ggrid = 0.0d0\n    do i = 1,2*nx_sc+1\n        do j = 1,2*ny_sc+1\n            do k = 1,2*nz_sc+1\n                ggrid(i,j,k,:) = matmul((/dble(i-nx_sc-1),dble(j-ny_sc-1),dble(k-nz_sc-1)/),reci_cell_sc)\n            end do\n        end do\n    end do\n    if (unfold.ne.0) then\n        allocate(weightk(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1))\n        allocate(spectral(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n        allocate(spectral_proj(3,nlay,2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n        allocate(kmeshx(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n        allocate(kmeshy(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n        allocate(kmeshz(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n        allocate(emesh(2*nx_sc+1,2*ny_sc+1,2*nz_sc+1,nk,ne))\n    else\n        allocate(weightk(1,1,1))\n        allocate(spectral(1,1,1,1,1))\n        allocate(spectral_proj(1,1,1,1,1,1,1))\n        allocate(kmeshx(1,1,1,1,1))\n        allocate(kmeshy(1,1,1,1,1))\n        allocate(kmeshz(1,1,1,1,1))\n        allocate(emesh(1,1,1,1,1))\n    end if\n\n    spectral = 0.0d0\n    spectral_proj = 0.0d0\n\n    open(unit=4,file=\"eigen.dat\",status=\"unknown\",action=\"write\")\n    open(unit=44,file=\"pr.dat\",status=\"unknown\",action=\"write\")\n    open(unit=55,file=\"prd.dat\",status=\"unknown\",action=\"write\")\n\n\n    do ik = 1,nk\n        matmat = (dynmat(ik,:,:)+dble(ipolar)*dynmat_g(ik,:,:)) * cm2\n        call eigenh(matmat,omega(ik,:),evs)\n        if ((dos.ne.0).and.(verbose.ne.0)) then\n            call write_evs(ik,evs,kps(ik,:))\n        else if ((dos.ne.0).and.(verbose.eq.0)) then\n            call write_evs_avg(ik,evs,kps(ik,:))\n        end if\n        omega(ik,:) = real(sqrt(abs(omega(ik,:))))\n        ! participation ratio \n        do ib = 1,natm_sc*3\n            pr(ik,ib) = participation(evs(:,ib)) \n            prd(ik,ib) =participation(evs(6*nx_sc*ny_sc*natm*3+1:natm_sc*3-6*nx_sc*ny_sc*natm*3,ib)) \n        end do\n        \n        do ib = 1,natm_sc*3\n            if (unfold.ne.0) then\n                weightk(:,:,:) = 0.0\n                do ii = 1,2*nx_sc+1\n                    do jj = 1,2*ny_sc+1\n                        do kk = 1,2*nz_sc+1\n                            do ie=1,size(egrid,1)\n                                ktemp = matmul(kps(ik,:),reci_cell_sc) + ggrid(ii,jj,kk,:)\n                                kmeshx(ii,jj,kk,ik,ie) = ktemp(1)\n                                kmeshy(ii,jj,kk,ik,ie) = ktemp(2)\n                                kmeshz(ii,jj,kk,ik,ie) = ktemp(3)\n                                emesh(ii,jj,kk,ik,ie) = egrid(ie) \n                            end do\n                            weightk(ii,jj,kk) = weight_k(matmul(kps(ik,:),reci_cell_sc),ggrid(ii,jj,kk,:),evs(:,ib))\n                            spectral(ii,jj,kk,ik,:) = spectral(ii,jj,kk,ik,:)+ weightk(ii,jj,kk)*exp(-0.5*(omega(ik,ib)-egrid(:))**2/sigma**2)&\n                                /sigma/sqrt(2*pi)\n                            do nn= 1,nlay \n                                do ll = 1,layern(nn)\n                                    do alpha = 1,3\n                                        spectral_proj(alpha,nn,ii,jj,kk,ik,:) =spectral_proj(alpha,nn,ii,jj,kk,ik,:)&\n                        +abs(evs((layerlist(nn,ll)-1)*3+alpha,ib)/sqrt(mass_sc(layerlist(nn,ll))))**2&\n                         *weightk(ii,jj,kk)*exp(-0.5*(omega(ik,ib)-egrid(:))**2/sigma**2)&\n                        /sigma/sqrt(2*pi)\n                                    end do\n                                end do\n                            end do \n                        end do\n                    end do\n                end do\n            end if\n            write(4,2000,advance=\"no\") omega(ik,ib)\n            write(44,2000,advance=\"no\") pr(ik,ib)\n            write(55,2000,advance=\"no\") prd(ik,ib)\n        end do\n        write(4,\"(a)\",advance=\"yes\") \" \"\n        write(44,\"(a)\",advance=\"yes\") \" \"\n        write(55,\"(a)\",advance=\"yes\") \" \"\n        write(*,140) dble(ik)/dble(nk)*100.0d0,'%'\n    end do\n    2000 format(1f10.5)\n    140 format(f8.2,a)\n    close(4)\n    close(44)\n    close(55)\n\n    allocate(datamesh((nk)*nz_sc+1,ne))\n    allocate(datamesh_proj(3,nlay,(nk)*nz_sc+1,ne))\n    datamesh = 0.0d0\n    datamesh_proj = 0.0d0\n    !! formatted\n    if (unfold .ne. 0) then\n        do ik = 1,nk\n        !    do ib = 1,natm_sc*3\n                do ii = 1,2*nx_sc+1\n                    do jj = 1,2*ny_sc+1\n                        do kk = 1,2*nz_sc+1\n                            if ((kmeshz(ii,jj,kk,ik,1).ge. (-1.0*pi/az)) .and.(kmeshz(ii,jj,kk,ik,1).le. (1.0*pi/az)).and.(abs(kmeshx(ii,jj,kk,ik,1)).lt.1.0d-4).and.(abs(kmeshy(ii,jj,kk,ik,1)).lt.1.0d-4)) then \n        !                        write(*,*)(kmeshz(ii,jj,kk,ik,1)+1.0*pi/az)/(2*pi/az/nz_sc/(nk-1))-nint((kmeshz(ii,jj,kk,ik,1)+1.0*pi/az)/(2*pi/az/nz_sc/(nk-1)))\n        !                    do ie=1,size(egrid,1)\n                                 ikz = nint((kmeshz(ii,jj,kk,ik,1)+1.0*pi/az)/(2*pi/az/nz_sc/(nk)))+1\n                                 datamesh(ikz,:) = datamesh(ikz,:) +&\n                                 spectral(ii,jj,kk,ik,:)\n                                 do nn= 1,nlay \n                                     do alpha=1,3\n                                         datamesh_proj(alpha,nn,ikz,:) = datamesh_proj(alpha,nn,ikz,:) +&\n                                         spectral_proj(alpha,nn,ii,jj,kk,ik,:)\n                                     end do                         \n                                 end do\n                                \n        !                        write(1,2000,advance='no') spectral(ii,jj,kk,ik,ie)\n        !                        write(2,2000,advance='no') emesh(ii,jj,kk,ik,ie)\n        !                        write(3,2000,advance='no') kmeshz(ii,jj,kk,ik,ie)\n        !                    end do\n        !                     write(1,\"(a)\",advance=\"yes\") \" \"\n        !                     write(2,\"(a)\",advance=\"yes\") \" \"\n        !                     write(3,\"(a)\",advance=\"yes\") \" \"\n                             end if\n                        end do\n                    end do\n                end do\n        !    end do\n        !    write(*,*) dble(ik)/dble(nk)\n        end do\n    end if\n    !2000 format(1f10.5)\n    if (verbose .ne. 0) then\n        ! write the spectral function\n        open(unit=1,file=\"spectral.dat\",status=\"unknown\",action=\"write\",form=\"unformatted\")\n        open(unit=2,file=\"emesh.dat\",status=\"unknown\",action=\"write\",form=\"unformatted\")\n        open(unit=3,file=\"kmeshz.dat\",status=\"unknown\",action=\"write\",form=\"unformatted\")\n        write(1) spectral\n        write(2) emesh\n        write(3) kmeshz\n        close(1)\n        close(2)\n        close(3)\n    end if\n\n    open(unit=1,file=\"datamesh.dat\",status=\"unknown\",action=\"write\",form=\"unformatted\")\n    write(1) datamesh\n    close(1)\n    open(unit=1,file=\"datamesh_proj.dat\",status=\"unknown\",action=\"write\",form=\"unformatted\")\n    write(1) datamesh_proj\n    close(1)\nelse\n    do ik = 1,nk\n        kpoint = kps(ik,:)\n        matmat = 0.0d0\n        do a = -nscx,nscx\n            do b = -nscy,nscy\n                do c = -nscz,nscz\n                    do i = 1,natm_sc\n                       pos_i = pos_sc(i,:)\n                       pos_i_pc = pos(idx_scpc(i),:)\n                       do j = 1,natm_sc\n                           pos_j = pos_sc(j,:)\n                           pos_j_pc = pos(idx_scpc(j),:)\n                           total_weight = 0.0\n                           g(1,:) = matmul(kpoint,reci_cell_sc)\n                           weight = 0.0d0\n                           dr = -matmul((/dble(a),dble(b),dble(c)/),cell_sc) &\n                           +pos_j-pos_i\n                           ixyz = matmul(dr-(pos_j_pc-pos_i_pc),ivcell)\n                           nreq = 1\n                           jj = 0\n                           do ir = 1,124\n                               df = dot_product(dr,rws(ir,1:3))-rd(ir)\n                               if (df.gt.1.0d-5) then\n                                   jj = 1\n                                   cycle\n                               end if\n                               if (abs(df).lt.1.0d-5) then\n                                   nreq = nreq+1\n                               end if\n                           end do\n                           aa = -nint(ixyz(1))\n                           bb = -nint(ixyz(2))\n                           cc = -nint(ixyz(3))\n                           if (jj.eq.0) then\n                               weight = 1.0/dble(nreq)\n                           end if\n                           if (weight.gt.0) then\n                               t1 = mod(aa+1,nx)\n                               if (t1.le.0) then\n                                   t1 = t1+nx\n                               end if\n                               t2 = mod(bb+1,ny)\n                               if (t2.le.0) then\n                                   t2 = t2+ny\n                               end if\n                               t3 = mod(cc+1,nz)\n                               if (t3.le.0) then\n                                   t3 = t3+nz\n                               end if\n                               do m = 1,3\n                                   do n = 1,3\n                                        matmat((i-1)*3+m,(j-1)*3+n) = matmat((i-1)*3+m,(j-1)*3+n)&\n                                       +weight*fc(m,n,idx_scpc(i),idx_scpc(j),t1,t2,t3)&\n                                       /sqrt(mass_sc(i)*mass_sc(j))&\n                                       *exp(i_imag*dot_product(dr-(pos_j-pos_i),matmul(kpoint,reci_cell_sc)))\n\n                     \n                                   end do\n                                end do\n                           end if\n                       end do\n                    end do\n                end do\n            end do\n        end do\n\n        matmat =matmat*cm2\n        call eigenh(matmat,omega(ik,:),evs)\n        omega(ik,:) = real(sqrt(abs(omega(ik,:))))\n        velx = 0.0d0\n        vely = 0.0d0\n        velz = 0.0d0\n        do a = -nscx,nscx\n            do b = -nscy,nscy\n                do c = -nscz,nscz\n                    do i = 1,natm_sc\n                       pos_i = pos_sc(i,:)\n                       pos_i_pc = pos(idx_scpc(i),:)\n                       do j = 1,natm_sc\n                           pos_j = pos_sc(j,:)\n                           pos_j_pc = pos(idx_scpc(j),:)\n                           total_weight = 0.0\n                           g(1,:) = matmul(kpoint,reci_cell_sc)\n                           weight = 0.0d0\n                           dr = -matmul((/dble(a),dble(b),dble(c)/),cell_sc) &\n                           +pos_j-pos_i\n                           ixyz = matmul(dr-(pos_j_pc-pos_i_pc),ivcell)\n                           nreq = 1\n                           jj = 0\n                           \n                           do ir = 1,124\n                               df = dot_product(dr,rws(ir,1:3))-rd(ir)\n                               if (df.gt.1.0d-5) then\n                                   jj = 1\n                                   cycle\n                               end if\n                               if (abs(df).lt.1.0d-5) then\n                                   nreq = nreq+1\n                               end if\n                           end do\n                           aa = -nint(ixyz(1))\n                           bb = -nint(ixyz(2))\n                           cc = -nint(ixyz(3))\n                           if (jj.eq.0) then\n                               weight = 1.0/dble(nreq)\n                           end if\n                           if (weight.gt.0) then\n                               t1 = mod(aa+1,nx)\n                               if (t1.le.0) then\n                                   t1 = t1+nx\n                               end if\n                               t2 = mod(bb+1,ny)\n                               if (t2.le.0) then\n                                   t2 = t2+ny\n                               end if\n                               t3 = mod(cc+1,nz)\n                               if (t3.le.0) then\n                                   t3 = t3+nz\n                               end if\n                               do m = 1,3\n                                   do n = 1,3\n                                        velx((i-1)*3+m,(j-1)*3+n) = velx((i-1)*3+m,(j-1)*3+n)&\n                                    +i_imag*weight*fc(m,n,idx_scpc(i),idx_scpc(j),t1,t2,t3)&\n                                    *(dr(1)-(pos_j(1)-pos_i(1)))/sqrt(mass_sc(i)*mass_sc(j))&\n                                    *exp(i_imag*dot_product(dr-(pos_j-pos_i),matmul(kpoint,reci_cell_sc)))\n\n                                        vely((i-1)*3+m,(j-1)*3+n) = vely((i-1)*3+m,(j-1)*3+n)&\n                                    +i_imag*weight*fc(m,n,idx_scpc(i),idx_scpc(j),t1,t2,t3)&\n                                    *(dr(2)-(pos_j(2)-pos_i(2)))/sqrt(mass_sc(i)*mass_sc(j))&\n                                    *exp(i_imag*dot_product(dr-(pos_j-pos_i),matmul(kpoint,reci_cell_sc)))\n                                    \n                                        velz((i-1)*3+m,(j-1)*3+n) = velz((i-1)*3+m,(j-1)*3+n)&\n                                    +i_imag*weight*fc(m,n,idx_scpc(i),idx_scpc(j),t1,t2,t3)&\n                                    *(dr(3)-(pos_j(3)-pos_i(3)))/sqrt(mass_sc(i)*mass_sc(j))&\n                                    *exp(i_imag*dot_product(dr-(pos_j-pos_i),matmul(kpoint,reci_cell_sc)))\n\n                                   end do\n                                end do\n                           end if\n                       end do\n                    end do\n                end do\n            end do\n        end do\n\n\n        velx = matmul(dconjg(transpose(evs)),matmul(velx,evs))\n        vely = matmul(dconjg(transpose(evs)),matmul(vely,evs))\n        velz = matmul(dconjg(transpose(evs)),matmul(velz,evs))\n        do i = 1,natm_sc*3\n            do j = 1,natm_sc*3\n                velx(i,j) = velx(i,j)/sqrt(omega(ik,i)*omega(ik,j))\n                vely(i,j) = vely(i,j)/sqrt(omega(ik,i)*omega(ik,j))\n                velz(i,j) = velz(i,j)/sqrt(omega(ik,i)*omega(ik,j))\n            end do\n        end do\n\n        velx = velx/2.0d0*0.02998*cm2*2*pi*1.0d2\n        vely = vely/2.0d0*0.02998*cm2*2*pi*1.0d2\n        velz = velz/2.0d0*0.02998*cm2*2*pi*1.0d2\n\n        write (x1,fmt) ik\n\n        open(unit=4,file=\"displacements/vel\"//trim(x1)//\".dat\",status=\"unknown\",action=\"write\")\n        do i = 1,3*natm_sc\n            write(4,2001) omega(ik,i),real(velx(i,i)),real(vely(i,i)),real(velz(i,i))\n        end do\n\n        2001 format(4e15.5)\n        close(4)\n    end do\nend if\n\nend subroutine\n"}
{"id": 141, "subroutine": "subroutine write_evs(i,evs,kpts)\n\nuse view_struct\n\nimplicit none\n\ninteger(kind=4) :: i,m,n,nmode,nindex\ncomplex(kind=8) :: evs(:,:)\nreal(kind=8)    :: kpts(3)\ncharacter(len=8) :: fmt,x1\n\nnmode = size(evs,2)\nnindex = size(evs,1)\n\n\nfmt = '(i6.6)'\nwrite (x1,fmt) i\nopen(unit=1,file=\"displacements/\"//trim(x1)//\".dat\",status=\"unknown\",action=\"write\")\ndo m = 1,nmode\n    write(1,*) real(evs(:,m))/sqrt(mass_ev(:))\nend do\nclose(unit=1)\n\nend subroutine\n"}
{"id": 142, "subroutine": "  subroutine build_primitive_cell(banddos,p_cell,cell)\n    use m_types\n    use m_inv3\n    use m_constants, only : tpi_const\n    implicit none\n    type(t_banddos),intent(in)  :: banddos\n    type(t_cell),intent(in)     :: cell\n    type(t_cell),intent(inout)  :: p_cell\n\n    integer :: i\n    do i =1,3\n\tp_cell%amat(1,i)=cell%amat(1,i)/banddos%s_cell_x\n\tp_cell%amat(2,i)=cell%amat(2,i)/banddos%s_cell_y\n\tp_cell%amat(3,i)=cell%amat(3,i)/banddos%s_cell_z\n!\tp_cell%amat(i,1)=cell%amat(i,1)/banddos%s_cell_x\n!\tp_cell%amat(i,2)=cell%amat(i,2)/banddos%s_cell_y\n!\tp_cell%amat(i,3)=cell%amat(i,3)/banddos%s_cell_z\n    end do\n    call inv3(p_cell%amat,p_cell%bmat,p_cell%omtil)\n    p_cell%bmat=p_cell%bmat*tpi_const\n  end subroutine  build_primitive_cell\n"}
{"id": 143, "subroutine": "  subroutine unfold_band_kpts(banddos,p_cell,cell,p_kpts,kpts)\n    use m_types\n    use m_inv3\n    use m_constants, only : tpi_const\n\n    implicit none\n\n    type(t_banddos),intent(in)  :: banddos\n    type(t_cell),intent(in)     :: cell\n    type(t_cell),intent(inout)  :: p_cell\n    type(t_kpts),intent(inout)  :: p_kpts\n    type(t_kpts),intent(inout)  :: kpts\n\n    call build_primitive_cell(banddos,p_cell,cell)\n\n    p_kpts=kpts\n    !write(1088,*) 'banddos%unfoldband: ', banddos%unfoldband\n    !write(1088,*) 'brav. matrix: '\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%amat(1,1), cell%amat(1,2), cell%amat(1,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%amat(2,1), cell%amat(2,2), cell%amat(2,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%amat(3,1), cell%amat(3,2), cell%amat(3,3)\n    !write(1088,*) 'brav. rez. matrix: '\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%bmat(1,1), cell%bmat(1,2), cell%bmat(1,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%bmat(2,1), cell%bmat(2,2), cell%bmat(2,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') cell%bmat(3,1), cell%bmat(3,2), cell%bmat(3,3)\n    !write(1088,*) ' primitive brav. matrix: '\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%amat(1,1), p_cell%amat(1,2), p_cell%amat(1,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%amat(2,1), p_cell%amat(2,2), p_cell%amat(2,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%amat(3,1), p_cell%amat(3,2), p_cell%amat(3,3)\n    !write(1088,*) 'primitive brav. rez. matrix: '\n    !write(89,'(3f15.8)') p_cell%bmat\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%bmat(1,1), p_cell%bmat(1,2), p_cell%bmat(1,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%bmat(2,1), p_cell%bmat(2,2), p_cell%bmat(2,3)\n    !write(1088,'(f15.8,f15.8,f15.8)') p_cell%bmat(3,1), p_cell%bmat(3,2), p_cell%bmat(3,3)\n    !write(1088,'(a,i7,a,i7)') 'kpts%nkpt',kpts%nkpt,'   p_kpts%nkpt',p_kpts%nkpt\n    !write(1088,*) kpts%specialpoints\n  end subroutine unfold_band_kpts\n"}
{"id": 144, "subroutine": "  subroutine find_supercell_kpts(banddos,p_cell,cell,p_kpts,kpts)\n    use m_types\n    use m_judft\n    use m_inv3\n    implicit none\n\n    type(t_banddos),intent(in)  :: banddos\n    type(t_cell),intent(in)     :: cell\n    type(t_cell),intent(in)     :: p_cell\n    type(t_kpts),intent(in)     :: p_kpts\n    type(t_kpts),intent(inout)  :: kpts\n\n    integer :: i,m1,m2,m3\n    real    :: rez_inv_to_internal(3,3)\n    real    :: rez_inv_det\n    real    :: list(13,p_kpts%nkpt)  !cartesion coordinates for k,k,m\n    real    :: pc_kpoint_i(3)    !primitive cell kpoint internal\n    real    :: sc_kpoint_i(3)    !super cell kpoint internal\n    real    :: pc_kpoint_c(3)    !primitive cell kpoint cartesian\n    real    :: sc_kpoint_c(3)    !super cell kpoint cartesian\n    real    :: eps(3)\n    real    :: eps_r, eps_kpt\n    logical :: representation_found\n    real    ::kpt_dist\n\n    eps = 1.0e-10\n    eps_r = 0.000000001\n\n    call inv3(cell%bmat,rez_inv_to_internal,rez_inv_det)\n    !write(1088,*) p_kpts%specialpoints\n    !write(333,'(3f15.8)')p_kpts%bk\n    kpt_dist=0\n    do i= 1,size(list,2)\n\t!        pc_kpoint_c(1)=p_kpts%bk(1,i)*p_cell%bmat(1,1)+p_kpts%bk(2,i)*p_cell%bmat(1,2)+p_kpts%bk(3,i)*p_cell%bmat(1,3)\n\t!        pc_kpoint_c(2)=p_kpts%bk(1,i)*p_cell%bmat(2,1)+p_kpts%bk(2,i)*p_cell%bmat(2,2)+p_kpts%bk(3,i)*p_cell%bmat(2,3)\n\t!        pc_kpoint_c(3)=p_kpts%bk(1,i)*p_cell%bmat(3,1)+p_kpts%bk(2,i)*p_cell%bmat(3,2)+p_kpts%bk(3,i)*p_cell%bmat(3,3)\n\t\tpc_kpoint_c(1)=p_kpts%bk(1,i)*p_cell%bmat(1,1)+p_kpts%bk(2,i)*p_cell%bmat(2,1)+p_kpts%bk(3,i)*p_cell%bmat(3,1)\n\t\tpc_kpoint_c(2)=p_kpts%bk(1,i)*p_cell%bmat(1,2)+p_kpts%bk(2,i)*p_cell%bmat(2,2)+p_kpts%bk(3,i)*p_cell%bmat(3,2)\n\t\tpc_kpoint_c(3)=p_kpts%bk(1,i)*p_cell%bmat(1,3)+p_kpts%bk(2,i)*p_cell%bmat(2,3)+p_kpts%bk(3,i)*p_cell%bmat(3,3)\n\t\tlist(1,i)=pc_kpoint_c(1)\n\t\tlist(2,i)=pc_kpoint_c(2)\n\t\tlist(3,i)=pc_kpoint_c(3)\n\t!!!!------- finding kpts in primitive rez. unit cell -----\n\t!\trepresentation_found=.false.\n\t!m_loop:\tdo m1= -banddos%s_cell_x,banddos%s_cell_x\n\t!\t\tdo m2= -banddos%s_cell_y,banddos%s_cell_y\n\t!\t\t\tdo m3= -banddos%s_cell_z,banddos%s_cell_z\n\t!\t\t\t\tpc_kpoint_c(1)=list(1,i)-m1*cell%bmat(1,1)-m2*cell%bmat(1,2)-m3*cell%bmat(1,3)\n\t!\t\t\t\tpc_kpoint_c(2)=list(2,i)-m1*cell%bmat(2,1)-m2*cell%bmat(2,2)-m3*cell%bmat(2,3)\n\t!\t\t\t\tpc_kpoint_c(3)=list(3,i)-m1*cell%bmat(3,1)-m2*cell%bmat(3,2)-m3*cell%bmat(3,3)\n\t!!\t\t\t\tif (         (dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,1)) >= 0).and.((dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,1)) < dot_product(cell%bmat(:,1), cell%bmat(:,1)))) &\n\t!!\t\t\t\t     & .and. (dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,2)) >= 0).and.((dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,2)) < dot_product(cell%bmat(:,2), cell%bmat(:,2)))) &\n\t!!\t\t\t\t     & .and. (dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,3)) >= 0).and.((dot_product(pc_kpoint_c(:)+eps(:), cell%bmat(:,3)) < dot_product(cell%bmat(:,3), cell%bmat(:,3))))) then\n\t!\t\t\t\tif (all((matmul(rez_inv_to_internal,pc_kpoint_c)+eps(:))>=0).and.all((matmul(rez_inv_to_internal,pc_kpoint_c)+eps(:))<1)) then\n\t!\t\t\t\t\tlist(4,i)=pc_kpoint_c(1)\n\t!\t\t\t\t\tlist(5,i)=pc_kpoint_c(2)\n\t!\t\t\t\t\tlist(6,i)=pc_kpoint_c(3)\n\t!\t\t\t\t\tlist(7,i)=-m1\n\t!\t\t\t\t\tlist(8,i)=-m2\n\t!\t\t\t\t\tlist(9,i)=-m3\n\t!\t\t\t\t\trepresentation_found=.true.\n\t!\t\t\t\tend if\n\t !      \t\t\t        if (representation_found) exit m_loop\n\t!\t\t\tend do\n\t!\t\tend do\n\t!\tend do m_loop\n\t !       if (.not.representation_found) then\n\t  !      write(*,'(a,f15.8,f15.8,f15.8)') 'no representation found for the following kpoint:',list(1,i),list(2,i),list(3,i)\n\t   !     end if\n\t   !----------------------- method internal coordintes --------------------\n\t    sc_kpoint_i(:)=matmul(pc_kpoint_c,rez_inv_to_internal)\n\t    pc_kpoint_i(:)=p_kpts%bk(1:3,i)\n\t    !sc_kpoint_i(:) = sc_kpoint_i(:) + 0.5\n\t    m1 = floor(sc_kpoint_i(1))\n\t    m2 = floor(sc_kpoint_i(2))\n\t    m3 = floor(sc_kpoint_i(3))\n\t    m1=0\n\t    m2=0\n\t    m3=0\n\t    sc_kpoint_i(1) = sc_kpoint_i(1) - m1\n\t    sc_kpoint_i(2) = sc_kpoint_i(2) - m2\n\t    sc_kpoint_i(3) = sc_kpoint_i(3) - m3\n\t    !sc_kpoint_i(:) = sc_kpoint_i(:) - 0.5\n\t    list(4,i)=sc_kpoint_i(1)\n\t    list(5,i)=sc_kpoint_i(2)\n\t    list(6,i)=sc_kpoint_i(3)\n\t    list(7,i)=m1\n\t    list(8,i)=m2\n\t    list(9,i)=m3 !this whole block is to move kpoints into first bz within -0.5 to 0.5\n\n\t!  \tkpts%bk(:,i)=matmul(rez_inv_to_internal,pc_kpoint_c)\n\t    !-------------saving old kpts----------\n\t    list(11:13,i)=kpts%bk(:,i)\n  \t    !------finished---------\n\t    kpts%bk(:,i)=list(4:6,i)\n\n\tif (i>1) then\n\tkpt_dist=kpt_dist+sqrt(dot_product(list(1:3,i)-list(1:3,i-1),list(1:3,i)-list(1:3,i-1)))\n\tend if\n\tlist(10,i)=kpt_dist\n    end do\n    !write(91,'(3f15.8)') kpts%bk\n    !write(92,*) kpts%wtkpt\n    allocate (kpts%sc_list(13,p_kpts%nkpt))\n    kpts%specialpointindices(:) = p_kpts%specialpointindices(:)\n    kpts%sc_list=list\n    !write(90,'(10f15.8)') kpts%sc_list\n  end subroutine find_supercell_kpts\n"}
{"id": 145, "subroutine": " subroutine calculate_plot_w_n(banddos,cell,kpts,smat_unfold,zmat,lapw,i_kpt,jsp,eig,results,input,atoms,unfoldingbuffer,fmpi)\n\tuse m_types\n\tuse m_judft\n\tuse m_inv3\n\tuse m_types_mpimat\n        use m_constants\n\timplicit none\n\n        type(t_input),intent(in) :: input\n        type(t_atoms),intent(in)     :: atoms\n\ttype(t_banddos),intent(in)  :: banddos\n\ttype(t_results),intent(inout)  :: results\n\ttype(t_cell),intent(in)     :: cell\n\ttype(t_kpts),intent(in)     :: kpts\n\tclass(t_mat),intent(inout)  :: smat_unfold\n\tclass(t_mat),intent(in)     :: zmat\n\ttype(t_lapw),intent(in)     :: lapw\n        type(t_mpi),intent(in)       :: fmpi\n\ttype(t_cell)      :: p_cell\n\tinteger, intent(in)\t    :: i_kpt,jsp\n\treal, intent(in)\t    :: eig(:)\n        complex, intent(inout)         :: unfoldingbuffer(:,:,:)\n\tinteger :: i,j,k,l,n\n\tinteger :: na,n_i,nn,nk,nki,gi,lo\n\treal, allocatable\t::w_n(:)\n\tcomplex, allocatable    ::w_n_c(:)\n\treal, allocatable\t::w_n_sum(:)\n\tcomplex, allocatable    ::w_n_c_sum(:)\n        logical :: method_rubel=.false.\n        logical :: write_to_file=.false.\n        class(t_mat), allocatable :: zmat_s\n\n!\tmethod_rubel=.true.    !this switch is to switch between overlap matrix and rubel method (without overlap matrix)\n\n\tcall build_primitive_cell(banddos,p_cell,cell)\n\tif (.not. method_rubel) then\n\t\tdo j = 1, lapw%nv(jsp)\n\t\t  do i = 1, j-1\n\t      \t\tif(smat_unfold%l_real) then\n\t\t\t\tsmat_unfold%data_r(j,i) = smat_unfold%data_r(i,j)\n\t      \t\telse\n\t\t\t\tsmat_unfold%data_c(j,i) = conjg(smat_unfold%data_c(i,j))\n\t      \t\tend if\n\t\t   end do\n\t\tend do\n\tend if\n!   \twrite_to_file=.true.\n\tif (write_to_file) then\n\t\tif (i_kpt==1) then\n\t\t\tif (jsp==1) open (679,file='bands_sc_old.1',status='unknown') !this is kind of my birthday 6 july 1992 (s.r.)\n\t\t\tif (jsp==2) open (680,file='bands_sc_old.2',status='unknown')\n\t\tend if\n\tend if\n\n!\t\twrite(*,*) 'real zmat size dim 1:', size(zmat%data_r,1), 'dim2:', size(zmat%data_r,2)\n!\t\twrite(*,*) 'smat dim1', size(smat_unfold%data_r,1), 'dim2', size(smat_unfold%data_r,2),'data',smat_unfold%data_r(2,2)\n!\t\twrite(222,'(234f15.8)') zmat%data_r\n!\t\twrite(223,'(234f15.8)') smat_unfold%data_r\n\n\n\tif (zmat%l_real) then\n\t\tallocate(w_n(zmat%matsize2))\n\t        w_n = 0\n!\t    if (method_rubel) then\n\t\tallocate(w_n_sum(zmat%matsize2))\n\t        w_n_sum = 0\n!\t    end if\n\telse\n\t\tallocate(w_n_c(zmat%matsize2))\n\t\tw_n_c=0\n!\t    if (method_rubel) then\n\t\tallocate(w_n_c_sum(zmat%matsize2))\n\t\tw_n_c_sum=0\n!\t    end if\n\tend if\n!---------create zmat_s--- smat*zmat---------------------\n\tselect type(zmat)\n\t\ttype is (t_mat)\n\t\tallocate(t_mat::zmat_s)\n\t\tselect type(zmat_s)\n             \t\ttype is (t_mat)\n\t     \t\tzmat_s=zmat\n\t\tend select\n\t\ttype is (t_mpimat)\n\t\tallocate(t_mpimat::zmat_s)\n\t\tselect type(zmat_s)\n             \t\ttype is (t_mpimat)\n\t     \t\tzmat_s=zmat\n\t\tend select\n\tend select\n!---------------------------------------------------------\n!\t\twrite(345,'(3i6)') lapw%gvec(:,:,jsp)\n\twrite (*,*)results%ef\n        write (*,*) i_kpt\n\tif (.not. method_rubel) then\n!          if (fmpi%n_size==1) then\n!             call smat_unfold%multiply(zmat,zmat_s)\n!          else\n!             call smat_unfold%mpimat_multiply(zmat,zmat_s)\n!          endif\n           call smat_unfold%multiply(zmat,zmat_s)\n        end if\n       !$omp parallel private(j,n_i,nn,na,lo,nk,nki,gi)\n       !$omp do\n\tdo i=1,zmat%matsize2\n\t\tif (method_rubel) then\n\t\t\tdo j=1,lapw%nv(jsp)\n\t\t\t\tif (zmat%l_real) then\n\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat%data_r(j,i)\n!\t\t\t\t\t\twrite(*,*) 'zmat is real'\n\t\t\t\telse\n\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat%data_c(j,i)\n!\t\t\t\t\t\twrite(*,*) 'zmat is complex'\n\t\t\t\tend if\n\t\t\t\tif ((modulo(lapw%gvec(1,j,jsp)+nint(kpts%sc_list(7,i_kpt)),banddos%s_cell_x)==0).and.&\n\t\t\t\t     &(modulo(lapw%gvec(2,j,jsp)+nint(kpts%sc_list(8,i_kpt)),banddos%s_cell_y)==0).and.&\n\t\t\t\t     &(modulo(lapw%gvec(3,j,jsp)+nint(kpts%sc_list(9,i_kpt)),banddos%s_cell_z)==0)) then\n\t\t\t\t\tif (zmat%l_real) then\n\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat%data_r(j,i)\n!\t\t\t\t\t\t\twrite(*,*) 'zmat is real'\n\t\t\t\t\telse\n\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat%data_c(j,i)\n!\t\t\t\t\t\t\twrite(*,*) 'zmat is complex'\n\t\t\t\t\tend if\n\t\t\t   \tend if\n\t\t\tend do\n!------------------lo's------------------------\n\t\t\tna=0\n\t\t\tdo n_i=1,atoms%ntype\n\t\t\t\tdo nn=1,atoms%neq(n_i)\n\t\t\t\t\tna=na+1\n\t\t\t\t\tdo lo=1,atoms%nlo(n_i)\n\t\t\t\t\t\tnk=lapw%nkvec(lo,na)\n\t\t\t\t\t\tdo nki=1,nk\n\t\t\t\t\t\t\tgi=lapw%kvec(nki,lo,na)\n\t\t\t\t\t\t\tj=lapw%nv(jsp)+lapw%index_lo(lo,na)+nki\n\t\t\t\t\t\t\tif (zmat%l_real) then\n\t\t\t\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat%data_r(j,i)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat%data_c(j,i)\n\t\t\t\t\t\t\tend if\n\t\t\t\t\t\t\tif ((modulo(lapw%gvec(1,gi,jsp)+nint(kpts%sc_list(7,i_kpt)),banddos%s_cell_x)==0).and.&\n\t\t\t\t\t\t\t   &(modulo(lapw%gvec(2,gi,jsp)+nint(kpts%sc_list(8,i_kpt)),banddos%s_cell_y)==0).and.&\n\t\t\t\t\t\t\t   &(modulo(lapw%gvec(3,gi,jsp)+nint(kpts%sc_list(9,i_kpt)),banddos%s_cell_z)==0)) then\n\t\t\t\t\t\t\t\tif (zmat%l_real) then\n\t\t\t\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat%data_r(j,i)\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat%data_c(j,i)\n\t\t\t\t\t\t\t\tend if\n\t\t\t\t\t\t\tend if\n\t\t\t\t\t\tend do\n\t\t\t\t\tend do\n\t\t\t\tend do\n\t\t\tend do\n!--------------------------lo's finished----------------\n\t\telse\n\t\t\tdo j=1,lapw%nv(jsp)\n!\t\t\t\tdo k=1,zmat%matsize1\n\t\t\t\t\tif (zmat%l_real) then\n!\t\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat%data_r(k,i)*smat_unfold%data_r(j,k)\n\t\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat_s%data_r(j,i)\n\t\t\t\t\telse\n!\t\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat%data_c(k,i)*smat_unfold%data_c(j,k)\n\t\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat_s%data_c(j,i)\n\t\t\t\t\tend if\n!\t\t\t\tend do\n\t\t\t\tif ((modulo(lapw%gvec(1,j,jsp)+nint(kpts%sc_list(7,i_kpt)),banddos%s_cell_x)==0).and.&\n\t\t\t\t   &(modulo(lapw%gvec(2,j,jsp)+nint(kpts%sc_list(8,i_kpt)),banddos%s_cell_y)==0).and.&\n\t\t\t\t   &(modulo(lapw%gvec(3,j,jsp)+nint(kpts%sc_list(9,i_kpt)),banddos%s_cell_z)==0)) then\n!\t\t\t\t\tdo k=1,zmat%matsize1\n\t\t\t\t\t\tif (zmat%l_real) then\n!\t\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat%data_r(k,i)*smat_unfold%data_r(j,k)\n\t\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat_s%data_r(j,i)\n\t\t\t\t\t\telse\n!\t\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat%data_c(k,i)*smat_unfold%data_c(j,k)\n\t\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat_s%data_c(j,i)\n\t\t\t\t\t\tend if\n!\t\t\t\t\tend do\n\t\t\t\tend if\n\t\t\tend do\n!\t\t\twrite(1250+fmpi%irank,'(4f15.8)') w_n_c(i),w_n_c_sum(i)\n!------------------lo's------------------------\n      \t\t\tna=0\n      \t\t\tdo n_i=1,atoms%ntype\n        \t\t\tdo nn=1,atoms%neq(n_i)\n          \t\t\t\tna=na+1\n          \t\t\t\tdo lo=1,atoms%nlo(n_i)\n\t\t\t\t\t\tnk=lapw%nkvec(lo,na)\n\t\t\t\t\t\tdo nki=1,nk\n\t\t\t\t\t\t\tgi=lapw%kvec(nki,lo,na)\n\t\t\t\t\t\t\tj=lapw%nv(jsp)+lapw%index_lo(lo,na)+nki\n\t\t\t\t!\t\t\tdo k=1,zmat%matsize1\n\t\t\t\t\t\t\t\tif (zmat%l_real) then\n\t\t\t\t!\t\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat%data_r(k,i)*smat_unfold%data_r(j,k)\n\t\t\t\t\t\t\t\t\tw_n_sum(i)=w_n_sum(i)+zmat%data_r(j,i)*zmat_s%data_r(j,i)\n\t\t\t\t\t\t\t\telse\n\t\t\t\t!\t\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat%data_c(k,i)*smat_unfold%data_c(j,k)\n\t\t\t\t\t\t\t\t\tw_n_c_sum(i)=w_n_c_sum(i)+conjg(zmat%data_c(j,i))*zmat_s%data_c(j,i)\n\t\t\t\t\t\t\t\tend if\n\t\t\t\t!\t\t\tend do\n\t\t\t\t\t\t\tif ((modulo(lapw%gvec(1,gi,jsp)+nint(kpts%sc_list(7,i_kpt)),banddos%s_cell_x)==0).and.&\n\t\t\t\t\t\t\t   &(modulo(lapw%gvec(2,gi,jsp)+nint(kpts%sc_list(8,i_kpt)),banddos%s_cell_y)==0).and.&\n\t\t\t\t\t\t\t   &(modulo(lapw%gvec(3,gi,jsp)+nint(kpts%sc_list(9,i_kpt)),banddos%s_cell_z)==0)) then\n\t\t\t!\t\t\t\t\tdo k=1,zmat%matsize1\n\t\t\t\t\t\t\t\t\tif (zmat%l_real) then\n\t\t\t!\t\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat%data_r(k,i)*smat_unfold%data_r(j,k)\n\t\t\t\t\t\t\t\t\t\tw_n(i)=w_n(i)+zmat%data_r(j,i)*zmat_s%data_r(j,i)\n\t\t\t\t\t\t\t\t\telse\n\t\t\t!\t\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat%data_c(k,i)*smat_unfold%data_c(j,k)\n\t\t\t\t\t\t\t\t\t\tw_n_c(i)=w_n_c(i)+conjg(zmat%data_c(j,i))*zmat_s%data_c(j,i)\n\t\t\t\t\t\t\t\t\tend if\n\t\t    \t!\t\t\t\t\tend do\n\t\t\t\t\t\t\tend if\n\t\t\t\t\t\tend do\n\t\t\t\t\tend do\n\t\t\t\tend do\n\t\t\tend do\n!--------------------------lo's finished----------------\n\t\tend if\n!\t\tif (method_rubel) then\n\t\tif (write_to_file) then\n\t\t\tif (zmat%l_real) then\n\t\t\t\tif (w_n(i)/w_n_sum(i)<0) w_n(i)=0   ! delete negative entries\n\t\t\t\tif (jsp==1) write(679,'(3f15.8)') kpts%sc_list(10,i_kpt), ((eig(i)-results%ef)*hartree_to_ev_const),w_n(i)/w_n_sum(i)\n\t\t\t\tif (jsp==2) write(680,'(3f15.8)') kpts%sc_list(10,i_kpt), ((eig(i)-results%ef)*hartree_to_ev_const),w_n(i)/w_n_sum(i)\n\t\t\t\tif ((w_n(i)/w_n_sum(i)>1).or.(w_n(i)/w_n_sum(i)<0)) write(*,*) 'w_n/sum larger 1 or smaller 0', w_n(i)/w_n_sum(i), 'eigenvalue',eig(i)\n\t\t\telse\n\t\t\t\tif (real(w_n_c(i))<0) w_n_c(i)=0    ! delete negative entries\n\t\t\t\tif (jsp==1) write(679,'(4f15.8)') kpts%sc_list(10,i_kpt), ((eig(i)-results%ef)*hartree_to_ev_const),w_n_c(i)/w_n_c_sum(i)\n\t\t\t\tif (jsp==2) write(680,'(4f15.8)') kpts%sc_list(10,i_kpt), ((eig(i)-results%ef)*hartree_to_ev_const),w_n_c(i)/w_n_c_sum(i)\n\t\t\t\tif ((abs(w_n_c(i)/w_n_c_sum(i))>1).or.(real(w_n_c(i))<0)) write(*,*) 'w_n_c/sum larger 1 or smaller 0', w_n_c(i)/w_n_c_sum(i), 'eigenvalue',eig(i)\n\t\t        end if\n                end if\n\t\tif (zmat%l_real) then\n\t\t\tif (w_n(i)/w_n_sum(i)<0) w_n(i)=0   ! delete negative entries\n\t\t\tunfoldingbuffer(i,i_kpt,jsp)=w_n(i)/w_n_sum(i)\n\t\t\tif ((w_n(i)/w_n_sum(i)>1).or.(w_n(i)/w_n_sum(i)<0)) write(*,*) 'w_n/sum larger 1 or smaller 0', w_n(i)/w_n_sum(i), 'eigenvalue',eig(i)\n\t\telse\n\t\t\tif (real(w_n_c(i))<0) w_n_c(i)=0    ! delete negative entries\n\t\t\tunfoldingbuffer(i,i_kpt,jsp)=w_n_c(i)/w_n_c_sum(i)\n\t\t\tif ((abs(w_n_c(i)/w_n_c_sum(i))>1).or.(real(w_n_c(i))<0)) write(*,*) 'w_n_c/sum larger 1 or smaller 0', w_n_c(i)/w_n_c_sum(i), 'eigenvalue',eig(i)\n\t        end if\n!\t\telse\n!\t\t\tif (zmat%l_real) then\n!\t\t\t\tif (jsp==1) write(679,'(3f15.8)') kpt_dist, ((eig(i)-results%ef)*hartree_to_ev_const),w_n(i)\n!\t\t\t\tif (jsp==2) write(680,'(3f15.8)') kpt_dist, ((eig(i)-results%ef)*hartree_to_ev_const),w_n(i)\n!\t\t\t\tif ((w_n(i)>1).or.(w_n(i)<0)) write(*,*) 'w_n larger 1 or smaller 0', w_n(i), 'eigenvalue',eig(i)\n!\t\t\telse\n!\t\t\t\tif (jsp==1) write(679,'(4f15.8)') kpt_dist, ((eig(i)-results%ef)*hartree_to_ev_const),w_n_c(i)\n!\t\t\t\tif (jsp==2) write(680,'(4f15.8)') kpt_dist, ((eig(i)-results%ef)*hartree_to_ev_const),w_n_c(i)\n!\t\t\t\tif ((abs(w_n_c(i))>1).or.(real(w_n_c(i))<0)) write(*,*) 'w_n_c larger 1 or smaller 0', w_n_c(i), 'eigenvalue',eig(i)\n!\t        \tend if\n!\t\tend if\n\tend do\n       !$omp end do\n       !$omp end parallel\n        write (*,*) 'finished',i_kpt\n\tif (i_kpt==kpts%nkpt) then\n\t\tif (write_to_file .and. jsp==1) close (679)\n\t\tif (jsp==input%jspins) then\n\t\t\tif (write_to_file .and. jsp==2) close (680)\n\t\t\t!kpts%bk(:,:)=kpts%sc_list(11:13,:)\n\t\t\twrite(*,*) 'unfolded bandstructure calculated succesfully, calledby=calculate_plot_w_n'\n\t\t\t!call judft_error('unfolded bandstructure created succesfully - use band_sc.gnu to plot', calledby='calculate_plot_w_n')\n\n\t\tend if\n\tend if\n end subroutine\n"}
{"id": 146, "subroutine": "subroutine write_band_sc(kpts,results,efermiprev)\n     use m_types\n     use m_judft\n     use m_constants\n     implicit none\n\ttype(t_results),intent(in)  :: results\n\ttype(t_kpts),intent(in)     :: kpts\n        real, intent(in) :: efermiprev\n\tinteger :: i,i_kpt,jsp\n\n\topen (679,file='bands_sc.1',status='unknown') !this is kind of my birthday 6 july 1992 (s.r.)\n\tif (size(results%unfolding_weights,3)==2) open (680,file='bands_sc.2',status='unknown')\n        do jsp=1,size(results%unfolding_weights,3)\n\t\tdo i_kpt=1,size(results%unfolding_weights,2)\n\t\t\tdo i=1,results%neig(i_kpt,jsp)\n\t\t\t\tif (jsp==1) write(679,'(4f15.8)') kpts%sc_list(10,i_kpt), ((results%eig(i,i_kpt,1)-efermiprev)*hartree_to_ev_const),results%unfolding_weights(i,i_kpt,1)\n\t\t\t\tif (jsp==2) write(680,'(4f15.8)') kpts%sc_list(10,i_kpt), ((results%eig(i,i_kpt,2)-efermiprev)*hartree_to_ev_const),results%unfolding_weights(i,i_kpt,2)\n\t\t\tend do\n\t\tend do\n\tend do\n\tclose (679)\n\tif (size(results%unfolding_weights,3)==2) close (680)\n\twrite(*,*) 'unfolded bandstructure written succesfully - use band_sc.gnu to plot, calledby=write_band_sc',efermiprev\nend subroutine\n"}
{"id": 147, "subroutine": "      subroutine write_gnu_sc(nosyp,d,ssy,input)\n      \tuse m_types\n\tuse m_judft\n      implicit none\n\n      type(t_input),intent(in) :: input\n      integer, intent (in) :: nosyp\n      real,    intent (in) :: d(nosyp)\n      character(len=1), intent (in) :: ssy(nosyp)\n\n      integer n,aoff,adel\n      character(len=200) temptitle\n      aoff = iachar('a')-1\n      adel = iachar('a')-iachar('a')\n      !write(*,*) aoff,adel\n\n      open (27,file='band_sc.gnu',status='unknown')\n      write (27,*) 'reset'\n      write (27,900)\n      write (27,901)\n      write (27,902)\n      write (27,903)\n      write(temptitle,'(10a)') input%comment\n      if(trim(adjustl(temptitle)).eq.'') then\n         temptitle = \"fleur bandstructure\"\n      end if\n      write (27,904) trim(adjustl(temptitle))\n      do n = 1, nosyp\n        write (27,905) d(n),d(n)\n      enddo\n      write (27,906) d(1),d(nosyp)\n!\n! nomal labels\n!\n      if (iachar(ssy(1)) < aoff ) then\n        write (27,907) ssy(1),d(1),achar(92)\n      else\n        write (27,907) \" \",d(1),achar(92)\n      endif\n      do n = 2, nosyp-1\n        if (iachar(ssy(n)) < aoff ) then\n          write (27,908) ssy(n),d(n),achar(92)\n        else\n          write (27,908) \" \",d(n),achar(92)\n        endif\n      enddo\n      if (iachar(ssy(nosyp)) < aoff ) then\n        write (27,909) ssy(nosyp),d(nosyp)\n      else\n        write (27,909) \" \",d(nosyp)\n      endif\n!\n! greek labels\n!\n      do n = 1, nosyp\n        if (iachar(ssy(n)) > aoff ) then\n          write (27,914) achar(iachar(ssy(n))-adel),d(n)\n        endif\n      enddo\n!\n! now write the rest\n!\n      write (27,910)\n      write (27,*) 'set palette model rgb'\n      write (27,*) 'set palette defined (-2 \"black\", -1 \"white\" ,0 \"white\",',achar(92)\n      write (27,*) '0.67 \"light-blue\",1 \"blue\")'\n      write (27,*) 'set cbrange [-2:1]'\n      write (27,*) 'unset colorbox'\n      write (27,*) 'size1(x)=0.9*x**(0.4)'\n      write (27,*) 'color1(x)=0.3+x/2.4'\n      write (27,*) 'size2(x)=0.35*(1-x**(0.01))'\n      write (27,*) 'color2(x)=1.15*(x-1)'\n      write (27,*) 'e_f=0.000000 #fermi energy is already corrected when using hdf5'\n      write (27,911) d(nosyp)+0.00001,achar(92)\n      if (input%jspins == 2) then\n\twrite (27,912) achar(92)\n\twrite (27,916) achar(92)\n      end if\n      write (27,913) achar(92)\n      write (27,915)\n      close (27)\n\n 900  format ('set terminal postscript enhanced color \"times-roman\" 20')\n 901  format ('set xlabel \"\"')\n 902  format ('set ylabel \"e - e_f (ev)\"')\n 903  format ('set nokey')\n 904  format ('set title \"',a,'\"')\n 905  format ('set arrow from',f9.5,', -9.0 to',f9.5,',  5.0 nohead')\n 906  format ('set arrow from',f9.5,', 0.0 to',f9.5,', 0.0 nohead lt 3')\n 907  format ('set xtics (\"',a1,'\"',f9.5,', ',a)\n 908  format ('           \"',a1,'\"',f9.5,', ',a)\n 909  format ('           \"',a1,'\"',f9.5,'  )')\n 910  format ('set ytics -8,2,4')\n 911  format ('plot [0:',f9.5,'] [-9:5] ',a)\n 912  format ('\"bands_sc.2\" using 1:($2-e_f):(size1($3)):(color1($3))  w p pt 7 ps variable lc palette, ',a)\n 916  format ('\"bands_sc.2\" using 1:($2-e_f):(size2($3)):(color2($3)) w p pt 7 ps variable lc palette,',a)\n 913  format ('\"bands_sc.1\" using 1:($2-e_f):(size1($3)):(color1($3))  w p pt 7 ps variable lc palette, ',a)\n 915  format ('\"bands_sc.1\" using 1:($2-e_f):(size2($3)):(color2($3)) w p pt 7 ps variable lc palette')\n 914  format ('set label \"',a1,'\" at ',f9.5,', -9.65 center font \"symbol,20\"')\n      end subroutine write_gnu_sc\n"}
{"id": 148, "subroutine": "  subroutine monolis_prm_initialize(monoprm, fname_in)\n    implicit none\n    type(monolis_prm) :: monoprm\n    character(*) :: fname_in\n\n    !> monoprm%input_file_dir = trim(fname_in)\n    monoprm%method = 1\n    monoprm%precond = 1\n    monoprm%curiter = 0\n    monoprm%maxiter = 1000\n    monoprm%ierr = -1\n    monoprm%tol = 1.0d-8\n    monoprm%curresid = 0.0d0\n    monoprm%is_scaling    = .false.\n    monoprm%is_reordering = .false.\n    monoprm%is_init_x     = .true.\n    monoprm%is_sym_matrix = .true.\n    monoprm%is_debug      = .false.\n    monoprm%is_measurement= .false.\n    monoprm%is_check_diag = .true.\n    monoprm%show_iterlog  = .true.\n    monoprm%show_time     = .true.\n    monoprm%show_summary  = .true.\n  end subroutine monolis_prm_initialize\n"}
{"id": 149, "subroutine": "  subroutine monolis_prm_finalize(monoprm)\n    implicit none\n    type(monolis_prm) :: monoprm\n\n  end subroutine monolis_prm_finalize\n"}
{"id": 150, "subroutine": "  elemental subroutine finalize_single (el)\n    implicit none\n    type(mytype), intent(in) :: el\n    ! do nothing in this test\n  end subroutine finalize_single\n"}
{"id": 151, "subroutine": "  subroutine finalize_vector (el)\n    implicit none\n    type(mytype), intent(inout) :: el(:)\n    ! do nothing in this test\n  end subroutine finalize_vector\n"}
{"id": 152, "subroutine": "  subroutine finalize_matrix (el)\n    implicit none\n    type(mytype) :: el(:, :)\n    ! do nothing in this test\n  end subroutine finalize_matrix\n"}
{"id": 153, "subroutine": "subroutine orca_grad(xyz2,pot_grad,e_evb)\nuse evb_mod \nuse general\nimplicit none\nreal(kind=8)::xyz2(3,natoms)\nreal(kind=8)::pot_grad(3,natoms,1)\nreal(kind=8)::e_evb\ninteger::i,j\n\n\n!\n!     write orca input file\n!\nopen (unit=19,file=\"egrad.inp\",status=\"replace\")\nwrite (19,*) orca_com\nwrite (19,*) \"*xyz 0 1\"\ndo i=1,natoms\n   write(19,*) name(i),xyz2(:,i)*bohr\nend do\nwrite(19,*) \"*\"\nclose(19)\n\ncall system(\"orca egrad.inp > egrad.out\")\n\n!\n!    read in orca output file\n!\nopen(unit=29,file=\"egrad.engrad\",status=\"old\")\ndo i=1,7\n   read(29,*)\nend do\nread(29,*) e_evb\ndo i=1,3\n   read(29,*)\nend do\ndo i=1,natoms\n   do j=1,3\n      read(29,*) pot_grad(j,i,1)\n   end do\nend do\nclose(29)\nreturn\n\nend subroutine orca_grad\n"}
{"id": 154, "subroutine": "subroutine gcmdln()\n\nuse earth, only: list_plate_models\n\nuse platemotion, only: input_file, &\n                       output_file, &\n                       plates, &\n                       pole, &\n                       model_name, &\n                       convert_mode\n\nimplicit none\n\n! local variables\ninteger :: i, j, narg\ncharacter(len=512) :: tag\n\n! initialize control parameters\ninput_file = ''\noutput_file = ''\nplates = ''\npole = 0.0d0\nmodel_name = 'morvel56'\nconvert_mode = ''\n\n! number of arguments\nnarg = command_argument_count()\nif (narg.eq.0) then\n  call usage('')\nendif\n\n! read arguments\ni = 1\ndo while (i.le.narg)\n\n    call get_command_argument(i,tag)\n\n\n    if (trim(tag).eq.'-plate'.or.trim(tag).eq.'-plates') then\n        i = i + 1\n        call get_command_argument(i,plates(1))\n        j = index(plates(1),'/')\n        plates(1)(j:j) = ' '\n        read(plates(1),*) plates(2),plates(2)\n        plates(1)(j:len(plates(1))) = ''\n\n    elseif (trim(tag).eq.'-pole') then\n        i = i + 1\n        call get_command_argument(i,tag)\n        j = index(tag,'/')\n        tag(j:j) = ' '\n        j = index(tag,'/')\n        tag(j:j) = ' '\n        read(tag,*) pole(1),pole(2),pole(3)\n\n    elseif (trim(tag).eq.'-model') then\n        i = i + 1\n        call get_command_argument(i,model_name)\n\n    elseif (trim(tag).eq.'-list') then\n        i = i + 1\n        if (i.gt.narg) then\n            call list_plate_models('all')\n        else\n            call get_command_argument(i,tag)\n            call list_plate_models(tag)\n        endif\n        stop\n\n    elseif (trim(tag).eq.'-f') then\n        i = i + 1\n        call get_command_argument(i,input_file)\n\n    elseif (trim(tag).eq.'-o') then\n        i = i + 1\n        call get_command_argument(i,output_file)\n\n    elseif (tag.eq.'-geo2xyz') then\n        convert_mode = 'geo2xyz'\n    elseif (tag.eq.'-xyz2geo') then\n        convert_mode = 'xyz2geo'\n\n    else\n        call usage('platemotion: no command line option '//trim(tag))\n    endif\n\n    i = i + 1\nenddo\n\n! write(0,*) trim(plates(1)),' ',trim(plates(2))\n! write(0,*) pole\n! write(0,*) model_name\n\nreturn\nend subroutine\n"}
{"id": 155, "subroutine": "subroutine usage(str)\nuse io, only: stderr\nimplicit none\ncharacter(len=*) :: str\n\nif (trim(str).ne.'') then\n    write(stderr,*) trim(str)\n    write(stderr,*)\nendif\n\nwrite(stderr,*) 'usage: platemotion -plate|-pole opt [-model name] [-list [model]] [-f ifile] ',&\n                '[-o ofile]'\nwrite(stderr,*)\nwrite(stderr,*) '-plate p1/p2       plates (p2 moving w.r.t. fixed p1)'\nwrite(stderr,*) '-pole lon/lat/vel  euler pole (velocity in deg/ma)'\nwrite(stderr,*) '-model model_name  plate circuit model (default: morvel56)'\nwrite(stderr,*) '                       itrf2005 (altamimi et al., 2007)'\nwrite(stderr,*) '                       itrf2008 (altamimi et al., 2012)'\nwrite(stderr,*) '                       morvel (demets et al., 2010)'\nwrite(stderr,*) '                       morvel56 (argus et al., 2011)'\nwrite(stderr,*) '                       nuvel1a  (demets et al., 1994)'\nwrite(stderr,*) '-list model        list plates in model (use all or leave blank to see all models)'\nwrite(stderr,*) '-geo2xyz           convert euler pole in geographic coordinates to cartesian'\nwrite(stderr,*) '-xyz2geo           convert euler pole in cartesian coordinates to geographic (assumes lon/lat/vel is x/y/z)'\nwrite(stderr,*) '-f ifile           input file (default: stdin)'\nwrite(stderr,*) '-o ofile           output file (default: stdout)'\nwrite(stderr,*)\n\ncall error_exit(1)\nend subroutine\n"}
{"id": 156, "subroutine": "  subroutine check(status)\n    integer, intent ( in) :: status\n    \n    if(status /= nf90_noerr) then \n      print *, trim(nf90_strerror(status))\n      stop 2\n    end if\n  end subroutine check  \n"}
{"id": 157, "subroutine": "      subroutine ppinit2(idproc,nvp)\n\n! lgrp communicator = mpi_comm_world\n! output: idproc, nvp\n! idproc = processor id in lgrp communicator\n! nvp = number of real or virtual processors obtained\n      implicit none\n      integer, intent(inout) :: idproc, nvp\n! nproc = number of real or virtual processors obtained\n! lgrp = current communicator\n! mreal = default datatype for reals\n! mint = default datatype for integers\n! mcplx = default datatype for complex type\n! mdouble = default double precision type\n! lworld = mpi_comm_world communicator\n! msum = mpi_sum\n! mmax = mpi_max\n! local data\n      integer :: ierror, ndprec, idprec\n      integer :: iprec\n      logical :: flag\n      real :: prec\n! ndprec = (0,1) = (no,yes) use (normal,autodouble) precision\n      if (digits(prec) > 24) then\n         ndprec = 1\n      else\n         ndprec = 0\n      endif\n! idprec = (0,1) = (no,yes) use (normal,autodouble) integer precision\n      if (digits(iprec) > 31) then\n         idprec = 1\n      else\n         idprec = 0\n      endif\n! this segment is used for mpi computers\n! indicate whether mpi_init has been called\n      call mpi_initialized(flag,ierror)\n      if (.not.flag) then\n! initialize the mpi execution environment\n         call mpi_init(ierror)\n         if (ierror /= 0) stop\n      endif\n      lworld = mpi_comm_world\n      lgrp = lworld\n! determine the rank of the calling process in the communicator\n      call mpi_comm_rank(lgrp,idproc,ierror)\n! determine the size of the group associated with a communicator\n      call mpi_comm_size(lgrp,nproc,ierror)\n! set default datatypes\n      mint = mpi_integer\n      mdouble = mpi_double_precision\n! single precision real\n      if (ndprec==0) then\n         mreal = mpi_real\n         mcplx = mpi_complex\n! double precision real\n      else\n         mreal = mpi_double_precision\n         mcplx = mpi_double_complex\n      endif\n! single precision integer\n!     if (idprec==0) then\n!        mint = mpi_integer\n! double precision integer\n!     else\n!        mint = mpi_integer8\n!     endif\n! operators\n      msum = mpi_sum\n      mmax = mpi_max\n      nvp = nproc\n      end subroutine\n"}
{"id": 158, "subroutine": "      subroutine ppexit()\n\n      implicit none\n! lworld = mpi_comm_world communicator\n! local data\n      integer :: ierror\n      logical :: flag\n! indicate whether mpi_init has been called\n      call mpi_initialized(flag,ierror)\n      if (flag) then\n! synchronize processes\n         call mpi_barrier(lworld,ierror)\n! terminate mpi execution environment\n         call mpi_finalize(ierror)\n      endif\n      end subroutine\n"}
{"id": 159, "subroutine": "      subroutine pwtimera(icntrl,time,dtime)\n\n! input: icntrl, dtime\n! icntrl = (-1,0,1) = (initialize,ignore,read) clock\n! clock should be initialized before it is read!\n! time = elapsed time in seconds\n! dtime = current time\n! written for mpi\n      implicit none\n      integer, intent(in) :: icntrl\n      real, intent(inout) :: time\n      double precision, intent(inout) :: dtime\n! local data\n      double precision :: jclock\n! initialize clock\n      if (icntrl==(-1)) then\n         dtime = mpi_wtime()\n! read clock and write time difference from last clock initialization\n      else if (icntrl==1) then\n         jclock = dtime\n         dtime = mpi_wtime()\n         time = real(dtime - jclock)\n      endif\n      end subroutine\n"}
{"id": 160, "subroutine": "      subroutine ppsum(f,g,nxp)\n\n! f(j,k) = sum over k of f(j,k)\n! at the end, all processors contain the same summation.\n! f = input and output real data\n! g = scratch real array\n! nxp = number of data values in vector\n      implicit none\n      integer, intent(in) :: nxp\n      real, dimension(nxp), intent(inout) :: f, g\n! lgrp = current communicator\n! mreal = default datatype for reals\n! msum = mpi_sum\n! local data\n      integer :: j, ierr\n! perform sum\n      call mpi_allreduce(f,g,nxp,mreal,msum,lgrp,ierr)\n! copy output from scratch array\n      do j = 1, nxp\n         f(j) = g(j)\n      enddo\n      end subroutine\n"}
{"id": 161, "subroutine": "      subroutine ppimax(if,ig,nxp)\n\n! that is, if(j,k) = maximum as a function of k of if(j,k)\n! at the end, all processors contain the same maximum.\n! if = input and output integer data\n! ig = scratch integer array\n! nxp = number of data values in vector\n      implicit none\n      integer, intent(in) :: nxp\n      integer, dimension(nxp), intent(inout) :: if, ig\n! lgrp = current communicator\n! mint = default datatype for integers\n! mmax = mpi_max\n! local data\n      integer :: j, ierr\n! find maximum\n      call mpi_allreduce(if,ig,nxp,mint,mmax,lgrp,ierr)\n! copy output from scratch array\n      do j = 1, nxp\n         if(j) = ig(j)\n      enddo\n      end subroutine\n"}
{"id": 162, "subroutine": "      subroutine ppncguard32l(f,scs,nyzp,kstrt,nvpy,nvpz,nxv,nypmx,nzpmx&\n     &,idds)\n\n! f(j,k,l) = real data for grid j,k,l in particle partition.\n! the grid is non-uniform and includes one extra guard cell.\n! scs(j,k) = scratch array for particle partition\n! nyzp(1:2) = number of primary gridpoints in y/z in particle partition\n! kstrt = starting data block number\n! nvpy/nvpz = number of real or virtual processors in y/z\n! nxv = first dimension of f, must be >= nx\n! nypmx = maximum size of particle partition in y, including guard cells\n! nzpmx = maximum size of particle partition in z, including guard cells\n! idds = dimensionality of domain decomposition\n! linear interpolation, for distributed data,\n! with 2d spatial decomposition\n      implicit none\n      integer, intent(in) :: kstrt, nvpy, nvpz, nxv, nypmx, nzpmx, idds\n      real, dimension(nxv,nypmx,nzpmx), intent(inout) :: f\n      real, dimension(nxv,nzpmx,2), intent(inout) :: scs\n      integer, dimension(idds), intent(in) :: nyzp\n! lgrp = current communicator\n! mreal = default datatype for reals\n! local data\n      integer :: j, k, js, ks, noff, kr, kl\n      integer :: nxvz, nxvzs, nxvy, nxvys, nyp1, nzp1\n      integer :: msid, ierr\n      integer, dimension(lstat) :: istatus\n      nyp1 = nyzp(1) + 1\n      nzp1 = nyzp(2) + 1\n! js/ks = processor co-ordinates in y/z => idproc = js + nvpy*ks\n      ks = (kstrt - 1)/nvpy\n      js = kstrt - nvpy*ks - 1\n      noff = nypmx*nzpmx\n      nxvz = nxv*nzpmx\n      nxvy = nxv*nypmx\n! special case for one processor in y\n      if (nvpy==1) then\n!$omp parallel do private(j,k)\n         do k = 1, nyzp(2)\n            do j = 1, nxv\n               f(j,nyp1,k) = f(j,1,k)\n            enddo\n         enddo\n!$omp end parallel do\n      else\n! buffer data in y\n!$omp parallel do private(j,k)\n         do k = 1, nyzp(2)\n            do j = 1, nxv\n               scs(j,k,1) = f(j,1,k)\n            enddo\n         enddo\n!$omp end parallel do\n! copy to guard cells in y\n         nxvzs = nxv*nyzp(2)\n         kr = js + 1\n         if (kr >= nvpy) kr = kr - nvpy\n         kl = js - 1\n         if (kl < 0) kl = kl + nvpy\n         kr = kr + nvpy*ks\n         kl = kl + nvpy*ks\n! this segment is used for mpi computers\n         call mpi_irecv(scs(1,1,2),nxvz,mreal,kr,noff+3,lgrp,msid,ierr)\n         call mpi_send(scs,nxvzs,mreal,kl,noff+3,lgrp,ierr)\n         call mpi_wait(msid,istatus,ierr)\n! copy guard cells\n!$omp parallel do private(j,k)\n         do k = 1, nyzp(2)\n            do j = 1, nxv\n               f(j,nyp1,k) = scs(j,k,2)\n           enddo\n         enddo\n!$omp end parallel do\n      endif\n! special case for one processor in z\n      if (nvpz==1) then\n!$omp parallel do private(j,k)\n         do k = 1, nyp1\n            do j = 1, nxv\n               f(j,k,nzp1) = f(j,k,1)\n            enddo\n         enddo\n!$omp end parallel do\n         return\n      endif\n! copy to guard cells in z\n      nxvys = nxv*nyp1\n      kr = ks + 1\n      if (kr >= nvpz) kr = kr - nvpz\n      kl = ks - 1\n      if (kl < 0) kl = kl + nvpz\n      kr = js + nvpy*kr\n      kl = js + nvpy*kl\n! this segment is used for mpi computers\n      call mpi_irecv(f(1,1,nzp1),nxvy,mreal,kr,noff+4,lgrp,msid,ierr)\n      call mpi_send(f,nxvys,mreal,kl,noff+4,lgrp,ierr)\n      call mpi_wait(msid,istatus,ierr)\n      end subroutine\n"}
{"id": 163, "subroutine": "      subroutine ppnacguard32l(f,scs,scr,nyzp,ndim,kstrt,nvpy,nvpz,nx,  &\n     &nxv,nypmx,nzpmx,idds)\n\n! f(ndim,j,k,l) = real data for grid j,k,l in particle partition.\n! the grid is non-uniform and includes one extra guard cell.\n! scs/scr = scratch arrays for particle partition\n! nyzp(1:2) = number of primary gridpoints in y/z in particle partition\n! ndim = leading dimension of array f\n! kstrt = starting data block number\n! nvpy/nvpz = number of real or virtual processors in y/z\n! nx = system length in x direction\n! nxv = second dimension of f, must be >= nx+1\n! nypmx = maximum size of particle partition in y, including guard cells\n! nzpmx = maximum size of particle partition in z, including guard cells\n! idds = dimensionality of domain decomposition\n! linear interpolation, for distributed data\n! with 2d spatial decomposition\n      implicit none\n      integer, intent(in) :: ndim, kstrt, nvpy, nvpz, nx, nxv\n      integer, intent(in) :: nypmx, nzpmx, idds\n      real, dimension(ndim,nxv,nypmx,nzpmx), intent(inout) :: f\n      real, dimension(ndim,nxv,nzpmx,2), intent(inout) :: scs\n      real, dimension(ndim,nxv,nypmx), intent(inout) :: scr\n      integer, dimension(idds), intent(in) :: nyzp\n! lgrp = current communicator\n! mreal = default datatype for reals\n! local data\n      integer :: i, j, k, js, ks, noff, kr, kl\n      integer :: nx1, nxvz, nxvzs, nxvy, nxvys, nyp1, nzp1\n      integer :: msid, ierr\n      integer, dimension(lstat) :: istatus\n      nx1 = nx + 1\n      nyp1 = nyzp(1) + 1\n      nzp1 = nyzp(2) + 1\n! js/ks = processor co-ordinates in y/z => idproc = js + nvpy*ks\n      ks = (kstrt - 1)/nvpy\n      js = kstrt - nvpy*ks - 1\n      noff = ndim*nypmx*nzpmx\n      nxvz = ndim*nxv*nzpmx\n      nxvy = ndim*nxv*nypmx\n! special case for one processor in y\n      if (nvpy==1) then\n!$omp parallel do private(i,j,k)\n         do k = 1, nzp1\n            do j = 1, nx1\n               do i = 1, ndim\n                  f(i,j,1,k) = f(i,j,1,k) + f(i,j,nyp1,k)\n                  f(i,j,nyp1,k) = 0.0\n               enddo\n            enddo\n         enddo\n!$omp end parallel do\n      else\n! buffer data in y\n!$omp parallel do private(i,j,k)\n         do k = 1, nzp1 \n            do j = 1, nxv\n               do i = 1, ndim\n                  scs(i,j,k,1) = f(i,j,nyp1,k)\n               enddo\n            enddo\n         enddo\n!$omp end parallel do\n! add guard cells in y\n         nxvzs = ndim*nxv*nzp1\n         kr = js + 1\n         if (kr >= nvpy) kr = kr - nvpy\n         kl = js - 1\n         if (kl < 0) kl = kl + nvpy\n         kr = kr + nvpy*ks\n         kl = kl + nvpy*ks\n! this segment is used for mpi computers\n         call mpi_irecv(scs(1,1,1,2),nxvz,mreal,kl,noff+1,lgrp,msid,ierr&\n     &)\n         call mpi_send(scs,nxvzs,mreal,kr,noff+1,lgrp,ierr)\n         call mpi_wait(msid,istatus,ierr)\n! add up the guard cells\n!$omp parallel do private(i,j,k)\n         do k = 1, nzp1\n           do j = 1, nx1\n              do i = 1, ndim\n                  f(i,j,1,k) = f(i,j,1,k) + scs(i,j,k,2)\n                  f(i,j,nyp1,k) = 0.0\n               enddo\n            enddo\n         enddo\n!$omp end parallel do\n      endif\n! special case for one processor in z\n      if (nvpz==1) then\n!$omp parallel do private(i,j,k)\n         do k = 1, nyp1\n            do j = 1, nx1\n               do i = 1, ndim\n                  f(i,j,k,1) = f(i,j,k,1) + f(i,j,k,nzp1)\n                  f(i,j,k,nzp1) = 0.0\n               enddo\n            enddo\n         enddo\n!$omp end parallel do\n         return\n      endif\n! add guard cells in z\n      nxvys = ndim*nxv*nyp1\n      kr = ks + 1\n      if (kr >= nvpz) kr = kr - nvpz\n      kl = ks - 1\n      if (kl < 0) kl = kl + nvpz\n      kr = js + nvpy*kr\n      kl = js + nvpy*kl\n! this segment is used for mpi computers\n      call mpi_irecv(scr,nxvy,mreal,kl,noff+2,lgrp,msid,ierr)\n      call mpi_send(f(1,1,1,nzp1),nxvys,mreal,kr,noff+2,lgrp,ierr)\n      call mpi_wait(msid,istatus,ierr)\n! add up the guard cells\n!$omp parallel do private(i,j,k)\n      do k = 1, nyp1\n         do j = 1, nx1\n            do i = 1, ndim\n               f(i,j,k,1) = f(i,j,k,1) + scr(i,j,k)\n               f(i,j,k,nzp1) = 0.0\n            enddo\n         enddo\n      enddo\n!$omp end parallel do\n      end subroutine\n"}
{"id": 164, "subroutine": "      subroutine pptpos3a(f,g,s,t,nx,ny,nz,kxyp,kyp,kzp,kstrt,nvpy,nxv, &\n     &nyv,kxypd,kypd,kzpd)\n\n! and z to a matrix g, distributed in x and z, that is,\n! g(k+kyp*(m-1),j,l) = f(j+kxyp*(n-1),k,l), where\n! 1 <= j <= kxyp, 1 <= k <= kyp, 1 <= l <= kzp, and\n! 1 <= n <= nx/kxyp, 1 <= m <= ny/kyp\n! and where indices n and m can be distributed across processors.\n\n! synchronously or asynchronously. it uses a minimum of system resources\n! f = complex input array\n! g = complex output array\n! s, t = complex scratch arrays\n! nx/ny/nz = number of points in x/y/z\n! kxyp/kyp/kzp = number of data values per block in x/y/z\n! kstrt = starting data block number\n! nvpy = number of real or virtual processors in y\n! nxv/nyv = first dimension of f/g\n! kypd/kxypd = second dimension of f/g\n! kzpd = third dimension of f and g\n      implicit none\n      integer, intent(in) :: nx, ny, nz, kxyp, kyp, kzp, kstrt, nvpy\n      integer, intent(in) :: nxv, nyv, kxypd, kypd, kzpd\n      complex, dimension(nxv,kypd,kzpd), intent(in) :: f\n      complex, dimension(nyv,kxypd,kzpd), intent(inout) :: g\n      complex, dimension(kxyp*kyp*kzp), intent(inout) :: s, t\n! lgrp = current communicator\n! mcplx = default datatype for complex\n! local data\n      integer :: n, j, k, l, js, ks, kxyps, kyps, kzps, id, joff, koff\n      integer :: ld, jd, kxyzp\n      integer :: ierr, msid, ll\n      integer, dimension(lstat) :: istatus\n! js/ks = processor co-ordinates in y/z => idproc = js + nvpy*ks\n      ks = (kstrt - 1)/nvpy\n      js = kstrt - nvpy*ks - 1\n      kxyps = min(kxyp,max(0,nx-kxyp*js))\n      kyps = min(kyp,max(0,ny-kyp*js))\n      kzps = min(kzp,max(0,nz-kzp*ks))\n      kxyzp = kxyp*kyp*kzp\n! special case for one processor\n      if (nvpy==1) then\n!$omp parallel do private(j,k,l,ll)\n         do ll = 1, kyp*kzp\n            l = (ll - 1)/kyp\n            k = ll - kyp*l\n            l = l + 1\n            do j = 1, kxyp\n               g(k,j,l) = f(j,k,l)\n            enddo\n         enddo\n!$omp end parallel do\n         return\n      endif\n! this segment is used for shared memory computers\n!     do l = 1, nz\n!        do m = 1, min(ny,nvpy)\n!           koff = kyp*(m - 1)\n!           do i = 1, min(nx,nvpy)\n!           joff = kxyp*(i - 1)\n!              do k = 1, min(kyp,max(0,ny-koff))\n!                 do j = 1, min(kxyp,max(0,nx-joff))\n!                    g(k+koff,j+joff,l) = f(j+joff,k+koff,l)\n!                 enddo\n!              enddo\n!           enddo\n!        enddo\n!     enddo\n! this segment is used for mpi computers\n      do n = 1, nvpy\n         id = n - js - 1\n         if (id < 0) id = id + nvpy\n! extract data to send\n         joff = kxyp*id\n         ld = min(kxyp,max(0,nx-joff))\n!$omp parallel do private(j,k,l,ll,koff)\n         do ll = 1, kyps*kzps\n            l = (ll - 1)/kyps\n            k = ll - kyps*l\n            l = l + 1\n            koff = kyps*(l - 1) - 1\n            do j = 1, ld\n               s(j+ld*(k+koff)) = f(j+joff,k,l)\n            enddo\n         enddo\n!$omp end parallel do\n         jd = id + nvpy*ks\n         ld = ld*kyps*kzps\n! post receive\n         call mpi_irecv(t,kxyzp,mcplx,jd,n,lgrp,msid,ierr)\n! send data\n         call mpi_send(s,ld,mcplx,jd,n,lgrp,ierr)\n! receive data\n         call mpi_wait(msid,istatus,ierr)\n! insert data received\n         koff = kyp*id\n         ld = min(kyp,max(0,ny-koff))\n!$omp parallel do private(j,k,l,ll,joff)\n         do ll = 1, ld*kzps\n            l = (ll - 1)/ld\n            k = ll - ld*l\n            l = l + 1\n            joff = ld*(l - 1) - 1\n            do j = 1, kxyps\n               g(k+koff,j,l) = t(j+kxyps*(k+joff))\n            enddo\n         enddo\n!$omp end parallel do\n      enddo\n      end subroutine\n"}
{"id": 165, "subroutine": "      subroutine pptpos3b(g,h,s,t,nx,ny,nz,kxyp,kyzp,kzp,kstrt,nvpy,nvpz&\n     &,nyv,nzv,kxypd,kyzpd,kzpd)\n\n! and z to a matrix h, distributed in x and y, that is,\n! h(l+kzp*(n-1),j,k) = g(k+kyzp*(m-1),j,l), where\n! 1 <= j <= kxyp, 1 <= k <= kyzp, 1 <= l <= kzp, and\n! 1 <= m <= ny/kyzp, 1 <= n <= nz/kzp\n! and where indices n and m can be distributed across processors.\n\n! synchronously or asynchronously. it uses a minimum of system resources\n! g = complex input array\n! h = complex output array\n! s, t = complex scratch arrays\n! nx/ny/nz = number of points in x/y/z\n! kxyp/kyzp/kzp = number of data values per block in x/y/z\n! kstrt = starting data block number\n! nvpy/nvpz = number of real or virtual processors in y/z\n! nyv/nzv = first dimension of g/h\n! kxypd = second dimension of g and h\n! kzpd/kyzpd = third dimension of g/h\n      implicit none\n      integer, intent(in) :: nx, ny, nz, kxyp, kyzp, kzp, kstrt\n      integer, intent(in) :: nvpy, nvpz, nyv, nzv, kxypd, kyzpd, kzpd\n      complex, dimension(nyv,kxypd,kzpd), intent(inout) :: g\n      complex, dimension(nzv,kxypd,kyzpd), intent(inout) :: h\n      complex, dimension(kyzp*kxyp*kzp), intent(inout) :: s, t\n! lgrp = current communicator\n! mcplx = default datatype for complex\n! local data\n      integer :: n, j, k, l, js, ks, kxyps, kyzps, kzps, id, koff, loff\n      integer :: ld, jd, kxyzp, ll\n      integer :: ierr, msid\n      integer, dimension(lstat) :: istatus\n! js/ks = processor co-ordinates in x/z => idproc = js + nvpy*ks\n      ks = (kstrt - 1)/nvpy\n      js = kstrt - nvpy*ks - 1\n      kxyps = min(kxyp,max(0,nx-kxyp*js))\n      kyzps = min(kyzp,max(0,ny-kyzp*ks))\n      kzps = min(kzp,max(0,nz-kzp*ks))\n      kxyzp = kxyp*kyzp*kzp\n! special case for one processor\n      if (nvpz==1) then\n!$omp parallel do private(j,k,l,ll)\n         do ll = 1, kxyp*kzp\n            l = (ll - 1)/kxyp\n            j = ll - kxyp*l\n            l = l + 1\n            do k = 1, kyzp\n               h(l,j,k) = g(k,j,l)\n            enddo\n         enddo\n!$omp end parallel do\n         return\n      endif\n! this segment is used for shared memory computers\n!     do i = 1, min(nz,nvpz)\n!        loff = kzp*(i - 1)\n!        do m = 1, min(ny,nvpz)\n!           koff = kyzp*(m - 1)\n!           do l = 1, min(kzp,max(0,nz-loff))\n!              do j = 1, nx\n!                 do k = 1, min(kyzp,max(0,ny-koff))\n!                    h(l+loff,j,k+koff) = g(k+koff,j,l+loff)\n!                 enddo\n!              enddo\n!           enddo\n!        enddo\n!     enddo\n! this segment is used for mpi computers\n      do n = 1, nvpz\n         id = n - ks - 1\n         if (id < 0) id = id + nvpz\n! extract data to send\n         koff = kyzp*id\n         ld = min(kyzp,max(0,ny-koff))\n!$omp parallel do private(j,k,l,ll,loff)\n         do ll = 1, kxyps*kzps\n            l = (ll - 1)/kxyps\n            j = ll - kxyps*l\n            l = l + 1\n            loff = kxyps*(l - 1) - 1\n            do k = 1, ld\n               s(k+ld*(j+loff)) = g(k+koff,j,l)\n            enddo\n         enddo\n!$omp end parallel do\n         jd = js + nvpy*id\n         ld = ld*kxyps*kzps\n! post receive\n         call mpi_irecv(t,kxyzp,mcplx,jd,n,lgrp,msid,ierr)\n! send data\n         call mpi_send(s,ld,mcplx,jd,n,lgrp,ierr)\n! receive data\n         call mpi_wait(msid,istatus,ierr)\n! insert data received\n         loff = kzp*id\n         ld = min(kzp,max(0,nz-loff))\n!$omp parallel do private(j,k,l,ll,koff)\n         do ll = 1, kxyps*ld\n            l = (ll - 1)/kxyps\n            j = ll - kxyps*l\n            l = l + 1\n            koff = kxyps*(l - 1) - 1\n            do k = 1, kyzps\n               h(l+loff,j,k) = t(k+kyzps*(j+koff))\n            enddo\n         enddo\n!$omp end parallel do\n      enddo\n      end subroutine\n"}
{"id": 166, "subroutine": "      subroutine pppmove32(sbufr,sbufl,rbufr,rbufl,ncll,nclr,mcll,mclr, &\n     &mcls,kstrt,nvpy,nvpz,idimp,nbmax,mx1,myp1,mzp1,mxzyp1,irc)\n\n! for distributed data, with 2d domain decomposition in y/z.\n! tiles are assumed to be arranged in 3d linear memory\n! output: rbufr, rbufl, mcll, mclr\n! sbufl = buffer for particles being sent to lower/back processor\n! sbufr = buffer for particles being sent to upper/forward processor\n! rbufl = buffer for particles being received from lower/back processor\n! rbufr = buffer for particles being received from upper/forward\n! processor\n! ncll = particle number offsets sent to lower/back processor\n! nclr = particle number offsets sent to upper/forward processor\n! mcll = particle number offsets received from lower/back processor\n! mclr = particle number offsets received from upper/forward processor\n! mcls = particle number ofsets received from corner processors\n! kstrt = starting data block number\n! nvpy/nvpz = number of real or virtual processors in y/z\n! idimp = size of phase space = 4 or 5\n! nbmax =  size of buffers for passing particles between processors\n! mx1 = (system length in x direction - 1)/mx + 1\n! myp1 = (partition length in y direction - 1)/my + 1\n! mzp1 = (partition length in z direction - 1)/mz + 1\n! mxzyp1 = mx1*max(myp1,mzp1)\n! irc = maximum overflow, returned only if error occurs, when irc > 0\n      implicit none\n      integer, intent(in) :: kstrt, nvpy, nvpz, idimp, nbmax\n      integer, intent(in) :: mx1, myp1, mzp1, mxzyp1\n      integer, intent(inout) :: irc\n      real, dimension(idimp,nbmax,2), intent(in) :: sbufr, sbufl\n      real, dimension(idimp,nbmax,2), intent(inout) :: rbufr, rbufl\n      integer, dimension(3,mxzyp1,3,2), intent(inout) :: ncll, nclr\n      integer, dimension(3,mxzyp1,3,2), intent(inout) :: mcll, mclr\n      integer, dimension(3,mx1+1,4), intent(inout) :: mcls\n! lgrp = current communicator\n! mint = default datatype for integers\n! mreal = default datatype for reals\n! local data\n      integer :: ierr, js, ks, kl, kr, i, j, k, n, jsl, jsr\n      integer :: m, ll, lr, krr, krl, klr, kll, jsrr, jsrl, jslr, jsll\n      integer :: nr, nl, mr, ml, nbr, nbl\n      integer :: mxyp1, mxzp1, nbsize, ncsize, nsize\n      integer, dimension(8) :: msid\n      integer, dimension(12) :: itg\n      integer, dimension(lstat) :: istatus\n      integer, dimension(1) :: nb, iwork\n      data itg /3,4,5,6,7,8,9,10,11,12,13,14/\n! js/ks = processor co-ordinates in y/z => idproc = js + nvpy*ks\n      ks = (kstrt - 1)/nvpy\n      js = kstrt - nvpy*ks - 1\n      mxyp1 = mx1*myp1\n      mxzp1 = mx1*mzp1\n      nbsize = idimp*nbmax\n      ncsize = 9*mxzyp1\n! copy particle buffers in y:\n! update rbufl(:,1), rbufr(:,1), mcll(:,1), mclr(:,1)\n! special case for one processor\n      if ((nvpy*nvpz)==1) then\n!$omp parallel\n!$omp do private(i,j,k,ll)\n         do ll = 1, 3*mxzp1\n            k = (ll - 1)/mxzp1\n            j = ll - mxzp1*k\n            k = k + 1\n            do i = 1, 3\n               mcll(i,j,k,1) = nclr(i,j,k,1)\n               mclr(i,j,k,1) = ncll(i,j,k,1)\n            enddo\n         enddo\n!$omp end do nowait\n!$omp do private(i,j)\n         do j = 1, nclr(3,mxzp1,3,1)\n            do i = 1, idimp\n               rbufl(i,j,1) = sbufr(i,j,1)\n            enddo\n         enddo\n!$omp end do nowait\n!$omp do private(i,j)\n         do j = 1, ncll(3,mxzp1,3,1)\n            do i = 1, idimp\n               rbufr(i,j,1) = sbufl(i,j,1)\n            enddo\n         enddo\n!$omp end do\n!$omp end parallel\n! get particles from corners\n         n = mx1*(mzp1 - 1)\n! zero out base addresses in prefix scans\n         if (n.gt.0) then\n            nr = nclr(3,n,3,1)\n            nl = ncll(3,n,3,1)\n         else\n            nr = nclr(3,mxzp1,2,1)\n            nl = ncll(3,mxzp1,2,1)\n         endif\n         do j = 1, mx1\n            do i = 1, 3\n               nclr(i,j,2,1) = nclr(i,j,2,1) - nclr(3,mxzp1,1,1)\n               nclr(i,n+j,3,1) = nclr(i,n+j,3,1) - nr\n               ncll(i,j,2,1) = ncll(i,j,2,1) - ncll(3,mxzp1,1,1)\n               ncll(i,n+j,3,1) = ncll(i,n+j,3,1) - nl\n            enddo\n         enddo\n! add new base addresses in prefix scans\n         ml = mcll(3,mxzp1,3,1)\n         mr = mclr(3,mxzp1,3,1)\n         do j = 1, mx1\n            do i = 1, 3\n               mcls(i,j,1) = nclr(i,j,2,1) + ml\n               mcls(i,j,3) = ncll(i,j,2,1) + mr\n            enddo\n         enddo\n         mcls(1,mx1+1,1) = ml\n         mcls(1,mx1+1,3) = mr\n! append corner particles to end of buffers\n         k = nclr(3,mx1,2,1)\n         m = nclr(3,mxzp1,1,1)\n         do j = 1, k\n            do i = 1, idimp\n               rbufl(i,j+ml,1) = sbufr(i,j+m,1)\n            enddo\n         enddo\n         ml = ml + k\n         k = ncll(3,mx1,2,1)\n         m = ncll(3,mxzp1,1,1)\n         do j = 1, k\n            do i = 1, idimp\n               rbufr(i,j+mr,1) = sbufl(i,j+m,1)\n            enddo\n         enddo\n         mr = mr + k\n! add new base addresses in prefix scans\n         do j = 1, mx1\n            do i = 1, 3\n               mcls(i,j,2) = nclr(i,n+j,3,1) + ml\n               mcls(i,j,4) = ncll(i,n+j,3,1) + mr\n            enddo\n         enddo\n         mcls(1,mx1+1,2) = ml\n         mcls(1,mx1+1,4) = mr\n! append more corner particles to end of buffers\n         do j = 1, nclr(3,n+mx1,3,1)\n            do i = 1, idimp\n               rbufl(i,j+ml,1) = sbufr(i,j+nr,1)\n            enddo\n         enddo\n         do j = 1, ncll(3,n+mx1,3,1)\n            do i = 1, idimp\n               rbufr(i,j+mr,1) = sbufl(i,j+nl,1)\n            enddo\n         enddo\n! this segment is used for mpi computers\n      else\n! get particles from below and above\n         kr = js + 1\n         if (kr.ge.nvpy) kr = kr - nvpy\n         kl = js - 1\n         if (kl.lt.0) kl = kl + nvpy\n         kr = kr + nvpy*ks\n         kl = kl + nvpy*ks\n! post receives\n         call mpi_irecv(mcll(1,1,1,1),ncsize,mint,kl,itg(1),lgrp,msid(1)&\n     &,ierr)\n         call mpi_irecv(mclr(1,1,1,1),ncsize,mint,kr,itg(2),lgrp,msid(2)&\n     &,ierr)\n         call mpi_irecv(rbufl(1,1,1),nbsize,mreal,kl,itg(3),lgrp,msid(3)&\n     &,ierr)\n         call mpi_irecv(rbufr(1,1,1),nbsize,mreal,kr,itg(4),lgrp,msid(4)&\n     &,ierr)\n! send particle number offsets\n         call mpi_isend(nclr(1,1,1,1),ncsize,mint,kr,itg(1),lgrp,msid(5)&\n     &,ierr)\n         call mpi_isend(ncll(1,1,1,1),ncsize,mint,kl,itg(2),lgrp,msid(6)&\n     &,ierr)\n         call mpi_wait(msid(1),istatus,ierr)\n         call mpi_wait(msid(2),istatus,ierr)\n! send particles\n         jsr = idimp*nclr(3,mxzp1,3,1)\n         call mpi_isend(sbufr(1,1,1),jsr,mreal,kr,itg(3),lgrp,msid(7),  &\n     &ierr)\n         jsl = idimp*ncll(3,mxzp1,3,1)\n         call mpi_isend(sbufl(1,1,1),jsl,mreal,kl,itg(4),lgrp,msid(8),  &\n     &ierr)\n         call mpi_wait(msid(3),istatus,ierr)\n         call mpi_wait(msid(4),istatus,ierr)\n! make sure sbufr, sbufl, ncll, and nclr have been sent\n         do i = 1, 4\n            call mpi_wait(msid(i+4),istatus,ierr)\n         enddo\n! get particles from corners\n         kr = js + 1\n         if (kr.ge.nvpy) kr = kr - nvpy\n         kl = js - 1\n         if (kl.lt.0) kl = kl + nvpy\n         lr = ks + 1\n         if (lr.ge.nvpz) lr = lr - nvpz\n         ll = ks - 1\n         if (ll.lt.0) ll = ll + nvpz\n         krl = kr + nvpy*ll\n         krr = kr + nvpy*lr\n         kll = kl + nvpy*ll\n         klr = kl + nvpy*lr\n         nsize = 3*mx1\n         n = mx1*(mzp1 - 1)\n! zero out base addresses in prefix scans\n         if (n.gt.0) then\n            nr = nclr(3,n,3,1)\n            nl = ncll(3,n,3,1)\n         else\n            nr = nclr(3,mxzp1,2,1)\n            nl = ncll(3,mxzp1,2,1)\n         endif\n         do j = 1, mx1\n            do i = 1, 3\n               nclr(i,j,2,1) = nclr(i,j,2,1) - nclr(3,mxzp1,1,1)\n               nclr(i,n+j,3,1) = nclr(i,n+j,3,1) - nr\n               ncll(i,j,2,1) = ncll(i,j,2,1) - ncll(3,mxzp1,1,1)\n               ncll(i,n+j,3,1) = ncll(i,n+j,3,1) - nl\n            enddo\n         enddo\n         n = n + 1\n! post receives\n         call mpi_irecv(mcls(1,1,1),nsize,mint,klr,itg(5),lgrp,msid(1), &\n     &ierr)\n         call mpi_irecv(mcls(1,1,2),nsize,mint,kll,itg(6),lgrp,msid(2), &\n     &ierr)\n         call mpi_irecv(mcls(1,1,3),nsize,mint,krr,itg(7),lgrp,msid(3), &\n     &ierr)\n         call mpi_irecv(mcls(1,1,4),nsize,mint,krl,itg(8),lgrp,msid(4), &\n     &ierr)\n! send particle number offsets\n         call mpi_isend(nclr(1,1,2,1),nsize,mint,krl,itg(5),lgrp,msid(5)&\n     &,ierr)\n         call mpi_isend(nclr(1,n,3,1),nsize,mint,krr,itg(6),lgrp,msid(6)&\n     &,ierr)\n         call mpi_isend(ncll(1,1,2,1),nsize,mint,kll,itg(7),lgrp,msid(7)&\n     &,ierr)\n         call mpi_isend(ncll(1,n,3,1),nsize,mint,klr,itg(8),lgrp,msid(8)&\n     &,ierr)\n! make sure particle offsets have been sent to and received from corners\n         do i = 1, 8\n            call mpi_wait(msid(i),istatus,ierr)\n         enddo\n! check for overflow errors\n         ml = mcll(3,mxzp1,3,1)\n         mr = mclr(3,mxzp1,3,1)\n         nbl = nbmax - (ml + (mcls(3,mx1,1) + mcls(3,mx1,2)))\n         nbr = nbmax - (mr + (mcls(2,mx1,3) + mcls(3,mx1,4)))\n         nb(1) = min(-nbl,-nbr)\n         call ppimax(nb,iwork,1)\n         if (nb(1) > 0) then\n            write (2,*) 'corner buffer overflow error = ', nb(1)\n            irc = nb(1)\n            return\n         endif\n         nbl = idimp*nbl\n         nbr = idimp*nbr\n! add new base addresses in prefix scans\n         do j = 1, mx1\n            do i = 1, 3\n               mcls(i,j,1) = mcls(i,j,1) + ml\n               mcls(i,j,3) = mcls(i,j,3) + mr\n            enddo\n         enddo\n         mcls(1,mx1+1,1) = ml\n         mcls(1,mx1+1,3) = mr\n! post first part of particle receives, append to end\n         ml = ml + 1\n         call mpi_irecv(rbufl(1,ml,1),nbl,mreal,klr,itg(9),lgrp,msid(1),&\n     &ierr)\n         mr = mr + 1\n         call mpi_irecv(rbufr(1,mr,1),nbr,mreal,krr,itg(11),lgrp,msid(3)&\n     &,ierr)\n! send first part of particles\n         m = nclr(3,mxzp1,1,1) + 1\n         jsrl = idimp*nclr(3,mx1,2,1)\n         call mpi_isend(sbufr(1,m,1),jsrl,mreal,krl,itg(9),lgrp,msid(5),&\n     &ierr)\n         m = ncll(3,mxzp1,1,1) + 1\n         jsll = idimp*ncll(3,mx1,2,1)\n         call mpi_isend(sbufl(1,m,1),jsll,mreal,kll,itg(11),lgrp,msid(7)&\n     &,ierr)\n         call mpi_wait(msid(1),istatus,ierr)\n         call mpi_get_count(istatus,mreal,m,ierr)\n         nbl = nbl - m\n         m = m/idimp\n         ml = ml + m - 1\n         call mpi_wait(msid(3),istatus,ierr)\n         call mpi_get_count(istatus,mreal,m,ierr)\n         nbr = nbr - idimp*m\n         m = m/idimp\n         mr = mr + m - 1\n! add new base addresses in prefix scans\n         do j = 1, mx1\n            do i = 1, 3\n               mcls(i,j,2) = mcls(i,j,2) + ml\n               mcls(i,j,4) = mcls(i,j,4) + mr\n            enddo\n         enddo\n         mcls(1,mx1+1,2) = ml\n         mcls(1,mx1+1,4) = mr\n! post second part of particle receives, append to end\n         ml = ml + 1\n         call mpi_irecv(rbufl(1,ml,1),nbl,mreal,kll,itg(10),lgrp,msid(2)&\n     &,ierr)\n         mr = mr + 1\n         call mpi_irecv(rbufr(1,mr,1),nbr,mreal,krl,itg(12),lgrp,msid(4)&\n     &,ierr)\n! send second part of particles\n         jsrr = idimp*nclr(3,n+mx1-1,3,1)\n         m = nr + 1\n         call mpi_isend(sbufr(1,m,1),jsrr,mreal,krr,itg(10),lgrp,msid(6)&\n     &,ierr)\n         jslr = idimp*ncll(3,n+mx1-1,3,1)\n         m = nl + 1\n         call mpi_isend(sbufl(1,m,1),jslr,mreal,klr,itg(12),lgrp,msid(8)&\n     &,ierr)\n         call mpi_wait(msid(2),istatus,ierr)\n         call mpi_wait(msid(4),istatus,ierr)\n! make sure sbufr and sbufl have been sent to corners\n         do i = 1, 4\n            call mpi_wait(msid(i+4),istatus,ierr)\n         enddo\n      endif\n! copy particle buffers in z:\n! update rbufl(:,2), rbufr(:,2), mcll(:,2), mclr(:,2)\n! special case for one processor\n      if ((nvpy*nvpz)==1) then\n!$omp parallel\n!$omp do private(i,j,k,ll)\n         do ll = 1, 3*mxyp1\n            k = (ll - 1)/mxyp1\n            j = ll - mxyp1*k\n            k = k + 1\n            do i = 1, 3\n               mcll(i,j,k,2) = nclr(i,j,k,2)\n               mclr(i,j,k,2) = ncll(i,j,k,2)\n            enddo\n         enddo\n!$omp end do nowait\n!$omp do private(i,j)\n         do j = 1, nclr(3,mxyp1,3,2)\n            do i = 1, idimp\n               rbufl(i,j,2) = sbufr(i,j,2)\n            enddo\n         enddo\n!$omp end do nowait\n!$omp do private(i,j)\n         do j = 1, ncll(3,mxyp1,3,2)\n            do i = 1, idimp\n               rbufr(i,j,2) = sbufl(i,j,2)\n            enddo\n         enddo\n!$omp end do\n!$omp end parallel\n! this segment is used for mpi computers\n      else\n! get particles from back and front\n         kr = ks + 1\n         if (kr.ge.nvpz) kr = kr - nvpz\n         kl = ks - 1\n         if (kl.lt.0) kl = kl + nvpz\n         kr = js + nvpy*kr\n         kl = js + nvpy*kl\n! post receives\n         call mpi_irecv(mcll(1,1,1,2),ncsize,mint,kl,itg(1),lgrp,msid(1)&\n     &,ierr)\n         call mpi_irecv(mclr(1,1,1,2),ncsize,mint,kr,itg(2),lgrp,msid(2)&\n     &,ierr)\n         call mpi_irecv(rbufl(1,1,2),nbsize,mreal,kl,itg(3),lgrp,msid(3)&\n     &,ierr)\n         call mpi_irecv(rbufr(1,1,2),nbsize,mreal,kr,itg(4),lgrp,msid(4)&\n     &,ierr)\n! send particle number offsets\n         call mpi_isend(nclr(1,1,1,2),ncsize,mint,kr,itg(1),lgrp,msid(5)&\n     &,ierr)\n         call mpi_isend(ncll(1,1,1,2),ncsize,mint,kl,itg(2),lgrp,msid(6)&\n     &,ierr)\n         call mpi_wait(msid(1),istatus,ierr)\n         call mpi_wait(msid(2),istatus,ierr)\n! send particles\n         jsr = idimp*nclr(3,mxyp1,3,2)\n         call mpi_isend(sbufr(1,1,2),jsr,mreal,kr,itg(3),lgrp,msid(7),  &\n     &ierr)\n         jsl = idimp*ncll(3,mxyp1,3,2)\n         call mpi_isend(sbufl(1,1,2),jsl,mreal,kl,itg(4),lgrp,msid(8),  &\n     &ierr)\n         call mpi_wait(msid(3),istatus,ierr)\n         call mpi_wait(msid(4),istatus,ierr)\n! make sure sbufr, sbufl, ncll, and nclr have been sent\n         do i = 1, 4\n            call mpi_wait(msid(i+4),istatus,ierr)\n         enddo\n      endif\n      end subroutine\n"}
{"id": 167, "subroutine": "      subroutine ppinit2(idproc,nvp)\n      use mpplib3, only: sub => ppinit2\n      implicit none\n      integer, intent(inout) :: idproc, nvp\n      call sub(idproc,nvp)\n      end subroutine\n"}
{"id": 168, "subroutine": "      subroutine pwtimera(icntrl,time,dtime)\n      use mpplib3, only: sub => pwtimera\n      implicit none\n      integer, intent(in) :: icntrl\n      real, intent(inout) :: time\n      double precision, intent(inout) :: dtime\n      call sub(icntrl,time,dtime)\n      end subroutine\n"}
{"id": 169, "subroutine": "      subroutine ppsum(f,g,nxp)\n      use mpplib3, only: sub => ppsum\n      implicit none\n      integer, intent(in) :: nxp\n      real, dimension(nxp), intent(inout) :: f, g\n      call sub(f,g,nxp)\n      end subroutine\n"}
{"id": 170, "subroutine": "      subroutine ppimax(if,ig,nxp)\n      use mpplib3, only: sub => ppimax\n      implicit none\n      integer, intent(in) :: nxp\n      integer, dimension(nxp), intent(inout) :: if, ig\n      call sub(if,ig,nxp)\n      end subroutine\n"}
{"id": 171, "subroutine": "      subroutine ppdmax(f,g,nxp)\n      use mpplib3, only: sub => ppdmax\n      implicit none\n      integer, intent(in) :: nxp\n      double precision, dimension(nxp), intent(inout) :: f, g\n      call sub(f,g,nxp)\n      end subroutine\n"}
{"id": 172, "subroutine": "      subroutine ppncguard32l(f,scs,nyzp,kstrt,nvpy,nvpz,nxv,nypmx,nzpmx&\n     &,idds)\n      use mpplib3, only: sub => ppncguard32l\n      implicit none\n      integer, intent(in) :: kstrt, nvpy, nvpz, nxv, nypmx, nzpmx, idds\n      real, dimension(nxv,nypmx,nzpmx), intent(inout) :: f\n      real, dimension(nxv,nzpmx,2), intent(inout) :: scs\n      integer, dimension(idds), intent(in) :: nyzp\n      call sub(f,scs,nyzp,kstrt,nvpy,nvpz,nxv,nypmx,nzpmx,idds)\n      end subroutine\n"}
{"id": 173, "subroutine": "      subroutine ppnaguard32l(f,scs,scr,nyzp,kstrt,nvpy,nvpz,nx,nxv,    &\n     &nypmx,nzpmx,idds)\n      use mpplib3, only: sub => ppnaguard32l\n      implicit none\n      integer, intent(in) :: kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx\n      integer, intent(in) :: idds\n      real, dimension(nxv,nypmx,nzpmx), intent(inout) :: f\n      real, dimension(nxv,nzpmx,2), intent(inout) :: scs\n      real, dimension(nxv,nypmx), intent(inout) :: scr\n      integer, dimension(idds), intent(in) :: nyzp\n      call sub(f,scs,scr,nyzp,kstrt,nvpy,nvpz,nx,nxv,nypmx,nzpmx,idds)\n      end subroutine\n"}
{"id": 174, "subroutine": "       subroutine ppnacguard32l(f,scs,scr,nyzp,ndim,kstrt,nvpy,nvpz,nx,  &\n     &nxv,nypmx,nzpmx,idds)\n      use mpplib3, only: sub => ppnacguard32l\n      implicit none\n      integer, intent(in) :: ndim, kstrt, nvpy, nvpz, nx, nxv\n      integer, intent(in) :: nypmx, nzpmx, idds\n      real, dimension(ndim,nxv,nypmx,nzpmx), intent(inout) :: f\n      real, dimension(ndim,nxv,nzpmx,2), intent(inout) :: scs\n      real, dimension(ndim,nxv,nypmx), intent(inout) :: scr\n      integer, dimension(idds), intent(in) :: nyzp\n      call sub(f,scs,scr,nyzp,ndim,kstrt,nvpy,nvpz,nx,nxv,nypmx,nzpmx,  &\n     &idds)\n      end subroutine\n"}
{"id": 175, "subroutine": "      subroutine pptpos3a(f,g,s,t,nx,ny,nz,kxyp,kyp,kzp,kstrt,nvpy,nxv, &\n     &nyv,kxypd,kypd,kzpd)\n      use mpplib3, only: sub => pptpos3a\n      implicit none\n      integer, intent(in) :: nx, ny, nz, kxyp, kyp, kzp, kstrt, nvpy\n      integer, intent(in) :: nxv, nyv, kxypd, kypd, kzpd\n      complex, dimension(nxv,kypd,kzpd), intent(in) :: f\n      complex, dimension(nyv,kxypd,kzpd), intent(inout) :: g\n      complex, dimension(kxyp*kyp*kzp), intent(inout) :: s, t\n      call sub(f,g,s,t,nx,ny,nz,kxyp,kyp,kzp,kstrt,nvpy,nxv,nyv,kxypd,  &\n     &kypd,kzpd)\n      end subroutine\n"}
{"id": 176, "subroutine": "      subroutine pptpos3b(g,h,s,t,nx,ny,nz,kxyp,kyzp,kzp,kstrt,nvpy,nvpz&\n     &,nyv,nzv,kxypd,kyzpd,kzpd)\n      use mpplib3, only: sub => pptpos3b\n      implicit none\n      integer, intent(in) :: nx, ny, nz, kxyp, kyzp, kzp, kstrt\n      integer, intent(in) :: nvpy, nvpz, nyv, nzv, kxypd, kyzpd, kzpd\n      complex, dimension(nyv,kxypd,kzpd), intent(inout) :: g\n      complex, dimension(nzv,kxypd,kyzpd), intent(inout) :: h\n      complex, dimension(kyzp*kxyp*kzp), intent(inout) :: s, t\n      call sub(g,h,s,t,nx,ny,nz,kxyp,kyzp,kzp,kstrt,nvpy,nvpz,nyv,nzv,  &\n     &kxypd,kyzpd,kzpd)\n      end subroutine\n"}
{"id": 177, "subroutine": "      subroutine ppntpos3b(g,h,s,t,nx,ny,nz,kxyp,kyzp,kzp,kstrt,nvpy,   &\n     &nvpz,ndim,nyv,nzv,kxypd,kyzpd,kzpd)\n      use mpplib3, only: sub => ppntpos3b\n      implicit none\n      integer, intent(in) :: nx, ny, nz, kxyp, kyzp, kzp, kstrt, nvpy\n      integer, intent(in) :: nvpz, ndim, nyv, nzv, kxypd, kyzpd, kzpd\n      complex, dimension(ndim,nyv,kxypd,kzpd), intent(inout) :: g\n      complex, dimension(ndim,nzv,kxypd,kyzpd), intent(inout) :: h\n      complex, dimension(ndim,kyzp*kxyp*kzp), intent(inout) :: s, t\n      call sub(g,h,s,t,nx,ny,nz,kxyp,kyzp,kzp,kstrt,nvpy,nvpz,ndim,nyv, &\n     &nzv,kxypd,kyzpd,kzpd)\n      end subroutine\n"}
{"id": 178, "subroutine": "      subroutine pppmove32(sbufr,sbufl,rbufr,rbufl,ncll,nclr,mcll,mclr, &\n     &mcls,kstrt,nvpy,nvpz,idimp,nbmax,mx1,myp1,mzp1,mxzyp1,irc)\n      use mpplib3, only: sub => pppmove32\n      implicit none\n      integer, intent(in) :: kstrt, nvpy, nvpz, idimp, nbmax\n      integer, intent(in) :: mx1, myp1, mzp1, mxzyp1\n      integer, intent(inout) :: irc\n      real, dimension(idimp,nbmax,2), intent(in) :: sbufr, sbufl\n      real, dimension(idimp,nbmax,2), intent(inout) :: rbufr, rbufl\n      integer, dimension(3,mxzyp1,3,2), intent(inout) :: ncll, nclr\n      integer, dimension(3,mxzyp1,3,2), intent(inout) :: mcll, mclr\n      integer, dimension(3,mx1+1,4), intent(inout) :: mcls\n      call sub(sbufr,sbufl,rbufr,rbufl,ncll,nclr,mcll,mclr,mcls,kstrt,  &\n     &nvpy,nvpz,idimp,nbmax,mx1,myp1,mzp1,mxzyp1,irc)\n      end subroutine\n"}
{"id": 179, "subroutine": "  subroutine init_vtpr(ncomp,comp_string,nphases,&\n       kij_ref,alpha_ref)\n    use thermopack_constants, only: clen\n    use volume_shift, only: initvolumeshift\n    implicit none\n    integer, intent(in) :: ncomp !< number of components\n    character(len=*), intent(in) :: comp_string    !< string defining components. comma or white-space separated.\n    integer, intent(in) :: nphases !< number of phases\n    character(len=*), optional, intent(in) :: kij_ref, alpha_ref !< data set numbers\n    ! locals\n    character(len=clen) :: eos    !< string defining equation of state\n    character(len=clen) :: mixing !< string defining mixing rules\n    character(len=clen) :: alpha  !< string defining alpha correlation\n    integer :: ic, volumeshiftid, ncbeos\n    real :: b_exponent !< inverse exponent (1/s) in mixing of covolume (s>1.0)\n    type(thermo_model), pointer :: act_mod_ptr\n    act_mod_ptr => get_active_thermo_model()\n\n    eos = 'pr'\n    mixing = 'vtpr'\n    alpha = 'twu'\n    b_exponent = 4.0/3.0\n    !\n    ! initialize thermopack\n    call init_thermo(eos,mixing,alpha,comp_string,nphases,&\n       kij_ref=kij_ref,alpha_ref=alpha_ref,b_exponent=b_exponent)\n\n    ! enable volume-shift\n    volumeshiftid = initvolumeshift(ncomp,act_mod_ptr%comps,'peneloux','pr')\n    ncbeos = size(act_mod_ptr%eos)\n    do ic=1,ncbeos\n      act_mod_ptr%eos(ic)%p_eos%volumeshiftid = volumeshiftid\n    enddo\n\n    print *, 'warning! should add vtpr specific unifac parameterters...'\n    print *, 'see schmid 2014 (10.1021/ie404118f) or later.'\n  end subroutine init_vtpr\n"}
{"id": 180, "subroutine": "subroutine f_memcpy_i0(dest,src,n)\n  implicit none\n  integer, intent(in) :: n !<nelems\n  integer(f_integer) :: dest !<destination buffer address\n  integer(f_integer) :: src !<source buffer address\n  !local variables\n  integer(f_long) :: ns,nd\n  ns=n*kind(src)\n  nd=n*kind(dest)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_i0\n"}
{"id": 181, "subroutine": "subroutine f_memcpy_i1(dest,src)\n  implicit none\n  integer(f_integer), dimension(:), intent(inout) :: dest !<destination buffer\n  integer(f_integer), dimension(:), intent(in) :: src !<source buffer \n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=f_sizeof(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_i1\n"}
{"id": 182, "subroutine": "subroutine f_memcpy_c1i1(dest,src)\n  implicit none\n  integer(f_integer), dimension(:), intent(inout) :: dest !<destination buffer\n  character, dimension(:), intent(in) :: src !<source buffer \n  !local variables\n  integer(f_long) :: ns,nd\n  external :: f_atoi\n  nd=f_sizeof(dest)\n  ns=f_sizeof(len(src),src)\n  !include 'f_memcpy-base-inc.f90'\n  if (nd < ns) then\n     call f_err_throw('error in f_memcpy; the size of the source ('//ns//&\n          ') and of the destination buffer ('//nd//&\n          ') are not compatible',err_id=err_invalid_copy)\n     return\n  end if\n  if (ns <=0) return\n  call f_atoi(ns,src,dest)\nend subroutine f_memcpy_c1i1\n"}
{"id": 183, "subroutine": "subroutine f_memcpy_d1(dest,src)\n  implicit none\n  double precision, dimension(:), intent(inout) :: dest !<destination buffer\n  double precision, dimension(:), intent(in) :: src !<source buffer \n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=f_sizeof(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_d1\n"}
{"id": 184, "subroutine": "subroutine f_memcpy_d2(dest,src)\n  implicit none\n  double precision, dimension(:,:), intent(inout) :: dest !<destination buffer\n  double precision, dimension(:,:), intent(in) :: src !<source buffer \n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=f_sizeof(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_d2\n"}
{"id": 185, "subroutine": "subroutine f_memcpy_d6d3(dest,src)\n  implicit none\n  real(f_double), dimension(:,:,:), intent(inout) :: dest !<destination buffer\n  real(f_double), dimension(:,:,:,:,:,:), intent(in) :: src !<source buffer \n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=f_sizeof(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_d6d3\n"}
{"id": 186, "subroutine": "subroutine f_memcpy_r0r1(dest,src,n)\n  implicit none\n  integer, intent(in) :: n !<nelems\n  real(f_simple), dimension(:), intent(inout) :: dest !<destination buffer address\n  real(f_simple) :: src !<source buffer address\n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=n*kind(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_r0r1\n"}
{"id": 187, "subroutine": "subroutine f_memcpy_d1d0(dest,src,n)\n  implicit none\n  integer, intent(in) :: n !<nelems\n  double precision :: dest !<destination buffer address\n  double precision, dimension(:), intent(in) :: src !<source buffer address\n  !local variables\n  integer(f_long) :: ns,nd\n  ns=n*kind(src) \n  nd=f_sizeof(src) !inverted \n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_d1d0\n"}
{"id": 188, "subroutine": "subroutine f_memcpy_i0i1(dest,src,n)\n  implicit none\n  integer, intent(in) :: n !<nelems\n  integer(f_integer), dimension(:), intent(inout) :: dest !<destination buffer address\n  integer(f_integer) :: src !<source buffer address\n  !local variables\n  integer(f_long) :: ns,nd\n  nd=f_sizeof(dest)\n  ns=n*kind(src)\n  include 'f_memcpy-base-inc.f90'\nend subroutine f_memcpy_i0i1\n"}
{"id": 189, "subroutine": "    subroutine ngx_link_func_init_cycle(cyc) bind(c)\n        type(ngx_link_func_cycle_t), intent(in) :: cyc\n\n        call ngx_link_func_cyc_log_info(cyc, 'starting the web app ...' // c_null_char)\n        is_service_on = .true.\n    end subroutine ngx_link_func_init_cycle\n"}
{"id": 190, "subroutine": "    subroutine ngx_link_func_exit_cycle(cyc) bind(c)\n        type(ngx_link_func_cycle_t), intent(in) :: cyc\n\n        call ngx_link_func_cyc_log_info(cyc, 'shutting down the web app ...' // c_null_char)\n        is_service_on = .false.\n    end subroutine ngx_link_func_exit_cycle\n"}
{"id": 191, "subroutine": "    subroutine ngx_post(ctx) bind(c)\n        type(ngx_link_func_ctx_t), intent(in) :: ctx\n        character(len=:), allocatable         :: req_body\n        character(len=:), allocatable         :: response\n        character(len=256), allocatable       :: params(:)\n        character(len=256)                    :: pair(2)\n        integer                               :: nparams\n        integer                               :: i\n\n        allocate (character(len=ctx%req_body_len) :: req_body)\n        call c_f_str_ptr(ctx%req_body, req_body)\n\n        nparams = 1 + count_sub_string(req_body, '&')\n        allocate (params(nparams))\n        call split(req_body, params, '&')\n\n        response = 'post parameters:' // new_line('a')\n\n        do i = 1, nparams\n            call split(params(i), pair, '=')\n            response = response // trim(pair(1)) // ': ' // trim(pair(2)) // new_line('a')\n        end do\n\n        call ngx_link_func_write_resp(ctx, &\n                                      int(200, kind=8), &\n                                      '200 ok' // c_null_char, &\n                                      'text/html' // c_null_char, &\n                                      response // c_null_char, &\n                                      int(len(response), kind=8))\n\n        deallocate (params)\n    end subroutine ngx_post\n"}
{"id": 192, "subroutine": "    subroutine split(str, array, del)\n        !! splits a string by a given delimiter into an array of strings.\n        character(len=*), intent(in)    :: str\n        character(len=*), intent(inout) :: array(:)\n        character(len=*), intent(in)    :: del\n        integer                         :: n, pos1, pos2\n\n        pos1 = 1\n        n    = 0\n\n        do\n            pos2 = index(str(pos1:), del)\n\n            if (pos2 == 0) then\n                n = n + 1\n                if (n > size(array)) exit\n                array(n) = str(pos1:)\n                exit\n            end if\n\n            n = n + 1\n            array(n) = str(pos1:pos1 + pos2 - 2)\n            pos1 = pos1 + pos2\n        end do\n    end subroutine split\n"}
{"id": 193, "subroutine": "    subroutine init(self)\n        class(fic_case2_pmmf),  intent(inout)  :: self\n\n        ! set function name\n        call self%set_name(\"flow in cylinder - case2\")\n\n    end subroutine init\n"}
{"id": 194, "subroutine": " subroutine g(r)\n   real, dimension(2), intent(out) :: r\n end subroutine\n"}
{"id": 195, "subroutine": "            subroutine nonlinear_optimization(n,qref,f0,point,poids,    &\n     &f_min,f_max)\n              integer(kind=4), intent(in) :: n\n              real(kind=8), intent(in) :: qref\n              real(kind=8), intent(in) :: f0\n              real(kind=8), intent(out) :: point(1:n)\n              real(kind=8), intent(out) :: poids(1:n)\n              real(kind=8), intent(in) :: f_min\n              real(kind=8), intent(in) :: f_max\n            end subroutine nonlinear_optimization\n"}
{"id": 196, "subroutine": "  subroutine s\n    if (x(2) .eq. 2.5) call abort ()\n  contains\n    function x(n, m)\n      integer, optional :: m\n      if (present(m)) then\n        x = real(n)**m\n      else\n        x = 0.0\n      end if\n    end function\n  end subroutine s\n"}
{"id": 197, "subroutine": "  subroutine app__main()\n    implicit none\n    integer :: it, it_last\n    real(8) :: etime, etime0\n\n    ! initialization\n    call load_config()\n    call init()\n\n    ! current clock\n    etime0 = get_etime()\n\n    ! main loop\n    do it = it0+1, max_it\n       ! update\n       call particle__solv(gp, up, uf, cumcnt, nxs, nxe)\n       call field__fdtd_i(uf, up, gp, cumcnt, nxs, nxe, &\n            & bc__dfield, bc__curre, bc__phi)\n       call bc__particle_x(gp, np2)\n       call bc__particle_y(gp, np2)\n       call sort__bucket(up, gp, cumcnt, np2, nxs, nxe)\n\n       ! output entire particles\n       if ( mod(it, intvl_ptcl) == 0 ) then\n          call io__ptcl(up, uf, np2, it)\n       end if\n\n       ! ouput tracer particles\n       if ( mod(it, intvl_orb) == 0 ) then\n          call io__orb(up, uf, np2, it)\n       end if\n\n       ! output moments and electromagnetic fields\n       if ( mod(it, intvl_mom) == 0 ) then\n          call mom_calc__accl(gp, up, uf, cumcnt, nxs, nxe)\n          call mom_calc__nvt(mom, gp, np2)\n          call bc__mom(mom)\n          call io__mom(mom, uf, it)\n          call energy_history(up, uf, np2, it)\n       endif\n\n       ! check elapsed time\n       etime = get_etime() - etime0\n       if ( etime >= max_elapsed ) then\n          ! save snapshoft for restart\n          write(restart_file, '(i7.7, \"_restart\")') it\n          call save_restart(up, uf, np2, nxs, nxe, it, restart_file)\n\n          if ( nrank == nroot ) then\n             write(0,'(\"*** elapsed time limit exceeded \")')\n             write(0,'(\"*** a snapshot \", a, \" has been saved\")') &\n                  & trim(restart_file)\n          end if\n\n          call finalize()\n          stop\n       endif\n\n       if( verbose >= 1 .and. nrank == nroot ) then\n          write(*,'(\"*** time step: \", i7, \" completed in \", e10.2, \" sec.\")') &\n               & it, etime\n       end if\n    enddo\n\n    ! save final state\n    it = max_it + 1\n    write(restart_file, '(i7.7, \"_restart\")') it\n    call save_restart(up, uf, np2, nxs, nxe, it, restart_file)\n    call finalize()\n\n  end subroutine app__main\n"}
{"id": 198, "subroutine": "  subroutine load_config()\n    implicit none\n\n    logical :: status, found\n    integer :: arg_count, npp\n    character(len=:), allocatable :: filename\n\n    type(json_core) :: json\n    type(json_file) :: file\n    type(json_value), pointer :: root, p\n\n    ! check ndim\n    if( ndim /= 6 ) then\n       write(0,*) 'error: ndim must be 6'\n       stop\n    end if\n\n    !\n    ! process command line to find a configuration file\n    !\n    arg_count = command_argument_count()\n\n    if( arg_count == 0 ) then\n       config = config_default\n    else\n       ! only the first argument is relevant\n       call get_command_argument(1, config)\n    end if\n\n    ! check init file\n    inquire(file=trim(config), exist=status)\n\n    if( .not. status ) then\n       write(0, '(\"error: \", a, \" does not exists\")') trim(config)\n       stop\n    end if\n\n    ! try loading init file\n    call json%initialize()\n    call file%initialize()\n    call file%load(trim(config))\n\n    if( file%failed() ) then\n       write(0, '(\"error: failed to load \", a)') trim(config)\n       stop\n    end if\n\n    ! read \"config\" section\n    call file%get(root)\n    call json%get(root, 'config', p)\n\n    call json%get(p, 'verbose', verbose)\n    call json%get(p, 'datadir', datadir)\n    call json%get(p, 'max_elapsed', max_elapsed)\n    call json%get(p, 'max_it', max_it)\n    call json%get(p, 'intvl_ptcl', intvl_ptcl)\n    call json%get(p, 'intvl_mom', intvl_mom)\n    call json%get(p, 'intvl_orb', intvl_orb)\n\n    ! make sure this is a directory\n    datadir = trim(datadir) // '/'\n\n    ! restart file\n    call json%get(p, 'restart_file', filename, found)\n\n    if ( found .and. filename /= '' ) then\n       restart = .true.\n       restart_file = filename\n    endif\n\n    ! read \"parameter\" section and initialize\n    call json%get(root, 'parameter', p)\n    call json%get(p, 'num_process', num_process)\n    call json%get(p, 'n_ppc', n_ppc)\n    call json%get(p, 'n_x', n_x)\n    call json%get(p, 'n_y', n_y)\n    call json%get(p, 'mass_ratio', mass_ratio)\n    call json%get(p, 'sigma_e', sigma_e)\n    call json%get(p, 'omega_pe', omega_pe)\n    call json%get(p, 'v_the', v_the)\n    call json%get(p, 'v_thi', v_thi)\n    call json%get(p, 't_ani', t_ani)\n\n    nproc = num_process\n    nx    = n_x\n    ny    = n_y\n    np    = n_ppc * nx * 5\n    n0    = n_ppc\n    nxgs  = 2\n    nxge  = nxgs + nx - 1\n    nygs  = 2\n    nyge  = nygs + ny - 1\n    nxs   = nxgs\n    nxe   = nxge\n\n    call json%serialize(root, config_string)\n    call json%destroy()\n    call file%destroy()\n\n  end subroutine load_config\n"}
{"id": 199, "subroutine": "  subroutine init()\n    implicit none\n    integer :: n, isp, i, j, ndim_in\n    real(8) :: wpe, wpi, wge, wgi, vte, vti\n\n    ! mpi\n    call mpi_set__init(nygs, nyge, nproc)\n\n    ! random number\n    call init_random_seed()\n\n    ! allocate memory and initialize everything by zero\n    allocate(np2(nys:nye,nsp))\n    allocate(cumcnt(nxgs:nxge+1,nys:nye,nsp))\n    allocate(uf(6,nxgs-2:nxge+2,nys-2:nye+2))\n    allocate(up(ndim,np,nys:nye,nsp))\n    allocate(gp(ndim,np,nys:nye,nsp))\n    allocate(mom(1:7,nxgs-1:nxge+1,nys-1:nye+1,1:nsp))\n    np2    = 0\n    cumcnt = 0\n    uf     = 0\n    up     = 0\n    gp     = 0\n    mom    = 0\n\n    ! set physical parameters\n    delt = cfl*delx/c\n    wpe  = omega_pe\n    wge  = omega_pe * sqrt(sigma_e)\n    wpi  = wpe / sqrt(mass_ratio)\n    wgi  = wge / mass_ratio\n    vte  = v_the\n    vti  = v_thi\n    r(1) = mass_ratio\n    r(2) = 1.0d0\n    q(1) =+sqrt(r(1) / (4*pi*n0)) * wpi\n    q(2) =-sqrt(r(2) / (4*pi*n0)) * wpe\n    b0   = r(1)*c / q(1) * wgi\n\n    ! number of particles\n    np2(nys:nye,1:nsp) = n0*(nxge-nxgs+1)\n    if ( nrank == nroot ) then\n       if ( n0*(nxge-nxgs+1) > np ) then\n          write(0,*) 'error: too large number of particles'\n          stop\n       endif\n    endif\n\n    ! preparation of sort\n    do isp = 1, nsp\n       !$omp parallel do private(i,j)\n       do j = nys, nye\n          cumcnt(nxgs,j,isp) = 0\n          do i = nxgs+1, nxge+1\n             cumcnt(i,j,isp) = cumcnt(i-1,j,isp) + n0\n          enddo\n          if ( cumcnt(nxge+1,j,isp) /= np2(j,isp) ) then\n             write(0,*) 'error: invalid values encounterd for cumcnt'\n             stop\n          endif\n       enddo\n       !$omp end parallel do\n    enddo\n\n    ! initialize modules\n    call bc__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye, &\n         & nup, ndown, mnpi, mnpr, ncomw, nerr, nstat, delx, delt, c)\n    call particle__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye, &\n         & delx, delt, c, q, r)\n    call field__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye, &\n         & mnpr, ncomw, opsum, nerr, delx, delt, c, q, r, gfac)\n    call sort__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye)\n    call io__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye, &\n         & nproc, nrank, delx, delt, c, q, r, datadir)\n    call mom_calc__init( &\n         & ndim, np, nsp, nxgs, nxge, nygs, nyge, nys, nye, &\n         & delx, delt, c, q, r)\n\n    if ( restart ) then\n       ! restart\n       call io__input(gp, uf, np2, nxs, nxe, it0, restart_file)\n       call sort__bucket(up, gp, cumcnt, np2, nxs, nxe)\n    else\n       ! output parameters and set initial condition\n       call save_param(n0, wpe, wpi, wge, wgi, vti, vte, param)\n       call set_initial_condition()\n       it0 = 0\n       call energy_history(up, uf, np2, it0)\n    endif\n\n    ! copy\n    gp = up\n\n  end subroutine init\n"}
{"id": 200, "subroutine": "  subroutine finalize()\n    implicit none\n\n    call io__finalize()\n    call mpi_finalize(mpierr)\n\n  end subroutine finalize\n"}
{"id": 201, "subroutine": "  subroutine set_initial_condition()\n    implicit none\n    integer :: i, j, ii, isp\n    real(8) :: v1, gam1, gamp, sd(nsp)\n\n    !\n    ! electromagnetic field\n    !\n    !$omp parallel do private(i,j)\n    do j=nys-2,nye+2\n       do i=nxgs-2,nxge+2\n          uf(1,i,j) = 0.0d0\n          uf(2,i,j) = 0.0d0\n          uf(3,i,j) = b0\n          uf(4,i,j) = 0.0d0\n          uf(5,i,j) = 0.0d0\n          uf(6,i,j) = 0.0d0\n       enddo\n    enddo\n    !$omp end parallel do\n\n    !\n    ! particle position\n    !\n    isp = 1\n    !$omp parallel do private(ii,j)\n    do j=nys,nye\n       do ii=1,np2(j,isp)\n          up(1,ii,j,1) = (nxgs + (nxge-nxgs+1)*(ii - 0.5d0)/np2(j,isp)) * delx\n          up(2,ii,j,1) = (j + uniform_rand()) * delx\n          up(1,ii,j,2) = up(1,ii,j,1)\n          up(2,ii,j,2) = up(2,ii,j,1)\n       enddo\n    enddo\n    !$omp end parallel do\n\n    !\n    ! particle velocity\n    !\n    sd(1) = v_thi\n    sd(2) = v_the\n    do isp=1,nsp\n       !$omp parallel do private(ii,j,v1,gam1,gamp)\n       do j=nys,nye\n          do ii=1,np2(j,isp)\n             ! maxwellian in fluid rest frame\n             up(3,ii,j,isp) = sd(isp) * normal_rand()\n             up(4,ii,j,isp) = sd(isp) * normal_rand()\n             up(5,ii,j,isp) = t_ani * sd(isp) * normal_rand()\n          enddo\n       enddo\n       !$omp end parallel do\n    enddo\n\n    ! set particle ids\n    call set_particle_ids()\n\n  end subroutine set_initial_condition\n"}
{"id": 202, "subroutine": "  subroutine set_particle_ids()\n    implicit none\n    integer :: isp, i, j\n\n    integer(8) :: gcumsum(nproc+1,nsp), lcumsum(nys:nye+1,nsp), pid\n\n    if( ndim /= 6 ) then\n       return\n    end if\n\n    ! calculate the first particle ids\n    call get_global_cumsum(np2, gcumsum)\n\n    do isp = 1, nsp\n       lcumsum(nys,isp) = gcumsum(nrank+1,isp)\n       do j = nys, nye\n          lcumsum(j+1,isp) = lcumsum(j,isp) + np2(j,isp)\n       end do\n    end do\n\n    ! unique id as 64bit integer (negative by default)\n    do isp = 1, nsp\n       !$omp parallel do private(i,j,pid)\n       do j = nys, nye\n          do i = 1, np2(j,isp)\n             pid = lcumsum(j,isp) + i\n             up(6,i,j,isp) = transfer(-pid, 1.0_8)\n          end do\n       end do\n       !$omp end parallel do\n    end do\n\n  end subroutine set_particle_ids\n"}
{"id": 203, "subroutine": "  subroutine energy_history(up, uf, np2, it)\n    implicit none\n    integer, intent(in) :: it\n    integer, intent(in) :: np2(nys:nye,nsp)\n    real(8), intent(in) :: up(ndim,np,nys:nye,nsp)\n    real(8), intent(in) :: uf(6,nxgs-2:nxge+2,nys-2:nye+2)\n\n    integer :: i, j, ii, isp, unit\n    real(8) :: vene(nsp)\n    real(8) :: efield, bfield, gam, u2\n    real(8) :: energy_l(nsp+3), energy_g(nsp+3)\n\n    ! open file\n    if( nrank == 0 ) then\n       if( it == 0 ) then\n          open(newunit=unit, file=trim(datadir) // trim(ehist), &\n               & status='replace')\n       else\n          open(newunit=unit, file=trim(datadir) // trim(ehist), &\n               & status='old', position='append')\n       end if\n    endif\n\n    ! initialize\n    vene(1:nsp) = 0\n    efield = 0\n    bfield = 0\n\n    do isp=1,nsp\n!$omp parallel do private(ii,j) reduction(+:vene)\n       do j=nys,nye\n       do ii=1,np2(j,isp)\n          u2 =  up(3,ii,j,isp)*up(3,ii,j,isp) &\n               +up(4,ii,j,isp)*up(4,ii,j,isp) &\n               +up(5,ii,j,isp)*up(5,ii,j,isp)\n          gam = sqrt(1+u2/(c*c))\n          vene(isp) = vene(isp)+r(isp)*(gam-1)\n       enddo\n       enddo\n!$omp end parallel do\n    enddo\n\n!$omp parallel do private(i,j) reduction(+:bfield,efield)\n    do j=nys,nye\n    do i=nxgs,nxge\n       bfield = bfield+uf(1,i,j)*uf(1,i,j)+uf(2,i,j)*uf(2,i,j)+uf(3,i,j)*uf(3,i,j)\n       efield = efield+uf(4,i,j)*uf(4,i,j)+uf(5,i,j)*uf(5,i,j)+uf(6,i,j)*uf(6,i,j)\n    enddo\n    enddo\n!$omp end parallel do\n\n    do isp = 1, nsp\n       energy_l(isp) = vene(isp)\n    end do\n    energy_l(nsp+1) = efield / (8*pi)\n    energy_l(nsp+2) = bfield / (8*pi)\n    call mpi_reduce(energy_l, energy_g, nsp+2, mnpr, opsum, 0, ncomw, nerr)\n\n    if( nrank == 0 ) then\n       ! time, particle1, particle2, efield, bfield, total\n       energy_g(5) = sum(energy_g(1:4))\n       write(unit, fmt='(f8.2, 5(1x, e12.5))') it*delt, &\n            & energy_g(1), energy_g(2), energy_g(3), energy_g(4), energy_g(5)\n       close(unit)\n    endif\n\n  end subroutine energy_history\n"}
{"id": 204, "subroutine": "  subroutine save_restart(up, uf, np2, nxs, nxe, it, restart_file)\n    implicit none\n    integer, intent(in)          :: np2(nys:nye,nsp), nxs, nxe\n    integer, intent(in)          :: it\n    real(8), intent(in)          :: up(ndim,np,nys:nye,nsp)\n    real(8), intent(in)          :: uf(6,nxgs-2:nxge+2,nys-2:nye+2)\n    character(len=*), intent(in) :: restart_file\n\n    logical :: found\n    type(json_core) :: json\n    type(json_file) :: file\n    type(json_value), pointer :: root, p\n\n    call json%initialize()\n    call file%initialize()\n    call file%deserialize(config_string)\n    call file%get(root)\n    call json%get(root, 'config', p)\n    call json%update(p, 'restart_file', trim(restart_file), found)\n\n    ! write data to the disk\n    call io__output(up, uf, np2, nxs, nxe, it, trim(restart_file))\n\n    if ( nrank == nroot ) then\n       call json%print(root, config)\n    end if\n\n    call json%destroy()\n    call file%destroy()\n\n  end subroutine save_restart\n"}
{"id": 205, "subroutine": "  subroutine save_param(n0, wpe, wpi, wge, wgi, vti, vte, filename)\n    implicit none\n    integer, intent(in)          :: n0\n    real(8), intent(in)          :: wpe, wpi, wge, wgi, vti, vte\n    character(len=*), intent(in) :: filename\n\n    character(len=256) :: jsonfile, datafile\n    integer(int64) :: disp\n    integer :: fh\n\n    type(json_core) :: json\n    type(json_file) :: file\n    type(json_value), pointer :: root, p\n\n    ! save deafult parameters\n    call io__param(n0, wpe, wpi, wge, wgi, vti, vte, filename)\n\n    ! save additional parameters\n    datafile = trim(datadir) // trim(filename) // '.raw'\n    jsonfile = trim(datadir) // trim(filename) // '.json'\n\n    ! open json file\n    call file%initialize()\n    call json%initialize()\n    call file%load(jsonfile)\n    call file%get(root)\n\n    ! open data file\n    call mpiio_open_file(datafile, fh, disp, 'a')\n\n    ! put attributes\n    call json%get(root, 'attribute', p)\n\n    ! write json and close\n    if( nrank == 0 ) then\n       call json%print(root, jsonfile)\n    end if\n    call json%destroy()\n\n    ! close data file\n    call mpiio_close_file(fh)\n\n  end subroutine save_param\n"}
{"id": 206, "subroutine": "  subroutine get_global_cumsum(np2, cumsum)\n    implicit none\n    integer, intent(in)       :: np2(nys:nye,nsp)\n    integer(8), intent(inout) :: cumsum(nproc+1,nsp)\n\n    integer :: i, isp, mpierr\n    integer(8) :: lcount(nsp), gcount(nsp, nproc)\n\n    ! get number of particles for each proces\n    lcount(1:nsp) = sum(np2(nys:nye,1:nsp), dim=1)\n    call mpi_allgather(lcount, nsp, mpi_integer8, gcount, nsp, mpi_integer8, &\n         & mpi_comm_world, mpierr)\n\n    ! calculate cumulative sum\n    do isp = 1, nsp\n       cumsum(1,isp) = 0\n       do i = 1, nproc\n          cumsum(i+1,isp) = cumsum(i,isp) + gcount(isp,i)\n       end do\n    end do\n\n  end subroutine get_global_cumsum\n"}
{"id": 207, "subroutine": "  subroutine set_liq_vap_discr_method(liq_vap_discr_method)\n    ! method information\n    integer, intent(in) :: liq_vap_discr_method !< method to discriminate between liquid and vapor in case of an undefined single phase.\n    type(thermo_model), pointer :: act_mod_ptr\n    act_mod_ptr => get_active_thermo_model()\n\n    ! method for discriminating between liquid/vapor when poorly defined\n    act_mod_ptr%liq_vap_discr_method = liq_vap_discr_method\n  end subroutine set_liq_vap_discr_method\n"}
{"id": 208, "subroutine": "  subroutine init_volume_translation(volume_trans_model, param_ref)\n    use volume_shift, only: initvolumeshift\n    character(len=*), intent(in) :: volume_trans_model   !< string model for volume translation\n    character(len=*), intent(in) :: param_ref !< string defining parameter set\n    !\n    type(thermo_model), pointer :: act_mod_ptr\n    integer :: i\n    act_mod_ptr => get_active_thermo_model()\n\n    act_mod_ptr%eos(1)%p_eos%volumeshiftid = &\n         initvolumeshift(nce, act_mod_ptr%comps, &\n         volume_trans_model, act_mod_ptr%eos(1)%p_eos%eosid)\n\n    ! distribute volumeshiftid\n    do i=2,size(act_mod_ptr%eos)\n      act_mod_ptr%eos(i)%p_eos%volumeshiftid = &\n           act_mod_ptr%eos(1)%p_eos%volumeshiftid\n    enddo\n  end subroutine init_volume_translation\n"}
{"id": 209, "subroutine": "  subroutine init_thermo(eos,mixing,alpha,comp_string,nphases,&\n       liq_vap_discr_method_in,csp_eos,csp_ref_comp,kij_ref,alpha_ref,&\n       saft_ref,b_exponent,trendeosforcp,cptype,silent)\n    use thermopack_constants, only: clen, trend, thermopack\n    use cbselect,   only: selectcubiceos\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var,  only: nc, nce, ncsym, complist, apparent, nph\n    use eosdata,    only: cpasrk, cpapr, eospc_saft, eospets, eosbh_pert\n    !$ use omp_lib, only: omp_get_max_threads\n    ! method information\n    character(len=*), intent(in) :: eos    !< string defining equation of state\n    character(len=*), intent(in) :: mixing !< string defining mixing rules\n    character(len=*), intent(in) :: alpha  !< string defining alpha correlation\n    character(len=*), intent(in) :: comp_string    !< string defining components. comma or white-space separated.\n    integer, intent(in) :: nphases !< number of phases\n    integer, optional, intent(in) :: liq_vap_discr_method_in !< method to discriminate between liquid and vapor in case of an undefined single phase. will be set to none if absent.\n    character(len=*), optional, intent(in) :: csp_eos !< corrensponding state equation\n    character(len=*), optional, intent(in) :: csp_ref_comp !< csp component\n    character(len=*), optional, intent(in) :: kij_ref, alpha_ref, saft_ref !< data set identifiers\n    real, optional, intent(in) :: b_exponent !< inverse exponent (1/s) in mixing of covolume (s>1.0)\n    character(len=*), optional, intent(in) :: trendeosforcp !< option to init trend for ideal gas properties.\n    integer, optional, intent(in) :: cptype !< type numbers for cp\n    logical, optional, intent(in) :: silent !< option to disable init messages.\n    ! locals\n    integer :: ncomp !< number of components\n    character(len=clen) :: message\n    integer             :: i, ierr, index\n    type(thermo_model), pointer :: act_mod_ptr\n    if (present(silent)) then\n      silent_init = silent\n    endif\n\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model have been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n\n    ! component list.\n    call initcomplist(trim(uppercase(comp_string)),ncomp,act_mod_ptr%complist)\n    allocate(complist, source=act_mod_ptr%complist)\n\n\n    ! equation of state\n    call allocate_eos(ncomp, eos)\n\n    ! method for discriminating between liquid/vapor when poorly defined\n    if (present(liq_vap_discr_method_in)) then\n      act_mod_ptr%liq_vap_discr_method = liq_vap_discr_method_in\n    end if\n\n    ! number of phases\n    act_mod_ptr%nph = nphases\n\n    ! assign active mode variables\n    ncsym = ncomp\n    nce = ncomp\n    nc = ncomp\n    act_mod_ptr%nc = ncomp\n    nph = act_mod_ptr%nph\n    complist => act_mod_ptr%complist\n    apparent => null()\n    numassocsites = 0\n\n    ! initialize components\n    call selectcomp(complist,nce,\"default\",act_mod_ptr%comps,ierr)\n\n    ! set cptype\n    if (present(cptype)) then\n      do i=1,nc\n        act_mod_ptr%comps(i)%p_comp%id_cp%cptype = cptype\n      enddo\n    endif\n\n    if (str_eq(eos, \"eoscg\") .or. &\n         str_eq(eos, \"eos-cg\") .or. &\n         str_eq(eos, \"gerg2008\") .or. &\n         str_eq(eos, \"gerg-2008\") .or. &\n         str_eq(eos, \"eoscg-gerg\")) then\n      act_mod_ptr%eoslib = trend\n    else\n      act_mod_ptr%eoslib = thermopack\n    endif\n\n    ! initialize the selected eos-library\n    select case (act_mod_ptr%eoslib)\n    case (thermopack)\n      ! initialize thermopack\n      call init_thermopack(trim(uppercase(eos)),trim(uppercase(mixing)), &\n           trim(uppercase(alpha)), &\n           nphases,csp_eos,csp_ref_comp, & ! csp_refcomp is case sensitive in compdb\n           kij_ref,alpha_ref,saft_ref,&\n           b_exponent)\n      if (present(trendeosforcp)) then\n        ! initialize trend for ideal properties\n        call init_trend(trim(uppercase(trendeosforcp)),ncomp,nphases,.false.)\n      endif\n    case (trend)\n      ! initialize trend\n      call init_trend(trim(uppercase(eos)),ncomp,nphases,.true.)\n    case default\n      write(message,*) 'wrong eos library'\n      call stoperror(trim(message))\n    end select\n\n    call init_fallback_and_redefine_criticals(silent_init)\n  end subroutine init_thermo\n"}
{"id": 210, "subroutine": "  subroutine init_fallback_and_redefine_criticals(silent)\n    use thermopack_constants, only: trend, thermopack\n    use thermopack_var, only: nce\n    use eosdata, only: issafteos\n    use cbselect, only: selectcubiceos, selectmixingrules\n    use cubic_eos, only: cb_eos\n    !$ use omp_lib, only: omp_get_max_threads\n    logical, intent(in) :: silent !< option to disable init messages.\n    ! locals\n    integer             :: i\n    real                :: tci, pci, oi\n\n    type(thermo_model), pointer :: act_mod_ptr\n    act_mod_ptr => get_active_thermo_model()\n\n    if (.not. act_mod_ptr%need_alternative_eos) return\n\n    if (act_mod_ptr%eoslib == trend) then\n      ! use trend parameters to get better critical point in alternative model\n      do i=1,nce\n        call trend_getcrit(i,tci,pci,oi)\n        act_mod_ptr%comps(i)%p_comp%tc = tci\n        act_mod_ptr%comps(i)%p_comp%pc = pci\n        act_mod_ptr%comps(i)%p_comp%acf = oi\n      enddo\n    endif\n\n    select type(p_eos => act_mod_ptr%cubic_eos_alternative(1)%p_eos)\n    type is (cb_eos)\n      call selectcubiceos(nce, act_mod_ptr%comps, p_eos, &\n           \"classic\", \"default\")\n\n      call selectmixingrules(nce, act_mod_ptr%comps, p_eos, &\n         \"vdw\", \"default\")\n    class default\n      call stoperror(\"init_cubic: should be cubic eos\")\n    end select\n\n    ! distribute parameters from redefined eos\n    do i=2,size(act_mod_ptr%cubic_eos_alternative)\n      act_mod_ptr%cubic_eos_alternative(i)%p_eos = &\n           act_mod_ptr%cubic_eos_alternative(1)%p_eos\n    enddo\n\n    if (act_mod_ptr%eoslib == thermopack .and. &\n         issafteos(act_mod_ptr%eos(1)%p_eos%eosidx)) then\n      call redefine_critical_parameters(silent)\n    endif\n  end subroutine init_fallback_and_redefine_criticals\n"}
{"id": 211, "subroutine": "  subroutine init_cubic(comps,eos,mixing,alpha,parameter_reference,vol_shift)\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var, only: nc, nce, ncsym, complist, nph, apparent\n    use thermopack_constants, only: thermopack\n    use eos_container, only: allocate_eos\n    use cbselect, only: selectcubiceos, selectmixingrules\n    use cubic_eos, only: cb_eos\n    use volume_shift, only: initvolumeshift\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), intent(in) :: eos     !< equation of state\n    character(len=*), optional, intent(in) :: mixing !< mixing rule\n    character(len=*), optional, intent(in) :: alpha  !< alpha correlation\n    character(len=*), optional, intent(in) :: parameter_reference  !< parameter reference\n    logical, optional, intent(in) :: vol_shift  !< volume shift\n    ! locals\n    integer                          :: ncomp, i, index, ierr, volumeshiftid\n    character(len=len_trim(comps))   :: comps_upper\n    character(len=100)               :: mixing_loc, alpha_loc, paramref_loc, beta_loc\n    logical                          :: volshift_loc\n    type(thermo_model), pointer      :: act_mod_ptr\n    logical                          :: found_tcpr, found_quantumcubic\n    integer                          :: matchval_tcpr, matchval_quantumcubic\n    ! get a pointer to the active thermodynamics model\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model has been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n\n    ! set component list\n    comps_upper=trim(uppercase(comps))\n    call initcomplist(comps_upper,ncomp,act_mod_ptr%complist)\n    call allocate_eos(ncomp, eos)\n\n    ! number of phases\n    act_mod_ptr%nph = 3\n\n    ! assign active mode variables\n    ncsym = ncomp\n    nce = ncomp\n    nc = ncomp\n    nph = act_mod_ptr%nph\n    act_mod_ptr%nc = ncomp\n    complist => act_mod_ptr%complist\n    apparent => null()\n\n    ! set eos library identifier\n    act_mod_ptr%eoslib = thermopack\n\n    ! set local variables inputs that are optional\n    mixing_loc = \"vdw\"\n    alpha_loc = \"classic\"\n    paramref_loc = \"default\"\n    volshift_loc = .false.\n    beta_loc = \"classic\"\n    if (present(mixing)) then\n       mixing_loc = uppercase(mixing)\n       if (str_eq(mixing_loc, \"classic\")) mixing_loc = \"vdw\"\n    end if\n    if (present(alpha)) alpha_loc = uppercase(alpha)\n    if (present(parameter_reference)) paramref_loc = parameter_reference\n    if (present(vol_shift)) volshift_loc = vol_shift\n\n    ! special handling of translated-consistent peng--robinson eos by le guennec\n    ! et al. (10.1016/j.fluid.2016.09.003)\n    call string_match_val(\"tcpr\", paramref_loc, found_tcpr, matchval_tcpr)\n    if (found_tcpr) then\n       alpha_loc = \"twu\"\n       volshift_loc = .true.\n    end if\n\n    ! special handling of quantum cubic peng-robinson equation of state by aasen\n    ! et al. (10.1016/j.fluid.2020.112790)\n    call string_match_val(\"quantumcubic\", paramref_loc, found_quantumcubic, matchval_quantumcubic)\n    if (found_quantumcubic) then\n       alpha_loc = \"twu\"\n       volshift_loc = .true.\n       beta_loc = \"quantum\"\n    end if\n\n    ! initialize components module\n    call selectcomp(complist,nce,paramref_loc,act_mod_ptr%comps,ierr)\n\n    ! initialize volume shift\n    if (volshift_loc) then\n       volumeshiftid = initvolumeshift(nc,act_mod_ptr%comps,'peneloux',eos, param_ref=paramref_loc)\n       act_mod_ptr%eos(1)%p_eos%volumeshiftid = volumeshiftid\n    end if\n\n    ! initialize thermopack\n    select type(p_eos => act_mod_ptr%eos(1)%p_eos)\n    type is (cb_eos)\n      call selectcubiceos(nc, act_mod_ptr%comps, &\n           p_eos, alpha_loc, paramref_loc, betastr=beta_loc)\n\n      call selectmixingrules(nc, act_mod_ptr%comps, &\n           p_eos, mixing_loc, paramref_loc)\n    class default\n      call stoperror(\"init_cubic: should be cubic eos\")\n   end select\n\n    ! distribute parameters from redefined eos\n    do i=2,size(act_mod_ptr%eos)\n      act_mod_ptr%eos(i)%p_eos = act_mod_ptr%eos(1)%p_eos\n    enddo\n\n  end subroutine init_cubic\n"}
{"id": 212, "subroutine": "  subroutine init_tcpr(comps, mixing, parameter_ref)\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), intent(in), optional :: mixing !< mixing rule\n    character(len=*), intent(in), optional :: parameter_ref !< parameter set reference\n    !\n    character(len=200) :: parameter_reference\n    type(thermo_model), pointer      :: act_mod_ptr\n    parameter_reference = \"tcpr\"\n    if (present(parameter_ref)) then\n      parameter_reference = trim(parameter_ref) // \"/\" // trim(parameter_reference)\n    endif\n    call init_cubic(eos=\"pr\", comps=comps, mixing=mixing, &\n         parameter_reference=parameter_reference)\n  end subroutine init_tcpr\n"}
{"id": 213, "subroutine": "  subroutine init_quantum_cubic(comps, mixing)\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), intent(in), optional :: mixing !< mixing rule\n    call init_cubic(eos=\"pr\", comps=comps, mixing=mixing, parameter_reference=\"quantumcubic/tcpr\")\n  end subroutine init_quantum_cubic\n"}
{"id": 214, "subroutine": "  subroutine init_extcsp(comps,sh_eos,sh_mixing,sh_alpha,&\n       ref_eos,ref_comp,ref_alpha,&\n       parameter_ref)\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var, only: nc, nce, ncsym, complist, nph, apparent\n    use thermopack_constants, only: thermopack, ref_len\n    use stringmod,  only: uppercase\n    use eos_container, only: allocate_eos\n    use extcsp, only: extcsp_eos, csp_init\n    use volume_shift, only: noshift\n    !$ use omp_lib, only: omp_get_max_threads\n    character(len=*), intent(in) :: comps !< components. comma or white-space\n    !separated\n    character(len=*), intent(in) :: sh_eos      !< shape factor equation of state\n    character(len=*), intent(in) :: sh_alpha    !< shape factor alpha\n    character(len=*), intent(in) :: sh_mixing   !< shape factor mixing rules\n    character(len=*), intent(in) :: ref_eos     !< reference equation of state\n    character(len=*), intent(in) :: ref_comp    !< reference component\n    character(len=*), intent(in), optional :: ref_alpha  !< needed if refeos is a cubic eos. should not be present if one want to use an mbwr reference eos.\n    character(len=*), intent(in), optional :: parameter_ref !< parameter set reference\n\n    ! locals\n    integer                          :: ncomp, i, index, ierr, ncbeos\n    character(len=len_trim(comps))   :: comps_upper\n    type(thermo_model), pointer      :: act_mod_ptr\n    class(base_eos_param), pointer   :: act_eos_ptr\n    character(len=ref_len)           :: param_ref\n\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model have been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n    ! set component list\n    comps_upper=trim(uppercase(comps))\n    call initcomplist(comps_upper,ncomp,act_mod_ptr%complist)\n    !\n    call allocate_eos(ncomp, \"csp-\"//trim(sh_eos))\n\n    ! number of phases\n    act_mod_ptr%nph = 3\n\n    ! assign active mode variables\n    ncsym = ncomp\n    nce = ncomp\n    nc = ncomp\n    nph = act_mod_ptr%nph\n    act_mod_ptr%nc = ncomp\n    complist => act_mod_ptr%complist\n    apparent => null()\n\n    ! set eos library identifyer\n    act_mod_ptr%eoslib = thermopack\n\n    ! set local variable for parameter reference\n    if (present(parameter_ref)) then\n      param_ref = parameter_ref\n    else\n      param_ref = \"default\"\n    endif\n\n    ! initialize components module\n    call selectcomp(complist,nce,param_ref,act_mod_ptr%comps,ierr)\n\n    act_eos_ptr => get_active_eos()\n    act_eos_ptr%volumeshiftid = noshift\n    act_eos_ptr%iselectrolyteeos = .false.\n    select type(p_eos => act_eos_ptr)\n    type is (extcsp_eos)\n      call csp_init(p_eos,nce,act_mod_ptr%comps,&\n           refcomp_str=trim(ref_comp),&\n           sheos=trim(sh_eos),&\n           shmixrule=trim(sh_mixing),shalpha=trim(sh_alpha),&\n           refeos=trim(ref_eos),refalpha=ref_alpha,&\n           parameter_ref=parameter_ref)\n   end select\n\n   ncbeos = 1\n   !$ ncbeos = omp_get_max_threads()\n   do i=2,ncbeos\n     act_mod_ptr%eos(i)%p_eos = act_mod_ptr%eos(1)%p_eos\n   enddo\n\n   ! set globals\n   call update_global_variables_form_active_thermo_model()\n\n   ! initialize fallback eos\n   call init_fallback_and_redefine_criticals(silent=.true.)\n\n  end subroutine init_extcsp\n"}
{"id": 215, "subroutine": "  subroutine redefine_critical_parameters(silent_init, tc_in, vc_in)\n    use cbmix,      only: cbsinglecalcabc\n    use thermopack_var, only: nce\n    use eostv,        only: pressure\n    use critical,     only: calccriticaltv\n    use saturation,   only: acentricfactoreos\n    use thermopack_constants,      only: tptmin, rgas\n    use cbalpha,      only: getacentricalphaparam\n    use cubic_eos,    only: cb_eos\n    logical, intent(in) :: silent_init\n    real, optional, intent(in) :: tc_in(nce), vc_in(nce)\n    ! locals\n    integer :: i, j, ierr\n    real :: tmin\n    real :: vc\n    real :: tc  !< specified critical temperature [k]\n    real :: pc  !< specified critical pressure [pa]\n    real :: acf !< specified acentric factor [-]\n    real :: z(nce)\n    type(thermo_model), pointer :: act_mod_ptr\n    class(base_eos_param), pointer :: act_eos_ptr\n\n    act_mod_ptr => get_active_thermo_model()\n    act_eos_ptr => get_active_alt_eos()\n    tmin = tptmin\n    tptmin = 2.0\n    do i=1,nce\n      z = 0\n      z(i) = 1\n      tc = -1.0\n      vc = -1.0\n      if (present(tc_in)) tc = tc_in(i)\n      if (present(vc_in)) vc = vc_in(i)\n      call calccriticaltv(tc,vc,z,ierr)\n      if (ierr /= 0 .and. .not. silent_init) then\n        print *, 'not able to redefine critical properties for component: ', &\n             trim(act_mod_ptr%comps(i)%p_comp%ident)\n      else\n        pc = pressure(tc,vc,z)\n        select type (p_eos => act_eos_ptr)\n        class is (cb_eos)\n          p_eos%single(i)%tc = tc\n          p_eos%single(i)%pc = pc\n          call cbsinglecalcabc(nce,p_eos,i)\n          act_mod_ptr%comps(i)%p_comp%tc = tc\n          act_mod_ptr%comps(i)%p_comp%pc = pc\n          act_mod_ptr%comps(i)%p_comp%zc = pc*vc/(tc*rgas)\n          acf = acentricfactoreos(i,ierr)\n          act_mod_ptr%comps(i)%p_comp%acf = acf\n          p_eos%single(i)%acf = acf\n          call getacentricalphaparam(p_eos%single(i)%alphamethod, acf, &\n               p_eos%single(i)%alphaparams)\n\n          ! copy to others\n          do j=2,size(act_mod_ptr%cubic_eos_alternative)\n            select type (p_eos_j => act_mod_ptr%cubic_eos_alternative(j)%p_eos)\n            class is (cb_eos)\n              p_eos_j%single(i)%tc = p_eos%single(i)%tc\n              p_eos_j%single(i)%pc = p_eos%single(i)%pc\n              p_eos_j%single(i)%acf = p_eos%single(i)%acf\n              p_eos_j%single(i)%alphaparams = p_eos%single(i)%alphaparams\n              call cbsinglecalcabc(nce, p_eos_j, i)\n            class default\n              print *,\"fallback eos should be cubic\"\n            end select\n          enddo\n        class default\n          print *,\"fallback eos should be cubic\"\n        end select\n      endif\n    enddo\n    tptmin = tmin\n  end subroutine redefine_critical_parameters\n"}
{"id": 216, "subroutine": "  subroutine init_thermopack(eos,mixing,alpha,nphase,&\n       csp_eos,csp_ref_comp,kij_ref,alpha_ref,saft_ref,&\n       b_exponent)\n    use eosdata, only: issafteos\n    use stringmod, only: str_eq\n    use thermopack_constants, only: thermopack, ref_len\n    use thermopack_var, only: nce, nc, complist\n    use volume_shift, only: initvolumeshift, noshift\n    use extcsp, only: csp_init, extcsp_eos\n    use cubic_eos, only: cb_eos\n    use cbselect, only: selectcubiceos, selectmixingrules\n    use saft_interface, only: saft_type_eos_init\n    use cpa_parameters, only: mixhasselfassociatingcomp\n    use assocschemeutils, only: no_assoc\n    use saft_association, only: numassocsites\n    use stringmod, only: uppercase\n    use eos_container, only: allocate_eos\n    !$ use omp_lib\n    ! method information\n    character(len=*), intent(in) :: eos    !< string defining equation of state\n    character(len=*), intent(in) :: mixing !< string defining mixing rules\n    character(len=*), intent(in) :: alpha  !< string defining alpha correlation\n    integer, intent(in) :: nphase !< number of phases\n    character(len=*), optional, intent(in) :: csp_eos !< corrensponding state equation\n    character(len=*), optional, intent(in) :: csp_ref_comp !< csp component\n    character(len=*), optional, intent(in) :: kij_ref, alpha_ref, saft_ref !< data set number\n    real, optional, intent(in) :: b_exponent !< inverse exponent (1/s) in mixing of covolume (s>1.0)\n    ! string containing components on tplib format\n    character(len=100) :: mixrule,csp_refeos,csp_refcomp_str\n    character(len=len(eos)) :: eoslocal  !< local copy of string defining equation of state\n    integer :: ncbeos, i, volumeshiftid\n    character(len=ref_len) :: kij_ref_local, alpha_ref_local, saft_ref_local\n    type(thermo_model), pointer :: act_mod_ptr\n    class(base_eos_param), pointer :: act_eos_ptr\n    !\n    act_mod_ptr => get_active_thermo_model()\n    act_eos_ptr => get_active_eos()\n\n    if (present(kij_ref)) then\n      kij_ref_local = trim(kij_ref)\n    else\n      kij_ref_local = \"default\"\n    endif\n    if (present(alpha_ref)) then\n      alpha_ref_local = trim(alpha_ref)\n    else\n      alpha_ref_local = \"default\"\n    endif\n    if (present(saft_ref)) then\n      saft_ref_local = trim(saft_ref)\n    else\n      saft_ref_local = \"default\"\n    endif\n\n    ! set parameters\n    mixrule = trim(mixing)\n    volumeshiftid = noshift\n    eoslocal = eos\n    numassocsites = 0\n    if (len(eos) >= 3) then\n      if (eos(1:3) == 'cpa') then\n        if ( .not. mixhasselfassociatingcomp(nc,trim(eoslocal),&\n             complist,saft_ref)) then\n          print *,'no self associating components. initializing ',&\n               eos(5:len(eos)),' instead of ',trim(eos)\n          eoslocal = eos(5:len(eos))\n          do i=1,nce\n            act_mod_ptr%comps(i)%p_comp%assoc_scheme = no_assoc\n          enddo\n        endif\n      endif\n    endif\n\n    if (trim(uppercase(eos)) == 'lk') then\n      mixrule = 'vdw'\n    else if (trim(uppercase(eos)) == 'srk-peneloux') then\n      eoslocal = 'srk'\n      volumeshiftid = initvolumeshift(nc,act_mod_ptr%comps,'peneloux','srk')\n    else if (trim(uppercase(eos)) == 'pr-peneloux') then\n      eoslocal = 'pr'\n      volumeshiftid = initvolumeshift(nc,act_mod_ptr%comps,'peneloux','pr')\n    else if (len(eos) >= 3) then\n      if (uppercase(eos(1:3)) == 'csp') then\n        eoslocal = eos(5:len(trim(eos)))\n        if (present(csp_eos)) then\n          csp_refeos = uppercase(csp_eos)\n        else\n          csp_refeos = \"nist_meos\"\n          if (.not. silent_init) &\n               print *,'init_thermopack: csp model defaulted to mbwr32'\n        endif\n        if (present(csp_ref_comp)) then\n          csp_refcomp_str = csp_ref_comp ! this is case sensitive\n        else\n          csp_refcomp_str = \"c3\"\n          if (.not. silent_init) &\n               print *,'init_thermopack: csp reference component defaulted to c3'\n        endif\n      end if\n    end if\n\n    act_eos_ptr%volumeshiftid = volumeshiftid\n    act_eos_ptr%iselectrolyteeos = .false.\n    select type(p_eos => act_eos_ptr)\n    class is (cb_eos)\n      call selectcubiceos(nce,act_mod_ptr%comps,p_eos,trim(alpha),&\n           alpha_ref_local)\n      call selectmixingrules(nce,act_mod_ptr%comps,p_eos,mixrule,&\n           kij_ref_local,b_exponent)\n    type is (extcsp_eos)\n      call csp_init(p_eos,nce,act_mod_ptr%comps,refcomp_str=trim(csp_refcomp_str),&\n           sheos=trim(eoslocal),&\n           shmixrule=trim(mixrule),shalpha=trim(alpha),&\n           refeos=trim(csp_refeos),refalpha=trim(alpha))\n   end select\n\n    ! saft initialization must be done after cbeos initialization.\n    if (issafteos(act_eos_ptr%eosidx)) then\n       call saft_type_eos_init(nce,act_mod_ptr%comps,&\n            act_eos_ptr,saft_ref_local,silent_init)\n    end if\n    ncbeos = 1\n    !$ ncbeos = omp_get_max_threads()\n    do i=2,ncbeos\n      act_mod_ptr%eos(i)%p_eos = act_mod_ptr%eos(1)%p_eos\n    enddo\n  end subroutine init_thermopack\n"}
{"id": 217, "subroutine": "  subroutine init_trend(eos,ncomp,nphase,dofallbackinit)\n    !use thermopack_constants, only: rgas,trend,verbose\n    !use thermopack_var, only: complist,nph\n    !use stringmod, only: chartoascii\n    !use compname_translation, only: translate_compname\n#ifdef __intel_compiler\n    use ifport\n#endif\n    ! input:\n    character(len=*), intent(in)    :: eos            !< string defining equation of state\n    integer, intent(in)             :: ncomp          !< number of components\n    integer, intent(in)             :: nphase         !< number of phases\n    logical, intent(in)             :: dofallbackinit !< init thermopack as fallback\n    !internal:\n    ! integer                         :: i\n    ! integer                         :: mix\n    ! character (12)                  :: comps(ncomp)\n    ! character(len=255)              :: path,trendroot\n    ! integer                         :: npath,int_path(255),int_comps(12*ncomp),ncomps\n\n    ! if (dofallbackinit) then\n    !   ! also initialize thermopack cubic eos, to be used for initial estimates.\n    !   if (verbose) then\n    !     write(*,*) \"initializing eos-lib thermopack for initial estimates. (srk, classic)\"\n    !   endif\n    !   call init_thermopack(\"srk\",\"classic\",\"classic\", nphase)\n    ! endif\n    ! ! setting eoslib flag\n    ! if (verbose) then\n    !   write(*,*) \"initializing eos-lib trend\"\n    ! endif\n    ! eoslib = trend\n    ! call set_constants() ! depend on eoslib\n    ! ! setting global nph number\n    ! nph = nphase\n    ! do i=1,ncomp\n    !   call translate_compname(trim(complist(i)), trend, comps(i))\n    !   char_comps((i-1)*12+1:i*12) = comps(i)\n    ! enddo\n    ! ! setting mixing rules\n    ! if (verbose) then\n    !   write(*,*) \"obs: mixing rule and alpha-correlation input ignored.\"\n    ! endif\n    ! mix = 1 ! lorentz-berthelot or modified helmholtz mixing rules\n    ! call getenv(\"trendroot\",trendroot)\n    ! if (trim(trendroot) == \"\") then\n    !    trendroot = \"./trend/\"\n    ! endif\n    ! ! setting path based on input eos-string:\n    ! ! they are all \"multi-parameter explicit helmholtz\" eos, but with different parameters.\n    ! select case(trim(eos))\n    ! case (\"eoscg\")\n    !   ! the eos for ccs mixtures, parameters fitted by johannes gernert.\n    !   ! will fail when selecting components not covered in the original fitting.\n    !    path = trim(trendroot)//\"eos_cg/\"\n    ! case (\"gerg2008\")\n    !   ! the gerg-2008 eos for natural gas mixtures.\n    !   path = trim(trendroot)//\"gerg-2008/\"\n    ! case (\"eoscg-gerg\")\n    !   ! primarily eoscg, but now falling back to gerg2008 for unsupported components.\n    !   path = trim(trendroot)//\"/\"\n    ! case default\n    !   call stoperror(\"no such eos in trend (eoscg,gerg2008,eoscg-gerg): \"//trim(eos))\n    ! end select\n    ! if (verbose) then\n    !   write(*,*) \"will look for dirs fluids and binary_mix_files in: \"//trim(path)\n    ! endif\n    ! npath = len(trim(path))\n    ! call chartoascii(int_path,path,npath)\n    ! ncomps = 12*ncomp\n    ! call chartoascii(int_comps,char_comps,ncomps)\n    ! call trend_init_no_char(ncomp,int_path,npath,int_comps,ncomps,mix,rgas)\n\n  end subroutine init_trend\n"}
{"id": 218, "subroutine": "  subroutine init_saftvrmie(comps,parameter_reference)\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var,  only: nce, complist\n    use thermopack_constants, only: thermopack, ref_len\n    use stringmod,  only: uppercase\n    use volume_shift, only: noshift\n    use saft_interface, only: saft_type_eos_init\n    !$ use omp_lib\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), optional, intent(in) :: parameter_reference !< data set reference\n    ! locals\n    integer                          :: ncomp, index, ierr, i, ncbeos\n    character(len=len_trim(comps))   :: comps_upper\n    type(thermo_model), pointer      :: act_mod_ptr\n    class(base_eos_param), pointer   :: act_eos_ptr\n    character(len=ref_len)           :: param_ref\n\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model have been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n    ! set component list\n    comps_upper=trim(uppercase(comps))\n    call initcomplist(comps_upper,ncomp,act_mod_ptr%complist)\n\n    call allocate_eos(ncomp, \"saft-vr-mie\")\n    act_mod_ptr%need_alternative_eos = .true.\n\n    ! number of phases\n    act_mod_ptr%nph = 3\n    ! assign active mode variables\n    act_mod_ptr%nc = ncomp\n    nce = ncomp\n    complist => act_mod_ptr%complist\n    ! set eos library identifyer\n    act_mod_ptr%eoslib = thermopack\n\n    ! set local variable for parameter reference\n    if (present(parameter_reference)) then\n      param_ref = parameter_reference\n    else\n      param_ref = \"default\"\n    endif\n\n    ! initialize components module\n    call selectcomp(complist,nce,param_ref,act_mod_ptr%comps,ierr)\n\n    ! initialize thermopack\n    act_eos_ptr => act_mod_ptr%eos(1)%p_eos\n    act_eos_ptr%volumeshiftid = noshift\n    act_eos_ptr%iselectrolyteeos = .false.\n\n    ! saft initialization must be done after cbeos initialization.\n    call saft_type_eos_init(nce,act_mod_ptr%comps,&\n         act_eos_ptr,param_ref,silent_init=.true.)\n    ncbeos = 1\n    !$ ncbeos = omp_get_max_threads()\n    do i=2,ncbeos\n      act_mod_ptr%eos(i)%p_eos = act_mod_ptr%eos(1)%p_eos\n    enddo\n\n    ! set globals\n    call update_global_variables_form_active_thermo_model()\n\n    ! initialize fallback eos\n    call init_fallback_and_redefine_criticals(silent=.true.)\n\n  end subroutine init_saftvrmie\n"}
{"id": 219, "subroutine": "  subroutine init_quantum_saftvrmie(comps,feynman_hibbs_order,parameter_reference)\n    use saftvrmie_options, only: lafitte, qsaft_fh1, qsaft_fh2, lafitte_hs_ref, &\n         saftvrmieaij_model_options\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    integer, optional, intent(in) :: feynman_hibbs_order\n    character(len=*), optional, intent(in) :: parameter_reference !< data set reference\n    ! locals\n    integer :: fh, fh_model\n    if (present(feynman_hibbs_order)) then\n      fh = feynman_hibbs_order\n    else\n      fh = 1\n    endif\n    fh_model = fh + 1\n    call saftvrmieaij_model_options(fh_model, lafitte_hs_ref)\n    call init_saftvrmie(comps,parameter_reference)\n  end subroutine init_quantum_saftvrmie\n"}
{"id": 220, "subroutine": "  subroutine init_pcsaft(comps,parameter_reference)\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var,  only: nc, nce, ncsym, complist, apparent, nph\n    use thermopack_constants, only: thermopack, ref_len\n    use stringmod,  only: uppercase\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), optional, intent(in) :: parameter_reference !< data set reference\n    ! locals\n    integer                          :: ncomp, index, ierr\n    character(len=len_trim(comps))   :: comps_upper\n    type(thermo_model), pointer      :: act_mod_ptr\n    character(len=ref_len)           :: param_ref\n\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model have been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n    ! set component list\n    comps_upper=trim(uppercase(comps))\n    call initcomplist(comps_upper,ncomp,act_mod_ptr%complist)\n    !\n    call allocate_eos(ncomp, \"pc-saft\")\n\n    ! number of phases\n    act_mod_ptr%nph = 3\n\n    ! assign active mode variables\n    ncsym = ncomp\n    nce = ncomp\n    nc = ncomp\n    nph = act_mod_ptr%nph\n    act_mod_ptr%nc = ncomp\n    complist => act_mod_ptr%complist\n    apparent => null()\n\n    ! set eos library identifyer\n    act_mod_ptr%eoslib = thermopack\n\n    ! set local variable for parameter reference\n    if (present(parameter_reference)) then\n      param_ref = parameter_reference\n    else\n      param_ref = \"default\"\n    endif\n\n    ! initialize components module\n    call selectcomp(complist,nce,param_ref,act_mod_ptr%comps,ierr)\n\n    ! initialize thermopack\n    call init_thermopack(\"pc-saft\", \"classic\", \"classic\", nphase=3,&\n         saft_ref=param_ref)\n\n    ! set globals\n    call update_global_variables_form_active_thermo_model()\n\n    ! initialize fallback eos\n    call init_fallback_and_redefine_criticals(silent=.true.)\n\n  end subroutine init_pcsaft\n"}
{"id": 221, "subroutine": "  subroutine init_cpa(comps,eos,mixing,alpha,parameter_reference)\n    use compdata,   only: selectcomp, initcomplist\n    use thermopack_var,  only: nc, nce, ncsym, complist, apparent, nph\n    use thermopack_constants, only: thermopack\n    use stringmod,  only: uppercase\n    character(len=*), intent(in) :: comps !< components. comma or white-space separated\n    character(len=*), optional, intent(in) :: eos    !< equation of state\n    character(len=*), optional, intent(in) :: mixing !< mixing rule\n    character(len=*), optional, intent(in) :: alpha  !< alpha correlation\n    character(len=*), optional, intent(in) :: parameter_reference !< data set reference\n    ! locals\n    integer                          :: ncomp, index, ierr\n    character(len=len_trim(comps))   :: comps_upper\n    character(len=100)               :: mixing_loc, alpha_loc, eos_loc, param_ref\n    type(thermo_model), pointer     :: act_mod_ptr\n\n    ! initialize thermopack\n    eos_loc = \"srk\"\n    if (present(eos)) eos_loc = uppercase(eos)\n    !\n    if (.not. active_thermo_model_is_associated()) then\n      ! no thermo_model have been allocated\n      index = add_eos()\n    endif\n    act_mod_ptr => get_active_thermo_model()\n    ! set component list\n    comps_upper=trim(uppercase(comps))\n    call initcomplist(comps_upper,ncomp,act_mod_ptr%complist)\n    !\n    call allocate_eos(ncomp, \"cpa-\"//trim(eos_loc))\n\n    ! number of phases\n    act_mod_ptr%nph = 3\n\n    ! assign active mode variables\n    ncsym = ncomp\n    nce = ncomp\n    nc = ncomp\n    act_mod_ptr%nc = ncomp\n    nph = act_mod_ptr%nph\n    complist => act_mod_ptr%complist\n    apparent => null()\n\n    ! set eos library identifyer\n    act_mod_ptr%eoslib = thermopack\n\n    ! set local variable for parameter reference\n    if (present(parameter_reference)) then\n      param_ref = parameter_reference\n    else\n      param_ref = \"default\"\n    endif\n\n    ! initialize components module\n    call selectcomp(complist,nce,param_ref,act_mod_ptr%comps,ierr)\n\n    alpha_loc = \"classic\"\n    mixing_loc = \"classic\"\n    if (present(mixing)) mixing_loc = uppercase(mixing)\n    if (present(alpha)) alpha_loc = uppercase(alpha)\n\n    call init_thermopack(\"cpa-\"//trim(eos_loc),trim(uppercase(mixing_loc)), &\n         trim(uppercase(alpha_loc)), nphase=3, saft_ref=param_ref)\n\n    ! set globals\n    call update_global_variables_form_active_thermo_model()\n\n    ! initialize fallback eos\n    act_mod_ptr%need_alternative_eos = .true.\n    call init_fallback_and_redefine_criticals(silent=.true.)\n  end subroutine init_cpa\n"}
{"id": 222, "subroutine": "            recursive subroutine init_cema\r\n            end subroutine init_cema\r\n"}
{"id": 223, "subroutine": "  subroutine usage_stop()\n\n    character(18) :: sp1 = '                  '\n    write(error_unit,'(a)') 'usage: fwin2sac.x <-l listfile> '\n    write(error_unit,'(a)') sp1//'[-t chtbl] [-c chids|chlist|all] [-s stnms|stlist|all] [-p cmpnm|cmplist|all]'\n    stop\n  end subroutine usage_stop\n"}
{"id": 224, "subroutine": "  subroutine ch2sh(ch, sh)\n\n    type(winch__hdr), intent(in)  :: ch\n    type(sac__hdr), intent(out) :: sh\n    !--\n    integer :: iscan\n    !----\n\n    \n    sh%stla  =   ch%lat \n    sh%stlo  =   ch%lon \n    sh%stdp  = - ch%elev \n    sh%stel  =   ch%elev  \n    if( len_trim( ch%stnm ) <= 8 ) then\n      sh%kstnm = trim(ch%stnm)\n    else\n      sh%kstnm = ch%stnm(1:8)\n    end if\n    sh%kcmpnm = trim(ch%cmpnm)\n\n    !! cmpaz, cmpinc\n    !! n\n    iscan = scan( ch%cmpnm, 'nx' )\n    if( iscan > 0 ) then\n      sh%cmpaz = 0\n      sh%cmpinc = 90\n    end if\n    \n    !! e\n    iscan = scan( ch%cmpnm, 'ey' )\n    if( iscan > 0 ) then\n      sh%cmpaz = 90\n      sh%cmpinc = 90\n    end if\n    \n    !! v\n    iscan = scan( ch%cmpnm, 'uz' )\n    if( iscan > 0 ) then\n      sh%cmpaz = 0\n      sh%cmpinc = 0\n    end if\n    \n    !! unit\n    select case ( trim(ch%unit) )\n      case( 'm' )\n        sh%idep = 6\n      case( 'm/s' )\n        sh%idep = 7\n      case( 'm/s/s' )\n        sh%idep = 8\n      case default\n        sh%idep = 5\n    end select\n  \n  end subroutine ch2sh\n"}
{"id": 225, "subroutine": "  subroutine environment_start( code )\n\n    character(len=*), intent(in) :: code\n\n    logical           :: exst, debug = .false.\n    character(len=80) :: code_version, uname\n    character(len=6), external :: int_to_char\n    integer :: iost\n\n    ! ... intel compilers v .ge.8 allocate a lot of stack space\n    ! ... stack limit is often small, thus causing sigsegv and crash\n  \n    call remove_stack_limit ( )\n\n    ! ... use \".false.\" to disable all clocks except the total cpu time clock\n    ! ... use \".true.\"  to enable clocks\n\n    call init_clocks( .true. )\n    call start_clock( trim(code) )\n\n    code_version = trim (code) // \" v.\" // trim (version_number)\n\n    ! ... for compatibility with pwscf\n\n    nd_nmbr = trim ( int_to_char( me_image+1 ))\n\n    if( meta_ionode ) then\n\n       ! ...  search for file crash and delete it\n\n       inquire( file=trim(crash_file), exist=exst )\n       if( exst ) then\n          open(  unit=crashunit, file=trim(crash_file), status='old',iostat=iost )\n          if(iost==0) close( unit=crashunit, status='delete', iostat=iost )\n          if(iost/=0) write(stdout,'(5x,\"remark: crash file could not ne deleted\")')\n       end if\n\n    else\n       ! ... one processor per image (other than meta_ionode)\n       ! ... or, for debugging purposes, all processors,\n       ! ... open their own standard output file\n#if defined(debug)\n       debug = .true.\n#endif\n       if (me_image == root_image .or. debug ) then\n          uname = 'out.' // trim(int_to_char( my_image_id )) // '_' // &\n               trim(int_to_char( me_image))\n          open ( unit = stdout, file = trim(uname),status='unknown')\n       else\n          open ( unit = stdout, file='/dev/null', status='unknown' )\n       end if\n\n    end if\n    !\n    call opening_message( code_version )\n    call parallel_info ( )\n  end subroutine environment_start\n"}
{"id": 226, "subroutine": "  subroutine environment_end( code )\n\n    character(len=*), intent(in) :: code\n\n    if ( meta_ionode ) write( stdout, * )\n\n    call stop_clock(  trim(code) )\n    call print_clock( trim(code) )\n\n    call closing_message( )\n\n    if( meta_ionode ) then\n       write( stdout,'(a)')      '     job done.'\n       call print_clock( 'benchmark_time' )\n       write( stdout,3335)\n    end if\n3335 format('=',78('-'),'=')\n\n    return\n  end subroutine environment_end\n"}
{"id": 227, "subroutine": "  subroutine opening_message( code_version )\n\n    character(len=*), intent(in) :: code_version\n    character(len=9)  :: cdate, ctime\n\n    call date_and_tim( cdate, ctime )\n    !\n    write( stdout, '(/5x,\"program \",a18,\" starts on \",a9,\" at \",a9)' ) &\n         code_version, cdate, ctime\n    !\n    write (stdout, &\n         '(/5x,\"this is mini-dft, a mini-application for plane-wave density functional\",&\n         &/5x,\"theory calculations. mini-dft was extracted from\",&\n         &/5x,\"the open-source quantum espresso suite by b. austin (2013). \")')\n    !\n    write( stdout, '(/5x,\"to acknowledge quantum espresso, please cite\", &\n         &/9x,\"p. giannozzi et al., j. phys.:condens. matter 21 395502 (2009);\", &\n         &/9x,\"url http://www.quantum-espresso.org\" )' )\n\n    return\n  end subroutine opening_message\n"}
{"id": 228, "subroutine": "  subroutine closing_message( )\n\n    character(len=9)  :: cdate, ctime\n    character(len=80) :: time_str\n\n    call date_and_tim( cdate, ctime )\n\n    time_str = 'this run was terminated on:  ' // ctime // ' ' // cdate\n\n    if( meta_ionode ) then\n       write( stdout,*)\n       write( stdout,3334) time_str\n       write( stdout,3335)\n    end if\n\n3334 format(3x,a60,/)\n3335 format('=',78('-'),'=')\n\n    return\n  end subroutine closing_message\n"}
{"id": 229, "subroutine": "  subroutine parallel_info ( )\n    !\n#if defined(__openmp) || defined(_openmp)\n    integer, external :: omp_get_max_threads\n#endif\n    !\n#if defined(__openmp) || defined(_openmp)\n    write( stdout, '(/5x,\"parallel version (mpi & openmp), running on \",&\n         &i8,\" processor cores\")' ) nproc * omp_get_max_threads()\n    !\n    write( stdout, '(5x,\"number of mpi processes:           \",i8)' ) nproc\n    !\n    write( stdout, '(5x,\"threads/mpi process:               \",i6)' ) &\n         omp_get_max_threads()\n#else\n    write( stdout, '(/5x,\"parallel version (mpi), running on \",&\n         &i8,\" processors\")' ) nproc \n#endif\n    !\n    if ( nimage > 1 ) write( stdout, &\n         '(5x,\"path-images division:  nimage    = \",i8)' ) nimage\n    if ( nbgrp > 1 ) write( stdout, &\n         '(5x,\"band groups division:  nbgrp     = \",i8)' ) nbgrp\n    if ( npool > 1 ) write( stdout, &\n         '(5x,\"k-points division:     npool     = \",i8)' ) npool\n    if ( nproc_pool > 1 ) write( stdout, &\n         '(5x,\"r & g space division:  proc/pool = \",i8)' ) nproc_pool\n    if ( get_ntask_groups() > 1 ) write( stdout, &\n         '(5x,\"wavefunctions fft division:  fft/group = \",i8)' ) &\n         get_ntask_groups()\n    !\n  end subroutine parallel_info\n"}
{"id": 230, "subroutine": "subroutine zhpsi\n  use global_variables\n  implicit none\n! finite difference\n  real(dp),parameter :: cn0=-205d0/72d0,cn1=8d0/5d0\n  real(dp),parameter :: cn2=-1d0/5d0,cn3=8d0/315d0\n  real(dp),parameter :: cn4=-1d0/560d0    \n  integer :: ix,iy\n  real(dp) :: c0,c1,c2,c3,c4\n  real(dp) :: c0e,c1e,c2e,c3e,c4e,c0n,c1n,c2n,c3n,c4n\n! nine-points formula  \n  c0e=-0.5d0*cn0/(dx**2)/mu_e\n  c1e=-0.5d0*cn1/(dx**2)/mu_e\n  c2e=-0.5d0*cn2/(dx**2)/mu_e\n  c3e=-0.5d0*cn3/(dx**2)/mu_e\n  c4e=-0.5d0*cn4/(dx**2)/mu_e\n\n  c0n=-0.5d0*cn0/(dr**2)/mu_n\n  c1n=-0.5d0*cn1/(dr**2)/mu_n\n  c2n=-0.5d0*cn2/(dr**2)/mu_n\n  c3n=-0.5d0*cn3/(dr**2)/mu_n\n  c4n=-0.5d0*cn4/(dr**2)/mu_n\n\n  ztmp_wfn_b(:,:)=0d0\n  ztmp_wfn_b(0:nx,0:nr) = ztmp_wfn(0:nx,0:nr)\n  ztmp_wfn_b(0:nx,-1) = ztmp_wfn(0:nx,1)\n  ztmp_wfn_b(0:nx,-2) = ztmp_wfn(0:nx,2)\n  ztmp_wfn_b(0:nx,-3) = ztmp_wfn(0:nx,3)\n  ztmp_wfn_b(0:nx,-4) = ztmp_wfn(0:nx,4)\n\n  do iy=0,nr\n  do ix=0,nx\n    ztmp_hwfn(ix,iy)=(c0e+c0n)*ztmp_wfn_b(ix,iy) &\n          + c1e*(ztmp_wfn_b(ix+1,iy) + ztmp_wfn_b(ix-1,iy)) &\n          + c2e*(ztmp_wfn_b(ix+2,iy) + ztmp_wfn_b(ix-2,iy)) &\n          + c3e*(ztmp_wfn_b(ix+3,iy) + ztmp_wfn_b(ix-3,iy)) &\n          + c4e*(ztmp_wfn_b(ix+4,iy) + ztmp_wfn_b(ix-4,iy)) &\n          + c1n*(ztmp_wfn_b(ix,iy+1) + ztmp_wfn_b(ix,iy-1)) &\n          + c2n*(ztmp_wfn_b(ix,iy+2) + ztmp_wfn_b(ix,iy-2)) &\n          + c3n*(ztmp_wfn_b(ix,iy+3) + ztmp_wfn_b(ix,iy-3)) &\n          + c4n*(ztmp_wfn_b(ix,iy+4) + ztmp_wfn_b(ix,iy-4)) \n\n  end do\n  end do\n\n  ztmp_hwfn(:,:) = ztmp_hwfn(:,:) + v_all(:,:)*ztmp_wfn(:,:)\n  return\nend subroutine zhpsi\n"}
{"id": 231, "subroutine": "        subroutine sub_lib_in_lib()\n        implicit none\n        end subroutine sub_lib_in_lib\n"}
{"id": 232, "subroutine": "  subroutine collect_container(testsuite)\n\n    !> collection of tests\n    type(unittest_t), allocatable, intent(out) :: testsuite(:)\n    \n    testsuite = [ &\n        & new_unittest(\"container-scalar\", test_container_scalar), &\n        & new_unittest(\"container-scalar-ptr\", test_container_scalar_ptr) &\n        ]\n        \n  end subroutine collect_container\n"}
{"id": 233, "subroutine": "  subroutine test_container_scalar(error)\n    type(error_t), allocatable, intent(out) :: error\n\n    type(fhash_container_t) :: container\n\n    ! set value\n    container = fhash_container(int(9,int32))\n\n    if (.not.allocated(container%scalar_data)) then\n      call test_failed(error,'scalar_data not allocated.')\n      return\n    end if\n\n    select type(v=>container%scalar_data)\n    type is (integer(int32))\n      if (v /= 9) then\n        call test_failed(error,'wrong value for container%scalar_data.')\n        return\n      end if\n    class default\n      call test_failed(error,'wrong data type for container%scalar_data.')\n      return\n    end select\n\n  end subroutine test_container_scalar\n"}
{"id": 234, "subroutine": "  subroutine test_container_scalar_ptr(error)\n    type(error_t), allocatable, intent(out) :: error\n\n    integer(int32), target :: my_int, new_int\n    type(fhash_container_t) :: container\n\n    my_int = 9\n\n    ! set value\n    container = fhash_container(my_int,pointer=.true.)\n\n    if (.not.associated(container%scalar_ptr)) then\n      call test_failed(error,'scalar_ptr not associated.')\n      return\n    end if\n\n    my_int = 10\n\n    select type(v=>container%scalar_ptr)\n    type is (integer(int32))\n      if (v /= my_int) then\n        call test_failed(error,'wrong value for container%scalar_ptr.')\n        return\n      end if\n    class default\n      call test_failed(error,'wrong data type for container%scalar_ptr.')\n      return\n    end select\n    \n  end subroutine test_container_scalar_ptr\n"}
{"id": 235, "subroutine": "  subroutine heat_echo ( p, hecmesh, fstrheat )\n\n    use m_fstr\n    use m_hecmw2fstr_mesh_conv\n\n    implicit none\n\n    type(fstr_param)         :: p\n    type(hecmwst_local_mesh) :: hecmesh\n    type(fstr_heat)          :: fstrheat\n\n    !** local variables\n    integer(kind=kint) :: i, j, itype, is, ie, ic_type, nn, icel, isect, mid, ic, im, jm, js, je, kc, km\n    real(kind=kreal)   :: val, temp, aa, bb, time, x, y, z\n    integer(kind=kint) :: ig1, is0, ie0, ik, in, inod, nid\n    integer(kind=kint) :: nids(20)\n\n\n    !c +-------------------------------+\n    !c | global parameters             |\n    !c +-------------------------------+\n\n    write(ilog,*) 'global parameters  ***********'\n    write(ilog,*)\n    write(ilog,*) 'iecho   ',iecho\n    write(ilog,*) 'iresult ',iresult\n    write(ilog,*) 'ivisual ',ivisual\n    write(ilog,*)\n    write(ilog,*) 'for heat ...'\n    write(ilog,*) 'ineutral ', ineutral\n    write(ilog,*) 'irres    ', irres\n    write(ilog,*) 'iwres    ', iwres\n    write(ilog,*) 'nrres    ', nrres\n    write(ilog,*) 'nprint   ', nprint\n    write(ilog,*)\n    write(ilog,*) 'ref_temp ', ref_temp\n    write(ilog,*)\n    write(ilog,*) 'analysis control for heat'\n    write(ilog,*) 'dt     ',dt\n    write(ilog,*) 'etime  ',etime\n    write(ilog,*) 'itmax  ',itmax\n    write(ilog,*) 'eps    ',eps\n\n    !c +-------------------------------+\n    !c | fstrparam                     |\n    !c +-------------------------------+\n\n    write(ilog,*) 'fstrparam  ********************'\n    write(ilog,*)\n    write(ilog,*) 'solution_type ',p%solution_type\n    write(ilog,*) 'solver_method ',p%solver_method\n    write(ilog,*)\n    write(ilog,*) '!!static !heat'\n    write(ilog,*) p%analysis_n\n    if( associated( p%dtime))  write(ilog,*) 'dtime  ', p%dtime\n    if( associated( p%etime))  write(ilog,*) 'etime  ', p%etime\n    if( associated( p%dtmin))  write(ilog,*) 'dtmin  ', p%dtmin\n    if( associated( p%delmax)) write(ilog,*) 'delmax ', p%delmax\n    if( associated( p%itmax))  write(ilog,*) 'itmax  ', p%itmax\n    if( associated( p%eps))    write(ilog,*) 'eps    ', p%eps\n    write(ilog,*) 'ref_temp ', p%ref_temp\n    write(ilog,*)\n    write(ilog,*) 'output control'\n    write(ilog,*) 'fg_echo   ', p%fg_echo\n    write(ilog,*) 'fg_result ', p%fg_result\n    write(ilog,*) 'fg_visual ', p%fg_visual\n    write(ilog,*)\n    write(ilog,*) 'for heat ...'\n    write(ilog,*) 'fg_neutral ', p%fg_neutral\n    write(ilog,*) 'fg_irres   ', p%fg_irres\n    write(ilog,*) 'fg_iwres   ', p%fg_iwres\n    write(ilog,*) 'nrres   ',    p%nrres\n    write(ilog,*) 'nprint  ',    p%nprint\n    write(ilog,*)\n    write(ilog,*) 'index table for global node id sorting'\n    write(ilog,*) 'n_node ', p%n_node\n    if( associated( p%global_local_id)) write(ilog,*) 'global_local_id ', p%global_local_id\n\n    !c +-------------------------------+\n    !c | node                          |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### nodes'\n    write(ilog,*) '### number of nodes',hecmesh%n_node\n    write(ilog,*) 'id x y z'\n    do i=1,hecmesh%n_node\n      nid = hecmesh%global_node_id(i)\n      x = hecmesh%node(3*i-2)\n      y = hecmesh%node(3*i-1)\n      z = hecmesh%node(3*i)\n      write(ilog,*) nid,x,y,z\n    enddo\n\n\n    !c +-------------------------------+\n    !c | element                       |\n    !c +-------------------------------+\n\n    call fstr2hecmw_mesh_conv( hecmesh )\n    write(ilog,*)\n    write(ilog,*) '### elements'\n\n    do itype= 1, hecmesh%n_elem_type\n      is= hecmesh%elem_type_index(itype-1) + 1\n      ie= hecmesh%elem_type_index(itype  )\n      ic_type= hecmesh%elem_type_item(itype)\n\n      !c** set number of nodes\n      nn = hecmw_get_max_node(ic_type)\n      !c element loop\n      do icel= is, ie\n        !c** node id\n        is= hecmesh%elem_node_index(icel-1)\n        do j=1,nn\n          if( hecmesh%n_refine > 0 ) then\n            nids(j)= hecmesh%elem_node_item (is+j)\n          else\n            nids(j)= hecmesh%global_node_id( hecmesh%elem_node_item (is+j))\n          endif\n        enddo\n        !c** section  id\n        isect= hecmesh%section_id(icel)\n        !c** material id\n        mid= hecmesh%section%sect_mat_id_item(isect)\n        write(ilog,*) '### element id=',hecmesh%global_elem_id(icel)\n        write(ilog,*) ic_type,isect,mid\n        write(ilog,*) (nids(j),j=1,nn)\n      enddo\n    enddo\n    call hecmw2fstr_mesh_conv(hecmesh)\n    !c +-------------------------------+\n    !c | material                      |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### material'\n\n    ic = 0\n    do im = 1, hecmesh%material%n_mat\n      write(ilog,*)\n      write(ilog,*) '  material no. =', im\n      do jm = 1, 3\n        ic = ic  + 1\n        js= hecmesh%material%mat_table_index(ic-1) + 1\n        je= hecmesh%material%mat_table_index(ic  )\n        nn= je - js + 1\n        if (jm.eq.1) write(ilog,*) ' density       temperature   functiona     functionb'\n        if (jm.eq.2) write(ilog,*) ' spcific heat  temperature   functiona     functionb'\n        if (jm.eq.3) write(ilog,*) ' conductivity  temperature   functiona     functionb'\n        kc = 0\n        do km = js, je\n          kc = kc + 1\n          val  = hecmesh%material%mat_val (km)\n          temp = hecmesh%material%mat_temp(km)\n          if (jm.eq.1) aa = fstrheat%rhofunca(im,kc)\n          if (jm.eq.1) bb = fstrheat%rhofuncb(im,kc)\n          if (jm.eq.2) aa = fstrheat%cpfunca(im,kc)\n          if (jm.eq.2) bb = fstrheat%cpfuncb(im,kc)\n          if (jm.eq.3) aa = fstrheat%condfunca(im,kc)\n          if (jm.eq.3) bb = fstrheat%condfuncb(im,kc)\n          write(ilog,'(1p4e13.4)') val,temp,aa,bb\n        enddo\n        if (jm.eq.1) aa = fstrheat%rhofunca(im,kc+1)\n        if (jm.eq.1) bb = fstrheat%rhofuncb(im,kc+1)\n        if (jm.eq.2) aa = fstrheat%cpfunca(im,kc+1)\n        if (jm.eq.2) bb = fstrheat%cpfuncb(im,kc+1)\n        if (jm.eq.3) aa = fstrheat%condfunca(im,kc+1)\n        if (jm.eq.3) bb = fstrheat%condfuncb(im,kc+1)\n        write(ilog,'(26x,1p2e13.4)') aa,bb\n      enddo\n    enddo\n\n    !c +-------------------------------+\n    !c | node group                    |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### ngroup'\n\n    do ig1= 1, hecmesh%node_group%n_grp\n      write(ilog,*)\n      write(ilog,'(a80)') hecmesh%node_group%grp_name(ig1)\n      is0= hecmesh%node_group%grp_index(ig1-1) + 1\n      ie0= hecmesh%node_group%grp_index(ig1  )\n      do ik= is0, ie0\n        in   = hecmesh%node_group%grp_item(ik)\n        write(ilog,*) in\n      enddo\n    enddo\n\n    !c +-------------------------------+\n    !c | elemen group                  |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### egroup'\n\n    do ig1= 1, hecmesh%elem_group%n_grp\n      write(ilog,*)\n      write(ilog,'(a80)') hecmesh%elem_group%grp_name(ig1)\n      is0= hecmesh%elem_group%grp_index(ig1-1) + 1\n      ie0= hecmesh%elem_group%grp_index(ig1  )\n      do ik= is0, ie0\n        in   = hecmesh%elem_group%grp_item(ik)\n        write(ilog,*) in\n      enddo\n    enddo\n\n    !c +-------------------------------+\n    !c | boundary                      |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### boundary'\n\n    write(ilog,*) '  t_fix_tot :', fstrheat%t_fix_tot\n    write(ilog,*) '      no./ nid/  amp/ temp-boundary '\n    do i = 1, fstrheat%t_fix_tot\n      inod = hecmesh%global_node_id( fstrheat%t_fix_node(i) )\n      write(ilog,'(2i10,i5,1pe15.7)') i, inod, fstrheat%t_fix_ampl(i)        &\n        , fstrheat%t_fix_val (i)\n    enddo\n\n    write(ilog,*) '  q_nod_tot :', fstrheat%q_nod_tot\n    write(ilog,*) '      no./ nid/ amp/ q-point '\n    do i = 1, fstrheat%q_nod_tot\n      in = hecmesh%global_node_id( fstrheat%q_nod_node(i) )\n      write(ilog,'(2i10,i5,1pe15.7)') i, inod, fstrheat%q_nod_ampl(i)        &\n        , fstrheat%q_nod_val (i)\n    enddo\n\n    write(ilog,*) '  q_vol_tot :', fstrheat%q_vol_tot\n    write(ilog,*) '      no./ eid/ sid/ amp/ q-vol '\n    do i = 1, fstrheat%q_vol_tot\n      ie = hecmesh%global_elem_id( fstrheat%q_vol_elem(i) )\n      write(ilog,'(2i10,i5,1pe15.7)') i, ie, fstrheat%q_vol_ampl(i)          &\n        , fstrheat%q_vol_val (i)\n    enddo\n\n    write(ilog,*) '  q_suf_tot :', fstrheat%q_suf_tot\n    write(ilog,*) '      no./ eid/ sid/ amp/ q-surf '\n    do i = 1, fstrheat%q_suf_tot\n      ie = hecmesh%global_elem_id( fstrheat%q_suf_elem(i) )\n      write(ilog,'(2i10,2i5,1pe15.7)') i, ie, fstrheat%q_suf_surf(i)         &\n        , fstrheat%q_suf_ampl(i), fstrheat%q_suf_val (i)\n\n    enddo\n\n    write(ilog,*) '  h_suf_tot :', fstrheat%h_suf_tot\n    write(ilog,*) '      no./ eid/ sid/ h_amp/ t_amp/ hh/ sink/ '\n    do i = 1, fstrheat%h_suf_tot\n      ie = hecmesh%global_elem_id( fstrheat%h_suf_elem(i) )\n      write(ilog,'(2i10,3i5,1p2e15.7)') i, ie, fstrheat%h_suf_surf(i)        &\n        , fstrheat%h_suf_ampl(i,1), fstrheat%h_suf_ampl(i,2)       &\n        , fstrheat%h_suf_val (i,1), fstrheat%h_suf_val (i,2)\n    enddo\n\n    write(ilog,*) '  r_suf_tot :', fstrheat%r_suf_tot\n    write(ilog,*) '      no./ eid/ sid/ r_amp/ t_amp/ rr/ sink/ '\n    do i = 1, fstrheat%r_suf_tot\n      ie = hecmesh%global_elem_id( fstrheat%r_suf_elem(i) )\n      write(ilog,'(2i10,3i5,1p2e15.7)') i, ie, fstrheat%r_suf_surf(i)        &\n        , fstrheat%r_suf_ampl(i,1), fstrheat%r_suf_ampl(i,2)       &\n        , fstrheat%r_suf_val (i,1), fstrheat%r_suf_val (i,2)\n    enddo\n\n    !c +-------------------------------+\n    !c | amplitude                     |\n    !c +-------------------------------+\n\n    write(ilog,*)\n    write(ilog,*) '### amplitude'\n\n    write(ilog,*) ' amplitudetot  :', fstrheat%amplitudetot\n    do i = 1, fstrheat%amplitudetot\n      nn = fstrheat%ampltab(i)\n      write(ilog,'(2i5,a,a10)') i, nn,' : name=', hecmesh%amp%amp_name(i)\n\n      do j = 1, nn\n        time = fstrheat%ampltime(i,j)\n        val  = fstrheat%ampl    (i,j)\n        aa   = fstrheat%amplfunca(i,j)\n        bb   = fstrheat%amplfuncb(i,j)\n        write(ilog,'(i5,1p4e12.4)') j,time,val,aa,bb\n      enddo\n      aa   = fstrheat%amplfunca(i,nn+1)\n      bb   = fstrheat%amplfuncb(i,nn+1)\n      write(ilog,'(i5,1p4e12.4)') nn+1,time,val,aa,bb\n\n    enddo\n\n  end subroutine heat_echo\n"}
{"id": 236, "subroutine": "subroutine check(iexit)\n\n!-------------------------------------------------------------\n!\n! check the read input that includes the problem size,\n!  the angular quadrature, the boundary conditions, \n!  the iteration controls, the material map, and\n!  the spatial moments\n!\n!-------------------------------------------------------------\n\nuse invar\nuse totvar\nimplicit none\ninteger, intent(inout) :: iexit\ninteger :: n\nreal*8, dimension(apo) :: leng\n\n! before starting if constructs, set up ordinate lengths to make sure they're 1 or less\ndo n = 1, apo\n   leng(n) = sqrt(ang(n,1)*ang(n,1) + ang(n,2)*ang(n,2))\nend do\n\n! spatial moment order\nif (lambda < 0) then\n   write(8,'(/,3x,a)') \"error: illegal entry for lambda. must be zero or greater.\"\n   iexit = iexit + 1\n\n! method of solution\nelse if (meth /= 0 .and. meth /= 1) then\n   write(8,'(/,3x,a)') \"error: method value 'meth' must be 0 or 1.\"\n   iexit = iexit + 1\n\n! cell number of cells, groups, materials\nelse if (nxt < 1) then\n   write(8,'(/,3x,a)') \"error: illegal number of x cells. must be positive.\"\n   iexit = iexit + 1\nelse if (nyt < 1) then\n   write(8,'(/,3x,a)') \"error: illegal number of y cells. must be positive.\"\n   iexit = iexit + 1\nelse if (npx*npy /= isize) then\n   write(8,'(/,3x,a)') \"error: illegal number of p_i x p_j sub-domains.\"\n   iexit = iexit + 1\nelse if (ng < 1) then\n   write(8,'(/,3x,a)') \"error: illegal number of energy groups. must be positive.\"\n   iexit = iexit + 1\nelse if (nm < 1) then\n   write(8,'(/,3x,a)') \"error: illegal number of materials. must be positive.\"\n   iexit = iexit + 1\n   \n! cell sizes\nelse if (minval(dxt) <= 0.) then\n   write(8,'(/,3x,a)') \"error: illegal x cell dimension, dx. must be positive.\"\n   iexit = iexit + 1\nelse if (minval(dyt) <= 0.) then\n   write(8,'(/,3x,a)') \"error: illegal y cell dimension, dy. must be positive.\"\n   iexit = iexit + 1\n\n! material map\nelse if (minval(matt) < 1 .or. maxval(matt) > nm) then\n   write(8,'(/,3x,a)') \"error: illegal value in material map. must be in [1, #materials].\"\n   iexit = iexit + 1\n   \n! bcs\nelse if (q1bc /= 0 .and. q1bc /= 1) then\n   write(8,'(/,3x,a)') \"error: illegal q1 bc. must be 0-vac or 1-input.\"\n   iexit = iexit + 1\nelse if (q2bc /= 0 .and. q2bc /= 1) then\n   write(8,'(/,3x,a)') \"error: illegal q2 bc. must be 0-vac or 1-input.\"\n   iexit = iexit + 1\nelse if (q3bc /= 0 .and. q3bc /= 1) then\n   write(8,'(/,3x,a)') \"error: illegal q3 bc. must be 0-vac or 1-input.\"\n   iexit = iexit + 1\nelse if (q4bc /= 0 .and. q4bc /= 1) then\n   write(8,'(/,3x,a)') \"error: illegal q4 bc. must be 0-vac or 1-input.\"\n   iexit = iexit + 1\n\n! iteration control parameters\nelse if (err <= 0.) then\n   write(8,'(/,3x,a)') \"error: illegal convergence criterion. must be positive.\"\n   iexit = iexit + 1\nelse if (bitmx <= 0) then\n   write(8,'(/,3x,a)') \"error: illegal max pbj iterations, bitmx. must be positive.\"\n   iexit = iexit + 1\nelse if (itmx <= 0) then\n   write(8,'(/,3x,a)') \"error: illegal max inner iterations, itmx. must be positive.\"\n   iexit = iexit + 1\nelse if (tolr <= 0.) then\n   write(8,'(/,3x,a)') \"error: illegal tolerance setting, tolr. must be positive.\"\n   iexit = iexit + 1\nelse if (iall < 0 .or. iall > lambda) then\n   write(8,'(/,3x,a)') \"error: illegal value for moments to converge, iall. must be in [0, lambda].\"\n   iexit = iexit + 1\n\n! checks on the solution\nelse if (ichk < 0) then\n   write(8,'(/,3x,a)') \"error: illegal value for solution check flag, iall.\"\n   write(8,'(/,3x,a)') \"iall is 0 (skip check) or positive integer\"\n   iexit = iexit + 1\nelse if (tchk < 0.) then\n   write(8,'(/,3x,a)') \"error: illegal value for solution check tolerance, tchk. must be positive.\"\n   iexit = iexit + 1\n   \n! checks on the angular quadrature\nelse if (minval(ang) <= 0. .or. maxval(ang) >= 1.) then\n   write(8,'(/,3x,a)') \"error: illegal value for direction cosine. must be entered positive, less than 1.\"\n   iexit = iexit + 1\nelse if (minval(w) <= 0. .or. maxval(w) > 0.25) then\n   write(8,'(/,3x,a)') \"error: illegal value for weight. must be entered positive, less than 0.25.\"\n   iexit = iexit + 1\nelse if (maxval(leng) >= 1.) then\n   write(8,'(/,3x,a)') \"error: a discrete ordinate has length >= 1 based on mu, eta values.\"\n   iexit = iexit + 1\n\n! checks on the editing input\nelse if (momp < 0 .or. momp > lambda) then\n   write(8,'(/,3x,a)') \"error: illegal value for max moment to print, momp. must be between 0 and lambda.\"\n   iexit = iexit + 1\nelse if (pmoaf /= 0 .and. pmoaf /= 1 .and. pmoaf /= 2) then\n   write(8,'(/,3x,a)') \"error: illegal value for flag for printing outward angular flux at boundaries.\"\n   write(8,'(/,3x,a)') \"       must be 0/1/2 = none/zero moment only/all moments\"\n   iexit = iexit + 1\n\n! or there is nothing wrong, report that and continue\nelse\n   write(8,'(/,3x,a,//)') \"no input errors have been detected.\"\n\nend if\n   \n\nreturn\nend subroutine check\n"}
{"id": 237, "subroutine": "  subroutine user_mod_end_of_time_step(grid, n, time)\n!------------------------------------------------------------------------------!\n!   this function is called at the end of time step.                           !\n!------------------------------------------------------------------------------!\n!----------------------------------[modules]-----------------------------------!\n  use grid_mod\n!------------------------------------------------------------------------------!\n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  type(grid_type) :: grid\n  integer         :: n     ! time step\n  real            :: time  ! physical time\n!==============================================================================!\n\n  end subroutine\n"}
{"id": 238, "subroutine": "        subroutine echo(u)\n            real, dimension(:,:),intent(in) :: u\n            integer :: ix,iy\n\n            do iy=1,5\n                write(*,*) u(1:5,iy)\n            end do\n\n        end subroutine\n"}
{"id": 239, "subroutine": "      subroutine recoonescalar(ns,ja1,ja2,ja3,ja4,ka,iat)\n!                                                                  *\n!     -------------  section rec    subprogram 05  --------------  *\n!                                                                  *\n\n!                                                                  *\n!   written by  g. gaigalas                                        *\n!   transform to fortran 90/95 by g. gaigalas       december 2012  *\n!   the last modification made by g. gaigalas       october  2017  *\n!                                                                  *\n!*******************************************************************\n!\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      use m_c,          only: npeel, jlist, jjc1, jjc2, jjq1, jjq2\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(in)  :: ns, ja1, ja2, ja3, ja4, ka\n      integer, intent(out) :: iat\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: i, ia1, ia2, ij, ij1, ij2, j, npeelgg\n!-----------------------------------------------\n      iat=1\n      if(npeel == 1 .and. ns == -1)return\n      if(ns == -1) then\n         npeelgg = npeel\n      else\n         npeelgg = ns\n      end if\n      ij1=jlist(ja1)\n      ij2=jlist(ja2)\n      if(ja1 == 1.and.ja2 == 2) go to 1\n      if(ka /= 0)go to 5\n!\n!  cases when :          ka = 0\n!                  or    ja1 = ja2\n!                  or    ja1 = 1    ja2 = 2\n!\n    1 do i=1,npeelgg\n        ij=jlist(i)\n        if(i < npeelgg-1) then\n         if(jjc1(i) /= jjc2(i))iat=0\n        end if\n        if(ka /= 0) then\n          if(i == ja1) cycle\n          if(i == ja2) cycle\n        end if\n        do j=1,3\n          if(jjq1(j,ij) /= jjq2(j,ij))iat=0\n        end do\n      end do\n      return\n!\n!  other cases\n!\n    5 continue\n      do i=1,npeelgg\n        ij=jlist(i)\n        if(i < npeelgg-1) then\n          ia1=ja1-1\n          ia2=ja2-1\n          if(ja1 == 1)ia1=ja1\n          if(i >= ia1.and.i < ia2)go to 7\n          if(jjc1(i) /= jjc2(i))iat=0\n        end if\n    7   if(i == ja1) cycle\n        if(i == ja2) cycle\n        if((ka == 2).and.(i == ja3)) cycle\n        if((ka == 3).and.(i == ja3)) cycle\n        if((ka == 3).and.(i == ja4)) cycle\n        do j=1,3\n          if(jjq1(j,ij) /= jjq2(j,ij))iat=0\n        end do\n      end do\n      return\n      end subroutine recoonescalar\n"}
{"id": 240, "subroutine": "      subroutine fft0 (im)\n!@sum  fft0 initializes sines and cosines used by fft routines.\n!@auth gary russell\n!@ver  1.0\n      use fft36\n      implicit none\n      integer n !@var iq,n loop variables\n      integer, intent(in) :: im    !@var im size of arrays (must=km)\nc\n      if(im.ne.km)  go to 100\n      do n=1,km/4\n        s(n) = dsin(twopi*n/real(km,kind=8))\n      end do\n      do n=1,km/2-1\n        ch(n) = cos(twopi*n/real(2*km,kind=8))\n        sh(n) = sin(twopi*n/real(2*km,kind=8))\n      end do\n      return\n 100  write (6,*) ' this version of fft is for ',km,'. im =',im\n      call stop_model('stopped in fft36.f',255)\n      end subroutine fft0\n"}
{"id": 241, "subroutine": "      subroutine fft (f,a,b)\n!@sum   fft calculates fast fourier transform of an input array f\n!@auth  gary russell\n!@ver   1.0\n!@calls docalc\nc****\nc**** fft calculates a fast fourier transform of the input array\nc**** f, producing the cosine and sine coefficients in the output\nc**** arrays a and b.  f is dimensioned by 36 = km; a and b are\nc**** dimensioned 0:18.  upon entering fft, the total energy is:\nc****   .5*sum(f(k)**2)\nc**** with the sum being taken over all k from 1 to km.  the\nc**** fourier coefficients are defined by:\nc****   a(n)+i*b(n) = sum(f(k)*exp(-2*pi*i*n*k/km))/kmh\nc**** with the sum being taken over all k from 1 to km.  kmh = km\nc**** when n = 0 or km/2, and kmh = km/2 otherwise.  in the\nc**** program's notation, cpqn means:\nc****   cpqn = sum(f(k)*cos(2*pi*n*k/km))\nc**** with the sum being taken over all k = q mod(p).  spqn has a\nc**** similar definition, but cos is replaced by sin.  the notation\nc**** a=10, b=11, etc. is used for p, q and n.  the same total\nc**** energy can be calculated from the spectral coefficients as:\nc****   .5*sum(a(n)**2+b(n)**2)*kmh\nc**** with the sum being taken over all wave numbers n from 0 to km/2.\nc****\n      use fft36\n      implicit none\n      real*8, intent(in) :: f(km)      !@var f input gridpoint array\n      real*8, intent(out) :: a(0:km/2) !@var a fourier coeffs. (cos)\n      real*8, intent(out) :: b(0:km/2) !@var b fourier coeffs. (sin)\n\n      call docalc(f)\n\nc**** calculate final coefficients of fourier expansion\n      a(0)  = (c200+c210)*bykm\n      a(1)  = (c201+c211)*bykmh\n      a(2)  = (c202+c212)*bykmh\n      a(3)  = (c203+c213)*bykmh\n      a(4)  = (c204+c214)*bykmh\n      a(5)  = (c205+c215)*bykmh\n      a(6)  = (c206+c216)*bykmh\n      a(7)  = (c207+c217)*bykmh\n      a(8)  = (c208+c218)*bykmh\n      a(9)  = (c400-c420)*bykmh\n      a(10) = (c208-c218)*bykmh\n      a(11) = (c207-c217)*bykmh\n      a(12) = (c206-c216)*bykmh\n      a(13) = (c205-c215)*bykmh\n      a(14) = (c204-c214)*bykmh\n      a(15) = (c203-c213)*bykmh\n      a(16) = (c202-c212)*bykmh\n      a(17) = (c201-c211)*bykmh\n      a(18) = (c200-c210)*bykm\n      b(0)  = 0.\n      b(1)  = (s201+s211)*bykmh\n      b(2)  = (s202+s212)*bykmh\n      b(3)  = (s203+s213)*bykmh\n      b(4)  = (s204+s214)*bykmh\n      b(5)  = (s205+s215)*bykmh\n      b(6)  = (s206+s216)*bykmh\n      b(7)  = (s207+s217)*bykmh\n      b(8)  = (s208+s218)*bykmh\n      b(9)  = (c410-c430)*bykmh\n      b(10) = (s218-s208)*bykmh\n      b(11) = (s217-s207)*bykmh\n      b(12) = (s216-s206)*bykmh\n      b(13) = (s215-s205)*bykmh\n      b(14) = (s214-s204)*bykmh\n      b(15) = (s213-s203)*bykmh\n      b(16) = (s212-s202)*bykmh\n      b(17) = (s211-s201)*bykmh\n      b(18) = 0.\nc****\n      return\n      end subroutine fft\n"}
{"id": 242, "subroutine": "      subroutine ffti (a,b,f)\n!@sum  ffti performs an inverse fast fourier transform\n!@auth gary russell\n!@ver  1.0 (km=36)\n      use fft36\n      implicit none\n      real*8, intent(out) :: f(km)     !@var f output gridpoint array\n      real*8, intent(in) :: a(0:km/2)  !@var a fourier coeffs. (cos)\n      real*8, intent(in) :: b(0:km/2)  !@var b fourier coeffs. (sin)\n\nc     s200 = 0\n      s201 = b(1)-b(17)\n      s211 = b(1)+b(17)\n      s202 = b(2)-b(16)\n      s212 = b(2)+b(16)\n      s203 = b(3)-b(15)\n      s213 = b(3)+b(15)\n      s204 = b(4)-b(14)\n      s214 = b(4)+b(14)\n      s205 = b(5)-b(13)\n      s215 = b(5)+b(13)\n      s206 = b(6)-b(12)\n      s216 = b(6)+b(12)\n      s207 = b(7)-b(11)\n      s217 = b(7)+b(11)\n      s208 = b(8)-b(10)\n      s218 = b(8)+b(10)\nc     s210 = 0\n      s219 = b(9)*2.\n\n      c200 =(a(0)+a(18))*2.\n      c210 =(a(0)-a(18))*2.\n      c201 = a(1)+a(17)\n      c211 = a(1)-a(17)\n      c202 = a(2)+a(16)\n      c212 = a(2)-a(16)\n      c203 = a(3)+a(15)\n      c213 = a(3)-a(15)\n      c204 = a(4)+a(14)\n      c214 = a(4)-a(14)\n      c205 = a(5)+a(13)\n      c215 = a(5)-a(13)\n      c206 = a(6)+a(12)\n      c216 = a(6)-a(12)\n      c207 = a(7)+a(11)\n      c217 = a(7)-a(11)\n      c208 = a(8)+a(10)\n      c218 = a(8)-a(10)\n      c209 = a(9)*2.\n\n      s401 = s201-s208\n      s421 = s201+s208\n      s402 = s202-s207\n      s422 = s202+s207\n      s403 = s203-s206\n      s423 = s203+s206\n      s404 = s204-s205\n      s424 = s204+s205\n      s411 = s211+c218\n      s431 = s211-c218\n      s412 = s212+c217\n      s432 = s212-c217\n      s413 = s213+c216\n      s433 = s213-c216\n      s414 = s214+c215\n      s434 = s214-c215\n\n      c400 = c200+c209\n      c420 = c200-c209\n      c401 = c201+c208\n      c421 = c201-c208\n      c402 = c202+c207\n      c422 = c202-c207\n      c403 = c203+c206\n      c423 = c203-c206\n      c404 = c204+c205\n      c424 = c204-c205\n      c410 = c210+s219\n      c430 = c210-s219\n      c411 = c211+s218\n      c431 = c211-s218\n      c412 = c212+s217\n      c432 = c212-s217\n      c413 = c213+s216\n      c433 = c213-s216\n      c414 = c214+s215\n      c434 = c214-s215\nc factor here = 9/2\n      cc00 =  c400+c403*2.\n      cc40 =  c400-c403+s403*rt3\n      cc80 =  c400-c403-s403*rt3\n      cc90 =  c410-s413*2.\n      cc10 =  c410+s413+c413*rt3\n      cc50 =  c410+s413-c413*rt3\n      cc60 =  c420-c423*2.\n      cc20 =  c420+c423+s423*rt3\n      cca0 =  c420+c423-s423*rt3\n      cc30 =  c430+s433*2.\n      cc70 =  c430-s433-c433*rt3\n      ccb0 =  c430-s433+c433*rt3\n      cc01 =   c402+c404+c401\n      sc01 =  -s402+s404+s401\n      sc41 =  (s402-s404)*s(3)+(c402-c404)*s(6)+s401\n      sc81 =  (s402-s404)*s(3)-(c402-c404)*s(6)+s401\n      cc41 = -(c402+c404)*s(3)+(s402+s404)*s(6)+c401\n      cc81 = -(c402+c404)*s(3)-(s402+s404)*s(6)+c401\n      cc61 = -(c424+c422)+c421\n      sc61 = -(s424-s422)+s421\n      cc21 =  (c424+c422)*s(3)+(s424+s422)*s(6)+c421\n      cca1 =  (c424+c422)*s(3)-(s424+s422)*s(6)+c421\n      sc21 =  (s424-s422)*s(3)-(c424-c422)*s(6)+s421\n      sca1 =  (s424-s422)*s(3)+(c424-c422)*s(6)+s421\n      cc91 =   c411-s412-s414\n      sc91 =   s411-c412+c414\n      cc11 =  (s412+s414)*s(3)+(c412+c414)*s(6)+c411\n      cc51 =  (s412+s414)*s(3)-(c412+c414)*s(6)+c411\n      sc11 =  (c412-c414)*s(3)-(s412-s414)*s(6)+s411\n      sc51 =  (c412-c414)*s(3)+(s412-s414)*s(6)+s411\n      cc31 =   s432+s434+c431\n      sc31 =   c432-c434+s431\n      sc71 = -(c432-c434)*s(3)+(s432-s434)*s(6)+s431\n      scb1 = -(c432-c434)*s(3)-(s432-s434)*s(6)+s431\n      cc71 = -(s432+s434)*s(3)-(c432+c434)*s(6)+c431\n      ccb1 = -(s432+s434)*s(3)+(c432+c434)*s(6)+c431\n\nc factor here =(1/3)*(9/2)=3/2 (km/24)\n      f(36) =  cc00*s(3)+cc01\n      f(35) =  ccb0*s(3)-scb1*s(1)+ccb1*s(8)\n      f(34) =  cca0*s(3)-sca1*s(2)+cca1*s(7)\n      f(33) = (cc90-sc91)*s(3)+cc91*s(6)\n      f(32) =  cc80*s(3)-sc81*s(4)+cc81*s(5)\n      f(31) =  cc70*s(3)-sc71*s(5)+cc71*s(4)\n      f(30) = (cc60+cc61)*s(3)-sc61*s(6)\n      f(29) =  cc50*s(3)-sc51*s(7)+cc51*s(2)\n      f(28) =  cc40*s(3)-sc41*s(8)+cc41*s(1)\n      f(27) =  cc30*s(3)-sc31\n      f(26) =  cc20*s(3)-sc21*s(8)-cc21*s(1)\n      f(25) =  cc10*s(3)-sc11*s(7)-cc11*s(2)\n      f(24) = (cc00-cc01)*s(3)-sc01*s(6)\n      f(23) =  ccb0*s(3)-ccb1*s(4)-scb1*s(5)\n      f(22) =  cca0*s(3)-cca1*s(5)-sca1*s(4)\n      f(21) = (cc90-sc91)*s(3)-cc91*s(6)\n      f(20) =  cc80*s(3)-cc81*s(7)-sc81*s(2)\n      f(19) =  cc70*s(3)-cc71*s(8)-sc71*s(1)\n      f(18) =  cc60*s(3)-cc61\n      f(17) =  cc50*s(3)-cc51*s(8)+sc51*s(1)\n      f(16) =  cc40*s(3)-cc41*s(7)+sc41*s(2)\n      f(15) = (cc30+sc31)*s(3)-cc31*s(6)\n      f(14) =  cc20*s(3)-cc21*s(5)+sc21*s(4)\n      f(13) =  cc10*s(3)-cc11*s(4)+sc11*s(5)\n      f(12) =  1.5*cc00-f(24)-f(36)\n      f(11) =  1.5*ccb0-f(23)-f(35)\n      f(10) =  1.5*cca0-f(22)-f(34)\n      f( 9) =  1.5*cc90-f(21)-f(33)\n      f( 8) =  1.5*cc80-f(20)-f(32)\n      f( 7) =  1.5*cc70-f(19)-f(31)\n      f( 6) =  1.5*cc60-f(18)-f(30)\n      f( 5) =  1.5*cc50-f(17)-f(29)\n      f( 4) =  1.5*cc40-f(16)-f(28)\n      f( 3) =  1.5*cc30-f(15)-f(27)\n      f( 2) =  1.5*cc20-f(14)-f(26)\n      f( 1) =  1.5*cc10-f(13)-f(25)\nc****\n      return\n      end subroutine ffti\n"}
{"id": 243, "subroutine": "      subroutine ffte (f,e)\n!@sum   ffte calcs. the spectral energy e from input gridpoint values f\n!@auth  gary russell\n!@ver   1.0\n!@calls docalc\n      use fft36\n      implicit none\n      real*8, intent(in) :: f(km)       !@var f input gridpoint array\n      real*8, intent(out) :: e(0:km/2)  !@var e spectral energy\n\n      call docalc(f)\nc****\n      e(0)  =  (c200+c210)*(c200+c210)*bykm2\n      e(1)  = ((c201+c211)*(c201+c211)+(s201+s211)*(s201+s211))*bykm\n      e(2)  = ((c202+c212)*(c202+c212)+(s202+s212)*(s202+s212))*bykm\n      e(3)  = ((c203+c213)*(c203+c213)+(s203+s213)*(s203+s213))*bykm\n      e(4)  = ((c204+c214)*(c204+c214)+(s204+s214)*(s204+s214))*bykm\n      e(5)  = ((c205+c215)*(c205+c215)+(s205+s215)*(s205+s215))*bykm\n      e(6)  = ((c206+c216)*(c206+c216)+(s206+s216)*(s206+s216))*bykm\n      e(7)  = ((c207+c217)*(c207+c217)+(s207+s217)*(s207+s217))*bykm\n      e(8)  = ((c208+c218)*(c208+c218)+(s208+s218)*(s208+s218))*bykm\n      e(9)  = ((c400-c420)*(c400-c420)+(c410-c430)*(c410-c430))*bykm\n      e(10) = ((c208-c218)*(c208-c218)+(s218-s208)*(s218-s208))*bykm\n      e(11) = ((c207-c217)*(c207-c217)+(s217-s207)*(s217-s207))*bykm\n      e(12) = ((c206-c216)*(c206-c216)+(s216-s206)*(s216-s206))*bykm\n      e(13) = ((c205-c215)*(c205-c215)+(s215-s205)*(s215-s205))*bykm\n      e(14) = ((c204-c214)*(c204-c214)+(s214-s204)*(s214-s204))*bykm\n      e(15) = ((c203-c213)*(c203-c213)+(s213-s203)*(s213-s203))*bykm\n      e(16) = ((c202-c212)*(c202-c212)+(s212-s202)*(s212-s202))*bykm\n      e(17) = ((c201-c211)*(c201-c211)+(s211-s201)*(s211-s201))*bykm\n      e(18) =  (c200-c210)*(c200-c210)*bykm2\nc****\n      return\n      end subroutine ffte\n"}
{"id": 244, "subroutine": "      subroutine fft2 (f,a,b)   \n!@sum   fft2 calculates fourier coefficients on secondary grid\n!@auth  gary russell\n!@ver   1.0\n!@calls fft\nc****\nc**** values in f(k) are located a half space right of those in fft.\nc****\n      use fft36\n      implicit none\n      real*8, intent(in) :: f(km)      !@var input array\n      real*8, intent(out) :: a(0:km/2) !@var fourier coefficients (cos)\n      real*8, intent(out) :: b(0:km/2) !@var fourier coefficients (sin)\n      real*8  anew  !@var  anew  dummy variable\n      integer n !@var n loop variable\n\n      call fft (f,a,b)\n      do n=1,km/2-1\n        anew = a(n)*ch(n)-b(n)*sh(n)\n        b(n) = a(n)*sh(n)+b(n)*ch(n)\n        a(n) = anew\n      end do\n      b(km/2) = a(km/2)\n      a(km/2) = 0.\n      return\n      end subroutine fft2\n"}
{"id": 245, "subroutine": "      subroutine docalc(f)\n!@sum  docalc calculate intermediate expressions for fft\n!@auth gary russell\n!@ver  1.0 (km=36)\n      use fft36\n      implicit none\n      real*8, intent(in) :: f(km) !@var f input grid point array\n\nc**** calculate expressions summed by increments of 12\n      cc00 = f(36)+f(12)+f(24)\n      cc10 = f(1)+f(13)+f(25)\n      cc20 = f(2)+f(14)+f(26)\n      cc30 = f(3)+f(15)+f(27)\n      cc40 = f(4)+f(16)+f(28)\n      cc50 = f(5)+f(17)+f(29)\n      cc60 = f(6)+f(18)+f(30)\n      cc70 = f(7)+f(19)+f(31)\n      cc80 = f(8)+f(20)+f(32)\n      cc90 = f(9)+f(21)+f(33)\n      cca0 = f(10)+f(22)+f(34)\n      ccb0 = f(11)+f(23)+f(35)\n      cc01 = f(36)-(f(12)+f(24))*s(3)\n      cc11 = f(1)*s(8)-f(13)*s(4)-f(25)*s(2)\n      cc21 = f(2)*s(7)-f(14)*s(5)-f(26)*s(1)\n      cc31 = (f(3)-f(15))*s(6)\n      cc41 = f(4)*s(5)-f(16)*s(7)+f(28)*s(1)\n      cc51 = f(5)*s(4)-f(17)*s(8)+f(29)*s(2)\n      cc61 = (f(6)+f(30))*s(3)-f(18)\n      cc71 = f(7)*s(2)-f(19)*s(8)+f(31)*s(4)\n      cc81 = f(8)*s(1)-f(20)*s(7)+f(32)*s(5)\n      cc91 = (f(33)-f(21))*s(6)\n      cca1 = f(34)*s(7)-f(10)*s(1)-f(22)*s(5)\n      ccb1 = f(35)*s(8)-f(11)*s(2)-f(23)*s(4)\n      sc01 = (f(12)-f(24))*s(6)\n      sc11 = f(1)*s(1)+f(13)*s(5)-f(25)*s(7)\n      sc21 = f(2)*s(2)+f(14)*s(4)-f(26)*s(8)\n      sc31 = (f(3)+f(15))*s(3)-f(27)\n      sc41 = f(4)*s(4)+f(16)*s(2)-f(28)*s(8)\n      sc51 = f(5)*s(5)+f(17)*s(1)-f(29)*s(7)\n      sc61 = (f(6)-f(30))*s(6)\n      sc71 = f(7)*s(7)-f(19)*s(1)-f(31)*s(5)\n      sc81 = f(8)*s(8)-f(20)*s(2)-f(32)*s(4)\n      sc91 = f(9)-(f(21)+f(33))*s(3)\n      sca1 = f(10)*s(8)-f(22)*s(4)-f(34)*s(2)\n      scb1 = f(11)*s(7)-f(23)*s(5)-f(35)*s(1)\nc**** calculate expressions summed by increments of 4\n      c400 = cc00+cc40+cc80\n      c410 = cc10+cc50+cc90\n      c420 = cc20+cc60+cca0\n      c430 = cc30+cc70+ccb0\n      c401 = cc01+cc41+cc81\n      c411 = cc11+cc51+cc91\n      c421 = cc21+cc61+cca1\n      c431 = cc31+cc71+ccb1\n      c402 = (cc01-(cc41+cc81)*s(3))+(sc41-sc81)*s(6)\n      c412 = (cc11-cc51)*s(6)+((sc11+sc51)*s(3)-sc91)\n      c422 = ((cc21+cca1)*s(3)-cc61)+(sc21-sca1)*s(6)\n      c432 = (ccb1-cc71)*s(6)+(sc31-(sc71+scb1)*s(3))\n      c403 = cc00-(cc40+cc80)*s(3)\n      c413 = (cc10-cc50)*s(6)\n      c423 = (cc20+cca0)*s(3)-cc60\n      c433 = (ccb0-cc70)*s(6)\n      c404 = (cc01-(cc41+cc81)*s(3))-(sc41-sc81)*s(6)\n      c414 = (cc11-cc51)*s(6)-((sc11+sc51)*s(3)-sc91)\n      c424 = ((cc21+cca1)*s(3)-cc61)-(sc21-sca1)*s(6)\n      c434 = (ccb1-cc71)*s(6)-(sc31-(sc71+scb1)*s(3))\n      s401 = sc01+sc41+sc81\n      s411 = sc11+sc51+sc91\n      s421 = sc21+sc61+sca1\n      s431 = sc31+sc71+scb1\n      s402 = ((cc41-cc81)*s(6))+((sc41+sc81)*s(3)-sc01)\n      s412 = ((cc11+cc51)*s(3)-cc91)+((sc51-sc11)*s(6))\n      s422 = ((cc21-cca1)*s(6))+(sc61-(sc21+sca1)*s(3))\n      s432 = (cc31-(cc71+ccb1)*s(3))+((sc71-scb1)*s(6))\n      s403 = (cc40-cc80)*s(6)\n      s413 = (cc10+cc50)*s(3)-cc90\n      s423 = (cc20-cca0)*s(6)\n      s433 = cc30-(cc70+ccb0)*s(3)\n      s404 = (cc41-cc81)*s(6)-((sc41+sc81)*s(3)-sc01)\n      s414 = ((cc11+cc51)*s(3)-cc91)-(sc51-sc11)*s(6)\n      s424 = (cc21-cca1)*s(6)-(sc61-(sc21+sca1)*s(3))\n      s434 = (cc31-(cc71+ccb1)*s(3))-(sc71-scb1)*s(6)\nc**** calculate expressions summed by increments of 2\n      c200 = c400+c420\n      c210 = c410+c430\n      c201 = c401+c421\n      c211 = c411+c431\n      c202 = c402+c422\n      c212 = c412+c432\n      c203 = c403+c423\n      c213 = c413+c433\n      c204 = c404+c424\n      c214 = c414+c434\n      c205 = c404-c424\n      c215 = s414-s434\n      c206 = c403-c423\n      c216 = s413-s433\n      c207 = c402-c422\n      c217 = s412-s432\n      c208 = c401-c421\n      c218 = s411-s431\nc     c209 = c400-c420\nc     c219 = 0.\nc     s200 = 0.\nc     s210 = 0.\n      s201 = s401+s421\n      s211 = s411+s431\n      s202 = s402+s422\n      s212 = s412+s432\n      s203 = s403+s423\n      s213 = s413+s433\n      s204 = s404+s424\n      s214 = s414+s434\n      s205 = s424-s404\n      s215 = c414-c434\n      s206 = s423-s403\n      s216 = c413-c433\n      s207 = s422-s402\n      s217 = c412-c432\n      s208 = s421-s401\n      s218 = c411-c431\nc     s209 = 0.\nc     s219 = c410-c430\nc****\n      return\n      end subroutine docalc\n"}
{"id": 246, "subroutine": "subroutine simplegrid_dimens(griddim,nmax,mmax,aggrtable)\n!!--description-----------------------------------------------------------------\n!\n! initializes a griddim structure for a simple (1,nmax) and (1,mmax) grid\n!\n!!--declarations----------------------------------------------------------------\n    implicit none\n!\n! call variables\n!\n    type (griddimtype)        :: griddim\n    integer                   :: nmax\n    integer                   :: mmax\n    integer, dimension(:,:), pointer, optional :: aggrtable\n!\n! local variables\n!\n    integer                   :: istat\n!\n!! executable statements -------------------------------------------------------\n!\n    griddim%nlb    = 1\n    griddim%nub    = nmax\n    griddim%nmax   = nmax\n    !\n    griddim%mlb    = 1\n    griddim%mub    = mmax\n    griddim%mmax   = mmax\n    !\n    griddim%nmlb   = 1\n    griddim%nmub   = nmax*mmax\n    griddim%nmmax  = nmax*mmax\n    !\n    griddim%nfg    = 1\n    griddim%nlg    = nmax\n    griddim%nmaxgl = nmax\n    !\n    griddim%mfg    = 1\n    griddim%mlg    = mmax\n    griddim%mmaxgl = mmax\n    !\n    if (present(aggrtable)) then\n       griddim%aggrtable => aggrtable\n    else\n       griddim%aggrtable => null()\n    endif\n    !\n    allocate(griddim%celltype(griddim%nmmax), stat=istat)\n    if (istat==0) griddim%celltype = 1\n    griddim%nmbnd => null()\nend subroutine simplegrid_dimens\n"}
{"id": 247, "subroutine": "      subroutine dracah(i, j, k, l, m, n, rac)\n!                                                                      *\n\n!   k, l, m, n should be twice their actual value. works for integer   *\n!   and  half-integer  values of  angular momenta. the routine makes   *\n\n!   fore this routine is used.                                         *\n!                                                                      *\n!   written by n s scott                    last update: 16 oct 1992   *\n!   the last modification made by g. gaigalas           october 2017   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  07:27:24   2/14/04\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      use vast_kind_param, only:  double\n      use facts_c\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(in) :: i\n      integer , intent(in) :: j\n      integer , intent(in) :: k\n      integer , intent(in) :: l\n      integer , intent(in) :: m\n      integer , intent(in) :: n\n      real(double) , intent(out) :: rac\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: j1, j2, j3, j4, j5, j6, j7, numin, numax, icount, kk, ki\n!-----------------------------------------------\n      j1 = i + j + m\n      j2 = k + l + m\n      j3 = i + k + n\n      j4 = j + l + n\n      if (2*max(max(i,j),m) - j1>0 .or. mod(j1,2)/=0) go to 2\n      if (2*max(max(k,l),m) - j2>0 .or. mod(j2,2)/=0) go to 2\n      if (2*max(max(i,k),n) - j3>0 .or. mod(j3,2)/=0) go to 2\n      if (2*max(max(j,l),n) - j4>0 .or. mod(j4,2)/=0) go to 2\n      go to 1\n    2 continue\n      rac = 0.0d00\n      return\n!\n    1 continue\n      j1 = j1/2\n      j2 = j2/2\n      j3 = j3/2\n      j4 = j4/2\n      j5 = (i + j + k + l)/2\n      j6 = (i + l + m + n)/2\n      j7 = (j + k + m + n)/2\n      numin = max(max(max(j1,j2),j3),j4) + 1\n      numax = min(min(j5,j6),j7) + 1\n      rac = 1.0d00\n      icount = 0\n!\n      if (numin /= numax) then\n         numin = numin + 1\n!\n         do kk = numin, numax\n            ki = numax - icount\n            rac = 1.0d00 - rac*dble(ki*(j5 - ki + 2)*(j6 - ki + 2)*(j7 - ki + 2&\n               ))/dble((ki - 1 - j1)*(ki - 1 - j2)*(ki - 1 - j3)*(ki - 1 - j4))\n            icount = icount + 1\n         end do\n!\n         numin = numin - 1\n      endif\n      rac = rac*(-1.0d00)**(j5 + numin + 1)*exp((gam(numin+1)-gam(numin-j1)-gam&\n         (numin-j2)-gam(numin-j3)-gam(numin-j4)-gam(j5+2-numin)-gam(j6+2-numin)&\n         -gam(j7+2-numin))+(gam(j1+1-i)+gam(j1+1-j)+gam(j1+1-m)-gam(j1+2)+gam(&\n         j2+1-k)+gam(j2+1-l)+gam(j2+1-m)-gam(j2+2)+gam(j3+1-i)+gam(j3+1-k)+gam(&\n         j3+1-n)-gam(j3+2)+gam(j4+1-j)+gam(j4+1-l)+gam(j4+1-n)-gam(j4+2))*&\n         0.5d00)\n!\n      return\n      end subroutine dracah\n"}
{"id": 248, "subroutine": "      subroutine setrealvaluefromdictionary( valuetoset, sourcedict, key, &\n                                             errorlevel, message, poster)  \n         implicit none\n!\n!        ---------\n!        arguments\n!        ---------\n!\n         real(kind=rp)                :: valuetoset\n         class(ftvaluedictionary)     :: sourcedict\n         integer, intent(in)          :: errorlevel\n         character(len=*), intent(in) :: key\n         character(len=*)             :: message, poster\n!\n         \n         if( sourcedict % containskey(key) )     then\n            valuetoset = sourcedict % doubleprecisionvalueforkey(key)\n         else\n            call throwerrorexceptionoftype(poster = poster,  &\n                                           msg    = message, &\n                                           typ    = errorlevel)\n         end if \n         \n      end subroutine setrealvaluefromdictionary\n"}
{"id": 249, "subroutine": "      subroutine setrealarrayvaluefromdictionary( arraytoset, sourcedict, key, &\n                                                  errorlevel, message, poster)  \n         implicit none\n!\n!        ---------\n!        arguments\n!        ---------\n!\n         real(kind=rp)                :: arraytoset(3)\n         class(ftvaluedictionary)     :: sourcedict\n         integer, intent(in)          :: errorlevel\n         character(len=*), intent(in) :: key\n         character(len=*)             :: message, poster\n!\n!        ----------\n!        interfaces\n!        ----------\n!\n         interface\n            function getrealarray( inputline ) result(x)\n               use smconstants\n               implicit none\n               real(kind=rp), dimension(3) :: x\n               character ( len = * ) :: inputline\n            end function getrealarray\n         end interface\n!\n!        ---------------\n!        local variables\n!        ---------------\n!\n         character(len= default_character_length) :: str\n!\n         if( sourcedict % containskey(key) )     then\n            str = sourcedict % stringvalueforkey(key = key,  &\n                                                 requestedlength = default_character_length)\n            arraytoset = getrealarray( str )\n         else \n            call throwerrorexceptionoftype(poster = poster,  &\n                                           msg    = message, &\n                                           typ    = errorlevel)\n         end if\n         \n      end subroutine setrealarrayvaluefromdictionary\n"}
{"id": 250, "subroutine": "  subroutine write_vector(vector, name, unit)\n    implicit none\n    real(wp), intent(in) :: vector(:)\n    character(len=*), intent(in), optional :: name\n    integer, intent(in), optional :: unit\n    integer :: d\n    integer :: j, iunit\n    ! integer :: i, j, k, l, istep\n\n    d = size(vector, dim=1)\n\n    if (present(unit)) then\n      iunit = unit\n    else\n      iunit = output_unit\n    end if\n\n    if (present(name)) write (iunit, '(/,\"vector printed:\",1x,a)') name\n\n    do j = 1, d\n      write (iunit, '(i6)', advance='no') j\n      write (iunit, '(1x,f15.8)', advance='no') vector(j)\n      write (iunit, '(a)')\n    end do\n\n  end subroutine write_vector\n"}
{"id": 251, "subroutine": "  subroutine write_2d_matrix(matrix, name, unit, step)\n    implicit none\n    real(wp), intent(in) :: matrix(:, :)\n    character(len=*), intent(in), optional :: name\n    integer, intent(in), optional :: unit\n    integer, intent(in), optional :: step\n    integer :: d1, d2\n    integer :: i, j, k, l, istep, iunit\n\n    d1 = size(matrix, dim=1)\n    d2 = size(matrix, dim=2)\n\n    if (present(unit)) then\n      iunit = unit\n    else\n      iunit = output_unit\n    end if\n\n    if (present(step)) then\n      istep = step\n    else\n      istep = 6\n    end if\n\n    if (present(name)) write (iunit, '(/,\"matrix printed:\",1x,a)') name\n\n    do i = 1, d2, istep\n      l = min(i + istep - 1, d2)\n      write (iunit, '(/,6x)', advance='no')\n      do k = i, l\n        write (iunit, '(6x,i7,3x)', advance='no') k\n      end do\n      write (iunit, '(a)')\n      do j = 1, d1\n        write (iunit, '(i6)', advance='no') j\n        do k = i, l\n          write (iunit, '(1x,f15.8)', advance='no') matrix(j, k)\n        end do\n        write (iunit, '(a)')\n      end do\n    end do\n\n  end subroutine write_2d_matrix\n"}
{"id": 252, "subroutine": "      subroutine bd_rspline ( card, large_fld_inp )\n  \n! processes rspline bulk data cards. writes rspline card data to file l1f. note that this code only recognizes 2 indep grids on a\n! given rspline unlike nastran (thus user must enter a different rspline for each pair of indep grids between which the cubic\n! spline will be fitted to all of the dep grid/comps\n \n      use pentium_ii_kind, only       :  byte, long, double\n      use iount1, only                :  wrt_err, wrt_log, err, f04, f06, l1f\n      use scontr, only                :  blnk_sub_nam, fatal_err, ierrfl, jcard_len, jf, mrspline, nrspline, nrecard, nrigel\n      use timdat, only                :  tsec\n      use subr_begend_levels, only    :  bd_rspline_begend\n      use model_stuf, only            :  rigid_elem_ids\n \n      use bd_rspline_use_ifs\n\n      implicit none\n \n      character(len=len(blnk_sub_nam)):: subr_name = 'bd_rspline'\n      character(len=*), intent(inout) :: card              ! a bulk data card\n      character(len=*), intent(in)    :: large_fld_inp     ! if 'y', card is large field format\n      character(len(card))            :: child             ! \"child\" card read in subr nextc, called herein\n      character(len=jcard_len)        :: jcard(10)         ! the 10 fields of characters making up card\n      character(len(jcard))           :: chrinp            ! a character field returned from subr ip6chk\n      character( 1*byte)              :: err_1158_written  ! indicator of whether fatal error #1158 has been written\n\n      character(len(jcard))           :: flds_c(mrspline+1)! char array of all fields on this entry that have grid or comp vals.\n!                                                            it will have igrid1, then pairs of dgrid(i)/comp(i), then igrid2.\n\n      character(len(jcard))           :: id                ! char value for element id in field 2 of parent entry\n      character( 8*byte)              :: ip6typ            ! descriptor of what is in the 8 char field sent to subr ip6chk\n      character(len(jcard))           :: name              ! jcard(1) from parent entry\n      character( 8*byte), parameter   :: rtype = 'rspline '! rigid element type\n \n      integer(long)                   :: dcomp(mrspline+1) ! array of dep displ comp values (1-6) found on this logical rspline card\n      integer(long)                   :: dgrid(mrspline+1) ! array of dep grid id's found on this logical rspline card\n\n      integer(long)                   :: flds_i(mrspline+1)! integer array of all fields on this entry that have grid or comp vals.\n!                                                            it will have igrid1, then pairs of dgrid(i)/comp(i), then igrid2.\n\n      integer(long)                   :: flds_f(mrspline+1)! field number on the rspline entry where a value exists (parent or cont)\n      integer(long)                   :: i4inp     = 0     ! a value read from input file that should be an integer value\n      integer(long)                   :: j                 ! do loop index\n      integer(long)                   :: igrid1,igrid2     ! the 2 independent grids on the rspline entry\n      integer(long)                   :: icont     = 0     ! indicator of whether a cont card exists. output from subr nextc\n      integer(long)                   :: ierr      = 0     ! error indicator returned from subr nextc called herein\n      integer(long)                   :: jerr      = 0     ! a local error count\n      integer(long)                   :: je                ! an intermediale variable  \n      integer(long)                   :: num_dependents    ! count of number of pairs of dependent grids/components\n      integer(long)                   :: num_entries       ! count of number of entries placed into array gc_flds\n      integer(long)                   :: num_ci            ! number of displ components in a dcomp field\n      integer(long)                   :: elid      = 0     ! this elements' id\n      integer(long), parameter        :: subr_begend = bd_rspline_begend\n \n      real(double)                    :: dl_rat            ! value in field 3 for d/l ratio\n      real(double)                    :: r8inp             ! a real value read from a field on this rspline entry\n \n! **********************************************************************************************************************************\n      if (wrt_log >= subr_begend) then\n         call ourtim\n         write(f04,9001) subr_name,tsec\n 9001    format(1x,a,' begn ',f10.3)\n      endif\n\n! **********************************************************************************************************************************\n! rspline bulk data card:\n \n!   field   item            explanation \n!   -----   ------------    -------------\n!    2      elid            rspline elem id\n!    3      d/l             diam/length ratio of the rod used in determining the beam deflection relationship\n!    4      g1              indep grid at one end of the rspline line\n!    5-9    gi,ci           dep grid/comps (dep grid/comps)\n\n! on optional continuation entries:\n!    2-9    contain either a grid or comp number. to be conservative each cont entry will be assumed to have an 8 dep entries\n\n! subsequent entries have the same format.\n \n      jerr = 0\n\n! initialize arrays\n\n      igrid1 = 0\n      igrid2 = 0\n      do j=1,mrspline+1\n         dgrid(j)      = 0\n         dcomp(j)      = 0\n         flds_i(j)     = 0\n         flds_f(j)     = 0\n         flds_c(j)(1:) = ' '\n      enddo\n \n! make jcard from card\n \n      call mkjcard ( subr_name, card, jcard )\n      name = jcard(1)\n      id   = jcard(2)\n \n! up the elem count\n\n      nrspline = nrspline + 1\n      nrigel   = nrigel+1\n \n! read and check data on parent entry\n \n      call i4fld ( jcard(2), jf(2), i4inp )                ! field 2: elem id\n      if (ierrfl(2) == 'n') then\n         elid                   = i4inp\n         rigid_elem_ids(nrigel) = elid\n      else\n         jerr = jerr + 1\n      endif\n\n      call r8fld ( jcard(3), jf(3), r8inp )                ! field 3: dl_rat\n      if (ierrfl(3) == 'n') then\n         dl_rat = r8inp\n      else\n         jerr = jerr + 1\n      endif\n\n      num_entries = 0                                      ! fields 4-9\n      do j=4,9\n         call i4fld ( jcard(j), jf(j), i4inp )\n         if (ierrfl(j) == 'n') then\n            num_entries = num_entries + 1\n            if (num_entries > mrspline + 1) call array_size_error_1 ( subr_name, num_entries, 'flds arrays' )\n            flds_i(num_entries) = i4inp\n            flds_c(num_entries) = jcard(j)\n            flds_f(num_entries) = jf(j)\n         else\n            jerr = jerr + 1\n         endif\n      enddo\n            \n      call bd_imbedded_blank ( jcard,2,3,4,5,6,7,8,9 )     ! make sure there are no imbedded blanks\n      call crderr ( card )                                 ! crderr prints errors found when reading fields\n\n! read and check data on optional continuation entries\n\ndo_1: do\n         if (large_fld_inp == 'n') then\n            call nextc  ( card, icont, ierr )\n         else\n            call nextc2 ( card, icont, ierr, child )\n            card = child\n         endif\n         if (icont == 1) then\n            call mkjcard ( subr_name, card, jcard )\n            do j=2,9\n               call i4fld ( jcard(j), jf(j), i4inp )\n               if (ierrfl(j) == 'n') then\n                  num_entries = num_entries + 1\n                  if (num_entries > mrspline + 1) call array_size_error_1 ( subr_name, num_entries, 'flds arrays' )\n                  flds_i(num_entries) = i4inp\n                  flds_c(num_entries) = jcard(j)\n                  flds_f(num_entries) = jf(j)\n               else\n                  jerr = jerr + 1\n               endif\n            enddo\n            call bd_imbedded_blank ( jcard,2,3,4,5,6,7,8,9 )\n            call crderr ( card )\n         else\n            exit do_1\n         endif\n      enddo do_1\n                  \n! flds_i may have some number of 0 entries at the end which should not be counted in num_entries.\n! scan flds_i (from end to begining) to find where last nonzero entry exists. this value is the one we want for num_entries\n\n      je = num_entries\n      do j=je,1,-1\n         if (flds_i(j) == 0) then\n            num_entries = num_entries - 1\n            cycle\n         else\n            exit\n         endif\n      enddo\n\n! now that we have an accurate count for num_entries we can make some sanity checks on flds_i. num_entries should be an even\n! number (igrid1, igrid2 and pairs of dgrid(i), dcomp(i)). also, flds_i should not have any zero values\n\n      err_1158_written = 'n'\n\n      je = modulo ( num_entries, 2 )\n      if (je /= 0) then                                    ! num_entries is not an even number unless je = 0\n         jerr = jerr + 1\n         fatal_err = fatal_err + 1\n         write(err,1158) name, id, 'this rspline entry does not have an even number of: dep grids + pairs of dep grid/comp entries'\n         write(f06,1158) name, id, 'this rspline entry does not have an even number of: dep grids + pairs of dep grid/comp entries'\n         err_1158_written = 'y'\n      endif\n\n      do j=1,num_entries\n         if (flds_i(j) == 0) then                         ! zero vals in flds_i\n            jerr = jerr + 1\n            fatal_err = fatal_err + 1\n            if (err_1158_written == 'n') then\n               write(err,1158) name, id, 'this rspline entry has some fields that are blank or that contain 0 values'\n               write(f06,1158) name, id, 'this rspline entry has some fields that are blank or that contain 0 values'\n            else\n               write(err,11582)\n               write(f06,11582)\n            endif\n         endif\n      enddo\n\n! make sure all dcomp(i) are proper component numbers\n\n      do j=3,num_entries,2\n         call ip6chk ( flds_c(j), chrinp, ip6typ, num_ci )\n         if (ip6typ(1:8) /= 'comp nos') then\n            jerr = jerr + 1\n            fatal_err = fatal_err + 1\n            write(err,1124) flds_f(j), name, id, flds_f(j), flds_c(j)\n            write(f06,1124) flds_f(j), name, id, flds_f(j), flds_c(j)\n         endif\n      enddo\n\n! determine the fields that will be written to l1f\n\n      igrid1 = flds_i(1)\n      if (num_entries > 0) then\n         igrid2 = flds_i(num_entries)\n      endif\n      num_dependents = 0\n      do j=2,num_entries-1,2\n         num_dependents = num_dependents + 1\n         dgrid(num_dependents) = flds_i(j)\n         dcomp(num_dependents) = flds_i(j+1)\n      enddo\n\n\n! if jerr /= 0 we can write data to l1f\n\n      if (jerr == 0) then\n         do j=1,num_dependents\n            write(l1f) rtype\n            write(l1f) elid, j, num_dependents, igrid1, igrid2, dgrid(j), dcomp(j), dl_rat\n            nrecard = nrecard + 1\n         enddo\n      endif\n\n! **********************************************************************************************************************************\n      if (wrt_log >= subr_begend) then\n         call ourtim\n         write(f04,9002) subr_name,tsec\n 9002    format(1x,a,' end  ',f10.3)\n      endif\n\n      return\n\n! **********************************************************************************************************************************\n 1124 format(' *error  1124: invalid dof number in field ',i3,' on ',a,' entry with id = ',a                                       &\n                    ,/,14x,' must be a combination of digits 1-6. however, field ',i3, ' has: \"',a,'\"')\n\n\n 1129 format(' *error  1129: invalid dof number in field ',i3,' on ',a,' id = ',a,' continuation entry',i4                         &\n                    ,/,14x,' must be a combination of digits 1-6. however, field ',i3, ' has: \"',a,'\"')\n\n\n 1158 format(' *error  1158: format error on ',a,a,'. format must have:'                                                           &\n                    ,/,14x,' (a) two and only two indep grids (in field 4 of the parent entry and in the last field on the',       &\n                           ' logical rspline entry)'                                                                               &\n                    ,/,14x,' (b) pairs of dep grids/comps following indep grid 1 and before indep grid 2 with no blank fields'     &\n                    ,/,15x,a)\n\n\n11582 format('               this rspline entry also has some fields that are blank or that contain 0 values')\n\n! **********************************************************************************************************************************\n\n      end subroutine bd_rspline\n"}
{"id": 253, "subroutine": "subroutine lagrange_diffmatrix(x,n,d)\n\n    integer, intent(in)                             :: n\n\n    real(dp), dimension(n), intent(in)       :: x\n    real(dp), dimension(n,n), intent(out)  :: d\n\n    integer                                         :: i,j\n    real(dp), dimension(n)                   :: w\n\n    call lagrange_barycentricweights(x,n,w)\n\n    do i=1,n\n        do j=1,n\n            if (i.eq.j) cycle\n            d(i,j) = w(j) / ( w(i) * (x(i)-x(j)) )\n            d(i,i) = d(i,i) - d(i,j)\n        end do\n    end do\n\nend subroutine\n"}
{"id": 254, "subroutine": "subroutine lagrange_barycentricweights(x,n,w)\n\n    integer, intent(in)         :: n\n    real(dp), intent(in)   :: x(n)\n    real(dp), intent(out)  :: w(n)\n\n    integer :: i,j\n\n    w = 1\n\n    do j=1,n\n        do i=1,n\n            if (j.eq.i) cycle\n            w(j) = w(j) / (x(j)-x(i))\n        end do\n    end do\n\nend subroutine\n"}
{"id": 255, "subroutine": "pure subroutine lagrange_vandermondematrix(n, m, xs, ys, vdm)\n\n    integer, intent(in)     :: n, m\n    real(dp), intent(in)        :: xs(n), ys(m)\n    real(dp), intent(out)       :: vdm(m,n)\n\n    integer :: i\n\n    do i = 1,m\n        vdm(i,:) = lagrange_basis(n, xs, ys(i))\n    end do\n\nend subroutine\n"}
{"id": 256, "subroutine": "            subroutine sp2fl(psp,pfc,klev)\n              integer(kind=4), intent(in) :: klev\n              real(kind=8), intent(in) :: psp(506,klev)\n              real(kind=8), intent(out) :: pfc(2048,klev)\n            end subroutine sp2fl\n"}
{"id": 257, "subroutine": "      subroutine write_bar ( num, fill_f06, fill_ans )\n \n! routine for writing output to text files f06 and ans for bar element stresses. up to 2 elements written per line of output.\n! data is first written to character variables and then that character variable is output the f06 and ans.\n \n      use pentium_ii_kind, only       :  byte, long, double\n      use iount1, only                :  wrt_err, wrt_log, ans, err, f04, f06\n      use scontr, only                :  bartor, blnk_sub_nam, mogel\n      use timdat, only                :  tsec\n      use subr_begend_levels, only    :  write_bar_begend\n      use constants_1, only           :  zero\n      use debug_parameters, only      :  debug\n      use link9_stuff, only           :  eid_out_array, maxreq, msprnt, ogel\n \n      use write_bar_use_ifs\n\n      implicit none\n \n      character(len=len(blnk_sub_nam)):: subr_name = 'write_bar'\n\n      character(len=*), intent(in)    :: fill_f06          ! padding for output format\n      character(len=*), intent(in)    :: fill_ans          ! padding for output format\n      character(133*byte)             :: bline1a           ! result of concatenating char. variables bout1, bms1, bmsf1, btor to\n!                                                            make the 1st line of stress output for a cbar with torsional stress \n      character(133*byte)             :: bline1b           ! result of concatenating char. variables bout1, bms1, bmsf1, bms2, bmsf2\n!                                                            to make the 1st line of stress output for a cbar w/o torsional stress\n      character(133*byte)             :: bline2a           ! result of concatenating char. variables bout2, bms2, bmsf2\n!                                                            to make the 2nd line of stress output for a cbar\n      character(133*byte)             :: bline2b           ! result of concatenating char. variables bout2, bms2, bmsf2\n!                                                            to make the 2nd line of stress output for a cbar\n      character(107*byte)             :: bout1             ! internal file: element id and elem stresses for end a of element\n      character(107*byte)             :: bout2             ! internal file: element id and elem stresses for end b of element\n      character( 10*byte)             :: bms1              ! internal file: margin of safety in tension for element\n      character( 10*byte)             :: bms2              ! internal file: margin of safety in tension for element\n      character( 14*byte)             :: bms3              ! internal file: margin of safety in tension for element\n      character(  1*byte)             :: bmsf1             ! internal file: margin of safety flag (msflag) for tension m.s.\n      character(  1*byte)             :: bmsf2             ! internal file: margin of safety flag (msflag) for compr m.s.\n      character(  1*byte)             :: bmsf3             ! internal file: margin of safety flag (msflag) for torque m.s.\n      character( 14*byte)             :: btor              ! internal file: torsional stress\n\n      character(14*byte)              :: abs_ans_char(16)  ! character variable that contains the 6 grid abs  outputs\n      character(14*byte)              :: max_ans_char(16)  ! character variable that contains the 6 grid max  outputs\n      character(14*byte)              :: min_ans_char(16)  ! character variable that contains the 6 grid min  outputs\n      character(  1*byte)             :: msflag            ! if margin is negative, msflag is an *\n      character(14*byte)              :: ogel_char(mogel)  ! char representation of 1 row of ogel outputs\n \n      integer(long), intent(in)       :: num               ! the number of rows of ogel to write out\n      integer(long)                   :: i,j               ! do loop indices\n      integer(long)                   :: k                 ! counter\n      integer(long), parameter        :: subr_begend = write_bar_begend\n \n      real(double)                    :: abs_ans(16)       ! max abs for all grids output for each of the 6 disp components\n      real(double)                    :: max_ans(16)       ! max for all grids output for each of the 6 disp components\n      real(double)                    :: min_ans(16)       ! min for all grids output for each of the 6 disp components\n\n! **********************************************************************************************************************************\n      if (wrt_log >= subr_begend) then\n         call ourtim\n         write(f04,9001) subr_name,tsec\n 9001    format(1x,a,' begn ',f10.3)\n      endif\n\n! **********************************************************************************************************************************\n      k = 0\n      do i=1,num\n \n         bline1a(1:) = ' '\n         bline1b(1:) = ' '\n         bline2a(1:) = ' '\n         bline2b(1:) = ' '\n\n         bout1(1:)   = ' '\n         bms1(1:)    = ' '\n         bmsf1       = ' '   \n \n         bout2(1:)   = ' '\n         bms2(1:)    = ' '\n         bmsf2       = ' '\n\n         btor(1:)    = ' '   \n \n! write first line of output for one element to a temporary internal file\n \n         k = k + 1\n         call wrt_real_to_char_var ( ogel, maxreq, mogel, k, ogel_char )\n         write(bout1,9011) eid_out_array(i,1), (ogel_char(j),j=1,7)\n\n         msflag = ' '\n         if (msprnt(k,1) /= '0') then\n            if (ogel(k,8) < zero) then\n               msflag = '*'\n            endif\n            write(bms1, 9021) ogel(k,8)\n            write(bmsf1,9031) msflag\n         else\n            write(bms1, 9022)\n            write(bmsf1,9032)\n         endif\n         if (bartor == 'y') then\n            write(btor, 9041) ogel(k,9)\n         endif\n\n! write second line of output for one element to a temporary internal file\n \n         k = k + 1\n         call wrt_real_to_char_var ( ogel, maxreq, mogel, k, ogel_char )\n         write(bout2,9012) (ogel_char(j),j=1,4), (ogel_char(j),j=6,7)\n\n         msflag = ' '\n         if (msprnt(k,2) /= '0') then\n            if (ogel(k,8) < zero) then\n               msflag = '*'\n            endif\n            write(bms2, 9021) ogel(k,8)\n            write(bmsf2,9031) msflag\n         else\n            write(bms2, 9022)\n            write(bmsf2,9032)\n         endif\n\n         msflag = ' '\n         if (msprnt(k,3) /= '0') then\n            if (ogel(k,9) < zero) then\n               msflag = '*'\n            endif\n            write(bms3, 9023) ogel(k,9)\n            write(bmsf3,9031) msflag\n         else\n            write(bms3, 9024)\n            write(bmsf3,9032)\n         endif\n\n! write the two lines of stress output for one element to f06\n\n         write(f06,*)\n         write(ans,*)\n         if (bartor == 'y') then\n            bline1a = bout1//bms1//bmsf1//btor\n            bline2a = bout2//bms2//bmsf2//bms3//bmsf3\n            write(f06,9031) bline1a\n            write(f06,9031) bline2a\n            if (debug(200) > 0) then\n               write(ans,9901) fill_ans, eid_out_array(i,1), (ogel(k-1,j),j=1,9)\n               write(ans,9902) fill_ans, (ogel(k,j),j=1,9)\n            endif\n         else\n            bline1b = bout1//bms1//bmsf1\n            bline2b = bout2//bms2//bmsf2\n            write(f06,9031) bline1b\n            write(f06,9031) bline2b\n            if (debug(200) > 0) then\n               write(ans,9903) fill_ans, eid_out_array(i,1), (ogel(k-1,j),j=1,8)\n               write(ans,9904) fill_ans, (ogel(k,j),j=1,8)\n           endif\n         endif\n\n         if (debug(200) > 0) then\n         endif\n \n      enddo   \n \n      call get_max_min_abs ( 1, 8 )\n      write(f06,9108) (max_ans_char(j),j=1,7), max_ans(8), (max_ans_char(j),j=9,15), max_ans(16),                                  &\n                      (min_ans_char(j),j=1,7), min_ans(8), (min_ans_char(j),j=9,15), min_ans(16),                                  &\n                      (abs_ans_char(j),j=1,7), abs_ans(8), (abs_ans_char(j),j=9,15), abs_ans(16)\n      if (debug(200) > 0) then\n         write(ans,9118) (max_ans(j),j=1,16),(min_ans(j),j=1,16), (abs_ans(j),j=1,16)\n      endif\n\n! **********************************************************************************************************************************\n      if (wrt_log >= subr_begend) then\n         call ourtim\n         write(f04,9002) subr_name,tsec\n 9002    format(1x,a,' end  ',f10.3)\n      endif\n\n      return\n\n! **********************************************************************************************************************************\n 9011 format(1x,i8,7a)\n\n 9012 format(1x,8x,4a,14x,2a)\n\n 9021 format(es10.2)\n\n 9022 format('          ')\n\n 9023 format(4x,es10.2)\n\n 9024 format('              ')\n\n 9031 format(a)\n\n 9032 format(' ')\n\n 9041 format(es14.6)\n\n 9901 format(a,i8,7(1es14.6),4x,1es10.2,2es14.6)\n\n 9902 format(a,8x,7(1es14.6),4x,1es10.2,2es14.6)\n\n 9903 format(a,i8,7(1es14.6),4x,1es10.2,1es14.6)\n\n 9904 format(a,8x,7(1es14.6),4x,1es10.2,1es14.6)\n\n\n\n 9108 format( 1x,'         ------------- ------------- ------------- ------------- ------------- ------------- -------------',     &\n                        ' ---------',/,                                                                                            &\n             1x,'max* :  ',7a,1es10.2,/,                                                                                           &\n             1x,'max* :  ',7a,1es10.2,//,                                                                                          &\n             1x,'min* :  ',7a,1es10.2,/,                                                                                           &\n             1x,'min* :  ',7a,1es10.2,//,                                                                                          &\n             1x,'abs* :  ',7a,1es10.2,/,                                                                                           &\n             1x,'abs* :  ',7a,1es10.2,/,                                                                                           &\n             1x,'*for output set')\n\n 9118 format(11x,'              ------------- ------------- ------------- ------------- ------------- ------------- -------------',&\n                             ' ---------',/,                                                                                       &\n             1x,'max (for output set):  ',7(1es14.6),es14.2,/,                                                                     &\n             1x,'max (for output set):  ',7(1es14.6),es14.2,//,                                                                    &\n             1x,'min (for output set):  ',7(1es14.6),es14.2,/,                                                                     &\n             1x,'min (for output set):  ',7(1es14.6),es14.2,//,                                                                    &\n             1x,'abs (for output set):  ',7(1es14.6),es14.2,/,                                                                     &\n             1x,'abs (for output set):  ',7(1es14.6),es14.2)\n\n! **********************************************************************************************************************************\n \n! ##################################################################################################################################\n \n      contains\n \n! ##################################################################################################################################\n\n      subroutine get_max_min_abs ( beg_col, end_col )\n\n      use pentium_ii_kind, only       :  long\n      use constants_1, only           :  zero\n      use machine_params, only        :  mach_large_num\n\n      implicit none\n\n      integer(long), intent(in)       :: beg_col           ! col number in ogel where to beg for averaging to get max, min, abs\n      integer(long), intent(in)       :: end_col           ! col number in ogel where to end for averaging to get max, min, abs\n      integer(long)                   :: ii,jj,kk,ll       ! do loop indices or counters\n\n! **********************************************************************************************************************************\n! get max, min, abs values\n\n      do jj=1,2*(end_col-beg_col+1)\n         max_ans(jj) = -mach_large_num\n      enddo \n\n      ll = 0\n      do ii=1,num\n         kk = 0\n         ll = ll + 1\n         do jj=beg_col,end_col\n            kk = kk + 1\n            if (ogel(ll,jj) > max_ans(kk)) then\n               max_ans(kk) = ogel(ll,jj)\n            endif\n         enddo\n         ll = ll + 1\n         do jj=beg_col,end_col\n            kk = kk + 1\n            if (ogel(2*ii,jj) > max_ans(kk)) then\n               max_ans(kk) = ogel(ll,jj)\n            endif\n         enddo\n      enddo\n\n      do jj=1,2*(end_col-beg_col+1)\n         min_ans(jj) = max_ans(jj)\n      enddo\n\n      ll = 0\n      do ii=1,num\n         kk = 0\n         ll = ll + 1\n         do jj=beg_col,end_col\n            kk = kk + 1\n            if (ogel(ll,jj) < min_ans(kk)) then\n               min_ans(kk) = ogel(ll,jj)\n            endif\n         enddo\n         ll = ll + 1\n         do jj=beg_col,end_col\n            kk = kk + 1\n            if (ogel(ll,jj) < min_ans(kk)) then\n               min_ans(kk) = ogel(ll,jj)\n            endif\n         enddo\n      enddo\n\n      do ii=1,2*(end_col-beg_col+1)\n         abs_ans(ii) = max( dabs(max_ans(ii)), dabs(min_ans(ii)) )\n      enddo\n\n      do ii=1,16\n\n         if (abs_ans(ii) == 0.0) then\n            write(abs_ans_char(ii),'(a)') '  0.0         '\n         else\n            write(abs_ans_char(ii),'(1es14.6)') abs_ans(ii)\n         endif\n\n         if (max_ans(ii) == 0.0) then\n            write(max_ans_char(ii),'(a)') '  0.0         '\n         else\n            write(max_ans_char(ii),'(1es14.6)') max_ans(ii)\n         endif\n\n         if (min_ans(ii) == 0.0) then\n            write(min_ans_char(ii),'(a)') '  0.0         '\n         else\n            write(min_ans_char(ii),'(1es14.6)') min_ans(ii)\n         endif\n\n      enddo\n\n      end subroutine get_max_min_abs\n\n      end subroutine write_bar\n"}
{"id": 258, "subroutine": "subroutine r_eigenval(smat, eval, iter)\n\nimplicit none\ninteger :: ii,iter\nreal(8) :: smat(iter,iter),eval(iter)\ncharacter :: jobvl*1, jobvr*1\ninteger :: info, lda, ldb, ldvl, ldvr, lwork, n\nreal(8),allocatable :: a( :, : ), alphai( : ), alphar( : )\nreal(8),allocatable :: b( :, : ), beta( : ), vl( :, : )\nreal(8),allocatable :: vr( :, : ), work( : )\n\njobvl='n'\njobvr='v'\nn=iter\nlda=iter\nldb=iter\n     \nldvl=iter\nldvr=iter\n\nlwork=8*iter\n\nallocate ( a( lda, n ), alphai( n ), alphar( n ) )\nallocate ( b( ldb, n ), beta( n ), vl( ldvl, n ) )\nallocate ( vr( ldvr, n ), work( lwork ) )\n\na=smat\n\nb=0.d0\ndo ii=1,iter\n  b(ii,ii)=1.d0\nend do\n\ncall dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,      &\n       beta, vl, ldvl, vr, ldvr, work, lwork, info )\n\n! check whether eigenvalues are real.\n\ndo ii=1,iter\n  if(alphai(ii) > 0.05d0)then\n    write(*,*) \"========== diis error ==========\"\n    write(*,*) \"one of eigenvalue is imaginary.\"\n    write(*,*) \"================================\"\n    stop\n  end if\nend do\n\neval=alphar\n\ndeallocate (a,alphai,alphar,b,beta,vl,vr,work)\n\nreturn\n\nend subroutine r_eigenval\n"}
{"id": 259, "subroutine": "subroutine r_gen_eigen(rmat,smat,alpha,betav,evec,iter,ier2)\n\nimplicit none\n\ninteger :: iter,ii,ier2\nreal(8) :: rmat(iter,iter)\nreal(8) :: smat(iter,iter)\nreal(8) :: alpha(iter),betav(iter)\nreal(8) :: evec(iter,iter)\ncharacter :: jobvl*1, jobvr*1\ninteger :: info, lda, ldb, ldvl, ldvr, lwork, n\nreal(8),allocatable :: a( :, : ), alphai( : ), alphar( : )\nreal(8),allocatable :: b( :, : ), beta( : ), vl( :, : )\nreal(8),allocatable :: vr( :, : ), work( : )\n\nier2=0\n\njobvl='n'\njobvr='v'\nn=iter\nlda=iter\nldb=iter\n     \nldvl=iter\nldvr=iter\n\nlwork=8*iter\n\nallocate ( a( lda, n ), alphai( n ), alphar( n ) )\nallocate ( b( ldb, n ), beta( n ), vl( ldvl, n ) )\nallocate ( vr( ldvr, n ), work( lwork ) )\n\na=rmat\nb=smat\n\ncall dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,      &\n       beta, vl, ldvl, vr, ldvr, work, lwork, info )\n\n! check whether eigenvalues and eigenvectors take real value.\ndo ii=1,iter\n  if(alphai(ii) > 1.d-8)then\n    write(*,*) \"========== diis error ==========\"\n    write(*,*) \"one of eigenvector is imaginary.\"\n    write(*,*) \"================================\"\n    stop\n  end if\nend do\n\nalpha=alphar\nbetav=beta\nevec=vr\n\ndeallocate (a,alphai,alphar,b,beta,vl,vr,work)\n\nreturn\n\nend subroutine r_gen_eigen\n"}
{"id": 260, "subroutine": "subroutine c_eigenval(smat, eval, iter)\n\nimplicit none\ninteger :: ii,iter\ncomplex(8) :: smat(iter,iter)\nreal(8) :: eval(iter)\ncharacter :: jobvl*1, jobvr*1\ninteger :: info, lda, ldb, ldvl, ldvr, lwork, n\ncomplex(8),allocatable :: a( :, : ), alpha( : )\ncomplex(8),allocatable :: b( :, : ), beta( : ), vl( :, : )\ncomplex(8),allocatable :: vr( :, : ), work( : )\n\njobvl='n'\njobvr='v'\nn=iter\nlda=iter\nldb=iter\n     \nldvl=iter\nldvr=iter\n\nlwork=8*iter\n\nallocate ( a( lda, n ), alpha( n ) )\nallocate ( b( ldb, n ), beta( n ), vl( ldvl, n ) )\nallocate ( vr( ldvr, n ), work( lwork ) )\n\na=smat\n\nb=0.d0\ndo ii=1,iter\n  b(ii,ii)=1.d0\nend do\n\ncall zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha,      &\n       beta, vl, ldvl, vr, ldvr, work, lwork, info )\n\neval=real(alpha)\n\ndeallocate (a,alpha,b,beta,vl,vr,work)\n\nreturn\n\nend subroutine c_eigenval\n"}
{"id": 261, "subroutine": "subroutine c_gen_eigen(rmat,smat,alpha,betav,evec,iter,ier2)\n\nimplicit none\n\ninteger :: iter,ier2\ncomplex(8) :: rmat(iter,iter)\ncomplex(8) :: smat(iter,iter)\ncomplex(8) :: alpha(iter),betav(iter)\ncomplex(8) :: evec(iter,iter)\ncharacter :: jobvl*1, jobvr*1\ninteger :: info, lda, ldb, ldvl, ldvr, lwork, n\ncomplex(8),allocatable :: a( :, : ), alpha2( : )\ncomplex(8),allocatable :: b( :, : ), beta( : ), vl( :, : )\ncomplex(8),allocatable :: vr( :, : ), work( : )\n\nier2=0\n\njobvl='n'\njobvr='v'\nn=iter\nlda=iter\nldb=iter\n     \nldvl=iter\nldvr=iter\n\nlwork=8*iter\n\nallocate ( a( lda, n ), alpha2( n ) )\nallocate ( b( ldb, n ), beta( n ), vl( ldvl, n ) )\nallocate ( vr( ldvr, n ), work( lwork ) )\n\na=rmat\nb=smat\n\ncall zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha2,      &\n       beta, vl, ldvl, vr, ldvr, work, lwork, info )\n\nalpha=alpha2\nbetav=beta\nevec=vr\n\ndeallocate (a,alpha2,b,beta,vl,vr,work)\n\nreturn\n\nend subroutine c_gen_eigen\n"}
{"id": 262, "subroutine": "    subroutine core_guess(kf,hc,f)\n        ! ----------------------------\n        ! core hamiltonian\n        ! ----------------------------\n        !\n        ! source:\n        !   a. szabo and n. s. ostlund\n        !   modern quantum chemistry\n        !   dover\n        !   1996\n        !\n        !-----------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        ! initial guess: core hamiltonian\n        f = hc\n\n    end subroutine core_guess\n"}
{"id": 263, "subroutine": "    subroutine huckel_guess(kf,hc,s,f,cst)\n        ! -----------------------------------------------------\n        ! extended h\u00fcckel theory\n        ! -----------------------------------------------------\n        !\n        ! source:\n        !   extended h\u00fcckel and slater\u2019s rule initial guess for\n        !       real space grid-based density functional theory\n        !   m. lee, k. leiter, c. eisner, j. crone and j. knap\n        !   computational and theoretical chemistry\n        !   2015\n        !\n        !------------------------------------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf),intent(in) :: s    ! overlap matrix\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n        real*8, intent(in) :: cst                   ! multiplicative constant in h\u00fcckel model\n\n        ! intermediate variables\n        integer :: i, j                             ! loop indices\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        f(:,:) = 0.0d0\n\n        do i = 1,kf\n            do j = 1,kf\n                f(i,j) = cst * s(i,j) * 0.5d0 * (hc(i,i) + hc(j,j))\n            end do\n        end do\n\n    end subroutine huckel_guess\n"}
{"id": 264, "subroutine": "subroutine driver\n    use dynamo\n    implicit none\n    character( len = 256 ) :: str\n    integer :: i, j\n\n    call getarg( 1, str )\n    write(*,\"(a,a,a)\") \"[\", trim( str ), \"]\"\n    open( file = trim( str ), unit = 998, action = \"read\", form = \"formatted\" )\n    read( 998, \"(a)\" ) str\n    write(*,\"(a,a,a)\") \"[\", trim( str ), \"]\"\n    do while( trim( str ) /= \"exit\" )\n        if( trim( str ) == \"charges\" ) then\n            open( file = \"dynamo.chrg\", unit = 999, action = \"read\", form = \"unformatted\" )\n            read( 999 ) atmchg\n            close( 999 )\n        end if\n        if( trim( str ) == \"coordinates\" ) then\n            open( file = \"dynamo.crd\", unit = 999, action = \"read\", form = \"unformatted\" )\n            read( 999 ) atmcrd(1:3,1:natoms)\n            close( 999 )\n        end if\n        if( trim( str ) == \"energy\" ) then\n            call energy\n            open( file = \"dynamo.dat\", unit = 999, action = \"write\", form = \"unformatted\" )\n            write( 999 ) etotal\n            close( 999 )\n        end if\n        if( trim( str ) == \"gradient\" ) then\n            if( .not. allocated( atmder ) ) allocate( atmder(1:3,1:natoms ) )\n            call gradient\n            open( file = \"dynamo.dat\", unit = 999, action = \"write\", form = \"unformatted\" )\n            write( 999 ) etotal\n            write( 999 ) atmder\n            close( 999 )\n        end if\n        read( 998, \"(a)\" ) str\n        write(*,\"(a,a,a)\") \"[\", trim( str ), \"]\"\n    end do\n    close( 998 )\nend subroutine driver\n"}
{"id": 265, "subroutine": "subroutine setupgrid\n\n  use grid\n\n  implicit none\n\n  integer :: i, j, hny\n  real*8 :: sinr, cosr, sinlat, num, den\n\n  ! set up grid information\n\n  hny = ny/2\n\n  do i = 1, nx\n     xp(i) = (i-0.5)*dx\n     xu(i) = (i-1)*dx\n     xv(i) = (i-0.5)*dx\n  enddo\n\n  do j = 1, ny\n     yp(j) = (j-hny-0.5)*dy\n     yu(j) = (j-hny-0.5)*dy\n     yv(j) = (j-hny-1)*dy\n     cosp(j) = cos(yp(j))\n     cosv(j) = cos(yv(j))\n     sinp(j) = sin(yp(j))\n     sinv(j) = sin(yv(j))\n  enddo\n\n  yv(1) = -piby2\n  yv(ny+1) = piby2\n  cosv(1) = 0.0\n  cosv(ny+1) = 0.0\n  sinv(1) = 0.0\n  sinv(ny+1) = 1.0\n\n  dareadx = 0.0\n  areatot = 0.0\n  do j = 1, ny\n     ! area(j) = dx*(sinv(j+1) - sinv(j))\n     area(j) = dx*dy*cosp(j)\n     areatot = areatot + area(j)\n     dareadx = dareadx + dy*cosp(j)\n  enddo\n  areatot = areatot*nx\n\n  ! print *,'dareadx = ',dareadx,' areatot = ',areatot\n\n  ! sine of geographical latitude for rotated model grid,\n  ! and geographical latitude and longitude\n  sinr = sin(rotgrid)\n  cosr = cos(rotgrid)\n  ! phi points\n  do i = 1, nx\n     do j = 1, ny\n        sinlat = cosr*sinp(j) - sinr*cosp(j)*sin(xp(i))\n        singeolatp(i,j) = sinlat\n        geolatp(i,j) = asin(sinlat)\n        num = cosr*cosp(j)*sin(xp(i)) + sinr*sinp(j)\n        den = cosp(j)*cos(xp(i))\n        geolonp(i,j) = modulo(atan2(num,den),twopi)\n     enddo\n  enddo\n  ! vorticity points\n  do i = 1, nx\n     do j = 1, ny+1\n        sinlat = cosr*sinv(j) - sinr*cosv(j)*sin(xu(i))\n        singeolatz(i,j) = sinlat\n     enddo\n  enddo\n\n  print*, \"grid :   nx= \", nx, \"ny= \", ny\nend subroutine setupgrid\n"}
{"id": 266, "subroutine": "subroutine setconst\n\n  use version\n  use constants\n\n  implicit none\n\n  ! set earth's radius\n  rearth = 6371220.0\n\n  ! set rotation rate\n  twoomega = 1.4584e-4\n  !twoomega = 0.0\n\n  ! gravity\n  gravity = 9.80616d0\n\n  ! set reference geopotential for phi\n  select case(ic)\n  case(1)\n     phiref = 1.0e5  ! resting state with uniform phi\n     print*, \"ic 1: resting state with uniform phi\"\n  case(2)\n     phiref = 2.94d4 ! balanced solid body rotation tc02\n     print*, \"ic 2: balanced solid body rotation tc02\"\n  case(5)\n     ! test case 5 - mountain tc05\n     ! phiref = 37979.96 ! min for case 5\n     ! phiref = 58439.00 ! max for case 5\n     phiref = 48209.48 ! minimax for case 5 tc05\n     print*, \"ic 5: test case 5 - mountain tc05\"\n  case(6)\n     ! phiref = 78464.01 ! min for case 6\n     ! phiref = 103502.53! max for case 6\n     phiref = 90983.27 ! minimax for case 6 tc06\n     print*, \"ic 6 : rosby-haurwitz wave tc06\"\n  case(7)\n     phiref = 1.0e5    ! suitable for galewsky\n     print*, \"ic 7 : gallewsky test case - unstable jet\"\n  case(8)\n     phiref = 1.0d0*gravity ! for hollingsworth test\n     print*, \"ic 8 : hollingsworth test with phi0 \", phiref\n  case default\n     write(*,*) \"please set a valid initial condition and a\"\n     write(*,*) \" valid reference phi in setconst\"\n     stop\n  end select\n\nend subroutine setconst\n"}
{"id": 267, "subroutine": "subroutine initial\n\n  ! set up initial conditions\n  use version\n  use state\n  use force\n  use constants\n  use timeinfo\n  use work ! for testing advection\n  use errdiag\n\n  implicit none\n\n  integer, parameter :: nygg = 2*nx\n\n  integer :: i, j, rrw, ip, jp, jy !, ic\n  real*8 :: gwamp = 100.0d2, phimeangw = 1.0d5\n  real*8 :: u00, phi00, sinr, cosr\n  real*8 :: phis0, rr0, rr1, rr, latc, longc\n  real*8 :: wrw, krw, phi0rw, a, b, c\n  real*8 :: psigg(nygg+1), hgg(nygg+1), u1, u2, l1, l2, &\n       lat0, lat1, umax, en, umen, dygg, psi1, psi2, &\n       alpha, beta, totvol, totarea, hbar, den, num, hpert, &\n       lat2, e1, e2, coslat, c1, c2, c3, c4, pxyz(1:3), p0xyz(1:3)\n\n  !pxt - given by command line argument\n  ! ic = 1   resting, constant phi\n  ! ic = 2   williamson et al. test case 2\n  ! ic = 5   williamson et al. test case 5 tc05\n  ! ic = 7   galewsky et al. barotropically unstable jet - specify stream fn\n  ! ic = 6   rossby haurwitz wave tc06\n  ! ic = 8   like case 2 but with orography balancing u\n\n  !ic = 5\n\n\n  ! departure point and advection tests\n\n  !do j = 1, ny\n  !  do i = 1, nx\n  !    if (abs(xu(i)-0.3) .lt. 0.3) then\n  !      phi0(i,j) = cos(yu(j))*(cos(0.5*pi*(xu(i)-0.3)/0.3))**2\n  !    else\n  !      phi0(i,j) = 0.0\n  !    endif\n  !    phi0(i,j) = sin(yp(j))\n  !    u0(i,j) = 100.0*cosp(j)*(sin(5.0*yp(j))**2)\n  !    phi0(i,j) = 1000.0\n  !    u0(i,j) = (rearth*dx/dt)*cosp(j)*(-1)**(i+j)\n  !  enddo\n  !enddo\n\n  !do j = 1, ny+1\n  !  do i = 1, nx \n  !    if (abs(xv(i)-0.3) .lt. 0.3) then\n  !      rv0(i,j) = cos(yv(j))*(cos(0.5*pi*(xv(i)-0.3)/0.3))**2\n  !    else\n  !      rv0(i,j) = 0.0\n  !    endif\n  !    v0(i,j) = - 000.0*sin(xv(i)) &\n  !              + 000.0*cos(xv(i))\n  !    v0(i,j) = cosv(j)*rearth*dy/(2.0*dt)\n  !     v0(i,j) = 0.0\n  !  enddo\n  !enddo\n\n\n  ! global non-rotating gravity wave\n\n  !do j = 1, ny\n  !  do i = 1, nx\n  !     phi0(i,j) = phimeangw + gwamp*cos(yp(j))*cos(xp(i))   ! case 1\n  !      phi0(i,j) = phimeangw + gwamp*cos(yp(j))*sin(xp(i))  ! case 2\n  !      u0(i,j) = gwamp*cos(xu(i))/(sqrt(2.0*phimeangw))      ! case 1\n  !     u0(i,j) = 0.0                                         ! case 2\n  !  enddo\n  !enddo    \n\n  !do j = 1, ny+1\n  !  do i = 1, nx \n  !    v0(i,j) = -gwamp*sin(xv(i))*sin(yv(j))/(sqrt(2.0*phimeangw)) ! case 1\n  !     v0(i,j) = gwamp*cos(yv(j))/(sqrt(2.0*phimeangw))            ! case 2\n  !  enddo\n  !enddo\n\n\n  ! zero orography - modify below for tc 5\n  phis = 0.0d0\n\n  if (ic == 1) then\n\n     ! resting state with uniform phi\n     phi0 = 1.0d5\n     u0 = 0.0d0\n     v0 = 0.0d0\n\n  elseif (ic == 2 .or. ic == 5 ) then\n\n     ! balanced solid body rotation\n     if (ic == 2) then\n        ! test case 2\n        u00 = 2.0d0*pi*rearth/(12.0d0*86400.0d0)\n        phi00 = 2.94d4\n        ! if changed, remmember to change also in module setconst\n     elseif (ic == 5) then\n        ! test case 5\n        u00 = 20.0d0\n        phi00 = 5960.0d0*gravity\n        ! if changed, remmember to change also in module setconst\n     endif\n\n     cosr = cos(rotgrid)\n     sinr = sin(rotgrid)\n\n     do j = 1, ny\n        do i = 1, nx\n           phi0(i,j) = phi00 - 0.5*(rearth*twoomega*u00 + u00*u00)*singeolatp(i,j)**2\n           u0(i,j) = u00*(cosp(j)*cosr + sin(xu(i))*sinp(j)*sinr)\n        enddo\n     enddo\n\n     do j = 1, ny+1\n        do i = 1, nx \n           v0(i,j) = u00*cos(xv(i))*sinr\n        enddo\n     enddo\n\n     if (ic == 5 ) then\n        ! include mountain\n        phis0 = 2000.0d0*9.80616d0\n        rr0 = pi/9.0d0\n        latc = pi/6.0d0\n        longc = 3.0d0*pi/2.0d0 !0.5d0*pi\n        do j = 1, ny\n           do i = 1, nx  \n              ! isolated mountain\n              rr = sqrt(min(rr0*rr0,(geolonp(i,j)-longc)**2 + (geolatp(i,j)-latc)**2))\n              phis(i,j) = phis0*(1.0 - rr/rr0)\n           enddo\n        enddo\n        ! correct phi to allow for orography\n        phi0 = phi0 - phis\n     endif\n\n     ! p. peixoto - smooth moutain - unsued\n     !\n     !    ! include smooth mountain on thin layer\n     !\n     !    phis0 = 20.0d0*9.80616d0\n     !    rr0 = pi/9.0d0\n     !    latc = pi/6.0d0\n     !    longc = 3.0d0*pi/2.0d0 !0.5d0*pi\n     !    do j = 1, ny\n     !      do i = 1, nx\n     !\n     !            !thin layer\n     !        \tphi0(i,j) = 100.0d0*gravity\n     !\n     !        \t!mountain\n     !\t        !convert lonc, latc to cartesian coords\n     !\t\t\tcall sph2cart(longc, latc, p0xyz(1), p0xyz(2), p0xyz(3))\n     !\t        !convert geolonp, geolatp to cartesian coords\n     !\t\t\tcall sph2cart(geolonp(i,j), geolatp(i,j), pxyz(1), pxyz(2), pxyz(3))\n     !\t        !set mountain\n     !\t        rr= dsqrt(dot_product( pxyz-p0xyz, pxyz-p0xyz))\n     !\t        rr1=2*(1-cos(rr0))\n     !\n     !\t\t\tphis(i,j) =  phi00 - 0.5*(rearth*twoomega*u00 + u00*u00)*singeolatp(i,j)**2\n     !\n     !\t\t\tphis(i,j) =phis(i,j) + phis0*exp(-0.4*rr**2/rr1**2)\n     !\t\t\tphi0(i,j) =phi0(i,j) - phis0*exp(-0.4*rr**2/rr1**2)\n     !\t\t\t!print*, geolonp(i,j), geolatp(i,j), phis(i,j), phi0(i,j)\n     !      enddo\n     !    enddo\n     !    ! do not correct phi to allow for orography!\n     !    !phi0 = phi0 - phis\n     !\n     !pxt\n  elseif (ic == 8) then\n\n     u00 = 2.0d0*pi*rearth/(12.0d0*86400.0d0)\n     !phi00 = 1.0d-2\n     phi00 = phiref !1.0d+2*gravity !set in setconst\n     cosr = cos(rotgrid)\n     sinr = sin(rotgrid)\n\n     do j = 1, ny\n        do i = 1, nx\n           !bottom topo as in tc02\n           phis(i,j) = 2.94d4 - 0.5*(rearth*twoomega*u00 + u00*u00)*singeolatp(i,j)**2\n           ! constant thin layer\n           phi0(i,j) = phi00\n           u0(i,j) = u00*(cosp(j)*cosr + sin(xu(i))*sinp(j)*sinr)\n        enddo\n     enddo\n\n     do j = 1, ny+1\n        do i = 1, nx\n           v0(i,j) = u00*cos(xv(i))*sinr\n        enddo\n     enddo\n\n  elseif (ic == 7) then\n\n     ! galewsky test initialized using stream function\n\n     umax = 80.0\n     lat0 = pi/7.0\n     lat1 = pi/2.0 - lat0\n     en = exp(-4/(lat1 - lat0)**2)\n     umen = umax/en\n     totvol = 0.0d0\n     totarea = 0.0d0\n     ! integrate to tabulate h and psi as functions of geographical\n     ! latitude\n     dygg = pi/nygg\n     hgg(1) = 0.0d0\n     psigg(1) = 0.0d0\n     do j = 2, nygg\n        l1 = (j-2)*dygg - piby2\n        den = (l1 - lat0)*(l1 - lat1)\n        if (den .lt. 0.0d0) then\n           u1 = umen*exp(1.0d0/den)\n        else\n           u1 = 0.0d0\n        endif\n        l2 = (j-1)*dygg - piby2\n        den = (l2 - lat0)*(l2 - lat1)\n        if (den .lt. 0.0d0) then\n           u2 = umen*exp(1.0d0/den)\n        else\n           u2 = 0.0d0\n        endif\n        psigg(j) = psigg(j-1) - 0.5*(u1 + u2)*dygg\n        u1 = u1*(twoomega*sin(l1) + tan(l1)*u1/rearth)\n        u2 = u2*(twoomega*sin(l2) + tan(l2)*u2/rearth)\n        hgg(j) = hgg(j-1) - rearth*0.5*(u1 + u2)*dygg\n        totarea = totarea + cos(l2)*dygg\n        totvol = totvol + hgg(j)*cos(l2)*dygg\n     enddo\n     psigg(nygg+1) = psigg(nygg)\n     hgg(nygg+1) = hgg(nygg)\n     totvol = totvol/(totarea*gravity)\n     hgg = hgg + (1.0d4 - totvol)*gravity\n\n     ! now assign h as a function of geographical latitude\n     ! using interpolation from tabulated values\n     totvol = 0.0d0\n     totarea = 0.0d0\n     do j = 1, ny\n        do i = 1, nx\n           l1 = asin(singeolatp(i,j)) + piby2\n           jy = floor(l1/dygg) + 1\n           beta = (l1 - (jy - 1)*dygg)/dygg\n           if (jy == 1 .or. jy == nygg) then\n              ! linear interpolation\n              c2 = 1.0d0 - beta\n              c3 = beta\n              phi0(i,j) = c2*hgg(jy) + c3*hgg(jy+1)\n           else\n              ! cubic interpolation\n              c1 = -beta*(beta - 1.0d0)*(beta - 2.0d0)/6.0d0\n              c2 = 0.5d0*(beta + 1.0d0)*(beta - 1.0d0)*(beta - 2.0d0)\n              c3 = -0.5d0*(beta + 1.0d0)*beta*(beta - 2.0d0)\n              c4 = (beta + 1.0d0)*beta*(beta - 1.0d0)/6.0d0\n              phi0(i,j) = c1*hgg(jy-1) + c2*hgg(jy) + c3*hgg(jy+1) + c4*hgg(jy+2)\n           endif\n           totarea = totarea + area(j)\n           totvol = totvol + area(j)*phi0(i,j)\n        enddo\n     enddo\n     ! now calculate velocity components by interpolating\n     ! stream function to each vorticity point\n     ! u field\n     do j = 1, ny\n        jp = j + 1\n        do i = 1, nx\n           l1 = asin(singeolatz(i,j)) + piby2\n           jy = floor(l1/dygg) + 1\n           beta = (l1 - (jy - 1)*dygg)/dygg\n           if (jy == 1 .or. jy == nygg) then\n              ! linear interpolation\n              c2 = 1.0d0 - beta\n              c3 = beta\n              psi1 = c2*psigg(jy) + c3*psigg(jy+1)\n           else\n              ! cubic interpolation\n              c1 = -beta*(beta - 1.0d0)*(beta - 2.0d0)/6.0d0\n              c2 = 0.5d0*(beta + 1.0d0)*(beta - 1.0d0)*(beta - 2.0d0)\n              c3 = -0.5d0*(beta + 1.0d0)*beta*(beta - 2.0d0)\n              c4 = (beta + 1.0d0)*beta*(beta - 1.0d0)/6.0d0\n              psi1 = c1*psigg(jy-1) + c2*psigg(jy) + c3*psigg(jy+1) + c4*psigg(jy+2)\n           endif\n           l2 = asin(singeolatz(i,jp)) + piby2\n           jy = floor(l2/dygg) + 1\n           beta = (l2 - (jy - 1)*dygg)/dygg\n           if (jy == 1 .or. jy == nygg) then\n              ! linear interpolation\n              c2 = 1.0d0 - beta\n              c3 = beta\n              psi2 = c2*psigg(jy) + c3*psigg(jy+1)\n           else\n              ! cubic interpolation\n              c1 = -beta*(beta - 1.0d0)*(beta - 2.0d0)/6.0d0\n              c2 = 0.5d0*(beta + 1.0d0)*(beta - 1.0d0)*(beta - 2.0d0)\n              c3 = -0.5d0*(beta + 1.0d0)*beta*(beta - 2.0d0)\n              c4 = (beta + 1.0d0)*beta*(beta - 1.0d0)/6.0d0\n              psi2 = c1*psigg(jy-1) + c2*psigg(jy) + c3*psigg(jy+1) + c4*psigg(jy+2)\n           endif\n           u0(i,j) = -(psi2 - psi1)/dy\n        enddo\n     enddo\n     ! v field\n     do j = 2, ny\n        do i = 1,nx\n           ip = i + 1\n           if (i .eq. nx) ip = 1\n           l1 = asin(singeolatz(i,j)) + piby2\n           jy = floor(l1/dygg) + 1\n           beta = (l1 - (jy - 1)*dygg)/dygg\n           if (jy == 1 .or. jy == nygg) then\n              ! linear interpolation\n              c2 = 1.0d0 - beta\n              c3 = beta\n              psi1 = c2*psigg(jy) + c3*psigg(jy+1)\n           else\n              ! cubic interpolation\n              c1 = -beta*(beta - 1.0d0)*(beta - 2.0d0)/6.0d0\n              c2 = 0.5d0*(beta + 1.0d0)*(beta - 1.0d0)*(beta - 2.0d0)\n              c3 = -0.5d0*(beta + 1.0d0)*beta*(beta - 2.0d0)\n              c4 = (beta + 1.0d0)*beta*(beta - 1.0d0)/6.0d0\n              psi1 = c1*psigg(jy-1) + c2*psigg(jy) + c3*psigg(jy+1) + c4*psigg(jy+2)\n           endif\n           l2 = asin(singeolatz(ip,j)) + piby2\n           jy = floor(l2/dygg) + 1\n           beta = (l2 - (jy - 1)*dygg)/dygg\n           if (jy == 1 .or. jy == nygg) then\n              ! linear interpolation\n              c2 = 1.0d0 - beta\n              c3 = beta\n              psi2 = c2*psigg(jy) + c3*psigg(jy+1)\n           else\n              ! cubic interpolation\n              c1 = -beta*(beta - 1.0d0)*(beta - 2.0d0)/6.0d0\n              c2 = 0.5d0*(beta + 1.0d0)*(beta - 1.0d0)*(beta - 2.0d0)\n              c3 = -0.5d0*(beta + 1.0d0)*beta*(beta - 2.0d0)\n              c4 = (beta + 1.0d0)*beta*(beta - 1.0d0)/6.0d0\n              psi2 = c1*psigg(jy-1) + c2*psigg(jy) + c3*psigg(jy+1) + c4*psigg(jy+2)\n           endif\n           v0(i,j) = (psi2 - psi1)/(dx*cosv(j))\n        enddo\n     enddo\n     v0(:,1) = 0.0\n     v0(:,ny+1) = 0.0\n\n     ! equilibrium phi for forced dissipative case\n     !phieqm = phi0\n     !phieqmmean = 1.0d4*gravity\n\n     do j = 1, ny\n        do i = 1, nx\n           phieqm(i,j) = 94280.0d0  &\n                - 5330.0d0*tanh((geolatp(i,j) - 0.5d0*piby2)/(0.02d0*piby2))\n        enddo\n     enddo\n\n     ! call dumpm(phieqm,'phieqm',nx,ny)\n\n     ! geopotential perturbation\n     alpha = 1.0d0/3.0d0\n     beta = 1.0d0/15.0d0\n     hpert = 120.0d0\n     lat2 = 0.5d0*piby2\n     do j = 1, ny\n        do i = 1, nx\n           l2 = geolatp(i,j)\n           coslat = cos(l2)\n           l1 = geolonp(i,j)\n           if (l1 > pi) l1 = l1 - twopi\n           e1 = exp(-(l1/alpha)**2)\n           e2 = exp(-((lat2 - l2)/beta)**2)\n           phi0(i,j) = phi0(i,j) + gravity*hpert*coslat*e1*e2\n        enddo\n     enddo\n\n  elseif (ic == 6) then\n\n     ! rossby harwitz wave\n     rrw = 4\n     wrw = 1.0*7.848e-6\n     ! wrw = twoomega/28.0  ! to obtain a stationary rh wave !\n     krw = 1.0*7.848e-6\n     phi0rw = 8.0e3*9.80616\n     ! phi0rw = 8.0e5*9.80616 ! large rossby radius ~ bve\n\n     do j = 1, ny\n        a = 0.5*wrw*(twoomega + wrw)*cosp(j)*cosp(j) &\n             + 0.25*(krw*krw*(cosp(j))**(2*rrw)) &\n             *((rrw+1)*cosp(j)*cosp(j) + (2*rrw*rrw - rrw - 2) - &\n             2*rrw*rrw*(cosp(j))**(-2))\n        b = (((twoomega + 2*wrw)*krw)/((rrw+1)*(rrw+2))) &\n             *((cosp(j))**rrw) &\n             *((rrw*rrw + 2*rrw + 2) - (rrw + 1)*(rrw + 1)*cosp(j)*cosp(j))\n        c = 0.25*krw*krw*(cosp(j)**(2*rrw))*((rrw + 1)*cosp(j)*cosp(j) - (rrw+2))\n        do i = 1, nx\n           phi0(i,j) = phi0rw &\n                + rearth*rearth*( a + b*cos(rrw*xp(i)) + c*cos(2*rrw*xp(i)) )\n           u0(i,j) = rearth*( wrw*cosp(j) &\n                +  krw*((cosp(j))**(rrw-1)) &\n                *(rrw*sinp(j)*sinp(j) - cosp(j)*cosp(j)) &\n                *cos(rrw*xu(i)) )\n        enddo\n     enddo\n\n     do j = 1, ny+1\n        do i = 1, nx\n           v0(i,j) = - rearth*krw*rrw*(cosv(j)**(rrw-1))*sinv(j)*sin(rrw*xv(i))\n        enddo\n     enddo\n\n  else\n\n     print *,'initial condition ic = ',ic,' not coded.'\n     stop\n\n  endif\n\n\n  ! save initial state for computing errors in steady test cases\n  phi_init = phi0\n  u_init = u0\n  v_init = v0\n\n\nend subroutine initial\n"}
{"id": 268, "subroutine": "subroutine timing\n\n  ! set up info on run length, time step, etc\n\n  use timeinfo\n  use constants\n  use version\n\n  implicit none\n\n  ! length of run\n  !tstop = 1296000.0d0 !15 days\n  if(ic==7)then\n     tstop = 6.0d0*day2sec !518400.0d0 !6 days\n  elseif(ic==8)then\n     tstop = 200.0d0*day2sec\n  else\n     tstop = 15.0d0*day2sec !15 days\n  end if\n  ! tstop = 12000.0\n\n  ! size of time step\n  !dt = 200.0d0\n  !dt = 400.0d0\n  !dt = 600.0d0\n  dt = 1200.0d0\n  !dt = 50.0d0 !225.0d0\n  !dt = 20.0d0 !225.0d0\n  !dt = 10800.0d0\n  hdt = 0.5d0*dt\n\n  ! off-centring parameters\n  !adt = 1.0d0*dt !(total back)\n  !adt = 0.65d0*dt !(offcenter)\n  adt = hdt  !(centred)\n  bdt = dt - adt\n\n  if ((ischeme == 3) .and. (adt .ne. hdt)) then\n     print *,'*** time scheme must be centred for slice ***'\n     print *,'*** think carefully about coupling to departure '\n     print *,'point calculation before changing ***.'\n     stop\n  endif\n\n  ! total number of steps to take\n  nstop = nint(tstop/dt)\n\n  ! number of steps between output dumps\n  !day by day\n  if(ic==7 .and. idumpref)then\n     idump = nstop/6\n  elseif(ic == 8)then\n     idump = nstop/20\n  else\n     idump = nstop/2\n  end if\n  !idump = 10\n\n  print*, \"integration period :\", tstop*sec2day, \" days\"\n  print*, \"timestep           :\", dt , \" sec\"\n  print*, \"num of time steps  :\", nstop\n  print*, \"plotting every     :\", tstop*idump/nstop*sec2day, \" days\"\n  print*, \"coriolis mtd (0-simple, 1-jt, 2-new) :\", coriolis_mtd\n  print*, \"slice    (1-off, 2-sim, 3-full) :\", ischeme\n  print*, \"offcentering       :\", adt, \"of\", dt, \" (\", adt/dt, \")\"\n\nend subroutine timing\n"}
{"id": 269, "subroutine": "subroutine integrate\n\n\n  use timeinfo\n  use alldata\n  use version\n  use errdiag\n\n  implicit none\n  real*8 ::nonlin_alpha=1.0, u_maxerr\n  real*8 :: phiforce(nx,ny), uforce(nx,ny), vforce(nx,ny+1), upert(nx,ny), tmp(nx*ny)\n  integer::i, j, iunit\n  character*512 :: yname, icname, coriname, slicename, yres, hrefname, filename\n  logical:: linearstabtest=.false.\n  !logical:: linearstabtest=.true.\n\n  ! -------------------------------------------------------\n\n  ! preliminary calculations\n  call prelim\n  print *,'done preliminaries'\n\n  istep=0\n\n  ! output initial data\n  if(idump>0)then\n     write(*,*) \"time (dys):\",  real(istep)*dt*sec2day, tstop*sec2day\n     call diagnostics(0)\n     call dumpstate(0)\n     !call outstate(0)\n\n     !adjust part of filenames\n     write(yres,*) (nx)\n     if (abs(rotgrid) > 0.00001d0) then\n        yname = \"_r\"//trim(adjustl(trim(yres)))\n     else\n        yname = \"_\"//trim(adjustl(trim(yres)))\n     end if\n     write(yres,*) (ny)\n     yname = trim(yname)//\"x\"//trim(adjustl(trim(yres)))\n\n\n     !filename for log of hollinsworth analysis\n     write(icname,'(i4.2)') ic\n     icname=trim(adjustl(trim(icname)))\n     write(coriname,'(i4.1)') coriolis_mtd\n     coriname=trim(adjustl(trim(coriname)))\n     if(ischeme>1)then\n        write(slicename,'(i4.1)') ischeme\n        slicename=\"_slice\"//trim(adjustl(trim(slicename)))\n     else\n        slicename=\"\"\n     end if\n     write(hrefname,'(f8.3)') phiref/gravity\n     hrefname=trim(adjustl(trim(hrefname)))//\"lintest\"\n     if(adt .ne. hdt)then\n        filename=\"dump/\"//\"eg_swe_ic\"//trim(icname)//\"_cor\"//trim(coriname)//&\n            \"_href\"//trim(hrefname)//trim(slicename)//&\n            \"_offcent_log\"//trim(adjustl(trim(yname)))//\".dat\"\n     else\n        filename=\"dump/\"//\"eg_swe_ic\"//trim(icname)//\"_cor\"//trim(coriname)//&\n        \"_href\"//trim(hrefname)//trim(slicename)//&\n            \"_log\"//trim(adjustl(trim(yname)))//\".dat\"\n     end if\n\n     !write values on log file\n     if(linearstabtest) then !hollingsworth test with linearizations\n        print*, \"log file:\", trim(filename)\n        call getunit(iunit)\n        open(iunit,file=filename, status='replace')\n        write(iunit, *) \"   istep    time     nonlin_alpha     u_maxerr\"\n     end if\n\n  end if\n  !print*, \"   step   nstep   time(dys)  ntime(dys)\"\n\n\n  ! loop over steps\n  do istep = 1, nstop\n\n     call step\n\n     !  call diagnostics(istep)\n     if (mod(istep,idump) == 0) then\n        !call outstate(istep)\n        call dumpstate(istep)\n     endif\n\n     ! if required write out current phi field as reference solution\n     ! for other models\n     if(idumpref)then\n        call writeref\n     endif\n\n     ! if required read in reference solution from high resolution\n     ! run and compute and write errors\n     ! call diffref\n\n     if(ic==8 .and. linearstabtest)then !hollingsworth test with linearizations\n        if(istep==1)then\n\n           !forcing\n           uforce=u_init-u\n           vforce=v_init-v\n           phiforce=phi_init-phi\n\n           !perturb phi\n           phi(nx/2, ny/2)  =phi(nx/2, ny/2)  +phi(nx/2, ny/2)  /100000.0\n           phi(nx/2+1, ny/2)=phi(nx/2+1, ny/2)+phi(nx/2+1, ny/2)/100000.0\n           phi(nx/2, ny/2+1)=phi(nx/2, ny/2+1)+phi(nx/2, ny/2+1)/100000.0\n        end if\n\n        u=u+uforce\n        v=v+vforce\n        phi=phi+phiforce\n\n        tmp=reshape(u-u_init, (/ nx*ny /))\n        !print*, size(tmp)\n        !stop\n        !u_maxerr = maxval(maxval(abs(u-u_init), dim=1))\n        u_maxerr = sqrt(dot_product(tmp, tmp)/size(tmp))\n        !print*, maxval(maxval(abs(u-u_init), dim=1)), maxval(abs(tmp)), u_maxerr\n        if(u_maxerr>0) nonlin_alpha=0.00001/u_maxerr\n\n        print '(a15, 2e16.8)', \" alpha / maxuerr:\", nonlin_alpha, u_maxerr\n        !write to log file\n        write(iunit, *) istep, istep*dt*sec2day, nonlin_alpha, u_maxerr\n        flush(iunit)\n        print *,' '\n\n        u=u_init+nonlin_alpha*(u-u_init)\n        v=v_init+nonlin_alpha*(v-v_init)\n        phi=phi_init+nonlin_alpha*(phi-phi_init)\n\n\n        u0 = u\n        v0 = v\n        phi0 = phi\n\n        ! recalculate quantities involved in departure point calculations\n        call cgridave(nx,ny,u,v,ubar,vbar)\n        call uvatphi(nx,ny,u,v,up,vp)\n        u0bar = ubar\n        v0bar = vbar\n        u0p = up\n        v0p = vp\n\n     end if\n\n\n\n\n     if (mod(istep,1) == 0) then\n        print*, \"time (dys) :\",  istep*dt*sec2day, \" of \", tstop*sec2day\n        print*, \"step = \", istep, \" of \", nstop\n        call diagnostics(istep)\n     endif\n\n    if(ic==8 )then\n        tmp=reshape(u-u_init, (/ nx*ny /))\n        u_maxerr = maxval(maxval(abs(u-u_init), dim=1))\n        if(u_maxerr > 10)then\n           print*, \"instability detected -- stopping here!!!\"\n           call dumpstate(istep)\n\n           exit\n        endif\n    end if\n\n  enddo\n  if(idump>0)then\n     !call outstate(nstop)\n     call dumpstate(nstop)\n  end if\n\n  ! call dumpm(phi+phis,'phitot',nx,ny)\n\n\n\nend subroutine integrate\n"}
{"id": 270, "subroutine": "subroutine step\n\n\n  use alldata\n  use contest\n\n  implicit none\n\n  integer :: nouter = 2, ninner = 2, iouter, iinner, ng, count\n\n  real*8 :: nu\n  real*8 :: div(nx,ny)\n\n  ! convergence diagnostics at final step\n  !if (istep == nstop) then\n  !  print *,'doing convergence test'\n  !  nouter = 20\n  !  ninner = 20\n  !endif\n\n  ! constant for helmholtz problem\n  !nu = 1.0/(hdt*hdt*phiref)\n  nu = 1.0/(adt*adt*phiref)\n\n  ! terms in momentum equation at current time level\n  call momentum\n\n  ! for semi-lagrangian version:\n  ! terms in phi equation at current time level\n  if (ischeme == 1 .or. ischeme == 2 .or. ischeme == 3) then\n     call slphieqn\n  endif\n\n  ! use current values of state variables as first guess\n  ! for new value\n  phi = phi0 \n  u = u0\n  v = v0\n  !print *,'zero first guess'\n  !phi = 0.0\n  !u = 0.0\n  !v = 0.0\n\n  ! c-grid average velocity components\n  call cgridave(nx,ny,u,v,ubar,vbar)\n  call uvatphi(nx,ny,u,v,up,vp)\n\n  ! first guess for departure points at first step\n  ! and departure areas\n  ! (at subsequent steps the first guess is taken from\n  ! the previous step).\n\n  ! pxt - uses v0bar and v0bar - which are not yet setup !\n  if(ic==8)then\n     call departurefg\n     call departurefgp\n  end if\n\n  count = 0\n\n  olddiv = 0.0\n  oldphid = 0.0\n\n  ! outer loop\n  do iouter = 1, nouter\n\n     itcount = iouter\n\n     ! save current values to examine convergence\n     ! oldu = u\n     ! oldv = v\n     ! oldphi = phi\n\n     ! recalculate departure points\n     call departure\n     call departurep\n\n     ! and modified departure points in polar regions\n     call departuremod\n\n     ! recalculate departure point terms and rhs of\n     ! phi equation\n     call up_outer\n\n     ! inner loop\n     do iinner = 1, ninner\n\n        ! save current values to examine convergence\n        !oldu = u\n        !oldv = v\n        !oldphi = phi\n\n        ! update coriolis terms and hence rhs of\n        ! helmholtz problem\n        call up_inner\n\n        ! solve helmholtz\n        ng = p - 2\n        ! ng = p - 1\n        rhs = -nu*rhs\n\n        call mgsolve(phi,rhs,nu,ng)\n\n        ! back substitute to find new u and v\n        call backsub\n\n        ! and compute corresponding c-grid average velocities\n        call cgridave(nx,ny,u,v,ubar,vbar)\n        call uvatphi(nx,ny,u,v,up,vp)\n\n        ! calculate modified velocities for polar regions\n        call modifywind\n        call cgridave(nx,ny,umod,vmod,umodbar,vmodbar)\n\n        !deltau = u - oldu\n        !deltav = v - oldv\n        !deltaphi = phi - oldphi\n\n        !count = count + 1\n        !rmsu(count) = sqrt(sum(deltau*deltau)/(nx*ny))\n        !rmsv(count) = sqrt(sum(deltav*deltav)/(nx*ny))\n        !rmsphi(count) = sqrt(sum(deltaphi*deltaphi)/(nx*ny))\n\n        ! print *,'count = ',count\n        ! print *,' diffs = ',rmsphi(count),rmsu(count),rmsv(count)\n\n     enddo\n\n     !deltau = u - oldu\n     !deltav = v - oldv\n     !deltaphi = phi - oldphi\n\n     !if (istep == nstop) then\n     ! call dump(deltaphi,'deltaphi',nx,ny)\n     ! call dump(deltau,'deltau',nx,ny)\n     ! call dump(deltav,'deltav',nx,ny+1)\n     !endif\n\n     !count = count + 1\n     !rmsu(count) = sqrt(sum(deltau*deltau)/(nx*ny))\n     !rmsv(count) = sqrt(sum(deltav*deltav)/(nx*ny))\n     !rmsphi(count) = sqrt(sum(deltaphi*deltaphi)/(nx*ny))\n\n     !print *,'count = ',count\n     !print *,' diffs = ',rmsphi(count),rmsu(count),rmsv(count)\n\n  enddo\n\n\n  ! print *,'could do a final phi update to ensure conservation'\n\n\n  phi0 = phi\n  u0 = u\n  v0 = v\n  u0bar = ubar\n  v0bar = vbar\n  u0p = up\n  v0p = vp\n  u0mod = umod\n  v0mod = vmod\n  u0modbar = umodbar\n  v0modbar = vmodbar\n\n\nend subroutine step\n"}
{"id": 271, "subroutine": "subroutine prelim\n\n  ! preliminary calculations before commencing time stepping.\n\n  use alldata\n  use contest\n\n  implicit none\n\n\n  ! gradient of orography\n  call gradphis\n\n  ! all velocity components at all points\n  call cgridave(nx,ny,u0,v0,u0bar,v0bar)\n  call uvatphi(nx,ny,u0,v0,u0p,v0p)\n\n  ! first guess for new time level fields\n  phi = phi0\n  u = u0\n  v = v0\n\n  ! all velocity components at all points\n  call cgridave(nx,ny,u,v,ubar,vbar)\n  call uvatphi(nx,ny,u,v,up,vp)\n\n  ! first guess for departure points at first step\n  ! and departure areas\n  ! (at subsequent steps the first guess is taken from\n  ! the previous step).\n  call departurefg\n  call departurefgp\n\n  ! modified winds in polar cap region\n  call modifywind\n  u0mod = umod\n  v0mod = vmod\n  call cgridave(nx,ny,u0mod,v0mod,u0modbar,v0modbar)\n  call cgridave(nx,ny,umod,vmod,umodbar,vmodbar)\n\n  ! first guess for modified departure points\n  call departuremodfg\n\nend subroutine prelim\n"}
{"id": 272, "subroutine": "subroutine departurefg\n\n  ! first guess for departure point calculation.\n  ! use velocity at old time level.\n\n  ! also first guess for departure areas\n\n  use alldata\n\n  implicit none\n  integer :: i, j\n  real*8 :: sina, cosa, x, y, r, sind, dlambda\n\n  ! u-point departure points\n  do  j = 1, ny\n     sina = sinp(j)\n     cosa = cosp(j)\n     do i = 1, nx\n        ! displacement in local cartesian system\n        x = -u0(i,j)*dt\n        y = -v0bar(i,j)*dt\n        ! project back to spherical coordinate system\n        r = sqrt(x*x + y*y + rearth*rearth)\n        sind = (y*cosa + rearth*sina)/r\n        ydu(i,j) = asin(sind)\n        dlambda = atan2(x,rearth*cosa - y*sina)\n        xdu(i,j) = modulo(xu(i) + dlambda, twopi)\n     enddo\n  enddo\n\n  ! v-point departure points\n  do  j = 2, ny\n     sina = sinv(j)\n     cosa = cosv(j)\n     do i = 1, nx\n        ! displacement in local cartesian system\n        x = -u0bar(i,j)*dt\n        y = -v0(i,j)*dt\n        ! project back to spherical coordinate system\n        r = sqrt(x*x + y*y + rearth*rearth)\n        sind = (y*cosa + rearth*sina)/r\n        ydv(i,j) = asin(sind)\n        dlambda = atan2(x,rearth*cosa - y*sina)\n        xdv(i,j) = modulo(xv(i) + dlambda, twopi)\n     enddo\n  enddo\n\n  ! departure areas. first guess equals arrival areas\n  ! do j = 1, ny\n  !   aread(:,j) = area(j)\n  ! enddo\n\n\nend subroutine departurefg\n"}
{"id": 273, "subroutine": "subroutine cgridave(nx,ny,u,v,ubar,vbar)\n\n  ! to average u to v points and v to u points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny)\n  real*8 ,intent(inout) :: v(nx,ny+1)\n  real*8, intent(out) :: ubar(nx,ny+1), vbar(nx,ny)\n\n  integer :: i, im, ip, j, jm, jp\n\n  ! deal with polar values first, as we need to reconstruct\n  ! polar v values as well as u values\n  call polar(u,ubar(:,1),v(:,1),ubar(:,ny+1),v(:,ny+1))\n\n  ! u at v points\n  do j = 2, ny\n     jm = j-1\n     do i = 1, nx\n        ip = i+1\n        if (i == nx) ip = 1\n        ubar(i,j) = 0.25*(u(i,jm)+u(i,j)+u(ip,jm)+u(ip,j))\n     enddo\n  enddo\n\n  ! v at u points\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        im = i-1\n        if (im == 0) im = nx\n        vbar(i,j) = 0.25*(v(im,j)+v(im,jp)+v(i,j)+v(i,jp))\n     enddo\n  enddo\n\n\nend subroutine cgridave\n"}
{"id": 274, "subroutine": "subroutine polar(u,usp,vsp,unp,vnp)\n\n  ! determine polar values of u and v from u at nearest\n  ! u-latitude. also used for rhs of momentum equation.\n\n  use grid\n\n  implicit none\n\n  real*8, intent(in) :: u(nx,ny)\n  real*8, intent(out) :: usp(nx), vsp(nx), unp(nx), vnp(nx)\n  real*8 :: a, b, lambda, vp\n\n  ! south pole\n  a = sum(u(:,1)*sin(xu(:)))\n  b = sum(u(:,1)*cos(xu(:)))\n  lambda = atan2(b,-a)\n  vp = (-a*cos(lambda) + b*sin(lambda))*2.0/nx\n  vsp(:) = vp*cos(xv(:) - lambda)\n  usp(:) = -vp*sin(xv(:) - lambda)\n\n  ! north pole\n  a = sum(u(:,ny)*sin(xu(:)))\n  b = sum(u(:,ny)*cos(xu(:)))\n  lambda = atan2(-b,a)\n  vp = (a*cos(lambda) - b*sin(lambda))*2.0/nx\n  vnp(:) = vp*cos(xv(:) - lambda)\n  unp(:) = vp*sin(xv(:) - lambda)\n\n\nend subroutine polar\n"}
{"id": 275, "subroutine": "subroutine coriolis(u,v,phi,fu,fv)\n  ! pxt - added variations\n\n  use grid\n  use constants\n  use version\n\n  implicit none\n\n  ! integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny), phi(nx,ny)\n  !real*8, intent(out) :: fu(nx,ny), fv(nx,ny)\n  real*8, intent(out) :: fu(nx,ny+1), fv(nx,ny)\n  real*8 :: tempv(nx,ny+1), tempu(nx,ny), tempp(nx,ny)\n\n\n  if(coriolis_mtd==0)then\n     call coriolis_simple(u,v,phi,fu,fv)\n\n  elseif(coriolis_mtd==1)then\n     call coriolis_jt(u,v,phi,fu,fv)\n\n  elseif(coriolis_mtd==2)then\n     call coriolis_new(u,v,phi,fu,fv)\n\n  else\n     print*, \"error: unknown coriolis scheme:\", coriolis_mtd\n     stop\n  end if\n\ncontains\n\n  subroutine coriolis_jt(u,v,phi,fu,fv)\n\n    ! to evaluate the coriolis terms on the c-grid,\n    ! taking account of energy conservation and improved\n    ! rossby mode dispersion\n\n    use grid\n    use constants\n\n    implicit none\n\n    ! integer, intent(in) :: nx, ny\n    real*8, intent(in) :: u(nx,ny), v(nx,ny), phi(nx,ny)\n    !real*8, intent(out) :: fu(nx,ny), fv(nx,ny)\n    real*8, intent(out) :: fu(nx,ny+1), fv(nx,ny)\n    real*8 :: tempv(nx,ny+1), tempu(nx,ny), tempp(nx,ny)\n\n    integer :: i, im, ip, j, jm, jp\n\n    ! ------\n\n    ! phi v cos(lat) at v points\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          tempv(i,j) = 0.5*(phi(i,jm) + phi(i,j)) *cosv(j)*v(i,j)\n       enddo\n    enddo\n    ! zero at polar latitudes\n    tempv(:,1) = 0.0\n    tempv(:,ny+1) = 0.0\n\n    ! average to phi points and times f / phi\n    do j = 1, ny\n       jp = j + 1\n       do i = 1, nx\n          tempp(i,j) = 0.5*(tempv(i,j) + tempv(i,jp))*twoomega*singeolatp(i,j)/phi(i,j)\n       enddo\n    enddo\n\n    ! average to u points and divide by cos(lat) to get\n    ! fv at u points\n    do j = 1, ny\n       do i = 1, nx\n          im = i-1\n          if (im == 0) im = nx\n          fv(i,j) = 0.5*(tempp(im,j) + tempp(i,j)) /cosp(j)\n       enddo\n    enddo\n\n    ! ------\n\n    ! phi u at u points\n    do j = 1, ny\n       do i = 1, nx\n          im = i - 1\n          if (im == 0) im = nx\n          tempu(i,j) = 0.5*(phi(im,j) + phi(i,j))*u(i,j)\n       enddo\n    enddo\n\n    ! average to phi points and times f / phi\n    do j = 1, ny\n       do i = 1, nx\n          ip = i + 1\n          if (i == nx) ip = 1\n          tempp(i,j) = 0.5*(tempu(i,j) + tempu(ip,j))*twoomega*singeolatp(i,j)/phi(i,j)\n       enddo\n    enddo\n\n    ! average to v points to get\n    ! fu at v points\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          fu(i,j) = 0.5*(tempp(i,jm) + tempp(i,j))\n       enddo\n    enddo\n    ! zero at polar latitudes\n    fu(:,1) = 0.0\n    fu(:,ny+1) = 0.0\n\n    ! ------\n\n  end subroutine coriolis_jt\n\n  ! ========================================================\n\n  subroutine coriolis_new(u,v,phi,fu,fv)\n\n    ! to evaluate the coriolis terms on the c-grid,\n    ! taking account of energy conservation and improved\n    ! stability (but probably impairing rossby mode dispersion)\n\n    use grid\n    use constants\n\n    implicit none\n\n    ! integer, intent(in) :: nx, ny\n    real*8, intent(in) :: u(nx,ny), v(nx,ny), phi(nx,ny)\n    !real*8, intent(out) :: fu(nx,ny), fv(nx,ny)\n    real*8, intent(out) :: fu(nx,ny+1), fv(nx,ny)\n    real*8 :: tempv(nx,ny+1), tempu(nx,ny), tempz(nx,ny+1), tempz2(nx,ny+1)\n\n    integer :: i, im, ip, j, jm, jp\n\n    ! ------\n\n    ! phi at vorticity points\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          im = i - 1\n          if (im == 0) im = nx\n          tempz2(i,j) = 0.25*(phi(im,jm) + phi(im,j) + phi(i,jm) + phi(i,j))\n       enddo\n    enddo\n\n    ! ------\n\n    ! phi v cos(lat) at v points\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          tempv(i,j) = 0.5*(phi(i,jm) + phi(i,j)) *cosv(j)*v(i,j)\n       enddo\n    enddo\n    ! zero at polar latitudes\n    tempv(:,1) = 0.0\n    tempv(:,ny+1) = 0.0\n\n    ! average to vorticity points and times f / phi\n    do j = 2, ny\n       do i = 1, nx\n          im = i-1\n          if (im == 0) im = nx\n          tempz(i,j) = 0.5*(tempv(im,j) + tempv(i,j))*twoomega*singeolatz(i,j)/tempz2(i,j)\n       enddo\n    enddo\n    tempz(:,1) = 0.0d0\n    tempz(:,ny+1) = 0.0d0\n\n    ! average to u points and divide by cos(lat) to get\n    ! fv at u points\n    do j = 1, ny\n       jp = j + 1\n       do i = 1, nx\n          fv(i,j) = 0.5*(tempz(i,j) + tempz(i,jp)) /cosp(j)\n       enddo\n    enddo\n\n    ! ------\n\n    ! phi u at u points\n    do j = 1, ny\n       do i = 1, nx\n          im = i - 1\n          if (im == 0) im = nx\n          tempu(i,j) = 0.5*(phi(im,j) + phi(i,j))*u(i,j)\n       enddo\n    enddo\n\n    ! average to vorticity points and times f / phi\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          tempz(i,j) = 0.5*(tempu(i,jm) + tempu(i,j))*twoomega*singeolatz(i,j)/tempz2(i,j)\n       enddo\n    enddo\n\n    ! average to v points to get\n    ! fu at v points\n    do j = 2, ny\n       do i = 1, nx\n          ip = i + 1\n          if (i == nx) ip = 1\n          fu(i,j) = 0.5*(tempz(i,j) + tempz(ip,j))\n       enddo\n    enddo\n    ! zero at polar latitudes\n    fu(:,1) = 0.0\n    fu(:,ny+1) = 0.0\n\n    ! ------\n\n  end subroutine coriolis_new\n\n  ! ========================================================\n\n  subroutine coriolis_simple(u,v,phi,fu,fv)\n\n    ! coriolis term calculate in a simple way to avoid instability\n    ! pxt - pedro peixoto mar 2016\n\n    use grid\n    use constants\n\n    implicit none\n\n    ! integer, intent(in) :: nx, ny\n    real*8, intent(in) :: u(nx,ny), v(nx,ny), phi(nx,ny)\n    !real*8, intent(out) :: fu(nx,ny), fv(nx,ny)\n    real*8, intent(out) :: fu(nx,ny+1), fv(nx,ny)\n    real*8 :: tempv(nx,ny+1), tempu(nx,ny), tempp(nx,ny)\n\n    integer :: i, im, ip, j, jm, jp\n\n    ! ------\n\n\n    ! average v to phi points and times f\n    do j = 1, ny\n       jp = j + 1\n       do i = 1, nx\n          tempp(i,j) = 0.5*(v(i,j) + v(i,jp))*twoomega*singeolatp(i,j)\n       enddo\n    enddo\n\n    ! average to u points to get\n    ! fv at u points\n    do j = 1, ny\n       do i = 1, nx\n          im = i-1\n          if (im == 0) im = nx\n          fv(i,j) = 0.5*(tempp(im,j) + tempp(i,j))\n       enddo\n    enddo\n\n    ! ------\n\n    ! u at u points\n    tempu=u\n\n    ! average to phi points and times f\n    do j = 1, ny\n       do i = 1, nx\n          ip = i + 1\n          if (i == nx) ip = 1\n          tempp(i,j) = 0.5*(tempu(i,j) + tempu(ip,j))*twoomega*singeolatp(i,j)\n       enddo\n    enddo\n\n    ! average to v points to get\n    ! fu at v points\n    do j = 2, ny\n       jm = j - 1\n       do i = 1, nx\n          fu(i,j) = 0.5*(tempp(i,jm) + tempp(i,j))\n       enddo\n    enddo\n    ! zero at polar latitudes\n    fu(:,1) = 0.0\n    fu(:,ny+1) = 0.0\n\n    ! ------\n\n  end subroutine coriolis_simple\n\nend subroutine coriolis\n"}
{"id": 276, "subroutine": "subroutine departure\n\n  ! calculate departure points for a given estimate\n  ! of the current and new u and v and their spatial\n  ! averages\n\n\n  use alldata\n\n  implicit none\n\n  !pxt - original was 2\n  integer :: ndepit = 10, idepit, i, j, k, l, kp, lp, k1, k1p, k2, k2p, &\n       hnx\n\n  real*8 :: a1, a2, b1, b2, ud, vd, sina, cosa, sind, cosd, rk, rl, &\n       flip1, flip2, sinad, cosad, sdl, cdl, den, urot, vrot, &\n       m11, m12, m21, m22, x, y, r, dlambda\n\n\n  ! ---------------------------------------------------------\n\n\n  ! handy quantity for polar interpolation\n  hnx = nx/2\n\n  ! loop over iterations\n  do idepit = 1, ndepit\n\n     ! u-point departure points\n     do  j = 1, ny\n\n        sina = sinp(j)\n        cosa = cosp(j)\n        do i = 1, nx\n\n           ! trig factors at estimated departure point\n           sind = sin(ydu(i,j))\n           cosd = cos(ydu(i,j))\n\n           ! determine departure cell index based on latest estimate\n           ! xdu, ydu\n           rk = (xdu(i,j) - xu(1))/dx\n           k = floor(rk)\n           a2 = rk - k\n           a1 = 1.0 - a2\n           k = modulo(k, nx) + 1\n           rl = (ydu(i,j) - yu(1))/dy\n           l = floor(rl)\n           b2 = rl - l\n           b1 = 1.0 - b2\n           l = l + 1\n           ! l = 0 or l = ny ??\n           kp = k+1\n           if (k == nx) kp = 1\n           lp = l+1\n\n           ! tricks to handle polar case\n           ! here we interpolate across the pole.\n           ! (an alternative would be to use the polar values of u and v\n           ! and interpolate between nearest u latitude and the pole.)\n           k1 = k\n           k1p = kp\n           k2 = k\n           k2p = kp\n           flip1 = 1.0\n           flip2 = 1.0\n           if (l == 0) then ! south pole\n              l = 1\n              k1 = modulo(k1 + hnx - 1, nx) + 1\n              k1p = modulo(k1p + hnx - 1, nx ) + 1\n              flip1 = -1.0\n           elseif(l == ny) then ! north pole\n              lp = ny\n              k2 = modulo(k2 + hnx - 1, nx) + 1\n              k2p = modulo(k2p + hnx - 1, nx ) + 1\n              flip2 = -1.0\n           endif\n\n           ! linearly interpolate  velocity to estimated departure point\n           ud = (a1*b1*u0(k1,l) &\n                + a2*b1*u0(k1p,l))*flip1 &\n                + (a1*b2*u0(k2,lp) &\n                + a2*b2*u0(k2p,lp))*flip2\n           vd = (a1*b1*v0bar(k1,l) &\n                + a2*b1*v0bar(k1p,l))*flip1 &\n                + (a1*b2*v0bar(k2,lp) &\n                + a2*b2*v0bar(k2p,lp))*flip2\n\n           ! rotate to arrival point cartesian system\n           sinad = sina*sind\n           cosad = cosa*cosd\n           sdl = sin(xu(i) - xdu(i,j))\n           cdl = cos(xu(i) - xdu(i,j))\n           den = 1.0 + sinad + cosad*cdl\n           m11 = (cosad + (1.0 + sinad)*cdl) / den\n           m12 = (sina + sind)*sdl / den\n           m21 = -m12\n           m22 = m11\n           urot = ud*m11 + vd*m12\n           vrot = ud*m21 + vd*m22\n\n           ! hence calculate better estimate of departure point\n           ! in arrival point cartesian system\n           x = -hdt*(u(i,j) + urot)\n           y = -hdt*(vbar(i,j) + vrot)\n\n           ! project back to spherical coordinate system\n           r = sqrt(x*x + y*y + rearth*rearth)\n           sind = (y*cosa + rearth*sina)/r\n           ydu(i,j) = asin(sind)\n           dlambda = atan2(x,rearth*cosa - y*sina)\n           xdu(i,j) = modulo(xu(i) + dlambda, twopi)\n\n        enddo\n     enddo\n\n\n     ! v-point departure points\n     do  j = 2, ny\n        sina = sinv(j)\n        cosa = cosv(j)\n        do i = 1, nx\n\n           ! trig factors at estimated departure point\n           sind = sin(ydv(i,j))\n           cosd = cos(ydv(i,j))\n\n           ! determine departure cell index based on latest estimate\n           ! xdv, ydv\n           rk = (xdv(i,j) - xv(1))/dx\n           k = floor(rk)\n           a2 = rk - k\n           a1 = 1.0 - a2\n           k = modulo(k, nx) + 1\n           rl = (ydv(i,j) - yv(1))/dy\n           l = floor(rl)\n           b2 = rl - l\n           b1 = 1.0 - b2\n           l = l + 1\n           kp = k+1\n           if (k == nx) kp = 1\n           lp = l+1\n\n           ! linearly interpolate  velocity to estimated departure point\n           ud = a1*b1*u0bar(k,l) &\n                + a2*b1*u0bar(kp,l) &\n                + a1*b2*u0bar(k,lp) &\n                + a2*b2*u0bar(kp,lp)\n           vd = a1*b1*v0(k,l) &\n                + a2*b1*v0(kp,l) &\n                + a1*b2*v0(k,lp) &\n                + a2*b2*v0(kp,lp)\n\n           ! rotate to arrival point cartesian system\n           sinad = sina*sind\n           cosad = cosa*cosd\n           sdl = sin(xv(i) - xdv(i,j))\n           cdl = cos(xv(i) - xdv(i,j))\n           den = 1.0 + sinad + cosad*cdl\n           m11 = (cosad + (1.0 + sinad)*cdl) / den\n           m12 = (sina + sind)*sdl / den\n           m21 = -m12\n           m22 = m11\n           urot = ud*m11 + vd*m12\n           vrot = ud*m21 + vd*m22 \n\n           ! hence calculate better estimate of departure point\n           ! in arrival point cartesian system\n           x = -hdt*(ubar(i,j) + urot)\n           y = -hdt*(v(i,j) + vrot)\n\n           ! project back to spherical coordinate system\n           r = sqrt(x*x + y*y + rearth*rearth)\n           sind = (y*cosa + rearth*sina)/r\n           ydv(i,j) = asin(sind)\n           dlambda = atan2(x,rearth*cosa - y*sina)\n           xdv(i,j) = modulo(xv(i) + dlambda, twopi)\n\n        enddo\n     enddo\n\n  enddo\n\n\nend subroutine departure\n"}
{"id": 277, "subroutine": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"}
{"id": 278, "subroutine": "subroutine slice1d(xg,xd,domain,q,qnew,qg,n)\n\n  ! to use the slice-1d algorithm to conservatively\n  ! advect a quantity q on a one-dimensional periodic\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), domain, q(n)\n  real*8, intent(out) :: qnew(n), qg(n)\n  integer :: i, idx(n), im, ip, k, j, length, jj\n  real*8 :: a(n), b(n), c(n), r(n), dx(n), rdx(n), xi(n), &\n       part(n), a0(n), a1(n), a2(n), xx, sum\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n\n     ip = modulo(i,n)+1\n     dx(i) = modulo(xg(ip) - xg(i), domain)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure cells\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n) .or. xd(i) .le. xg(1)) then\n        k = n\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n),1)\n        ! safety check for irregular grid\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n     endif\n     idx(i) = k\n     xi(i) = modulo(xd(i) - xg(k),domain)*rdx(k)\n  enddo\n\n  ! set up coefficients for tridiagonal problem\n  ! to determine parabolic spline fit\n  do i = 1, n\n     im = i-1\n     if (i == 1) im = n\n     a(i) = rdx(im)\n     b(i) = 2.0*(rdx(im) + rdx(i))\n     c(i) = rdx(i)\n     r(i) = 3.0*(q(im)*rdx(im) + q(i)*rdx(i))\n  enddo\n\n  ! solve tridiagonal problem\n  ! to obtain cell edge values qg\n  call trisolve(qg,a,b,c,r,n)\n\n  ! hence find coefficients of parabolas\n  do i = 1, n\n     ip = i + 1\n     if (i == n) ip = 1\n     a0(i) = qg(i)\n     a1(i) = -2*qg(i) - qg(ip) + 3*q(i)    ! zws coeff / 2\n     a2(i) = qg(i) + qg(ip) - 2*q(i)       ! zws coeff / 3\n  enddo\n\n  ! compute partial integrals for each departure point\n  ! and grid point value of q at departure point\n  do i = 1, n\n     k = idx(i)\n     xx = xi(i)\n     part(i) = ((((a2(k)*xx + a1(k))*xx) + a0(k))*xx)*dx(k)\n     qg(i) = (3.0*a2(k)*xx + 2.0*a1(k))*xx + a0(k)\n  enddo\n\n  ! finally compute integrals between departure points\n  ! and update values of q\n  do i = 1, n\n     ip = i + 1\n     if (i == n) ip = 1\n     sum = part(ip) - part(i)\n     length = modulo(idx(ip) - idx(i), n)\n     do j = 1,length\n        jj = modulo(idx(i) + j - 2,n) + 1\n        sum = sum + q(jj)*dx(jj)\n     enddo\n     qnew(i) = sum*rdx(i)\n  enddo\n\n\n\nend subroutine slice1d\n"}
{"id": 279, "subroutine": "subroutine slice1db(xg,xd,q,qnew,qg,n)\n\n  ! to use the slice-1d algorithm to conservatively\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n+1), xd(n+1), q(n)\n  real*8, intent(out) :: qnew(n), qg(n+1)\n  integer :: i, idx(n+1), im, ip, k, j, length, jj\n  real*8 :: a(n+1), b(n+1), c(n+1), r(n+1), dx(n), rdx(n), xi(n+1), &\n       part(n+1), a0(n), a1(n), a2(n), xx, sum\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure cells\n  ! and fractions of cells\n  ! xd(1) should equal xg(1) and\n  ! xd(n+1) should equal xg(n+1)\n\n  do i = 1, n+1\n     if (xd(i) .ge. xg(n)) then\n        k = n\n     elseif (xd(i) .le. xg(1)) then\n        k = 1\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n     endif\n     idx(i) = k\n     xi(i) = (xd(i) - xg(k))*rdx(k)\n  enddo\n\n  ! set up coefficients for tridiagonal problem\n  ! to determine parabolic spline fit\n  !\n  ! for  n-s sweep on sphere bc's should be zero when using distance\n  ! as the coordinate (1/8/08)\n  ! but should remain zero gradient when using area as coordinate\n  ! (3/8/08)\n  !\n  a(1) = 0.0\n  b(1) = 2.0\n  c(1) = 1.0\n  r(1) = 3.0*q(1)\n  ! a(1) = 0.0\n  ! b(1) = 1.0\n  ! c(1) = 0.0\n  ! r(1) = 0.0\n  do i = 2, n\n     im = i-1\n     a(i) = rdx(im)\n     b(i) = 2.0*(rdx(im) + rdx(i))\n     c(i) = rdx(i)\n     r(i) = 3.0*(q(im)*rdx(im) + q(i)*rdx(i))\n  enddo\n  a(n+1) = 1.0\n  b(n+1) = 2.0\n  c(n+1) = 0.0\n  r(n+1) = 3.0*q(n)\n  ! a(n+1) = 0.0\n  ! b(n+1) = 1.0\n  ! c(n+1) = 0.0\n  ! r(n+1) = 0.0\n  ! solve tridiagonal problem\n  ! to obtain cell edge values qg\n  call trisolveb(qg,a,b,c,r,n+1)\n\n  ! hence find coefficients of parabolas\n  do i = 1, n\n     ip = i + 1\n     a0(i) = qg(i)\n     a1(i) = -2*qg(i) - qg(ip) + 3*q(i)    ! zws coeff / 2\n     a2(i) = qg(i) + qg(ip) - 2*q(i)       ! zws coeff / 3\n  enddo\n\n  ! compute partial integrals for each departure point\n  ! and grid point value of q at departure point\n  do i = 1, n+1\n     k = idx(i)\n     xx = xi(i)\n     part(i) = ((((a2(k)*xx + a1(k))*xx) + a0(k))*xx)*dx(k)\n     qg(i) = (3.0*a2(k)*xx + 2.0*a1(k))*xx + a0(k)\n  enddo\n\n  ! finally compute integrals between departure points\n  ! and update values of q\n  do i = 1, n\n     ip = i + 1\n     sum = part(ip) - part(i)\n     length = idx(ip) - idx(i)\n     do j = 0,length - 1\n        jj = idx(i) + j\n        sum = sum + q(jj)*dx(jj)\n     enddo\n     qnew(i) = sum*rdx(i)\n  enddo\n\n\nend subroutine slice1db\n"}
{"id": 280, "subroutine": "subroutine slice2d(xdu,ydu,xdv,ydv,q,qnew)\n\n  ! to advect a quantity q using the 2d slice algorithm\n\n  use version\n  use grid\n  use util\n\n  implicit none\n\n  real*8, intent(in) :: xdu(nx,ny), ydu(nx,ny), xdv(nx,ny+1), ydv(nx,ny+1), &\n       q(nx,ny)\n  real*8, intent(out) :: qnew(nx,ny)\n  integer :: i, im, j, jm, jp\n  real*8 :: xiecv(nx,ny), a1, a2, yy, domain, hdomain, &\n       qx(nx), qxnew(nx), qy(ny), qynew(ny), qgx(nx), qgy(ny+1), &\n       s(ny+1), ds(ny), silcv(ny+1), x1, x2, s1, s2, deltax, deltay, &\n       slen, hslen, dsi(ny), den, cl, &\n       xdc(nx,ny+1), ydc(nx,ny+1), y1, y2, &\n       xtemp(ny), xdu2(ny), dxdu(ny), dq, qcorr(nx,ny), &\n       dmdxu(nx,ny)\n\n\n  ! useful constants\n  domain = twopi\n  hdomain = 0.5*domain\n\n\n  ! estimate departure points for cell corners\n  ! used for c-grid correction to slice\n  do i = 1, nx\n     im = i - 1\n     if (i == 1) im = nx\n     do j = 2, ny\n        jm = j - 1\n        x1 = xdv(im,j)\n        x2 = xdv(i,j)\n        y1 = ydu(i,jm)\n        y2 = ydu(i,j)\n        if (x1 .gt. x2) x2 = x2 + domain\n        xdc(i,j) = modulo(0.5*(x1 + x2),domain)\n        ydc(i,j) = modulo(0.5*(y1 + y2),domain)\n     enddo\n  enddo\n  ! polar corners\n  xdc(:,1) = xdu(:,1)\n  ydc(:,1) = -piby2\n  xdc(:,ny+1) = xdu(:,ny)\n  ydc(:,ny+1) = piby2\n\n\n  ! loop over rows\n  do j = 1, ny\n\n     ! find x values of ends of intermediate eulerian control volumes\n     yy = yu(j)\n     do i = 1, nx\n        ! find indices to u departure points to\n        ! north and south of yu(j)\n        jm = j\n        jp = j\n        deltay = ydu(i,j) - yy\n        if (deltay .gt. 0.0) then\n           do while (deltay .gt. 0.0)\n              jm = jm - 1\n              if (jm > 0 ) then\n                 deltay = ydu(i,jm) - yy\n              else\n                 deltay = -1.0\n              endif\n           enddo\n           jp = jm + 1\n        else\n           do while (deltay .le. 0.0)\n              jp = jp + 1\n              if (jp < ny + 1) then\n                 deltay = ydu(i,jp) - yy\n              else\n                 deltay = 1.0\n              endif\n           enddo\n           jm = jp - 1\n        endif\n        ! assume polar points fixed\n        if (jm == 0) then\n           y1 = -piby2\n           x1 = xu(i)\n           y2 = ydu(i,jp)\n           x2 = xdu(i,jp)\n        elseif (jp == ny+1) then\n           y1 = ydu(i,jm)\n           x1 = xdu(i,jm)\n           y2 = piby2\n           x2 = xu(i)\n        else\n           y1 = ydu(i,jm)\n           x1 = xdu(i,jm)\n           y2 = ydu(i,jp)\n           x2 = xdu(i,jp)\n        endif\n        den = y2 - y1\n        a1 = (y2 - yy)/den\n        a2 = 1.0 - a1\n        x1 = xu(i) + near(x1 - xu(i),domain)\n        x2 = xu(i) + near(x2 - xu(i),domain)\n        xiecv(i,j) = modulo(a1*x1 + a2*x2,domain)\n     enddo\n\n     ! remap to intermediate control volumes\n     qx = q(:,j)\n     call slice1d(xu,xiecv(:,j),domain,qx,qxnew,qgx,nx)\n\n\n     ! mass in intermediate control volumes\n     qnew(:,j) = qxnew*area(j)\n\n     ! q at u-edges of intermediate control volumes\n     dmdxu(:,j) = qgx\n\n  enddo\n\n\n  ! initialize correction to q\n  qcorr = 0.0\n\n\n  ! loop over columns\n  do i = 1, nx\n\n     ! define coordinate s at top and bottom of lagrangian\n     ! control volumes (assume polar departure points are\n     ! defined to be at the poles)\n     s(1) = 0.0\n     do j = 2, ny+1\n        jm = j - 1\n        deltax = xdv(i,j) - xdv(i,jm)\n        if (deltax .gt. hdomain) then\n           deltax = deltax - domain\n        elseif (deltax .lt. -hdomain) then\n           deltax = deltax + domain\n        endif\n        deltay = ydv(i,j) - ydv(i,jm)\n        ! approximation to spherical distances\n        cl = cos(0.5*(ydv(i,j) + ydv(i,jm)))\n        deltax=cl*deltax\n        ds(jm) = sqrt(deltax*deltax + deltay*deltay)\n        s(j) = s(jm) + ds(jm)\n     enddo\n     slen = s(ny+1)\n     hslen = 0.5*slen\n\n     ! find s values of ends of\n     ! intermediate lagrangian control volumes\n     do j = 2, ny\n        yy = yv(j)\n        ! find indices to v departure points to\n        ! north and south of yv(j)\n        jm = j\n        jp = j\n        deltay = ydv(i,j) - yy\n        if (deltay .gt. 0.0) then\n           do while (deltay .gt. 0.0)\n              jm = jm - 1\n              if (jm > 0 ) then\n                 deltay = ydv(i,jm) - yy\n              else\n                 deltay = -1.0\n              endif\n           enddo\n           jp = jm + 1\n        else\n           do while (deltay .le. 0.0)\n              jp = jp + 1\n              if (jp < ny + 1) then\n                 deltay = ydu(i,jp) - yy\n              else\n                 deltay = 1.0\n              endif\n           enddo\n           jm = jp - 1\n        endif\n        den = ydv(i,jp) - ydv(i,jm)\n        a1 = (ydv(i,jp) - yy)/den\n        a2 = 1.0 - a1\n        s1 = s(jm)\n        s2 = s(jp)\n        silcv(j) = a1*s1 + a2*s2\n     enddo\n     silcv(1) = s(1)\n     silcv(ny+1) = s(ny+1)\n     do j = 1, ny\n        jp = j + 1\n        dsi(j) = silcv(jp) - silcv(j)\n     enddo\n\n     ! remap to lagrangian control volumes\n     qy(:) = qnew(i,:)/dsi(:)\n     call slice1db(silcv,s,qy,qynew,qgy,ny)\n\n     ! mass in lagrangian control volumes\n     ! equals mass in eulerian arrival control volumes.\n     ! divide by area to get density\n     qnew(i,:) = qynew(:)*dsi(:)/area(:)\n\n  enddo\n\n\n  ! c-grid correction to slice\n  ! effect should be small so use linear interpolation,\n  ! and interpolate in y rather than s\n\n  do i = 1, nx\n\n     im = i - 1\n     if (i == 1) im = nx  \n\n     ! estimate q at cell edge as average of cell values\n     ! either side\n     do j = 1, ny\n        ! jp = j + 1\n        ! deltay = modulo(ydc(i,jp) - ydc(i,j),domain)\n        ! dmdxu(i,j) = 0.5*(qnew(im,j) + qnew(i,j))*deltay/area(j)\n        ! print *,'check c-grid correction '\n        dmdxu(i,j) = 0.5*(qnew(im,j) + qnew(i,j))/dx\n     enddo\n\n     ! interpolate xd from edges of intermediate eulerian cvs\n     ! to edges of lagrangian cvs\n     ! being careful about wrap-around\n     xtemp = xiecv(i,1:ny)\n     do j = 1, ny\n        xtemp(j) = xu(i) + near(xtemp(j) - xu(i), domain)\n     enddo\n     call lin1db(yu,ydu(i,1:ny),xtemp,xdu2,ny)\n\n     ! compare estimate with the true xdu\n     do j = 1, ny\n        dxdu(j) = near(xdu(i,j) - xdu2(j), domain)\n     enddo\n\n     ! correction to masses in cells either side\n     do j = 1, ny\n        dq = dxdu(j)*dmdxu(i,j)\n        qcorr(i,j) = qcorr(i,j) - dq\n        qcorr(im,j) = qcorr(im,j) + dq \n     enddo\n\n  enddo\n\n\n  if (cgridcorr == 1) then\n     ! correct q\n     qnew = qnew + qcorr\n  endif\n\n\nend subroutine slice2d\n"}
{"id": 281, "subroutine": "subroutine slice2da(xdu,ydu,xdv,ydv,aread,q,qnew)\n\n  ! to advect a quantity q using the 2d slice algorithm\n  ! in this version the departure cell areas are specified and\n  ! integrated cell area is used as the coordinate for remapping\n  ! in the n-s sweeps.\n\n  ! no need for c-grid correction in this version (departure areas\n  ! already feel the c-grid divergence, and any correction would\n  ! compromise the departure cell areas).\n\n  use version\n  use grid\n  use util\n\n  implicit none\n\n  ! note xdv and ydv are not actually used \n  real*8, intent(in) :: xdu(nx,ny), ydu(nx,ny), xdv(nx,ny+1), ydv(nx,ny+1), &\n       q(nx,ny), aread(nx,ny)\n  real*8, intent(out) :: qnew(nx,ny)\n  integer :: i, ip, j, jm, jp\n  real*8 :: xiecv(nx,ny), a1, a2, yy, domain, hdomain, &\n       qx(nx), qxnew(nx), qy(ny), qynew(ny), qgx(nx), qgy(ny+1), &\n       s(ny+1), silcv(ny+1), x1, x2, deltay, &\n       slen, den, &\n       y1, y2, aicv(nx,ny), fac, astripd(nx), astripi(nx), &\n       acorr(nx), xcorr(nx), dabar, dxbar\n\n\n  ! useful constants\n  domain = twopi\n  hdomain = 0.5*domain\n\n  ! first find ends of intermediate control volumes and corresponding\n  ! intermediate areas; hence find corresponding total area\n  ! in each n-s strip for comparison with total arrival cell area\n  ! in each n-s strip.\n  astripi = 0.0\n  astripd = 0.0\n  do j = 1, ny\n\n     yy = yu(j)\n     do i = 1, nx\n        ! find indices to u departure points to\n        ! north and south of yu(j)\n        jm = j\n        jp = j\n        deltay = ydu(i,j) - yy\n        if (deltay .gt. 0.0) then\n           do while (deltay .gt. 0.0)\n              jm = jm - 1\n              if (jm > 0 ) then\n                 deltay = ydu(i,jm) - yy\n              else\n                 deltay = -1.0\n              endif\n           enddo\n           jp = jm + 1\n        else\n           do while (deltay .le. 0.0)\n              jp = jp + 1\n              if (jp < ny + 1) then\n                 deltay = ydu(i,jp) - yy\n              else\n                 deltay = 1.0\n              endif\n           enddo\n           jm = jp - 1\n        endif\n        ! assume polar points fixed\n        if (jm == 0) then\n           y1 = -piby2\n           x1 = xu(i)\n           y2 = ydu(i,jp)\n           x2 = xdu(i,jp)\n        elseif (jp == ny+1) then\n           y1 = ydu(i,jm)\n           x1 = xdu(i,jm)\n           y2 = piby2\n           x2 = xu(i)\n        else\n           y1 = ydu(i,jm)\n           x1 = xdu(i,jm)\n           y2 = ydu(i,jp)\n           x2 = xdu(i,jp)\n        endif\n        den = y2 - y1\n        a1 = (y2 - yy)/den\n        a2 = 1.0 - a1\n        x1 = xu(i) + near(x1 - xu(i),domain)\n        x2 = xu(i) + near(x2 - xu(i),domain)\n        xiecv(i,j) = modulo(a1*x1 + a2*x2,domain)\n     enddo\n\n     ! note areas of intermediate control volumes and accumulate\n     ! areas in strips\n     do i = 1, nx\n        ip = i + 1\n        if (i == nx) ip = 1\n        aicv(i,j) = near((xiecv(ip,j) - xiecv(i,j)),domain)*dy*cosp(j)\n        astripi(i) = astripi(i) + aicv(i,j)\n        astripd(i) = astripd(i) + aread(i,j)\n     enddo\n\n  enddo\n\n\n  ! calculate correction to xiecv to make astripi coinicide\n  ! as closely as possible with astripd. (they can only coincide\n  ! exactly if the global sum of departure areas exactly agrees with\n  ! area of sphere.)\n\n  ! required fractional in area\n  acorr = astripd - astripi\n\n  ! tweak xiecv\n  dabar = sum(acorr)/nx\n  acorr = acorr - dabar\n  xcorr(1) = 0.0\n  do i = 2, nx\n     xcorr(i) = xcorr(i-1) + acorr(i-1)/dareadx\n  enddo\n  dxbar = sum(xcorr)/nx\n  xcorr = xcorr - dxbar\n  do j = 1, ny\n     xiecv(:,j) = modulo(xiecv(:,j) + xcorr,domain)\n     aicv(:,j) = aicv(:,j) + acorr*cosp(j)*dy/dareadx\n  enddo\n\n  ! main loop over rows\n  do j = 1, ny\n\n     ! remap to intermediate control volumes\n     qx = q(:,j)\n     call slice1d(xu,xiecv(:,j),domain,qx,qxnew,qgx,nx)\n\n     ! mass in intermediate control volumes\n     qnew(:,j) = qxnew*area(j)\n\n  enddo\n\n  ! convert mass to density in intermediate control volumes\n  qnew = qnew/aicv\n\n\n  ! loop over columns\n  do i = 1, nx\n\n     ! define coordinate at top and bottom of lagrangian control volumes\n     ! and top and bottom of intermediate lagrangian control volumes\n     ! assume polar departure points are at the poles\n     s(1) = 0.0\n     silcv(1) = 0.0\n     do j = 2, ny + 1\n        jm = j - 1\n        s(j) = s(jm) + aread(i,jm)\n        silcv(j) = silcv(jm) + aicv(i,jm)\n     enddo\n\n     ! check that total area in the strip is correct\n     fac = silcv(ny+1)/s(ny+1)\n     s = s*fac\n\n     ! remap to lagrangian control volumes\n     qy(:) = qnew(i,:)\n     call slice1db(silcv,s,qy,qynew,qgy,ny)\n\n     ! mass in lagrangian control volumes\n     ! equals mass in eulerian arrival control volumes.\n     ! divide by area to get density\n     qnew(i,:) = qynew(:)*aicv(i,:)/area(:)\n\n  enddo\n\n\n\n\nend subroutine slice2da\n"}
{"id": 282, "subroutine": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"}
{"id": 283, "subroutine": "subroutine momentum\n\n  ! calulate terms needed in the momentum equations\n  ! at departure points\n\n  use alldata\n\n  implicit none\n\n  integer :: i, im, j, jm\n  real*8 :: phitot(nx,ny), &\n       rdx, rdy, cdx\n\n  rdx = rearth*dx\n  rdy = rearth*dy\n\n  ! total geopotential\n  phitot = phis + phi0\n\n  ! calculate coriolis terms\n  !call coriolis(nx,ny,u0,v0,phi0,fu,fv)\n  call coriolis(u0,v0,phi0,fu,fv)\n\n  ! at u-points\n  do j = 1, ny\n     cdx = cosp(j)*rdx\n     do i = 1, nx\n        im = i - 1\n        if (i == 1) im = nx\n        ru0(i,j) = u0(i,j) &\n             - bdt*( (phitot(i,j) - phitot(im,j))/cdx - fv(i,j) )\n        !- hdt*( (phitot(i,j) - phitot(im,j))/cdx - fv(i,j) )\n     enddo\n  enddo\n\n  ! at v-points\n  do j = 2, ny\n     jm = j - 1\n     do i = 1, nx \n        rv0(i,j) = v0(i,j) &\n             - bdt*( (phitot(i,j) - phitot(i,jm))/rdy + fu(i,j) )\n        !- hdt*( (phitot(i,j) - phitot(i,jm))/rdy + fu(i,j) )\n     enddo\n  enddo\n\n  ! perform c-grid average and find polar values of rv0\n  call cgridave(nx,ny,ru0,rv0,ru0bar,rv0bar)\n\n\n\nend subroutine momentum\n"}
{"id": 284, "subroutine": "subroutine diagnostics(istep)\n\n  ! output some basic diagnostics and error measures\n\n  use state\n  use work\n  use errdiag\n  use constants\n\n\n  implicit none\n  integer, intent(in) :: istep\n\n  integer :: i, j\n  real*8 :: phierr(nx,ny), uerr(nx,ny), verr(nx,ny+1), l1phi, l2phi, linfphi, &\n       l1u, l2u, linfu, l1v, l2v, linfv, aphi, au, av, aerr, da, mass\n\n\n  ! find polar values of v\n  call polar(u,ubar(:,1),v(:,1),ubar(:,ny+1),v(:,ny+1))\n\n  ! compute l1, l2 and linf error norms for phi and velocity,\n  ! assuming steady state is the truth\n  phierr = phi - phi_init\n  uerr = u - u_init\n  verr = v - v_init\n  l1phi = 0.0d0\n  l2phi = 0.0d0\n  linfphi = 0.0d0\n  l1u = 0.0d0\n  l2u = 0.0d0\n  linfu = 0.0d0\n  l1v = 0.0d0\n  l2v = 0.0d0\n  linfv = 0.0d0\n  aphi = 0.0d0\n  au = 0.0d0\n  av = 0.0d0\n  do j = 1, ny\n     do i = 1, nx\n        da = area(j)\n        aphi = aphi + da\n        aerr = abs(phierr(i,j))\n        l1phi = l1phi + da*aerr\n        l2phi = l2phi + da*aerr*aerr\n        linfphi = max(linfphi,aerr)\n        au = au + da\n        aerr = abs(uerr(i,j))\n        l1u = l1u + da*aerr\n        l2u = l2u + da*aerr*aerr\n        linfu = max(linfu,aerr)\n     enddo\n  enddo\n  l1phi = l1phi/aphi\n  l2phi = sqrt(l2phi/aphi)\n  do j = 2, ny\n     do i = 1, nx\n        da = dx*dy*cosv(j)\n        av = av + da\n        aerr = abs(verr(i,j))\n        l1v = l1v + da*aerr\n        l2v = l2v + da*aerr*aerr\n        linfv = max(linfv,aerr)\n     enddo\n  enddo\n  l1u = (l1u + l1v)/(au + av)\n  l2u = sqrt((l2u + l2v)/(au + av))\n  !print *,'step ',istep\n  print '(a22, 3e16.8)',' l1, l2, linf (phi) = ',l1phi, l2phi, linfphi\n  print '(a22, 3e16.8)',' l1, l2, linf (u  ) = ',l1u  , l2u  , linfu\n\n  mass = 0.0\n  do j = 1, ny\n     da = area(j)\n     do i = 1, nx\n        mass = mass + phi(i,j)*da\n     enddo\n  enddo\n  !print *,'step ',istep,'  mass = ',mass\n  !write(*,*) \tmass\n\n  print *,'mass              = ', mass\n  print *,' '\nend subroutine diagnostics\n"}
{"id": 285, "subroutine": "subroutine outstate(istep)\n\n  ! output the model state\n\n  use state\n  use work\n  use errdiag\n  use constants\n\n  implicit none\n  integer, intent(in) :: istep\n  character*6 :: ystep\n  character*10 :: yname\n  character*24 :: ytitle\n  integer :: i, im, j, jm, ip, jp\n  real*8 :: xi(nx,ny+1), q(nx,ny+1), &\n       mbar, dm, tote, da, source, div(nx,ny), ros(nx,ny), s1, s2, temp\n\n\n  ! find polar values of v\n  call polar(u,ubar(:,1),v(:,1),ubar(:,ny+1),v(:,ny+1))\n\n  do j = 2, ny\n     jm = j - 1\n     do i = 1, nx\n        im = modulo(i - 2,nx) + 1\n        xi(i,j) = ((v(i,j) - v(im,j))/dx - (u(i,j)*cosp(j) - u(i,jm)*cosp(jm))/dy)/(cosv(j)*rearth)\n        mbar = 0.25*(phi(i,j) + phi(im,j) + phi(i,jm) + phi(im,jm))\n        q(i,j) = (twoomega*singeolatz(i,j) + xi(i,j)) / mbar\n     enddo\n  enddo\n  ! south pole\n  temp = sum(u(:,1))*cosp(1)*8/(dy*dy*nx*rearth)\n  xi(:,1) = -temp\n  temp = sum(phi(:,1))/nx\n  q(:,1) = (-twoomega*singeolatz(1,1)+xi(:,1))/temp\n  ! north pole\n  temp = sum(u(:,ny))*cosp(ny)*8/(dy*dy*nx*rearth)\n  xi(:,ny+1) = temp\n  temp = sum(phi(:,ny))/nx\n  q(:,ny+1) = (twoomega*singeolatz(1,ny+1) + xi(:,ny+1))/temp\n\n\n\n  write(ystep,'(i6.6)') istep\n  yname = 'dump'//ystep\n  open(23,file=yname)\n  write(23,*) nx, ny\n  write(23,*) xu, yu, xv, yv\n  ytitle = 'u    step '//ystep\n  write(23,*) ytitle\n  write(23,*) u\n  ytitle = 'v    step '//ystep\n  write(23,*) ytitle\n  write(23,*) v\n  ytitle = 'phi + phis step '//ystep\n  write(23,*) ytitle\n  write(23,*) phi + phis\n  !ytitle = 'xi  step '//ystep\n  !write(23,*) ytitle\n  !write(23,*) xi\n  !ytitle = 'pv  step '//ystep\n  !write(23,*) ytitle\n  !write(23,*) q\n  !ytitle = 'div step '//ystep\n  !write(23,*) ytitle\n  !write(23,*) div\n\n\n  close(23)\n\n\nend subroutine outstate\n"}
{"id": 286, "subroutine": "subroutine dump(f,ytitle,nx,ny)\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: f(nx,ny)\n  real :: fstar4(nx,ny)\n  character*(*) :: ytitle\n\n  ! convert to single precision to reduce size of output\n  ! and improve readability!\n  fstar4 = f\n  write(33,*) nx,ny\n  write(33,*) ytitle\n  write(33,*) fstar4\n\nend subroutine dump\n"}
{"id": 287, "subroutine": "subroutine dumpm(f,ytitle,nx,ny)\n\n  ! dump for matlab plotting\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: f(nx,ny)\n  real :: fstar4(nx,ny)\n  character*(*) :: ytitle\n\n  ! convert to single precision to reduce size of output\n  ! and improve readability!\n  fstar4 = f\n\n  write(34,*) 'nx = ',nx,';'\n  write(34,*) 'ny = ',ny,';'\n  write(34,*)  ytitle//' = [ ...'\n  write(34,888) fstar4\n  write(34,*) ' ];'\n  write(34,*) '[ min('//ytitle//') max('//ytitle//') ]'\n  write(34,*) 'z = reshape('//ytitle//',nx,ny);'\n  write(34,*) 'contour(z'')'\n  write(34,*) 'title('''//ytitle//''')'\n  write(34,*) 'pause'\n\n888 format(e16.4)\n\nend subroutine dumpm\n"}
{"id": 288, "subroutine": "subroutine outcon\n\n  ! to finalize and output convergence test diagnostics\n\n  use contest\n\n  open(24,file='contest.dat')\n  write(24,*) rmsu\n  write(24,*) rmsv\n  write(24,*) rmsphi\n\n\nend subroutine outcon\n"}
{"id": 289, "subroutine": "subroutine divergence(u,v,div)\n\n  ! to compute the divergence of a vector field on the c-grid\n\n  use grid\n  use constants\n\n  implicit none\n\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: div(nx,ny)\n\n  integer :: i, j, ip, jp\n  real*8 :: cm, cp, c0, cdx, cdy, rdx, rdy\n\n\n  rdx = rearth*dx\n  rdy = rearth*dy\n\n  do j = 1, ny\n     jp = j + 1\n     cm = cosv(j)\n     cp = cosv(jp)\n     c0 = cosp(j)\n     cdx = rdx*c0\n     cdy = rdy*c0\n     do i = 1, nx\n        ip = i + 1\n        if (i == nx) ip = 1\n        div(i,j) = (u(ip,j) - u(i,j))/cdx &\n             + (cp*v(i,jp) - cm*v(i,j))/cdy\n     enddo\n  enddo\n\n\nend subroutine divergence\n"}
{"id": 290, "subroutine": "subroutine up_outer\n\n  ! update terms in outer loop\n\n  use alldata\n  use contest\n\n  implicit none\n\n  integer :: i, j, jp, ng, im, jm, &\n       nfixiter, iter\n\n  real*8 :: div(nx,ny), tempu(nx,ny+1), tempv(nx,ny), &\n       sina, cosa, sind, cosd, sinad, cosad, sdl, cdl, &\n       m11, m12, m21, m22, den, tempphi(nx,ny), &\n       divd(nx,ny), &\n       adad(nx,ny), temp1(nx,ny), acorr(nx,ny), &\n       chi(nx,ny), nu, mass1, mass2, r2, cjr2, dyn, &\n       dabar, dxbar, xcorr(nx), dyc, totda, alpha, fac\n\n\n  ! useful constant\n  r2 = rearth*rearth\n\n  ! interpolate current time level terms in momentum equations\n  ! to departure points \n  call lagrangeu(xdu,ydu,ru0,rud)\n  call lagrangev(xdv,ydv,rv0,rvd)\n  call lagrangeu(xdu,ydu,rv0bar,tempv)\n  call lagrangev(xdv,ydv,ru0bar,tempu)\n\n\n  ! rotate rud, rvd to arrival point local coordinate system\n\n  ! u points\n  do j = 1, ny\n     sina = sinp(j)\n     cosa = cosp(j)\n     do i = 1, nx\n        sind = sin(ydu(i,j))\n        cosd = cos(ydu(i,j))\n        sinad = sina*sind\n        cosad = cosa*cosd\n        sdl = sin(xu(i) - xdu(i,j))\n        cdl = cos(xu(i) - xdu(i,j))\n        den = 1.0 + sinad + cosad*cdl\n        m11 = (cosad + (1.0 + sinad)*cdl) / den\n        m12 = (sina + sind)*sdl / den\n        rud(i,j) = rud(i,j)*m11 + tempv(i,j)*m12\n     enddo\n  enddo\n  ! v points\n  do j = 2, ny\n     sina = sinv(j)\n     cosa = cosv(j)\n     do i = 1, nx\n        sind = sin(ydv(i,j))\n        cosd = cos(ydv(i,j))\n        sinad = sina*sind\n        cosad = cosa*cosd\n        sdl = sin(xv(i) - xdv(i,j))\n        cdl = cos(xv(i) - xdv(i,j))\n        den = 1.0 + sinad + cosad*cdl\n        m22 = (cosad + (1.0 + sinad)*cdl) / den\n        m21 = -(sina + sind)*sdl / den   \n        rvd(i,j) = tempu(i,j)*m21 + rvd(i,j)*m22\n     enddo\n  enddo\n  ! polar v points\n  rvd(:,1) = 0.0\n  rvd(:,ny+1) = 0.0\n\n\n  ! add in orography contribution\n  !rud = rud - hdt*dphisdx\n  !rvd = rvd - hdt*dphisdy\n  rud = rud - adt*dphisdx\n  rvd = rvd - adt*dphisdy\n\n  ! arrival point divergence\n  call divergence(u,v,div)\n\n\n  ! begin alternatives\n\n  if (ischeme == 1) then\n\n     ! semi-lagrangian a la endgame\n\n     ! interpolate current time level terms to departure points\n     call lagrangep(xdp,ydp,rphi0,rphid)\n\n     ! total terms from phi equation\n     !rphi = rphid + hdt*(phiref - phi)*div\n     rphi = rphid + adt*(phiref - phi)*div\n\n  elseif (ischeme == 2) then\n\n     ! semi-lagrangian as close as possible to slice\n\n     ! interpolate current time level terms to departure points\n     call lagrangep(xdp,ydp,rphi0,rphid)\n\n     ! convert to slice-like departure point/cell values\n     rphid = rphid / (1.0 + adt*div)\n\n     ! total terms from phi equation\n     rphi = rphid + adt*phiref*div\n\n  elseif (ischeme == 3) then\n\n     ! slice\n\n     ! interpolate current time level terms to departure points\n     call lagrangep(xdp,ydp,rphi0,tempphi)\n\n     ! convert to slice-like departure point/cell values\n     tempphi = tempphi / (1.0 + hdt*div)\n\n     ! departure point divergence\n     call lagrangep(xdp,ydp,div0,divd)\n\n     ! current time level divergence associated with modified\n     ! winds\n     call divergence(u0mod,v0mod,div0mod)\n\n     ! arrival point divergence associated with modified winds\n     call divergence(umod,vmod,divmod)\n\n     if (areafix == 7) then\n\n        ! improve estimate of departure area\n\n        ! first estimate departure cell divergence\n        call slice2da(xdumod,ydumod,xdvmod,ydvmod,aread,div0mod,divd)\n\n        ! now step cell area\n        do j = 1, ny\n           aread(:,j) = (1.0 - hdt*(divmod(:,j) + divd(:,j)))*area(j)\n        enddo\n\n        ! finally advect mass using desired departure areas.\n        call slice2da(xdumod,ydumod,xdvmod,ydvmod,aread,phi0,rphid)\n\n     else\n\n        call slice2d(xdumod,ydumod,xdvmod,ydvmod,phi0,rphid)\n\n     endif\n\n\n     ! conservatively merge the slice values with the\n     ! semi-lagrangian values\n     call merge(rphid,tempphi,jmods,jmodn)\n\n\n     ! total terms from phi equation\n     rphi = rphid + hdt*phiref*div\n\n\n  else\n\n     print *,'ischeme = ',ischeme,' not implemented '\n     stop\n\n  endif\n\n  ! end of alternatives\n\n\n\nend subroutine up_outer\n"}
{"id": 291, "subroutine": "subroutine merge(rphi1,rphi2,jmods,jmodn)\n\n  ! to merge values predicted by slice with values predicted\n  ! by semi-lagrangian advection, using the latter near the\n  ! poles and the former elsewhere.\n\n  use grid\n\n  implicit none\n\n  real*8, intent(inout) :: rphi1(nx,ny)\n  real*8, intent(in) :: rphi2(nx,ny)\n  integer, intent(in) :: jmods, jmodn\n\n  integer :: j, jj\n  real*8 :: fac, mass1, mass2, w(3)\n\n\n  ! weights for merging\n  w(1) = 5.0d0/32.0d0\n  w(2) = 0.5d0\n  w(3) = 27.0d0/32.0d0\n\n\n  ! southern hemisphere\n\n  ! find mass in modified region, correct sl values to\n  ! conserve mass, and overwrite slice values\n  mass1 = 0.0d0\n  mass2 = 0.0d0\n  do j = 1, jmods\n     mass1 = mass1 + area(j)*sum(rphi1(:,j))\n     mass2 = mass2 + area(j)*sum(rphi2(:,j))\n  enddo\n  fac = mass1/mass2\n  rphi1(:,1:jmods) = fac*rphi2(:,1:jmods)\n\n  ! merging region\n  do jj = 1, 3\n     j = jmods + jj\n     ! correct mass of sl values\n     mass1 = sum(rphi1(:,j))\n     mass2 = sum(rphi2(:,j))\n     fac = mass1/mass2\n     ! and merge with slice values\n     rphi1(:,j) = w(jj)*rphi1(:,j) + fac*(1.0 - w(jj))*rphi2(:,j)\n  enddo\n\n\n  ! northern hemisphere\n\n  ! find mass in modified region, correct sl values to\n  ! conserve mass, and overwrite slice values\n  mass1 = 0.0d0\n  mass2 = 0.0d0\n  do j = jmodn, ny\n     mass1 = mass1 + area(j)*sum(rphi1(:,j))\n     mass2 = mass2 + area(j)*sum(rphi2(:,j))\n  enddo\n  fac = mass1/mass2\n  rphi1(:,jmodn:ny) = fac*rphi2(:,jmodn:ny)\n\n  ! merging region\n  do jj = 1, 3\n     j = jmodn - jj\n     ! correct mass of sl values\n     mass1 = sum(rphi1(:,j))\n     mass2 = sum(rphi2(:,j))\n     fac = mass1/mass2\n     ! and merge with slice values\n     rphi1(:,j) = w(jj)*rphi1(:,j) + fac*(1.0 - w(jj))*rphi2(:,j)\n  enddo\n\n\nend subroutine merge\n"}
{"id": 292, "subroutine": "subroutine mergearea(area1,area2,jmods,jmodn)\n\n  ! to merge departure areas predicted by slice with those predicted\n  ! by semi-lagrangian advection, using the latter near the\n  ! poles and the former elsewhere.\n\n  use grid\n\n  implicit none\n\n  real*8, intent(inout) :: area1(nx,ny)\n  real*8, intent(in) :: area2(nx,ny)\n  integer, intent(in) :: jmods, jmodn\n\n  integer :: j, jj\n  real*8 :: fac, a1, a2, w(3)\n\n\n  ! weights for merging\n  w(1) = 5.0d0/32.0d0\n  w(2) = 0.5d0\n  w(3) = 27.0d0/32.0d0\n\n\n  ! southern hemisphere\n\n  ! find area in modified region, correct sl values to\n  ! conserve area, and overwrite slice values\n  a1 = 0.0d0\n  a2 = 0.0d0\n  do j = 1, jmods\n     a1 = a1 + sum(area1(:,j))\n     a2 = a2 + sum(area2(:,j))\n  enddo\n  fac = a1/a2\n  area1(:,1:jmods) = fac*area2(:,1:jmods)\n\n  ! merging region\n  do jj = 1, 3\n     j = jmods + jj\n     ! correct area of sl values\n     a1 = sum(area1(:,j))\n     a2 = sum(area2(:,j))\n     fac = a1/a2\n     ! and merge with slice values\n     area1(:,j) = w(jj)*area1(:,j) + fac*(1.0 - w(jj))*area2(:,j)\n  enddo\n\n\n  ! northern hemisphere\n\n  ! find area in modified region, correct sl values to\n  ! conserve area, and overwrite slice values\n  a1 = 0.0d0\n  a2 = 0.0d0\n  do j = jmodn, ny\n     a1 = a1 + sum(area1(:,j))\n     a2 = a2 + sum(area2(:,j))\n  enddo\n  fac = a1/a2\n  area1(:,jmodn:ny) = fac*area2(:,jmodn:ny)\n\n  ! merging region\n  do jj = 1, 3\n     j = jmodn - jj\n     ! correct mass of sl values\n     a1 = sum(area1(:,j))\n     a2 = sum(area2(:,j))\n     fac = a1/a2\n     ! and merge with slice values\n     area1(:,j) = w(jj)*area1(:,j) + fac*(1.0 - w(jj))*area2(:,j)\n  enddo\n\n\nend subroutine mergearea\n"}
{"id": 293, "subroutine": "subroutine up_inner\n\n  ! update terms in inner loop\n\n  use alldata\n  use contest\n\n  implicit none\n\n  real*8 :: div(nx,ny)\n\n\n  ! update coriolis terms and add to departure point\n  ! momentum terms\n  !call coriolis(nx,ny,u,v,phi,fu,fv)\n  call coriolis(u,v,phi,fu,fv)\n  ru = rud + adt*fv\n  rv = rvd - adt*fu\n  !ru = rud + hdt*fv\n  !rv = rvd - hdt*fu\n\n  ! compute divergence\n  call divergence(ru,rv,div)\n\n  ! rhs of helmholtz problem\n  !rhs = rphi - phiref*hdt*div\n  rhs = rphi - phiref*adt*div\n\nend subroutine up_inner\n"}
{"id": 294, "subroutine": "subroutine backsub\n\n  ! after solving helmholtz, backsubstitute to find\n  ! updated velocities\n\n  use alldata\n  use contest\n\n  implicit none\n\n  integer :: i, j, im, jm\n\n  real*8 :: dphidx(nx,ny), dphidy(nx,ny+1), rdx, cdx, rdy\n\n  rdx = rearth*dx\n  rdy = rearth*dy\n\n  ! work out dphi/dx and dphi/dy\n\n  ! at u-points\n  do j = 1, ny\n     cdx = cosp(j)*rdx\n     do i = 1, nx\n        im = i - 1\n        if (i == 1) im = nx\n        dphidx(i,j) = (phi(i,j) - phi(im,j))/cdx\n     enddo\n  enddo\n\n  ! at v-points\n  do j = 2, ny\n     jm = j - 1\n     do i = 1, nx \n        dphidy(i,j) = (phi(i,j) - phi(i,jm))/rdy\n     enddo\n  enddo\n\n  ! set polar values to zero\n  dphidy(:,1) = 0.0\n  dphidy(:,ny+1) = 0.0\n\n  ! backsubstitute\n  !u = ru - hdt*dphidx\n  !v = rv - hdt*dphidy\n  u = ru - adt*dphidx\n  v = rv - adt*dphidy\n\n\nend subroutine backsub\n"}
{"id": 295, "subroutine": "subroutine mgsolve(phi,rr,nu,ng)\n\n  ! multigrid solver for elliptic equation\n  !\n  ! delsq phi - nu phi = rr\n  !\n  ! using full multigrid algorithm\n\n  use grid\n  use constants\n\n  implicit none\n\n  ! numbers of iterations on coarsest grid and other grids\n  !integer, parameter :: niterc = 10, niter = 2, npass = 2\n  !pxt modif\n  integer, parameter :: niterc = 20, niter = 4, npass = 4\n\n  integer, intent(in) :: ng\n  real*8, intent(in) :: rr(nx,ny), nu\n  real*8, intent(out) :: phi(nx,ny)\n\n  integer :: nnx(ng), nny(ng), igrid, igridm, jgrid, jgridm, iter, &\n       nnxj, nnyj, ipass\n\n  real*8 :: ff(nx,ny,ng),temp1(nx,ny), rf(nx,ny,ng), &\n       aa(ny,ng), bb(ny,ng), cc(ny,ng), &\n       ddx, ddy, ccp(ny,ng), ccv(ny+1,ng), r2\n\n  integer :: j, j2\n\n\n  ! useful constant\n  r2 = rearth*rearth\n\n  ! map coefficients to each grid in the hierarchy\n  nnx(ng) = nx\n  nny(ng) = ny\n  ddx = dx\n  ddy = dy\n  ccp(:,ng) = cosp\n  ccv(:,ng) = cosv\n\n  do j = 1, ny\n     aa(j,ng) = (ccv(j+1,ng)/ccp(j,ng))/(r2*ddy*ddy)\n     bb(j,ng) = 1.0/(r2*ccp(j,ng)*ccp(j,ng)*ddx*ddx)\n     cc(j,ng) = (ccv(j,ng)/ccp(j,ng))/(r2*ddy*ddy)\n  enddo\n\n  do igrid = ng, 2, -1\n     igridm = igrid - 1\n     nnxj = nnx(igrid)\n     nnyj = nny(igrid)\n     nnx(igridm) = nnxj/2\n     nny(igridm) = nnyj/2\n     ddx = 2.0*ddx\n     ddy = 2.0*ddy\n\n     do j = 1, nny(igridm)\n        j2 = 2*j\n        ccp(j,igridm) = ccv(j2,igrid)\n        ccv(j,igridm) = ccv(j2-1,igrid)\n     enddo\n     ccv(nny(igridm)+1,igridm) = 0.0\n\n     do j = 1, nny(igridm)\n        aa(j,igridm) = (ccv(j+1,igridm)/ccp(j,igridm))/(r2*ddy*ddy)\n        bb(j,igridm) = 1.0/(r2*ccp(j,igridm)*ccp(j,igridm)*ddx*ddx)\n        cc(j,igridm) = (ccv(j,igridm)/ccp(j,igridm))/(r2*ddy*ddy)\n     enddo\n  enddo\n\n\n  ! initialize solution to zero\n  phi = 0.0d0\n\n\n  do ipass = 1, npass\n\n     ! initialize rhs as residual using latest estimate\n     if (ipass == 1) then\n        ! no need to do the calculation\n        rf(:,:,ng) = rr\n     else\n        call residual(phi,rr,rf(:,:,ng), &\n             aa(:,ng),bb(:,ng),cc(:,ng),nu,nx,ny,nx,ny)\n     endif\n\n     ! initialize solution to zero\n     ff = 0.0\n\n     ! inject right hand side to each grid in the hierarchy\n     do igrid = ng, 2, -1\n        igridm = igrid - 1\n        nnxj = nnx(igrid)\n        nnyj = nny(igrid)\n        call inject(rf(1,1,igrid),rf(1,1,igridm),ccp(:,igrid),ccp(:,igridm),nx,ny,nnxj,nnyj)\n     enddo\n\n\n     ! iterate to convergence on coarsest grid\n     nnxj = nnx(1)\n     nnyj = nny(1)\n     ff(1:nnxj,1:nnyj,1) = 0.0d0\n     do iter = 1, niterc\n        call relax(ff(1,1,1),rf(1,1,1), &\n             aa(:,1),bb(:,1),cc(:,1),nu,nx,ny,nnxj,nnyj)\n     enddo\n\n     ! sequence of growing v-cycles\n     do igrid = 2, ng\n\n        igridm = igrid - 1\n        nnxj = nnx(igrid)\n        nnyj = nny(igrid)\n\n        ! accurately prolong solution to grid igrid\n        ! and execute one v-cycle starting from grid igrid\n\n        !accurately prolong\n        call prolong2(ff(1,1,igridm),ff(1,1,igrid),nx,ny,nnxj,nnyj)\n\n        ! descending part of v-cycle\n        do jgrid = igrid, 2, -1\n\n           jgridm = jgrid - 1\n           nnxj = nnx(jgrid)\n           nnyj = nny(jgrid)\n\n           ! relax on grid jgrid\n           do iter = 1, niter\n              call relax(ff(1,1,jgrid),rf(1,1,jgrid), &\n                   aa(:,jgrid),bb(:,jgrid),cc(:,jgrid),nu,nx,ny,nnxj,nnyj)\n           enddo\n\n           ! calculate residual on jgrid\n           temp1 = 0.0d0\n           call residual(ff(1,1,jgrid),rf(1,1,jgrid),temp1, &\n                aa(:,jgrid),bb(:,jgrid),cc(:,jgrid),nu,nx,ny,nnxj,nnyj)\n\n           ! inject residual to jgrid-1\n           call inject(temp1,rf(1,1,jgridm),ccp(:,igrid),ccp(:,igridm),nx,ny,nnxj,nnyj)\n\n           ! set correction first guess to zero on grid jgrid-1\n           ff(1:nnx(jgridm),1:nny(jgridm),jgridm) = 0.0d0\n\n        enddo\n\n        ! relax to convergence on grid 1\n        nnxj = nnx(1)\n        nnyj = nny(1)\n        do iter = 1, niterc\n           call relax(ff(1,1,1),rf(1,1,1), &\n                aa(:,1),bb(:,1),cc(:,1),nu,nx,ny,nnxj,nnyj)\n        enddo\n\n        ! ascending part of v-cycle\n        do jgrid = 2, igrid\n\n           jgridm = jgrid - 1\n           nnxj = nnx(jgrid)\n           nnyj = nny(jgrid)\n\n           ! prolong correction to grid jgrid\n           call prolong(ff(1,1,jgridm),temp1,nx,ny,nnxj,nnyj)\n\n           ! add correction to solution on jgrid\n           ff(1:nnxj,1:nnyj,jgrid) = ff(1:nnxj,1:nnyj,jgrid) &\n                + temp1(1:nnxj,1:nnyj)\n\n           ! relax on grid jgrid\n           do iter = 1, niter\n              call relax(ff(1,1,jgrid),rf(1,1,jgrid), &\n                   aa(:,jgrid),bb(:,jgrid),cc(:,jgrid),nu,nx,ny,nnxj,nnyj)\n           enddo\n        enddo\n\n     enddo\n\n     ! add correction to phi\n     phi = phi+ ff(1:nx,1:ny,ng)\n\n  enddo\n\n\n\nend subroutine mgsolve\n"}
{"id": 296, "subroutine": "subroutine inject(ff,cf,ccf,ccc,nx,ny,nnx,nny)\n\n  ! inject data from a fine grid to a coarser grid\n  ! using full area weighting for phi\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny),ccf(ny),ccc(ny)\n  real*8, intent(out) :: cf(nx,ny)\n  integer :: i, i2, j, j2, i2m, i2p, j2m, j2p\n\n\n  do j = 1, nny/2\n     j2 = j + j\n     j2m = modulo(j2-2,nny) + 1\n     j2p = modulo(j2,nny) + 1\n     do i = 1, nnx/2\n        i2 = i + i\n        i2m = modulo(i2-2,nnx) + 1\n        i2p = modulo(i2,nnx) + 1\n\n        ! basic version\n        cf(i,j) = 0.25*( &\n             (ff(i2m,j2m) + ff(i2,j2m))*ccf(j2m) &\n             + (ff(i2m,j2 ) + ff(i2,j2 ))*ccf(j2 ) &\n             )/ccc(j)\n\n     enddo\n  enddo\n\nend subroutine inject\n"}
{"id": 297, "subroutine": "subroutine prolong(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! cheap version using linear fitting\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: i, i2, j, j2, im, jm, ip, i2m, jp, j2m, hnnx, hnny\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n        ff(i2m,j2m) = 0.0625*(cf(im,jm) + 3*cf(i,jm) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2m,j2 ) = 0.0625*(cf(im,jp) + 3*cf(i,jp) + 3*cf(im,j) + 9*cf(i,j))\n        ff(i2 ,j2m) = 0.0625*(cf(ip,jm) + 3*cf(i,jm) + 3*cf(ip,j) + 9*cf(i,j))\n        ff(i2 ,j2 ) = 0.0625*(cf(ip,jp) + 3*cf(i,jp) + 3*cf(ip,j) + 9*cf(i,j))\n     enddo\n  enddo\n\nend subroutine prolong\n"}
{"id": 298, "subroutine": "subroutine prolong2(cf,ff,nx,ny,nnx,nny)\n\n  ! prolong phi field from a coarse grid to a fine grid:\n  ! accurate version using cubic fitting\n\n  implicit none\n\n  real*8, parameter :: a = -0.1318, b = 0.8439, c = 0.4575, d = -0.1696\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: cf(nx,ny)\n  real*8, intent(out) :: ff(nx,ny)\n  integer :: hnnx, hnny, i, im, imm, ip, ipp, j, jm, jmm, jp, jpp, &\n       i2, i2m, j2, j2m\n\n  hnnx = nnx/2\n  hnny = nny/2\n\n  do j = 1, hnny\n     j2 = j + j\n     jm = modulo(j-2,hnny) + 1\n     jmm = modulo(jm-2,hnny) + 1\n     jp = modulo(j,hnny) + 1\n     jpp = modulo(jp,hnny) + 1\n     j2m = modulo(j2-2,nny) + 1\n     do i = 1, hnnx\n        i2 = i + i\n        im = modulo(i-2,hnnx) + 1\n        imm = modulo(im-2,hnnx) + 1\n        ip = modulo(i,hnnx) + 1\n        ipp = modulo(ip,hnnx) + 1\n        i2m = modulo(i2-2,nnx) + 1\n\n        ff(i2 ,j2 ) = a*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + d*(a*cf(ipp,jm) + b*cf(ipp,j) + c*cf(ipp,jp) + d*cf(ipp,jpp))\n\n        ff(i2m,j2 ) = a*(a*cf(ip,jm)  + b*cf(ip,j)  + c*cf(ip,jp)  + d*cf(ip,jpp)) &\n             + b*(a*cf(i,jm)   + b*cf(i,j)   + c*cf(i,jp)   + d*cf(i,jpp) ) &\n             + c*(a*cf(im,jm)  + b*cf(im,j)  + c*cf(im,jp)  + d*cf(im,jpp)) &\n             + d*(a*cf(imm,jm) + b*cf(imm,j) + c*cf(imm,jp) + d*cf(imm,jpp))\n\n        ff(i2 ,j2m) = a*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + d*(a*cf(ipp,jp) + b*cf(ipp,j) + c*cf(ipp,jm) + d*cf(ipp,jmm))\n\n        ff(i2m,j2m) = a*(a*cf(ip,jp)  + b*cf(ip,j)  + c*cf(ip,jm)  + d*cf(ip,jmm)) &\n             + b*(a*cf(i,jp)   + b*cf(i,j)   + c*cf(i,jm)   + d*cf(i,jmm) ) &\n             + c*(a*cf(im,jp)  + b*cf(im,j)  + c*cf(im,jm)  + d*cf(im,jmm)) &\n             + d*(a*cf(imm,jp) + b*cf(imm,j) + c*cf(imm,jm) + d*cf(imm,jmm))\n\n     enddo\n  enddo\n\n\nend subroutine prolong2\n"}
{"id": 299, "subroutine": "subroutine relax(ff,rf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! red-black relaxation for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: rf(nx,ny), a(ny), b(ny), c(ny), nu\n  real*8, intent(inout) :: ff(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp, iparity, istart\n  integer :: irb = 3 ! 1 for red-black, 0 for gauss-seidel, 2 for both\n  ! 3 for row by row simultaneous relaxation\n  real*8 :: c0, xa(nnx), xb(nnx), xc(nnx), xr(nnx), x(nnx)\n\n\n  if (irb == 1 .or. irb == 2) then\n\n     ! red-black relaxation of phi\n\n     do iparity=1, 2\n\n        ! first row\n        j = 1\n        jp = modulo(j,nny) + 1\n        c0 = a(j) + 2.0*b(j) + nu\n        istart = modulo(j + iparity,2) + 1\n        do i = istart, nnx, 2\n           im = modulo(i - 2,nnx) + 1\n           ip = modulo(i,nnx) + 1\n           ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + a(j)*ff(i,jp)    &\n                -rf(i,j) ) &\n                / c0\n        enddo\n\n        ! middle rows\n        do j = 2, nny - 1\n           jm = modulo(j - 2,nny) + 1\n           jp = modulo(j,nny) + 1\n           c0 = a(j) + 2.0*b(j) + c(j) + nu\n           istart = modulo(j + iparity,2) + 1\n           do i = istart, nnx, 2\n              im = modulo(i - 2,nnx) + 1\n              ip = modulo(i,nnx) + 1\n              ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + a(j)*ff(i,jp) + c(j)*ff(i,jm)    &\n                   -rf(i,j) ) &\n                   / c0     \n           enddo\n        enddo\n\n        ! last row\n        j = nny\n        jm = modulo(j - 2,nny) + 1\n        c0 = 2.0*b(j) + c(j) + nu\n        istart = modulo(j + iparity,2) + 1\n        do i = istart, nnx, 2\n           im = modulo(i - 2,nnx) + 1\n           ip = modulo(i,nnx) + 1\n           ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + c(j)*ff(i,jm)    &\n                -rf(i,j) ) &\n                / c0     \n        enddo\n\n     enddo\n\n  endif\n\n\n  if (irb == 0 .or. irb == 2) then\n\n     ! gauss-seidel\n\n     ! first row\n     j = 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + a(j)*ff(i,jp)    &\n             -rf(i,j) ) / c0\n     enddo\n\n     ! middle rows\n     do j = 2, nny - 1\n        jm = modulo(j - 2,nny) + 1\n        jp = modulo(j,nny) + 1\n        c0 = a(j) + 2.0*b(j) + c(j) + nu\n        do i = 1, nnx\n           im = modulo(i - 2,nnx) + 1\n           ip = modulo(i,nnx) + 1\n           ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + a(j)*ff(i,jp) + c(j)*ff(i,jm)    &\n                -rf(i,j) ) /c0\n        enddo\n     enddo\n\n     ! last row\n     j = nny\n     jm = modulo(j - 2,nny) + 1\n     c0 = 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        ff(i,j) = ( b(j)*(ff(ip,j) + ff(im,j)) + c(j)*ff(i,jm)    &\n             -rf(i,j) )  / c0\n     enddo\n\n  endif\n\n  if (irb == 3) then\n\n     ! row by row simultaneous relaxation, alternating rows\n\n     xa(1:nnx) = b(1)\n     xc(1:nnx) = b(1)\n     xb(1:nnx) = -(2*b(1) + a(1) + c(1) + nu)\n     xr = rf(1:nnx,1) - a(1)*ff(1:nnx,2)\n     call trisolve(x,xa,xb,xc,xr,nnx)\n     ff(1:nnx,1) = x\n\n     do j = 3, nny-1, 2\n        xa(1:nnx) = b(j)\n        xc(1:nnx) = b(j)\n        xb(1:nnx) = -(2*b(j) + a(j) + c(j) + nu)\n        xr = rf(1:nnx,j) - a(j)*ff(1:nnx,j+1) - c(j)*ff(1:nnx,j-1)\n        call trisolve(x,xa,xb,xc,xr,nnx)\n        ff(1:nnx,j) = x\n     enddo\n\n     do j = 2, nny-2, 2\n        xa(1:nnx) = b(j)\n        xc(1:nnx) = b(j)\n        xb(1:nnx) = -(2*b(j) + a(j) + c(j) + nu)\n        xr = rf(1:nnx,j) - a(j)*ff(1:nnx,j+1) - c(j)*ff(1:nnx,j-1)\n        call trisolve(x,xa,xb,xc,xr,nnx)\n        ff(1:nnx,j) = x\n     enddo\n\n     xa(1:nnx) = b(nny)\n     xc(1:nnx) = b(nny)\n     xb(1:nnx) = -(2*b(nny) + a(nny) + c(nny) + nu)\n     xr = rf(1:nnx,nny) - c(nny)*ff(1:nnx,nny-1)\n     call trisolve(x,xa,xb,xc,xr,nnx)\n     ff(1:nnx,nny) = x\n\n  endif\n\n\nend subroutine relax\n"}
{"id": 300, "subroutine": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}
{"id": 301, "subroutine": "subroutine lagrangeu(xd,yd,q,qnew)\n\n  ! 2d cubic lagrange interpolation for the u-points on the\n  ! spherical c-grid\n\n  use grid\n  use util\n\n  implicit none\n\n  real*8, intent(in) :: xd(nx,ny), yd(nx,ny), &\n       q(nx,ny)\n  real*8, intent(out) :: qnew(nx,ny)\n  integer :: i, j, id, idm, idp, idpp, jd, jdm, jdp, jdpp, &\n       i1, i1m, i1p, i1pp, hnx\n  real*8 :: xdd, ydd, d12, d13, d14, d23, d24, d34, &\n       denx1, denx2, denx3, denx4, deny1, deny2, deny3, deny4, &\n       dd1, dd2, dd3, dd4, &\n       fac1, fac2, fac3, fac4, facy1, facy2, facy3, facy4, &\n       q1, q2, q3, q4, qqm, qq, qqp, qqpp, &\n       flip, x(nx), y(ny)\n\n  ! regular gridded values are at u points\n  x = xu\n  y = yu\n\n  ! handy value for handling poles\n  hnx = nx/2\n\n  ! interpolation factors can be pre-computed on uniform grid\n\n  ! for longitude direction\n  d12 = -dx\n  d13 = -2*dx\n  d14 = -3*dx\n  d23 = -dx\n  d24 = -2*dx\n  d34 = -dx\n  denx1 =  d12*d13*d14\n  denx2 = -d12*d23*d24\n  denx3 =  d13*d23*d34\n  denx4 = -d14*d24*d34\n\n  ! for latitude direction\n  d12 = -dy\n  d13 = -2*dy\n  d14 = -3*dy\n  d23 = -dy\n  d24 = -2*dy\n  d34 = -dy\n  deny1 =  d12*d13*d14\n  deny2 = -d12*d23*d24\n  deny3 =  d13*d23*d34\n  deny4 = -d14*d24*d34\n\n\n  do j = 1, ny\n     do i = 1, nx\n\n        ! find indices of departure point and stencil \n        xdd = xd(i,j)\n        ydd = yd(i,j)\n\n        id =   modulo(floor((xdd-x(1))/dx),nx) + 1\n        idm =  modulo(id-2,nx) + 1\n        idp =  modulo(id,nx) + 1\n        idpp = modulo(idp,nx) + 1\n        jd =   floor((ydd-y(1))/dy) + 1\n        jdm =  jd - 1\n        jdp =  jd + 1\n        jdpp = jdp + 1\n\n        ! factors for x-interpolation\n        dd1 = near(xdd - x(idm), twopi)\n        dd2 = near(xdd - x(id), twopi)\n        dd3 = near(xdd - x(idp), twopi)\n        dd4 = near(xdd - x(idpp), twopi)    \n        fac1 = dd2*dd3*dd4/denx1\n        fac2 = dd1*dd3*dd4/denx2\n        fac3 = dd1*dd2*dd4/denx3\n        fac4 = dd1*dd2*dd3/denx4\n\n        ! factors for y-interpolation\n        dd2 = ydd - (y(1) + jdm*dy)\n        dd1 = dd2 + dy\n        dd3 = dd2 - dy\n        dd4 = dd2 - 2*dy\n        facy1 = dd2*dd3*dd4/deny1\n        facy2 = dd1*dd3*dd4/deny2\n        facy3 = dd1*dd2*dd4/deny3\n        facy4 = dd1*dd2*dd3/deny4    \n\n        ! interpolate at four rows\n        ! first\n        i1m = idm\n        i1 = id\n        i1p = idp\n        i1pp = idpp\n        flip = 1.0\n        if (jd .le. 1) then\n           jdm = 1 - jdm\n           i1m  = modulo(i1m - hnx - 1, nx) + 1\n           i1   = modulo(i1 - hnx - 1, nx) + 1\n           i1p  = modulo(i1p - hnx - 1, nx) + 1\n           i1pp = modulo(i1pp - hnx - 1, nx) + 1\n           flip = -1.0\n        endif\n        q1 = q(i1m ,jdm)\n        q2 = q(i1  ,jdm)\n        q3 = q(i1p ,jdm)\n        q4 = q(i1pp,jdm)    \n        qqm = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)*flip\n\n        ! second\n        i1m = idm\n        i1 = id\n        i1p = idp\n        i1pp = idpp\n        flip = 1.0\n        if (jd .eq. 0) then\n           jd = 1\n           i1m  = modulo(i1m - hnx - 1, nx) + 1\n           i1   = modulo(i1 - hnx - 1, nx) + 1\n           i1p  = modulo(i1p - hnx - 1, nx) + 1\n           i1pp = modulo(i1pp - hnx - 1, nx) + 1\n           flip = -1.0\n        endif\n        q1 = q(i1m ,jd)\n        q2 = q(i1  ,jd)\n        q3 = q(i1p ,jd)\n        q4 = q(i1pp,jd)    \n        qq = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)*flip\n\n        ! third\n        i1m = idm\n        i1 = id\n        i1p = idp\n        i1pp = idpp\n        flip = 1.0\n        if (jd .eq. ny) then\n           jdp = ny\n           i1m  = modulo(i1m - hnx - 1, nx) + 1\n           i1   = modulo(i1 - hnx - 1, nx) + 1\n           i1p  = modulo(i1p - hnx - 1, nx) + 1\n           i1pp = modulo(i1pp - hnx - 1, nx) + 1\n           flip = -1.0\n        endif\n        q1 = q(i1m ,jdp)\n        q2 = q(i1  ,jdp)\n        q3 = q(i1p ,jdp)\n        q4 = q(i1pp,jdp)    \n        qqp = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)*flip\n\n        ! fourth\n        i1m = idm\n        i1 = id\n        i1p = idp\n        i1pp = idpp\n        flip = 1.0\n        if (jd .ge. ny - 1) then\n           jdpp = 2*ny + 1 - jdpp\n           i1m  = modulo(i1m - hnx - 1, nx) + 1\n           i1   = modulo(i1 - hnx - 1, nx) + 1\n           i1p  = modulo(i1p - hnx - 1, nx) + 1\n           i1pp = modulo(i1pp - hnx - 1, nx) + 1\n           flip = -1.0\n        endif\n        q1 = q(i1m ,jdpp)\n        q2 = q(i1  ,jdpp)\n        q3 = q(i1p ,jdpp)\n        q4 = q(i1pp,jdpp)\n        qqpp = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)*flip\n\n        ! interpolate in y\n        qnew(i,j) = qqm*facy1 + qq*facy2 + qqp*facy3 + qqpp*facy4\n\n     enddo\n  enddo\n\n\nend subroutine lagrangeu\n"}
{"id": 302, "subroutine": "subroutine gradphis\n\n  ! calculate the components of the gradient of the orography\n\n  use alldata\n\n  implicit none\n\n  integer :: i, im, j, jm\n  real*8 :: rdx, rdy, cdx\n\n  rdx = rearth*dx\n  rdy = rearth*dy\n\n  ! at u-points\n  do j = 1, ny\n     cdx = cosp(j)*rdx\n     do i = 1, nx\n        im = i - 1\n        if (i == 1) im = nx\n        dphisdx(i,j) = (phis(i,j) - phis(im,j))/cdx\n     enddo\n  enddo\n\n  ! at v-points\n  do j = 2, ny\n     jm = j - 1\n     do i = 1, nx \n        dphisdy(i,j) = (phis(i,j) - phis(i,jm))/rdy\n     enddo\n  enddo\n\n  ! set polar valuesto zero\n  dphisdy(:,1) = 0.0\n  dphisdy(:,ny+1) = 0.0\n\n\nend subroutine gradphis\n"}
{"id": 303, "subroutine": "subroutine uvatphi(nx,ny,u,v,up,vp)\n\n  ! to average u and v to phi points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: up(nx,ny), vp(nx,ny)\n\n  integer :: i, ip, j, jp\n\n  ! assume polar values of v have been defined by a previous\n  ! call to polar, e.g. within cgridave\n\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        ip = i+1\n        if ( i == nx ) ip = 1\n        up(i,j) = 0.5*(u(i,j) + u(ip,j))\n        vp(i,j) = 0.5*(v(i,j) + v(i,jp))\n     enddo\n  enddo\n\nend subroutine uvatphi\n"}
{"id": 304, "subroutine": "subroutine departurefgp\n\n  ! first guess for departure point calculation at phi points.\n  ! use velocity at old time level.\n\n  use alldata\n\n  implicit none\n  integer :: i, j\n  real*8 :: sina, cosa, x, y, r, sind, dlambda\n\n  do  j = 1, ny\n     sina = sinp(j)\n     cosa = cosp(j)\n     do i = 1, nx\n        ! displacement in local cartesian system\n        x = -u0p(i,j)*dt\n        y = -v0p(i,j)*dt\n        ! project back to spherical coordinate system\n        r = sqrt(x*x + y*y + rearth*rearth)\n        sind = (y*cosa + rearth*sina)/r\n        ydp(i,j) = asin(sind)\n        dlambda = atan2(x,rearth*cosa - y*sina)\n        xdp(i,j) = modulo(xp(i) + dlambda, twopi)\n     enddo\n  enddo\n\n\nend subroutine departurefgp\n"}
{"id": 305, "subroutine": "subroutine slphieqn\n\n  ! calulate terms needed in the phi equation at departure points\n  ! when semi-lagrangian advection of phi is used\n\n  use alldata\n\n  implicit none\n\n\n  ! assume polar values of v0 have been defined by a call to polar,\n  ! e.g. within cgridave\n\n  ! first find flow divergence\n  call divergence(u0,v0,div0)\n\n  ! hence compute required term\n  !rphi0 = phi0*(1.0 - hdt*div0)\n  rphi0 = phi0*(1.0 - bdt*div0)\n\nend subroutine slphieqn\n"}
{"id": 306, "subroutine": "subroutine modifydep\n\n  ! compute modified departure points such that the\n  ! poles don't move, smoothly merging with true\n  ! departure points at lower latitudes\n\n  use alldata\n\n  implicit none\n\n  integer :: jmod, i, j, jp\n  real*8 :: margin, ydpole, ymod, w1, w2, frac, corr, xxa, xxd, yya, yyd\n\n\n  ! width of buffer zone\n  margin = 4*dy\n\n  ! copy departure points\n  xdumod = xdu\n  ydumod = ydu\n  xdvmod = xdv\n  ydvmod = ydv\n\n\n  ! southern hemisphere\n\n  ! estimate departure latitude of the pole\n  ydpole = maxval(ydu(:,1))\n\n  ! add buffer zone and calculate index to this latitude\n  ymod = ydpole + margin\n  jmod = ceiling((ymod+piby2)/dy) + 1\n  jmods = jmod\n\n  ! modify departure points\n  do j = 1, jmod\n     jp = j + 1\n     do i = 1,nx\n        ! transform to cartesian coodinates based on pole,\n        ! merge, and transform back\n        frac = max((ymod - yu(j))/(ymod + piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        w2 = 1.0 - w1\n        xxa = (yu(j) + piby2)*cos(xu(i))\n        yya = (yu(j) + piby2)*sin(xu(i))\n        xxd = (ydumod(i,j) + piby2)*cos(xdumod(i,j))\n        yyd = (ydumod(i,j) + piby2)*sin(xdumod(i,j))\n        xxd = w1*xxd + w2*xxa\n        yyd = w1*yyd + w2*yya\n        xdumod(i,j) = modulo(atan2(yyd,xxd), twopi)\n        ydumod(i,j)  = sqrt(xxd*xxd + yyd*yyd) - piby2\n        frac = max((ymod - yv(jp))/(ymod + piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        w2 = 1.0 - w1\n        xxa = (yv(jp) + piby2)*cos(xv(i))\n        yya = (yv(jp) + piby2)*sin(xv(i))\n        xxd = (ydvmod(i,jp) + piby2)*cos(xdvmod(i,jp))\n        yyd = (ydvmod(i,jp) + piby2)*sin(xdvmod(i,jp))\n        xxd = w1*xxd + w2*xxa\n        yyd = w1*yyd + w2*yya\n        xdvmod(i,jp) = modulo(atan2(yyd,xxd),twopi)\n        ydvmod(i,jp)  = sqrt(xxd*xxd + yyd*yyd) - piby2\n     enddo\n  enddo\n\n\n  ! northern hemisphere\n\n  ! estimate departure latitude of the pole\n  ydpole = minval(ydu(:,ny))\n\n  ! add buffer zone and calculate index to this latitude\n  ymod = ydpole - margin\n  jmod = floor((ymod+piby2)/dy)\n  jmodn = jmod\n\n\n  ! modify departure points\n  do j = jmod, ny\n     do i = 1,nx\n        frac = max((ymod - yu(j))/(ymod - piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        w2 = 1.0 - w1\n        xxa = (piby2 - yu(j))*cos(xu(i))\n        yya = (piby2 - yu(j))*sin(xu(i))\n        xxd = (piby2 - ydumod(i,j))*cos(xdumod(i,j))\n        yyd = (piby2 - ydumod(i,j))*sin(xdumod(i,j))\n        xxd = w1*xxd + w2*xxa\n        yyd = w1*yyd + w2*yya\n        xdumod(i,j) = modulo(atan2(yyd,xxd),twopi)\n        ydumod(i,j)  = piby2 - sqrt(xxd*xxd + yyd*yyd)\n        frac = max((ymod - yv(j))/(ymod - piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        w2 = 1.0 - w1\n        xxa = (piby2 - yv(j))*cos(xv(i))\n        yya = (piby2 - yv(j))*sin(xv(i))\n        xxd = (piby2 - ydvmod(i,j))*cos(xdvmod(i,j))\n        yyd = (piby2 - ydvmod(i,j))*sin(xdvmod(i,j))\n        xxd = w1*xxd + w2*xxa\n        yyd = w1*yyd + w2*yya\n        xdvmod(i,j) = modulo(atan2(yyd,xxd),twopi)\n        ydvmod(i,j)  = piby2 - sqrt(xxd*xxd + yyd*yyd)\n     enddo\n  enddo\n\n\n  ! assign polar departure points to equal arrival points\n  xdvmod(:,1) = xv(:)\n  ydvmod(:,1) = -piby2\n  xdvmod(:,ny+1) = xv(:)\n  ydvmod(:,ny+1) = piby2\n\n\nend subroutine modifydep\n"}
{"id": 307, "subroutine": "subroutine modifywind\n\n  ! compute modified wind field such that the\n  ! poles don't move, smoothly merging with true\n  ! wind field at lower latitudes\n\n  use alldata\n\n  implicit none\n\n  integer :: jmod, i, j, jp\n  real*8 :: margin, ydpole, ymod, w1, frac\n\n\n  ! width of buffer zone\n  margin = 4*dy\n\n  ! copy winds\n  umod = u\n  vmod = v\n\n\n  ! southern hemisphere\n\n  ! estimate departure latitude of the pole\n  ydpole = maxval(ydu(:,1))\n\n  ! add buffer zone and calculate index to this latitude\n  ymod = ydpole + margin\n  jmod = ceiling((ymod+piby2)/dy) + 1\n  jmods = jmod\n\n  ! modify winds\n  do j = 1, jmod\n     jp = j + 1\n     do i = 1,nx\n\n        frac = max((ymod - yu(j))/(ymod + piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        umod(i,j) = w1*u(i,j)\n        frac = max((ymod - yv(jp))/(ymod + piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        vmod(i,jp) = w1*v(i,jp)\n\n     enddo\n  enddo\n\n\n  ! northern hemisphere\n\n  ! estimate departure latitude of the pole\n  ydpole = minval(ydu(:,ny))\n\n  ! add buffer zone and calculate index to this latitude\n  ymod = ydpole - margin\n  jmod = floor((ymod+piby2)/dy)\n  jmodn = jmod\n\n\n  ! modify departure points\n  do j = jmod, ny\n     do i = 1,nx\n\n        frac = max((ymod - yu(j))/(ymod - piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        umod(i,j) = w1*u(i,j)\n        frac = max((ymod - yv(j))/(ymod - piby2), 0.0d0)\n        w1 = cos(piby2*frac)**2\n        vmod(i,j) = w1*v(i,j)\n\n     enddo\n  enddo\n\n\n  ! assign polar winds to equal zero\n  vmod(:,1) = 0.0\n  vmod(:,ny+1) = 0.0\n\n\n\nend subroutine modifywind\n"}
{"id": 308, "subroutine": "subroutine dumpgrid\n\n  ! output the grid coordinates in a simple format for use in generating\n  ! reference solutions\n\n  use grid\n\n  implicit none\n  integer :: i, j\n  real*8 :: long, lat\n  character*30 :: ygridcoords\n  character*5 :: ynlon, ynlat\n\n  ! -----------------------------------------------------------------------\n\n  write(ynlon,'(i5.5)') nx\n  write(ynlat,'(i5.5)') ny\n  if (abs(rotgrid) < 0.00001d0) then\n     ygridcoords = 'gridcoords_ll__'//ynlon//'x'//ynlat//'.dat'\n  else\n     ygridcoords = 'gridcoords_llr_'//ynlon//'x'//ynlat//'.dat'\n  endif\n  open(88,file=ygridcoords,form='unformatted')\n\n  write(88) nx*ny\n  do j = 1, ny\n     do i = 1, nx\n        write(88) geolonp(i,j), geolatp(i,j)\n     enddo\n  enddo\n\n  close(88)\n\n  ! -----------------------------------------------------------------------\n\nend subroutine dumpgrid\n"}
{"id": 309, "subroutine": "subroutine writeref\n\n  use timeinfo\n  use state\n  use version\n\n  implicit none\n\n  integer, parameter :: &\n       ngref = 19,            &  ! number of grids on which to dump reference solution\n       nreftime = 10              ! number of times at which reference solution is required\n\n  integer :: ilist, igref, nface, if0\n  character*128 :: ytime, dir\n  character*128 :: dirgrids, icname\n  character*256 :: ygc(ngref)\n  character*256 :: yrefpre(ngref)\n  character*256 :: filename\n  real*8 :: reftime(nreftime)\n  real*8, allocatable :: flong(:), flat(:), href(:), uref(:), vref(:)\n  integer:: inode, nnbnode, nedge, i, iedge\n  real*8:: p1, p2, p3\n  logical:: ifile\n\n  ! ----------------------------------------------------------\n\n  !dirgrids=\"../grid/\"\n  dirgrids=\"../../imodel/grid/\"\n\n  ! list of grid coordinate files\n  ygc(1) = 'hr95jt_001'\n  ygc(2) = 'hr95jt_002'\n  ygc(3) = 'hr95jt_003'\n  ygc(4) = 'hr95jt_004'\n  ygc(5) = 'hr95jt_005'\n  ygc(6) = 'hr95jt_006'\n  ygc(7) = 'hr95jt_007'\n  ygc(8) = '' !'hr95jt_008'\n  ygc(9) = '' !'hr95jt_009'\n  ygc(10) = '' !'hr95hk_009'\n  ygc(11) = 'icos_pol_scvt_h1_1'\n  ygc(12) = 'icos_pol_scvt_h1_2'\n  ygc(13) = 'icos_pol_scvt_h1_3'\n  ygc(14) = 'icos_pol_scvt_h1_4'\n  ygc(15) = 'icos_pol_scvt_h1_5'\n  ygc(16) = 'icos_pol_scvt_h1_6'\n  ygc(17) = 'icos_pol_scvt_h1_7'\n  ygc(18) = '' !'icos_pol_scvt_h1_8'\n  ygc(19) = '' !'icos_pol_scvt_h1_9'\n\n  write(icname,'(i4.2)') ic\n  icname=trim(adjustl(trim(icname)))\n\n  do igref=1,ngref\n     ! list of reference solution file prefixes\n     yrefpre( igref) = 'dump/tc'//trim(icname)//'_'//trim(ygc(igref))\n  end do\n\n\n  ! list of times at which reference solution is required\n  reftime(1) = 3600.0d0              ! 1 hour\n  reftime(2) = 86400.0d0             ! 1 day\n  reftime(3) = 2.0d0*86400.0d0         ! 2 day\n  reftime(4) = 3.0d0*86400.0d0         ! 3 day\n  reftime(5) = 4.0d0*86400.0d0         ! 4 day\n  reftime(6) = 5.0d0*86400.0d0         ! 5 days\n  reftime(7) = 6.0d0*86400.0d0         ! 6 days\n  reftime(8) = 10.0d0*86400.0d0        ! 10 days\n  reftime(9) = 14.0d0*86400.0d0        ! 14 days\n  reftime(10) = 15.0d0*86400.0d0        ! 15 days\n\n  if(istep==1)then\n     open(58,file='tc'//trim(icname)//'_reftimes.dat', status='replace')\n     write(58, *) nreftime\n     do ilist = 1, nreftime\n        write(58, *) reftime(ilist)\n     end do\n     close(58)\n  end if\n\n  do ilist = 1, nreftime\n     if (istep == nint(reftime(ilist)/dt)) then\n\n        ! reference solution is required at this time\n        write(ytime,'(i10.10)') nint(reftime(ilist))\n\n        do igref = 1, ngref\n\n           ! read in grid on which reference solution is required\n           filename=trim(dirgrids)//trim(ygc(igref))//'_vert_coord.dat'\n           print *,'reading: ',filename\n           inquire(file=filename, exist=ifile)\n           if(.not. ifile)then\n              print*, \"file not found\"\n              cycle\n           end if\n           open(48,file=trim(dirgrids)//trim(ygc(igref))//'_vert_coord.dat',form='unformatted')\n           read(48) nface\n           !print *,'  nface = ',nface\n           allocate(flong(nface),flat(nface),href(nface))\n           read(48) (inode, p1, p2, p3, flong(if0), flat(if0), nnbnode, if0=1,nface)\n           close(48)\n\n           ! interpolate reference solution to this grid\n           call interpref(flong,flat,href,nface)\n\n           ! output reference solution\n           print *,'creating reference solution file for h: ',trim(yrefpre(igref))//'_'//trim(ytime)//'h.dat'\n           open(49,file=trim(yrefpre(igref))//'_'//trim(ytime)//'h.dat',form='unformatted')\n           do if0 = 1, nface\n              write(49) href(if0)\n           enddo\n           close(49)\n           deallocate(flong,flat,href)\n\n           !reference solution for velocities on edges\n\n           !read grid data with midpoint hexagon edges\n           open(48,file=trim(dirgrids)//trim(ygc(igref))//'_edhx_cc.dat',form='unformatted')\n           read(48) nedge\n           !print *,'nedge = ',nedge\n\n           allocate(flong(nedge),flat(nedge), uref(nedge), vref(nedge))\n           read(48) (iedge, p1, p2, p3, flong(i), flat(i), i=1, nedge)\n           close(48)\n\n           !interpolate to grid edges\n           call interprefu(flong,flat,uref,nedge)\n           call interprefv(flong,flat,vref,nedge)\n\n           ! output reference solution\n           print *,'creating reference solution file for u, v on hx edges: ',trim(yrefpre(igref))//'_'//trim(ytime)//'uv_edhx.dat'\n           open(49,file=trim(yrefpre(igref))//'_'//trim(ytime)//'uv_edhx.dat',form='unformatted')\n           do i = 1, nedge\n              write(49) uref(i), vref(i)\n           enddo\n           close(49)\n\n           !read grid data with midpoint triangle edges\n           open(48,file=trim(dirgrids)//trim(ygc(igref))//'_ed_cc.dat',form='unformatted')\n           read(48) nedge\n           !print *,'nedge = ',nedge\n\n           read(48) (iedge, p1, p2, p3, flong(i), flat(i), i=1, nedge)\n           close(48)\n\n           !interpolate to grid edges\n           call interprefu(flong,flat,uref,nedge)\n           call interprefv(flong,flat,vref,nedge)\n\n           ! output reference solution\n           print *,'creating reference solution file for u, v on tr edges: ',trim(yrefpre(igref))//'_'//trim(ytime)//'uv_ed.dat'\n           open(49,file=trim(yrefpre(igref))//'_'//trim(ytime)//'uv_ed.dat',form='unformatted')\n           do i = 1, nedge\n              write(49) uref(i), vref(i)\n           enddo\n           close(49)\n\n           deallocate(flong,flat, uref, vref)\n\n        enddo\n\n     endif\n\n  enddo\n\n\n  ! ---------------------------------------------------------\n\nend subroutine writeref\n"}
{"id": 310, "subroutine": "subroutine interpref(xd,yd,href,nface)\n\n  ! 2d cubic lagrange interpolation to compute the surface height\n  ! at a given list of coordinates - used for generating reference solutions\n  ! for other models\n\n  use grid\n  use state\n  use util\n\n  implicit none\n\n  integer, intent(in) :: nface\n  real*8, intent(in) :: xd(nface), yd(nface)\n  real*8, intent(out) :: href(nface)\n  integer :: i, j, id, idm, idp, idpp, jd, jdm, jdp, jdpp, &\n       i1, i1m, i1p, i1pp, hnx\n  real*8 :: xdd, ydd, d12, d13, d14, d23, d24, d34, &\n       denx1, denx2, denx3, denx4, deny1, deny2, deny3, deny4, &\n       dd1, dd2, dd3, dd4, &\n       fac1, fac2, fac3, fac4, facy1, facy2, facy3, facy4, &\n       q1, q2, q3, q4, qqm, qq, qqp, qqpp, &\n       x(nx), y(ny), q(nx,ny)\n\n\n  ! construct surface height\n  q = (phi + phis)/9.80616d0\n\n  ! regular gridded values are at phi points\n  x = xp\n  y = yp\n\n  ! handy value for handling poles\n  hnx = nx/2\n\n  ! interpolation factors can be pre-computed on uniform grid\n\n  ! for longitude direction\n  d12 = -dx\n  d13 = -2*dx\n  d14 = -3*dx\n  d23 = -dx\n  d24 = -2*dx\n  d34 = -dx\n  denx1 =  d12*d13*d14\n  denx2 = -d12*d23*d24\n  denx3 =  d13*d23*d34\n  denx4 = -d14*d24*d34\n\n  ! for latitude direction\n  d12 = -dy\n  d13 = -2*dy\n  d14 = -3*dy\n  d23 = -dy\n  d24 = -2*dy\n  d34 = -dy\n  deny1 =  d12*d13*d14\n  deny2 = -d12*d23*d24\n  deny3 =  d13*d23*d34\n  deny4 = -d14*d24*d34\n\n\n  do i = 1, nface\n\n     ! find indices of departure point and stencil \n     xdd = xd(i)\n     ydd = yd(i)\n\n     id =   modulo(floor((xdd-x(1))/dx),nx) + 1\n     idm =  modulo(id-2,nx) + 1\n     idp =  modulo(id,nx) + 1\n     idpp = modulo(idp,nx) + 1\n     jd =   floor((ydd-y(1))/dy) + 1\n     jdm =  jd - 1\n     jdp =  jd + 1\n     jdpp = jdp + 1\n\n     ! factors for x-interpolation\n     dd1 = near(xdd - x(idm), twopi)\n     dd2 = near(xdd - x(id), twopi)\n     dd3 = near(xdd - x(idp), twopi)\n     dd4 = near(xdd - x(idpp), twopi)    \n     fac1 = dd2*dd3*dd4/denx1\n     fac2 = dd1*dd3*dd4/denx2\n     fac3 = dd1*dd2*dd4/denx3\n     fac4 = dd1*dd2*dd3/denx4\n\n     ! factors for y-interpolation\n     dd2 = ydd - (y(1) + jdm*dy)\n     dd1 = dd2 + dy\n     dd3 = dd2 - dy\n     dd4 = dd2 - 2*dy\n     facy1 = dd2*dd3*dd4/deny1\n     facy2 = dd1*dd3*dd4/deny2\n     facy3 = dd1*dd2*dd4/deny3\n     facy4 = dd1*dd2*dd3/deny4        \n\n     ! interpolate at four rows\n     ! first\n     i1m = idm\n     i1 = id\n     i1p = idp\n     i1pp = idpp\n     if (jd .le. 1) then\n        jdm = 1 - jdm\n        i1m  = modulo(i1m - hnx - 1, nx) + 1\n        i1   = modulo(i1 - hnx - 1, nx) + 1\n        i1p  = modulo(i1p - hnx - 1, nx) + 1\n        i1pp = modulo(i1pp - hnx - 1, nx) + 1\n     endif\n     q1 = q(i1m ,jdm)\n     q2 = q(i1  ,jdm)\n     q3 = q(i1p ,jdm)\n     q4 = q(i1pp,jdm)    \n     qqm = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)\n\n     ! second\n     i1m = idm\n     i1 = id\n     i1p = idp\n     i1pp = idpp\n     if (jd .eq. 0) then\n        jd = 1\n        i1m  = modulo(i1m - hnx - 1, nx) + 1\n        i1   = modulo(i1 - hnx - 1, nx) + 1\n        i1p  = modulo(i1p - hnx - 1, nx) + 1\n        i1pp = modulo(i1pp - hnx - 1, nx) + 1\n     endif\n     q1 = q(i1m ,jd)\n     q2 = q(i1  ,jd)\n     q3 = q(i1p ,jd)\n     q4 = q(i1pp,jd)    \n     qq = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)\n\n     ! third\n     i1m = idm\n     i1 = id\n     i1p = idp\n     i1pp = idpp\n     if (jd .eq. ny) then\n        jdp = ny\n        i1m  = modulo(i1m - hnx - 1, nx) + 1\n        i1   = modulo(i1 - hnx - 1, nx) + 1\n        i1p  = modulo(i1p - hnx - 1, nx) + 1\n        i1pp = modulo(i1pp - hnx - 1, nx) + 1\n     endif\n     q1 = q(i1m ,jdp)\n     q2 = q(i1  ,jdp)\n     q3 = q(i1p ,jdp)\n     q4 = q(i1pp,jdp)    \n     qqp = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)\n\n     ! fourth\n     i1m = idm\n     i1 = id\n     i1p = idp\n     i1pp = idpp\n     if (jd .ge. ny - 1) then\n        jdpp = 2*ny + 1 - jdpp\n        i1m  = modulo(i1m - hnx - 1, nx) + 1\n        i1   = modulo(i1 - hnx - 1, nx) + 1\n        i1p  = modulo(i1p - hnx - 1, nx) + 1\n        i1pp = modulo(i1pp - hnx - 1, nx) + 1\n     endif\n     q1 = q(i1m ,jdpp)\n     q2 = q(i1  ,jdpp)\n     q3 = q(i1p ,jdpp)\n     q4 = q(i1pp,jdpp)\n     qqpp = (q1*fac1 + q2*fac2 + q3*fac3 + q4*fac4)\n\n     ! interpolate in y\n     href(i) = qqm*facy1 + qq*facy2 + qqp*facy3 + qqpp*facy4\n\n  enddo\n\n\n\nend subroutine interpref\n"}
{"id": 311, "subroutine": "subroutine diffref\n\n  ! compute and output the surface height difference from a reference solution\n\n  use state\n  use timeinfo\n  use constants\n  implicit none\n\n  integer, parameter :: nreftime = 5, chanerrout = 86\n  integer :: reftime(nreftime), ilist, i, j\n  real*8 :: h(nx,ny), href(nx,ny), l1, l2, linf, tota\n  character*36 :: yrefpre\n  character*10 :: ytime\n  character*11 :: yres\n  character*36 :: yname\n  character*5 :: ynx, yny\n\n  ! -----------------------------------------------------------------------\n\n  ! reference solution file prefixes\n  if (abs(rotgrid) < 0.00001d0) then\n     yrefpre = 'tc5ref_ll__'\n  else\n     yrefpre = 'tc5ref_llr_'\n  endif\n\n  ! resolution (for building file name)\n  write(ynx,'(i5.5)') nx\n  write(yny,'(i5.5)') ny\n  yres = ynx//'x'//yny\n\n  ! list of times at which reference solution is required\n  reftime(1) = nint(3600.0d0)              ! 1 hour\n  reftime(2) = nint(86400.0d0)             ! 1 day\n  reftime(3) = nint(5.0d0*86400.0)         ! 5 days\n  reftime(4) = nint(10.0d0*86400.0)        ! 10 days\n  reftime(5) = nint(15.0d0*86400.0)        ! 15 days\n\n  ! surface height\n  h = (phi + phis)/gravity\n\n  do ilist = 1, nreftime\n\n     if (nint(istep*dt) == reftime(ilist)) then\n\n        ! reference solution is required at this time\n        write(ytime,'(i10.10)') reftime(ilist)\n        ! read reference solution\n        open(87,file=yrefpre//yres//'_'//ytime//'.dat',form='unformatted')\n        do j = 1, ny\n           do i = 1, nx\n              read(87) href(i,j)\n           enddo\n        enddo\n        close(87)\n\n        ! file for matlab primal grid output\n        yname = 'err1_'//ytime//'.m'\n        open(chanerrout,file=yname)\n\n        ! write header information\n        write(chanerrout,*)   'nx = ',nx,';'\n        write(chanerrout,*)   'ny = ',ny,';'\n        write(chanerrout,*)   'long = [ ...'\n        write(chanerrout,888) xp\n        write(chanerrout,*)   ' ];'\n        write(chanerrout,*)   'lat = [ ...'\n        write(chanerrout,888) yp\n        write(chanerrout,*)   ' ];'\n\n        ! output\n        write(chanerrout,*)   'ytitle = ''reference h time ',ytime,''';'\n        write(chanerrout,*)   'q = [ ...'\n        write(chanerrout,888) href\n        write(chanerrout,*)   ' ];'\n        write(chanerrout,*)   'q = reshape(q,nx,ny);'\n        write(chanerrout,*)   'figure(1)'\n        write(chanerrout,*)   'contour(long,lat,q'',11,''k'')'\n        write(chanerrout,*)   'qx = max(max(q));'\n        write(chanerrout,*)   'qn = min(min(q));'\n        write(chanerrout,*)   'title ([ytitle,''  min = '',num2str(qn),''  max = '',num2str(qx) ])'\n        write(chanerrout,*)   'ytitle = ''solution h time ',ytime,''';'\n        write(chanerrout,*)   'q = [ ...'\n        write(chanerrout,888) h\n        write(chanerrout,*)   ' ];'\n        write(chanerrout,*)   'q = reshape(q,nx,ny);'\n        write(chanerrout,*)   'figure(2)'\n        write(chanerrout,*)   'contour(long,lat,q'',11,''k'')'\n        write(chanerrout,*)   'qx = max(max(q));'\n        write(chanerrout,*)   'qn = min(min(q));'\n        write(chanerrout,*)   'title ([ytitle,''  min = '',num2str(qn),''  max = '',num2str(qx) ])'\n        h = h - href\n        write(chanerrout,*)   'ytitle = ''h error time ',ytime,''';'\n        write(chanerrout,*)   'q = [ ...'\n        write(chanerrout,888) h\n        write(chanerrout,*)   ' ];'\n        write(chanerrout,*)   'q = reshape(q,nx,ny);'\n        write(chanerrout,*)   'figure(3)'\n        write(chanerrout,*)   'contour(long,lat,q'',11,''k'')'\n        write(chanerrout,*)   'qx = max(max(q));'\n        write(chanerrout,*)   'qn = min(min(q));'\n        write(chanerrout,*)   'title ([ytitle,''  min = '',num2str(qn),''  max = '',num2str(qx) ])'\n        close(chanerrout)\n\n        ! error norms\n        tota = 0.0d0\n        l1 = 0.0d0\n        l2 = 0.0d0\n        do j = 1, ny\n           tota = tota + area(j)\n           l1 = l1 + area(j)*sum(abs(h(:,j)))\n           l2 = l2 + area(j)*sum(h(:,j)*h(:,j))\n        enddo\n        tota = tota*nx\n        l1 = l1/tota\n        l2 = sqrt(l2/tota)\n        linf = maxval(abs(h))\n        print *,'h error: l1   = ',l1 ,'  l2   = ',l2 ,'  linf = ',linf\n\n     endif\n\n  enddo\n\n888 format(e16.4)\n889 format(i8)\n\n\n  ! -----------------------------------------------------------------------\n\nend subroutine diffref\n"}
{"id": 312, "subroutine": "subroutine testdep\n\n  ! test departure point calculation\n\n  use alldata\n\n  implicit none\n\n  integer :: i, j\n\n  ! old velocity field specified in initial\n  ! copy into new velocity field\n  ! calculate c-grid average velocities,\n  ! and find first guess for departure points\n  call prelim\n\n\n  ! full calculation of departure points\n  call departure\n  call departurep\n\n\n  ! modify departure points so that poles don't move\n  ! for use with slice\n  call modifydep\n  xdu = xdumod\n  ydu = ydumod\n  xdv = xdvmod\n  ydv = ydvmod\n\n\n\n\n  write(22,*) nx, ny\n  do j = 1, ny\n     do i = 1, nx\n        write(22,*) xdu(i,j), ydu(i,j), xu(i), yu(j)\n     enddo\n  enddo\n  do j = 2, ny\n     do i = 1, nx\n        write(22,*) xdv(i,j), ydv(i,j), xv(i), yv(j)\n     enddo\n  enddo\n  do j = 1, ny\n     do i = 1, nx\n        write(22,*) xdp(i,j), ydp(i,j), xp(i), yp(j)\n     enddo\n  enddo\n\n\nend subroutine testdep\n"}
{"id": 313, "subroutine": "subroutine testrotate\n\n  ! test sl advection / interpolation\n\n  use alldata\n\n  implicit none\n\n  integer :: i, j\n\n  real*8 :: tempu(nx,ny+1), tempv(nx,ny), sina, cosa, sinad, cosad, &\n       sdl, cdl, den, m11, m12, m21, m22, sind, cosd\n\n\n  ! old velocity field specified in initial\n  ! copy into new velocity field\n  ! calculate c-grid average velocities,\n  ! and find first guess for departure points\n  call prelim\n\n  ! full calculation of departure points\n  call departure\n  call departurep\n\n  ! interpolate current time level terms in momentum equations\n  ! to departure points \n  call lagrangeu(xdu,ydu,u0,rud)\n  call lagrangev(xdv,ydv,v0,rvd)\n\n  ! rotate rud, rvd to arrival point local coordinate system\n  print *,' need to interpolate ave fields, not ave interpolated'\n  call cgridave(nx,ny,rud,rvd,tempu,tempv)\n\n  call dump(u0,' u ',nx,ny)\n  call dump(rud,' rdu before',nx,ny)\n  call dump(tempu,' tempu ',nx,ny+1)\n  call dump(v0,' v ',nx,ny+1)\n  call dump(rvd,' rdv before',nx,ny+1)\n  call dump(tempv,' tempv ',nx,ny)\n\n  ! u points\n  do j = 1, ny\n     sina = sinp(j)\n     cosa = cosp(j)\n     do i = 1, nx\n        sind = sin(ydu(i,j))\n        cosd = cos(ydu(i,j))\n        sinad = sina*sind\n        cosad = cosa*cosd\n        sdl = sin(xu(i) - xdu(i,j))\n        cdl = cos(xu(i) - xdu(i,j))\n        den = 1.0 + sinad + cosad*cdl\n        m11 = (cosad + (1.0 + sinad)*cdl) / den\n        m12 = (sina + sind)*sdl / den\n        rud(i,j) = rud(i,j)*m11 + tempv(i,j)*m12\n     enddo\n  enddo\n  ! v points\n  do j = 2, ny\n     sina = sinv(j)\n     cosa = cosv(j)\n     do i = 1, nx\n        sind = sin(ydv(i,j))\n        cosd = cos(ydv(i,j))\n        sinad = sina*sind\n        cosad = cosa*cosd\n        sdl = sin(xv(i) - xdv(i,j))\n        cdl = cos(xv(i) - xdv(i,j))\n        den = 1.0 + sinad + cosad*cdl\n        m22 = (cosad + (1.0 + sinad)*cdl) / den\n        m21 = -(sina + sind)*sdl / den\n        if (j == 18 .and. i == 1) then\n           print *,'j = ',j\n           print *,'sina = ',sina,' cosa = ',cosa\n           print *,'sind = ',sind,' cosd = ',cosd\n           print *,'sdl = ',sdl,' cdl = ',cdl\n           print *,'den = ',den,' m22 m21 = ',m22,m21\n           print *,' tempu = ',tempu(i,j),' rvd = ',rvd(i,j)\n        endif\n        rvd(i,j) = tempu(i,j)*m21 + rvd(i,j)*m22\n        if (j == 18 .and. i == 1) then\n           print *,' rvd = ',rvd(i,j)\n        endif\n     enddo\n  enddo\n  ! polar v points\n  rvd(:,1) = 0.0\n  rvd(:,ny+1) = 0.0\n\n  call dump(rud,' rdu after ',nx,ny)\n  call dump(rud - u0,' u diff ',nx,ny)\n\n  call dump(rvd,' rdv after ',nx,ny+1)\n  call dump(rvd - v0,' v diff ',nx,ny+1)\n\n\n\nend subroutine testrotate\n"}
{"id": 314, "subroutine": "subroutine sph2cart (lon, lat, x, y, z )\n  !------------------------------------------------------------------------------------\n  ! sph2cart\n  !\n  !     transforms geographical coordinates (lat,lon) to cartesian coordinates.\n  !     similar to stripack's trans\n  !\n  !    input: lat, latitudes of the node in radians [-pi/2,pi/2]\n  !           lon, longitudes of the nodes in radians [-pi,pi]\n  !\n  !    output:  x, y, z, the coordinates in the range -1 to 1.\n  !                    x**2 + y**2 + z**2 = 1\n  !\n  !   p. peixoto 2015\n  !---------------------------------------------------------------------\n  real (8), intent(in) :: lon\n  real (8), intent(in) :: lat\n  real (8), intent(out) :: x\n  real (8), intent(out) :: y\n  real (8), intent(out) :: z\n  real (8):: coslat\n\n  coslat = dcos (lat)\n  x = coslat * dcos (lon)\n  y = coslat * dsin (lon)\n  z = dsin (lat)\n\n  return\nend subroutine sph2cart\n"}
{"id": 315, "subroutine": "subroutine dumpstate(jstep)\n\n  ! output the model state for use in gmt\n  ! p. peixoto\n\n  use version\n  use state\n  use work\n  use errdiag\n  use constants\n  use timeinfo\n\n  implicit none\n  integer, intent(in) :: jstep\n  character*64 :: ystep\n  character*64 :: yname\n  character*24 :: ytitle\n  integer :: i, im, j, jm, ip, jp\n  real*8 :: xi(nx,ny+1), q(nx,ny+1), h(nx,ny), &\n       mbar, dm, tote, da, source, div(nx,ny), ros(nx,ny), s1, s2, temp\n  real*8 :: herr(nx,ny)\n\n  ! find polar values of v\n  call polar(u,ubar(:,1),v(:,1),ubar(:,ny+1),v(:,ny+1))\n\n  do j = 2, ny\n     jm = j - 1\n     do i = 1, nx\n        im = modulo(i - 2,nx) + 1\n        xi(i,j) = ((v(i,j) - v(im,j))/dx - (u(i,j)*cosp(j) - u(i,jm)*cosp(jm))/dy)/(cosv(j)*rearth)\n        mbar = 0.25*(phi(i,j) + phi(im,j) + phi(i,jm) + phi(im,jm))\n        q(i,j) = (twoomega*singeolatz(i,j) + xi(i,j)) / mbar\n     enddo\n  enddo\n  ! south pole\n  temp = sum(u(:,1))*cosp(1)*8/(dy*dy*nx*rearth)\n  xi(:,1) = -temp\n  temp = sum(phi(:,1))/nx\n  q(:,1) = (-twoomega*singeolatz(1,1)+xi(:,1))/temp\n  ! north pole\n  temp = sum(u(:,ny))*cosp(ny)*8/(dy*dy*nx*rearth)\n  xi(:,ny+1) = temp\n  temp = sum(phi(:,ny))/nx\n  q(:,ny+1) = (twoomega*singeolatz(1,ny+1) + xi(:,ny+1))/temp\n  !set pv=xi/h instead of xi/phi\n  q=q*gravity\n\n  write(ystep,*) nint(jstep*dt)\n  yname = trim(adjustl(trim(ystep)))\n  write(ystep,*) (nx)\n  if (abs(rotgrid) > 0.00001d0) then\n     yname = trim(yname)//\"_r\"//trim(adjustl(trim(ystep)))\n  else\n     yname = trim(yname)//\"_\"//trim(adjustl(trim(ystep)))\n  end if\n  write(ystep,*) (ny)\n  yname = trim(yname)//\"x\"//trim(adjustl(trim(ystep)))\n\n  ! surface height\n  h = (phi + phis)/gravity\n  call plot_var(u, \"u_t\"//trim(yname), \"u\")\n  call plot_var(v, \"v_t\"//trim(yname), \"v\")\n  call plot_var(h, \"h_t\"//trim(yname), \"h\")\n  call plot_var(xi, \"vort_t\"//trim(yname), \"z\")\n  call plot_var(q, \"pv_t\"//trim(yname), \"z\")\n\n  if (ic==2 .or. ic ==8)then\n     herr = (phi - phi_init)/gravity\n     call plot_var(herr, \"herr_t\"//trim(yname), \"h\")\n  end if\n  !  open(23,file=yname)\n  !  write(23,*) nx, ny\n  !  write(23,*) xu, yu, xv, yv\n  !  ytitle = 'u    step '//ystep\n  !  write(23,*) ytitle\n  !  write(23,*) u\n  !  ytitle = 'v    step '//ystep\n  !  write(23,*) ytitle\n  !  write(23,*) v\n  !  ytitle = 'phi + phis step '//ystep\n  !  write(23,*) ytitle\n  !  write(23,*) phi + phis\n  !  !ytitle = 'xi  step '//ystep\n  !  !write(23,*) ytitle\n  !  !write(23,*) xi\n  !  !ytitle = 'pv  step '//ystep\n  !  !write(23,*) ytitle\n  !  !write(23,*) q\n  !  !ytitle = 'div step '//ystep\n  !  !write(23,*) ytitle\n  !  !write(23,*) div\n\n\n  !  close(23)\n\n\nend subroutine dumpstate\n"}
{"id": 316, "subroutine": "subroutine plot_var(q, ytitle, pos)\n  ! plot primal field variable using lat lon regular grid\n  ! p. peixoto\n\n  use grid\n  use version\n  !use timeinfo\n  !use state\n  use constants\n\n  implicit none\n\n  !variable to be plotted\n  real*8, intent(in) :: q(1:nx,1:ny)\n\n  ! position of variable\n  ! u, v, phi or h, q or z - else uses as phi\n  character*(*), intent(in) :: pos\n\n  ! interpolated variable\n  real*8 :: qplot(1:nx,1:ny)\n\n  !name to be used\n  character*(*), intent(in) :: ytitle\n\n  !auxiliar local variables\n  integer*4:: i, j, k, iunit\n  real*8 :: tlon, tlat, dlat, dlon\n\n  !buffer for data output (faster to write)\n  ! single precision output\n  real*4, allocatable :: buffer(:,:)\n\n  !file name for output\n  character (len=256):: filename, icname, coriname, slicename, offname, hrefname\n\n  !degree spacings\n  dlat=dy*rad2deg !/real(ny, 8)\n  dlon=dx*rad2deg !/real(nx, 8)\n\n  !for h, phi\n  qplot=q\n\n  !interpolate to phi position (for plotting reasons)\n  if(trim(pos)==\"u\" .or. trim(pos)==\"z\")then\n     qplot(1:nx-1, 1:ny)=0.5*(q(1:nx-1, 1:ny)+q(2:nx, 1:ny))\n     qplot(nx, 1:ny)=0.5*(q(nx, 1:ny)+q(1, 1:ny))\n  end if\n  if(trim(pos)==\"v\".or. trim(pos)==\"z\")then\n     qplot(1:nx, 1:ny-1)=0.5*(q(1:nx, 1:ny-1)+q(1:nx, 2:ny))\n     !north pole - same as nearest latitute (to avoid acessing ny+1)\n     qplot(1:nx, ny)=q(1:nx, ny)\n  end if\n\n  !buffer for binary plotting - faster\n  allocate(buffer(3, 1:nx*ny))\n\n  !write to buffer\n  k=1\n  !pixel registration mode (gmt) (at midpoint of cell)\n  tlat=-90.0+dlat/2.0\n  do j=1,ny\n     !tlat=lat(j)*rad2deg\n     tlon=-180.0+dlon/2.0\n     !print*, \"lat: \", tlat\n     do i=1,nx\n        !tlon=lon(i)*rad2deg\n        ! convert 0->360 to -180->180\n        !if(tlon>180.0d0)then\n        !\ttlon=tlon-360.0d0\n        !endif\n\n        buffer(1, k)=tlon\n        buffer(2, k)=tlat\n        buffer(3, k)=qplot(mod(i+nx/2-1, nx)+1,j)\n        k=k+1\n        !write(iunit) tlon, tlat, varunif(i,j)\n        tlon=tlon+dlon\n     end do\n     tlat=tlat+dlat\n  end do\n\n  !filename for lat lon field\n  write(icname,'(i4.2)') ic\n  icname=trim(adjustl(trim(icname)))\n  write(coriname,'(i4.1)') coriolis_mtd\n  coriname=trim(adjustl(trim(coriname)))\n  if(ischeme>1)then\n     write(slicename,'(i4.1)') ischeme\n     slicename=\"_slice\"//trim(adjustl(trim(slicename)))\n  else\n     slicename=\"\"\n  endif\n  !if(ic==8 .and. .true.)then !hollingsworth test with linearizations\n  write(hrefname,'(f8.3)') phiref/gravity\n  hrefname=trim(adjustl(trim(hrefname)))\n  !endif\n  filename=\"dump/\"//\"eg_swe_run_ic\"//trim(icname)//\"_cor\"//trim(coriname)//&\n    \"_href\"//trim(hrefname)//trim(slicename)//\"_\"//trim(adjustl(trim(ytitle)))//\".dat\"\n  !filename=\"dump/\"//\"eg_swe_cor\"//trim(coriname)//\"ic\"//trim(icname)//\"_\"//trim(ytitle)//\".dat\"\n\n  !write values on file\n  call getunit(iunit)\n  open(iunit,file=filename, status='replace', access='stream', form='unformatted')\n  !write whole block to file (much faster)\n  write(iunit) buffer\n  close(iunit)\n  print*, \"long-lat output written in : \", trim(filename)\n\n  return\nend subroutine plot_var\n"}
{"id": 317, "subroutine": "subroutine getunit ( iunit )\n  !----------------------------------------------------------\n  ! getunit returns a free fortran unit number.\n  !\n  !    a \"free\" fortran unit number is an integer between 1 and 99 which\n  !    is not currently associated with an i/o device.  a free fortran unit\n  !    number is needed in order to open a file with the open command.\n  !\n  !    if iunit = 0, then no free fortran unit could be found, although\n  !    all 99 units were checked (except for units 5, 6 and 9, which\n  !    are commonly reserved for console i/o).\n  !\n  !    otherwise, iunit is an integer between 1 and 99, representing a\n  !    free fortran unit.  note that get_unit assumes that units 5 and 6\n  !    are special, and will never return those values.\n  !\n  !    john burkardt\n  !    18 september 2005\n  !----------------------------------------------------------------------------\n  integer :: i\n  integer :: ios\n  integer :: iunit\n  logical:: lopen\n\n  iunit = 0\n  do i = 11, 99\n     if ( i /= 5 .and. i /= 6 .and. i /= 9 ) then\n        inquire ( unit = i, opened = lopen, iostat = ios )\n        if ( ios == 0 ) then\n           if ( .not. lopen ) then\n              iunit = i\n              return\n           end if\n        end if\n     end if\n  end do\n\n  return\nend subroutine getunit\n"}
{"id": 318, "subroutine": "subroutine dtm3(day,f,fbar,akp,alti,hl,alat,xlon,tz,tinf,ro,d,wmm)\n  !***********************************************************************\n  ! cnes dtm2020 operational: f10.7 and kp       \n  ! ver 21/10/2020\n  ! calculation of temperature and density with dtm2020_oper\n  !  \n  !*par ** input **\n  !     day = day of year [1-366]\n  !     f   = f(1)=instantaneous flux at (t - 24hr)    /   f(2)=0.\n  !     fbar= fbar(1)=mean flux of last 81 days at t   /   fbar(2)=0.\n  !     akp = akp(1)= kp delayed by 3 hours, akp(3)=mean of last 24 hours\n  !           akp(2) & akp(4)=0.\n  !     alti= altitude (in km) greater than 120 km\n  !     hl  = local time (in radian: 0-24hr = 0-2pi)\n  !     alat= latitude (in radian)\n  !     xlon= longitude (in radian)\n  !\n  !*par ** output **\n  !     tz      = temperature at altitude -> alti\n  !     tinf    = exospheric temperature\n  !     d(1)    = partial density of atomic hydrogen (in gram/cm3)\n  !     d(2)    = partial density of helium\n  !     d(3)    = partial density of atomic oxygen\n  !     d(4)    = partial density of molecular nitrogen\n  !     d(5)    = partial density of molecular oxygen\n  !     d(6)    = partial density of atomic nitrogen\n  !     ro      = total density (in gram/cm3)\n  !     wmm     = mean molecular mass (in gram)\n  !***********************************************************************\n  !\n  !.. implicit declarations .. \n  implicit none\n  ! \n  !.. parameters .. \n  integer, parameter :: nlatm = 96\n  ! \n  !.. formal arguments .. \n  real, intent(in) :: alat,alti,day,hl,xlon\n  real, intent(out) :: ro,tinf,tz,wmm\n  real, dimension(2), intent(in) :: f,fbar\n  real, dimension(4), intent(in) :: akp\n  real, dimension(6), intent(out) :: d\n  ! \n  !.. local scalars .. \n  integer :: i,n\n  integer :: ityp = 0\n  real :: c,c2,c4,s,s2,dt120,dtinf,clmlmg,sp,cmg,cmg2,cmg4, &\n          dtp120,gamma,gdelaz,gdelh,gdelo,gdelt0,gdeltp,tinftz,ts,zeta\n  real :: cpmg = .19081,re = 6356.77,rgas = 831.4\n  real :: dzeta,dzeta2,expsz,gdelaz2,gdelhe,gdelo2,gdelt,glb,secl2,sigma, &\n          sigzeta,t,t120sd,t120tt,t120tz,upapg,zlb\n  real :: zlb0 = 120.,xlmg = -1.2392\n  real :: t120 = 0.0,tp120 = 0.0,xlog = 0.0\n  real :: cose = .9175,gsurf = 980.665,sine = .3978,spmg = .98163,zero = 0.\n  real :: crd,dlat,dlon,gmlatd,gmlond,gmlatr,gmlonr\n  ! \n  !.. local arrays .. \n  integer, dimension(6) :: ma\n  real, dimension(6) :: alefa\n  real, dimension(6) :: cc = 0.0,dbase = 0.0,fz = 0.0 \n  real, dimension(6) :: vma\n  real, dimension(nlatm) :: daz,daz2,dh,dhe,do2,dox,dt0,dtp,dtt\n  !\n  !.. common blocks .. \n  common /cons/ pi,deupi,cdr,sard\n  real :: cdr,deupi,pi,sard\n  common /hlocal/ hl0,ch,sh,c2h,s2h,c3h,s3h\n  real :: c2h,c3h,ch,hl0,s2h,s3h,sh\n  common /pardtm/ tt,h,he,o,az2,o2,az,t0,tp\n  real, dimension(nlatm) :: az,az2,h,he,o,o2,t0,tp,tt\n  common /plgdtm/ p10,p20,p30,p40,p50,p60,p11,p21,p31,p41,p51,p22,p32,p42,p52, &\n                  p62,p33,p10mg,p20mg,p40mg,p11mg,p22mg,p31mg,p50mg,p60mg\n  real :: p10,p10mg,p11,p20,p20mg,p21,p22,p30,p31,p32,p33,p40,p40mg,p41,p42, &\n          p50,p51,p52,p60,p62,p11mg,p22mg,p31mg,p50mg,p60mg\n  ! \n  !.. data declarations .. \n  data alefa/-0.40,-0.38,0.,0.,0.,0./\n  data ma/1,4,16,28,32,14/\n  data vma/1.6606e-24,6.6423e-24,26.569e-24,46.4958e-24,53.1381e-24,23.2479e-24/\n  ! \n  ! ... executable statements ...\n  ! \n  zlb = zlb0 \n  !\n  ro = 0.\n  dtinf = 0.\n  dt120 = 0.\n  dtp120 = 0.\n  fz(1) = 0.\n  fz(2) = 0.\n  fz(3) = 0.\n  fz(4) = 0.\n  fz(5) = 0.\n  fz(6) = 0.\n  !\n  do i = 1,nlatm\n    dtt(i) = 0.\n    dh(i) = 0.\n    dhe(i) = 0.\n    dox(i) = 0.\n    daz2(i) = 0.\n    do2(i) = 0.\n    daz(i) = 0.\n    dt0(i) = 0.\n    dtp(i) = 0.\n  end do\n  !\n  c = sin(alat)\n  c2 = c * c\n  c4 = c2 * c2\n  s = cos(alat)\n  s2 = s * s\n  p10 = c\n  p20 = 1.5*c2 - 0.5\n  p30 = c * (2.5*c2-1.5)\n  p40 = 4.375*c4 - 3.75*c2 + 0.375\n  p50 = c * (7.875*c4-8.75*c2+1.875)\n  p60 = (5.5*c*p50-2.5*p40) / 3.\n  p11 = s\n  p21 = 3. * c * s\n  p31 = s * (7.5*c2-1.5)\n  p41 = c * s * (17.5*c2-7.5)\n  p51 = s * (39.375*c4-26.25*c2+1.875)\n  p22 = 3. * s2\n  p32 = 15. * c * s2\n  p42 = s2 * (52.5*c2-7.5)\n  p52 = 3.*c*p42 - 2.*p32\n  p62 = 2.75*c*p52 - 1.75*p42\n  p33 = 15. * s * s2\n  !\n    clmlmg = cos(xlon-xlmg)\n    sp = s*cpmg*clmlmg + c*spmg\n    !\n    cmg = sp ! pole magnetique\n    cmg2 = cmg * cmg\n    cmg4 = cmg2 * cmg2\n    p10mg = cmg\n    p20mg = 1.5*cmg2 - 0.5\n    p40mg = 4.375*cmg4 - 3.75*cmg2 + 0.375\n  !\n  hl0 = hl\n  ch = cos(hl0)\n  sh = sin(hl0)\n  c2h = ch*ch - sh*sh\n  s2h = 2. * ch * sh\n  c3h = c2h*ch - s2h*sh\n  s3h = s2h*ch + c2h*sh\n  !\n  call gldtm(f,fbar,akp,day,tt,dtt,gdelt,1.,xlon)\n  dtt(1) = 1. + gdelt\n  tinf = tt(1) * dtt(1)\n  call gldtm(f,fbar,akp,day,t0,dt0,gdelt0,1.,xlon)\n  dt0(1) = 1. + gdelt0\n  t120 = t0(1) * dt0(1)\n  call gldtm(f,fbar,akp,day,tp,dtp,gdeltp,1.,xlon)\n  dtp(1) = 1. + gdeltp\n  tp120 = tp(1) * dtp(1)  \n  !-----------------------------------------------------------------------------\n  sigma = tp120 / (tinf-t120)\n  dzeta = (re+zlb) / (re+alti)\n  zeta = (alti-zlb) * dzeta\n  dzeta2 = dzeta * dzeta\n  sigzeta = sigma * zeta\n  expsz = exp(-sigzeta)\n  tz = tinf - (tinf-t120)*expsz\n  !\n    call gldtm(f,fbar,akp,day,h,dh,gdelh,0.,xlon)\n    dh(1)=exp(gdelh)\n    dbase(1)=h(1)*dh(1)\n!\n    call gldtm(f,fbar,akp,day,he,dhe,gdelhe,0.,xlon)\n    dhe(1)=exp(gdelhe)\n    dbase(2)=he(1)*dhe(1)\n!\n    call gldtm(f,fbar,akp,day,o,dox,gdelo,1.,xlon)\n    dox(1)=exp(gdelo)\n    dbase(3)=o(1)*dox(1)\n!\n    call gldtm(f,fbar,akp,day,az2,daz2,gdelaz2,1.,xlon)\n    daz2(1)=exp(gdelaz2)\n    dbase(4)=az2(1)*daz2(1)\n!\n    call gldtm(f,fbar,akp,day,o2,do2,gdelo2,1.,xlon)\n    do2(1)=exp(gdelo2)\n    dbase(5)=o2(1)*do2(1)\n!\n    call gldtm(f,fbar,akp,day,az,daz,gdelaz,1.,xlon)\n    daz(1)=exp(gdelaz)\n    dbase(6)=az(1)*daz(1)\n    !\n    glb = gsurf / (1.+zlb/re)**2\n    glb = glb / (sigma*rgas*tinf)\n    t120tz = t120 / tz\n    xlog = log(t120tz)\n    tinftz = tinf / tz\n    t120tt = t120 / (tinf-t120)\n!\n    do i = 1,6\n      gamma = ma(i) * glb\n      upapg = 1. + alefa(i) + gamma\n      fz(i) = t120tz**upapg * exp(-sigzeta*gamma)\n      cc(i) = dbase(i) * fz(i)\n      d(i) = cc(i) * vma(i)\n      ro = ro + d(i)\n    end do \n      wmm=ro/(vma(1)*(cc(1)+cc(2)+cc(3)+cc(4)+cc(5)+cc(6)))\n!\nend subroutine dtm3\n"}
{"id": 319, "subroutine": "subroutine gldtm(f,fbar,akp,day,a,da,gdel,ff0,xlon)\n  !***********************************************************************\n  ! sb 21/10/2020\n  ! corrections et nouveaux inconnus\n  !*rol calcul de la fonction g(l) evoluee pour dtm_2013 & 2020_oper\n  !\n  !     gdel=resultat du calcul de g(l)\n  !***********************************************************************\n  !\n  ! \n  !.. implicit declarations .. \n  implicit none\n  ! \n  !.. parameters .. \n  integer, parameter :: nlatm = 96\n  ! \n  !.. formal arguments .. \n  real, intent(in) :: day,ff0,xlon\n  real, intent(out) :: gdel\n  real, dimension(2), intent(in) :: f,fbar\n  real, dimension(4), intent(in) :: akp\n  real, dimension(nlatm), intent(in) :: a\n  real, dimension(nlatm), intent(inout) :: da\n  ! \n  !.. local scalars .. \n  integer :: i,ikpm\n  integer :: ikp = 0\n  real :: a74,a77,a78,a88,f1f,fp\n  real :: c2fi = 0.0\n  real :: clfl,cos2te,coste,dakp,dakpm,dkp,dkpm,f0,fp1, &\n          rsin2te,slfl,rsinte\n  real :: rot = .017214206,rot2 = .034428412,roth = .261799387, &\n          rots = 7.27220e-05\n  ! \n  !.. local arrays .. \n  real, dimension(2) :: fbm150 = 0.0,fmfb = 0.0\n  ! \n  common /hlocal/ hl,ch,sh,c2h,s2h,c3h,s3h\n  real :: c2h,c3h,ch,hl,s2h,s3h,sh\n  common /plgdtm/ p10,p20,p30,p40,p50,p60,p11,p21,p31,p41,p51,p22,p32,p42,p52, &\n                  p62,p33,p10mg,p20mg,p40mg,p11mg,p22mg,p31mg,p50mg,p60mg\n  real :: p10,p10mg,p11,p20,p20mg,p21,p22,p30,p31,p32,p33,p40,p40mg,p41,p42, &\n          p50,p51,p52,p60,p62,p11mg,p22mg,p31mg,p50mg,p60mg\n  ! \n  da(2) = p20\n  da(3) = p40\n  da(74) = p10\n  da(77) = p30\n  da(78) = p50\n  da(79) = p60\n  fmfb(1) = f(1) - fbar(1)\n  fmfb(2) = f(2) - fbar(2)\n  fbm150(1) = fbar(1) - 150.\n  fbm150(2) = fbar(2)\n  da(4) = fmfb(1)\n  da(6) = fbm150(1)\n  da(5) = da(4) * da(4)\n  da(69) = da(6) * da(6)\n  da(82) = da(4) * p10\n  da(83) = da(4) * p20\n  da(84) = da(4) * p30\n  da(85) = da(6) * p20\n  da(86) = da(6) * p30\n  da(87) = da(6) * p40\n    ikp = 62\n    ikpm = 67\n    c2fi = 1. - p10mg*p10mg\n    dkp = akp(1) + (a(ikp)+c2fi*a(ikp+1))*akp(2)\n    dakp = a(7) + a(8)*p20mg + a(68)*p40mg + &\n           2.*dkp*(a(60)+a(61)*p20mg+a(75)*2.*dkp*dkp)\n    da(ikp) = dakp * akp(2)\n    da(ikp+1) = da(ikp) * c2fi\n    dkpm = akp(3) + a(ikpm)*akp(4)\n    dakpm = a(64) + a(65)*p20mg + a(72)*p40mg + &\n            2.*dkpm*(a(66)+a(73)*p20mg+a(76)*2.*dkpm*dkpm)\n    da(ikpm) = dakpm * akp(4)\n  da(7) = dkp\n  da(8) = p20mg * dkp\n  da(68) = p40mg * dkp\n  da(60) = dkp * dkp\n  da(61) = p20mg * da(60)\n  da(75) = da(60) * da(60)\n  da(64) = dkpm\n  da(65) = p20mg * dkpm\n  da(72) = p40mg * dkpm\n  da(66) = dkpm * dkpm\n  da(73) = p20mg * da(66)\n  da(76) = da(66) * da(66)\n  f0 = a(4)*da(4) + a(5)*da(5) + a(6)*da(6) + a(69)*da(69) + a(82)*da(82) + &\n       a(83)*da(83) + a(84)*da(84) + a(85)*da(85) + a(86)*da(86) + &\n       a(87)*da(87)\n  f1f = 1. + f0*ff0\n  ! \n  f0 = f0 + a(2)*da(2) + a(3)*da(3) + a(74)*da(74) + a(77)*da(77) + a(7)*da(7) + &\n       a(8)*da(8) + a(60)*da(60) + a(61)*da(61) + a(68)*da(68) + a(64)*da(64) &\n       + a(65)*da(65) + a(66)*da(66) + a(72)*da(72) + a(73)*da(73) + &\n       a(75)*da(75) + a(76)*da(76) + a(78)*da(78) + a(79)*da(79)\n  da(9) = cos(rot*(day-a(11)))\n  da(10) = p20 * da(9)\n  da(12) = cos(rot2*(day-a(14)))\n  da(13) = p20 * da(12)\n  coste = cos(rot*(day-a(18)))\n  da(15) = p10 * coste\n  da(16) = p30 * coste\n  da(17) = da(6) * da(15)\n  cos2te = cos(rot2*(day-a(20)))\n  da(19) = p10 * cos2te\n  da(39) = p30 * cos2te\n  da(59) = da(6) * da(19)\n  da(21) = p11 * ch\n  da(22) = p31 * ch\n  da(23) = da(6) * da(21) \n  da(24) = da(21) * coste\n  da(25) = p21 * ch * coste\n  da(26) = p11 * sh\n  da(27) = p31 * sh\n  da(28) = da(6) * da(26)\n  da(29) = da(26) * coste\n  da(30) = p21 * sh * coste\n  da(94)=p51*ch  \n  da(95)=p51*sh  \n  da(31) = p22 * c2h\n  da(37) = p42 * c2h\n  da(32) = p32 * c2h * coste\n  da(33) = p22 * s2h\n  da(38) = p42 * s2h\n  da(34) = p32 * s2h * coste\n  da(88) = p32 * c2h \n  da(89) = p32 * s2h\n  da(90) = da(6) * da(31)\n  da(91) = da(6) * da(33)\n  da(92) = p62 * c2h\n  da(93) = p62 * s2h\n  da(35) = p33 * c3h\n  da(36) = p33 * s3h\n  fp = a(9)*da(9) + a(10)*da(10) + a(12)*da(12) + a(13)*da(13) + a(15)*da(15) &\n       + a(16)*da(16) + a(17)*da(17) + a(19)*da(19) + a(21)*da(21) + &\n       a(22)*da(22) + a(23)*da(23) + a(24)*da(24) + a(25)*da(25) + &\n       a(26)*da(26) + a(27)*da(27) + a(28)*da(28) + a(29)*da(29) + &\n       a(30)*da(30) + a(31)*da(31) + a(32)*da(32) + a(33)*da(33) + &\n       a(34)*da(34) + a(35)*da(35) + a(36)*da(36) + a(37)*da(37) + &\n       a(38)*da(38) + a(39)*da(39) + a(59)*da(59) + a(88)*da(88) + a(89)*da(89) + &\n       a(90)*da(90) + a(91)*da(91) + a(92)*da(92) + a(93)*da(93) + &\n       a(94)*da(94) + a(95)*da(95) \n  !\n  da(40) = p10 * coste * dkp\n  da(41) = p30 * coste * dkp\n  da(42) = p50 * coste * dkp\n  da(43) = p11 * ch * dkp\n  da(44) = p31 * ch * dkp\n  da(45) = p51 * ch * dkp\n  da(46) = p11 * sh * dkp\n  da(47) = p31 * sh * dkp\n  da(48) = p51 * sh * dkp\n  !\n  fp = fp + a(40)*da(40) + a(41)*da(41) + a(42)*da(42) + a(43)*da(43) + &\n       a(44)*da(44) + a(45)*da(45) + a(46)*da(46) + a(47)*da(47) + &\n       a(48)*da(48)\n  !\n    dakp = (a(40)*p10+a(41)*p30+a(42)*p50)*coste + &\n           (a(43)*p11+a(44)*p31+a(45)*p51)*ch + &\n           (a(46)*p11+a(47)*p31+a(48)*p51)*sh\n    da(ikp) = da(ikp) + dakp*akp(2)\n    da(ikp+1) = da(ikp) + dakp*c2fi*akp(2)\n    clfl = cos(xlon)\n    da(49) = p11 * clfl\n    da(50) = p21 * clfl\n    da(51) = p31 * clfl\n    da(52) = p41 * clfl\n    da(53) = p51 * clfl\n    slfl = sin(xlon)\n    da(54) = p11 * slfl\n    da(55) = p21 * slfl\n    da(56) = p31 * slfl\n    da(57) = p41 * slfl\n    da(58) = p51 * slfl\n    !\n    fp = fp + a(49)*da(49) + a(50)*da(50) + a(51)*da(51) + a(52)*da(52) + &\n         a(53)*da(53) + a(54)*da(54) + a(55)*da(55) + a(56)*da(56) + &\n         a(57)*da(57) + a(58)*da(58)\n  !\n  gdel = f0 + fp*f1f\n  !\nend subroutine gldtm\n"}
{"id": 320, "subroutine": "subroutine lecdtm\n  ! sb 21/10/2020\n  !\n  !reading in the dtm model coefficients in vectors, per constituent\n!************************************************************************\n  !.. parameters .. \n  integer, parameter :: nlatm = 96\n  ! \n  !\n  character titre*100,ct120*8,ctp120*8\n  common /pardtm/ tt,h,he,o,az2,o2,az,t0,tp\n  real, dimension(nlatm) :: az,az2,h,he,o,o2,t0,tp,tt\n  integer :: npdtm,i,ni\n  !\n  open(10,file='dtm_2020_f107_kp',status='old')  \n  !\n  read(iu10,530) titre\n  read(iu10,540) npdtm\n  write(*,600) titre\n  !\n  do i=1,npdtm\n    read(iu10,540,end=20) ni,tt(i),dtt,h(i),dh,he(i),dhe,o(i),dox, &\n            az2(i),daz2,o2(i),do2,az(i),daz,t0(i),dt0,tp(i),dtp\n  end do\n!\n20 continue\n!\n530  format(a100)\n540  format(i4,9(e13.6,e9.2))\n600  format(a100/)\n!\nend subroutine lecdtm \n"}
{"id": 321, "subroutine": "  subroutine readmask(inf,mask)\n    \n    implicit none\n\n    real, pointer :: mask(:,:)\n    character :: inf*150\n\n    allocate(mask(ni,nj))\n    open(1,file=inf,status='old',form='unformatted')\n    read(1) mask\n    close(1)\n\n  end subroutine readmask\n"}
{"id": 322, "subroutine": "  subroutine jstartend2(size,rank,jstart,jend,lside)\n\n    implicit none\n\n    integer :: i,j,i1,j1\n    integer, intent(in) :: size,rank\n    integer, intent(out) :: jstart,jend\n    integer :: nmode,neach\n    double precision :: lx,ly,labs\n    double precision, intent(in) :: lside(2)\n\n    nmode=0\n    do j=1,nj\n       j1=j-1\n       if (j1>nj/2)  j1 = j1 - nj\n       do i=1,ni/2+1\n          i1=i-1\n          lx=i1*(2*pi/lside(1))\n          ly=j1*(2*pi/lside(2))\n          labs=sqrt(lx*lx+ly*ly)\n          if (labs<llowbin(1)) cycle\n          if (labs>=llowbin(npmax+1)) cycle\n          nmode=nmode+1\n       enddo\n    enddo\n    neach=nmode/size\n\n    nmode=0\n    do j=1,nj\n       j1=j-1\n       if (j1>nj/2)  j1 = j1 - nj\n       do i=1,ni/2+1\n          i1=i-1\n          lx=i1*(2*pi/lside(1))\n          ly=j1*(2*pi/lside(2))\n          labs=sqrt(lx*lx+ly*ly)\n          if (labs<llowbin(1)) cycle\n          if (labs>=llowbin(npmax+1)) cycle\n          nmode=nmode+1\n       enddo\n       if (nmode<=neach*rank) jstart=j+1\n       if (nmode<=neach*(rank+1)) jend=j\n    enddo\n\n    if (rank==0) jstart=1\n    if (rank==size-1) jend=nj\n\n  end subroutine jstartend2\n"}
{"id": 323, "subroutine": "subroutine volscatt(tts,tto,psi,ttl,chi_s,chi_o,frho,ftau)\n\n    !********************************************************************************\n    !*tts= solar zenith\n    !*tto= viewing zenith\n    !*psi= azimuth\n    !*ttl= leaf inclination angle\n    !*chi_s= interception functions\n    !*chi_o= interception functions\n    !*frho= function to be multiplied by leaf reflectance rho\n    !*ftau= functions to be multiplied by leaf transmittance tau\n    !********************************************************************************\n\n    !compute volume scattering functions and interception coefficients\n    !for given solar zenith, viewing zenith, azimuth and leaf inclination angle.\n\n    !chi_s and chi_o are the interception functions.\n    !frho and ftau are the functions to be multiplied by leaf reflectance rho and\n    !leaf transmittance tau, respectively, in order to obtain the volume scattering\n    !function.\n\n    !wout verhoef, april 2001, for croma\n\n    implicit none\n\n    real*8,intent(in) :: tts,tto,psi,ttl\n    real*8,intent(inout) :: chi_s,chi_o,frho,ftau\n\n    real*8 :: pi,rd\n    common /angle/ pi,rd\n\n    real*8 costs,costo,sints,sinto,cospsi\n    real*8 psir\n    real*8 costl,sintl,cs,co,ss,so,ds\n    real*8 cosbts,cosbto,bts,bto\n    real*8 btran1,btran2,bt1,bt2,bt3,t1,t2\n    real*8 doo,denom\n\n    costs=cos(rd*tts)\n    costo=cos(rd*tto)\n    sints=sin(rd*tts)\n    sinto=sin(rd*tto)\n    cospsi=cos(rd*psi)\n\n    psir=rd*psi\n\n    costl=cos(rd*ttl)\n    sintl=sin(rd*ttl)\n    cs=costl*costs\n    co=costl*costo\n    ss=sintl*sints\n    so=sintl*sinto\n\n    !c ..............................................................................\n    !c     betas -bts- and betao -bto- computation\n    !c     transition angles (beta) for solar (betas) and view (betao) directions\n    !c     if thetav+thetal>pi/2, bottom side of the leaves is observed for leaf azimut \n    !c     interval betao+phi<leaf azimut<2pi-betao+phi.\n    !c     if thetav+thetal<pi/2, top side of the leaves is always observed, betao=pi\n    !c     same consideration for solar direction to compute betas\n    !c ..............................................................................\n\n\n    cosbts=5.\n    if (abs(ss).gt.1e-6) then\n        cosbts=-cs/ss\n    endif\n\n    cosbto=5.\n    if (abs(so).gt.1e-6) then\n        cosbto=-co/so\n    endif\n\n    if (abs(cosbts).lt.1.d0) then\n        bts=acos(cosbts)\n        ds=ss\n    else\n        bts=pi\n        ds=cs\n    endif\n\n    chi_s=2./pi*((bts-pi*.5)*cs+sin(bts)*ss)\n\n    if (abs(cosbto).lt.1.d0) then\n        bto=acos(cosbto)\n        doo=so\n    elseif(tto.lt.90.) then\n        bto=pi\n        doo=co\n    else\n        bto=0\n        doo=-co\n    endif\n\n    chi_o=2./pi*((bto-pi*.5)*co+sin(bto)*so)\n\n    !c ..............................................................................\n    !c   computation of auxiliary azimut angles bt1, bt2, bt3 used          \n    !c   for the computation of the bidirectional scattering coefficient w              \n    !c .............................................................................\n\n\n    btran1=abs(bts-bto)\n    btran2=pi-abs(bts+bto-pi)\n\n    if (psir.le.btran1) then\n        bt1=psir\n        bt2=btran1\n        bt3=btran2\n    else\n        bt1=btran1\n        if (psir.le.btran2) then\n            bt2=psir\n            bt3=btran2\n        else\n            bt2=btran2\n            bt3=psir\n        endif\n    endif\n\n    t1=2.*cs*co+ss*so*cospsi\n    t2=0.\n    if (bt2.gt.0.) then\n        t2=sin(bt2)*(2.*ds*doo+ss*so*cos(bt1)*cos(bt3))\n    endif\n\n    denom=2.*pi*pi\n    frho=((pi-bt2)*t1+t2)/denom\n    ftau=    (-bt2*t1+t2)/denom\n\n    if (frho.lt.0) then\n        frho=0\n    endif\n\n    if (ftau.lt.0) then\n        ftau=0\n    endif\n\n    return\nend subroutine volscatt\n"}
{"id": 324, "subroutine": "      subroutine snrc(is, kaps, ks, nd1, nd2, ne1, ne2, ibrd, ibre)\n!                                                                      *\n!   determines the range of tensor rank nu for direct/exchange terms,  *\n!   and classifies the types of radial integral.                       *\n!                                                                      *\n!   input variables:                                                   *\n!                                                                      *\n!      is      : orbital labels                                        *\n!      kaps    : values of 2*kappa                                     *\n!      ks      : values of 2*j+1                                       *\n!                                                                      *\n!   outputs:                                                           *\n!                                                                      *\n!      nd1/ne1 : lowest nu value for direct/exchange types             *\n!      nd2/ne2 : corresponding number of contributing nu values: nu    *\n!                = nd1, nd1+2 ,..., nd1+2*(nd2-1) etc                  *\n!      ibrd    : classify types of  radial  integrals  contributing;   *\n!      ibre      negative value implies null contribution              *\n!                                                                      *\n!                                           last update: 09 oct 1992   *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(out) :: nd1\n      integer, intent(out) :: nd2\n      integer, intent(out) :: ne1\n      integer, intent(out) :: ne2\n      integer, intent(out) :: ibrd\n      integer, intent(out) :: ibre\n      integer, intent(in) :: is(4)\n      integer, intent(in) :: kaps(4)\n      integer, intent(in) :: ks(4)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iac, iad, nd1a, nd2a, ne1a, ne2a\n!-----------------------------------------------\n!\n      nd2 = 0\n      ne2 = 0\n!\n!   2.0  form limits for direct terms\n!\n      iac = 1\n      if (kaps(1)*kaps(3) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(4) < 0) iad = -1\n      nd1 = abs(ks(1)-ks(3))/2 - 1\n      if (iac == (-1)) nd1 = nd1 + 1\n      if (nd1 == (-1)) nd1 = 1\n      nd1a = abs(ks(2)-ks(4))/2 - 1\n      if (iad == (-1)) nd1a = nd1a + 1\n      if (nd1a == (-1)) nd1a = 1\n      if (mod(nd1 - nd1a,2) /= 0) then\n         ibrd = -1\n      else\n         nd2 = abs(ks(1)+ks(3))/2\n         if (iac == (-1)) nd2 = nd2 + 1\n         nd2a = abs(ks(2)+ks(4))/2\n         if (iad == (-1)) nd2a = nd2a + 1\n         nd1 = max(nd1,nd1a)\n         nd2 = min(nd2,nd2a)\n         nd2 = (nd2 - nd1)/2 + 1\n!\n!   2.1  identify type of radial integrals\n!\n         ibrd = 1\n         if (is(1)==is(3) .and. is(2)/=is(4) .or. is(1)/=is(3) .and. is(2)==is(&\n            4)) ibrd = 2\n         if (is(1)==is(3) .and. is(2)==is(4)) ibrd = 3\n      endif\n!\n!   3.0  form limits for exchange terms\n!\n      if (is(1)==is(2) .or. is(3)==is(4)) then\n         ibre = -1\n         return\n      endif\n      iac = 1\n      if (kaps(1)*kaps(4) < 0) iac = -1\n      iad = 1\n      if (kaps(2)*kaps(3) < 0) iad = -1\n      ne1 = iabs(ks(1)-ks(4))/2 - 1\n      if (iac == (-1)) ne1 = ne1 + 1\n      if (ne1 == (-1)) ne1 = 1\n      ne1a = abs(ks(2)-ks(3))/2 - 1\n      if (iad == (-1)) ne1a = ne1a + 1\n      if (ne1a == (-1)) ne1a = 1\n      if (mod(ne1 - ne1a,2) /= 0) then\n         ibre = -1\n         return\n      endif\n!\n      ne2 = abs(ks(1)+ks(4))/2\n      if (iac == (-1)) ne2 = ne2 + 1\n      ne2a = abs(ks(2)+ks(3))/2\n      if (iad == (-1)) ne2a = ne2a + 1\n      ne1 = max(ne1,ne1a)\n      ne2 = min(ne2,ne2a)\n      ne2 = (ne2 - ne1)/2 + 1\n!\n!   3.1  identify type of radial integrals\n!\n      ibre = 1\n      if (is(1)==is(4) .and. is(2)/=is(3) .or. is(1)/=is(4) .and. is(2)==is(3)&\n         ) ibre = 2\n      if (is(1)==is(3) .and. is(2)==is(4)) ibre = 4\n      return\n!\n      end subroutine snrc\n"}
{"id": 325, "subroutine": "       subroutine val_is_inf(v, res)\n         use bl_types\n         real(dp_t), intent(in)  :: v\n         integer,    intent(out) :: res\n       end subroutine val_is_inf\n"}
{"id": 326, "subroutine": "       subroutine fab_contains_inf(dptr, count, res)\n         use bl_types\n         integer,    intent(in)  :: count\n         real(dp_t), intent(in)  :: dptr(count)\n         integer,    intent(out) :: res\n       end subroutine fab_contains_inf\n"}
{"id": 327, "subroutine": "  subroutine setval_fabs_on_init(yes_or_no)\n    logical, intent(in) :: yes_or_no\n    do_init_fabs = yes_or_no\n  end subroutine setval_fabs_on_init\n"}
{"id": 328, "subroutine": "  subroutine set_fab_default_init(val)\n    real(dp_t), intent(in) :: val\n    fab_default_init = val\n  end subroutine set_fab_default_init\n"}
{"id": 329, "subroutine": "  subroutine set_zfab_default_init(val)\n    complex(dp_t), intent(in) :: val\n    zfab_default_init = val\n  end subroutine set_zfab_default_init\n"}
{"id": 330, "subroutine": "  subroutine set_ifab_default_init(val)\n    integer, intent(in) :: val\n    ifab_default_init = val\n  end subroutine set_ifab_default_init\n"}
{"id": 331, "subroutine": "  subroutine set_lfab_default_init(val)\n    logical, intent(in) :: val\n    lfab_default_init = val\n  end subroutine set_lfab_default_init\n"}
{"id": 332, "subroutine": "  subroutine print_and_reset_fab_byte_spread()\n    use parallel\n    integer    :: ioproc, ihi, ilo, iav\n    real(dp_t) :: lo, hi, av\n    ioproc = parallel_ioprocessornode()\n    call parallel_reduce(lo, real(fab_high_water_mark,dp_t), mpi_min, proc = ioproc)\n    call parallel_reduce(hi, real(fab_high_water_mark,dp_t), mpi_max, proc = ioproc)\n    call parallel_reduce(av, real(fab_high_water_mark,dp_t), mpi_sum, proc = ioproc)\n    if ( parallel_ioprocessor() ) then\n       !\n       ! this assumes sizeof(dp_t) == 8\n       !\n       ilo = int(lo*(8._dp_t/(1024._dp_t**2)))\n       ihi = int(hi*(8._dp_t/(1024._dp_t**2)))\n       iav = int(av/parallel_nprocs()*(8._dp_t/(1024._dp_t**2)))\n       print*, ''\n       write(6,fmt='(\"fab megabyte spread across mpi nodes: [\",i9,\" - \",i9,\" [avg: \",i9,\"]]\")') ilo, ihi, iav\n       print*, ''\n    end if\n    fab_high_water_mark = 0\n  end subroutine print_and_reset_fab_byte_spread\n"}
{"id": 333, "subroutine": "  subroutine fab_set_mem_stats(ms)\n    type(mem_stats), intent(in) :: ms\n    fab_ms = ms\n  end subroutine fab_set_mem_stats\n"}
{"id": 334, "subroutine": "  subroutine zfab_set_mem_stats(ms)\n    type(mem_stats), intent(in) :: ms\n    zfab_ms = ms\n  end subroutine zfab_set_mem_stats\n"}
{"id": 335, "subroutine": "  subroutine ifab_set_mem_stats(ms)\n    type(mem_stats), intent(in) :: ms\n    ifab_ms = ms\n  end subroutine ifab_set_mem_stats\n"}
{"id": 336, "subroutine": "  subroutine lfab_set_mem_stats(ms)\n    type(mem_stats), intent(in) :: ms\n    lfab_ms = ms\n  end subroutine lfab_set_mem_stats\n"}
{"id": 337, "subroutine": "  subroutine fab_build(fb, bx, nc, ng, nodal, alloc, stencil)\n    use iso_c_binding, only : c_loc, c_ptr, c_size_t\n    interface\n       subroutine double_array_init (p, n) bind(c)\n         use, intrinsic :: iso_c_binding\n         type(c_ptr), value :: p\n         integer(kind=c_size_t), intent(in), value :: n\n       end subroutine double_array_init\n    end interface\n    type(fab), intent(out) :: fb\n    type(box), intent(in)  :: bx\n    integer, intent(in), optional :: ng, nc\n    logical, intent(in), optional :: nodal(:)\n    logical, intent(in), optional :: alloc\n    logical, intent(in), optional :: stencil\n    integer :: lo(max_spacedim), hi(max_spacedim)\n    integer :: lnc, lng\n    logical :: lal, lst\n    integer (kind=c_size_t) :: csz\n    type(c_ptr) :: cp\n    lng = 0; if ( present(ng) ) lng = ng\n    lnc = 1; if ( present(nc) ) lnc = nc\n    lal = .true. ; if ( present(alloc)   ) lal = alloc\n    lst = .false.; if ( present(stencil) ) lst = stencil\n    lo = 1\n    hi = 1\n    fb%dim = bx%dim\n    fb%bx = bx\n    fb%nc = lnc\n    fb%ibx = box_nodalize(bx, nodal)\n    fb%pbx = grow(fb%ibx, lng)\n    lo(1:fb%dim) = fb%pbx%lo(1:fb%dim)\n    hi(1:fb%dim) = fb%pbx%hi(1:fb%dim)\n    if ( empty(fb%pbx) ) return\n    if ( lal ) then\n       if ( lst) then\n          allocate(fb%p(1:lnc,lo(1):hi(1),lo(2):hi(2),lo(3):hi(3)))\n          cp = c_loc(fb%p(1,lo(1),lo(2),lo(3)))\n       else\n          allocate(fb%p(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),1:lnc))\n          cp = c_loc(fb%p(lo(1),lo(2),lo(3),1))\n       end if\n       if ( do_init_fabs ) call setval(fb, fab_default_init)\n       csz = size(fb%p)\n       call double_array_init(cp, csz)\n       call mem_stats_alloc(fab_ms, volume(fb, all=.true.))\n       if ( (fab_ms%num_alloc-fab_ms%num_dealloc) > fab_high_water_mark ) then\n          fab_high_water_mark = (fab_ms%num_alloc-fab_ms%num_dealloc)\n       end if\n    end if\n  end subroutine fab_build\n"}
{"id": 338, "subroutine": "  subroutine zfab_build(fb, bx, nc, ng, nodal, alloc)\n    type(zfab), intent(out) :: fb\n    type(box), intent(in)  :: bx\n    integer, intent(in), optional :: ng, nc\n    logical, intent(in), optional :: nodal(:)\n    logical, intent(in), optional :: alloc\n    integer :: lo(max_spacedim), hi(max_spacedim)\n    integer :: lnc, lng\n    logical :: lal\n    lng = 0; if ( present(ng) ) lng = ng\n    lnc = 1; if ( present(nc) ) lnc = nc\n    lal = .true.; if ( present(alloc) ) lal = alloc\n    lo = 1\n    hi = 1\n    fb%dim = bx%dim\n    fb%bx = bx\n    fb%nc = lnc\n    fb%ibx = box_nodalize(bx, nodal)\n    fb%pbx = grow(fb%ibx, lng)\n    lo(1:fb%dim) = fb%pbx%lo(1:fb%dim)\n    hi(1:fb%dim) = fb%pbx%hi(1:fb%dim)\n    if ( lal ) then\n       allocate(fb%p(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),1:lnc))\n       if ( do_init_fabs ) call setval(fb, zfab_default_init)\n       call mem_stats_alloc(zfab_ms, volume(fb, all=.true.))\n    end if\n  end subroutine zfab_build\n"}
{"id": 339, "subroutine": "  subroutine fab_destroy(fb)\n    type(fab), intent(inout) :: fb\n    if ( associated(fb%p) ) then\n       deallocate(fb%p)\n       if (fb%dim .gt. 0) then\n          call mem_stats_dealloc(fab_ms, volume(fb, all=.true.))\n       end if\n    end if\n    fb%bx  = nobox(fb%dim)\n    fb%dim = 0\n    fb%nc  = 0\n  end subroutine fab_destroy\n"}
{"id": 340, "subroutine": "  subroutine zfab_destroy(fb)\n    type(zfab), intent(inout) :: fb\n    if ( associated(fb%p) ) then\n       deallocate(fb%p)\n       call mem_stats_dealloc(zfab_ms, volume(fb, all=.true.))\n    end if\n    fb%bx  = nobox(fb%dim)\n    fb%dim = 0\n    fb%nc  = 0\n  end subroutine zfab_destroy\n"}
{"id": 341, "subroutine": "  subroutine ifab_destroy(fb)\n    type(ifab), intent(inout) :: fb\n    if ( associated(fb%p) ) then\n       deallocate(fb%p)\n       call mem_stats_dealloc(ifab_ms, volume(fb, all=.true.))\n    end if\n    fb%bx  = nobox(fb%dim)\n    fb%dim = 0\n    fb%nc  = 0\n  end subroutine ifab_destroy\n"}
{"id": 342, "subroutine": "  subroutine fab_setval(fb, val)\n    use bl_error_module\n    type(fab), intent(inout) :: fb\n    real(kind=dp_t), intent(in) :: val\n    if ( .not. associated(fb%p) ) call bl_error(\"fab_setval: not associated\")\n    fb%p = val\n  end subroutine fab_setval\n"}
{"id": 343, "subroutine": "  subroutine fab_setval_bx(fb, val, bx)\n    use bl_error_module\n    type(fab), intent(inout) :: fb\n    type(box), intent(in) :: bx\n    real(kind=dp_t), intent(in) :: val\n    real(kind=dp_t), pointer :: p(:,:,:,:)\n    p => fab_dataptr_bx(fb, bx)\n    if ( .not. associated(p) ) call bl_error(\"fab_setval: not associated\")\n    p = val\n  end subroutine fab_setval_bx\n"}
{"id": 344, "subroutine": "  subroutine zfab_setval_bx(fb, val, bx)\n    use bl_error_module\n    type(zfab), intent(inout) :: fb\n    type(box), intent(in) :: bx\n    complex(kind=dp_t), intent(in) :: val\n    complex(kind=dp_t), pointer :: p(:,:,:,:)\n    p => zfab_dataptr_bx(fb, bx)\n    if ( .not. associated(p) ) call bl_error(\"fab_setval: not associated\")\n    p = val\n  end subroutine zfab_setval_bx\n"}
{"id": 345, "subroutine": "  subroutine fab_setval_c(fb, val, c, nc)\n    use bl_error_module\n    type(fab), intent(inout) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    real(kind=dp_t), intent(in) :: val\n    real(kind=dp_t), pointer :: p(:,:,:,:)\n    p => fab_dataptr_c(fb, c, nc)\n    if ( .not. associated(p) ) call bl_error(\"fab_setval: not associated\")\n    p = val\n  end subroutine fab_setval_c\n"}
{"id": 346, "subroutine": "  subroutine ifab_setval_c(fb, val, c, nc)\n    use bl_error_module\n    type(ifab), intent(inout) :: fb\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    integer, intent(in) :: val\n    integer, pointer :: p(:,:,:,:)\n    p => ifab_dataptr_c(fb, c, nc)\n    if ( .not. associated(p) ) call bl_error(\"fab_setval: not associated\")\n    p = val\n  end subroutine ifab_setval_c\n"}
{"id": 347, "subroutine": "  subroutine lfab_setval_bx_c(fb, val, bx, c, nc)\n    use bl_error_module\n    type(lfab), intent(inout) :: fb\n    type(box), intent(in) :: bx\n    integer, intent(in) :: c\n    integer, intent(in), optional :: nc\n    logical, intent(in) :: val\n    logical, pointer :: p(:,:,:,:)\n    p => lfab_dataptr_bx_c(fb, bx, c, nc)\n    if ( .not. associated(p) ) call bl_error(\"fab_setval: not associated\")\n    p = val\n  end subroutine lfab_setval_bx_c\n"}
{"id": 348, "subroutine": "  subroutine fab_set_corner(fb, val, bx, c, nc)\n    type(fab), intent(inout) :: fb\n    real(dp_t), intent(in) :: val\n    type(box), intent(in) :: bx\n    integer, intent(in) :: c, nc\n    integer :: i, j, k, m, lo(3), hi(3), ilo(3), ihi(3), iin, jin, kin\n    if (fb%dim .eq. 1) return\n    lo = 1\n    hi = 1\n    lo(1:fb%dim) = lwb(bx)\n    hi(1:fb%dim) = upb(bx)\n    ilo = 1\n    ihi = 1\n    ilo(1:fb%dim) = lwb(fb%ibx)\n    ihi(1:fb%dim) = upb(fb%ibx)\n    do m = 1, nc\n       do k = lo(3), hi(3)\n          if (k .ge. ilo(3) .and. k .le. ihi(3)) then\n             kin = 1\n          else\n             kin = 0\n          end if\n          do j = lo(2), hi(2)\n             if (j .ge. ilo(2) .and. j .le. ihi(2)) then\n                jin = 1\n             else\n                jin = 0\n             end if\n             if (jin+kin.eq.2) cycle\n             do i = lo(1), hi(1)\n                if (i .ge. ilo(1) .and. i .le. ihi(1)) then\n                   iin = 1\n                else\n                   iin = 0\n                end if\n                if (iin+jin+kin.le.1) fb%p(i,j,k,m) = val\n             end do\n          end do\n       end do\n    end do\n  end subroutine fab_set_corner\n"}
{"id": 349, "subroutine": "  subroutine fab_print(fb, comp, str, unit, all, data, bx, skip)\n    use bl_io_module\n    type(fab), intent(in) :: fb\n    integer, intent(in), optional :: comp\n    character(len=*), intent(in), optional :: str\n    integer, intent(in), optional :: unit\n    logical, intent(in), optional :: all, data\n    integer, intent(in), optional :: skip\n    type(box), intent(in), optional :: bx\n    integer :: un\n    logical :: lall, ldata\n    type(box) :: lbx\n    lbx  = box_allbox(fb%dim); if ( present(bx) ) lbx  = bx\n    lall = .true.; if ( present(all) ) lall = all\n    ldata = .true.; if ( present(data) ) ldata = data\n    un = unit_stdout(unit)\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\"fab\")', advance = 'no')\n    if ( present(str) ) then\n       write(unit=un, fmt='(\": \",a)') str\n    else\n       write(unit=un, fmt='()')\n    end if\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\" dim     = \",i2)') fb%dim\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\" nc      = \",i2)') fb%nc\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\" ibx     = \",i2)', advance = 'no')\n    call print(fb%ibx, unit = un)\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\" pbx     = \",i2)', advance = 'no')\n    call print(fb%pbx, unit = un)\n    call unit_skip(un, skip)\n    write(unit=un, fmt='(\" bx      = \",i2)', advance = 'no')\n    call print(fb%bx, unit = un)\n    if ( .not. associated(fb%p) ) then\n       call unit_skip(un, skip)\n       write(unit=un, fmt=*) 'not associated'\n    else\n       if ( present(comp) ) then\n        select case (fb%dim)\n        case (1)\n          call print_1d(fb%p(:,1,1,comp:comp), lbound(fb%p), intersection(fb%ibx,lbx))\n        case (2)\n          call print_2d(fb%p(:,:,1,comp:comp), lbound(fb%p), intersection(fb%ibx,lbx))\n        case (3)\n          call print_3d(fb%p(:,:,:,comp:comp), lbound(fb%p), intersection(fb%ibx,lbx))\n        end select\n       else\n        select case (fb%dim)\n        case (1)\n          call print_1d(fb%p(:,1,1,:), lbound(fb%p), intersection(fb%ibx,lbx))\n        case (2)\n          call print_2d(fb%p(:,:,1,:), lbound(fb%p), intersection(fb%ibx,lbx))\n        case (3)\n          call print_3d(fb%p(:,:,:,:), lbound(fb%p), intersection(fb%ibx,lbx))\n        end select\n       end if\n    end if\n  contains\n    subroutine print_1d(fb, lo, bx)\n      integer, intent(in) :: lo(:)\n      type(box), intent(in) :: bx\n      real(kind=dp_t), intent(in) :: fb(lo(1):,:)\n      integer ::n, i\n      integer :: nc, hi(1)\n      character(len=1) c\n      nc = size(fb,dim=2)\n      hi(1) = lo(1) + size(fb,dim=1) - 1\n      if ( ldata ) then\n         do n = 1, nc\n            do i = lo(1), hi(1)\n               if ( .not. ( lall .or. contains(bx, (/i/)) ) ) cycle\n               c = ' '\n               if ( .not. contains(bx, (/i/)) ) c = '*'\n               call unit_skip(un, skip)\n               write(unit=un, fmt='(a1,1x,i3,1(1x,i5),1x,g25.15)') &\n                    c, n, i, fb(i,n)\n            end do\n         end do\n      end if\n    end subroutine print_1d\n    subroutine print_2d(fb, lo, bx)\n      integer, intent(in) :: lo(:)\n      type(box), intent(in) :: bx\n      real(kind=dp_t), intent(in) :: fb(lo(1):,lo(2):,:)\n      integer :: n, j, i\n      integer :: nc, hi(2)\n      character(len=1) c\n      nc = size(fb,dim=3)\n      do i = 1, 2\n         hi(i) = lo(i) + size(fb,dim=i) - 1\n      end do\n      if ( ldata ) then\n         do n = 1, nc\n            do j = lo(2), hi(2)\n               do i = lo(1), hi(1)\n                  if ( .not. ( lall .or. contains(bx, (/i,j/)) ) ) cycle\n                  c = ' '\n                  if ( .not. contains(bx, (/i,j/)) ) c = '*'\n                  call unit_skip(un, skip)\n                  write(unit=un, fmt='(a1,1x,i3,2(1x,i5),1x,g25.15)') &\n                       c, n, i, j, fb(i,j,n)\n               end do\n            end do\n         end do\n      end if\n    end subroutine print_2d\n    subroutine print_3d(fb, lo, bx)\n      integer, intent(in) :: lo(:)\n      type(box), intent(in) :: bx\n      real(kind=dp_t), intent(in) :: fb(lo(1):,lo(2):,lo(3):,:)\n      integer :: n, k, j, i\n      integer :: nc, hi(3)\n      character(len=1) :: c\n      nc = size(fb,dim=4)\n      do i = 1, 3\n         hi(i) = lo(i) + size(fb,dim=i) - 1\n      end do\n      if ( ldata ) then\n         do n = 1, nc\n            do k = lo(3), hi(3)\n               do j = lo(2), hi(2)\n                  do i = lo(1), hi(1)\n                     if ( .not. ( lall .or. contains(bx, (/i,j,k/)) ) ) cycle\n                     c = ' '\n                     if ( .not. contains(bx, (/i,j,k/)) ) c = '*'\n                     call unit_skip(un, skip)\n                     write(unit=un, fmt='(a1,1x,i3,3(1x,i5),1x,g25.15)') &\n                          c, n, i, j, k, fb(i,j,k,n)\n                  end do\n               end do\n            end do\n         end do\n      end if\n    end subroutine print_3d\n  end subroutine fab_print\n"}
{"id": 350, "subroutine": "  subroutine set_manual_control_least_used_cpus(flag)\n    logical, intent(in) :: flag\n    manual_control_least_used_cpus = flag\n  end subroutine set_manual_control_least_used_cpus\n"}
{"id": 351, "subroutine": "  subroutine set_luc_vol(i)\n    integer(kind=ll_t), intent(in) :: i\n    mcluc_vol = i\n  end subroutine set_luc_vol\n"}
{"id": 352, "subroutine": "  subroutine fab_build_0d (fb,nc)\n    type(fab), intent(out) :: fb\n    integer, intent(in) :: nc\n    fb%dim = 0\n    fb%bx  = nobox(3)\n    fb%pbx = fb%bx\n    fb%ibx = fb%bx\n    fb%nc  = nc\n    allocate(fb%p(nc,1,1,1))\n  end subroutine fab_build_0d\n"}
{"id": 353, "subroutine": "    subroutine init(self)\n        class(harmonic_balance_t),  intent(inout)   :: self\n\n        integer(ik)                         :: ierr\n        type(assemble_harmonic_balance_t)   :: assemble_harmonic_balance\n\n        call self%set_name('harmonic balance')\n\n        if (allocated(self%system)) deallocate(self%system)\n        allocate(self%system, source=assemble_harmonic_balance, stat=ierr)\n        if (ierr /= 0) call allocationerror\n\n    end subroutine init\n"}
{"id": 354, "subroutine": "    subroutine step(self,data,nonlinear_solver,linear_solver,preconditioner)\n        class(harmonic_balance_t),                      intent(inout)   :: self\n        type(chidg_data_t),                             intent(inout)   :: data\n        class(nonlinear_solver_t),   optional,          intent(inout)   :: nonlinear_solver\n        class(linear_solver_t),      optional,          intent(inout)   :: linear_solver\n        class(preconditioner_t),     optional,          intent(inout)   :: preconditioner\n\n        ! simply solve the nonlinear system. no iteration in time.\n        call nonlinear_solver%solve(data,self%system,linear_solver,preconditioner)\n\n        ! store end residual from nonlinear solver.\n        call self%residual_norm%push_back(nonlinear_solver%residual_norm%at(nonlinear_solver%residual_norm%size()))\n\n    end subroutine step\n"}
{"id": 355, "subroutine": "    subroutine assemble(self,data,differentiate,timing)\n        class(assemble_harmonic_balance_t),   intent(inout)               :: self\n        type(chidg_data_t),                   intent(inout)               :: data\n        integer(ik),                          intent(in)                  :: differentiate\n        real(rk),                             intent(inout), optional     :: timing\n\n        integer(ik)             :: itime_outer, itime_inner, idom, ielem, ifield, ierr, ntime, &\n                                   irow_start, irow_end, icol_start, icol_end\n        real(rk),   allocatable :: temp_1(:), temp_2(:), d(:,:), temp_mat(:,:), hb_mat(:,:)\n        type(chidg_vector_t)    :: rhs_tmp\n        type(seed_t)            :: seed\n        type(element_info_t)    :: elem_info\n\n        \n        associate ( rhs => data%sdata%rhs, lhs => data%sdata%lhs, q => data%sdata%q )\n        call rhs%clear()\n        if (differentiate == dq_diff) call lhs%clear()\n\n\n        ! set local variables equal to the values set in time_manager\n        ntime = size(data%time_manager%times)\n        d = data%time_manager%d\n\n        do itime_outer = 1,ntime\n\n            ! spatial update needed\n            data%time_manager%itime = itime_outer\n            data%time_manager%t     = data%time_manager%times(itime_outer)\n            call update_space(data,differentiate,timing)\n\n            do idom = 1,data%mesh%ndomains()\n\n                if (allocated(temp_1) .and. allocated(temp_2)) deallocate(temp_1,temp_2)\n                allocate(temp_1(data%mesh%domain(idom)%nterms_s),temp_2(data%mesh%domain(idom)%nterms_s), stat=ierr)\n                if (ierr /= 0) call allocationerror\n\n                do ielem = 1,data%mesh%domain(idom)%nelem\n                    elem_info = data%mesh%get_element_info(idom,ielem)\n\n                    do itime_inner = 1,ntime\n\n                        ! lhs hb contribution for each variable\n                        temp_mat = d(itime_outer,itime_inner)*data%mesh%domain(idom)%elems(ielem)%mass\n                        if (allocated(hb_mat)) deallocate(hb_mat)\n                        allocate(hb_mat(elem_info%nterms_s*elem_info%nfields,elem_info%nterms_s*elem_info%nfields), stat=ierr)\n                        if (ierr /= 0) call allocationerror\n                        hb_mat = zero\n\n                        ! accumulate variable contributions\n                        do ifield = 1,data%eqnset(elem_info%eqn_id)%prop%nprimary_fields()\n\n                            ! temporary variables for computing the temporal rhs contributions\n                            temp_1 = d(itime_outer,itime_inner)*matmul(data%mesh%domain(idom)%elems(ielem)%mass, &\n                                                            q%get_field(elem_info,ifield,itime_inner))\n\n\n                            call rhs%add_field(temp_1,elem_info,ifield,itime_outer)\n\n                            ! accumulate hb contribution for the variable\n                            irow_start = 1 + (ifield-1)*elem_info%nterms_s\n                            irow_end   = irow_start + (elem_info%nterms_s-1)\n                            icol_start = 1 + (ifield-1)*elem_info%nterms_s\n                            icol_end   = icol_start + (elem_info%nterms_s-1)\n                            hb_mat(irow_start:irow_end,icol_start:icol_end) = temp_mat\n\n                        end do  ! ifield\n\n                        ! lhs contribution\n                        call seed%init(elem_info%idomain_g,  &\n                                       elem_info%idomain_l,  &\n                                       elem_info%ielement_g, &\n                                       elem_info%ielement_l, &\n                                       elem_info%nfields,    &\n                                       elem_info%nterms_s,   &\n                                       elem_info%nterms_c,   &\n                                       irank,                &\n                                       itime_inner,          &\n                                       elem_info%dof_start,  &\n                                       elem_info%xdof_start, &\n                                       no_id,                &\n                                       no_id,                &\n                                       no_id)\n\n                        ! store hb contribution for all fields to lhs at one time\n                        if (itime_inner /= itime_outer) then\n                            if (differentiate == dq_diff) call lhs%store_element(hb_mat,elem_info,seed,itime_outer)\n                        end if\n\n\n                    end do  ! itime_inner\n                end do  ! ielem\n            end do  ! idom\n        end do  ! itime_outer\n\n        end associate\n\n\n        ! assemble rhs, lhs after hb contributions\n        call data%sdata%rhs%assemble()\n        if (differentiate == dq_diff) call data%sdata%lhs%assemble()\n\n\n    end subroutine assemble\n"}
{"id": 356, "subroutine": "  subroutine correc(p)\n\n    real, intent(in), dimension(0:,0:,0:) :: p\n    real, dimension(0:i1,0:j1,0:k1) :: dpdx, dpdy, dpdz\n    integer :: i,j,k\n\n    !$omp parallel default(none) &\n    !$omp&shared(factori,factorj,factork) &\n    !$omp&shared(p,unew,vnew,wnew,dudt,dvdt,dwdt) &\n    !$omp&private(i,j,k)\n    !$omp do\n\n    do k=1,kmax\n       do j=1,jmax\n          do i=1,imax\n\n             !---- remove pressure jump (gfm) ----!\n\n             unew(i,j,k) = dudt(i,j,k) - dt*dxi * ( p(i+1,j,k)-p(i,j,k) -p_x(i,j,k) )/rho0 \n             vnew(i,j,k) = dvdt(i,j,k) - dt*dyi * ( p(i,j+1,k)-p(i,j,k) -p_y(i,j,k) )/rho0\n             wnew(i,j,k) = dwdt(i,j,k) - dt*dzi * ( p(i,j,k+1)-p(i,j,k) -p_z(i,j,k) )/rho0\n\n          enddo\n       enddo\n    enddo\n    !$omp end parallel\n\n\n    return\n  end subroutine correc\n"}
{"id": 357, "subroutine": "subroutine bondseek(n,positions,r0,r1,bn)\n\n    implicit none\n\n    integer*4, intent(in)       :: n\n    real*8,    intent(in)       :: r0,r1\n    real*8,    intent(in)       :: positions(n,3)\n\n    integer*4 :: i,j,k\n    integer*4, intent(out) :: bn\n\n    real*8 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n\n    bn = 0\n\n    do i = 1, (n - 1)\n        xi = positions(i,1)\n        yi = positions(i,2)\n        zi = positions(i,3)\n        do j = 1, n\n            if (i .ge. j) cycle\n            xj = positions(j,1)\n            yj = positions(j,2)\n            zj = positions(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = sqrt(dx * dx + dy * dy + dz * dz)\n\n            if (mdl .ge. r0 .and. mdl .le. r1) bn = bn + 1\n\n        end do\n    end do\n    return\nend subroutine bondseek\n"}
{"id": 358, "subroutine": "      subroutine dt_himult(mode)\n \nc***********************************************************************\nc tables of average energies/multiplicities.                           *\nc this version dated 30.08.2000 is written by s. roesler               *\nc last change  5.5.2012 by s. roesler.                                 *\nc***********************************************************************\n \n      implicit none\n      double precision ave , avmult , avpt , avswm , betblc , betgre , \n     &                 one , swmexp , tiny14 , two , zero\n      integer i , iavpt , ivel , j , mode , nopart\n      save \n \n      include 'inc/dtflka'\n \n      parameter (zero=0.0d0,one=1.0d0,two=2.0d0,tiny14=1.0d-14)\n \n      parameter (swmexp=1.7d0)\n \n      character*8 anameh(4)\n \nc particle properties (bamjet index convention)\n      include 'inc/dtpart'\nc temporary storage for one final state particle\n      include 'inc/dtfspa'\nc event flag used for histograms\n      include 'inc/dtnorm'\nc lorentz-parameters of the current interaction\n      include 'inc/dtltra'\n \n      parameter (nopart=210)\n      dimension avmult(4,nopart) , ave(4,nopart) , avswm(4,nopart) , \n     &          avpt(4,nopart) , iavpt(4,nopart)\n      data anameh/'deuteron' , '3-h     ' , '3-he    ' , '4-he    '/\n \n      if ( mode.eq.2 ) then\n \nc------------------------------------------------------------------\nc filling of histogram with event-record\n         if ( pe.lt.0.0d0 ) then\n \n            if ( lpri.gt.4 ) write (lout,*) ' himult:  pe < 0 ! ' , pe\n            return\n         end if\n         if ( .not.lfrag ) then\n            ivel = 2\n            if ( lgrey ) ivel = 3\n            if ( lblack ) ivel = 4\n            ave(1,idbjt) = ave(1,idbjt) + pe\n            ave(ivel,idbjt) = ave(ivel,idbjt) + pe\n            avpt(1,idbjt) = avpt(1,idbjt) + pt\n            avpt(ivel,idbjt) = avpt(ivel,idbjt) + pt\n            iavpt(1,idbjt) = iavpt(1,idbjt) + 1\n            iavpt(ivel,idbjt) = iavpt(ivel,idbjt) + 1\n            avswm(1,idbjt) = avswm(1,idbjt) + pe**swmexp\n            avswm(ivel,idbjt) = avswm(ivel,idbjt) + pe**swmexp\n            avmult(1,idbjt) = avmult(1,idbjt) + one\n            avmult(ivel,idbjt) = avmult(ivel,idbjt) + one\n            if ( idbjt.lt.207 ) then\nc   total energy, multiplicity\n               ave(1,30) = ave(1,30) + pe\n               ave(ivel,30) = ave(ivel,30) + pe\n               avpt(1,30) = avpt(1,30) + pt\n               avpt(ivel,30) = avpt(ivel,30) + pt\n               iavpt(1,30) = iavpt(1,30) + 1\n               iavpt(ivel,30) = iavpt(ivel,30) + 1\n               avswm(1,30) = avswm(1,30) + pe**swmexp\n               avswm(ivel,30) = avswm(ivel,30) + pe**swmexp\n               avmult(1,30) = avmult(1,30) + one\n               avmult(ivel,30) = avmult(ivel,30) + one\nc   charged energy, multiplicity\n               if ( ichar.lt.0 ) then\n                  ave(1,26) = ave(1,26) + pe\n                  ave(ivel,26) = ave(ivel,26) + pe\n                  avpt(1,26) = avpt(1,26) + pt\n                  avpt(ivel,26) = avpt(ivel,26) + pt\n                  iavpt(1,26) = iavpt(1,26) + 1\n                  iavpt(ivel,26) = iavpt(ivel,26) + 1\n                  avswm(1,26) = avswm(1,26) + pe**swmexp\n                  avswm(ivel,26) = avswm(ivel,26) + pe**swmexp\n                  avmult(1,26) = avmult(1,26) + one\n                  avmult(ivel,26) = avmult(ivel,26) + one\n               end if\n               if ( ichar.ne.0 ) then\n                  ave(1,27) = ave(1,27) + pe\n                  ave(ivel,27) = ave(ivel,27) + pe\n                  avpt(1,27) = avpt(1,27) + pt\n                  avpt(ivel,27) = avpt(ivel,27) + pt\n                  iavpt(1,27) = iavpt(1,27) + 1\n                  iavpt(ivel,27) = iavpt(ivel,27) + 1\n                  avswm(1,27) = avswm(1,27) + pe**swmexp\n                  avswm(ivel,27) = avswm(ivel,27) + pe**swmexp\n                  avmult(1,27) = avmult(1,27) + one\n                  avmult(ivel,27) = avmult(ivel,27) + one\n               end if\n            end if\n         end if\n \n         return\n      else if ( mode.eq.3 ) then\n \nc------------------------------------------------------------------\nc output\n \n         if ( lpri.gt.4 ) write (lout,99010)\n99010    format (/,1x,'himult:',21x,'particle - statistics',/,29x,\n     &           '---------------------',/)\n         if ( muldef.eq.1 ) then\n \n            if ( lpri.gt.4 ) write (lout,'(1x,a,/)')\n     &            'fast/grey/black: emu-def.'\n         else\n            betgre = 0.7d0\n            betblc = 0.23d0\n \n            if ( lpri.gt.4 ) write (lout,99020) betgre , betgre , \n     &           betblc , betblc\n99020       format (1x,'fast:  beta > ',f4.2,'    grey:  ',f4.2,\n     &              ' > beta > ',f4.2,'    black:  beta < ',f4.2,/)\n         end if\n \n         if ( lpri.gt.4 ) write (lout,99030) swmexp\nc    &      '       grey     black      k      f(',f3.1,')',/,1x,\n99030    format (1x,'particle    |',12x,'average multiplicity',/,13x,\n     &           '|     total         fast',\n     &           '       grey     black    <pt>     f(',f3.1,')',/,1x,\n     &           '------------+--------------',\n     &           '-------------------------------------------------')\n         do i = 1 , nopart\n            do j = 1 , 4\n               avmult(j,i) = avmult(j,i)/dble(max(icevt,1))\n               ave(j,i) = ave(j,i)/dble(max(icevt,1))/eproj\n               avpt(j,i) = avpt(j,i)/dble(max(iavpt(j,i),1))\n               avswm(j,i) = avswm(j,i)/dble(max(icevt,1))/eproj**swmexp\n            end do\n            if ( i.lt.207 ) then\n \nc    &                       ave(1,i),avswm(1,i)\n               if ( lpri.gt.4 ) write (lout,99040) aname(i) , i , \n     &              avmult(1,i) , avmult(2,i) , avmult(3,i) , \n     &              avmult(4,i) , avpt(1,i) , avswm(1,i)\n            else\n \nc    &                       ave(1,i),avswm(1,i)\n               if ( lpri.gt.4 ) write (lout,99040) anameh(i-206) , i , \n     &              avmult(1,i) , avmult(2,i) , avmult(3,i) , \n     &              avmult(4,i) , avpt(1,i) , avswm(1,i)\n            end if\n         end do\n         goto 99999\n      end if\n \nc------------------------------------------------------------------\nc initialization\n      do i = 1 , nopart\n         do j = 1 , 4\n            avmult(j,i) = zero\n            ave(j,i) = zero\n            avswm(j,i) = zero\n            avpt(j,i) = zero\n            iavpt(j,i) = 0\n         end do\n      end do\n \n      return\n99040 format (1x,a8,i4,'| ',2f13.6,2f9.5,2f9.5)\nc*temporary\nc     write(lout,'(a,f7.3)') ' number of charged heavy particles: ',\nc    &               avmult(3,27)+avmult(4,27)\nc*\n \n99999 end subroutine\n"}
{"id": 359, "subroutine": "      subroutine chisq_aspect_max(target,sigma,niter,iflag)\n!-----------------------------------------------------------------------\n!     libraries\n!-----------------------------------------------------------------------\n      use stellopt_runtime\n      use stellopt_targets\n      use equil_vals, only: aspect\n      \n!-----------------------------------------------------------------------\n!     input/output variables\n!\n!-----------------------------------------------------------------------\n      real(rprec), intent(in)    ::  target\n      real(rprec), intent(in)    ::  sigma\n      integer,     intent(in)    ::  niter\n      integer,     intent(in)    ::  iflag\n      \n!-----------------------------------------------------------------------\n!     local variables\n!\n!-----------------------------------------------------------------------\n      \n!----------------------------------------------------------------------\n\n!----------------------------------------------------------------------\n      if (iflag < 0) return\n      if (iflag == 1) write(iunit_out,'(a,2(2x,i3.3))') 'aspect_max ',1,4\n      if (iflag == 1) write(iunit_out,'(a)') 'target sigma aspect_max chi'\n      if (niter >= 0) then\n         mtargets = mtargets + 1\n         targets(mtargets) = target\n         sigmas(mtargets)  = sigma\n         ! impose a limit on the calculated aspect ratio, below aspec_max\n         ! it should match target but above it should match grow\n         vals(mtargets)    = target + 1 + tanh((aspect-target)/(width_aspect_max))\n         if (iflag == 1) write(iunit_out,'(3es22.12e3)') target,sigma,aspect,vals(mtargets)\n      else\n         if (sigma < bigno) then\n            mtargets = mtargets + 1\n            if (niter == -2) target_dex(mtargets)=jtarget_aspect_max\n         end if\n      end if\n      return\n!----------------------------------------------------------------------\n\n!----------------------------------------------------------------------\n      end subroutine chisq_aspect_max\n"}
{"id": 360, "subroutine": "      subroutine shelltri (lm, e, enon, al, yl, dl, xl, bfl, ptr)\n      use commod\n      use allfun\n      implicit none\n\n      type(mshtype), intent(in) :: lm\n      integer, intent(in) :: e, enon, ptr(enon)\n      real(kind=8), intent(in) :: al(tdof,enon), yl(tdof,enon),\n     2   dl(tdof,enon), xl(3,enon), bfl(3,enon)\n\n      logical :: bflag, setit(3)\n      integer :: i, j, k, a, b, g\n      real(kind=8) :: rho, dmp, elm, nu, ht, t1, amd, afl, w, jac0, jac,\n     2   ud(3), fb(3), nv0(3), nv(3), gcov0(3,2), gcnv0(3,2), gcov(3,2),\n     3   gcnv(3,2), x0(3,enon), xc(3,enon), eloc(3,3), jm(2,2), qm(3,3),\n     4   dm(3,3), em(3), eb(3), dem(3), deb(3), bm(3,3,enon),\n     5   bb(3,3,enon), dbm(3,3,enon), dbb(3,3,enon), btde, btdb, nxsnx\n\n      real(kind=8), allocatable :: n(:), nx(:,:), lr(:,:), lk(:,:,:),\n     2   tmpx(:,:)\n\n!     note that for triangular elements, enon=6 and lm%enon=3\n      allocate(n(lm%enon), nx(2,lm%enon), lr(dof,enon),\n     2   lk(dof*dof,enon,enon))\n\n!     define parameters\n      rho   = eq(ceq)%dmn(cdmn)%prop(solid_density)\n      dmp   = eq(ceq)%dmn(cdmn)%prop(damping)\n      elm   = eq(ceq)%dmn(cdmn)%prop(elasticity_modulus)\n      nu    = eq(ceq)%dmn(cdmn)%prop(poisson_ratio)\n      ht    = eq(ceq)%dmn(cdmn)%prop(shell_thickness)\n      fb(1) = eq(ceq)%dmn(cdmn)%prop(f_x)\n      fb(2) = eq(ceq)%dmn(cdmn)%prop(f_y)\n      fb(3) = eq(ceq)%dmn(cdmn)%prop(f_z)\n\n      amd  = eq(ceq)%am*rho + eq(ceq)%af*eq(ceq)%gam*dt*dmp\n      afl  = eq(ceq)%af*eq(ceq)%beta*dt*dt\n      i    = eq(ceq)%s\n      j    = i + 1\n      k    = j + 1\n\n!     determine if current element is a boundary element\n      bflag = .false.\n      do a=lm%enon+1, enon\n         if (ptr(a) .eq. 0) then\n            bflag = .true.\n            exit\n         end if\n      end do\n\n!     get the reference configuration\n      x0(:,:) = xl(:,:)\n\n!     get the current configuration\n      do a=1, enon\n         xc(1,a) = x0(1,a) + dl(i,a)\n         xc(2,a) = x0(2,a) + dl(j,a)\n         xc(3,a) = x0(3,a) + dl(k,a)\n      end do\n      nx(:,:) = lm%nx(:,:,1)\n\n!     covariant and contravariant bases in reference config\n      allocate(tmpx(nsd,lm%enon))\n      tmpx = x0(:,1:lm%enon)\n      call gnns(lm%enon, nx, tmpx, nv0, gcov0, gcnv0)\n      jac0 = sqrt(norm(nv0))\n      nv0  = nv0/jac0\n\n!     covariant and contravariant bases in current config\n      tmpx = xc(:,1:lm%enon)\n      call gnns(lm%enon, nx, tmpx, nv, gcov, gcnv)\n      jac = sqrt(norm(nv))\n      nv  = nv/jac\n      deallocate(tmpx)\n\n!     define local coordinates, jacobian (j) and its inverse tensor\n!     defined in voigt notation such that q*e = j^{-t} * e * j^{-1})\n      eloc(:,1) = gcov0(:,1)/sqrt(norm(gcov0(:,1)))\n      eloc(:,3) = nv0(:)\n\n      eloc(1,2) = eloc(2,3)*eloc(3,1) - eloc(3,3)*eloc(2,1)\n      eloc(2,2) = eloc(3,3)*eloc(1,1) - eloc(1,3)*eloc(3,1)\n      eloc(3,2) = eloc(1,3)*eloc(2,1) - eloc(2,3)*eloc(1,1)\n\n      jm(1,1) = norm(gcov0(:,1), eloc(:,1))\n      jm(1,2) = norm(gcov0(:,2), eloc(:,1))\n      jm(2,1) = norm(gcov0(:,1), eloc(:,2))\n      jm(2,2) = norm(gcov0(:,2), eloc(:,2))\n\n      qm = 0d0\n      qm(1,1) = 1d0/jm(1,1)**2\n      qm(2,1) = (-jm(1,2)/(jm(1,1)*jm(2,2)))**2\n      qm(2,2) = 1d0/jm(2,2)**2\n      qm(2,3) = -jm(1,2)/(jm(1,1)*jm(2,2)**2)\n      qm(3,1) = -2d0*jm(1,2)/(jm(2,2)*jm(1,1)**2)\n      qm(3,3) = 1d0/(jm(1,1)*jm(2,2))\n\n!     material tensor d, isotropic st venant kirchhoff model\n      dm = 0d0\n      dm(1,1) = 1d0\n      dm(1,2) = nu\n      dm(2,1) = nu\n      dm(2,2) = 1d0\n      dm(3,3) = 5d-1*(1d0-nu)\n      dm = elm/(1d0-nu**2) * dm\n\n!     compute qt * d * q\n      dm = matmul(dm, qm)\n      dm = matmul(transpose(qm), dm)\n\n!     membrane strain and its variation\n!     define membrane strain tensor (em), voigt notation\n      em = 0d0\n      do g=1, nsd\n         em(1) = em(1) + gcov(g,1)*gcov(g,1) - gcov0(g,1)*gcov0(g,1)\n         em(2) = em(2) + gcov(g,2)*gcov(g,2) - gcov0(g,2)*gcov0(g,2)\n         em(3) = em(3) + gcov(g,1)*gcov(g,2) - gcov0(g,1)*gcov0(g,2)\n      end do\n      em(1) = 5d-1 * em(1)\n      em(2) = 5d-1 * em(2)\n\n!     define variation in membrane strain only for the main element\n      bm = 0d0\n      do a=1, lm%enon\n         bm(1,1,a) = nx(1,a)*gcov(1,1)\n         bm(1,2,a) = nx(1,a)*gcov(2,1)\n         bm(1,3,a) = nx(1,a)*gcov(3,1)\n\n         bm(2,1,a) = nx(2,a)*gcov(1,2)\n         bm(2,2,a) = nx(2,a)*gcov(2,2)\n         bm(2,3,a) = nx(2,a)*gcov(3,2)\n\n         bm(3,1,a) = nx(2,a)*gcov(1,1) + nx(1,a)*gcov(1,2)\n         bm(3,2,a) = nx(2,a)*gcov(2,1) + nx(1,a)*gcov(2,2)\n         bm(3,3,a) = nx(2,a)*gcov(3,1) + nx(1,a)*gcov(3,2)\n      end do\n\n!     zero-out bm for fixed bc on boundary elements\n      if (bflag) then\n         setit = .false.\n         do a=lm%enon+1, enon\n            if (ptr(a) .eq. 0) then\n               b = a - lm%enon\n               if (btest(lm%sbc(b,e),btype_fix)) setit(b) = .true.\n            end if\n         end do\n\n         do a=1, lm%enon\n            if (setit(a)) then\n               do b=1, lm%enon\n                  if (a .eq. b) cycle\n                  bm(:,:,b) = 0d0\n               end do\n            end if\n         end do\n      end if\n\n!     bending strain and its variation for triangular elements\n      call shellbendtri(lm, e, ptr, x0, xc, eb, bb)\n\n!     contribution to residue and tangent matrices from membrane strain\n!     d * em\n      dem(1) = dm(1,1)*em(1) + dm(1,2)*em(2) + dm(1,3)*em(3)\n      dem(2) = dm(2,1)*em(1) + dm(2,2)*em(2) + dm(2,3)*em(3)\n      dem(3) = dm(3,1)*em(1) + dm(3,2)*em(2) + dm(3,3)*em(3)\n\n!     d * bm\n      do a=1, lm%enon\n         dbm(1,1,a) = dm(1,1)*bm(1,1,a) + dm(1,2)*bm(2,1,a) +\n     2      dm(1,3)*bm(3,1,a)\n         dbm(1,2,a) = dm(1,1)*bm(1,2,a) + dm(1,2)*bm(2,2,a) +\n     2      dm(1,3)*bm(3,2,a)\n         dbm(1,3,a) = dm(1,1)*bm(1,3,a) + dm(1,2)*bm(2,3,a) +\n     2      dm(1,3)*bm(3,3,a)\n\n         dbm(2,1,a) = dm(2,1)*bm(1,1,a) + dm(2,2)*bm(2,1,a) +\n     2      dm(2,3)*bm(3,1,a)\n         dbm(2,2,a) = dm(2,1)*bm(1,2,a) + dm(2,2)*bm(2,2,a) +\n     2      dm(2,3)*bm(3,2,a)\n         dbm(2,3,a) = dm(2,1)*bm(1,3,a) + dm(2,2)*bm(2,3,a) +\n     2      dm(2,3)*bm(3,3,a)\n\n         dbm(3,1,a) = dm(3,1)*bm(1,1,a) + dm(3,2)*bm(2,1,a) +\n     2      dm(3,3)*bm(3,1,a)\n         dbm(3,2,a) = dm(3,1)*bm(1,2,a) + dm(3,2)*bm(2,2,a) +\n     2      dm(3,3)*bm(3,2,a)\n         dbm(3,3,a) = dm(3,1)*bm(1,3,a) + dm(3,2)*bm(2,3,a) +\n     2      dm(3,3)*bm(3,3,a)\n      end do\n\n!     contribution to residue and tangent matrices from bending strain\n!     d * eb\n      deb(1) = dm(1,1)*eb(1) + dm(1,2)*eb(2) + dm(1,3)*eb(3)\n      deb(2) = dm(2,1)*eb(1) + dm(2,2)*eb(2) + dm(2,3)*eb(3)\n      deb(3) = dm(3,1)*eb(1) + dm(3,2)*eb(2) + dm(3,3)*eb(3)\n\n!     d * bb\n      do a=1, enon\n         dbb(1,1,a) = dm(1,1)*bb(1,1,a) + dm(1,2)*bb(2,1,a) +\n     2      dm(1,3)*bb(3,1,a)\n         dbb(1,2,a) = dm(1,1)*bb(1,2,a) + dm(1,2)*bb(2,2,a) +\n     2      dm(1,3)*bb(3,2,a)\n         dbb(1,3,a) = dm(1,1)*bb(1,3,a) + dm(1,2)*bb(2,3,a) +\n     2      dm(1,3)*bb(3,3,a)\n\n         dbb(2,1,a) = dm(2,1)*bb(1,1,a) + dm(2,2)*bb(2,1,a) +\n     2      dm(2,3)*bb(3,1,a)\n         dbb(2,2,a) = dm(2,1)*bb(1,2,a) + dm(2,2)*bb(2,2,a) +\n     2      dm(2,3)*bb(3,2,a)\n         dbb(2,3,a) = dm(2,1)*bb(1,3,a) + dm(2,2)*bb(2,3,a) +\n     2      dm(2,3)*bb(3,3,a)\n\n         dbb(3,1,a) = dm(3,1)*bb(1,1,a) + dm(3,2)*bb(2,1,a) +\n     2      dm(3,3)*bb(3,1,a)\n         dbb(3,2,a) = dm(3,1)*bb(1,2,a) + dm(3,2)*bb(2,2,a) +\n     2      dm(3,3)*bb(3,2,a)\n         dbb(3,3,a) = dm(3,1)*bb(1,3,a) + dm(3,2)*bb(2,3,a) +\n     2      dm(3,3)*bb(3,3,a)\n      end do\n\n!     contribution to residue and stiffness matrices due to inertia and\n!     body forces\n      lr = 0d0\n      lk = 0d0\n      do g=1, lm%ng\n         n = lm%n(:,g)\n         w = lm%w(g)*jac0*ht\n!        acceleration and mass damping at the integration point\n         ud = -fb\n         do a=1, lm%enon\n            ud(1) = ud(1) + n(a)*(rho*(al(i,a)-bfl(1,a)) + dmp*yl(i,a))\n            ud(2) = ud(2) + n(a)*(rho*(al(j,a)-bfl(2,a)) + dmp*yl(j,a))\n            ud(3) = ud(3) + n(a)*(rho*(al(k,a)-bfl(3,a)) + dmp*yl(k,a))\n         end do\n\n!        local residue\n         do a=1, lm%enon\n            lr(1,a) = lr(1,a) + n(a)*w*ud(1)\n            lr(2,a) = lr(2,a) + n(a)*w*ud(2)\n            lr(3,a) = lr(3,a) + n(a)*w*ud(3)\n         end do\n\n!        local stiffness contribution from mass matrix\n         do b=1, lm%enon\n            do a=1, lm%enon\n               t1 = w*amd*n(a)*n(b)\n               lk(1,a,b) = lk(1,a,b) + t1\n               lk(dof+2,a,b) = lk(dof+2,a,b) + t1\n               lk(2*dof+3,a,b) = lk(2*dof+3,a,b) + t1\n            end do\n         end do\n      end do\n\n!     contribution from membrane strain related terms only on the main\n!     triangular element\n      t1 = jac0 * ht/2d0\n      do a=1, lm%enon\n         btde = bm(1,1,a)*dem(1) + bm(2,1,a)*dem(2) + bm(3,1,a)*dem(3)\n         lr(1,a) = lr(1,a) + t1*btde\n\n         btde = bm(1,2,a)*dem(1) + bm(2,2,a)*dem(2) + bm(3,2,a)*dem(3)\n         lr(2,a) = lr(2,a) + t1*btde\n\n         btde = bm(1,3,a)*dem(1) + bm(2,3,a)*dem(2) + bm(3,3,a)*dem(3)\n         lr(3,a) = lr(3,a) + t1*btde\n\n         do b=1, lm%enon\n!           geometric stiffness\n            nxsnx = ( nx(1,a)*nx(1,b)*dem(1) + nx(2,a)*nx(2,b)*dem(2) +\n     2                nx(1,a)*nx(2,b)*dem(3) + nx(2,a)*nx(1,b)*dem(3) )\n\n!           material stiffness\n            btdb = bm(1,1,a)*dbm(1,1,b) + bm(2,1,a)*dbm(2,1,b) +\n     2             bm(3,1,a)*dbm(3,1,b)\n            lk(1,a,b) = lk(1,a,b) + afl*t1*(btdb + nxsnx)\n\n            btdb = bm(1,1,a)*dbm(1,2,b) + bm(2,1,a)*dbm(2,2,b) +\n     2             bm(3,1,a)*dbm(3,2,b)\n            lk(2,a,b) = lk(2,a,b) + afl*t1*btdb\n\n            btdb = bm(1,1,a)*dbm(1,3,b) + bm(2,1,a)*dbm(2,3,b) +\n     2             bm(3,1,a)*dbm(3,3,b)\n            lk(3,a,b) = lk(3,a,b) + afl*t1*btdb\n\n            btdb = bm(1,2,a)*dbm(1,1,b) + bm(2,2,a)*dbm(2,1,b) +\n     2             bm(3,2,a)*dbm(3,1,b)\n            lk(dof+1,a,b) = lk(dof+1,a,b) + afl*t1*btdb\n\n            btdb = bm(1,2,a)*dbm(1,2,b) + bm(2,2,a)*dbm(2,2,b) +\n     2             bm(3,2,a)*dbm(3,2,b)\n            lk(dof+2,a,b) = lk(dof+2,a,b) + afl*t1*(btdb + nxsnx)\n\n            btdb = bm(1,2,a)*dbm(1,3,b) + bm(2,2,a)*dbm(2,3,b) +\n     2             bm(3,2,a)*dbm(3,3,b)\n            lk(dof+3,a,b) = lk(dof+3,a,b) + afl*t1*btdb\n\n            btdb = bm(1,3,a)*dbm(1,1,b) + bm(2,3,a)*dbm(2,1,b) +\n     2             bm(3,3,a)*dbm(3,1,b)\n            lk(2*dof+1,a,b) = lk(2*dof+1,a,b) + afl*t1*btdb\n\n            btdb = bm(1,3,a)*dbm(1,2,b) + bm(2,3,a)*dbm(2,2,b) +\n     2             bm(3,3,a)*dbm(3,2,b)\n            lk(2*dof+2,a,b) = lk(2*dof+2,a,b) + afl*t1*btdb\n\n            btdb = bm(1,3,a)*dbm(1,3,b) + bm(2,3,a)*dbm(2,3,b) +\n     2             bm(3,3,a)*dbm(3,3,b)\n            lk(2*dof+3,a,b) = lk(2*dof+3,a,b) + afl*t1*(btdb + nxsnx)\n         end do\n      end do\n\n!     contribution from bending strain related terms for the main\n!     triangle and its neighbors. geometric stiffness is ignored\n      t1 = jac0 * ht**3 /24d0\n      do a=1, enon\n         btde = bb(1,1,a)*deb(1) + bb(2,1,a)*deb(2) + bb(3,1,a)*deb(3)\n         lr(1,a) = lr(1,a) + t1*btde\n\n         btde = bb(1,2,a)*deb(1) + bb(2,2,a)*deb(2) + bb(3,2,a)*deb(3)\n         lr(2,a) = lr(2,a) + t1*btde\n\n         btde = bb(1,3,a)*deb(1) + bb(2,3,a)*deb(2) + bb(3,3,a)*deb(3)\n         lr(3,a) = lr(3,a) + t1*btde\n\n         do b=1, enon\n            btdb = bb(1,1,a)*dbb(1,1,b) + bb(2,1,a)*dbb(2,1,b) +\n     2             bb(3,1,a)*dbb(3,1,b)\n            lk(1,a,b) = lk(1,a,b) + afl*t1*btdb\n\n            btdb = bb(1,1,a)*dbb(1,2,b) + bb(2,1,a)*dbb(2,2,b) +\n     2             bb(3,1,a)*dbb(3,2,b)\n            lk(2,a,b) = lk(2,a,b) + afl*t1*btdb\n\n            btdb = bb(1,1,a)*dbb(1,3,b) + bb(2,1,a)*dbb(2,3,b) +\n     2             bb(3,1,a)*dbb(3,3,b)\n            lk(3,a,b) = lk(3,a,b) + afl*t1*btdb\n\n            btdb = bb(1,2,a)*dbb(1,1,b) + bb(2,2,a)*dbb(2,1,b) +\n     2             bb(3,2,a)*dbb(3,1,b)\n            lk(dof+1,a,b) = lk(dof+1,a,b) + afl*t1*btdb\n\n            btdb = bb(1,2,a)*dbb(1,2,b) + bb(2,2,a)*dbb(2,2,b) +\n     2             bb(3,2,a)*dbb(3,2,b)\n            lk(dof+2,a,b) = lk(dof+2,a,b) + afl*t1*btdb\n\n            btdb = bb(1,2,a)*dbb(1,3,b) + bb(2,2,a)*dbb(2,3,b) +\n     2             bb(3,2,a)*dbb(3,3,b)\n            lk(dof+3,a,b) = lk(dof+3,a,b) + afl*t1*btdb\n\n            btdb = bb(1,3,a)*dbb(1,1,b) + bb(2,3,a)*dbb(2,1,b) +\n     2             bb(3,3,a)*dbb(3,1,b)\n            lk(2*dof+1,a,b) = lk(2*dof+1,a,b) + afl*t1*btdb\n\n            btdb = bb(1,3,a)*dbb(1,2,b) + bb(2,3,a)*dbb(2,2,b) +\n     2             bb(3,3,a)*dbb(3,2,b)\n            lk(2*dof+2,a,b) = lk(2*dof+2,a,b) + afl*t1*btdb\n\n            btdb = bb(1,3,a)*dbb(1,3,b) + bb(2,3,a)*dbb(2,3,b) +\n     2             bb(3,3,a)*dbb(3,3,b)\n            lk(2*dof+3,a,b) = lk(2*dof+3,a,b) + afl*t1*btdb\n         end do\n      end do\n\n!     global assembly\n#ifdef with_trilinos\n      if (eq(ceq)%assmtls) then\n         call trilinos_doassem(enon, ptr, lk, lr)\n      else\n#endif\n         call doassem(enon, ptr, lk, lr)\n#ifdef with_trilinos\n      end if\n#endif\n\n      deallocate(n, nx, lr, lk)\n\n      return\n      end subroutine shelltri\n"}
{"id": 361, "subroutine": "      subroutine shellbendtri(lm, e, ptr, x0, xc, eb, bb)\n\n      use commod\n      use allfun\n\n      implicit none\n\n      type(mshtype), intent(in) :: lm\n      integer, intent(in) :: e, ptr(6)\n      real(kind=8), intent(inout) ::  x0(3,6), xc(3,6), eb(3), bb(3,3,6)\n\n      logical :: bflag, lfix(3)\n      integer :: i, j, p, f, enon\n\n      real(kind=8) :: jac0, jac, ci, aii, nv0(3), nv(3), ei(3), ni(3),\n     2   eiei(3,3), nini(3,3), eiap(3,3), im(3,3), gcov(3,2), gcnv(3,2),\n     3   gcov0(3,2), gcnv0(3,2)\n\n      real(kind=8) :: a0(3,6), a(3,6), adg0(3,3), adg(3,3), xi0(3,3),\n     2   xi(3,3), tm0(3,3), tm(3,3), v0(3), v(3), b1b(3,6), nm(3,3),\n     2   mm(3,3,2), h1(6,18), h2(18,18), h3(3,18), h1h2(6,18),\n     3   h3h2(3,18), bb1(3,18), tmpa(3,3)\n\n      enon = 2*lm%enon\n!     boundary element check\n      bflag = .false.\n      do j=lm%enon+1, enon\n         if (ptr(j) .eq. 0) then\n            bflag = .true.\n            exit\n         end if\n      end do\n\n!     edge vectors of the main element (reference config)\n      a0(:,1) = x0(:,3) - x0(:,2)\n      a0(:,2) = x0(:,1) - x0(:,3)\n      a0(:,3) = x0(:,2) - x0(:,1)\n\n!     edge vectors of the main element (current config)\n      a(:,1)  = xc(:,3) - xc(:,2)\n      a(:,2)  = xc(:,1) - xc(:,3)\n      a(:,3)  = xc(:,2) - xc(:,1)\n\n!     covariant and contravariant bases in reference config\n      tmpa = x0(:,1:lm%enon)\n      call gnns(lm%enon, lm%nx(:,:,1), tmpa, nv0, gcov0, gcnv0)\n      jac0 = sqrt(norm(nv0))\n      nv0  = nv0/jac0\n\n!     covariant and contravariant bases in current config\n      tmpa = xc(:,1:lm%enon)\n      call gnns(lm%enon, lm%nx(:,:,1), tmpa, nv, gcov, gcnv)\n      jac = sqrt(norm(nv))\n      nv  = nv/jac\n\n!     update position vector of surrounding nodes, if boundary elements\n      if (bflag) then\n         do j=lm%enon+1, enon\n            if (ptr(j) .ne. 0) cycle\n            i = j - lm%enon\n            p = i - 1\n            if (i .eq. 1) p = 3\n!           reference config\n!           ei = ei0 = ai0/|ai0| (reference config)\n            aii   = 1d0/sqrt(norm(a0(:,i)))\n            ei(:) = a0(:,i) * aii\n!           ni = ni0 = ei0 x n0 (reference config)\n            ni(1) = ei(2)*nv0(3) - ei(3)*nv0(2)\n            ni(2) = ei(3)*nv0(1) - ei(1)*nv0(3)\n            ni(3) = ei(1)*nv0(2) - ei(2)*nv0(1)\n!           xj = xi + 2(ni \\ctimes ni)ap\n            nini    = mat_dyadprod(ni, ni, 3)\n            x0(1,j) = 2d0*(nini(1,1)*a0(1,p) + nini(1,2)*a0(2,p) +\n     2         nini(1,3)*a0(3,p)) + x0(1,i)\n            x0(2,j) = 2d0*(nini(2,1)*a0(1,p) + nini(2,2)*a0(2,p) +\n     2         nini(2,3)*a0(3,p)) + x0(2,i)\n            x0(3,j) = 2d0*(nini(3,1)*a0(1,p) + nini(3,2)*a0(2,p) +\n     2         nini(3,3)*a0(3,p)) + x0(3,i)\n\n!           current config\n!           ei = ai/|ai| (current config)\n            aii   = 1d0/sqrt(norm(a(:,i)))\n            ei(:) = a(:,i)*aii\n!           ni = ei x n (currnt config)\n            ni(1) = ei(2)*nv(3) - ei(3)*nv(2)\n            ni(2) = ei(3)*nv(1) - ei(1)*nv(3)\n            ni(3) = ei(1)*nv(2) - ei(2)*nv(1)\n!           xj = xi + 2(ni \\ctimes ni)ap\n            nini    = mat_dyadprod(ni, ni, 3)\n            xc(1,j) = 2d0*(nini(1,1)*a(1,p) + nini(1,2)*a(2,p) +\n     2         nini(1,3)*a(3,p)) + xc(1,i)\n            xc(2,j) = 2d0*(nini(2,1)*a(1,p) + nini(2,2)*a(2,p) +\n     2         nini(2,3)*a(3,p)) + xc(2,i)\n            xc(3,j) = 2d0*(nini(3,1)*a(1,p) + nini(3,2)*a(2,p) +\n     2         nini(3,3)*a(3,p)) + xc(3,i)\n\n            if (btest(lm%sbc(i,e),btype_fix)) xc(:,j) = x0(:,j)\n         end do\n      end if\n\n!     edge vector of surrounding nodes (reference config)\n      a0(:,4)   = x0(:,4) - x0(:,2)\n      a0(:,5)   = x0(:,5) - x0(:,3)\n      a0(:,6)   = x0(:,6) - x0(:,1)\n\n!     edge vector of surrounding nodes (current config)\n      a(:,4)    = xc(:,4) - xc(:,2)\n      a(:,5)    = xc(:,5) - xc(:,3)\n      a(:,6)    = xc(:,6) - xc(:,1)\n\n!     a.gcnv (reference config)\n      adg0(1,1) = norm(a0(:,4), gcnv0(:,1)) ! xi_4\n      adg0(1,2) = norm(a0(:,5), gcnv0(:,1)) ! xi_5\n      adg0(1,3) = norm(a0(:,6), gcnv0(:,1)) ! xi_6\n\n      adg0(2,1) = norm(a0(:,4), gcnv0(:,2)) ! eta_4\n      adg0(2,2) = norm(a0(:,5), gcnv0(:,2)) ! eta_5\n      adg0(2,3) = norm(a0(:,6), gcnv0(:,2)) ! eta_6\n\n      adg0(3,1) = norm(a0(:,4), nv0)        ! z_4\n      adg0(3,2) = norm(a0(:,5), nv0)        ! z_5\n      adg0(3,3) = norm(a0(:,6), nv0)        ! z_6\n\n!     a.gcnv (current config)\n      adg(1,1)  = norm(a(:,4), gcnv(:,1)) ! xi_4\n      adg(1,2)  = norm(a(:,5), gcnv(:,1)) ! xi_5\n      adg(1,3)  = norm(a(:,6), gcnv(:,1)) ! xi_6\n\n      adg(2,1)  = norm(a(:,4), gcnv(:,2)) ! eta_4\n      adg(2,2)  = norm(a(:,5), gcnv(:,2)) ! eta_5\n      adg(2,3)  = norm(a(:,6), gcnv(:,2)) ! eta_6\n\n      adg(3,1)  = norm(a(:,4), nv)        ! z_4\n      adg(3,2)  = norm(a(:,5), nv)        ! z_5\n      adg(3,3)  = norm(a(:,6), nv)        ! z_6\n\n!     xi matrix (reference config)\n      xi0(:,:)  = adg0(:,:)\n      xi0(1,1)  = adg0(1,1) + 1d0\n      xi0(2,2)  = adg0(2,2) + 1d0\n\n!     xi matrix (current config)\n      xi(:,:)   = adg(:,:)\n      xi(1,1)   = adg(1,1) + 1d0\n      xi(2,2)   = adg(2,2) + 1d0\n\n!     tmat and inverse (reference config)\n      do i=1, 3\n         tm0(i,1) = xi0(1,i)**2 - xi0(1,i) ! xi**2 - xi\n         tm0(i,2) = xi0(2,i)**2 - xi0(2,i) ! eta**2 - eta\n         tm0(i,3) = xi0(1,i)*xi0(2,i)      ! xi * eta\n      end do\n      tm0 = mat_inv(tm0, 3)\n\n!     tmat and inverse (current config)\n      do i=1, 3\n         tm(i,1) = xi(1,i)**2 - xi(1,i) ! xi**2 - xi\n         tm(i,2) = xi(2,i)**2 - xi(2,i) ! eta**2 - eta\n         tm(i,3) = xi(1,i)*xi(2,i)      ! xi * eta\n      end do\n      tm = mat_inv(tm, 3)\n\n!     v = inv(t) * z (reference config)\n      v0(1) = tm0(1,1)*xi0(3,1) + tm0(1,2)*xi0(3,2) + tm0(1,3)*xi0(3,3)\n      v0(2) = tm0(2,1)*xi0(3,1) + tm0(2,2)*xi0(3,2) + tm0(2,3)*xi0(3,3)\n      v0(3) = tm0(3,1)*xi0(3,1) + tm0(3,2)*xi0(3,2) + tm0(3,3)*xi0(3,3)\n\n!     v = inv(t) * z (current config)\n      v(1) = tm(1,1)*xi(3,1) + tm(1,2)*xi(3,2) + tm(1,3)*xi(3,3)\n      v(2) = tm(2,1)*xi(3,1) + tm(2,2)*xi(3,2) + tm(2,3)*xi(3,3)\n      v(3) = tm(3,1)*xi(3,1) + tm(3,2)*xi(3,2) + tm(3,3)*xi(3,3)\n\n!     bending strain, eb = 2*(v0-v) = 2*(tinv0*z0 - tinv*z)\n      eb(:) = 2d0 * (v0(:) - v(:))\n\n!     now compute variation in bending strain\n!     b1 bar\n      b1b(:,1) = -tm(:,1) * ((2d0*xi(1,1)-1d0)*v(1) + xi(2,1)*v(3))\n      b1b(:,2) = -tm(:,1) * ((2d0*xi(2,1)-1d0)*v(2) + xi(1,1)*v(3))\n\n      b1b(:,3) = -tm(:,2) * ((2d0*xi(1,2)-1d0)*v(1) + xi(2,2)*v(3))\n      b1b(:,4) = -tm(:,2) * ((2d0*xi(2,2)-1d0)*v(2) + xi(1,2)*v(3))\n\n      b1b(:,5) = -tm(:,3) * ((2d0*xi(1,3)-1d0)*v(1) + xi(2,3)*v(3))\n      b1b(:,6) = -tm(:,3) * ((2d0*xi(2,3)-1d0)*v(2) + xi(1,3)*v(3))\n\n!     h1\n      h1 = 0d0\n      h1(1, 4: 6) =  gcnv(:,1)*adg(2,1)\n      h1(2, 4: 6) =  gcnv(:,2)*adg(2,1)\n      h1(3, 4: 6) =  gcnv(:,1)*adg(2,2)\n      h1(4, 4: 6) =  gcnv(:,2)*adg(2,2)\n      h1(5, 4: 6) =  gcnv(:,1)*adg(2,3)\n      h1(6, 4: 6) =  gcnv(:,2)*adg(2,3)\n\n      h1(1, 7: 9) = -gcnv(:,1)*adg(1,1)\n      h1(2, 7: 9) = -gcnv(:,2)*adg(1,1)\n      h1(3, 7: 9) = -gcnv(:,1)*adg(1,2)\n      h1(4, 7: 9) = -gcnv(:,2)*adg(1,2)\n      h1(5, 7: 9) = -gcnv(:,1)*adg(1,3)\n      h1(6, 7: 9) = -gcnv(:,2)*adg(1,3)\n\n      h1(1,10:12) =  gcnv(:,1)\n      h1(2,10:12) =  gcnv(:,2)\n      h1(3,13:15) =  gcnv(:,1)\n      h1(4,13:15) =  gcnv(:,2)\n      h1(5,16:18) =  gcnv(:,1)\n      h1(6,16:18) =  gcnv(:,2)\n\n!     h2\n      h2 = 0d0\n      h2( 1, 4) = -1d0\n      h2( 2, 5) = -1d0\n      h2( 3, 6) = -1d0\n      h2( 4, 7) = -1d0\n      h2( 5, 8) = -1d0\n      h2( 6, 9) = -1d0\n      h2( 7, 1) = -1d0\n      h2( 8, 2) = -1d0\n      h2( 9, 3) = -1d0\n\n      h2( 1, 7) =  1d0\n      h2( 2, 8) =  1d0\n      h2( 3, 9) =  1d0\n      h2( 4, 1) =  1d0\n      h2( 5, 2) =  1d0\n      h2( 6, 3) =  1d0\n      h2( 7, 4) =  1d0\n      h2( 8, 5) =  1d0\n      h2( 9, 6) =  1d0\n\n      h2(10, 4) = -1d0\n      h2(11, 5) = -1d0\n      h2(12, 6) = -1d0\n      h2(13, 7) = -1d0\n      h2(14, 8) = -1d0\n      h2(15, 9) = -1d0\n      h2(16, 1) = -1d0\n      h2(17, 2) = -1d0\n      h2(18, 3) = -1d0\n      do i=10, 18\n         h2(i,i) = 1d0\n      end do\n\n!     n matrix\n      nm = mat_id(3) - mat_dyadprod(nv, nv, 3)\n!     m1, m2 matrices\n      mm(:,:,:) = 0d0\n      do i=1, 2\n         mm(1,2,i) = -gcov(3,i)\n         mm(1,3,i) =  gcov(2,i)\n         mm(2,3,i) = -gcov(1,i)\n\n!        skew-symmetric\n         mm(2,1,i) = -mm(1,2,i)\n         mm(3,1,i) = -mm(1,3,i)\n         mm(3,2,i) = -mm(2,3,i)\n      end do\n\n!     h3 matrix\n      h3 = 0d0\n      tmpa = matmul(nm, mm(:,:,1))\n      tmpa = -tmpa / jac\n      h3(1,4) = a(1,4)*tmpa(1,1) + a(2,4)*tmpa(2,1) + a(3,4)*tmpa(3,1)\n      h3(1,5) = a(1,4)*tmpa(1,2) + a(2,4)*tmpa(2,2) + a(3,4)*tmpa(3,2)\n      h3(1,6) = a(1,4)*tmpa(1,3) + a(2,4)*tmpa(2,3) + a(3,4)*tmpa(3,3)\n\n      h3(2,4) = a(1,5)*tmpa(1,1) + a(2,5)*tmpa(2,1) + a(3,5)*tmpa(3,1)\n      h3(2,5) = a(1,5)*tmpa(1,2) + a(2,5)*tmpa(2,2) + a(3,5)*tmpa(3,2)\n      h3(2,6) = a(1,5)*tmpa(1,3) + a(2,5)*tmpa(2,3) + a(3,5)*tmpa(3,3)\n\n      h3(3,4) = a(1,6)*tmpa(1,1) + a(2,6)*tmpa(2,1) + a(3,6)*tmpa(3,1)\n      h3(3,5) = a(1,6)*tmpa(1,2) + a(2,6)*tmpa(2,2) + a(3,6)*tmpa(3,2)\n      h3(3,6) = a(1,6)*tmpa(1,3) + a(2,6)*tmpa(2,3) + a(3,6)*tmpa(3,3)\n\n      tmpa = matmul(nm, mm(:,:,2))\n      tmpa = -tmpa / jac\n      h3(1,7) = a(1,4)*tmpa(1,1) + a(2,4)*tmpa(2,1) + a(3,4)*tmpa(3,1)\n      h3(1,8) = a(1,4)*tmpa(1,2) + a(2,4)*tmpa(2,2) + a(3,4)*tmpa(3,2)\n      h3(1,9) = a(1,4)*tmpa(1,3) + a(2,4)*tmpa(2,3) + a(3,4)*tmpa(3,3)\n\n      h3(2,7) = a(1,5)*tmpa(1,1) + a(2,5)*tmpa(2,1) + a(3,5)*tmpa(3,1)\n      h3(2,8) = a(1,5)*tmpa(1,2) + a(2,5)*tmpa(2,2) + a(3,5)*tmpa(3,2)\n      h3(2,9) = a(1,5)*tmpa(1,3) + a(2,5)*tmpa(2,3) + a(3,5)*tmpa(3,3)\n\n      h3(3,7) = a(1,6)*tmpa(1,1) + a(2,6)*tmpa(2,1) + a(3,6)*tmpa(3,1)\n      h3(3,8) = a(1,6)*tmpa(1,2) + a(2,6)*tmpa(2,2) + a(3,6)*tmpa(3,2)\n      h3(3,9) = a(1,6)*tmpa(1,3) + a(2,6)*tmpa(2,3) + a(3,6)*tmpa(3,3)\n\n      h3(1,10:12) = nv(:)\n      h3(2,13:15) = nv(:)\n      h3(3,16:18) = nv(:)\n\n!     variation in bending strain (bb = -2*(b1b*h1*h2 + tinv*h3*h2))\n      h1h2 = matmul(h1, h2)\n      bb1  = matmul(b1b, h1h2)\n      h3h2 = matmul(h3, h2)\n      bb1  = -2d0*(bb1 + matmul(tm, h3h2))\n\n      bb   = reshape(bb1, shape(bb))\n\n!     update bb for boundary elements\n      if (bflag) then\n         lfix = .false.\n         im   = mat_id(3)\n         do j=lm%enon+1, enon\n            if (ptr(j) .ne. 0) cycle\n            i = j - lm%enon\n            p = i - 1\n            f = i + 1\n            if (i .eq. 1) p = 3\n            if (i .eq. 3) f = 1\n            if (btest(lm%sbc(i,e),btype_fix)) then\n!              ei = ei0 = ai0/|ai0| (reference config)\n               aii   = 1d0/sqrt(norm(a0(:,i)))\n               ei(:) = a0(:,i) * aii\n!              ni = ni0 = ei0 x n0 (reference config)\n               ni(1) = ei(2)*nv0(3) - ei(3)*nv0(2)\n               ni(2) = ei(3)*nv0(1) - ei(1)*nv0(3)\n               ni(3) = ei(1)*nv0(2) - ei(2)*nv0(1)\n               nini  = mat_dyadprod(ni, ni, 3)\n            else\n!              ei = ai/|ai| (current config)\n               aii   = 1d0/sqrt(norm(a(:,i)))\n               ei(:) = a(:,i)*aii\n!              ni = ei x n (currnt config)\n               ni(1) = ei(2)*nv(3) - ei(3)*nv(2)\n               ni(2) = ei(3)*nv(1) - ei(1)*nv(3)\n               ni(3) = ei(1)*nv(2) - ei(2)*nv(1)\n               ci    = norm(a(:,i),a(:,p))*aii*aii\n               nini  = mat_dyadprod(ni, ni, 3)\n               eiei  = mat_dyadprod(ei, ei, 3)\n               eiap  = mat_dyadprod(ei, a(:,p), 3)\n            end if\n\n!           update bb now\n            if (btest(lm%sbc(i,e),btype_free)) then\n!              e_i\n               if (.not.lfix(i)) then\n                  tmpa = -im + 2d0*eiei\n                  bb(:,:,i) = bb(:,:,i) + matmul(bb(:,:,j), tmpa)\n               end if\n!              e_p\n               if (.not.lfix(p)) then\n                  tmpa = -2d0*(ci*im - 2d0*ci*eiei + aii*eiap)\n                  bb(:,:,p) = bb(:,:,p) + matmul(bb(:,:,j), tmpa)\n               end if\n!              e_f\n               if (.not.lfix(f)) then\n                  tmpa = 2d0*((1d0-ci)*im - (1d0-2d0*ci)*eiei -aii*eiap)\n                  bb(:,:,f) = bb(:,:,f) + matmul(bb(:,:,j), tmpa)\n               end if\n               bb(:,:,j) = 0d0\n            else if (btest(lm%sbc(i,e),btype_hing)) then\n!              e_i\n               if (.not.lfix(i)) then\n                  tmpa = -im + 2d0*eiei\n                  bb(:,:,i) = bb(:,:,i) + matmul(bb(:,:,j), tmpa)\n               end if\n               lfix(p)   = .true.\n               lfix(f)   = .true.\n               bb(:,:,p) = 0d0\n               bb(:,:,f) = 0d0\n               bb(:,:,j) = 0d0\n            else if (btest(lm%sbc(i,e),btype_fix)) then\n               if (.not.lfix(i)) then\n                  tmpa = im - 2d0*nini\n                  bb(:,:,i) = bb(:,:,i) + matmul(bb(:,:,j), tmpa)\n               end if\n               lfix(p)   = .true.\n               lfix(f)   = .true.\n               bb(:,:,f) = 0d0\n               bb(:,:,p) = 0d0\n            else if (btest(lm%sbc(i,e),btype_symm)) then\n               if (.not.lfix(i)) then\n                  tmpa = im - 2d0*nini\n                  bb(:,:,i) = bb(:,:,i) + matmul(bb(:,:,j), tmpa)\n               end if\n               bb(:,:,j) = 0d0\n               tmpa(:,1) = ei(:)\n               tmpa(:,2) = nv(:)\n               tmpa(:,3) = ni(:)\n               bb(:,:,f) = matmul(bb(:,:,f), tmpa)\n               bb(:,3,f) = 0d0\n               bb(:,:,p) = matmul(bb(:,:,p), tmpa)\n               bb(:,3,p) = 0d0\n            end if\n         end do\n      end if\n\n      return\n      end subroutine shellbendtri\n"}
{"id": 362, "subroutine": "      subroutine shellfp (enon, w, n, nx, dl, xl, tfl, lr, lk)\n      use commod\n      use allfun\n      implicit none\n\n      integer, intent(in) :: enon\n      real(kind=8), intent(in) :: w, n(enon), nx(2,enon), dl(tdof,enon),\n     2   xl(3,enon), tfl(enon)\n      real(kind=8), intent(inout) :: lr(dof,enon), lk(dof*dof,enon,enon)\n\n      integer :: i, j, k, a, b\n      real(kind=8) :: t1, afl, wl, tfn, nv(3), gcov(3,2), gcnv(3,2),\n     2   xc(3,enon), lkp(3)\n\n      afl  = eq(ceq)%af*eq(ceq)%beta*dt*dt\n      i    = eq(ceq)%s\n      j    = i + 1\n      k    = j + 1\n\n!     get the current configuration and traction vector\n      tfn = 0d0\n      do a=1, enon\n         xc(1,a) = xl(1,a) + dl(i,a)\n         xc(2,a) = xl(2,a) + dl(j,a)\n         xc(3,a) = xl(3,a) + dl(k,a)\n\n         tfn = tfn + n(a)*tfl(a)\n      end do\n      wl = w * tfn\n\n!     covariant and contravariant bases in current config\n      call gnns(enon, nx, xc, nv, gcov, gcnv)\n\n!     local residue\n      do a=1, enon\n         lr(1,a) = lr(1,a) - wl*n(a)*nv(1)\n         lr(2,a) = lr(2,a) - wl*n(a)*nv(2)\n         lr(3,a) = lr(3,a) - wl*n(a)*nv(3)\n      end do\n\n!     local stiffness: mass matrix and stiffness contribution due to\n!     follower traction load\n      t1 = afl*wl*5d-1\n      do b=1, enon\n         do a=1, enon\n            lkp(:) = gcov(:,1)*(n(b)*nx(2,a) - n(a)*nx(2,b))\n     2             - gcov(:,2)*(n(b)*nx(1,a) - n(a)*nx(1,b))\n\n            lk(2,a,b) = lk(2,a,b) - t1*lkp(3)\n            lk(3,a,b) = lk(3,a,b) + t1*lkp(2)\n\n            lk(dof+1,a,b) = lk(dof+1,a,b) + t1*lkp(3)\n            lk(dof+3,a,b) = lk(dof+3,a,b) - t1*lkp(1)\n\n            lk(2*dof+1,a,b) = lk(2*dof+1,a,b) - t1*lkp(2)\n            lk(2*dof+2,a,b) = lk(2*dof+2,a,b) + t1*lkp(1)\n         end do\n      end do\n\n      return\n      end subroutine shellfp\n"}
{"id": 363, "subroutine": "subroutine shexpanddh(grid, py_m, py_n, lmax_calc, py_lmax, cilm, lmax, norm, sampling, csphase)\n\t!                 in     in    in   in    in        in      out   out   in    in         in\n\tuse fftw3\n\tuse shtools, only: dhaj\n\t\t\n\timplicit none\n\t\n\tinteger, intent(in)  ::\tpy_m, py_n, py_lmax, lmax_calc\n\treal*8, intent(in)   ::\tgrid(py_m, py_n)\n\treal*8, intent(out)  ::\tcilm(2, py_lmax+1, py_lmax+1)\n\tinteger, intent(out) ::\tlmax\n\tinteger, intent(in), optional :: norm, sampling, csphase\n\t\n\tcomplex*16           ::\tcc(py_m+1)\n\tinteger              ::\tl, m, n, i, l1, m1, i_eq, i_s, astat(4), lmax_comp, nlong\n\tinteger*8            ::\tplan\n\treal*8               ::\tpi, gridl(2*py_m), aj(py_m), fcoef1(2, py_m/2+1), fcoef2(2, py_m/2+1)\n\treal*8               ::\ttheta, prod, scalef, rescalem, u, p, pmm, pm1, pm2, z, ffc(1:2,-1:1)\n\t\n\treal*8,    save, allocatable ::\tsqr(:), ff1(:,:), ff2(:,:)\n\tinteger*1, save, allocatable ::\tfsymsign(:,:)\n\tinteger, save                ::\tlmax_old=0, norm_old = 0\n\t\n\t\n\tn     = py_m\n\tlmax  = py_m/2 - 1\n\tnlong = py_n\n\t\n\tlmax_comp = min(lmax, lmax_calc)\n\t\t\n\tpi = acos(-1.0d0)\n\t\n\tcilm = 0.0d0\n\t\n\tscalef = 1.0d-280\n\t\n\tcall dhaj(n, aj)\n\taj(1:n) = aj(1:n)*sqrt(4.0d0*pi) \t! driscoll and heally use unity normalized spherical harmonics\n\t\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t!\n\t!\tcalculate recursion constants used in computing the legendre polynomials\n\t!\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\tif (lmax_comp /= lmax_old .or. norm /= norm_old) then\n\n\t\tif (allocated(sqr)) deallocate(sqr)\n\t\tif (allocated(ff1)) deallocate(ff1)\n\t\tif (allocated(ff2)) deallocate(ff2)\n\t\tif (allocated(fsymsign)) deallocate(fsymsign)\n\t\t\n\t\tallocate(sqr(2*lmax_comp+1), stat=astat(1))\n\t\tallocate(ff1(lmax_comp+1,lmax_comp+1), stat=astat(2))\n\t\tallocate(ff2(lmax_comp+1,lmax_comp+1), stat=astat(3))\n\t\tallocate(fsymsign(lmax_comp+1,lmax_comp+1), stat=astat(4))\n\t\t\n\t\tif (sum(astat(1:4)) /= 0) then\n\t\t\tprint*, \"error --- shexpanddh\"\n\t\t\tprint*, \"problem allocating arrays sqr, ff1, ff2, or fsymsign\", &\n\t\t\t\tastat(1), astat(2), astat(3), astat(4)\n\t\t\tstop\n\t\tendif\n\t\t\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t!\n\t\t! \tcalculate signs used for symmetry of legendre functions about equator\n\t\t!\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\n\t\tdo l = 0, lmax_comp, 1\n\t\t\tdo m = 0, l, 1\n\t\t\t\tif (mod(l-m,2) == 0) then\n\t\t\t\t\tfsymsign(l+1,m+1) = 1\n\t\t\t\telse\n\t\t\t\t\tfsymsign(l+1,m+1) = -1\n\t\t\t\tendif\n\t\t\tenddo\n\t\tenddo\n\t\t\t\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t!\n\t\t!\tprecompute square roots of integers that are used several times.\n\t\t!\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\t\tdo l=1, 2*lmax_comp+1\n\t\t\tsqr(l) = sqrt(dble(l))\n\t\tenddo\n\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t!\n\t\t! \tprecompute multiplicative factors used in recursion relationships\n\t\t! \t\tp(l,m) = x*f1(l,m)*p(l-1,m) - p(l-2,m)*f2(l,m)\n\t\t!\t\tk = l*(l+1)/2 + m + 1\n\t\t!\tnote that prefactors are not used for the case when m=l as a different \n\t\t!\trecursion is used. furthermore, for m=l-1, plmbar(l-2,m) is assumed to be zero.\n\t\t!\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\n\t\tselect case(norm)\n\t\t\n\t\t\tcase(1,4)\n\t\n\t\t\t\tif (lmax_comp /= 0) then\n\t\t\t\t\tff1(2,1) = sqr(3)\n\t\t\t\t\tff2(2,1) = 0.0d0\n\t\t\t\tendif\n\t\t\t\t\n\t\t\t\tdo l=2, lmax_comp, 1\n\t\t\t\t\tff1(l+1,1) = sqr(2*l-1) * sqr(2*l+1) / dble(l)\n\t\t\t\t\tff2(l+1,1) = dble(l-1) * sqr(2*l+1) / sqr(2*l-3) / dble(l)\n\t\t\t\t\tdo m=1, l-2, 1\n\t\t\t\t\t\tff1(l+1,m+1) = sqr(2*l+1) * sqr(2*l-1) / sqr(l+m) / sqr(l-m)\n                \t\t\t\tff2(l+1,m+1) = sqr(2*l+1) * sqr(l-m-1) * sqr(l+m-1) &\n                  \t\t\t\t \t/ sqr(2*l-3) / sqr(l+m) / sqr(l-m) \n\t\t\t\t\tenddo\n\t\t\t\t\tff1(l+1,l) = sqr(2*l+1) * sqr(2*l-1) / sqr(l+m) / sqr(l-m)\n                \t\t\tff2(l+1,l) = 0.0d0\n\t\t\t\tenddo\n\t\t\t\n\t\t\tcase(2)\n\t\t\t\n\t\t\t\tif (lmax_comp /= 0) then\n\t\t\t\t\tff1(2,1) = 1.0d0\n\t\t\t\t\tff2(2,1) = 0.0d0\n\t\t\t\tendif\n\t\t\t\t\n\t\t\t\tdo l=2, lmax_comp, 1\n\t\t\t\t\tff1(l+1,1) = dble(2*l-1) /dble(l)\n\t\t\t\t\tff2(l+1,1) = dble(l-1) /dble(l)\n\t\t\t\t\tdo m=1, l-2, 1\n\t\t\t\t\t\tff1(l+1,m+1) = dble(2*l-1) / sqr(l+m) / sqr(l-m)\n                  \t\t\t\tff2(l+1,m+1) = sqr(l-m-1) * sqr(l+m-1) / sqr(l+m) / sqr(l-m)\n\t\t\t\t\tenddo\n\t\t\t\t\tff1(l+1,l)= dble(2*l-1) / sqr(l+m) / sqr(l-m)\n                  \t\t\tff2(l+1,l) = 0.0d0\n\t\t\t\tenddo\n\t\t\t\n\t\t\tcase(3)\n\t\t\n\t\t\t\tdo l=1, lmax_comp, 1\n\t\t\t\t\tff1(l+1,1) = dble(2*l-1) /dble(l)\n\t\t\t\t\tff2(l+1,1) = dble(l-1) /dble(l)\n\t\t\t\t\tdo m=1, l-1, 1\n\t\t\t\t\t\tff1(l+1,m+1) = dble(2*l-1) / dble(l-m)\n                  \t\t\t\tff2(l+1,m+1) = dble(l+m-1) / dble(l-m)\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\n\t\tend select\n\t\n\t\tlmax_old = lmax_comp\n\t\tnorm_old = norm\n\t\n\tendif\t\n\t\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t!\n\t! \tcreate generic plan for gridl\n\t!\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\tcall dfftw_plan_dft_r2c_1d(plan, nlong, gridl(1:nlong), cc, fftw_measure)\n\n\t\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t!\t\t\n\t! \tintegrate over all latitudes. take into account symmetry of the \n\t!\tplms about the equator.\n\t!\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\ti_eq = n/2 + 1\t! index correspondong to the equator\n\t\n\tdo i=2, i_eq - 1, 1\n\t\n\t\ttheta = (i-1) * pi / dble(n)\n\t\tz = cos(theta)\n\t\tu = sqrt( (1.0d0-z) * (1.0d0+z) )\n\t\t\n\t\tgridl(1:nlong) = grid(i,1:nlong)\n\t\tcall dfftw_execute(plan)\t! take fourier transform\n\t\tfcoef1(1,1:n/2) = sqrt(2*pi) * aj(i) * dble(cc(1:n/2)) / dble(nlong)\n\t\tfcoef1(2,1:n/2) = -sqrt(2*pi) * aj(i) * dimag(cc(1:n/2)) / dble(nlong)\n\t\t\n\t\ti_s = 2*i_eq -i\n\t\t\n\t\tgridl(1:nlong) = grid(i_s,1:nlong)\n\t\tcall dfftw_execute(plan)\t! take fourier transform\n\t\tfcoef2(1,1:n/2) = sqrt(2*pi) * aj(i_s) * dble(cc(1:n/2)) / dble(nlong)\n\t\tfcoef2(2,1:n/2) = -sqrt(2*pi) * aj(i_s) * dimag(cc(1:n/2)) / dble(nlong)\n\t\t\n\t\tselect case(norm)\n\t\t\tcase(1,2,3);\tpm2 = 1.0d0\n\t\t\tcase(4);\tpm2 = 1.0d0 / sqrt(4*pi)\n\t\tend select\n\n\t\tcilm(1,1,1) = cilm(1,1,1) + pm2 * (fcoef1(1,1) + fcoef2(1,1) )\n\t\t! fsymsign = 1\n\t\t\n\t\tif (lmax_comp == 0) cycle\n\t\t\t\t\n\t\tpm1 =  ff1(2,1) * z * pm2\n\t\tcilm(1,2,1) = cilm(1,2,1) + pm1 * ( fcoef1(1,1) - fcoef2(1,1) )\n\t\t! fsymsign = -1\n\t\t\n\t\tffc(1,-1) = fcoef1(1,1) - fcoef2(1,1)\n\t\tffc(1, 1) = fcoef1(1,1) + fcoef2(1,1)\n\t\tdo l=2, lmax_comp, 1\n\t\t\tl1 = l+1\n\t\t\tp = ff1(l1,1) * z * pm1 - ff2(l1,1) * pm2\n\t\t\tpm2 = pm1\n\t\t\tpm1 = p\n\t\t\tcilm(1,l1,1) = cilm(1,l1,1) + p * ffc(1,fsymsign(l1,1))\n\t\tenddo\n\t\t\t\t\n\t\tselect case(norm)\n\t\t\tcase(1,2);\tpmm = sqr(2) * scalef\n\t\t\tcase(3);\tpmm = scalef\n\t\t\tcase(4);\tpmm = sqr(2) * scalef / sqrt(4*pi)\n\t\tend select\n\t\t\t\t\n\t\trescalem = 1.0d0/scalef\n\t\n\t\tdo m = 1, lmax_comp-1, 1\n\t\t\t\t\n\t\t\tm1 = m+1\n\t\t\trescalem = rescalem * u\n\t\t\t\t\t\n\t\t\tselect case(norm)\n\t\t\t\tcase(1,4)\n\t\t\t\t\tpmm = csphase * pmm * sqr(2*m+1) / sqr(2*m)\n\t\t\t\t\tpm2 = pmm\n\t\t\t\tcase(2)\n\t\t\t\t\tpmm = csphase * pmm * sqr(2*m+1) / sqr(2*m)\n\t\t\t\t\tpm2 = pmm / sqr(2*m+1)\n\t\t\t\tcase(3)\n\t\t\t\t\tpmm = csphase * pmm * (2*m-1)\n\t\t\t\t\tpm2 = pmm\n\t\t\tend select\n\t\t\t\t\t\n\t\t\tfcoef1(1:2,m1) = fcoef1(1:2,m1) * rescalem\n\t\t\tfcoef2(1:2,m1) = fcoef2(1:2,m1) * rescalem\n\t\t\t\t\t\n\t\t\tcilm(1:2,m1,m1) = cilm(1:2,m1,m1) + pm2 * &\n\t\t\t\t\t( fcoef1(1:2,m1) + fcoef2(1:2,m1) )\n\t\t\t! fsymsign = 1\n\t\t\t\t\t\n\t   \t\tpm1 = z * ff1(m1+1,m1) * pm2\n\t   \t\t\t\n\t   \t\tcilm(1:2,m1+1,m1) = cilm(1:2,m1+1,m1) + pm1 * &\n               \t\t\t\t( fcoef1(1:2,m1) - fcoef2(1:2,m1) )\n               \t\t! fsymsign = -1\n\t\t\t\t\t\n\t\t\tffc(1:2,-1) = fcoef1(1:2,m1) - fcoef2(1:2,m1)\n\t\t\tffc(1:2, 1) = fcoef1(1:2,m1) + fcoef2(1:2,m1)\n\t\t\tdo l = m+2, lmax_comp, 1\n\t\t\t\tl1 = l+1\n                  \t\tp = z * ff1(l1,m1) * pm1-ff2(l1,m1) * pm2\n                  \t\tpm2 = pm1\n                  \t\tpm1 = p\n\t\t\t\tcilm(1:2,l1,m1) = cilm(1:2,l1,m1) + p * ffc(1:2,fsymsign(l1,m1))\n\t\t\tenddo\n               \t\t\t\t\n\t\tenddo\n\t\t\t\t\n\t\trescalem = rescalem * u\n\t\t\t\n            \tselect case(norm)\n            \t\tcase(1,4);\tpmm = csphase * pmm * sqr(2*lmax_comp+1) / sqr(2*lmax_comp) * rescalem\n            \t\tcase(2);\tpmm = csphase * pmm / sqr(2*lmax_comp) * rescalem\n            \t\tcase(3);\tpmm = csphase * pmm * (2*lmax_comp-1) * rescalem\n        \tend select\n        \t\t\t\n        \tcilm(1:2,lmax_comp+1,lmax_comp+1) = cilm(1:2,lmax_comp+1,lmax_comp+1) + pmm * &\n        \t\t\t\t( fcoef1(1:2,lmax_comp+1) + fcoef2(1:2,lmax_comp+1) )\t\n        \t\t\t\t! fsymsign = 1\n\tenddo\n\t\n\t! finally, do equator\n\t\n\ti = i_eq\n\t\n\tz = 0.0d0\n\tu = 1.0d0\n\t\n\tgridl(1:nlong) = grid(i,1:nlong)\n\tcall dfftw_execute(plan)\t! take fourier transform\n\tfcoef1(1,1:n/2) = sqrt(2*pi) * aj(i) * dble(cc(1:n/2)) / dble(nlong)\n\tfcoef1(2,1:n/2) = -sqrt(2*pi) * aj(i) * dimag(cc(1:n/2)) / dble(nlong)\n\n\n\tselect case(norm)\n\t\tcase(1,2,3);\tpm2 = 1.0d0\n\t\tcase(4);\tpm2 = 1.0d0 / sqrt(4*pi)\n\tend select\n\n\tcilm(1,1,1) = cilm(1,1,1) + pm2 * fcoef1(1,1)\n\t\n\tif (lmax_comp /= 0) then\n\t\t\t\t\n\t\tdo l=2, lmax_comp, 2\n\t\t\tl1 = l+1\n\t\t\tp = - ff2(l1,1) * pm2\n\t\t\tpm2 = p\n\t\t\tcilm(1,l1,1) = cilm(1,l1,1) + p * fcoef1(1,1)\n\t\tenddo\n\t\t\t\t\n\t\tselect case(norm)\n\t\t\tcase(1,2);\tpmm = sqr(2) * scalef\n\t\t\tcase(3);\tpmm = scalef\n\t\t\tcase(4);\tpmm = sqr(2) * scalef / sqrt(4*pi)\n\t\tend select\n\t\t\t\t\n\t\trescalem = 1.0d0/scalef\n\t\n\t\tdo m = 1, lmax_comp-1, 1\n\t\t\t\t\n\t\t\tm1 = m+1\n\t\t\t\t\t\n\t\t\tselect case(norm)\n\t\t\t\tcase(1,4)\n\t\t\t\t\tpmm = csphase * pmm * sqr(2*m+1) / sqr(2*m)\n\t\t\t\t\tpm2 = pmm\n\t\t\t\tcase(2)\n\t\t\t\t\tpmm = csphase * pmm * sqr(2*m+1) / sqr(2*m)\n\t\t\t\t\tpm2 = pmm / sqr(2*m+1)\n\t\t\t\tcase(3)\n\t\t\t\t\tpmm = csphase * pmm * (2*m-1)\n\t\t\t\t\tpm2 = pmm\n\t\t\tend select\n\n\t\t\tfcoef1(1:2,m1) = fcoef1(1:2,m1) * rescalem\n\t\t\t\t\t\n\t\t\tcilm(1:2,m1,m1) = cilm(1:2,m1,m1) + pm2 * fcoef1(1:2,m1)\n\t\t\t\t\t\t\t\t\n\t\t\tdo l = m+2, lmax_comp, 2\n\t\t\t\tl1 = l+1\n                \t  \tp = - ff2(l1,m1) * pm2\n                  \t\tpm2 = p\n\t\t\t\tcilm(1:2,l1,m1) = cilm(1:2,l1,m1) + p * fcoef1(1:2,m1) \n\t\t\tenddo\n\n\t\tenddo\t\t\n       \n       \t\tselect case(norm)\n            \t\tcase(1,4);\tpmm = csphase * pmm * sqr(2*lmax_comp+1) / sqr(2*lmax_comp) * rescalem\n            \t\tcase(2);\tpmm = csphase * pmm / sqr(2*lmax_comp) * rescalem\n            \t\tcase(3);\tpmm = csphase * pmm * (2*lmax_comp-1) * rescalem\n       \t\tend select\n       \t\t\t\n       \t\tcilm(1:2,lmax_comp+1,lmax_comp+1) = cilm(1:2,lmax_comp+1,lmax_comp+1) + pmm * fcoef1(1:2,lmax_comp+1) \n       \t\t\n       \tendif\n\n\tcall dfftw_destroy_plan(plan) \n\t\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t!\n\t! \tdivide by integral of ylm*ylm \n\t!\n\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\tselect case(norm)\n\t\n\t\tcase(1)\n\t\n\t\t\tdo l=0, lmax_comp, 1\n\t\t\t\tcilm(1:2,l+1, 1:l+1) = cilm(1:2,l+1, 1:l+1) / (4*pi)\n\t\t\tenddo\n\t\t\n\t\tcase(2)\n\t\n\t\t\tdo l=0, lmax_comp, 1\n\t\t\t\tcilm(1:2,l+1, 1:l+1) = cilm(1:2,l+1, 1:l+1) * (2*l+1) / (4*pi)\n\t\t\tenddo\n\t\n\t\tcase(3)\n\t\t \n\t\t\tdo l=0, lmax_comp, 1\n\t\t\t\tprod = 4 * pi / dble(2*l+1)\n\t\t\t\tcilm(1,l+1,1) = cilm(1,l+1,1) / prod\n\t\t\t\tprod = prod / 2.0d0\n\t\t\t\tdo m=1, l-1, 1\n\t\t\t\t\tprod = prod * (l+m) * (l-m+1)\n\t\t\t\t\tcilm(1:2,l+1,m+1) = cilm(1:2,l+1,m+1) / prod\n\t\t\t\tenddo\n\t\t\t\t!do m=l case\n\t\t\t\tif (l /= 0) cilm(1:2,l+1,l+1) = cilm(1:2,l+1, l+1)/(prod*2*l)\n\t\t\tenddo\n\t\t\t\n\tend select\n\t\t\nend subroutine shexpanddh\n"}
{"id": 364, "subroutine": "   subroutine v_mmp(atoms,jspins,spin_pol,ns_mmp,u,f0,f2, vs_mmp,e_ldau)\n\n      type(t_atoms),    intent(in)     :: atoms\n      integer,          intent(in)     :: jspins\n      real,             intent(in)     :: u(-lmaxu_const:,-lmaxu_const:,-lmaxu_const:,-lmaxu_const:,:)\n      real,             intent(in)     :: f0(:),f2(:)\n      complex,          intent(in)     :: ns_mmp(-lmaxu_const:,-lmaxu_const:,:,:)\n      logical,          intent(in)     :: spin_pol !is the double-counting spin-polarised (reason: for spin-polarized calculations\n                                                   !with dft+hubbard1 we use a non-spin polarized orbital in dft)\n      complex,          intent(out)    :: vs_mmp(-lmaxu_const:,-lmaxu_const:,:,:)\n      real,             intent(inout)  :: e_ldau\n\n      ! ..  local variables ..\n      integer :: ispin,jspin,l ,mp,p,q,itype,m,i_u\n      real    :: rho_tot,u_htr,j_htr,e_ee,ns_sum,spin_deg,e_dc,e_dcc\n      real    :: rho_sig(jspins),v_diag(jspins),eta(0:jspins)\n\n      !\n      ! loop over atoms\n      !\n      spin_deg = 1.0 / (3 - jspins)\n      e_ldau = 0.0\n\n      do i_u = 1, atoms%n_u+atoms%n_hia\n\n         itype = atoms%lda_u(i_u)%atomtype\n         l     = atoms%lda_u(i_u)%l\n         u_htr = atoms%lda_u(i_u)%u / hartree_to_ev_const\n         j_htr = atoms%lda_u(i_u)%j / hartree_to_ev_const\n\n         u_htr = f0(i_u)/hartree_to_ev_const\n         if (l.eq.1) then\n            j_htr = f2(i_u)/(5*hartree_to_ev_const)\n         else if (l.eq.2) then\n            j_htr = 1.625*f2(i_u)/(14*hartree_to_ev_const)\n         else if (l.eq.3) then\n            j_htr = (286.+195*451/675+250*1001/2025)*f2(i_u)/(6435*hartree_to_ev_const)\n         end if\n         !\n         ! calculate spin-density 'rho_sig' and total density 'rho_tot'\n         !\n         rho_tot = 0.0\n         do ispin = 1,jspins\n            rho_sig(ispin) = 0.0\n            do m = -l,l\n               rho_sig(ispin) = rho_sig(ispin) + real(ns_mmp(m,m,i_u,ispin))\n            end do\n            rho_tot = rho_tot + rho_sig(ispin)\n         end do\n         rho_sig(1) = rho_sig(1) * spin_deg  ! if jspins = 1, divide by 2\n\n\n         !\n         ! use around-mean-field limit (true) of atomic limit (false)\n         !\n         if(jspins.eq.2 .and.i_u>atoms%n_u.and..not.spin_pol) then\n            rho_sig(1)      = rho_tot/jspins\n            rho_sig(jspins) = rho_tot/jspins\n         endif\n         if(atoms%lda_u(i_u)%l_amf) then\n            eta(1) = rho_sig(1) / (2*l + 1) \n            eta(jspins) = rho_sig(jspins) / (2*l + 1)\n            eta(0) = (eta(1) + eta(jspins) )\n         else\n            eta(0) = 1.0\n            eta(1) = 0.5\n            eta(jspins) = 0.5\n         endif\n\n         !\n         !--------------------------------------------------------------------------------------------+\n         !  s       --                                        s'                    1        s   1    |\n         ! v     =  >  ( <m,p|v|m',q> - <m,p|v|q,m'> d     ) n     + d    ( -u (n - -) + j (n  - -) ) |\n         !  m,m'    --                                s,s'    p,q     m,m'          2            2    |\n         !        p,q,s'                                                                              |\n         !--------------------------------------------------------------------------------------------+\n         ! initialise vs_mmp\n         vs_mmp(:,:,i_u,:) = cmplx_0\n         !\n         ! outer spin loop - set up v_mmp\n         !\n         do ispin = 1,jspins\n            do m = -l,l\n               do mp =-l,l\n                  do jspin = 1,jspins\n                     if (ispin.eq.jspin) then\n                        do p = -l,l\n                           do q = -l,l\n                              vs_mmp(m,mp,i_u,ispin) = vs_mmp(m,mp,i_u,ispin) +  &\n                                 ns_mmp(p, q,i_u,jspin) * ( u(m,p,mp,q,i_u) - u(m,p,q,mp,i_u) )\n                           end do\n                        end do\n                     end if\n                     if ((ispin.ne.jspin).or.(jspins.eq.1)) then\n                        do p = -l,l\n                           do q = -l,l\n                              vs_mmp(m,mp,i_u,ispin) = vs_mmp(m,mp,i_u,ispin) +  &\n                                 u(m,p,mp,q,i_u) * ns_mmp(p, q,i_u,jspin)\n                           end do\n                        end do\n                     end if\n                  end do\n\n               end do ! m' loop\n            end do   ! m  loop\n         end do      ! outer spin loop\n         !\n         !  set diagonal terms and correct for non-spin-polarised case\n         !\n         do ispin = 1,jspins\n            v_diag(ispin) = - u_htr * ( rho_tot - 0.5*eta(0) ) + j_htr * ( rho_sig(ispin) - eta(ispin) )\n            do m = -l,l\n               do mp = -l,l\n                  vs_mmp(m,mp,i_u,ispin) = vs_mmp(m,mp,i_u,ispin) * spin_deg\n               end do\n               vs_mmp(m,m,i_u,ispin) = vs_mmp(m,m,i_u,ispin) + v_diag(ispin)\n            end do\n         end do\n\n         !----------------------------------------------------------------------+\n         !              s                                                       !\n         !  ee      1  ---   s        s                     1        s  1       !\n         ! e  (n) = -  >    n      ( v     + d     ( u (n - -) - j (n - -) ))   !\n         !          2  ---   m,m'     m,m'    m,m'          2           2       !\n         !             m,m'                                                     !\n         !----------------------------------------------------------------------+\n\n         e_ee = 0.0\n         do ispin = 1,jspins\n            do m = -l,l\n               do mp =-l,l\n                  e_ee=e_ee+real(vs_mmp(m,mp,i_u,ispin)*ns_mmp(m,mp,i_u,ispin))\n               end do\n               e_ee = e_ee - v_diag(ispin) * real( ns_mmp(m,m,i_u,ispin) )\n            end do\n         end do\n\n         !----------------------------------------------------------------------+\n         !   dc       ee      u           j  --   s   s       1                 |\n         !  e      = e  (n) - - n (n-1) + -  >   n  (n -1)  - - (u-j) n         |\n         !   lda+u            2           2  --               2                 |\n         !                                    s                                 |\n         !----------------------------------------------------------------------+\n\n         ns_sum = 0.0\n         do ispin = 1,jspins\n            ns_sum = ns_sum + rho_sig(ispin) * (rho_sig(ispin) - 2.0*eta(ispin))\n         end do\n         e_dc = u_htr * rho_tot * ( rho_tot - eta(0) ) - j_htr * ns_sum\n         e_dcc = (u_htr - j_htr) * rho_tot\n\n         ns_sum = ns_sum / spin_deg\n         !       e_ldau = e_ldau + (e_ee -  u_htr * rho_tot * ( rho_tot - 1. )\n         !    +    + j_htr * ns_sum  - (u_htr - j_htr) * rho_tot) * neq(itype)\n         !       write(*,*) e_ldau\n         e_ldau = e_ldau + ( e_ee - e_dc - e_dcc) * atoms%neq(itype)\n         !       write(*,*) e_ldau\n\n      end do ! loop over u parameters\n\n      e_ldau = e_ldau / 2\n\n   end subroutine v_mmp\n"}
{"id": 365, "subroutine": "  subroutine hc5_initparamtriang (ilvmin,ilvmax,rproblem)\n  \n!<description>\n  ! this routine initialises the parametrisation and triangulation of the\n  ! domain. the corresponding .prm/.tri files are read from disc and\n  ! the triangulation is refined as described by the parameter ilv.\n!</description>\n\n!<input>\n  ! minimum refinement level of the mesh; = coarse grid = level 1\n  integer, intent(in) :: ilvmin\n  \n  ! maximum refinement level\n  integer, intent(in) :: ilvmax\n!</input>\n\n!<inputoutput>\n  ! a problem structure saving problem-dependent information.\n  type(t_problem), intent(inout) :: rproblem\n!</inputoutput>\n\n\n  ! local variables\n  integer :: i\n  \n    ! initialise the level in the problem structure\n    rproblem%ilvmin = ilvmin\n    rproblem%ilvmax = ilvmax\n\n    ! at first, read in the parametrisation of the boundary and save\n    ! it to rboundary.\n    call boundary_read_prm(rproblem%rboundary, rproblem%sprmfile)\n        \n    ! now read in the basic triangulation.\n    call tria_readtrifile2d (rproblem%rlevelinfo(rproblem%ilvmin)%rtriangulation, &\n        rproblem%strifile, rproblem%rboundary)\n    \n    ! refine the mesh up to the minimum level\n    call tria_quickrefine2levelordering(rproblem%ilvmin-1,&\n        rproblem%rlevelinfo(rproblem%ilvmin)%rtriangulation,rproblem%rboundary)\n    \n    ! create information about adjacencies and everything one needs from\n    ! a triangulation. afterwards, we have the coarse mesh.\n    call tria_initstandardmeshfromraw (&\n        rproblem%rlevelinfo(rproblem%ilvmin)%rtriangulation,rproblem%rboundary)\n    \n    ! now, refine to level up to nlmax.\n    do i=rproblem%ilvmin+1,rproblem%ilvmax\n      call tria_refine2levelordering (rproblem%rlevelinfo(i-1)%rtriangulation,&\n          rproblem%rlevelinfo(i)%rtriangulation, rproblem%rboundary)\n      call tria_initstandardmeshfromraw (rproblem%rlevelinfo(i)%rtriangulation,&\n          rproblem%rboundary)\n    end do\n\n  end subroutine\n"}
{"id": 366, "subroutine": "  subroutine hc5_initdiscretisation (rproblem)\n  \n!<description>\n  ! this routine initialises the discretisation structure of the underlying\n  ! problem and saves it to the problem structure.\n!</description>\n\n!<inputoutput>\n  ! a problem structure saving problem-dependent information.\n  type(t_problem), intent(inout), target :: rproblem\n!</inputoutput>\n\n\n  ! local variables\n  integer :: i\n  \n    ! an object for saving the domain:\n    type(t_boundary), pointer :: p_rboundary\n    \n    ! an object for saving the triangulation on the domain\n    type(t_triangulation), pointer :: p_rtriangulation\n\n    ! an object for the block discretisation on one level\n    type(t_blockdiscretisation), pointer :: p_rdiscretisation\n    \n    do i=rproblem%ilvmin,rproblem%ilvmax\n      ! ask the problem structure to give us the boundary and triangulation.\n      ! we need it for the discretisation.\n      p_rboundary => rproblem%rboundary\n      p_rtriangulation => rproblem%rlevelinfo(i)%rtriangulation\n      \n      ! now we can start to initialise the discretisation. at first, set up\n      ! a block discretisation structure that specifies the blocks in the\n      ! solution vector. in this simple problem, we only have one block.\n      allocate(p_rdiscretisation)\n      call spdiscr_initblockdiscr (p_rdiscretisation,1,&\n                                   p_rtriangulation, p_rboundary)\n\n      ! save the discretisation structure to our local levelinfo structure\n      ! for later use.\n      rproblem%rlevelinfo(i)%p_rdiscretisation => p_rdiscretisation\n\n      ! p_rdiscretisation%rdiscretisations is a list of scalar\n      ! discretisation structures for every component of the solution vector.\n      ! initialise the first element of the list to specify the element\n      ! and cubature rule for this solution component:\n      call spdiscr_initdiscr_simple ( &\n                  p_rdiscretisation%rspatialdiscr(1), &\n                  el_e011,cub_g2x2, &\n                  p_rtriangulation, p_rboundary)\n\n      ! create an assembly information structure on each level which tells the code\n      ! the cubature formula to use. standard: gauss 3x3.\n      call spdiscr_createdefcubstructure(&  \n          p_rdiscretisation%rspatialdiscr(1),rproblem%rlevelinfo(i)%rcubatureinfo,&\n          cub_gen_auto_g3)\n\n    end do\n                                   \n  end subroutine\n"}
{"id": 367, "subroutine": "  subroutine hc5_donediscretisation (rproblem)\n  \n!<description>\n  ! releases the discretisation from the heap.\n!</description>\n\n!<inputoutput>\n  ! a problem structure saving problem-dependent information.\n  type(t_problem), intent(inout), target :: rproblem\n!</inputoutput>\n\n\n  ! local variables\n  integer :: i\n\n    do i=rproblem%ilvmax,rproblem%ilvmin,-1\n      ! delete the block discretisation together with the associated\n      ! scalar spatial discretisations....\n      call spdiscr_releaseblockdiscr(rproblem%rlevelinfo(i)%p_rdiscretisation)\n      \n      ! and remove the allocated block discretisation structure from the heap.\n      deallocate(rproblem%rlevelinfo(i)%p_rdiscretisation)\n      \n      ! release the cubature info structures\n      call spdiscr_releasecubstructure(rproblem%rlevelinfo(i)%rcubatureinfo)\n    end do\n    \n  end subroutine\n"}
{"id": 368, "subroutine": "  subroutine hc5_doneparamtriang (rproblem)\n  \n!<description>\n  ! releases the triangulation and parametrisation from the heap.\n!</description>\n\n!<inputoutput>\n  ! a problem structure saving problem-dependent information.\n  type(t_problem), intent(inout), target :: rproblem\n!</inputoutput>\n\n\n  ! local variables\n  integer :: i\n\n    do i=rproblem%ilvmax,rproblem%ilvmin,-1\n      ! release the triangulation\n      call tria_done (rproblem%rlevelinfo(i)%rtriangulation)\n    end do\n    \n    ! finally release the domain.\n    call boundary_release (rproblem%rboundary)\n    \n  end subroutine\n"}
{"id": 369, "subroutine": "    pure subroutine calc_alphas_gamma(solver)\n      use types, only: solver_settings\n      type(solver_settings), intent(inout) :: solver\n\n      solver%alpha_m = (3 - solver%rho_infty)/(1 + solver%rho_infty)\n      solver%alpha_f = 1/(1 + solver%rho_infty)\n      solver%gamma = 0.5d0 + solver%alpha_m - solver%alpha_f\n    end subroutine\n"}
{"id": 370, "subroutine": "    pure subroutine predictor_deltauconstant(soln, solnm1, solnp1, solver)\n      use types, only: solver_settings, solution_state_ptr\n      use transformation\n      use math\n      type(solution_state_ptr), intent(in) :: soln, solnm1\n      type(solver_settings), intent(in) :: solver\n      type(solution_state_ptr), intent(out) :: solnp1\n      real*8 :: ty12(6,6)\n\n      solnp1%u = soln%u + (soln%u - solnm1%u)\n      solnp1%udot = (soln%u - solnm1%u)/(solver%delta_t * solver%gamma) &\n                    + ((solver%gamma - 1)*soln%udot)/solver%gamma\n\n      ty12 = 0d0\n      ty12(1:3,1:3) = t_a12(soln%y(4:6))\n      ty12(4:6,4:6) = t_r21(soln%y(4:6))\n      solnp1%y = soln%y + (ty12.matmul.soln%u)*solver%delta_t\n      ! old implementation without correct axis transformations\n      ! solnp1%y = soln%y + soln%u*solver%delta_t + 0.5d0*soln%udot*solver%delta_t**2 &\n      !            + ( ((soln%udot - soln%udot)/solver%delta_t) * solver%delta_t**3 )/6d0\n    end subroutine\n"}
{"id": 371, "subroutine": "    subroutine iterate(soln, solnp1, solver, problem, residual)\n      use aero\n      use types, only: solver_settings, solution_state_ptr, problemdata\n      use transformation\n      use math\n      use matinv66\n      type(solution_state_ptr), intent(inout) :: soln\n      type(solver_settings), intent(in) :: solver\n      type(problemdata), intent(in) :: problem\n      type(solution_state_ptr), intent(out) :: solnp1\n      real*8, intent(out) :: residual\n\n      !  [ ] calculate them based on soln and solnp1\n      !  [ ] then calculate a_naf and b_naf from an, anp1, bn, and bnp1\n      !  [ ] make calca take y and u as direct inputs rather than solution\n      !  [ ] use tr12 and (subsequent) omega2 to generate omega_tilde\n      !  [x] make y predictor use tr12 since y is in axis1 and u in axis2\n\n      real*8, dimension(6) :: udoti_nam, ui_naf, yi_naf, gi, ai_naf\n      real*8, dimension(6,6) :: bi_naf, ki, ty12_naf, dai_nafdui_naf\n      real*8, dimension(3,3) :: omega_tilde, imat, imat_inv\n      real*8 :: time_factor\n      integer :: i, j, k\n      logical :: bool\n\n      time_factor = solver%alpha_m/(solver%gamma*solver%delta_t*solver%alpha_f)\n      ui_naf = 0; udoti_nam = 0; yi_naf = 0;\n\n      udoti_nam = soln%udot + solver%alpha_m*(solnp1%udot - soln%udot)\n      ui_naf = soln%u + solver%alpha_f*(solnp1%u - soln%u)\n      yi_naf = soln%y + solver%alpha_f*(solnp1%y - soln%y)\n\n      do i=1,solver%niters\n        call calca(yi_naf, ui_naf, problem, ai_naf, dai_nafdui_naf)\n        bi_naf = 0\n        imat = 0; imat_inv = 0;\n        forall(j=1:3) imat(j,j) = problem%disc%i(j)\n        forall(j=1:3) imat_inv(j,j) = 1/problem%disc%i(j)\n        call skewsymmetric(ui_naf(4:6), omega_tilde)\n\n        bi_naf(1:3, 1:3) = omega_tilde\n        bi_naf(4:6, 4:6) = imat_inv.matmul.omega_tilde.matmul.imat\n\n        gi = udoti_nam - ai_naf + (bi_naf.matmul.ui_naf)\n        residual = maxval(abs(gi))\n        ! print *, 'max residual', maxval(abs(gi))\n\n        if (residual < solver%tolerance) then !todo add \"or if last iteration\"\n          exit\n        end if\n\n        ! create tangent matrix\n        ki = bi_naf - dai_nafdui_naf\n        forall(j=1:6) ki(j,j) = ki(j,j) + time_factor\n\n\n        ! invert block diagonal tangent matrix\n        invertki: associate(ki_inv => bi_naf)\n          call m66inv(ki, ki_inv, bool)\n\n          if (.not.bool) then\n            print *, 'tangent matrix not invertable'\n          end if\n\n          ui_naf = ui_naf - (ki_inv.matmul.gi)\n          udoti_nam = (1 - solver%alpha_m/solver%gamma)*soln%udot + time_factor*(ui_naf - soln%u)\n        end associate invertki\n\n        ty12_naf = 0d0\n        ty12_naf(1:3,1:3) = t_a12(yi_naf(4:6))\n        ty12_naf(4:6,4:6) = t_r21(yi_naf(4:6))\n        yi_naf = soln%y - (ty12_naf.matmul.ui_naf)*(solver%delta_t*(solver%alpha_f - 1))\n        ! print *, solnp1%y(1:3)\n\n      end do\n\n      solnp1%u = soln%u + (ui_naf - soln%u)/solver%alpha_f\n      solnp1%udot = soln%udot + (udoti_nam - soln%udot)/solver%alpha_m\n      solnp1%y = soln%y + (yi_naf - soln%y)/solver%alpha_f\n\n      ! print *, solnp1%y(1:3)\n    end subroutine\n"}
{"id": 372, "subroutine": "        module subroutine restart_model(domain, dataset, options)\n            implicit none\n            type(domain_t),  intent(inout) :: domain\n            type(output_t),  intent(inout) :: dataset\n            type(options_t), intent(inout) :: options\n\n        end subroutine\n"}
{"id": 373, "subroutine": "subroutine wbb_sr\n\nuse mpar\nuse mbbio\n\nimplicit none\n\ninteger(kind=rsp) i,j,n_rec,i_basin,i_rec\nreal(kind=rep) nodata\ninteger(kind=isp) :: ic\ncharacter(len=32) demfile\n\nreal(kind=rep),allocatable :: rwa(:)\n\n\r\ninteger(kind=isp) ii,jj,ii_basin,last_i_basin,flag_gronda,cnt_celle,cnt_b_cell\r\n\r\nreal(kind=rep) quota_cij,quota_ciijj,quota_gronda,quota_min,quota_chiusura\r\nreal(kind=rep) max_q_depit,cqm_new\r\n\r\n! set the dem file name and nodata threshold\n! (catchment cell are those with dem elevation greater that nodata)\n\nwrite(6,*)\nwrite(6,*) 'searching the dtm_13.val input file...' \ndemfile='dtm_13.val'\nnodata=-9999.0_rep\nwrite(6,*) 'assigned nodata value =',nodata \n\n! read <parfile>\n\ncall rparfile('hap.in')\n\nallocate(rwa(n))\n\n! open the ascii catchment dem file <demfile>\n\nopen(73,file=demfile,status='old')\n\r\ncall catchment_cells(nodata,rwa,n_rec,quota_min)\r\n\r\ncall init_dtm(n_rec)\n\n! write the binary files basin_b/basin_i\n\ni_rec= 0\nrewind 73\ndo j=m,1,-1\n   read(73,*,iostat=ic) (rwa(i),i=1,n)\n   select case(ic)\n   case(:-1)\n      write(6,*) \"error when reading the file \",demfile\n      stop\n   case(0)\n      do i=1,n\n         if (rwa(i).gt.nodata) then\n            i_rec=i_rec+1\n            i_basin=(i-1)*m+j\n            call set_dtm_index(i_basin,i_rec)\n            call set_quota(i_basin,rwa(i))\n         end if\n      end do\n   case(1:)\n      write(6,*) \"insufficient data in the file \",demfile\n      stop\n   end select\nend do\r\nn_celle=n_rec\nwrite(6,*) 'number of processed cells =',n_rec\nwrite(6,*)\n\r\nif (bcc.eq.0) goto 2000\r\n\r\n! procedure for boundary channel constraction\r\n\r\nwrite(6,*) 'boundary channel constraction...'\r\nwrite(6,*)\r\n\r\nquota_gronda=quota_min*cqm\r\nquota_chiusura=quota_gronda*cqg\r\n\r\ncnt_b_cell=0\r\ndo j=m,1,-1\r\n   do i=1,n\r\n      i_basin=(i-1)*m+j\r\n\t  quota_cij=dtm_quota(i_basin)\r\n      if (quota_cij < 0.0_rep) cycle\r\n      flag_gronda=0\r\n      do ii=i-1,i+1\r\n\t     if (flag_gronda.eq.1) cycle \r\n         do jj=j-1,j+1              \r\n\t\t    if (flag_gronda.eq.1) cycle    \r\n            if (ii.eq.0.or.ii.eq.n+1) flag_gronda=1            \r\n            if (jj.eq.0.or.jj.eq.m+1) flag_gronda=1           \r\n            if (flag_gronda.eq.0) then\r\n \t\t       ii_basin=(ii-1)*m+jj\r\n               quota_ciijj=dtm_quota(ii_basin)\r\n               if (quota_ciijj < 0.0_rep) flag_gronda=1\r\n            end if\r\n\t\t\tif (flag_gronda.eq.1) then\t\t\t   \r\n\t\t\t   cnt_b_cell=cnt_b_cell+1\r\n\t\t\t   last_i_basin=i_basin\r\n               call set_quota(last_i_basin,quota_gronda)\r\n\t\t\tend if                  \r\n\t     end do\r\n      end do\r\n   end do\r\nend do\r\n\r\ncall set_quota(last_i_basin,quota_chiusura)\r\n\r\nwrite(6,*) 'boundary channel constraction terminated'\r\nwrite(6,*)\r\n\r\nwrite(6,*) 'minimum cell elevation (m) =',quota_min\r\nwrite(6,*) 'boundary channel elevation (m) =',quota_gronda\r\nwrite(6,*) 'outlet cell elevation (m) =',quota_chiusura\r\nwrite(6,*) 'number of boundary channel cells =',cnt_b_cell\r\nwrite(6,*)\r\n\r\nmax_q_depit=quota_gronda+(cnt_b_cell*delta_x*sqrt(2.0)*pt)\r\ncqm_new=1-(cnt_b_cell*delta_x*sqrt(2.0)*pt)/quota_min\r\n\r\nif (max_q_depit.ge.quota_min) then\r\n   write(6,*) '********************************************************************************'\r\n   write(6,*) 'warning:'\r\n   write(6,*)\r\n   write(6,*) 'probably after the depitting, the highest boundary channel cell has elevation'\r\n   write(6,*) 'great then the lowest dem cell.'\r\n   write(6,*) 'a new value of coefficient for boundary channel elevation definition'\r\n   write(6,*) 'is reccomended less then', cqm_new\r\n   write(6,*)\r\n   write(6,*) '********************************************************************************'\r\n   stop\r\nend if\r\n\r\n2000 continue\r\n\r\n! close the files\n\nclose(73)\n\ncall save_dtm(\"basin_b\",\"basin_i\")\n\nend subroutine wbb_sr\n"}
{"id": 374, "subroutine": "subroutine catchment_cells(nodata,rwa,n_rec,quota_min)\nuse mpar\nimplicit none\r\ninteger(kind=isp) ::  n_rec\nreal(kind=rep) :: nodata\r\nreal(kind=rep) :: quota_min,quota_min_tmp\nreal(kind=rep),dimension(n) :: rwa\ninteger(kind=isp) :: i,ic\nrewind 73\nn_rec= 0\r\nquota_min=8844.43 !mount everest elevation\ndo\n   read(73,*,iostat=ic) (rwa(i),i=1,n)\r\n   if (ic /= 0) exit\n   do i=1,n\n      if (rwa(i).gt.nodata) then\r\n\t     n_rec=n_rec+1\r\n      else\r\n \t     rwa(i)=quota_min  !fittizio per eliminare i nodata per \r\n \t                       !il calcolo della quota minuma\r\n      end if\n   end do\r\n   quota_min_tmp=minval(rwa)\r\n   quota_min=dmin1(quota_min,quota_min_tmp)\nend do\nrewind 73\nend subroutine catchment_cells\n"}
{"id": 375, "subroutine": "      subroutine spme (i, j, hcoul, hbab, hmag)\n      use vast_kind_param,only: double\n      integer, intent(in) :: i\n      integer, intent(in) :: j\n      real(double), intent(out) :: hcoul\n      real(double), intent(out) :: hbab\n      real(double), intent(out) :: hmag\n      end subroutine\n"}
{"id": 376, "subroutine": "   subroutine slepcinit(a,gnpoin,npoin,npoinlocal,ndofn,optionsfile,exmod,lun_solve,memor)\n      implicit none\n\n      class(slepcsystem) :: a\n      type(memoryman), target :: memor\n      integer(ip)    :: gnpoin,npoin,npoinlocal,ndofn,lun_solve,optionslen\n      character(150) :: exmod,optionsfile\n      character(120) :: errorstring\n      character(10)  :: string\n      petscerrorcode :: ierr\n      \n      a%memor => memor\n      a%npoinlocal = npoinlocal\n      a%npoin = npoin\n      a%gnpoin = gnpoin\n      a%ndofn = ndofn\n\n      a%optionsfile = adjustl(trim(optionsfile))\n      string = adjustl(trim(exmod))\n      a%exmod = adjustl(trim(string))//'_'\n\n      a%lun_solve = lun_solve\n\n      optionslen = len(adjustl(trim(optionsfile)))\n      optionsfile = adjustl(trim(optionsfile))\n      call petscoptionsinsertfile(a%mpicomm,petsc_null_options,optionsfile(1:optionslen),petsc_true,ierr) \n\n      if (ierr /= 0) then\n         errorstring = 'slepc: '//adjustl(trim(optionsfile))//' not found'\n         call runend(errorstring)\n      endif\n\n   end subroutine\n"}
{"id": 377, "subroutine": "   subroutine slepcsetlinearsystem(a,linearsystem)\n      implicit none\n      class(slepcsystem) :: a\n      class(parallelsysteminterface), pointer :: linearsystem\n\n      a%linearsystem => linearsystem\n\n   end subroutine\n"}
{"id": 378, "subroutine": "   subroutine slepcsetmatrixpointers(a)\n      implicit none\n      class(slepcsystem) :: a\n      class(parallelsysteminterface),pointer:: ls => null()\n\n      ls => a%linearsystem\n      select type(ls)\n      class is(petscsystem)\n         a%amatrix => ls%matrix\n      end select\n\n   end subroutine\n"}
{"id": 379, "subroutine": "   subroutine slepcsetrhspointers(a)\n      implicit none\n      class(slepcsystem) :: a\n      class(parallelsysteminterface),pointer:: ls => null()\n\n      ls => a%linearsystem\n      select type(ls)\n      class is(petscsystem)\n         a%rhs => ls%rhs\n      end select\n\n      call a%rhspointer(a%rhs)\n\n   end subroutine\n"}
{"id": 380, "subroutine": "   subroutine slepcwriteinfo(a,fil_outpu)\n      implicit none\n      class(slepcsystem) :: a \n      character(150)   :: fil_outpu\n      petscerrorcode   :: ierr\n\n      call petscviewercreate(a%mpicomm,a%outviewer,ierr)\n      call petscviewerfilesetmode(a%outviewer,file_mode_write,ierr)\n      call petscviewerasciiopen(a%mpicomm,fil_outpu,a%outviewer,ierr)\n\n      call a%specificwriter\n\n      call petscviewerdestroy(a%outviewer,ierr)\n\n   end subroutine\n"}
{"id": 381, "subroutine": "   subroutine slepcsetconv(a,nconv)\n      implicit none\n      class(slepcsystem) :: a \n      integer(ip)        :: nconv\n\n      a%ndofr = nconv\n      a%nconv = nconv\n\n   end subroutine\n"}
{"id": 382, "subroutine": "   subroutine slepcsetmean(a,snapmean)\n      implicit none\n      class(slepcsystem) :: a \n      integer(ip)        :: ipoin,ispos,idofn\n      real(rp)           :: snapmean(a%ndofn,a%npoinlocal)\n      petscerrorcode     :: ierr\n\n      do ipoin = 1, a%npoinlocal\n         do idofn = 1, a%ndofn\n            ispos = (a%ndofn)*(a%localordering%islocal2global(ipoin))+idofn\n            call vecsetvalues(a%snapmean,1,ispos-1,snapmean(idofn,ipoin),insert_values,ierr)\n         enddo\n      enddo\n      call vecassemblybegin(a%snapmean,ierr)\n      call vecassemblyend(a%snapmean,ierr)\n    \n   end subroutine\n"}
{"id": 383, "subroutine": "   subroutine slepcsetbasis(a,idofr,basis)\n      implicit none\n      class(slepcsystem) :: a \n      integer(ip)        :: idofr,ipoin,ispos,idofn\n      real(rp), target   :: basis(a%ndofn,a%npoinlocal)\n      petscerrorcode     :: ierr\n\n      call veczeroentries(a%basisu(idofr),ierr)\n      do ipoin = 1, a%npoinlocal\n         do idofn = 1, a%ndofn\n            ispos = (a%ndofn)*(a%localordering%islocal2global(ipoin))+idofn\n            call vecsetvalues(a%basisu(idofr),1,ispos-1,basis(idofn,ipoin),insert_values,ierr)\n         enddo\n      enddo\n      call vecassemblybegin(a%basisu(idofr),ierr)\n      call vecassemblyend(a%basisu(idofr),ierr)\n\n      call a%basispointer(a%basisu)\n      call a%precpointer(a%basisu)\n\n   end subroutine\n"}
{"id": 384, "subroutine": "   subroutine slepcsetsigma(a,sigma)\n      implicit none\n      class(slepcsystem) :: a\n      real(rp)           :: sigma(a%nconv) \n\n      call a%memor%alloc(a%nconv,a%sigma,'sigma','slepcsystem')\n      a%sigma = sigma\n\n   end subroutine\n"}
{"id": 385, "subroutine": "   subroutine slepcorthogonalizebasis(a)\n      implicit none\n      class(slepcsystem) :: a \n      integer(ip)        :: idofr,iaux\n      real(rp)           :: aux(a%ndofn*a%npoinlocal)\n      petscerrorcode     :: ierr\n\n      call bvcreate(a%mpicomm,a%basis,ierr)\n      call bvsetfromoptions(a%basis,ierr)\n      call bvsetsizes(a%basis,a%ndofn*a%npoinlocal,a%ndofn*a%gnpoin,a%nconv,ierr)\n      iaux = a%ndofn*a%gnpoin*a%nconv\n      call a%memor%allocobj(ierr,'basisbv','slepcsystem',iaux)\n      do idofr =1,a%ndofr\n         call bvinsertvec(a%basis,idofr-1,a%basisu(idofr),ierr)\n      enddo\n\n      call bvorthogonalize(a%basis,petsc_null_mat,ierr)\n\n      do idofr =1,a%ndofr\n         call bvcopyvec(a%basis,idofr-1,a%basisu(idofr),ierr)\n      enddo\n\n   end subroutine\n"}
{"id": 386, "subroutine": "   subroutine slepcgetmean(a,mean)\n      implicit none\n      class(slepcsystem) :: a\n      real(rp)           :: mean(a%ndofn,a%npoinlocal)\n\n      mean = a%snapshotmean\n\n   end subroutine\n"}
{"id": 387, "subroutine": "   subroutine slepcgetbasis(a,u)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: i\n      real(rp)           :: u(a%ndofn*a%npoinlocal,a%ndofr)\n      vec                :: u_aux\n      petscerrorcode     :: ierr\n\n      call veccreate(a%mpicomm,u_aux,ierr)\n      call vecsetfromoptions(u_aux,ierr)\n      call vecsetsizes(u_aux,a%ndofn*a%npoinlocal,a%ndofn*a%gnpoin,ierr)\n      call vecsetup(u_aux,ierr)\n      do i=0,a%ndofr-1\n         call vecplacearray(u_aux,u(:,i+1),ierr)\n         call bvcopyvec(a%basis,i,u_aux,ierr)  !getcolumn may be faster\n         call vecresetarray(u_aux,ierr)\n      end do\n      call vecdestroy(u_aux,ierr)\n\n   end subroutine\n"}
{"id": 388, "subroutine": "   subroutine slepcgetbasisr(a,v)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: i\n      real(rp)           :: v(a%ndofr,a%ndofr)\n      vec                :: v_aux,v_auxs\n      vecscatter         :: toallscatter\n      petscerrorcode     :: ierr\n\n      call veccreate(a%mpicomm,v_aux,ierr)\n      call vecsetfromoptions(v_aux,ierr)\n      call vecsetsizes(v_aux,petsc_decide,a%ndofr,ierr)\n      call vecsetup(v_aux,ierr)\n\n      call vecscattercreatetoall(v_aux,toallscatter,v_auxs,ierr)\n\n      do i=0,a%ndofr-1\n         call bvcopyvec(a%rbasis,i,v_aux,ierr)  !getcolumn may be faster\n         call vecplacearray(v_auxs,v(:,i+1),ierr)\n         call vecscatterbegin(toallscatter,v_aux,v_auxs,insert_values,scatter_forward,ierr)\n         call vecscatterend(toallscatter,v_aux,v_auxs,insert_values,scatter_forward,ierr)\n         call vecresetarray(v_auxs,ierr)\n      end do\n      call vecdestroy(v_aux,ierr)\n      call vecdestroy(v_auxs,ierr)\n      call vecscatterdestroy(toallscatter,ierr)\n\n   end subroutine\n"}
{"id": 389, "subroutine": "   subroutine slepctozero(a)\n      implicit none\n      class(slepcsystem) :: a\n      petscerrorcode     :: ierr\n\n      call matzeroentries(a%aphi,ierr)\n      call veczeroentries(a%rhsphi,ierr)\n   end subroutine\n"}
{"id": 390, "subroutine": "   subroutine slepcsetupoperators(a)\n      implicit none\n      class(slepcsystem) :: a\n      petscerrorcode     :: ierr\n\n      call matassemblybegin(a%amatrix,mat_final_assembly,ierr)\n      call matassemblyend(a%amatrix,mat_final_assembly,ierr)\n      call vecassemblybegin(a%rhs,ierr)\n      call vecassemblyend(a%rhs,ierr)\n      call vecassemblybegin(a%rhs_pointer,ierr)\n      call vecassemblyend(a%rhs_pointer,ierr)\n\n   end subroutine\n"}
{"id": 391, "subroutine": "   subroutine slepcinitoperators(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: iaux\n      petscerrorcode     :: ierr\n\n      call veccreate(a%mpicomm,a%rhsphi,ierr)\n      call vecsetfromoptions(a%rhsphi,ierr)\n      call vecsetsizes(a%rhsphi,petsc_decide,a%ndofr,ierr)\n      call vecsetup(a%rhsphi,ierr)\n      call vecassemblybegin(a%rhsphi,ierr)\n      call vecassemblyend(a%rhsphi,ierr)\n      iaux = a%ndofr\n      call a%memor%allocobj(ierr,'rhsphi','slepcsystem',iaux)\n      \n      call veccreate(a%mpicomm,a%unkno,ierr)\n      call vecsetfromoptions(a%unkno,ierr)\n      call vecsetsizes(a%unkno,petsc_decide,a%ndofr,ierr)\n      call vecsetup(a%unkno,ierr)\n      call vecassemblybegin(a%unkno,ierr)\n      call vecassemblyend(a%unkno,ierr)\n      iaux = a%ndofr\n      call a%memor%allocobj(ierr,'unkno','slepcsystem',iaux)\n\n      call matcreate(a%mpicomm,a%aphi,ierr)\n      call matsetfromoptions(a%aphi,ierr)\n      call matsetsizes(a%aphi,petsc_decide,petsc_decide,a%ndofr,a%ndofr,ierr)\n      call matsetup(a%aphi,ierr)\n      call matzeroentries(a%aphi,ierr)\n      call matassemblybegin(a%aphi,mat_final_assembly,ierr)\n      call matassemblyend(a%aphi,mat_final_assembly,ierr)\n      iaux = a%ndofr*a%ndofr\n      call a%memor%allocobj(ierr,'aphi','slepcsystem',iaux)\n   end subroutine\n"}
{"id": 392, "subroutine": "   subroutine basispointer(a,basisu)\n      implicit none\n      class(slepcsystem) :: a\n      vec, target        :: basisu(:)\n\n      a%basis_pointer => basisu\n\n   end subroutine\n"}
{"id": 393, "subroutine": "   subroutine slepcresetbasispointer(a)\n      implicit none\n      class(slepcsystem) :: a\n\n      call a%basispointer(a%basisu)\n\n   end subroutine\n"}
{"id": 394, "subroutine": "   subroutine rhspointer(a,rhsp)\n      implicit none\n      class(slepcsystem) :: a\n      vec, target        :: rhsp\n\n      a%rhs_pointer => rhsp\n\n   end subroutine\n"}
{"id": 395, "subroutine": "   subroutine slepcpetrovgalerkinprojection(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: idofr\n      petscerrorcode     :: ierr\n\n      do idofr = 1, a%ndofr\n         call matmult(a%amatrix,a%basisu(idofr),a%modbasis(idofr),ierr)\n      end do\n      call a%basispointer(a%modbasis)\n      call a%precpointer(a%modbasis)\n\n   end subroutine\n"}
{"id": 396, "subroutine": "   subroutine slepcmeantorhs(a)\n      implicit none\n      class(slepcsystem) :: a\n      vec                :: auxvec,u_aux\n      petscerrorcode     :: ierr\n\n      call vecduplicate(a%rhs_pointer,auxvec,ierr)\n      call veccopy(a%rhs_pointer,auxvec,ierr)\n\n      call matmult(a%amatrix,a%snapmean,a%modrhs,ierr)\n      call vecaypx(a%modrhs,-1.0_rp,auxvec,ierr)\n      \n      call vecdestroy(auxvec,ierr)\n      \n      call a%rhspointer(a%modrhs)\n\n   end subroutine\n"}
{"id": 397, "subroutine": "   subroutine slepcmatprojection(a)\n      implicit none\n      class(slepcsystem) :: a\n      real(rp)           :: auxmat(a%ndofr)\n      integer(ip)        :: idofr,j\n      petscerrorcode     :: ierr\n\n      do idofr = 1,a%ndofr\n         call vecmdot(a%basis_pointer(idofr),a%ndofr,a%prec_pointer,auxmat,ierr)\n         call matsetvalues(a%aphi,a%ndofr,(/(j,j=0,a%ndofr-1)/),1,idofr-1,auxmat,insert_values,ierr)\n      end do\n      call matassemblybegin(a%aphi,mat_final_assembly,ierr)\n      call matassemblyend(a%aphi,mat_final_assembly,ierr)\n\n   end subroutine\n"}
{"id": 398, "subroutine": "   subroutine slepcvecprojection(a)\n      implicit none\n      class(slepcsystem) :: a\n      real(rp)           :: rhsphi(a%ndofr)\n      integer(ip)        :: j\n      petscerrorcode     :: ierr\n       \n      call vecmdot(a%rhs_pointer,a%ndofr,a%prec_pointer,rhsphi,ierr)\n      call vecsetvalues(a%rhsphi,a%ndofr,(/(j,j=0,a%ndofr-1)/),rhsphi,insert_values,ierr)\n      call vecassemblybegin(a%rhsphi,ierr)\n      call vecassemblyend(a%rhsphi,ierr)\n\n   end subroutine\n"}
{"id": 399, "subroutine": "   subroutine slepcinitsolve(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: iaux\n      pc                 :: petsc_pc\n      petscerrorcode     :: ierr\n\n      call veccreate(a%mpicomm,a%modrhs,ierr)\n      call vecsetfromoptions(a%modrhs,ierr)\n      call vecsetsizes(a%modrhs,a%ndofn*a%npoinlocal,a%ndofn*a%gnpoin,ierr)\n      call vecsetup(a%modrhs,ierr)\n      iaux = a%ndofn*a%npoinlocal\n      call a%memor%allocobj(ierr,'modrhs','slepcsystem',iaux)\n      call veczeroentries(a%modrhs,ierr)\n\n      call vecduplicatevecsf90(a%modrhs,a%ndofr,a%basisu,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%allocobj(ierr,'basis','slepcsystem',iaux)\n\n      call vecduplicatevecsf90(a%modrhs,a%ndofr,a%modbasis,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%allocobj(ierr,'modbasis','slepcsystem',iaux)\n\n      call veccreate(a%mpicomm,a%snapmean,ierr)\n      call vecsetfromoptions(a%snapmean,ierr)\n      call vecsetsizes(a%snapmean,a%ndofn*a%npoinlocal,a%ndofn*a%gnpoin,ierr)\n      call vecsetup(a%snapmean,ierr)\n      iaux = a%ndofn*a%npoinlocal\n      call a%memor%allocobj(ierr,'snapmean','slepcsystem',iaux)\n      call veczeroentries(a%snapmean,ierr)\n      \n      call kspcreate(a%mpicomm,a%solver,ierr)\n      call kspsetoptionsprefix(a%solver,adjustl(trim(a%exmod)),ierr)\n      call kspsetfromoptions(a%solver,ierr)\n      call a%memor%allocobj(ierr,'solver','slepcsystem',1)\n      call kspgetpc(a%solver,petsc_pc,ierr)\n      call pcsetoptionsprefix(petsc_pc,adjustl(trim(a%exmod)),ierr)\n      call pcsetfromoptions(petsc_pc,ierr)\n\n   end subroutine\n"}
{"id": 400, "subroutine": "   subroutine slepcsolveprojsystem(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip)        :: niter,convergedreason,i,j\n      real(rp)           :: rnorm\n      real(rp)           :: cputim2,cputim1\n      real(rp), pointer  :: matpointer(:,:) => null(),vecpointer(:) => null()\n      petscerrorcode     :: ierr\n\n      call cpu_time(cputim1)\n      call kspsetoperators(a%solver,a%aphi,a%aphi,ierr)\n      call kspsolve(a%solver,a%rhsphi,a%unkno,ierr)\n\n      call kspgetconvergedreason(a%solver,convergedreason,ierr)\n      if (ierr < 0) then\n         write(*,*) 'warning, rom solver did not converge'\n      endif\n      call kspgetiterationnumber(a%solver,niter,ierr)\n      call kspgetresidualnorm(a%solver,rnorm,ierr)\n\n      call cpu_time(cputim2)\n      if (a%mpirank == a%mpiroot) then\n         write(a%lun_solve,500)\n         write(a%lun_solve,100) niter\n         write(a%lun_solve,101) rnorm\n         write(a%lun_solve,102) cputim2-cputim1\n         write(a%lun_solve,501)\n         if (a%kfl_flush == 1) call flush(a%lun_solve)\n      endif\n\n      500 format('rom solver info')\n      100 format('   number of iterations: ',i12)\n      101 format('   residual norm:        ',e12.6)\n      102 format('   solve time:           ',e12.6)\n      501 format('------------------------------')\n   end subroutine\n"}
{"id": 401, "subroutine": "   subroutine slepcgetsolution(a,solution)\n      implicit none\n      class(slepcsystem) :: a\n      real(rp)           :: solution(a%ndofr)\n      vecscatter         :: toallscatter\n      vec                :: unkall\n      petscerrorcode     :: ierr\n\n      solution = 0.0_rp\n      call vecscattercreatetoall(a%unkno,toallscatter,unkall,ierr)\n      call vecplacearray(unkall,solution,ierr)\n      call vecscatterbegin(toallscatter,a%unkno,unkall,insert_values,scatter_forward,ierr)\n      call vecscatterend(toallscatter,a%unkno,unkall,insert_values,scatter_forward,ierr)\n      call vecresetarray(unkall,ierr)\n      call vecdestroy(unkall,ierr)\n      call vecscatterdestroy(toallscatter,ierr)\n\n   end subroutine\n"}
{"id": 402, "subroutine": "   subroutine slepcdeallocateoperators(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip) :: iaux\n      petscerrorcode :: ierr\n\n      call matdestroy(a%aphi,ierr)\n      call vecdestroy(a%rhsphi,ierr)\n      iaux = a%ndofr*a%ndofr\n      call a%memor%deallocobj(ierr,'aphi','slepcsystem',iaux)\n      iaux = a%ndofr\n      call a%memor%deallocobj(ierr,'rhsphi','slepcsystem',iaux)\n      call vecdestroy(a%unkno,ierr)\n      call a%memor%deallocobj(ierr,'unkno','slepcsystem',iaux)\n\n      call kspreset(a%solver,ierr)\n\n   end subroutine\n"}
{"id": 403, "subroutine": "   subroutine slepcsystemdeallocate(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip) :: iaux\n      petscerrorcode :: ierr\n\n      call vecdestroy(a%modrhs,ierr)\n      iaux = a%ndofn*a%npoinlocal\n      call a%memor%deallocobj(ierr,'modrhs','slepcsystem',iaux)\n      \n      call vecdestroy(a%snapmean,ierr)\n      iaux = a%ndofn*a%npoinlocal\n      call a%memor%deallocobj(ierr,'snapmean','slepcsystem',iaux)\n      \n      call kspdestroy(a%solver,ierr)\n      call a%memor%deallocobj(ierr,'solver','slepcsystem',1)\n\n      call vecdestroyvecsf90(a%ndofr,a%basisu,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%deallocobj(ierr,'basis','slepcsystem',iaux)\n      call vecdestroyvecsf90(a%ndofr,a%modbasis,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%deallocobj(ierr,'modbasis','slepcsystem',iaux)\n      \n      call a%memor%dealloc(a%nconv,a%sigma,'sigma','slepcsystem')\n\n   end subroutine\n"}
{"id": 404, "subroutine": "   subroutine slepcorthogonalizedeallocate(a)\n      implicit none\n      class(slepcsystem) :: a\n      integer(ip) :: iaux\n      petscerrorcode :: ierr\n\n      call bvdestroy(a%basis,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%deallocobj(ierr,'basisbv','slepcsystem',iaux)\n\n   end subroutine\n"}
{"id": 405, "subroutine": "   subroutine slepcsetbasistols(a,ls,basis)\n      implicit none\n      class(slepcsystem) :: a\n      class(parallelsysteminterface),pointer:: ls\n      real(rp), target   :: basis(a%ndofn,a%npoinlocal,a%ndofr)\n      petscerrorcode :: ierr\n\n      select type(ls)\n      class is(basispetscsystem)\n         ls%basisu => a%basisu\n         ls%basis => basis\n         ls%ndofr = a%ndofr\n         ls%ndofr  = a%ndofr\n         ls%ndofn  = a%ndofn\n         ls%npoinlocal = a%npoinlocal\n      end select\n\n   end subroutine\n"}
{"id": 406, "subroutine": "   subroutine proj_init(a,kfl_massmatrix,kfl_precondition)\n      implicit none\n      class(basispetscsystem) :: a\n      real(rp)    :: auxmat(a%ndofr)\n      integer(ip) :: idofr,iaux,j\n      integer(ip) :: kfl_precondition    !use a precondition projection\n      logical     :: kfl_massmatrix      !mass matrix projection in basis\n      petscerrorcode :: ierr\n\n      a%kfl_massmatrix = kfl_massmatrix\n      call veccreate(a%mpicomm,a%prhs,ierr)\n      call vecsetfromoptions(a%prhs,ierr)\n      call vecsetsizes(a%prhs,petsc_decide,a%ndofr,ierr)\n      call vecsetup(a%prhs,ierr)\n      call veczeroentries(a%prhs,ierr)\n      call vecassemblybegin(a%prhs,ierr)\n      call vecassemblyend(a%prhs,ierr)\n      iaux = a%ndofr\n      call a%memor%allocobj(ierr,'prhs','slepcsystem',iaux)\n      \n      call veccreate(a%mpicomm,a%punkno,ierr)\n      call vecsetfromoptions(a%punkno,ierr)\n      call vecsetsizes(a%punkno,petsc_decide,a%ndofr,ierr)\n      call vecsetup(a%punkno,ierr)\n      call veczeroentries(a%punkno,ierr)\n      call vecassemblybegin(a%punkno,ierr)\n      call vecassemblyend(a%punkno,ierr)\n      iaux = a%ndofr\n      call a%memor%allocobj(ierr,'punkno','slepcsystem',iaux)\n\n      call vecduplicatevecsf90(a%rhs,a%ndofr,a%auxbasis,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%allocobj(ierr,'auxbasis','slepcsystem',iaux)\n\n      call matassemblybegin(a%matrix,mat_final_assembly,ierr)\n      call matassemblyend(a%matrix,mat_final_assembly,ierr)\n      !projection of the matrix to the rom space\n      do idofr = 1, a%ndofr\n         call matmult(a%matrix,a%basisu(idofr),a%auxbasis(idofr),ierr)\n      end do\n      if (a%kfl_massmatrix) then\n         call veccreate(a%mpicomm,a%pmatrixd,ierr)\n         call vecsetfromoptions(a%pmatrixd,ierr)\n         call vecsetsizes(a%pmatrixd,petsc_decide,a%ndofr,ierr)\n         call vecsetup(a%pmatrixd,ierr)\n         call veczeroentries(a%pmatrixd,ierr)\n         call vecassemblybegin(a%pmatrixd,ierr)\n         call vecassemblyend(a%pmatrixd,ierr)\n         iaux = a%ndofr\n         call a%memor%allocobj(ierr,'pmatrixd','slepcsystem',iaux)\n         do idofr = 1,a%ndofr\n            !diagonal form\n            call vecdot(a%auxbasis(idofr),a%basisu(idofr),auxmat(idofr),ierr)\n            !call vecsetvalue(a%pmatrixd,idofr-1,1.0_rp,insert_values,ierr)   !identity matrix form\n            call vecsetvalue(a%pmatrixd,idofr-1,1.0_rp/auxmat(idofr),insert_values,ierr)  !full multiplication\n         end do\n         a%modbasis => a%basisu\n      elseif (kfl_precondition .eq. 1) then\n         call matcreate(a%mpicomm,a%pmatrix,ierr)\n         call matsetfromoptions(a%pmatrix,ierr)\n         call matsetsizes(a%pmatrix,petsc_decide,petsc_decide,a%ndofr,a%ndofr,ierr)\n         call matsetup(a%pmatrix,ierr)\n         call matzeroentries(a%pmatrix,ierr)\n         call matassemblybegin(a%pmatrix,mat_final_assembly,ierr)\n         call matassemblyend(a%pmatrix,mat_final_assembly,ierr)\n         iaux = a%ndofr*a%ndofr\n         call a%memor%allocobj(ierr,'pmatrix','slepcsystem',iaux)\n         do idofr = 1,a%ndofr\n            !non-diagonal form\n            call vecmdot(a%auxbasis(idofr),a%ndofr,a%auxbasis,auxmat,ierr)\n            call matsetvalues(a%pmatrix,a%ndofr,(/(j,j=0,a%ndofr-1)/),1,idofr-1,auxmat,insert_values,ierr)\n         end do\n         a%modbasis => a%auxbasis\n         call matassemblybegin(a%pmatrix,mat_final_assembly,ierr)\n         call matassemblyend(a%pmatrix,mat_final_assembly,ierr)\n      else\n         call matcreate(a%mpicomm,a%pmatrix,ierr)\n         call matsetfromoptions(a%pmatrix,ierr)\n         call matsetsizes(a%pmatrix,petsc_decide,petsc_decide,a%ndofr,a%ndofr,ierr)\n         call matsetup(a%pmatrix,ierr)\n         call matzeroentries(a%pmatrix,ierr)\n         call matassemblybegin(a%pmatrix,mat_final_assembly,ierr)\n         call matassemblyend(a%pmatrix,mat_final_assembly,ierr)\n         iaux = a%ndofr*a%ndofr\n         call a%memor%allocobj(ierr,'pmatrix','slepcsystem',iaux)\n         do idofr = 1,a%ndofr\n            !non-diagonal form\n            call vecmdot(a%auxbasis(idofr),a%ndofr,a%basisu,auxmat,ierr)\n            call matsetvalues(a%pmatrix,a%ndofr,(/(j,j=0,a%ndofr-1)/),1,idofr-1,auxmat,insert_values,ierr)\n         end do\n         a%modbasis => a%basisu\n         call matassemblybegin(a%pmatrix,mat_final_assembly,ierr)\n         call matassemblyend(a%pmatrix,mat_final_assembly,ierr)\n      end if\n\n   end subroutine\n"}
{"id": 407, "subroutine": "   subroutine proj_solve(a,unkno)\n      implicit none\n      class(basispetscsystem) :: a\n      real(rp)    :: unkno(a%ndofn,a%npoinlocal),auxunkno(a%ndofr),rnorm,rhsvec(a%ndofr)\n      integer(ip) :: niter,idofn,idofr,ipoin,convergedreason,j\n      real(rp)    :: cputim2, cputim1\n      petscerrorcode :: ierr\n\n      call cpu_time(cputim1)\n      \n      call vecassemblybegin(a%rhs,ierr)\n      call vecassemblyend(a%rhs,ierr)\n      !projection of the rhs to the rom space\n      call vecmdot(a%rhs,a%ndofr,a%modbasis,rhsvec,ierr)\n      call vecsetvalues(a%prhs,a%ndofr,(/(j,j=0,a%ndofr-1)/),rhsvec,insert_values,ierr)\n      call vecassemblybegin(a%prhs,ierr)\n      call vecassemblyend(a%prhs,ierr)\n\n      if (a%kfl_massmatrix) then\n         call vecpointwisemult(a%punkno,a%pmatrixd,a%prhs,ierr)\n      else\n         call kspsetoperators(a%solver,a%pmatrix,a%pmatrix,ierr)\n         call kspsolve(a%solver,a%prhs,a%punkno,ierr)\n         call kspgetconvergedreason(a%solver,convergedreason,ierr)\n         if (ierr < 0) then\n            write(*,*) 'warning, rom mass matrix solver did not converge'\n         endif\n         call kspgetiterationnumber(a%solver,niter,ierr);\n         call kspgetresidualnorm(a%solver,rnorm,ierr)\n      end if\n\n      unkno = 0.0_rp\n      call vecplacearray(a%unkno,unkno,ierr)\n      call a%getsolution(auxunkno)\n      do idofr = 1, a%ndofr\n         call vecaxpy(a%unkno,auxunkno(idofr),a%basisu(idofr),ierr)\n      end do\n      call vecresetarray(a%unkno,ierr)\n      call vecresetarray(a%unkno,ierr)\n\n      call cpu_time(cputim2)\n\n      if (a%mpirank == a%mpiroot) then\n         write(a%lun_solve,500)\n         write(a%lun_solve,100) niter\n         write(a%lun_solve,101) rnorm\n         write(a%lun_solve,102) cputim2-cputim1\n         write(a%lun_solve,501)\n         if (a%kfl_flush == 1) call flush(a%lun_solve)\n      endif\n\n      500 format('rom mass matrix solver info')\n      100 format('   number of iterations: ',i12)\n      101 format('   residual norm:        ',e12.6)\n      102 format('   solve time:           ',e12.6)\n      501 format('------------------------------')\n\n   end subroutine\n"}
{"id": 408, "subroutine": "   subroutine proj_getsolution(a,solution)\n      implicit none\n      class(basispetscsystem) :: a\n      real(rp)           :: solution(a%ndofr)\n      vecscatter         :: toallscatter\n      vec                :: unkall\n      petscerrorcode     :: ierr\n\n      solution = 0.0_rp\n      call vecscattercreatetoall(a%punkno,toallscatter,unkall,ierr)\n      call vecplacearray(unkall,solution,ierr)\n      call vecscatterbegin(toallscatter,a%punkno,unkall,insert_values,scatter_forward,ierr)\n      call vecscatterend(toallscatter,a%punkno,unkall,insert_values,scatter_forward,ierr)\n      call vecresetarray(unkall,ierr)\n      call vecdestroy(unkall,ierr)\n      call vecscatterdestroy(toallscatter,ierr)\n\n   end subroutine\n"}
{"id": 409, "subroutine": "   subroutine proj_deallocate(a)\n      implicit none\n      class(basispetscsystem) :: a\n      integer(ip) :: iaux\n      petscerrorcode :: ierr\n\n      if (a%kfl_massmatrix) then\n         call vecdestroy(a%pmatrixd,ierr)\n         iaux = a%ndofr\n         call a%memor%deallocobj(ierr,'pmatrixd','slepcsystem',iaux)\n      else\n         call matdestroy(a%pmatrix,ierr)\n         iaux = a%ndofr*a%ndofr\n         call a%memor%deallocobj(ierr,'pmatrix','slepcsystem',iaux)\n      end if\n      call vecdestroy(a%prhs,ierr)\n      iaux = a%ndofr\n      call a%memor%deallocobj(ierr,'prhs','slepcsystem',iaux)\n      call vecdestroy(a%punkno,ierr)\n      call a%memor%deallocobj(ierr,'punkno','slepcsystem',iaux)\n\n      call vecdestroyvecsf90(a%ndofr,a%auxbasis,ierr)\n      iaux = a%ndofn*a%npoinlocal*a%ndofr\n      call a%memor%deallocobj(ierr,'auxbasis','slepcsystem',iaux)\n\n      call matdestroy(a%matrix,ierr);\n      iaux = a%matrixsize\n      call a%memor%deallocobj(ierr,'matrix','petscsystem_deallocate',iaux)\n\n      call kspdestroy(a%solver,ierr);\n      call a%memor%deallocobj(ierr,'solver','petscsystem_deallocate',1)\n\n      call vecdestroy(a%unkno,ierr);\n      call a%memor%deallocobj(ierr,'unkno','petscsystem_deallocate',1)\n\n      call vecdestroy(a%rhs,ierr);\n      iaux = a%rhssize\n      call a%memor%deallocobj(ierr,'rhs','petscsystem_deallocate',iaux)\n\n      call a%localordering%deallocate(a%memor)\n   end subroutine\n"}
{"id": 410, "subroutine": "    pure subroutine db1ink(x,nx,fcn,kx,iknot,tx,bcoef,iflag)\n\n    implicit none\n\n    integer,intent(in)                      :: nx     !! number of x abcissae\n    integer,intent(in)                      :: kx     !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1)\n    real(wp),dimension(:),intent(in)        :: x      !! `nx` array of x abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)        :: fcn    !! `(nx)` array of function values to interpolate. `fcn(i)` should\n                                                      !!    contain the function value at the point `x(i)`\n    integer,intent(in)                      :: iknot  !! 0 = knot sequence chosen by [[db1ink]].\n                                                      !! 1 = knot sequence chosen by user.\n    real(wp),dimension(:),intent(inout)     :: tx     !! the `nx+kx` knots in the `x` direction for the spline interpolant.\n                                                      !!   if `iknot=0` these are chosen by [[db1ink]].\n                                                      !!   if `iknot=1` these are specified by the user.\n                                                      !!   must be non-decreasing.\n    real(wp),dimension(:),intent(out)       :: bcoef  !! `(nx)` array of coefficients of the b-spline interpolant.\n    integer,intent(out)                     :: iflag  !! 0 = successful execution.\n                                                      !! 2 = iknot out of range.\n                                                      !! 3 = nx out of range.\n                                                      !! 4 = kx out of range.\n                                                      !! 5 = x not strictly increasing.\n                                                      !! 6 = tx not non-decreasing.\n                                                      !! 700 = size(x) /= size(fcn,1).\n                                                      !! 706 = size(x) /= nx.\n                                                      !! 712 = size(tx) /= nx+kx.\n                                                      !! 800 = size(x) /= size(bcoef,1).\n\n    real(wp),dimension(2*kx*(nx+1)) :: work\n    logical :: status_ok\n\n    !check validity of inputs\n\n    call check_inputs('db1ink',&\n                        iknot,&\n                        iflag,&\n                        nx=nx,&\n                        kx=kx,&\n                        x=x,&\n                        f1=fcn,&\n                        bcoef1=bcoef,&\n                        tx=tx,&\n                        status_ok=status_ok)\n\n    if (status_ok) then\n\n        !choose knots\n\n        if (iknot == 0) then\n            call dbknot(x,nx,kx,tx)\n        end if\n\n        !construct b-spline coefficients\n\n        call dbtpcf(x,nx,fcn,nx,1,tx,kx,bcoef,work,iflag)\n\n    end if\n\n    end subroutine db1ink\n"}
{"id": 411, "subroutine": "    pure subroutine db1val(xval,idx,tx,nx,kx,bcoef,f,iflag,inbvx)\n\n    implicit none\n\n    integer,intent(in)                   :: idx      !! x derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                   :: nx       !! the number of interpolation points in x. (same as in last call to [[db1ink]])\n    integer,intent(in)                   :: kx       !! order of polynomial pieces in x. (same as in last call to [[db1ink]])\n    real(wp),intent(in)                  :: xval     !! x coordinate of evaluation point.\n    real(wp),dimension(nx+kx),intent(in) :: tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]])\n    real(wp),dimension(nx),intent(in)    :: bcoef    !! the b-spline coefficients computed by [[db1ink]].\n    real(wp),intent(out)                 :: f        !! interpolated value\n    integer,intent(out)                  :: iflag    !! status flag: 0 : no errors, /=0 : error\n    integer,intent(inout)                :: inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n\n    real(wp),dimension(3*kx) :: work\n\n    f = 0.0_wp\n\n    if (xval<tx(1) .or. xval>tx(nx+kx)) then\n        !write(error_unit,'(a)') 'db1val - x value out of bounds'\n        iflag = 601\n        return\n    end if\n\n    call dbvalu(tx,bcoef,nx,kx,idx,xval,inbvx,work,iflag,f)\n\n    end subroutine db1val\n"}
{"id": 412, "subroutine": "    pure subroutine db3ink(x,nx,y,ny,z,nz,fcn,kx,ky,kz,iknot,tx,ty,tz,bcoef,iflag)\n\n    implicit none\n\n    integer,intent(in)                       :: nx    !! number of x abcissae (>= 3)\n    integer,intent(in)                       :: ny    !! number of y abcissae (>= 3)\n    integer,intent(in)                       :: nz    !! number of z abcissae (>= 3)\n    integer,intent(in)                       :: kx    !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1)\n    integer,intent(in)                       :: ky    !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1)\n    integer,intent(in)                       :: kz    !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1)\n    real(wp),dimension(:),intent(in)         :: x     !! `nx` array of x abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)         :: y     !! `ny` array of y abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)         :: z     !! `nz` array of z abcissae. must be strictly increasing.\n    real(wp),dimension(:,:,:),intent(in)     :: fcn   !! `(nx,ny,nz)` matrix of function values to interpolate. fcn(i,j,k) should\n                                                      !!   contain the function value at the point (x(i),y(j),z(k))\n    integer,intent(in)                       :: iknot !! 0 = knot sequence chosen by [[db1ink]].\n                                                      !! 1 = knot sequence chosen by user.\n    real(wp),dimension(:),intent(inout)      :: tx    !! the `nx+kx` knots in the `x` direction for the spline interpolant.\n                                                      !!   if `iknot=0` these are chosen by [[db3ink]].\n                                                      !!   if `iknot=1` these are specified by the user.\n                                                      !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)      :: ty    !! the `ny+ky` knots in the `y` direction for the spline interpolant.\n                                                      !!    if `iknot=0` these are chosen by [[db3ink]].\n                                                      !!    if `iknot=1` these are specified by the user.\n                                                      !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)      :: tz    !! the `nz+kz` knots in the `z` direction for the spline interpolant.\n                                                      !!    if `iknot=0` these are chosen by [[db3ink]].\n                                                      !!    if `iknot=1` these are specified by the user.\n                                                      !!    must be non-decreasing.\n    real(wp),dimension(:,:,:),intent(out)    :: bcoef !! '(nx,ny,nz)' matrix of coefficients of the b-spline interpolant.\n    integer,intent(out)                      :: iflag !!  0 = successful execution.\n                                                      !!  2 = iknot out of range.\n                                                      !!  3 = nx out of range.\n                                                      !!  4 = kx out of range.\n                                                      !!  5 = x not strictly increasing.\n                                                      !!  6 = tx not non-decreasing.\n                                                      !!  7 = ny out of range.\n                                                      !!  8 = ky out of range.\n                                                      !!  9 = y not strictly increasing.\n                                                      !! 10 = ty not non-decreasing.\n                                                      !! 11 = nz out of range.\n                                                      !! 12 = kz out of range.\n                                                      !! 13 = z not strictly increasing.\n                                                      !! 14 = ty not non-decreasing.\n                                                      !! 700 = size(x) /= size(fcn,1).\n                                                      !! 701 = size(y) /= size(fcn,2).\n                                                      !! 702 = size(z) /= size(fcn,3).\n                                                      !! 706 = size(x) /= nx.\n                                                      !! 707 = size(y) /= ny.\n                                                      !! 708 = size(z) /= nz.\n                                                      !! 712 = size(tx) /= nx+kx.\n                                                      !! 713 = size(ty) /= ny+ky.\n                                                      !! 714 = size(tz) /= nz+kz.\n                                                      !! 800 = size(x) /= size(bcoef,1).\n                                                      !! 801 = size(y) /= size(bcoef,2).\n                                                      !! 802 = size(z) /= size(bcoef,3).\n\n    real(wp),dimension(nx*ny*nz) :: temp\n    real(wp),dimension(max(2*kx*(nx+1),2*ky*(ny+1),2*kz*(nz+1))) :: work\n    logical :: status_ok\n\n    ! check validity of input\n\n    call check_inputs('db3ink',&\n                        iknot,&\n                        iflag,&\n                        nx=nx,ny=ny,nz=nz,&\n                        kx=kx,ky=ky,kz=kz,&\n                        x=x,y=y,z=z,&\n                        tx=tx,ty=ty,tz=tz,&\n                        f3=fcn,&\n                        bcoef3=bcoef,&\n                        status_ok=status_ok)\n\n    if (status_ok) then\n\n        ! choose knots\n\n        if (iknot == 0) then\n            call dbknot(x,nx,kx,tx)\n            call dbknot(y,ny,ky,ty)\n            call dbknot(z,nz,kz,tz)\n        end if\n\n        ! copy fcn to work in packed for dbtpcf\n        temp(1:nx*ny*nz) = reshape( fcn, [nx*ny*nz] )\n\n        ! construct b-spline coefficients\n\n                      call dbtpcf(x,nx,temp, nx,ny*nz,tx,kx,bcoef,work,iflag)\n        if (iflag==0) call dbtpcf(y,ny,bcoef,ny,nx*nz,ty,ky,temp, work,iflag)\n        if (iflag==0) call dbtpcf(z,nz,temp, nz,nx*ny,tz,kz,bcoef,work,iflag)\n\n    end if\n\n    end subroutine db3ink\n"}
{"id": 413, "subroutine": "    pure subroutine db3val(xval,yval,zval,idx,idy,idz,&\n                                     tx,ty,tz,&\n                                     nx,ny,nz,kx,ky,kz,bcoef,f,iflag,&\n                                     inbvx,inbvy,inbvz,iloy,iloz)\n\n    implicit none\n\n    integer,intent(in)                      :: idx      !! x derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                      :: idy      !! y derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                      :: idz      !! z derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                      :: nx       !! the number of interpolation points in x. (same as in last call to [[db3ink]])\n    integer,intent(in)                      :: ny       !! the number of interpolation points in y. (same as in last call to [[db3ink]])\n    integer,intent(in)                      :: nz       !! the number of interpolation points in z. (same as in last call to [[db3ink]])\n    integer,intent(in)                      :: kx       !! order of polynomial pieces in x. (same as in last call to [[db3ink]])\n    integer,intent(in)                      :: ky       !! order of polynomial pieces in y. (same as in last call to [[db3ink]])\n    integer,intent(in)                      :: kz       !! order of polynomial pieces in z. (same as in last call to [[db3ink]])\n    real(wp),intent(in)                     :: xval     !! x coordinate of evaluation point.\n    real(wp),intent(in)                     :: yval     !! y coordinate of evaluation point.\n    real(wp),intent(in)                     :: zval     !! z coordinate of evaluation point.\n    real(wp),dimension(nx+kx),intent(in)    :: tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db3ink]])\n    real(wp),dimension(ny+ky),intent(in)    :: ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db3ink]])\n    real(wp),dimension(nz+kz),intent(in)    :: tz       !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db3ink]])\n    real(wp),dimension(nx,ny,nz),intent(in) :: bcoef    !! the b-spline coefficients computed by [[db3ink]].\n    real(wp),intent(out)                    :: f        !! interpolated value\n    integer,intent(out)                     :: iflag    !! status flag: 0 : no errors, /=0 : error\n    integer,intent(inout)                   :: inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                   :: inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                   :: inbvz    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                   :: iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                   :: iloz     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n\n    real(wp),dimension(ky,kz)              :: temp1\n    real(wp),dimension(kz)                 :: temp2\n    real(wp),dimension(3*max(kx,ky,kz))    :: work\n\n    integer :: lefty, leftz, mflag,&\n                kcoly, kcolz, j, k\n\n    f = 0.0_wp\n\n    if (xval<tx(1) .or. xval>tx(nx+kx)) then\n        !write(error_unit,'(a)') 'db3val - x value out of bounds'\n        iflag = 601\n        return\n    end if\n    if (yval<ty(1) .or. yval>ty(ny+ky)) then\n        !write(error_unit,'(a)') 'db3val - y value out of bounds'\n        iflag = 602\n        return\n    end if\n    if (zval<tz(1) .or. zval>tz(nz+kz)) then\n        !write(error_unit,'(a)') 'db3val - z value out of bounds'\n        iflag = 603\n        return\n    end if\n\n    iflag = -1\n    call dintrv(ty,ny+ky,yval,iloy,lefty,mflag); if (mflag /= 0) return\n    call dintrv(tz,nz+kz,zval,iloz,leftz,mflag); if (mflag /= 0) return\n\n    iflag = 0\n\n    kcolz = leftz - kz\n    do k=1,kz\n        kcolz = kcolz + 1\n        kcoly = lefty - ky\n        do j=1,ky\n            kcoly = kcoly + 1\n            call dbvalu(tx,bcoef(:,kcoly,kcolz),nx,kx,idx,xval,inbvx,work,iflag,temp1(j,k))\n            if (iflag/=0) return\n        end do\n    end do\n\n    kcoly = lefty - ky + 1\n    do k=1,kz\n        call dbvalu(ty(kcoly:),temp1(:,k),ky,ky,idy,yval,inbvy,work,iflag,temp2(k))\n        if (iflag/=0) return\n    end do\n\n    kcolz = leftz - kz + 1\n    call dbvalu(tz(kcolz:),temp2,kz,kz,idz,zval,inbvz,work,iflag,f)\n\n    end subroutine db3val\n"}
{"id": 414, "subroutine": "    pure subroutine db5ink(x,nx,y,ny,z,nz,q,nq,r,nr,&\n                        fcn,&\n                        kx,ky,kz,kq,kr,&\n                        iknot,&\n                        tx,ty,tz,tq,tr,&\n                        bcoef,iflag)\n\n    implicit none\n\n    integer,intent(in)                             :: nx    !! number of x abcissae (>= 3)\n    integer,intent(in)                             :: ny    !! number of y abcissae (>= 3)\n    integer,intent(in)                             :: nz    !! number of z abcissae (>= 3)\n    integer,intent(in)                             :: nq    !! number of q abcissae (>= 3)\n    integer,intent(in)                             :: nr    !! number of r abcissae (>= 3)\n    integer,intent(in)                             :: kx    !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1)\n    integer,intent(in)                             :: ky    !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1)\n    integer,intent(in)                             :: kz    !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1)\n    integer,intent(in)                             :: kq    !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1)\n    integer,intent(in)                             :: kr    !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1)\n    real(wp),dimension(:),intent(in)               :: x     !! `nx` array of x abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)               :: y     !! `ny` array of y abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)               :: z     !! `nz` array of z abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)               :: q     !! `nq` array of q abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)               :: r     !! `nr` array of r abcissae. must be strictly increasing.\n    real(wp),dimension(:,:,:,:,:),intent(in)       :: fcn   !! `(nx,ny,nz,nq,nr)` matrix of function values to interpolate. fcn(i,j,k,q,r) should\n                                                            !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m))\n    integer,intent(in)                             :: iknot !! 0 = knot sequence chosen by [[db1ink]].\n                                                            !! 1 = knot sequence chosen by user.\n    real(wp),dimension(:),intent(inout)            :: tx    !! the `nx+kx` knots in the x direction for the spline interpolant.\n                                                            !!   if `iknot=0` these are chosen by [[db5ink]].\n                                                            !!   if `iknot=1` these are specified by the user.\n                                                            !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)            :: ty    !! the `ny+ky` knots in the y direction for the spline interpolant.\n                                                            !!    if `iknot=0` these are chosen by [[db5ink]].\n                                                            !!    if `iknot=1` these are specified by the user.\n                                                            !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)            :: tz    !! the `nz+kz` knots in the z direction for the spline interpolant.\n                                                            !!    if `iknot=0` these are chosen by [[db5ink]].\n                                                            !!    if `iknot=1` these are specified by the user.\n                                                            !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)            :: tq    !! the `nq+kq` knots in the q direction for the spline interpolant.\n                                                            !!    if `iknot=0` these are chosen by [[db5ink]].\n                                                            !!    if `iknot=1` these are specified by the user.\n                                                            !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)            :: tr    !! the `nr+kr` knots in the r direction for the spline interpolant.\n                                                            !!    if `iknot=0` these are chosen by [[db5ink]].\n                                                            !!    if `iknot=1` these are specified by the user.\n                                                            !!    must be non-decreasing.\n    real(wp),dimension(:,:,:,:,:),intent(out)      :: bcoef !! `(nx,ny,nz,nq,nr)` matrix of coefficients of the b-spline interpolant.\n    integer,intent(out)                            :: iflag !!  0 = successful execution.\n                                                            !!  2 = iknot out of range.\n                                                            !!  3 = nx out of range.\n                                                            !!  4 = kx out of range.\n                                                            !!  5 = x not strictly increasing.\n                                                            !!  6 = tx not non-decreasing.\n                                                            !!  7 = ny out of range.\n                                                            !!  8 = ky out of range.\n                                                            !!  9 = y not strictly increasing.\n                                                            !! 10 = ty not non-decreasing.\n                                                            !! 11 = nz out of range.\n                                                            !! 12 = kz out of range.\n                                                            !! 13 = z not strictly increasing.\n                                                            !! 14 = tz not non-decreasing.\n                                                            !! 15 = nq out of range.\n                                                            !! 16 = kq out of range.\n                                                            !! 17 = q not strictly increasing.\n                                                            !! 18 = tq not non-decreasing.\n                                                            !! 19 = nr out of range.\n                                                            !! 20 = kr out of range.\n                                                            !! 21 = r not strictly increasing.\n                                                            !! 22 = tr not non-decreasing.\n                                                            !! 700 = size(x) /= size(fcn,1).\n                                                            !! 701 = size(y) /= size(fcn,2).\n                                                            !! 702 = size(z) /= size(fcn,3).\n                                                            !! 703 = size(q) /= size(fcn,4).\n                                                            !! 704 = size(r) /= size(fcn,5).\n                                                            !! 706 = size(x) /= nx.\n                                                            !! 707 = size(y) /= ny.\n                                                            !! 708 = size(z) /= nz.\n                                                            !! 709 = size(q) /= nq.\n                                                            !! 710 = size(r) /= nr.\n                                                            !! 712 = size(tx) /= nx+kx.\n                                                            !! 713 = size(ty) /= ny+ky.\n                                                            !! 714 = size(tz) /= nz+kz.\n                                                            !! 715 = size(tq) /= nq+kq.\n                                                            !! 716 = size(tr) /= nr+kr.\n                                                            !! 800 = size(x) /= size(bcoef,1).\n                                                            !! 801 = size(y) /= size(bcoef,2).\n                                                            !! 802 = size(z) /= size(bcoef,3).\n                                                            !! 803 = size(q) /= size(bcoef,4).\n                                                            !! 804 = size(r) /= size(bcoef,5).\n\n    real(wp),dimension(nx*ny*nz*nq*nr) :: temp\n    real(wp),dimension(max( 2*kx*(nx+1),&\n                            2*ky*(ny+1),&\n                            2*kz*(nz+1),&\n                            2*kq*(nq+1),&\n                            2*kr*(nr+1) )) :: work\n    logical :: status_ok\n\n    !  check validity of input\n\n    call check_inputs('db5ink',&\n                        iknot,&\n                        iflag,&\n                        nx=nx,ny=ny,nz=nz,nq=nq,nr=nr,&\n                        kx=kx,ky=ky,kz=kz,kq=kq,kr=kr,&\n                        x=x,y=y,z=z,q=q,r=r,&\n                        tx=tx,ty=ty,tz=tz,tq=tq,tr=tr,&\n                        f5=fcn,&\n                        bcoef5=bcoef,&\n                        status_ok=status_ok)\n\n    if (status_ok) then\n\n        !  choose knots\n\n        if (iknot == 0) then\n            call dbknot(x,nx,kx,tx)\n            call dbknot(y,ny,ky,ty)\n            call dbknot(z,nz,kz,tz)\n            call dbknot(q,nq,kq,tq)\n            call dbknot(r,nr,kr,tr)\n        end if\n\n        ! copy fcn to work in packed for dbtpcf\n\n        temp(1:nx*ny*nz*nq*nr) = reshape( fcn, [nx*ny*nz*nq*nr] )\n\n        !  construct b-spline coefficients\n\n                      call dbtpcf(x,nx,temp,  nx,ny*nz*nq*nr,tx,kx,bcoef,work,iflag)\n        if (iflag==0) call dbtpcf(y,ny,bcoef, ny,nx*nz*nq*nr,ty,ky,temp, work,iflag)\n        if (iflag==0) call dbtpcf(z,nz,temp,  nz,nx*ny*nq*nr,tz,kz,bcoef,work,iflag)\n        if (iflag==0) call dbtpcf(q,nq,bcoef, nq,nx*ny*nz*nr,tq,kq,temp, work,iflag)\n        if (iflag==0) call dbtpcf(r,nr,temp,  nr,nx*ny*nz*nq,tr,kr,bcoef,work,iflag)\n\n     end if\n\n    end subroutine db5ink\n"}
{"id": 415, "subroutine": "    pure subroutine db5val(xval,yval,zval,qval,rval,&\n                                idx,idy,idz,idq,idr,&\n                                tx,ty,tz,tq,tr,&\n                                nx,ny,nz,nq,nr,&\n                                kx,ky,kz,kq,kr,&\n                                bcoef,f,iflag,&\n                                inbvx,inbvy,inbvz,inbvq,inbvr,iloy,iloz,iloq,ilor)\n\n    implicit none\n\n    integer,intent(in)                            :: idx      !! x derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                            :: idy      !! y derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                            :: idz      !! z derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                            :: idq      !! q derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                            :: idr      !! r derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                            :: nx       !! the number of interpolation points in x. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: ny       !! the number of interpolation points in y. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: nz       !! the number of interpolation points in z. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: nq       !! the number of interpolation points in q. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: nr       !! the number of interpolation points in r. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: kx       !! order of polynomial pieces in x. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: ky       !! order of polynomial pieces in y. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: kz       !! order of polynomial pieces in z. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: kq       !! order of polynomial pieces in q. (same as in last call to [[db5ink]])\n    integer,intent(in)                            :: kr       !! order of polynomial pieces in r. (same as in last call to [[db5ink]])\n    real(wp),intent(in)                           :: xval     !! x coordinate of evaluation point.\n    real(wp),intent(in)                           :: yval     !! y coordinate of evaluation point.\n    real(wp),intent(in)                           :: zval     !! z coordinate of evaluation point.\n    real(wp),intent(in)                           :: qval     !! q coordinate of evaluation point.\n    real(wp),intent(in)                           :: rval     !! r coordinate of evaluation point.\n    real(wp),dimension(nx+kx),intent(in)          :: tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db5ink]])\n    real(wp),dimension(ny+ky),intent(in)          :: ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db5ink]])\n    real(wp),dimension(nz+kz),intent(in)          :: tz       !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db5ink]])\n    real(wp),dimension(nq+kq),intent(in)          :: tq       !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db5ink]])\n    real(wp),dimension(nr+kr),intent(in)          :: tr       !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db5ink]])\n    real(wp),dimension(nx,ny,nz,nq,nr),intent(in) :: bcoef    !! the b-spline coefficients computed by [[db5ink]].\n    real(wp),intent(out)                          :: f        !! interpolated value\n    integer,intent(out)                           :: iflag    !! status flag: 0 : no errors, /=0 : error\n    integer,intent(inout)                         :: inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: inbvz    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: inbvq    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: inbvr    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: iloz     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: iloq     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                         :: ilor     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n\n    real(wp),dimension(ky,kz,kq,kr)           :: temp1\n    real(wp),dimension(kz,kq,kr)              :: temp2\n    real(wp),dimension(kq,kr)                 :: temp3\n    real(wp),dimension(kr)                    :: temp4\n    real(wp),dimension(3*max(kx,ky,kz,kq,kr)) :: work\n    integer :: lefty, leftz, leftq, leftr, mflag,&\n               kcoly, kcolz, kcolq, kcolr, j, k, q, r\n\n    f = 0.0_wp\n\n    if (xval<tx(1) .or. xval>tx(nx+kx)) then\n        !write(error_unit,'(a)') 'db5val - x value out of bounds'\n        iflag = 601\n        return\n    end if\n    if (yval<ty(1) .or. yval>ty(ny+ky)) then\n        !write(error_unit,'(a)') 'db5val - y value out of bounds'\n        iflag = 602\n        return\n    end if\n    if (zval<tz(1) .or. zval>tz(nz+kz)) then\n        !write(error_unit,'(a)') 'db5val - z value out of bounds'\n        iflag = 603\n        return\n    end if\n    if (qval<tq(1) .or. qval>tq(nq+kq) ) then\n        !write(error_unit,'(a)') 'db5val - q value out of bounds'\n        iflag = 604\n        return\n    end if\n    if ( rval<tr(1) .or. rval>tr(nr+kr) ) then\n        !write(error_unit,'(a)') 'db5val - r value out of bounds'\n        iflag = 605\n        return\n    end if\n\n    iflag = -1\n    call dintrv(ty,ny+ky,yval,iloy,lefty,mflag); if (mflag /= 0) return\n    call dintrv(tz,nz+kz,zval,iloz,leftz,mflag); if (mflag /= 0) return\n    call dintrv(tq,nq+kq,qval,iloq,leftq,mflag); if (mflag /= 0) return\n    call dintrv(tr,nr+kr,rval,ilor,leftr,mflag); if (mflag /= 0) return\n\n    iflag = 0\n\n    ! x -> y, z, q, r\n    kcolr = leftr - kr\n    do r=1,kr\n        kcolr = kcolr + 1\n        kcolq = leftq - kq\n        do q=1,kq\n            kcolq = kcolq + 1\n            kcolz = leftz - kz\n            do k=1,kz\n                kcolz = kcolz + 1\n                kcoly = lefty - ky\n                do j=1,ky\n                    kcoly = kcoly + 1\n                    call dbvalu(tx,bcoef(:,kcoly,kcolz,kcolq,kcolr),&\n                                nx,kx,idx,xval,inbvx,work,iflag,temp1(j,k,q,r))\n                    if (iflag/=0) return\n                end do\n            end do\n        end do\n    end do\n\n    ! y -> z, q, r\n    kcoly = lefty - ky + 1\n    do r=1,kr\n        do q=1,kq\n            do k=1,kz\n                call dbvalu(ty(kcoly:),temp1(:,k,q,r),ky,ky,idy,yval,inbvy,work,iflag,temp2(k,q,r))\n                if (iflag/=0) return\n            end do\n        end do\n    end do\n\n    ! z -> q, r\n    kcolz = leftz - kz + 1\n    do r=1,kr\n        do q=1,kq\n            call dbvalu(tz(kcolz:),temp2(:,q,r),kz,kz,idz,zval,inbvz,work,iflag,temp3(q,r))\n            if (iflag/=0) return\n        end do\n    end do\n\n    ! q -> r\n    kcolq = leftq - kq + 1\n    do r=1,kr\n        call dbvalu(tq(kcolq:),temp3(:,r),kq,kq,idq,qval,inbvq,work,iflag,temp4(r))\n        if (iflag/=0) return\n    end do\n\n    ! r\n    kcolr = leftr - kr + 1\n    call dbvalu(tr(kcolr:),temp4,kr,kr,idr,rval,inbvr,work,iflag,f)\n\n    end subroutine db5val\n"}
{"id": 416, "subroutine": "    pure subroutine db6ink(x,nx,y,ny,z,nz,q,nq,r,nr,s,ns,&\n                        fcn,&\n                        kx,ky,kz,kq,kr,ks,&\n                        iknot,&\n                        tx,ty,tz,tq,tr,ts,&\n                        bcoef,iflag)\n\n    implicit none\n\n    integer,intent(in)                                :: nx    !! number of x abcissae (>= 3)\n    integer,intent(in)                                :: ny    !! number of y abcissae (>= 3)\n    integer,intent(in)                                :: nz    !! number of z abcissae (>= 3)\n    integer,intent(in)                                :: nq    !! number of q abcissae (>= 3)\n    integer,intent(in)                                :: nr    !! number of r abcissae (>= 3)\n    integer,intent(in)                                :: ns    !! number of s abcissae (>= 3)\n    integer,intent(in)                                :: kx    !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1)\n    integer,intent(in)                                :: ky    !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1)\n    integer,intent(in)                                :: kz    !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1)\n    integer,intent(in)                                :: kq    !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1)\n    integer,intent(in)                                :: kr    !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1)\n    integer,intent(in)                                :: ks    !! the order of spline pieces in s (>= 2, < ns). (order = polynomial degree + 1)\n    real(wp),dimension(:),intent(in)                  :: x     !! `nx` array of x abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)                  :: y     !! `ny` array of y abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)                  :: z     !! `nz` array of z abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)                  :: q     !! `nq` array of q abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)                  :: r     !! `nr` array of r abcissae. must be strictly increasing.\n    real(wp),dimension(:),intent(in)                  :: s     !! `ns` array of s abcissae. must be strictly increasing.\n    real(wp),dimension(:,:,:,:,:,:),intent(in)        :: fcn   !! `(nx,ny,nz,nq,nr,ns)` matrix of function values to interpolate. fcn(i,j,k,q,r,s) should\n                                                               !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m),s(n))\n    integer,intent(in)                                :: iknot !! 0 = knot sequence chosen by [[db1ink]].\n                                                               !! 1 = knot sequence chosen by user.\n    real(wp),dimension(:),intent(inout)               :: tx    !! the `nx+kx` knots in the x direction for the spline interpolant.\n                                                               !!   if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!   if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)               :: ty    !! the `ny+ky` knots in the y direction for the spline interpolant.\n                                                               !!    if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!    if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)               :: tz    !! the `nz+kz` knots in the z direction for the spline interpolant.\n                                                               !!    if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!    if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)               :: tq    !! the `nq+kq` knots in the q direction for the spline interpolant.\n                                                               !!    if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!    if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)               :: tr    !! the `nr+kr` knots in the r direction for the spline interpolant.\n                                                               !!    if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!    if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:),intent(inout)               :: ts    !! the `ns+ks` knots in the s direction for the spline interpolant.\n                                                               !!    if `iknot=0` these are chosen by [[db6ink]].\n                                                               !!    if `iknot=1` these are specified by the user.\n                                                               !!    must be non-decreasing.\n    real(wp),dimension(:,:,:,:,:,:),intent(out)       :: bcoef !! `(nx,ny,nz,nq,nr,ns)` matrix of coefficients of the b-spline interpolant.\n    integer,intent(out)                               :: iflag !!  0 = successful execution.\n                                                               !!  2 = iknot out of range.\n                                                               !!  3 = nx out of range.\n                                                               !!  4 = kx out of range.\n                                                               !!  5 = x not strictly increasing.\n                                                               !!  6 = tx not non-decreasing.\n                                                               !!  7 = ny out of range.\n                                                               !!  8 = ky out of range.\n                                                               !!  9 = y not strictly increasing.\n                                                               !! 10 = ty not non-decreasing.\n                                                               !! 11 = nz out of range.\n                                                               !! 12 = kz out of range.\n                                                               !! 13 = z not strictly increasing.\n                                                               !! 14 = tz not non-decreasing.\n                                                               !! 15 = nq out of range.\n                                                               !! 16 = kq out of range.\n                                                               !! 17 = q not strictly increasing.\n                                                               !! 18 = tq not non-decreasing.\n                                                               !! 19 = nr out of range.\n                                                               !! 20 = kr out of range.\n                                                               !! 21 = r not strictly increasing.\n                                                               !! 22 = tr not non-decreasing.\n                                                               !! 23 = ns out of range.\n                                                               !! 24 = ks out of range.\n                                                               !! 25 = s not strictly increasing.\n                                                               !! 26 = ts not non-decreasing.\n                                                               !! 700 = size(x) /= size(fcn,1).\n                                                               !! 701 = size(y) /= size(fcn,2).\n                                                               !! 702 = size(z) /= size(fcn,3).\n                                                               !! 703 = size(q) /= size(fcn,4).\n                                                               !! 704 = size(r) /= size(fcn,5).\n                                                               !! 705 = size(s) /= size(fcn,6).\n                                                               !! 706 = size(x) /= nx.\n                                                               !! 707 = size(y) /= ny.\n                                                               !! 708 = size(z) /= nz.\n                                                               !! 709 = size(q) /= nq.\n                                                               !! 710 = size(r) /= nr.\n                                                               !! 711 = size(s) /= ns.\n                                                               !! 712 = size(tx) /= nx+kx.\n                                                               !! 713 = size(ty) /= ny+ky.\n                                                               !! 714 = size(tz) /= nz+kz.\n                                                               !! 715 = size(tq) /= nq+kq.\n                                                               !! 716 = size(tr) /= nr+kr.\n                                                               !! 717 = size(ts) /= ns+ks.\n                                                               !! 800 = size(x) /= size(bcoef,1).\n                                                               !! 801 = size(y) /= size(bcoef,2).\n                                                               !! 802 = size(z) /= size(bcoef,3).\n                                                               !! 803 = size(q) /= size(bcoef,4).\n                                                               !! 804 = size(r) /= size(bcoef,5).\n                                                               !! 805 = size(s) /= size(bcoef,6).\n\n    real(wp),dimension(nx*ny*nz*nq*nr*ns) :: temp\n    real(wp),dimension(max( 2*kx*(nx+1),&\n                            2*ky*(ny+1),&\n                            2*kz*(nz+1),&\n                            2*kq*(nq+1),&\n                            2*kr*(nr+1),&\n                            2*ks*(ns+1))) :: work\n    logical :: status_ok\n\n    ! check validity of input\n\n    call check_inputs('db6ink',&\n                        iknot,&\n                        iflag,&\n                        nx=nx,ny=ny,nz=nz,nq=nq,nr=nr,ns=ns,&\n                        kx=kx,ky=ky,kz=kz,kq=kq,kr=kr,ks=ks,&\n                        x=x,y=y,z=z,q=q,r=r,s=s,&\n                        tx=tx,ty=ty,tz=tz,tq=tq,tr=tr,ts=ts,&\n                        f6=fcn,&\n                        bcoef6=bcoef,&\n                        status_ok=status_ok)\n\n    if (status_ok) then\n\n        ! choose knots\n\n        if (iknot == 0) then\n            call dbknot(x,nx,kx,tx)\n            call dbknot(y,ny,ky,ty)\n            call dbknot(z,nz,kz,tz)\n            call dbknot(q,nq,kq,tq)\n            call dbknot(r,nr,kr,tr)\n            call dbknot(s,ns,ks,ts)\n        end if\n\n        ! construct b-spline coefficients\n\n                      call dbtpcf(x,nx,fcn,  nx,ny*nz*nq*nr*ns,tx,kx,temp, work,iflag)\n        if (iflag==0) call dbtpcf(y,ny,temp, ny,nx*nz*nq*nr*ns,ty,ky,bcoef,work,iflag)\n        if (iflag==0) call dbtpcf(z,nz,bcoef,nz,nx*ny*nq*nr*ns,tz,kz,temp, work,iflag)\n        if (iflag==0) call dbtpcf(q,nq,temp, nq,nx*ny*nz*nr*ns,tq,kq,bcoef,work,iflag)\n        if (iflag==0) call dbtpcf(r,nr,bcoef,nr,nx*ny*nz*nq*ns,tr,kr,temp, work,iflag)\n        if (iflag==0) call dbtpcf(s,ns,temp, ns,nx*ny*nz*nq*nr,ts,ks,bcoef,work,iflag)\n\n     end if\n\n    end subroutine db6ink\n"}
{"id": 417, "subroutine": "    pure subroutine db6val(xval,yval,zval,qval,rval,sval,&\n                                idx,idy,idz,idq,idr,ids,&\n                                tx,ty,tz,tq,tr,ts,&\n                                nx,ny,nz,nq,nr,ns,&\n                                kx,ky,kz,kq,kr,ks,&\n                                bcoef,f,iflag,&\n                                inbvx,inbvy,inbvz,inbvq,inbvr,inbvs,iloy,iloz,iloq,ilor,ilos)\n\n    implicit none\n\n    integer,intent(in)                               :: idx      !! x derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: idy      !! y derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: idz      !! z derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: idq      !! q derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: idr      !! r derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: ids      !! s derivative of piecewise polynomial to evaluate.\n    integer,intent(in)                               :: nx       !! the number of interpolation points in x. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: ny       !! the number of interpolation points in y. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: nz       !! the number of interpolation points in z. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: nq       !! the number of interpolation points in q. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: nr       !! the number of interpolation points in r. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: ns       !! the number of interpolation points in s. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: kx       !! order of polynomial pieces in x. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: ky       !! order of polynomial pieces in y. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: kz       !! order of polynomial pieces in z. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: kq       !! order of polynomial pieces in q. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: kr       !! order of polynomial pieces in r. (same as in last call to [[db6ink]])\n    integer,intent(in)                               :: ks       !! order of polynomial pieces in s. (same as in last call to [[db6ink]])\n    real(wp),intent(in)                              :: xval     !! x coordinate of evaluation point.\n    real(wp),intent(in)                              :: yval     !! y coordinate of evaluation point.\n    real(wp),intent(in)                              :: zval     !! z coordinate of evaluation point.\n    real(wp),intent(in)                              :: qval     !! q coordinate of evaluation point.\n    real(wp),intent(in)                              :: rval     !! r coordinate of evaluation point.\n    real(wp),intent(in)                              :: sval     !! s coordinate of evaluation point.\n    real(wp),dimension(nx+kx),intent(in)             :: tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(ny+ky),intent(in)             :: ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(nz+kz),intent(in)             :: tz       !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(nq+kq),intent(in)             :: tq       !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(nr+kr),intent(in)             :: tr       !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(ns+ks),intent(in)             :: ts       !! sequence of knots defining the piecewise polynomial in the s direction. (same as in last call to [[db6ink]])\n    real(wp),dimension(nx,ny,nz,nq,nr,ns),intent(in) :: bcoef    !! the b-spline coefficients computed by [[db6ink]].\n    real(wp),intent(out)                             :: f        !! interpolated value\n    integer,intent(out)                              :: iflag    !! status flag: 0 : no errors, /=0 : error\n    integer,intent(inout)                            :: inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: inbvz    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: inbvq    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: inbvr    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: inbvs    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: iloz     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: iloq     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: ilor     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n    integer,intent(inout)                            :: ilos     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.\n\n    real(wp),dimension(ky,kz,kq,kr,ks)            :: temp1\n    real(wp),dimension(kz,kq,kr,ks)               :: temp2\n    real(wp),dimension(kq,kr,ks)                  :: temp3\n    real(wp),dimension(kr,ks)                     :: temp4\n    real(wp),dimension(ks)                        :: temp5\n    real(wp),dimension(3*max(kx,ky,kz,kq,kr,ks))  :: work\n\n    integer :: lefty,leftz,leftq,leftr,lefts,&\n               mflag,&\n               kcoly,kcolz,kcolq,kcolr,kcols,&\n               j,k,q,r,s\n\n    f = 0.0_wp\n\n    if (xval<tx(1) .or. xval>tx(nx+kx)) then\n        !write(error_unit,'(a)') 'db6val - x value out of bounds'\n        iflag = 601\n        return\n    end if\n    if (yval<ty(1) .or. yval>ty(ny+ky)) then\n        !write(error_unit,'(a)') 'db6val - y value out of bounds'\n        iflag = 602\n        return\n    end if\n    if (zval<tz(1) .or. zval>tz(nz+kz)) then\n        !write(error_unit,'(a)') 'db6val - z value out of bounds'\n        iflag = 603\n        return\n    end if\n    if (qval<tq(1) .or. qval>tq(nq+kq) ) then\n        !write(error_unit,'(a)') 'db6val - q value out of bounds'\n        iflag = 604\n        return\n    end if\n    if ( rval<tr(1) .or. rval>tr(nr+kr) ) then\n        !write(error_unit,'(a)') 'db6val - r value out of bounds'\n        iflag = 605\n        return\n    end if\n    if (sval<ts(1) .or. sval>ts(ns+ks) ) then\n        !write(error_unit,'(a)') 'db6val - s value out of bounds'\n        iflag = 606\n        return\n    end if\n\n    iflag = -1\n    call dintrv(ty,ny+ky,yval,iloy,lefty,mflag); if (mflag /= 0) return\n    call dintrv(tz,nz+kz,zval,iloz,leftz,mflag); if (mflag /= 0) return\n    call dintrv(tq,nq+kq,qval,iloq,leftq,mflag); if (mflag /= 0) return\n    call dintrv(tr,nr+kr,rval,ilor,leftr,mflag); if (mflag /= 0) return\n    call dintrv(ts,ns+ks,sval,ilos,lefts,mflag); if (mflag /= 0) return\n\n    iflag = 0\n\n    ! x -> y, z, q, r, s\n    kcols = lefts - ks\n    do s=1,ks\n        kcols = kcols + 1\n        kcolr = leftr - kr\n        do r=1,kr\n            kcolr = kcolr + 1\n            kcolq = leftq - kq\n            do q=1,kq\n                kcolq = kcolq + 1\n                kcolz = leftz - kz\n                do k=1,kz\n                    kcolz = kcolz + 1\n                    kcoly = lefty - ky\n                    do j=1,ky\n                        kcoly = kcoly + 1\n                        call dbvalu(tx,bcoef(:,kcoly,kcolz,kcolq,kcolr,kcols),&\n                                             nx,kx,idx,xval,inbvx,work,iflag,temp1(j,k,q,r,s))\n                        if (iflag/=0) return\n                    end do\n                end do\n            end do\n        end do\n    end do\n\n    ! y -> z, q, r, s\n    kcoly = lefty - ky + 1\n    do s=1,ks\n        do r=1,kr\n            do q=1,kq\n                do k=1,kz\n                    call dbvalu(ty(kcoly:),temp1(:,k,q,r,s),ky,ky,idy,yval,inbvy,work,iflag,temp2(k,q,r,s))\n                    if (iflag/=0) return\n                end do\n            end do\n        end do\n    end do\n\n    ! z -> q, r, s\n    kcolz = leftz - kz + 1\n    do s=1,ks\n        do r=1,kr\n            do q=1,kq\n                call dbvalu(tz(kcolz:),temp2(:,q,r,s),kz,kz,idz,zval,inbvz,work,iflag,temp3(q,r,s))\n                if (iflag/=0) return\n            end do\n        end do\n    end do\n\n    ! q -> r, s\n    kcolq = leftq - kq + 1\n    do s=1,ks\n        do r=1,kr\n            call dbvalu(tq(kcolq:),temp3(:,r,s),kq,kq,idq,qval,inbvq,work,iflag,temp4(r,s))\n            if (iflag/=0) return\n        end do\n    end do\n\n    ! r -> s\n    kcolr = leftr - kr + 1\n    do s=1,ks\n        call dbvalu(tr(kcolr:),temp4(:,s),kr,kr,idr,rval,inbvr,work,iflag,temp5(s))\n        if (iflag/=0) return\n    end do\n\n    ! s\n    kcols = lefts - ks + 1\n    call dbvalu(ts(kcols:),temp5,ks,ks,ids,sval,inbvs,work,iflag,f)\n\n    end subroutine db6val\n"}
{"id": 418, "subroutine": "    pure subroutine check_inputs(routine,&\n                            iknot,&\n                            iflag,&\n                            nx,ny,nz,nq,nr,ns,&\n                            kx,ky,kz,kq,kr,ks,&\n                            x,y,z,q,r,s,&\n                            tx,ty,tz,tq,tr,ts,&\n                            f1,f2,f3,f4,f5,f6,&\n                            bcoef1,bcoef2,bcoef3,bcoef4,bcoef5,bcoef6,&\n                            status_ok)\n\n    implicit none\n\n    character(len=*),intent(in)                         :: routine\n    integer,intent(in)                                  :: iknot !! = 0 if the ink routine is computing the knots.\n    integer,intent(out)                                 :: iflag\n    integer,intent(in),optional                         :: nx,ny,nz,nq,nr,ns\n    integer,intent(in),optional                         :: kx,ky,kz,kq,kr,ks\n    real(wp),dimension(:),intent(in),optional           :: x,y,z,q,r,s\n    real(wp),dimension(:),intent(in),optional           :: tx,ty,tz,tq,tr,ts\n    real(wp),dimension(:),intent(in),optional           :: f1,bcoef1\n    real(wp),dimension(:,:),intent(in),optional         :: f2,bcoef2\n    real(wp),dimension(:,:,:),intent(in),optional       :: f3,bcoef3\n    real(wp),dimension(:,:,:,:),intent(in),optional     :: f4,bcoef4\n    real(wp),dimension(:,:,:,:,:),intent(in),optional   :: f5,bcoef5\n    real(wp),dimension(:,:,:,:,:,:),intent(in),optional :: f6,bcoef6\n    logical,intent(out)                                 :: status_ok\n\n    logical :: error\n\n    status_ok = .false.\n\n    if ((iknot < 0) .or. (iknot > 1)) then\n\n        !write(error_unit,'(a,1x,i5)') &\n        !    trim(routine)//' - iknot is out of range: ',iflag\n        iflag = 2\n\n    else\n\n        call check('x',nx,kx,x,tx,[3,  4, 5, 6,706,712],iflag,error); if (error) return\n        call check('y',ny,ky,y,ty,[7,  8, 9,10,707,713],iflag,error); if (error) return\n        call check('z',nz,kz,z,tz,[11,12,13,14,708,714],iflag,error); if (error) return\n        call check('q',nq,kq,q,tq,[15,16,17,18,709,715],iflag,error); if (error) return\n        call check('r',nr,kr,r,tr,[19,20,21,22,710,716],iflag,error); if (error) return\n        call check('s',ns,ks,s,ts,[23,24,25,26,711,717],iflag,error); if (error) return\n\n        if (present(x) .and. present(f1) .and. present(bcoef1)) then\n            if (size(x)/=size(f1,1))     then; iflag = 700; return; end if\n            if (size(x)/=size(bcoef1,1)) then; iflag = 800; return; end if\n        end if\n        if (present(x) .and. present(y) .and. present(f2) .and. present(bcoef2)) then\n            if (size(x)/=size(f2,1))     then; iflag = 700; return; end if\n            if (size(y)/=size(f2,2))     then; iflag = 701; return; end if\n            if (size(x)/=size(bcoef2,1)) then; iflag = 800; return; end if\n            if (size(y)/=size(bcoef2,2)) then; iflag = 801; return; end if\n        end if\n        if (present(x) .and. present(y) .and. present(z) .and. present(f3) .and. &\n            present(bcoef3)) then\n            if (size(x)/=size(f3,1))     then; iflag = 700; return; end if\n            if (size(y)/=size(f3,2))     then; iflag = 701; return; end if\n            if (size(z)/=size(f3,3))     then; iflag = 702; return; end if\n            if (size(x)/=size(bcoef3,1)) then; iflag = 800; return; end if\n            if (size(y)/=size(bcoef3,2)) then; iflag = 801; return; end if\n            if (size(z)/=size(bcoef3,3)) then; iflag = 802; return; end if\n        end if\n        if (present(x) .and. present(y) .and. present(z) .and. present(q) .and. &\n            present(f4) .and. present(bcoef4)) then\n            if (size(x)/=size(f4,1))     then; iflag = 700; return; end if\n            if (size(y)/=size(f4,2))     then; iflag = 701; return; end if\n            if (size(z)/=size(f4,3))     then; iflag = 702; return; end if\n            if (size(q)/=size(f4,4))     then; iflag = 703; return; end if\n            if (size(x)/=size(bcoef4,1)) then; iflag = 800; return; end if\n            if (size(y)/=size(bcoef4,2)) then; iflag = 801; return; end if\n            if (size(z)/=size(bcoef4,3)) then; iflag = 802; return; end if\n            if (size(q)/=size(bcoef4,4)) then; iflag = 803; return; end if\n        end if\n        if (present(x) .and. present(y) .and. present(z) .and. present(q) .and. &\n            present(r) .and. present(f5) .and. present(bcoef5)) then\n            if (size(x)/=size(f5,1))     then; iflag = 700; return; end if\n            if (size(y)/=size(f5,2))     then; iflag = 701; return; end if\n            if (size(z)/=size(f5,3))     then; iflag = 702; return; end if\n            if (size(q)/=size(f5,4))     then; iflag = 703; return; end if\n            if (size(r)/=size(f5,5))     then; iflag = 704; return; end if\n            if (size(x)/=size(bcoef5,1)) then; iflag = 800; return; end if\n            if (size(y)/=size(bcoef5,2)) then; iflag = 801; return; end if\n            if (size(z)/=size(bcoef5,3)) then; iflag = 802; return; end if\n            if (size(q)/=size(bcoef5,4)) then; iflag = 803; return; end if\n            if (size(r)/=size(bcoef5,5)) then; iflag = 804; return; end if\n        end if\n        if (present(x) .and. present(y) .and. present(z) .and. present(q) .and. &\n            present(r) .and. present(s) .and. present(f6) .and. present(bcoef6)) then\n            if (size(x)/=size(f6,1))     then; iflag = 700; return; end if\n            if (size(y)/=size(f6,2))     then; iflag = 701; return; end if\n            if (size(z)/=size(f6,3))     then; iflag = 702; return; end if\n            if (size(q)/=size(f6,4))     then; iflag = 703; return; end if\n            if (size(r)/=size(f6,5))     then; iflag = 704; return; end if\n            if (size(s)/=size(f6,6))     then; iflag = 705; return; end if\n            if (size(x)/=size(bcoef6,1)) then; iflag = 800; return; end if\n            if (size(y)/=size(bcoef6,2)) then; iflag = 801; return; end if\n            if (size(z)/=size(bcoef6,3)) then; iflag = 802; return; end if\n            if (size(q)/=size(bcoef6,4)) then; iflag = 803; return; end if\n            if (size(r)/=size(bcoef6,5)) then; iflag = 804; return; end if\n            if (size(s)/=size(bcoef6,6)) then; iflag = 805; return; end if\n        end if\n\n        status_ok = .true.\n        iflag = 0\n\n    end if\n\n    contains\n\n        pure subroutine check(s,n,k,x,t,ierrs,iflag,error)  !check t,x,n,k for validity\n\n        implicit none\n\n        character(len=1),intent(in)               :: s     !! coordinate string: 'x','y','z','q','r','s'\n        integer,intent(in)              ,optional :: n     !! size of `x`\n        integer,intent(in)              ,optional :: k     !! order\n        real(wp),dimension(:),intent(in),optional :: x     !! abcissae vector\n        real(wp),dimension(:),intent(in),optional :: t     !! knot vector size(n+k)\n        integer,dimension(:),intent(in)           :: ierrs !! int error codes for n,k,x,t,size(x),size(t) checks\n        integer,intent(out)                       :: iflag !! status return code\n        logical,intent(out)                       :: error !! true if there was an error\n\n        if (present(n) .and. present(k) .and. present(x) .and. present(t)) then\n            call check_n('n'//s,n,x,[ierrs(1),ierrs(5)],iflag,error); if (error) return\n            call check_k('k'//s,k,n,ierrs(2),iflag,error); if (error) return\n            call check_x(s,n,x,ierrs(3),iflag,error); if (error) return\n            if (iknot /= 0) then\n                call check_t('t'//s,n,k,t,[ierrs(4),ierrs(6)],iflag,error); if (error) return\n            end if\n        end if\n\n        end subroutine check\n\n        pure subroutine check_n(s,n,x,ierr,iflag,error)\n\n        implicit none\n\n        character(len=*),intent(in)     :: s\n        integer,intent(in)              :: n\n        real(wp),dimension(:),intent(in):: x     !! abcissae vector\n        integer,dimension(2),intent(in) :: ierr  ![n<3 check, size(x)==n check]\n        integer,intent(out)             :: iflag !! status return code\n        logical,intent(out)             :: error\n\n        if (n < 3) then\n            !write(error_unit,'(a,1x,i5)') &\n            !    trim(routine)//' - '//trim(s)//' is out of range: ',n\n            iflag = ierr(1)\n            error = .true.\n        else\n            if (size(x)/=n) then\n                !write(error_unit,'(a,1x,i5)') &\n                !    trim(routine)//' - '//trim(s)//' is not abscissa vector size'\n                iflag = ierr(2)\n                error = .true.\n            else\n                error = .false.\n            end if\n        end if\n\n        end subroutine check_n\n\n        pure subroutine check_k(s,k,n,ierr,iflag,error)\n\n        implicit none\n\n        character(len=*),intent(in) :: s\n        integer,intent(in)          :: k\n        integer,intent(in)          :: n\n        integer,intent(in)          :: ierr\n        integer,intent(out)         :: iflag !! status return code\n        logical,intent(out)         :: error\n\n        if ((k < 2) .or. (k >= n)) then\n            !write(error_unit,'(a,1x,i5)') &\n            !    trim(routine)//' - '//trim(s)//' is out of range: ',k\n            iflag = ierr\n            error = .true.\n        else\n            error = .false.\n        end if\n\n        end subroutine check_k\n\n        pure subroutine check_x(s,n,x,ierr,iflag,error)\n\n        implicit none\n\n        character(len=*),intent(in)       :: s\n        integer,intent(in)                :: n\n        real(wp),dimension(:),intent(in)  :: x\n        integer,intent(in)                :: ierr\n        integer,intent(out)               :: iflag !! status return code\n        logical,intent(out)               :: error\n\n        integer :: i\n\n        error = .true.\n        do i=2,n\n            if (x(i) <= x(i-1)) then\n                iflag = ierr\n                !write(error_unit,'(a)') trim(routine)//' - '//trim(s)//&\n                !            ' array must be strictly increasing'\n                return\n            end if\n        end do\n        error = .false.\n\n        end subroutine check_x\n\n        pure subroutine check_t(s,n,k,t,ierr,iflag,error)\n\n        implicit none\n\n        character(len=*),intent(in)       :: s\n        integer,intent(in)                :: n\n        integer,intent(in)                :: k\n        real(wp),dimension(:),intent(in)  :: t\n        integer,dimension(2),intent(in)   :: ierr  !! [non-decreasing check, size check]\n        integer,intent(out)               :: iflag !! status return code\n        logical,intent(out)               :: error\n\n        integer :: i\n\n        error = .true.\n\n        if (size(t)/=(n+k)) then\n            !write(error_unit,'(a)') trim(routine)//' - '//trim(s)//&\n            !            ' array is not the correct size'\n            iflag = ierr(2)\n            return\n        end if\n\n        do i=2,n + k\n            if (t(i) < t(i-1))  then\n                iflag = ierr(1)\n                !write(error_unit,'(a)') trim(routine)//' - '//trim(s)//&\n                !            ' array must be non-decreasing'\n                return\n            end if\n        end do\n        error = .false.\n\n        end subroutine check_t\n\n    end subroutine check_inputs\n"}
{"id": 419, "subroutine": "    pure subroutine dbknot(x,n,k,t)\n\n    implicit none\n\n    integer,intent(in)                 :: n\n    integer,intent(in)                 :: k\n    real(wp),dimension(n),intent(in)   :: x\n    real(wp),dimension(:),intent(out)  :: t\n\n    integer  :: i, j, ipj, npj, ip1, jstrt\n    real(wp) :: rnot\n\n    !put k knots at each endpoint\n    !(shift right endpoints slightly -- see pg 350 of reference)\n    rnot = x(n) + 0.1_wp*( x(n)-x(n-1) )\n    do j=1,k\n        t(j)   = x(1)\n        npj    = n + j\n        t(npj) = rnot\n    end do\n\n    !distribute remaining knots\n\n    if (mod(k,2) == 1)  then\n\n        !case of odd k --  knots between data points\n\n        i = (k-1)/2 - k\n        ip1 = i + 1\n        jstrt = k + 1\n        do j=jstrt,n\n            ipj = i + j\n            t(j) = 0.5_wp*( x(ipj) + x(ipj+1) )\n        end do\n\n    else\n\n        !case of even k --  knots at data points\n\n        i = (k/2) - k\n        jstrt = k+1\n        do j=jstrt,n\n            ipj = i + j\n            t(j) = x(ipj)\n        end do\n\n    end if\n\n    end subroutine dbknot\n"}
{"id": 420, "subroutine": "    pure subroutine dbtpcf(x,n,fcn,ldf,nf,t,k,bcoef,work,iflag)\n\n    integer,intent(in)                    :: n\n    integer,intent(in)                    :: nf\n    integer,intent(in)                    :: ldf\n    integer,intent(in)                    :: k\n    real(wp),dimension(n),intent(in)      :: x\n    real(wp),dimension(ldf,nf),intent(in) :: fcn\n    real(wp),dimension(*),intent(in)      :: t\n    real(wp),dimension(nf,n),intent(out)  :: bcoef\n    real(wp),dimension(*),intent(out)     :: work   !! work array of size >= `2*k*(n+1)`\n    integer,intent(out)                   :: iflag  !!   0: no errors\n                                                    !! 301: n should be >0\n\n    integer :: i, j, m1, m2, iq, iw\n\n    ! check for null input\n\n    if (nf > 0)  then\n\n        ! partition work array\n        m1 = k - 1\n        m2 = m1 + k\n        iq = 1 + n\n        iw = iq + m2*n+1\n\n        ! compute b-spline coefficients\n\n        ! first data set\n\n        call dbintk(x,fcn,t,n,k,work,work(iq),work(iw),iflag)\n        if (iflag == 0) then\n            do i=1,n\n                bcoef(1,i) = work(i)\n            end do\n\n            !  all remaining data sets by back-substitution\n\n            if (nf == 1)  return\n            do j=2,nf\n                do i=1,n\n                    work(i) = fcn(i,j)\n                end do\n                call dbnslv(work(iq),m2,n,m1,m1,work)\n                do i=1,n\n                    bcoef(j,i) = work(i)\n                end do\n            end do\n        end if\n\n    else\n        !write(error_unit,'(a)') 'dbtpcf - n should be >0'\n        iflag = 301\n    end if\n\n    end subroutine dbtpcf\n"}
{"id": 421, "subroutine": "    pure subroutine dbintk(x,y,t,n,k,bcoef,q,work,iflag)\n\n    implicit none\n\n    integer,intent(in)                :: n      !! number of data points, n >= k\n    real(wp),dimension(n),intent(in)  :: x      !! vector of length n containing data point abscissa\n                                                !! in strictly increasing order.\n    real(wp),dimension(n),intent(in)  :: y      !! corresponding vector of length n containing data\n                                                !! point ordinates.\n    real(wp),dimension(*),intent(in)  :: t      !! knot vector of length n+k\n                                                !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k)\n                                                !! >= x(n), this leaves only n-k knots (not\n                                                !! necessarily x(i) values) interior to (x(1),x(n))\n    integer,intent(in)                :: k      !! order of the spline, k >= 1\n    real(wp),dimension(n),intent(out) :: bcoef  !! a vector of length n containing the b-spline coefficients\n    real(wp),dimension(*),intent(out) :: q      !! a work vector of length (2*k-1)*n, containing\n                                                !! the triangular factorization of the coefficient\n                                                !! matrix of the linear system being solved.  the\n                                                !! coefficients for the interpolant of an\n                                                !! additional data set (x(i),yy(i)), i=1,...,n\n                                                !! with the same abscissa can be obtained by loading\n                                                !! yy into bcoef and then executing\n                                                !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef)\n    real(wp),dimension(*),intent(out) :: work   !! work vector of length 2*k\n    integer,intent(out)               :: iflag  !!   0: no errors.\n                                                !! 100: k does not satisfy k>=1.\n                                                !! 101: n does not satisfy n>=k.\n                                                !! 102: x(i) does not satisfy x(i)<x(i+1) for some i.\n                                                !! 103: some abscissa was not in the support of the.\n                                                !! corresponding basis function and the system is singular.\n                                                !! 104: the system of solver detects a singular system.\n                                                !! although the theoretical conditions for a solution were satisfied.\n\n    integer :: iwork, i, ilp1mx, j, jj, km1, kpkm2, left,lenq, np1\n    real(wp) :: xi\n    logical :: found\n\n    if (k<1) then\n        !write(error_unit,'(a)') 'dbintk - k does not satisfy k>=1'\n        iflag = 100\n        return\n    end if\n\n    if (n<k) then\n        !write(error_unit,'(a)') 'dbintk - n does not satisfy n>=k'\n        iflag = 101\n        return\n    end if\n\n    jj = n - 1\n    if (jj/=0) then\n        do i=1,jj\n            if (x(i)>=x(i+1)) then\n                !write(error_unit,'(a)') 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i'\n                iflag = 102\n                return\n            end if\n        end do\n    end if\n\n    np1 = n + 1\n    km1 = k - 1\n    kpkm2 = 2*km1\n    left = k\n    ! zero out all entries of q\n    lenq = n*(k+km1)\n    do i=1,lenq\n        q(i) = 0.0_wp\n    end do\n\n    ! loop over i to construct the n interpolation equations\n    do i=1,n\n\n        xi = x(i)\n        ilp1mx = min(i+k,np1)\n        ! find left in the closed interval (i,i+k-1) such that\n        !         t(left) <= x(i) < t(left+1)\n        ! matrix is singular if this is not possible\n        left = max(left,i)\n        if (xi<t(left)) then\n            !write(error_unit,'(a)') 'dbintk - some abscissa was not in the support of the'//&\n            !             ' corresponding basis function and the system is singular'\n            iflag = 103\n            return\n        end if\n        found = .false.\n        do\n            found = (xi<t(left+1))\n            if (found) exit\n            left = left + 1\n            if (left>=ilp1mx) exit\n        end do\n        if (.not. found) then\n            left = left - 1\n            if (xi>t(left+1)) then\n                !write(error_unit,'(a)') 'dbintk - some abscissa was not in the support of the'//&\n                !             ' corresponding basis function and the system is singular'\n                iflag = 103\n                return\n            end if\n        end if\n        ! the i-th equation enforces interpolation at xi, hence\n        ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j =\n        ! left-k+1,...,left actually might be nonzero. these  k  numbers\n        ! are returned, in  bcoef (used for temp.storage here), by the\n        ! following\n        call dbspvn(t, k, k, 1, xi, left, bcoef, work, iwork, iflag)\n        if (iflag/=0) return\n\n        ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into\n        ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since\n        ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q\n        ! as a two-dim. array , with  2*k-1  rows (see comments in\n        ! dbnfac). in the present program, we treat  q  as an equivalent\n        ! one-dimensional array (because of fortran restrictions on\n        ! dimension statements) . we therefore want  bcoef(j) to go into\n        ! entry\n        !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1)\n        !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j\n        ! of q.\n        jj = i - left + 1 + (left-k)*(k+km1)\n        do j=1,k\n            jj = jj + kpkm2\n            q(jj) = bcoef(j)\n        end do\n\n    end do\n\n    ! obtain factorization of a, stored again in q.\n    call dbnfac(q, k+km1, n, km1, km1, iflag)\n\n    if (iflag==1) then !success\n        ! solve  a*bcoef = y  by backsubstitution\n        do i=1,n\n            bcoef(i) = y(i)\n        end do\n        call dbnslv(q, k+km1, n, km1, km1, bcoef)\n        iflag = 0\n    else  !failure\n        !write(error_unit,'(a)') 'dbintk - the system of solver detects a singular system'//&\n        !             ' although the theoretical conditions for a solution were satisfied'\n        iflag = 104\n    end if\n\n    end subroutine dbintk\n"}
{"id": 422, "subroutine": "    pure subroutine dbnfac(w,nroww,nrow,nbandl,nbandu,iflag)\n\n    integer,intent(in) :: nroww   !! row dimension of the work array w. must be >= nbandl + 1 + nbandu.\n    integer,intent(in) :: nrow    !! matrix order\n    integer,intent(in) :: nbandl  !! number of bands of a below the main diagonal\n    integer,intent(in) :: nbandu  !! number of bands of a above the main diagonal\n    integer,intent(out) :: iflag  !! indicating success(=1) or failure (=2)\n    real(wp),dimension(nroww,nrow),intent(inout) :: w  !! work array. see header for details.\n\n    integer :: i, ipk, j, jmax, k, kmax, middle, midmk, nrowm1\n    real(wp) :: factor, pivot\n\n    iflag = 1\n    middle = nbandu + 1   ! w(middle,.) contains the main diagonal of a.\n    nrowm1 = nrow - 1\n\n    if (nrowm1 < 0) then\n        iflag = 2\n        return\n    elseif (nrowm1 == 0) then\n        if (w(middle,nrow)==0.0_wp) iflag = 2\n        return\n    end if\n\n    if (nbandl<=0) then\n        ! a is upper triangular. check that diagonal is nonzero .\n        do i=1,nrowm1\n            if (w(middle,i)==0.0_wp) then\n                iflag = 2\n                return\n            end if\n        end do\n        if (w(middle,nrow)==0.0_wp) iflag = 2\n        return\n    end if\n\n    if (nbandu<=0) then\n        ! a is lower triangular. check that diagonal is nonzero and\n        ! divide each column by its diagonal.\n        do i=1,nrowm1\n            pivot = w(middle,i)\n            if (pivot==0.0_wp) then\n                iflag = 2\n                return\n            end if\n            jmax = min(nbandl,nrow-i)\n            do j=1,jmax\n                w(middle+j,i) = w(middle+j,i)/pivot\n            end do\n        end do\n        return\n    end if\n\n    ! a is not just a triangular matrix. construct lu factorization\n    do i=1,nrowm1\n        ! w(middle,i)  is pivot for i-th step .\n        pivot = w(middle,i)\n        if (pivot==0.0_wp) then\n            iflag = 2\n            return\n        end if\n        ! jmax is the number of (nonzero) entries in column i\n        ! below the diagonal.\n        jmax = min(nbandl,nrow-i)\n        ! divide each entry in column i below diagonal by pivot.\n        do j=1,jmax\n            w(middle+j,i) = w(middle+j,i)/pivot\n        end do\n        ! kmax is the number of (nonzero) entries in row i to\n        ! the right of the diagonal.\n        kmax = min(nbandu,nrow-i)\n        ! subtract a(i,i+k)*(i-th column) from (i+k)-th column\n        ! (below row i).\n        do k=1,kmax\n            ipk = i + k\n            midmk = middle - k\n            factor = w(midmk,ipk)\n            do j=1,jmax\n                w(midmk+j,ipk) = w(midmk+j,ipk) - w(middle+j,i)*factor\n            end do\n        end do\n    end do\n\n    ! check the last diagonal entry.\n    if (w(middle,nrow)==0.0_wp) iflag = 2\n\n    end subroutine dbnfac\n"}
{"id": 423, "subroutine": "    pure subroutine dbnslv(w,nroww,nrow,nbandl,nbandu,b)\n\n    integer,intent(in) :: nroww   !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]].\n    integer,intent(in) :: nrow    !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]].\n    integer,intent(in) :: nbandl  !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]].\n    integer,intent(in) :: nbandu  !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]].\n    real(wp),dimension(nroww,nrow),intent(in) :: w    !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]].\n    real(wp),dimension(nrow),intent(inout) :: b  !! **in**: right side of the system to be solved\n                                                 !! **out**: the solution x, of order nrow\n\n    integer :: i, j, jmax, middle, nrowm1\n\n    middle = nbandu + 1\n    if (nrow/=1) then\n\n        nrowm1 = nrow - 1\n        if (nbandl/=0) then\n\n            ! forward pass\n            ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l)\n            !                       from right side (below i-th row).\n            do i=1,nrowm1\n                jmax = min(nbandl,nrow-i)\n                do j=1,jmax\n                    b(i+j) = b(i+j) - b(i)*w(middle+j,i)\n                end do\n            end do\n\n        end if\n\n        ! backward pass\n        ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal\n        !                          entry of u, then subtract right side(i)*(i-th column\n        !                          of u) from right side (above i-th row).\n        if (nbandu<=0) then\n            ! a is lower triangular.\n            do i=1,nrow\n                b(i) = b(i)/w(1,i)\n            end do\n            return\n        end if\n\n        i = nrow\n        do\n            b(i) = b(i)/w(middle,i)\n            jmax = min(nbandu,i-1)\n            do j=1,jmax\n                b(i-j) = b(i-j) - b(i)*w(middle-j,i)\n            end do\n            i = i - 1\n            if (i<=1) exit\n        end do\n\n    end if\n\n    b(1) = b(1)/w(middle,1)\n\n    end subroutine dbnslv\n"}
{"id": 424, "subroutine": "    pure subroutine dbspvn(t,jhigh,k,index,x,ileft,vnikx,work,iwork,iflag)\n\n    implicit none\n\n    real(wp),dimension(*),intent(in)  :: t        !! knot vector of length n+k, where\n                                                  !! n = number of b-spline basis functions\n                                                  !! n = sum of knot multiplicities-k\n                                                  !! dimension t(ileft+jhigh)\n    integer,intent(in)                :: jhigh    !! order of b-spline, 1 <= jhigh <= k\n    integer,intent(in)                :: k        !! highest possible order\n    integer,intent(in)                :: index    !! index = 1 gives basis functions of order jhigh\n                                                  !!       = 2 denotes previous entry with work, iwork\n                                                  !!         values saved for subsequent calls to\n                                                  !!         dbspvn.\n    real(wp),intent(in)               :: x        !! argument of basis functions, t(k) <= x <= t(n+1)\n    integer,intent(in)                :: ileft    !! largest integer such that t(ileft) <= x < t(ileft+1)\n    real(wp),dimension(k),intent(out) :: vnikx    !! vector of length k for spline values.\n    real(wp),dimension(*),intent(out) :: work     !! a work vector of length 2*k\n    integer,intent(out)               :: iwork    !! a work parameter.  both work and iwork contain\n                                                  !! information necessary to continue for index = 2.\n                                                  !! when index = 1 exclusively, these are scratch\n                                                  !! variables and can be used for other purposes.\n    integer,intent(out)               :: iflag    !!   0: no errors\n                                                  !! 201: k does not satisfy k>=1\n                                                  !! 202: jhigh does not satisfy 1<=jhigh<=k\n                                                  !! 203: index is not 1 or 2\n                                                  !! 204: x does not satisfy t(ileft)<=x<=t(ileft+1)\n\n    integer :: imjp1, ipj, jp1, jp1ml, l\n    real(wp) :: vm, vmprev\n\n    ! content of j, deltam, deltap is expected unchanged between calls.\n    ! work(i) = deltap(i),\n    ! work(k+i) = deltam(i), i = 1,k\n\n    if (k<1) then\n        !write(error_unit,'(a)') 'dbspvn - k does not satisfy k>=1'\n        iflag = 201\n        return\n    end if\n    if (jhigh>k .or. jhigh<1) then\n        !write(error_unit,'(a)') 'dbspvn - jhigh does not satisfy 1<=jhigh<=k'\n        iflag = 202\n        return\n    end if\n    if (index<1 .or. index>2) then\n        !write(error_unit,'(a)') 'dbspvn - index is not 1 or 2'\n        iflag = 203\n        return\n    end if\n    if (x<t(ileft) .or. x>t(ileft+1)) then\n        !write(error_unit,'(a)') 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)'\n        iflag = 204\n        return\n    end if\n\n    iflag = 0\n\n    if (index==1) then\n        iwork = 1\n        vnikx(1) = 1.0_wp\n        if (iwork>=jhigh) return\n    end if\n\n    do\n        ipj = ileft + iwork\n        work(iwork) = t(ipj) - x\n        imjp1 = ileft - iwork + 1\n        work(k+iwork) = x - t(imjp1)\n        vmprev = 0.0_wp\n        jp1 = iwork + 1\n        do l=1,iwork\n            jp1ml = jp1 - l\n            vm = vnikx(l)/(work(l)+work(k+jp1ml))\n            vnikx(l) = vm*work(l) + vmprev\n            vmprev = vm*work(k+jp1ml)\n        end do\n        vnikx(jp1) = vmprev\n        iwork = jp1\n        if (iwork>=jhigh) exit\n    end do\n\n    end subroutine dbspvn\n"}
{"id": 425, "subroutine": "    pure subroutine dbvalu(t,a,n,k,ideriv,x,inbv,work,iflag,val)\n\n    implicit none\n\n    real(wp),intent(out)             :: val     !! the interpolated value\n    integer,intent(in)               :: n       !! number of b-spline coefficients.\n                                                !! (sum of knot multiplicities-k)\n    real(wp),dimension(:),intent(in) :: t       !! knot vector of length n+k\n    real(wp),dimension(n),intent(in) :: a       !! b-spline coefficient vector of length n\n    integer,intent(in)               :: k       !! order of the b-spline, k >= 1\n    integer,intent(in)               :: ideriv  !! order of the derivative, 0 <= ideriv <= k-1.\n                                                !! ideriv = 0 returns the b-spline value\n    real(wp),intent(in)              :: x       !! argument, t(k) <= x <= t(n+1)\n    integer,intent(inout)            :: inbv    !! an initialization parameter which must be set\n                                                !! to 1 the first time dbvalu is called.\n                                                !! inbv contains information for efficient process-\n                                                !! ing after the initial call and inbv must not\n                                                !! be changed by the user.  distinct splines require\n                                                !! distinct inbv parameters.\n    real(wp),dimension(:),intent(inout) :: work !! work vector of length at least 3*k\n    integer,intent(out)              :: iflag   !!   0: no errors\n                                                !! 401: k does not satisfy k>=1\n                                                !! 402: n does not satisfy n>=k\n                                                !! 403: ideriv does not satisfy 0<=ideriv<k\n                                                !! 404: x is not greater than or equal to t(k)\n                                                !! 405: x is not less than or equal to t(n+1)\n                                                !! 406: a left limiting value cannot be obtained at t(k)\n\n    integer :: i,iderp1,ihi,ihmkmj,ilo,imk,imkpj,ipj,&\n               ip1,ip1mj,j,jj,j1,j2,kmider,kmj,km1,kpk,mflag\n    real(wp) :: fkmj\n\n    val = 0.0_wp\n\n    if (k<1) then\n        !write(error_unit,'(a)') 'dbvalu - k does not satisfy k>=1'\n        iflag = 401\n        return\n    end if\n\n    if (n<k) then\n        !write(error_unit,'(a)') 'dbvalu - n does not satisfy n>=k'\n        iflag = 402\n        return\n    end if\n\n    if (ideriv<0 .or. ideriv>=k) then\n        !write(error_unit,'(a)') 'dbvalu - ideriv does not satisfy 0<=ideriv<k'\n        iflag = 403\n        return\n    end if\n\n    kmider = k - ideriv\n\n    ! find *i* in (k,n) such that t(i) <= x < t(i+1)\n    ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)).\n\n    km1 = k - 1\n    call dintrv(t, n+1, x, inbv, i, mflag)\n    if (x<t(k)) then\n        !write(error_unit,'(a)') 'dbvalu - x is not greater than or equal to t(k)'\n        iflag = 404\n        return\n    end if\n\n    if (mflag/=0) then\n\n        if (x>t(i)) then\n            !write(error_unit,'(a)') 'dbvalu - x is not less than or equal to t(n+1)'\n            iflag = 405\n            return\n        end if\n\n        do\n            if (i==k) then\n                !write(error_unit,'(a)') 'dbvalu - a left limiting value cannot be obtained at t(k)'\n                iflag = 406\n                return\n            end if\n            i = i - 1\n            if (x/=t(i)) exit\n        end do\n\n    end if\n\n    ! difference the coefficients *ideriv* times\n    ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k\n\n    imk = i - k\n    do j=1,k\n        imkpj = imk + j\n        work(j) = a(imkpj)\n    end do\n\n    if (ideriv/=0) then\n        do j=1,ideriv\n            kmj = k - j\n            fkmj = real(kmj,wp)\n            do jj=1,kmj\n                ihi = i + jj\n                ihmkmj = ihi - kmj\n                work(jj) = (work(jj+1)-work(jj))/(t(ihi)-t(ihmkmj))*fkmj\n            end do\n        end do\n    end if\n\n    ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative,\n    ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv).\n\n    if (ideriv/=km1) then\n        ip1 = i + 1\n        kpk = k + k\n        j1 = k + 1\n        j2 = kpk + 1\n        do j=1,kmider\n            ipj = i + j\n            work(j1) = t(ipj) - x\n            ip1mj = ip1 - j\n            work(j2) = x - t(ip1mj)\n            j1 = j1 + 1\n            j2 = j2 + 1\n        end do\n        iderp1 = ideriv + 1\n        do j=iderp1,km1\n            kmj = k - j\n            ilo = kmj\n            do jj=1,kmj\n                work(jj) = (work(jj+1)*work(kpk+ilo)+work(jj)*&\n                            work(k+jj))/(work(kpk+ilo)+work(k+jj))\n                ilo = ilo - 1\n            end do\n        end do\n    end if\n\n    iflag = 0\n    val = work(1)\n\n    end subroutine dbvalu\n"}
{"id": 426, "subroutine": "    pure subroutine dintrv(xt,lxt,x,ilo,ileft,mflag)\n\n    implicit none\n\n    integer,intent(in)                 :: lxt    !! length of the `xt` vector\n    real(wp),dimension(lxt),intent(in) :: xt     !! a knot or break point vector of length `lxt`\n    real(wp),intent(in)                :: x      !! argument\n    integer,intent(inout)              :: ilo    !! an initialization parameter which must be set\n                                                 !! to 1 the first time the spline array `xt` is\n                                                 !! processed by dintrv. `ilo` contains information for\n                                                 !! efficient processing after the initial call and `ilo`\n                                                 !! must not be changed by the user.  distinct splines\n                                                 !! require distinct i`lo parameters.\n    integer,intent(out)                :: ileft  !! largest integer satisfying `xt(ileft) <= x`\n    integer,intent(out)                :: mflag  !! signals when `x` lies out of bounds\n\n    integer :: ihi, istep, middle\n\n    ihi = ilo + 1\n    if ( ihi>=lxt ) then\n        if ( x>=xt(lxt) ) then\n            mflag = 1\n            ileft = lxt\n            return\n        end if\n        if ( lxt<=1 ) then\n            mflag = -1\n            ileft = 1\n            return\n        end if\n        ilo = lxt - 1\n        ihi = lxt\n    endif\n\n    if ( x>=xt(ihi) ) then\n\n        ! now x >= xt(ilo). find upper bound\n        istep = 1\n        do\n            ilo = ihi\n            ihi = ilo + istep\n            if ( ihi>=lxt ) then\n                if ( x>=xt(lxt) ) then\n                    mflag = 1\n                    ileft = lxt\n                    return\n                end if\n                ihi = lxt\n            elseif ( x>=xt(ihi) ) then\n                istep = istep*2\n                cycle\n            endif\n            exit\n        end do\n\n    else\n\n        if ( x>=xt(ilo) ) then\n            mflag = 0\n            ileft = ilo\n            return\n        end if\n        ! now x <= xt(ihi). find lower bound\n        istep = 1\n        do\n            ihi = ilo\n            ilo = ihi - istep\n            if ( ilo<=1 ) then\n                ilo = 1\n                if ( x<xt(1) ) then\n                    mflag = -1\n                    ileft = 1\n                    return\n                end if\n            elseif ( x<xt(ilo) ) then\n                istep = istep*2\n                cycle\n            endif\n            exit\n        end do\n\n    endif\n\n    ! now xt(ilo) <= x < xt(ihi). narrow the interval\n    do\n        middle = (ilo+ihi)/2\n        if ( middle==ilo ) then\n            mflag = 0\n            ileft = ilo\n            return\n        end if\n        ! note. it is assumed that middle = ilo in case ihi = ilo+1\n        if ( x<xt(middle) ) then\n            ihi = middle\n        else\n            ilo = middle\n        endif\n    end do\n\n    end subroutine dintrv\n"}
{"id": 427, "subroutine": "   subroutine vca_allocate_bath(vca_bath_)\n      type(effective_bath) :: vca_bath_\n      !\n      if(vca_bath_%status)call vca_deallocate_bath(vca_bath_)\n      !\n      if(nbath==0)stop \"allocate_vca_bath error: nbath==0\"\n      !\n      ! select case(bath_type)\n      ! case default!normal_normal\n      !\n      allocate(vca_bath_%e(nlat,nspin,norb,nbath))  !local energies of the bath per site,orb\n      allocate(vca_bath_%v(nlat,nspin,norb,nbath))  !same-spin hybridization per site,orb\n      !\n      ! case('hybrid')                            !hybrid_normal\n      !    !\n      !    allocate(vca_bath_%e(1,1,nspin,nbath))        !local energies of the bath stand-alone\n      !    allocate(vca_bath_%v(nlat,nspin,norb,nbath))  !same-spin hybridization, connects site,orb to bath sites\n      !    !\n      !    ! case('normal_hybrid')\n      !    !    allocate(vca_bath_%e(nlat,1,nspin,nbath))        !local energies of the bath stand-alone\n      !    !    allocate(vca_bath_%v(nlat,nspin,norb,nbath))  !same-spin hybridization, connects site,orb to bath sites\n      !    !\n      ! end select\n      vca_bath_%e=0d0\n      vca_bath_%v=0d0\n      vca_bath_%status=.true.\n   end subroutine vca_allocate_bath\n"}
{"id": 428, "subroutine": "   subroutine vca_deallocate_bath(vca_bath_)\n      type(effective_bath) :: vca_bath_\n      if(allocated(vca_bath_%e))   deallocate(vca_bath_%e)\n      if(allocated(vca_bath_%v))   deallocate(vca_bath_%v)\n      vca_bath_%status=.false.\n   end subroutine vca_deallocate_bath\n"}
{"id": 429, "subroutine": "   subroutine vca_init_bath(vca_bath_)\n      type(effective_bath) :: vca_bath_\n      integer              :: i,unit,flen,nh\n      integer              :: io,jo,ispin,iorb,jorb,jspin,ilat\n      logical              :: iofile\n      real(8)              :: de,hwband\n      character(len=21)    :: space\n      real,dimension(nbath):: ran\n      !\n      hwband=1d0\n      !\n      if(.not.vca_bath_%status)stop \"vca_init_bath error: bath not allocated\"\n      !\n      if(nbath==0)stop \"vca_allocate_bath error: nbath==0\"\n      !\n      ! !get energies:\n      ! if(nbath==1)then\n      !    vca_bath_%e(:,:,:,nbath)= 0d0\n      ! else\n      !    vca_bath_%e(:,:,:,1)    =-hwband\n      !    vca_bath_%e(:,:,:,nbath)= hwband\n      ! endif\n      ! nh=nbath/2\n      ! if(mod(nbath,2)==0.and.nbath>=4)then\n      !    de=hwband/max(nh-1,1)\n      !    vca_bath_%e(:,:,:,nh)  = -1.d-3\n      !    vca_bath_%e(:,:,:,nh+1)=  1.d-3\n      !    do i=2,nh-1\n      !       vca_bath_%e(:,:,:,i)        =-hwband + (i-1)*de\n      !       vca_bath_%e(:,:,:,nbath-i+1)= hwband - (i-1)*de\n      !    enddo\n      ! elseif(mod(nbath,2)/=0.and.nbath>=3)then\n      !    de=hwband/nh\n      !    vca_bath_%e(:,:,:,nh+1)= 0.0d0\n      !    do i=2,nh\n      !       vca_bath_%e(:,:,:,i)        =-hwband + (i-1)*de\n      !       vca_bath_%e(:,:,:,nbath-i+1)= hwband - (i-1)*de\n      !    enddo\n      ! endif\n      ! ! call random_number(ran)\n      ! ! forall(ilat=1:size(vca_bath_%e,1),iorb=1:size(vca_bath_%e,2),ispin=1:nspin)&\n      ! !      vca_bath_%e(ilat,ispin,iorb,:) = ran !imphloc(ilat,ilat,ispin,iorb,ispin,iorb) + ran/10d0\n      ! !\n      ! !get spin-keep yhbridizations\n      ! do i=1,nbath\n      !    vca_bath_%v(:,:,:,i)=max(0.1d0,1.d0/sqrt(dble(nbath)))\n      ! enddo\n      !\n      !\n      vca_bath_%e = 1d0\n      vca_bath_%v = 0d0\n      !\n      !\n      !read from file if exist:\n      !\n      inquire(file=\"bath.restart\",exist=iofile)\n      if(iofile)then\n         write(logfile,\"(a)\")\"reading bath from file bath.restart\"\n         unit = free_unit()\n         !\n         open(unit,file=\"bath.restart\")\n         !\n         read(unit,*)          !read the header:\n         ! select case(bath_type)\n         ! case default\n         do ilat=1,nlat\n            do i=1,nbath\n               read(unit,*)((&\n                  vca_bath_%e(ilat,ispin,iorb,i),&\n                  vca_bath_%v(ilat,ispin,iorb,i),&\n                  iorb=1,norb),ispin=1,nspin)\n            enddo\n         enddo\n         !\n         ! case ('hybrid')\n         !    do ilat=1,nlat\n         !       do i=1,nbath\n         !          read(unit,*)(&\n         !               vca_bath_%e(1,1,ispin,i),&\n         !               (&\n         !               vca_bath_%v(ilat,ispin,iorb,i),&\n         !               iorb=1,norb),ispin=1,nspin)\n         !       enddo\n         !    enddo\n         ! end select\n         close(unit)\n      endif\n   end subroutine vca_init_bath\n"}
{"id": 430, "subroutine": "   subroutine vca_write_bath(vca_bath_,unit)\n      type(effective_bath) :: vca_bath_\n      integer,optional     :: unit\n      integer              :: unit_\n      integer              :: i\n      character(len=7)     :: sitestring\n      integer              :: io,jo,ispin,iorb,ilat\n      complex(8)           :: hybr_aux\n      complex(8)           :: hrep_aux(nspin*norb,nspin*norb)\n      !\n      unit_=logfile;if(present(unit))unit_=unit\n      !\n      if(.not.vca_bath_%status)stop \"write_vca_bath error: bath not allocated\"\n      !\n      ! select case(bath_type)\n      ! case default\n      if(unit_==logfile) then\n         write(unit_, \"(a7)\") \"\"\n         write(unit_, \"(a7)\", advance=\"no\") \"\"\n         write(unit_,\"(90(a12,1x))\")((&\n            \"ek_l\"//str(iorb)//\"_s\"//str(ispin),\"vk_l\"//str(iorb)//\"_s\"//str(ispin),&\n            iorb=1,norb),ispin=1,nspin)\n         do ilat=1,nlat\n            sitestring=\"site \"//str(ilat,2)\n            do i=1,nbath\n               write(unit_, \"(a7)\", advance=\"no\") sitestring\n               write(unit_,\"(90(f12.4,1x))\")((&\n                  vca_bath_%e(ilat,ispin,iorb,i),&\n                  vca_bath_%v(ilat,ispin,iorb,i),&\n                  iorb=1,norb),ispin=1,nspin)\n               sitestring=\"\"\n            enddo\n         enddo\n         write(unit_, \"(a7)\") \"\"\n      else\n         write(unit_,\"(90(a21,1x))\")((&\n            \"#ek_l\"//str(iorb)//\"_s\"//str(ispin),\"vk_l\"//str(iorb)//\"_s\"//str(ispin),&\n            iorb=1,norb),ispin=1,nspin)\n         do ilat=1,nlat\n            do i=1,nbath\n               write(unit_,\"(90(f21.12,1x))\")((&\n                  vca_bath_%e(ilat,ispin,iorb,i),&\n                  vca_bath_%v(ilat,ispin,iorb,i),&\n                  iorb=1,norb),ispin=1,nspin)\n            enddo\n         enddo\n\n      endif\n      !\n      ! case('hybrid')\n      !    !\n      !    write(unit_,\"(90(a21,1x))\")(&\n      !         \"#ek_s\"//reg(txtfy(ispin)),(\"vk_l\"//reg(txtfy(iorb))//\"_s\"//reg(txtfy(ispin)),&\n      !         iorb=1,norb),ispin=1,nspin)\n      !    do ilat=1,nlat\n      !       do i=1,nbath\n      !          write(unit_,\"(90(f21.12,1x))\")(&\n      !               vca_bath_%e(ilat,1,ispin,i),&\n      !               (vca_bath_%v(ilat,ispin,iorb,i),&\n      !               iorb=1,norb),ispin=1,nspin)\n      !       enddo\n      !    enddo\n      ! end select\n   end subroutine vca_write_bath\n"}
{"id": 431, "subroutine": "   subroutine vca_save_bath(vca_bath_,file,used)\n      type(effective_bath)      :: vca_bath_\n      character(len=*),optional :: file\n      character(len=256)        :: file_\n      logical,optional          :: used\n      logical                   :: used_\n      character(len=16)         :: extension\n      integer                   :: unit_\n      !\n      if(.not.vca_bath_%status)stop \"save_vca_bath error: bath is not allocated\"\n      !\n      used_=.false.;if(present(used))used_=used\n      extension=\".restart\";if(used_)extension=\".used\"\n      !\n      file_=\"bath\"//reg(extension)\n      if(present(file))file_=reg(file)\n      unit_=free_unit()\n      open(unit_,file=reg(file_))\n      call vca_write_bath(vca_bath_,unit_)\n      close(unit_)\n   end subroutine vca_save_bath\n"}
{"id": 432, "subroutine": "   subroutine vca_set_bath(bath_,vca_bath_)\n      real(8),dimension(:)   :: bath_\n      type(effective_bath)   :: vca_bath_\n      integer                :: stride,io,jo,i\n      integer                :: ispin,iorb,jorb,jspin,ibath,ilat\n      logical                :: check\n      complex(8)             :: hrep_aux(nspin*norb,nspin*norb)\n      complex(8)             :: u(nspin*norb,nspin*norb)\n      complex(8)             :: udag(nspin*norb,nspin*norb)\n      real(8)                :: element_r,element_i,eps_k,lambda_k\n      !\n      if(.not.vca_bath_%status)stop \"set_vca_bath error: bath not allocated\"\n      !\n      check = check_bath_dimension(bath_)\n      if(.not.check)stop \"set_vca_bath error: wrong bath dimensions\"\n      !\n      ! select case(bath_type)\n      ! case default\n      stride = 0\n      do ilat=1,nlat\n         do iorb=1,norb\n            do ispin=1,nspin\n               do i=1,nbath\n                  io = stride + i + (iorb-1)*nbath + (ilat-1)*nbath*norb + (ispin-1)*nbath*norb*nlat\n                  vca_bath_%e(ilat,ispin,iorb,i) = bath_(io)\n               enddo\n            enddo\n         enddo\n      enddo\n      stride = nlat*nspin*norb*nbath\n      do ilat=1,nlat\n         do iorb=1,norb\n            do ispin=1,nspin\n               do i=1,nbath\n                  io = stride + i + (iorb-1)*nbath + (ilat-1)*nbath*norb + (ispin-1)*nbath*norb*nlat\n                  vca_bath_%v(ilat,ispin,iorb,i) = bath_(io)\n               enddo\n            enddo\n         enddo\n      enddo\n      !\n      if(hfmode)then\n         do ilat=1,nlat\n            do iorb=1,norb\n               do ispin=1,nspin\n                  do i=1,nbath\n                     if( .not. hfshift) vca_bath_%e(ilat,ispin,iorb,i) = vca_bath_%e(ilat,ispin,iorb,i)-(0.5d0*uloc(iorb)+0.5d0*ust*(norb-1)+0.5d0*(ust-jh)*(norb-1))\n                  enddo\n               enddo\n            enddo\n         enddo\n      endif\n      !\n      ! case ('hybrid')\n      !    stride = 0\n      !    do ispin=1,nspin\n      !       do i=1,nbath\n      !          io = stride + i + (ispin-1)*nbath\n      !          vca_bath_%e(1,1,ispin,i) = bath_(io)\n      !       enddo\n      !    enddo\n      !    stride = nspin*nbath\n      !    do ilat=1,nlat\n      !       do iorb=1,norb\n      !          do ispin=1,nspin\n      !             do i=1,nbath\n      !                io = stride + i + index_stride_los(ilat,ispin,iorb)\n      !                vca_bath_%v(ilat,ispin,iorb,i) = bath_(io)\n      !             enddo\n      !          enddo\n      !       enddo\n      !    enddo\n      ! end select\n   end subroutine vca_set_bath\n"}
{"id": 433, "subroutine": "   subroutine set_bath_component(bath_,ilat,ispin,iorb,e_component,v_component)\n      real(8),dimension(:),allocatable        :: bath_\n      integer                                 :: stride,io,jo,i\n      integer                                 :: ispin,iorb,jorb,jspin,ibath,ilat\n      logical                                 :: check, is_e\n      complex(8)                              :: hrep_aux(nspin*norb,nspin*norb)\n      complex(8)                              :: u(nspin*norb,nspin*norb)\n      complex(8)                              :: udag(nspin*norb,nspin*norb)\n      real(8),dimension(nbath),optional       :: e_component,v_component\n      !\n      !\n      !\n      ! select case(bath_type)\n      ! case default\n      if(present(e_component))then\n         stride = 0\n         do i=1,nbath\n            io = stride + i + (iorb-1)*nbath + (ilat-1)*nbath*norb + (ispin-1)*nbath*norb*nlat\n            bath_(io) = e_component(i)\n         enddo\n      endif\n      if(present(v_component))then\n         stride = nlat*nspin*norb*nbath\n         do i=1,nbath\n            io = stride + i + (iorb-1)*nbath + (ilat-1)*nbath*norb + (ispin-1)*nbath*norb*nlat\n            bath_(io) = v_component(i)\n         enddo\n      endif\n      !\n      ! case ('hybrid')\n      !    stride = 0\n      !    do ispin=1,nspin\n      !       do i=1,nbath\n      !          io = stride + i + (ispin-1)*nbath\n      !          vca_bath_%e(1,1,ispin,i) = bath_(io)\n      !       enddo\n      !    enddo\n      !    stride = nspin*nbath\n      !    do ilat=1,nlat\n      !       do iorb=1,norb\n      !          do ispin=1,nspin\n      !             do i=1,nbath\n      !                io = stride + i + index_stride_los(ilat,ispin,iorb)\n      !                vca_bath_%v(ilat,ispin,iorb,i) = bath_(io)\n      !             enddo\n      !          enddo\n      !       enddo\n      !    enddo\n      ! end select\n   end subroutine set_bath_component\n"}
{"id": 434, "subroutine": "  subroutine should_be_int(val, rslt)\n    integer, intent(in) :: val, rslt\n    if (should_print(3)) write (*,*) '      value: ', val, ' should be ', rslt, proc_message()\n  end subroutine should_be_int\n"}
{"id": 435, "subroutine": "  subroutine announce_test(test_name)\n    character(*), intent(in) :: test_name\n    if (should_print(1)) write (*,*) '--> testing ', test_name, proc_message()\n  end subroutine announce_test\n"}
{"id": 436, "subroutine": "  subroutine process_test(rslt, test_name)\n    use mp, only: mp_abort, mp_initialized\n    logical, intent (in) :: rslt\n    character(*), intent(in) :: test_name\n    if (.not. rslt) then \n      write(*,*) '--> ', test_name, ' failed', proc_message()\n      if (mp_initialized) then \n        call mp_abort('failed test', .true.)\n      else\n        stop 1\n      end if\n    end if\n\n    if (should_print(1)) write (*,*) '--> ', test_name, ' passed', proc_message()\n  end subroutine process_test\n"}
{"id": 437, "subroutine": "  subroutine announce_check(test_name)\n    character(*), intent(in) :: test_name\n    if (should_print(2)) write (*,*) '   --> checking ', test_name, proc_message()\n  end subroutine announce_check\n"}
{"id": 438, "subroutine": "  subroutine process_check(test_result, rslt, test_name)\n    logical, intent (inout) :: test_result\n    logical, intent (in) :: rslt\n    character(*), intent(in) :: test_name\n    if (.not. rslt) then \n       write(*,*) '   --> ', test_name, ' failed', proc_message()\n    else\n       if (should_print(2)) write (*,*) '   --> ', test_name, ' passed', proc_message()\n    end if\n    test_result = test_result .and. rslt\n  end subroutine process_check\n"}
{"id": 439, "subroutine": "  subroutine announce_module_test(module_name)\n    character(*), intent(in) :: module_name\n    character(8) :: message = 'testing '\n    if (should_print(1)) call print_with_stars(message, module_name)\n  end subroutine announce_module_test\n"}
{"id": 440, "subroutine": "  subroutine close_module_test(module_name)\n    character(*), intent(in) :: module_name\n    character(17) :: message = 'finished testing '\n    if (should_print(1)) call print_with_stars(message, module_name)\n    write (*,*)\n  end subroutine close_module_test\n"}
{"id": 441, "subroutine": "  subroutine print_with_stars(str1, str2)\n    character(*), intent (in) :: str1, str2\n    character, dimension(:), allocatable :: stars\n    integer :: i\n\n    allocate(stars(len(str1) + len(str2) + len(proc_message()) ))\n    do i = 1,len(str1)+len(str2)+len(proc_message())\n       stars(i) = '*'\n    end do\n\n    write (*,*) stars\n    write (*,*) str1, str2, proc_message()\n    write (*,*) stars\n  end subroutine print_with_stars\n"}
{"id": 442, "subroutine": "  subroutine debug_message(verbosity_level, message)\n    use mp, only: iproc, mp_initialized\n    integer, intent(in) :: verbosity_level\n    character(*), intent(in) :: message\n    if (mp_initialized) then \n      if (should_print(verbosity_level)) write (*,\"(a,a5,i6,a7,i6)\") message, \" jid=\", job_id, &\n        \" iproc=\", iproc\n    else\n      if (should_print(verbosity_level)) write (*,\"(a,a5,i6,a7,i6)\") message, \" jid=\", job_id\n    end if\n  end subroutine debug_message\n"}
{"id": 443, "subroutine": "  subroutine set_job_id(jid)\n    integer, intent(in) :: jid\n    job_id = jid\n  end subroutine set_job_id\n"}
{"id": 444, "subroutine": "subroutine c()\n call a()\nend subroutine c\n"}
{"id": 445, "subroutine": "subroutine a()\nend subroutine a\n"}
{"id": 446, "subroutine": " subroutine b()\n   call c()\n end subroutine\n"}
{"id": 447, "subroutine": "    subroutine sn_assign(sn1,sn2)\n        class(splay_node),intent(inout):: sn1\n        type(splay_node),intent(in):: sn2\n\n        sn1%left = sn2%left\n        sn1%right = sn2%right\n        sn1%parent = sn2%parent\n        sn1%size = sn2%size\n        sn1%value = sn2%value\n    end subroutine\n"}
{"id": 448, "subroutine": "    subroutine sn_rotate(sn)\n        class(splay_node),intent(inout):: sn\n        type(splay_node),pointer:: pp, p, c\n\n        p = sn%parent\n        pp = pp%parent\n\n        if (p%left == sn) then\n            c = sn%right\n            sn%right = p\n            p%left = c\n        else\n            c = sn%left\n            sn%left = p\n            p%right = c\n        end if\n\n        if (associated(pp)) then\n            if (pp%left == p) pp%left = sn\n            if (pp%right == p) pp%right = sn\n        end if\n        sn%parent = pp\n        p%parent = sn\n        c%parent = p\n\n        call p%update()\n        call sn%update()\n    end subroutine\n"}
{"id": 449, "subroutine": "    subroutine sn_splay(sn)\n        class(splay_node):: sn\n\n        do while(sn%has_parent())\n            if (sn%parent%state() == 0) then ! \u89aa\u306e\u89aa\u304c\u3044\u306a\u3044\n                call sn%rotate()\n            else if (sn%state() == sn%parent%state()) then ! me->p->pp\u304c\u76f4\u7dda\n                call sn%parent%rotate()\n                call sn%rotate()\n            else ! me->p->pp\u304c\u6298\u308c\u7dda\n                call sn%rotate()\n                call sn%rotate()\n            end if\n        end do\n    end subroutine\n"}
{"id": 450, "subroutine": "    subroutine sn_update(sn)\n        class(splay_node):: sn\n\n        sn%size = 1\n        if (sn%has_left()) sn%size = sn%size+sn%left%size\n        if (sn%has_right()) sn%size = sn%size+sn%right%size\n    end subroutine\n"}
{"id": 451, "subroutine": "subroutine determine_time_levels(iyy1,imm1,idd1,ihh1,&\n       iyy2,imm2,idd2,ihh2,dth,ntime,iyy,imm,idd,ihh,&\n       maxtim)\n!$$$  subprogram documentation block\n!                .      .    .                                       .\n! subprogram:    determine_time_levels                deter time levls\n!   prgmmr: treadon          org: np20                date: 2005-07-22\n!\n! abstract:  this routine counts the number of time levels\n!            between date1 and date2 when stepping by dth\n!            hours.\n!\n! program history log:\n!   2005-07-22 treadon - original code\n!\n!   input argument list:\n!     iyy1,imm1,idd1,ihh1 - starting year,month,day,hour\n!     iyy2,imm2,idd2,ihh2 - ending year,month,day,hour\n!     dth - time increment in hours\n!\n!   output argument list:\n!     ntime - number of time levels between date1 and date2\n!     iyy,imm,idd,ihh - array containing each time level\n!\n! attributes:\n!   language: f90\n!   machine:  ibm rs/6000 sp\n!\n!$$$\n  implicit none\n  \n  real,parameter:: zero = 0.0\n\n  logical:: done\n  integer:: iyy1,imm1,idd1,ihh1,iyy2,imm2,idd2,ihh2\n  integer:: ntime,maxtim\n  integer,dimension(maxtim):: iyy,imm,idd,ihh\n  integer,dimension(8):: ida,jda,lda\n  real:: dth\n  real,dimension(5):: fha\n\n!---------------------------------------------------------------------------\n! load date/time arrays with starting and ending time levels\n  fha=zero\n  ida=0; lda=0\n  fha(2)=dth\n  ida(1)=iyy1\n  ida(2)=imm1\n  ida(3)=idd1\n  ida(4)=0\n  ida(5)=ihh1\n  jda=ida\n\n  lda(1)=iyy2\n  lda(2)=imm2\n  lda(3)=idd2\n  lda(4)=0\n  lda(5)=ihh2\n\n! use w3 routine w3movdat to step from date1 to date2\n! at the interval of dth hours.  count the number of\n! time levels between date1 and date2.\n\n  ntime=0\n  done=.false.\n  do while (.not.done)\n     ntime=ntime+1\n     if (ntime>maxtim) then\n        write(6,*)'global_angupdate:  ***warning*** ntime=',ntime,' > ',maxtim\n        ntime=maxtim\n     endif\n\n     if ( (jda(1)==lda(1)) .and. (jda(2)==lda(2)) .and. &\n          (jda(3)==lda(3)) .and. (jda(5)==lda(5)) ) then\n        done = .true.\n     endif\n\n     iyy(ntime)=jda(1)\n     imm(ntime)=jda(2)\n     idd(ntime)=jda(3)\n     ihh(ntime)=jda(5)\n\n     ida=jda\n     jda=0\n     call w3movdat(fha,ida,jda)\n\n  end do\n  return\nend subroutine determine_time_levels\n"}
{"id": 452, "subroutine": "subroutine preparation\n  use global_variables\n  implicit none\n  integer :: ikr,ikz,ik\n\n\n  nkrz = nkr*(2*nkz+1)\n  nkrz_ave=nkrz/nprocs; nkrz_remainder=mod(nkrz,nprocs)\n  if (nkrz_remainder == 0) then\n    nkrz_s=nkrz_ave*myrank+1\n    nkrz_e=nkrz_ave*(myrank+1)\n  else\n    if (myrank +1 <= nkrz_remainder) then\n      nkrz_s=(nkrz_ave+1)*myrank+1\n      nkrz_e=nkrz_s + (nkrz_ave+1)-1 !(nkrz_ave+1)*(myrank+1)\n    else\n      nkrz_s=(nkrz_ave+1)*nkrz_remainder + nkrz_ave*(myrank-nkrz_remainder)+1\n      nkrz_e=nkrz_s + nkrz_ave-1\n    end if\n  end if\n\n  if(myrank==0)then\n    write(*,\"(a,2x,i7)\")\"nkrz=\",nkrz\n    write(*,\"(a,2x,i7)\")\"nkrz_ave\",nkrz_ave\n    write(*,\"(a,2x,i7)\")\"nkrz_remainder\",nkrz_remainder\n  end if\n!  write(*,\"(9i9)\")myrank,nkrz_s,nkrz_e\n\n  allocate(zct(3,1,nkrz_s:nkrz_e),eps(3,nkrz_s:nkrz_e))\n  allocate(kz0(-nkz:nkz),kz(-nkz:nkz),kr(nkr))\n  allocate(ikr_table(nkrz),ikz_table(nkrz))\n  zct = 0d0; zct(1,1,:) = 1d0\n  eps = 0d0\n\n! table\n  ik = 0\n  do ikr = 1,nkr\n    do ikz = -nkz,nkz\n      ik = ik + 1\n      ikr_table(ik) = ikr\n      ikz_table(ik) = ikz\n    end do\n  end do\n  \n\n  dkr = kr_max/dble(nkr)\n  dkz = kz_max/dble(nkz)\n\n  do ikz = -nkz,nkz\n    kz0(ikz) = dkz*dble(ikz)\n  end do\n  kz = kz0\n\n  do ikr = 1,nkr\n    kr(ikr) = dkr*dble(ikr)\n  end do\n\n  do ik = nkrz_s,nkrz_e\n    ikr = ikr_table(ik)\n    ikz = ikz_table(ik)\n    kz(ikz) = kz0(ikz)\n    eps(1,ik) = eps_d\n    eps(2,ik) = eps_c1 +0.5d0/mass_c1*(kr(ikr)**2+kz(ikz)**2)\n    eps(3,ik) = eps_c2 +0.5d0/mass_c2*(kr(ikr)**2+kz(ikz)**2)\n  end do\n\nend subroutine preparation\n"}
{"id": 453, "subroutine": "      subroutine sir(u, params)\n      double precision, dimension(0:3) :: u\n      double precision, dimension(0:4) :: params\n      double precision s, i, r, y, beta, gamma, iota, n, delta_t\n      double precision lambda_, ifrac, rfrac, infection, recovery\n      double precision randbn\n\n      s = u(0)\n      i = u(1)\n      r = u(2)\n      y = u(3)\n      \n      beta = params(0)\n      gamma = params(1)\n      iota = params(2)\n      n = params(3)\n      delta_t = params(4)      \n\n      lambda_ = beta * (i + iota) / n\n      ifrac = 1.0 - exp(-lambda_ * delta_t)\n      rfrac = 1.0 - exp(-gamma * delta_t)\n      infection = randbn(s, ifrac)\n      recovery = randbn(i, rfrac)\n\nc     set the return values\n      u(0) = s - infection\n      u(1) = i + infection - recovery\n      u(2) = r + recovery\n      u(3) = y + infection\n\n      end subroutine sir\n"}
{"id": 454, "subroutine": "      subroutine simulate()\n      integer, parameter :: tf = 200\n      integer, parameter :: tl = tf/0.1\n      integer j\n      double precision, dimension(0:tl) :: t, s, i, r, y\n      double precision, dimension(0:3) :: u0, u\n      double precision, dimension(0:4) :: params, returns\n      double precision tmp, pyrand\n\n      tmp = pyrand(.true.)    ! initialize\n\n      params(0)= 0.1\n      params(1) = 0.05\n      params(2) = 0.01\n      params(3) = 1000.0\n      params(4) = 0.1\n\n      do j = 1, tl\n         s(j) = 0.0\n         i(j) = 0.0\n         r(j) = 0.0\n         y(j) = 0.0\n      end do\n\n      u0(0) = 999.0\n      u0(1) = 1.0\n      u0(2) = 0.0\n      u0(3) = 0.0\n      \n      s(0) = u0(0)\n      i(0) = u0(1)\n      r(0) = u0(2)\n      y(0) = u0(3)\n\n      do j = 0, 3\n         u(j) = u0(j)\n      end do\n\n      u = u0\n      \n      do j = 1, tl\n         call sir(u, params)\n         s(j) = u(0)\n         i(j) = u(1)\n         r(j) = u(2)\n         y(j) = u(3)\n      end do\n\n      call print_output(tl, s, i, r, y)\n      \n      end subroutine simulate\n"}
{"id": 455, "subroutine": "      subroutine print_output(tl, s, i, r, y)\n      integer tl\n      double precision, dimension(0:tl) :: s, i, r, y\n      \n 10   format(\"[\", 3(x,f4.0), \" ...\", 3(x,f4.0), \"]\")\n      write (*, 10) s(1), s(2), s(3), s(tl-2), s(tl-1), s(tl)\n      write (*, 10) i(1), i(2), i(3), i(tl-2), i(tl-1), i(tl)\n      write (*, 10) r(1), r(2), r(3), r(tl-2), r(tl-1), r(tl)\n      write (*, 10) y(1), y(2), y(3), y(tl-2), y(tl-1), y(tl)\n      end subroutine print_output\n"}
{"id": 456, "subroutine": "    subroutine init(self)   \n        class(mnph_artificial_viscosity_t), intent(inout)   :: self\n\n        integer                                     :: unit, msg\n        logical                                     :: file_exists, use_lift, elem_avg\n\n        namelist /av_options/ elem_avg\n\n\n\n\n        call self%set_name('mnph artificial viscosity')\n        call self%set_dependency('f(grad(q))')\n\n        call self%add_model_field('artificial viscosity')\n        call self%add_model_field('artificial viscosity - 1')\n        call self%add_model_field('artificial viscosity - 2')\n        call self%add_model_field('artificial viscosity - 3')\n\n        !!\n        !! check if input from 'models.nml' is available.\n        !!   1: if available, read and set self%mu\n        !!   2: if not available, do nothing and mu retains default value\n        !!\n        !inquire(file='models.nml', exist=file_exists)\n        !if (file_exists) then\n        !    open(newunit=unit,form='formatted',file='models.nml')\n        !    read(unit,nml=mnph_artificial_viscosity_unsmoothed_ani,iostat=msg)\n        !    if (msg == 0) self%av_constant = av_constant\n        !    close(unit)\n        !end if\n\n        inquire(file='artificial_viscosity.nml', exist=file_exists)\n         if (file_exists) then\n             open(newunit=unit,form='formatted',file='artificial_viscosity.nml')\n             read(unit,nml=av_options,iostat=msg)\n             if (msg == 0) self%elem_avg  = elem_avg\n             close(unit)\n         end if\n\n\n    end subroutine init\n"}
{"id": 457, "subroutine": "    subroutine compute(self,worker)\n        class(mnph_artificial_viscosity_t), intent(in)      :: self\n        type(chidg_worker_t),               intent(inout)   :: worker\n\n        type(ad_d), dimension(:),   allocatable :: &\n            density, vel1, vel2, vel3, t, c, wave_speed, sensor, av, av1, av2, av3, avtemp, temp_av\n\n        real(rk), dimension(:)  :: h(3)\n        real(rk)                :: hmin\n        real(rk)                :: pr_star  = 0.9_rk     \n\n        integer(ik)             :: p, ii, nvertex, inode, ivertex, idom, ielem, idom_g, inode_g\n        real(rk), allocatable   :: eval_node1(:), eval_node2(:), eval_node3(:), nodes(:,:), h_field(:,:), h_scalar(:)\n        real(rk)                :: eval_node(3), center(3), radius(3), vert_vals_hmin(8)\n\n        real(rk), allocatable, dimension(:) :: weights, jinv\n        idom = worker%element_info%idomain_l\n        ielem = worker%element_info%ielement_l\n\n        idom_g = worker%element_info%idomain_g\n\n\n        h_field = worker%h_smooth()\n\n        select case (trim(h_field_dimension))\n            case('2d','2d')\n                h_scalar = (h_field(:,1) + h_field(:,2))/two\n            case('3d','3d')\n                h_scalar = (h_field(:,1) + h_field(:,2) + h_field(:,3))/three\n            case default\n                call chidg_signal(fatal,'mnph_artificial_viscosity: invalid input for h_field_dimension (2d,3d).')\n\n        end select\n        !h_scalar = (h_field(:,1)*h_field(:,2)*h_field(:,3))**(one/three)\n        !h_scalar = one\n\n        p = worker%solution_order('interior')\n        if (p == 0) p = 1\n        h_scalar = h_scalar/real(p, rk)\n        h_field = h_field/real(p,rk)\n        \n        \n        sensor = worker%get_field('mnph shock sensor', 'value')\n        density = worker%get_field('density','value')\n\n        vel1 = worker%get_field('momentum-1','value')\n        vel2 = worker%get_field('momentum-2','value')\n        vel3 = worker%get_field('momentum-3','value')\n\n        vel1 = vel1/(density)\n        vel2 = vel2/(density)\n        vel3 = vel3/(density)\n\n        c = worker%get_field('pressure', 'value')\n\n        wave_speed = c\n        c = (gam*wave_speed/(density))\n        c = c*sin_ramp(c, zero, one)\n        wave_speed = sqrt(vel1**two+vel2**two+vel3**two+c)\n\n        av = 1.0_rk*(1.5_rk*h_scalar)*wave_speed*sensor\n        \n        !avtemp = av\n        !av = sin_ramp2(avtemp,0.01_rk*1.5_rk*h_scalar*wave_speed, 1.5_rk*h_scalar*wave_speed)\n        !if (self%elem_avg) then\n        !    if (worker%interpolation_source == 'element') then\n        !        weights = worker%quadrature_weights('element')\n        !        jinv    = worker%inverse_jacobian('element')\n\n        !        temp_av = av\n\n        !        temp_av = sum(weights*jinv*av)/sum(weights*jinv)\n\n        !        av = temp_av\n\n        !    else\n        !        weights = worker%quadrature_weights('face')\n        !        jinv    = worker%inverse_jacobian('face')\n\n        !        temp_av = av\n\n        !        temp_av = sum(weights*jinv*av)/sum(weights*jinv)\n\n        !        av = temp_av\n\n        !    end if\n\n        !end if\n\n\n        if (any(ieee_is_nan(av(:)%x_ad_))) print *, 'unsmoothed av is nan'\n        if (any(ieee_is_nan(av(:)%x_ad_))) print *, worker%interpolation_source\n        \n\n        av1 = 1.5_rk*(h_field(:,1))*wave_speed*sensor\n        av2 = 1.5_rk*(h_field(:,2))*wave_speed*sensor\n        av3 = 1.5_rk*(h_field(:,3))*wave_speed*sensor\n\n        !av1 = 1.0_rk*(1.5_rk*h_field(:,1))*wave_speed*sensor\n        !av2 = 1.0_rk*(1.5_rk*h_field(:,2))*wave_speed*sensor\n        !av3 = 1.0_rk*(1.5_rk*h_field(:,3))*wave_speed*sensor\n        !print *, 'unsmoothed av: ', av(1)%x_ad_\n\n        !! average to improve robustness\n        !if (worker%interpolation_source == 'element') then\n        !    weights = worker%quadrature_weights('element')\n        !    jinv    = worker%inverse_jacobian('element')\n\n        !    av2 = av\n        !    av = sum(weights*jinv*av2)/sum(weights*jinv)\n\n        !else \n        !    weights = worker%quadrature_weights('face')\n        !    jinv    = worker%inverse_jacobian('face')\n\n        !    av2 = av\n        !    av = sum(weights*jinv*av2)/sum(weights*jinv)\n\n\n        !end if\n       \n        !\n        ! contribute laminar viscosity\n        !\n        call worker%store_model_field('artificial viscosity', 'value', av)\n        call worker%store_model_field('artificial viscosity - 1', 'value', av1)\n        call worker%store_model_field('artificial viscosity - 2', 'value', av2)\n        call worker%store_model_field('artificial viscosity - 3', 'value', av3)\n\n\n    end subroutine compute\n"}
{"id": 458, "subroutine": "subroutine iosys()\n  !-----------------------------------------------------------------------------\n  !\n\n  ! ...  use \"-input filename\" to read input from file \"filename\":\n  ! ...  may be useful if you have trouble reading from standard input\n  ! ...  ---------------------------------------------------------------\n  !\n  ! ...  access the modules renaming the variables that have the same name\n  ! ...  as the input parameters, this is required in order to use a code\n  ! ...  independent input parser\n  !\n  !\n  use kinds,         only : dp\n  use control_flags, only: adapt_thr, tr2_init, tr2_multi\n  use constants,     only : autoev, ev_to_kelvin, pi, rytoev, &\n                            ry_kbar, amconv, bohr_radius_angs, eps8\n  use mp_global,     only : npool, nproc_pool\n  !\n  use io_global,     only : stdout, ionode, ionode_id\n  !\n  !\n  use mp,            only : mp_bcast\n  !\n  !\n  use cell_base,     only : at, alat, omega, &\n                            cell_base_init, init_dofree\n  !\n  use ions_base,     only : if_pos, ityp, tau, extfor, &\n                            ntyp_ => nsp, &\n                            nat_  => nat, &\n                            amass, tau_format\n  !\n  use basis,         only : startingconfig, starting_wfc, starting_pot\n  !\n  use run_info,      only : title_ => title\n  !\n  !\n  use extfield,      only : tefield_  => tefield, &\n                            dipfield_ => dipfield, &\n                            edir_     => edir, &\n                            emaxpos_  => emaxpos, &\n                            eopreg_   => eopreg, &\n                            eamp_     => eamp, &\n                            forcefield\n  !\n  use io_files,      only : input_drho, output_drho, &\n                            psfile, tmp_dir, wfc_dir, &\n                            prefix_     => prefix, &\n                            pseudo_dir_ => pseudo_dir\n  !\n  use force_mod,     only : lforce, lstres, force\n  !\n  use gvecs,         only : dual\n  use gvect,         only : ecutrho_ => ecutrho\n  !\n  use fft_base, only : dfftp\n  use fft_base, only : dffts\n  !\n  use klist,         only : lgauss, ngauss, two_fermi_energies, &\n                            smearing_          => smearing, &\n                            degauss_           => degauss, &\n                            tot_charge_        => tot_charge, &\n                            tot_magnetization_ => tot_magnetization\n  !\n  use ktetra,        only : ltetra\n  use start_k,       only : init_start_k\n  !\n  !\n  use a2f,           only : la2f_ => la2f\n  !\n  !\n  !\n  use lsda_mod,      only : nspin_                  => nspin, &\n                            starting_magnetization_ => starting_magnetization, &\n                            lsda\n  !\n  use relax,         only : epse, epsf, epsp, starting_scf_threshold\n  !\n  use control_flags, only : isolve, max_cg_iter, david, tr2, imix, gamma_only,&\n                            nmix, iverbosity, niter, pot_order, wfc_order, &\n                            remove_rigid_rot_ => remove_rigid_rot, &\n                            diago_full_acc_   => diago_full_acc, &\n                            tolp_             => tolp, &\n                            upscale_          => upscale, &\n                            mixing_beta_      => mixing_beta, &\n                            nstep_            => nstep, &\n                            iprint_           => iprint, &\n                            noinv_            => noinv, &\n                            lkpoint_dir_      => lkpoint_dir, &\n                            tqr_              => tqr, &\n                            io_level, ethr, lscf, lbfgs, lmd, &\n                            ldamped, lbands, llang,           &\n                            lconstrain, restart, twfcollect, &\n                            lecrpa_           => lecrpa\n  !\n  use wvfct,         only : nbnd_ => nbnd, &\n                            ecutwfc_ => ecutwfc, &\n                            ecfixed_ => ecfixed, &\n                            qcutz_   => qcutz, &\n                            q2sigma_ => q2sigma\n  !\n  use fixed_occ,     only : tfixed_occ, f_inp, &\n                            one_atom_occupations_ => one_atom_occupations\n  !\n  !\n  use spin_orb, only : lspinorb_ => lspinorb,  &\n                       starting_spin_angle_ => starting_spin_angle\n\n  !\n  use symm_base, only : no_t_rev_ => no_t_rev, nofrac, allfrac, &\n                        nosym_ => nosym, nosym_evc_=> nosym_evc\n  !\n\n  use read_pseudo_mod,       only : readpp\n\n  !\n  ! ... control namelist\n  !\n  use input_parameters, only : title, calculation, verbosity, restart_mode,    &\n                               nstep, iprint, tstress, tprnfor, dt, outdir,    &\n                               wfcdir, prefix, etot_conv_thr, forc_conv_thr,   &\n                               pseudo_dir, disk_io, tefield, dipfield,         &\n                               wf_collect,                                    &\n                               lkpoint_dir, lecrpa \n  !\n  ! ... system namelist\n  !\n  use input_parameters, only : ibrav, celldm, a, b, c, cosab, cosac, cosbc, &\n                               nat, ntyp, nbnd,tot_charge,tot_magnetization,&\n                               ecutwfc, ecutrho, nr1, nr2, nr3, nr1s, nr2s, &\n                               nr3s, noinv, nosym, nosym_evc, no_t_rev,     &\n                               use_all_frac, force_symmorphic,              &\n                               starting_magnetization,                      &\n                               occupations, degauss, smearing, nspin,       &\n                               ecfixed, qcutz, q2sigma, lda_plus_u,         &\n                               lda_plus_u_kind, hubbard_u, hubbard_j,       &\n                               hubbard_alpha, input_dft, la2f,              &\n                               starting_ns_eigenvalue, u_projection_type,   &\n                               x_gamma_extrapolation, nqx1, nqx2, nqx3,     &\n                               exxdiv_treatment, yukawa, ecutvcut,          &\n                               exx_fraction, screening_parameter, ecutfock, &\n                               edir, emaxpos, eopreg, eamp, &\n                               constrained_magnetization,     &\n                               b_field, fixed_magnetization, lspinorb,&\n                               starting_spin_angle,                           &\n                               assume_isolated, spline_ps,                    &\n                               one_atom_occupations \n  !\n  ! ... electrons namelist\n  !\n  use input_parameters, only : electron_maxstep, mixing_mode, mixing_beta, &\n                               mixing_ndim, mixing_fixed_ns, conv_thr,     &\n                               tqr, diago_thr_init, diago_cg_maxiter,      &\n                               diago_david_ndim, diagonalization,          &\n                               diago_full_acc, startingwfc, startingpot,   &\n                               real_space\n  use input_parameters, only : adaptive_thr, conv_thr_init, conv_thr_multi\n  !\n  ! ... ions namelist\n  !\n  use input_parameters, only : phase_space, ion_dynamics, ion_positions, tolp, &\n                               tempw, delta_t, nraise, ion_temperature,        &\n                               refold_pos, remove_rigid_rot, upscale,          &\n                               pot_extrapolation,  wfc_extrapolation,          &\n                               w_1, w_2, trust_radius_max, trust_radius_min,   &\n                               trust_radius_ini, bfgs_ndim\n  !\n  ! ... cell namelist\n  !\n  use input_parameters, only : cell_parameters, cell_dynamics, press, wmass,  &\n                               cell_temperature, cell_factor, press_conv_thr, &\n                               cell_dofree\n  !\n  ! ... cards\n  !\n  use input_parameters,   only : k_points, xk, wk, nk1, nk2, nk3,  &\n                                 k1, k2, k3, nkstot\n  use input_parameters, only : nconstr_inp, trd_ht, rd_ht, cell_units\n  !\n  use read_namelists_module, only : read_namelists, sm_not_set\n  use us, only : spline_ps_ => spline_ps\n  !\n  use input_parameters,       only : deallocate_input_parameters\n  !\n  implicit none\n  !\n  character(len=256), external :: trimcheck\n  !\n  integer  :: ia, image, nt, inlc\n  real(dp) :: theta, phi\n  !\n  !\n  ! ... various initializations of control variables\n  !\n  lforce    = tprnfor\n  !\n  select case( trim( calculation ) )\n  case( 'scf' )\n     !\n     lscf  = .true.\n     nstep = 1\n     !\n  case( 'nscf' )\n     !\n     lforce = .false.\n     nstep  = 1\n     !\n  case( 'bands' )\n     !\n     lforce = .false.\n     lbands = .true.\n     nstep  = 1\n     !\n  case( 'relax' )\n     !\n     lscf   = .true.\n     lforce = .true.\n     !\n     epse = etot_conv_thr\n     epsf = forc_conv_thr\n     !\n     select case( trim( ion_dynamics ) )\n     case( 'bfgs' )\n        !\n        lbfgs = .true.\n        !\n     case ( 'damp' )\n        !\n        lmd     = .true.\n        ldamped = .true.\n        !\n        !\n     case default\n        !\n        call errore( 'iosys', 'calculation=' // trim( calculation ) // &\n                   & ': ion_dynamics=' // trim( ion_dynamics ) // &\n                   & ' not supported', 1 )\n        !\n     end select\n     !\n     !\n  case( 'vc-relax' )\n     !\n     lscf      = .true.\n     lmd       = .true.\n     lforce    = .true.\n     ldamped   = .true.\n     !\n     epse =  etot_conv_thr\n     epsf =  forc_conv_thr\n     epsp = press_conv_thr\n     !\n     select case( trim( cell_dynamics ) )\n     case( 'none' )\n        !\n        !\n     case( 'damp-pr' )\n        !\n        !\n     case( 'damp-w' )\n        !\n        !\n     case( 'bfgs' )\n        !\n        lbfgs = .true.\n        lmd   = .false.\n        ldamped = .false.\n        !\n     case default\n        !\n        call errore( 'iosys', 'calculation=' // trim( calculation ) // &\n                   & ': cell_dynamics=' // trim( cell_dynamics ) // &\n                   & ' not supported', 1 )\n        !\n     end select\n     !\n     if ( .not. ldamped .and. .not. lbfgs) &\n        call errore( 'iosys', 'calculation='// trim( calculation ) // &\n                   & ': incompatible ion (' // trim( ion_dynamics )// &\n                   & ') and cell dynamics ('// trim(cell_dynamics )// ')', 1 )\n     !\n  case( 'vc-md' )\n     !\n     lscf      = .true.\n     lmd       = .true.\n     lforce    = .true.\n     !\n     !\n     select case( trim( cell_dynamics ) )\n     case( 'none' )\n        !\n        !\n     case( 'pr' )\n        !\n        !\n     case( 'w' )\n        !\n        !\n     case default\n        !\n        call errore( 'iosys', 'calculation=' // trim( calculation ) // &\n                   & ': ion_dynamics=' // trim( ion_dynamics ) // &\n                   & ' not supported', 1 )\n        !\n     end select\n     !\n     if ( trim( ion_dynamics ) /= 'beeman' ) &\n        call errore( 'iosys', 'calculation=' // trim( calculation ) // &\n                   & ': ion_dynamics=' // trim( ion_dynamics ) // &\n                   & ' not supported', 1 )\n     !\n  case default\n     !\n     call errore( 'iosys', 'calculation ' // &\n                & trim( calculation ) // ' not implemented', 1 )\n     !\n  end select\n  !\n  lstres = ( tstress .and. lscf )\n  !\n  if ( tefield .and. ( .not. nosym ) ) then\n     nosym = .true.\n     write( stdout, &\n            '(5x,\"presently no symmetry can be used with electric field\",/)' )\n  endif\n  if ( tefield .and. tstress ) then\n     tstress = .false.\n     write( stdout, &\n            '(5x,\"presently stress not available with electric field\",/)' )\n  endif\n  if ( tefield .and. ( nspin > 2 ) ) then\n     call errore( 'iosys', 'lsda not available with electric field' , 1 )\n  endif\n  !\n  twfcollect = wf_collect\n  !\n  ! ... set values for electron and bands\n  !\n  tfixed_occ = .false.\n  ltetra     = .false.\n  lgauss     = .false.\n  !\n  select case( trim( occupations ) )\n  case( 'fixed' )\n     !\n     ngauss = 0\n     if ( degauss /= 0.d0 ) then\n        call errore( ' iosys ', &\n                   & ' fixed occupations, gauss. broadening ignored', -1 )\n        degauss = 0.d0\n     endif\n     !\n  case( 'smearing' )\n     !\n     lgauss = ( degauss > 0.0_dp ) \n     if ( .not. lgauss ) &\n        call errore( ' iosys ', &\n                   & ' smearing requires gaussian broadening', 1 )\n     !\n     select case ( trim( smearing ) )\n     case ( 'gaussian', 'gauss', 'gaussian', 'gauss' )\n        ngauss = 0\n        smearing_ = 'gaussian'\n     case ( 'methfessel-paxton', 'm-p', 'mp', 'methfessel-paxton', 'm-p', 'mp' )\n        ngauss = 1\n        smearing_ = 'methfessel-paxton'\n     case ( 'marzari-vanderbilt', 'cold', 'm-v', 'mv', 'marzari-vanderbilt', 'm-v', 'mv')\n        ngauss = -1\n        smearing_ = 'marzari-vanderbilt'\n     case ( 'fermi-dirac', 'f-d', 'fd', 'fermi-dirac', 'f-d', 'fd')\n        ngauss = -99\n        smearing_ = 'fermi-dirac'\n     case default\n        call errore( ' iosys ', ' smearing '//trim(smearing)//' unknown', 1 )\n     end select\n     !\n  case( 'tetrahedra' )\n     !\n     ! replace \"errore\" with \"infomsg\" in the next line if you really want\n     ! to perform a calculation with forces using tetrahedra \n     !\n     if( lforce ) call errore( 'iosys', &\n        'force calculation with tetrahedra not recommanded: use smearing',1)\n     !\n     ! as above, for stress\n     !\n     if( lstres ) call errore( 'iosys', &\n        'stress calculation with tetrahedra not recommanded: use smearing',1)\n     ngauss = 0\n     ltetra = .true.\n     !\n  case( 'from_input' )\n     !\n     ngauss     = 0\n     tfixed_occ = .true.\n     !\n  case default\n     !\n     call errore( 'iosys','occupations ' // trim( occupations ) // &\n                & 'not implemented', 1 )\n     !\n  end select\n  !\n  if( nbnd < 1 ) &\n     call errore( 'iosys', 'nbnd less than 1', nbnd )\n  !\n  select case( nspin )\n  case( 1 )\n     !\n     lsda = .false.\n     !\n  case( 2 )\n     !\n     lsda = .true.\n     !\n  case( 4 )\n     !\n     lsda = .false.\n     !\n  case default\n     !\n     call errore( 'iosys', 'wrong input value for nspin', 1 )\n     !\n  end select\n  !\n  two_fermi_energies = ( tot_magnetization /= -1._dp)\n  if ( two_fermi_energies .and. tot_magnetization < 0._dp) &\n     call errore( 'iosys', 'tot_magnetization only takes positive values', 1 )\n  if ( two_fermi_energies .and. .not. lsda ) &\n     call errore( 'iosys', 'tot_magnetization requires nspin=2', 1 )\n  !\n  if ( occupations == 'fixed' .and. lsda  .and. lscf ) then\n     !\n     if ( two_fermi_energies ) then\n        !\n        if ( abs( nint(tot_magnetization ) - tot_magnetization ) > eps8 ) &\n           call errore( 'iosys', &\n                 & 'fixed occupations requires integer tot_magnetization', 1 )\n        if ( abs( nint(tot_charge ) - tot_charge ) > eps8 ) &\n           call errore( 'iosys', &\n                      & 'fixed occupations requires integer charge', 1 )\n        !\n     else\n        !\n        call errore( 'iosys', &\n                   & 'fixed occupations and lsda need tot_magnetization', 1 )\n        !\n     endif\n     !\n  endif\n  !\n  !\n  select case( trim( constrained_magnetization ) )\n  case( 'none' )\n     !\n     ! ... starting_magnetization(nt) = sm_not_set means \"not set\"\n     ! ... if no constraints are imposed on the magnetization, \n     ! ... starting_magnetization must be set for at least one atomic type\n     !\n     if ( lscf .and. lsda .and. ( .not. tfixed_occ ) .and. &\n          ( .not. two_fermi_energies )  .and. &\n          all (starting_magnetization(1:ntyp) == sm_not_set) ) &\n        call errore('iosys','some starting_magnetization must be set', 1 )\n     !\n     ! ... bring starting_magnetization between -1 and 1\n     !\n     do nt = 1, ntyp\n        !\n        if ( starting_magnetization(nt) == sm_not_set ) then\n           starting_magnetization(nt) = 0.0_dp\n        elseif ( starting_magnetization(nt) > 1.0_dp ) then\n          starting_magnetization(nt) = 1.0_dp\n        elseif ( starting_magnetization(nt) <-1.0_dp ) then\n          starting_magnetization(nt) =-1.0_dp\n        endif\n        !\n     enddo\n     !\n     !\n  case( 'atomic' )\n     !\n     if ( nspin == 1 ) &\n        call errore( 'iosys','constrained atomic magnetizations ' // &\n                   & 'require nspin=2 or 4 ', 1 )\n     if ( all (starting_magnetization(1:ntyp) == sm_not_set) ) &\n        call errore( 'iosys','constrained atomic magnetizations ' // &\n                   & 'require that some starting_magnetization is set', 1 )\n     !\n     !\n  case( 'atomic direction' )\n     !\n     if ( nspin == 1 ) &\n        call errore( 'iosys','constrained atomic magnetization ' // &\n                   & 'directions require nspin=2 or 4 ', 1 )\n     !\n  case( 'total' )\n     !\n     if ( nspin == 4 ) then\n        !\n        !\n     else\n        !\n        call errore( 'iosys','constrained total magnetization ' // &\n                   & 'requires nspin= 4 ', 1 )\n        !\n     endif\n     !\n  case( 'total direction' )\n     !\n  case default\n     !\n     call errore( 'iosys','constrained magnetization ' // &\n                & trim( constrained_magnetization ) // 'not implemented', 1 )\n     !\n  end select\n  !\n  !\n  if ( ecutrho <= 0.d0 ) then\n     !\n     dual = 4.d0\n     ecutrho = dual*ecutwfc\n     !\n  else\n     !\n     dual = ecutrho / ecutwfc\n     if ( dual <= 1.d0 ) &\n        call errore( 'iosys', 'invalid dual?', 1 )\n     !\n  endif\n  !\n  select case( trim( restart_mode ) )\n  case( 'from_scratch' )\n     !\n     restart        = .false.\n     if ( lscf ) then\n        startingconfig = 'input'\n     else\n        startingconfig = 'file'\n     endif\n     !\n  case default\n     !\n     call errore( 'iosys', &\n                & 'unknown restart_mode ' // trim( restart_mode ), 1 )\n     !\n  end select\n  !\n  select case( trim( disk_io ) )\n  case( 'high' )\n     !\n     io_level = 2\n     !\n  case ( 'low' )\n     !\n     io_level = 0\n     restart  = .false.\n     !\n  case ( 'none' )\n     !\n     io_level = -1\n     restart  = .false.\n     if ( twfcollect ) then\n        call infomsg('iosys', 'minimal i/o required, wf_collect reset to false')\n        twfcollect= .false.\n     endif\n     !\n  case default\n     !\n     io_level = 1\n     !\n     if ( lscf ) restart  = .false.\n     !\n  end select\n  !\n  hubbard_u(:)    = hubbard_u(:) / rytoev\n  hubbard_j(:,:)  = hubbard_j(:,:) / rytoev\n  hubbard_alpha(:)= hubbard_alpha(:) / rytoev\n  !\n  ethr = diago_thr_init\n  !\n  if ( startingpot /= 'atomic' .and. startingpot /= 'file' ) then\n     !\n     call infomsg( 'iosys', 'wrong startingpot: use default (1)' )\n     !\n     if ( lscf ) then\n        startingpot = 'atomic'\n     else \n        startingpot = 'file'\n     end if\n     !\n  endif\n  !\n  if ( .not. lscf .and. startingpot /= 'file' ) then\n     !\n     call infomsg( 'iosys', 'wrong startingpot: use default (2)' )\n     !\n     startingpot = 'file'\n     !\n  endif\n  !\n  if (      startingwfc /= 'atomic' .and. &\n            startingwfc /= 'random' .and. &\n            startingwfc /= 'atomic+random' .and. &\n            startingwfc /= 'file' ) then\n     !\n     call infomsg( 'iosys', 'wrong startingwfc: use default' )\n     !\n     startingwfc = 'atomic'\n     !\n  endif\n  !\n  select case( trim( diagonalization ) )\n  case ( 'cg' )\n     !\n     isolve = 1\n     max_cg_iter = diago_cg_maxiter\n     !\n  case ( 'david', 'davidson' )\n     !\n     isolve = 0\n     david = diago_david_ndim\n     !\n  case default\n     !\n     call errore( 'iosys', 'diagonalization ' // &\n                & trim( diagonalization ) // ' not implemented', 1 )\n     !\n  end select\n  !\n  tr2   = conv_thr\n  niter = electron_maxstep\n  adapt_thr = adaptive_thr\n  tr2_init  = conv_thr_init\n  tr2_multi = conv_thr_multi\n  !\n  pot_order = 1\n  select case( trim( pot_extrapolation ) )\n  case( 'from_wfcs', 'from-wfcs' )\n     ! not actually implemented\n     pot_order =-1\n     !\n  case( 'none' )\n     !\n     pot_order = 0\n     !\n  case( 'first_order', 'first-order', 'first order' )\n     !\n     if ( lmd  ) then\n        pot_order = 2\n     else\n        call infomsg('iosys', \"pot_extrapolation='\"//trim(pot_extrapolation)//&\n                     \"' not available, using 'atomic'\")\n     endif\n     !\n  case( 'second_order', 'second-order', 'second order' )\n     !\n     if ( lmd  ) then\n        pot_order = 3\n     else\n        call infomsg('iosys', \"pot_extrapolation='\"//trim(pot_extrapolation)//&\n                     \"' not available, using 'atomic'\")\n     endif\n     !\n  case default\n     !\n     pot_order = 1\n     !\n  end select\n  !\n  wfc_order = 0\n  select case( trim( wfc_extrapolation ) )\n     !\n  case( 'first_order', 'first-order', 'first order' )\n     !\n     if ( lmd  ) then\n        wfc_order = 2\n     else\n        call infomsg('iosys', \"wfc_extrapolation='\"//trim(pot_extrapolation)//&\n                     \"' not available, using 'atomic'\")\n     endif\n     !\n  case( 'second_order', 'second-order', 'second order' )\n     !\n     if ( lmd  ) then\n        wfc_order = 3\n     else\n        call infomsg('iosys', \"wfc_extrapolation='\"//trim(pot_extrapolation)//&\n                     \"' not available, using 'atomic'\")\n     endif\n     !\n  end select\n  !\n  select case( trim( mixing_mode ) )\n  case( 'plain' )\n     !\n     imix = 0\n     !\n  case( 'tf' )\n     !\n     imix = 1\n     !\n  case( 'local-tf' )\n     !\n     imix = 2\n     !\n  case( 'potential' )\n     !\n     call errore( 'iosys', 'potential mixing no longer implemented', 1 )\n     !\n  case default\n     !\n     call errore( 'iosys', 'unknown mixing ' // trim( mixing_mode ), 1 )\n     !\n  end select\n  !\n  starting_scf_threshold = tr2\n  nmix = mixing_ndim\n  !\n  if ( ion_dynamics == ' bfgs' .and. epse <= 20.d0 * ( tr2 / upscale ) ) &\n       call errore( 'iosys', 'required etot_conv_thr is too small:' // &\n                     & ' conv_thr must be reduced', 1 )\n  !\n  select case( trim( verbosity ) )\n  case( 'debug', 'high', 'medium' )\n     !\n     iverbosity = 1\n     !\n  case( 'low', 'default', 'minimal' )\n     !\n     iverbosity = 0 \n     !\n  case default\n     !\n     iverbosity = 0\n     !\n  end select\n  !\n  tmp_dir = trimcheck ( outdir )\n  !\n\n  !\n  ! ... copy values from input module to pw internals\n  !\n  tqr_        = tqr\n  !\n  title_      = title\n  lkpoint_dir_=lkpoint_dir\n  tefield_    = tefield\n  dipfield_   = dipfield\n  prefix_     = trim( prefix )\n  pseudo_dir_ = trimcheck( pseudo_dir )\n  nstep_      = nstep\n  iprint_     = iprint\n  lecrpa_     = lecrpa\n  !\n  nat_     = nat\n  ntyp_    = ntyp\n  edir_    = edir\n  emaxpos_ = emaxpos\n  eopreg_  = eopreg\n  eamp_    = eamp\n  dfftp%nr1     = nr1\n  dfftp%nr2     = nr2\n  dfftp%nr3     = nr3\n  ecutrho_ = ecutrho\n  ecutwfc_ = ecutwfc\n  ecfixed_ = ecfixed\n  qcutz_   = qcutz\n  q2sigma_ = q2sigma\n  dffts%nr1    = nr1s\n  dffts%nr2    = nr2s\n  dffts%nr3    = nr3s\n  degauss_ = degauss\n  !\n  tot_charge_        = tot_charge\n  tot_magnetization_ = tot_magnetization\n  !\n  lspinorb_ = lspinorb\n  starting_spin_angle_ = starting_spin_angle\n  one_atom_occupations_ = one_atom_occupations\n  !\n  no_t_rev_ = no_t_rev\n  allfrac   = use_all_frac\n  !\n  spline_ps_ = spline_ps\n  !\n  la2f_                   = la2f\n  nspin_                  = nspin\n  starting_magnetization_ = starting_magnetization\n  noinv_                  = noinv\n  nosym_                  = nosym\n  nosym_evc_              = nosym_evc\n  nofrac                  = force_symmorphic\n  nbnd_                   = nbnd\n  !\n  !\n  !\n  diago_full_acc_ = diago_full_acc\n  starting_wfc    = startingwfc\n  starting_pot    = startingpot\n  mixing_beta_    = mixing_beta\n  !\n  remove_rigid_rot_ = remove_rigid_rot\n  upscale_          = upscale\n  !\n  if (trim(occupations) /= 'from_input') one_atom_occupations_=.false.\n  !\n  !\n  select case( trim( assume_isolated ) )\n      !\n    case( 'none' )\n      !\n      !\n    case default\n      !\n      call errore ('iosys','unrecognized value for assume_isolated',1)\n  end select\n  !\n  ! ... read following cards\n  !\n  allocate( ityp( nat_ ) )\n  allocate( tau(    3, nat_ ) )\n  allocate( force(  3, nat_ ) )\n  allocate( if_pos( 3, nat_ ) )\n  allocate( extfor( 3, nat_ ) )\n  if ( tfixed_occ ) then\n     if ( nspin_ == 4 ) then\n        allocate( f_inp( nbnd_, 1 ) )\n     else\n        allocate( f_inp( nbnd_, nspin_ ) )\n     endif\n  endif\n  !\n  if ( tefield ) allocate( forcefield( 3, nat_ ) )\n  !\n  ! ... note that read_cards_pw no longer reads cards!\n  !\n  call read_cards_pw ( psfile, tau_format )\n  !\n  ! ... set up atomic positions and crystal lattice\n  !\n  call cell_base_init ( ibrav, celldm, a, b, c, cosab, cosac, cosbc, &\n                        trd_ht, rd_ht, cell_units )\n  !\n  ! ... set up k-points\n  !\n  call init_start_k ( nk1, nk2, nk3, k1, k2, k3, k_points, nkstot, xk, wk )\n  gamma_only = ( k_points == 'gamma' )\n  if( gamma_only ) call errore('iosys','kpoints=gamma calculations not available for mini_dft',1)\n  !\n  !\n  call convert_tau ( tau_format, nat_, tau)\n  !\n  if ( wmass == 0.d0 ) then\n     !\n     ! ... set default value of wmass\n     !\n#if defined __pgi\n     do ia = 1, nat_\n        wmass = wmass + amass( ityp(ia) )\n     enddo\n#else\n     wmass = sum( amass(ityp(:)) )\n#endif\n     !\n     wmass = wmass * amconv\n     !\n  else\n     !\n     ! ... wmass is given in amu, renata's dynamics uses masses in atomic units\n     !\n     !\n  endif\n  !\n  ! ... unit conversion for pressure\n  !\n  !\n  ! ... set constraints for cell dynamics/optimization\n  !\n  call init_dofree ( cell_dofree )\n  !\n  ! ... read pseudopotentials (also sets dft)\n  !\n  call readpp ( input_dft )\n  !\n  !\n  ! ... variables for constrained dynamics are set here\n  !\n  lconstrain = ( nconstr_inp > 0 )\n  !\n  ! ... files\n  !\n  input_drho  = ' '\n  output_drho = ' '\n  !\n  if (real_space ) then\n        call errore ('iosys', 'real space only with gamma point', 1)\n  endif\n  !\n  ! deallocation of temp input arrays\n  !\n  call deallocate_input_parameters ()  \n  !\n  return\n  !\nend subroutine iosys\n"}
{"id": 459, "subroutine": "subroutine read_cards_pw ( psfile, tau_format )\n  !----------------------------------------------------------------------------\n  !\n  use kinds,              only : dp\n  use input_parameters,   only : atom_label, atom_pfile, atom_mass, taspc, &\n                                 tapos, rd_pos, atomic_positions, if_pos,  &\n                                 sp_pos, f_inp, rd_for, tavel, sp_vel, rd_vel\n  use cell_base,          only : at, ibrav\n  use ions_base,          only : nat, ntyp => nsp, ityp, tau, atm, extfor\n  use fixed_occ,          only : tfixed_occ, f_inp_ => f_inp\n  use ions_base,          only : if_pos_ =>  if_pos, amass, fixatom\n  use control_flags,      only : lfixatom, textfor\n  !\n  implicit none\n  !\n  character (len=256) :: psfile(ntyp)\n  character (len=80)  :: tau_format\n  integer, external :: atomic_number\n  real(dp), external :: atom_weight\n  !\n  integer :: is, ia\n  !\n  !\n  amass = 0\n  !\n  if ( .not. taspc ) &\n     call errore( 'read_cards_pw', 'atomic species info missing', 1 )\n  if ( .not. tapos ) &\n     call errore( 'read_cards_pw', 'atomic position info missing', 1 )\n  !\n  do is = 1, ntyp\n     !\n     amass(is)  = atom_mass(is)\n     psfile(is) = atom_pfile(is)\n     atm(is)    = atom_label(is)\n     !\n     if ( amass(is) <= 0.0_dp ) amass(is)= &\n              atom_weight(atomic_number(trim(atm(is))))\n\n     if ( amass(is) <= 0.d0 ) call errore( 'read_cards_pw', 'invalid  mass', is )\n     !\n  enddo\n  !\n  textfor = .false.\n  if( any( rd_for /= 0.0_dp ) ) textfor = .true.\n  !\n  do ia = 1, nat\n     !\n     tau(:,ia) = rd_pos(:,ia)\n     ityp(ia)  = sp_pos(ia)\n     extfor(:,ia) = rd_for(:,ia)\n     !\n  enddo\n  !\n  ! ... the constrain on fixed coordinates is implemented using the array\n  ! ... if_pos whose value is 0 when the coordinate is to be kept fixed, 1\n  ! ... otherwise. \n  !\n  if_pos_(:,:) = if_pos(:,1:nat)\n  fixatom = count( if_pos_(1,:)==0 .and. if_pos_(2,:)==0 .and. if_pos_(3,:)==0 )\n  lfixatom = any ( if_pos_ == 0 )\n  !\n  tau_format = trim( atomic_positions )\n  !\n  if ( tfixed_occ ) then\n     !\n     f_inp_ = f_inp\n     !\n     deallocate ( f_inp )\n     !\n  endif\n  !\n  return\n  !\nend subroutine read_cards_pw\n"}
{"id": 460, "subroutine": "subroutine convert_tau (tau_format, nat_, tau)\n!-----------------------------------------------------------------------\n  !\n  ! ... convert input atomic positions to internally used format:\n  ! ... tau in a0 units\n  !\n  use kinds,         only : dp\n  use constants,     only : bohr_radius_angs\n  use cell_base,     only : at, alat\n  implicit none\n  character (len=*), intent(in)  :: tau_format\n  integer, intent(in)  :: nat_\n  real (dp), intent(inout) :: tau(3,nat_)\n  !\n  select case( tau_format )\n  case( 'alat' )\n     !\n     ! ... input atomic positions are divided by a0: do nothing\n     !\n  case( 'bohr' )\n     !\n     ! ... input atomic positions are in a.u.: divide by alat\n     !\n     tau = tau / alat\n     !\n  case( 'crystal' )\n     !\n     ! ... input atomic positions are in crystal axis\n     !\n     call cryst_to_cart( nat_, tau, at, 1 )\n     !\n  case( 'angstrom' )\n     !\n     ! ... atomic positions in a: convert to a.u. and divide by alat\n     !\n     tau = tau / bohr_radius_angs / alat\n     !\n  case default\n     !\n     call errore( 'iosys','tau_format=' // &\n                & trim( tau_format ) // ' not implemented', 1 )\n     !\n  end select\n  !\nend subroutine convert_tau\n"}
{"id": 461, "subroutine": "subroutine display(brd,trgt,n)\nimplicit none\n!arguments\ninteger :: n\nlogical :: brd(n,n), trgt(n,n)\n!local\ncharacter(len=*), parameter :: cfmt = \"(a3)\", ifmt = \"(i3)\"\ninteger :: i, j\nwrite(*,*) 'current configuration: '\ndo i = 0,n\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'r/c'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*)\ndo i = 0,n\n  if(i.eq.0) then\n    do j = 0,n+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+n\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,n\n      if(brd(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\n\nwrite(*,*)\nwrite(*,*)\n\nwrite(*,*) 'target configuration'\ndo i = 0,n\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'r/c'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*)\ndo i = 0,n\n  if(i.eq.0) then\n    do j = 0,n+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+n\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,n\n      if(trgt(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\nwrite(*,*)\nwrite(*,*)\nend subroutine\n"}
{"id": 462, "subroutine": "subroutine next_move(brd,trgt,n,input,solved)\nimplicit none\n!arguments\ninteger :: n, input\nlogical :: brd(n,n), trgt(n,n), solved\n!others\ninteger :: i,j\n\nif(input.gt.n) then\n  input = input-n\n  do i = 1,n\n    brd(input,i) = .not.brd(input,i)\n  end do\nelse\n  do i = 1,n\n    brd(i,input) = .not.brd(i,input)\n  end do\nend if\nsolved = .true.\ndo i = 1,n\n  do j = 1,n\n    if( (.not.brd(i,j).and.trgt(i,j)) .or. (brd(i,j).and..not.trgt(i,j)) ) then\n      solved = .false.\n      exit\n    end if\n  end do\n  if(.not.solved) exit\nend do\nend subroutine\n"}
{"id": 463, "subroutine": "subroutine read_dump(ifile,skipdump)\n!\n\n! (sph)\n!\n\nuse sphdata\nimplicit none\n\ninteger,intent(in) :: ifile\nlogical,intent(inout) :: skipdump\ninteger :: check,smallfile\n\nskipdump = .false.\n\ncheck =0\nsmallfile = 0\n\nprint*, fileformat\n\n\n\nprint*, 'reading sph file'\n  \nif(fileformat=='sphng_wkmr') then\n   \n   call rdump_sphng_wkmr(filename(ifile),check,smallfile)\n   \nelse if(fileformat=='sphng_iab') then\n   call rdump_sphng_iab(filename(ifile),check,smallfile)\n   \nendif\n\n\n! skip small dumps\nif(smallfile/=0) then\n   print*, 'skipping small/incomplete dump'\n   skipdump = .true.\nendif\n\nif (check /= 0) then\n   !\tif file missing in series, skip it\n   if(ifile==1) then\n      print*, 'error: program aborted at first file read in'\n      print*, \" if sph read fails, check the following:\"\n      print*, \"    - file endianness\"\n      print*, \"    - default real size\"\n      print*, \" \"\n      print*, \" for the gfortran compiler, inserting or \"\n      print*, \" removing the following flags should correct\"\n      print*, \" the problem:\"\n      print*, \"    -fconvert=swap\"\n      print*, \"       (swaps endianness during read-in)\"\n      print*, \"    -fdefault-real-8\"\n      print*, \"       (sets default real to double precision)\"\n      stop\n   else\n      print*, 'skipping missing dump ',filename(ifile)\n      skipdump = .true.\n   endif\nendif\n\nend subroutine read_dump\n"}
{"id": 464, "subroutine": "      subroutine get_dimension(l_dim,dim)\n      implicit none\n      logical,intent(in) :: l_dim(3)\n      integer,intent(inout) :: dim\n      integer :: i\n\n      dim=3\n      do i=1,3\n         if(l_dim(i))dim=dim+1\n      enddo\n\n      end subroutine get_dimension\n"}
{"id": 465, "subroutine": "      subroutine get_shift(l_dim,shift)\n      implicit none\n      logical,intent(in) :: l_dim(3)\n      integer,intent(inout) :: shift(3)\n\n      shift=0\n      if(l_dim(1))then\n         shift(2)=shift(2)+1\n         shift(3)=shift(3)+1\n      endif\n\n      if(l_dim(2))then\n         shift(3)=shift(3)+1\n      endif\n\n      end subroutine get_shift\n"}
{"id": 466, "subroutine": "      subroutine gwf_plottemplate()\n      use m_judft\n      implicit none\n      integer :: i,nwfs,numbands\n      logical :: l_exist\n\n      inquire(file='proj',exist=l_exist)\n      if(.not.l_exist) then\n         call judft_error('where is proj?',\n     >                    calledby='gwf_plottemplate')\n      endif\n\n      open(8888,file='proj',status='old')\n      read(8888,*)nwfs,numbands\n      close(8888)\n\n      open(8888,file='printhdwf',status='unknown')\n      write(8888,'(i4,3x,a1,3x,a4,i3)')nwfs,'f','nga=',5\n      do i=1,nwfs\n         write(8888,'(i4,3x,i1,3x,i4)')i,4,0\n      enddo\n\n      close(8888)\n\n      write(*,*)'******************************'\n      write(*,*)'* created printhdwf template *'\n      write(*,*)'******************************'\n\n      end subroutine gwf_plottemplate\n"}
{"id": 467, "subroutine": "  subroutine solve_with_general_elpa_eigenexa(n, proc, matrix_a, eigenpairs, matrix_b)\n    class(elpa_t), pointer :: e\n    integer, intent(in) :: n\n    type(ek_process_t), intent(in) :: proc\n    type(ek_sparse_mat_t), intent(in) :: matrix_a\n    type(ek_sparse_mat_t), intent(in), optional :: matrix_b\n    type(ek_eigenpairs_types_union_t), intent(out) :: eigenpairs\n\n    integer :: desc_a(desc_size), desc_a2(desc_size), desc_b(desc_size), &\n         desc_a_re(desc_size), &\n         block_size, max_block_size, &\n         myid, np_rows, np_cols, my_prow, my_pcol, &\n         na_rows, na_cols, mpi_comm_rows, mpi_comm_cols, &\n         sc_desc(desc_size), ierr, info, mpierr\n\n    type(ek_eigenpairs_types_union_t) :: eigenpairs_tmp\n\n    double precision :: time_start, time_start_part, time_end\n    double precision, allocatable :: matrix_a_dist(:, :), matrix_a2_dist(:, :), matrix_b_dist(:, :), matrix_a_redist(:, :)\n    integer :: numroc, success\n\n    time_start = mpi_wtime()\n    time_start_part = time_start\n\n    call mpi_comm_rank(mpi_comm_world, myid, mpierr)\n    call blacs_gridinfo(proc%context, np_rows, np_cols, my_prow, my_pcol)\n\n#if\telpa_version >= 201705003\n    ierr = elpa_get_communicators(mpi_comm_world, my_prow, my_pcol, &\n         mpi_comm_rows, mpi_comm_cols)\n#else\n    call get_elpa_row_col_comms(mpi_comm_world, my_prow, my_pcol, &\n         mpi_comm_rows, mpi_comm_cols)\n#endif\n\n    max_block_size = min(n / np_rows, n / np_cols)\n    block_size = min(max_block_size, g_block_size)\n    na_rows = numroc(n, block_size, my_prow, 0, np_rows)\n    na_cols = numroc(n, block_size, my_pcol, 0, np_cols)\n    call descinit(sc_desc, n, n, block_size, block_size, 0, 0, proc%context, na_rows, info)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:init', time_end - time_start_part)\n    time_start_part = time_end\n\n    call setup_distributed_matrix('a', proc, n, n, desc_a, matrix_a_dist)\n    call setup_distributed_matrix('a2', proc, n, n, desc_a2, matrix_a2_dist)\n    call setup_distributed_matrix('b', proc, n, n, desc_b, matrix_b_dist)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:setup_distributed_matrices', time_end - time_start_part)\n    time_start_part = time_end\n\n    call distribute_global_sparse_matrix(matrix_a, desc_a, matrix_a_dist)\n    call distribute_global_sparse_matrix(matrix_a, desc_a2, matrix_a2_dist)\n    call distribute_global_sparse_matrix(matrix_b, desc_b, matrix_b_dist)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:distribute_global_sparse_matrices', time_end - time_start_part)\n    time_start_part = time_end\n\n    if (elpa_init(20170403) /= elpa_ok) then\n      print *, \"elpa api version not supported\"\n      stop\n    endif\n    e => elpa_allocate()\n\n    call e%set(\"na\", n, success) !size of matrix\n    call e%set(\"nev\", n, success) !number of eigenvectors to be calculated\n    call e%set(\"local_nrows\", na_rows, success)\n    call e%set(\"local_ncols\", na_cols, success)\n    call e%set(\"nblk\", block_size, success)\n    call e%set(\"mpi_comm_parent\", mpi_comm_world, success)\n    call e%set(\"process_row\", my_prow, success)\n    call e%set(\"process_col\", my_pcol, success)\n    success = e%setup()\n\n    call e%set(\"solver\", elpa_solver_1stage, success)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:setup_parameter', time_end - time_start)\n    time_start = time_end\n\n    ! return of cholesky_real is stored in the upper triangle.\n#if\telpa_version >= 201705003\n    call e%cholesky(matrix_b_dist, success)\n#else\n    call cholesky_real(n, matrix_b_dist, na_rows, block_size, mpi_comm_rows, mpi_comm_cols, success)\n#endif\n    if (success == elpa_error) then\n      call terminate('solver_main, general_elpa_eigenexa: cholesky_real failed', 1)\n    end if\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:cholesky_real', time_end - time_start_part)\n    time_start_part = time_end\n\n#if\telpa_version >= 201705003\n    call e%invert_triangular(matrix_b_dist, success)\n#else\n    call invert_trm_real(n, matrix_b_dist, na_rows, block_size, mpi_comm_rows, mpi_comm_cols, success)\n#endif\n\n    if (success == elpa_error) then\n      call terminate('solver_main, ggeneral_elpa_eigenexa: invert_trm_real failed', 1)\n    end if\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:invert_trm_real', time_end - time_start_part)\n    time_start_part = time_end\n\n    ! reduce a as u^-t a u^-1\n    ! a <- u^-t a\n    call e%hermitian_multiply('u', 'full', n, &\n          matrix_b_dist, matrix_a2_dist, na_rows, na_cols, &\n          matrix_a_dist, na_rows, na_cols, success)\n\n    deallocate(matrix_a2_dist)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:mult_at_b_real', time_end - time_start_part)\n    time_start_part = time_end\n\n    ! a <- a u^-1\n    call pdtrmm('right', 'upper', 'no_trans', 'no_unit', n, n, 1.0d0, &\n         matrix_b_dist, 1, 1, sc_desc, matrix_a_dist, 1, 1, sc_desc)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:pdtrmm_right', time_end - time_start_part)\n    time_start_part = time_end\n\n    call setup_distributed_matrix_for_eigenexa(n, desc_a_re, matrix_a_redist, eigenpairs_tmp)\n    call pdgemr2d(n, n, matrix_a_dist, 1, 1, desc_a, matrix_a_redist, 1, 1, desc_a_re, desc_a(context_))\n    deallocate(matrix_a_dist)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:pdgemr2d_1', time_end - time_start_part)\n    time_start_part = time_end\n\n    call eigen_solver_eigenexa(matrix_a_redist, desc_a_re, n, eigenpairs_tmp, 'l')\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:eigen_solver_eigenexa', time_end - time_start_part)\n    time_start_part = time_end\n\n    deallocate(matrix_a_redist)\n    eigenpairs%type_number = 2\n    allocate(eigenpairs%blacs%values(n), stat = ierr)\n    if (ierr /= 0) then\n      call terminate('eigen_solver, general_elpa_eigenexa: allocation failed', ierr)\n    end if\n    eigenpairs%blacs%values(:) = eigenpairs_tmp%blacs%values(:)\n    eigenpairs%blacs%desc(:) = eigenpairs_tmp%blacs%desc(:)\n    call setup_distributed_matrix('eigenvectors', proc, n, n, &\n         eigenpairs%blacs%desc, eigenpairs%blacs%vectors, desc_a(block_row_))\n    call pdgemr2d(n, n, eigenpairs_tmp%blacs%vectors, 1, 1, eigenpairs_tmp%blacs%desc, &\n         eigenpairs%blacs%vectors, 1, 1, eigenpairs%blacs%desc, &\n         eigenpairs_tmp%blacs%desc(context_))\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:pdgemr2d_2', time_end - time_start_part)\n    time_start_part = time_end\n\n    ! z <- u^-1 z\n    call pdtrmm('left', 'upper', 'no_trans', 'no_unit', n, n, 1.0d0, &\n         matrix_b_dist, 1, 1, sc_desc, eigenpairs%blacs%vectors, 1, 1, sc_desc)\n\n    time_end = mpi_wtime()\n    call add_event('solve_with_general_elpa_eigenexa:pdtrmm_ev', time_end - time_start_part)\n    call add_event('solve_with_general_elpa_eigenexa', time_end - time_start)\n\n    call elpa_deallocate(e)\n    call elpa_uninit()\n  end subroutine solve_with_general_elpa_eigenexa\n"}
{"id": 468, "subroutine": "subroutine oneloopdecay_cha(msdos,msd2os,msvimos,msvim2os,msvreos,msvre2os,           & \n& msuos,msu2os,mseos,mse2os,mhhos,mhh2os,mahos,mah2os,mhpmos,mhpm2os,mchios,             & \n& mchi2os,mfvos,mfv2os,mchaos,mcha2os,mfeos,mfe2os,mfdos,mfd2os,mfuos,mfu2os,            & \n& mgluos,mglu2os,mvzos,mvz2os,mvwmos,mvwm2os,zdos,zvios,zvros,zuos,zeos,zhos,            & \n& zaos,zpos,znos,uvos,umos,upos,zelos,zeros,zdlos,zdros,zulos,zuros,mah,mah2,            & \n& mcha,mcha2,mchi,mchi2,mfd,mfd2,mfe,mfe2,mfu,mfu2,mfv,mfv2,mglu,mglu2,mhh,              & \n& mhh2,mhpm,mhpm2,msd,msd2,mse,mse2,msu,msu2,msvim,msvim2,msvre,msvre2,mvwm,             & \n& mvwm2,mvz,mvz2,pg,tw,um,up,uv,v,za,zd,zdl,zdr,ze,zel,zer,zh,zn,zp,zu,zul,              & \n& zur,zvi,zvr,zw,zz,betah,g1,g2,g3,yd,ye,lam,kap,lamn,yu,yv,mux,td,te,tlam,              & \n& tk,tln,tu,tv,bmux,mq2,ml2,mhd2,mhu2,md2,mu2,me2,mv2,ms2,mx2,m1,m2,m3,vd,               & \n& vu,vs,dg1,dg2,dg3,dmux,dbmux,dyd,dtd,dye,dte,dlam,dtlam,dkap,dtk,dlamn,dtln,           & \n& dyu,dtu,dyv,dtv,dmq2,dml2,dmhd2,dmhu2,dmd2,dmu2,dme2,dmv2,dms2,dmx2,dm1,               & \n& dm2,dm3,dvd,dvu,dvs,dpg,dzd,dzvi,dzvr,dzu,dze,dzh,dza,dzp,dzn,duv,dum,dup,             & \n& dzel,dzer,dzdl,dzdr,dzul,dzur,dsintw,dcostw,dtantw,zfvg,zffg,zfvp,zfvz,zfvwm,          & \n& zfsd,zfsvim,zfsvre,zfsu,zfse,zfhh,zfah,zfhpm,zfl0,zffv,zflm,zflp,zffel,zffer,          & \n& zffdl,zffdr,zfful,zffur,zfvpvz,zfvzvp,cplahahah,cplahahhh,cplahchpmvwm,cplahhhhh,      & \n& cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,cplahsvimsvim,    & \n& cplahsvimsvre,cplahsvresvre,cplcchacfusdl,cplcchacfusdr,cplcchachaahl,cplcchachaahr,   & \n& cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,   & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,             & \n& cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,             & \n& cplcchafvsel,cplcchafvser,cplcfdchasul,cplcfdchasur,cplcfdchisdl,cplcfdchisdr,         & \n& cplcfdfdahl,cplcfdfdahr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,cplcfdfdvgr,               & \n& cplcfdfdvpl,cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,cplcfdfuhpml,cplcfdfuhpmr,             & \n& cplcfdfuvwml,cplcfdfuvwmr,cplcfdglusdl,cplcfdglusdr,cplcfechasviml,cplcfechasvimr,     & \n& cplcfechasvrel,cplcfechasvrer,cplcfechisel,cplcfechiser,cplcfefeahl,cplcfefeahr,       & \n& cplcfefehhl,cplcfefehhr,cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,               & \n& cplcfefvhpml,cplcfefvhpmr,cplcfefvvwml,cplcfefvvwmr,cplcfuchisul,cplcfuchisur,         & \n& cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplcfufuahl,cplcfufuahr,       & \n& cplcfufuhhl,cplcfufuhhr,cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,cplcfufuvpr,               & \n& cplcfufuvzl,cplcfufuvzr,cplcfuglusul,cplcfuglusur,cplchafucsdl,cplchafucsdr,           & \n& cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplchichiahl,              & \n& cplchichiahr,cplchichihhl,cplchichihhr,cplchichivzl,cplchichivzr,cplchifdcsdl,         & \n& cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,cplchifucsur,cplchifvsviml,        & \n& cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplchpmvpvwm,cplchpmvwmvz,cplcvwmvpvwm,      & \n& cplcvwmvwmvz,cplfvchacsel,cplfvchacser,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,         & \n& cplfvfecvwmr,cplfvfvahl,cplfvfvahr,cplfvfvhhl,cplfvfvhhr,cplfvfvvzl,cplfvfvvzr,        & \n& cplglufdcsdl,cplglufdcsdr,cplglufucsul,cplglufucsur,cplhhchpmvwm,cplhhcvwmvwm,         & \n& cplhhhhhh,cplhhhpmchpm,cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,    & \n& cplhhsvimsvre,cplhhsvresvre,cplhhvzvz,cplhpmchpmvp,cplhpmchpmvz,cplhpmcvwmvp,          & \n& cplhpmcvwmvz,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplsdchpmcsu,cplsdcsdvg,          & \n& cplsdcsdvp,cplsdcsdvz,cplsdcsucvwm,cplsecsevp,cplsecsevz,cplsesvimchpm,cplsesvimcvwm,  & \n& cplsesvrechpm,cplsesvrecvwm,cplsucsdvwm,cplsucsuvg,cplsucsuvp,cplsucsuvz,              & \n& cplsvimcsevwm,cplsvimsvrevz,cplsvrecsevwm,ctcplcchacfusdl,ctcplcchacfusdr,             & \n& ctcplcchachaahl,ctcplcchachaahr,ctcplcchachahhl,ctcplcchachahhr,ctcplcchachavpl,       & \n& ctcplcchachavpr,ctcplcchachavzl,ctcplcchachavzr,ctcplcchachihpml,ctcplcchachihpmr,     & \n& ctcplcchachivwml,ctcplcchachivwmr,ctcplcchafdcsul,ctcplcchafdcsur,ctcplcchafesviml,    & \n& ctcplcchafesvimr,ctcplcchafesvrel,ctcplcchafesvrer,ctcplcchafvsel,ctcplcchafvser,      & \n& gcplcchachihpml,gcplcchachihpmr,gcplchpmvpvwm,gcplhpmcvwmvp,goszcplcchachihpml,        & \n& goszcplcchachihpmr,goszcplchpmvpvwm,goszcplhpmcvwmvp,gzcplcchachihpml,gzcplcchachihpmr,& \n& gzcplchpmvpvwm,gzcplhpmcvwmvp,zcplcchacfusdl,zcplcchacfusdr,zcplcchachaahl,            & \n& zcplcchachaahr,zcplcchachahhl,zcplcchachahhr,zcplcchachavpl,zcplcchachavpr,            & \n& zcplcchachavzl,zcplcchachavzr,zcplcchachihpml,zcplcchachihpmr,zcplcchachivwml,         & \n& zcplcchachivwmr,zcplcchafdcsul,zcplcchafdcsur,zcplcchafesviml,zcplcchafesvimr,         & \n& zcplcchafesvrel,zcplcchafesvrer,zcplcchafvsel,zcplcchafvser,zcplcfdchasul,             & \n& zcplcfdchasur,zcplcfdfdvpl,zcplcfdfdvpr,zcplcfechasviml,zcplcfechasvimr,               & \n& zcplcfechasvrel,zcplcfechasvrer,zcplcfefevpl,zcplcfefevpr,zcplcfufuvpl,zcplcfufuvpr,   & \n& zcplchafucsdl,zcplchafucsdr,zcplchichachpml,zcplchichachpmr,zcplchichacvwml,           & \n& zcplchichacvwmr,zcplchpmvpvwm,zcplcvwmvpvwm,zcplfvchacsel,zcplfvchacser,               & \n& zcplhpmchpmvp,zcplhpmcvwmvp,zcplsdcsdvp,zcplsecsevp,zcplsucsuvp,zruzd,zruzvi,          & \n& zruzvr,zruzu,zruze,zruzh,zruza,zruzp,zruzn,zruuv,zruum,zruup,zruzel,zruzer,            & \n& zruzdl,zruzdr,zruzul,zruzur,mlambda,em,gs,deltam,kont,gp1lcha)\n\nimplicit none \nreal(dp),intent(in) :: g1,g2,g3,mhd2,mhu2,ms2\n\ncomplex(dp),intent(in) :: yd(3,3),ye(3,3),lam,kap,lamn(3,3),yu(3,3),yv(3,3),mux(3,3),td(3,3),te(3,3),           & \n& tlam,tk,tln(3,3),tu(3,3),tv(3,3),bmux(3,3),mq2(3,3),ml2(3,3),md2(3,3),mu2(3,3),        & \n& me2(3,3),mv2(3,3),mx2(3,3),m1,m2,m3\n\nreal(dp),intent(in) :: vd,vu,vs\n\nreal(dp),intent(in) :: mah(3),mah2(3),mcha(2),mcha2(2),mchi(5),mchi2(5),mfd(3),mfd2(3),mfe(3),               & \n& mfe2(3),mfu(3),mfu2(3),mfv(9),mfv2(9),mglu,mglu2,mhh(3),mhh2(3),mhpm(2),               & \n& mhpm2(2),msd(6),msd2(6),mse(6),mse2(6),msu(6),msu2(6),msvim(9),msvim2(9),              & \n& msvre(9),msvre2(9),mvwm,mvwm2,mvz,mvz2,tw,v,za(3,3),zh(3,3),zp(2,2),zz(2,2),betah\n\ncomplex(dp),intent(in) :: pg,um(2,2),up(2,2),uv(9,9),zd(6,6),zdl(3,3),zdr(3,3),ze(6,6),zel(3,3),zer(3,3),       & \n& zn(5,5),zu(6,6),zul(3,3),zur(3,3),zvi(9,9),zvr(9,9),zw(2,2)\n\nreal(dp),intent(in) :: dg1,dg2,dg3,dmhd2,dmhu2,dms2,dvd,dvu,dvs,dzh(3,3),dza(3,3),dzp(2,2),dsintw,           & \n& dcostw,dtantw\n\ncomplex(dp),intent(in) :: dmux(3,3),dbmux(3,3),dyd(3,3),dtd(3,3),dye(3,3),dte(3,3),dlam,dtlam,dkap,             & \n& dtk,dlamn(3,3),dtln(3,3),dyu(3,3),dtu(3,3),dyv(3,3),dtv(3,3),dmq2(3,3),dml2(3,3),      & \n& dmd2(3,3),dmu2(3,3),dme2(3,3),dmv2(3,3),dmx2(3,3),dm1,dm2,dm3,dpg,dzd(6,6),            & \n& dzvi(9,9),dzvr(9,9),dzu(6,6),dze(6,6),dzn(5,5),duv(9,9),dum(2,2),dup(2,2),             & \n& dzel(3,3),dzer(3,3),dzdl(3,3),dzdr(3,3),dzul(3,3),dzur(3,3)\n\ncomplex(dp),intent(in) :: cplahahah(3,3,3),cplahahhh(3,3,3),cplahchpmvwm(3,2),cplahhhhh(3,3,3),cplahhhvz(3,3),  & \n& cplahhpmchpm(3,2,2),cplahhpmcvwm(3,2),cplahsdcsd(3,6,6),cplahsecse(3,6,6),             & \n& cplahsucsu(3,6,6),cplahsvimsvim(3,9,9),cplahsvimsvre(3,9,9),cplahsvresvre(3,9,9),      & \n& cplcchacfusdl(2,3,6),cplcchacfusdr(2,3,6),cplcchachaahl(2,2,3),cplcchachaahr(2,2,3),   & \n& cplcchachahhl(2,2,3),cplcchachahhr(2,2,3),cplcchachavpl(2,2),cplcchachavpr(2,2),       & \n& cplcchachavzl(2,2),cplcchachavzr(2,2),cplcchachihpml(2,5,2),cplcchachihpmr(2,5,2),     & \n& cplcchachivwml(2,5),cplcchachivwmr(2,5),cplcchafdcsul(2,3,6),cplcchafdcsur(2,3,6),     & \n& cplcchafesviml(2,3,9),cplcchafesvimr(2,3,9),cplcchafesvrel(2,3,9),cplcchafesvrer(2,3,9),& \n& cplcchafvsel(2,9,6),cplcchafvser(2,9,6),cplcfdchasul(3,2,6),cplcfdchasur(3,2,6),       & \n& cplcfdchisdl(3,5,6),cplcfdchisdr(3,5,6),cplcfdfdahl(3,3,3),cplcfdfdahr(3,3,3),         & \n& cplcfdfdhhl(3,3,3),cplcfdfdhhr(3,3,3),cplcfdfdvgl(3,3),cplcfdfdvgr(3,3),               & \n& cplcfdfdvpl(3,3),cplcfdfdvpr(3,3),cplcfdfdvzl(3,3),cplcfdfdvzr(3,3),cplcfdfuhpml(3,3,2),& \n& cplcfdfuhpmr(3,3,2),cplcfdfuvwml(3,3),cplcfdfuvwmr(3,3),cplcfdglusdl(3,6),             & \n& cplcfdglusdr(3,6),cplcfechasviml(3,2,9),cplcfechasvimr(3,2,9),cplcfechasvrel(3,2,9),   & \n& cplcfechasvrer(3,2,9),cplcfechisel(3,5,6),cplcfechiser(3,5,6),cplcfefeahl(3,3,3),      & \n& cplcfefeahr(3,3,3),cplcfefehhl(3,3,3),cplcfefehhr(3,3,3),cplcfefevpl(3,3),             & \n& cplcfefevpr(3,3),cplcfefevzl(3,3),cplcfefevzr(3,3),cplcfefvhpml(3,9,2),cplcfefvhpmr(3,9,2),& \n& cplcfefvvwml(3,9),cplcfefvvwmr(3,9),cplcfuchisul(3,5,6),cplcfuchisur(3,5,6),           & \n& cplcfufdchpml(3,3,2),cplcfufdchpmr(3,3,2),cplcfufdcvwml(3,3),cplcfufdcvwmr(3,3),       & \n& cplcfufuahl(3,3,3),cplcfufuahr(3,3,3),cplcfufuhhl(3,3,3),cplcfufuhhr(3,3,3),           & \n& cplcfufuvgl(3,3),cplcfufuvgr(3,3),cplcfufuvpl(3,3),cplcfufuvpr(3,3),cplcfufuvzl(3,3),  & \n& cplcfufuvzr(3,3),cplcfuglusul(3,6),cplcfuglusur(3,6),cplchafucsdl(2,3,6),              & \n& cplchafucsdr(2,3,6),cplchichachpml(5,2,2),cplchichachpmr(5,2,2),cplchichacvwml(5,2),   & \n& cplchichacvwmr(5,2),cplchichiahl(5,5,3),cplchichiahr(5,5,3),cplchichihhl(5,5,3),       & \n& cplchichihhr(5,5,3),cplchichivzl(5,5),cplchichivzr(5,5),cplchifdcsdl(5,3,6),           & \n& cplchifdcsdr(5,3,6),cplchifecsel(5,3,6),cplchifecser(5,3,6),cplchifucsul(5,3,6),       & \n& cplchifucsur(5,3,6),cplchifvsviml(5,9,9),cplchifvsvimr(5,9,9),cplchifvsvrel(5,9,9),    & \n& cplchifvsvrer(5,9,9),cplchpmvpvwm(2),cplchpmvwmvz(2),cplcvwmvpvwm,cplcvwmvwmvz,        & \n& cplfvchacsel(9,2,6),cplfvchacser(9,2,6),cplfvfechpml(9,3,2),cplfvfechpmr(9,3,2),       & \n& cplfvfecvwml(9,3),cplfvfecvwmr(9,3),cplfvfvahl(9,9,3),cplfvfvahr(9,9,3),               & \n& cplfvfvhhl(9,9,3),cplfvfvhhr(9,9,3),cplfvfvvzl(9,9),cplfvfvvzr(9,9),cplglufdcsdl(3,6), & \n& cplglufdcsdr(3,6),cplglufucsul(3,6),cplglufucsur(3,6),cplhhchpmvwm(3,2),               & \n& cplhhcvwmvwm(3),cplhhhhhh(3,3,3),cplhhhpmchpm(3,2,2),cplhhhpmcvwm(3,2),cplhhsdcsd(3,6,6),& \n& cplhhsecse(3,6,6),cplhhsucsu(3,6,6),cplhhsvimsvim(3,9,9),cplhhsvimsvre(3,9,9),         & \n& cplhhsvresvre(3,9,9),cplhhvzvz(3),cplhpmchpmvp(2,2),cplhpmchpmvz(2,2),cplhpmcvwmvp(2), & \n& cplhpmcvwmvz(2),cplhpmsucsd(2,6,6),cplhpmsvimcse(2,9,6),cplhpmsvrecse(2,9,6),          & \n& cplsdchpmcsu(6,2,6),cplsdcsdvg(6,6),cplsdcsdvp(6,6),cplsdcsdvz(6,6),cplsdcsucvwm(6,6)\n\ncomplex(dp),intent(in) :: cplsecsevp(6,6),cplsecsevz(6,6),cplsesvimchpm(6,9,2),cplsesvimcvwm(6,9),               & \n& cplsesvrechpm(6,9,2),cplsesvrecvwm(6,9),cplsucsdvwm(6,6),cplsucsuvg(6,6),              & \n& cplsucsuvp(6,6),cplsucsuvz(6,6),cplsvimcsevwm(9,6),cplsvimsvrevz(9,9),cplsvrecsevwm(9,6),& \n& ctcplcchacfusdl(2,3,6),ctcplcchacfusdr(2,3,6),ctcplcchachaahl(2,2,3),ctcplcchachaahr(2,2,3),& \n& ctcplcchachahhl(2,2,3),ctcplcchachahhr(2,2,3),ctcplcchachavpl(2,2),ctcplcchachavpr(2,2),& \n& ctcplcchachavzl(2,2),ctcplcchachavzr(2,2),ctcplcchachihpml(2,5,2),ctcplcchachihpmr(2,5,2),& \n& ctcplcchachivwml(2,5),ctcplcchachivwmr(2,5),ctcplcchafdcsul(2,3,6),ctcplcchafdcsur(2,3,6),& \n& ctcplcchafesviml(2,3,9),ctcplcchafesvimr(2,3,9),ctcplcchafesvrel(2,3,9),               & \n& ctcplcchafesvrer(2,3,9),ctcplcchafvsel(2,9,6),ctcplcchafvser(2,9,6),gcplcchachihpml(2,5,2),& \n& gcplcchachihpmr(2,5,2),gcplchpmvpvwm(2),gcplhpmcvwmvp(2),goszcplcchachihpml(2,5,2),    & \n& goszcplcchachihpmr(2,5,2),goszcplchpmvpvwm(2),goszcplhpmcvwmvp(2),gzcplcchachihpml(2,5,2),& \n& gzcplcchachihpmr(2,5,2),gzcplchpmvpvwm(2),gzcplhpmcvwmvp(2),zcplcchacfusdl(2,3,6),     & \n& zcplcchacfusdr(2,3,6),zcplcchachaahl(2,2,3),zcplcchachaahr(2,2,3),zcplcchachahhl(2,2,3),& \n& zcplcchachahhr(2,2,3),zcplcchachavpl(2,2),zcplcchachavpr(2,2),zcplcchachavzl(2,2),     & \n& zcplcchachavzr(2,2),zcplcchachihpml(2,5,2),zcplcchachihpmr(2,5,2),zcplcchachivwml(2,5),& \n& zcplcchachivwmr(2,5),zcplcchafdcsul(2,3,6),zcplcchafdcsur(2,3,6),zcplcchafesviml(2,3,9),& \n& zcplcchafesvimr(2,3,9),zcplcchafesvrel(2,3,9),zcplcchafesvrer(2,3,9),zcplcchafvsel(2,9,6),& \n& zcplcchafvser(2,9,6),zcplcfdchasul(3,2,6),zcplcfdchasur(3,2,6),zcplcfdfdvpl(3,3),      & \n& zcplcfdfdvpr(3,3),zcplcfechasviml(3,2,9),zcplcfechasvimr(3,2,9),zcplcfechasvrel(3,2,9),& \n& zcplcfechasvrer(3,2,9),zcplcfefevpl(3,3),zcplcfefevpr(3,3),zcplcfufuvpl(3,3),          & \n& zcplcfufuvpr(3,3),zcplchafucsdl(2,3,6),zcplchafucsdr(2,3,6),zcplchichachpml(5,2,2),    & \n& zcplchichachpmr(5,2,2),zcplchichacvwml(5,2),zcplchichacvwmr(5,2),zcplchpmvpvwm(2),     & \n& zcplcvwmvpvwm,zcplfvchacsel(9,2,6),zcplfvchacser(9,2,6),zcplhpmchpmvp(2,2),            & \n& zcplhpmcvwmvp(2),zcplsdcsdvp(6,6),zcplsecsevp(6,6),zcplsucsuvp(6,6)\n\nreal(dp), intent(in) :: em, gs \ncomplex(dp),intent(in) :: zfvg,zffg,zfvp,zfvz,zfvwm,zfsd(6,6),zfsvim(9,9),zfsvre(9,9),zfsu(6,6),zfse(6,6),      & \n& zfhh(3,3),zfah(3,3),zfhpm(2,2),zfl0(5,5),zffv(9,9),zflm(2,2),zflp(2,2),zffel(3,3),     & \n& zffer(3,3),zffdl(3,3),zffdr(3,3),zfful(3,3),zffur(3,3),zfvpvz,zfvzvp\n\nreal(dp),intent(in) :: msdos(6),msd2os(6),msvimos(9),msvim2os(9),msvreos(9),msvre2os(9),msuos(6),            & \n& msu2os(6),mseos(6),mse2os(6),mhhos(3),mhh2os(3),mahos(3),mah2os(3),mhpmos(2),          & \n& mhpm2os(2),mchios(5),mchi2os(5),mfvos(9),mfv2os(9),mchaos(2),mcha2os(2),               & \n& mfeos(3),mfe2os(3),mfdos(3),mfd2os(3),mfuos(3),mfu2os(3),mgluos,mglu2os,               & \n& mvzos,mvz2os,mvwmos,mvwm2os,zhos(3,3),zaos(3,3),zpos(2,2)\n\ncomplex(dp),intent(in) :: zdos(6,6),zvios(9,9),zvros(9,9),zuos(6,6),zeos(6,6),znos(5,5),uvos(9,9),              & \n& umos(2,2),upos(2,2),zelos(3,3),zeros(3,3),zdlos(3,3),zdros(3,3),zulos(3,3),            & \n& zuros(3,3)\n\ncomplex(dp),intent(in) :: zruzd(6,6),zruzvi(9,9),zruzvr(9,9),zruzu(6,6),zruze(6,6),zruzh(3,3),zruza(3,3),       & \n& zruzp(2,2),zruzn(5,5),zruuv(9,9),zruum(2,2),zruup(2,2),zruzel(3,3),zruzer(3,3),        & \n& zruzdl(3,3),zruzdr(3,3),zruzul(3,3),zruzur(3,3)\n\nreal(dp), intent(in) :: mlambda, deltam \nreal(dp), intent(out) :: gp1lcha(2,168) \ninteger, intent(out) :: kont \nreal(dp) :: mvg,mvp,mvg2,mvp2, helfactor, phasespacefactor \ninteger :: i1,i2,i3,i4, isave, gt1, gt2, gt3 \n\ncomplex(dp) :: zruzdc(6, 6) \ncomplex(dp) :: zruzvic(9, 9) \ncomplex(dp) :: zruzvrc(9, 9) \ncomplex(dp) :: zruzuc(6, 6) \ncomplex(dp) :: zruzec(6, 6) \ncomplex(dp) :: zruzhc(3, 3) \ncomplex(dp) :: zruzac(3, 3) \ncomplex(dp) :: zruzpc(2, 2) \ncomplex(dp) :: zruznc(5, 5) \ncomplex(dp) :: zruuvc(9, 9) \ncomplex(dp) :: zruumc(2, 2) \ncomplex(dp) :: zruupc(2, 2) \ncomplex(dp) :: zruzelc(3, 3) \ncomplex(dp) :: zruzerc(3, 3) \ncomplex(dp) :: zruzdlc(3, 3) \ncomplex(dp) :: zruzdrc(3, 3) \ncomplex(dp) :: zruzulc(3, 3) \ncomplex(dp) :: zruzurc(3, 3) \nreal(dp) :: mrpchatochaah(2,2,3),mrgchatochaah(2,2,3), mrpzchatochaah(2,2,3),mrgzchatochaah(2,2,3) \nreal(dp) :: mvpchatochaah(2,2,3) \nreal(dp) :: rmsqtreechatochaah(2,2,3),rmsqwavechatochaah(2,2,3),rmsqvertexchatochaah(2,2,3) \ncomplex(dp) :: amptreechatochaah(2,2,2,3),ampwavechatochaah(2,2,2,3)=(0._dp,0._dp),ampvertexchatochaah(2,2,2,3)& \n & ,ampvertexiroschatochaah(2,2,2,3),ampvertexirdrchatochaah(2,2,2,3), ampsumchatochaah(2,2,2,3), ampsum2chatochaah(2,2,2,3) \ncomplex(dp) :: amptreezchatochaah(2,2,2,3),ampwavezchatochaah(2,2,2,3),ampvertexzchatochaah(2,2,2,3) \nreal(dp) :: ampsqchatochaah(2,2,3),  ampsqtreechatochaah(2,2,3) \nreal(dp) :: mrpchatochahh(2,2,3),mrgchatochahh(2,2,3), mrpzchatochahh(2,2,3),mrgzchatochahh(2,2,3) \nreal(dp) :: mvpchatochahh(2,2,3) \nreal(dp) :: rmsqtreechatochahh(2,2,3),rmsqwavechatochahh(2,2,3),rmsqvertexchatochahh(2,2,3) \ncomplex(dp) :: amptreechatochahh(2,2,2,3),ampwavechatochahh(2,2,2,3)=(0._dp,0._dp),ampvertexchatochahh(2,2,2,3)& \n & ,ampvertexiroschatochahh(2,2,2,3),ampvertexirdrchatochahh(2,2,2,3), ampsumchatochahh(2,2,2,3), ampsum2chatochahh(2,2,2,3) \ncomplex(dp) :: amptreezchatochahh(2,2,2,3),ampwavezchatochahh(2,2,2,3),ampvertexzchatochahh(2,2,2,3) \nreal(dp) :: ampsqchatochahh(2,2,3),  ampsqtreechatochahh(2,2,3) \nreal(dp) :: mrpchatochavz(2,2),mrgchatochavz(2,2), mrpzchatochavz(2,2),mrgzchatochavz(2,2) \nreal(dp) :: mvpchatochavz(2,2) \nreal(dp) :: rmsqtreechatochavz(2,2),rmsqwavechatochavz(2,2),rmsqvertexchatochavz(2,2) \ncomplex(dp) :: amptreechatochavz(4,2,2),ampwavechatochavz(4,2,2)=(0._dp,0._dp),ampvertexchatochavz(4,2,2)& \n & ,ampvertexiroschatochavz(4,2,2),ampvertexirdrchatochavz(4,2,2), ampsumchatochavz(4,2,2), ampsum2chatochavz(4,2,2) \ncomplex(dp) :: amptreezchatochavz(4,2,2),ampwavezchatochavz(4,2,2),ampvertexzchatochavz(4,2,2) \nreal(dp) :: ampsqchatochavz(2,2),  ampsqtreechatochavz(2,2) \nreal(dp) :: mrpchatochihpm(2,5,2),mrgchatochihpm(2,5,2), mrpzchatochihpm(2,5,2),mrgzchatochihpm(2,5,2) \nreal(dp) :: mvpchatochihpm(2,5,2) \nreal(dp) :: rmsqtreechatochihpm(2,5,2),rmsqwavechatochihpm(2,5,2),rmsqvertexchatochihpm(2,5,2) \ncomplex(dp) :: amptreechatochihpm(2,2,5,2),ampwavechatochihpm(2,2,5,2)=(0._dp,0._dp),ampvertexchatochihpm(2,2,5,2)& \n & ,ampvertexiroschatochihpm(2,2,5,2),ampvertexirdrchatochihpm(2,2,5,2), ampsumchatochihpm(2,2,5,2), ampsum2chatochihpm(2,2,5,2) \ncomplex(dp) :: amptreezchatochihpm(2,2,5,2),ampwavezchatochihpm(2,2,5,2),ampvertexzchatochihpm(2,2,5,2) \nreal(dp) :: ampsqchatochihpm(2,5,2),  ampsqtreechatochihpm(2,5,2) \nreal(dp) :: mrpchatochivwm(2,5),mrgchatochivwm(2,5), mrpzchatochivwm(2,5),mrgzchatochivwm(2,5) \nreal(dp) :: mvpchatochivwm(2,5) \nreal(dp) :: rmsqtreechatochivwm(2,5),rmsqwavechatochivwm(2,5),rmsqvertexchatochivwm(2,5) \ncomplex(dp) :: amptreechatochivwm(4,2,5),ampwavechatochivwm(4,2,5)=(0._dp,0._dp),ampvertexchatochivwm(4,2,5)& \n & ,ampvertexiroschatochivwm(4,2,5),ampvertexirdrchatochivwm(4,2,5), ampsumchatochivwm(4,2,5), ampsum2chatochivwm(4,2,5) \ncomplex(dp) :: amptreezchatochivwm(4,2,5),ampwavezchatochivwm(4,2,5),ampvertexzchatochivwm(4,2,5) \nreal(dp) :: ampsqchatochivwm(2,5),  ampsqtreechatochivwm(2,5) \nreal(dp) :: mrpchatofdcsu(2,3,6),mrgchatofdcsu(2,3,6), mrpzchatofdcsu(2,3,6),mrgzchatofdcsu(2,3,6) \nreal(dp) :: mvpchatofdcsu(2,3,6) \nreal(dp) :: rmsqtreechatofdcsu(2,3,6),rmsqwavechatofdcsu(2,3,6),rmsqvertexchatofdcsu(2,3,6) \ncomplex(dp) :: amptreechatofdcsu(2,2,3,6),ampwavechatofdcsu(2,2,3,6)=(0._dp,0._dp),ampvertexchatofdcsu(2,2,3,6)& \n & ,ampvertexiroschatofdcsu(2,2,3,6),ampvertexirdrchatofdcsu(2,2,3,6), ampsumchatofdcsu(2,2,3,6), ampsum2chatofdcsu(2,2,3,6) \ncomplex(dp) :: amptreezchatofdcsu(2,2,3,6),ampwavezchatofdcsu(2,2,3,6),ampvertexzchatofdcsu(2,2,3,6) \nreal(dp) :: ampsqchatofdcsu(2,3,6),  ampsqtreechatofdcsu(2,3,6) \nreal(dp) :: mrpchatofesvim(2,3,9),mrgchatofesvim(2,3,9), mrpzchatofesvim(2,3,9),mrgzchatofesvim(2,3,9) \nreal(dp) :: mvpchatofesvim(2,3,9) \nreal(dp) :: rmsqtreechatofesvim(2,3,9),rmsqwavechatofesvim(2,3,9),rmsqvertexchatofesvim(2,3,9) \ncomplex(dp) :: amptreechatofesvim(2,2,3,9),ampwavechatofesvim(2,2,3,9)=(0._dp,0._dp),ampvertexchatofesvim(2,2,3,9)& \n & ,ampvertexiroschatofesvim(2,2,3,9),ampvertexirdrchatofesvim(2,2,3,9), ampsumchatofesvim(2,2,3,9), ampsum2chatofesvim(2,2,3,9) \ncomplex(dp) :: amptreezchatofesvim(2,2,3,9),ampwavezchatofesvim(2,2,3,9),ampvertexzchatofesvim(2,2,3,9) \nreal(dp) :: ampsqchatofesvim(2,3,9),  ampsqtreechatofesvim(2,3,9) \nreal(dp) :: mrpchatofesvre(2,3,9),mrgchatofesvre(2,3,9), mrpzchatofesvre(2,3,9),mrgzchatofesvre(2,3,9) \nreal(dp) :: mvpchatofesvre(2,3,9) \nreal(dp) :: rmsqtreechatofesvre(2,3,9),rmsqwavechatofesvre(2,3,9),rmsqvertexchatofesvre(2,3,9) \ncomplex(dp) :: amptreechatofesvre(2,2,3,9),ampwavechatofesvre(2,2,3,9)=(0._dp,0._dp),ampvertexchatofesvre(2,2,3,9)& \n & ,ampvertexiroschatofesvre(2,2,3,9),ampvertexirdrchatofesvre(2,2,3,9), ampsumchatofesvre(2,2,3,9), ampsum2chatofesvre(2,2,3,9) \ncomplex(dp) :: amptreezchatofesvre(2,2,3,9),ampwavezchatofesvre(2,2,3,9),ampvertexzchatofesvre(2,2,3,9) \nreal(dp) :: ampsqchatofesvre(2,3,9),  ampsqtreechatofesvre(2,3,9) \nreal(dp) :: mrpchatofvse(2,9,6),mrgchatofvse(2,9,6), mrpzchatofvse(2,9,6),mrgzchatofvse(2,9,6) \nreal(dp) :: mvpchatofvse(2,9,6) \nreal(dp) :: rmsqtreechatofvse(2,9,6),rmsqwavechatofvse(2,9,6),rmsqvertexchatofvse(2,9,6) \ncomplex(dp) :: amptreechatofvse(2,2,9,6),ampwavechatofvse(2,2,9,6)=(0._dp,0._dp),ampvertexchatofvse(2,2,9,6)& \n & ,ampvertexiroschatofvse(2,2,9,6),ampvertexirdrchatofvse(2,2,9,6), ampsumchatofvse(2,2,9,6), ampsum2chatofvse(2,2,9,6) \ncomplex(dp) :: amptreezchatofvse(2,2,9,6),ampwavezchatofvse(2,2,9,6),ampvertexzchatofvse(2,2,9,6) \nreal(dp) :: ampsqchatofvse(2,9,6),  ampsqtreechatofvse(2,9,6) \nreal(dp) :: mrpchatocfusd(2,3,6),mrgchatocfusd(2,3,6), mrpzchatocfusd(2,3,6),mrgzchatocfusd(2,3,6) \nreal(dp) :: mvpchatocfusd(2,3,6) \nreal(dp) :: rmsqtreechatocfusd(2,3,6),rmsqwavechatocfusd(2,3,6),rmsqvertexchatocfusd(2,3,6) \ncomplex(dp) :: amptreechatocfusd(2,2,3,6),ampwavechatocfusd(2,2,3,6)=(0._dp,0._dp),ampvertexchatocfusd(2,2,3,6)& \n & ,ampvertexiroschatocfusd(2,2,3,6),ampvertexirdrchatocfusd(2,2,3,6), ampsumchatocfusd(2,2,3,6), ampsum2chatocfusd(2,2,3,6) \ncomplex(dp) :: amptreezchatocfusd(2,2,3,6),ampwavezchatocfusd(2,2,3,6),ampvertexzchatocfusd(2,2,3,6) \nreal(dp) :: ampsqchatocfusd(2,3,6),  ampsqtreechatocfusd(2,3,6) \nreal(dp) :: mrpchatochavp(2,2),mrgchatochavp(2,2), mrpzchatochavp(2,2),mrgzchatochavp(2,2) \nreal(dp) :: mvpchatochavp(2,2) \nreal(dp) :: rmsqtreechatochavp(2,2),rmsqwavechatochavp(2,2),rmsqvertexchatochavp(2,2) \ncomplex(dp) :: amptreechatochavp(4,2,2),ampwavechatochavp(4,2,2)=(0._dp,0._dp),ampvertexchatochavp(4,2,2)& \n & ,ampvertexiroschatochavp(4,2,2),ampvertexirdrchatochavp(4,2,2), ampsumchatochavp(4,2,2), ampsum2chatochavp(4,2,2) \ncomplex(dp) :: amptreezchatochavp(4,2,2),ampwavezchatochavp(4,2,2),ampvertexzchatochavp(4,2,2) \nreal(dp) :: ampsqchatochavp(2,2),  ampsqtreechatochavp(2,2) \nwrite(*,*) \"calculating one-loop decays of cha \" \nkont = 0 \nmvg = mlambda \nmvp = mlambda \nmvg2 = mlambda**2 \nmvp2 = mlambda**2 \n\nzruzdc = conjg(zruzd)\nzruzvic = conjg(zruzvi)\nzruzvrc = conjg(zruzvr)\nzruzuc = conjg(zruzu)\nzruzec = conjg(zruze)\nzruzhc = conjg(zruzh)\nzruzac = conjg(zruza)\nzruzpc = conjg(zruzp)\nzruznc = conjg(zruzn)\nzruuvc = conjg(zruuv)\nzruumc = conjg(zruum)\nzruupc = conjg(zruup)\nzruzelc = conjg(zruzel)\nzruzerc = conjg(zruzer)\nzruzdlc = conjg(zruzdl)\nzruzdrc = conjg(zruzdr)\nzruzulc = conjg(zruzul)\nzruzurc = conjg(zruzur)\n\n ! counter \nisave = 1 \n\nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! cha ah\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatochaah(cplcchachaahl,cplcchachaahr,mah,            & \n& mcha,mah2,mcha2,amptreechatochaah)\n\n  else \ncall amplitude_tree_ninvseesaw_chatochaah(zcplcchachaahl,zcplcchachaahr,              & \n& mah,mcha,mah2,mcha2,amptreechatochaah)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatochaah(mlambda,em,gs,cplcchachaahl,cplcchachaahr,      & \n& mahos,mchaos,mrpchatochaah,mrgchatochaah)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatochaah(mlambda,em,gs,zcplcchachaahl,zcplcchachaahr,    & \n& mahos,mchaos,mrpchatochaah,mrgchatochaah)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatochaah(mlambda,em,gs,cplcchachaahl,cplcchachaahr,      & \n& mah,mcha,mrpchatochaah,mrgchatochaah)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatochaah(mlambda,em,gs,zcplcchachaahl,zcplcchachaahr,    & \n& mah,mcha,mrpchatochaah,mrgchatochaah)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochaah(cplcchachaahl,cplcchachaahr,ctcplcchachaahl,& \n& ctcplcchachaahr,mah,mah2,mcha,mcha2,zfah,zflm,zflp,ampwavechatochaah)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochaah(mah,mcha,mchi,mfd,mfe,mfu,mfv,            & \n& mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfe2,              & \n& mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahah,           & \n& cplahahhh,cplcchachaahl,cplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,           & \n& cplcfdfdahr,cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,     & \n& cplahhhhh,cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,        & \n& cplahsvimsvim,cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,  & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,             & \n& cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,              & \n& cplcchafesvrer,cplcchafvsel,cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexchatochaah)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatochaah(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahah,      & \n& cplahahhh,cplcchachaahl,cplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,           & \n& cplcfdfdahr,cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,     & \n& cplahhhhh,cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,        & \n& cplahsvimsvim,cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,  & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,             & \n& cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,              & \n& cplcchafesvrer,cplcchafvsel,cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexirdrchatochaah)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochaah(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplahahah,cplahahhh,        & \n& zcplcchachaahl,zcplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,cplcfdfdahr,       & \n& cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,cplahhhhh,       & \n& cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,cplahsvimsvim,    & \n& cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,cplchichacvwml, & \n& cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,      & \n& cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,  & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml, & \n& cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,              & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcchafvsel,              & \n& cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochaah)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochaah(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahah,      & \n& cplahahhh,zcplcchachaahl,zcplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,         & \n& cplcfdfdahr,cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,     & \n& cplahhhhh,cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,        & \n& cplahsvimsvim,cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,  & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,             & \n& cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,              & \n& cplcchafesvrer,cplcchafvsel,cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochaah)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochaah(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplahahah,cplahahhh,        & \n& cplcchachaahl,cplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,cplcfdfdahr,         & \n& cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,cplahhhhh,       & \n& cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,cplahsvimsvim,    & \n& cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,cplchichacvwml, & \n& cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,      & \n& cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,  & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml, & \n& cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,              & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcchafvsel,              & \n& cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochaah)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochaah(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahah,      & \n& cplahahhh,cplcchachaahl,cplcchachaahr,cplchichiahl,cplchichiahr,cplcfdfdahl,           & \n& cplcfdfdahr,cplcfefeahl,cplcfefeahr,cplcfufuahl,cplcfufuahr,cplfvfvahl,cplfvfvahr,     & \n& cplahhhhh,cplahhhvz,cplahhpmchpm,cplahhpmcvwm,cplahsdcsd,cplahsecse,cplahsucsu,        & \n& cplahsvimsvim,cplahsvimsvre,cplahsvresvre,cplahchpmvwm,cplchichachpml,cplchichachpmr,  & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,             & \n& cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,              & \n& cplcchafesvrer,cplcchafvsel,cplcchafvser,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochaah)\n\n end if \n end if \nampvertexchatochaah = ampvertexchatochaah -  ampvertexirdrchatochaah! +  ampvertexiroschatochaah ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatochaah=0._dp \nampvertexzchatochaah=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochaah(1,gt2,:,:) = ampwavezchatochaah(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatochaah(1,gt1,:,:) \nampvertexzchatochaah(1,gt2,:,:)= ampvertexzchatochaah(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatochaah(1,gt1,:,:) \nampwavezchatochaah(2,gt2,:,:) = ampwavezchatochaah(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatochaah(2,gt1,:,:) \nampvertexzchatochaah(2,gt2,:,:)= ampvertexzchatochaah(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatochaah(2,gt1,:,:) \n end do \nend do \nampwavechatochaah=ampwavezchatochaah \nampvertexchatochaah= ampvertexzchatochaah\n! final state 1 \nampwavezchatochaah=0._dp \nampvertexzchatochaah=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochaah(1,:,gt2,:) = ampwavezchatochaah(1,:,gt2,:)+zruum(gt2,gt1)*ampwavechatochaah(1,:,gt1,:) \nampvertexzchatochaah(1,:,gt2,:)= ampvertexzchatochaah(1,:,gt2,:)+zruum(gt2,gt1)*ampvertexchatochaah(1,:,gt1,:) \nampwavezchatochaah(2,:,gt2,:) = ampwavezchatochaah(2,:,gt2,:)+zruupc(gt2,gt1)*ampwavechatochaah(2,:,gt1,:) \nampvertexzchatochaah(2,:,gt2,:)= ampvertexzchatochaah(2,:,gt2,:)+zruupc(gt2,gt1)*ampvertexchatochaah(2,:,gt1,:) \n end do \nend do \nampwavechatochaah=ampwavezchatochaah \nampvertexchatochaah= ampvertexzchatochaah\n! final state 2 \nampwavezchatochaah=0._dp \nampvertexzchatochaah=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatochaah(:,:,:,gt2) = ampwavezchatochaah(:,:,:,gt2)+zruza(gt2,gt1)*ampwavechatochaah(:,:,:,gt1) \nampvertexzchatochaah(:,:,:,gt2)= ampvertexzchatochaah(:,:,:,gt2)+zruza(gt2,gt1)*ampvertexchatochaah(:,:,:,gt1) \n end do \nend do \nampwavechatochaah=ampwavezchatochaah \nampvertexchatochaah= ampvertexzchatochaah\nend if\nif (shiftirdiv) then \nampvertexchatochaah = ampvertexchatochaah  +  ampvertexiroschatochaah\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->cha ah -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatochaah = amptreechatochaah \n ampsum2chatochaah = amptreechatochaah + 2._dp*ampwavechatochaah + 2._dp*ampvertexchatochaah  \nelse \n ampsumchatochaah = amptreechatochaah + ampwavechatochaah + ampvertexchatochaah\n ampsum2chatochaah = amptreechatochaah + ampwavechatochaah + ampvertexchatochaah \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochaah = amptreechatochaah\n ampsum2chatochaah = amptreechatochaah \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,2\n    do gt3=2,3\nif (((oskinematics).and.(mchaos(gt1).gt.(mchaos(gt2)+mahos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mcha(gt2)+mah(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatochaah = amptreechatochaah\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatochaah(gt1, gt2, gt3) \n  ampsum2chatochaah = 2._dp*ampwavechatochaah\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatochaah(gt1, gt2, gt3) \n  ampsum2chatochaah = 2._dp*ampvertexchatochaah\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatochaah(gt1, gt2, gt3) \n  ampsum2chatochaah = amptreechatochaah + 2._dp*ampwavechatochaah + 2._dp*ampvertexchatochaah\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatochaah(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatochaah = amptreechatochaah\n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \n  ampsqtreechatochaah(gt1, gt2, gt3) = ampsqchatochaah(gt1, gt2, gt3)  \n  ampsum2chatochaah = + 2._dp*ampwavechatochaah + 2._dp*ampvertexchatochaah\n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mahos(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \n  ampsqchatochaah(gt1, gt2, gt3) = ampsqchatochaah(gt1, gt2, gt3) + ampsqtreechatochaah(gt1, gt2, gt3)  \nelse  \n  ampsum2chatochaah = amptreechatochaah\n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \n  ampsqtreechatochaah(gt1, gt2, gt3) = ampsqchatochaah(gt1, gt2, gt3)  \n  ampsum2chatochaah = + 2._dp*ampwavechatochaah + 2._dp*ampvertexchatochaah\n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mah(gt3),ampsumchatochaah(:,gt1, gt2, gt3),ampsum2chatochaah(:,gt1, gt2, gt3),ampsqchatochaah(gt1, gt2, gt3)) \n  ampsqchatochaah(gt1, gt2, gt3) = ampsqchatochaah(gt1, gt2, gt3) + ampsqtreechatochaah(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatochaah(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochaah(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchaos(gt2),mahos(gt3),helfactor*ampsqchatochaah(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mcha(gt2),mah(gt3),helfactor*ampsqchatochaah(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatochaah(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochaah(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatochaah(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochaah(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatochaah(gt1, gt2, gt3) + mrgchatochaah(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatochaah(gt1, gt2, gt3) + mrgchatochaah(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! cha hh\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatochahh(cplcchachahhl,cplcchachahhr,mcha,           & \n& mhh,mcha2,mhh2,amptreechatochahh)\n\n  else \ncall amplitude_tree_ninvseesaw_chatochahh(zcplcchachahhl,zcplcchachahhr,              & \n& mcha,mhh,mcha2,mhh2,amptreechatochahh)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatochahh(mlambda,em,gs,cplcchachahhl,cplcchachahhr,      & \n& mchaos,mhhos,mrpchatochahh,mrgchatochahh)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatochahh(mlambda,em,gs,zcplcchachahhl,zcplcchachahhr,    & \n& mchaos,mhhos,mrpchatochahh,mrgchatochahh)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatochahh(mlambda,em,gs,cplcchachahhl,cplcchachahhr,      & \n& mcha,mhh,mrpchatochahh,mrgchatochahh)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatochahh(mlambda,em,gs,zcplcchachahhl,zcplcchachahhr,    & \n& mcha,mhh,mrpchatochahh,mrgchatochahh)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochahh(cplcchachahhl,cplcchachahhr,ctcplcchachahhl,& \n& ctcplcchachahhr,mcha,mcha2,mhh,mhh2,zfhh,zflm,zflp,ampwavechatochahh)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochahh(mah,mcha,mchi,mfd,mfe,mfu,mfv,            & \n& mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfe2,              & \n& mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahhh,           & \n& cplcchachaahl,cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,         & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplchichihhl,cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,  & \n& cplcchachivwmr,cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfufuhhl,cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,               & \n& cplhhhhhh,cplhhhpmchpm,cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,    & \n& cplhhsvimsvre,cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,         & \n& cplcchacfusdr,ampvertexchatochahh)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatochahh(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahhh,      & \n& cplcchachaahl,cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,         & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplchichihhl,cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,  & \n& cplcchachivwmr,cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfufuhhl,cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,               & \n& cplhhhhhh,cplhhhpmchpm,cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,    & \n& cplhhsvimsvre,cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,         & \n& cplcchacfusdr,ampvertexirdrchatochahh)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochahh(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplahahhh,cplcchachaahl,    & \n& cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,        & \n& cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,zcplcchachahhl,     & \n& zcplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel, & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,   & \n& cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,              & \n& cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,cplcfefehhr,           & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfufuhhl,               & \n& cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,cplhhhhhh,cplhhhpmchpm,    & \n& cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,cplhhsvimsvre,             & \n& cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,cplcchacfusdr,         & \n& ampvertexiroschatochahh)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochahh(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahhh,      & \n& cplcchachaahl,cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,         & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& zcplcchachahhl,zcplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr, & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplchichihhl,cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,  & \n& cplcchachivwmr,cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfufuhhl,cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,               & \n& cplhhhhhh,cplhhhpmchpm,cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,    & \n& cplhhsvimsvre,cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,         & \n& cplcchacfusdr,ampvertexiroschatochahh)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochahh(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplahahhh,cplcchachaahl,    & \n& cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,        & \n& cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,      & \n& cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,  & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,   & \n& cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,              & \n& cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,cplcfefehhr,           & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfufuhhl,               & \n& cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,cplhhhhhh,cplhhhpmchpm,    & \n& cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,cplhhsvimsvre,             & \n& cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,cplcchacfusdr,         & \n& ampvertexiroschatochahh)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochahh(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplahahhh,      & \n& cplcchachaahl,cplcchachaahr,cplahhhhh,cplahhhvz,cplchichachpml,cplchichachpmr,         & \n& cplchichacvwml,cplchichacvwmr,cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,     & \n& cplcchachahhl,cplcchachahhr,cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,   & \n& cplcfechasvrel,cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,               & \n& cplcchachavzr,cplchichihhl,cplchichihhr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,  & \n& cplcchachivwmr,cplcfdfdhhl,cplcfdfdhhr,cplcchafdcsul,cplcchafdcsur,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfufuhhl,cplcfufuhhr,cplfvfvhhl,cplfvfvhhr,cplcchafvsel,cplcchafvser,               & \n& cplhhhhhh,cplhhhpmchpm,cplhhhpmcvwm,cplhhsdcsd,cplhhsecse,cplhhsucsu,cplhhsvimsvim,    & \n& cplhhsvimsvre,cplhhsvresvre,cplhhchpmvwm,cplhhcvwmvwm,cplhhvzvz,cplcchacfusdl,         & \n& cplcchacfusdr,ampvertexiroschatochahh)\n\n end if \n end if \nampvertexchatochahh = ampvertexchatochahh -  ampvertexirdrchatochahh! +  ampvertexiroschatochahh ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatochahh=0._dp \nampvertexzchatochahh=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochahh(1,gt2,:,:) = ampwavezchatochahh(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatochahh(1,gt1,:,:) \nampvertexzchatochahh(1,gt2,:,:)= ampvertexzchatochahh(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatochahh(1,gt1,:,:) \nampwavezchatochahh(2,gt2,:,:) = ampwavezchatochahh(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatochahh(2,gt1,:,:) \nampvertexzchatochahh(2,gt2,:,:)= ampvertexzchatochahh(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatochahh(2,gt1,:,:) \n end do \nend do \nampwavechatochahh=ampwavezchatochahh \nampvertexchatochahh= ampvertexzchatochahh\n! final state 1 \nampwavezchatochahh=0._dp \nampvertexzchatochahh=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochahh(1,:,gt2,:) = ampwavezchatochahh(1,:,gt2,:)+zruum(gt2,gt1)*ampwavechatochahh(1,:,gt1,:) \nampvertexzchatochahh(1,:,gt2,:)= ampvertexzchatochahh(1,:,gt2,:)+zruum(gt2,gt1)*ampvertexchatochahh(1,:,gt1,:) \nampwavezchatochahh(2,:,gt2,:) = ampwavezchatochahh(2,:,gt2,:)+zruupc(gt2,gt1)*ampwavechatochahh(2,:,gt1,:) \nampvertexzchatochahh(2,:,gt2,:)= ampvertexzchatochahh(2,:,gt2,:)+zruupc(gt2,gt1)*ampvertexchatochahh(2,:,gt1,:) \n end do \nend do \nampwavechatochahh=ampwavezchatochahh \nampvertexchatochahh= ampvertexzchatochahh\n! final state 2 \nampwavezchatochahh=0._dp \nampvertexzchatochahh=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatochahh(:,:,:,gt2) = ampwavezchatochahh(:,:,:,gt2)+zruzh(gt2,gt1)*ampwavechatochahh(:,:,:,gt1) \nampvertexzchatochahh(:,:,:,gt2)= ampvertexzchatochahh(:,:,:,gt2)+zruzh(gt2,gt1)*ampvertexchatochahh(:,:,:,gt1) \n end do \nend do \nampwavechatochahh=ampwavezchatochahh \nampvertexchatochahh= ampvertexzchatochahh\nend if\nif (shiftirdiv) then \nampvertexchatochahh = ampvertexchatochahh  +  ampvertexiroschatochahh\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->cha hh -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatochahh = amptreechatochahh \n ampsum2chatochahh = amptreechatochahh + 2._dp*ampwavechatochahh + 2._dp*ampvertexchatochahh  \nelse \n ampsumchatochahh = amptreechatochahh + ampwavechatochahh + ampvertexchatochahh\n ampsum2chatochahh = amptreechatochahh + ampwavechatochahh + ampvertexchatochahh \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochahh = amptreechatochahh\n ampsum2chatochahh = amptreechatochahh \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,2\n    do gt3=1,3\nif (((oskinematics).and.(mchaos(gt1).gt.(mchaos(gt2)+mhhos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mcha(gt2)+mhh(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatochahh = amptreechatochahh\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatochahh(gt1, gt2, gt3) \n  ampsum2chatochahh = 2._dp*ampwavechatochahh\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatochahh(gt1, gt2, gt3) \n  ampsum2chatochahh = 2._dp*ampvertexchatochahh\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatochahh(gt1, gt2, gt3) \n  ampsum2chatochahh = amptreechatochahh + 2._dp*ampwavechatochahh + 2._dp*ampvertexchatochahh\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatochahh(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatochahh = amptreechatochahh\n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \n  ampsqtreechatochahh(gt1, gt2, gt3) = ampsqchatochahh(gt1, gt2, gt3)  \n  ampsum2chatochahh = + 2._dp*ampwavechatochahh + 2._dp*ampvertexchatochahh\n  call squareamp_ftofs(mchaos(gt1),mchaos(gt2),mhhos(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \n  ampsqchatochahh(gt1, gt2, gt3) = ampsqchatochahh(gt1, gt2, gt3) + ampsqtreechatochahh(gt1, gt2, gt3)  \nelse  \n  ampsum2chatochahh = amptreechatochahh\n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \n  ampsqtreechatochahh(gt1, gt2, gt3) = ampsqchatochahh(gt1, gt2, gt3)  \n  ampsum2chatochahh = + 2._dp*ampwavechatochahh + 2._dp*ampvertexchatochahh\n  call squareamp_ftofs(mcha(gt1),mcha(gt2),mhh(gt3),ampsumchatochahh(:,gt1, gt2, gt3),ampsum2chatochahh(:,gt1, gt2, gt3),ampsqchatochahh(gt1, gt2, gt3)) \n  ampsqchatochahh(gt1, gt2, gt3) = ampsqchatochahh(gt1, gt2, gt3) + ampsqtreechatochahh(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatochahh(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochahh(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchaos(gt2),mhhos(gt3),helfactor*ampsqchatochahh(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mcha(gt2),mhh(gt3),helfactor*ampsqchatochahh(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatochahh(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochahh(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatochahh(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochahh(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatochahh(gt1, gt2, gt3) + mrgchatochahh(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatochahh(gt1, gt2, gt3) + mrgchatochahh(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! cha vz\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatochavz(cplcchachavzl,cplcchachavzr,mcha,           & \n& mvz,mcha2,mvz2,amptreechatochavz)\n\n  else \ncall amplitude_tree_ninvseesaw_chatochavz(zcplcchachavzl,zcplcchachavzr,              & \n& mcha,mvz,mcha2,mvz2,amptreechatochavz)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatochavz(mlambda,em,gs,cplcchachavzl,cplcchachavzr,      & \n& mchaos,mvzos,mrpchatochavz,mrgchatochavz)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatochavz(mlambda,em,gs,zcplcchachavzl,zcplcchachavzr,    & \n& mchaos,mvzos,mrpchatochavz,mrgchatochavz)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatochavz(mlambda,em,gs,cplcchachavzl,cplcchachavzr,      & \n& mcha,mvz,mrpchatochavz,mrgchatochavz)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatochavz(mlambda,em,gs,zcplcchachavzl,zcplcchachavzr,    & \n& mcha,mvz,mrpchatochavz,mrgchatochavz)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochavz(cplcchachavpl,cplcchachavpr,cplcchachavzl,  & \n& cplcchachavzr,ctcplcchachavpl,ctcplcchachavpr,ctcplcchachavzl,ctcplcchachavzr,         & \n& mcha,mcha2,mvp,mvp2,mvz,mvz2,zflm,zflp,zfvpvz,zfvz,ampwavechatochavz)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochavz(mah,mcha,mchi,mfd,mfe,mfu,mfv,            & \n& mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfe2,              & \n& mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,       & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichivzl,cplchichivzr,     & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexchatochavz)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatochavz(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichivzl,cplchichivzr,     & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexirdrchatochavz)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochavz(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,zcplcchachavzl,zcplcchachavzr,cplchichivzl,cplchichivzr,   & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochavz)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochavz(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,zcplcchachavzl,zcplcchachavzr,cplchichivzl,cplchichivzr,   & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochavz)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochavz(mahos,mchaos,mchios,mfdos,             & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichivzl,cplchichivzr,     & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochavz)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochavz(mah,mcha,mchi,mfd,mfe,mfu,             & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplahhhvz,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,   & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichivzl,cplchichivzr,     & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplcfdfdvzl,               & \n& cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,  & \n& cplcchafesvrer,cplcfefevzl,cplcfefevzr,cplcfufuvzl,cplcfufuvzr,cplfvfvvzl,             & \n& cplfvfvvzr,cplcchafvsel,cplcchafvser,cplhhvzvz,cplhpmchpmvz,cplhpmcvwmvz,              & \n& cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsecsevz,cplsucsuvz,cplsvimsvrevz,            & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochavz)\n\n end if \n end if \nampvertexchatochavz = ampvertexchatochavz -  ampvertexirdrchatochavz! +  ampvertexiroschatochavz ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatochavz=0._dp \nampvertexzchatochavz=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochavz(1,gt2,:) = ampwavezchatochavz(1,gt2,:)+zruumc(gt2,gt1)*ampwavechatochavz(1,gt1,:) \nampvertexzchatochavz(1,gt2,:)= ampvertexzchatochavz(1,gt2,:) + zruumc(gt2,gt1)*ampvertexchatochavz(1,gt1,:) \nampwavezchatochavz(2,gt2,:) = ampwavezchatochavz(2,gt2,:)+zruup(gt2,gt1)*ampwavechatochavz(2,gt1,:) \nampvertexzchatochavz(2,gt2,:)= ampvertexzchatochavz(2,gt2,:) + zruup(gt2,gt1)*ampvertexchatochavz(2,gt1,:) \nampwavezchatochavz(3,gt2,:) = ampwavezchatochavz(3,gt2,:)+zruumc(gt2,gt1)*ampwavechatochavz(3,gt1,:) \nampvertexzchatochavz(3,gt2,:)= ampvertexzchatochavz(3,gt2,:) + zruumc(gt2,gt1)*ampvertexchatochavz(3,gt1,:) \nampwavezchatochavz(4,gt2,:) = ampwavezchatochavz(4,gt2,:)+zruup(gt2,gt1)*ampwavechatochavz(4,gt1,:) \nampvertexzchatochavz(4,gt2,:)= ampvertexzchatochavz(4,gt2,:) + zruup(gt2,gt1)*ampvertexchatochavz(4,gt1,:) \n end do \nend do \nampwavechatochavz=ampwavezchatochavz \nampvertexchatochavz= ampvertexzchatochavz\n! final state 1 \nampwavezchatochavz=0._dp \nampvertexzchatochavz=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochavz(1,:,gt2) = ampwavezchatochavz(1,:,gt2)+zruum(gt2,gt1)*ampwavechatochavz(1,:,gt1) \nampvertexzchatochavz(1,:,gt2)= ampvertexzchatochavz(1,:,gt2)+zruum(gt2,gt1)*ampvertexchatochavz(1,:,gt1) \nampwavezchatochavz(2,:,gt2) = ampwavezchatochavz(2,:,gt2)+zruupc(gt2,gt1)*ampwavechatochavz(2,:,gt1) \nampvertexzchatochavz(2,:,gt2)= ampvertexzchatochavz(2,:,gt2)+zruupc(gt2,gt1)*ampvertexchatochavz(2,:,gt1) \nampwavezchatochavz(3,:,gt2) = ampwavezchatochavz(3,:,gt2)+zruum(gt2,gt1)*ampwavechatochavz(3,:,gt1) \nampvertexzchatochavz(3,:,gt2)= ampvertexzchatochavz(3,:,gt2)+zruum(gt2,gt1)*ampvertexchatochavz(3,:,gt1) \nampwavezchatochavz(4,:,gt2) = ampwavezchatochavz(4,:,gt2)+zruupc(gt2,gt1)*ampwavechatochavz(4,:,gt1) \nampvertexzchatochavz(4,:,gt2)= ampvertexzchatochavz(4,:,gt2)+zruupc(gt2,gt1)*ampvertexchatochavz(4,:,gt1) \n end do \nend do \nampwavechatochavz=ampwavezchatochavz \nampvertexchatochavz= ampvertexzchatochavz\nend if\nif (shiftirdiv) then \nampvertexchatochavz = ampvertexchatochavz  +  ampvertexiroschatochavz\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->cha vz -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatochavz = amptreechatochavz \n ampsum2chatochavz = amptreechatochavz + 2._dp*ampwavechatochavz + 2._dp*ampvertexchatochavz  \nelse \n ampsumchatochavz = amptreechatochavz + ampwavechatochavz + ampvertexchatochavz\n ampsum2chatochavz = amptreechatochavz + ampwavechatochavz + ampvertexchatochavz \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochavz = amptreechatochavz\n ampsum2chatochavz = amptreechatochavz \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,2\nif (((oskinematics).and.(mchaos(gt1).gt.(mchaos(gt2)+mvzos))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mcha(gt2)+mvz)))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2 \n  ampsum2chatochavz = amptreechatochavz\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatochavz(gt1, gt2) \n  ampsum2chatochavz = 2._dp*ampwavechatochavz\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatochavz(gt1, gt2) \n  ampsum2chatochavz = 2._dp*ampvertexchatochavz\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatochavz(gt1, gt2) \n  ampsum2chatochavz = amptreechatochavz + 2._dp*ampwavechatochavz + 2._dp*ampvertexchatochavz\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatochavz(gt1, gt2) \n end if \nif (oskinematics) then \n  ampsum2chatochavz = amptreechatochavz\n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \n  ampsqtreechatochavz(gt1, gt2) = ampsqchatochavz(gt1, gt2)  \n  ampsum2chatochavz = + 2._dp*ampwavechatochavz + 2._dp*ampvertexchatochavz\n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),mvzos,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \n  ampsqchatochavz(gt1, gt2) = ampsqchatochavz(gt1, gt2) + ampsqtreechatochavz(gt1, gt2)  \nelse  \n  ampsum2chatochavz = amptreechatochavz\n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \n  ampsqtreechatochavz(gt1, gt2) = ampsqchatochavz(gt1, gt2)  \n  ampsum2chatochavz = + 2._dp*ampwavechatochavz + 2._dp*ampvertexchatochavz\n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvz,ampsumchatochavz(:,gt1, gt2),ampsum2chatochavz(:,gt1, gt2),ampsqchatochavz(gt1, gt2)) \n  ampsqchatochavz(gt1, gt2) = ampsqchatochavz(gt1, gt2) + ampsqtreechatochavz(gt1, gt2)  \nend if  \nelse  \n  ampsqchatochavz(gt1, gt2) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochavz(gt1, gt2).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchaos(gt2),mvzos,helfactor*ampsqchatochavz(gt1, gt2))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mcha(gt2),mvz,helfactor*ampsqchatochavz(gt1, gt2))\nend if \nif ((abs(mrpchatochavz(gt1, gt2)).gt.1.0e-20_dp).or.(abs(mrgchatochavz(gt1, gt2)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatochavz(gt1, gt2)).gt.1.0e-20_dp).or.(abs(mrgchatochavz(gt1, gt2)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatochavz(gt1, gt2) + mrgchatochavz(gt1, gt2)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatochavz(gt1, gt2) + mrgchatochavz(gt1, gt2))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! chi hpm\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatochihpm(cplcchachihpml,cplcchachihpmr,             & \n& mcha,mchi,mhpm,mcha2,mchi2,mhpm2,amptreechatochihpm)\n\n  else \ncall amplitude_tree_ninvseesaw_chatochihpm(zcplcchachihpml,zcplcchachihpmr,           & \n& mcha,mchi,mhpm,mcha2,mchi2,mhpm2,amptreechatochihpm)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatochihpm(mlambda,em,gs,cplcchachihpml,cplcchachihpmr,   & \n& mchaos,mchios,mhpmos,mrpchatochihpm,mrgchatochihpm)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatochihpm(mlambda,em,gs,zcplcchachihpml,zcplcchachihpmr, & \n& mchaos,mchios,mhpmos,mrpchatochihpm,mrgchatochihpm)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatochihpm(mlambda,em,gs,cplcchachihpml,cplcchachihpmr,   & \n& mcha,mchi,mhpm,mrpchatochihpm,mrgchatochihpm)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatochihpm(mlambda,em,gs,zcplcchachihpml,zcplcchachihpmr, & \n& mcha,mchi,mhpm,mrpchatochihpm,mrgchatochihpm)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochihpm(cplcchachihpml,cplcchachihpmr,             & \n& ctcplcchachihpml,ctcplcchachihpmr,mcha,mcha2,mchi,mchi2,mhpm,mhpm2,zfhpm,              & \n& zfl0,zflm,zflp,ampwavechatochihpm)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochihpm(mah,mcha,mchi,mfd,mfe,mfu,               & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,     & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexchatochihpm)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatochihpm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,     & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexirdrchatochihpm)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochihpm(mahos,mchaos,mchios,mfdos,            & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& zcplcchachihpml,zcplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochihpm)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochihpm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& zcplcchachihpml,zcplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochihpm)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochihpm(mahos,mchaos,mchios,mfdos,            & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,     & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochihpm)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochihpm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahhpmchpm,cplahhpmcvwm,cplchichachpml,      & \n& cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,     & \n& cplchichivzl,cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,         & \n& cplchifucsul,cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,     & \n& cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,     & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuhpml,              & \n& cplcfdfuhpmr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplhhhpmchpm,         & \n& cplhhhpmcvwm,cplhpmsucsd,cplhpmsvimcse,cplhpmsvrecse,cplhpmchpmvp,cplhpmcvwmvp,        & \n& cplhpmchpmvz,cplhpmcvwmvz,cplcchacfusdl,cplcchacfusdr,ampvertexiroschatochihpm)\n\n end if \n end if \nampvertexchatochihpm = ampvertexchatochihpm -  ampvertexirdrchatochihpm! +  ampvertexiroschatochihpm ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatochihpm=0._dp \nampvertexzchatochihpm=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochihpm(1,gt2,:,:) = ampwavezchatochihpm(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatochihpm(1,gt1,:,:) \nampvertexzchatochihpm(1,gt2,:,:)= ampvertexzchatochihpm(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatochihpm(1,gt1,:,:) \nampwavezchatochihpm(2,gt2,:,:) = ampwavezchatochihpm(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatochihpm(2,gt1,:,:) \nampvertexzchatochihpm(2,gt2,:,:)= ampvertexzchatochihpm(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatochihpm(2,gt1,:,:) \n end do \nend do \nampwavechatochihpm=ampwavezchatochihpm \nampvertexchatochihpm= ampvertexzchatochihpm\n! final state 1 \nampwavezchatochihpm=0._dp \nampvertexzchatochihpm=0._dp \ndo gt1=1,5\n  do gt2=1,5\nampwavezchatochihpm(1,:,gt2,:) = ampwavezchatochihpm(1,:,gt2,:)+zruzn(gt2,gt1)*ampwavechatochihpm(1,:,gt1,:) \nampvertexzchatochihpm(1,:,gt2,:)= ampvertexzchatochihpm(1,:,gt2,:)+zruzn(gt2,gt1)*ampvertexchatochihpm(1,:,gt1,:) \nampwavezchatochihpm(2,:,gt2,:) = ampwavezchatochihpm(2,:,gt2,:)+zruznc(gt2,gt1)*ampwavechatochihpm(2,:,gt1,:) \nampvertexzchatochihpm(2,:,gt2,:)= ampvertexzchatochihpm(2,:,gt2,:)+zruznc(gt2,gt1)*ampvertexchatochihpm(2,:,gt1,:) \n end do \nend do \nampwavechatochihpm=ampwavezchatochihpm \nampvertexchatochihpm= ampvertexzchatochihpm\n! final state 2 \nampwavezchatochihpm=0._dp \nampvertexzchatochihpm=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochihpm(:,:,:,gt2) = ampwavezchatochihpm(:,:,:,gt2)+zruzp(gt2,gt1)*ampwavechatochihpm(:,:,:,gt1) \nampvertexzchatochihpm(:,:,:,gt2)= ampvertexzchatochihpm(:,:,:,gt2)+zruzp(gt2,gt1)*ampvertexchatochihpm(:,:,:,gt1) \n end do \nend do \nampwavechatochihpm=ampwavezchatochihpm \nampvertexchatochihpm= ampvertexzchatochihpm\nend if\nif (shiftirdiv) then \nampvertexchatochihpm = ampvertexchatochihpm  +  ampvertexiroschatochihpm\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->chi hpm -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatochihpm = amptreechatochihpm \n ampsum2chatochihpm = amptreechatochihpm + 2._dp*ampwavechatochihpm + 2._dp*ampvertexchatochihpm  \nelse \n ampsumchatochihpm = amptreechatochihpm + ampwavechatochihpm + ampvertexchatochihpm\n ampsum2chatochihpm = amptreechatochihpm + ampwavechatochihpm + ampvertexchatochihpm \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochihpm = amptreechatochihpm\n ampsum2chatochihpm = amptreechatochihpm \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,5\n    do gt3=2,2\nif (((oskinematics).and.(mchaos(gt1).gt.(mchios(gt2)+mhpmos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mchi(gt2)+mhpm(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatochihpm = amptreechatochihpm\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatochihpm(gt1, gt2, gt3) \n  ampsum2chatochihpm = 2._dp*ampwavechatochihpm\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatochihpm(gt1, gt2, gt3) \n  ampsum2chatochihpm = 2._dp*ampvertexchatochihpm\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatochihpm(gt1, gt2, gt3) \n  ampsum2chatochihpm = amptreechatochihpm + 2._dp*ampwavechatochihpm + 2._dp*ampvertexchatochihpm\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatochihpm(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatochihpm = amptreechatochihpm\n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \n  ampsqtreechatochihpm(gt1, gt2, gt3) = ampsqchatochihpm(gt1, gt2, gt3)  \n  ampsum2chatochihpm = + 2._dp*ampwavechatochihpm + 2._dp*ampvertexchatochihpm\n  call squareamp_ftofs(mchaos(gt1),mchios(gt2),mhpmos(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \n  ampsqchatochihpm(gt1, gt2, gt3) = ampsqchatochihpm(gt1, gt2, gt3) + ampsqtreechatochihpm(gt1, gt2, gt3)  \nelse  \n  ampsum2chatochihpm = amptreechatochihpm\n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \n  ampsqtreechatochihpm(gt1, gt2, gt3) = ampsqchatochihpm(gt1, gt2, gt3)  \n  ampsum2chatochihpm = + 2._dp*ampwavechatochihpm + 2._dp*ampvertexchatochihpm\n  call squareamp_ftofs(mcha(gt1),mchi(gt2),mhpm(gt3),ampsumchatochihpm(:,gt1, gt2, gt3),ampsum2chatochihpm(:,gt1, gt2, gt3),ampsqchatochihpm(gt1, gt2, gt3)) \n  ampsqchatochihpm(gt1, gt2, gt3) = ampsqchatochihpm(gt1, gt2, gt3) + ampsqtreechatochihpm(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatochihpm(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochihpm(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchios(gt2),mhpmos(gt3),helfactor*ampsqchatochihpm(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mchi(gt2),mhpm(gt3),helfactor*ampsqchatochihpm(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatochihpm(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochihpm(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatochihpm(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatochihpm(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatochihpm(gt1, gt2, gt3) + mrgchatochihpm(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatochihpm(gt1, gt2, gt3) + mrgchatochihpm(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! chi vwm\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatochivwm(cplcchachivwml,cplcchachivwmr,             & \n& mcha,mchi,mvwm,mcha2,mchi2,mvwm2,amptreechatochivwm)\n\n  else \ncall amplitude_tree_ninvseesaw_chatochivwm(zcplcchachivwml,zcplcchachivwmr,           & \n& mcha,mchi,mvwm,mcha2,mchi2,mvwm2,amptreechatochivwm)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatochivwm(mlambda,em,gs,cplcchachivwml,cplcchachivwmr,   & \n& mchaos,mchios,mvwmos,mrpchatochivwm,mrgchatochivwm)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatochivwm(mlambda,em,gs,zcplcchachivwml,zcplcchachivwmr, & \n& mchaos,mchios,mvwmos,mrpchatochivwm,mrgchatochivwm)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatochivwm(mlambda,em,gs,cplcchachivwml,cplcchachivwmr,   & \n& mcha,mchi,mvwm,mrpchatochivwm,mrgchatochivwm)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatochivwm(mlambda,em,gs,zcplcchachivwml,zcplcchachivwmr, & \n& mcha,mchi,mvwm,mrpchatochivwm,mrgchatochivwm)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochivwm(cplcchachivwml,cplcchachivwmr,             & \n& ctcplcchachivwml,ctcplcchachivwmr,mcha,mcha2,mchi,mchi2,mvwm,mvwm2,zfl0,               & \n& zflm,zflp,zfvwm,ampwavechatochivwm)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochivwm(mah,mcha,mchi,mfd,mfe,mfu,               & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,   & \n& cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,       & \n& cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml, & \n& cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,cplcfdfuvwmr,cplcchafvsel,   & \n& cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,cplhhcvwmvwm,cplcchacfusdl,        & \n& cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,cplchpmvpvwm,cplcvwmvpvwm,       & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexchatochivwm)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatochivwm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,   & \n& cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,       & \n& cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml, & \n& cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,cplcfdfuvwmr,cplcchafvsel,   & \n& cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,cplhhcvwmvwm,cplcchacfusdl,        & \n& cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,cplchpmvpvwm,cplcvwmvpvwm,       & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexirdrchatochivwm)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochivwm(mahos,mchaos,mchios,mfdos,            & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,goszcplcchachihpml,& \n& goszcplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,   & \n& cplcfuchisur,zcplcchachivwml,zcplcchachivwmr,cplcchafdcsul,cplcchafdcsur,              & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,              & \n& cplcfdfuvwmr,cplcchafvsel,cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,         & \n& cplhhcvwmvwm,cplcchacfusdl,cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,      & \n& goszcplchpmvpvwm,cplcvwmvpvwm,cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochivwm)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochivwm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,gzcplcchachihpml, & \n& gzcplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,     & \n& cplcfuchisur,zcplcchachivwml,zcplcchachivwmr,cplcchafdcsul,cplcchafdcsur,              & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,              & \n& cplcfdfuvwmr,cplcchafvsel,cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,         & \n& cplhhcvwmvwm,cplcchacfusdl,cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,      & \n& gzcplchpmvpvwm,cplcvwmvpvwm,cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochivwm)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochivwm(mahos,mchaos,mchios,mfdos,            & \n& mfeos,mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,           & \n& mvzos,mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,               & \n& msd2os,mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,              & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,gcplcchachihpml,  & \n& gcplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,      & \n& cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml, & \n& cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,cplcfdfuvwmr,cplcchafvsel,   & \n& cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,cplhhcvwmvwm,cplcchacfusdl,        & \n& cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,gcplchpmvpvwm,cplcvwmvpvwm,      & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochivwm)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatochivwm(mah,mcha,mchi,mfd,mfe,mfu,            & \n& mfv,mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,               & \n& mfe2,mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,  & \n& cplcchachaahr,cplchichiahl,cplchichiahr,cplahchpmvwm,cplchichachpml,cplchichachpmr,    & \n& cplchichacvwml,cplchichacvwmr,cplcchachahhl,cplcchachahhr,cplcchachavpl,               & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchichihhl,cplchichihhr,cplchichivzl,      & \n& cplchichivzr,cplchifdcsdl,cplchifdcsdr,cplchifecsel,cplchifecser,cplchifucsul,         & \n& cplchifucsur,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,   & \n& cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfechisel,cplcfechiser,cplcfuchisul,       & \n& cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcchafesviml, & \n& cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfdfuvwml,cplcfdfuvwmr,cplcchafvsel,   & \n& cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhchpmvwm,cplhhcvwmvwm,cplcchacfusdl,        & \n& cplcchacfusdr,cplsucsdvwm,cplsvimcsevwm,cplsvrecsevwm,cplchpmvpvwm,cplcvwmvpvwm,       & \n& cplchpmvwmvz,cplcvwmvwmvz,ampvertexiroschatochivwm)\n\n end if \n end if \nampvertexchatochivwm = ampvertexchatochivwm -  ampvertexirdrchatochivwm! +  ampvertexiroschatochivwm ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatochivwm=0._dp \nampvertexzchatochivwm=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatochivwm(1,gt2,:) = ampwavezchatochivwm(1,gt2,:)+zruumc(gt2,gt1)*ampwavechatochivwm(1,gt1,:) \nampvertexzchatochivwm(1,gt2,:)= ampvertexzchatochivwm(1,gt2,:) + zruumc(gt2,gt1)*ampvertexchatochivwm(1,gt1,:) \nampwavezchatochivwm(2,gt2,:) = ampwavezchatochivwm(2,gt2,:)+zruup(gt2,gt1)*ampwavechatochivwm(2,gt1,:) \nampvertexzchatochivwm(2,gt2,:)= ampvertexzchatochivwm(2,gt2,:) + zruup(gt2,gt1)*ampvertexchatochivwm(2,gt1,:) \nampwavezchatochivwm(3,gt2,:) = ampwavezchatochivwm(3,gt2,:)+zruumc(gt2,gt1)*ampwavechatochivwm(3,gt1,:) \nampvertexzchatochivwm(3,gt2,:)= ampvertexzchatochivwm(3,gt2,:) + zruumc(gt2,gt1)*ampvertexchatochivwm(3,gt1,:) \nampwavezchatochivwm(4,gt2,:) = ampwavezchatochivwm(4,gt2,:)+zruup(gt2,gt1)*ampwavechatochivwm(4,gt1,:) \nampvertexzchatochivwm(4,gt2,:)= ampvertexzchatochivwm(4,gt2,:) + zruup(gt2,gt1)*ampvertexchatochivwm(4,gt1,:) \n end do \nend do \nampwavechatochivwm=ampwavezchatochivwm \nampvertexchatochivwm= ampvertexzchatochivwm\n! final state 1 \nampwavezchatochivwm=0._dp \nampvertexzchatochivwm=0._dp \ndo gt1=1,5\n  do gt2=1,5\nampwavezchatochivwm(1,:,gt2) = ampwavezchatochivwm(1,:,gt2)+zruzn(gt2,gt1)*ampwavechatochivwm(1,:,gt1) \nampvertexzchatochivwm(1,:,gt2)= ampvertexzchatochivwm(1,:,gt2)+zruzn(gt2,gt1)*ampvertexchatochivwm(1,:,gt1) \nampwavezchatochivwm(2,:,gt2) = ampwavezchatochivwm(2,:,gt2)+zruznc(gt2,gt1)*ampwavechatochivwm(2,:,gt1) \nampvertexzchatochivwm(2,:,gt2)= ampvertexzchatochivwm(2,:,gt2)+zruznc(gt2,gt1)*ampvertexchatochivwm(2,:,gt1) \nampwavezchatochivwm(3,:,gt2) = ampwavezchatochivwm(3,:,gt2)+zruzn(gt2,gt1)*ampwavechatochivwm(3,:,gt1) \nampvertexzchatochivwm(3,:,gt2)= ampvertexzchatochivwm(3,:,gt2)+zruzn(gt2,gt1)*ampvertexchatochivwm(3,:,gt1) \nampwavezchatochivwm(4,:,gt2) = ampwavezchatochivwm(4,:,gt2)+zruznc(gt2,gt1)*ampwavechatochivwm(4,:,gt1) \nampvertexzchatochivwm(4,:,gt2)= ampvertexzchatochivwm(4,:,gt2)+zruznc(gt2,gt1)*ampvertexchatochivwm(4,:,gt1) \n end do \nend do \nampwavechatochivwm=ampwavezchatochivwm \nampvertexchatochivwm= ampvertexzchatochivwm\nend if\nif (shiftirdiv) then \nampvertexchatochivwm = ampvertexchatochivwm  +  ampvertexiroschatochivwm\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->chi vwm -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatochivwm = amptreechatochivwm \n ampsum2chatochivwm = amptreechatochivwm + 2._dp*ampwavechatochivwm + 2._dp*ampvertexchatochivwm  \nelse \n ampsumchatochivwm = amptreechatochivwm + ampwavechatochivwm + ampvertexchatochivwm\n ampsum2chatochivwm = amptreechatochivwm + ampwavechatochivwm + ampvertexchatochivwm \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochivwm = amptreechatochivwm\n ampsum2chatochivwm = amptreechatochivwm \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,5\nif (((oskinematics).and.(mchaos(gt1).gt.(mchios(gt2)+mvwmos))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mchi(gt2)+mvwm)))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2 \n  ampsum2chatochivwm = amptreechatochivwm\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatochivwm(gt1, gt2) \n  ampsum2chatochivwm = 2._dp*ampwavechatochivwm\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatochivwm(gt1, gt2) \n  ampsum2chatochivwm = 2._dp*ampvertexchatochivwm\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatochivwm(gt1, gt2) \n  ampsum2chatochivwm = amptreechatochivwm + 2._dp*ampwavechatochivwm + 2._dp*ampvertexchatochivwm\nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatochivwm(gt1, gt2) \n end if \nif (oskinematics) then \n  ampsum2chatochivwm = amptreechatochivwm\n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \n  ampsqtreechatochivwm(gt1, gt2) = ampsqchatochivwm(gt1, gt2)  \n  ampsum2chatochivwm = + 2._dp*ampwavechatochivwm + 2._dp*ampvertexchatochivwm\n  call squareamp_ftofv(mchaos(gt1),mchios(gt2),mvwmos,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \n  ampsqchatochivwm(gt1, gt2) = ampsqchatochivwm(gt1, gt2) + ampsqtreechatochivwm(gt1, gt2)  \nelse  \n  ampsum2chatochivwm = amptreechatochivwm\n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \n  ampsqtreechatochivwm(gt1, gt2) = ampsqchatochivwm(gt1, gt2)  \n  ampsum2chatochivwm = + 2._dp*ampwavechatochivwm + 2._dp*ampvertexchatochivwm\n  call squareamp_ftofv(mcha(gt1),mchi(gt2),mvwm,ampsumchatochivwm(:,gt1, gt2),ampsum2chatochivwm(:,gt1, gt2),ampsqchatochivwm(gt1, gt2)) \n  ampsqchatochivwm(gt1, gt2) = ampsqchatochivwm(gt1, gt2) + ampsqtreechatochivwm(gt1, gt2)  \nend if  \nelse  \n  ampsqchatochivwm(gt1, gt2) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochivwm(gt1, gt2).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchios(gt2),mvwmos,helfactor*ampsqchatochivwm(gt1, gt2))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mchi(gt2),mvwm,helfactor*ampsqchatochivwm(gt1, gt2))\nend if \nif ((abs(mrpchatochivwm(gt1, gt2)).gt.1.0e-20_dp).or.(abs(mrgchatochivwm(gt1, gt2)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatochivwm(gt1, gt2)).gt.1.0e-20_dp).or.(abs(mrgchatochivwm(gt1, gt2)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatochivwm(gt1, gt2) + mrgchatochivwm(gt1, gt2)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatochivwm(gt1, gt2) + mrgchatochivwm(gt1, gt2))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! fd conjg(su)\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatofdcsu(cplcchafdcsul,cplcchafdcsur,mcha,           & \n& mfd,msu,mcha2,mfd2,msu2,amptreechatofdcsu)\n\n  else \ncall amplitude_tree_ninvseesaw_chatofdcsu(zcplcchafdcsul,zcplcchafdcsur,              & \n& mcha,mfd,msu,mcha2,mfd2,msu2,amptreechatofdcsu)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatofdcsu(mlambda,em,gs,cplcchafdcsul,cplcchafdcsur,      & \n& mchaos,mfdos,msuos,mrpchatofdcsu,mrgchatofdcsu)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatofdcsu(mlambda,em,gs,zcplcchafdcsul,zcplcchafdcsur,    & \n& mchaos,mfdos,msuos,mrpchatofdcsu,mrgchatofdcsu)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatofdcsu(mlambda,em,gs,cplcchafdcsul,cplcchafdcsur,      & \n& mcha,mfd,msu,mrpchatofdcsu,mrgchatofdcsu)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatofdcsu(mlambda,em,gs,zcplcchafdcsul,zcplcchafdcsur,    & \n& mcha,mfd,msu,mrpchatofdcsu,mrgchatofdcsu)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatofdcsu(cplcchafdcsul,cplcchafdcsur,ctcplcchafdcsul,& \n& ctcplcchafdcsur,mcha,mcha2,mfd,mfd2,msu,msu2,zffdl,zffdr,zflm,zflp,zfsu,               & \n& ampwavechatofdcsu)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatofdcsu(mah,mcha,mchi,mfd,mfu,mglu,               & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfdfdahl,          & \n& cplcfdfdahr,cplahsucsu,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplchifdcsdl,cplchifdcsdr,cplchifucsul,cplchifucsur,       & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplglufdcsdl,              & \n& cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,cplcfdfdvgr,cplcfdfdvpl,              & \n& cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcfufdchpml,         & \n& cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,cplglufucsur,cplhhsucsu,        & \n& cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,cplsucsuvg,cplsucsuvp,           & \n& cplsucsuvz,ampvertexchatofdcsu)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatofdcsu(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfdfdahl,          & \n& cplcfdfdahr,cplahsucsu,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplchifdcsdl,cplchifdcsdr,cplchifucsul,cplchifucsur,       & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplglufdcsdl,              & \n& cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,cplcfdfdvgr,cplcfdfdvpl,              & \n& cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcfufdchpml,         & \n& cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,cplglufucsur,cplhhsucsu,        & \n& cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,cplsucsuvg,cplsucsuvp,           & \n& cplsucsuvz,ampvertexirdrchatofdcsu)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofdcsu(mahos,mchaos,mchios,mfdos,             & \n& mfuos,mgluos,mhhos,mhpmos,msdos,msuos,mvg,mvp,mvwmos,mvzos,mah2os,mcha2os,             & \n& mchi2os,mfd2os,mfu2os,mglu2os,mhh2os,mhpm2os,msd2os,msu2os,mvg2,mvp2,mvwm2os,          & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfdfdahl,cplcfdfdahr,cplahsucsu,cplcchachahhl,   & \n& cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifdcsdl,    & \n& cplchifdcsdr,cplchifucsul,cplchifucsur,cplcchachihpml,cplcchachihpmr,cplcchachivwml,   & \n& cplcchachivwmr,cplglufdcsdl,cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,          & \n& cplcfdfdvgr,cplcfdfdvpl,cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,zcplcchafdcsul,            & \n& zcplcchafdcsur,cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,   & \n& cplglufucsur,cplhhsucsu,cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,         & \n& cplsucsuvg,cplsucsuvp,cplsucsuvz,ampvertexiroschatofdcsu)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofdcsu(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfdfdahl,          & \n& cplcfdfdahr,cplahsucsu,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplchifdcsdl,cplchifdcsdr,cplchifucsul,cplchifucsur,       & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplglufdcsdl,              & \n& cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,cplcfdfdvgr,cplcfdfdvpl,              & \n& cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,zcplcchafdcsul,zcplcchafdcsur,cplcfufdchpml,       & \n& cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,cplglufucsur,cplhhsucsu,        & \n& cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,cplsucsuvg,cplsucsuvp,           & \n& cplsucsuvz,ampvertexiroschatofdcsu)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofdcsu(mahos,mchaos,mchios,mfdos,             & \n& mfuos,mgluos,mhhos,mhpmos,msdos,msuos,mvg,mvp,mvwmos,mvzos,mah2os,mcha2os,             & \n& mchi2os,mfd2os,mfu2os,mglu2os,mhh2os,mhpm2os,msd2os,msu2os,mvg2,mvp2,mvwm2os,          & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfdfdahl,cplcfdfdahr,cplahsucsu,cplcchachahhl,   & \n& cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifdcsdl,    & \n& cplchifdcsdr,cplchifucsul,cplchifucsur,cplcchachihpml,cplcchachihpmr,cplcchachivwml,   & \n& cplcchachivwmr,cplglufdcsdl,cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,          & \n& cplcfdfdvgr,cplcfdfdvpl,cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,cplcchafdcsul,             & \n& cplcchafdcsur,cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,    & \n& cplglufucsur,cplhhsucsu,cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,         & \n& cplsucsuvg,cplsucsuvp,cplsucsuvz,ampvertexiroschatofdcsu)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofdcsu(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfdfdahl,          & \n& cplcfdfdahr,cplahsucsu,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplchifdcsdl,cplchifdcsdr,cplchifucsul,cplchifucsur,       & \n& cplcchachihpml,cplcchachihpmr,cplcchachivwml,cplcchachivwmr,cplglufdcsdl,              & \n& cplglufdcsdr,cplcfdfdhhl,cplcfdfdhhr,cplcfdfdvgl,cplcfdfdvgr,cplcfdfdvpl,              & \n& cplcfdfdvpr,cplcfdfdvzl,cplcfdfdvzr,cplcchafdcsul,cplcchafdcsur,cplcfufdchpml,         & \n& cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplglufucsul,cplglufucsur,cplhhsucsu,        & \n& cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,cplsucsuvg,cplsucsuvp,           & \n& cplsucsuvz,ampvertexiroschatofdcsu)\n\n end if \n end if \nampvertexchatofdcsu = ampvertexchatofdcsu -  ampvertexirdrchatofdcsu! +  ampvertexiroschatofdcsu ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatofdcsu=0._dp \nampvertexzchatofdcsu=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatofdcsu(1,gt2,:,:) = ampwavezchatofdcsu(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatofdcsu(1,gt1,:,:) \nampvertexzchatofdcsu(1,gt2,:,:)= ampvertexzchatofdcsu(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatofdcsu(1,gt1,:,:) \nampwavezchatofdcsu(2,gt2,:,:) = ampwavezchatofdcsu(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatofdcsu(2,gt1,:,:) \nampvertexzchatofdcsu(2,gt2,:,:)= ampvertexzchatofdcsu(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatofdcsu(2,gt1,:,:) \n end do \nend do \nampwavechatofdcsu=ampwavezchatofdcsu \nampvertexchatofdcsu= ampvertexzchatofdcsu\n! final state 1 \nampwavezchatofdcsu=0._dp \nampvertexzchatofdcsu=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatofdcsu(1,:,gt2,:) = ampwavezchatofdcsu(1,:,gt2,:)+zruzdl(gt2,gt1)*ampwavechatofdcsu(1,:,gt1,:) \nampvertexzchatofdcsu(1,:,gt2,:)= ampvertexzchatofdcsu(1,:,gt2,:)+zruzdl(gt2,gt1)*ampvertexchatofdcsu(1,:,gt1,:) \nampwavezchatofdcsu(2,:,gt2,:) = ampwavezchatofdcsu(2,:,gt2,:)+zruzdrc(gt2,gt1)*ampwavechatofdcsu(2,:,gt1,:) \nampvertexzchatofdcsu(2,:,gt2,:)= ampvertexzchatofdcsu(2,:,gt2,:)+zruzdrc(gt2,gt1)*ampvertexchatofdcsu(2,:,gt1,:) \n end do \nend do \nampwavechatofdcsu=ampwavezchatofdcsu \nampvertexchatofdcsu= ampvertexzchatofdcsu\n! final state 2 \nampwavezchatofdcsu=0._dp \nampvertexzchatofdcsu=0._dp \ndo gt1=1,6\n  do gt2=1,6\nampwavezchatofdcsu(:,:,:,gt2) = ampwavezchatofdcsu(:,:,:,gt2)+zruzuc(gt2,gt1)*ampwavechatofdcsu(:,:,:,gt1) \nampvertexzchatofdcsu(:,:,:,gt2)= ampvertexzchatofdcsu(:,:,:,gt2)+zruzuc(gt2,gt1)*ampvertexchatofdcsu(:,:,:,gt1) \n end do \nend do \nampwavechatofdcsu=ampwavezchatofdcsu \nampvertexchatofdcsu= ampvertexzchatofdcsu\nend if\nif (shiftirdiv) then \nampvertexchatofdcsu = ampvertexchatofdcsu  +  ampvertexiroschatofdcsu\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->fd conj[su] -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatofdcsu = amptreechatofdcsu \n ampsum2chatofdcsu = amptreechatofdcsu + 2._dp*ampwavechatofdcsu + 2._dp*ampvertexchatofdcsu  \nelse \n ampsumchatofdcsu = amptreechatofdcsu + ampwavechatofdcsu + ampvertexchatofdcsu\n ampsum2chatofdcsu = amptreechatofdcsu + ampwavechatofdcsu + ampvertexchatofdcsu \nend if \nif (onlytreelevelcontributions) then \n ampsumchatofdcsu = amptreechatofdcsu\n ampsum2chatofdcsu = amptreechatofdcsu \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,3\n    do gt3=1,6\nif (((oskinematics).and.(mchaos(gt1).gt.(mfdos(gt2)+msuos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mfd(gt2)+msu(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatofdcsu = amptreechatofdcsu\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatofdcsu(gt1, gt2, gt3) \n  ampsum2chatofdcsu = 2._dp*ampwavechatofdcsu\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatofdcsu(gt1, gt2, gt3) \n  ampsum2chatofdcsu = 2._dp*ampvertexchatofdcsu\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatofdcsu(gt1, gt2, gt3) \n  ampsum2chatofdcsu = amptreechatofdcsu + 2._dp*ampwavechatofdcsu + 2._dp*ampvertexchatofdcsu\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatofdcsu(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatofdcsu = amptreechatofdcsu\n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \n  ampsqtreechatofdcsu(gt1, gt2, gt3) = ampsqchatofdcsu(gt1, gt2, gt3)  \n  ampsum2chatofdcsu = + 2._dp*ampwavechatofdcsu + 2._dp*ampvertexchatofdcsu\n  call squareamp_ftofs(mchaos(gt1),mfdos(gt2),msuos(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \n  ampsqchatofdcsu(gt1, gt2, gt3) = ampsqchatofdcsu(gt1, gt2, gt3) + ampsqtreechatofdcsu(gt1, gt2, gt3)  \nelse  \n  ampsum2chatofdcsu = amptreechatofdcsu\n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \n  ampsqtreechatofdcsu(gt1, gt2, gt3) = ampsqchatofdcsu(gt1, gt2, gt3)  \n  ampsum2chatofdcsu = + 2._dp*ampwavechatofdcsu + 2._dp*ampvertexchatofdcsu\n  call squareamp_ftofs(mcha(gt1),mfd(gt2),msu(gt3),ampsumchatofdcsu(:,gt1, gt2, gt3),ampsum2chatofdcsu(:,gt1, gt2, gt3),ampsqchatofdcsu(gt1, gt2, gt3)) \n  ampsqchatofdcsu(gt1, gt2, gt3) = ampsqchatofdcsu(gt1, gt2, gt3) + ampsqtreechatofdcsu(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatofdcsu(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatofdcsu(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 3._dp*gammatps(mchaos(gt1),mfdos(gt2),msuos(gt3),helfactor*ampsqchatofdcsu(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 3._dp*gammatps(mcha(gt1),mfd(gt2),msu(gt3),helfactor*ampsqchatofdcsu(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatofdcsu(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofdcsu(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatofdcsu(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofdcsu(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatofdcsu(gt1, gt2, gt3) + mrgchatofdcsu(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatofdcsu(gt1, gt2, gt3) + mrgchatofdcsu(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! fe svim\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatofesvim(cplcchafesviml,cplcchafesvimr,             & \n& mcha,mfe,msvim,mcha2,mfe2,msvim2,amptreechatofesvim)\n\n  else \ncall amplitude_tree_ninvseesaw_chatofesvim(zcplcchafesviml,zcplcchafesvimr,           & \n& mcha,mfe,msvim,mcha2,mfe2,msvim2,amptreechatofesvim)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatofesvim(mlambda,em,gs,cplcchafesviml,cplcchafesvimr,   & \n& mchaos,mfeos,msvimos,mrpchatofesvim,mrgchatofesvim)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatofesvim(mlambda,em,gs,zcplcchafesviml,zcplcchafesvimr, & \n& mchaos,mfeos,msvimos,mrpchatofesvim,mrgchatofesvim)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatofesvim(mlambda,em,gs,cplcchafesviml,cplcchafesvimr,   & \n& mcha,mfe,msvim,mrpchatofesvim,mrgchatofesvim)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatofesvim(mlambda,em,gs,zcplcchafesviml,zcplcchafesvimr, & \n& mcha,mfe,msvim,mrpchatofesvim,mrgchatofesvim)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatofesvim(cplcchafesviml,cplcchafesvimr,             & \n& ctcplcchafesviml,ctcplcchafesvimr,mcha,mcha2,mfe,mfe2,msvim,msvim2,zffel,              & \n& zffer,zflm,zflp,zfsvim,ampwavechatofesvim)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatofesvim(mah,mcha,mchi,mfe,mfv,mhh,               & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvim,cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,    & \n& cplcfechasvimr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexchatofesvim)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatofesvim(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvim,cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,    & \n& cplcfechasvimr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexirdrchatofesvim)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvim(mahos,mchaos,mchios,mfeos,            & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfefeahl,cplcfefeahr,cplahsvimsvim,              & \n& cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,cplcfechasvimr,               & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,cplchifecser,     & \n& cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,              & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,zcplcchafesviml,zcplcchafesvimr,cplcchafesvrel,cplcchafesvrer,             & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexiroschatofesvim)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvim(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvim,cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,    & \n& cplcfechasvimr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,zcplcchafesviml,zcplcchafesvimr,cplcchafesvrel,cplcchafesvrer,             & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexiroschatofesvim)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvim(mahos,mchaos,mchios,mfeos,            & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfefeahl,cplcfefeahr,cplahsvimsvim,              & \n& cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,cplcfechasvimr,               & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,cplchifecser,     & \n& cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml,              & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexiroschatofesvim)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvim(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvim,cplahsvimsvre,cplcchachahhl,cplcchachahhr,cplcfechasviml,    & \n& cplcfechasvimr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsviml,cplchifvsvimr,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvim,cplhhsvimsvre,cplhpmsvimcse,cplsesvimchpm,cplsesvimcvwm,cplsvimsvrevz,   & \n& cplsvimcsevwm,ampvertexiroschatofesvim)\n\n end if \n end if \nampvertexchatofesvim = ampvertexchatofesvim -  ampvertexirdrchatofesvim! +  ampvertexiroschatofesvim ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatofesvim=0._dp \nampvertexzchatofesvim=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatofesvim(1,gt2,:,:) = ampwavezchatofesvim(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatofesvim(1,gt1,:,:) \nampvertexzchatofesvim(1,gt2,:,:)= ampvertexzchatofesvim(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatofesvim(1,gt1,:,:) \nampwavezchatofesvim(2,gt2,:,:) = ampwavezchatofesvim(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatofesvim(2,gt1,:,:) \nampvertexzchatofesvim(2,gt2,:,:)= ampvertexzchatofesvim(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatofesvim(2,gt1,:,:) \n end do \nend do \nampwavechatofesvim=ampwavezchatofesvim \nampvertexchatofesvim= ampvertexzchatofesvim\n! final state 1 \nampwavezchatofesvim=0._dp \nampvertexzchatofesvim=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatofesvim(1,:,gt2,:) = ampwavezchatofesvim(1,:,gt2,:)+zruzel(gt2,gt1)*ampwavechatofesvim(1,:,gt1,:) \nampvertexzchatofesvim(1,:,gt2,:)= ampvertexzchatofesvim(1,:,gt2,:)+zruzel(gt2,gt1)*ampvertexchatofesvim(1,:,gt1,:) \nampwavezchatofesvim(2,:,gt2,:) = ampwavezchatofesvim(2,:,gt2,:)+zruzerc(gt2,gt1)*ampwavechatofesvim(2,:,gt1,:) \nampvertexzchatofesvim(2,:,gt2,:)= ampvertexzchatofesvim(2,:,gt2,:)+zruzerc(gt2,gt1)*ampvertexchatofesvim(2,:,gt1,:) \n end do \nend do \nampwavechatofesvim=ampwavezchatofesvim \nampvertexchatofesvim= ampvertexzchatofesvim\n! final state 2 \nampwavezchatofesvim=0._dp \nampvertexzchatofesvim=0._dp \ndo gt1=1,9\n  do gt2=1,9\nampwavezchatofesvim(:,:,:,gt2) = ampwavezchatofesvim(:,:,:,gt2)+zruzvi(gt2,gt1)*ampwavechatofesvim(:,:,:,gt1) \nampvertexzchatofesvim(:,:,:,gt2)= ampvertexzchatofesvim(:,:,:,gt2)+zruzvi(gt2,gt1)*ampvertexchatofesvim(:,:,:,gt1) \n end do \nend do \nampwavechatofesvim=ampwavezchatofesvim \nampvertexchatofesvim= ampvertexzchatofesvim\nend if\nif (shiftirdiv) then \nampvertexchatofesvim = ampvertexchatofesvim  +  ampvertexiroschatofesvim\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->fe svim -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatofesvim = amptreechatofesvim \n ampsum2chatofesvim = amptreechatofesvim + 2._dp*ampwavechatofesvim + 2._dp*ampvertexchatofesvim  \nelse \n ampsumchatofesvim = amptreechatofesvim + ampwavechatofesvim + ampvertexchatofesvim\n ampsum2chatofesvim = amptreechatofesvim + ampwavechatofesvim + ampvertexchatofesvim \nend if \nif (onlytreelevelcontributions) then \n ampsumchatofesvim = amptreechatofesvim\n ampsum2chatofesvim = amptreechatofesvim \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,3\n    do gt3=1,9\nif (((oskinematics).and.(mchaos(gt1).gt.(mfeos(gt2)+msvimos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mfe(gt2)+msvim(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatofesvim = amptreechatofesvim\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatofesvim(gt1, gt2, gt3) \n  ampsum2chatofesvim = 2._dp*ampwavechatofesvim\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatofesvim(gt1, gt2, gt3) \n  ampsum2chatofesvim = 2._dp*ampvertexchatofesvim\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatofesvim(gt1, gt2, gt3) \n  ampsum2chatofesvim = amptreechatofesvim + 2._dp*ampwavechatofesvim + 2._dp*ampvertexchatofesvim\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatofesvim(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatofesvim = amptreechatofesvim\n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \n  ampsqtreechatofesvim(gt1, gt2, gt3) = ampsqchatofesvim(gt1, gt2, gt3)  \n  ampsum2chatofesvim = + 2._dp*ampwavechatofesvim + 2._dp*ampvertexchatofesvim\n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvimos(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \n  ampsqchatofesvim(gt1, gt2, gt3) = ampsqchatofesvim(gt1, gt2, gt3) + ampsqtreechatofesvim(gt1, gt2, gt3)  \nelse  \n  ampsum2chatofesvim = amptreechatofesvim\n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \n  ampsqtreechatofesvim(gt1, gt2, gt3) = ampsqchatofesvim(gt1, gt2, gt3)  \n  ampsum2chatofesvim = + 2._dp*ampwavechatofesvim + 2._dp*ampvertexchatofesvim\n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvim(gt3),ampsumchatofesvim(:,gt1, gt2, gt3),ampsum2chatofesvim(:,gt1, gt2, gt3),ampsqchatofesvim(gt1, gt2, gt3)) \n  ampsqchatofesvim(gt1, gt2, gt3) = ampsqchatofesvim(gt1, gt2, gt3) + ampsqtreechatofesvim(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatofesvim(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatofesvim(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mfeos(gt2),msvimos(gt3),helfactor*ampsqchatofesvim(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mfe(gt2),msvim(gt3),helfactor*ampsqchatofesvim(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatofesvim(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofesvim(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatofesvim(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofesvim(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatofesvim(gt1, gt2, gt3) + mrgchatofesvim(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatofesvim(gt1, gt2, gt3) + mrgchatofesvim(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! fe svre\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatofesvre(cplcchafesvrel,cplcchafesvrer,             & \n& mcha,mfe,msvre,mcha2,mfe2,msvre2,amptreechatofesvre)\n\n  else \ncall amplitude_tree_ninvseesaw_chatofesvre(zcplcchafesvrel,zcplcchafesvrer,           & \n& mcha,mfe,msvre,mcha2,mfe2,msvre2,amptreechatofesvre)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatofesvre(mlambda,em,gs,cplcchafesvrel,cplcchafesvrer,   & \n& mchaos,mfeos,msvreos,mrpchatofesvre,mrgchatofesvre)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatofesvre(mlambda,em,gs,zcplcchafesvrel,zcplcchafesvrer, & \n& mchaos,mfeos,msvreos,mrpchatofesvre,mrgchatofesvre)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatofesvre(mlambda,em,gs,cplcchafesvrel,cplcchafesvrer,   & \n& mcha,mfe,msvre,mrpchatofesvre,mrgchatofesvre)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatofesvre(mlambda,em,gs,zcplcchafesvrel,zcplcchafesvrer, & \n& mcha,mfe,msvre,mrpchatofesvre,mrgchatofesvre)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatofesvre(cplcchafesvrel,cplcchafesvrer,             & \n& ctcplcchafesvrel,ctcplcchafesvrer,mcha,mcha2,mfe,mfe2,msvre,msvre2,zffel,              & \n& zffer,zflm,zflp,zfsvre,ampwavechatofesvre)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatofesvre(mah,mcha,mchi,mfe,mfv,mhh,               & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvre,cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,    & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexchatofesvre)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatofesvre(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvre,cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,    & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexirdrchatofesvre)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvre(mahos,mchaos,mchios,mfeos,            & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfefeahl,cplcfefeahr,cplahsvimsvre,              & \n& cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,cplcfechasvrer,               & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,cplchifecser,     & \n& cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml,              & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,zcplcchafesvrel,zcplcchafesvrer,             & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexiroschatofesvre)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvre(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvre,cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,    & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,zcplcchafesvrel,zcplcchafesvrer,             & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexiroschatofesvre)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvre(mahos,mchaos,mchios,mfeos,            & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfefeahl,cplcfefeahr,cplahsvimsvre,              & \n& cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,cplcfechasvrer,               & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,cplchifecser,     & \n& cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml,              & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexiroschatofesvre)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofesvre(mah,mcha,mchi,mfe,mfv,mhh,            & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfefeahl,            & \n& cplcfefeahr,cplahsvimsvre,cplahsvresvre,cplcchachahhl,cplcchachahhr,cplcfechasvrel,    & \n& cplcfechasvrer,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifecsel,   & \n& cplchifecser,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcchachivwml, & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcfefehhl,        & \n& cplcfefehhr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,               & \n& cplcfefevpl,cplcfefevpr,cplcfefevzl,cplcfefevzr,cplcchafvsel,cplcchafvser,             & \n& cplhhsvimsvre,cplhhsvresvre,cplhpmsvrecse,cplsesvrechpm,cplsesvrecvwm,cplsvimsvrevz,   & \n& cplsvrecsevwm,ampvertexiroschatofesvre)\n\n end if \n end if \nampvertexchatofesvre = ampvertexchatofesvre -  ampvertexirdrchatofesvre! +  ampvertexiroschatofesvre ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatofesvre=0._dp \nampvertexzchatofesvre=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatofesvre(1,gt2,:,:) = ampwavezchatofesvre(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatofesvre(1,gt1,:,:) \nampvertexzchatofesvre(1,gt2,:,:)= ampvertexzchatofesvre(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatofesvre(1,gt1,:,:) \nampwavezchatofesvre(2,gt2,:,:) = ampwavezchatofesvre(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatofesvre(2,gt1,:,:) \nampvertexzchatofesvre(2,gt2,:,:)= ampvertexzchatofesvre(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatofesvre(2,gt1,:,:) \n end do \nend do \nampwavechatofesvre=ampwavezchatofesvre \nampvertexchatofesvre= ampvertexzchatofesvre\n! final state 1 \nampwavezchatofesvre=0._dp \nampvertexzchatofesvre=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatofesvre(1,:,gt2,:) = ampwavezchatofesvre(1,:,gt2,:)+zruzel(gt2,gt1)*ampwavechatofesvre(1,:,gt1,:) \nampvertexzchatofesvre(1,:,gt2,:)= ampvertexzchatofesvre(1,:,gt2,:)+zruzel(gt2,gt1)*ampvertexchatofesvre(1,:,gt1,:) \nampwavezchatofesvre(2,:,gt2,:) = ampwavezchatofesvre(2,:,gt2,:)+zruzerc(gt2,gt1)*ampwavechatofesvre(2,:,gt1,:) \nampvertexzchatofesvre(2,:,gt2,:)= ampvertexzchatofesvre(2,:,gt2,:)+zruzerc(gt2,gt1)*ampvertexchatofesvre(2,:,gt1,:) \n end do \nend do \nampwavechatofesvre=ampwavezchatofesvre \nampvertexchatofesvre= ampvertexzchatofesvre\n! final state 2 \nampwavezchatofesvre=0._dp \nampvertexzchatofesvre=0._dp \ndo gt1=1,9\n  do gt2=1,9\nampwavezchatofesvre(:,:,:,gt2) = ampwavezchatofesvre(:,:,:,gt2)+zruzvr(gt2,gt1)*ampwavechatofesvre(:,:,:,gt1) \nampvertexzchatofesvre(:,:,:,gt2)= ampvertexzchatofesvre(:,:,:,gt2)+zruzvr(gt2,gt1)*ampvertexchatofesvre(:,:,:,gt1) \n end do \nend do \nampwavechatofesvre=ampwavezchatofesvre \nampvertexchatofesvre= ampvertexzchatofesvre\nend if\nif (shiftirdiv) then \nampvertexchatofesvre = ampvertexchatofesvre  +  ampvertexiroschatofesvre\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->fe svre -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatofesvre = amptreechatofesvre \n ampsum2chatofesvre = amptreechatofesvre + 2._dp*ampwavechatofesvre + 2._dp*ampvertexchatofesvre  \nelse \n ampsumchatofesvre = amptreechatofesvre + ampwavechatofesvre + ampvertexchatofesvre\n ampsum2chatofesvre = amptreechatofesvre + ampwavechatofesvre + ampvertexchatofesvre \nend if \nif (onlytreelevelcontributions) then \n ampsumchatofesvre = amptreechatofesvre\n ampsum2chatofesvre = amptreechatofesvre \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,3\n    do gt3=1,9\nif (((oskinematics).and.(mchaos(gt1).gt.(mfeos(gt2)+msvreos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mfe(gt2)+msvre(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatofesvre = amptreechatofesvre\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatofesvre(gt1, gt2, gt3) \n  ampsum2chatofesvre = 2._dp*ampwavechatofesvre\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatofesvre(gt1, gt2, gt3) \n  ampsum2chatofesvre = 2._dp*ampvertexchatofesvre\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatofesvre(gt1, gt2, gt3) \n  ampsum2chatofesvre = amptreechatofesvre + 2._dp*ampwavechatofesvre + 2._dp*ampvertexchatofesvre\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatofesvre(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatofesvre = amptreechatofesvre\n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \n  ampsqtreechatofesvre(gt1, gt2, gt3) = ampsqchatofesvre(gt1, gt2, gt3)  \n  ampsum2chatofesvre = + 2._dp*ampwavechatofesvre + 2._dp*ampvertexchatofesvre\n  call squareamp_ftofs(mchaos(gt1),mfeos(gt2),msvreos(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \n  ampsqchatofesvre(gt1, gt2, gt3) = ampsqchatofesvre(gt1, gt2, gt3) + ampsqtreechatofesvre(gt1, gt2, gt3)  \nelse  \n  ampsum2chatofesvre = amptreechatofesvre\n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \n  ampsqtreechatofesvre(gt1, gt2, gt3) = ampsqchatofesvre(gt1, gt2, gt3)  \n  ampsum2chatofesvre = + 2._dp*ampwavechatofesvre + 2._dp*ampvertexchatofesvre\n  call squareamp_ftofs(mcha(gt1),mfe(gt2),msvre(gt3),ampsumchatofesvre(:,gt1, gt2, gt3),ampsum2chatofesvre(:,gt1, gt2, gt3),ampsqchatofesvre(gt1, gt2, gt3)) \n  ampsqchatofesvre(gt1, gt2, gt3) = ampsqchatofesvre(gt1, gt2, gt3) + ampsqtreechatofesvre(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatofesvre(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatofesvre(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mfeos(gt2),msvreos(gt3),helfactor*ampsqchatofesvre(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mfe(gt2),msvre(gt3),helfactor*ampsqchatofesvre(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatofesvre(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofesvre(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatofesvre(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofesvre(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatofesvre(gt1, gt2, gt3) + mrgchatofesvre(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatofesvre(gt1, gt2, gt3) + mrgchatofesvre(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! fv se\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatofvse(cplcchafvsel,cplcchafvser,mcha,              & \n& mfv,mse,mcha2,mfv2,mse2,amptreechatofvse)\n\n  else \ncall amplitude_tree_ninvseesaw_chatofvse(zcplcchafvsel,zcplcchafvser,mcha,            & \n& mfv,mse,mcha2,mfv2,mse2,amptreechatofvse)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatofvse(mlambda,em,gs,cplcchafvsel,cplcchafvser,         & \n& mchaos,mfvos,mseos,mrpchatofvse,mrgchatofvse)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatofvse(mlambda,em,gs,zcplcchafvsel,zcplcchafvser,       & \n& mchaos,mfvos,mseos,mrpchatofvse,mrgchatofvse)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatofvse(mlambda,em,gs,cplcchafvsel,cplcchafvser,         & \n& mcha,mfv,mse,mrpchatofvse,mrgchatofvse)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatofvse(mlambda,em,gs,zcplcchafvsel,zcplcchafvser,       & \n& mcha,mfv,mse,mrpchatofvse,mrgchatofvse)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatofvse(cplcchafvsel,cplcchafvser,ctcplcchafvsel,    & \n& ctcplcchafvser,mcha,mcha2,mfv,mfv2,mse,mse2,zffv,zflm,zflp,zfse,ampwavechatofvse)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatofvse(mah,mcha,mchi,mfe,mfv,mhh,mhpm,            & \n& mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,mse2,               & \n& msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplfvfvahl,cplfvfvahr,       & \n& cplahsecse,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,cplcchachavpl,        & \n& cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,   & \n& cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcfechisel,cplcfechiser,cplcchachivwml,  & \n& cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcchafesviml,     & \n& cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,cplfvfvvzl,         & \n& cplfvfvvzr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplcfefvvwml,           & \n& cplcfefvvwmr,cplhhsecse,cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,cplsesvrecvwm,       & \n& cplsecsevp,cplsecsevz,ampvertexchatofvse)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatofvse(mah,mcha,mchi,mfe,mfv,mhh,              & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplfvfvahl,             & \n& cplfvfvahr,cplahsecse,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,           & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifvsviml,cplchifvsvimr,   & \n& cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcfechisel,cplcfechiser,   & \n& cplcchachivwml,cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,     & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,     & \n& cplfvfvvzl,cplfvfvvzr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,             & \n& cplcfefvvwml,cplcfefvvwmr,cplhhsecse,cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,        & \n& cplsesvrecvwm,cplsecsevp,cplsecsevz,ampvertexirdrchatofvse)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofvse(mahos,mchaos,mchios,mfeos,              & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplfvfvahl,cplfvfvahr,cplahsecse,cplfvchacsel,      & \n& cplfvchacser,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,    & \n& cplcchachavzr,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,  & \n& cplcchachihpmr,cplcfechisel,cplcfechiser,cplcchachivwml,cplcchachivwmr,cplfvfechpml,   & \n& cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,   & \n& cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,cplfvfvvzl,cplfvfvvzr,cplcfefvhpml,               & \n& cplcfefvhpmr,zcplcchafvsel,zcplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhsecse,         & \n& cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,cplsesvrecvwm,cplsecsevp,cplsecsevz,         & \n& ampvertexiroschatofvse)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofvse(mah,mcha,mchi,mfe,mfv,mhh,              & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplfvfvahl,             & \n& cplfvfvahr,cplahsecse,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,           & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifvsviml,cplchifvsvimr,   & \n& cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcfechisel,cplcfechiser,   & \n& cplcchachivwml,cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,     & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,     & \n& cplfvfvvzl,cplfvfvvzr,cplcfefvhpml,cplcfefvhpmr,zcplcchafvsel,zcplcchafvser,           & \n& cplcfefvvwml,cplcfefvvwmr,cplhhsecse,cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,        & \n& cplsesvrecvwm,cplsecsevp,cplsecsevz,ampvertexiroschatofvse)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofvse(mahos,mchaos,mchios,mfeos,              & \n& mfvos,mhhos,mhpmos,mseos,msvimos,msvreos,mvp,mvwmos,mvzos,mah2os,mcha2os,              & \n& mchi2os,mfe2os,mfv2os,mhh2os,mhpm2os,mse2os,msvim2os,msvre2os,mvp2,mvwm2os,            & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplfvfvahl,cplfvfvahr,cplahsecse,cplfvchacsel,      & \n& cplfvchacser,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,    & \n& cplcchachavzr,cplchifvsviml,cplchifvsvimr,cplchifvsvrel,cplchifvsvrer,cplcchachihpml,  & \n& cplcchachihpmr,cplcfechisel,cplcfechiser,cplcchachivwml,cplcchachivwmr,cplfvfechpml,   & \n& cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,cplcchafesviml,cplcchafesvimr,cplcchafesvrel,   & \n& cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,cplfvfvvzl,cplfvfvvzr,cplcfefvhpml,               & \n& cplcfefvhpmr,cplcchafvsel,cplcchafvser,cplcfefvvwml,cplcfefvvwmr,cplhhsecse,           & \n& cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,cplsesvrecvwm,cplsecsevp,cplsecsevz,         & \n& ampvertexiroschatofvse)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatofvse(mah,mcha,mchi,mfe,mfv,mhh,              & \n& mhpm,mse,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfe2,mfv2,mhh2,mhpm2,               & \n& mse2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplfvfvahl,             & \n& cplfvfvahr,cplahsecse,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,           & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplchifvsviml,cplchifvsvimr,   & \n& cplchifvsvrel,cplchifvsvrer,cplcchachihpml,cplcchachihpmr,cplcfechisel,cplcfechiser,   & \n& cplcchachivwml,cplcchachivwmr,cplfvfechpml,cplfvfechpmr,cplfvfecvwml,cplfvfecvwmr,     & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplfvfvhhl,cplfvfvhhr,     & \n& cplfvfvvzl,cplfvfvvzr,cplcfefvhpml,cplcfefvhpmr,cplcchafvsel,cplcchafvser,             & \n& cplcfefvvwml,cplcfefvvwmr,cplhhsecse,cplsesvimchpm,cplsesvimcvwm,cplsesvrechpm,        & \n& cplsesvrecvwm,cplsecsevp,cplsecsevz,ampvertexiroschatofvse)\n\n end if \n end if \nampvertexchatofvse = ampvertexchatofvse -  ampvertexirdrchatofvse! +  ampvertexiroschatofvse ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatofvse=0._dp \nampvertexzchatofvse=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatofvse(1,gt2,:,:) = ampwavezchatofvse(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatofvse(1,gt1,:,:) \nampvertexzchatofvse(1,gt2,:,:)= ampvertexzchatofvse(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatofvse(1,gt1,:,:) \nampwavezchatofvse(2,gt2,:,:) = ampwavezchatofvse(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatofvse(2,gt1,:,:) \nampvertexzchatofvse(2,gt2,:,:)= ampvertexzchatofvse(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatofvse(2,gt1,:,:) \n end do \nend do \nampwavechatofvse=ampwavezchatofvse \nampvertexchatofvse= ampvertexzchatofvse\n! final state 1 \nampwavezchatofvse=0._dp \nampvertexzchatofvse=0._dp \ndo gt1=1,9\n  do gt2=1,9\nampwavezchatofvse(1,:,gt2,:) = ampwavezchatofvse(1,:,gt2,:)+zruuv(gt2,gt1)*ampwavechatofvse(1,:,gt1,:) \nampvertexzchatofvse(1,:,gt2,:)= ampvertexzchatofvse(1,:,gt2,:)+zruuv(gt2,gt1)*ampvertexchatofvse(1,:,gt1,:) \nampwavezchatofvse(2,:,gt2,:) = ampwavezchatofvse(2,:,gt2,:)+zruuvc(gt2,gt1)*ampwavechatofvse(2,:,gt1,:) \nampvertexzchatofvse(2,:,gt2,:)= ampvertexzchatofvse(2,:,gt2,:)+zruuvc(gt2,gt1)*ampvertexchatofvse(2,:,gt1,:) \n end do \nend do \nampwavechatofvse=ampwavezchatofvse \nampvertexchatofvse= ampvertexzchatofvse\n! final state 2 \nampwavezchatofvse=0._dp \nampvertexzchatofvse=0._dp \ndo gt1=1,6\n  do gt2=1,6\nampwavezchatofvse(:,:,:,gt2) = ampwavezchatofvse(:,:,:,gt2)+zruze(gt2,gt1)*ampwavechatofvse(:,:,:,gt1) \nampvertexzchatofvse(:,:,:,gt2)= ampvertexzchatofvse(:,:,:,gt2)+zruze(gt2,gt1)*ampvertexchatofvse(:,:,:,gt1) \n end do \nend do \nampwavechatofvse=ampwavezchatofvse \nampvertexchatofvse= ampvertexzchatofvse\nend if\nif (shiftirdiv) then \nampvertexchatofvse = ampvertexchatofvse  +  ampvertexiroschatofvse\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->fv se -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatofvse = amptreechatofvse \n ampsum2chatofvse = amptreechatofvse + 2._dp*ampwavechatofvse + 2._dp*ampvertexchatofvse  \nelse \n ampsumchatofvse = amptreechatofvse + ampwavechatofvse + ampvertexchatofvse\n ampsum2chatofvse = amptreechatofvse + ampwavechatofvse + ampvertexchatofvse \nend if \nif (onlytreelevelcontributions) then \n ampsumchatofvse = amptreechatofvse\n ampsum2chatofvse = amptreechatofvse \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,9\n    do gt3=1,6\nif (((oskinematics).and.(mchaos(gt1).gt.(mfvos(gt2)+mseos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mfv(gt2)+mse(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatofvse = amptreechatofvse\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatofvse(gt1, gt2, gt3) \n  ampsum2chatofvse = 2._dp*ampwavechatofvse\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatofvse(gt1, gt2, gt3) \n  ampsum2chatofvse = 2._dp*ampvertexchatofvse\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatofvse(gt1, gt2, gt3) \n  ampsum2chatofvse = amptreechatofvse + 2._dp*ampwavechatofvse + 2._dp*ampvertexchatofvse\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatofvse(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatofvse = amptreechatofvse\n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \n  ampsqtreechatofvse(gt1, gt2, gt3) = ampsqchatofvse(gt1, gt2, gt3)  \n  ampsum2chatofvse = + 2._dp*ampwavechatofvse + 2._dp*ampvertexchatofvse\n  call squareamp_ftofs(mchaos(gt1),mfvos(gt2),mseos(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \n  ampsqchatofvse(gt1, gt2, gt3) = ampsqchatofvse(gt1, gt2, gt3) + ampsqtreechatofvse(gt1, gt2, gt3)  \nelse  \n  ampsum2chatofvse = amptreechatofvse\n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \n  ampsqtreechatofvse(gt1, gt2, gt3) = ampsqchatofvse(gt1, gt2, gt3)  \n  ampsum2chatofvse = + 2._dp*ampwavechatofvse + 2._dp*ampvertexchatofvse\n  call squareamp_ftofs(mcha(gt1),mfv(gt2),mse(gt3),ampsumchatofvse(:,gt1, gt2, gt3),ampsum2chatofvse(:,gt1, gt2, gt3),ampsqchatofvse(gt1, gt2, gt3)) \n  ampsqchatofvse(gt1, gt2, gt3) = ampsqchatofvse(gt1, gt2, gt3) + ampsqtreechatofvse(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatofvse(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatofvse(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mfvos(gt2),mseos(gt3),helfactor*ampsqchatofvse(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mfv(gt2),mse(gt3),helfactor*ampsqchatofvse(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatofvse(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofvse(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatofvse(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatofvse(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatofvse(gt1, gt2, gt3) + mrgchatofvse(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatofvse(gt1, gt2, gt3) + mrgchatofvse(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \nif (.not.calcloopdecay_loopinducedonly) then \n!---------------- \n! bar(fu) sd\n!---------------- \n\n!tree level \n  if (.not.externalzfactors) then \ncall amplitude_tree_ninvseesaw_chatocfusd(cplcchacfusdl,cplcchacfusdr,mcha,           & \n& mfu,msd,mcha2,mfu2,msd2,amptreechatocfusd)\n\n  else \ncall amplitude_tree_ninvseesaw_chatocfusd(zcplcchacfusdl,zcplcchacfusdr,              & \n& mcha,mfu,msd,mcha2,mfu2,msd2,amptreechatocfusd)\n\n  end if \n\n\n!real corrections \nif (oskinematics) then \n  if (.not.externalzfactors) then \n ! os and no z-factors \ncall gamma_real_ninvseesaw_chatocfusd(mlambda,em,gs,cplcchacfusdl,cplcchacfusdr,      & \n& mchaos,mfuos,msdos,mrpchatocfusd,mrgchatocfusd)\n\n  else \n ! os and z-factors \ncall gamma_real_ninvseesaw_chatocfusd(mlambda,em,gs,zcplcchacfusdl,zcplcchacfusdr,    & \n& mchaos,mfuos,msdos,mrpchatocfusd,mrgchatocfusd)\n\n  end if \nelse \n ! dr and no z-factors \n  if (.not.externalzfactors) then \ncall gamma_real_ninvseesaw_chatocfusd(mlambda,em,gs,cplcchacfusdl,cplcchacfusdr,      & \n& mcha,mfu,msd,mrpchatocfusd,mrgchatocfusd)\n\n  else \n ! dr and z-factors \ncall gamma_real_ninvseesaw_chatocfusd(mlambda,em,gs,zcplcchacfusdl,zcplcchacfusdr,    & \n& mcha,mfu,msd,mrpchatocfusd,mrgchatocfusd)\n\n  end if \nend if \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatocfusd(cplcchacfusdl,cplcchacfusdr,ctcplcchacfusdl,& \n& ctcplcchacfusdr,mcha,mcha2,mfu,mfu2,msd,msd2,zfful,zffur,zflm,zflp,zfsd,               & \n& ampwavechatocfusd)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatocfusd(mah,mcha,mchi,mfd,mfu,mglu,               & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfufuahl,          & \n& cplcfufuahr,cplahsdcsd,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,       & \n& cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,               & \n& cplcfdglusdl,cplcfdglusdr,cplcfuglusul,cplcfuglusur,cplhhsdcsd,cplsdcsdvg,             & \n& cplsdcsdvp,cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,           & \n& ampvertexchatocfusd)\n\nif (shiftirdiv) then \ncall amplitude_ir_vertex_ninvseesaw_chatocfusd(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfufuahl,          & \n& cplcfufuahr,cplahsdcsd,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,       & \n& cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,               & \n& cplcfdglusdl,cplcfdglusdr,cplcfuglusul,cplcfuglusur,cplhhsdcsd,cplsdcsdvg,             & \n& cplsdcsdvp,cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,           & \n& ampvertexirdrchatocfusd)\n\n if (externalzfactors) then \n  if (oskinematics) then \n ! os and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatocfusd(mahos,mchaos,mchios,mfdos,             & \n& mfuos,mgluos,mhhos,mhpmos,msdos,msuos,mvg,mvp,mvwmos,mvzos,mah2os,mcha2os,             & \n& mchi2os,mfd2os,mfu2os,mglu2os,mhh2os,mhpm2os,msd2os,msu2os,mvg2,mvp2,mvwm2os,          & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfufuahl,cplcfufuahr,cplahsdcsd,cplcchachahhl,   & \n& cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml,  & \n& cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfuchisul,cplcfuchisur,cplcchachivwml,     & \n& cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,  & \n& cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,             & \n& cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,cplcfdglusdl,cplcfdglusdr,cplcfuglusul,            & \n& cplcfuglusur,cplhhsdcsd,cplsdcsdvg,cplsdcsdvp,cplsdcsdvz,zcplcchacfusdl,               & \n& zcplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,ampvertexiroschatocfusd)\n\n   else \n ! dr and z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatocfusd(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfufuahl,          & \n& cplcfufuahr,cplahsdcsd,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,       & \n& cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,               & \n& cplcfdglusdl,cplcfdglusdr,cplcfuglusul,cplcfuglusur,cplhhsdcsd,cplsdcsdvg,             & \n& cplsdcsdvp,cplsdcsdvz,zcplcchacfusdl,zcplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,         & \n& ampvertexiroschatocfusd)\n\n end if \n else \n  if (oskinematics) then \n ! os and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatocfusd(mahos,mchaos,mchios,mfdos,             & \n& mfuos,mgluos,mhhos,mhpmos,msdos,msuos,mvg,mvp,mvwmos,mvzos,mah2os,mcha2os,             & \n& mchi2os,mfd2os,mfu2os,mglu2os,mhh2os,mhpm2os,msd2os,msu2os,mvg2,mvp2,mvwm2os,          & \n& mvz2os,cplcchachaahl,cplcchachaahr,cplcfufuahl,cplcfufuahr,cplahsdcsd,cplcchachahhl,   & \n& cplcchachahhr,cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml,  & \n& cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,cplcfuchisul,cplcfuchisur,cplcchachivwml,     & \n& cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,  & \n& cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,             & \n& cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,cplcfdglusdl,cplcfdglusdr,cplcfuglusul,            & \n& cplcfuglusur,cplhhsdcsd,cplsdcsdvg,cplsdcsdvp,cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,  & \n& cplsdchpmcsu,cplsdcsucvwm,ampvertexiroschatocfusd)\n\n   else \n ! dr and no z-factors \ncall amplitude_ir_vertex_ninvseesaw_chatocfusd(mah,mcha,mchi,mfd,mfu,mglu,            & \n& mhh,mhpm,msd,msu,mvg,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfu2,mglu2,mhh2,               & \n& mhpm2,msd2,msu2,mvg2,mvp2,mvwm2,mvz2,cplcchachaahl,cplcchachaahr,cplcfufuahl,          & \n& cplcfufuahr,cplahsdcsd,cplcchachahhl,cplcchachahhr,cplcchachavpl,cplcchachavpr,        & \n& cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr,cplcfdchisdl,cplcfdchisdr,   & \n& cplcfuchisul,cplcfuchisur,cplcchachivwml,cplcchachivwmr,cplcchafdcsul,cplcchafdcsur,   & \n& cplcfufdchpml,cplcfufdchpmr,cplcfufdcvwml,cplcfufdcvwmr,cplcfufuhhl,cplcfufuhhr,       & \n& cplcfufuvgl,cplcfufuvgr,cplcfufuvpl,cplcfufuvpr,cplcfufuvzl,cplcfufuvzr,               & \n& cplcfdglusdl,cplcfdglusdr,cplcfuglusul,cplcfuglusur,cplhhsdcsd,cplsdcsdvg,             & \n& cplsdcsdvp,cplsdcsdvz,cplcchacfusdl,cplcchacfusdr,cplsdchpmcsu,cplsdcsucvwm,           & \n& ampvertexiroschatocfusd)\n\n end if \n end if \nampvertexchatocfusd = ampvertexchatocfusd -  ampvertexirdrchatocfusd! +  ampvertexiroschatocfusd ! shift added later\nend if \n\n\n ! add z-factors to have external fields on-shell \n if (externalzfactors) then \n! decaying particle \nampwavezchatocfusd=0._dp \nampvertexzchatocfusd=0._dp \ndo gt1=1,2\n  do gt2=1,2\nampwavezchatocfusd(1,gt2,:,:) = ampwavezchatocfusd(1,gt2,:,:)+zruup(gt2,gt1)*ampwavechatocfusd(1,gt1,:,:) \nampvertexzchatocfusd(1,gt2,:,:)= ampvertexzchatocfusd(1,gt2,:,:) + zruup(gt2,gt1)*ampvertexchatocfusd(1,gt1,:,:) \nampwavezchatocfusd(2,gt2,:,:) = ampwavezchatocfusd(2,gt2,:,:)+zruumc(gt2,gt1)*ampwavechatocfusd(2,gt1,:,:) \nampvertexzchatocfusd(2,gt2,:,:)= ampvertexzchatocfusd(2,gt2,:,:) + zruumc(gt2,gt1)*ampvertexchatocfusd(2,gt1,:,:) \n end do \nend do \nampwavechatocfusd=ampwavezchatocfusd \nampvertexchatocfusd= ampvertexzchatocfusd\n! final state 1 \nampwavezchatocfusd=0._dp \nampvertexzchatocfusd=0._dp \ndo gt1=1,3\n  do gt2=1,3\nampwavezchatocfusd(1,:,gt2,:) = ampwavezchatocfusd(1,:,gt2,:)+zruzur(gt2,gt1)*ampwavechatocfusd(1,:,gt1,:) \nampvertexzchatocfusd(1,:,gt2,:)= ampvertexzchatocfusd(1,:,gt2,:)+zruzur(gt2,gt1)*ampvertexchatocfusd(1,:,gt1,:) \nampwavezchatocfusd(2,:,gt2,:) = ampwavezchatocfusd(2,:,gt2,:)+zruzulc(gt2,gt1)*ampwavechatocfusd(2,:,gt1,:) \nampvertexzchatocfusd(2,:,gt2,:)= ampvertexzchatocfusd(2,:,gt2,:)+zruzulc(gt2,gt1)*ampvertexchatocfusd(2,:,gt1,:) \n end do \nend do \nampwavechatocfusd=ampwavezchatocfusd \nampvertexchatocfusd= ampvertexzchatocfusd\n! final state 2 \nampwavezchatocfusd=0._dp \nampvertexzchatocfusd=0._dp \ndo gt1=1,6\n  do gt2=1,6\nampwavezchatocfusd(:,:,:,gt2) = ampwavezchatocfusd(:,:,:,gt2)+zruzd(gt2,gt1)*ampwavechatocfusd(:,:,:,gt1) \nampvertexzchatocfusd(:,:,:,gt2)= ampvertexzchatocfusd(:,:,:,gt2)+zruzd(gt2,gt1)*ampvertexchatocfusd(:,:,:,gt1) \n end do \nend do \nampwavechatocfusd=ampwavezchatocfusd \nampvertexchatocfusd= ampvertexzchatocfusd\nend if\nif (shiftirdiv) then \nampvertexchatocfusd = ampvertexchatocfusd  +  ampvertexiroschatocfusd\nend if\n \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->bar[fu] sd -----------------------\" \nend if \nif (.not.squarefullamplitudedecays) then \n ampsumchatocfusd = amptreechatocfusd \n ampsum2chatocfusd = amptreechatocfusd + 2._dp*ampwavechatocfusd + 2._dp*ampvertexchatocfusd  \nelse \n ampsumchatocfusd = amptreechatocfusd + ampwavechatocfusd + ampvertexchatocfusd\n ampsum2chatocfusd = amptreechatocfusd + ampwavechatocfusd + ampvertexchatocfusd \nend if \nif (onlytreelevelcontributions) then \n ampsumchatocfusd = amptreechatocfusd\n ampsum2chatocfusd = amptreechatocfusd \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,3\n    do gt3=1,6\nif (((oskinematics).and.(mchaos(gt1).gt.(mfuos(gt2)+msdos(gt3)))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mfu(gt2)+msd(gt3))))) then \n if (debugloopdecays) then \n  write(*,*) gt1, gt2, gt3 \n  ampsum2chatocfusd = amptreechatocfusd\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x tree: \",ampsqchatocfusd(gt1, gt2, gt3) \n  ampsum2chatocfusd = 2._dp*ampwavechatocfusd\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x wave: \",ampsqchatocfusd(gt1, gt2, gt3) \n  ampsum2chatocfusd = 2._dp*ampvertexchatocfusd\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x vertex: \",ampsqchatocfusd(gt1, gt2, gt3) \n  ampsum2chatocfusd = amptreechatocfusd + 2._dp*ampwavechatocfusd + 2._dp*ampvertexchatocfusd\nif (oskinematics) then \n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nelse  \n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \nend if  \n  write(*,*) \"tree x (tree+wave+vertex): \",ampsqchatocfusd(gt1, gt2, gt3) \n end if \nif (oskinematics) then \n  ampsum2chatocfusd = amptreechatocfusd\n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \n  ampsqtreechatocfusd(gt1, gt2, gt3) = ampsqchatocfusd(gt1, gt2, gt3)  \n  ampsum2chatocfusd = + 2._dp*ampwavechatocfusd + 2._dp*ampvertexchatocfusd\n  call squareamp_ftofs(mchaos(gt1),mfuos(gt2),msdos(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \n  ampsqchatocfusd(gt1, gt2, gt3) = ampsqchatocfusd(gt1, gt2, gt3) + ampsqtreechatocfusd(gt1, gt2, gt3)  \nelse  \n  ampsum2chatocfusd = amptreechatocfusd\n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \n  ampsqtreechatocfusd(gt1, gt2, gt3) = ampsqchatocfusd(gt1, gt2, gt3)  \n  ampsum2chatocfusd = + 2._dp*ampwavechatocfusd + 2._dp*ampvertexchatocfusd\n  call squareamp_ftofs(mcha(gt1),mfu(gt2),msd(gt3),ampsumchatocfusd(:,gt1, gt2, gt3),ampsum2chatocfusd(:,gt1, gt2, gt3),ampsqchatocfusd(gt1, gt2, gt3)) \n  ampsqchatocfusd(gt1, gt2, gt3) = ampsqchatocfusd(gt1, gt2, gt3) + ampsqtreechatocfusd(gt1, gt2, gt3)  \nend if  \nelse  \n  ampsqchatocfusd(gt1, gt2, gt3) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatocfusd(gt1, gt2, gt3).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 3._dp*gammatps(mchaos(gt1),mfuos(gt2),msdos(gt3),helfactor*ampsqchatocfusd(gt1, gt2, gt3))\nelse \n  gp1lcha(gt1,i4) = 3._dp*gammatps(mcha(gt1),mfu(gt2),msd(gt3),helfactor*ampsqchatocfusd(gt1, gt2, gt3))\nend if \nif ((abs(mrpchatocfusd(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatocfusd(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \n ! adding real corrections \nif ((abs(mrpchatocfusd(gt1, gt2, gt3)).gt.1.0e-20_dp).or.(abs(mrgchatocfusd(gt1, gt2, gt3)).gt.1.0e-20_dp)) then \n if (.not.onlytreelevelcontributions) then \n   if (debugloopdecays) write(*,*) \"real\", phasespacefactor*0.5_dp*helfactor*(mrpchatocfusd(gt1, gt2, gt3) + mrgchatocfusd(gt1, gt2, gt3)) \n  gp1lcha(gt1,i4) = gp1lcha(gt1,i4) + phasespacefactor*0.5_dp*helfactor*(mrpchatocfusd(gt1, gt2, gt3) + mrgchatocfusd(gt1, gt2, gt3))\n   if (debugloopdecays) write(*,*) \"sum\",  gp1lcha(gt1,i4) \n  end if \nend if \nend if \ni4=i4+1\n\n    end do\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend if \n!---------------- \n! cha vp\n!---------------- \n\nif (loopinduceddecaysos) then \n\n\n!self-energy corrections \n if (externalzfactors) then \ncall amplitude_wave_ninvseesaw_chatochavp(zcplcchachavpl,zcplcchachavpr,              & \n& zcplcchachavzl,zcplcchachavzr,ctcplcchachavpl,ctcplcchachavpr,ctcplcchachavzl,         & \n& ctcplcchachavzr,mchaos,mcha2os,mvp,mvp2,zflm,zflp,zfvp,zfvzvp,ampwavechatochavp)\n\n else \ncall amplitude_wave_ninvseesaw_chatochavp(cplcchachavpl,cplcchachavpr,cplcchachavzl,  & \n& cplcchachavzr,ctcplcchachavpl,ctcplcchachavpr,ctcplcchachavzl,ctcplcchachavzr,         & \n& mchaos,mcha2os,mvp,mvp2,zflm,zflp,zfvp,zfvzvp,ampwavechatochavp)\n\n end if \n\n\n!vertex corrections \n if (externalzfactors) then \ncall amplitude_vertex_ninvseesaw_chatochavp(mahos,mchaos,mchios,mfdos,mfeos,          & \n& mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,mvzos,           & \n& mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,msd2os,              & \n& mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,zcplcchachaahl,zcplcchachaahr,     & \n& zcplchichachpml,zcplchichachpmr,zcplchichacvwml,zcplchichacvwmr,zcplchafucsdl,         & \n& zcplchafucsdr,zcplfvchacsel,zcplfvchacser,zcplcchachahhl,zcplcchachahhr,               & \n& zcplcfdchasul,zcplcfdchasur,zcplcfechasviml,zcplcfechasvimr,zcplcfechasvrel,           & \n& zcplcfechasvrer,zcplcchachavpl,zcplcchachavpr,zcplcchachavzl,zcplcchachavzr,           & \n& zcplcchachihpml,zcplcchachihpmr,zcplcchachivwml,zcplcchachivwmr,zcplcfdfdvpl,          & \n& zcplcfdfdvpr,zcplcchafdcsul,zcplcchafdcsur,zcplcchafesviml,zcplcchafesvimr,            & \n& zcplcchafesvrel,zcplcchafesvrer,zcplcfefevpl,zcplcfefevpr,zcplcfufuvpl,zcplcfufuvpr,   & \n& zcplcchafvsel,zcplcchafvser,zcplhpmchpmvp,zcplhpmcvwmvp,zcplsdcsdvp,zcplcchacfusdl,    & \n& zcplcchacfusdr,zcplsecsevp,zcplsucsuvp,zcplchpmvpvwm,zcplcvwmvpvwm,ampvertexchatochavp)\n\n else \ncall amplitude_vertex_ninvseesaw_chatochavp(mahos,mchaos,mchios,mfdos,mfeos,          & \n& mfuos,mfvos,mhhos,mhpmos,msdos,mseos,msuos,msvimos,msvreos,mvp,mvwmos,mvzos,           & \n& mah2os,mcha2os,mchi2os,mfd2os,mfe2os,mfu2os,mfv2os,mhh2os,mhpm2os,msd2os,              & \n& mse2os,msu2os,msvim2os,msvre2os,mvp2,mvwm2os,mvz2os,cplcchachaahl,cplcchachaahr,       & \n& cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,cplchafucsdl,              & \n& cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,cplcfdchasul,       & \n& cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer,              & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr, & \n& cplcchachivwml,cplcchachivwmr,cplcfdfdvpl,cplcfdfdvpr,cplcchafdcsul,cplcchafdcsur,     & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfefevpl,               & \n& cplcfefevpr,cplcfufuvpl,cplcfufuvpr,cplcchafvsel,cplcchafvser,cplhpmchpmvp,            & \n& cplhpmcvwmvp,cplsdcsdvp,cplcchacfusdl,cplcchacfusdr,cplsecsevp,cplsucsuvp,             & \n& cplchpmvpvwm,cplcvwmvpvwm,ampvertexchatochavp)\n\n end if \nelse \n\n\n!self-energy corrections \ncall amplitude_wave_ninvseesaw_chatochavp(cplcchachavpl,cplcchachavpr,cplcchachavzl,  & \n& cplcchachavzr,ctcplcchachavpl,ctcplcchachavpr,ctcplcchachavzl,ctcplcchachavzr,         & \n& mcha,mcha2,mvp,mvp2,zflm,zflp,zfvp,zfvzvp,ampwavechatochavp)\n\n\n\n!vertex corrections \ncall amplitude_vertex_ninvseesaw_chatochavp(mah,mcha,mchi,mfd,mfe,mfu,mfv,            & \n& mhh,mhpm,msd,mse,msu,msvim,msvre,mvp,mvwm,mvz,mah2,mcha2,mchi2,mfd2,mfe2,              & \n& mfu2,mfv2,mhh2,mhpm2,msd2,mse2,msu2,msvim2,msvre2,mvp2,mvwm2,mvz2,cplcchachaahl,       & \n& cplcchachaahr,cplchichachpml,cplchichachpmr,cplchichacvwml,cplchichacvwmr,             & \n& cplchafucsdl,cplchafucsdr,cplfvchacsel,cplfvchacser,cplcchachahhl,cplcchachahhr,       & \n& cplcfdchasul,cplcfdchasur,cplcfechasviml,cplcfechasvimr,cplcfechasvrel,cplcfechasvrer, & \n& cplcchachavpl,cplcchachavpr,cplcchachavzl,cplcchachavzr,cplcchachihpml,cplcchachihpmr, & \n& cplcchachivwml,cplcchachivwmr,cplcfdfdvpl,cplcfdfdvpr,cplcchafdcsul,cplcchafdcsur,     & \n& cplcchafesviml,cplcchafesvimr,cplcchafesvrel,cplcchafesvrer,cplcfefevpl,               & \n& cplcfefevpr,cplcfufuvpl,cplcfufuvpr,cplcchafvsel,cplcchafvser,cplhpmchpmvp,            & \n& cplhpmcvwmvp,cplsdcsdvp,cplcchacfusdl,cplcchacfusdr,cplsecsevp,cplsucsuvp,             & \n& cplchpmvpvwm,cplcvwmvpvwm,ampvertexchatochavp)\n\nend if \n\n\n !square the amplitude \nif (debugloopdecays) then \nwrite(*,*) \"------------------ cha->cha vp -----------------------\" \nend if \nif (onlytreelevelcontributions) then \n ampsumchatochavp = 0._dp \n ampsum2chatochavp = 0._dp  \nelse \n ampsumchatochavp = ampvertexchatochavp + ampwavechatochavp\n ampsum2chatochavp = ampvertexchatochavp + ampwavechatochavp \nend if \ndo gt1=1,2\ni4 = isave \n  do gt2=1,2\nif (((oskinematics).and.(mchaos(gt1).gt.(mchaos(gt2)+0.))).or.((.not.oskinematics).and.(mcha(gt1).gt.(mcha(gt2)+mvp)))) then \nif (oskinematics) then \n  call squareamp_ftofv(mchaos(gt1),mchaos(gt2),0._dp,ampsumchatochavp(:,gt1, gt2),ampsum2chatochavp(:,gt1, gt2),ampsqchatochavp(gt1, gt2)) \nelse  \n  call squareamp_ftofv(mcha(gt1),mcha(gt2),mvp,ampsumchatochavp(:,gt1, gt2),ampsum2chatochavp(:,gt1, gt2),ampsqchatochavp(gt1, gt2)) \nend if  \nelse  \n  ampsqchatochavp(gt1, gt2) = 0._dp \nend if  \n\n! calculate partial widths \nhelfactor = 2._dp \nif (ampsqchatochavp(gt1, gt2).le.0._dp) then \n  gp1lcha(gt1,i4) = 0._dp \nelse \nif (oskinematics) then \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mchaos(gt1),mchaos(gt2),0._dp,helfactor*ampsqchatochavp(gt1, gt2))\nelse \n  gp1lcha(gt1,i4) = 1._dp*gammatps(mcha(gt1),mcha(gt2),mvp,helfactor*ampsqchatochavp(gt1, gt2))\nend if \nif ((abs(mrpchatochavp(gt1, gt2)).gt.1.0e-20_dp).or.(abs(mrgchatochavp(gt1, gt2)).gt.1.0e-20_dp)) then \n  phasespacefactor = 1._dp \nend if \n if (debugloopdecays) write(*,*) \"virtual\", gp1lcha(gt1,i4) \nend if \ni4=i4+1\n\n  end do\nif (gt1.eq.2) isave = i4 \nend do\nend subroutine oneloopdecay_cha\n"}
{"id": 469, "subroutine": "subroutine mburyvt(buryf,tillf,bcrbc,bdrbc,burydistflg,nlay,lthick,ldepth,      &\n                 & btmflatstem,btmflatleaf,btmflatstore,btmflatrootstore,       &\n                 & btmflatrootfiber,btmbgstemz,btmbgleafz,btmbgstorez,          &\n                 & btmbgrootstorez,btmbgrootfiberz,bdmflatstem,bdmflatleaf,     &\n                 & bdmflatstore,bdmflatrootstore,bdmflatrootfiber,bdmbgstemz,   &\n                 & bdmbgleafz,bdmbgstorez,bdmbgrootstorez,bdmbgrootfiberz,bflg)\nimplicit none\n!\ninclude 'p1werm.inc'\n!\n\n!\ninteger :: bcrbc,bflg,burydistflg,nlay\nreal :: btmflatleaf,btmflatrootfiber,btmflatrootstore,btmflatstem,btmflatstore, &\n      & tillf\nreal,dimension(mnsz,mnbpls) :: bdmbgleafz,bdmbgrootfiberz,bdmbgrootstorez,      &\n                             & bdmbgstemz,bdmbgstorez\nreal,dimension(mnbpls) :: bdmflatleaf,bdmflatrootfiber,bdmflatrootstore,        &\n                        & bdmflatstem,bdmflatstore\ninteger,dimension(mnbpls) :: bdrbc\nreal,dimension(mnsz) :: btmbgleafz,btmbgrootfiberz,btmbgrootstorez,btmbgstemz,  &\n                      & btmbgstorez,ldepth,lthick\nreal,dimension(mnrbc) :: buryf\n!\n! local variables\n!\nreal :: burydist\nreal,dimension(nlay) :: fracbury\ninteger :: idy,lay,tflg\nreal :: tbury\n!\n!     + + + purpose + + +\n!\n\n!     the above ground biomass into the soil or the inverse process of bringing\n!     buried biomass to the surface.  it deals only with the biomass\n!     pools (ie no live crop is involved)\n!\n!     + + + keywords + + +\n!     bury, lift, biomass manipulation\n \n!\n!     + + + argument declarations + + +\n \n\n!     + + + argument definitions + + +\n \n!     buryf     - fraction of flat material buried for\n!                 different residue burial classes (m^2/m^2)\n!     tillf    - fraction of soil area tilled by the machine\n!     bcrbc     - residue burial class for standing crop\n!     bdrbc     - residue burial classes for residue\n!     nlay      - number of soil layers used in the operation(s)\n!     lthick    - distance from soil surface to bottom of layer\n!                 for each soil layer\n!     btmflatstem  - crop flat stem mass (kg/m^2)\n!     btmflatleaf  - crop flat leaf mass (kg/m^2)\n!     btmflatstore - crop flat storage mass (kg/m^2)\n \n!     btmflatrootstore - crop flat root storage mass (kg/m^2)\n!                   (tubers (potatoes, carrots), extended leaf (onion), seeds (peanuts))\n!     btmflatrootfiber - crop flat root fibrous mass (kg/m^2)\n \n!     btmbgflatstemz  - crop buried stem mass by layer (kg/m^2)\n!     btmbgflatleafz  - crop buried leaf mass by layer (kg/m^2)\n!     btmbgflatstorez - crop buried storage mass by layer (kg/m^2)\n \n!     btmbgrootstorez - crop root storage mass by layer (kg/m^2)\n!                   (tubers (potatoes, carrots), extended leaf (onion), seeds (peanuts))\n!     btmbgrootfiberz - crop root fibrous mass by layer (kg/m^2)\n \n!     bdmflatstem  - flat stem mass (kg/m^2)\n!     bdmflatleaf  - flat leaf mass (kg/m^2)\n!     bdmflatstore - flat storage mass (kg/m^2)\n \n!     bdmflatstore - flat storage root mass (kg/m^2)\n!     bdmflatfiber - flat fibrous root mass (kg/m^2)\n \n!     bdmbgstemz  - buried stem mass by layer (kg/m^2)\n!     bdmbgleafz  - buried leaf mass by layer (kg/m^2)\n!     bdmbgstorez - buried (from above ground) storage mass by layer (kg/m^2)\n \n!     bdmbgrootstorez - buried storage root mass by layer (kg/m^2)\n!     bdmbgrootfiberz - buried fibrous root mass by layer (kg/m^2)\n \n!     bflg      - flag indicating what to manipulate\n!       0 - all standing material is manipulate (both crop and residue)\n!       1 - crop\n!       2 - 1'st residue pool\n!       4 - 2'nd residue pool\n!       ....\n!       2**n - nth residue pool\n \n!       note that any combination of pools or crop may be used\n!       a bit test is done on the binary number to see what to modify\n!\n!     + + + accessed common block variable definitions + + +\n!\n!     mnrbc         - max number of residue burial classes\n!     mnbpls        - max number of biomass pools\n!     mnsz          - max number of soil layers\n!\n!     + + + functions + + +\n!\n!     + + + local variables + + +\n!\n!\n!     + + + local variable definitions + + +\n!\n!     bury      - mass of biomass that is buried\n!     tbury     - mass of crop biomass that is buried\n!     idy       - biomass pools (1-3)\n!     lay       - number of layers in a specified subregion\n!     tflg      - temporary biomass flag\n!\n!     + + + end specifications + + +\n!\n      !set tflg bits correctly for \"all\" pools if bflg=0\nif (bflg.eq.0) then\n  tflg = 1                          ! crop pool\n  do idy = 1,mnbpls\n     tflg = tflg + 2**idy           ! decomp pools\n  end do\nelse\n  tflg = bflg\nend if\n \n!     calculate fractions of total to be buried in each layer\ndo lay = 1,nlay\n  fracbury(lay) = burydist(lay,burydistflg,lthick,ldepth,nlay)\nend do\n      !perform the burying of biomass\n!      print *, 'mbury tflg/bflg: ', tflg, bflg\n!      print *, 'tflat before mbury: ', tflat\n!      print *, 'dflat before mbury: ', dflat(1), dflat(2),dflat(3)\n \n!     check for proper indexes in bcrbc\nif ((bcrbc.ge.1).and.(bcrbc.le.mnrbc)) then\n  if (btest(tflg,0)) then               ! crop pool\n              ! stem component\n     tbury = btmflatstem*buryf(bcrbc)*tillf\n     do lay = 1,nlay\n        btmbgstemz(lay) = btmbgstemz(lay) + tbury*fracbury(lay)\n     end do\n     btmflatstem = btmflatstem - tbury\n              ! leaf component\n     tbury = btmflatleaf*buryf(bcrbc)*tillf\n     do lay = 1,nlay\n        btmbgleafz(lay) = btmbgleafz(lay) + tbury*fracbury(lay)\n     end do\n     btmflatleaf = btmflatleaf - tbury\n              ! storage component\n     tbury = btmflatstore*buryf(bcrbc)*tillf\n     do lay = 1,nlay\n        btmbgstorez(lay) = btmbgstorez(lay) + tbury*fracbury(lay)\n     end do\n     btmflatstore = btmflatstore - tbury\n              ! root storage component\n     tbury = btmflatrootstore*buryf(bcrbc)*tillf\n     do lay = 1,nlay\n        btmbgrootstorez(lay) = btmbgrootstorez(lay) + tbury*fracbury(lay)\n     end do\n     btmflatrootstore = btmflatrootstore - tbury\n              ! root fiber component\n     tbury = btmflatrootfiber*buryf(bcrbc)*tillf\n     do lay = 1,nlay\n        btmbgrootfiberz(lay) = btmbgrootfiberz(lay) + tbury*fracbury(lay)\n     end do\n     btmflatrootfiber = btmflatrootfiber - tbury\n  end if\nend if\n \ndo idy = 1,mnbpls\n!         check for proper indexes in bdrbc\n  if ((bdrbc(idy).ge.1).and.(bdrbc(idy).le.mnrbc)) then\n     if (btest(tflg,idy)) then\n        tbury = bdmflatstem(idy)*buryf(bdrbc(idy))*tillf\n        do lay = 1,nlay\n           bdmbgstemz(lay,idy) = bdmbgstemz(lay,idy) + tbury*fracbury(lay)\n        end do\n        bdmflatstem(idy) = bdmflatstem(idy) - tbury\n \n        tbury = bdmflatleaf(idy)*buryf(bdrbc(idy))*tillf\n        do lay = 1,nlay\n           bdmbgleafz(lay,idy) = bdmbgleafz(lay,idy) + tbury*fracbury(lay)\n        end do\n        bdmflatleaf(idy) = bdmflatleaf(idy) - tbury\n \n        tbury = bdmflatstore(idy)*buryf(bdrbc(idy))*tillf\n        do lay = 1,nlay\n           bdmbgstorez(lay,idy) = bdmbgstorez(lay,idy) + tbury*fracbury(lay)\n        end do\n        bdmflatstore(idy) = bdmflatstore(idy) - tbury\n \n        tbury = bdmflatrootstore(idy)*buryf(bdrbc(idy))*tillf\n        do lay = 1,nlay\n           bdmbgrootstorez(lay,idy) = bdmbgrootstorez(lay,idy)                  &\n                                    & + tbury*fracbury(lay)\n        end do\n        bdmflatrootstore(idy) = bdmflatrootstore(idy) - tbury\n \n        tbury = bdmflatrootfiber(idy)*buryf(bdrbc(idy))*tillf\n        do lay = 1,nlay\n           bdmbgrootfiberz(lay,idy) = bdmbgrootfiberz(lay,idy)                  &\n                                    & + tbury*fracbury(lay)\n        end do\n        bdmflatrootfiber(idy) = bdmflatrootfiber(idy) - tbury\n     end if\n  end if\nend do\n! \n!      print *, 'tflat after mbury: ', tflat\n!      print *, 'dflat after mbury: ', dflat(1), dflat(2),dflat(3)\n!\nend subroutine mburyvt\n"}
{"id": 470, "subroutine": "  subroutine query_init(this)\n    type(query_t), intent(out) :: this\n\n    this%cptr = c_query_create()\n\n  end subroutine query_init\n"}
{"id": 471, "subroutine": "  subroutine query_final(this)\n    type(query_t), intent(inout) :: this\n\n    if (.not. c_associated(this%cptr)) then\n      return\n    end if\n    call c_query_destroy(this%cptr)\n    this%cptr = c_null_ptr\n\n  end subroutine query_final\n"}
{"id": 472, "subroutine": "  subroutine query_get_child(this, node, name, child, required, error)\n    class(query_t), intent(inout) :: this\n    type(node_t), intent(in) :: node\n    character(*), intent(in) :: name\n    type(node_t), intent(out) :: child\n    logical, intent(in), optional :: required\n    type(error_t), intent(out), optional :: error\n\n    type(error_t) :: error_\n\n    error_%cptr = c_query_get_child(this%cptr, node%cptr, f_c_string(name),&\n        & logical(required, kind=c_bool), child%cptr)\n    call handle_error(error_, \"child '\" // name // \"' of node '\" // node%get_name()&\n        & // \"' not found\", error)\n    if (present(error)) then\n      call error_%move_to(error)\n      return\n    else if (error_%is_associated()) then\n      error stop\n    end if\n\n  end subroutine query_get_child\n"}
{"id": 473, "subroutine": "  subroutine query_get_child_data_array(this, node, name, data, child, error)\n    class(query_t), intent(inout) :: this\n    type(node_t), intent(in) :: node\n    character(*), intent(in) :: name\n    type(array_t), intent(out) :: data\n    type(node_t), intent(out), optional :: child\n    type(error_t), intent(out), optional :: error\n\n    type(node_t) :: child_\n    type(error_t) :: error_\n\n    error_%cptr = c_query_get_child_data(this%cptr, node%cptr, f_c_string(name), child_%cptr,&\n        & data%cptr)\n    call handle_error(error_, \"data child '\" // name // \"' of node '\" // node%get_name()&\n        & // \"' not found\", error)\n    if (present(child)) then\n      call child_%move_to(child)\n    end if\n\n  end subroutine query_get_child_data_array\n"}
{"id": 474, "subroutine": "  subroutine query_get_child_data_i4(this, node, name, data, child, error)\n    class(query_t), intent(inout) :: this\n    type(node_t), intent(in) :: node\n    character(*), intent(in) :: name\n    integer(c_int), intent(out) :: data\n    type(node_t), intent(out), optional :: child\n    type(error_t), intent(out), optional :: error\n\n    type(node_t) :: child_\n    type(error_t) :: error_\n\n    error_%cptr = c_query_get_child_data_i4(this%cptr, node%cptr, f_c_string(name), child_%cptr,&\n        & data)\n    call handle_error(error_, \"data child '\" // name // \"' of node '\" // node%get_name()&\n        & // \"' with i4 data not found\", error)\n    if (present(child)) then\n      call child_%move_to(child)\n    end if\n\n  end subroutine query_get_child_data_i4\n"}
{"id": 475, "subroutine": "  subroutine query_get_child_data_i4_ptr2(this, node, name, data, child, error)\n    class(query_t), intent(inout) :: this\n    type(node_t), intent(in) :: node\n    character(*), intent(in) :: name\n    integer(c_int), pointer, intent(out) :: data(:,:)\n    type(node_t), intent(out), optional :: child\n    type(error_t), intent(out), optional :: error\n\n    type(c_ptr) :: cshape, cdata\n    integer(c_int), pointer :: pshape(:)\n    integer, allocatable :: fshape(:)\n    integer :: rank\n    type(node_t) :: child_\n    type(error_t) :: error_\n\n    error_%cptr = c_query_get_child_data_i4p(this%cptr, node%cptr, f_c_string(name), child_%cptr,&\n        & rank, cshape, cdata)\n    call handle_error(error_, \"data child '\" // name // \"' of node '\" // node%get_name()&\n        & // \"' with i4 data not found\", error)\n    call check_rank(rank, 2, child_)\n    call c_f_pointer(cshape, pshape, [rank])\n    ! reverse shape as it is stored with row-major convention\n    fshape = pshape(rank : 1 : -1)\n    call c_f_pointer(cdata, data, fshape)\n    if (present(child)) then\n      call child_%move_to(child)\n    end if\n\n  end subroutine query_get_child_data_i4_ptr2\n"}
{"id": 476, "subroutine": "  subroutine check_rank(obtained, expected, child)\n    integer, intent(in) :: obtained, expected\n    type(node_t), intent(in) :: child\n\n    if (expected /= obtained) then\n      call fatal_error(\"invalid rank for child '\" // child%get_name() // \"'\")\n    end if\n\n  end subroutine check_rank\n"}
{"id": 477, "subroutine": "  subroutine move_to_optval(val, optval)\n    type(node_t), intent(inout) :: val\n    type(node_t), intent(out), optional :: optval\n\n    if (present(optval)) then\n      call val%move_to(optval)\n    end if\n\n  end subroutine move_to_optval\n"}
{"id": 478, "subroutine": "  subroutine tag_boxes(mf,tagboxes,dx,lev,aux_tag_mf)\n\n    use variables, only: rho_comp, spec_comp\n    use geometry, only: nr_fine, nr\n    use network, only: network_species_index\n\n    type( multifab)          , intent(in   ) :: mf\n    type(lmultifab)          , intent(inout) :: tagboxes\n    real(dp_t)               , intent(in   ) :: dx\n    integer                  , intent(in   ) :: lev\n    type( multifab), optional, intent(in   ) :: aux_tag_mf\n\n    real(kind = dp_t), pointer :: sp(:,:,:,:)\n    logical          , pointer :: tp(:,:,:,:)\n    integer           :: i, j, lo(get_dim(mf)), ng_s, dm\n    logical           ::      radialtag(0:nr_fine-1)\n    logical           :: radialtag_proc(0:nr_fine-1)\n\n    integer, save :: ih1\n    logical, save :: firstcall = .true.\n\n    if (firstcall) then\n       ih1 = network_species_index(\"hydrogen-1\")\n       firstcall = .false.\n    endif\n\n\n    radialtag = .false.\n    radialtag_proc = .false.\n\n    dm = get_dim(mf)\n\n    ng_s = mf%ng\n\n    do i = 1, nfabs(mf)\n       sp => dataptr(mf, i)\n       lo =  lwb(get_box(tagboxes, i))\n       select case (dm)\n       case (2)\n          call radialtag_2d(radialtag_proc, &\n                            sp(:,:,1,spec_comp-1+ih1),sp(:,:,1,rho_comp),&\n                            lo,ng_s,lev)\n       case  (3)\n          call radialtag_3d(radialtag_proc, &\n                            sp(:,:,:,spec_comp-1+ih1),sp(:,:,:,rho_comp), &\n                            lo,ng_s,lev)\n       end select\n    end do\n\n    ! gather radialtag\n    call parallel_reduce(radialtag, radialtag_proc, mpi_lor)\n\n\n    do i = 1, nfabs(mf)\n       tp => dataptr(tagboxes, i)\n       lo =  lwb(get_box(tagboxes, i))\n       select case (dm)\n       case (2)\n          call tag_boxes_2d(tp(:,:,1,1),radialtag,lo)\n       case  (3)\n          call tag_boxes_3d(tp(:,:,:,1),radialtag,lo)\n       end select\n    end do\n\n  end subroutine tag_boxes\n"}
{"id": 479, "subroutine": "  subroutine radialtag_2d(radialtag,h1,rho,lo,ng,lev)\n\n    use probin_module, only: base_cutoff_density\n\n    integer          , intent(in   ) :: lo(:),ng\n    logical          , intent(inout) :: radialtag(0:)\n    real(kind = dp_t), intent(in   ) ::  h1(lo(1)-ng:,lo(2)-ng:)\n    real(kind = dp_t), intent(in   ) :: rho(lo(1)-ng:,lo(2)-ng:)\n    integer, optional, intent(in   ) :: lev\n\n    ! local\n    integer :: i,j,nx,ny,llev\n    real(kind=dp_t) :: xh1\n\n    llev = 1; if (present(lev)) llev = lev\n    nx = size(h1,dim=1) - 2*ng\n    ny = size(h1,dim=2) - 2*ng\n\n    do j = lo(2),lo(2)+ny-1\n       do i = lo(1),lo(1)+nx-1\n          xh1 = h1(i,j)/rho(i,j)\n\n          if (xh1 > 1.d-4 .and. rho(i,j) > 2.d0*base_cutoff_density) then\n             radialtag(j) = .true.\n          end if\n\n       end do\n    enddo\n\n  end subroutine radialtag_2d\n"}
{"id": 480, "subroutine": "  subroutine radialtag_3d(radialtag,h1,rho,lo,ng,lev)\n\n    use probin_module, only: base_cutoff_density\n\n    integer          , intent(in   ) :: lo(:),ng\n    logical          , intent(inout) :: radialtag(0:)\n    real(kind = dp_t), intent(in   ) ::  h1(lo(1)-ng:,lo(2)-ng:,lo(3)-ng:)\n    real(kind = dp_t), intent(in   ) :: rho(lo(1)-ng:,lo(2)-ng:,lo(3)-ng:)\n    integer, optional, intent(in   ) :: lev\n\n    ! local\n    integer :: i,j,k,nx,ny,nz,llev\n    real(kind=dp_t) :: xh1\n\n    llev = 1; if (present(lev)) llev = lev\n    nx = size(h1,dim=1) - 2*ng\n    ny = size(h1,dim=2) - 2*ng\n    nz = size(h1,dim=3) - 2*ng\n\n    do k = lo(3),lo(3)+nz-1\n       do j = lo(2),lo(2)+ny-1\n          do i = lo(1),lo(1)+nx-1\n\n             xh1 = h1(i,j,k)/rho(i,j,k)\n             if (xh1 > 1.d-4 .and. rho(i,j,k) > 2.d0*base_cutoff_density) then\n                radialtag(k) = .true.\n             end if\n\n          end do\n       enddo\n    end do\n\n  end subroutine radialtag_3d\n"}
{"id": 481, "subroutine": "  subroutine tag_boxes_2d(tagbox,radialtag,lo)\n\n    integer          , intent(in   ) :: lo(:)\n    logical          , intent(  out) :: tagbox(lo(1):,lo(2):)\n    logical          , intent(in   ) :: radialtag(0:)\n\n    integer :: j,ny\n\n    ny = size(tagbox,dim=2)\n\n    tagbox = .false.\n\n    ! tag all boxes with radialtag = .true\n    do j = lo(2),lo(2)+ny-1\n       tagbox(:,j) = radialtag(j)\n    enddo\n\n  end subroutine tag_boxes_2d\n"}
{"id": 482, "subroutine": "  subroutine tag_boxes_3d(tagbox,radialtag,lo)\n\n    integer          , intent(in   ) :: lo(:)\n    logical          , intent(  out) :: tagbox(lo(1):,lo(2):,lo(3):)\n    logical          , intent(in   ) :: radialtag(0:)\n\n    integer :: k,nz\n\n    nz = size(tagbox,dim=3)\n\n    tagbox = .false.\n\n    ! tag all boxes with radialtag = .true.\n    do k = lo(3),lo(3)+nz-1\n       tagbox(:,:,k) = radialtag(k)\n    end do\n\n  end subroutine tag_boxes_3d\n"}
{"id": 483, "subroutine": "  subroutine r\n    real(kind = kind(c)) :: d   ! invalid declaration\n                                ! see below\n    real(kind=2) :: c\n  end subroutine r\n"}
{"id": 484, "subroutine": "      subroutine nine11(j1, j2, j3, l1, l2, k1, a) \n!-----------------------------------------------\n!   m o d u l e s \n!-----------------------------------------------\n      use vast_kind_param, only:  double \n      use consts_c \n!...translated by pacific-sierra research 77to90  4.3e  10:09:06  11/16/01  \n!...switches:                     \n!-----------------------------------------------\n!   i n t e r f a c e   b l o c k s\n!-----------------------------------------------\n      use sixj_i \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer  :: j1 \n      integer  :: j2 \n      integer  :: j3 \n      integer  :: l1 \n      integer  :: l2 \n      integer  :: k1 \n      real(double) , intent(out) :: a \n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: iskai \n      real(double) :: s, vard \n!-----------------------------------------------\n      a = zero \n      iskai = dble((j1 - l1)*(j1 + l1 + 2) - (j2 - l2)*(j2 + l2 + 2)) \n      if (iskai == 0) return  \n      call sixj (j1, l1, k1, l2, j2, j3, 0, s) \n      vard = dsqrt(dble(4*k1)*dble(k1 + 2)*dble(k1 + 1)*dble(j3)*dble(j3 + 2)*&\n         dble(j3 + 1)) \n      a = s*dble(iskai)/vard \n      if (mod(l1 + j2 + k1 + j3,4) /= 0) a = -a \n      return  \n      end subroutine nine11 \n"}
{"id": 485, "subroutine": "subroutine matprd(a,b,c,nrowa,ncola,ncolb)\n    implicit none\n    ! parameter\n    real(8) r0 /0.0d0/\n    ! arguments\n    integer :: nrowa , ncola , ncolb\n    real(8), dimension(nrowa,ncola)  :: a\n    real(8), dimension(ncola, ncolb) :: b\n    real(8), dimension(nrowa,ncolb)  :: c\n    ! locals\n    integer i, j, k\n    ! begin algorithm\r\n    c=r0\n    do j=1,ncolb\n\t    do k=1,ncola\n\t\t    do i=1,nrowa\n\t\t\t    c(i,j)=c(i,j)+a(i,k)*b(k,j)\n\t\t    enddo\n\t    enddo\n    enddo\nend subroutine\n"}
{"id": 486, "subroutine": "  subroutine message_decorated_str(mark,string)\n    !! \u98fe\u308a\u6587\u5b57\u3067\u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u3092\u56f2\u3080\n    !!  \n    !!   usage:\n    !!\n    !!      call message_decorated_str('#',\"this is a test.\")\n    !!\n    !!   output:\n    !! \n    !!      ###################\n    !!      # this is a test. #\n    !!      ###################\n    !!  \n    character, intent(in)        :: mark    !! \u3053\u306e\u6587\u5b57\u3067\u30e1\u30fc\u30bb\u30fc\u30b8\u3092\u56f2\u3080\n    character(len=*), intent(in) :: string  !! \u51fa\u529b\u30e1\u30fc\u30bb\u30fc\u30b8\uff08\u6587\u5b57\u5217\uff09\n     \n    integer(si) :: len\n\n    len = len_trim(string) + 4\n\n    write(6,*) repeat(mark,len)\n    write(6,*) mark//' '//trim(string)//' '//mark\n    write(6,*) repeat(mark,len)\n  end subroutine message_decorated_str\n"}
{"id": 487, "subroutine": "  subroutine message_decorated_str_sint(mark,string,int)\n    !!  \u98fe\u308a\u6587\u5b57\u3067\u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u3068\u5358\u7cbe\u5ea6\u6574\u6570\u3092\u56f2\u3080\n    !!\n    !!  usage:\n    !!\n    !!     call mess...('#','this is message at nloop = ', nloop)\n    !!\n    character, intent(in)        :: mark   !! \u3053\u306e\u6587\u5b57\u3067\u5168\u4f53\u3092\u56f2\u3080\n    character(len=*), intent(in) :: string !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    integer(si), intent(in)      :: int    !! \u6587\u5b57\u5217\u306e\u5f8c\u306b\u66f8\u304f\u5358\u7cbe\u5ea6\u6574\u6570\n    character(len=200) :: string_int\n\n    write(string_int,'(a,i8)') string, int\n\n    call message_decorated_str(mark, string_int)\n  end subroutine message_decorated_str_sint\n"}
{"id": 488, "subroutine": "  subroutine message_decorated_str_dint(mark,string,int) \n    !! \u98fe\u308a\u6587\u5b57\u3067\u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u3068\u500d\u7cbe\u5ea6\u6574\u6570\u3092\u56f2\u3080\n    !!\n    !! usage:\n    !!\n    !!    call mess...('#','this is message at nloop = ', nloop)\n    !!\n    character, intent(in)        :: mark   !! \u3053\u306e\u6587\u5b57\u3067\u5168\u4f53\u3092\u56f2\u3080\n    character(len=*), intent(in) :: string !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    integer(di), intent(in)      :: int    !! \u6587\u5b57\u5217\u306e\u5f8c\u306b\u66f8\u304f\u500d\u7cbe\u5ea6\u6574\u6570\n    character(len=200) :: string_int\n\n    write(string_int,'(a,i16)') string, int\n\n    call message_decorated_str(mark, string_int)\n  end subroutine message_decorated_str_dint\n"}
{"id": 489, "subroutine": "  subroutine message_str(string)\n    !! \u666e\u901a\u306eprint\u6587\n    character(len=*), intent(in) :: string !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n\n    write(6,*) string\n  end subroutine message_str\n"}
{"id": 490, "subroutine": "  subroutine message_str_double(string, double)\n    !! \u6587\u5b57\u5217 + \u500d\u7cbe\u5ea6\u5b9f\u65702\u3064\u306e\u51fa\u529b\n    character(len=*), intent(in) :: string !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    real(dr), intent(in)         :: double !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u5b9f\u6570\n\n    write(6,*) string, double\n  end subroutine message_str_double\n"}
{"id": 491, "subroutine": "  subroutine message_str_double_double(string, double1, double2)\n    !! \u98fe\u308a\u6587\u5b57\u3067\u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u3068\u500d\u7cbe\u5ea6\u5b9f\u65702\u3064\u3092\u56f2\u3080\n    character(len=*), intent(in) :: string  !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    real(dr), intent(in)         :: double1 !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u5b9f\u65701\n    real(dr), intent(in)         :: double2 !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u5b9f\u65702\n\n    write(6,*) string, double1, double2\n  end subroutine message_str_double_double\n"}
{"id": 492, "subroutine": "  subroutine message_str_sint(string, int)\n    !! \u6587\u5b57\u5217 + \u5358\u7cbe\u5ea6\u6574\u6570\u306e\u51fa\u529b\n    character(len=*), intent(in) :: string  !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    integer(si), intent(in)      :: int     !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u6574\u6570\n\n    write(6,*) string, int\n  end subroutine message_str_sint\n"}
{"id": 493, "subroutine": "  subroutine message_str_dint(string, int)\n    !! \u6587\u5b57\u5217 + \u500d\u7cbe\u5ea6\u6574\u6570\u306e\u51fa\u529b\n    character(len=*), intent(in) :: string  !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    integer(di), intent(in)      :: int     !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u6574\u6570\n\n    write(6,*) string, int\n  end subroutine message_str_dint\n"}
{"id": 494, "subroutine": "  subroutine message_str_sint_double(string, i1, d1)\n    !! \u6587\u5b57\u5217 + \u5358\u7cbe\u5ea6\u6574\u6570 + \u500d\u7cbe\u5ea6\u5b9f\u6570\u306e\u51fa\u529b\n    character(len=*), intent(in) :: string  !! \u30e1\u30fc\u30bb\u30fc\u30b8\u6587\u5b57\u5217\n    integer(si), intent(in)      :: i1      !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u6574\u6570\n    real(dr), intent(in)         :: d1      !! \u66f8\u304d\u51fa\u3055\u308c\u308b\u5b9f\u6570\n\n    write(6,*) string, i1, d1\n  end subroutine message_str_sint_double\n"}
{"id": 495, "subroutine": "  subroutine ut__assert(must_be_true,message)\n    !! \u30a2\u30b5\u30fc\u30b7\u30e7\u30f3\n    logical,          intent(in) :: must_be_true !! \u5fc5\u9808\u6761\u4ef6\n    character(len=*), intent(in) :: message      !! \u907a\u8a00\n\n    if ( .not.must_be_true ) then\n       call ut__fatal(message)\n    end if\n  end subroutine ut__assert\n"}
{"id": 496, "subroutine": "  subroutine ut__fatal(last_will)\n    !! \u81f4\u547d\u7684\u30a8\u30e9\u30fc\n    !!\n    !!   print the last_will and stop.\n    !!\n    character(len=*), intent(in) :: last_will   !! \u907a\u8a00\n    call ut__message('!',last_will)\n    stop 'program stopped by ut__fatal.'\n  end subroutine ut__fatal\n"}
{"id": 497, "subroutine": "            subroutine checkio(kstat,ym)\n              integer(kind=4) :: kstat\n              character(*) :: ym\n            end subroutine checkio\n"}
{"id": 498, "subroutine": "subroutine evaluate_wave_transmission(grav_dirn,grav_factor,&\n    n_time,heartrate,a0,no_freq,a,b,n_adparams,admittance_param,n_model,model_definition,cap_model)\n!dec$ attributes dllexport,alias:\"so_evaluate_wave_transmission\" :: evaluate_wave_transmission\n\n  integer, intent(in) :: n_time\n  real(dp), intent(in) :: heartrate\n  real(dp), intent(in) :: a0\n  integer, intent(in):: no_freq\n  real(dp), intent(in) :: a(no_freq)\n  real(dp), intent(in) :: b(no_freq)\n  integer, intent(in) :: n_adparams\n  real(dp), intent(in) :: admittance_param(n_adparams)\n  integer, intent(in) :: n_model\n  real(dp), intent(in) :: model_definition(n_model)\n  integer, intent(in) :: grav_dirn\n  integer, intent(in) :: cap_model\n\n  type(all_admit_param) :: admit_param\n  type(fluid_properties) :: fluid\n  type(elasticity_param) :: elast_param\n\n  character(len=60) :: mesh_type\n  real(dp) :: viscosity\n  real(dp) :: density\n  real(dp) :: harmonic_scale\n  real(dp) :: steady_flow\n  complex(dp), allocatable :: eff_admit(:,:)\n  complex(dp), allocatable :: char_admit(:,:)\n  complex(dp), allocatable :: reflect(:,:)\n  complex(dp), allocatable :: prop_const(:,:)\n  complex(dp), allocatable :: p_factor(:,:)\n  real(dp), allocatable :: forward_pressure(:)\n  real(dp), allocatable :: reflected_pressure(:)\n  real(dp), allocatable :: forward_flow(:)\n  real(dp), allocatable :: reflected_flow(:)\n  integer :: min_art,max_art,min_ven,max_ven,min_cap,max_cap,ne,nu,nt,nf,np\n  character(len=30) :: tree_direction,mechanics_type\n  real(dp) start_time,end_time,dt,time,omega\n  real(dp) grav_vect(3),grav_factor,mechanics_parameters(2)\n  integer :: allocatestatus,fid=10,fid2=20,fid3=30,fid4=40,fid5=50\n  character(len=60) :: sub_name\n\n  sub_name = 'evalulate_wave_transmission'\n  call enter_exit(sub_name,1)\n  !!model type and fluid properties\n  !mesh_type: can be simple_tree, full_plus_ladder, full_sheet, full_tube the first can be airways, arteries, veins but no special features at the terminal level, the last one has arteries and veins connected by capillary units of some type (lung ladder acinus, lung sheet capillary bed, capillaries are just tubes represented by an element)\n  if(model_definition(1).eq.1.0_dp)then\n    mesh_type='simple_tree'\n  elseif(model_definition(1).eq.2.0_dp)then\n    mesh_type='full_plus_ladder'\n  !elseif(model_definition(1).eq.3.0_dp)then\n  !  full_sheet\n  !elseif(model_definition(1).eq.4.0_dp)then\n  ! full_tube\n  else\n    print *, 'error: your geometry choice has not yet been implemented'\n    call exit(0)\n  endif\n  !viscosity and density of fluid\n  if(model_definition(2).eq.1.0_dp)then !blood\n    viscosity=fluid%blood_viscosity\n    density=fluid%blood_density\n  elseif(model_definition(2).eq.2.0_dp)then !air\n    viscosity=fluid%air_viscosity\n    density=fluid%air_density\n  else\n    viscosity=model_definition(3)\n    density=model_definition(4)\n  endif\n\n  !!set up admittance model\n  if(admittance_param(1).eq.1.0_dp)then\n    admit_param%admittance_type='lachase_standard'\n    elast_param%vessel_type='elastic_hooke'\n    elast_param%elasticity_parameters(1)=admittance_param(2)!pa\n    elast_param%elasticity_parameters(2)=admittance_param(3)!unitless\n    elast_param%elasticity_parameters(3)=admittance_param(4)!dummy\n  elseif(admittance_param(1).eq.2.0_dp)then\n    admit_param%admittance_type='lachase_modified'\n    elast_param%vessel_type='elastic_hooke'\n    elast_param%elasticity_parameters(1)=admittance_param(2)!pa\n    elast_param%elasticity_parameters(2)=admittance_param(3)!unitless\n    elast_param%elasticity_parameters(3)=admittance_param(4)!dummy\n  elseif(admittance_param(1).eq.3.0_dp)then\n    admit_param%admittance_type='zhu_chesler'\n    elast_param%vessel_type='elastic_hooke'\n    elast_param%elasticity_parameters(1)=admittance_param(2)!pa\n    elast_param%elasticity_parameters(2)=admittance_param(3)!unitless\n    elast_param%elasticity_parameters(3)=admittance_param(4)!dummy\n  elseif(admittance_param(1).eq.4.0_dp)then\n    admit_param%admittance_type='duan_zamir'\n    elast_param%vessel_type='elastic_alpha'\n    elast_param%elasticity_parameters(1)=admittance_param(2)!/pa\n    elast_param%elasticity_parameters(2)=admittance_param(3)!unitless\n    elast_param%elasticity_parameters(3)=admittance_param(4)!dummy\n  else\n    print *, 'error: your admittance model choice has not yet been implemented'\n    call exit(0)\n  endif\n\n  !! set up parameters defining outlet boundary conditions\n  if(admittance_param(5).eq.1.0_dp)then !note we need to check that the right number of parameters have been input\n    admit_param%bc_type='two_unit_wk'\n    admit_param%two_parameter%admit_p1=admittance_param(6)\n    admit_param%two_parameter%admit_p2=admittance_param(7)\n  elseif(admittance_param(5).eq.2.0_dp)then\n    admit_param%bc_type='three_unit_wk'\n    admit_param%three_parameter%admit_p1=admittance_param(6)\n    admit_param%three_parameter%admit_p2=admittance_param(7)\n    admit_param%three_parameter%admit_p3=admittance_param(8)\n  elseif(admittance_param(5).eq.4.0_dp)then\n    admit_param%bc_type='two_wk_plus'\n    admit_param%four_parameter%admit_p1=admittance_param(6)\n    admit_param%four_parameter%admit_p2=admittance_param(7)\n    admit_param%four_parameter%admit_p3=admittance_param(8)\n    admit_param%four_parameter%admit_p4=admittance_param(9)\n  elseif(admittance_param(5).eq.5.0_dp)then\n    admit_param%bc_type='zero_reflection'\n  else\n    print *, 'error: your boundary condition choice has not yet been implemented'\n    call exit(0)\n  endif\n\n  mechanics_type='linear'\n  if (mechanics_type.eq.'linear') then\n    mechanics_parameters(1)=5.0_dp*98.07_dp !average pleural pressure (pa)\n    mechanics_parameters(2)=0.25_dp*0.1e-2_dp !pleural density, defines gradient in pleural pressure\n  else\n    print *, 'error: only linear mechanics models have been implemented to date,assuming default parameters'\n     call exit(0)\n  endif\n\n  grav_vect=0.d0\n  if (grav_dirn.eq.1) then\n     grav_vect(1)=1.0_dp\n  elseif (grav_dirn.eq.2) then\n    grav_vect(2)=1.0_dp\n  elseif (grav_dirn.eq.3) then\n    grav_vect(3)=1.0_dp\n  else\n     print *, \"error: posture not recognised (currently only x=1,y=2,z=3))\"\n     call exit(0)\n  endif\n  grav_vect=grav_vect*grav_factor\n\n  !!determine steady component of flow\n  if(a0.eq.0.0_dp)then !using steady flow solution at inlet as a0\n    steady_flow=elem_field(ne_qdot,1)!assuming first element\n  else!otherwise input a0 is used\n    steady_flow=a0\n  endif\n  !! set up parameters defining compliance model\n  harmonic_scale=heartrate/60.0_dp !frequency of first harmonic (hz)\n  !!allocate memory\n  allocate (eff_admit(1:no_freq,num_elems), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for eff_admit array ***\"\n  allocate (char_admit(1:no_freq,num_elems), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for char_admit array ***\"\n  allocate (reflect(1:no_freq,num_elems), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for reflect array ***\"\n  allocate (prop_const(1:no_freq,num_elems), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for prop_const array ***\"\n  allocate (p_factor(1:no_freq,num_elems), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for p_factor array ***\"\n  allocate (forward_pressure(n_time), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for forward_p array ***\"\n  allocate (reflected_pressure(n_time), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for reflected_p array ***\"\n    allocate (forward_flow(n_time), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for forward_q array ***\"\n  allocate (reflected_flow(n_time), stat = allocatestatus)\n  if (allocatestatus /= 0) stop \"*** not enough memory for reflected_q array ***\"\n\n  !initialise admittance\n  char_admit=0.0_dp\n  eff_admit=0.0_dp\n  !calculate characteristic admittance of each branch\n  call characteristic_admittance(no_freq,char_admit,prop_const,harmonic_scale, &\n    density,viscosity,admit_param,elast_param,mechanics_parameters,grav_vect)\n\n  !apply boundary conditions to terminal units\n  call boundary_admittance(no_freq,eff_admit,char_admit,admit_param,harmonic_scale,&\n    density,viscosity,elast_param,mesh_type)\n\n\n    ! calculate effective admittance through the tree\n    if(mesh_type.eq.'full_plus_ladder')then\n        min_art=1\n        ne=1\n        do while(elem_field(ne_group,ne).eq.0.0_dp)\n            max_art=ne\n            ne=ne+1\n        enddo\n        min_ven=ne\n        do while(elem_field(ne_group,ne).eq.2.0_dp)\n            max_ven=ne\n            ne=ne+1\n        enddo\n        min_cap=ne\n        max_cap=num_elems\n\n        !vein admittance\n        tree_direction='converging'\n        call tree_admittance(no_freq,eff_admit,char_admit,reflect,prop_const,harmonic_scale,&\n            min_ven,max_ven,tree_direction)\n!        !cap admittance\n        call capillary_admittance(no_freq,eff_admit,char_admit,reflect,prop_const,harmonic_scale,&\n            min_cap,max_cap,elast_param,mechanics_parameters,grav_vect,cap_model)!\n        !art admittance\n        tree_direction='diverging'\n        call tree_admittance(no_freq,eff_admit,char_admit,reflect,prop_const,harmonic_scale,&\n            min_art,max_art,tree_direction)\n    else!assume simple tree\n        tree_direction='diverging'\n        min_art=1\n        max_art=num_elems\n        call tree_admittance(no_freq,eff_admit,char_admit,reflect,prop_const,harmonic_scale,&\n            min_art,max_art,tree_direction)\n    endif\n\n!\n!    !calculate pressure drop through arterial tree (note to do veins too need to implement this concept thro' whole ladder model)\n!    !also need to implement in reverse for veins\n    call pressure_factor(no_freq,p_factor,reflect,prop_const,harmonic_scale,min_art,max_art)\n    open(fid5, file = 'inputimpedance.txt',action='write')\n    write(fid5,fmt=*) 'input impedance:'\n    do nf=1,no_freq\n        omega=nf*harmonic_scale\n        write(fid5,fmt=*) omega,abs(eff_admit(nf,1)),&\n            atan2(dimag(eff_admit(nf,1)),real(eff_admit(nf,1), 8))\n    enddo\n    close(fid5)\n\n    start_time=0.0_dp\n    end_time=60.0_dp/heartrate\n    dt=(end_time-start_time)/n_time\n    time=start_time\n    !consider first pressure and flow into the vessel (at x=0)\n    open(fid, file = 'incident_pressure.txt', action='write')\n    open(fid2, file = 'incident_flow.txt',action='write')\n    open(fid3, file = 'total_pressure.txt',action='write')\n    open(fid4, file = 'total_flow.txt',action='write')\n    do nu =1,num_units\n        ne=units(nu)\n        forward_pressure=0.0_dp\n        reflected_pressure=0.0_dp\n        forward_flow=0.0_dp\n        reflected_flow=0.0_dp\n        do nt=1,n_time\n            do nf=1,no_freq\n                omega=2*pi*nf*harmonic_scale\n                forward_pressure(nt)=forward_pressure(nt)+abs(p_factor(nf,ne))*a(nf)*cos(omega*time+b(nf)+&\n                    atan2(dimag(p_factor(nf,ne)),real(p_factor(nf,ne), 8)))\n\n                reflected_pressure(nt)=reflected_pressure(nt)+abs(p_factor(nf,ne))*a(nf)*&\n                    abs(reflect(nf,ne))*exp((-2*elem_field(ne_length,ne))*(real(prop_const(nf,ne), 8)))*&\n                    cos(omega*time+b(nf)+&\n                    atan2(dimag(p_factor(nf,ne)),real(p_factor(nf,ne), 8))+&\n                    (-2*elem_field(ne_length,ne))*(dimag(prop_const(nf,ne)))+&\n                    atan2(dimag(reflect(nf,ne)),real(reflect(nf,ne), 8)))\n\n                forward_flow(nt)=forward_flow(nt)+abs(char_admit(nf,ne))*abs(p_factor(nf,ne))*a(nf)*&\n                    cos(omega*time+b(nf)+&\n                    atan2(dimag(p_factor(nf,ne)),real(p_factor(nf,ne), 8))+&\n                    atan2(dimag(char_admit(nf,ne)),real(char_admit(nf,ne), 8)))\n\n                reflected_flow(nt)=reflected_flow(nt)+abs(char_admit(nf,ne))*abs(p_factor(nf,ne))*a(nf)*&\n                    abs(reflect(nf,ne))*exp((-2*elem_field(ne_length,ne))*(real(prop_const(nf,ne), 8)))*&\n                    cos(omega*time+b(nf)+&\n                    atan2(dimag(p_factor(nf,ne)),real(p_factor(nf,ne), 8))+&\n                    (-2*elem_field(ne_length,ne))*(dimag(prop_const(nf,ne)))+&\n                    atan2(dimag(reflect(nf,ne)),real(reflect(nf,ne), 8))+&\n                    atan2(dimag(char_admit(nf,ne)),real(char_admit(nf,ne), 8)))\n\n            enddo\n            time=time+dt\n        enddo\n        np=elem_nodes(2,ne)\n        write(fid,fmt=*) ne, forward_pressure+node_field(nj_bv_press,np)\n        write(fid2,fmt=*) ne, forward_flow+elem_field(ne_qdot,ne)\n\n        write(fid3,fmt=*) ne, forward_pressure+reflected_pressure + node_field(nj_bv_press,np)\n        write(fid4,fmt=*) ne, forward_flow-reflected_flow + elem_field(ne_qdot,ne)\n\n\n    enddo\n    close(fid)\n    close(fid2)\n    close(fid3)\n    close(fid4)\n\n\n  !!deallocate memory\n  deallocate (eff_admit, stat = allocatestatus)\n  deallocate (char_admit, stat = allocatestatus)\n  deallocate (reflect, stat = allocatestatus)\n  deallocate (prop_const, stat=allocatestatus)\n  deallocate (p_factor, stat=allocatestatus)\n  deallocate (forward_pressure, stat=allocatestatus)\n  deallocate (reflected_pressure, stat=allocatestatus)\n  deallocate (forward_flow, stat=allocatestatus)\n  deallocate (reflected_flow, stat=allocatestatus)\n  call enter_exit(sub_name,2)\nend subroutine evaluate_wave_transmission\n"}
{"id": 499, "subroutine": "      subroutine copy0(a,b)\n! simple 1d copy of length nx\n! a = b\n      implicit none\n      real, dimension(:) :: a, b\n! local data\n      integer :: j, nx\n! nx = size of arrays in x\n      nx = min(size(a,1),size(b,1))\n!\n      do j = 1, nx\n         a(j) = b(j)\n      enddo\n!\n      end subroutine\n"}
{"id": 500, "subroutine": "      subroutine copy1(a,b,mx)\n! segmented 1d copy of length nx, with block size mx\n! a = b\n      implicit none\n      integer :: mx\n      real, dimension(:) :: a, b\n! local data\n      integer :: j, id, nx, nbx, joff\n! nx = size of arrays in x\n      nx = min(size(a,1),size(b,1))\n! nbx = number of blocks\n      nbx = (nx - 1)/mx + 1\n!\n      do id = 0, nbx-1\n         joff = mx*id\n         do j = 1, min(mx,nx-joff)\n            a(j+joff) = b(j+joff)\n         enddo\n      enddo\n!\n      end subroutine\n"}
{"id": 501, "subroutine": "      subroutine copy2(a,b,mx)\n! segmented 2d copy of length nx, ny, with block size mx\n! a = b\n      implicit none\n      integer :: mx\n      real, dimension(:,:) :: a, b\n! local data\n      integer :: j, k, id, nx, ny, nbx, joff\n! nx/ny = size of arrays in x/y\n      nx = min(size(a,1),size(b,1)); ny = min(size(a,2),size(b,2))\n! nbx = number of blocks in x\n      nbx = (nx - 1)/mx + 1\n!\n      do k = 1, ny\n         do id = 0, nbx-1\n            joff = mx*id\n            do j = 1, min(mx,nx-joff)\n               a(j+joff,k) = b(j+joff,k)\n            enddo\n         enddo\n      enddo\n!\n      end subroutine\n"}
{"id": 502, "subroutine": "  subroutine init_nbin\n    use ran_mod\n    nbin=88\n    itcount=0\n    do i=1,100\n       dpia13srt(i)=normal2(0.,1.)\n    enddo\n!begin  wso 8/14/13\n    ntransition = 10\n!end    wso 8/14/13\n    \n  end subroutine init_nbin\n"}
{"id": 503, "subroutine": " subroutine harmo(lmax, lon, lat, armoy)\n use shtools \n implicit none \n!integer, parameter :: llmax=512, jjmax=(llmax+1)*(llmax+2)/2  \n integer j, mj, j_index, lmax  \n complex*16 armoy(*) \n real*8 lon, lat\n real*8, allocatable :: plm(:) \n real*8 cosdd, sindd\n integer :: jmax\n!\n!\n! given longitude lon and latitude lat  - in degrees - this routine computes \n! *all* the 4-pi normalized complex harmonics $\\cal y_{lm}(\\theta,\\lambda)$, \n! with \\theta=colatitude and \\lambda=longitude, to degree lmax given. uses  \n! the (modified) shtools legendre functions by plmbar (see sbr plmbar_mod). \n! - last modified by gs 12-14-2007 - \n! - modified by dm apr 2019 -- dynamically allocate plm\n!\n!\n! ---- tests the longitude and latitude bounds \n!\n  if(abs(lat)>90.) then \n \t        write(88,*) \"error in sbr. harmo: latitude is out of range\" \n\t \twrite(88,*) \"the program will stop ----------------\"\n \t        write(* ,*) \"error in sbr. harmo: latitude is out of range\" \n\t \twrite(* ,*) \"the program will stop ----------------\"\n                call stop_config \n\t        stop 1\t\t\n  elseif (lon<0.or.lon>360.) then\n \t        write(88,*) \"error in sbr. harmo: longitude is out of range\" \n\t \twrite(88,*) \"the program will stop ----------------\"\n \t        write(* ,*) \"error in sbr. harmo: longitude is out of range\" \n\t \twrite(* ,*) \"the program will stop ----------------\"\n                call stop_config \n\t        stop 2\t\n  endif   \n!\n!\n! ---- allocate temporary arrays\n!\n   jmax=(lmax+1)*(lmax+2)/2\n   allocate( plm(jmax) )\n!  \n!\n! ---- builds the shtools legendre functions, with condon-shortley phase \n!\n    call plmbar_mod(lmax, lat, plm)  \n!\n! \n! ---- computes the 4-pi normalized spherical harmonics up to degree lmax\n!\n    do j=1, j_index(lmax,lmax)\n       \tarmoy(j) = plm(j)*cmplx(cosdd(float(mj(j))*lon),sindd(float(mj(j))*lon)) \n    enddo\n!\n!\n! ---- release memory\n!\n    deallocate( plm )\n!\nend subroutine harmo\n"}
{"id": 504, "subroutine": "      subroutine calsoft_hyd_bfr_et\n\n      use hru_module, only : cn2, hru, hru_init\n      use soil_module\n      use plant_module\n      use hydrograph_module\n      use ru_module\n      use aquifer_module\n      use channel_module\n      use hru_lte_module\n      use sd_channel_module\n      use basin_module\n      use maximum_data_module\n      use calibration_data_module\n      use conditional_module\n      use reservoir_module\n      use organic_mineral_mass_module\n      use time_module\n      \n      implicit none\n      \n      integer :: iter_all      !none      |counter\n      integer :: iterall       !none      |counter\n      integer :: isim          !          |\n      integer :: ireg          !none      |counter\n      integer :: ilum          !none      |counter\n      integer :: iihru         !none      |counter\n      integer :: icn           !none      |counter\n      integer :: ihru_s        !none      |counter\n      integer :: iter_ind      !          |end of loop\n      integer :: ietco         !none      |counter\n      integer :: ik            !none      |counter\n      integer :: nly           !          |end of loop\n      integer :: iperco        !none      |counter\n      real :: rmeas            !          |\n      real :: denom            !          |\n      real :: soft             !          |\n      real :: diff             !          |\n      real :: rto              !          |\n      real :: chg_val          !          | \n      real :: dep_below_soil   !          |  \n      real :: perc_ln_func\n\n      ! calibrate esco and pet for water yield\n        iter_ind = 1\n        \n        ! 1st esco adjustment\n        isim = 0\n        do ireg = 1, db_mx%lsu_reg\n          do ilum = 1, region(ireg)%nlum\n            soft = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa\n            diff = 0.\n            if (soft > 1.e-6) diff = abs((soft - lscal(ireg)%lum(ilum)%aa%wyr) / soft)\n            if (diff > .01 .and. lscal(ireg)%lum(ilum)%ha > 1.e-6 .and. lscal(ireg)%lum(ilum)%prm_lim%etco < 1.e-6) then\n            isim = 1\n            \n                lscal(ireg)%lum(ilum)%prm_prev = lscal(ireg)%lum(ilum)%prm\n                lscal(ireg)%lum(ilum)%prev = lscal(ireg)%lum(ilum)%aa\n\n                diff = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa - lscal(ireg)%lum(ilum)%aa%wyr\n                chg_val = - diff / 250.     ! increment etco .4 for every 100 mm difference\n                lscal(ireg)%lum(ilum)%prm_prev%etco = lscal(ireg)%lum(ilum)%prm%etco\n                lscal(ireg)%lum(ilum)%prm%etco = lscal(ireg)%lum(ilum)%prm%etco + chg_val\n                lscal(ireg)%lum(ilum)%prev%wyr = lscal(ireg)%lum(ilum)%aa%wyr\n                \n                if (lscal(ireg)%lum(ilum)%prm%etco >= ls_prms(2)%pos) then\n                  chg_val = ls_prms(2)%pos - lscal(ireg)%lum(ilum)%prm_prev%etco\n                  lscal(ireg)%lum(ilum)%prm%etco = ls_prms(2)%pos\n                  lscal(ireg)%lum(ilum)%prm_lim%etco = 1.\n                end if\n                if (lscal(ireg)%lum(ilum)%prm%etco <= ls_prms(2)%neg) then\n                  chg_val = lscal(ireg)%lum(ilum)%prm_prev%etco + ls_prms(2)%neg\n                  lscal(ireg)%lum(ilum)%prm%etco = ls_prms(2)%neg\n                  lscal(ireg)%lum(ilum)%prm_lim%etco = 1.\n                end if\n                           \n            do ihru_s = 1, region(ireg)%num_tot\n              iihru = region(ireg)%num(ihru_s)\n              if (lscal(ireg)%lum(ilum)%meas%name == hru(iihru)%lum_group_c .or. lscal(ireg)%lum(ilum)%meas%name == \"basin\") then\n                !set parms for 1st et calibration\n                hru(iihru)%hyd%esco = hru(iihru)%hyd%esco + chg_val\n                hru(iihru)%hyd%esco = amin1 (hru(iihru)%hyd%esco, ls_prms(2)%up)\n                hru(iihru)%hyd%esco = max (hru(iihru)%hyd%esco, ls_prms(2)%lo)\n                hru_init(iihru)%hyd%esco = hru(iihru)%hyd%esco\n                !hru(iihru)%hyd%epco = hru(iihru)%hyd%epco + chg_val * .5\n                !hru(iihru)%hyd%epco = amin1 (hru(iihru)%hyd%epco, ls_prms(2)%up)\n                !hru(iihru)%hyd%epco = max (hru(iihru)%hyd%epco, ls_prms(2)%lo)\n                !hru_init(iihru)%hyd%epco = hru(iihru)%hyd%epco\n              end if\n            end do\n            lscal(ireg)%lum(ilum)%nbyr = 0\n            lscal(ireg)%lum(ilum)%precip_aa = 0.\n            lscal(ireg)%lum(ilum)%aa = lscal_z\n            !zero plant calibration data in case plants are calibrated\n            !plcal(ireg)%lum(ilum)%nbyr = 0\n            !plcal(ireg)%lum(ilum)%precip_aa = 0.\n            !plcal(ireg)%lum(ilum)%ha = 0.\n            !plcal(ireg)%lum(ilum)%aa = plcal_z\n\n          end if\n          end do\n        end do\n            \n        !! re-initialize all objects\n        call re_initialize\n\n        ! 1st esco adjustment \n        if (isim > 0) then\n          cal_sim =  \" first esco adj \"\n          call time_control\n        end if\n        \n        ! adjust et using esco\n        do ietco = 1, 2     !iter_ind\n          isim = 0\n          do ireg = 1, db_mx%lsu_reg\n          do ilum = 1, region(ireg)%nlum\n            !check all hru\"s for proper lum\n            soft = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa\n            diff = 0.\n            if (soft > 1.e-6) diff = abs((soft - lscal(ireg)%lum(ilum)%aa%wyr) / soft)\n            if (diff > .01 .and. lscal(ireg)%lum(ilum)%ha > 1.e-6 .and. lscal(ireg)%lum(ilum)%prm_lim%etco < 0.99) then\n            isim = 1\n\n                rmeas = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa\n                denom = lscal(ireg)%lum(ilum)%prev%wyr - lscal(ireg)%lum(ilum)%aa%wyr\n                if (abs(denom) > 1.e-6) then\n                  chg_val = - (lscal(ireg)%lum(ilum)%prm_prev%etco - lscal(ireg)%lum(ilum)%prm%etco)                  &\n                    * (lscal(ireg)%lum(ilum)%aa%wyr - rmeas) / denom\n                else\n                  diff = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa - lscal(ireg)%lum(ilum)%aa%wyr\n                  chg_val = - diff / 200.\n                end if\n                ! lower chg_val - changing both esco and epco causes esco to go too low\n                !chg_val = chg_val * .5\n                \n                lscal(ireg)%lum(ilum)%prm_prev%etco = lscal(ireg)%lum(ilum)%prm%etco\n                lscal(ireg)%lum(ilum)%prm%etco = lscal(ireg)%lum(ilum)%prm%etco + chg_val\n                lscal(ireg)%lum(ilum)%prev%wyr = lscal(ireg)%lum(ilum)%aa%wyr\n                      \n                if (lscal(ireg)%lum(ilum)%prm%etco >= ls_prms(2)%pos) then\n                  chg_val = ls_prms(2)%pos - lscal(ireg)%lum(ilum)%prm_prev%etco\n                  lscal(ireg)%lum(ilum)%prm%etco = ls_prms(2)%pos\n                  lscal(ireg)%lum(ilum)%prm_lim%etco = 1.\n                end if\n                if (lscal(ireg)%lum(ilum)%prm%etco <= ls_prms(2)%neg) then\n                  chg_val = ls_prms(2)%neg - lscal(ireg)%lum(ilum)%prm_prev%etco\n                  lscal(ireg)%lum(ilum)%prm%etco = ls_prms(2)%neg\n                  lscal(ireg)%lum(ilum)%prm_lim%etco = 1.\n                end if\n                \n            do ihru_s = 1, region(ireg)%num_tot\n                iihru = region(ireg)%num(ihru_s)\n              if (lscal(ireg)%lum(ilum)%meas%name == hru(iihru)%lum_group_c .or. lscal(ireg)%lum(ilum)%meas%name == \"basin\") then\n                !set parms for et calibration\n                hru(iihru)%hyd%esco = hru(iihru)%hyd%esco + chg_val\n                hru(iihru)%hyd%esco = amin1 (hru(iihru)%hyd%esco, ls_prms(2)%up)\n                hru(iihru)%hyd%esco = max (hru(iihru)%hyd%esco, ls_prms(2)%lo)\n                hru_init(iihru)%hyd%esco = hru(iihru)%hyd%esco\n                !hru(iihru)%hyd%epco = hru(iihru)%hyd%epco + chg_val * .5\n                !hru(iihru)%hyd%epco = amin1 (hru(iihru)%hyd%epco, ls_prms(2)%up)\n                !hru(iihru)%hyd%epco = max (hru(iihru)%hyd%epco, ls_prms(2)%lo)\n                !hru_init(iihru)%hyd%epco = hru(iihru)%hyd%epco\n              end if\n            end do\n            lscal(ireg)%lum(ilum)%nbyr = 0\n            lscal(ireg)%lum(ilum)%precip_aa = 0.\n            lscal(ireg)%lum(ilum)%aa = lscal_z\n            !plcal(ireg)%lum(ilum)%nbyr = 0\n            !plcal(ireg)%lum(ilum)%precip_aa = 0.\n            !plcal(ireg)%lum(ilum)%ha = 0.\n            !plcal(ireg)%lum(ilum)%aa = plcal_z\n          end if\n          end do\n          end do\n\n          !! re-initialize all objects\n          call re_initialize\n\n          !! re-initialize all objects\n          call re_initialize\n\n          ! et adjustment \n          if (isim > 0) then\n            cal_sim =  \" esco adj \"\n            call time_control\n          end if\n        \n        end do      ! iesco\n                    \n        ! first calibrate potential et\n        do ietco = 1, 2     !iter_ind\n        isim = 0\n        do ireg = 1, db_mx%lsu_reg\n          do ilum = 1, region(ireg)%nlum\n              \n            soft = lscal(ireg)%lum(ilum)%meas%wyr * lscal(ireg)%lum(ilum)%precip_aa\n            diff = 0.\n            if (soft > 1.e-6) diff = abs((soft - lscal(ireg)%lum(ilum)%aa%wyr) / soft)\n            if (diff > .01 .and. lscal(ireg)%lum(ilum)%ha > 1.e-6) then\n            isim = 1\n            \n                lscal(ireg)%lum(ilum)%prm_prev = lscal(ireg)%lum(ilum)%prm\n                lscal(ireg)%lum(ilum)%prev = lscal(ireg)%lum(ilum)%aa\n\n                if (soft < lscal(ireg)%lum(ilum)%aa%wyr) then\n                  chg_val = 1. + abs((soft - lscal(ireg)%lum(ilum)%aa%wyr) / soft)\n                else\n                  chg_val = 1. - abs((lscal(ireg)%lum(ilum)%aa%wyr - soft) / lscal(ireg)%lum(ilum)%aa%wyr)\n                end if\n                lscal(ireg)%lum(ilum)%prm_prev%petco = lscal(ireg)%lum(ilum)%prm%petco\n                if (ietco == 1) then\n                  lscal(ireg)%lum(ilum)%prm%petco = chg_val\n                else\n                  lscal(ireg)%lum(ilum)%prm%petco = lscal(ireg)%lum(ilum)%prm%petco * chg_val\n                end if\n                lscal(ireg)%lum(ilum)%prm_prev%petco = lscal(ireg)%lum(ilum)%aa%wyr\n                \n                if (lscal(ireg)%lum(ilum)%prm%petco >= ls_prms(4)%pos) then\n                  chg_val = ls_prms(4)%pos\n                  lscal(ireg)%lum(ilum)%prm%petco = ls_prms(4)%pos\n                  lscal(ireg)%lum(ilum)%prm_lim%petco = 1.\n                end if\n                if (lscal(ireg)%lum(ilum)%prm%petco <= ls_prms(4)%neg) then\n                  chg_val = ls_prms(4)%neg\n                  lscal(ireg)%lum(ilum)%prm%petco = ls_prms(4)%neg\n                  lscal(ireg)%lum(ilum)%prm_lim%petco = 1.\n                end if\n\n            !check all hru\"s for proper lum\n            do ihru_s = 1, region(ireg)%num_tot\n              iihru = region(ireg)%num(ihru_s)\n              if (lscal(ireg)%lum(ilum)%meas%name == hru(iihru)%lum_group_c .or. lscal(ireg)%lum(ilum)%meas%name == \"basin\") then\n                !set parms for pet adjustment and run\n                hru(iihru)%hyd%harg_pet = chg_val * hru(iihru)%hyd%harg_pet\n                hru(iihru)%hyd%harg_pet = amin1 (hru(iihru)%hyd%harg_pet, ls_prms(4)%up)\n                hru(iihru)%hyd%harg_pet = max (hru(iihru)%hyd%harg_pet, ls_prms(4)%lo)\n                hru_init(iihru)%hyd%harg_pet = hru(iihru)%hyd%harg_pet\n              end if\n            end do\n            \n            lscal(ireg)%lum(ilum)%nbyr = 0\n            lscal(ireg)%lum(ilum)%precip_aa = 0.\n            lscal(ireg)%lum(ilum)%aa = lscal_z\n          end if\n          end do\n        end do\n        \n        !! re-initialize all objects\n        call re_initialize\n\n        ! 1st cover adjustment \n        if (isim > 0) then\n          cal_sim =  \" first pet adj \"\n          call time_control\n        end if\n\n      end do    ! petco iterations\n\n\t  return\n      end subroutine calsoft_hyd_bfr_et\n"}
{"id": 505, "subroutine": "    subroutine write_x_sensitivities_plot3d(data,ifunc,filename)\n        type(chidg_data_t),      intent(inout)  :: data\n        integer(ik),             intent(in)     :: ifunc\n        character(*),            intent(in)     :: filename\n\n        character(:),   allocatable     :: filename_grd, filename_fun, filename_nam\n        integer(ik)                     :: nblocks, iblock, ipt_x, ipt_y, ipt_z, inode, &\n                                           i, j, k, idir, ivar, ierr, n, nnodes_grid,   &\n                                           nnodes_stored\n        integer(ik),    allocatable     :: nvars(:,:), npoints(:,:)\n        logical                         :: node_count_match\n        real(rk)                        :: r, theta, z, djdr, djdtheta, djdz\n        real(rk),       allocatable     :: blk_coords(:,:,:,:), blk_sensitivities(:,:,:,:)\n        type(mr4vector_t)               :: coords, sensitivities\n        type(nvector_t),allocatable     :: node_sensitivities(:)\n\n\n        ! file names\n        filename_grd = trim(filename) // \".x\"\n        filename_fun = trim(filename) // \".q\"\n        filename_nam = trim(filename) // \".nam\"\n\n         \n        ! get overall number of blocks\n        npoints = data%mesh%npoints\n        nblocks = size(npoints,1)\n        \n\n        ! define matrix for .q file variables\n        allocate(nvars(nblocks,4),stat=ierr)\n        if (ierr/=0) call allocationerror\n        nvars(:,1:3) = npoints\n        nvars(:,4)  = 3 ! number of variables\n\n         \n        ! get sensitivities for the ifunc\n        node_sensitivities = data%sdata%adjointx%node_sensitivities(ifunc,:)\n\n\n        ! retrieve data and set it in plot3d friendly-format\n        do iblock = 1,nblocks\n\n\n            ! for sanity check, check that the number of points correspond to the original number of points in the grid\n            nnodes_stored = node_sensitivities(iblock)%size()\n            nnodes_grid   = npoints(iblock,1)*npoints(iblock,2)*npoints(iblock,3)\n            node_count_match = ( nnodes_stored == nnodes_grid )\n            if (.not. node_count_match) then\n                call chidg_signal_two(fatal,\"write_x_sensitivities: mismatch of node count in block \",iblock,\".\")\n            end if\n           \n\n            ! re/allocate matrices based on block dimensions\n            if (allocated(blk_coords))        deallocate(blk_coords)\n            if (allocated(blk_sensitivities)) deallocate(blk_sensitivities)\n            allocate(blk_coords(npoints(iblock,1),npoints(iblock,2),npoints(iblock,3),3), stat=ierr)\n            if (ierr/=0) call allocationerror\n            allocate(blk_sensitivities(npoints(iblock,1),npoints(iblock,2),npoints(iblock,3),3), stat=ierr)\n            if (ierr/=0) call allocationerror\n\n            \n            ! reset node count\n            inode = 1\n\n\n            do ipt_z = 1,npoints(iblock,3)\n                do ipt_y = 1,npoints(iblock,2)\n                    do ipt_x = 1,npoints(iblock,1)\n                        \n                        ! simply get sensitivities and coords since they are already in cartesian coordinates\n                        if ( node_sensitivities(iblock)%data(inode)%coordinate_system == cartesian ) then\n                            blk_coords(ipt_x,ipt_y,ipt_z,1)        = node_sensitivities(iblock)%data(inode)%coords(1)\n                            blk_coords(ipt_x,ipt_y,ipt_z,2)        = node_sensitivities(iblock)%data(inode)%coords(2)\n                            blk_coords(ipt_x,ipt_y,ipt_z,3)        = node_sensitivities(iblock)%data(inode)%coords(3)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,1) = node_sensitivities(iblock)%data(inode)%sensitivities(1)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,2) = node_sensitivities(iblock)%data(inode)%sensitivities(2)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,3) = node_sensitivities(iblock)%data(inode)%sensitivities(3)\n                        end if\n\n                        ! tranform cylindrical coordinates back to cartesian and rotate sensitivity vector\n                        if ( node_sensitivities(iblock)%data(inode)%coordinate_system == cylindrical ) then\n                            r     = node_sensitivities(iblock)%data(inode)%coords(1)\n                            theta = node_sensitivities(iblock)%data(inode)%coords(2)\n                            z     = node_sensitivities(iblock)%data(inode)%coords(3)\n                            blk_coords(ipt_x,ipt_y,ipt_z,1) = r*cos(theta) \n                            blk_coords(ipt_x,ipt_y,ipt_z,2) = r*sin(theta)\n                            blk_coords(ipt_x,ipt_y,ipt_z,3) = z\n                            djdr     = node_sensitivities(iblock)%data(inode)%sensitivities(1)\n                            djdtheta = node_sensitivities(iblock)%data(inode)%sensitivities(2)\n                            djdz     = node_sensitivities(iblock)%data(inode)%sensitivities(3)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,1) = djdr*cos(theta) - djdtheta*sin(theta)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,2) = djdr*sin(theta) + djdtheta*cos(theta)\n                            blk_sensitivities(ipt_x,ipt_y,ipt_z,3) = djdz\n                        end if\n                        \n                        inode = inode + 1\n\n                    end do !ipt_x\n\n                end do !ipt_y\n\n            end do !ipt_z\n            \n            ! push-back matrix for iblock\n            call coords%push_back(blk_coords)\n            call sensitivities%push_back(blk_sensitivities)\n\n\n        end do !iblock\n\n\n        ! write grid file .x\n        open(unit=7, file=trim(filename_grd), form='unformatted')\n        write(7) nblocks\n        write(7) (( npoints(iblock,idir), idir=1,3), iblock=1,nblocks)\n        do iblock = 1,nblocks\n            write(7) (((( coords%data(iblock)%mat(i,j,k,n), i=1,npoints(iblock,1)), j=1,npoints(iblock,2)), k=1,npoints(iblock,3)), n=1,3)\n        end do\n        close(7)\n\n\n        ! write function file .q\n        open(unit=8, file=trim(filename_fun), form='unformatted')\n        write(8) nblocks\n        write(8) (( nvars(iblock,ivar), ivar=1,4), iblock=1,nblocks)\n        do iblock = 1,nblocks\n            write(8) (((( sensitivities%data(iblock)%mat(i,j,k,n), i=1,npoints(iblock,1)), j=1,npoints(iblock,2)), k=1,npoints(iblock,3)), n=1,3)\n        end do\n        close(8)\n\n\n        ! write name file .nam\n        open(unit=9, file=trim(filename_nam) )\n        write(9,'(a)') \"dj/dx\" \n        write(9,'(a)') \"dj/dy\" \n        write(9,'(a)') \"dj/dz\" \n        close(9)\n\n    end subroutine write_x_sensitivities_plot3d\n"}
{"id": 506, "subroutine": "      subroutine pho_harini(ip,idp1,idp2,pv1,pv2,nout,mode)\nc**********************************************************************\nc\nc     initialize calculation of hard cross section\nc\nc     must not be called during mc generation\nc\nc***********************************************************************\n      implicit none\n      double precision deps , dummy , pv1 , pv2\n      integer idp1 , idp2 , ip , mode , nout\n      save \n \n      parameter (deps=1.d-10)\n \nc  input/output channels\n      include 'inc/poinou'\nc  event debugging information\n      include 'inc/podebg'\nc  model switches and parameters\n      include 'inc/pomdls'\nc  currently activated parton density parametrizations\n      include 'inc/poppdf'\nc  some constants\n      include 'inc/pocons'\nc  scale parameters for parton model calculations\n      include 'inc/pohscl'\nc  data of c.m. system of pomeron / reggeon exchange\n      include 'inc/popcms'\nc  obsolete cut-off information\n      include 'inc/pocut1'\nc  hard scattering parameters used for most recent hard interaction\n      include 'inc/pohapa'\n \n      double precision pho_alphas\n \n      character*20 rflag\n \nc  set local pomeron c.m. system data\n      idpdg1 = idp1\n      idpdg2 = idp2\n      pvirtp(1) = pv1\n      pvirtp(2) = pv2\nc  initialize pdfs\n      call pho_actpdf(idpdg1,1)\n      call pho_actpdf(idpdg2,2)\nc  initialize alpha_s calculation\n      dummy = pho_alphas(0.d0,-4)\nc  initialize scales with defaults\n      if ( (idpdg1.eq.22) .or. (idpdg1.eq.990) ) then\n         if ( (idpdg2.eq.22) .or. (idpdg2.eq.990) ) then\n            aqqal = parmdl(83)\n            aqqali = parmdl(86)\n            aqqalf = parmdl(89)\n            aqqpd = parmdl(92)\n            nqqal = ipamdl(83)\n            nqqali = ipamdl(86)\n            nqqalf = ipamdl(89)\n            nqqpd = ipamdl(92)\n         else\n            aqqal = parmdl(82)\n            aqqali = parmdl(85)\n            aqqalf = parmdl(88)\n            aqqpd = parmdl(91)\n            nqqal = ipamdl(82)\n            nqqali = ipamdl(85)\n            nqqalf = ipamdl(88)\n            nqqpd = ipamdl(91)\n         end if\n      else if ( (idpdg2.eq.22) .or. (idpdg2.eq.990) ) then\n         aqqal = parmdl(82)\n         aqqali = parmdl(85)\n         aqqalf = parmdl(88)\n         aqqpd = parmdl(91)\n         nqqal = ipamdl(82)\n         nqqali = ipamdl(85)\n         nqqalf = ipamdl(88)\n         nqqpd = ipamdl(91)\n      else\n         aqqal = parmdl(81)\n         aqqali = parmdl(84)\n         aqqalf = parmdl(87)\n         aqqpd = parmdl(90)\n         nqqal = ipamdl(81)\n         nqqali = ipamdl(84)\n         nqqalf = ipamdl(87)\n         nqqpd = ipamdl(90)\n      end if\n      if ( parmdl(109+ip).lt.deps ) parmdl(109+ip) = aqqal\n      if ( parmdl(113+ip).lt.deps ) parmdl(113+ip) = aqqali\n      if ( parmdl(117+ip).lt.deps ) parmdl(117+ip) = aqqalf\n      if ( parmdl(121+ip).lt.deps ) parmdl(121+ip) = aqqpd\n      if ( ipamdl(64+ip).lt.0 ) ipamdl(64+ip) = nqqal\n      if ( ipamdl(68+ip).lt.0 ) ipamdl(68+ip) = nqqali\n      if ( ipamdl(72+ip).lt.0 ) ipamdl(72+ip) = nqqalf\n      if ( ipamdl(76+ip).lt.0 ) ipamdl(76+ip) = nqqpd\n      aqqal = parmdl(109+ip)\n      aqqali = parmdl(113+ip)\n      aqqalf = parmdl(117+ip)\n      aqqpd = parmdl(121+ip)\n      nqqal = ipamdl(64+ip)\n      nqqali = ipamdl(68+ip)\n      nqqalf = ipamdl(72+ip)\n      nqqpd = ipamdl(76+ip)\n      ptcut(1) = parmdl(36)\n      ptcut(2) = parmdl(37)\n      ptcut(3) = parmdl(38)\n      ptcut(4) = parmdl(39)\n      ptano(1) = parmdl(130)\n      ptano(2) = parmdl(131)\n      ptano(3) = parmdl(132)\n      ptano(4) = parmdl(133)\n      rflag = '(energy-independent)'\n      if ( ipamdl(7).gt.0 ) rflag = '(energy-dependent)'\n \nc  write out all settings\n      if ( (ideb(66).ge.15) .or. (mode.gt.0) ) then\n         if ( lpri.gt.4 ) write (lo,99010) ip , idpdg1 , idpdg2 , \n     &        ptcut(ip) , rflag , pdfnam(1) , igrp(1) , iset(1) , \n     &        iext(1) , pdfnam(2) , igrp(2) , iset(2) , iext(2) , \n     &        pdflam , nf , nqqal , aqqal , nqqpd , aqqpd\n99010    format (/,' pho_harini: hard scattering parameters for ip:',\n     &           i3/,5x,'particle 1 / particle 2:',2i8,/,5x,\n     &           'min. pt   :',f7.1,2x,a,/,5x,'pdf side 1:',2x,a8,\n     &           ' igrp/iset/iext ',3i4,/,5x,'pdf side 2:',2x,a8,\n     &           ' igrp/iset/iext ',3i4,/,5x,\n     &           'lambda1,2 (4 active flavours):',2f8.3,/,5x,\n     &           'max. number of active flavours nf  :',i3,/,5x,\n     &           'nqqal/aqqal/nqqpd/aqqpd:',i5,f8.3,i5,f8.3)\n      end if\n \n      end subroutine\n"}
{"id": 507, "subroutine": "\tsubroutine simulation0(tot_time_r)\t!tot_time_r = time in seconds\n\tuse variables\n\tuse parameters\n\timplicit none\n\tinteger \t\t::\tt,tt,tot_time\n\treal*8\t\t\t::\ttot_time_r\n\ttot_time = int(tot_time_r)\t\t!total simulation time\n!================================ main loop ===============================================!\n\tdo tt = 1,tot_time\n\t!---------------------------loop over one second of neuronal time--------------------------!\n\t\tdo t = 1,one_sec\n\t\t\ttr = tr + dt\t\t!from interation to neuronal time\n\t\t\tcall input_g(t)\t\t!inhomogeneous input onto postsynaptic neuron\n\t\t\tcall lif()\t\t!leaky integrate-and-fire neuron\n\t\tend do\n\t!------------------------------------------------------------------------------------------!\n\tend do\n!==========================================================================================!\n\tend subroutine\n"}
{"id": 508, "subroutine": "\tsubroutine simulation(tot_time_r)\t!tot_time_r = time in seconds\n\tuse variables\n\tuse parameters\n\timplicit none\n\tinteger \t\t::\tt,tt,tot_time\n\treal*8\t\t\t::\ttot_time_r\n\ttot_time = int(tot_time_r)\t\t!total simulation time\n!================================ main loop ===============================================!\n\tdo tt = 1,tot_time\n\t!---------------------------loop over one second of neuronal time--------------------------!\n\t\tdo t = 1,one_sec\n\t\t\ttr = tr + dt\t\t!from interation to neuronal time\n\t\t\tcall input_g(t)\t\t!inhomogeneous input onto postsynaptic neuron\n\t\t\tcall lif()\t\t!leaky integrate-and-fire neuron\n\t\t\tcall currents()\t\t!calculation of excitatory and inhibitory currents\n\t\t!----------------------------- output data for plots --------------------------------------!\n\t\t\tif(spk_post) write(1,*)tr,-25.0d0\t\t\t\t\t!postsynaptic spike\n\t\t\twrite(1,*)tr,x(1)\t\t\t\t\t\t\t!postsynaptic memb potential\n\t\t\twrite(2,\"(5f20.5)\")tr,sum(curr_e),sum(curr_i1),sum(curr_i2),curr_leak\t!currents\n\t\t\twrite(3,\"(17f20.5)\")tr,activity/200.0d0\t\t\t\t\t!input rate\n\t\t!------------------------------------------------------------------------------------------!\n\t\tend do\n\t!------------------------------------------------------------------------------------------!\n\tend do\n!==========================================================================================!\n\tend subroutine\n"}
{"id": 509, "subroutine": "\tsubroutine currents()\n\tuse variables\n\tuse parameters\n\timplicit none\n\tinteger\t\t::\tpw,j0,jf\n\treal*8\t\t::\ttmp\n!---------------------------- loop over input signals -------------------------------------!\n\tdo pw = 1,n_pw\n\t!------------------------- excitatory neurons ---------------------------------------------!\n\t\tj0 = ((pw-1)*ne_pw) + 1\t\t\t\t!vector starting point\n\t\tjf = pw*ne_pw\t\t\t\t\t!vector ending point\n\t\ttmp = sum(spkr(j0:jf)*msynw(j0:jf))\t\t!excitatory spikes from input signal pw\n\t\tcond_e(pw) = cond_e(pw)*pr(35) + tmp\t\t!total excitatory conductance due to signal pw\n\t\tcurr_e(pw) = cond_e(pw)*x(1)\t\t\t!total excitatory current due to signal pw\n\t!------------------------------------------------------------------------------------------!\n\t!--------------------- inhibitory neurons - pop 1 -----------------------------------------!\n\t\tj0 = ((pw-1)*ni_pw1) + ne + 1\t\t\t!vector starting point\n\t\tjf = pw*ni_pw1 + ne\t\t\t\t!vector ending point\n\t\ttmp = sum(spkr(j0:jf)*msynw(j0:jf))\t\t!inhibitory spikes from input signal pw pop 1\n\t\tcond_i1(pw) = cond_i1(pw)*pr(36) + tmp\t\t!total inhibitory conductance due to signal pw pop 1\n\t\tcurr_i1(pw) = - cond_i1(pw)*(pr(32)-x(1))\t!total inhibitory current due to signal pw pop 1\n\t!------------------------------------------------------------------------------------------!\n\t!--------------------- inhibitory neurons - pop 2 -----------------------------------------!\n\t\tj0 = ((pw-1)*ni_pw2) + ne + ni1 + 1\t\t!vector starting point\n\t\tjf = pw*ni_pw2 + ne + ni1\t\t\t!vector ending point\n\t\ttmp = sum(spkr(j0:jf)*msynw(j0:jf))\t\t!inhibitory spikes from input signal pw pop 2\n\t\tcond_i2(pw) = cond_i2(pw)*pr(36) + tmp\t\t!total inhibitory conductance due to signal pw pop 2\n\t\tcurr_i2(pw) = - cond_i2(pw)*(pr(32)-x(1))\t!total inhibitory current due to signal pw pop 2\n\t!------------------------------------------------------------------------------------------!\n\tend do\n!------------------------------------------------------------------------------------------!\n\tcurr_leak = x(1) - pr(2)\t\t\t\t!leak current\n\tend subroutine\n"}
{"id": 510, "subroutine": "    subroutine normalize(f)\n        complex(kind(0d0)),intent(inout) :: f(1:nl)\n        f = f / sqrt( integrate( abs(f)**2 ) )\n        f = f * sqrt( dble( particlen ) )\n    end subroutine normalize\n"}
{"id": 511, "subroutine": "    subroutine evolve(phi, pot, omega_z, isimag)\n        complex(kind(0d0)),intent(inout)     :: phi(1:nl)\n        double precision,intent(in)          :: pot(1:nl)\n        double precision,intent(in)          :: omega_z(1:nz)\n        logical,intent(in)                   :: isimag\n        integer                              :: iter\n        double precision                     :: mu\n        integer,parameter                    :: nexp = 15\n        \n        ! save old wave function temporarily\n        old_phi = phi\n\n        if (isimag) then\n            ! imaginary time evolution ------------------------------------------------------\n            ! first term of taylor expansion\n            ztemp = old_phi\n            phi   = old_phi\n            ! other terms of taylor expansion\n            do iter = 1, 1\n                call h(ztemp, density, pot, omega_z)\n                ztemp = - hphi * dt_imag / iter\n                phi   = phi + ztemp\n            end do\n            call normalize(phi)\n        else\n            ! real time evolution -----------------------------------------------------------\n            mu = calc_mu(old_phi, pot, omega_z)\n            \n            ! pc = predictor-corrector\n            if ( is_pc_enabled ) then\n                ! first term of taylor expansion\n                ztemp = old_phi\n                phi = old_phi\n                ! other terms of taylor expansion\n                do iter = 1, nexp\n                    call h(ztemp, abs(old_phi)**2, pot, omega_z)\n                    ztemp2 = hphi - mu * ztemp\n                    ztemp  = ( 1d0 / ( iu - gamma ) ) * ztemp2 * dt_real * 0.5 / iter\n                    phi    = phi + ztemp\n                end do\n                density = abs(phi)**2\n            else\n                density = abs(old_phi)**2\n            end if\n\n            ! first term of taylor expansion\n            ztemp = old_phi\n            phi   = old_phi\n            ! other terms of taylor expansion\n            do iter = 1, nexp\n                call h(ztemp, density, pot, omega_z)\n                ztemp2 = hphi - mu * ztemp\n                ztemp  = ( 1d0 / ( iu - gamma ) ) * ztemp2 * dt_real / iter\n                phi    = phi + ztemp\n            end do\n        end if\n    end subroutine evolve\n"}
{"id": 512, "subroutine": "    subroutine h(phi, density_, pot, omega_z)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        double precision,intent(in)    :: pot(1:nl)\n        double precision,intent(in)    :: density_(1:nl)\n        double precision,intent(in)    :: omega_z(1:nz)\n        complex(kind(0d0))             :: temp(1:nl)\n        integer                        :: i\n        hphi = 0d0\n        temp = transform_fftw(phi)\n\n        call laplacian_fftw(temp)\n        hphi = hphi - 0.5d0 * zlap\n        \n        hphi = hphi + pot * phi\n\n        call gradient_fftw(temp)\n        call lzphi(phi, zgrad)\n        i = 1\n        do iz = 1, nz\n            do iy = 1, ny\n                do ix = 1, nx\n                    hphi(i) = hphi(i) - omega_z(iz) * zlzphi(i)\n                    i = i + 1\n                end do\n            end do\n        end do\n\n        hphi = hphi + density_ * phi\n    end subroutine\n"}
{"id": 513, "subroutine": "    subroutine prepare_derivative()\n        call prepare_fdm\n        if ( defmode == defmode_fft ) then\n            call new_fftw\n        end if\n    end subroutine\n"}
{"id": 514, "subroutine": "    subroutine prepare_mpi()\n        integer iret, nthreads_omp, nthreads_fftw\n\n        ! fftw threads ###############\n        nthreads_fftw = 3\n        call dfftw_init_threads(iret)\n        call dfftw_plan_with_nthreads(nthreads_fftw)\n        ! openmp ####################\n        nthreads_omp  = nthreads_fftw\n        if ( nthreads_omp > 1 ) then\n            !$ call omp_set_num_threads(nthreads_omp)\n            !$ write (*, *) \"openmp is successfully initiated.\"\n        else\n            !$ call omp_set_num_threads(1)\n        end if\n        ! ############################\n        if ( mpi_rank == 0 ) then\n            write (*, '(1x,3(a, i0))') \"fftw_threads = \", nthreads_fftw, \", omp_threads = \", nthreads_omp, \", fftw_code = \", iret\n        end if\n        ! mpi ########################\n        !call mpi_init(mpi_ierr)\n        !call fftw_mpi_init\n        !call mpi_comm_size(mpi_comm_world, mpi_num_procs, mpi_ierr)\n        !call mpi_comm_rank(mpi_comm_world, mpi_rank, mpi_ierr)\n        ! ############################\n    end subroutine\n"}
{"id": 515, "subroutine": "    subroutine prepare_fdm()\n        integer :: i\n        allocate( c1(-nd:nd), c2(-nd:nd) )\n        c1 = 0d0\n        c2 = 0d0\n        ! 1st derivative\n        do i = 1, nd\n            if ( i == 1 ) then\n                c1(1) = nd / ( nd + 1d0 )\n            else\n                c1(i) = -c1(i-1) * ( i - 1 ) * ( nd - i + 1d0 ) / ( i * ( nd + i ) )\n            end if\n            c1(-i) = -c1(i)\n        end do\n        c1 = c1 / dh\n      \n        ! 2nd derivative\n        do i = 1, nd\n          if ( i == 1 ) then\n            c2(1) = 2d0 * nd / ( nd + 1d0 )\n          else\n            c2(i) = -c2(i-1) * ( i - 1d0 )**2 * ( nd - i + 1d0 ) / ( i**2 * ( nd + i ) )\n          end if\n          c2(-i) = c2(i)\n          c2(0) = c2(0) + c2(i)\n        end do\n        c2(0) = -2d0 * c2(0)\n        c2 = c2 / ( dh * dh )\n    end subroutine\n"}
{"id": 516, "subroutine": "    subroutine laplacian_zero(f)\n        complex(kind(0d0)),intent(in) :: f(1:nl)\n        integer                       :: ix, iy, iz, i, id, ip\n        zlap = (0d0, 0d0)\n\n        do i = 1, nl\n            ix = i2ix(i); iy = i2iy(i); iz = i2iz(i);\n            do id = -nd, nd\n                if ( 1 <= ix + id .and. ix + id <= nx ) then\n                    ip = ixyz2i(ix + id, iy, iz)\n                    zlap(i) = zlap(i) + f(ip) * c2(id)\n                end if\n            end do\n\n            if ( ny > 1 ) then\n                ix = i2ix(i); iy = i2iy(i); iz = i2iz(i);\n                do id = -nd, nd\n                    if ( 1 <= iy + id .and. iy + id <= ny ) then\n                        ip = ixyz2i(ix, iy + id, iz)\n                        zlap(i) = zlap(i) + f(ip) * c2(id)\n                    end if\n                end do\n            end if\n\n            if ( nz > 1 ) then\n                ix = i2ix(i); iy = i2iy(i); iz = i2iz(i);\n                do id = -nd, nd\n                    if ( 1 <= iz + id .and. iz + id <= nz ) then\n                        ip = ixyz2i(ix, iy, iz + id)\n                        zlap(i) = zlap(i) + f(ip) * c2(id)\n                    end if\n                end do\n            end if\n        end do\n    end subroutine\n"}
{"id": 517, "subroutine": "    subroutine laplacian(f)\n        complex(kind(0d0)),intent(in) :: f(1:nl)\n        double precision              :: t2, t1\n        complex(kind(0d0))            :: temp(1:nl)\n\n        select case ( defmode )\n        case ( defmode_fdm_periodic )\n            call laplacian_periodic(f)\n        case ( defmode_fdm_zero )\n            call laplacian_zero(f)\n        case ( defmode_fft )\n            temp = transform_fftw(f)\n            call laplacian_fftw( temp )\n        end select\n    end subroutine\n"}
{"id": 518, "subroutine": "    subroutine gradient(f)\n        complex(kind(0d0)),intent(in) :: f(1:nl)\n        complex(kind(0d0))            :: temp(1:nl)\n        if ( defmode == defmode_fft ) then\n            temp = transform_fftw( f )\n            call gradient_fftw( temp )\n        else\n            call df_dx_complex(f)\n            call df_dy_complex(f)\n            call df_dz_complex(f)\n        end if\n    end subroutine gradient\n"}
{"id": 519, "subroutine": "    subroutine abs2gradient(f)\n        complex(kind(0d0)),intent(in) :: f(1:nl)\n        call gradient(f)\n        zabs2gradient = abs( zgrad(:, 1) )**2\n        if ( ny > 1 ) then\n            zabs2gradient = zabs2gradient + abs( zgrad(:, 2) )**2\n        end if\n        if ( nz > 1 ) then\n            zabs2gradient = zabs2gradient + abs( zgrad(:, 3) )**2\n        end if\n    end subroutine abs2gradient\n"}
{"id": 520, "subroutine": "    subroutine make_vortex(phi, m, x0, y0)\n        complex(kind(0d0)),intent(inout)       :: phi(1:nl)\n        integer,           intent(in)          :: m\n        integer                                :: i, ix, iy\n        double precision                       :: x, y\n        double precision,intent(in)            :: x0, y0\n\n        do i = 1, nl\n            ix = i2ix(i); iy = i2iy(i)\n            x = xpos(ix); y = ypos(iy)\n            if ( nl / dble(nx) > 1 ) then\n                phi(i) = phi(i) * exp(iu * m * phase(y-y0, x-x0))\n            else\n                if ( x < 0 ) then\n                    phi(i) = phi(i)\n                else\n                    phi(i) = phi(i) * exp(iu * pi)\n                end if\n            end if\n        end do\n    end subroutine\n"}
{"id": 521, "subroutine": "    subroutine lzphi(phi, grad)\n        complex(kind(0d0)),intent(in)  :: phi(1:nl)\n        complex(kind(0d0)),intent(in)  :: grad(1:nl,1:3)\n        integer                        :: i, ix, iy\n        double precision               :: x, y\n        do i = 1, nl\n            ix = i2ix(i); iy = i2iy(i)\n            x = xpos(ix); y = ypos(iy)\n            zlzphi(i) = -iu * ( x * grad(i, 2) - y * grad(i, 1) )\n        end do\n    end subroutine lzphi\n"}
{"id": 522, "subroutine": "    subroutine gradient_fftw(g)\n        complex(kind(0d0)),intent(in) :: g(1:nl)\n        complex(kind(0d0))            :: temp1(1:nl), temp2(1:nl), temp3(1:nl)\n        integer                       :: i, j\n \n        if (nx > 1) then\n            temp1(:) = g(:) * k(:, 1)\n            zgrad(:, 1) = iu * revert_fftw( temp1 )\n        else \n            zgrad(:, 1) = (0d0, 0d0)\n        end if\n\n        if (ny > 1) then\n            temp2(:) = g(:) * k(:, 2)\n            zgrad(:, 2) = iu * revert_fftw( temp2 )\n        else\n            zgrad(:, 2) = (0d0, 0d0)\n        end if\n\n        if (nz > 1) then\n            temp3(:) = g(:) * k(:, 3)\n            zgrad(:, 3) = iu * revert_fftw( temp3 )\n        else\n            zgrad(:, 3) = (0d0, 0d0)\n        end if\n    end subroutine\n"}
{"id": 523, "subroutine": "    subroutine laplacian_fftw(f)\n        complex(kind(0d0)),intent(in) :: f(1:nl)\n        complex(kind(0d0))            :: temp(1:nl)\n        temp = f * k2\n        zlap = -1d0 * revert_fftw( temp )\n    end subroutine\n"}
{"id": 524, "subroutine": "    subroutine new_fftw()\n        double precision    :: kx(1:nx), ky(1:ny), kz(1:nz)\n        integer             :: ix, iy, iz, i\n        ! this way saves calculation time 1.43x times faster\n        pfx = fftw_alloc_complex(int(nl, c_size_t))\n        pfk = fftw_alloc_complex(int(nl, c_size_t))\n        pgx = fftw_alloc_complex(int(nl, c_size_t))\n        pgk = fftw_alloc_complex(int(nl, c_size_t))\n        call c_f_pointer( pfx, fx, [nl] )\n        call c_f_pointer( pfk, fk, [nl] )\n        call c_f_pointer( pgx, gx, [nl] )\n        call c_f_pointer( pgk, gk, [nl] )\n        select case ( dim )\n        case (1)\n            call dfftw_plan_dft_1d(plan_f, nx, fx, fk, fftw_forward, fftw_measure)\n            call dfftw_plan_dft_1d(plan_b, nx, fk, fx, fftw_backward, fftw_measure)\n        case (2)\n            call dfftw_plan_dft_2d(plan_f, nx, ny, fx, fk, fftw_forward, fftw_measure)\n            call dfftw_plan_dft_2d(plan_b, nx, ny, fk, fx, fftw_backward, fftw_measure)\n        case (3)\n            call dfftw_plan_dft_3d(plan_f, nx, ny, nz, fx, fk, fftw_forward, fftw_measure)\n            call dfftw_plan_dft_3d(plan_b, nx, ny, nz, fk, fx, fftw_backward, fftw_measure)\n        case default\n            stop \"dim is not specified\"\n        end select\n        allocate( k(1:nl, 3), k2(1:nl) )\n        kx = create_wavenumber(nx)\n        ky = create_wavenumber(ny)\n        kz = create_wavenumber(nz)\n        i = 1\n        do iz = 1, nz\n            do iy = 1, ny\n                do ix = 1, nx\n                    k(i, 1) = kx(ix)\n                    k(i, 2) = ky(iy)\n                    k(i, 3) = kz(iz)\n                    k2(i)   = kx(ix)**2 + ky(iy)**2 + kz(iz)**2\n                    i = i + 1\n                end do\n            end do\n        end do\n    end subroutine\n"}
{"id": 525, "subroutine": "    subroutine destroy_fftw()\n        call dfftw_destroy_plan( plan_f )\n        call dfftw_destroy_plan( plan_b )\n        call fftw_free( pfx )\n        call fftw_free( pfk )\n    end subroutine\n"}
{"id": 526, "subroutine": "  subroutine snow_diel(frequency,ep_real,ep_imag,rad,frac,ep_eff)\n\n    real(fp) :: ep_imag,ep_real\n    real(fp) :: frequency,rad,frac,k0,yr,yi\n    complex(fp) :: y,ep_r,ep_i,ep_eff,fracy\n\n    k0 = twopi/(300.0_fp/frequency)\n\n    yr = (ep_real - one)/(ep_real + two)\n    yi = ep_imag/(ep_real + two)\n\n    y = cmplx(yr, yi, fp)\n    fracy=frac*y\n\n    ep_r = (one + two*fracy)/(one - fracy)\n    ep_i = two*fracy*y*(k0*rad)**3*(one-frac)**4/((one-fracy)**2*(one+two*frac)**2)\n    ep_eff = ep_r - cmplx(zero,one,fp)*ep_i\n\n    if (aimag(ep_eff) >= zero) ep_eff = cmplx(real(ep_eff), -0.0001_fp, fp)\n\n  end subroutine snow_diel\n"}
{"id": 527, "subroutine": "  subroutine snow_optic(frequency,a,h,f,ep_real,ep_imag,gv,gh, ssalb_v,ssalb_h,tau_v,tau_h)\n\n    real(fp) :: yr,yi,ep_real,ep_imag\n    real(fp) :: frequency,a,h,f,ssalb_v,ssalb_h,tau_v,tau_h,gv,gh,k\n    real(fp) :: ks1,ks2,ks3,ks,kr1,kr2,kr3,kr,ki1,ki2,ki3,ki\n    real(fp) :: fact1,fact2,fact3,fact4,fact5\n\n    k = twopi/(300._fp/frequency)\n\n    yr = (ep_real - one)/(ep_real + two)\n    yi = -ep_imag/(ep_real + two)\n\n    fact1 = (one+two*f)**2\n    fact2 = one-f*yr\n    fact3 = (one-f)**4\n    fact4 = f*(k*a)**3\n    fact5 = one+two*f*yr\n\n    ks1 = k*sqrt(fact2/fact5)\n    ks2 = fact4*fact3/fact1\n    ks3 = (yr/fact2)**2\n    ks = ks1*ks2*ks3\n\n    kr1 = fact5/fact2\n    kr2 = two*ks2\n    kr3 = two*yi*yr/(fact2**3)\n    kr = k*sqrt(kr1+kr2*kr3)\n\n    ki1 = 3.0_fp*f*yi/fact2**2\n    ki2 = kr2\n    ki3 = ks3\n    ki  = k**2/(two*kr)*(ki1+ki2*ki3)\n\n    gv = 0.5_fp\n    gh = 0.5_fp\n\n    ssalb_v = min(ks/ki, 0.999_fp)\n    ssalb_h = ssalb_v\n    tau_v = two*ki*h\n    tau_h = tau_v\n\n  end subroutine snow_optic\n"}
{"id": 528, "subroutine": "      subroutine lodcsl_zero (next_block)\n      logical, intent(out)  :: next_block\n      end subroutine\n"}
{"id": 529, "subroutine": "        subroutine eval_overlap(n1,n2,c1,c2,e1,e2,r1,r2,l1,l2,val)\n          implicit none\n          integer,intent(in)::n1,n2,l1(3),l2(3)\n          real(8),intent(in)::c1(n1),c2(n2),e1(n1),e2(n2),r1(3),r2(3)\n          real(8),intent(out)::val\n          integer::i,j\n          real(8)::vt\n          val=0d0\n          do i=1,n1\n            do j=1,n2\n              call overlap_pg_(e1(i),e2(j),r1,r2,l1,l2,vt)\n              vt=vt*pgn_(l1,e1(i))*pgn_(l2,e2(j))\n              vt=vt*c1(i)*c2(j)\n              val=val+vt\n            end do\n          end do\n        end subroutine\n"}
{"id": 530, "subroutine": "        subroutine overlap_pg_(e1i,e2i,r1,r2,l1,l2,val)\n          implicit none\n          real(8),intent(in)::e1i,e2i,r1(3),r2(3)\n          real(8),intent(out)::val\n          integer,intent(in)::l1(3),l2(3)\n          integer::ix,nn,i\n          real(8)::gm,rp(3),pa,pb,vt,w,vf\n          gm=e1i+e2i\n          rp(:)=(e1i*r1(:)+e2i*r2(:))/gm\n          val=(pi/gm)**1.5\n          val=val*exp(-e1i*e2i*sum((r1-r2)**2)/gm)\n          do ix=1,3\n            pa=rp(ix)-r1(ix)\n            pb=rp(ix)-r2(ix)\n            nn=floor((l1(ix)+l2(ix))/2d0)\n            vt=0d0\n            do i=0,nn\n              w=nfact2_(i)/((2d0*gm)**i)\n              call fcoef_(2*i,l1(ix),l2(ix),pa,pb,vf)\n              w=w*vf\n              vt=vt+w\n            end do\n            val=val*vt\n          end do\n        end subroutine\n"}
{"id": 531, "subroutine": "        subroutine fcoef_(i,m,l,a,b,val)\n          implicit none\n          integer,intent(in)::i,m,l\n          real(8),intent(in)::a,b\n          real(8),intent(out)::val\n          integer::j,k\n          if (i>6) then\n            write(*,'(\"error: out of range: fcoef_()\")')\n            stop 1\n          end if\n          val=0d0\n          do j=0,i\n            k=i-j\n            if (m>=j.and.l>=k) then\n              val=val+nbin_(m,j)*a**(m-j)*nbin_(l,k)*b**(l-k)\n            end if\n          end do\n        end subroutine\n"}
{"id": 532, "subroutine": "        subroutine kinetic_pg_(e1i,e2i,r1,r2,l1,l2,val)\n          implicit none\n          real(8),intent(in)::e1i,e2i,r1(3),r2(3)\n          real(8),intent(out)::val\n          integer,intent(in)::l1(3),l2(3)\n          integer::lps(3),ix\n          real(8)::vt,st\n          call overlap_pg_(e1i,e2i,r1,r2,l1,l2,st)\n          val=e2i*(2*sum(l2)+3)*st\n          vt=0d0\n          do ix=1,3\n            lps(:)=0\n            lps(ix)=lps(ix)+2\n            call overlap_pg_(e1i,e2i,r1,r2,l1,l2+lps,st)\n            vt=vt+st\n          end do\n          val=val-2d0*e2i**2d0*vt\n          vt=0d0\n          do ix=1,3\n            if (l2(ix)>=2) then\n              lps(:)=0\n              lps(ix)=lps(ix)-2\n              call overlap_pg_(e1i,e2i,r1,r2,l1,l2+lps,st)\n              vt=vt+l2(ix)*(l2(ix)-1)*st\n            end if\n          end do\n          val=val-0.5d0*vt\n        end subroutine\n"}
{"id": 533, "subroutine": "        subroutine attract_pg_(e1i,e2i,r1,r2,l1,l2,r3,val)\n          implicit none\n          real(8),intent(in)::e1i,e2i,r1(3),r2(3),r3(3)\n          real(8),intent(out)::val\n          integer,intent(in)::l1(3),l2(3)\n          integer::ix,ii,jj,kk\n          real(8) ::\n     &      gm,rp(3),gls(5,3),pa(3),pb(3),pc(3),vt,vb,gpc2\n          gm=e1i+e2i\n          val=2d0*pi/gm*exp(-e1i*e2i*sum((r1-r2)**2)/gm)\n          rp(:)=(e1i*r1(:)+e2i*r2(:))/gm\n          pa(:)=rp(:)-r1(:)\n          pb(:)=rp(:)-r2(:)\n          pc(:)=rp(:)-r3(:)\n          gpc2=gm*sum(pc**2)\n          do ix=1,3\n            call glist_(l1(ix),l2(ix),pa(ix),pb(ix),pc(ix),gm,gls(:,ix))\n          end do\n          vt=0d0\n          do ii=0,l1(1)+l2(1)\n            do jj=0,l1(2)+l2(2)\n              do kk=0,l1(3)+l2(3)\n                call boys_(ii+jj+kk,gpc2,vb)\n                vt=vt+gls(ii+1,1)*gls(jj+1,2)*gls(kk+1,3)*vb\n              end do\n            end do\n          end do\n          val=val*vt\n        end subroutine\n"}
{"id": 534, "subroutine": "        subroutine boys_(n,x,val)\n          ! boys function interface.\n          implicit none\n          integer,parameter::nmax=10\n          integer,intent(in)::n\n          real(8),intent(in)::x\n          real(8),intent(out)::val\n          if (x<1d-6) then\n            val=1d0/(2d0*n+1)-x/(2d0*n+3d0)\n          else\n            val=fboys_(n,x)\n          end if\n        end subroutine\n"}
{"id": 535, "subroutine": "        subroutine glist_(l1w,l2w,paw,pbw,pcw,gm,glsw)\n          implicit none\n          integer,intent(in)::l1w,l2w\n          real(8),intent(in)::paw,pbw,pcw,gm\n          real(8),intent(out)::glsw(:)\n          real(8)::f0,f1,f2,f3\n          glsw(:)=0d0\n          if (l1w+l2w==0) then\n            glsw(1)=1d0\n          else if (l1w+l2w==1) then\n            call fcoef_(0,l1w,l2w,paw,pbw,f0)\n            glsw(1)=f0\n            glsw(2)=-pcw\n          else if (l1w+l2w==2) then\n            call fcoef_(0,l1w,l2w,paw,pbw,f0)\n            call fcoef_(1,l1w,l2w,paw,pbw,f1)\n            glsw(1)=f0+1/(2*gm)\n            glsw(2)=-f1*pcw-1/(2*gm)\n            glsw(3)=pcw**2\n          else if (l1w+l2w==3) then\n            call fcoef_(0,l1w,l2w,paw,pbw,f0)\n            call fcoef_(1,l1w,l2w,paw,pbw,f1)\n            call fcoef_(2,l1w,l2w,paw,pbw,f2)\n            glsw(1)=f0+f2/(2*gm)\n            glsw(2)=-f1*pcw-f2/(2*gm)-3*pcw/(2*gm)\n            glsw(3)=f2*pcw**2+3*pcw/(2*gm)\n            glsw(4)=-pcw**3\n          else if (l1w+l2w==4) then\n            call fcoef_(0,l1w,l2w,paw,pbw,f0)\n            call fcoef_(1,l1w,l2w,paw,pbw,f1)\n            call fcoef_(2,l1w,l2w,paw,pbw,f2)\n            call fcoef_(3,l1w,l2w,paw,pbw,f3)\n            glsw(1)=f0+f2/(2*gm)+3/(4*gm**2)\n            glsw(2)=-f1*pcw-f2/(2*gm)-3*pcw*f3/gm-3/(2*gm**2)\n            glsw(3)=f2*pcw**2+3*pcw*f3/(2*gm)+3*pcw**2/gm+3/(4*gm**2)\n            glsw(4)=-f3*pcw**3-3*pcw**2/gm\n            glsw(5)=pcw**4\n          else\n            write(*,'(\"error: out of range: glist_()\")')\n            stop 1\n          end if\n        end subroutine\n"}
{"id": 536, "subroutine": "        subroutine eval_repulse(\n     &      n1,n2,n3,n4,c1,c2,c3,c4,e1,e2,e3,e4,\n     &      r1,r2,r3,r4,l1,l2,l3,l4,val)\n          implicit none\n          integer,intent(in)::n1,n2,n3,n4,l1(3),l2(3),l3(3),l4(3)\n          real(8),intent(in)::\n     &      c1(n1),c2(n2),c3(n3),c4(n4),e1(n1),e2(n2),e3(n3),e4(n4),\n     &      r1(3),r2(3),r3(3),r4(3)\n          real(8),intent(out)::val\n          real(8)::vt\n          integer::i,j,k,l\n          val=0d0\n          do i=1,n1\n            do j=1,n2\n              do k=1,n3\n                do l=1,n4\n                  call repulse_pg_(\n     &              e1(i),e2(j),e3(k),e4(l),r1,r2,r3,r4,l1,l2,l3,l4,vt)\n                  vt=vt*pgn_(l1,e1(i))*pgn_(l2,e2(j))\n                  vt=vt*pgn_(l3,e3(k))*pgn_(l4,e4(l))\n                  vt=vt*c1(i)*c2(j)*c3(k)*c4(l)\n                  val=val+vt\n                end do\n              end do\n            end do\n          end do\n        end subroutine\n"}
{"id": 537, "subroutine": "        subroutine repulse_pg_(\n     &      e1i,e2i,e3i,e4i,r1,r2,r3,r4,l1,l2,l3,l4,val)\n          implicit none\n          integer,intent(in)::l1(3),l2(3),l3(3),l4(3)\n          real(8),intent(in) ::\n     &      e1i,e2i,e3i,e4i,r1(3),r2(3),r3(3),r4(3)\n          real(8),intent(out)::val\n          integer::ix,ii,jj,kk\n          real(8)::gm1,gm2,rp(3),rq(3),rab2,rcd2,rpq2,delta,\n     &      cls(9,3),vt,vb\n          gm1=e1i+e2i\n          gm2=e3i+e4i\n          rp(:)=(e1i*r1(:)+e2i*r2(:))/gm1\n          rq(:)=(e3i*r3(:)+e4i*r4(:))/gm2\n          rab2=sum((r1-r2)**2)\n          rcd2=sum((r3-r4)**2)\n          rpq2=sum((rp-rq)**2)\n          delta=(1d0/gm1+1d0/gm2)/4d0\n          val=1d0\n          val=val*2*pi**2.5/(gm1*gm2)/((gm1+gm2)**0.5)\n          val=val*exp(-(e1i*e2i*rab2/gm1)-(e3i*e4i*rcd2/gm2))\n          if (abs(val)>twoetol) then\n            do ix=1,3\n              call clist_(\n     &          r1(ix),l1(ix),r2(ix),l2(ix),rp(ix),e1i+e2i,\n     &          r3(ix),l3(ix),r4(ix),l4(ix),rq(ix),e3i+e4i,cls(:,ix))\n            end do\n            vt=0d0\n            do ii=0,l1(1)+l2(1)+l3(1)+l4(1)\n              do jj=0,l1(2)+l2(2)+l3(2)+l4(2)\n                do kk=0,l1(3)+l2(3)+l3(3)+l4(3)\n                  call boys_(ii+jj+kk,rpq2/(4*delta),vb)\n                  vt=vt+cls(ii+1,1)*cls(jj+1,2)*cls(kk+1,3)*vb\n                end do\n              end do\n            end do\n            val=val*vt\n          end if\n        end subroutine\n"}
{"id": 538, "subroutine": "        subroutine clist_(\n     &      raw,l1w,rbw,l2w,rpw,gm1,rcw,l3w,rdw,l4w,rqw,gm2,clsw)\n          implicit none\n          integer,intent(in)::l1w,l2w,l3w,l4w\n          real(8),intent(in)::raw,rbw,rpw,gm1,rcw,rdw,rqw,gm2\n          real(8),intent(out)::clsw(:)\n          real(8)::pa,pb,qc,qd,delta,hls1(5),hls2(5),f3n,f3d\n          integer::i,j,ii,u\n          pa=rpw-raw\n          pb=rpw-rbw\n          qc=rqw-rcw\n          qd=rqw-rdw\n          delta=0.25d0*(1d0/gm1+1d0/gm2)\n          clsw(:)=0d0\n          call hlist_(l1w,l2w,pa,pb,gm1,hls1)\n          call hlist_(l3w,l4w,qc,qd,gm2,hls2)\n          do i=0,l1w+l2w\n            do j=0,l3w+l4w\n              do u=0,int(floor((i+j)/2d0))\n                f3n=1d0\n                f3n=f3n*nfact_(i+j)*(-1)**u\n                f3n=f3n*(rqw-rpw)**(i+j-2*u)\n                f3d=1d0\n                f3d=f3d*nfact_(u)\n                f3d=f3d*nfact_(i+j-2*u)\n                f3d=f3d*delta**(i+j-u)\n                ii=i+j-u+1\n                if (ii>size(clsw)) then\n                  write(*,'(\"error: out of range: clist_()\")')\n                  stop 1\n                end if\n                clsw(ii)=clsw(ii)+hls1(i+1)*(-1)**j*hls2(j+1)*f3n/f3d\n              end do\n            end do\n          end do\n        end subroutine\n"}
{"id": 539, "subroutine": "        subroutine hlist_(l1w0,l2w0,pa0,pb0,gm,hls)\n          implicit none\n          integer,intent(in)::l1w0,l2w0\n          real(8),intent(in)::pa0,pb0,gm\n          integer::l1w,l2w\n          real(8)::pa,pb\n          real(8),intent(out)::hls(:)\n          if (l1w0>=l2w0) then\n            l1w=l1w0\n            l2w=l2w0\n            pa=pa0\n            pb=pb0\n          else\n            l1w=l2w0\n            l2w=l1w0\n            pa=pb0\n            pb=pa0\n          end if\n          hls(:)=0d0\n          if (l1w==0.and.l2w==0) then\n            hls(1)=1d0\n          else if (l1w==1.and.l2w==0) then\n            hls(1)=pa\n            hls(2)=1/(4*gm)\n          else if (l1w==1.and.l2w==1) then\n            hls(1)=pa*pb+1d0/(2*gm)\n            hls(2)=(pa+pb)/(4*gm)\n            hls(3)=1/(4*gm)**2\n          else if (l1w==2.and.l2w==0) then\n            hls(1)=pa**2+1d0/(2*gm)\n            hls(2)=pa/(2*gm)\n            hls(3)=1/(4*gm)**2\n          else if (l1w==2.and.l2w==1) then\n            hls(1)=pa**2*pb+(2*pa+pb)/(2*gm)\n            hls(2)=(2*pa*pb+pa**2)/(4*gm)+6*(1/(4*gm)**2)\n            hls(3)=(2*pa+pb)*(1/(4*gm))**2\n            hls(4)=(1/(4*gm))**3\n          else if (l1w==2.and.l2w==2) then\n            hls(1)=(pa*pb)**2+(pa**2+4*pa*pb+pb**2)/(2*gm)\n     &        +12*(1/(4*gm)**2)\n            hls(2)=pa*pb*(pa+pb)/(2*gm)+12*(pa+pb)*(1/(4*gm))**2\n            hls(3)=(pa**2+4*pa*pb+pb**2)*(1/(4*gm))**2+12*(1/(4*gm))**3\n            hls(4)=2*(pa+pb)*(1/(4*gm))**3\n            hls(5)=(1/(4*gm))**4\n          else\n            write(*,'(\"error: out of range: hlist_()\")')\n            stop 1\n          end if\n        end subroutine\n"}
{"id": 540, "subroutine": "        subroutine eval_velocity(n1,n2,c1,c2,e1,e2,r1,r2,l1,l2,ix,val)\n          implicit none\n          integer,intent(in)::n1,n2,l1(3),l2(3),ix\n          real(8),intent(in)::c1(n1),c2(n2),e1(n1),e2(n2),r1(3),r2(3)\n          real(8),intent(out)::val\n          integer::i,j\n          real(8)::vt\n          val=0d0\n          do i=1,n1\n            do j=1,n2\n              call velocity_pg_(e1(i),e2(j),r1,r2,l1,l2,ix,vt)\n              vt=vt*pgn_(l1,e1(i))*pgn_(l2,e2(j))\n              vt=vt*c1(i)*c2(j)\n              val=val+vt\n            end do\n          end do\n        end subroutine\n"}
{"id": 541, "subroutine": "        subroutine velocity_pg_(e1i,e2i,r1,r2,l1,l2,ix,val)\n          implicit none\n          integer,intent(in)::l1(3),l2(3),ix\n          real(8),intent(in)::e1i,e2i,r1(3),r2(3)\n          real(8),intent(out)::val\n          integer::lps(3)\n          real(8)::vt\n          lps(:)=0\n          lps(ix)=lps(ix)+1\n          call overlap_pg_(e1i,e2i,r1,r2,l1,l2+lps,vt)\n          val=-2d0*e2i*vt\n          if (l2(ix)>0) then\n            call overlap_pg_(e1i,e2i,r1,r2,l1,l2-lps,vt)\n            val=val+l2(ix)*vt\n          end if\n        end subroutine\n"}
{"id": 542, "subroutine": "      subroutine gettflux\n      use vsvd\n      implicit none\nc-----------------------------------------------\nc   l o c a l   p a r a m e t e r s\nc-----------------------------------------------\n      real(rprec) :: p01=1.e-2_dp, zero = 0.0_dp\nc-----------------------------------------------\nc   l o c a l   v a r i a b l e s\nc-----------------------------------------------\n      real(rprec) :: tfac, phifac0\nc-----------------------------------------------\n\n!\n!       update phiedge scale factor by the formula\n!       fdot/f = -2*(1 - apres/aminor), where f = phiscale\n!\n      tfac = p01*rsfac\n\n      if (imatch_phiedge .eq. 0) then\n         if (aminor .eq. zero) then\n            phifac0 = phifac\n         else\n           phifac0 = phifac*(apres/aminor)\n         end if\n         gphifac = tfac*(phifac0 - phifac)\n\n      else if (imatch_phiedge .eq. 2) then\n         call getlim\n         gphifac = tfac*phifac*gphifac\n      endif\n\n      end subroutine gettflux\n"}
{"id": 543, "subroutine": "    subroutine test_l2m_getlvl2minors\n        integer, parameter :: n = 4\n        integer, parameter :: nv1 = 0\n        integer, parameter :: nv2 = 0\n        real(dp) :: csc(n+nv1, n+nv2)\n        real(dp) :: l2minor(n**4)\n        real(dp), parameter :: tol = 1.e-12_dp\n        integer :: i\n        external :: getlvl2minors_lu\n        \n        csc = reshape([ (i, i=1, (n+nv1)*(n+nv2)) ], shape(csc), order=[2, 1])\n        \n        call getlvl2minors_lu(n, nv2, csc, n+nv1, l2minor, n**3)\n        call assert_equals(-4.0_dp, l2minor(18), tol, 'level 2 minors')\n        call assert_equals(-4.0_dp, l2minor(79), tol, 'level 2 minors')\n        call assert_equals(-4.0_dp, l2minor(226), tol, 'level 2 minors')\n        call assert_equals(-4.0_dp, l2minor(191), tol, 'level 2 minors')\n    end subroutine test_l2m_getlvl2minors\n"}
{"id": 544, "subroutine": "        subroutine c_ezcu_dev_wait(c_dev_ptr) bind(c, name = \"ezcu_dev_wait\")\n            use iso_c_binding, only: c_ptr\n            type(c_ptr), value, intent(in) :: c_dev_ptr\n        end subroutine c_ezcu_dev_wait\n"}
{"id": 545, "subroutine": "    subroutine ezcu_dev_find(idx, d)\n        integer(kind=4),             value, intent(in) :: idx\n        type(ezcu_dev_t),       pointer, intent(inout) :: d\n        call c_f_pointer(c_ezcu_dev_find(idx), d)\n    end subroutine ezcu_dev_find\n"}
{"id": 546, "subroutine": "    subroutine ezcu_dev_wait(d)\n        type(ezcu_dev_t), pointer, intent(in) :: d\n        call c_ezcu_dev_wait(c_loc(d))\n    end subroutine ezcu_dev_wait\n"}
{"id": 547, "subroutine": "    pure subroutine ustring_t_assign_string_t(lhs, rhs)\n        class (ustring_t), intent (inout) :: lhs\n        class (string_t), intent (in) :: rhs\n\n        call lhs%set_value(rhs%get_value())\n    end subroutine ustring_t_assign_string_t\n"}
{"id": 548, "subroutine": "    elemental subroutine ustring_t_assign_character(lhs, rhs)\n        class (ustring_t), intent (inout) :: lhs\n        character(len=*), intent(in) :: rhs\n\n        call lhs%set_value(rhs)\n    end subroutine ustring_t_assign_character\n"}
{"id": 549, "subroutine": "    pure subroutine set_uvalue(this, the_value)\n        class (ustring_t), intent (inout) :: this\n        character(len=*), intent (in) :: the_value\n\n        call this%string_t%set_value(ucase(trim(the_value)))\n    end subroutine set_uvalue\n"}
{"id": 550, "subroutine": "subroutine calc_xika(xika0,xi,rho,nui,nk,delta,obj_func,xika,ncomp,nbeads,nsitemax)\n    implicit none\n    integer,intent(in) :: ncomp, nbeads, nsitemax\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika0\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    real(8), intent(in) :: rho\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: obj_func\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: xika\n    integer :: i,k,a,j,l,b\n    \n    !initialize xika to 1.0\n    xika=1.0\n    \n    do i=0, ncomp-1\n        do k=0, nbeads-1\n            do a=0, nsitemax-1\n                do j=0, ncomp-1\n                    do l=0, nbeads-1\n                        do b=0, nsitemax-1\n                            xika(i,k,a)=xika(i,k,a) + (rho * xi(j) * nui(j,l) * nk(l,b) * xika0(j,l,b) * delta(i,j,k,l,a,b))\n                        enddo\n                    enddo\n                enddo\n            enddo\n        enddo\n    enddo\n    xika = (1.0/xika)\n    \n    obj_func = xika - xika0\n    \nend subroutine\n"}
{"id": 551, "subroutine": "subroutine min_xika(rho,xika_init,xi,nui,nk,delta,maxiter,tol,xika_final,nrho,ncomp,nbeads,nsitemax)\n    implicit none\n    integer, intent(in) :: nrho,ncomp,nbeads,nsitemax\n    real(8), intent(in), dimension(0:nrho-1) :: rho\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika_init\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:nrho-1,0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    integer, intent(in) :: maxiter\n    real(8), intent(in) :: tol\n    real(8), intent(out), dimension(0:nrho-1,0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika_final\n    real(8), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika,obj_func,xika0\n    real(8), dimension(0:(ncomp*nbeads*nsitemax)-1) :: xika_flat\n    integer :: i,iter\n    \n    \n    xika=xika_init\n    \n    do i=0, nrho-1\n        !write(*,*) xika0\n        do iter=0, maxiter-1\n            xika0=xika\n            call calc_xika(xika0,xi,rho(i),nui,nk,delta(i,:,:,:,:,:,:),obj_func,xika,ncomp,nbeads,nsitemax)            \n            if(maxval(dabs(obj_func)).lt.tol) exit\n        enddo\n        xika_final(i,:,:,:)=xika\n        !write(*,*) i,iter,xika,obj_func\n    end do\n    !write(*,*) i,rho(i),xika,xika_final(i,:,:,:)\nend subroutine\n"}
{"id": 552, "subroutine": "        subroutine eigdrv3d()\n!  \n!  driver for eigenvalue problem (lapack)\n!\n!=============================================================================!\n        use global\n        use local2d\n        use local3d\n        implicit none\n!=============================================================================!\n        complex :: v(ndof,nx,ny)\n        complex :: matx(5,ndof,ndof,nx,ny)\n        complex :: mat(ndof,nx,ndof,nx)\n        real    :: rmat(ndof,nx,ndof,nx)\n        real    :: dtl(nx,ny)\n        \n!.... lapack variables\n\n        integer :: lwork, info\n        real, allocatable :: rwork(:)\n        complex, allocatable :: work(:)\n        complex :: eval(ndof*nx), evec(ndof,nx,ndof*nx)\n        real :: reval(ndof*nx), ieval(ndof*nx), revec(ndof,nx,ndof*nx)\n        \n        integer :: i, j, idof, jdof\n        character*80 :: name, code='eigdrv$'\n!=============================================================================!\n\n        alfa = one\n        dtl = one\n\n        v = zero\n        mat = zero\n        matx = zero\n\n        call lhs1f3d( matx, ah, dh, dhi, vh11, abhi, dtl, v )\n\n!.... remove identity matrix\n\n        do j = 1, ny\n          do i = 1, nx\n            do idof = 1, ndof\n              matx(3,idof,idof,i,j) = matx(3,idof,idof,i,j) - one\n            end do\n          end do\n        end do\n\n!.... convert to lapack general matrix storage\n\n        j = 1\n\n        i = 1\n        do idof = 1, ndof\n          do jdof = 1, ndof\n            mat(idof,i,jdof,nx-2) = matx(1,idof,jdof,i,j)\n            mat(idof,i,jdof,nx-1) = matx(2,idof,jdof,i,j)\n            mat(idof,i,jdof,i  )  = matx(3,idof,jdof,i,j)\n            mat(idof,i,jdof,i+1)  = matx(4,idof,jdof,i,j)\n            mat(idof,i,jdof,i+2)  = matx(5,idof,jdof,i,j)\n          end do\n        end do\n        \n        i = 2\n        do idof = 1, ndof\n          do jdof = 1, ndof\n            mat(idof,i,jdof,nx-1) = matx(1,idof,jdof,i,j)\n            mat(idof,i,jdof,i-1)  = matx(2,idof,jdof,i,j)\n            mat(idof,i,jdof,i  )  = matx(3,idof,jdof,i,j)\n            mat(idof,i,jdof,i+1)  = matx(4,idof,jdof,i,j)\n            mat(idof,i,jdof,i+2)  = matx(5,idof,jdof,i,j)\n          end do\n        end do\n\n        do i = 3, nx-2\n          do idof = 1, ndof\n            do jdof = 1, ndof\n              mat(idof,i,jdof,i-2) = matx(1,idof,jdof,i,j)\n              mat(idof,i,jdof,i-1) = matx(2,idof,jdof,i,j)\n              mat(idof,i,jdof,i  ) = matx(3,idof,jdof,i,j)\n              mat(idof,i,jdof,i+1) = matx(4,idof,jdof,i,j)\n              mat(idof,i,jdof,i+2) = matx(5,idof,jdof,i,j)\n            end do\n          end do\n        end do\n\n        i = nx-2\n        do idof = 1, ndof\n          do jdof = 1, ndof\n            mat(idof,i,jdof,i-2) = matx(1,idof,jdof,i,j)\n            mat(idof,i,jdof,i-1) = matx(2,idof,jdof,i,j)\n            mat(idof,i,jdof,i  ) = matx(3,idof,jdof,i,j)\n            mat(idof,i,jdof,i+1) = matx(4,idof,jdof,i,j)\n            mat(idof,i,jdof,1)   = matx(5,idof,jdof,i,j)\n          end do\n        end do\n\n        i = nx-1\n        do idof = 1, ndof\n          do jdof = 1, ndof\n            mat(idof,i,jdof,i-2) = matx(1,idof,jdof,i,j)\n            mat(idof,i,jdof,i-1) = matx(2,idof,jdof,i,j)\n            mat(idof,i,jdof,i  ) = matx(3,idof,jdof,i,j)\n            mat(idof,i,jdof,1)   = matx(4,idof,jdof,i,j)\n            mat(idof,i,jdof,2)   = matx(5,idof,jdof,i,j)\n          end do\n        end do\n \n        i = nx\n        do idof = 1, ndof\n          do jdof = 1, ndof\n            mat(idof,i,jdof,i  ) = one\n          end do\n        end do\n\n        if (.false.) then\n\n        write(*,*) 'starting eigenvalue solver'\n        lwork = max(1,3*(ndof*nx))\n        allocate( work(lwork), rwork(2*(ndof*nx)) )\n        call zgeev ( 'n', 'v', ndof*(nx-1), mat, ndof*nx, eval, &\n                     evec, ndof*nx, evec, ndof*nx,          &\n                     work, lwork, rwork, info )\n        write(*,*) 'zgeev info = ',info\n        deallocate( work, rwork )\n        write(*,*) 'finished eigenvalue solver'\n\n        else\n\n        rmat = real(mat)\n        write(*,*) 'starting eigenvalue solver'\n        lwork = max(1,4*(ndof*nx))\n        allocate( rwork(lwork) )\n        call dgeev ( 'n', 'v', ndof*(nx-1), rmat, ndof*nx, reval, ieval, &\n                     revec, ndof*nx, revec, ndof*nx,          &\n                     rwork, lwork, info )\n        write(*,*) 'dgeev info = ',info\n        deallocate( rwork )\n        write(*,*) 'finished eigenvalue solver'\n\n        do j = 1, ndof*(nx-1)\n          eval(j) = cmplx(reval(j),ieval(j))\n        end do\n\n        do j = 2, ndof*(nx-1)\n          if (eval(j) == conjg(eval(j-1))) then\n            evec(:,:,j-1) = revec(:,:,j-1) + (zero,one)*revec(:,:,j)\n            evec(:,:,j)   = revec(:,:,j-1) - (zero,one)*revec(:,:,j)\n          end if\n        end do\n\n        end if\n\n!.... correct eigenvectors for periodic boundary conditions\n\n        do j = 1, ndof*nx\n          evec(:,nx,j) = evec(:,1,j)\n        end do\n        do idof = 1, ndof\n          i = ndof*(nx-1) + idof\n          eval(i) = zero\n        end do\n\n!.... output the eigenvalues and eigenvectors\n\n        open(11,file='eig.dat', form='unformatted', status='unknown')\n        write(11) ndof*nx, 0.0, nx, 1, nz, ndof, &\n                  re, ma, pr, gamma, cv\n        write(11) eval\n        write(11) evec\n        close(11)\n\n        end subroutine eigdrv3d\n"}
{"id": 553, "subroutine": "subroutine test_canonical()\n\ntype(path_t) :: cur, par, file, p1, p2\ncharacter(*), parameter :: dummy = \"nobody.txt\"\n\ninteger :: l1, l2, l3\n\n!> empty\nif(resolve(\"\") /= \"\") error stop \"resolve('') /= ''\"\n\n! -- current directory  -- old macos doesn't handle \".\" or \"..\" alone\ncur = path_t(\".\")\ncur = cur%resolve()\nl1 = cur%length()\nif (l1 < 1) error stop \"canonical '.' \" // cur%path()\n\nif (cur%path() /= get_cwd()) error stop \"canonical('.') \" // cur%path() // \" /= get_cwd: \" // get_cwd()\n\nprint *, \"ok: current dir = \", cur%path()\n! -- home directory\np1 = path_t(\"~\")\np1 = p1%resolve()\nif (p1%path(1,1) == \"~\") error stop \"%resolve ~ did not expanduser: \" // p1%path()\nif (resolve(\"~\") == \"~\") error stop \"resolve('~') should not be '~'\"\nprint *, \"ok: home dir = \", p1%path()\n\np2 = path_t(p1%parent())\nl1 = p2%length()\nif (l1 >= p1%length()) error stop \"parent home \" // p2%path()\nprint *, \"ok: parent home = \", p2%path()\n\n\n! -- relative dir\npar = path_t(\"~/..\")\npar = par%resolve()\n\nl2 = par%length()\nif (l2 /= l1) error stop 'up directory was not canonicalized: ~/.. => ' // par%path()\n\nprint *, 'ok: canon_dir = ', par%path()\n\n! -- relative file\nfile = path_t('~/../' // dummy)\nfile = file%resolve()\nl3 = file%length()\nif (l3 - l2 /= len(dummy) + 1) error stop 'file was not canonicalized: ' // file%path()\n\nprint *, 'ok: canon_file = ', file%path()\n\nend subroutine test_canonical\n"}
{"id": 554, "subroutine": "subroutine test_same_file()\n\ntype(path_t) :: p1, p2\ninteger :: i\n\ncall mkdir(\"test-a/b/\", status=i)\nif(i < 0) then\n  write(stderr,'(a)') \"mkdir not supported on this platform\"\n  return\nendif\n\nif(.not. is_dir(\"test-a/b\")) error stop \"mkdir test-a/b failed\"\n\np1 = path_t(\"test-a/c\")\ncall p1%touch()\nif(.not. is_file(\"test-a/c\")) error stop \"touch test-a/c failed\"\n\np2 = path_t(\"test-a/b/../c\")\n\nif (.not. p1%same_file(p2)) error stop 'error: %same_file'\nif (.not. same_file(p1%path(), p2%path())) error stop 'error: same_file()'\n\nend subroutine test_same_file\n"}
{"id": 555, "subroutine": "  subroutine queue_init(self, data)\n    type(queue_node_t), pointer :: self\n    integer, dimension(:), intent(in), optional :: data\n\n    ! allocate an empty node.\n    allocate(self)\n    nullify(self%prev)\n    nullify(self%next)\n\n    ! if successfully allocated, allocate internal data and set it.\n    ! if not, nullify allocated pointer and exit.\n    if (present(data)) then\n      allocate(self%data(size(data)))\n      self%data = data\n    else\n      nullify(self%data)\n    end if\n  end subroutine queue_init\n"}
{"id": 556, "subroutine": "  subroutine queue_free(self)\n    type(queue_node_t), pointer :: self\n    type(queue_node_t), pointer :: current\n    type(queue_node_t), pointer :: next\n\n    ! first, start at self.\n    ! if there is something associated, deallocate the internal saved data and\n    ! set the 'next' pointer to null. then deallocate and nullify the current\n    ! node and proceed with the next one, until every node is freed.\n    current => self\n    do while (associated(current))\n      next => current%next\n      if (associated(current%data)) then\n        deallocate(current%data)\n        nullify(current%data)\n      end if\n      deallocate(current)\n      nullify(current)\n      current => next\n    end do\n  end subroutine queue_free\n"}
{"id": 557, "subroutine": "  subroutine queue_poll(self)\n    type(queue_node_t), pointer :: self\n    type(queue_node_t), pointer :: current\n    type(queue_node_t), pointer :: next\n\n    current => self\n    do while (associated(current%next))\n      current => current%next\n    end do\n\n    ! setting queue_data to self%data to make this value easily transferble\n    ! for usage in other ways ...\n    queue_data = current%data\n\n    if (associated(current%data)) then\n        deallocate(current%data)\n        nullify(current%data)\n    end if\n    \n    nullify(current%prev%next)\n    nullify(current%prev)\n    deallocate(current)\n    nullify(current)\n  end subroutine queue_poll\n"}
{"id": 558, "subroutine": "  subroutine queue_peek(self)\n    type(queue_node_t), pointer :: self\n    type(queue_node_t), pointer :: selfcopy\n\n    ! move to end of queue.\n    selfcopy => self\n    do while (associated(selfcopy%next))\n      selfcopy => selfcopy%next\n    end do\n\n    queue_data = selfcopy%data\n  end subroutine queue_peek\n"}
{"id": 559, "subroutine": "      subroutine fem_druckerprager_stress_update(i, j, gp_stress, \n     & gp_strain, iunload)\n!***********************************************************************\n! copyright 2011 los alamos national security, llc  all rights reserved\n! unless otherwise indicated,  this information has been authored by an\n! employee or employees of the los alamos national security, llc (lans),\n! operator of the  los  alamos national  laboratory  under contract  no.\n! de-ac52-06na25396  with  the u. s. department  of  energy.  the  u. s.\n! government   has   rights  to  use,  reproduce,  and  distribute  this\n! information.  the  public may copy  and  use this  information without\n! charge, provided that this  notice and any statement of authorship are\n! reproduced on all copies.  neither  the  government nor lans makes any\n! warranty,   express   or   implied,   or   assumes  any  liability  or\n! responsibility for the use of this information.      \n!***********************************************************************\n! \n! computes the stresses from strains for the drucker-prager (without cap)\n! plasticity model\n! \n! author : satish karra\n! date : march 26 2012\n!\n\n      use comsi, only: iplastic, plasticmodel, modelnumber, e1, e2, e3\n      use comsi, only: isplastic, plasticparam1, plastic_strain\n      use comsi, only: plasticparam2, plasticparam3\n      use comsi, only: du, dv, dw, alp, bulk\n      use comdi, only: t, phi, tini, phini\n      use comai, only: iout, iptty, iad, ns, nei\n      use comfem\n\n      implicit none\n      integer                                :: i, j, k   \n      double precision,  dimension(6)        :: gp_stress, gp_strain\n      double precision,  dimension(6)        :: dstrain\n      double precision,  dimension(6)        :: tot_strain, dev_strain\n      integer, dimension(8)                  :: node\n      logical                                :: iunload\n      double precision,  dimension(8)        :: alpha, beta, deltat\n      double precision,  dimension(8)        :: lambda, g, deltap\n      double precision,  dimension(6,6)      :: d\n      double precision alphadeltat, betadeltap, vol_strain, pressure\n      double precision bulk_mod, lambda_bar, g_bar, j2, deltagamma\n      double precision phi_trial, phi_tol, fac, eta, xi, rad\n      integer itmp, imodel\n\n\n      if(iplastic.eq.0) then\n        write(iout,*) '***error : drucker-prager stress update called\n     &   without plastic flag being set '\n      endif\n\n      if(.not.allocated(conv_pstrain)) then\n        allocate(conv_pstrain(nei, numgausspoints))\n        conv_pstrain = 0.0d0\n      endif\n\n      itmp = modelnumber(elnode(i, 1))\n      imodel = plasticmodel(itmp)\n\n      do k=2,ns\n        itmp = modelnumber(elnode(i, k))\n        if(imodel.ne.plasticmodel(itmp)) then\n          write(iout, *) 'multiple plastic models being used !\n     &        not supported at this time! '\n          write(iptty, *) 'multiple plastic models being used !\n     &        not supported at this time! '\n          stop\n        endif\n      enddo\n\n      phi_tol = 1.0d-6\n      isplastic(i,j) = 0\n\n      bulk_mod = 0.0d0\n      lambda_bar = 0.0d0\n      g_bar = 0.0d0\n\n      alphadeltat = 0.0d0\n      betadeltap  = 0.0d0\n\n!   assigning drucker prager parameters for now\n      eta = plasticparam1(itmp) \n      xi = plasticparam2(itmp)\n      rad = plasticparam3(itmp)\n\n      do k = 1, ns\n        node(k) = elnode(i, k)\n        lambda(k) = e2(node(k))\n        g(k) = 0.5d0*(e1(k) - e2(k))\n        lambda_bar = lambda_bar + lambda(k)*psi(i,j,k)\n        g_bar = g_bar + g(k)*psi(i,j,k)\n        alpha(k) = alp(node(k))\n        deltat(k) = t(node(k)) - tini(node(k))\n        beta(k) = bulk(node(k))\n        deltap(k) = phi(node(k)) - phini(node(k))\n        alphadeltat = alphadeltat + \n     &                 psi(i,j,k)*alpha(k)*deltat(k)\n        betadeltap = betadeltap + \n     &                 psi(i,j,k)*beta(k)*deltap(k)\n\n      enddo\n\n      ! change gp_strain from incremental strain to total new strain\n      tot_strain = conv_strain(i, j, :) + gp_strain\n\n      bulk_mod = lambda_bar + (2.0d0/3.0d0)*g_bar\n      vol_strain = tot_strain(1) + tot_strain(2) + tot_strain(3)\n      vol_strain = vol_strain - 3.0d0*(alphadeltat + betadeltap)\n      pressure = bulk_mod*(vol_strain)\n\n      dev_strain = tot_strain\n      dev_strain(1) = dev_strain(1) - vol_strain/3.0d0\n      dev_strain(2) = dev_strain(2) - vol_strain/3.0d0 \n      dev_strain(3) = dev_strain(3) - vol_strain/3.0d0\n      dev_strain(4) = dev_strain(4)/2.0d0\n      dev_strain(5) = dev_strain(5)/2.0d0\n      dev_strain(6) = dev_strain(6)/2.0d0\n\n      call j2invariant(j2, 2.0d0*g_bar*dev_strain)\n      phi_trial = sqrt(j2) + eta*pressure - xi*rad \n\n      if((phi_trial.ge.phi_tol).and.(iunload.eqv..false.)) then\n        isplastic(i, j) = 1\n\n        deltagamma = phi_trial/(g_bar + bulk_mod*eta**2)\n\n        if (sqrt(j2) - g_bar*deltagamma.ge.phi_tol) then\n! going to the smooth part of the cone\n          fac = (1.d0 - g_bar*deltagamma/sqrt(j2))*2.d0*g_bar\n          pressure = pressure - bulk_mod*deltagamma*eta\n          gp_stress(1) = fac*dev_strain(1) + pressure\n          gp_stress(2) = fac*dev_strain(2) + pressure\n          gp_stress(3) = fac*dev_strain(3) + pressure\n          gp_stress(4) = fac*dev_strain(4)\n          gp_stress(5) = fac*dev_strain(5)\n          gp_stress(6) = fac*dev_strain(6)\n          plastic_strain(i,j) = conv_pstrain(i,j) + eta*deltagamma\n          fac = fac/(2.0d0*g_bar)\n          tot_strain(1) = fac*dev_strain(1) + pressure/(3.0d0*bulk_mod)\n          tot_strain(2) = fac*dev_strain(2) + pressure/(3.0d0*bulk_mod)\n          tot_strain(3) = fac*dev_strain(3) + pressure/(3.0d0*bulk_mod)\n          tot_strain(4) = 2.d0*fac*dev_strain(4)\n          tot_strain(5) = 2.d0*fac*dev_strain(5) \n          tot_strain(6) = 2.d0*fac*dev_strain(6) \n        else\n! going to return to the apex\n          deltagamma = (pressure - xi/eta*rad)/(eta*bulk_mod)\n          gp_stress(1) = pressure - bulk_mod*eta*deltagamma\n          gp_stress(2) = pressure - bulk_mod*eta*deltagamma\n          gp_stress(3) = pressure - bulk_mod*eta*deltagamma\n          gp_stress(4) = 0.d0\n          gp_stress(5) = 0.d0\n          gp_stress(6) = 0.d0\n          plastic_strain(i,j) = conv_pstrain(i,j) +\n     &                          deltagamma*sqrt(0.5d0 + eta**2/3.d0)\n          tot_strain(1) = gp_stress(1)/(3.0d0*bulk_mod)\n          tot_strain(2) = gp_stress(2)/(3.0d0*bulk_mod)\n          tot_strain(3) = gp_stress(3)/(3.0d0*bulk_mod)\n          tot_strain(4) = 0.d0\n          tot_strain(5) = 0.d0\n          tot_strain(6) = 0.d0\n        endif\n\n      else\n        fac = 2.0d0*g_bar\n        gp_stress(1) = fac*dev_strain(1) + pressure\n        gp_stress(2) = fac*dev_strain(2) + pressure\n        gp_stress(3) = fac*dev_strain(3) + pressure\n        gp_stress(4) = fac*dev_strain(4)\n        gp_stress(5) = fac*dev_strain(5)\n        gp_stress(6) = fac*dev_strain(6)\n      endif\n\n      fem_strain(i,j,:) = tot_strain\n      fem_stress(i,j,:) = gp_stress\n\n      end subroutine fem_druckerprager_stress_update\n"}
{"id": 560, "subroutine": "  subroutine tapinit(self, strt, stp)\n    type(tap), pointer :: self\n    integer, intent(in), optional :: strt, stp\n\n    allocate(self)\n\n    nullify(self%nextelem)\n    nullify(self%prevelem)\n\n    if (present(strt)) then\n      allocate(self%strt)\n      self%strt = strt\n    else\n      self%strt => null()\n    end if\n\n    if (present(stp)) then\n      allocate(self%stp)\n      self%stp = stp\n    else\n      self%stp => null()\n    end if\n  end subroutine tapinit\n"}
{"id": 561, "subroutine": "  subroutine tapfree(self)\n    type(tap), pointer :: self, current, next\n\n    current => self\n    do while (associated(current))\n      next => current%nextelem\n      if (associated(current%strt)) then\n        deallocate(current%strt)\n        nullify(current%strt)\n      end if\n      if (associated(current%stp)) then\n        deallocate(current%stp)\n        nullify(current%stp)\n      end if\n      deallocate(current)\n      nullify(current)\n      current => next\n    end do\n  end subroutine tapfree\n"}
{"id": 562, "subroutine": "  subroutine tapinsertafter(self, strt, stp)\n    type(tap), intent(in), pointer :: self\n    integer, intent(in), optional :: strt, stp\n    type(tap), pointer :: next\n\n    allocate(next)\n    nullify(next%nextelem)\n    nullify(next%prevelem)\n\n    if (present(strt)) then\n      allocate(next%strt)\n      next%strt = strt\n    else\n      next%strt => null()\n    end if\n    if (present(stp)) then\n      allocate(next%stp)\n      next%stp = stp\n    else\n      next%stp => null()\n    end if\n\n    ! make the connection\n    if (associated(self%nextelem)) then\n      next%nextelem => self%nextelem\n      next%nextelem%prevelem => next\n    end if\n\n    self%nextelem => next\n    next%prevelem => self\n\n  end subroutine\n"}
{"id": 563, "subroutine": "  subroutine tapdelete(self)\n    type(tap), pointer, intent(inout) :: self\n\n    if (associated(self)) then\n      ! change links\n      if ((associated(self%nextelem)) .and. (associated(self%prevelem))) then\n        ! middle element\n        self%prevelem%nextelem => self%nextelem\n        self%nextelem%prevelem => self%prevelem\n        self%nextelem => null()\n        self%prevelem => null()\n      elseif (associated(self%nextelem)) then\n        ! head element\n        self%nextelem%prevelem => null()\n        self%nextelem => null()\n      elseif (associated(self%prevelem)) then\n        ! tail element\n        self%prevelem%nextelem => null()\n        self%prevelem => null()\n      end if\n\n      ! delete self\n      if (associated(self%strt)) then\n        deallocate(self%strt)\n        nullify(self%strt)\n      end if\n      if (associated(self%stp)) then\n        deallocate(self%stp)\n        nullify(self%stp)\n      end if\n\n      deallocate(self)\n      nullify(self)\n    end if\n  end subroutine tapdelete\n"}
{"id": 564, "subroutine": "  subroutine tapput(self,strt, stp)\n    type(tap), pointer :: self\n    integer, intent(in) :: strt, stp\n\n    self%strt = strt\n    self%stp = stp\n\n  end subroutine tapput\n"}
{"id": 565, "subroutine": "  subroutine tapget(self,strt,stp)\n    type(tap), pointer :: self\n    integer, pointer, intent(out) :: strt, stp\n    if (associated(self)) then\n      strt => self%strt\n      stp => self%stp\n    else\n      strt => null()\n      stp => null()\n    end if\n  end subroutine tapget\n"}
{"id": 566, "subroutine": "        subroutine glclearindex(c) bind(c, name='glclearindex')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: c\n        end subroutine glclearindex\n"}
{"id": 567, "subroutine": "        subroutine glclearcolor(red, green, blue, alpha) bind(c, name='glclearcolor')\n            import :: glclampf\n            real(kind=glclampf), intent(in), value :: red\n            real(kind=glclampf), intent(in), value :: green\n            real(kind=glclampf), intent(in), value :: blue\n            real(kind=glclampf), intent(in), value :: alpha\n        end subroutine glclearcolor\n"}
{"id": 568, "subroutine": "        subroutine glclear(mask) bind(c, name='glclear')\n            import :: glbitfield\n            integer(kind=glbitfield), intent(in), value :: mask\n        end subroutine glclear\n"}
{"id": 569, "subroutine": "        subroutine glindexmask(mask) bind(c, name='glindexmask')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: mask\n        end subroutine glindexmask\n"}
{"id": 570, "subroutine": "        subroutine glcolormask(red, green, blue, alpha) bind(c, name='glcolormask')\n            import :: glboolean\n            integer(kind=glboolean), intent(in), value :: red\n            integer(kind=glboolean), intent(in), value :: green\n            integer(kind=glboolean), intent(in), value :: blue\n            integer(kind=glboolean), intent(in), value :: alpha\n        end subroutine glcolormask\n"}
{"id": 571, "subroutine": "        subroutine glalphafunc(func, ref) bind(c, name='glalphafunc')\n            import :: glclampf, glenum\n            integer(kind=glenum), intent(in), value :: func\n            real(kind=glclampf),  intent(in), value :: ref\n        end subroutine glalphafunc\n"}
{"id": 572, "subroutine": "        subroutine glblendfunc(sfactor, dfactor) bind(c, name='glblendfunc')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: sfactor\n            integer(kind=glenum), intent(in), value :: dfactor\n        end subroutine glblendfunc\n"}
{"id": 573, "subroutine": "        subroutine gllogicop(opcode) bind(c, name='gllogicop')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: opcode\n        end subroutine gllogicop\n"}
{"id": 574, "subroutine": "        subroutine glcullface(mode) bind(c, name='glcullface')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glcullface\n"}
{"id": 575, "subroutine": "        subroutine glpointsize(size) bind(c, name='glpointsize')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: size\n        end subroutine glpointsize\n"}
{"id": 576, "subroutine": "        subroutine gllinewidth(width) bind(c, name='gllinewidth')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: width\n        end subroutine gllinewidth\n"}
{"id": 577, "subroutine": "        subroutine gllinestipple(factor, pattern) bind(c, name='gllinestipple')\n            import :: glint, glushort\n            integer(kind=glint),    intent(in), value :: factor\n            integer(kind=glushort), intent(in), value :: pattern\n        end subroutine gllinestipple\n"}
{"id": 578, "subroutine": "        subroutine glpolygonmode(face, mode) bind(c, name='glpolygonmode')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glpolygonmode\n"}
{"id": 579, "subroutine": "        subroutine glpolygonoffset(factor, units) bind(c, name='glpolygonoffset')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: factor\n            real(kind=glfloat), intent(in), value :: units\n        end subroutine glpolygonoffset\n"}
{"id": 580, "subroutine": "        subroutine glpolygonstipple(mask) bind(c, name='glpolygonstipple')\n            import :: glubyte\n            integer(kind=glubyte), intent(in) :: mask\n        end subroutine glpolygonstipple\n"}
{"id": 581, "subroutine": "        subroutine glgetpolygonstipple(mask) bind(c, name='glgetpolygonstipple')\n            import :: glubyte\n            integer(kind=glubyte), intent(in) :: mask\n        end subroutine glgetpolygonstipple\n"}
{"id": 582, "subroutine": "        subroutine gledgeflagv(flag) bind(c, name='gledgeflagv')\n            import :: glboolean\n            integer(kind=glboolean), intent(in) :: flag\n        end subroutine gledgeflagv\n"}
{"id": 583, "subroutine": "        subroutine glscissor(x, y, width, height) bind(c, name='glscissor')\n            import :: glint, glsizei\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n        end subroutine glscissor\n"}
{"id": 584, "subroutine": "        subroutine glclipplane(plane, equation) bind(c, name='glclipplane')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: plane\n            real(kind=gldouble), intent(in) :: equation\n        end subroutine glclipplane\n"}
{"id": 585, "subroutine": "        subroutine glenable(cap) bind(c, name='glenable')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: cap\n        end subroutine glenable\n"}
{"id": 586, "subroutine": "        subroutine glenableclientstate(cap) bind(c, name='glenableclientstate')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: cap\n        end subroutine glenableclientstate\n"}
{"id": 587, "subroutine": "        subroutine gldisableclientstate(cap) bind(c, name='gldisableclientstate')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: cap\n        end subroutine gldisableclientstate\n"}
{"id": 588, "subroutine": "        subroutine glgetdoublev(pname, params) bind(c, name='glgetdoublev')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=gldouble),  intent(in)        :: params(*)\n        end subroutine glgetdoublev\n"}
{"id": 589, "subroutine": "        subroutine glgetfloatv(pname, params) bind(c, name='glgetfloatv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in)        :: params(*)\n        end subroutine glgetfloatv\n"}
{"id": 590, "subroutine": "        subroutine glgetintegerv(pname, params) bind(c, name='glgetintegerv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine glgetintegerv\n"}
{"id": 591, "subroutine": "        subroutine glpushattrib(mask) bind(c, name='glpushattrib')\n            import :: glbitfield\n            integer(kind=glbitfield), intent(in), value :: mask\n        end subroutine glpushattrib\n"}
{"id": 592, "subroutine": "        subroutine glpopattrib() bind(c, name='glpopattrib')\n        end subroutine glpopattrib\n"}
{"id": 593, "subroutine": "        subroutine glpopclientattrib() bind(c, name='glpopclientattrib')\n        end subroutine glpopclientattrib\n"}
{"id": 594, "subroutine": "        subroutine glfinish() bind(c, name='glfinish')\n        end subroutine glfinish\n"}
{"id": 595, "subroutine": "        subroutine glflush() bind(c, name='glflush')\n        end subroutine glflush\n"}
{"id": 596, "subroutine": "        subroutine glhint(target, mode) bind(c, name='glhint')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glhint\n"}
{"id": 597, "subroutine": "        subroutine glcleardepth(depth) bind(c, name='glcleardepth')\n            import :: glclampd\n            real(kind=glclampd), intent(in), value :: depth\n        end subroutine glcleardepth\n"}
{"id": 598, "subroutine": "        subroutine gldepthfunc(func) bind(c, name='gldepthfunc')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: func\n        end subroutine gldepthfunc\n"}
{"id": 599, "subroutine": "        subroutine gldepthmask(flag) bind(c, name='gldepthmask')\n            import :: glboolean\n            integer(kind=glboolean), intent(in), value :: flag\n        end subroutine gldepthmask\n"}
{"id": 600, "subroutine": "        subroutine gldepthrange(near_val, far_val) bind(c, name='gldepthrange')\n            import :: glclampd\n            real(kind=glclampd), intent(in), value :: near_val\n            real(kind=glclampd), intent(in), value :: far_val\n        end subroutine gldepthrange\n"}
{"id": 601, "subroutine": "        subroutine glclearaccum(red, green, blue, alpha) bind(c, name='glclearaccum')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: red\n            real(kind=glfloat), intent(in), value :: green\n            real(kind=glfloat), intent(in), value :: blue\n            real(kind=glfloat), intent(in), value :: alpha\n        end subroutine glclearaccum\n"}
{"id": 602, "subroutine": "        subroutine glaccum(op, value) bind(c, name='glaccum')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: op\n            real(kind=glfloat),   intent(in), value :: value\n        end subroutine glaccum\n"}
{"id": 603, "subroutine": "        subroutine glmatrixmode(mode) bind(c, name='glmatrixmode')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glmatrixmode\n"}
{"id": 604, "subroutine": "        subroutine glortho(left, right, bottom, top, near_val, far_val) bind(c, name='glortho')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: left\n            real(kind=gldouble), intent(in), value :: right\n            real(kind=gldouble), intent(in), value :: bottom\n            real(kind=gldouble), intent(in), value :: top\n            real(kind=gldouble), intent(in), value :: near_val\n            real(kind=gldouble), intent(in), value :: far_val\n        end subroutine glortho\n"}
{"id": 605, "subroutine": "        subroutine glviewport(x, y, width, height) bind(c, name='glviewport')\n            import :: glint, glsizei\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n        end subroutine glviewport\n"}
{"id": 606, "subroutine": "        subroutine glpushmatrix() bind(c, name='glpushmatrix')\n        end subroutine glpushmatrix\n"}
{"id": 607, "subroutine": "        subroutine glpopmatrix() bind(c, name='glpopmatrix')\n        end subroutine glpopmatrix\n"}
{"id": 608, "subroutine": "        subroutine glloadidentity() bind(c, name='glloadidentity')\n        end subroutine glloadidentity\n"}
{"id": 609, "subroutine": "        subroutine glloadmatrixd(m) bind(c, name='glloadmatrixd')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: m\n        end subroutine glloadmatrixd\n"}
{"id": 610, "subroutine": "        subroutine glloadmatrixf(m) bind(c, name='glloadmatrixf')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: m\n        end subroutine glloadmatrixf\n"}
{"id": 611, "subroutine": "        subroutine glmultmatrixd(m) bind(c, name='glmultmatrixd')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: m\n        end subroutine glmultmatrixd\n"}
{"id": 612, "subroutine": "        subroutine glmultmatrixf(m) bind(c, name='glmultmatrixf')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: m\n        end subroutine glmultmatrixf\n"}
{"id": 613, "subroutine": "        subroutine glrotated(angle, x, y, z) bind(c, name='glrotated')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: angle\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n            real(kind=gldouble), intent(in), value :: z\n        end subroutine glrotated\n"}
{"id": 614, "subroutine": "        subroutine glrotatef(angle, x, y, z) bind(c, name='glrotatef')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: angle\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n            real(kind=glfloat), intent(in), value :: z\n        end subroutine glrotatef\n"}
{"id": 615, "subroutine": "        subroutine glscaled(x, y, z) bind(c, name='glscaled')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n            real(kind=gldouble), intent(in), value :: z\n        end subroutine glscaled\n"}
{"id": 616, "subroutine": "        subroutine glscalef(x, y, z) bind(c, name='glscalef')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n            real(kind=glfloat), intent(in), value :: z\n        end subroutine glscalef\n"}
{"id": 617, "subroutine": "        subroutine gltranslated(x, y, z) bind(c, name='gltranslated')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n            real(kind=gldouble), intent(in), value :: z\n        end subroutine gltranslated\n"}
{"id": 618, "subroutine": "        subroutine gldeletelists(list, range) bind(c, name='gldeletelists')\n            import :: glsizei, gluint\n            integer(kind=gluint),  intent(in), value :: list\n            integer(kind=glsizei), intent(in), value :: range\n        end subroutine gldeletelists\n"}
{"id": 619, "subroutine": "        subroutine glnewlist(list, mode) bind(c, name='glnewlist')\n            import :: glenum, gluint\n            integer(kind=gluint), intent(in), value :: list\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glnewlist\n"}
{"id": 620, "subroutine": "        subroutine glendlist() bind(c, name='glendlist')\n        end subroutine glendlist\n"}
{"id": 621, "subroutine": "        subroutine glcalllist(list) bind(c, name='glcalllist')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: list\n        end subroutine glcalllist\n"}
{"id": 622, "subroutine": "        subroutine glcalllists(n, type, lists) bind(c, name='glcalllists')\n            import :: glenum, glsizei, c_ptr\n            integer(kind=glsizei), intent(in), value :: n\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: lists\n        end subroutine glcalllists\n"}
{"id": 623, "subroutine": "        subroutine gllistbase(base) bind(c, name='gllistbase')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: base\n        end subroutine gllistbase\n"}
{"id": 624, "subroutine": "        subroutine glend() bind(c, name='glend')\n        end subroutine glend\n"}
{"id": 625, "subroutine": "        subroutine glvertex2d(x, y) bind(c, name='glvertex2d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n        end subroutine glvertex2d\n"}
{"id": 626, "subroutine": "        subroutine glvertex2f(x, y) bind(c, name='glvertex2f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n        end subroutine glvertex2f\n"}
{"id": 627, "subroutine": "        subroutine glvertex2i(x, y) bind(c, name='glvertex2i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: x\n            integer(kind=glint), intent(in), value :: y\n        end subroutine glvertex2i\n"}
{"id": 628, "subroutine": "        subroutine glvertex2s(x, y) bind(c, name='glvertex2s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n        end subroutine glvertex2s\n"}
{"id": 629, "subroutine": "        subroutine glvertex3d(x, y, z) bind(c, name='glvertex3d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n            real(kind=gldouble), intent(in), value :: z\n        end subroutine glvertex3d\n"}
{"id": 630, "subroutine": "        subroutine glvertex3i(x, y, z) bind(c, name='glvertex3i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: x\n            integer(kind=glint), intent(in), value :: y\n            integer(kind=glint), intent(in), value :: z\n        end subroutine glvertex3i\n"}
{"id": 631, "subroutine": "        subroutine glvertex3s(x, y, z) bind(c, name='glvertex3s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n            integer(kind=glshort), intent(in), value :: z\n        end subroutine glvertex3s\n"}
{"id": 632, "subroutine": "        subroutine glvertex4f(x, y, z, w) bind(c, name='glvertex4f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n            real(kind=glfloat), intent(in), value :: z\n            real(kind=glfloat), intent(in), value :: w\n        end subroutine glvertex4f\n"}
{"id": 633, "subroutine": "        subroutine glvertex4i(x, y, z, w) bind(c, name='glvertex4i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: x\n            integer(kind=glint), intent(in), value :: y\n            integer(kind=glint), intent(in), value :: z\n            integer(kind=glint), intent(in), value :: w\n        end subroutine glvertex4i\n"}
{"id": 634, "subroutine": "        subroutine glvertex4s(x, y, z, w) bind(c, name='glvertex4s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n            integer(kind=glshort), intent(in), value :: z\n            integer(kind=glshort), intent(in), value :: w\n        end subroutine glvertex4s\n"}
{"id": 635, "subroutine": "        subroutine glvertex2dv(v) bind(c, name='glvertex2dv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v\n        end subroutine glvertex2dv\n"}
{"id": 636, "subroutine": "        subroutine glvertex2fv(v) bind(c, name='glvertex2fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glvertex2fv\n"}
{"id": 637, "subroutine": "        subroutine glvertex2iv(v) bind(c, name='glvertex2iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glvertex2iv\n"}
{"id": 638, "subroutine": "        subroutine glvertex3dv(v) bind(c, name='glvertex3dv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v\n        end subroutine glvertex3dv\n"}
{"id": 639, "subroutine": "        subroutine glvertex3fv(v) bind(c, name='glvertex3fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glvertex3fv\n"}
{"id": 640, "subroutine": "        subroutine glvertex3sv(v) bind(c, name='glvertex3sv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glvertex3sv\n"}
{"id": 641, "subroutine": "        subroutine glvertex4fv(v) bind(c, name='glvertex4fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glvertex4fv\n"}
{"id": 642, "subroutine": "        subroutine glvertex4iv(v) bind(c, name='glvertex4iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glvertex4iv\n"}
{"id": 643, "subroutine": "        subroutine glnormal3b(nx, ny, nz) bind(c, name='glnormal3b')\n            import :: glbyte\n            integer(kind=glbyte), intent(in), value :: nx\n            integer(kind=glbyte), intent(in), value :: ny\n            integer(kind=glbyte), intent(in), value :: nz\n        end subroutine glnormal3b\n"}
{"id": 644, "subroutine": "        subroutine glnormal3d(nx, ny, nz) bind(c, name='glnormal3d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: nx\n            real(kind=gldouble), intent(in), value :: ny\n            real(kind=gldouble), intent(in), value :: nz\n        end subroutine glnormal3d\n"}
{"id": 645, "subroutine": "        subroutine glnormal3f(nx, ny, nz) bind(c, name='glnormal3f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: nx\n            real(kind=glfloat), intent(in), value :: ny\n            real(kind=glfloat), intent(in), value :: nz\n        end subroutine glnormal3f\n"}
{"id": 646, "subroutine": "        subroutine glnormal3s(nx, ny, nz) bind(c, name='glnormal3s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: nx\n            integer(kind=glshort), intent(in), value :: ny\n            integer(kind=glshort), intent(in), value :: nz\n        end subroutine glnormal3s\n"}
{"id": 647, "subroutine": "        subroutine glnormal3bv(v) bind(c, name='glnormal3bv')\n            import :: glbyte\n            integer(kind=glbyte), intent(in) :: v\n        end subroutine glnormal3bv\n"}
{"id": 648, "subroutine": "        subroutine glnormal3fv(v) bind(c, name='glnormal3fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glnormal3fv\n"}
{"id": 649, "subroutine": "        subroutine glnormal3iv(v) bind(c, name='glnormal3iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glnormal3iv\n"}
{"id": 650, "subroutine": "        subroutine glnormal3sv(v) bind(c, name='glnormal3sv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glnormal3sv\n"}
{"id": 651, "subroutine": "        subroutine glindexd(c) bind(c, name='glindexd')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: c\n        end subroutine glindexd\n"}
{"id": 652, "subroutine": "        subroutine glindexi(c) bind(c, name='glindexi')\n            import :: glint\n            integer(kind=glint), intent(in), value :: c\n        end subroutine glindexi\n"}
{"id": 653, "subroutine": "        subroutine glindexs(c) bind(c, name='glindexs')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: c\n        end subroutine glindexs\n"}
{"id": 654, "subroutine": "        subroutine glindexub(c) bind(c, name='glindexub')\n            import :: glubyte\n            integer(kind=glubyte), intent(in), value :: c\n        end subroutine glindexub\n"}
{"id": 655, "subroutine": "        subroutine glindexdv(c) bind(c, name='glindexdv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: c\n        end subroutine glindexdv\n"}
{"id": 656, "subroutine": "        subroutine glindexfv(c) bind(c, name='glindexfv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: c\n        end subroutine glindexfv\n"}
{"id": 657, "subroutine": "        subroutine glindexiv(c) bind(c, name='glindexiv')\n            import :: glint\n            integer(kind=glint), intent(in) :: c\n        end subroutine glindexiv\n"}
{"id": 658, "subroutine": "        subroutine glindexsv(c) bind(c, name='glindexsv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: c\n        end subroutine glindexsv\n"}
{"id": 659, "subroutine": "        subroutine glindexubv(c) bind(c, name='glindexubv')\n            import :: glubyte\n            integer(kind=glubyte), intent(in) :: c\n        end subroutine glindexubv\n"}
{"id": 660, "subroutine": "        subroutine glcolor3b(red, green, blue) bind(c, name='glcolor3b')\n            import :: glbyte\n            integer(kind=glbyte), intent(in), value :: red\n            integer(kind=glbyte), intent(in), value :: green\n            integer(kind=glbyte), intent(in), value :: blue\n        end subroutine glcolor3b\n"}
{"id": 661, "subroutine": "        subroutine glcolor3d(red, green, blue) bind(c, name='glcolor3d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: red\n            real(kind=gldouble), intent(in), value :: green\n            real(kind=gldouble), intent(in), value :: blue\n        end subroutine glcolor3d\n"}
{"id": 662, "subroutine": "        subroutine glcolor3f(red, green, blue) bind(c, name='glcolor3f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: red\n            real(kind=glfloat), intent(in), value :: green\n            real(kind=glfloat), intent(in), value :: blue\n        end subroutine glcolor3f\n"}
{"id": 663, "subroutine": "        subroutine glcolor3i(red, green, blue) bind(c, name='glcolor3i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: red\n            integer(kind=glint), intent(in), value :: green\n            integer(kind=glint), intent(in), value :: blue\n        end subroutine glcolor3i\n"}
{"id": 664, "subroutine": "        subroutine glcolor3ub(red, green, blue) bind(c, name='glcolor3ub')\n            import :: glubyte\n            integer(kind=glubyte), intent(in), value :: red\n            integer(kind=glubyte), intent(in), value :: green\n            integer(kind=glubyte), intent(in), value :: blue\n        end subroutine glcolor3ub\n"}
{"id": 665, "subroutine": "        subroutine glcolor3ui(red, green, blue) bind(c, name='glcolor3ui')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: red\n            integer(kind=gluint), intent(in), value :: green\n            integer(kind=gluint), intent(in), value :: blue\n        end subroutine glcolor3ui\n"}
{"id": 666, "subroutine": "        subroutine glcolor3us(red, green, blue) bind(c, name='glcolor3us')\n            import :: glushort\n            integer(kind=glushort), intent(in), value :: red\n            integer(kind=glushort), intent(in), value :: green\n            integer(kind=glushort), intent(in), value :: blue\n        end subroutine glcolor3us\n"}
{"id": 667, "subroutine": "        subroutine glcolor4b(red, green, blue, alpha) bind(c, name='glcolor4b')\n            import :: glbyte\n            integer(kind=glbyte), intent(in), value :: red\n            integer(kind=glbyte), intent(in), value :: green\n            integer(kind=glbyte), intent(in), value :: blue\n            integer(kind=glbyte), intent(in), value :: alpha\n        end subroutine glcolor4b\n"}
{"id": 668, "subroutine": "        subroutine glcolor4f(red, green, blue, alpha) bind(c, name='glcolor4f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: red\n            real(kind=glfloat), intent(in), value :: green\n            real(kind=glfloat), intent(in), value :: blue\n            real(kind=glfloat), intent(in), value :: alpha\n        end subroutine glcolor4f\n"}
{"id": 669, "subroutine": "        subroutine glcolor4i(red, green, blue, alpha) bind(c, name='glcolor4i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: red\n            integer(kind=glint), intent(in), value :: green\n            integer(kind=glint), intent(in), value :: blue\n            integer(kind=glint), intent(in), value :: alpha\n        end subroutine glcolor4i\n"}
{"id": 670, "subroutine": "        subroutine glcolor4ub(red, green, blue, alpha) bind(c, name='glcolor4ub')\n            import :: glubyte\n            integer(kind=glubyte), intent(in), value :: red\n            integer(kind=glubyte), intent(in), value :: green\n            integer(kind=glubyte), intent(in), value :: blue\n            integer(kind=glubyte), intent(in), value :: alpha\n        end subroutine glcolor4ub\n"}
{"id": 671, "subroutine": "        subroutine glcolor4us(red, green, blue, alpha) bind(c, name='glcolor4us')\n            import :: glushort\n            integer(kind=glushort), intent(in), value :: red\n            integer(kind=glushort), intent(in), value :: green\n            integer(kind=glushort), intent(in), value :: blue\n            integer(kind=glushort), intent(in), value :: alpha\n        end subroutine glcolor4us\n"}
{"id": 672, "subroutine": "        subroutine glcolor3bv(v) bind(c, name='glcolor3bv')\n            import :: glbyte\n            integer(kind=glbyte), intent(in) :: v\n        end subroutine glcolor3bv\n"}
{"id": 673, "subroutine": "        subroutine glcolor3iv(v) bind(c, name='glcolor3iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glcolor3iv\n"}
{"id": 674, "subroutine": "        subroutine glcolor3sv(v) bind(c, name='glcolor3sv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glcolor3sv\n"}
{"id": 675, "subroutine": "        subroutine glcolor3ubv(v) bind(c, name='glcolor3ubv')\n            import :: glubyte\n            integer(kind=glubyte), intent(in) :: v\n        end subroutine glcolor3ubv\n"}
{"id": 676, "subroutine": "        subroutine glcolor3uiv(v) bind(c, name='glcolor3uiv')\n            import :: gluint\n            integer(kind=gluint), intent(in) :: v\n        end subroutine glcolor3uiv\n"}
{"id": 677, "subroutine": "        subroutine glcolor3usv(v) bind(c, name='glcolor3usv')\n            import :: glushort\n            integer(kind=glushort), intent(in) :: v\n        end subroutine glcolor3usv\n"}
{"id": 678, "subroutine": "        subroutine glcolor4dv(v) bind(c, name='glcolor4dv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v\n        end subroutine glcolor4dv\n"}
{"id": 679, "subroutine": "        subroutine glcolor4iv(v) bind(c, name='glcolor4iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glcolor4iv\n"}
{"id": 680, "subroutine": "        subroutine glcolor4ubv(v) bind(c, name='glcolor4ubv')\n            import :: glubyte\n            integer(kind=glubyte), intent(in) :: v\n        end subroutine glcolor4ubv\n"}
{"id": 681, "subroutine": "        subroutine glcolor4uiv(v) bind(c, name='glcolor4uiv')\n            import :: gluint\n            integer(kind=gluint), intent(in) :: v\n        end subroutine glcolor4uiv\n"}
{"id": 682, "subroutine": "        subroutine glcolor4usv(v) bind(c, name='glcolor4usv')\n            import :: glushort\n            integer(kind=glushort), intent(in) :: v\n        end subroutine glcolor4usv\n"}
{"id": 683, "subroutine": "        subroutine gltexcoord1d(s) bind(c, name='gltexcoord1d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: s\n        end subroutine gltexcoord1d\n"}
{"id": 684, "subroutine": "        subroutine gltexcoord1f(s) bind(c, name='gltexcoord1f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: s\n        end subroutine gltexcoord1f\n"}
{"id": 685, "subroutine": "        subroutine gltexcoord1i(s) bind(c, name='gltexcoord1i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: s\n        end subroutine gltexcoord1i\n"}
{"id": 686, "subroutine": "        subroutine gltexcoord1s(s) bind(c, name='gltexcoord1s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: s\n        end subroutine gltexcoord1s\n"}
{"id": 687, "subroutine": "        subroutine gltexcoord2d(s, t) bind(c, name='gltexcoord2d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: s\n            real(kind=gldouble), intent(in), value :: t\n        end subroutine gltexcoord2d\n"}
{"id": 688, "subroutine": "        subroutine gltexcoord2f(s, t) bind(c, name='gltexcoord2f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: s\n            real(kind=glfloat), intent(in), value :: t\n        end subroutine gltexcoord2f\n"}
{"id": 689, "subroutine": "        subroutine gltexcoord2i(s, t) bind(c, name='gltexcoord2i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: s\n            integer(kind=glint), intent(in), value :: t\n        end subroutine gltexcoord2i\n"}
{"id": 690, "subroutine": "        subroutine gltexcoord2s(s, t) bind(c, name='gltexcoord2s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n        end subroutine gltexcoord2s\n"}
{"id": 691, "subroutine": "        subroutine gltexcoord3d(s, t, r) bind(c, name='gltexcoord3d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: s\n            real(kind=gldouble), intent(in), value :: t\n            real(kind=gldouble), intent(in), value :: r\n        end subroutine gltexcoord3d\n"}
{"id": 692, "subroutine": "        subroutine gltexcoord3f(s, t, r) bind(c, name='gltexcoord3f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: s\n            real(kind=glfloat), intent(in), value :: t\n            real(kind=glfloat), intent(in), value :: r\n        end subroutine gltexcoord3f\n"}
{"id": 693, "subroutine": "        subroutine gltexcoord3i(s, t, r) bind(c, name='gltexcoord3i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: s\n            integer(kind=glint), intent(in), value :: t\n            integer(kind=glint), intent(in), value :: r\n        end subroutine gltexcoord3i\n"}
{"id": 694, "subroutine": "        subroutine gltexcoord3s(s, t, r) bind(c, name='gltexcoord3s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n            integer(kind=glshort), intent(in), value :: r\n        end subroutine gltexcoord3s\n"}
{"id": 695, "subroutine": "        subroutine gltexcoord4d(s, t, r, q) bind(c, name='gltexcoord4d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: s\n            real(kind=gldouble), intent(in), value :: t\n            real(kind=gldouble), intent(in), value :: r\n            real(kind=gldouble), intent(in), value :: q\n        end subroutine gltexcoord4d\n"}
{"id": 696, "subroutine": "        subroutine gltexcoord4f(s, t, r, q) bind(c, name='gltexcoord4f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: s\n            real(kind=glfloat), intent(in), value :: t\n            real(kind=glfloat), intent(in), value :: r\n            real(kind=glfloat), intent(in), value :: q\n        end subroutine gltexcoord4f\n"}
{"id": 697, "subroutine": "        subroutine gltexcoord4s(s, t, r, q) bind(c, name='gltexcoord4s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n            integer(kind=glshort), intent(in), value :: r\n            integer(kind=glshort), intent(in), value :: q\n        end subroutine gltexcoord4s\n"}
{"id": 698, "subroutine": "        subroutine gltexcoord1fv(v) bind(c, name='gltexcoord1fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine gltexcoord1fv\n"}
{"id": 699, "subroutine": "        subroutine gltexcoord2dv(v) bind(c, name='gltexcoord2dv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v\n        end subroutine gltexcoord2dv\n"}
{"id": 700, "subroutine": "        subroutine gltexcoord2fv(v) bind(c, name='gltexcoord2fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine gltexcoord2fv\n"}
{"id": 701, "subroutine": "        subroutine gltexcoord3dv(v) bind(c, name='gltexcoord3dv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v\n        end subroutine gltexcoord3dv\n"}
{"id": 702, "subroutine": "        subroutine gltexcoord3fv(v) bind(c, name='gltexcoord3fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine gltexcoord3fv\n"}
{"id": 703, "subroutine": "        subroutine gltexcoord3iv(v) bind(c, name='gltexcoord3iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine gltexcoord3iv\n"}
{"id": 704, "subroutine": "        subroutine glrasterpos2d(x, y) bind(c, name='glrasterpos2d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n        end subroutine glrasterpos2d\n"}
{"id": 705, "subroutine": "        subroutine glrasterpos2f(x, y) bind(c, name='glrasterpos2f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n        end subroutine glrasterpos2f\n"}
{"id": 706, "subroutine": "        subroutine glrasterpos2i(x, y) bind(c, name='glrasterpos2i')\n            import :: glint\n            integer(kind=glint), intent(in), value :: x\n            integer(kind=glint), intent(in), value :: y\n        end subroutine glrasterpos2i\n"}
{"id": 707, "subroutine": "        subroutine glrasterpos2s(x, y) bind(c, name='glrasterpos2s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n        end subroutine glrasterpos2s\n"}
{"id": 708, "subroutine": "        subroutine glrasterpos3s(x, y, z) bind(c, name='glrasterpos3s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n            integer(kind=glshort), intent(in), value :: z\n        end subroutine glrasterpos3s\n"}
{"id": 709, "subroutine": "        subroutine glrasterpos4d(x, y, z, w) bind(c, name='glrasterpos4d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x\n            real(kind=gldouble), intent(in), value :: y\n            real(kind=gldouble), intent(in), value :: z\n            real(kind=gldouble), intent(in), value :: w\n        end subroutine glrasterpos4d\n"}
{"id": 710, "subroutine": "        subroutine glrasterpos4f(x, y, z, w) bind(c, name='glrasterpos4f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: x\n            real(kind=glfloat), intent(in), value :: y\n            real(kind=glfloat), intent(in), value :: z\n            real(kind=glfloat), intent(in), value :: w\n        end subroutine glrasterpos4f\n"}
{"id": 711, "subroutine": "        subroutine glrasterpos4s(x, y, z, w) bind(c, name='glrasterpos4s')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x\n            integer(kind=glshort), intent(in), value :: y\n            integer(kind=glshort), intent(in), value :: z\n            integer(kind=glshort), intent(in), value :: w\n        end subroutine glrasterpos4s\n"}
{"id": 712, "subroutine": "        subroutine glrasterpos2sv(v) bind(c, name='glrasterpos2sv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glrasterpos2sv\n"}
{"id": 713, "subroutine": "        subroutine glrasterpos3iv(v) bind(c, name='glrasterpos3iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glrasterpos3iv\n"}
{"id": 714, "subroutine": "        subroutine glrasterpos4fv(v) bind(c, name='glrasterpos4fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glrasterpos4fv\n"}
{"id": 715, "subroutine": "        subroutine glrasterpos4iv(v) bind(c, name='glrasterpos4iv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v\n        end subroutine glrasterpos4iv\n"}
{"id": 716, "subroutine": "        subroutine glrasterpos4sv(v) bind(c, name='glrasterpos4sv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glrasterpos4sv\n"}
{"id": 717, "subroutine": "        subroutine glrectd(x1, y1, x2, y2) bind(c, name='glrectd')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: x1\n            real(kind=gldouble), intent(in), value :: y1\n            real(kind=gldouble), intent(in), value :: x2\n            real(kind=gldouble), intent(in), value :: y2\n        end subroutine glrectd\n"}
{"id": 718, "subroutine": "        subroutine glrecti(x1, y1, x2, y2) bind(c, name='glrecti')\n            import :: glint\n            integer(kind=glint), intent(in), value :: x1\n            integer(kind=glint), intent(in), value :: y1\n            integer(kind=glint), intent(in), value :: x2\n            integer(kind=glint), intent(in), value :: y2\n        end subroutine glrecti\n"}
{"id": 719, "subroutine": "        subroutine glrects(x1, y1, x2, y2) bind(c, name='glrects')\n            import :: glshort\n            integer(kind=glshort), intent(in), value :: x1\n            integer(kind=glshort), intent(in), value :: y1\n            integer(kind=glshort), intent(in), value :: x2\n            integer(kind=glshort), intent(in), value :: y2\n        end subroutine glrects\n"}
{"id": 720, "subroutine": "        subroutine glrectdv(v1, v2) bind(c, name='glrectdv')\n            import :: gldouble\n            real(kind=gldouble), intent(in) :: v1\n            real(kind=gldouble), intent(in) :: v2\n        end subroutine glrectdv\n"}
{"id": 721, "subroutine": "        subroutine glrectfv(v1, v2) bind(c, name='glrectfv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: v1\n            real(kind=glfloat), intent(in) :: v2\n        end subroutine glrectfv\n"}
{"id": 722, "subroutine": "        subroutine glrectiv(v1, v2) bind(c, name='glrectiv')\n            import :: glint\n            integer(kind=glint), intent(in) :: v1\n            integer(kind=glint), intent(in) :: v2\n        end subroutine glrectiv\n"}
{"id": 723, "subroutine": "        subroutine glrectsv(v1, v2) bind(c, name='glrectsv')\n            import :: glshort\n            integer(kind=glshort), intent(in) :: v1\n            integer(kind=glshort), intent(in) :: v2\n        end subroutine glrectsv\n"}
{"id": 724, "subroutine": "        subroutine glvertexpointer(size, type, stride, ptr) bind(c, name='glvertexpointer')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glint),   intent(in), value :: size\n            integer(kind=glenum),  intent(in), value :: type\n            integer(kind=glsizei), intent(in), value :: stride\n            type(c_ptr),           intent(in), value :: ptr\n        end subroutine glvertexpointer\n"}
{"id": 725, "subroutine": "        subroutine glnormalpointer(type, stride, ptr) bind(c, name='glnormalpointer')\n            import :: glenum, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: type\n            integer(kind=glsizei), intent(in), value :: stride\n            type(c_ptr),           intent(in), value :: ptr\n        end subroutine glnormalpointer\n"}
{"id": 726, "subroutine": "        subroutine gledgeflagpointer(stride, ptr) bind(c, name='gledgeflagpointer')\n            import :: glsizei, c_ptr\n            integer(kind=glsizei), intent(in), value :: stride\n            type(c_ptr),           intent(in), value :: ptr\n        end subroutine gledgeflagpointer\n"}
{"id": 727, "subroutine": "        subroutine glgetpointerv(pname, params) bind(c, name='glgetpointerv')\n            import :: glenum, c_ptr\n            integer(kind=glenum), intent(in), value :: pname\n            type(c_ptr),          intent(in)        :: params\n        end subroutine glgetpointerv\n"}
{"id": 728, "subroutine": "        subroutine glarrayelement(i) bind(c, name='glarrayelement')\n            import :: glint\n            integer(kind=glint), intent(in), value :: i\n        end subroutine glarrayelement\n"}
{"id": 729, "subroutine": "        subroutine gldrawarrays(mode, first, count) bind(c, name='gldrawarrays')\n            import :: glenum, glint, glsizei\n            integer(kind=glenum),  intent(in), value :: mode\n            integer(kind=glint),   intent(in), value :: first\n            integer(kind=glsizei), intent(in), value :: count\n        end subroutine gldrawarrays\n"}
{"id": 730, "subroutine": "        subroutine gldrawelements(mode, count, type, indices) bind(c, name='gldrawelements')\n            import :: glenum, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: mode\n            integer(kind=glsizei), intent(in), value :: count\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: indices\n        end subroutine gldrawelements\n"}
{"id": 731, "subroutine": "        subroutine glinterleavedarrays(format, stride, pointer) bind(c, name='glinterleavedarrays')\n            import :: glenum, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: format\n            integer(kind=glsizei), intent(in), value :: stride\n            type(c_ptr),           intent(in), value :: pointer\n        end subroutine glinterleavedarrays\n"}
{"id": 732, "subroutine": "        subroutine gllightf(light, pname, param) bind(c, name='gllightf')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: light\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine gllightf\n"}
{"id": 733, "subroutine": "        subroutine gllighti(light, pname, param) bind(c, name='gllighti')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: light\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in), value :: param\n        end subroutine gllighti\n"}
{"id": 734, "subroutine": "        subroutine gllightiv(light, pname, params) bind(c, name='gllightiv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: light\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine gllightiv\n"}
{"id": 735, "subroutine": "        subroutine gllightmodelf(pname, param) bind(c, name='gllightmodelf')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine gllightmodelf\n"}
{"id": 736, "subroutine": "        subroutine gllightmodeli(pname, param) bind(c, name='gllightmodeli')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in), value :: param\n        end subroutine gllightmodeli\n"}
{"id": 737, "subroutine": "        subroutine gllightmodeliv(pname, params) bind(c, name='gllightmodeliv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine gllightmodeliv\n"}
{"id": 738, "subroutine": "        subroutine glmaterialf(face, pname, param) bind(c, name='glmaterialf')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine glmaterialf\n"}
{"id": 739, "subroutine": "        subroutine glmateriali(face, pname, param) bind(c, name='glmateriali')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in), value :: param\n        end subroutine glmateriali\n"}
{"id": 740, "subroutine": "        subroutine glmaterialfv(face, pname, params) bind(c, name='glmaterialfv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in)        :: params(*)\n        end subroutine glmaterialfv\n"}
{"id": 741, "subroutine": "        subroutine glmaterialiv(face, pname, params) bind(c, name='glmaterialiv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine glmaterialiv\n"}
{"id": 742, "subroutine": "        subroutine glgetmaterialiv(face, pname, params) bind(c, name='glgetmaterialiv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine glgetmaterialiv\n"}
{"id": 743, "subroutine": "        subroutine glcolormaterial(face, mode) bind(c, name='glcolormaterial')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: face\n            integer(kind=glenum), intent(in), value :: mode\n        end subroutine glcolormaterial\n"}
{"id": 744, "subroutine": "        subroutine glpixelzoom(xfactor, yfactor) bind(c, name='glpixelzoom')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: xfactor\n            real(kind=glfloat), intent(in), value :: yfactor\n        end subroutine glpixelzoom\n"}
{"id": 745, "subroutine": "        subroutine glpixelstoref(pname, param) bind(c, name='glpixelstoref')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine glpixelstoref\n"}
{"id": 746, "subroutine": "        subroutine glpixelmapfv(map, mapsize, values) bind(c, name='glpixelmapfv')\n            import :: glenum, glfloat, glsizei\n            integer(kind=glenum),  intent(in), value :: map\n            integer(kind=glsizei), intent(in), value :: mapsize\n            real(kind=glfloat),    intent(in)        :: values\n        end subroutine glpixelmapfv\n"}
{"id": 747, "subroutine": "        subroutine glpixelmapuiv(map, mapsize, values) bind(c, name='glpixelmapuiv')\n            import :: glenum, glsizei, gluint\n            integer(kind=glenum),  intent(in), value :: map\n            integer(kind=glsizei), intent(in), value :: mapsize\n            integer(kind=gluint),  intent(in)        :: values\n        end subroutine glpixelmapuiv\n"}
{"id": 748, "subroutine": "        subroutine glgetpixelmapfv(map, values) bind(c, name='glgetpixelmapfv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: map\n            real(kind=glfloat),   intent(in)        :: values\n        end subroutine glgetpixelmapfv\n"}
{"id": 749, "subroutine": "        subroutine glgetpixelmapusv(map, values) bind(c, name='glgetpixelmapusv')\n            import :: glenum, glushort\n            integer(kind=glenum),   intent(in), value :: map\n            integer(kind=glushort), intent(in)        :: values\n        end subroutine glgetpixelmapusv\n"}
{"id": 750, "subroutine": "        subroutine glbitmap(width, height, xorig, yorig, xmove, ymove, bitmap) bind(c, name='glbitmap')\n            import :: glfloat, glsizei, glubyte\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            real(kind=glfloat),    intent(in), value :: xorig\n            real(kind=glfloat),    intent(in), value :: yorig\n            real(kind=glfloat),    intent(in), value :: xmove\n            real(kind=glfloat),    intent(in), value :: ymove\n            integer(kind=glubyte), intent(in)        :: bitmap\n        end subroutine glbitmap\n"}
{"id": 751, "subroutine": "        subroutine glreadpixels(x, y, width, height, format, type, pixels) bind(c, name='glreadpixels')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glenum),  intent(in), value :: format\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: pixels\n        end subroutine glreadpixels\n"}
{"id": 752, "subroutine": "        subroutine gldrawpixels(width, height, format, type, pixels) bind(c, name='gldrawpixels')\n            import :: glenum, glsizei, c_ptr\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glenum),  intent(in), value :: format\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: pixels\n        end subroutine gldrawpixels\n"}
{"id": 753, "subroutine": "        subroutine glcopypixels(x, y, width, height, type) bind(c, name='glcopypixels')\n            import :: glenum, glint, glsizei\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glenum),  intent(in), value :: type\n        end subroutine glcopypixels\n"}
{"id": 754, "subroutine": "        subroutine glstencilfunc(func, ref, mask) bind(c, name='glstencilfunc')\n            import :: glenum, glint, gluint\n            integer(kind=glenum), intent(in), value :: func\n            integer(kind=glint),  intent(in), value :: ref\n            integer(kind=gluint), intent(in), value :: mask\n        end subroutine glstencilfunc\n"}
{"id": 755, "subroutine": "        subroutine glstencilmask(mask) bind(c, name='glstencilmask')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: mask\n        end subroutine glstencilmask\n"}
{"id": 756, "subroutine": "        subroutine glstencilop(fail, zfail, zpass) bind(c, name='glstencilop')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: fail\n            integer(kind=glenum), intent(in), value :: zfail\n            integer(kind=glenum), intent(in), value :: zpass\n        end subroutine glstencilop\n"}
{"id": 757, "subroutine": "        subroutine gltexgend(coord, pname, param) bind(c, name='gltexgend')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: coord\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=gldouble),  intent(in), value :: param\n        end subroutine gltexgend\n"}
{"id": 758, "subroutine": "        subroutine gltexgenf(coord, pname, param) bind(c, name='gltexgenf')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: coord\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine gltexgenf\n"}
{"id": 759, "subroutine": "        subroutine gltexgeniv(coord, pname, params) bind(c, name='gltexgeniv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: coord\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine gltexgeniv\n"}
{"id": 760, "subroutine": "        subroutine glgettexgendv(coord, pname, params) bind(c, name='glgettexgendv')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: coord\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=gldouble),  intent(in)        :: params(*)\n        end subroutine glgettexgendv\n"}
{"id": 761, "subroutine": "        subroutine gltexenvf(target, pname, param) bind(c, name='gltexenvf')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in), value :: param\n        end subroutine gltexenvf\n"}
{"id": 762, "subroutine": "        subroutine glgettexenvfv(target, pname, params) bind(c, name='glgettexenvfv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in)        :: params(*)\n        end subroutine glgettexenvfv\n"}
{"id": 763, "subroutine": "        subroutine gltexparameteri(target, pname, param) bind(c, name='gltexparameteri')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in), value :: param\n        end subroutine gltexparameteri\n"}
{"id": 764, "subroutine": "        subroutine glgettexlevelparameterfv(target, level, pname, params) bind(c, name='glgettexlevelparameterfv')\n            import :: glenum, glfloat, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint),  intent(in), value :: level\n            integer(kind=glenum), intent(in), value :: pname\n            real(kind=glfloat),   intent(in)        :: params(*)\n        end subroutine glgettexlevelparameterfv\n"}
{"id": 765, "subroutine": "        subroutine glgettexlevelparameteriv(target, level, pname, params) bind(c, name='glgettexlevelparameteriv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint),  intent(in), value :: level\n            integer(kind=glenum), intent(in), value :: pname\n            integer(kind=glint),  intent(in)        :: params(*)\n        end subroutine glgettexlevelparameteriv\n"}
{"id": 766, "subroutine": "        subroutine glteximage1d(target, level, internalformat, width, border, format, type, pixels) bind(c, name='glteximage1d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glint),   intent(in), value :: internalformat\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glint),   intent(in), value :: border\n            integer(kind=glenum),  intent(in), value :: format\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: pixels\n        end subroutine glteximage1d\n"}
{"id": 767, "subroutine": "        subroutine glgetteximage(target, level, format, type, pixels) bind(c, name='glgetteximage')\n            import :: glenum, glint, c_ptr\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint),  intent(in), value :: level\n            integer(kind=glenum), intent(in), value :: format\n            integer(kind=glenum), intent(in), value :: type\n            type(c_ptr),          intent(in), value :: pixels\n        end subroutine glgetteximage\n"}
{"id": 768, "subroutine": "        subroutine glgentextures(n, textures) bind(c, name='glgentextures')\n            import :: glsizei, gluint\n            integer(kind=glsizei), intent(in), value :: n\n            integer(kind=gluint),  intent(in)        :: textures(*)\n        end subroutine glgentextures\n"}
{"id": 769, "subroutine": "        subroutine gldeletetextures(n, textures) bind(c, name='gldeletetextures')\n            import :: glsizei, gluint\n            integer(kind=glsizei), intent(in), value :: n\n            integer(kind=gluint),  intent(in)        :: textures(*)\n        end subroutine gldeletetextures\n"}
{"id": 770, "subroutine": "        subroutine glbindtexture(target, texture) bind(c, name='glbindtexture')\n            import :: glenum, gluint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=gluint), intent(in), value :: texture\n        end subroutine glbindtexture\n"}
{"id": 771, "subroutine": "        subroutine glprioritizetextures(n, textures, priorities) bind(c, name='glprioritizetextures')\n            import :: glclampf, glsizei, gluint\n            integer(kind=glsizei), intent(in), value :: n\n            integer(kind=gluint),  intent(in)        :: textures(*)\n            real(kind=glclampf),   intent(in)        :: priorities\n        end subroutine glprioritizetextures\n"}
{"id": 772, "subroutine": "        subroutine gltexsubimage1d(target, level, xoffset, width, format, type, pixels) bind(c, name='gltexsubimage1d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glint),   intent(in), value :: xoffset\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glenum) , intent(in), value :: format\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: pixels\n        end subroutine gltexsubimage1d\n"}
{"id": 773, "subroutine": "        subroutine gltexsubimage2d(target, level, xoffset, yoffset, width, height, format, type, pixels) &\n                bind(c, name='gltexsubimage2d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glint),   intent(in), value :: xoffset\n            integer(kind=glint),   intent(in), value :: yoffset\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glenum),  intent(in), value :: format\n            integer(kind=glenum),  intent(in), value :: type\n            type(c_ptr),           intent(in), value :: pixels\n        end subroutine gltexsubimage2d\n"}
{"id": 774, "subroutine": "        subroutine glcopyteximage1d(target, level, internalformat, x, y, width, border) bind(c, name='glcopyteximage1d')\n            import :: glenum, glint, glsizei\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glenum),  intent(in), value :: internalformat\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glint),   intent(in), value :: border\n        end subroutine glcopyteximage1d\n"}
{"id": 775, "subroutine": "        subroutine glcopyteximage2d(target, level, internalformat, x, y, width, height, border) bind(c, name='glcopyteximage2d')\n            import :: glenum, glint, glsizei\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glenum),  intent(in), value :: internalformat\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glint),   intent(in), value :: border\n        end subroutine glcopyteximage2d\n"}
{"id": 776, "subroutine": "        subroutine glcopytexsubimage1d(target, level, xoffset, x, y, width) bind(c, name='glcopytexsubimage1d')\n            import :: glenum, glint, glsizei\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glint),   intent(in), value :: xoffset\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n        end subroutine glcopytexsubimage1d\n"}
{"id": 777, "subroutine": "        subroutine glcopytexsubimage2d(target, level, xoffset, yoffset, x, y, width, height) bind(c, name='glcopytexsubimage2d')\n            import :: glenum, glint, glsizei\n            integer(kind=glenum),  intent(in), value :: target\n            integer(kind=glint),   intent(in), value :: level\n            integer(kind=glint),   intent(in), value :: xoffset\n            integer(kind=glint),   intent(in), value :: yoffset\n            integer(kind=glint),   intent(in), value :: x\n            integer(kind=glint),   intent(in), value :: y\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n        end subroutine glcopytexsubimage2d\n"}
{"id": 778, "subroutine": "        subroutine glmap1d(target, u1, u2, stride, order, points) bind(c, name='glmap1d')\n            import :: gldouble, glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble),  intent(in), value :: u1\n            real(kind=gldouble),  intent(in), value :: u2\n            integer(kind=glint),  intent(in), value :: stride\n            integer(kind=glint),  intent(in), value :: order\n            real(kind=gldouble),  intent(in)        :: points\n        end subroutine glmap1d\n"}
{"id": 779, "subroutine": "        subroutine glmap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) bind(c, name='glmap2d')\n            import :: gldouble, glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble),  intent(in), value :: u1\n            real(kind=gldouble),  intent(in), value :: u2\n            integer(kind=glint),  intent(in), value :: ustride\n            integer(kind=glint),  intent(in), value :: uorder\n            real(kind=gldouble),  intent(in), value :: v1\n            real(kind=gldouble),  intent(in), value :: v2\n            integer(kind=glint),  intent(in), value :: vstride\n            integer(kind=glint),  intent(in), value :: vorder\n            real(kind=gldouble),  intent(in)        :: points\n        end subroutine glmap2d\n"}
{"id": 780, "subroutine": "        subroutine glmap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) bind(c, name='glmap2f')\n            import :: glenum, glfloat, glint\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=glfloat),   intent(in), value :: u1\n            real(kind=glfloat),   intent(in), value :: u2\n            integer(kind=glint),  intent(in), value :: ustride\n            integer(kind=glint),  intent(in), value :: uorder\n            real(kind=glfloat),   intent(in), value :: v1\n            real(kind=glfloat),   intent(in), value :: v2\n            integer(kind=glint),  intent(in), value :: vstride\n            integer(kind=glint),  intent(in), value :: vorder\n            real(kind=glfloat),   intent(in)        :: points\n        end subroutine glmap2f\n"}
{"id": 781, "subroutine": "        subroutine glgetmapfv(target, query, v) bind(c, name='glgetmapfv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: query\n            real(kind=glfloat),   intent(in)        :: v\n        end subroutine glgetmapfv\n"}
{"id": 782, "subroutine": "        subroutine glgetmapiv(target, query, v) bind(c, name='glgetmapiv')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glenum), intent(in), value :: query\n            integer(kind=glint),  intent(in)        :: v\n        end subroutine glgetmapiv\n"}
{"id": 783, "subroutine": "        subroutine glevalcoord1d(u) bind(c, name='glevalcoord1d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: u\n        end subroutine glevalcoord1d\n"}
{"id": 784, "subroutine": "        subroutine glevalcoord1fv(u) bind(c, name='glevalcoord1fv')\n            import :: glfloat\n            real(kind=glfloat), intent(in) :: u\n        end subroutine glevalcoord1fv\n"}
{"id": 785, "subroutine": "        subroutine glevalcoord2d(u, v) bind(c, name='glevalcoord2d')\n            import :: gldouble\n            real(kind=gldouble), intent(in), value :: u\n            real(kind=gldouble), intent(in), value :: v\n        end subroutine glevalcoord2d\n"}
{"id": 786, "subroutine": "        subroutine glevalcoord2f(u, v) bind(c, name='glevalcoord2f')\n            import :: glfloat\n            real(kind=glfloat), intent(in), value :: u\n            real(kind=glfloat), intent(in), value :: v\n        end subroutine glevalcoord2f\n"}
{"id": 787, "subroutine": "        subroutine glmapgrid1d(un, u1, u2) bind(c, name='glmapgrid1d')\n            import :: gldouble, glint\n            integer(kind=glint), intent(in), value :: un\n            real(kind=gldouble), intent(in), value :: u1\n            real(kind=gldouble), intent(in), value :: u2\n        end subroutine glmapgrid1d\n"}
{"id": 788, "subroutine": "        subroutine glmapgrid1f(un, u1, u2) bind(c, name='glmapgrid1f')\n            import :: glfloat, glint\n            integer(kind=glint), intent(in), value :: un\n            real(kind=glfloat),  intent(in), value :: u1\n            real(kind=glfloat),  intent(in), value :: u2\n        end subroutine glmapgrid1f\n"}
{"id": 789, "subroutine": "        subroutine glmapgrid2d(un, u1, u2, vn, v1, v2) bind(c, name='glmapgrid2d')\n            import :: gldouble, glint\n            integer(kind=glint), intent(in), value :: un\n            real(kind=gldouble), intent(in), value :: u1\n            real(kind=gldouble), intent(in), value :: u2\n            integer(kind=glint), intent(in), value :: vn\n            real(kind=gldouble), intent(in), value :: v1\n            real(kind=gldouble), intent(in), value :: v2\n        end subroutine glmapgrid2d\n"}
{"id": 790, "subroutine": "        subroutine glevalpoint1(i) bind(c, name='glevalpoint1')\n            import :: glint\n            integer(kind=glint), intent(in), value :: i\n        end subroutine glevalpoint1\n"}
{"id": 791, "subroutine": "        subroutine glevalpoint2(i, j) bind(c, name='glevalpoint2')\n            import :: glint\n            integer(kind=glint), intent(in), value :: i\n            integer(kind=glint), intent(in), value :: j\n        end subroutine glevalpoint2\n"}
{"id": 792, "subroutine": "        subroutine glevalmesh1(mode, i1, i2) bind(c, name='glevalmesh1')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: mode\n            integer(kind=glint),  intent(in), value :: i1\n            integer(kind=glint),  intent(in), value :: i2\n        end subroutine glevalmesh1\n"}
{"id": 793, "subroutine": "        subroutine glevalmesh2(mode, i1, i2, j1, j2) bind(c, name='glevalmesh2')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: mode\n            integer(kind=glint),  intent(in), value :: i1\n            integer(kind=glint),  intent(in), value :: i2\n            integer(kind=glint),  intent(in), value :: j1\n            integer(kind=glint),  intent(in), value :: j2\n        end subroutine glevalmesh2\n"}
{"id": 794, "subroutine": "        subroutine glfeedbackbuffer(size, type, buffer) bind(c, name='glfeedbackbuffer')\n            import :: glenum, glfloat, glsizei\n            integer(kind=glsizei), intent(in), value :: size\n            integer(kind=glenum),  intent(in), value :: type\n            real(kind=glfloat),    intent(in)        :: buffer\n        end subroutine glfeedbackbuffer\n"}
{"id": 795, "subroutine": "        subroutine glselectbuffer(size, buffer) bind(c, name='glselectbuffer')\n            import :: glsizei, gluint\n            integer(kind=glsizei), intent(in), value :: size\n            integer(kind=gluint),  intent(in)        :: buffer\n        end subroutine glselectbuffer\n"}
{"id": 796, "subroutine": "        subroutine glinitnames() bind(c, name='glinitnames')\n        end subroutine glinitnames\n"}
{"id": 797, "subroutine": "        subroutine glloadname(name) bind(c, name='glloadname')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: name\n        end subroutine glloadname\n"}
{"id": 798, "subroutine": "        subroutine glpushname(name) bind(c, name='glpushname')\n            import :: gluint\n            integer(kind=gluint), intent(in), value :: name\n        end subroutine glpushname\n"}
{"id": 799, "subroutine": "        subroutine glpopname() bind(c, name='glpopname')\n        end subroutine glpopname\n"}
{"id": 800, "subroutine": "        subroutine glactivetexture(texture) bind(c, name='glactivetexture')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: texture\n        end subroutine glactivetexture\n"}
{"id": 801, "subroutine": "        subroutine glclientactivetexture(texture) bind(c, name='glclientactivetexture')\n            import :: glenum\n            integer(kind=glenum), intent(in), value :: texture\n        end subroutine glclientactivetexture\n"}
{"id": 802, "subroutine": "        subroutine glcompressedteximage2d(target, level, internalformat, width, height, border, imagesize, data) &\n                bind(c, name='glcompressedteximage2d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: level\n            integer(kind=glenum), intent(in), value :: internalformat\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glint), intent(in), value :: border\n            integer(kind=glsizei), intent(in), value :: imagesize\n            type(c_ptr), intent(in), value :: data\n        end subroutine glcompressedteximage2d\n"}
{"id": 803, "subroutine": "        subroutine glcompressedtexsubimage1d(target, level, xoffset, width, format, imagesize, data) &\n                bind(c, name='glcompressedtexsubimage1d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: level\n            integer(kind=glint), intent(in), value :: xoffset\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glenum), intent(in), value :: format\n            integer(kind=glsizei), intent(in), value :: imagesize\n            type(c_ptr), intent(in), value :: data\n        end subroutine glcompressedtexsubimage1d\n"}
{"id": 804, "subroutine": "        subroutine glcompressedtexsubimage2d(target, level, xoffset, yoffset, width, height, format, imagesize, data) &\n                bind(c, name='glcompressedtexsubimage2d')\n            import :: glenum, glint, glsizei, c_ptr\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: level\n            integer(kind=glint), intent(in), value :: xoffset\n            integer(kind=glint), intent(in), value :: yoffset\n            integer(kind=glsizei), intent(in), value :: width\n            integer(kind=glsizei), intent(in), value :: height\n            integer(kind=glenum), intent(in), value :: format\n            integer(kind=glsizei), intent(in), value :: imagesize\n            type(c_ptr), intent(in), value :: data\n        end subroutine glcompressedtexsubimage2d\n"}
{"id": 805, "subroutine": "        subroutine glgetcompressedteximage(target, lod, img) bind(c, name='glgetcompressedteximage')\n            import :: glenum, glint, c_ptr\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: lod\n            type(c_ptr), intent(in), value :: img\n        end subroutine glgetcompressedteximage\n"}
{"id": 806, "subroutine": "        subroutine glmultitexcoord1d(target, s) bind(c, name='glmultitexcoord1d')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble), intent(in), value :: s\n        end subroutine glmultitexcoord1d\n"}
{"id": 807, "subroutine": "        subroutine glmultitexcoord1fv(target, v) bind(c, name='glmultitexcoord1fv')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=glfloat), intent(in) :: v\n        end subroutine glmultitexcoord1fv\n"}
{"id": 808, "subroutine": "        subroutine glmultitexcoord1sv(target, v) bind(c, name='glmultitexcoord1sv')\n            import :: glenum, glshort\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glshort), intent(in) :: v\n        end subroutine glmultitexcoord1sv\n"}
{"id": 809, "subroutine": "        subroutine glmultitexcoord2d(target, s, t) bind(c, name='glmultitexcoord2d')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble), intent(in), value :: s\n            real(kind=gldouble), intent(in), value :: t\n        end subroutine glmultitexcoord2d\n"}
{"id": 810, "subroutine": "        subroutine glmultitexcoord2f(target, s, t) bind(c, name='glmultitexcoord2f')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=glfloat), intent(in), value :: s\n            real(kind=glfloat), intent(in), value :: t\n        end subroutine glmultitexcoord2f\n"}
{"id": 811, "subroutine": "        subroutine glmultitexcoord2i(target, s, t) bind(c, name='glmultitexcoord2i')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: s\n            integer(kind=glint), intent(in), value :: t\n        end subroutine glmultitexcoord2i\n"}
{"id": 812, "subroutine": "        subroutine glmultitexcoord2s(target, s, t) bind(c, name='glmultitexcoord2s')\n            import :: glenum, glshort\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n        end subroutine glmultitexcoord2s\n"}
{"id": 813, "subroutine": "        subroutine glmultitexcoord3dv(target, v) bind(c, name='glmultitexcoord3dv')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble), intent(in) :: v\n        end subroutine glmultitexcoord3dv\n"}
{"id": 814, "subroutine": "        subroutine glmultitexcoord3f(target, s, t, r) bind(c, name='glmultitexcoord3f')\n            import :: glenum, glfloat\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=glfloat), intent(in), value :: s\n            real(kind=glfloat), intent(in), value :: t\n            real(kind=glfloat), intent(in), value :: r\n        end subroutine glmultitexcoord3f\n"}
{"id": 815, "subroutine": "        subroutine glmultitexcoord3i(target, s, t, r) bind(c, name='glmultitexcoord3i')\n            import :: glenum, glint\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glint), intent(in), value :: s\n            integer(kind=glint), intent(in), value :: t\n            integer(kind=glint), intent(in), value :: r\n        end subroutine glmultitexcoord3i\n"}
{"id": 816, "subroutine": "        subroutine glmultitexcoord3s(target, s, t, r) bind(c, name='glmultitexcoord3s')\n            import :: glenum, glshort\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n            integer(kind=glshort), intent(in), value :: r\n        end subroutine glmultitexcoord3s\n"}
{"id": 817, "subroutine": "        subroutine glmultitexcoord4d(target, s, t, r, q) bind(c, name='glmultitexcoord4d')\n            import :: gldouble, glenum\n            integer(kind=glenum), intent(in), value :: target\n            real(kind=gldouble), intent(in), value :: s\n            real(kind=gldouble), intent(in), value :: t\n            real(kind=gldouble), intent(in), value :: r\n            real(kind=gldouble), intent(in), value :: q\n        end subroutine glmultitexcoord4d\n"}
{"id": 818, "subroutine": "        subroutine glmultitexcoord4s(target, s, t, r, q) bind(c, name='glmultitexcoord4s')\n            import :: glenum, glshort\n            integer(kind=glenum), intent(in), value :: target\n            integer(kind=glshort), intent(in), value :: s\n            integer(kind=glshort), intent(in), value :: t\n            integer(kind=glshort), intent(in), value :: r\n            integer(kind=glshort), intent(in), value :: q\n        end subroutine glmultitexcoord4s\n"}
{"id": 819, "subroutine": "   subroutine do_fft(ndat,n3,time,tela,success)\n\n      implicit none\n\n      ! dimension parameters\n      integer, intent(in) :: ndat, n3\n      real(kind=8), intent(out) :: time,tela\n      logical, intent(out) :: success\n      ! local variables\n      integer :: count1,count2,count_rate,count_max,i,inzee,i_sign\n      real(kind=8) :: t1,t2\n      ! parameters for fft\n      integer :: nd3, nddat\n      ! general array\n      real(kind=8), allocatable :: zin(:,:)\n      ! arrays for fft \n      real(kind=8), allocatable :: z(:,:,:)\n\n      nd3=n3+1\n      nddat=ndat+1\n\n      ! allocations\n      allocate(zin(2,ndat*n3))\n      allocate(z(2,nddat*nd3,2))\n\n      do i=1,nddat*nd3\n         z(1,i,1)=0.d0\n         z(2,i,1)=0.d0\n         z(1,i,2)=0.d0\n         z(2,i,2)=0.d0\n      end do\n\n      call init(ndat,n3,nddat,nd3,zin,z)\n\n      i_sign=-1\n      inzee=1\n      call cpu_time(t1)\n      call system_clock(count1,count_rate,count_max)      \n      call fft1(ndat,n3,nddat,nd3,z,i_sign,inzee,success)\n      call system_clock(count2,count_rate,count_max)      \n      call cpu_time(t2)\n      time=(t2-t1)\n      tela=(count2-count1)/real(count_rate,kind=8)\n\n      ! de-allocations\n      deallocate(z)\n      deallocate(zin)\n\n   end subroutine do_fft\n"}
{"id": 820, "subroutine": "   subroutine init(ndat,n3,nddat,nd3,zin,z)\n      implicit none\n      !arguments\n      integer, intent(in) :: ndat,n3,nddat,nd3\n      real(kind=8) :: zin(2,ndat,n3),z(2,nddat,nd3)\n      !local variables\n      integer :: id,i3\n      do i3=1,n3\n         do id=1,ndat\n            zin(1,id,i3) = cos(1.23d0*real(id*11 + i3,kind=8))\n            zin(2,id,i3) = sin(3.21d0*real(i3*11 + id,kind=8))\n            z(1,id,i3) = zin(1,id,i3) \n            z(2,id,i3) = zin(2,id,i3) \n         end do\n      end do\n   end subroutine init\n"}
{"id": 821, "subroutine": "   subroutine fft1(ndat,n3,nddat,nd3,z,i_sign,inzee, success)\n\n      use module_fft_sg\n      implicit real(kind=8) (a-h,o-z), integer (i-n)\n\n      !!!$      interface\n      !!!!$        integer ( kind=4 ) function omp_get_num_threads ( )\n      !!!!$        end function omp_get_num_threads\n      !!!$      end interface\n      !!!!$      interface\n      !!!!$        integer ( kind=4 ) function omp_get_thread_num ( )\n      !!!!$        end function omp_get_thread_num\n      !!!!$      end interface\n\n      !arguments\n      integer, intent(in) :: ndat,n3,nddat,nd3,i_sign\n      integer, intent(inout) :: inzee\n      logical, intent(out) :: success\n      real(kind=8), intent(inout) :: z(2,nddat*nd3,2)\n      !local variables\n      real(kind=8), dimension(:,:), allocatable :: trig\n      integer, dimension(n_factors) :: after,now,before\n      real(kind=8), allocatable, dimension(:,:,:) :: zw  \n\n      if (n3.gt.nfft_max) then\n         write(*,*) 'dimension bigger than ', nfft_max\n         stop\n      end if\n\n      success = .true.\n\n      ntrig=n3\n      allocate(trig(2,ntrig))\n\n      ! check whether input values are reasonable\n      if (inzee.le.0 .or. inzee.ge.3) stop 'wrong inzee'\n      if (i_sign.ne.1 .and. i_sign.ne.-1) stop 'wrong i_sign'\n      if (n3.gt.nd3) stop 'n3>nd3'\n       \n      ! vector computer with memory banks:\n      if (ncache.eq.0) then\n         call ctrig_sg(n3,ntrig,trig,after,before,now,i_sign,ic)\n         nfft=ndat\n         mm=nddat\n         do i=1,ic-1\n            call fftstp_sg(mm,nfft,nd3,mm,nd3,z(1,1,inzee),z(1,1,3-inzee), &\n                           ntrig,trig,after(i),now(i),before(i),i_sign)\n            inzee=3-inzee\n         end do\n         i=ic\n         call fftrot_sg(mm,nfft,nd3,mm,nd3,z(1,1,inzee),z(1,1,3-inzee), &\n              ntrig,trig,after(i),now(i),before(i),i_sign)\n         inzee=3-inzee\n\n\n      ! risc machine with cache:\n      else\n         ! intel ifc does not understand default(private)\n         !!!!!$omp parallel  default(private) &\n         !!!!$omp parallel & \n         !!!!$omp private(zw,trig,before,after,now,i,j,iam,npr,jj,ma,mb,mm,ic,n,m,jompa,jompb,lot,lotomp,inzeep,inzet,nn,nfft) &\n         !!!!$omp shared(n1,n2,n3,nd1,nd2,nd3,z,i_sign,inzee,ncache) \n         npr=1\n         !!!!$       npr=omp_get_num_threads()\n         iam=0\n         !!!!$       iam=omp_get_thread_num()\n         !      write(6,*) 'npr,iam',npr,iam\n         ! critical section only necessary on intel\n         !!!!$omp critical\n         allocate(zw(2,ncache/4,2))\n         !!!!$omp end critical\n\n         inzet=inzee\n         ! transform along z axis\n\n         mm=nddat\n         m=nd3\n         lot=max(1,ncache/(4*n3))\n         nn=lot\n         n=n3\n         if (2*n*lot*2.gt.ncache) then\n            write(*,\"(a)\",advance=\"no\") 'stop ncache1'\n            success = .false.\n            return\n         end if\n\n         call ctrig_sg(n3,ntrig,trig,after,before,now,i_sign,ic)\n\n         if (ic.eq.1) then\n            i=ic\n            lotomp=(ndat)/npr+1\n            ma=iam*lotomp+1\n            mb=min((iam+1)*lotomp,ndat)\n            nfft=mb-ma+1\n            j=ma\n            jj=j*nd3-nd3+1\n            call fftrot_sg(mm,nfft,m,mm,m,z(1,j,inzet),z(1,jj,3-inzet), &\n                           ntrig,trig,after(i),now(i),before(i),i_sign)\n\n         else\n\n            lotomp=(ndat)/npr+1\n            jompa=iam*lotomp+1\n            jompb=min((iam+1)*lotomp,ndat)\n            do j=jompa,jompb,lot\n               ma=j\n               mb=min(j+(lot-1),jompb)\n               nfft=mb-ma+1\n               jj=j*nd3-nd3+1\n              \n               i=1\n               inzeep=2\n               call fftstp_sg(mm,nfft,m,nn,n,z(1,j,inzet),zw(1,1,3-inzeep), &\n                              ntrig,trig,after(i),now(i),before(i),i_sign)\n               inzeep=1\n              \n               do i=2,ic-1\n                  call fftstp_sg(nn,nfft,n,nn,n,zw(1,1,inzeep),zw(1,1,3-inzeep), &\n                                 ntrig,trig,after(i),now(i),before(i),i_sign)\n                  inzeep=3-inzeep\n               end do\n               i=ic\n               call fftrot_sg(nn,nfft,n,mm,m,zw(1,1,inzeep),z(1,jj,3-inzet), &\n                              ntrig,trig,after(i),now(i),before(i),i_sign)\n            end do\n         end if\n\n         inzet=3-inzet\n\n         !!!!!!!!!$omp barrier\n\n         deallocate(zw)\n         if (iam.eq.0) inzee=inzet\n\n      end if\n      deallocate(trig)\n\n   end subroutine fft1\n"}
{"id": 822, "subroutine": "  subroutine sim_message(message, iunit, fmt, level,                             &\n                         skipbefore, skipafter, advance)\n    ! -- dummy variables\n    character(len=*), intent(in) :: message              !< message to write to iunit\n    integer(i4b), intent(in), optional :: iunit          !< optional file unit to write the message to (default=stdout)\n    character(len=*), intent(in), optional :: fmt        !< optional format to write the message (default='(a)')\n    integer(i4b), intent(in), optional :: level          !< optional level for the message (default=summary)\n    integer(i4b), intent(in), optional :: skipbefore     !< optional number of empty lines before message (default=0)\n    integer(i4b), intent(in), optional :: skipafter      !< optional number of empty lines after message (default=0)\n    logical(lgp), intent(in), optional :: advance        !< optional boolean indicating if advancing output (default is .true.)\n    ! -- local variables\n    character(len=3) :: cadvance\n    integer(i4b) :: i\n    integer(i4b) :: ilen\n    integer(i4b) :: iu\n    integer(i4b) :: ilevel\n    character(len=lenhugeline) :: simfmt\n    character(len=*), parameter :: stdfmt = '(a)'\n    character(len=*), parameter :: emptyfmt = '()'\n    !\n    ! -- initialize local variables\n    ilen = len_trim(message)\n    !\n    ! -- process optional dummy variables\n    if (present(iunit)) then\n      iu = iunit\n    else\n      iu = istdout\n    end if\n    if (present(fmt)) then\n      simfmt = fmt\n    else\n      if (ilen > 0) then\n        simfmt = stdfmt\n      else\n        simfmt = emptyfmt\n      end if\n    end if\n    if (present(level)) then\n      ilevel = level\n    else\n      ilevel = vsummary\n    end if\n    if (present(advance)) then\n      if (advance) then\n        cadvance = 'yes'\n      else\n        cadvance = 'no'\n      end if\n    else\n      cadvance = 'yes'\n    end if\n    !\n    ! -- write empty line before message\n    if (present(skipbefore)) then\n      do i = 1, skipbefore\n        write(iu, *)\n      end do\n    end if\n    !\n    ! -- write message if the level of the message is less than\n    !    or equal the isim_level for the simulation\n    if (ilevel <= isim_level) then\n      if (ilen > 0) then\n        write(iu, trim(simfmt), advance=cadvance) message(1:ilen)\n      else\n        write(iu, trim(simfmt), advance=cadvance)\n      end if\n    end if\n    !\n    ! -- write empty line after message\n    if (present(skipafter)) then\n      do i = 1, skipafter\n        write(iu, *)\n      end do\n    end if\n    !\n    ! -- return\n    return\n  end subroutine sim_message\n"}
{"id": 823, "subroutine": "  subroutine write_message(message, icount, iwidth, iunit, level, &\n                           skipbefore, skipafter)\n    ! -- dummy variables\n    character (len=*), intent(in) :: message          !< message to be written\n    integer(i4b), intent(in), optional :: icount      !< counter to prepended to the message  \n    integer(i4b), intent(in), optional :: iwidth      !< maximum width of the prepended counter\n    integer(i4b), intent(in), optional :: iunit       !< the unit number to which the message is written\n    integer(i4b), intent(in), optional :: level       !< level of message (vsummary, vall, vdebug)\n    integer(i4b), intent(in), optional :: skipbefore  !< optional number of empty lines before message (default=0)\n    integer(i4b), intent(in), optional :: skipafter   !< optional number of empty lines after message (default=0)\n    ! -- local variables\n    integer(i4b), parameter    :: len_line=78\n    character(len=lenhugeline) :: amessage\n    character(len=len_line)    :: line\n    character(len=16)          :: cfmt\n    character(len=10)          :: counter\n    character(len=5)           :: fmt_first\n    character(len=20)          :: fmt_cont\n    logical(lgp)               :: include_counter\n    integer(i4b)               :: isb\n    integer(i4b)               :: isa\n    integer(i4b)               :: jend\n    integer(i4b)               :: len_str1\n    integer(i4b)               :: len_str2\n    integer(i4b)               :: len_message\n    integer(i4b)               :: junit\n    integer(i4b)               :: ilevel\n    integer(i4b)               :: i\n    integer(i4b)               :: j\n    !\n    ! -- return if no message is passed\n    if (len_trim(message) < 1) then\n      return\n    end if\n    !\n    ! -- initialize local variables\n    amessage = message\n    counter = ''\n    fmt_first = '(a)'\n    fmt_cont = '(a)'\n    len_str1 = 0\n    len_str2 = len_line\n    include_counter = .false.\n    junit = istdout\n    j = 0\n  !\n    ! -- process optional dummy variables\n    ! -- set the unit number\n    if(present(iunit))then\n      if (iunit > 0) then\n        junit = iunit\n      end if\n    end if\n    !\n    ! -- set the message level\n    if (present(level)) then\n      ilevel = level\n    else\n      ilevel = vsummary\n    end if\n    !\n    ! -- set skip before\n    if (present(skipbefore)) then\n      isb = skipbefore\n    else\n      isb = 0\n    end if\n    !\n    ! -- set skip after\n    if (present(skipafter)) then\n      isa = skipafter\n    else\n      isa = 0\n    end if\n    !\n    ! -- create the counter to prepend to the start of the message,\n    !    formats, and variables used to create strings \n    if (present(iwidth) .and. present(icount)) then\n      include_counter = .true.\n      ! -- write counter\n      write(cfmt, '(a,i0,a)') '(1x,i', iwidth, ',\".\",1x)'\n      write(counter, cfmt) icount\n      ! -- calculate the length of the first and second string on a line\n      len_str1 = len(trim(counter)) + 1\n      len_str2 = len_line - len_str1\n      ! -- write format for the continuation lines\n      write(fmt_cont, '(a,i0,a)') &\n        '(',len(trim(counter)) + 1, 'x,a)'\n    end if\n    !\n    ! -- calculate the length of the message\n    len_message = len_trim(amessage)\n    !\n    ! -- parse the amessage into multiple lines\n5   continue\n    jend = j + len_str2\n    if (jend >= len_message) go to 100\n    do i = jend, j+1, -1\n      if (amessage(i:i).eq.' ') then\n        if (j == 0) then\n          if (include_counter) then\n            line = counter(1:len_str1)//amessage(j+1:i)\n          else\n            line = amessage(j+1:i)\n          end if\n          call sim_message(line, iunit=junit, &\n                           fmt=fmt_first, level=ilevel, &\n                           skipbefore=isb)\n        else\n          line = adjustl(amessage(j+1:i))\n          call sim_message(line, iunit=junit, &\n                           fmt=fmt_cont, level=ilevel)\n        end if\n        j = i\n        go to 5\n      end if\n    end do\n    if (j == 0) then\n      if (include_counter) then\n        line = counter(1:len_str1)//amessage(j+1:jend)\n      else\n        line = amessage(j+1:jend)\n      end if\n      call sim_message(line, iunit=junit, &\n                       fmt=fmt_first, level=ilevel, &\n                       skipbefore=isb)\n    else\n      line = amessage(j+1:jend)\n      call sim_message(line, iunit=junit, &\n                       fmt=fmt_cont, level=ilevel)\n    end if\n    j = jend\n    go to 5\n    !\n    ! -- last piece of amessage to write to a line\n100 continue\n    jend = len_message\n    if (j == 0) then\n      if (include_counter) then\n        line = counter(1:len_str1)//amessage(j+1:jend)\n      else\n        line = amessage(j+1:jend)\n      end if\n      call sim_message(line, iunit=junit, &\n                       fmt=fmt_first, level=ilevel, &\n                       skipbefore=isb, skipafter=isa)\n    else\n      line = amessage(j+1:jend)\n      call sim_message(line, iunit=junit, fmt=fmt_cont, &\n                       level=ilevel, &\n                       skipafter=isa)\n    end if\n    !\n    ! -- return\n    return\n  end subroutine write_message\n"}
{"id": 824, "subroutine": "  subroutine write_centered(text, linelen, iunit)\n    ! -- dummy variables\n    character(len=*), intent(in) :: text            !< message to write to iunit\n    integer(i4b), intent(in) :: linelen             !< length of line to center text in\n    integer(i4b), intent(in), optional :: iunit     !< optional file unit to write text (default=stdout)\n    ! -- local variables\n    character(len=linelen) :: line\n    character(len=linelen) :: blank\n    integer(i4b) :: iu\n    integer(i4b) :: len_message\n    integer(i4b) :: jend\n    integer(i4b) :: ipad\n    integer(i4b) :: i\n    integer(i4b) :: j\n    !\n    ! -- process optional parameters\n    if (present(iunit)) then\n      iu = iunit\n    else\n      iu = istdout\n    end if\n    !\n    ! -- process text\n    if (iu > 0) then\n      !\n      ! -- initialize local variables\n      blank = ''\n      len_message = len_trim(adjustl(text))\n      j = 0\n      !\n      ! -- parse the amessage into multiple lines\n5     continue\n      jend = j + linelen\n      if (jend >= len_message) go to 100\n      do i = jend, j+1, -1\n        if (text(i:i).eq.' ') then\n          line = text(j+1:i)\n          ipad = ((linelen - len_trim(line)) / 2) \n          call sim_message(blank(1:ipad)//line, iunit=iu)\n          j = i\n          go to 5\n        end if\n      end do\n      line = text(j+1:jend)\n      ipad = ((linelen - len_trim(line)) / 2) \n      call sim_message(blank(1:ipad)//line, iunit=iu)\n      j = jend\n      go to 5\n      !\n      ! -- last piece of amessage to write to a line\n100   continue\n      jend = len_message\n      line = text(j+1:jend)\n      ipad = ((linelen - len_trim(line)) / 2) \n      call sim_message(blank(1:ipad)//line, iunit=iu)\n    end if\n    !\n    ! -- return\n    return\n  end subroutine write_centered\n"}
{"id": 825, "subroutine": "  subroutine stop_with_error(ierr)\n    ! -- dummy variables\n    integer(i4b), intent(in), optional :: ierr  !< optional error code to return (default=0)\n    ! -- local variables\n    integer(i4b) :: ireturn_err\n    !\n    ! -- process optional dummy variables\n    if (present(ierr)) then\n      ireturn_err = ierr\n    else\n      ireturn_err = 0\n    end if\n  \n    ! -- return the correct return code\n    call exit(ireturn_err)\n  \n  end subroutine stop_with_error  \n"}
{"id": 826, "subroutine": "subroutine flux_calc_kernel(x_min,x_max,y_min,y_max,z_min,z_max,dt, &\n                            xarea,                                  &\n                            yarea,                                  &\n                            zarea,                                  &\n                            xvel0,                                  &\n                            yvel0,                                  &\n                            zvel0,                                  &\n                            xvel1,                                  &\n                            yvel1,                                  &\n                            zvel1,                                  &\n                            vol_flux_x,                             &\n                            vol_flux_y,                             &\n                            vol_flux_z                              )\n\n  implicit none\n\n  integer       :: x_min, x_max, y_min, y_max, z_min, z_max\n  real(kind=8) :: dt\n  real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2,z_min-2:z_max+2) :: xarea\n  real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3,z_min-2:z_max+2) :: yarea\n  real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2,z_min-2:z_max+3) :: zarea\n  real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3,z_min-2:z_max+3) :: xvel0,yvel0,zvel0\n  real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3,z_min-2:z_max+3) :: xvel1,yvel1,zvel1\n  real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2,z_min-2:z_max+2) :: vol_flux_x\n  real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3,z_min-2:z_max+2) :: vol_flux_y\n  real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2,z_min-2:z_max+3) :: vol_flux_z\n\n  integer :: j,k,l\n\n!$omp parallel\n\n!$omp do\n  do l=z_min,z_max\n    do k=y_min,y_max\n      do j=x_min,x_max+1\n        vol_flux_x(j,k,l)=0.125_8*dt*xarea(j,k,l)                  &\n                         *(xvel0(j,k,l)+xvel0(j,k+1,l)+xvel0(j,k,l+1)+xvel0(j,k+1,l+1) &\n                          +xvel1(j,k,l)+xvel1(j,k+1,l)+xvel1(j,k,l+1)+xvel1(j,k+1,l+1))\n      enddo\n    enddo\n  enddo\n!$omp end do\n\n!$omp do\n  do l=z_min,z_max\n    do k=y_min,y_max+1\n      do j=x_min,x_max\n        vol_flux_y(j,k,l)=0.125_8*dt*yarea(j,k,l)                  &\n                         *(yvel0(j,k,l)+yvel0(j+1,k,l)+yvel0(j,k,l+1)+yvel0(j+1,k,l+1) &\n                          +yvel1(j,k,l)+yvel1(j+1,k,l)+yvel1(j,k,l+1)+yvel1(j+1,k,l+1))\n      enddo\n    enddo\n  enddo\n!$omp end do\n\n!$omp do\n  do l=z_min,z_max+1\n    do k=y_min,y_max\n      do j=x_min,x_max\n        vol_flux_z(j,k,l)=0.125_8*dt*zarea(j,k,l)                  &\n                         *(zvel0(j,k,l)+zvel0(j+1,k,l)+zvel0(j+1,k,l)+zvel0(j+1,k+1,l) &\n                          +zvel1(j,k,l)+zvel1(j+1,k,l)+zvel1(j,k+1,l)+zvel1(j+1,k+1,l))\n      enddo\n    enddo\n  enddo\n!$omp end do\n\n!$omp end parallel\n\nend subroutine flux_calc_kernel\n"}
{"id": 827, "subroutine": "  subroutine tra_bbc(kt)\n    integer, intent(in) :: kt\n    integer :: ji, jj\n    real(kind = wp), allocatable, dimension(:, :, :) :: ztrdt\n    if (ln_timing) call timing_start('tra_bbc')\n    if (l_trdtra) then\n      allocate(ztrdt(jpi, jpj, jpk))\n      !$acc kernels\n      ztrdt(:, :, :) = tsa(:, :, :, jp_tem)\n      !$acc end kernels\n    end if\n    !$acc kernels\n    do jj = 2, jpjm1\n      do ji = 2, jpim1\n        tsa(ji, jj, mbkt(ji, jj), jp_tem) = tsa(ji, jj, mbkt(ji, jj), jp_tem) + qgh_trd0(ji, jj) / e3t_n(ji, jj, mbkt(ji, jj))\n      end do\n    end do\n    !$acc end kernels\n    call lbc_lnk(tsa(:, :, :, jp_tem), 't', 1.)\n    if (l_trdtra) then\n      !$acc kernels\n      ztrdt(:, :, :) = tsa(:, :, :, jp_tem) - ztrdt(:, :, :)\n      !$acc end kernels\n      call trd_tra(kt, 'tra', jp_tem, jptra_bbc, ztrdt)\n      deallocate(ztrdt)\n    end if\n    if (ln_ctl) call prt_ctl(tab3d_1 = tsa(:, :, :, jp_tem), clinfo1 = ' bbc  - ta: ', mask1 = tmask, clinfo3 = 'tra-ta')\n    if (ln_timing) call timing_stop('tra_bbc')\n  end subroutine tra_bbc\n"}
{"id": 828, "subroutine": "  subroutine tra_bbc_init\n    integer :: ji, jj\n    integer :: inum\n    integer :: ios\n    integer :: ierror\n    type(fld_n) :: sn_qgh\n    character(len = 256) :: cn_dir\n    namelist /nambbc/ ln_trabbc, nn_geoflx, rn_geoflx_cst, sn_qgh, cn_dir\n    rewind(unit = numnam_ref)\n    read(numnam_ref, nambbc, iostat = ios, err = 901)\n901 if (ios /= 0) call ctl_nam(ios, 'nambbc in reference namelist', lwp)\n    rewind(unit = numnam_cfg)\n    read(numnam_cfg, nambbc, iostat = ios, err = 902)\n902 if (ios > 0) call ctl_nam(ios, 'nambbc in configuration namelist', lwp)\n    if (lwm) write(numond, nambbc)\n    if (lwp) then\n      write(numout, fmt = *)\n      write(numout, fmt = *) 'tra_bbc : bottom boundary condition (bbc), apply a geothermal heating'\n      write(numout, fmt = *) '~~~~~~~   '\n      write(numout, fmt = *) '   namelist nambbc : set bbc parameters'\n      write(numout, fmt = *) '      apply a geothermal heating at ocean bottom   ln_trabbc     = ', ln_trabbc\n      write(numout, fmt = *) '      type of geothermal flux                      nn_geoflx     = ', nn_geoflx\n      write(numout, fmt = *) '      constant geothermal flux value               rn_geoflx_cst = ', rn_geoflx_cst\n      write(numout, fmt = *)\n    end if\n    if (ln_trabbc) then\n      allocate(qgh_trd0(jpi, jpj))\n      select case (nn_geoflx)\n      case (1)\n        if (lwp) write(numout, fmt = *) '   ==>>>   constant heat flux  =   ', rn_geoflx_cst\n        !$acc kernels\n        qgh_trd0(:, :) = r1_rau0_rcp * rn_geoflx_cst\n        !$acc end kernels\n      case (2)\n        if (lwp) write(numout, fmt = *) '   ==>>>   variable geothermal heat flux'\n        allocate(sf_qgh(1), stat = ierror)\n        if (ierror > 0) then\n          call ctl_stop('tra_bbc_init: unable to allocate sf_qgh structure')\n          return\n        end if\n        allocate(sf_qgh(1) % fnow(jpi, jpj, 1))\n        if (sn_qgh % ln_tint) allocate(sf_qgh(1) % fdta(jpi, jpj, 1, 2))\n        call fld_fill(sf_qgh, (/sn_qgh/), cn_dir, 'tra_bbc_init', 'bottom temperature boundary condition', 'nambbc', no_print)\n        call fld_read(nit000, 1, sf_qgh)\n        qgh_trd0(:, :) = r1_rau0_rcp * sf_qgh(1) % fnow(:, :, 1) * 1.e-3\n      case default\n        write(ctmp1, fmt = *) '     bad flag value for nn_geoflx = ', nn_geoflx\n        call ctl_stop(ctmp1)\n      end select\n    else\n      if (lwp) write(numout, fmt = *) '   ==>>>   no geothermal heat flux'\n    end if\n  end subroutine tra_bbc_init\n"}
{"id": 829, "subroutine": "subroutine assemblytoarray(a,e,ndofn,elrhs,array)\n   use typre\n   use mod_element\n   use mod_mesh\n   implicit none\n   class(femmesh) :: a\n   class(finiteelement) :: e\n   integer(ip) :: ndofn\n   real(rp) :: elrhs(ndofn,*),array(ndofn,*)\n   \n   integer(ip) :: inode,ipoin,phang,jspos,jpoin,jhang\n   real(rp) :: jweight\n   \n   !usual\n   if (a%kfl_hangingnodes .eqv. .false.) then\n      !do not vectorize since they can repeat!!\n      do inode = 1,e%pnode\n         array(:,e%lnods(inode)) = array(:,e%lnods(inode)) + elrhs(:,inode)\n      enddo\n      !do not vectorize since they can repeat!\n      !array(:,e%lnods(1:e%pnode)) = array(:,e%lnods(1:e%pnode)) + elrhs(:,1:e%pnode)\n   \n   !hanging nodes\n   else\n      call a%assemblytoarrayhanging(e,ndofn,elrhs,array)\n   endif\nend subroutine\n"}
{"id": 830, "subroutine": "subroutine write_header(n)\nuse m_strings\n!--------------------------------------\n! the current solution is only for linux\n! as it binds fortran with linux shell\n! the more appropriate would be connect\n! fortran with c/c++ or python\n!--------------------------------------\nimplicit none\n\ninteger, intent(in)                     :: n\ncharacter(len=120)                      :: line\ncharacter(len=32)                       :: username\ncharacter(len=120), allocatable         :: array(:)\ninteger                                 :: date(8)\n\nwrite(n, 10)\ncall system('uname -a > _tmp')\nopen(unit=1,file='_tmp')\nread(1,'(a)') line\nclose(1)\ncall system('rm _tmp')\ncall split(line,array)\ncall getlog(username)\nwrite(n, '(1x,a,15x,a)') 'user: ',username\nwrite(n, '(1x,a,15x,a,/,1x,a,13x,a,1x,/,1x,a,2x,a)') 'host: ',array(2),'system: ',trim(array(15)),&\n'hardware platform: ',array(13)\n\ncall date_and_time(values=date)\n!***************************** now print them to the output file\nwrite(n,'(1x,a,6x,i4,5(a,i2.2))') 'date and time :', &\ndate(1), '/', date(2), '/', date(3), ' ', date(5), ':', &\ndate(6), ':', date(7)\n\nwrite(n, 12)\nwrite(n, 13)\n\n\n10 format(/,4x,'*******************************************************', &\n           /4x,'~~~~~~~~~ intrinsic reaction coordinate fit ~~~~~~~~~~~',  &\n           /4x,'                  ~~~~~ v. 2021.1 ~~~~~               ',  &\n           /4x,'*******************************************************',/)\n\n11 format('a')\n\n12 format(/,/,1x,'   irc is experimental code to fit explicit 1-d crossing potentials', &\n          /,1x,'              for the spin-forbidden reaction at hand.', &\n          /,1x,'   the program is distributed free of charge and there is no implied warranty.', &\n          /,1x,'   the code distribution is not allowed without written permission from the authors.')\n\n13 format(/,/,1x,'authors in alphabetical order:',&\n          /,1x,'-------------------------------------------------------------', &\n          /,1x,'ilya d. dergachev,             university of nevada, reno',&\n          /,1x,'vsevolod d. dergachev          university of nevada, reno',&\n          /,1x,'aleksandr o. lykhin,           university of nevada, reno',&\n          /,1x,'robert mauban,                 university of nevada, reno',&\n          /,1x,'mitra rooein,                  university of nevada, reno',&\n          /,1x,'sergey a. varganov             university of nevada, reno',&\n          /1x,'-------------------------------------------------------------',/)\n\nend subroutine write_header\n"}
{"id": 831, "subroutine": "subroutine write_output(input_file,n_prod)\n\nuse irc_data\n\nimplicit none\n\ncharacter(len=*), intent(in)    :: input_file\ninteger,          intent(in)    :: n_prod\ninteger                         :: i\ndouble precision                :: en_reac_fit(n1), en_prod_fit(n2)\n\nen_reac_fit = 0.0d0\nen_prod_fit = 0.0d0\n\nwrite(66,12) trim(input_file)\n\n! => fitting of reactan irc points.\n\nif ( (l(1) .eq. 0.0d0) .and. (l(2) .eq. 0.0d0) .and. (l(3) .eq. 0.0d0) ) then\n\n  write(66,13) l(4),l(5),irc_reac(n1),irc_reac(1)\n  en_reac_fit(1:n1) = l(4)*irc_reac(1:n1) + l(5)\n\nelse if ( (l(1) .eq. 0.0d0) .and. (l(2) .eq. 0.0d0)  ) then\n  \n  write(66,14) l(3),l(4),l(5),irc_reac(n1),irc_reac(1)\n  en_reac_fit(1:n1) = l(3)*irc_reac(1:n1)**2 + l(4)*irc_reac(1:n1) + l(5)\n\nelse if ( (l(1) .eq. 0.0d0 ) ) then\n \n  write(66,15) l(2),l(3),l(4),l(5),irc_reac(n1),irc_reac(1)\n  en_reac_fit(1:n1) = l(2)*irc_reac(1:n1)**3 + l(3)*irc_reac(1:n1)**2 + &\n                      l(4)*irc_reac(1:n1) + l(5)\n\nelse\n\n  write(66,16) l(1),l(2),l(3),l(4),l(5),irc_reac(n1),irc_reac(1)\n  en_reac_fit(1:n1) = l(1)*irc_reac(1:n1)**4 + l(2)*irc_reac(1:n1)**3 + &\n                      l(3)*irc_reac(1:n1)**2 + l(4)*irc_reac(1:n1) + l(5) \n\nend if\n\n! => fitting of product irc points.\n\nif ( (h(1) .eq. 0.0d0) .and. (h(2) .eq. 0.0d0) .and. (h(3) .eq. 0.0d0) ) then\n\n  write(66,17) h(4),h(5),irc_prod(n_prod),irc_prod(1)\n  en_prod_fit(1:n_prod) = h(4)*irc_prod(1:n_prod) + h(5)\n\nelse if ( (h(1) .eq. 0.0d0) .and. (h(2) .eq. 0.0d0)) then\n  \n  write(66,18) h(3),h(4),h(5),irc_prod(n1),irc_prod(1)\n  en_prod_fit(1:n_prod) = h(3)*irc_prod(1:n_prod)**2 + h(4)*irc_prod(1:n_prod) + h(5)\n\nelse if ( (h(1) .eq. 0.0d0 ) ) then\n \n  write(66,19) h(2),h(3),h(4),h(5),irc_prod(n_prod),irc_prod(1)\n  en_prod_fit(1:n_prod) = h(2)*irc_prod(1:n_prod)**3 + h(3)*irc_prod(1:n_prod)**2 + &\n                          h(4)*irc_prod(1:n_prod) + h(5)\n\nelse\n\n  write(66,20) h(1),h(2),h(3),h(4),h(5),irc_prod(n_prod),irc_prod(1)\n  en_prod_fit(1:n_prod) = h(1)*irc_prod(1:n_prod)**4 + h(2)*irc_prod(1:n_prod)**3 + &\n                          h(3)*irc_prod(1:n_prod)**2 + h(4)*irc_prod(1:n_prod) + h(5) \n\nend if\n\n! => write raw and fitted data to the output file for comparison\n\nwrite(66,21)\n\ndo i = 1, n1\n   write(66,22) i,irc_reac(i),en_reac(i),en_reac_fit(i)\nend do\n\nwrite(66,23)\n\ndo i = 1, n_prod\n   write(66,22) i,irc_prod(i),en_prod(i),en_prod_fit(i)\nend do\n\n12 format(/,'opening the ',a,' input file')\n\n13 format(/,/,1x,'mecp-reactant minimum energy path has been fit to a line:', &\n          /,/,10x,'f(x) = a1*x + a2, where',/,/,2x, &\n          'a1 = ',f10.5,' a2 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.',&\n          /,3x,'warning! fitting reactant to a line might inidcate that there are not enough irc points.',&\n          /,3x,'use fitting results with caution. consider re-running irc with smaller search step.')\n\n14 format(/,/,1x,'mecp-reactant minimum energy path has been fit to a parabola:', &\n          /,/,10x,'f(x) = a1*x^2 + a2*x + a3, where',/,/,2x, &\n          'a1 = ',f10.5,' a2 = ',f10.5,' a3 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.',&\n          /,3x,'warning! fitting reactant to parabola might indicate there are not enough irc points.',&\n          /,3x,'use fitting results with caution. consider re-running irc with smaller search step.')\n\n15 format(/,/,1x,'mecp-reactant minimum energy path has been fit to a cubic polynomial:', &\n          /,/,10x,'f(x) = a1*x^3 + a2*x^2 + a3*x + a4, where',/,/,2x, &\n          'a1 = ',f10.5,' a2 = ',f10.5,' a3 = ',f10.5,' a4 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.')\n\n16 format(/,/,1x,'mecp-reactant minimum energy path has been fit to a quartic polynomial:', &\n          /,/,10x,'f(x) = a1*x^4 + a2*x^3 + a3*x^2 + a4*x + a5, where',/,/,2x, &\n          'a1 = ',f10.5,' a2 = ',f10.5,' a3 = ',f10.5,' a4 = ',f10.5,' a5 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.')\n\n17 format(/,/,1x,'mecp-product minimum energy path has been fit to a line:', &\n          /,/,10x,'g(x) = b1*x + b2, where',/,/,5x, &\n          'b1 = ',f10.5,' b2 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.',&\n          /,/,3x,'warning! fitting to a line means there are only two irc points on the product minimum energy path',&\n          /,3x,'in the region from mecp to point where product energy is equal to energy at reactant minimum.',&\n          /,3x,'it might be alright, but please consider re-running irc with smaller step size.')\n\n18 format(/,/,1x,'mecp-product minimum energy path has been fit to a parabola:', &\n          /,/,10x,'g(x) = b1*x^2 + b2*x + b3, where',/,/,5x, &\n          'b1 = ',f10.5,' b2 = ',f10.5,' b3 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.',&\n          /,/,3x,'warning! fitting to parabola might indicate there are not enough irc points',&\n          /,3x,'in the region from mecp to point where product energy is equal to energy at reactant minimum.',&\n          /,3x,'it might be alright, but please consider re-running irc with smaller step size.')\n\n19 format(/,/,1x,'mecp-product minimum energy path has been fit to a cubic polynomial:', &\n          /,/,10x,'g(x) = b1*x^3 + b2*x^2 + b3*x + b4, where',/,/,5x, &\n          'b1 = ',f10.5,' b2 = ',f10.5,' b3 = ',f10.5,' b4 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.')\n\n20 format(/,/,1x,'mecp-product minimum energy path has been fit to a quartic polynomial:', &\n          /,/,10x,'g(x) = b1*x^4 + b2*x^3 + b3*x^2 + b4*x + b5, where',/,/,5x, &\n          'b1 = ',f10.5,' b2 = ',f10.5,' b3 = ',f10.5,' b4 = ',f10.5,' b5 = ',f10.5, &\n          /,/,10x,'the polynomial has been fit in the range of [',f5.3,',',f5.3,'] bohr.')\n\n21 format(/,/,1x,'mecp-reactant irc points, energies and energies fit from f(x)', &\n          /,/,6x,'n',9x,'x, bohr',8x,'e, a.u.',6x, 'e_fit, a.u.',/)\n\n22 format(5x,i3,5x,f10.5,5x,f10.5,5x,f10.5)\n\n23 format(/,/,1x,'mecp-product irc points, energies and energies fit from g(x)', &\n          /,/,6x,'n',9x,'x, bohr',8x,'e, a.u.',6x, 'e_fit, a.u.',/)\n\nend subroutine write_output\n"}
{"id": 832, "subroutine": "subroutine write_nast_template(input)\n\nuse irc_data\nuse get_constants\n\nimplicit none\ncharacter(len=*), intent(in)     :: input\ncharacter(len=19)                :: intersect_type\ndouble precision                 :: grad1, grad2, limitl, limitr, e_limitr\n!--------------------------------------------\nopen(unit = 44,access='stream',form='formatted',action = \"write\", file = input)\n\n! write heading to the output file\n\ngrad1 = 0.0d0\ngrad2 = 0.0d0\nlimitl = 0.0d0\nlimitr = 0.0d0\n\nwrite(44,10)\ncall write_header(44)\nwrite(44,'(/,a,f10.5)') 'value of the reaction coordinate at the mecp: x_m = ', irc_reac(1)\n\nif ( (l(1) .eq. 0.0d0) .and. (l(2) .eq. 0.0d0) .and. (l(3) .eq. 0.0d0) ) then\n\n  write(44,'(/,a,f10.5)') \"derivative of the reactant polynomial, df(x)/dx =  \", l(4)\n  \n  grad1 = l(4)\n  write(44,'(/,a,f10.5)') \"df(x)/dx | x_m = \", grad1\n\nelse if ( (l(1) .eq. 0.0d0) .and. (l(2) .eq. 0.0d0)  ) then\n  \n  write(44,'(/,a,f10.5,a,f10.5)') \"derivative of the reactant polynomial, df(x)/dx =  \", &\n                          2.0d0*l(3),'x + ',l(4)\n\n  grad1 = 2.0d0*l(3)*irc_reac(1) + l(4)\n  write(44,'(/,a,f10.5)') \"df(x)/dx | x_m = \", grad1\n\nelse if ( (l(1) .eq. 0.0d0 ) ) then\n \n  write(44,'(/,a,f10.5,a,f10.5,a,f10.5)') \"derivative of the reactant polynomial, df(x)/dx =  \", &\n                       3.0d0*l(2),'x^2 + ',2.0d0*l(3),'x + ',l(4)\n  \n  grad1 = 3.0d0*l(2)*(irc_reac(1)**2) + 2.0d0*l(3)*irc_reac(1) + l(4)\n  write(44,'(/,a,f10.5)') \"df(x)/dx | x_m = \", grad1\n\nelse\n\n  write(44,'(/,a,f10.5,a,f10.5,a,f10.5,a,f10.5)') \"derivative of the reactant polynomial, df(x)/dx =  \", &\n                       4.0d0*l(1),'x^3 + ',3.0d0*l(2),'x^2 + ',2.0d0*l(3),'x + ',l(4)\n  \n  grad1 = 4.0d0*l(1)*(irc_reac(1)**3) + 3.0d0*l(2)*(irc_reac(1)**2) + 2.0d0*l(3)*irc_reac(1) + l(4)\n  write(44,'(/,a,f10.5)') \"df(x)/dx | x_m = \", grad1\n\nend if\n\nif ( (h(1) .eq. 0.0d0) .and. (h(2) .eq. 0.0d0) .and. (h(3) .eq. 0.0d0) ) then\n\n  write(44,'(/,a,f10.5)') \"derivative of the product polynomial, dg(x)/dx =  \", h(4)\n  \n  grad2 = h(4)\n  write(44,'(/,a,f10.5)') \"dg(x)/dx | x_m = \", grad2\n\nelse if ( (h(1) .eq. 0.0d0) .and. (h(2) .eq. 0.0d0)  ) then\n  \n  write(44,'(/,a,f10.5,a,f10.5)') \"derivative of the product polynomial, dg(x)/dx =  \", &\n                          2.0d0*h(3),'x + ',h(4)\n  \n  grad2 = 2.0d0*h(3)*irc_reac(1) + h(4)\n  write(44,'(/,a,f10.5)') \"dg(x)/dx | x_m = \", grad2\n\nelse if ( (h(1) .eq. 0.0d0 ) ) then\n \n  write(44,'(/,a,f10.5,a,f10.5,a,f10.5)') \"derivative of the product polynomial, dg(x)/dx =  \", &\n                       3.0d0*h(2),'x^2 + ',2.0d0*h(3),'x + ',h(4)\n  \n  grad2 = 3.0d0*h(2)*(irc_reac(1)**2) + 2.0d0*h(3)*irc_reac(1) + h(4)\n  write(44,'(/,a,f10.5)') \"dg(x)/dx | x_m = \", grad2\n\nelse\n\n  write(44,'(/,a,f10.5,a,f10.5,a,f10.5,a,f10.5)') \"derivative of the product polynomial, dg(x)/dx =  \", &\n                       4.0d0*h(1),'x^3 + ',3.0d0*h(2),'x^2 + ',2.0d0*h(3),'x + ',h(4)\n  \n  grad2 = 4.0d0*h(1)*(irc_reac(1)**3) + 3.0d0*h(2)*(irc_reac(1)**2) + 2.0d0*h(3)*irc_reac(1) + h(4)\n  write(44,'(/,a,f10.5)') \"dg(x)/dx | x_m = \", grad2\n\nend if\n\nwrite(44,'(/,a,f10.5)') \"derivatives product at x_m: \", grad1*grad2\n\nif (grad1*grad2 < 0) then\n   intersect_type = 'peaked intersection'\nelse\n   intersect_type = 'sloped intersection'\nend if\n\nwrite(44,'(/,a,a)') \"derivatives product indicates \", intersect_type\n\nwrite(44,11)\n\nif (intersect_type == 'peaked intersection') then\n   limitr = irc_prod(n2)\nelse\n   limitr = 2.0d0*irc_reac(1)\n   e_limitr = l(1)*limitr**4 + l(2)*limitr**3 + &\n              l(3)*limitr**2 + l(4)*limitr + l(5)\nend if\n\n\nwrite(44,12) l(1),l(2),l(3),l(4),l(5), &\n             h(1),h(2),h(3),h(4),h(5), &\n             limitl, limitr \n\nwrite(44,13)\n\nif (intersect_type == 'peaked intersection') then\n   write(44,14) irc_prod(n2)\nelse\n   write (44,15) irc_reac(1),en_reac(1),en_reac(1)*au2wavenumber, &\n                 limitr,e_limitr,e_limitr*au2wavenumber\nend if\n\n10 format('=======',/,'=======',/,'=======', &\n          /,/,'this is an nast template input file automatically ',&\n         'genereated by the irc fit code.',&\n         /,'the file contains the polynomial coefficients',&\n         ' needed to run zhu-nakamura approach.', &\n         /,'check nast manual for more details.')\n\n11 format (/,/,'======================================================== ', &\n           /,/,\"     nast &polynomial input group for zhu-nakamura\", &\n           /,/,'========================================================')\n\n12 format(/,\"&polynomials\",/,\"hs4 = \",f10.7,/,\"hs3 = \",f10.7,/,&\n         \"hs2 = \",f10.7,/,\"hs1 = \",f10.7,/, \"hs0 = \",f10.7,/, &\n         \"ls4 = \",f10.7,/,\"ls3 = \",f10.7,/, \"ls2 = \",f10.7,/, &\n         \"ls1 = \",f10.7,/,\"ls0 = \",f10.7,/,\"limitl = \",f5.2,/, &\n         \"limitr = \",f5.2,/,\"&end\")\n\n13 format (/,'=============================== ', &\n           /,/,\"        limitl & limitr\", &\n           /,/,'================================', &\n           /,/,'limitl and limitr are the left and right limits on the x-axis,', &\n           /,'where x is the 1-d reaction coordinate.', &\n           /,/,\"limitl and limitr given above in the &polynomial group are authors' suggestion.\", &\n           /,'feel free to change these defaults at your own risk and understanding.', &\n           /,'an explanation of our choice is given below.', &\n           /,/,'limitr must be greater than limitl. limitl should be chosen at the reactant minimum.',&\n           /,'therefore, limitl is effectively zero: limitl = 0.0.', &\n           /,/,'the choice of limitr depends on the intersection type.')\n\n14 format  (/,'for the peaked intersection, limitr should be chosen as the product minimum,' &\n           /,'which is the final point on the mecp -> product path.', &\n           /,'in this example, the product minimum is at',f5.2,'.',/,/,'fly with us again.')\n\n15 format  (/,'for the sloped intersection, limitr should be chosen so that', &\n           /,'e1 = f(limitr) is well above mecp to ensure convergence.', &\n           /,/,'for that, our default choice is limitr = 2.0 * x_m,', &\n           /,'where x_m is the coordinate of mecp.', &\n           /,/,'in this example, x_m was ',f5.2,', e1(x_m) = ',f10.7,' a.u. (',f11.2,' cm-1 ).', &\n           /,'then, suggested limitr = ',f5.2,', e1(limitr) = ',f10.7,' a.u. (',f11.2,' cm-1 ).',/,/,'fly with us again.')\n\nend subroutine write_nast_template\n"}
{"id": 833, "subroutine": "subroutine foo(a, b, n1, n2)\n  character(len=3), dimension(2, n1) :: a\n  character(len=3), dimension(n2, 2) :: b\n  a = cshift(b,1)\n  a = eoshift(b,1)\nend subroutine foo\n"}
{"id": 834, "subroutine": "        subroutine nc_diag_read_id_get_global_attr_1d_byte(file_ncdr_id, attr_name, attr_stor)\n            integer(i_long), intent(in)                :: file_ncdr_id\n            character(len=*), intent(in)               :: attr_name\n            integer(i_byte), dimension(:), allocatable, intent(inout) :: attr_stor\n            \n            integer(i_long)                            :: attr_len, attr_type, file_ncid\n                        \n            call ncdr_check_ncdr_id(file_ncdr_id)\n            \n            file_ncid = ncdr_files(file_ncdr_id)%ncid\n            call ncdr_check_ncdr_id(file_ncdr_id)\n            \n            call nc_diag_read_id_assert_global_attr(file_ncdr_id, attr_name, attr_type, attr_len)\n            \n            call nc_diag_read_assert_global_attr_type(attr_type, nf90_byte)\n            \n            call nc_diag_read_assert_dims(attr_stor, (/ attr_len /))\n            \n            call ncdr_nc_check(nf90_get_att(file_ncid, &\n                    nf90_global, &\n                    attr_name, &\n                    attr_stor))\n        end subroutine nc_diag_read_id_get_global_attr_1d_byte\n"}
{"id": 835, "subroutine": "        subroutine nc_diag_read_noid_get_global_attr_1d_byte(attr_name, attr_stor)\n            character(len=*), intent(in)             :: attr_name\n            integer(i_byte), dimension(:), allocatable, intent(inout) :: attr_stor\n            \n            call ncdr_check_current_ncdr_id\n            call nc_diag_read_id_get_global_attr_1d_byte(current_ncdr_id, attr_name, attr_stor)\n        end subroutine nc_diag_read_noid_get_global_attr_1d_byte\n"}
{"id": 836, "subroutine": "        subroutine nc_diag_read_noid_get_global_attr_1d_short(attr_name, attr_stor)\n            character(len=*), intent(in)             :: attr_name\n            integer(i_short), dimension(:), allocatable, intent(inout) :: attr_stor\n            \n            call ncdr_check_current_ncdr_id\n            call nc_diag_read_id_get_global_attr_1d_short(current_ncdr_id, attr_name, attr_stor)\n        end subroutine nc_diag_read_noid_get_global_attr_1d_short\n"}
{"id": 837, "subroutine": "        subroutine nc_diag_read_id_get_global_attr_1d_double(file_ncdr_id, attr_name, attr_stor)\n            integer(i_long), intent(in)                :: file_ncdr_id\n            character(len=*), intent(in)               :: attr_name\n            real(r_double), dimension(:), allocatable, intent(inout) :: attr_stor\n            \n            integer(i_long)                            :: attr_len, attr_type, file_ncid\n                        \n            call ncdr_check_ncdr_id(file_ncdr_id)\n            \n            file_ncid = ncdr_files(file_ncdr_id)%ncid\n            call ncdr_check_ncid(file_ncid)\n            \n            call nc_diag_read_id_assert_global_attr(file_ncdr_id, attr_name, attr_type, attr_len)\n            \n            call nc_diag_read_assert_global_attr_type(attr_type, nf90_double)\n            \n            call nc_diag_read_assert_dims(attr_stor, (/ attr_len /))\n            \n            call ncdr_nc_check(nf90_get_att(file_ncid, &\n                    nf90_global, &\n                    attr_name, &\n                    attr_stor))\n        end subroutine nc_diag_read_id_get_global_attr_1d_double\n"}
{"id": 838, "subroutine": "        subroutine nc_diag_read_id_get_global_attr_1d_string(file_ncdr_id, attr_name, attr_stor)\n            integer(i_long), intent(in)                :: file_ncdr_id\n            character(len=*), intent(in)               :: attr_name\n            character(len=:),allocatable,intent(inout) :: attr_stor\n            \n            integer(i_long)                            :: attr_len, attr_type, file_ncid\n                        \n            call ncdr_check_ncdr_id(file_ncdr_id)\n            \n            file_ncid = ncdr_files(file_ncdr_id)%ncid\n            call ncdr_check_ncid(file_ncid)\n            \n            call nc_diag_read_id_assert_global_attr(file_ncdr_id, attr_name, attr_type, attr_len)\n            \n            call nc_diag_read_assert_global_attr_type(attr_type, nf90_char)\n            \n            call nc_diag_read_assert_dims_alloc_string(attr_stor, (/ attr_len /))\n            \n            call ncdr_nc_check(nf90_get_att(file_ncid, &\n                    nf90_global, &\n                    attr_name, &\n                    attr_stor))\n        end subroutine nc_diag_read_id_get_global_attr_1d_string\n"}
{"id": 839, "subroutine": "        subroutine nc_diag_read_noid_get_global_attr_1d_string(attr_name, attr_stor)\n            character(len=*), intent(in)             :: attr_name\n            character(len=:),allocatable,intent(inout) :: attr_stor\n            \n            call ncdr_check_current_ncdr_id\n            call nc_diag_read_id_get_global_attr_1d_string(current_ncdr_id, attr_name, attr_stor)\n        end subroutine nc_diag_read_noid_get_global_attr_1d_string\n"}
{"id": 840, "subroutine": "        subroutine nc_diag_read_noid_get_global_attr_single_byte(attr_name, attr_stor)\n            character(len=*), intent(in)             :: attr_name\n            integer(i_byte)                          :: attr_stor\n            \n            call ncdr_check_current_ncdr_id\n            call nc_diag_read_id_get_global_attr_single_byte(current_ncdr_id, attr_name, attr_stor)\n        end subroutine nc_diag_read_noid_get_global_attr_single_byte\n"}
{"id": 841, "subroutine": "\t\tsubroutine optima(nlay,ddep,vari,varm,error,error_e,error_h,error_c,suma,suma_e,suma_h)      \r\n!**********************************************************************************************\r\n!*****************************************************************\r\n!*\twritten by joaquim perez (08/01/99)\r\n!*\tgenerates the fitting function to be optimized by powell\r\n!*    or genetics algorithm. function from jorgensen 1990, and patterson, 1984\r\n!*\tgivin a layer distribution,the position of the termocline is calculated\r\n!*\tthen, the root mean squared or the normalized rms error of the variable \r\n!*\tcan be estimated by either all of the layers, or separated\r\n!*\tinto epi and hypo contributions.\r\n!*\r\n!*\tvariable list\r\n!*    varm: vector with measured data\r\n!*    vari: vector with simulated data\r\n!*\tw_e, w_h weight functions \r\n!*\tmean_field volumetric mean of the measured variable.\r\n!*    mean_simul volumetric mean of the simulated variable\r\n!*    error = measure of the error within all layers \r\n!*    error_vol = volume-weighted error function\r\n!*\terror_c = error made with epilimnetic and hypolimnetic contributions with weight paramters\r\n!*\terror_e = error made with epilimnetic contribution\r\n!*\terror_h = error made with hypolimnetic contribution\r\n!*    \r\n!*****************************************************************\r\n      use dlmwq_variables      \r\n      use dlmwq_services\r\n\t\timplicit none\r\n      save\r\n\r\n\t\tinteger*4 nlay, nlay_e,nlay_h\r\n\t\tinteger*4 nlayers\r\n\t\tinteger*4 i,j,k\r\n\t\treal*8 mean_field,mean_simul\r\n\t\treal*8 vol_total,vol_total_h,vol_total_e,var_media\r\n     \treal*8 error,error_vol,error_e,error_h,error_c\r\n\t\treal*8 vari(maxns),varm(maxns),ddep(maxns) \r\n\t\treal*8 suma,suma_h,suma_e,suma_vol\r\n\t\treal*8 var_media_h,var_media_t\r\n\t\treal*8 mean_field_e, mean_field_h\r\n\t\treal*8 mean_simul_h, mean_simul_t\r\n\t\treal*8 lake_top,lake_bottom\r\n\t\treal*8 thermdepth\t\r\n\t\treal*8 xp,zc,xmass\r\n\t\treal*8 w_e,w_h\r\n! \r\n!     position of the termocline\r\n! \t\t\r\n\t\tdo i =1,ndays\r\n\t\t\tif(vector_day(i).eq.jday) then\r\n\t\t\t\tthermdepth = vector_thermdepth(i)\r\n\t\t\t\tgoto 4406\r\n\t\t\tendif\r\n\t\tenddo\r\n4406  continue\r\n! \r\n!     initialize variables\r\n! \r\n\t\tnlay_h = 0\r\n\t\tnlay_e = 0\r\n\t\tw_e = 1.0\r\n\t\tw_h = 1.0\r\n\t\tsuma = 0.0\r\n\t\tsuma_h = 0.0\r\n\t\tsuma_e = 0.0 \r\n\t\tsuma_vol = 0.0\r\n\t\terror = 0.0\r\n\t\terror_e = 0.0\r\n\t\terror_h = 0.0\r\n\t\terror_c = 0.0\r\n\t\terror_vol = 0.0\r\n\t\tmean_field = 0.0\r\n      mean_simul = 0.0\r\n\t\tvol_total = 0.0\r\n\t\tvol_total_h = 0.0\r\n\t\tvol_total_e = 0.0\r\n      var_media = 0.0\r\n\t\tvar_media_h = 0.0\r\n\t\tvar_media_t = 0.0\r\n\t\tmean_field_e = 0.0\r\n\t\tmean_field_h = 0.0\r\n\t\tmean_simul_h = 0.0\r\n\t\tmean_simul_t = 0.0  \r\n! \t     \r\n!     rms definition\r\n! \r\n      if (calibration.eq.'rms'.or.calibration.eq.'rms') then \r\n\t\t\tif(thermdepth.eq.-99.0) then    !comment for variables\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tmean_field = mean_field + varm(i)*vol(i)\r\n\t\t\t\t\tmean_simul = mean_simul + vari(i)*vol(i)\r\n\t\t\t\t\tvol_total = vol_total+vol(i) \r\n\t\t\t\t\tsuma = suma + ((vari(i)-varm(i)))**2\r\n\t\t\t\tenddo\r\n\t\t\telse\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tsuma = suma + ((vari(i)-varm(i)))**2\r\n\t\t\t\t\tif (ddep(i).le. xmom) then\r\n\t\t\t\t\t\tnlay_h = nlay_h + 1\r\n\t\t\t\t\t\tmean_field_h = mean_field_h + varm(i)*vol(i)\r\n\t\t\t\t\t\tmean_simul_h = mean_simul_h + vari(i)*vol(i)\r\n\t\t\t\t\t\tvol_total_h = vol_total_h+vol(i)\r\n\t\t\t\t\t\tsuma_h = suma_h + ((vari(i)-varm(i)))**2\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnlay_e = nlay_e + 1\r\n\t\t\t\t\t\tmean_field_e = mean_field_e + varm(i)*vol(i)\r\n\t\t\t\t\t\tmean_simul_t = mean_simul_t + vari(i)*vol(i)\r\n\t\t\t\t\t\tvol_total_e = vol_total_e+vol(i)\r\n\t\t\t\t\t\tsuma_e = suma_e + ((vari(i)-varm(i)))**2\r\n\t\t\t\t\tendif\r\n\t\t\t\tenddo\r\n\t\t\tendif\r\n\r\n\t\t\tif(thermdepth.eq.-99.0) then \r\n\t\t\t\tmean_field = mean_field/vol_total\r\n \t\t\t\tmean_simul = mean_simul/vol_total\r\n\t\t\t\terror     = dsqrt(suma/nlay)\r\n\t\t\t\terror_e   = 0.0\r\n\t\t\t\terror_h   = 0.0\r\n\t\t\t\terror_c   = 0.0\r\n\t\t\t\terror_vol = dsqrt(suma_vol/vol_total)\t\r\n\t\t\telse\r\n\t\t\t\tmean_field =   (mean_field_e/vol_total_e)+ (mean_field_h/vol_total_h)\r\n \t\t\t\tmean_simul =   (mean_simul_t/vol_total_e)+ (mean_simul_h/vol_total_h)\r\n\t\t\t\terror   = dsqrt(suma/nlay)\r\n\t\t\t\terror_e =  w_e*dsqrt(suma_e/nlay_e) \r\n\t\t \r\n\t\t\t\tif(nlay_h.ne.0) then\r\n\t\t\t\t\terror_h = w_h*dsqrt(suma_h/nlay_h)\r\n\t\t\t\t\terror_c   = w_e*dsqrt(suma_e/nlay_e) + w_h*dsqrt(suma_h/nlay_h)\t\r\n\t\t\t\telse\r\n\t\t\t\t\twrite(*,*)' thermocline has reached the bottom'\r\n\t\t\t\t\terror_c = w_e*dsqrt(suma_e/nlay_e) \r\n\t\t\t\tendif\r\n\t\t\tendif\r\n      endif\r\n! \r\n!     psi definition (rms normalized by the mean)\r\n! \r\n\r\n\t\tif(calibration.eq.'psi'.or.calibration.eq.'psi') then\r\n\t\t\tif(thermdepth.eq.0) then    !comment for variables\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tmean_field = mean_field + varm(i)\t \r\n\t\t\t\tenddo\r\n\t\t\t\tmean_field = mean_field/nlay\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tsuma = suma + ((vari(i)-varm(i))/mean_field)**2\r\n\t\t\t\tenddo\t\r\n\t\t\t\terror = dsqrt(suma/nlay)\r\n\t\t\t\terror_e = 0.0\r\n\t\t\t\terror_h = 0.0\r\n\t\t\t\terror_c = 0.0 \r\n\t\t\telse\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tmean_field = mean_field + varm(i)\t\t\r\n\t\t\t\t\tif (ddep(i).le. xmom) then\r\n\t\t\t\t\t\tnlay_h = nlay_h + 1\r\n\t\t\t\t\t\tmean_field_h = mean_field_h + varm(i)\t \r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnlay_e = nlay_e + 1\r\n\t\t\t\t\t\tmean_field_e = mean_field_e + varm(i)\r\n\t\t\t\t\tendif\r\n\t\t\t\tenddo\r\n\t\t\t\tif(nlay_h.ne.0) then\r\n\t\t\t\t\tmean_field_h = mean_field_h / nlay_h\r\n\t\t\t\telse\r\n\t\t\t\t\tmean_field_h = 0.0\r\n\t\t\t\tendif\r\n\t\t\t\tmean_field_e = mean_field_e / nlay_e\r\n\r\n\t\t\t\tdo i = 1,nlay\r\n\t\t\t\t\tsuma = suma + ((vari(i)-varm(i))/mean_field)**2\r\n\t\t\t\t\tif (ddep(i).le. xmom) then\r\n\t\t\t\t\t\tsuma_h = suma_h + ((vari(i)-varm(i))/mean_field_h)**2\r\n\t\t\t\t\telse\t\t \r\n\t\t\t\t\t\tsuma_e = suma_e + ((vari(i)-varm(i))/mean_field_e)**2\r\n\t\t\t\t\tendif\r\n\t\t\t\tenddo\r\n\r\n\t\t\t\terror = dsqrt(suma/nlay)\r\n\t\t\t\terror_e =  w_e*dsqrt(suma_e/nlay_e)\r\n\r\n\t\t\t\tif(nlay_h.ne.0) then\r\n\t\t\t\t\terror_h = w_h*dsqrt(suma_h/nlay_h)\r\n\t\t\t\t\terror_c   = w_e*dsqrt(suma_e/nlay_e) + w_h*dsqrt(suma_h/nlay_h)\t\r\n\t\t\t\telse\r\n\t\t\t\t\twrite(*,*)' thermocline has reached the bottom'\r\n\t\t\t\t\terror_c = w_e*dsqrt(suma_e/nlay_e) \r\n\t\t\t\tendif\r\n\t\t\tendif\r\n\t\tendif\r\n\r\n\t\treturn\t\t\t\t   \r\n\t\tend subroutine optima\n"}
{"id": 842, "subroutine": "subroutine is_monotonic_increasing(a, tol_inc, tol_inc_big, tol_big, name)\n  real(wp), intent(in) :: a(:), tol_inc, tol_inc_big, tol_big\n  character(*), intent(in) :: name\n  \n  integer :: i\n  \n  !> probably better than creating a temporary array\n  do i = 2,size(a)\n    if(a(i) - a(i-1) < tol_inc) then\n      error stop 'grid_check: ' // name // ' is not monotonic increasing'\n    endif\n    if(a(i) - a(i-1) > tol_inc_big) then\n      error stop 'grid_check: ' // name // ' has too large derivative'\n    endif\n  end do\n  \n  !> not too big value\n  if (any(abs(a) > tol_big)) then\n    write(stderr,*) 'error:grid_check: ',name,' has too large values: ', maxval(a)\n    error stop\n  end if\nend subroutine is_monotonic_increasing\n"}
{"id": 843, "subroutine": "   subroutine setpointerscomputegradientprojection(itask)\n      implicit none\n      integer(ip) :: itask\n      select case (itask)   \n      \n      case(0)\n         allocate(kfl_isset)\n         call a%memor%allocobj(0,'kfl_isset','initprocedurepointer',1)\n         kfl_isset = -1\n      \n      case(1)\n         if (kfl_isset == -1) then\n            kfl_isset = 1\n         \n            call concatenateprocedures(prochook%initializations,allocategradproj)\n            call concatenateprocedures(prochook%finalizations,deallocategradproj)\n         \n            call concatenateprocedures(prochook%elmatstozero,gradprojelmatstozero)\n            \n            !now we assembly everything for computing the projection\n            call concatenateprocedures(prochook%ingausselmatsassembly,gradprojtoelgradproj)\n            \n            call concatenateprocedures(prochook%assemblyendite,assemblygradproj)\n            call concatenateprocedures(prochook%postloop,projectgradient)\n\n         endif  \n      case(100)\n         deallocate(kfl_isset)\n         call a%memor%deallocobj(0,'kfl_isset','initprocedurepointer',1)\n      \n      end select\n   end subroutine   \n"}
{"id": 844, "subroutine": "   subroutine allocategradproj\n      implicit none\n      \n      integer(ip) :: npoin,ngrdf\n      call a%mesh%getnpoin(npoin)\n     \n      ngrdf = (e%ndime+1)*e%ndime\n      call a%memor%alloc(ngrdf,npoin,wgrpro,'wgrpro','lmn_endelmope')\n      call a%memor%alloc(ngrdf,e%mnode,elrhgr,'elrhgr','lmn_endelmope')\n      call a%memor%alloc(e%ndime,e%ndime,e%mnode,elgrv,'elgrv','lmn_endelmope')\n      call a%memor%alloc(e%ndime,e%mnode,elgrt,'elgrt','lmn_endelmope')\n\n      wgrpro = 0.0_rp\n\n   end subroutine\n"}
{"id": 845, "subroutine": "   subroutine deallocategradproj\n      implicit none\n      integer(ip) :: ngrdf\n      \n      ngrdf = (e%ndime+1)*e%ndime\n      call a%memor%dealloc(ngrdf,e%mnode,elrhgr,'elrhgr','lmn_endelmope')\n      call a%memor%dealloc(e%ndime,e%ndime,e%mnode,elgrv,'elgrv','lmn_endelmope')\n      call a%memor%dealloc(e%ndime,e%mnode,elgrt,'elgrt','lmn_endelmope')\n\n   end subroutine\n"}
{"id": 846, "subroutine": "   subroutine gradprojelmatstozero\n      \n      !elmatstozero\n      elrhgr=0.0_rp\n      elgrv=0.0_rp\n      elgrt=0.0_rp\n\n   end subroutine\n"}
{"id": 847, "subroutine": "   subroutine gradprojtoelgradproj\n      \n       call grad_proj(e,e%ndime,dvol,grvel,elgrv)\n       call grad_proj(e,1_ip,dvol,grtem,elgrt)\n      \n   end subroutine\n"}
{"id": 848, "subroutine": "   subroutine assemblygradproj\n      implicit none\n      integer(ip) :: idime,jdime\n      \n      do jdime=1,e%ndime      \n         do idime=1,e%ndime      \n            elrhgr(e%ndime*(idime-1)+jdime,1:e%pnode) = elgrv(idime,jdime,1:e%pnode) &\n                  + elrhgr(e%ndime*(idime-1)+jdime,1:e%pnode)\n         end do\n         elrhgr(e%ndime*e%ndime+jdime,1:e%pnode) = elgrt(jdime,1:e%pnode) &\n              + elrhgr(e%ndime*e%ndime+jdime,1:e%pnode)\n      end do\n \n \n      !globalassembly\n\n      call a%mesh%assemblytoarray(e,size(wgrpro,1),elrhgr,wgrpro) \n      \n   end subroutine\n"}
{"id": 849, "subroutine": "   subroutine projectgradient\n      implicit none\n      integer(ip) :: idime,jdime\n      integer(ip) :: ndime,npoin\n      \n      call a%mesh%getndime(ndime)\n      call a%mesh%getnpoin(npoin)\n\n      call a%project(size(wgrpro,1),wgrpro) \n      \n      do idime=1,ndime+1      \n         do jdime=1,ndime      \n            a%grprj(idime,jdime,:) = wgrpro(ndime*(idime-1)+jdime,:)\n         end do\n      end do\n      \n      !dealloc wrepro\n      call a%memor%dealloc((ndime+1)*ndime,npoin,wgrpro,'wgrpro','lmn_endelmope')\n      \n   end subroutine\n"}
{"id": 850, "subroutine": "subroutine pseudoinv(matrix,m,n,inverse)\nuse evb_mod\nimplicit none\n!     the matrix that shall be inverted\nreal(kind=8), intent(in) :: matrix(m,n)\n!     first/leading dimension of the matrix\ninteger, intent(in) :: m\n!     second dimension of the matrix\ninteger, intent(in) :: n\n!     the pseudoinverse of the matrix (result)\nreal(kind=8), intent(out) :: inverse(n,m)\n!     variables for lapack routine\ncharacter(len=1)::jobu,jobvt\ninteger::info,lda,ldu,ldvt,lwork\nreal(kind=8)::lam_inv(n,m)\nreal(kind=8)::a(m,n),s(min(m,n)),u(m,m),vt(n,n)\nreal(kind=8),allocatable::work(:)\n!     transposed of the matrices resulting from svd\nreal(kind=8)::v(n,n),ut(m,m)\n!     loop indices\ninteger::i,j\n\n!\n!     call the lapack routine for svd\n!\njobu='a'\njobvt='a'\nlda=m\nlwork=max(1,3*min(m,n)+max(m,n),5*min(m,n))\nallocate(work(lwork))\nldu=m\nldvt=n\na=matrix\n\ncall dgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, &\n               & work, lwork, info)\n!\n!     transpose resulting matrices for pseudoinverse\n!\nv=transpose(vt)\nut=transpose(u)\n!\n!     fill the inverse singular value matrix\n!\nlam_inv=0.d0\ndo i=1,min(m,n)\n   lam_inv(i,i)=1.d0/s(i)\n   if (s(i) .lt. 1d-7) then\n      lam_inv(i,i)=0.d0\n   end if\n!   write(*,*) i,lam_inv(i,i)\nend do\n!stop \"hph\"\n!\n!     calculate the pseudoinverse: v^t*lambda^-1*u\n!\ninverse=matmul(v,matmul(lam_inv,ut))\n\n\nreturn\nend subroutine pseudoinv\n"}
{"id": 851, "subroutine": "      subroutine link9s\n\n\n      use pentium_ii_kind, only       :  byte, long, double\n\n      use iount1, only                :  file_nam_maxlen, wrt_err, wrt_log, err, f04, f06,                                         &\n                                         l1d    , l1g    , l1k    , l1q    ,                                                       &\n                                         link1d , link1g , link1k , link1q ,                                                       &\n                                         l1d_msg, l1g_msg, l1k_msg, l1q_msg,                                                       &\n                                         l1dstat, l1gstat, l1kstat, l1qstat\n\n      use scontr, only                :  blnk_sub_nam, data_nam_len, mpcomp0, mrpcomp0, mpcomp_plies,                              &\n                                         mrpcomp_plies, mrmatlc, mpbar, mrpbar, mpbeam, mrpbeam, mpbush, mrpbush, mpelas, mrpelas, &\n                                         mpload4_3d_data, mprod, mrprod, mpshear, mrpshear, mpshel, mrpshel, mpuser1, mrpuser1,    &\n                                         mpuserin, muserin_mat_names, mmatl, mpsolid, nedat, nbaroff, nbushoff, nele, ngrid,       &\n                                         nmatangle, nmatl, npbar, npbeam, npbush, npcomp, npcard, npdat, npelas, nprod, npshear,   &\n                                         npshel, npsolid, nplateoff, nplatethick, npload4_3d, npuser1, npuserin, nseq, nsub,       &\n                                         ntcard, ntdat, ntsub, nvvec, sol_name\n\n      use timdat, only                :  tsec\n      use params, only                :  cbmin3, cbmin4, iorq1m, iorq1s, iorq1b, iorq2b, iorq2t\n      use subr_begend_levels, only    :  link9s_begend\n\n      use model_stuf, only            :  baroff, bushoff, edat, eoff, epnt, esort1, esort2, etype, plateoff, platethick, vvec\n      use model_stuf, only            :  matangle, matl, rmatl, pbar, rpbar, pbeam, rpbeam, pbush, rpbush, pcomp, rpcomp, pelas,   &\n                                         rpelas, prod, rprod, pshear, rpshear, pshel, psolid, rpshel, puser1, rpuser1, puserin,    &\n                                         userin_mat_names\n      use model_stuf, only            :  eldt, elout, grout, oeldt, oelout, ogrout, scnum, sublod, title, stitle, label\n      use model_stuf, only            :  gtemp, tdata, tpnt\n      use model_stuf, only            :  pdata, ppnt, pload4_3d_data, ptype\n      use model_stuf, only            :  any_acce_output, any_disp_output, any_mpcf_output, any_spcf_output, any_oloa_output,      &\n                                         any_gpfo_output, any_elfe_output, any_elfn_output, any_stre_output\n      implicit none\n\n      integer(long), parameter        :: subr_begend = link9s_begend\n\n      end subroutine link9s\n"}
{"id": 852, "subroutine": "subroutine initialize_wavedata(wavedata)\n   type(wave_data_type) :: wavedata\n   character(30)        :: txthlp\n\n   wavedata%mode                    =  0\n   wavedata%time%refdate            =  0\n   wavedata%time%timtscale          =  0\n   wavedata%time%calctimtscale      =  0\n   wavedata%time%calctimtscale_prev =  -999\n   wavedata%time%calccount          =  0\n   wavedata%time%tscale             = 60.0\n   wavedata%time%timsec             =  0.0\n   wavedata%time%timmin             =  0.0\n   wavedata%output%count            =  0\n   wavedata%output%nexttim          =  0.0\n   wavedata%output%timseckeephot    =  0.0\n   wavedata%output%write_wavm       =  .false.\n   !\n   ! platform definition\n   !\n   call util_getenv('arch',txthlp)\n   call small(txthlp,999)\n   if (txthlp == 'win32' .or. txthlp == 'w32') then\n      arch = 'win32'\n   elseif (txthlp == 'win64') then\n      arch = 'win64'\n   else\n      arch = 'linux'\n   endif\nend subroutine initialize_wavedata\n"}
{"id": 853, "subroutine": "subroutine setmode(wavedata, mode_in)\n   integer :: mode_in\n   type(wave_data_type) :: wavedata\n\n   wavedata%mode = mode_in\nend subroutine setmode\n"}
{"id": 854, "subroutine": "subroutine setrefdate(wavetime, refdate_in)\n   integer :: refdate_in\n   type(wave_time_type) :: wavetime\n\n   wavetime%refdate = refdate_in\nend subroutine setrefdate\n"}
{"id": 855, "subroutine": "subroutine settimtscale(wavetime, timtscale_in, modsim, deltcom)\n   integer :: timtscale_in\n   integer :: modsim                ! 1: stationary, 2: quasi-stationary, 3: non-stationary\n   real    :: deltcom               ! used when modsim = 3: interval of communication flow-wave\n   type(wave_time_type) :: wavetime\n\n   wavetime%timtscale = timtscale_in\n   wavetime%timsec    = real(wavetime%timtscale) * wavetime%tscale\n   wavetime%timmin    = wavetime%timsec / 60.0\n   if (modsim == 3) then\n      wavetime%calctimtscale      = wavetime%timtscale + int(deltcom*60.0/wavetime%tscale)\n      wavetime%calctimtscale_prev = wavetime%timtscale\n   else\n      wavetime%calctimtscale = wavetime%timtscale\n   endif\nend subroutine settimtscale\n"}
{"id": 856, "subroutine": "subroutine settscale(wavetime, tscale_in)\n   real :: tscale_in\n   type(wave_time_type) :: wavetime\n\n   wavetime%tscale    = tscale_in\n   wavetime%timsec    = real(wavetime%timtscale) * wavetime%tscale\n   wavetime%timmin    = wavetime%timsec / 60.0\nend subroutine settscale\n"}
{"id": 857, "subroutine": "subroutine settimsec(wavetime, timsec_in, modsim, deltcom)\n   real :: timsec_in\n   integer :: modsim                ! 1: stationary, 2: quasi-stationary, 3: non-stationary\n   real    :: deltcom               ! used when modsim = 3: interval of communication flow-wave\n   type(wave_time_type) :: wavetime\n\n   wavetime%timsec    = timsec_in\n   wavetime%timmin    = wavetime%timsec / 60.0\n   wavetime%timtscale = nint(wavetime%timsec / wavetime%tscale)\n   if (modsim == 3) then\n      wavetime%calctimtscale      = wavetime%timtscale + int(deltcom*60.0/wavetime%tscale)\n      wavetime%calctimtscale_prev = wavetime%timtscale\n   else\n      wavetime%calctimtscale = wavetime%timtscale\n   endif\nend subroutine settimsec\n"}
{"id": 858, "subroutine": "subroutine setcalculationcount(wavetime, count_in)\n   integer :: count_in\n   type(wave_time_type) :: wavetime\n\n   wavetime%calccount = count_in\nend subroutine setcalculationcount\n"}
{"id": 859, "subroutine": "subroutine setoutputcount(waveoutput, count_in)\n   integer :: count_in\n   type(wave_output_type) :: waveoutput\n\n   waveoutput%count = count_in\nend subroutine setoutputcount\n"}
{"id": 860, "subroutine": "subroutine setnexttim(waveoutput, nexttim_in)\n   real :: nexttim_in\n   type(wave_output_type) :: waveoutput\n\n   waveoutput%nexttim = nexttim_in\nend subroutine setnexttim\n"}
{"id": 861, "subroutine": "subroutine setwrite_wavm(waveoutput, write_in)\n   logical :: write_in\n   type(wave_output_type) :: waveoutput\n\n   waveoutput%write_wavm = write_in\nend subroutine setwrite_wavm\n"}
{"id": 862, "subroutine": "subroutine printcommon\n    common /block1/ x, y /block2/ z\n    write (*,*) x, y\nend subroutine\n"}
{"id": 863, "subroutine": "subroutine sumcommon\n    common /block2/ z, /block3/ i, j, k\n    write (*,*) z, i+j+k\nend subroutine\n"}
{"id": 864, "subroutine": "subroutine loosn(u,tillf,nlay,density,sbd,laythk)\n!\nimplicit none\n!\ninclude 'p1werm.inc'\n!\n\n!\ninteger :: nlay\nreal :: tillf,u\nreal,dimension(mnsz) :: density,laythk,sbd\n!\n! local variables\n!\nreal,dimension(mnsz) :: dum\ninteger :: i\n!\n!     + + + purpose + + +\n\n!     that need to be loosen/compact(ed).\n \n!     + + + keywords + + +\n!     loosen/compact, tillage\n \n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n \n!     nlay     - number of soil layers used\n!     u        - loosening coefficient\n!     tillf    - fraction of soil area tilled by the machine\n!     density  - present soil bulk density\n!     sbd      - settled soil bulk density\n!     laythk   - layer thickness\n \n!     + + + accessed common block variable definitions + + +\n!     mnsz        - max number of soil layers\n \n!     + + + parameters + + +\n \n!     + + + local variables + + +\n \n!     + + + local variable definitions + + +\n \n!     dum = dummy variable used in calculating the mass in a subregion\n!     i = loop variable on layers\n \n!     + + + end specifications + + +\n \n!     perform the loosen/compact process on the layers in a subregion\n \ndo i = 1,nlay\n  dum(i) = density(i) - ((density(i)-(2.0/3.0)*sbd(i))*u*tillf)\n  laythk(i) = laythk(i)*(density(i)/dum(i))\n  density(i) = dum(i)\nend do\n!\nend subroutine loosn\n"}
{"id": 865, "subroutine": "subroutine bspline (x,n,c)\nimplicit none\ninteger i,k,n\nreal(kind=8)::x,denom\nreal(kind=8)::c(*)\n\n!\n!     initialize the b-spline as the linear case\n!\nc(1) = 1.0d0 - x\nc(2) = x\n!\n!     compute standard b-spline recursion to n-th order\n!\ndo k = 3, n\n   denom = 1.0d0 / dble(k-1)\n   c(k) = x * c(k-1) * denom\n   do i = 1, k-2\n      c(k-i) = ((x+dble(i))*c(k-i-1) &\n              &    + (dble(k-i)-x)*c(k-i)) * denom\n   end do\n   c(1) = (1.0d0-x) * c(1) * denom\nend do\n\nreturn\nend subroutine bspline\n"}
{"id": 866, "subroutine": "subroutine rhsfreesurface3d_swense(t,wavefield,g,rhse,rhsp,nx,ny)\n!\nuse precision\nuse constants\nuse datatypes\nimplicit none\ninteger :: nx,ny\nreal(kind=long) :: g,t\nreal(kind=long), dimension(nx,ny) :: rhse, rhsp ! e, ex, ey, p, px, py, w,\n!real(kind=long), dimension(nx,ny) :: e_i,ex_i,ey_i,et_i,px_i,py_i,w_i,pt_i\ntype(wavefield_fs) :: wavefield\n! local variables\n!$$$$$$ real(kind=long), dimension(:,:), allocatable :: pxs_i , pys_i\nreal(kind=long), dimension(nx,ny) :: pts_i , pxs_i , pys_i\n\nif (nx==1) then\n!$$$$$$     allocate(pys_i(nx,ny))\n  \t! surfacic quantities for incident wave field\n\tpys_i = wavefield%py_i_s + (wavefield%ey+wavefield%ey_i)*wavefield%pz_i_s\n    !\n\trhse = - (wavefield%ey+wavefield%ey_i)*(wavefield%py+pys_i) &\n    \t   + (wavefield%w+wavefield%pz_i_s)*(one + (wavefield%ey+wavefield%ey_i)**2) - wavefield%et_i                  ! kinematic fs bc\n    !\n    ! surfacic quantities for incident wave field\n    pts_i = wavefield%pt_i_s + (rhse+wavefield%et_i)*wavefield%pz_i_s\n    !\n\trhsp = -g*(wavefield%e+wavefield%e_i) - half*((wavefield%py+pys_i)**2 &\n    \t   -(wavefield%w+wavefield%pz_i_s)**2*(one + (wavefield%ey+wavefield%ey_i)**2)) - pts_i  ! dynamic fs bc!\n!$$$$$$     deallocate(pys_i)\nelse if (ny==1) then\n!$$$$$$     allocate(pxs_i(nx,ny))\n  \t! surfacic quantities for incident wave field\n    pxs_i = wavefield%px_i_s + (wavefield%ex+wavefield%ex_i)*wavefield%pz_i_s\n    !\n\trhse = -(wavefield%ex+wavefield%ex_i)*(wavefield%px+pxs_i) &\n    \t   +(wavefield%w+wavefield%pz_i_s)*(one + (wavefield%ex+wavefield%ex_i)**2) - wavefield%et_i                 ! kinematic fs bc\n    !\n    ! surfacic quantities for incident wave field\n    pts_i = wavefield%pt_i_s + (rhse+wavefield%et_i)*wavefield%pz_i_s\n    !\n\trhsp = -g*(wavefield%e+wavefield%e_i) - half*((wavefield%px+pxs_i)**2 &\n    \t   -(wavefield%w+wavefield%pz_i_s)**2*(one + (wavefield%ex+wavefield%ex_i)**2)) - pts_i  ! dynamic fs bc!\n!$$$$$$     deallocate(pxs_i)\nelse\n!$$$$$$     allocate(pxs_i(nx,ny),pys_i(nx,ny))\n  \t! surfacic quantities for incident wave field\n\tpxs_i = wavefield%px_i_s + (wavefield%ex+wavefield%ex_i)*wavefield%pz_i_s\n    pys_i = wavefield%py_i_s + (wavefield%ey+wavefield%ey_i)*wavefield%pz_i_s\n    !\n\trhse = -(wavefield%ex+wavefield%ex_i)*(wavefield%px+pxs_i)-(wavefield%ey+wavefield%ey_i)*(wavefield%py+pys_i) &\n    \t+ (wavefield%w+wavefield%pz_i_s)*(one + (wavefield%ex+wavefield%ex_i)**2 + (wavefield%ey+wavefield%ey_i)**2) &\n        - wavefield%et_i            ! kinematic fs bc\n    !\n    ! surfacic quantities for incident wave field\n    pts_i = wavefield%pt_i_s + (rhse+wavefield%et_i)*wavefield%pz_i_s\n    !\n\trhsp = -g*(wavefield%e+wavefield%e_i) - half*((wavefield%px+pxs_i)**2 + (wavefield%py+pys_i)**2 &\n    \t- (wavefield%w+wavefield%pz_i_s)**2*(one + (wavefield%ex+wavefield%ex_i)**2  &\n        + (wavefield%ey+wavefield%ey_i)**2)) - pts_i       ! dynamic fs bc!\n!$$$$$$     deallocate(pxs_i,pys_i)\nendif\n\nend subroutine rhsfreesurface3d_swense\n"}
{"id": 867, "subroutine": "subroutine orbinteg (infname, veqmode, orbc, veqsmatrix, veqpmatrix, is_backwards)\r\n\r\n\r\n! ----------------------------------------------------------------------\r\n\n! ----------------------------------------------------------------------\r\n! purpose:\r\n!  orbit integration: numerical integration of equation of motion and variational equations\r\n! ----------------------------------------------------------------------\r\n! input arguments:\r\n! - infname:      input cofiguration file name for the orbit parameterization \r\n! - veqmode:      veqmode = 0 :: variational equations integration is not performed\r\n!                       veqmode = 1 :: variational equations integration is performed\r\n!\r\n! output arguments:\r\n! - orbc:         satellite orbit array in icrf including the following per epoch:\r\n!               - modified julian day number (including the fraction of the day) \r\n!                       - seconds since 00h \r\n!                       - position vector (m)\r\n!                       - velocity vector (m/sec)\r\n! - veqsmatrix:   state trasnition matrix obtained from the variational equations solution based on numerical integration methods\r\n! - veqpmatrix: sensitivity matrix obtained from the variational equations solution based on numerical integration methods\r\n! ----------------------------------------------------------------------\r\n! note 1:\r\n! the time scale of the 2 first collumns of the orbit arrays (mjd and seoncds since 00h) \r\n! refer to the time system defined by the global variable time_scale in the module mdl_param.f03\r\n! according to the input parameterization file \r\n! ----------------------------------------------------------------------\r\n! author :  dr. thomas papanikolaou, cooperative research centre for spatial information, australia\r\n!\r\n! created:  5 october 2017\r\n!\r\n! chnages:  22-05-2019  tzupang tseng: compute the beta angle for setting the integration step size for the eclipsed satellites    \r\n! ----------------------------------------------------------------------\r\n        \r\n        \r\n      use mdl_precision\r\n      use mdl_num\r\n      use m_integreqm\r\n      use m_integrveq\r\n      use mdl_param\r\n      use mdl_config\r\n      use pod_yaml\r\n!      use m_betainfo\r\n      implicit none\r\n\r\n        \r\n! ----------------------------------------------------------------------\r\n! dummy arguments declaration\r\n! ----------------------------------------------------------------------\r\n! in\r\n      character (len=100), intent(in)  :: infname                       \r\n      integer (kind = prec_int2), intent(in) :: veqmode \r\n      logical :: is_backwards\r\n! ----------------------------------------------------------------------\r\n! out\r\n      real (kind = prec_d), dimension(:,:), allocatable, intent(out) :: orbc, veqsmatrix, veqpmatrix  \r\n! ----------------------------------------------------------------------\r\n\r\n! ----------------------------------------------------------------------\r\n! local variables declaration\r\n! ----------------------------------------------------------------------\r\n      real (kind = prec_d), dimension(:,:), allocatable :: smatrix, pmatrix \r\n      real (kind = prec_d) :: mjdo\r\n      real (kind = prec_d), dimension(3) :: ro, vo\r\n!       real (kind = prec_d), dimension(6) :: zo_icrf\r\n      real (kind = prec_d) :: arc\r\n      integer (kind = prec_int2) :: integid\r\n      real (kind = prec_d) :: step\r\n! ----------------------------------------------------------------------\r\n      real (kind = prec_d) :: to_sec     \r\n      real (kind = prec_d) :: t_sec     \r\n      integer (kind = prec_int8) :: nepochs, i\r\n!       , j\r\n      integer (kind = prec_int8) :: sz1, sz2 \r\n      integer (kind = prec_int2) :: allocatestatus\r\n!       , deallocatestatus  \r\n        real (kind = prec_d) :: mjd , mjd_tt, mjd_gps, mjd_tai, mjd_utc\r\n        real (kind = prec_d) :: dt_tt_tai, dt_tai_utc, dt_tai_gps\r\n!       double precision eop_cr(7)\r\n!       double precision crs2trs(3,3), trs2crs(3,3), d_crs2trs(3,3), d_trs2crs(3,3)\r\n!       real (kind = prec_d) :: r_trs(3), v_trs(3)\r\n!       real (kind = prec_d) :: r_crs(3), v_crs(3)\r\n!       real (kind = prec_d) :: v_trs_1(3), v_trs_2(3), v_crs_1(3), v_crs_2(3)    \r\n! ----------------------------------------------------------------------\r\n!       integer iy, im, id, j_flag\r\n!       double precision sec, fd, sec0\r\n!       ,djm0, \r\n        integer (kind = prec_int8) :: nparam\r\n\r\n!       real (kind = prec_d) :: xmatrix(6)\r\n!       real (kind = prec_d) :: beta0\r\n      logical found\r\n\r\n! ----------------------------------------------------------------------\r\n! read orbit parameterization\r\ncall prm_main (infname, veqmode == mveq)\r\n!call prm_read (infname)\r\n! ----------------------------------------------------------------------\r\n\r\n! ----------------------------------------------------------------------\r\n! temp                                                                                                            ! ----------------------------------------------------------------------\r\nsvec_zo = svec_zo_estim\r\n!print *, \"orbinteg: svec_zo = \", svec_zo\r\n!bias_accel_glb = bias_accel_aposteriori\r\n!cpr_cs_glb = cpr_cs_aposteriori\r\n! ----------------------------------------------------------------------\r\n\r\n! ----------------------------------------------------------------------\r\n! orbit integrator input parameters\r\n! ----------------------------------------------------------------------\r\nmjdo = mjd_to\r\nto_sec = sec_to\r\nro(1:3) = svec_zo(1:3)\r\nvo(1:3) = svec_zo(4:6)\r\nif (yaml_found) then\r\n    if (veqmode .eq. meqm) then\r\n        integid = yml_eqm_integrate_method\r\n        step = yml_eqm_integ_stepsize\r\n        do i=1,prn_override_count\r\n            if (yml_prn_overrides(i)%name .eq. trim(prn) .and. yml_prn_overrides(i)%integ%eqm_enabled) then\r\n                step = yml_prn_overrides(i)%integ%eqm_stepsize\r\n            end if\r\n        end do\r\n    else\r\n        integid = yml_veq_integrate_method\r\n        step = yml_veq_integ_stepsize\r\n        do i=1,prn_override_count\r\n            if (yml_prn_overrides(i)%name .eq. trim(prn) .and. yml_prn_overrides(i)%integ%veq_enabled) then\r\n                step = yml_prn_overrides(i)%integ%veq_stepsize\r\n            end if\r\n        end do\r\n    endif\r\n    if (is_backwards .and. step > 0) then\r\n        step = -1.0d0 * step\r\n    end if\r\nelse\r\n    ! just pick out the parameter file values todo: to be removed\r\n    integid = integmeth\r\n    step = integstep\r\nendif \r\n\r\nfound = .false.\r\ndo i=1,prn_override_count\r\n   if (yml_prn_overrides(i)%name .eq. trim(prn) .and. yml_prn_overrides(i)%integ%arc_enabled) then\r\n      arc = yml_prn_overrides(i)%integ%arc_length\r\n      found = .true.\r\n   end if\r\nend do\r\nif (.not.found) arc = orb_est_arc\r\n\r\n! ----------------------------------------------------------------------\r\n! compute the beta angle for setting the integration step size for the eclipsed\r\n! satellite\r\n!call betainfo (mjdo, ro, vo, beta0)\r\n!if (abs(beta0)-14.d0 .lt. 0.d0)then\r\n!step = 120\r\n!end if\r\n!-----------------------------------------------------------------------\r\n\r\n\r\n! ----------------------------------------------------------------------\r\n! orbit integration\r\n! ----------------------------------------------------------------------\r\n\r\nif (veqmode == meqm) then\r\n\r\n! ----------------------------------------------------------------------\r\n! orbit propagation based on numerical integration methods \r\n! ----------------------------------------------------------------------\r\n! numerical integration of the equation of motion\r\ncall integr_eqm (mjdo, to_sec, ro, vo, arc, integid, step, orbc)\r\n! ----------------------------------------------------------------------\r\n\r\n! ----------------------------------------------------------------------\r\nsz1 = size(orbc, dim = 1)\r\nsz2 = size(orbc, dim = 2)\r\n!print *, \"integr_eqm, sz1 = \", sz1, \", sz2 = \", sz2\r\nallocate (veqsmatrix(sz1,sz2), stat = allocatestatus)\r\nveqsmatrix = orbc\r\nallocate (veqpmatrix(sz1,sz2), stat = allocatestatus)\r\nveqpmatrix = orbc\r\n! ----------------------------------------------------------------------\r\n\r\n\r\nelse if (veqmode == mveq) then\r\n\r\n! ----------------------------------------------------------------------\r\n! variational equations solution based on numerical integration\r\n! ----------------------------------------------------------------------\r\n! number of estimated parameters (module mdl_param)\r\nnparam = nparam_glb\r\ncall integr_veq (mjdo, to_sec, ro, vo, arc, integid, step, nparam, orbc, smatrix, pmatrix)\r\n\r\nsz1 = size(smatrix, dim = 1)\r\nsz2 = size(smatrix, dim = 2)\r\n!print *, \"integr_veq, smatrix sz1 = \", sz1, \", sz2 = \", sz2\r\nallocate (veqsmatrix(sz1,sz2), stat = allocatestatus)\r\nveqsmatrix = smatrix\r\n\r\nsz1 = size(pmatrix, dim = 1)\r\nsz2 = size(pmatrix, dim = 2)\r\n!print *, \"integr_veq, pmatrix sz1 = \", sz1, \", sz2 = \", sz2\r\nallocate (veqpmatrix(sz1,sz2), stat = allocatestatus)\r\nveqpmatrix = pmatrix\r\n! ----------------------------------------------------------------------\r\n\r\nend if\r\n\r\n\r\n! ----------------------------------------------------------------------\r\n! time scale transformation in orbc matrix\r\n! ----------------------------------------------------------------------\r\n! time scale change is applied in case that time_scale .not. terrestrial time\r\n! time_scale: global variable in module mdl_param.f03\r\n! ----------------------------------------------------------------------\r\nif (yml_time_scale /= tt_time) then\r\n\r\nsz1 = size(orbc, dim = 1)\r\nsz2 = size(orbc, dim = 2)\r\nnepochs = sz1\r\n\r\ndo i = 1 , nepochs\r\n\r\n! mjd in tt time\r\nmjd = orbc(i,1)\r\n! seconds since 00h\r\nt_sec = orbc(i,2)\r\n!print *, \"t_sec \", t_sec\r\n\r\n! time scale: tt to gps time\r\ncall time_tt (mjd , mjd_tt, mjd_gps, mjd_tai, mjd_utc)\r\ncall time_tt_sec (mjd , dt_tt_tai, dt_tai_utc, dt_tai_gps)\r\n!print *,\"dt_tt_tai, dt_tai_utc, dt_tai_gps\", dt_tt_tai, dt_tai_utc, dt_tai_gps\r\n\r\n! test the time_scale global variable in mdl_param.f03      \r\nif (yml_time_scale == gps_time) then\r\n      mjd = mjd_gps\r\n      t_sec = t_sec - (dt_tt_tai + dt_tai_gps)\r\nelse if (yml_time_scale == utc_time) then\r\n      mjd = mjd_utc           \r\n      t_sec = t_sec - (dt_tt_tai + dt_tai_utc)\r\nelse if (yml_time_scale == tai_time) then\r\n      mjd = mjd_tai\r\n      t_sec = t_sec - (dt_tt_tai)   \r\nend if      \r\n!print *, \"time_scale \", time_scale\r\n!print *, \"(dt_tt_tai + dt_tai_gps) \", (dt_tt_tai + dt_tai_gps)\r\n!print *, \"t_sec \", t_sec\r\n\r\n! seconds since 00h\r\n!t_sec = (mjd - int(mjd)) * (24.d0 * 3600.d0)\r\n! seconds since 00h\r\nif (t_sec >= 86400.d0) then\r\n      t_sec = t_sec - int(t_sec / 86400.d0) * 86400.d0\r\nend if\r\n\r\n! time scale change in orbit matrix and veq matrices \r\norbc(i,1) = mjd\r\norbc(i,2) = t_sec\r\nif (veqmode == 1) then\r\n      veqsmatrix(i,1) = mjd\r\n      veqsmatrix(i,2) = t_sec\r\n      veqpmatrix(i,1) = mjd\r\n      veqpmatrix(i,2) = t_sec\r\nend if\r\n \r\nend do\r\n\r\nend if\r\n! ----------------------------------------------------------------------\r\n\r\n\r\nend subroutine\r\n"}
{"id": 868, "subroutine": "  subroutine random_set_seed(state, seed)\n    implicit none\n    type(random_state), intent(inout) :: state\n    integer, intent(in) :: seed\n\n    state%x = seed\n  end subroutine random_set_seed\n"}
{"id": 869, "subroutine": "  subroutine meanarray(n)\n    integer, intent(in) :: n\n    integer, dimension(n) :: a, b\n    a = 12\n    print *, \"find the address of a fortran object.\"\n    print *, loc(a)\n    print *, loc(a(1))\n    print *, loc(a(2))\n    print *, loc(a(3))\n    b = 255\n    a = (a + b) / 2\n    print *, sum(a)\n  end subroutine meanarray\n"}
{"id": 870, "subroutine": "    subroutine amg_c_krm_solver_apply_vect(alpha,sv,x,beta,y,desc_data,&\n         & trans,work,wv,info,init,initu)\n      import :: psb_desc_type, amg_c_krm_solver_type, psb_c_vect_type, psb_spk_, &\n           & psb_cspmat_type, psb_c_base_sparse_mat, psb_c_base_vect_type, psb_ipk_\n      implicit none\n      type(psb_desc_type), intent(in)             :: desc_data\n      class(amg_c_krm_solver_type), intent(inout) :: sv\n      type(psb_c_vect_type),intent(inout)         :: x\n      type(psb_c_vect_type),intent(inout)         :: y\n      complex(psb_spk_),intent(in)                    :: alpha,beta\n      character(len=1),intent(in)                   :: trans\n      complex(psb_spk_),target, intent(inout)         :: work(:)\n      type(psb_c_vect_type),intent(inout)         :: wv(:)\n      integer(psb_ipk_), intent(out)                :: info\n      character, intent(in), optional                :: init\n      type(psb_c_vect_type),intent(inout), optional   :: initu\n    end subroutine amg_c_krm_solver_apply_vect\n"}
{"id": 871, "subroutine": "    subroutine amg_c_krm_solver_apply(alpha,sv,x,beta,y,desc_data,&\n         & trans,work,info,init,initu)\n      import :: psb_desc_type, amg_c_krm_solver_type, psb_c_vect_type, psb_spk_, &\n           & psb_cspmat_type, psb_c_base_sparse_mat, psb_c_base_vect_type, psb_ipk_\n      implicit none\n      type(psb_desc_type), intent(in)      :: desc_data\n      class(amg_c_krm_solver_type), intent(inout) :: sv\n      complex(psb_spk_),intent(inout)         :: x(:)\n      complex(psb_spk_),intent(inout)         :: y(:)\n      complex(psb_spk_),intent(in)            :: alpha,beta\n      character(len=1),intent(in)           :: trans\n      complex(psb_spk_),target, intent(inout) :: work(:)\n      integer(psb_ipk_), intent(out)        :: info\n      character, intent(in), optional       :: init\n      complex(psb_spk_),intent(inout), optional :: initu(:)\n    end subroutine amg_c_krm_solver_apply\n"}
{"id": 872, "subroutine": "    subroutine amg_c_krm_solver_bld(a,desc_a,sv,info,b,amold,vmold,imold)\n      import :: psb_desc_type, amg_c_krm_solver_type, psb_c_vect_type, psb_spk_, &\n           & psb_cspmat_type, psb_c_base_sparse_mat, psb_c_base_vect_type,&\n           & psb_ipk_, psb_i_base_vect_type\n      implicit none\n      type(psb_cspmat_type), intent(in), target           :: a\n      type(psb_desc_type), intent(inout)                  :: desc_a\n      class(amg_c_krm_solver_type), intent(inout)         :: sv\n      integer(psb_ipk_), intent(out)                      :: info\n      type(psb_cspmat_type), intent(in), target, optional :: b\n      class(psb_c_base_sparse_mat), intent(in), optional  :: amold\n      class(psb_c_base_vect_type), intent(in), optional   :: vmold\n      class(psb_i_base_vect_type), intent(in), optional   :: imold\n    end subroutine amg_c_krm_solver_bld\n"}
{"id": 873, "subroutine": "  subroutine c_krm_solver_default(sv)\n\n    implicit none\n\n    ! arguments\n    class(amg_c_krm_solver_type), intent(inout) :: sv\n\n    sv%method     = 'bicgstab'\n    sv%kprec      = 'bjac'\n    sv%sub_solve  = 'ilu'\n    sv%i_sub_solve  = -1\n    sv%fillin = 1\n    sv%irst   = 30\n    sv%istopc = 2\n    sv%itmax  = 40\n    sv%itrace = -1\n    sv%eps    = 1.d-6\n    sv%global = .false.\n\n    return\n  end subroutine c_krm_solver_default\n"}
{"id": 874, "subroutine": "  subroutine c_krm_solver_check(sv,info)\n\n    implicit none\n\n    ! arguments\n    class(amg_c_krm_solver_type), intent(inout) :: sv\n    integer(psb_ipk_), intent(out)              :: info\n    integer(psb_ipk_) :: err_act\n    character(len=20) :: name='c_krm_solver_check'\n\n    call psb_erractionsave(err_act)\n    info = psb_success_\n\n\n    if (info /= psb_success_) goto 9999\n\n    call psb_erractionrestore(err_act)\n    return\n\n9999 call psb_error_handler(err_act)\n    return\n\n  end subroutine c_krm_solver_check\n"}
{"id": 875, "subroutine": "  subroutine c_krm_solver_cseti(sv,what,val,info,idx)\n\n    implicit none\n\n    ! arguments\n    class(amg_c_krm_solver_type), intent(inout) :: sv\n    character(len=*), intent(in)                  :: what\n    integer(psb_ipk_), intent(in)                 :: val\n    integer(psb_ipk_), intent(out)                :: info\n    integer(psb_ipk_), intent(in), optional       :: idx\n    integer(psb_ipk_)  :: err_act\n    character(len=20)  :: name='c_krm_solver_cseti'\n\n    info = psb_success_\n    call psb_erractionsave(err_act)\n\n    select case(psb_toupper(trim(what)))\n    case('krm_irst')\n      sv%irst = val\n    case('krm_istopc')\n      sv%istopc = val\n    case('krm_itmax')\n      sv%itmax = val\n    case('krm_itrace')\n      sv%itrace = val\n    case('krm_sub_solve')\n      sv%i_sub_solve = val\n    case('krm_fillin')\n      sv%fillin = val\n    case default\n      call sv%amg_c_base_solver_type%set(what,val,info,idx=idx)\n    end select\n\n    call psb_erractionrestore(err_act)\n    return\n\n9999 call psb_error_handler(err_act)\n    return\n  end subroutine c_krm_solver_cseti\n"}
{"id": 876, "subroutine": "  subroutine poisson3d_1_mg\n  \n!<description>\n  ! this is an all-in-one poisson solver for directly solving a poisson\n  ! problem without making use of special features like collections\n  ! and so on. the routine performs the following tasks:\n  !\n  ! 1.) read in triangulation\n  ! 2.) set up rhs\n  ! 3.) set up matrix\n  ! 4.) create solver structure\n  ! 5.) solve the problem\n  ! 6.) write solution to vtk file\n  ! 7.) release all variables, finish\n!</description>\n\n\n    ! definitions of variables.\n    !\n    ! we need a couple of variables for this problem. let us see...\n    !\n    ! an array of problem levels for the multigrid solver\n    type(t_level), dimension(:), pointer :: rlevels\n    \n    ! an object for saving the boundary mesh region\n    type(t_meshregion) :: rmeshregion\n    \n    ! path to the mesh\n    character(len=sys_strlen) :: spredir\n\n    ! a bilinear and linear form describing the analytic problem to solve\n    type(t_bilinearform) :: rform\n    type(t_linearform) :: rlinform\n    \n    ! a block matrix and a couple of block vectors. these will be filled\n    ! with data for the linear solver.\n    type(t_vectorblock) :: rvecsol,rvecrhs,rvectmp\n\n    ! a solver node that accepts parameters for the linear solver\n    type(t_linsolnode), pointer :: p_rsolvernode,p_rcoarsegridsolver,p_rsmoother\n\n    ! an array for the system matrix(matrices) during the initialisation of\n    ! the linear solver.\n    type(t_matrixblock), dimension(:), pointer :: rmatrices\n\n    ! one level of multigrid\n    type(t_linsolmg2levelinfo), pointer :: p_rlevelinfo\n\n    ! nlmin receives the level of the coarse grid.\n    integer :: nlmin\n\n    ! nlmax receives the level where we want to solve.\n    integer :: nlmax\n    \n    ! error indicator during initialisation of the solver\n    integer :: ierror\n    \n    ! error of fe function to reference function\n    real(dp) :: derror\n    \n    ! output block for ucd output to vtk file\n    type(t_ucdexport) :: rexport\n    character(len=sys_strlen) :: sucddir\n    \n    ! a temporary variable for the level-loops\n    integer :: i\n\n    ! ok, let us start.\n    !\n    ! we want to solve our poisson problem on level...\n    nlmin = 1\n    nlmax = 4\n    \n    ! allocate memory for all levels\n    allocate(rlevels(nlmin:nlmax))\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! read the domain, read the mesh, refine\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    \n    ! get the path $predir from the environment, where to read .prm/.tri files\n    ! from. if that does not exist, write to the directory \"./pre\".\n    if (.not. sys_getenv_string(\"predir\", spredir)) spredir = \"./pre\"\n\n    ! at first, read in the basic triangulation.\n    ! as we cannot refine a 3d grid yet, read in a cube grid.\n    call tria_readtrifile3d (rlevels(nlmin)%rtriangulation, trim(spredir)//\"/cube.tri\")\n    \n    ! refine it.\n    call tria_quickrefine2levelordering (nlmin-1,rlevels(nlmin)%rtriangulation)\n    \n    ! and create information about adjacencies and everything one needs from\n    ! a triangulation.\n    call tria_initstandardmeshfromraw (rlevels(nlmin)%rtriangulation)\n    \n    ! now refine the grid for the fine levels.\n    do i = nlmin+1, nlmax\n\n      ! refine the grid using the 2-level-ordering algorithm\n      call tria_refine2levelordering(rlevels(i-1)%rtriangulation,&\n          rlevels(i)%rtriangulation)\n      \n      ! create a standard mesh\n      call tria_initstandardmeshfromraw(rlevels(i)%rtriangulation)\n    \n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up discretisation structures which tells the code which\n    ! finite element to use\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! now we can start to initialise the discretisation. at first, set up\n    ! a block discretisation structure that specifies the blocks in the\n    ! solution vector. in this simple problem, we only have one block.\n    ! do this for all levels\n    do i = nlmin, nlmax\n      call spdiscr_initblockdiscr (rlevels(i)%rdiscretisation, 1, &\n                                   rlevels(i)%rtriangulation)\n    end do\n    \n    ! rdiscretisation%rdiscretisations is a list of scalar discretisation\n    ! structures for every component of the solution vector.\n    ! initialise the first element of the list to specify the element\n    ! for this solution component:\n    do i = nlmin, nlmax\n      call spdiscr_initdiscr_simple (&\n          rlevels(i)%rdiscretisation%rspatialdiscr(1), &\n          el_q1_3d,rlevels(i)%rtriangulation)\n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up an cubature info structure to tell the code which cubature\n    ! formula to use\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! create an assembly information structure on each level which tells the code\n    ! the cubature formula to use. standard: gauss 3x3.\n    do i = nlmin, nlmax\n      call spdiscr_createdefcubstructure(&  \n          rlevels(i)%rdiscretisation%rspatialdiscr(1),rlevels(i)%rcubatureinfo,&\n          cub_gen_auto_g3)\n    end do\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! create a 1x1 block matrix with the operator on every level\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! now as the discretisation is set up, we can start to generate\n    ! the structure of the system matrix which is to solve.\n    ! we create a scalar matrix, based on the discretisation structure\n    ! for our one and only solution component.\n    do i = nlmin, nlmax\n\n      ! initialise the block matrix with default values based on\n      ! the discretisation.\n      call lsysbl_creatematrix (&\n          rlevels(i)%rdiscretisation,rlevels(i)%rmatrix)\n\n      ! now as the discretisation is set up, we can start to generate\n      ! the structure of the system matrix which is to solve.\n      ! we create that directly in the block (1,1) of the block matrix\n      ! using the discretisation structure of the first block.\n      call bilf_creatematrixstructure (rlevels(i)%rmatrix, 1, 1, lsyssc_matrix9)\n      \n      ! and now to the entries of the matrix. for assembling of the entries,\n      ! we need a bilinear form, which first has to be set up manually.\n      ! we specify the bilinear form (grad psi_j, grad phi_i) for the\n      ! scalar system matrix in 3d.\n      rform%itermcount = 3\n      rform%idescriptors(1,1) = der_deriv3d_x\n      rform%idescriptors(2,1) = der_deriv3d_x\n      rform%idescriptors(1,2) = der_deriv3d_y\n      rform%idescriptors(2,2) = der_deriv3d_y\n      rform%idescriptors(1,3) = der_deriv3d_z\n      rform%idescriptors(2,3) = der_deriv3d_z\n\n      ! in the standard case, we have constant coefficients:\n      rform%ballcoeffconstant = .true.\n      rform%dcoefficients(1)  = 1.0\n      rform%dcoefficients(2)  = 1.0\n      rform%dcoefficients(3)  = 1.0\n\n      ! now we can build the matrix entries.\n      ! we specify the callback function coeff_laplace for the coefficients.\n      ! as long as we use constant coefficients, this routine is not used.\n      ! by specifying ballcoeffconstant = .false. above,\n      ! the framework will call the callback routine to get analytical\n      ! data.\n      call bilf_buildmatrixscalar (rform,.true.,&\n           rlevels(i)%rmatrix%rmatrixblock(1,1),rlevels(i)%rcubatureinfo)\n    \n    end do\n      \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! create rhs and solution vectors\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! next step: create a rhs vector, a solution vector and a temporary\n    ! vector. all are filled with zero.\n    call lsysbl_createvector (rlevels(nlmax)%rdiscretisation,rvecrhs,.true.)\n    call lsysbl_createvector (rlevels(nlmax)%rdiscretisation,rvecsol,.true.)\n    call lsysbl_createvector (rlevels(nlmax)%rdiscretisation,rvectmp,.true.)\n      \n    ! the vector structure is ready but the entries are missing.\n    ! so the next thing is to calculate the content of that vector.\n    !\n    ! at first set up the corresponding linear form (f,phi_j):\n    rlinform%itermcount = 1\n    rlinform%idescriptors(1) = der_func3d\n    \n    ! ... and then discretise the rhs to get a discrete version of it.\n    ! again we simply create a scalar vector based on the one and only\n    ! discretisation structure.\n    ! this scalar vector will later be used as the one and only first\n    ! component in a block vector.\n    call linf_buildvectorscalar (&\n        rlinform,.true.,rvecrhs%rvectorblock(1),rlevels(nlmax)%rcubatureinfo,coeff_rhs_3d)\n\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! discretise the boundary conditions and apply them to the matrix/rhs/sol.\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    \n    ! now we have the raw problem. what is missing is the definition of the boundary\n    ! conditions.\n    ! for implementing boundary conditions, we use a `filter technique with\n    ! discretised boundary conditions`. this means, we first have to calculate\n    ! a discrete version of the analytic bc, which we can implement into the\n    ! solution/rhs vectors using the corresponding filter.\n    \n    ! in contrast to the 2d examples, we currently do not have an analytic\n    ! description of the domain`s boundary, therefore we need a discrete\n    ! (mesh-dependent) description of the mesh`s boundary. this can be done\n    ! using mesh-regions.\n    do i = nlmin, nlmax\n    \n      ! create a t_discretebc structure where we store all discretised boundary\n      ! conditions.\n      call bcasm_initdiscretebc(rlevels(i)%rdiscretebc)\n\n      ! create a mesh region describing the mesh`s boundary based on the\n      ! nodal-property-array of the current triangulation.\n      call mshreg_createfromnodalprop(rmeshregion, rlevels(i)%rtriangulation, &\n                                      mshreg_idx_all)\n      \n      ! describe dirichlet bcs on that mesh region\n      call bcasm_newdirichletbconmr(rlevels(i)%rdiscretisation, 1,&\n        rlevels(i)%rdiscretebc,rmeshregion,getboundaryvaluesmr_3d)\n      \n      ! free the mesh region structure as we will not need it anymore\n      call mshreg_done(rmeshregion)\n\n      ! also implement the boundary conditions into the matrix.\n      call matfil_discretebc (rlevels(i)%rmatrix,rlevels(i)%rdiscretebc)\n\n      ! during the linear solver, the boundary conditions are also\n      ! frequently imposed to the vectors. but as the linear solver\n      ! does not work with the actual solution vectors but with\n      ! defect vectors instead.\n      ! so, set up a filter chain that filters the defect vector\n      ! during the solution process to implement discrete boundary conditions.\n      call filter_initfilterchain (rlevels(i)%rfilterchain,rlevels(i)%nfilters)\n      call filter_newfilterdiscbcdef (&\n          rlevels(i)%rfilterchain,rlevels(i)%nfilters,rlevels(i)%rdiscretebc)\n\n    end do ! level loop\n\n    ! next step is to implement boundary conditions into the rhs,\n    ! solution and matrix. this is done using a vector/matrix filter\n    ! for discrete boundary conditions.\n    call vecfil_discretebcrhs (rvecrhs,rlevels(nlmax)%rdiscretebc)\n    call vecfil_discretebcsol (rvecsol,rlevels(nlmax)%rdiscretebc)\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! set up a linear solver\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! now we have to build up the level information for multigrid.\n    !\n    ! create a multigrid-solver. attach the above filter chain\n    ! to the solver, so that the solver automatically filters\n    ! the vector during the solution process.\n    call linsol_initmultigrid2 (p_rsolvernode,nlmax-nlmin+1,rlevels(nlmax)%rfilterchain)\n    \n    ! set up a coarse grid solver.\n    ! the coarse grid in multigrid is always grid 1!\n    call linsol_getmultigrid2level (p_rsolvernode,1,p_rlevelinfo)\n    call linsol_initumfpack4 (p_rcoarsegridsolver)\n    \n    p_rlevelinfo%p_rcoarsegridsolver => p_rcoarsegridsolver\n    p_rlevelinfo%p_rfilterchain => rlevels(nlmin)%rfilterchain\n    \n    ! now set up the other levels...\n    do i = nlmin+1, nlmax\n    \n      ! create a jacobi smoother\n      !call linsol_initjacobi(p_rsmoother)\n      \n      ! create an ilu(0) smoother\n      call linsol_initmilus1x1 (p_rsmoother,0,0.0_dp)\n      \n      ! we will use 4 smoothing steps with damping parameter 0.7\n      call linsol_converttosmoother(p_rsmoother, 4, 0.7_dp)\n      \n      ! and add this multi-grid level. we will use the same smoother\n      ! for pre- and post-smoothing.\n      call linsol_getmultigrid2level (p_rsolvernode,i-nlmin+1,p_rlevelinfo)\n      p_rlevelinfo%p_rpresmoother => p_rsmoother\n      p_rlevelinfo%p_rpostsmoother => p_rsmoother\n      \n      ! attach the filter chain which imposes boundary conditions on that level.\n      p_rlevelinfo%p_rfilterchain => rlevels(i)%rfilterchain\n      \n    end do\n    \n    ! set the output level of the solver to 2 for some output\n    p_rsolvernode%ioutputlevel = 2\n    \n    ! attach the system matrices to the solver.\n    !\n    ! we copy our matrices to a big matrix array and transfer that\n    ! to the setmatrices routines. this intitialises then the matrices\n    ! on all levels according to that array. note that this does not\n    ! allocate new memory, we create only \"links\" to existing matrices\n    ! into rmatrices(:)!\n    allocate(rmatrices(nlmin:nlmax))\n    do i = nlmin, nlmax\n      call lsysbl_duplicatematrix (rlevels(i)%rmatrix,&\n          rmatrices(i),lsyssc_dup_share,lsyssc_dup_share)\n    end do\n    \n    call linsol_setmatrices(p_rsolvernode,rmatrices(nlmin:nlmax))\n\n    ! we can release rmatrices immediately -- as long as we do not\n    ! release rlevels(i)%rmatrix!\n    do i=nlmin,nlmax\n      call lsysbl_releasematrix (rmatrices(i))\n    end do\n    deallocate(rmatrices)\n\n    ! initialise structure/data of the solver. this allows the\n    ! solver to allocate memory / perform some precalculation\n    ! to the problem.\n    call linsol_initstructure (p_rsolvernode, ierror)\n    \n    if (ierror .ne. linsol_err_noerror) then\n      call output_line(\"matrix structure invalid!\",ou_class_error)\n      call sys_halt()\n    end if\n\n    call linsol_initdata (p_rsolvernode, ierror)\n    \n    if (ierror .ne. linsol_err_noerror) then\n      call output_line(\"matrix singular!\",ou_class_error)\n      call sys_halt()\n    end if\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! solve the system\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n    ! finally solve the system. as we want to solve ax=b with\n    ! b being the real rhs and x being the real solution vector,\n    ! we use linsol_solveadaptively. if b is a defect\n    ! rhs and x a defect update to be added to a solution vector,\n    ! we would have to use linsol_preconddefect instead.\n    call linsol_solveadaptively (p_rsolvernode,rvecsol,rvecrhs,rvectmp)\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! postprocessing of the solution\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    \n    ! that is it, rvecsol now contains our solution. we can now\n    ! start the postprocessing.\n    !\n    ! get the path for writing postprocessing files from the environment variable\n    ! $ucddir. if that does not exist, write to the directory \"./gmv\".\n    if (.not. sys_getenv_string(\"ucddir\", sucddir)) sucddir = \"./gmv\"\n\n    ! start ucd export to vtk file:\n    call ucd_startvtk (rexport,ucd_flag_standard,rlevels(nlmax)%rtriangulation,&\n                       trim(sucddir)//\"/u3d_1_mg.vtk\")\n    \n    ! add the solution to the ucd exporter\n    call ucd_addvectorbyvertex (rexport, \"sol\", ucd_var_standard, &\n        rvecsol%rvectorblock(1))\n    \n    ! write the file to disc, that is it.\n    call ucd_write (rexport)\n    call ucd_release (rexport)\n    \n    ! calculate the error to the reference function.\n    call pperr_scalar (pperr_l2error,derror,rvecsol%rvectorblock(1),&\n        getreferencefunction_3d, rcubatureinfo=rlevels(nlmax)%rcubatureinfo)\n    call output_line (\"l2-error: \" // sys_sdel(derror,10) )\n\n    call pperr_scalar (pperr_h1error,derror,rvecsol%rvectorblock(1),&\n        getreferencefunction_3d, rcubatureinfo=rlevels(nlmax)%rcubatureinfo)\n    call output_line (\"h1-error: \" // sys_sdel(derror,10) )\n    \n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    ! clean up\n    ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    \n    ! we are finished - but not completely!\n    ! now, clean up so that all the memory is available again.\n    !\n    ! release solver data and structure\n    call linsol_donedata (p_rsolvernode)\n    call linsol_donestructure (p_rsolvernode)\n    \n    ! release the solver node and all subnodes attached to it (if at all):\n    call linsol_releasesolver (p_rsolvernode)\n    \n    ! release the block matrices/vectors\n    call lsysbl_releasevector (rvectmp)\n    call lsysbl_releasevector (rvecsol)\n    call lsysbl_releasevector (rvecrhs)\n    do i = nlmax, nlmin, -1\n      call lsysbl_releasematrix (rlevels(i)%rmatrix)\n    end do\n\n    ! release the filter chain\n    do i = nlmax, nlmin, -1\n      call filter_donefilterchain (rlevels(i)%rfilterchain,rlevels(i)%nfilters)\n    end do\n\n    ! release our discrete version of the boundary conditions\n    do i = nlmax, nlmin, -1\n      call bcasm_releasediscretebc (rlevels(i)%rdiscretebc)\n    end do\n\n    ! release the cubature info structures\n    do i=nlmax,nlmin,-1\n      call spdiscr_releasecubstructure(rlevels(i)%rcubatureinfo)\n    end do\n\n    ! release the discretisation structure and all spatial discretisation\n    ! structures in it.\n    do i = nlmax, nlmin, -1\n      call spdiscr_releaseblockdiscr(rlevels(i)%rdiscretisation)\n    end do\n    \n    ! release the triangulation.\n    do i = nlmax, nlmin, -1\n      call tria_done (rlevels(i)%rtriangulation)\n    end do\n    \n    deallocate(rlevels)\n\n\n  end subroutine\n"}
{"id": 877, "subroutine": "   subroutine elementalloc(e,memor,runam)\n      use typre\n      use mod_memor\n      implicit none\n      class(finiteelement) :: e\n      character(*) :: runam\n      type(memoryman) :: memor\n\n      call memor%palloc(e%mnode,e%lnods,'e%lnods',runam)\n      call memor%alloc(e%ndime,e%mnode,e%elcod,'e%elcod',runam)\n\n      call memor%alloc(e%mnodb,e%lnodb,'e%lnodb',runam)\n      call memor%alloc(e%ndime,e%mnodb,e%bocod,'e%bocod',runam)\n      call memor%palloc(e%ndime,e%ndime,e%baloc,'e%baloc',runam)\n\n      call memor%palloc(e%ndime,e%mnode,e%cartd,'e%cartd',runam)\n      call memor%palloc(e%ndime,e%mnode,e%cartb,'e%cartb',runam)\n      call memor%palloc(e%ndime,e%ndime,e%xjaci,'e%xjaci',runam)\n      call memor%palloc(e%ndime,e%ndime,e%xjacm,'e%xjacm',runam)\n      call memor%palloc(e%ndime,e%ndime,e%tragl,'e%tragl',runam)\n      call memor%palloc(e%ndime        ,e%hleng,'e%hleng',runam)\n\n      if(e%mlapl>0) then\n         call memor%palloc(e%ntens,e%mnode*e%mlapl        ,e%hessi,'e%hessi',runam)\n      end if\n\n   end subroutine\n"}
{"id": 878, "subroutine": "   subroutine elementdealloc(e,memor,runam)\n      use typre\n      use mod_memor\n      implicit none\n      class(finiteelement) :: e\n      type(memoryman) :: memor\n      character(*) :: runam\n\n      call memor%pdealloc(size(e%lnods,1),e%lnods,'e%lnods',runam)\n      call memor%dealloc(e%ndime,size(e%elcod,2),e%elcod,'e%elcod',runam)\n\n      call memor%dealloc(e%mnodb,e%lnodb,'e%lnodb',runam)\n      call memor%dealloc(e%ndime,e%mnodb,e%bocod,'e%bocod',runam)\n      call memor%pdealloc(e%ndime,e%ndime,e%baloc,'e%baloc',runam)\n\n      call memor%pdealloc(e%ndime,size(e%cartd,2),e%cartd,'e%cartd',runam)\n      call memor%pdealloc(e%ndime,size(e%cartb,2),e%cartb,'e%cartb',runam)\n      call memor%pdealloc(e%ndime,e%ndime,e%xjaci,'e%xjaci',runam)\n      call memor%pdealloc(e%ndime,e%ndime,e%xjacm,'e%xjacm',runam)\n      call memor%pdealloc(e%ndime,e%ndime,e%tragl,'e%tragl',runam)\n      call memor%pdealloc(e%ndime        ,e%hleng,'e%hleng',runam)\n\n      if(e%mlapl>0) then\n         call memor%pdealloc(e%ntens,size(e%hessi,2),e%hessi,'e%hessi',runam)\n      end if\n\n      if(e%mparticulargausspoints /= 0)then\n         call e%deallocparticulargausspoints(memor)\n         e%mparticulargausspoints = 0\n      end if\n   end subroutine\n"}
{"id": 879, "subroutine": "   subroutine elementelmdel(e)\n      implicit none\n      class(finiteelement) :: e\n\n      e%kfl_isalreadycomputedlinearderivatives = .true.\n      if (e%linea == 1) call elmdel(e%pnode,e%ndime,e%elcod,e%cartd,e%detjm,e%linea,e%xjacm,e%xjaci)\n   end subroutine\n"}
{"id": 880, "subroutine": "   subroutine elementelmdcg(e)\n      implicit none\n      class(finiteelement) :: e\n\n      if (e%linea == 1) then\n         if (e%kfl_isalreadycomputedlinearderivatives .eqv. .false.) then\n            call elementelmdel(e)\n         endif\n      else\n         call elmder(e%pnode,e%ndime,e%dercg,e%elcod,e%cartd,e%detjm,e%xjacm,e%xjaci)\n      endif\n\n   end subroutine\n"}
{"id": 881, "subroutine": "   subroutine subelementdetjm(e,subelcod)\n      implicit none\n      class(finiteelement) :: e\n      real(rp)  :: subelcod(e%ndime,e%pnode)\n\n      if (e%linea == 1) then\n         call elemdetjm(e%pnode,e%ndime,subelcod,e%subdetjm)\n      else\n         call elmder(e%pnode,e%ndime,e%dercg,subelcod,e%cartd,e%subdetjm,e%xjacm,e%xjaci)\n      endif\n\n   end subroutine\n"}
{"id": 882, "subroutine": "   subroutine elementelmhes(e)\n      implicit none\n      class(finiteelement) :: e\n\n      if (e%linea == 1) then\n      else\n         call elmhes(e%heslo(1,1,e%igaus),e%hessi,e%ndime,e%pnode,e%ntens,e%xjaci,e%deriv(1,1,e%igaus),e%elcod)\n      endif\n\n   end subroutine\n"}
{"id": 883, "subroutine": "   subroutine elementelmderb(e)\n      implicit none\n      class(finiteelement) :: e\n\n      integer(ip) :: inode,idime,inodb,igaus\n      real(rp)    :: aux1\n\n      if (e%linea == 1) then\n         if (e%kfl_isalreadycomputedlinearderivatives .eqv. .false.) then\n            call elementelmdel(e)\n         endif\n         e%cartb = e%cartd\n      else\n          e%cartb=0.0_rp\n          do igaus=1,e%pgaus\n            e%igaus = igaus\n            call e%elmder\n            do inodb=1,e%pnodb\n               aux1 = e%shapb(inodb,e%igaub)*e%shaga(igaus,e%lboel(inodb))\n                do inode=1,e%pnode\n                  do idime=1,e%ndime\n                     e%cartb(idime,inode)=e%cartb(idime,inode)&\n                        +aux1*e%cartd(idime,inode)\n                  end do\n               end do\n            end do\n         end do\n      endif\n\n   end subroutine\n"}
{"id": 884, "subroutine": "   subroutine elementgather(e,ndime,elval,glval)\n      implicit none\n      class(finiteelement)  :: e\n      integer(ip)           :: ndime\n      real(rp), intent(in)  :: glval(ndime,*)\n      real(rp), intent(out) :: elval(ndime,e%pnode)\n      integer(ip) :: inode,ipoin\n\n      elval(:,:) = glval(:,e%lnods(1:e%pnode))\n\n   end subroutine\n"}
{"id": 885, "subroutine": "   subroutine boundarygather(e,ndime,elval,glval)\n      implicit none\n      class(finiteelement)  :: e\n      integer(ip)           :: ndime\n      real(rp), intent(in)  :: glval(ndime,*)\n      real(rp), intent(out) :: elval(ndime,e%pnodb)\n      integer(ip) :: inode,ipoin\n\n      elval(:,:) = glval(:,e%lnodb(1:e%pnodb))\n\n   end subroutine\n"}
{"id": 886, "subroutine": "   subroutine elementbounor(e)\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: cocog(e%ndime),produ\n      integer(ip) :: idime\n\n      !evaluates the tangent vectors\n      call mbmabt(e%baloc,e%bocod,e%derib(1,1,e%igaub),e%ndime,e%ndime-1,e%pnodb)\n\n      !computes the normal vector\n      if(e%ndime==2) then\n         e%baloc(1,2)= e%baloc(2,1)\n         e%baloc(2,2)=-e%baloc(1,1)\n      else\n         call vecpro(e%baloc(1,1),e%baloc(1,2),e%baloc(1,3),3)\n      end if\n\n      !computes the euclidian norm of the normal vector\n      call vecnor(e%baloc(1,e%ndime),e%ndime,e%eucta,2)\n\n      !coordinates center of gravity\n      do idime = 1,e%ndime\n         cocog(idime) = sum(e%elcod(idime,1:e%pnode))/real(e%pnode)\n      enddo\n\n      !normalize baloc\n      do idime=1,e%ndime\n         call vecuni(e%ndime,e%baloc(1,idime),produ)\n      end do\n\n      !ensure tangential vectors orthogonality\n      if (e%ndime == 3) then\n         produ = dot_product(e%baloc(1:e%ndime,1),e%baloc(1:e%ndime,2))\n         e%baloc(:,2) = e%baloc(:,2) - produ*e%baloc(:,1)\n         call vecuni(e%ndime,e%baloc(1,2),produ)\n      endif\n\n      !calculate n.v\n      produ=dot_product(cocog(1:e%ndime)-e%bocod(1:e%ndime,1),&\n            e%baloc(1:e%ndime,e%ndime))\n\n      !if n.v > 0, the normal is not the external one\n      if(produ>0.0_rp) then\n         e%baloc(:,1)     = -e%baloc(:,1)             !t1=-t1\n         e%baloc(:,e%ndime) = -e%baloc(:,e%ndime)     !n =-n\n      end if\n\n   end subroutine\n"}
{"id": 887, "subroutine": "   subroutine elementelmlen(e)\n      implicit none\n      class(finiteelement) :: e\n\n      real(rp)    :: enor0,h_tem\n      integer(ip) :: idime,jdime\n\n       if (e%linea == 0) then\n         e%xjacm=matmul(e%elcod(:,1:e%pnode),transpose(e%dercg(:,1:e%pnode))) ! j^t\n         call invmtx(e%xjacm,e%tragl,e%detjm,e%ndime) ! j^(-t)\n      else\n         e%tragl = e%xjaci\n      endif\n\n      !element length\n      do idime=1,e%ndime\n         enor0=0.0_rp\n         do jdime=1,e%ndime\n            enor0=enor0+e%tragl(idime,jdime)**2\n         end do\n         enor0=sqrt(enor0)\n         !call vecnor(tragl(1,idime),ndime,enor0,2)\n         e%hleng(idime)=e%hnatu/enor0\n      end do\n\n      !sort hleng: hleng(1)=max; hleng(ndime)=min\n      do idime=1,e%ndime-1\n         do jdime=idime+1,e%ndime\n            if(e%hleng(jdime)>e%hleng(idime)) then  !swap\n               h_tem       =e%hleng(jdime)\n               e%hleng(jdime)=e%hleng(idime)\n               e%hleng(idime)=h_tem\n            end if\n         end do\n      end do\n\n   end subroutine\n"}
{"id": 888, "subroutine": "   subroutine interpc(e,ndime,elvar,gpvar)\n      implicit none\n      class(finiteelement) :: e\n      integer(ip), intent(in) :: ndime\n      real(rp), intent(in)    :: elvar(ndime,e%pnode)\n      real(rp), intent(out) :: gpvar(ndime)\n\n      !integer(ip)             :: inode,idime\n\n      gpvar = matmul(elvar,e%shacg(1:e%pnode))\n      !do idime=1,e%ndime\n      !   gpvar(idime)=0.0_rp\n      !   do inode=1,e%pnode\n      !      gpvar(idime) = gpvar(idime) + e%shacg(inode)*elvar(idime,inode)\n      !   end do\n      !end do\n   end subroutine\n"}
{"id": 889, "subroutine": "   pure subroutine interpg(e,ndime,elvar,gpvar)\n\n      implicit none\n      class(finiteelement), intent(in)  :: e\n      !class(finiteelement)              :: e\n      integer(ip)         , intent(in)  :: ndime\n      real(rp)            , intent(in)  :: elvar(ndime,e%pnode)\n      real(rp)            , intent(out) :: gpvar(ndime)\n\n      !integer(ip)             :: inode,idime\n\n      gpvar = matmul(elvar,e%shape(1:e%pnode,e%igaus))\n   end subroutine\n"}
{"id": 890, "subroutine": "   subroutine interpb(e,ndime,bovar,gpvar)\n      implicit none\n      class(finiteelement) :: e\n      integer(ip), intent(in) :: ndime\n      real(rp), intent(in)    :: bovar(ndime,e%pnodb)\n      real(rp), intent(out) :: gpvar(ndime)\n\n      !integer(ip)             :: inodb,idime\n\n      gpvar = matmul(bovar,e%shapb(1:e%pnodb,e%igaub))\n   end subroutine\n"}
{"id": 891, "subroutine": "   subroutine hessian(e,ndofn,elvar,hessvar)\n      implicit none\n      class(finiteelement) :: e\n      integer(ip), intent(in) :: ndofn\n      real(rp) :: elvar(ndofn,e%pnode), hessvar(ndofn,e%ntens)\n\n      hessvar = matmul(elvar,transpose(e%hessi(:,1:e%pnode)))\n   end subroutine\n"}
{"id": 892, "subroutine": "   subroutine gradient(e,ndofn,elvar,grvar)\n      implicit none\n      class(finiteelement) :: e\n      integer(ip), intent(in) :: ndofn\n      real(rp) :: elvar(ndofn,e%pnode), grvar(ndofn,e%ndime)\n\n      grvar = matmul(elvar,transpose(e%cartd(:,1:e%pnode)))\n   end subroutine\n"}
{"id": 893, "subroutine": "   subroutine divergence(e,elvar,divvar)\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: elvar(e%ndime,e%pnode), divvar\n\n      integer(ip) :: idime,inode\n\n      divvar = 0.0_rp\n      do inode=1,e%pnode\n         do idime=1,e%ndime\n             divvar = divvar + e%cartd(idime,inode)*elvar(idime,inode)\n          end do\n      end do\n   end subroutine\n"}
{"id": 894, "subroutine": "   subroutine isopar(e,ncomp,xloc,elval,xval)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      integer(ip) :: ncomp\n      real(rp) :: xloc(e%ndime), xval(ncomp),elval(ncomp,*)\n\n      if (e%linea == 1) then\n         call linear_isopar(e,ncomp,xloc,elval,xval)\n      else\n         call runend('finiteelement: isopar only ready for linear elements')\n      endif\n   end subroutine\n"}
{"id": 895, "subroutine": "   subroutine linear_isopar(e,ncomp,xloc,elval,xval)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      integer(ip) :: ncomp\n      real(rp) :: xloc(e%ndime), xval(ncomp),elval(ncomp,*)\n\n\n      real(rp) :: xjacm(ncomp,e%ndime)\n      real(rp) :: b(ncomp),denom\n      integer(ip) :: i\n\n      if (e%ndime == 2) then\n         xjacm(:,1) = elval(:,2)-elval(:,1);\n         xjacm(:,2) = elval(:,3)-elval(:,1);\n         b(:) = elval(:,1);\n         xval(:) = xjacm(:,1)*xloc(1)+xjacm(:,2)*xloc(2)+b(:);\n\n      else if (e%ndime == 3) then\n         xjacm(:,1) = elval(:,2)-elval(:,1)\n         xjacm(:,2) = elval(:,3)-elval(:,1)\n         xjacm(:,3) = elval(:,4)-elval(:,1)\n\n         b(:) = elval(:,1)\n         xval(:) = xjacm(:,1)*xloc(1)+xjacm(:,2)*xloc(2)+xjacm(:,3)*xloc(3)+b(:);\n      endif\n\n   end subroutine\n"}
{"id": 896, "subroutine": "   subroutine isoparinv(e,xglob,xloc)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: xloc(e%ndime), xglob(e%ndime)\n\n      if (e%linea == 1) then\n         call linear_isoparinv(e,xglob,xloc)\n      else\n         call nonlinear_isoparinv(e,xglob,xloc)\n      endif\n\n\n   end subroutine\n"}
{"id": 897, "subroutine": "   subroutine linear_isoparinv(e,xglob,xloc)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: xloc(e%ndime), xglob(e%ndime)\n\n      real(rp) :: xjacm(e%ndime,e%ndime)\n      real(rp) :: b(e%ndime),denom,detjm, xjaci(e%ndime,e%ndime)\n      integer(ip) :: i\n\n      if (e%ndime == 2) then\n         xjacm(:,1) = e%elcod(:,2)-e%elcod(:,1);\n         xjacm(:,2) = e%elcod(:,3)-e%elcod(:,1);\n\n         b(:) = xglob(:)-e%elcod(:,1);\n         detjm = xjacm(1,1)*xjacm(2,2)-xjacm(1,2)*xjacm(2,1);\n         denom = 1.0_rp/detjm;\n         xloc(1) = (b(1)*xjacm(2,2)-b(2)*xjacm(1,2))*denom;\n         xloc(2) = (-b(1)*xjacm(2,1)+b(2)*xjacm(1,1))*denom;\n      else if (e%ndime == 3) then\n         xjacm(:,1) = e%elcod(:,2)-e%elcod(:,1)\n         xjacm(:,2) = e%elcod(:,3)-e%elcod(:,1)\n         xjacm(:,3) = e%elcod(:,4)-e%elcod(:,1)\n\n         !inverse matrix\n         xjaci(1,1)  = xjacm(2,2)*xjacm(3,3) - xjacm(3,2)*xjacm(2,3)\n         xjaci(2,1)  =-xjacm(2,1)*xjacm(3,3) + xjacm(3,1)*xjacm(2,3)\n         xjaci(3,1)  = xjacm(2,1)*xjacm(3,2) - xjacm(3,1)*xjacm(2,2)\n         xjaci(2,2) =  xjacm(1,1)*xjacm(3,3) - xjacm(3,1)*xjacm(1,3)\n         xjaci(3,2) = -xjacm(1,1)*xjacm(3,2) + xjacm(1,2)*xjacm(3,1)\n         xjaci(3,3) =  xjacm(1,1)*xjacm(2,2) - xjacm(2,1)*xjacm(1,2)\n         xjaci(1,2) = -xjacm(1,2)*xjacm(3,3) + xjacm(3,2)*xjacm(1,3)\n         xjaci(1,3) =  xjacm(1,2)*xjacm(2,3) - xjacm(2,2)*xjacm(1,3)\n         xjaci(2,3) = -xjacm(1,1)*xjacm(2,3) + xjacm(2,1)*xjacm(1,3)\n         detjm = xjacm(1,1)*xjaci(1,1) + xjacm(1,2)*xjaci(2,1)+ xjacm(1,3)*xjaci(3,1)\n         denom=1.0_rp/detjm\n         xjaci = xjaci*denom\n\n         b(:) = xglob(:)-e%elcod(:,1)\n         forall (i = 1:e%ndime)\n            xloc(i) = dot_product(xjaci(i,:),b(:))\n         end forall\n      endif\n\n   end subroutine\n"}
{"id": 898, "subroutine": "   subroutine nonlinear_isoparinv(e,xglob,xloc)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: xloc(e%ndime),xglob(e%ndime)\n\n      real(rp) :: xjaci(e%ndime,e%ndime)\n      real(rp) :: xjacm(e%ndime,e%ndime)\n      real(rp) :: shape(e%pnode)\n      real(rp) :: deriv(e%ndime,e%pnode)\n      real(rp) :: heslo(e%ntens,e%pnode)\n      real(rp) :: f_prev(e%ndime),delta(e%ndime),error,norm,detjm,cartd(e%ndime,e%pnode)\n      integer(ip) :: idime,jdime,inode,maxit,i\n\n      xloc = 0.0_rp\n      error = 1.0_rp\n      maxit = 6\n      i = 1\n\n      do while (i<=maxit .and. error>0.0000000001)\n         call shafun(xloc,e%ndime,e%pnode,e%ntens,shape,deriv,heslo)\n         call elmder(e%pnode,e%ndime,deriv,e%elcod,cartd,detjm,xjacm,xjaci)\n\n         f_prev = 0.0_rp\n         do idime=1,e%ndime\n            do inode=1,e%pnode\n               f_prev(idime) = f_prev(idime) - shape(inode)*e%elcod(idime,inode)\n            end do\n            f_prev(idime) = f_prev(idime) + xglob(idime)\n         end do\n\n         call mbvab1(delta,xjaci,f_prev,e%ndime,e%ndime,error,norm)\n         xloc = xloc + delta\n         i = i + 1\n      end do\n   end subroutine\n"}
{"id": 899, "subroutine": "   subroutine forceclosedrule(e)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      !if this is set, a close quadrature is enforced\n      !this is necessary for integrating the rhs of a smoothing\n      !also the lhs (vmass)\n\n      e%kfl_closedrule = 1\n   end subroutine\n"}
{"id": 900, "subroutine": "   subroutine defaultrule(e)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      !the default integration rule for the problem is used\n\n      e%kfl_closedrule = 0\n   end subroutine\n"}
{"id": 901, "subroutine": "   subroutine computeshafun(e,xloc,newshape)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      real(rp) :: xloc(e%ndime),shape(e%pnode),deriv(e%ndime,e%pnode),heslo(e%ntens,e%pnode)\n      real(rp), intent(out) :: newshape(e%pnode)\n\n      call shafun(xloc,e%ndime,e%pnode,e%ntens,shape,deriv,heslo)\n      newshape = shape\n\n   end subroutine\n"}
{"id": 902, "subroutine": "   subroutine setparticulargausspoints(e,memor,pgaus,posgp,weigp)\n      use typre\n      use mod_memor\n      implicit none\n      class(finiteelement), target :: e\n      type(memoryman) :: memor\n\n      integer(ip), intent(in) :: pgaus\n      real(rp), intent(in)    :: posgp(:,:),weigp(:)\n      integer(ip)             :: igaus\n\n      if(pgaus > e%mparticulargausspoints)then\n\n         if(e%mparticulargausspoints /= 0)then\n\n            call memor%realloc(e%mnode,pgaus,e%particularshape,'e%particularshape','setparticulargausspoints')\n            call memor%realloc(e%ndime,e%mnode,pgaus,e%particularderiv,'e%particularderiv','setparticulargausspoints')\n            call memor%realloc(e%ntens,e%mnode,pgaus,e%particularheslo,'e%particularheslo','setparticulargausspoints')\n            call memor%realloc(pgaus,e%particularweigp,'e%particularweigp','setparticulargausspoints')\n\n         else\n\n            call memor%alloc(e%mnode,pgaus,e%particularshape,'e%particularshape','setparticulargausspoints')\n            call memor%alloc(e%ndime,e%mnode,pgaus,e%particularderiv,'e%particularderiv','setparticulargausspoints')\n            call memor%alloc(e%ntens,e%mnode,pgaus,e%particularheslo,'e%particularheslo','setparticulargausspoints')\n            call memor%alloc(pgaus,e%particularweigp,'e%particularweigp','setparticulargausspoints')\n            call memor%alloc(e%ndime,e%mnode,e%particularcartd,'e%particularcartd','setparticulargausspoints')\n\n         end if\n\n         e%mparticulargausspoints=pgaus\n         !to enforce the reallocation of the enriched elements when we change mparticulargausspoints\n         e%mpnode=0\n      end if\n\n      e%pgaus = pgaus\n      do igaus = 1,e%pgaus\n         e%igaus = igaus\n         call shafun(posgp(1,e%igaus),e%ndime,e%pnode,e%ntens,e%particularshape(1,e%igaus),e%particularderiv(1,1,e%igaus),e%particularheslo(1,1,e%igaus))\n      end do\n\n      e%particularweigp(1:pgaus) = weigp(1:pgaus)\n\n\n      e%shape => e%particularshape\n      e%deriv => e%particularderiv\n      e%heslo => e%particularheslo\n      e%weigp => e%particularweigp\n\n      e%ielty0 = -1\n\n\n   end subroutine\n"}
{"id": 903, "subroutine": "   subroutine setenrichedelement(e,memor,newpnode,kshape,ngauss_minus,ngauss_plus,nodestatus)\n      use typre\n      use mod_memor\n      implicit none\n      class(finiteelement), target :: e\n      type(memoryman) :: memor\n      integer(ip), intent(in) :: newpnode,ngauss_minus,ngauss_plus,nodestatus(e%pnode)\n      real(rp), intent(in)    :: kshape(e%pnode)\n      integer(ip) :: inode,gauss_points(2,e%pnode)\n\n      if (newpnode > e%mnode) then\n         if (e%mpnode== 0) then\n            call memor%realloc(newpnode,e%pgaus,e%particularshape,'e%particularshape','setparticulargausspoints')\n            call memor%realloc(e%ndime,newpnode,e%pgaus,e%particularderiv,'e%particularderiv','setparticulargausspoints')\n            call memor%realloc(e%ntens,newpnode,e%pgaus,e%particularheslo,'e%particularheslo','setparticulargausspoints')\n            call memor%realloc(e%pgaus,e%particularweigp,'e%particularweigp','setparticulargausspoints')\n            call memor%realloc(e%ndime,newpnode,e%particularcartd,'e%particularcartd','setparticulargausspoints')\n         end if\n         e%mpnode=newpnode\n      end if\n\n      do inode = 1,e%pnode\n         if (nodestatus(inode) < 0) then\n            gauss_points(1,inode) = ngauss_minus+1\n            gauss_points(2,inode) = ngauss_minus+ngauss_plus\n         else\n            gauss_points(1,inode) = 1\n            gauss_points(2,inode) = ngauss_minus\n         endif\n      enddo\n\n      e%particularshape(e%pnode+1,:)=0.0_rp\n      e%particularderiv(1:e%ndime,e%pnode+1,:)=0.0_rp\n      e%particularheslo(1:e%ntens,e%pnode+1,:)=0.0_rp\n\n      !enriched shape function contruction\n      do inode = 1,e%pnode\n         e%particularshape(e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) = e%particularshape(e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) + &\n               e%particularshape(inode,gauss_points(1,inode):gauss_points(2,inode))*kshape(inode)\n\n         e%particularderiv(1:e%ndime,e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) = e%particularderiv(1:e%ndime,e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) + &\n               e%particularderiv(1:e%ndime,inode,gauss_points(1,inode):gauss_points(2,inode))*kshape(inode)\n\n         e%particularheslo(1:e%ntens,e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) = e%particularheslo(1:e%ntens,e%pnode+1,gauss_points(1,inode):gauss_points(2,inode)) + &\n               e%particularheslo(1:e%ntens,inode,gauss_points(1,inode):gauss_points(2,inode))*kshape(inode)\n      enddo\n\n      e%shape => e%particularshape\n      e%deriv => e%particularderiv\n      e%heslo => e%particularheslo\n      e%weigp => e%particularweigp\n      e%ielty0 = -1\n   end subroutine\n"}
{"id": 904, "subroutine": "   subroutine deallocparticulargausspoints(e,memor)\n      use typre\n      use mod_memor\n      implicit none\n      class(finiteelement) :: e\n      type(memoryman) :: memor\n\n      call memor%dealloc(size(e%particularshape,1),e%mparticulargausspoints,e%particularshape,'e%particularshape','deallocparticulargausspoints')\n      call memor%dealloc(e%ndime,size(e%particularderiv,2),e%mparticulargausspoints,e%particularderiv,'e%particularderiv','deallocparticulargausspoints')\n      call memor%dealloc(e%ntens,size(e%particularheslo,2),e%mparticulargausspoints,e%particularheslo,'e%particularheslo','deallocparticulargausspoints')\n      call memor%dealloc(e%mparticulargausspoints,e%particularweigp,'e%particularweigp','deallocparticulargausspoints')\n      call memor%dealloc(e%ndime,size(e%particularcartd,2),e%particularcartd,'e%particularcartd','deallocparticulargausspoints')\n   end subroutine\n"}
{"id": 905, "subroutine": "   subroutine gausstonodes(e,gaussarray,nodalarray)\n      class(finiteelement) :: e\n      real(rp) :: gaussarray(:,:), nodalarray(:,:)\n      real(rp) :: mass(e%pnode,e%pnode)\n      real(rp) :: transposenodal(size(nodalarray,2),size(nodalarray,1))\n      integer(ip) :: ipiv(e%pnode),info\n      integer(ip) :: igaus,inode,jnode,ndofn\n\n      ndofn = size(gaussarray,1)\n      mass = 0.0_rp\n      nodalarray = 0.0_rp\n      !build local mass matrix\n      do igaus = 1,e%pgaus\n         e%igaus = igaus\n         do inode = 1,e%pnode\n            do jnode = 1,e%pnode\n               mass(inode,jnode) = mass(inode,jnode) + e%shape(inode,e%igaus)*e%shape(jnode,e%igaus)\n            enddo\n            nodalarray(:,inode) = nodalarray(:,inode) + e%shape(inode,e%igaus)*gaussarray(:,e%igaus)\n         enddo\n      enddo\n      transposenodal = transpose(nodalarray)\n      call dgesv( e%pnode, ndofn, mass, e%pnode, ipiv, transposenodal, e%pnode, info )\n      nodalarray = transpose(transposenodal)\n   end subroutine\n"}
{"id": 906, "subroutine": "   subroutine gausstonodesb(e,gaussarray,nodalarray)\n      class(finiteelement) :: e\n      real(rp) :: gaussarray(:,:), nodalarray(:,:)\n      real(rp) :: mass(e%pnodb,e%pnodb)\n      real(rp) :: transposenodal(size(nodalarray,2),size(nodalarray,1))\n      integer(ip) :: ipiv(e%pnodb),info\n      integer(ip) :: igaub,inodb,jnodb,ndofn\n\n      ndofn = size(gaussarray,1)\n      mass = 0.0_rp\n      nodalarray = 0.0_rp\n      !build local mass matrix\n      do igaub = 1,e%pgaub\n         e%igaub = igaub\n         do inodb = 1,e%pnodb\n            do jnodb = 1,e%pnodb\n               mass(inodb,jnodb) = mass(inodb,jnodb) + e%shapb(inodb,e%igaub)*e%shapb(jnodb,e%igaub)\n            enddo\n            nodalarray(:,inodb) = nodalarray(:,inodb) + e%shapb(inodb,e%igaub)*gaussarray(:,e%igaub)\n         enddo\n      enddo\n      transposenodal = transpose(nodalarray)\n      call dgesv( e%pnodb, ndofn, mass, e%pnodb, ipiv, transposenodal, e%pnodb, info )\n      nodalarray = transpose(transposenodal)\n   end subroutine\n"}
{"id": 907, "subroutine": "   subroutine getweightfactor(e,weightfactor)\n      use typre\n      implicit none\n      class(finiteelement) :: e\n      real(rp), intent(out) :: weightfactor\n\n      weightfactor = 1.0-real(count(e%lnods(1:e%pnode)>e%npoinlocal))/real(e%pnode)\n\n   end subroutine\n"}
{"id": 908, "subroutine": "  subroutine show_usage()\n     write(*,*) 'usage :'//trim(appname)// &\n     '[-h] [-fg_lores filename] [-an_lores filename] [-fg_hires filename] [-ns n ] [-o outputfile]'\n     write(*,*) \"  -fg_lores    optional, low resulotion first guess file,                 default - fg\"\n     write(*,*) \"  -an_lores    optional, low resulotion analysis file comes from wrfvar,  default - wrfvar_output\"\n     write(*,*) \"  -fg_hires    optional, high resultion first guess file,                 default - wrfinput_hires\"\n     write(*,*) \"  -ns          optional, the refinement ratio between two resulotions,    default - 3\"\n     write(*,*) \"  -o           optional, output high resulotion analysis file,            default - wrfvar_output_hires\"\n     write(*,*) \"  -h           show this help\"\n  end subroutine show_usage\n"}
{"id": 909, "subroutine": "  subroutine bilin(old,xi,yi,ns,new,xo,yo)\n\n! assume: xo = (xi-1)*ns + 1, xi=50, xo=49*3+1=148\n!         yo = (yi-1)*ns + 1\n\n    implicit none\n\n    integer,                 intent(in) :: xi,yi,xo,yo\n    real, dimension(xi,yi),  intent(in) :: old\n    integer,                 intent(in) :: ns\n    real, dimension(xo,yo),  intent(out):: new\n\n    real  :: im(1:ns+1,2)\n!    real  :: imm(1:ns+3,2)\n    integer:: i,j,jm1,im1,ix1,ix2,iy1,iy2\n\n    forall(i=1:ns+1) im(i,2) = real(i-1)/ns\n      im(:,1) = 1 - im(:,2)\n\n    do j=2,yi\n      jm1 = j - 1\n      iy2 = jm1 * ns + 1\n      iy1 = iy2 - ns\n      do i=2,xi\n        im1 = i - 1\n        ix2 = im1 * ns + 1\n        ix1 = ix2 - ns\n        new(ix1:ix2,iy1:iy2) = matmul(im,matmul(old(im1:i,jm1:j),transpose(im)))\n      end do\n    end do\n\n\n   !   ns = ns + 2\n   ! forall(i=1:ns+1) imm(i,2) = real(i-1)/ns\n   !   imm(:,1) = 1 - imm(:,2)\n!\n!      j=yi\n!      jm1 = j - 1\n!      iy2 = jm1 * ns + 1\n!      iy1 = iy2 - ns\n!\n!      i=xi\n!        im1 = i - 1\n!        ix2 = im1 * ns + 1\n!        ix1 = ix2 - ns\n!        new(ix1:ix2,iy1:iy2) = matmul(imm,matmul(old(im1:i,jm1:j),transpose(imm)))\n!      end do\n!    end do\n\n  end subroutine bilin\n"}
{"id": 910, "subroutine": "pure subroutine levquadrature_lmlq_rsp( n,xa,xp,wa,wp,nm )\n!!#### local kinds\nuse knd_intrinsictypes,only: kind_r=>kind_rsp !!((01-a-knd_intrinsictypes.f90))\ninclude \"08-b-sub_levquadrature_lmlq.f90.hdr\"\n!!--begin--\ninclude \"08-b-sub_levquadrature_lmlq.f90.bdy\"\n!!--end--\nend subroutine\n"}
{"id": 911, "subroutine": "  subroutine init_base_state(s0_init,p0_init,rho0,rhoh0,p0,tempbar,tempbar_init) &\n       bind(c, name=\"init_base_state\")\n\n    double precision, intent(inout) :: s0_init(0:max_radial_level,0:nr_fine-1,1:nscal)\n    double precision, intent(inout) :: p0_init(0:max_radial_level,0:nr_fine-1)\n    double precision, intent(inout) ::    rho0(0:max_radial_level,0:nr_fine-1)\n    double precision, intent(inout) ::   rhoh0(0:max_radial_level,0:nr_fine-1)\n    double precision, intent(inout) ::      p0(0:max_radial_level,0:nr_fine-1)\n    double precision, intent(inout) :: tempbar(0:max_radial_level,0:nr_fine-1)\n    double precision, intent(inout) :: tempbar_init(0:max_radial_level,0:nr_fine-1)\n\n    ! local variables\n    integer :: ihe4, ic12, ife56\n    integer :: n,r\n    type (eos_t) :: eos_state\n\n    ihe4  = network_species_index(\"helium-4\")\n    ic12  = network_species_index(\"carbon-12\")\n    ife56 = network_species_index(\"iron-56\")\n\n    if (ihe4 < 0 .or. ic12 < 0 .or. ife56 < 0) then\n       print *, ihe4, ic12, ife56\n       call amrex_error(\"invalid species in init_base_state.\")\n    endif\n\n    eos_state%h         = ambient_h\n    eos_state%rho       = ambient_dens\n\n    eos_state%xn(:) = zero\n    eos_state%xn(ihe4)  = ambient_he4\n    eos_state%xn(ic12)  = ambient_c12\n    eos_state%xn(ife56) = ambient_fe56\n\n    call eos(eos_input_rh, eos_state)\n\n    diffusion_coefficient = const_conductivity / (eos_state%cp * ambient_dens)\n\n    do n=0,max_radial_level\n       do r=0,nr(n)-1\n\n          s0_init(n,r,rho_comp) = eos_state%rho\n          s0_init(n,r,rhoh_comp) = eos_state%rho * eos_state%h\n          s0_init(n,r,spec_comp:spec_comp+nspec-1) = eos_state%rho * eos_state%xn(1:nspec)\n          p0_init(n,r) = eos_state%p\n          s0_init(n,r,temp_comp) = eos_state%t\n\n       end do\n    end do ! end loop over levels\n\n    rho0 = s0_init(:,:,rho_comp)\n    rhoh0 = s0_init(:,:,rhoh_comp)\n    tempbar = s0_init(:,:,temp_comp)\n    tempbar_init = s0_init(:,:,temp_comp)\n    p0 = p0_init\n\n    ! initialize any inlet bc parameters\n    call set_inlet_bcs()\n\n  end subroutine init_base_state\n"}
{"id": 912, "subroutine": "  subroutine nf95_inq_varid(ncid, name, varid, ncerr)\n\n    use handle_err_m, only: handle_err\n    use netcdf, only: nf90_inq_varid\n\n    integer,             intent(in) :: ncid\n    character(len=*), intent(in):: name\n    integer,             intent(out) :: varid\n    integer, intent(out), optional:: ncerr\n\n    ! variable local to the procedure:\n    integer ncerr_not_opt\n\n    !-------------------\n\n    ncerr_not_opt = nf90_inq_varid(ncid, name, varid)\n    if (present(ncerr)) then\n       ncerr = ncerr_not_opt\n    else\n       call handle_err(\"nf95_inq_varid, name = \" // name, ncerr_not_opt, ncid)\n    end if\n\n  end subroutine nf95_inq_varid\n"}
{"id": 913, "subroutine": "  subroutine set_ic ! nb: nx, t_end etc is set in control.f90\n\n    real(num) :: rho_lo\n    real(num) :: rho_hi\n    real(num) :: p0_lo\n    real(num) :: fwtm, d\n    real(num) :: y\n\n    ! flow \n\n    u = 0.0_num\n    v = 0.0_num\n\n    ! free to either set rho0, then get rho from it via\n    !   rho(ix,iy = rho0(iy) + perturbation\n    ! or set rho(ix,iy) then calc \n    !   rho0(iy) =  1/nx sum_x (rho(ix,iy))\n    !\n    ! (i.e. user choice, all must be done in initial_conditions though)\n\n    ! simple case of unperturbed heavy on top of light (i.e. rho0(iy) = rho(:,iy) )\n\n    rho_lo = 1.0_num\n    rho_hi = 7.0_num\n    d = x_max - x_min\n    fwtm = 0.1_num *d\n\n    do iy = -1, ny+2\n      y = yc(iy)-0.5_num\n      y = y * 1.818_num / fwtm\n      rho0(iy) = rho_lo + 0.5_num * (rho_hi-rho_lo) * (1.0_num + tanh(y))\n      rho(-1:nx+2,iy) = rho0(iy)\n    enddo\n\n    ! calculate a hse background pressure p0 \n\n    p0_lo = 10.0_num ! just sets a gauge? \n        ! however, due to p0^(<1) terms, cant tolerate a negative number in the profile\n        ! so needs to be sufficiently high to not nan the betas \n\n    p0(-1) = p0_lo\n    do iy = 0, ny+2\n      p0(iy) = p0(iy-1) + 0.5_num * dy * (rho0(iy-1) + rho0(iy)) * grav_y\n    enddo\n\n\n  end subroutine set_ic\n"}
{"id": 914, "subroutine": "  subroutine shear_test_ic\n\n    real(num) :: x,y, rho_s, delta_s\n\n    rho_s = 42.0_num\n    delta_s = 0.05_num\n\n    do iy = -1,ny+1\n    do ix = -1,nx+1\n      x = xc(ix)\n      y = yc(iy)\n      if (y <= 0.5_num) then\n        u(ix,iy) =  tanh(rho_s * (y-0.25_num))\n      else\n        u(ix,iy) = tanh(rho_s * (0.75_num -y))\n      endif \n      v(ix,iy) = delta_s * sin(2.0_num * pi * x)\n    enddo\n    enddo\n\n    ! for homogeneous tests, should just be able to set background to uniform with \n    ! an arbitary pressure \n\n    rho = 1.0_num\n    rho0 = 1.0_num\n    p0 = 1.0_num\n\n  end subroutine shear_test_ic\n"}
{"id": 915, "subroutine": "  subroutine minion_test_ic\n\n    real(num) :: x,y\n\n    do iy = -1,ny+1\n    do ix = -1,nx+1\n      x = xc(ix)\n      y = yc(iy)\n      u(ix,iy) = 1.0_num - 2.0_num * cos(2.0_num*pi*x)*sin(2.0_num*pi*y)\n      v(ix,iy) = 1.0_num + 2.0_num * sin(2.0_num*pi*x)*cos(2.0_num*pi*y)\n    enddo\n    enddo\n\n    do iy = 1, ny\n    do ix = 1, nx\n      divu(ix,iy) = (u(ix+1,iy) - u(ix-1,iy))/dx/2.0_num &\n        & + (v(ix,iy+1) - v(ix,iy-1))/dy/2.0_num\n    enddo\n    enddo\n\n    ! for homogeneous tests, should just be able to set background to uniform with \n    ! an arbitary pressure \n\n    rho = 1.0_num\n    rho0 = 1.0_num\n    p0 = 1.0_num\n\n\n  end subroutine minion_test_ic\n"}
{"id": 916, "subroutine": "  subroutine vardens_adv_test_ic\n\n    real(num) :: x,y,r\n\n    u = 0.0_num\n    v = 1.0_num\n\n    rho = 1.0_num\n    do iy = -1,ny+1\n    do ix = -1,nx+1\n      x = xc(ix)-0.5_num\n      y = yc(iy)-0.5_num\n      r = sqrt(x**2 + y**2)\n      if (r <= 0.1_num) rho(ix,iy) = 2.0_num\n    enddo\n    enddo\n    print *, 'rho on grid',sum(rho(1:nx,1:ny)*dx*dy)\n\n    print *,'max numerical divu in ics',maxval(abs(divu))\n  end subroutine vardens_adv_test_ic\n"}
{"id": 917, "subroutine": "  subroutine rti1_ic\n\n    real(num) :: x, y \n    real(num) :: d, rho_lo, rho_hi\n    real(num) :: fwtm , amp\n    real(num) :: p0_lo\n\n    amp = 0.1_num\n\n    d = x_max - x_min\n    fwtm = 0.1_num *d\n    rho_lo = 1.0_num\n    rho_hi = 7.0_num \n\n    u = 0.0_num\n    v = 0.0_num \n\n    rho = rho_lo\n\n    do ix = -1, nx+1\n    do iy = -1, ny+2\n      x = xc(ix)\n\n      !now overwrite rho with the perturbed + desingularised profile\n      y = yc(iy) + amp * d * (cos(2.0_num * pi * x / d))\n      y = y * 1.818_num / fwtm\n      rho(ix,iy) = rho_lo + 0.5_num * (rho_hi-rho_lo) * (1.0_num + tanh(y))\n\n    enddo\n    enddo\n\n  ! calculate a consistent rho0 and p0\n\n    do iy = -1, ny+2\n      rho0(iy) = sum(rho(1:nx,iy)) / real(nx,num)\n    enddo\n\n    ! calculate a hse background pressure p0 \n\n    p0_lo = 100.0_num ! just sets a gauge? \n        ! however, due to p0^(<1) terms, cant tolerate a negative number in the profile\n        ! so needs to be sufficiently high to not nan the betas \n\n    p0(-1) = p0_lo\n    do iy = 0, ny+2\n      p0(iy) = p0(iy-1) + 0.5_num * dy * (rho0(iy-1) + rho0(iy)) * grav_y\n    enddo\n\n  end subroutine rti1_ic\n"}
{"id": 918, "subroutine": "  subroutine blob1_ic\n\n    real(num) :: x,y,r\n    real(num) :: p0_lo\n    ! this should probabally be de-singularised with a tanh profile on rho=rho(r)\n\n    u = 0.0_num\n    v = 0.0_num\n\n    grav_y = -1.0_num\n\n    rho = 1.0_num\n\n    do iy = -1,ny+1\n    do ix = -1,nx+1\n      x = xc(ix)-0.5_num\n      y = yc(iy)-0.5_num\n      r = sqrt(x**2 + y**2)\n      if (r <= 0.1_num) rho(ix,iy) = 0.8_num\n    enddo\n    enddo\n\n  ! calculate a consistent rho0 and p0\n\n    do iy = -1, ny+2\n      rho0(iy) = sum(rho(1:nx,iy)) / real(nx,num)\n    enddo\n\n    ! calculate a hse background pressure p0 \n\n    p0_lo = 100.0_num ! just sets a gauge? \n        ! however, due to p0^(<1) terms, cant tolerate a negative number in the profile\n        ! so needs to be sufficiently high to not nan the betas \n\n    p0(-1) = p0_lo\n    do iy = 0, ny+2\n      p0(iy) = p0(iy-1) + 0.5_num * dy * (rho0(iy-1) + rho0(iy)) * grav_y\n    enddo\n\n    print *, 'rho on grid',sum(rho(1:nx,1:ny)*dx*dy)\n\n  end subroutine blob1_ic\n"}
{"id": 919, "subroutine": "  subroutine circular_drop_ic\n              \n    real(num) :: x,y,r\n    real(num) :: p0_lo\n\n    u = 0.0_num\n    v = 0.0_num\n\n    grav_y = -1.0_num\n\n    ! although i've said so in the wiki i don't think anything in the code\n    ! requires definition that rho0 = lat avg rho at t=0\n    ! rather, just that rho = rho0 + rho1 , p = p0 + p1, and that due to\n    ! subtracting off the pressure grad and grav force associated with 0 quantities\n    ! it follows that they are required to themselves be hydrostatically balanced\n\n    ! ??? \n\n    ! therefore set the background state to be the uniform density upon which\n    ! the (huge) perturbation sits\n\n    rho0 = 1.0_num\n    rho = 1.0_num !both should be same, i.e. initialise with no perturbation then add on top\n\n    ! choose p0 s.t. this background is in hse\n\n    p0_lo = 10.0_num ! just sets a gauge? \n        ! however, due to p0^(<1) terms, cant tolerate a negative number in the profile\n        ! so needs to be sufficiently high to not nan the betas \n\n    p0(-1) = p0_lo\n    do iy = 0, ny+2\n      p0(iy) = p0(iy-1) + 0.5_num * dy * (rho0(iy-1) + rho0(iy)) * grav_y\n    enddo\n\n    ! go through and add the (huge) perturbation to density \n\n    do iy = -1,ny+1\n    do ix = -1,nx+1\n      x = xc(ix)-0.5_num\n      y = yc(iy)-0.75_num\n      r = sqrt(x**2 + y**2)\n      if (r <= 0.15_num) rho(ix,iy) = 1000.0_num\n    enddo        \n    enddo        \n              \n    print *, 'rho on grid',sum(rho(1:nx,1:ny)*dx*dy)\n              \n  end subroutine circular_drop_ic\n"}
{"id": 920, "subroutine": "    subroutine phi_rvector(l, n, p)\n        ! arguments\n        real(pfdp),  intent(in)  :: l(:)\n        integer,     intent(in) :: n\n        real(pfdp),  intent(out) :: p(n+1,size(l))\n        ! local variables\n        integer :: i, m\n        complex(pfdp), allocatable :: lc(:)\n        complex(pfdp), allocatable :: pc(:, :)\n        m = size(l)\n        allocate(lc(m))\n        allocate(pc(n+1, m))\n        do i = 1, m\n            lc(i) = cmplx(l(i), 0, pfdp)\n        end do\n        call phi_zvector(lc, n, pc)\n        p = real(pc)\n    end subroutine phi_rvector\n"}
{"id": 921, "subroutine": "    subroutine phi_rscalar(l, n, p)\n        ! arguments\n        real(pfdp), intent(in)  :: l\n        integer,    intent(in)  :: n\n        real(pfdp), intent(out) :: p(n+1)\n        ! local variables\n        real(pfdp) :: pm(n+1, 1)\n        real(pfdp) :: lv(1)\n        ! pack arguments for call to phi_vector\n        lv(1) = l\n        call phi_rvector(lv, n, pm)\n        ! unpack result\n        p = pm(:,1)\n    end subroutine phi_rscalar\n"}
{"id": 922, "subroutine": "    subroutine phi_rmatrix(l, n, p)\n        ! arguments\n        real(pfdp), intent(in)  :: l(:,:)\n        integer,       intent(in)  :: n\n        real(pfdp), intent(out) :: p(n + 1, size(l, 1), size(l, 2))\n        ! local variables\n        integer       :: ln, lm, d\n        real(pfdp), allocatable :: pm(:, :)\n        real(pfdp), allocatable :: lv(:)\n        ! pack arguments for call to phi_vector\n        lm = size(l, 1)\n        ln = size(l, 2)\n        d  = lm * ln\n        allocate(lv(d))\n        allocate(pm(n+1, d))\n        lv = reshape(l, (/ d /))\n        call phi_rvector(lv, n, pm)\n        ! unpack result\n        p = reshape(pm, (/n+1, ln, lm/))\n    end subroutine phi_rmatrix\n"}
{"id": 923, "subroutine": "    subroutine phi_zvector(l, n, p)\n        ! arguments\n        complex(pfdp), intent(in)  :: l(:)\n        integer,     intent(in)  :: n\n        complex(pfdp), intent(out) :: p(n+1,size(l))\n        ! local variables\n        integer     :: i,j,k,nl\n        real(pfdp)    :: f\n        complex(pfdp) :: z(c_m)\n        complex(pfdp) :: li,lzi,pp\n\n        nl = size(l)\n        p = 0;\n        ! set contour points\n        do i=1,c_m\n            z(i) = c_r * exp(2.0_pfdp*pi*ii*(i-1.0_pfdp)/real(c_m,pfdp))\n        enddo\n        ! compute phi\n        do i=1,nl\n            li = l(i)\n            if(abs(li) >= c_tol) then\n                ! direct formula\n                p(1,i) = exp(li)\n                f = 1.0_pfdp\n                do j=2,n+1\n                    p(j,i) = (p(j-1,i) - 1.0_pfdp/f)/li\n                    f = f*(j-1)\n                enddo\n            else\n                ! cauchy integral formula\n                do k=1,c_m\n                    lzi = li + z(k)\n                    pp = exp(lzi)\n                    p(1,i) = p(1,i) + pp/c_m\n                    f = 1.0_pfdp;\n                    do j=2,n+1\n                        pp = (pp - 1.0_pfdp/f)/lzi\n                        p(j,i) = p(j,i) + pp/c_m;\n                        f = f*(j-1)\n                    enddo\n                enddo\n                ! remove imaginary roundoff if l(i) is real\n                if(aimag(li) == 0.0_pfdp) then\n                  p(:,i) = real(p(:,i))\n                endif\n            end if\n        end do\nend subroutine phi_zvector\n"}
{"id": 924, "subroutine": "  subroutine init (b, y, n)\n    integer :: b(128)\n    real :: y(128)\n\n    s = -1\n    do i = 1, n\n      b(i) = i*i*s\n      y(i) = i*i*s\n      s = -s\n    end do\n\n  end subroutine\n"}
{"id": 925, "subroutine": "  subroutine checkfloat (a, b, n)\n      integer :: i, n\n      real, parameter :: eps = 0.000001\n      real :: diff, a(*), b(*)\n      do i = 1, n\n        diff = a(i) - b(i)\n        if (diff > eps .or. -diff > eps) call abort\n      end do\n  end subroutine\n"}
{"id": 926, "subroutine": "  subroutine checkint (a, b, n)\n      integer :: i, n, a(*), b(*)\n      do i = 1, n\n        if (a(i) .ne. b(i)) call abort\n      end do\n  end subroutine\n"}
{"id": 927, "subroutine": "  subroutine test ()\n    integer :: a(128), a_ref(128), b(128), ri, ri_ref\n    real :: x(128), x_ref(128), y(128), rf, rf_ref\n\n    call  init2(a, x, 128)\n    call  init2(a_ref, x_ref, 128)\n\n    call  init(b, y, 128)\n\n    ri = myaddint (a, b, 128)\n    rf = myaddfloat (x, y, 128)\n\n    call init(b, y, 128)\n\n    ri_ref = myaddint_ref (a_ref, b, 128)\n    rf_ref = myaddfloat_ref (x_ref, y, 128)\n\n    call checkint (a, a_ref, 128)\n    call checkfloat (x, x_ref, 128)\n  end subroutine\n"}
{"id": 928, "subroutine": "subroutine chkset(lundia    ,error     ,sferic    ,method    ,trasol    , &\n                & dischy    ,solver    ,disctr    ,ktemp     , &\n                & keva      ,iphisi    ,gdp       )\n!----- gpl ---------------------------------------------------------------------\n!                                                                               \n!  copyright (c)  stichting deltares, 2011-2016.                                \n!                                                                               \n!  this program is free software: you can redistribute it and/or modify         \n!  it under the terms of the gnu general public license as published by         \n!  the free software foundation version 3.                                      \n!                                                                               \n!  this program is distributed in the hope that it will be useful,              \n!  but without any warranty; without even the implied warranty of               \n!  merchantability or fitness for a particular purpose.  see the                \n!  gnu general public license for more details.                                 \n!                                                                               \n!  you should have received a copy of the gnu general public license            \n!  along with this program.  if not, see <http://www.gnu.org/licenses/>.        \n!                                                                               \n!  contact: delft3d.support@deltares.nl                                         \n!  stichting deltares                                                           \n!  p.o. box 177                                                                 \n!  2600 mh delft, the netherlands                                               \n!                                                                               \n!  all indications and logos of, and references to, \"delft3d\" and \"deltares\"    \n!  are registered trademarks of stichting deltares, and remain the property of  \n!  stichting deltares. all rights reserved.                                     \n!                                                                               \n!-------------------------------------------------------------------------------\n!  $id: chkset.f90 5717 2016-01-12 11:35:24z mourits $\n!  $headurl: https://svn.oss.deltares.nl/repos/delft3d/tags/6686/src/engines_gpl/flow2d3d/packages/kernel/src/inichk/chkset.f90 $\n!!--description-----------------------------------------------------------------\n!\n! checks the combination of domain decomposition with various program modes\n! checks the combination of z-model with various program modes\n! the combination domain decomposition and z-model is allowed\n! dredge is only allowed in combination with 3d morphology\n! checks the combination of 2-d and non-hydrostatic\n!\n!!--pseudo code and references--------------------------------------------------\n! none\n!!--declarations----------------------------------------------------------------\n    use precision\n    use globaldata\n    use dfparall\n    !\n    implicit none\n    !\n    type(globdat),target :: gdp\n    !\n    ! the following list of pointer parameters is used to point inside the gdp structure\n    !\n    integer                       , pointer :: kmax\n    integer                       , pointer :: lsec\n    integer                       , pointer :: lstsci\n    integer                       , pointer :: ltur\n    integer                       , pointer :: ltur2d\n    integer                       , pointer :: nto\n    integer                       , pointer :: ntoq\n    integer                       , pointer :: ndro\n    logical                       , pointer :: multi\n    integer                       , pointer :: nh_level\n    character(8)                  , pointer :: dpsopt\n    character(8)                  , pointer :: dpuopt\n\n    character(6)                  , pointer :: momsol\n    logical                       , pointer :: drogue\n    logical                       , pointer :: temp\n    logical                       , pointer :: dredge\n    logical                       , pointer :: wave\n    logical                       , pointer :: waveol\n    logical                       , pointer :: xbeach\n    logical                       , pointer :: iweflg\n    logical                       , pointer :: struct\n    logical                       , pointer :: sedim\n    logical                       , pointer :: htur2d\n    logical                       , pointer :: mudlay\n    logical                       , pointer :: nonhyd\n    logical                       , pointer :: couplemod\n    logical                       , pointer :: zmodel\n    logical                       , pointer :: roller\n    logical                       , pointer :: bubble\n    integer                       , pointer :: numdomains\n    integer                       , pointer :: nummappers\n    character(16)                 , pointer :: rst_layer_model\n    integer                       , pointer :: rtcmod\n    integer                       , pointer :: nrcmp\n    logical                       , pointer :: flcut\n    logical                       , pointer :: fl45\n    logical                       , pointer :: waqol\n    integer                       , pointer :: itcomi\n    logical                       , pointer :: ztbml\n    logical                       , pointer :: ztbml_upd_r1\n!\n! global variables\n!\n    integer     , intent(in)  :: iphisi      !  description and declaration in inttim.igs\n    integer     , intent(in)  :: keva        !  description and declaration in tricom.igs\n    integer     , intent(in)  :: ktemp       !  description and declaration in tricom.igs\n    integer                   :: lundia      !  description and declaration in inout.igs\n    logical     , intent(out) :: error       !!  flag=true if an error is encountered\n    logical     , intent(in)  :: sferic      !  description and declaration in tricom.igs\n    character(*), intent(in)  :: dischy      !  description and declaration in tricom.igs\n    character(*), intent(in)  :: disctr      !  description and declaration in tricom.igs\n    character(*)              :: method      !  description and declaration in tricom.igs\n    character(*), intent(in)  :: solver      !  description and declaration in tricom.igs\n    character(*)              :: trasol      !  description and declaration in tricom.igs\n!\n! local variables\n!\n    integer        :: ierror                 ! error counter\n    integer        :: iwarn                  ! warning counter\n    character(100) :: errtxt\n!\n!! executable statements -------------------------------------------------------\n!\n    kmax                => gdp%d%kmax\n    lsec                => gdp%d%lsec\n    lstsci              => gdp%d%lstsci\n    ltur                => gdp%d%ltur\n    ltur2d              => gdp%d%ltur2d\n    nto                 => gdp%d%nto\n    ntoq                => gdp%d%ntoq\n    ndro                => gdp%d%ndro\n    multi               => gdp%gdmorpar%multi\n    nh_level            => gdp%gdnonhyd%nh_level\n    dpsopt              => gdp%gdnumeco%dpsopt\n    dpuopt              => gdp%gdnumeco%dpuopt\n    momsol              => gdp%gdnumeco%momsol\n    drogue              => gdp%gdprocs%drogue\n    temp                => gdp%gdprocs%temp\n    dredge              => gdp%gdprocs%dredge\n    wave                => gdp%gdprocs%wave\n    waveol              => gdp%gdprocs%waveol\n    xbeach              => gdp%gdprocs%xbeach\n    iweflg              => gdp%gdprocs%iweflg\n    struct              => gdp%gdprocs%struct\n    sedim               => gdp%gdprocs%sedim\n    htur2d              => gdp%gdprocs%htur2d\n    mudlay              => gdp%gdprocs%mudlay\n    nonhyd              => gdp%gdprocs%nonhyd\n    couplemod           => gdp%gdprocs%couplemod\n    zmodel              => gdp%gdprocs%zmodel\n    roller              => gdp%gdprocs%roller\n    bubble              => gdp%gdprocs%bubble\n    numdomains          => gdp%gdprognm%numdomains\n    nummappers          => gdp%gdprognm%nummappers\n    rst_layer_model     => gdp%gdrestart%rst_layer_model\n    rtcmod              => gdp%gdrtc%rtcmod\n    nrcmp               => gdp%gdtfzeta%nrcmp\n    flcut               => gdp%gdtmpfil%flcut\n    fl45                => gdp%gdtmpfil%fl45\n    waqol               => gdp%gdwaqpar%waqol\n    itcomi              => gdp%gdinttim%itcomi\n    ztbml               => gdp%gdzmodel%ztbml\n    ztbml_upd_r1        => gdp%gdzmodel%ztbml_upd_r1\n    !\n    ierror = 0\n    iwarn  = 0\n    !\n    ! for checking functionality combinations:\n    ! must dd be specified as nummappers>=1 or numdomains>1?\n    ! the behaviour around a dd boundary is the same when comparing one domain\n    ! with an internal dd boundary with two domains. so use nummappers>=1.\n    !\n    if (nummappers >= 1) then\n       !\n       ! errors\n       !\n       if (iweflg) then\n          call prterr(lundia    ,'m001'    ,'internal wave option'          )\n          ierror = ierror + 1\n       endif\n       if (mudlay) then\n          call prterr(lundia    ,'m001'    ,'fluid mud'          )\n          ierror = ierror + 1\n       endif\n       if (solver(1:2)=='gs') then\n          call prterr(lundia    ,'m001'    ,'gauss seidel solver')\n          ierror = ierror + 1\n       endif\n       if (nonhyd .and. nh_level == nh_full) then\n          call prterr(lundia    ,'p004'    ,'the combination of fully non-hydrostatic mode and domain decomposition is not allowed')\n          ierror = ierror + 1\n       endif\n       !\n       ! warnings\n       !\n       if (roller) then\n          call prterr(lundia    ,'m002'    ,'roller model'       )\n          iwarn = iwarn + 1\n       endif\n       if (ltur2d>0) then\n          call prterr(lundia    ,'m002'    ,'q2e 2d turb.model'  )\n          iwarn = iwarn + 1\n       endif\n       if (nrcmp>0) then\n          call prterr(lundia    ,'m002'    ,'tide generating forces'        )\n          iwarn = iwarn + 1\n       endif\n       if (lsec>0) then\n          call prterr(lundia    ,'m002'    ,'secondary flow'     )\n          iwarn = iwarn + 1\n       endif\n       if (ndro>0) then\n          call prterr(lundia    ,'m002'    ,'drogues' )\n          iwarn = iwarn + 1\n       endif\n       if (disctr(1:4)=='expl') then\n          call prterr(lundia    ,'m002'    ,'explicit method'    )\n          iwarn = iwarn + 1\n       endif\n       if (sferic) then\n          call prterr(lundia    ,'m002'    ,'spherical coordinate'          )\n          iwarn = iwarn + 1\n       endif\n       if (momsol /= 'cyclic') then\n          call prterr(lundia    ,'m002'    ,'momentum solver other than cyclic'  )\n          iwarn = iwarn + 1\n       endif\n       if (couplemod) then\n          call prterr(lundia    ,'m002'    ,'online couple'      )\n          iwarn = iwarn + 1\n       endif\n    endif\n    !\n    ! z-model case\n    !\n    if (zmodel) then\n       !\n       ! errors\n       !\n       if (couplemod) then\n          call prterr(lundia    ,'z011'    ,'online couple'      )\n          ierror = ierror+ 1\n       endif\n       if (iweflg) then\n          call prterr(lundia    ,'z011'    ,'internal wave option'          )\n          ierror = ierror+ 1\n       endif\n       if (mudlay) then\n          call prterr(lundia    ,'z011'    ,'fluid mud'          )\n          ierror = ierror+ 1\n       endif\n       if (solver(1:2)=='gs') then\n          call prterr(lundia    ,'z011'    ,'gauss seidel solver')\n          ierror = ierror+ 1\n       endif\n       if (ltur2d>0) then\n          call prterr(lundia    ,'z011'    ,'q2e 2d turb.model'  )\n          ierror = ierror+ 1\n       endif\n       if (lsec>0) then\n          call prterr(lundia    ,'z011'    ,'secondary flow'     )\n          errtxt = 'use sigma version of delft3d-flow instead'\n          call prterr(lundia    ,'u021'    ,errtxt    )\n          ierror = ierror+ 1\n       endif\n       if (disctr(1:4)=='expl') then\n          call prterr(lundia    ,'z011'    ,'explicit method'    )\n          ierror = ierror+ 1\n       endif\n       if (roller) then\n          call prterr(lundia    ,'z011'    ,'roller model'       )\n          ierror = ierror+ 1\n       endif\n       if (sedim .and. (kmax==1)) then\n          call prterr(lundia    ,'z011'    ,'2d morphology'       )\n          ierror = ierror+ 1\n       endif\n       if (ztbml .and. rst_layer_model == 'unknown') then\n          call prterr(lundia    ,'p004'    ,'restarting with modified layering (ztbml=#y#) only allowed')\n          write (lundia, '(a)') '          from map-files with correct layer model'\n          ierror = ierror + 1\n       endif    \n       if (.not. ztbml .and. rst_layer_model == 'z-model, ztbml') then\n          call prterr(lundia    ,'p004'    ,'restarting from z-model run with modified bed-layering only allowed')\n          write (lundia, '(a)') '          with again modified layering: ztbml=#y#'\n          ierror = ierror + 1\n       endif\n       !\n       ! warnings\n       !\n       if (sedim) then\n          call prterr(lundia    ,'z012'    ,'3d morphology'      )\n          iwarn = iwarn+ 1\n       endif\n       if (method(1:3)/='adi') then\n          call prterr(lundia    ,'z011'    ,method    )\n          method = 'adi          '\n          errtxt = 'adi numerical method will be applied instead'\n          call prterr(lundia    ,'u190'    ,errtxt    )\n          iwarn = iwarn + 1\n       endif\n       if (ktemp/=5 .and. ktemp>0) then\n          call prterr(lundia    ,'z012'    ,'heat model other than option 5')\n          iwarn = iwarn + 1\n       endif\n       if (keva>0) then\n          call prterr(lundia    ,'z012'    ,'evaporation model'  )\n          iwarn = iwarn + 1\n       endif\n       if (nrcmp>0) then\n          call prterr(lundia    ,'z012'    ,'tide generating forces'        )\n          iwarn = iwarn + 1\n       endif\n       if (ntoq>0) then\n          call prterr(lundia    ,'z012'    ,'q-h boundary'       )\n          iwarn = iwarn + 1\n       endif\n       if (ndro>0) then\n          call prterr(lundia    ,'z012'    ,'drogues' )\n          iwarn = iwarn + 1\n       endif\n       if (sferic) then\n          call prterr(lundia    ,'z012'    ,'spherical coordinate'          )\n          iwarn = iwarn + 1\n       endif\n       if (htur2d) then\n          call prterr(lundia    ,'z012'    ,'hles'    )\n          iwarn = iwarn + 1\n       endif\n       if (struct) then\n          call prterr(lundia    ,'z012'    ,'structures'         )\n          iwarn = iwarn + 1\n       endif\n       if (ztbml .and. rst_layer_model == 'z-model') then\n          errtxt = 'z-model with modified bed-layering (ztmbl) activated. restarting from'\n          call prterr(lundia    ,'z013'    , errtxt)\n          write (lundia, '(a)') '            unmodified layering, with conservative remapping near bottom'\n          iwarn        = iwarn + 1\n          ztbml_upd_r1 = .true.\n       endif\n    else\n       !\n       ! sigma-model case\n       !\n       !\n       ! errors\n       !\n       if (fl45 .or. flcut) then\n          errtxt = 'combination of sigma-model and cut cells is not available'\n          call prterr(lundia ,'u021' ,errtxt )\n          ierror = ierror+ 1\n       endif\n       if (nonhyd) then\n          errtxt = 'combination of sigma-model and non-hydrostatic mode is not available'\n          call prterr(lundia ,'u021' ,errtxt )\n          ierror = ierror + 1\n       endif\n       if (roller) then\n          if(.not. wave) then\n             call prterr(lundia    ,'p004'    ,'roller model is activiated.  wave process must be activated')\n             ierror = ierror + 1\n          endif\n       endif\n       !\n       ! warnings\n       !\n       if (bubble) then\n          errtxt = 'combination of sigma-model and bubble screens has not yet been tested'\n          call prterr(lundia ,'z013' ,errtxt )\n          iwarn = iwarn + 1\n       endif\n    endif\n    !\n    !\n    !\n    if (dredge) then\n       !\n       ! errors\n       !\n       if (.not. sedim) then\n          call prterr(lundia    ,'p004'    ,'dredging is only allowed in combination with 3d morphology'  )\n          ierror = ierror+ 1\n       endif\n    endif\n    !\n    !\n    !\n    if (multi) then\n       call prterr(lundia, 'u190', 'mormerge: mass balance only satisfied for all runs together')\n       iwarn = iwarn + 1\n    endif\n    !\n    !\n    !\n    if (dpsopt=='dp' .and. dpuopt=='mean') then\n       call prterr(lundia, 'p004', 'the combination of dpsopt=dp and dpuopt=mean is invalid')\n       ierror = ierror+ 1\n    endif\n    !\n    !\n    !\n    if (waqol) then\n       if (sedim) then\n          call prterr(lundia, 'p004', 'morphology/sediments can not be switched on in both flow and waq')\n          ierror = ierror+ 1\n       endif\n    endif\n    !\n    !\n    !\n    if (iphisi > 0 .and. lstsci > 7) then\n       !\n       ! the output to ascii file can be written for a maximum of 7 constituents (prthis.f90)\n       !\n       call prterr(lundia, 'p004', 'writing to a tri-prt (ascii) file is not supported when using more than 7 constituents')\n       ierror = ierror+ 1\n    endif\n    !\n    if (kmax == 1 .and. nonhyd) then\n       !\n       ! 2d (kmax == 1) and non-hydrostatic is not allowed\n       !\n       call prterr(lundia, 'p004', 'the combination 2d and non-hydrostatic is not allowed')\n       ierror = ierror+ 1\n    endif\n    !\n    if (wave .and. waveol .and. (.not.xbeach) .and. itcomi==1) then\n       !\n       ! calling wave every timestep is not supported (yet).\n       ! if tried, flow does not read wave information at all.\n       !\n       call prterr(lundia, 'p004', 'calling wave every timestep is not supported.')\n       ierror = ierror+ 1\n    endif\n    !\n    if (parll) then\n       !\n       ! errors\n       !\n       if (drogue) then\n          errtxt = 'drogues/walking monitor points are not available in parallel computations'\n          call prterr(lundia ,'u021' ,errtxt )\n          ierror = ierror+ 1\n       endif\n    endif\n    !\n    !\n    !\n    if (ierror > 0) then\n       error = .true.\n    endif\nend subroutine chkset\n"}
{"id": 929, "subroutine": "  subroutine vvacxc(ifftd2,stars,vacuum,xcpot,input,noco,den,vxc,exc)\n\n    !     ********************************************************************\n    !     instead of vvacxcor.f: the different exchange-correlation \n    !     potentials defined through the key icorr are called through \n\n    !     in case of total = .true. calculates the ex.-corr. energy\n\n    !     ** r.pentcheva 08.05.96\n    !     ********************************************************************\n\n    use m_types\n    use m_constants\n    use m_fft2d\n\n    implicit none\n\n    class(t_xcpot),intent(in)     :: xcpot\n    type(t_input),intent(in)     :: input\n    type(t_vacuum),intent(in)    :: vacuum\n    type(t_noco),intent(in)      :: noco\n    type(t_stars),intent(in)     :: stars\n    type(t_potden),intent(in)    :: den\n    type(t_potden),intent(inout) :: vxc,exc\n    !     ..\n    !     .. scalar arguments ..\n    integer, intent (in) :: ifftd2\n    !     ..\n \n    !     ..\n    !     .. local scalars ..\n    integer :: k,js,nt,irec2,nmzdiff,ivac,ip,i \n    real    :: rhti\n    real    :: chdens,magmom \n    !     ..\n    !     .. local arrays ..\n    complex :: fgxy(stars%ng2-1)\n    real    :: af2(0:ifftd2-1,input%jspins),bf2(0:ifftd2-1),fgz\n    real,allocatable :: mx(:),my(:) \n    !     warping region\n    real    :: v_xc(0:ifftd2-1,input%jspins),e_xc(0:ifftd2-1)\n    real    :: v_x (0:ifftd2-1,input%jspins)\n    !     beyond warping region\n    real    :: vxcz(vacuum%nmzd,input%jspins)\n    real    :: vxz (vacuum%nmzd,input%jspins)\n\n    if (noco%l_noco) then\n       allocate (mx(0:ifftd2-1),my(0:ifftd2-1)) \n    end if\n\n    nt = ifftd2\n    rhti = 0.\n    !\n    !     the charge density in vacuum is expanded in 2-dim stars on a mesh \n    !     in z-direction . the g||.ne.zero-components expand from 1 to nmzxy\n    !     the g||.eq.zero-components expand from 1 to nmz\n    !     first we calculate vxc in the warping region\n    !\n    do  ivac = 1,vacuum%nvac\n       do ip = 1,vacuum%nmzxy\n          !\n          !         transform charge density to real space: 2-dim fft\n          !\n          do js = 1,input%jspins\n             call fft2d(stars, af2(0,js),bf2, den%vacz(ip,ivac,js),rhti,&\n                  den%vacxy(ip,1,ivac,js), vacuum%nmzxyd,+1)\n          end do\n\n          if (noco%l_noco) then \n\n             call fft2d(stars, mx,my, den%vacz(ip,ivac,3),den%vacz(ip,ivac,4),&\n                                 den%vacxy(ip,1,ivac,3), vacuum%nmzxyd,1)\n             do i=0,9*stars%mx1*stars%mx2-1 \n                chdens= (af2(i,1)+af2(i,2))/2.  \n                magmom= mx(i)**2 + my(i)**2 + ((af2(i,1)-af2(i,2))/2.)**2 \n                magmom= sqrt(magmom) \n                af2(i,1)= chdens + magmom \n                af2(i,2)= chdens - magmom\n             end do\n\n          end if\n          !\n          !         calculate the exchange-correlation potential in  real space\n          !\n          call xcpot%get_vxc(input%jspins,af2,v_xc,v_x)\n\n          do  js = 1,input%jspins\n             !\n             !            ----> 2-d back fft to g space\n             !\n             bf2=0.0\n             call fft2d(stars, v_xc(0,js),bf2, fgz,rhti,fgxy, 1,-1)\n             !\n             !            ----> and add vxc to coulomb potential\n             !            the g||.eq.zero component is added to vz\n             !\n             vxc%vacz(ip,ivac,js) = fgz + vxc%vacz(ip,ivac,js)\n             !\n             !            the g||.ne.zero components are added to vxc%vacxy\n             !\n             do irec2 = 1,stars%ng2-1\n                vxc%vacxy(ip,irec2,ivac,js) = vxc%vacxy(ip,irec2,ivac,js) + fgxy(irec2)\n             enddo\n          enddo\n          !\n          !i        calculate the exchange-correlation energy density in  real space\n          !\n          if (allocated(exc%vacz)) then\n             call xcpot%get_exc(input%jspins,af2,e_xc, mt_call=.false.)\n             !\n             !     ----> 2-d back fft to g space\n             !\n             bf2=0.0\n             call fft2d(stars, e_xc,bf2, exc%vacz(ip,ivac,1),rhti,exc%vacxy(ip,1,ivac,1), vacuum%nmzxyd,-1)\n          endif\n\n       enddo\n       !\n       !        calculate vxc for z now beyond warping region \n       !\n       nmzdiff = vacuum%nmz - vacuum%nmzxy\n\n       do k=1,nmzdiff\n\n          do js=1,input%jspins\n             af2(k-1,js) = den%vacz(vacuum%nmzxy+k,ivac,js)\n          enddo\n\n          if (noco%l_noco) then\n\n             mx(0)= den%vacz(vacuum%nmzxy+k,ivac,3)\n             my(0)= den%vacz(vacuum%nmzxy+k,ivac,4)\n             chdens= (af2(k-1,1)+af2(k-1,2))/2.\n             magmom= mx(0)**2 + my(0)**2 + ((af2(k-1,1)-af2(k-1,2))/2.)**2\n             magmom= sqrt(magmom)\n             af2(k-1,1)= chdens + magmom\n             af2(k-1,2)= chdens - magmom\n\n          end if\n\n       enddo\n\n       call xcpot%get_vxc(input%jspins,af2(0:nmzdiff-1,:),vxz,vxcz)\n      \n       !+gu\n       do  js=1,input%jspins\n          do k=vacuum%nmzxy+1,vacuum%nmz\n             vxc%vacz(k,ivac,js) = vxc%vacz(k,ivac,js) + vxcz(k-vacuum%nmzxy,js)\n          enddo\n       enddo\n       !\n       write (ounit,fmt=8020) ivac, (vxc%vacz(vacuum%nmz,ivac,js),js=1,input%jspins)\n8020   format (/,5x,'vacuum zero for vacuum',i3,' = ',2f10.5)\n       !\n       !        calculate the ex.-corr. energy density now beyond warping region\n       !\n       if (allocated(exc%vacz)) then\n          call xcpot%get_exc(input%jspins,af2(0:nmzdiff-1,:),exc%vacz(vacuum%nmzxy+1:,ivac,1), mt_call=.false.)\n       end if\n    enddo\n    if (noco%l_noco) then \n       deallocate (mx,my)\n    end if\n\n  end subroutine vvacxc\n"}
{"id": 930, "subroutine": "      subroutine cdf_normal(which,cum,ccum,x,mean,sd,status,check_input)\n! .. scalar arguments ..\n        real (dpkind), optional :: ccum, cum, mean, sd\n        real (dpkind) :: x\n        integer, optional, intent (out) :: status\n        integer, intent (in) :: which\n        logical, optional, intent (in) :: check_input\n! ..\n! .. local arrays ..\n        real (dpkind) :: params(6)\n! ..\n! .. local scalars ..\n        real (dpkind) :: local_ccum, local_cum, local_mean, local_sd, z\n        logical :: has_status, local_check_input\n! ..\n! .. intrinsic functions ..\n        intrinsic present\n! ..\n        has_status = present(status)\n\n! status = 0 means no error\n\n        if (has_status) then\n          status = 0\n        end if\n\n! check presence of arguments and fix up\n\n        call check_complements(cum,ccum,the_normal%name,'cum','ccum', &\n          local_cum,local_ccum,set_values=which/=1,bad_status=3, &\n          status=status)\n\n        if (has_status) then\n          if (status/=0) then\n            return\n          end if\n        end if\n\n\n        if (present(mean)) then\n          local_mean = mean\n        else\n          local_mean = zero\n        end if\n\n        if (present(sd)) then\n          local_sd = sd\n        else\n          local_sd = one\n        end if\n\n        params(1) = local_cum\n        params(2) = local_ccum\n        params(3) = x\n        params(4) = local_mean\n        params(5) = local_sd\n\n        if (present(check_input)) then\n          local_check_input = check_input\n        else\n          local_check_input = .true.\n        end if\n\n!!! check for consistency of which and answer\n\n        if (local_check_input) then\n\n          if (which==3 .and. .not. present(mean)) call which_miss(which, &\n            the_normal%name,'mean')\n\n          if (which==4 .and. .not. present(sd)) call which_miss(which, &\n            the_normal%name,'sd')\n\n          call validate_parameters(the_normal,which,params,status)\n\n          if (has_status) then\n            if (status/=0) then\n              return\n            end if\n          end if\n\n        end if\n\n! ++++++++++          ++++++++++          ++++++++++\n! compute the answers\n! ++++++++++          ++++++++++          ++++++++++\n\n        select case (which)\n        case (1)\n          z = (x-local_mean)/local_sd\n\n          call local_cum_normal(z,local_cum,local_ccum)\n\n          if (present(cum)) cum = local_cum\n          if (present(ccum)) ccum = local_ccum\n\n        case (2)\n          z = local_inv_normal(local_cum,local_ccum)\n\n          x = local_sd*z + local_mean\n\n        case (3)\n          z = local_inv_normal(local_cum,local_ccum)\n\n          mean = x - local_sd*z\n\n        case (4)\n          z = local_inv_normal(local_cum,local_ccum)\n\n          sd = (x-local_mean)/z\n        end select\n\n      end subroutine cdf_normal\n"}
{"id": 931, "subroutine": "      subroutine local_cum_normal(arg,result,ccum)\n!----------------------------------------------------------------------\n\n!                              function\n\n!     computes the cumulative  of    the  normal   distribution,   i.e.,\n!     the integral from -infinity to x of\n!          (1/sqrt(2*pi)) exp(-u*u/2) du\n!     x --> upper limit of integration.\n!                                        x is double precision\n!     result <-- cumulative normal distribution.\n!                                        result is double precision\n!     ccum <-- compliment of cumulative normal distribution.\n!                                        ccum is double precision\n!     renaming of function anorm from:\n!     cody, w.d. (1993). \"algorithm 715: specfun - a portabel fortran\n!     package of special function routines and test drivers\"\n!     acm transactions on mathematical software. 19, 22-32.\n!     with slight modifications to return ccum and to deal with\n!     machine constants.\n!----------------------------------------------------------------------\n! original comments:\n!------------------------------------------------------------------\n! this function evaluates the normal distribution function:\n!                              / x\n!                     1       |       -t*t/2\n!          p(x) = ----------- |      e       dt\n!                 sqrt(2 pi)  |\n!                             /-oo\n!   the main computation evaluates near-minimax approximations\n!   derived from those in \"rational chebyshev approximations for\n!   the error function\" by w. j. cody, math. comp., 1969, 631-637.\n!   this transportable program uses rational functions that\n!   theoretically approximate the normal distribution function to\n!   at least 18 significant decimal digits.  the accuracy achieved\n!   depends on the arithmetic system, the compiler, the intrinsic\n!   functions, and proper selection of the machine-dependent\n!   constants.\n!*******************************************************************\n!*******************************************************************\n! explanation of machine-dependent constants.\n!   min   = smallest machine representable number.\n!   eps   = argument below which anorm(x) may be represented by\n!           0.5  and above which  x*x  will not underflow.\n!           a conservative value is the largest machine number x\n!           such that   1.0 + x = 1.0   to machine precision.\n!*******************************************************************\n!*******************************************************************\n! error returns\n!  the program returns  anorm = 0     for  arg .le. xlow.\n! intrinsic functions required are:\n!     abs, aint, exp\n!  author: w. j. cody\n!          mathematics and computer science division\n!          argonne national laboratory\n!          argonne, il 60439\n!  latest modification: march 15, 1992\n!------------------------------------------------------------------\n!------------------------------------------------------------------\n!  mathematical constants\n!  sqrpi = 1 / sqrt(2*pi), root32 = sqrt(32), and\n!  thrsh is the argument for which anorm = 0.75.\n!------------------------------------------------------------------\n!------------------------------------------------------------------\n!  coefficients for approximation in first interval\n!------------------------------------------------------------------\n!------------------------------------------------------------------\n!  coefficients for approximation in second interval\n!------------------------------------------------------------------\n!------------------------------------------------------------------\n!  coefficients for approximation in third interval\n!------------------------------------------------------------------\n! .. scalar arguments ..\n        real (dpkind) :: arg, ccum, result\n! ..\n! .. local scalars ..\n        real (dpkind) :: del, eps, min, temp, x, xden, xnum, xsq, y\n        integer :: i\n! ..\n! .. intrinsic functions ..\n        intrinsic abs, aint, epsilon, exp, tiny\n! ..\n! .. parameters ..\n        real (dpkind), parameter :: a(5) = (/ &\n          2.2352520354606839287e00_dpkind, &\n          1.6102823106855587881e02_dpkind, &\n          1.0676894854603709582e03_dpkind, &\n          1.8154981253343561249e04_dpkind, &\n          6.5682337918207449113e-2_dpkind/)\n        real (dpkind), parameter :: b(4) = (/ &\n          4.7202581904688241870e01_dpkind, &\n          9.7609855173777669322e02_dpkind, &\n          1.0260932208618978205e04_dpkind, &\n          4.5507789335026729956e04_dpkind/)\n        real (dpkind), parameter :: c(9) = (/ &\n          3.9894151208813466764e-1_dpkind, &\n          8.8831497943883759412e00_dpkind, &\n          9.3506656132177855979e01_dpkind, &\n          5.9727027639480026226e02_dpkind, &\n          2.4945375852903726711e03_dpkind, &\n          6.8481904505362823326e03_dpkind, &\n          1.1602651437647350124e04_dpkind, &\n          9.8427148383839780218e03_dpkind, &\n          1.0765576773720192317e-8_dpkind/)\n        real (dpkind), parameter :: d(8) = (/ &\n          2.2266688044328115691e01_dpkind, &\n          2.3538790178262499861e02_dpkind, &\n          1.5193775994075548050e03_dpkind, &\n          6.4855582982667607550e03_dpkind, &\n          1.8615571640885098091e04_dpkind, &\n          3.4900952721145977266e04_dpkind, &\n          3.8912003286093271411e04_dpkind, &\n          1.9685429676859990727e04_dpkind/)\n        real (dpkind), parameter :: p(6) = (/ &\n          2.1589853405795699e-1_dpkind, 1.274011611602473639e-1_dpkind, &\n          2.2235277870649807e-2_dpkind, 1.421619193227893466e-3_dpkind, &\n          2.9112874951168792e-5_dpkind, 2.307344176494017303e-2_dpkind/)\n        real (dpkind), parameter :: q(5) = (/ &\n          1.28426009614491121e00_dpkind, 4.68238212480865118e-1_dpkind, &\n          6.59881378689285515e-2_dpkind, 3.78239633202758244e-3_dpkind, &\n          7.29751555083966205e-5_dpkind/)\n        real (dpkind), parameter :: root32 = 5.656854248e0_dpkind\n        real (dpkind), parameter :: sixten = 1.6_dpkind\n        real (dpkind), parameter :: sqrpi = &\n          3.9894228040143267794e-1_dpkind\n        real (dpkind), parameter :: thrsh = 0.66291e0_dpkind\n! ..\n!------------------------------------------------------------------\n!  machine dependent constants\n!------------------------------------------------------------------\n!        eps = spmpar(1)*0.5e0_dpkind\n        eps = epsilon(one)*half\n!        min = spmpar(2)\n        min = tiny(one)\n!------------------------------------------------------------------\n        x = arg\n        y = abs(x)\n        if (y<=thrsh) then\n!------------------------------------------------------------------\n!  evaluate  anorm  for  |x| <= 0.66291\n!------------------------------------------------------------------\n          xsq = zero\n          if (y>eps) xsq = x*x\n          xnum = a(5)*xsq\n          xden = xsq\n          xnum = (xnum+a(1))*xsq\n          xden = (xden+b(1))*xsq\n          xnum = (xnum+a(2))*xsq\n          xden = (xden+b(2))*xsq\n          xnum = (xnum+a(3))*xsq\n          xden = (xden+b(3))*xsq\n          result = x*(xnum+a(4))/(xden+b(4))\n          temp = result\n          result = half + temp\n          ccum = half - temp\n!------------------------------------------------------------------\n!  evaluate  anorm  for 0.66291 <= |x| <= sqrt(32)\n!------------------------------------------------------------------\n        else if (y<=root32) then\n          xnum = c(9)*y\n          xden = y\n\n          do i = 1, 7\n            xnum = (xnum+c(i))*y\n            xden = (xden+d(i))*y\n          end do\n\n          result = (xnum+c(8))/(xden+d(8))\n          xsq = aint(y*sixten)/sixten\n          del = (y-xsq)*(y+xsq)\n          result = exp(-xsq*xsq*half)*exp(-del*half)*result\n          ccum = one - result\n\n          if (x>zero) then\n            temp = result\n            result = ccum\n            ccum = temp\n          end if\n\n!------------------------------------------------------------------\n!  evaluate  anorm  for |x| > sqrt(32)\n!------------------------------------------------------------------\n        else\n          result = zero\n          xsq = one/(x*x)\n          xnum = p(6)*xsq\n          xden = xsq\n          xnum = (xnum+p(1))*xsq\n          xden = (xden+q(1))*xsq\n          xnum = (xnum+p(2))*xsq\n          xden = (xden+q(2))*xsq\n          xnum = (xnum+p(3))*xsq\n          xden = (xden+q(3))*xsq\n          xnum = (xnum+p(4))*xsq\n          xden = (xden+q(4))*xsq\n          result = xsq*(xnum+p(5))/(xden+q(5))\n          result = (sqrpi-result)/y\n          xsq = aint(x*sixten)/sixten\n          del = (x-xsq)*(x+xsq)\n          result = exp(-xsq*xsq*half)*exp(-del*half)*result\n          ccum = one - result\n\n          if (x>zero) then\n            temp = result\n            result = ccum\n            ccum = temp\n          end if\n\n        end if\n\n        if (result<min) result = zero\n        if (ccum<min) ccum = zero\n\n      end subroutine local_cum_normal\n"}
{"id": 932, "subroutine": "  subroutine c2d2_postprocessingstationary (rproblem,rvector,rpostprocessing)\n  \n!<description>\n  ! postprocessing of solutions of stationary simulations.\n  ! writes the solution into a gmv file, calculates forces,...\n!</description>\n\n!<inputoutput>\n  ! a problem structure saving problem-dependent information.\n  type(t_problem), intent(inout), target :: rproblem\n\n  ! postprocessing structure.\n  type(t_c2d2postprocessing), intent(inout) :: rpostprocessing\n!</inputoutput>\n\n!<input>\n  ! the solution vector which is to be evaluated by the postprocessing routines.\n  type(t_vectorblock), intent(in) :: rvector\n!</input>\n\n\n    ! calculate body forces.\n    call c2d2_calculatebodyforces (rvector,rproblem)\n    \n    ! calculate the divergence\n    call c2d2_calculatedivergence (rvector,rproblem)\n    \n    ! error analysis, comparison to reference function.\n    call c2d2_erroranalysis (rvector,rproblem)\n    \n    ! write the ucd export file (gmv, avs,...) as configured in the dat file.\n    call c2d2_writeucd (rpostprocessing, rvector, rproblem)\n    \n  end subroutine\n"}
{"id": 933, "subroutine": "  subroutine c2d2_erroranalysis (rsolution,rproblem)\n\n!<description>\n  ! performs error analysis on a given solution rsolution as specified\n  ! in the .dat file.\n  ! the result of the error analysis is written to the standard output.\n!</description>\n  \n!<input>\n  ! solution vector to compute the norm/error from.\n  type(t_vectorblock), intent(in) :: rsolution\n!</input>\n\n!<inputoutput>\n  ! problem structure.\n  type(t_problem), intent(inout) :: rproblem\n!</inputoutput>\n\n    \n    ! local variables\n    real(dp),dimension(3) :: derr\n    real(dp) :: derrorvel, derrorp\n    integer :: icalcl2,icalch1\n    \n    call parlst_getvalue_int (rproblem%rparamlist, 'cc-postprocessing', &\n                                     'ierroranalysisl2', icalcl2, 0)\n    call parlst_getvalue_int (rproblem%rparamlist, 'cc-postprocessing', &\n                                     'ierroranalysish1', icalch1, 0)\n    \n    if ((icalcl2 .ne. 0) .or. (icalch1 .ne. 0)) then\n      call output_lbrk()\n      call output_line ('error analysis')\n      call output_line ('--------------')\n    end if\n    \n    if (icalcl2 .ne. 0) then\n    \n      call c2d2_initcollectforassembly (rproblem,rproblem%rcollection)\n    \n      ! perform error analysis to calculate and add 1/2||u-z||_{l^2}.\n      call pperr_scalar (rsolution%rvectorblock(1),pperr_l2error,derr(1),&\n                         ffunction_targetx,rproblem%rcollection)\n\n      call pperr_scalar (rsolution%rvectorblock(2),pperr_l2error,derr(2),&\n                         ffunction_targety,rproblem%rcollection)\n                         \n      derrorvel = (0.5_dp*(derr(1)**2+derr(2)**2))\n\n      call pperr_scalar (rsolution%rvectorblock(3),pperr_l2error,derr(3),&\n                         ffunction_targetp,rproblem%rcollection)\n\n      derrorp = derr(3)\n      \n      call output_line ('||u-reference||_l2 = '//trim(sys_sdep(derrorvel,15,6)) )\n      call output_line ('||p-reference||_l2 = '//trim(sys_sdep(derrorp,15,6)) )\n      \n      call c2d2_donecollectforassembly (rproblem,rproblem%rcollection)\n      \n    end if\n\n    if (icalcl2 .ne. 0) then\n    \n      call c2d2_initcollectforassembly (rproblem,rproblem%rcollection)\n    \n      ! perform error analysis to calculate and add 1/2||u-z||_{l^2}.\n      call pperr_scalar (rsolution%rvectorblock(1),pperr_h1error,derr(1),&\n                         ffunction_targetx,rproblem%rcollection)\n\n      call pperr_scalar (rsolution%rvectorblock(2),pperr_h1error,derr(2),&\n                         ffunction_targety,rproblem%rcollection)\n                         \n      derrorvel = (0.5_dp*(derr(1)**2+derr(2)**2))\n\n      call output_line ('||u-reference||_h1 = '//trim(sys_sdep(derrorvel,15,6)) )\n      \n      call c2d2_donecollectforassembly (rproblem,rproblem%rcollection)\n      \n    end if\n    \n  end subroutine\n"}
{"id": 934, "subroutine": "  subroutine c2d2_calculatebodyforces (rsolution,rproblem)\n\n!<description>\n  ! calculates body forces as configured in the .dat file.\n  ! the result is written to the standard output.\n!</description>\n  \n!<input>\n  ! solution vector to compute the norm/error from.\n  type(t_vectorblock), intent(in) :: rsolution\n!</input>\n\n!<inputoutput>\n  ! problem structure.\n  type(t_problem), intent(inout) :: rproblem\n!</inputoutput>\n\n    \n    ! local variables\n    \n    ! forces on the object\n    real(dp), dimension(ndim2d) :: dforces\n    real(dp) :: df1,df2\n    type(t_boundaryregion) :: rregion\n    \n    ! if we have a uniform discretisation, calculate the body forces on the\n    ! 2nd boundary component - if it exists.\n    if ((rsolution%p_rblockdiscretisation%rspatialdiscr(1)% &\n         ccomplexity .eq. spdisc_uniform) .and. &\n        (boundary_igetnboundcomp(rproblem%p_rboundary) .ge. 2)) then\n\n      ! calculate drag-/lift coefficients on the 2nd boundary component.\n      ! this is for the benchmark channel!\n      call boundary_createregion (rproblem%p_rboundary, &\n          2, 0, rregion)\n      rregion%iproperties = bdr_prop_withstart+bdr_prop_withend\n      df1 = 1.0_dp/1000.0_dp\n      df2 = 0.1_dp * 0.2_dp**2\n      call ppns2d_bdforces_uniform (rsolution,rregion,dforces,cub_g1_1d,df1,df2)\n\n      call output_lbrk()\n      call output_line ('body forces')\n      call output_line ('-----------')\n      call output_line ('body forces real bd., bdc/horiz/vert')\n      call output_line (' 2 / ' &\n          //trim(sys_sdep(dforces(1),15,6)) // ' / '&\n          //trim(sys_sdep(dforces(2),15,6)) )\n      \n    endif\n    \n  end subroutine\n"}
{"id": 935, "subroutine": "  subroutine c2d2_calculatedivergence (rsolution,rproblem)\n\n!<description>\n  ! calculates the divergence of a solution.\n  ! the result is written to the standard output.\n!</description>\n  \n!<input>\n  ! solution vector to compute the norm/error from.\n  type(t_vectorblock), intent(in) :: rsolution\n!</input>\n\n!<inputoutput>\n  ! problem structure.\n  type(t_problem), intent(inout) :: rproblem\n!</inputoutput>\n\n\n    ! local variables\n    integer :: ieltype\n    type(t_matrixscalar) :: rbmatrix\n    type(t_vectorscalar), target :: rtempvector\n    \n    if (rsolution%p_rblockdiscretisation%rspatialdiscr(1)% &\n        ccomplexity .eq. spdisc_uniform) then\n        \n      ieltype = rsolution%p_rblockdiscretisation%rspatialdiscr(1)% &\n                relementdistr(1)%itrialelement\n                \n      if (elem_getprimaryelement(ieltype) .eq. el_q1t) then\n      \n        ! create a temporary vector\n        call lsyssc_createvecbydiscr (rsolution%rvectorblock(3)%p_rspatialdiscretisation,&\n            rtempvector,.true.)\n\n        ! calculate divergence = b1^t u1 + b2^t u2\n        call lsyssc_transposematrix (rproblem%rlevelinfo(rproblem%nlmax)%rmatrixb1,&\n            rbmatrix,lsyssc_tr_virtual)\n        call lsyssc_scalarmatvec (&\n            rbmatrix, rsolution%rvectorblock(1), &\n            rtempvector, 1.0_dp, 0.0_dp)\n        call lsyssc_transposematrix (rproblem%rlevelinfo(rproblem%nlmax)%rmatrixb2,&\n            rbmatrix,lsyssc_tr_virtual)\n        call lsyssc_scalarmatvec (&\n            rbmatrix, rsolution%rvectorblock(2), &\n            rtempvector, 1.0_dp, 1.0_dp)\n        \n        call output_lbrk()\n        call output_line ('divergence')\n        call output_line ('----------')\n        call output_line ('divergence = ' &\n            //trim(sys_sdep(lsyssc_vectornorm(rtempvector,linalg_norml2),15,6)) )\n            \n        call lsyssc_releasevector (rtempvector)\n      \n      end if\n      \n    end if\n    \n  end subroutine\n"}
{"id": 936, "subroutine": "      subroutine define_plasma(te, ti, ne, nni)\n      use allocatablevars \n      use physvars\n      use controlvars\n        implicit none\n        real                                :: te     ! [kev]\n        real                                :: ti     ! [kev]\n        real                                :: ne     ! [cm^-3]\n        integer                             :: nni    ! number of ion species\n!\n!       real,    dimension(:), allocatable  :: betab  ! [1/kev]\n!       real,    dimension(:), allocatable  :: mb     ! [kev]\n!       real,    dimension(:), allocatable  :: nb     ! [cm^-3]\n!       real,    dimension(:), allocatable  :: zb     ! [e]\n!       real,    dimension(:), allocatable  :: gb, etab, mpb, mbpb\n\n!\n! open output files\n!\n\n        te=100.   ! kev\n        ti=100.   ! kev\n        ne=1.e25 ! cm^-3\n\n        open(unit=1, file=\"main.symmetry.heavyme.010kev.dat\") !\n        open(unit=1, file=\"main.symmetry.heavyme.100kev.dat\") !\n\n!       open(unit=1, file=\"main.symmetry.100kev.dat\") !\n\n        asymptotic_forms=.false.\n        asymptotic_forms=.true.\n        if (asymptotic_forms) then\n           small_e_form=.true.\n           large_e_form=.true.\n        else\n           small_e_form=.false.\n           large_e_form=.false.\n        endif\n\n        nni=1  ! number of ion species\n        allocate(betab(1:nni+1),zb(1:nni+1),mb(nni+1),nb(1:nni+1))   ! allocatablevars\n        allocate(gb(1:nni+1),etab(1:nni+1),mpb(nni+1),mbpb(1:nni+1)) ! allocatablevars\n\n        zb(1)=-1.    ! species charges\n        zb(2)=+1.    ! \n        mb(1)=mekev  ! species masses [kev]\n        mb(2)=mpkev  !\n!\n! construct density and temperature arrays\n!\n        nb(1)=1.                          ! only for equimolar\n        nb(2:nni+1)=1./(zb(2:nni+1)*nni)  ! charge neutrality\n        nb=nb*ne                          ! number density array [cm^-3]\n        betab(1)=1./te                    ! inverse temp array   [kev^-1]\n        betab(2:nni+1)=1./ti              !\n      end subroutine define_plasma\n"}
{"id": 937, "subroutine": "      subroutine close_plasma\n      use allocatablevars\n        deallocate(betab,zb,mb,nb)   ! allocatablevars\n        deallocate(gb,etab,mpb)      ! allocatablevars\n      end subroutine close_plasma\n"}
{"id": 938, "subroutine": "      subroutine write_output(te, ti, ne, nni, betab, zb, mb, nb,   &\n      ln_bps_mass, ln_bps_born, delta_mass, cei_sing_mass,        &\n      cei_reg_mass, cei_qm_mass, cei_mass, cei_born, cei_dist_ei)\n      use physvars\n        implicit none\n        real,                        intent(in) :: te          ! [kev]\n        real,                        intent(in) :: ti          ! [kev]\n        real,                        intent(in) :: ne          ! [cm^-3]\n        integer,                     intent(in) :: nni         ! number of ion species\n        real,    dimension(1:nni+1), intent(in) :: betab       ! [1/kev]\n        real,    dimension(1:nni+1), intent(in) :: zb          ! [e]\n        real,    dimension(1:nni+1), intent(in) :: mb          ! [kev]\n        real,    dimension(1:nni+1), intent(in) :: nb          ! [cm^-3]\n        real,                        intent(in) :: ln_bps_mass !\n        real,                        intent(in) :: ln_bps_born !\n        real,                        intent(in) :: delta_mass  !\n        real,                        intent(in) :: cei_sing_mass !\n        real,                        intent(in) :: cei_reg_mass  !\n        real,                        intent(in) :: cei_qm_mass   !\n        real,                        intent(in) :: cei_mass      !\n        real,                        intent(in) :: cei_born      !\n        real,                        intent(in) :: cei_dist_ei   !\n        real  :: etae, ge, gi, ze\n        real,    dimension(1:nni+1) :: gb\n        real     :: c_ei_born\n        real     :: c_ei_tot, c_ei_i,c_ei_e, c_eic_tot, c_eic_i, c_eic_e\n        real     :: c_eiq_tot, c_eiq_i, c_eiq_e, c_eic_s_i, c_eic_s_e\n        real     :: c_eic_r_i ,c_eic_r_e\n        real,    dimension(1:nni+1)  :: c_eib\n        real,    dimension(1:nni+1,1:nni+1)  :: c_ab, c_ab_sing, c_ab_reg, c_ab_qm\n\n!     \n! write header\n!     \n        write(6,'(a)') '#'\n        write(6,'(a)') '#'\n        write(6,'(a, 3x,a17)') '#','plasma parameters'\n        write(6,'(a, 4x,a28, x,d12.4, x,d12.4)')  '#','electron and ion temp [kev]:', te, ti\n        write(6,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','number density nb   [cm^-3]:', nb\n        write(6,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','mass array mb         [amu]:', mb/amukev\n        write(6,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','mass array mb         [kev]:', mb\n        write(6,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','charge array zb            :', zb\n        write(1,'(a)') '#'  \n        write(1,'(a)') '#'\n        write(1,'(a, 3x,a17)') '#','plasma parameters'\n        write(1,'(a, 4x,a28, x,d12.4, x,d12.4)')  '#','electron and ion temp [kev]:', te, ti\n        write(1,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','number density nb   [cm^-3]:', nb\n        write(1,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','mass array mb         [amu]:', mb/amukev\n        write(1,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','mass array mb         [kev]:', mb\n        write(1,'(a, 4x,a28, x,d12.4, x,5d12.4)') '#','charge array zb            :', zb\n!\n! print plasma parameters\n!\n        call param(nni, betab, nb, gb, ge, gi, etae, ze)\n        write(6,'(a1, 2x,a9, 4x,a7, 4x,a7, 8x,a2, 7x,a2, 10x,a4, 9x,a9)') &\n          '#','ne[cm^-3]','te[kev]', 'ti[kev]','ge','gi','etae','ze/2**1.5'\n        write(6,'(a1,11d12.4)') '#',ne, te, ti, ge, gi, etae, ze/2**1.5\n        write(1,'(a1, 2x,a9, 4x,a7, 4x,a7, 8x,a2, 7x,a2, 10x,a4, 9x,a9)') &\n          '#','ne[cm^-3]','te[kev]', 'ti[kev]','ge','gi','etae','ze/2**1.5'\n        write(1,'(a1,11d12.4)') '#',ne, te, ti, ge, gi, etae, ze/2**1.5\n!\n! print rates\n!\n        call bps_rate_cei_born(nni,betab,zb,mb,nb,ln_bps_born,c_ei_born)\n        call bps_rate_cei_mass(nni, betab, zb, mb, nb, ln_bps_mass,   & \n          delta_mass, c_ei_tot, c_ei_i,c_ei_e,c_eic_tot,c_eic_i,c_eic_e,    &\n          c_eiq_tot,c_eiq_i,c_eiq_e, c_eic_s_i,c_eic_s_e,c_eic_r_i ,c_eic_r_e, c_eib) \n        call bps_rate_cab_matrix(nni, betab, zb, mb, nb, &\n            c_ab, c_ab_sing, c_ab_reg, c_ab_qm)\n\n        write(6,*) \"-----------------------------------\"\n        write(6,'(a14,e13.5,2x,a10)') \"cei_born     :\",c_ei_born, \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cei_mass     :\",c_ei_i,    \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cab_mass_sum :\",sum(c_ab(1,2:nni+1)), \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5)')        \"% diff       :\",100*abs((c_ei_i-c_ei_born)/c_ei_i)\n        write(6,*) \"\"\n        write(6,'(a14,e13.5)')        \"ln_bps_born  :\",ln_bps_born\n        write(6,'(a14,e13.5)')        \"ln_bps_mass  :\",ln_bps_mass\n        write(6,'(a14,e13.5)')        \"% diff       :\",100*abs((ln_bps_mass-ln_bps_born)/ln_bps_mass)\n        write(6,*) \"\"\n        write(6,'(a14,e13.5,2x,a10)') \"cei_reg_mass :\",c_eic_r_i,   \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cei_sing_mass:\",c_eic_s_i,   \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cei_qm_mass  :\",c_eiq_i,     \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"delta_mass   :\",delta_mass\n        write(6,*) \"-----------------------------------\"\n        write(6,'(a14,e13.5,2x,a10)') \"cab_reg_mass :\",sum(c_ab_reg(1,2:nni+1)),   \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cab_sing_mass:\",sum(c_ab_sing(1,2:nni+1)),  \"[1/cm^3 s]\"\n        write(6,'(a14,e13.5,2x,a10)') \"cab_qm_mass  :\",sum(c_ab_qm(1,2:nni+1)),    \"[1/cm^3 s]\"\n        write(6,*) \"-----------------------------------\"\n\n        write(1,*) \"-----------------------------------\"\n        write(1,'(a14,e13.5,2x,a10)') \"cei_born     :\",c_ei_born, \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cei_mass     :\",c_ei_i,    \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cab_mass_sum :\",sum(c_ab(1,2:nni+1)), \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5)')        \"% diff       :\",100*abs((c_ei_i-c_ei_born)/c_ei_i)\n        write(1,*) \"\"\n        write(1,'(a14,e13.5)')        \"ln_bps_born  :\",ln_bps_born\n        write(1,'(a14,e13.5)')        \"ln_bps_mass  :\",ln_bps_mass\n        write(1,'(a14,e13.5)')        \"% diff       :\",100*abs((ln_bps_mass-ln_bps_born)/ln_bps_mass)\n        write(1,*) \"\"\n        write(1,'(a14,e13.5,2x,a10)') \"cei_reg_mass :\",c_eic_r_i,   \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cei_sing_mass:\",c_eic_s_i,   \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cei_qm_mass  :\",c_eiq_i,     \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"delta_mass   :\",delta_mass\n        write(1,*) \"-----------------------------------\"\n        write(1,'(a14,e13.5,2x,a10)') \"cab_reg_mass :\",sum(c_ab_reg(1,2:nni+1)),   \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cab_sing_mass:\",sum(c_ab_sing(1,2:nni+1)),  \"[1/cm^3 s]\"\n        write(1,'(a14,e13.5,2x,a10)') \"cab_qm_mass  :\",sum(c_ab_qm(1,2:nni+1)),    \"[1/cm^3 s]\"\n        write(1,*) \"-----------------------------------\"\n\n\n!\n! quantities plotted\n!\n        write(1,'(a77)') \"# ix  x  x*exp(-x)*a_i*sqrt(2./pi)*1.e7  x*exp(-x)*a_i*norme*sqrt(2./pi)*1.e7\"\n\n!       write(6,'(a5, 2x,a7, 5x,a5, 7x,a3, 9x,a3, 9x,a6, 6x,a4, 8x,a4, 8x,a6, 6x,a4, 8x,a4)') &\n!         \"#  iu\", \"ep[kev]\", \"a_tot\", \"a_i\", \"a_e\", \"ac_tot\", \"ac_i_lim\", \"ac_e\", &\n!         \"aq_tot\", \"aq_i\", \"aq_e\"\n!       write(1,'(a)') \"#\"\n!       write(1,'(a5, 2x,a7, 5x,a5, 7x,a3, 9x,a3, 9x,a6, 6x,a4, 8x,a4, 8x,a6, 6x,a4, 8x,a4)') &\n!         \"#  iu\", \"ep[kev]\", \"a_tot\", \"a_i\", \"a_e\", \"ac_tot\", \"ac_i\", \"ac_e\", \"aq_tot\", \"aq_i\",\"aq_e\"\n      end subroutine write_output\n"}
{"id": 939, "subroutine": "      subroutine close_output\n      implicit none\n        close(1)\n      end subroutine close_output\n"}
{"id": 940, "subroutine": "      subroutine bps_rate_dist(nni, betab, zb, mb, nb, cei_dist_ei,     &\n        cei_sing_dist_ei, cei_reg_dist_ei, cei_qm_dist_ei, xmin, xmax, nmax)\n      use bpsvars\n      use mathvars\n      use physvars\n        implicit none\n        integer,                     intent(in)  :: nni             !  number of ions\n        real,    dimension(1:nni+1), intent(in)  :: betab           !  temperature array    [1/kev]\n        real,    dimension(1:nni+1), intent(in)  :: zb              !  charge array \n        real,    dimension(1:nni+1), intent(in)  :: mb              !  mass array [kev]\n        real,    dimension(1:nni+1), intent(in)  :: nb              !  number density array [cm^-3]\n        real,                        intent(out) :: cei_dist_ei     !  equilibration rate [cm^-3 s^-1]\n        real,                        intent(out) :: cei_sing_dist_ei!  normalized singular\n        real,                        intent(out) :: cei_reg_dist_ei !  normalized regular [cm^-3 s^-1]\n        real,                        intent(out) :: cei_qm_dist_ei  !  normalized quantum\n        real,                        intent(in)  :: xmin, xmax      !  integration limits\n        integer,                     intent(in)  :: nmax            !  number of integration regions [even]\n\n        real,    parameter :: upm=0.7745966692e0\n        real,    parameter :: w13=0.5555555556e0, w2=0.8888888889e0\n        real               :: a_tot, a_i, a_e, ac_tot, ac_i, ac_e, aq_tot, aq_i, aq_e\n        real               :: ac_s_i, ac_s_e, ac_r_i, ac_r_e\n        real               :: x, dx, xm, e, em\n        integer            :: ix\n        real               :: ze, ne, me, betae, norme, yei\n        integer            :: ib\n\n        cei_dist_ei     =0.\n        cei_sing_dist_ei=0.\n        cei_reg_dist_ei =0.\n        cei_qm_dist_ei  =0.\n\n        ib=1\n        ze=zb(ib)\n        me=mb(ib)\n        ne=nb(ib)\n        betae=betab(ib)\n        norme=2*ne*cc*sqrt(betae/me)\n\n        dx=(xmax-xmin)/nmax\n        x=xmin-dx\n        do ix=1,nmax,2 ! gaussian quadrature\n           x=x+2.*dx\n           e=x/betae\n           call bps_acoeff_ei_mass(nni,e,ze,me,betab,zb,mb,nb,     &\n              a_tot,a_i,a_e,ac_tot,ac_i,ac_e,aq_tot,aq_i,aq_e, &\n              ac_s_i, ac_s_e, ac_r_i, ac_r_e) ! mev/micron = 10^7 kev/cm\n           yei=x*exp(-x)*a_i\n           cei_dist_ei=cei_dist_ei+w2*yei\n!\n           xm=x-dx*upm\n           em=xm/betae\n           call bps_acoeff_ei_mass(nni,em,ze,me,betab,zb,mb,nb,    &\n              a_tot,a_i,a_e,ac_tot,ac_i,ac_e,aq_tot,aq_i,aq_e, &\n              ac_s_i, ac_s_e, ac_r_i, ac_r_e)\n           yei=xm*exp(-xm)*a_i\n           cei_dist_ei=cei_dist_ei+w13*yei\n!\n           xm=x+dx*upm\n           em=xm/betae\n           call bps_acoeff_ei_mass(nni,em,ze,me,betab,zb,mb,nb,    &\n              a_tot,a_i,a_e,ac_tot,ac_i,ac_e,aq_tot,aq_i,aq_e, &\n              ac_s_i, ac_s_e, ac_r_i, ac_r_e)\n           yei=xm*exp(-x)*a_i\n           cei_dist_ei=cei_dist_ei+w13*yei\n        enddo\n        cei_dist_ei=cei_dist_ei*1.e7 ! convert a from mev/micron to kev/cm.\n        cei_dist_ei=cei_dist_ei*dx*sqrt(2./pi)\n        cei_dist_ei=cei_dist_ei*norme\n      end subroutine bps_rate_dist\n"}
{"id": 941, "subroutine": "  subroutine get_date_from_cli(date)\n    ! reads year, month, and day from the command line\n    ! and returns the corresponding datetime instance.\n    type(datetime), intent(out) :: date\n    character(len=4) :: year_arg\n    character(len=2) :: month_arg, day_arg\n    integer :: year, month, day\n    \n    if (command_argument_count() < 3) then\n      stop 'usage: countdown year month day'\n    end if\n\n    call get_command_argument(1, year_arg)\n    call get_command_argument(2, month_arg)\n    call get_command_argument(3, day_arg)\n\n    read(year_arg, *) year\n    read(month_arg, *) month\n    read(day_arg, *) day\n\n    if (year < 1) then\n      stop 'year must be >= 1'\n    else if (month < 1 .or. month > 12) then\n      stop 'month must be >= 1 and <= 12'\n    else if (day < 1 .or. day > days_in_month(month, year)) then\n      stop 'invalid value for day'\n    end if\n\n    date = datetime(year, month, day, 0, 0, 0)\n\n  end subroutine get_date_from_cli\n"}
{"id": 942, "subroutine": "subroutine vertvel(rr,ia,ja,ka,imt,jmt,km,ff,uflux,vflux,do3d,wflux)\n!====================================================================\n! calculate the vertical flux based on the uflux and vflux\n!\n!  input:\n!    rr             : time interpolation constant between 0 and 1. controls how much\n!                   : of earlier time step is used in interpolation.\n!    ia,ja,ka       : original position in integers\n!    imt,jmt,km     : grid index sizing constants in (x,y,z), are for \n!                     horizontal and vertical rho grid [scalar]\n!    ff             : time direction. ff=1 forward, ff=-1 backward\n!    uflux          : u velocity (zonal) flux field, two time steps [ixjxkxt]\n!    vflux          : v velocity (meridional) flux field, two time steps [ixjxkxt]\n!    do3d           : flag to set whether to use 3d velocities or not\n!\n!  output:\n!    wflux          : w velocity (vertical) flux field, two time steps [kxt]\n!\n!  other parameters used in function:\n!    rg             : rg=1-rr for time interpolation between time steps. controls how much\n!                   : of later time step is used in interpolation.\n!    uu             : time-interpolated flux at ia/ja/ka (depending on ijk)\n!    um             : time-interpolated flux at ia-1/ja-1/ka-1 (depending on ijk)\n!    nsm=1,nsp=2    : time index. nsm picks out the earlier bounding time step and \n!                     nsp picks out the later bounding time step for interpolation.\n!    iam            : generic index for grid index -1 for whichever direction, ijk. \n!                     is only used in the i direction for whatever reason.\n!    k              : index for looping through depth layers\n!    n              : index for looping through times (1 and 2)\n!\n!  notes:\n!    computes the vertical velocity by integrating the continuity eq. from the bottom \n!    for the nsm and nsp velocity time steps.\n!    this is set up to use neither the -full_wflux nor -explicit_w flags currently, \n!    just the default w flux option.\n!====================================================================\n  \nimplicit none\n  \ninteger,        intent(in)                                      :: ff,ia,ja,ka,imt,jmt,km\ninteger,        intent(in)                                      :: do3d\nreal(kind=8),   intent(in)                                      :: rr\nreal(kind=8),   intent(in),     dimension(imt-1,jmt,km,2)       :: uflux\nreal(kind=8),   intent(in),     dimension(imt,jmt-1,km,2)       :: vflux\nreal(kind=8),   intent(out),    dimension(0:km,2)               :: wflux\nreal(kind=8)                                                    :: rg\n! real(kind=8)                                                    :: uu,um,rg\ninteger                                                         :: nsm=1,nsp=2,k,n,iam\n   \n\nrg=1.d0-rr\nwflux=0.d0\niam=ia-1 \n\n! print *,'in vertvel'\n! print '(a,i3,a,i3,a,i3)','ia=',ia,&\n!     ' ja=',ja,' ka=',ka\n! print *,'imt=',imt,' jmt=',jmt,' km=',km\n! print *,'size(uflux)=',size(uflux,1),' size(vflux)=',size(vflux,1)\n\n\nif(do3d==0) then\n    return\n  \n! start 3d code\nelse\n    kloop: do k=1,ka\n  ! these only need to be defined if we use full_wflux, which we aren't doing right now\n!      uu=rg*uflux(ia ,ja  ,k,nsp)+rr*uflux(ia ,ja  ,k,nsm)\n!      um=rg*uflux(iam,ja  ,k,nsp)+rr*uflux(iam,ja  ,k,nsm)\n!      vv=rg*vflux(ia ,ja  ,k,nsp)+rr*vflux(ia ,ja  ,k,nsm)\n!      vm=rg*vflux(ia ,ja-1,k,nsp)+rr*vflux(ia ,ja-1,k,nsm)\n\n! ! start ifs code\n! #if defined ifs\n!     do n=nsm,nsp\n!      wflux(k,n) = wflux(k-1,n) - ff * &\n!      ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n)  &\n!      + (dzt(ia,ja,k,nsp)-dzt(ia,ja,k,nsm))*dxdy(ia,ja)/tseas )  ! time change of the mass the in grid box\n!     enddo\n! #endif\n! ! end ifs code\n\n! start ocean code\n! #ifdef  full_wflux\n!      wflux(ia,ja,k,nsm)=wflux(ia,ja,k-1,nsm) - ff * ( uu - um + vv - vm )\n! #else\n        do n=nsm,nsp\n            wflux(k,n) = wflux(k-1,n) - ff * &\n                        ( uflux(ia,ja,k,n) - uflux(iam,ja,k,n) + &\n                        vflux(ia,ja,k,n) - vflux(ia,ja-1,k,n) )\n        enddo\n! #endif\n!end ocean code\n    end do kloop\n\nendif\n! end 3d code\n  \n!#endif\n  return\nend subroutine vertvel\n"}
{"id": 943, "subroutine": "subroutine spprr(lb1, lb2, srt)\n  parameter (arho=0.77)\n  common /ppb1/ene, factr2(6), fsum, ppinnb, s, wtot\n  common /ppmm/pprr, ppee, pppe, rpre, xopoe, rree\n  save\n  pprr = 0.\n  if ((lb1>=3 .and. lb1<=5) .and. (lb2>=3 .and. lb2<=5)) then\n    if (srt>(2*arho)) pprr = ptor(srt)\n  else if ((lb1>=25 .and. lb1<=27) .and. (lb2>=25 .and. lb2<=27)) then\n    pprr = rtop(srt)\n  end if\n  return\nend subroutine spprr\n"}
{"id": 944, "subroutine": "      subroutine el32int(jjja,jjjb,ja,jb,jja,jjb,jjc,jjd,icolbrei,     &\n                                                               interact)\n      integer, intent(in) :: jjja,jjjb,ja,jb,jja,jjb,jjc,jjd,icolbrei\n      integer, intent(out) :: interact\n      end subroutine\n"}
{"id": 945, "subroutine": "   subroutine set_initial_conditions\n\n     integer:: ix, iy, iz\n     real(num) :: hh\n     real(num) :: alpha1, alpha2, b1\n     real(num) :: rc, rb, rbx, rby, b_theta, b_z, delta, b2, c2\n     real(num) :: k, amp, dx, dy, theta, v_perp, v_r, v_theta\n     real(num) :: costh, sinth, coskz, sinkz, arg\n\n     vx = 0.0_num\n     vy = 0.0_num\n     vz = 0.0_num\n\n ! case 10\n     alpha1 = 1.8_num\n     alpha2 = alpha1*alpha1\n     b1 = 1.0_num\n\n ! helicity\n     hh = 0.0_num\n\n     bx = 0.0_num\n     by = 0.0_num\n     bz = 0.0_num\n\n     energy = 0.0_num\n     rho = 1.0_num\n     grav = 0.0_num\n\n ! velocity perturbation\n !case 3 perturbation\n     k = 6.0_num*pi/20.0_num\n     amp = 1.e-4_num\n     dx = 0.1_num * dxb(nx/2)\n     dy = 0.1_num * dyb(ny/2)\n     do ix = -1,nx+2\n       do iy = -1,ny+2\n         do iz = -1,nz+2\n\n           rc  = sqrt(xc(ix)*xc(ix)+yc(iy)*yc(iy))\n           rb  = sqrt(xb(ix)*xb(ix)+yb(iy)*yb(iy))\n           rbx = sqrt(xb(ix)*xb(ix)+yc(iy)*yc(iy))\n           rby = sqrt(xc(ix)*xc(ix)+yb(iy)*yb(iy))\n           if (rb .le. sqrt(dx**2 + dy**2)) then\n             costh = 1.0_num\n             sinth = 0.0_num\n           else\n             costh = xb(ix)/rb\n             sinth = yb(iy)/rb\n           end if\n           coskz = cos(k*zb(iz))\n           sinkz = sin(k*zb(iz))\n           v_r = exp(-rb**2*(1+(rb/0.5_num)**6))*cos(pi*zb(iz)/length_z)*&\n                 (costh*coskz + sinth*sinkz)\n !\n ! define the velocity at the cell boundaries\n !\n           if (rb .le. 1.0_num) then\n             b2 = alpha2*((1.0_num-rb**2.0_num)**7.0_num-1.0_num)/7.0_num\n             c2 = alpha2*rb*rb*(1.0_num-rb**2.0_num)**6.0_num\n             b_z = sqrt(1.0_num + b2 - c2)\n             b_theta = alpha1*rb*(1.0_num-rb*rb)**3.0_num\n             v_perp = -((b_theta**2 + b_z**2)/&\n              (b_z + k*rc*b_theta))*&\n              (1.0_num - 2.0_num*rb**2 - 8.0_num*(rb/0.5_num)**6)*exp(-4.0_num*rb**4)*&\n              cos(pi*zb(iz)/length_z)*(sinth*coskz - costh*sinkz)\n\n             v_theta = b_z*v_perp / (b_z**2 + b_theta**2)\n\n             vz(ix,iy,iz) = amp*(-b_theta*v_perp / (b_z**2 +&\n                   b_theta**2))\n             vx(ix,iy,iz) = amp*(v_r*costh - v_theta*sinth)\n             vy(ix,iy,iz) = amp*(v_r*sinth + v_theta*costh)\n           else\n             b_z = sqrt(1.0_num - alpha2/7.0_num)\n             b_theta = 0.0_num\n             v_perp = -((b_theta**2 + b_z**2)/&\n              (b_z + k*rb*b_theta))*&\n              (1.0_num - 2.0_num*rb**2 - 8.0_num*(rb/0.5_num)**6)*exp(-4.0_num*rb**4)*&\n              cos(pi*zb(iz)/length_z)*(sinth*coskz - costh*sinkz)\n\n             v_theta = b_z*v_perp / (b_z**2 + b_theta**2)\n\n             vz(ix,iy,iz) = amp*(-b_theta*v_perp / (b_z**2 +&\n                   b_theta**2))\n             vx(ix,iy,iz) = amp*(v_r*costh - v_theta*sinth)\n             vy(ix,iy,iz) = amp*(v_r*sinth + v_theta*costh)\n           end if\n !\n ! define bz on face centred at (xc,yc,zb)\n !\n           if (rc .le. 1.0_num) then\n             b2 = alpha2*((1.0_num-rc**2.0_num)**7.0_num-1.0_num)/7.0_num\n             c2 = alpha2*rc*rc*(1.0_num-rc**2.0_num)**6.0_num\n             bz(ix,iy,iz) = sqrt(1.0_num + b2 - c2)\n           else\n             bz(ix,iy,iz) = sqrt(1.0_num - alpha2/7.0_num)\n           end if\n !\n ! define bx on face centred at (xb,yc,zc)\n !\n           if (rbx .le. 1.0_num) then\n             b_theta = alpha1*rbx*(1.0_num-rbx*rbx)**3.0_num\n             bx(ix,iy,iz) = -b_theta * yc(iy) / rbx\n           else\n             bx(ix,iy,iz) = 0.0_num\n           end if\n !\n ! define by on face centred at (xc,yb,zc)\n !\n           if (rby .le. 1.0_num) then\n             b_theta = alpha1*rby*(1.0_num-rby*rby)**3.0_num\n             by(ix,iy,iz) = b_theta * xc(ix) / rby\n           else\n             by(ix,iy,iz) = 0.0_num\n           end if\n\n         end do\n       end do\n     end do\n\n   end subroutine set_initial_conditions\n"}
{"id": 946, "subroutine": "subroutine set_initial_conditions\n\n  integer :: ix, iy, iz, loop\n  real(num) :: rc, x1, y1, b_theta, amp, k, r0, a=1.1_num, r1, mu, m=1.5\n  real(num):: b0, bz0, t_ph=1.0_num, t_cor=150.0_num, z_cor=25.0_num, wtr=5.0_num\n  real(num) :: dg, w, q, lambda, r, bphi, b1, p0, p1, rho1, r_a, a1, a2, b\n  real(num) :: maxerr, xi_v\n  real(num), dimension(:), allocatable :: dzb_global, dzc_global,zc_global,grav_global\n\n  real(num), dimension(:), allocatable :: rho_ref, energy_ref, t_ref, mu_m\n\n  allocate(dzb_global(-1:nz_global+1), dzc_global(-1:nz_global), zc_global(-1:nz_global+1))\n  allocate(grav_global(-1:nz_global+2), mu_m(-1:nz_global+2))\n  allocate(rho_ref(-1:nz_global+2),energy_ref(-1:nz_global+2), t_ref(-1:nz_global+2))\n\n  ! changed from james's version to remove the need for a seperate routine setting up\n  ! the newton cooling arrays and the mpi calls.\n\n  ! set up the initial 1d hydrostatic equilibrium\n\n  grav_global = 0.9727_num\n\n  ! example of lowering g to zero in corona\n  a1 = 60.0_num\n  a2 = 80.0_num\n  where (zb_global > a1) grav_global = grav_global(0)*(1.0_num+cos(pi*(zb_global-a1)/(a2-a1))) &\n       /2.0_num\n  where (zb_global > a2) grav_global = 0.0_num\n\n  !y.fan atmosphere temp profile\n  do iz = -1, nz_global+1 ! needs to be +1 for the dzc calculation\n     zc_global(iz) = 0.5_num * (zb_global(iz) + zb_global(iz-1))\n     if (zc_global(iz) < 0.0_num) then\n        t_ref(iz) = t_ph - (t_ph * a * zc_global(iz) * grav_global(iz) / (m+1.0_num))\n     else\n        t_ref(iz) = t_ph + ((t_cor-t_ph) * 0.5_num * (tanh((zc_global(iz)-z_cor)/wtr)+1.0_num))\n     end if\n  end do\n  t_ref(nz_global+2) = t_ref(nz_global+1)\n\n  !solve hs eqn to get rho profile\n  !density at bottom of domain\n  rho_ref = 1.0_num\n\n  do iz = -1, nz_global\n     dzb_global(iz) = zb_global(iz) - zb_global(iz-1)\n     dzc_global(iz) = zc_global(iz+1) - zc_global(iz)\n  end do\n\n  !solve for density\n  mu_m = 0.5_num    ! the reduced mass in units of proton mass\n  if (include_neutrals) xi_n = 0.0_num\n  do loop = 1, 100\n     maxerr = 0.0_num\n    do iz = nz_global, 0, -1\n      if (zc_global(iz) < 0.0_num) then\n        dg = 1.0_num / (dzb_global(iz)+dzb_global(iz-1))\n        rho_ref(iz-1) = rho_ref(iz) * (t_ref(iz)/dzc_global(iz-1)/mu_m(iz)&\n             +grav_global(iz-1)*dzb_global(iz)*dg)\n        rho_ref(iz-1) = rho_ref(iz-1) / (t_ref(iz-1)/dzc_global(iz-1)/mu_m(iz-1) &\n             -grav_global(iz-1)*dzb_global(iz-1)*dg)\n      end if\n    end do\n    !now move from the photosphere up to the corona\n    do iz = 0, nz_global\n      if (zc_global(iz) > 0.0_num) then\n        dg = 1.0_num / (dzb_global(iz)+dzb_global(iz-1))\n        rho_ref(iz) = rho_ref(iz-1) * (t_ref(iz-1)/dzc_global(iz-1)/mu_m(iz-1)&\n             -grav_global(iz-1)*dzb_global(iz-1)*dg)\n        rho_ref(iz) = rho_ref(iz) / (t_ref(iz)/dzc_global(iz-1)/mu_m(iz) &\n             +grav_global(iz-1)*dzb_global(iz)*dg)\n      end if\n    end do\n    if (include_neutrals) then     !note this always assumes eos_pi\n        do iz = 0, nz_global\n           xi_v = get_neutral(t_ref(iz), rho_ref(iz))\n           r1 = mu_m(iz)\n           mu_m(iz) = 1.0_num / (2.0_num - xi_v)\n           maxerr = max(maxerr, abs(mu_m(iz) - r1))\n        end do\n     end if\n     if (maxerr < 1.e-10_num) exit\n  end do\n  rho_ref(nz_global+1:nz_global+2) = rho_ref(nz_global)\n  ! set the relaxation rate, james used an exponent of -1.67, here i use the value\n  ! in the 2d paper of -1.67. the tau equation is scaled by 1/t0 * 0.1\n\n  ! convert into the local 3d arrays\n  vx = 0.0_num\n  vy = 0.0_num\n  vz = 0.0_num\n\n  grav = grav_global(coordinates(1)*nz-1:coordinates(1)*nz+nz+2)\n\n  do iy = -1, ny + 2\n     do ix = -1, nx + 2\n        !store temperature in energy array for a few lines\n        energy(ix,iy,:) = t_ref(coordinates(1)*nz-1:coordinates(1)*nz+nz+2)\n        rho(ix,iy,:) = rho_ref(coordinates(1)*nz-1:coordinates(1)*nz+nz+2)\n     end do\n  end do\n\n  do iz = -1, nz + 2\n    do iy = -1, ny + 2\n      do ix = -1, nx + 2\n        r1 = energy(ix,iy,iz)\n        call get_energy(rho(ix,iy,iz), r1, eos_number, ix, iy, iz, energy(ix,iy,iz))\n      end do\n    end do\n  end do\n\n  !add magnetic flux tube at (0,0,-10) and change pressure, dens, energy over it\n  !grad(p1) matches lorentz force\n  !meq at end of tube\n  !pressure match at apex\n  !seee fan 2001 for details of initialisation\n  !w = width of tube\n  w = 2.0_num\n  q = -(1.0_num/w)\n  b0 = 5.0_num\n  lambda = 20.0_num\n  do ix = -1,nx+2\n     do iy = -1,ny+2\n        do iz = -1,nz+2\n           !define bx,by,bz at correct points\n           r = sqrt(yc(iy)**2 + (zc(iz)+10.0_num)**2)\n           bx(ix,iy,iz) =  b0 * exp(-(r/w)**2)\n           bphi =  bx(ix,iy,iz) * q * r\n\n           r = sqrt(yb(iy)**2 + (zc(iz)+10.0_num)**2)\n           b1 = b0 * exp(-(r/w)**2)\n           by(ix,iy,iz) = -b1 * q * (zc(iz)+10.0_num)\n\n           r = sqrt(yc(iy)**2 + (zb(iz)+10.0_num)**2)\n           b1 =  b0 * exp(-(r/w)**2)\n           bz(ix,iy,iz) =  b1 * q * yc(iy)\n\n           !define gas pressure and magnetic pressure\n           p0 =  rho(ix,iy,iz)*energy(ix,iy,iz)*(gamma-1.0_num)\n           p1 =  -0.25_num * bx(ix,iy,iz)**2 - 0.5_num * bphi**2\n           !change density and energy\n           r1 = xc(ix)/lambda\n           rho1 =  (p1/p0)*rho(ix,iy,iz)*exp(-(r1**2))\n           rho(ix,iy,iz)   =  rho(ix,iy,iz) + rho1\n           energy(ix,iy,iz)= (p0 + p1) / (rho(ix,iy,iz) * (gamma - 1.0_num))\n\n        end do\n     end do\n  end do\n\n  deallocate(dzb_global, dzc_global, zc_global)\n  deallocate(grav_global, mu_m)\n  deallocate(rho_ref, energy_ref, t_ref)\n\nend subroutine set_initial_conditions\n"}
{"id": 947, "subroutine": "  subroutine equilibrium\n\n    integer :: ix, iy, iz\n    real(num) :: rc, x1, y1, b_theta, amp, k, r0, a, r1, mu\n    real(num):: b0, bz0\n\n    vx = 0.0_num\n    vy = 0.0_num\n    vz = 0.0_num\n\n    bx = 1.0_num\n    by = 0.0_num\n    bz = 0.0_num\n\n    r0 = 1.0_num / sqrt(6.0_num)\n    a = 5.0_num / (6.0_num * sqrt(6.0_num))\n\n    bz0 = 1.0_num\n    b0 = 4.3_num\n\n    do ix = -1, nx+2             ! setup static equilibrium values\n       do iy = -1, ny+2\n          do iz = -1, nz+2\n\n             rc = sqrt(xc(ix)**2 + yc(iy)**2)\n             if (rc >= 1.0_num) rc = 1.0_num\n             bz(ix,iy,iz) = (1.0/2.0)*rc**2 - (3.0/8.0)*(rc**4/r0**2)    &\n                  + (7.0*a/25.0)*(rc**5/r0**3) + (1.0/12.0)*(rc**6/r0**4)     &\n                  - (9.0*a/70.0)*(rc**7/r0**5) + (1.0*a**2/20.0)*(rc**8/r0**6)\n             bz(ix,iy,iz) = sqrt(bz0**2 - b0**2*bz(ix,iy,iz))\n             rho(ix,iy,iz) = 0.45_num*(1.0_num+cos(pi*rc))+0.1_num\n\n             x1 = xb(ix)\n             y1 = yc(iy)\n             rc = sqrt(x1**2 + y1**2)\n             if (rc >= 1.0_num) rc = 1.0_num\n             b_theta = rc/2.0 - rc**3/(4.0*r0**2) + a*rc**4/(5.0*r0**3)\n             bx(ix,iy,iz) = - b0 * b_theta * y1 / rc\n\n             x1 = xc(ix)\n             y1 = yb(iy)\n             rc = sqrt(x1**2 + y1**2)\n             if (rc >= 1.0_num) rc = 1.0_num\n             b_theta = rc/2.0 - rc**3/(4.0*r0**2) + a*rc**4/(5.0*r0**3)\n             by(ix,iy,iz) = b0 * b_theta * x1 / rc\n\n          end do\n       end do\n    end do\n    bx(-2,:,:) = bx(-1,:,:)\n    by(:,-2,:) = by(:,-1,:)\n    bz(:,:,-2) = bz(:,:,-1)\n\n\n    where (rho < 0.1_num) rho = 0.1_num\n    energy = 0.01_num / (rho * (gamma-1.0_num))\n\n    k = 2.0_num * pi / length_z     ! apply velocity perturbation\n    amp = 1.e-2_num\n    r1 = 0.95_num\n    mu = 0.2_num\n\n    do ix = -1, nx+2\n       do iy = -1, ny+2\n          do iz = -1, nz+2\n             rc = sqrt(xb(ix)**2 + yb(iy)**2)\n             if (rc < r1) then\n                vx(ix,iy,iz) = amp*cos(2.5_num*k*zc(iz))   &\n                     * (1.0_num+cos(k*zc(iz)))*(1.0_num - (rc/r1)**2)**mu\n                vy(ix,iy,iz) = amp*sin(2.5_num*k*zc(iz))   &\n                     * (1.0_num+cos(k*zc(iz)))*(1.0_num - (rc/r1)**2)**mu\n             else\n                vx(ix,iy,iz) = 0.0_num\n                vy(ix,iy,iz) = 0.0_num\n             end if\n          end do\n       end do\n    end do\n\n\n  end subroutine equilibrium\n"}
{"id": 948, "subroutine": "  subroutine equilibrium\n\n    integer :: ix, iy, iz\n    real(num), dimension(:,:,:), allocatable :: ax,ay,az\n    real(num) :: mag_scale_height, b0, r, radius\n\n    allocate(ax(-2:nx+2,-2:ny+2,-2:nz+2),ay(-2:nx+2,-2:ny+2,-2:nz+2),az(-2:nx+2,-2:ny+2,-2:nz+2))\n\n    ax = 0.0_num\n    ay = 0.0_num\n    az = 0.0_num\n\n    vx = 0.0_num\n    vy = 0.0_num\n    vz = 0.0_num\n\n    rho = 1.0_num\n    energy = 0.01_num  / (gamma - 1.0_num)\n\n    bx = 0.0_num\n    by = 0.0_num\n    bz = 0.0_num\n\n    r = 10.0_num ! loop major radius, foot points are at +- r\n    b0 = 1.0_num\n    mag_scale_height = 2.0_num * r / pi\n    grav = 0.0_num\n\n    ! define the vector potential\n    do iz = -2, nz + 2\n       do ix = -2, nx + 2\n          ay(ix,:,iz) = b0 * mag_scale_height * cos(xb(ix) / mag_scale_height) * exp(-zb(iz)/mag_scale_height)\n       end do\n    end do\n\n\n    ! take the curl of the vector potential to get b\n    do iz = -1, nz + 2\n       do iy = -1, ny + 2\n          do ix = -1, nx + 2\n             ixm = ix - 1\n             iym = iy - 1\n             izm = iz - 1\n             bx(ix,iy,iz) = (az(ix,iy,iz) - az(ix,iym,iz)) / dyb(iy) - (ay(ix,iy,iz) - ay(ix,iy,izm)) / dzb(iz)\n             by(ix,iy,iz) = (ax(ix,iy,iz) - ax(ix,iy,izm)) / dzb(iz) - (az(ix,iy,iz) - az(ixm,iy,iz)) / dxb(ix)\n             bz(ix,iy,iz) = (ay(ix,iy,iz) - ay(ixm,iy,iz)) / dxb(ix) - (ax(ix,iy,iz) - ax(ix,iym,iz)) / dyb(iy)\n          end do\n       end do\n    end do\n\n    do iz = -1, nz + 2\n       do iy = -1, ny + 2\n          iym = iy - 1\n          izm = iz - 1\n          bx(-2,iy,iz) = (az(-2,iy,iz) - az(-2,iym,iz)) / dyb(iy) - (ay(-2,iy,iz) - ay(-2,iy,izm)) / dzb(iz)\n       end do\n    end do\n\n    do iz = -1, nz + 2\n       do ix = -1, nx + 2\n          by(ix,-2,iz) = (ax(ix,-2,iz) - ax(ix,-2,izm)) / dzb(iz) - (az(ix,-2,iz) - az(ixm,-2,iz)) / dxb(ix)\n       end do\n    end do\n\n    do iy = -1, ny + 2\n       do ix = -1, nx + 2\n          bz(ix,iy,-2) = (ay(ix,iy,-2) - ay(ixm,iy,-2)) / dxb(ix) - (ax(ix,iy,-2) - ax(ix,iym,-2)) / dyb(iy)\n       end do\n    end do\n\n    deallocate(ax,ay,az)\n\n\n  end subroutine equilibrium\n"}
{"id": 949, "subroutine": "      subroutine linsca(xlam, elden, scafac, absfac)\r\n\r\n!     enhanced factor for heii ly-alpha (not active)\r\n!\r\n\n!     electron scattering linearly in a table\r\n!\r\n!     the table is output of the monte-carlo programm \r\n!     ==> ip and dimensions have to be updated, if the table is changed\r\n\r\n      implicit real*8(a-h,o-z)\r\n      real*8,intent(in):: xlam, elden\r\n      real*8,intent(out):: scafac,absfac\r\n      parameter ( one = 1.d+0 )\r\n      parameter (ipdim=25,nbdim=99)\r\n      common /libldat/ scagri(ipdim), scaevt(ipdim,nbdim), \r\n     $                                absevt(ipdim,nbdim)\r\n      common /liblpar/ almin, almax, lblaon, ipmax, nbmax, nbinw\r\n\r\n      if (xlam.lt.almin .or. lblaon.eq.0) then\r\n         scafac=one\r\n         absfac=one\r\n         return\r\n      else if (xlam.lt.almax) then\r\n         xbin=xlam\r\n         if (xbin.lt.911.7 .and. xbin.gt.900.) xbin=899.\r\n         if (xbin.lt.227.9 .and. xbin.gt.220.) xbin=219.\r\n         nlam=xbin/nbinw\r\n         nlam=nlam+1\r\n         if (nlam.gt.nbmax) nlam=nbmax\r\n      else \r\n         scafac=one\r\n         absfac=one\r\n         return\r\n      endif\r\n\r\n      if (nlam.gt.nbdim) stop 'linsca'\r\n      if (nlam.lt.1 .or. nlam.gt.nbmax) stop 'linsca'\r\n      if (elden.gt.scagri(1)) then\r\n         scafac=scaevt(1,nlam)\r\n         absfac=absevt(1,nlam)\r\n      else if (elden.lt.scagri(ipmax)) then\r\n         scafac=scaevt(ipmax,nlam)\r\n         absfac=absevt(ipmax,nlam)\r\n      else\r\n         do 1 i=1,ipmax-1\r\n            if (elden.le.scagri(i)) k1=i\r\n 1       continue\r\n         k2=k1+1\r\n         dscagri=scagri(k1)-scagri(k2)\r\n         dscaevt=scaevt(k1,nlam)-scaevt(k2,nlam)\r\n         scafac=(elden-scagri(k1))/dscagri*dscaevt+scaevt(k1,nlam)\r\n         dabsevt=absevt(k1,nlam)-absevt(k2,nlam)\r\n         absfac=(elden-scagri(k1))/dscagri*dabsevt+absevt(k1,nlam)\r\nctest         if (xbin.lt.319. .and. xbin.gt.300.) scafac=scafac*10.\r\n      endif\r\n      if (scafac.lt.one) stop ' scafac.lt.1 '\r\n      if (absfac.lt.one) stop ' absfac.lt.1 '\r\n      return\r\n      end subroutine\r\n"}
{"id": 950, "subroutine": "      subroutine module_doc()\n      implicit none\n! functions\n      integer, external :: basin, climateflow, prms_time\n      integer, external :: cascade, obs, soltab, transp_tindex\n      integer, external :: transp_frost, frost_date, routing\n      integer, external :: temp_1sta_laps, temp_dist2\n      integer, external :: precip_1sta_laps, climate_hru\n      integer, external :: precip_dist2, xyz_dist, ide_dist\n      integer, external :: ddsolrad, ccsolrad\n      integer, external :: potet_pan, potet_jh, potet_hamon, potet_hs, potet_pt, potet_pm\n      integer, external :: intcp, snowcomp, gwflow, srunoff, soilzone\n      integer, external :: strmflow, subbasin, basin_sum, map_results, strmflow_in_out\n      integer, external :: write_climate_hru, muskingum, strmflow_lake, lake_route\n      external :: nhru_summary, prms_summary, water_balance\n! local variable\n      integer :: test\n!**********************************************************************\n      test = basin()\n      test = cascade()\n      test = climateflow()\n      test = soltab()\n      test = prms_time()\n      test = obs()\n      test = temp_1sta_laps()\n      test = temp_dist2()\n      test = xyz_dist()\n      test = ide_dist()\n      test = climate_hru()\n      test = precip_1sta_laps()\n      test = precip_dist2()\n      test = ddsolrad()\n      test = ccsolrad()\n      test = transp_tindex()\n      test = frost_date()\n      test = transp_frost()\n      test = potet_jh()\n      test = potet_hamon()\n      test = potet_pan()\n      test = potet_hs()\n      test = potet_pt()\n      test = potet_pm()\n      test = write_climate_hru()\n      test = intcp()\n      test = snowcomp()\n      test = srunoff()\n      test = soilzone()\n      test = gwflow()\n      test = routing()\n      test = strmflow()\n      test = strmflow_in_out()\n      test = muskingum()\n      test = lake_route()\n      test = strmflow_lake()\n      test = basin_sum()\n      test = map_results()\n      call nhru_summary()\n      call prms_summary()\n      call water_balance()\n      test = subbasin()\n\n      print 9001\n 9001 format (//, ' all available modules have been called.', /, &\n     &        ' all parameters have been declared.', /, &\n     &        ' note, no simulation was computed.', /)\n\n      end subroutine module_doc\n"}
{"id": 951, "subroutine": "      subroutine call_modules_restart(in_out)\n      use prms_module\n      implicit none\n      ! argument\n      integer, intent(in) :: in_out\n      external check_restart, check_restart_dimen\n      ! local variables\n      integer :: nhru_test, dprst_test, nsegment_test, temp_test, et_test, ierr\n      integer :: cascade_test, cascdgw_test, nhrucell_test, nlake_test\n      character(len=maxcontrol_length) :: model_test\n      character(len=12) :: module_name\n!***********************************************************************\n      if ( in_out==0 ) then\n        write ( restart_outunit ) modname\n        write ( restart_outunit ) timestep, nhru, dprst_flag, nsegment, temp_flag, et_flag, &\n     &          cascade_flag, cascadegw_flag, nhrucell, nlake, model_mode\n      else\n        ierr = 0\n        read ( restart_inunit ) module_name\n        call check_restart(modname, module_name)\n        read ( restart_inunit ) timestep, nhru_test, dprst_test, nsegment_test, temp_test, et_test, &\n     &         cascade_test, cascdgw_test, nhrucell_test, nlake_test, model_test\n        if ( model_mode/=model_test ) then\n          print *, 'error, initial conditions file saved for model_model=', model_test\n          print *, '       current model has model_model=', model_mode, ' they must be equal'\n          ierr = 1\n        endif\n        call check_restart_dimen('nhru', nhru_test, nhru, ierr)\n        call check_restart_dimen('nhrucell', nhrucell_test, nhrucell, ierr)\n        call check_restart_dimen('nlake', nlake_test, nlake, ierr)\n        if ( dprst_flag/=dprst_test ) then\n          print *, 'error, initial conditions file saved for model with dprst_flag=', dprst_test\n          print *, '       current model has dprst_flag=', dprst_flag, ' they must be equal'\n          ierr = 1\n        endif\n        if ( cascade_flag/=cascade_test ) then\n          print *, 'error, initial conditions file saved for model with cascade_flag=', cascade_test\n          print *, '       current model has cascade_flag=', cascade_flag, ' they must be equal'\n          ierr = 1\n        endif\n        if ( cascadegw_flag/=cascdgw_test ) then\n          print *, 'error, initial conditions file saved for model with cascadegw_flag=', cascdgw_test\n          print *, '       current model has cascadegw_flag=', cascadegw_flag, ' they must be equal'\n          ierr = 1\n        endif\n        call check_restart_dimen('nsegment', nsegment_test, nsegment, ierr)\n        if ( temp_flag/=temp_test ) then\n          print *, 'error, initial conditions file saved for model with different temperature'\n          print *, '       module than current model, they must use the same module'\n          ierr = 1\n        endif\n        if ( et_flag/=et_test ) then\n          if ( et_flag==4 ) then\n            print *, 'error, initial conditions file saved for model using potet_pan module'\n            print *, '       current model also must use potet_pan'\n            ierr = 1\n          elseif ( et_flag==11 ) then\n            print *, 'error, initial conditions file saved for model using potet_pm module'\n            print *, '       current model also must use potet_pm'\n            ierr = 1\n          endif\n        endif\n        if ( ierr==1 ) stop\n      endif\n      end subroutine call_modules_restart\n"}
{"id": 952, "subroutine": "    subroutine collect_math(testsuite)\n        type(unittest_type), allocatable, intent(out) :: testsuite(:)\n        testsuite = [&\n        new_unittest(\"angle_real vaild\", test_math_angle_real), &\n        new_unittest(\"cross_int vaild\", test_math_cross_int), &\n        new_unittest(\"cross_real vaild\", test_math_cross_real) &\n        ]\n    end subroutine collect_math\n"}
{"id": 953, "subroutine": "    subroutine test_math_cross_int(error)\n        type(error_type), allocatable, intent(out) :: error\n        integer(int8), dimension(3) :: x, y\n        x = 1_int8;  y = 2_int8\n        \n        call check(error, all((x.c.y) == [integer(int8) :: 0, 0, 0]))\n        if (allocated(error)) return\n        \n    end subroutine test_math_cross_int\n"}
{"id": 954, "subroutine": "    module subroutine test_math_angle_real(error)\n        type(error_type), allocatable, intent(out) :: error\n        real, dimension(3) :: x, y\n        x = 1_int8;  y = 2_int8\n        \n        call check(error, is_close(angle(x, y), 0.0))\n        if (allocated(error)) return\n        \n    end subroutine test_math_angle_real\n"}
{"id": 955, "subroutine": "  subroutine init_device_data()\n    implicit none\n    allocate(a(n,n))\n    allocate(b(n,n))\n    !$omp target enter data map(alloc:b)\n  end subroutine\n"}
{"id": 956, "subroutine": "  subroutine free_device_data()\n    implicit none\n    deallocate(a)\n    !$omp target exit data map(release:b)\n    deallocate(b)\n  end subroutine\n"}
{"id": 957, "subroutine": "subroutine getgaunt(lmax, ck)\n! calculates the gaunt c^k(l1, m1, l2, m2) coefficients\n! it returns an array of coefficients for all combinations of k, l1, m1, l2, m2:\n!   ck(k, l1, m1, l2, m2) = c^k(l1, m1, l2, m2)\n! indices out of bounds mean that the coefficient is zero.\ninteger, intent(in) :: lmax  ! max(l1, l2)\nreal(dp), allocatable, intent(out) :: ck(:, :, :, :, :) ! ck(k, l1, m1, l2, m2)\ninteger :: k, l1, m1, l2, m2\nallocate(ck(0:2*lmax, 0:lmax, -lmax:lmax, 0:lmax, -lmax:lmax))\nck = 0\ndo l1 = 0, lmax\n    do l2 = 0, lmax\n        do m1 = -l1, l1\n            do m2 = -l2, l2\n                do k = abs(l1-l2), l1+l2, 2\n                    if (abs(m1-m2) > k) cycle\n                    ck(k, l1, m1, l2, m2) = (-1)**(-m1) * &\n                        sqrt(1._dp*(2*l1+1)*(2*l2+1)) * &\n                        wigner3j(l1, k, l2, 0, 0, 0) * &\n                        wigner3j(l1, k, l2, -m1, m1-m2, m2)\n                end do\n            end do\n        end do\n    end do\nend do\nend subroutine\n"}
{"id": 958, "subroutine": "subroutine getgauntr(lmax, gr)\ninteger, intent(in) :: lmax  ! max(l1, l2)\n! gr(i, j, k, l, m, n) = <ij|kl|mn>_r\nreal(dp), allocatable, intent(out) :: gr(:, :, :, :, :, :)\nreal(dp), allocatable :: ck(:, :, :, :, :)\ninteger :: l1, m1, l2, m2, l3, m3\ninteger :: lmax2\nlmax2 = 4*lmax\nallocate(ck(0:2*lmax2, 0:lmax2, -lmax2:lmax2, 0:lmax2, -lmax2:lmax2))\ncall getgaunt(lmax2, ck)\nallocate(gr(0:lmax, -lmax:lmax, 0:2*lmax, -2*lmax:2*lmax, 0:lmax, -lmax:lmax))\ngr = 0\ndo l1 = 0, lmax\n    do l2 = 0, 2*lmax\n        do l3 = 0, lmax\n            do m1 = -l1, l1\n                do m2 = -l2, l2\n                    do m3 = -l3, l3\n                        gr(l1, m1, l2, m2, l3, m3) = &\n                            gauntr(l1, m1, l2, m2, l3, m3, ck, lmax2)\n                    end do\n                end do\n            end do\n        end do\n    end do\nend do\nend subroutine\n"}
{"id": 959, "subroutine": "subroutine fm(maxm, t, f)\n! calculates f_m(t) for m=0,1,..,maxm, where\n!\n!     f_m(t) = \\int_0^1 u^(2m) e^(-tu^2) du\n!\n! and assigns the result to the array f(m) = f_m(t).\n!\n! conditions on max, t: 0 <= maxm <= 500, t >= 0.\n!\n! this routine is tested for absolute accuracy 1e-15 and relative accuracy\n! 1e-12 for all maxm = 0..500 and all values \"t\" from the interval\n! 0 <= t <= 2e8.\n!\n! the algorithm is based on [1], all equations are references from there. the\n! idea is to use series expansion for f_maxm(t) and then the recursive relation\n! (24) downwards to calculate f_m(t) for m < maxm. for t >= maxm + 0.5, the\n! series would take too many iterations to converge and also the downwards\n! relation (24) becomes inaccurate, so we calculate f_0(t) directly and use\n! (24) upwards.\n!\n! [1] i. shavitt: methods in computational physics (academic press inc., new\n! york, 1963), vol. 2\ninteger, intent(in) :: maxm\nreal(dp), intent(in) :: t\n! the array f(0:maxm) will be equal to f(m) = f_m(t) for m = 0..maxm\nreal(dp), intent(out) :: f(0:)\n\nreal(dp) :: s, term\ninteger :: m\nif (maxm < 0 .or. maxm > 500) &\n    call stop_error(\"fm: only works for 0 <= m <= 500\")\nif (t < 0) call stop_error(\"fm: only works for t >= 0\")\nif (ubound(f, 1) /= maxm) call stop_error(\"fm: invalid bounds on f\")\n\nif (t < maxm + 0.5_dp) then\n    ! series expansion for f_m(t), between equations (24) and (25).\n    ! since (2*t)/(2*maxm+1) < 1, this will converge fast:\n    term = 1._dp / (2*maxm + 1)\n    s = term\n    m = 1\n    do while (term/s > epsilon(1._dp))\n        term = term * (2*t) / (2*maxm + 2 * m + 1)\n        ! \"s\" will only change if term/s > machine eps\n        s = s + term\n        m = m + 1\n    end do\n    f(maxm) = s * exp(-t)\n    ! eq. (24) downwards, for t < maxm+0.5, this converges well:\n    do m = maxm-1, 0, -1\n        f(m) = (2*t*f(m + 1) + exp(-t)) / (2*m + 1)\n    end do\nelse\n    ! eq. for f_0(t) on page 7:\n    f(0) = 0.5_dp * sqrt(pi/t) * erf(sqrt(t))\n    ! eq. (24) upwards, for t >= maxm+0.5, this converges well:\n    do m = 0, maxm-1\n        f(m + 1) = ((2*m + 1)*f(m) - exp(-t)) / (2*t)\n    end do\nendif\nend subroutine\n"}
{"id": 960, "subroutine": "subroutine knu_formula(maxk, x, k)\n! returns k(k) = k_{k+1/2}(x) / exp(-x) for k=-1,0,1,...,maxk.\ninteger, intent(in) :: maxk\nreal(dp), intent(in) :: x\nreal(dp), intent(out) :: k(-1:)\ninteger :: l\nk(-1) = sqrt(pi/(2*x))\nk(0) = k(-1)\ndo l = 0, maxk-1\n    ! k_{nu+1} = k_{nu-1} + 2*nu*k_nu/x\n    k(l + 1) = k(l-1) + (2*l + 1)*k(l)/x\nend do\nend subroutine\n"}
{"id": 961, "subroutine": "subroutine inu_formula(maxk, x, i)\n! returns i(k) = i_{k+1/2}(x) / exp(x) for k=-1,0,1,...,maxk.\ninteger, intent(in) :: maxk\nreal(dp), intent(in) :: x\nreal(dp), intent(out) :: i(-1:)\ninteger :: l\ni(-1) = (1+exp(-2*x)) / sqrt(2*pi*x)\n! i(0) = (1-exp(-2*x)) / sqrt(2*pi*x)\nif (x > -log(epsilon(1._dp))/2) then\n    ! (1-exp(-2*x)) = 1 in floating point precission\n    i(0) = 1 / sqrt(2*pi*x)\nelse\n    ! (1-exp(-2*x)) = 2*sinh(x)/exp(x) to avoid cancellation\n    i(0) = sqrt(2/(pi*x)) * sinh(x)/exp(x)\nend if\ndo l = 0, maxk-1\n    ! i_{nu+1} = i_{nu-1} - 2*nu*i_nu/x\n    i(l + 1) = i(l-1) - (2*l + 1)*i(l)/x\nend do\nend subroutine\n"}
{"id": 962, "subroutine": " subroutine x(nphi)\n   integer            :: nphi\n   integer, parameter :: maxphi=100\n   double precision   :: rmax(maxphi)\n   double precision  rmod\n   logical :: within(maxphi)\n\n   within(1:nphi) = rmod .lt. rmax(1:nphi)   !! legal\n end subroutine x\n"}
{"id": 963, "subroutine": "      subroutine dt_mashel(pa1,pa2,xm1,xm2,p1,p2,irej)\n \nc***********************************************************************\nc                                                                      *\nc    rescaling of momenta of two partons to put both                   *\nc                                       on mass shell                  *\nc                                                                      *\nc    input:       pa1,pa2   input momentum vectors                     *\nc                 xm1,2     desired masses of particles afterwards     *\nc                 p1,p2     changed momentum vectors                   *\nc                                                                      *\nc the original version is written by r. engel.                         *\nc this version dated 12.12.94 is modified by s. roesler.               *\nc***********************************************************************\n \n      implicit none\n      double precision anorf , bgx , bgy , bgz , cod , cof , del , \n     &                 dt_ylamb , ee , ee1 , ee2 , gam , one , p1 , p2 , \n     &                 pa1 , pa2 , pcmp , ppt , ptot1\n      double precision ptot2 , px , py , pz , sid , sif , ss , tiny10 , \n     &                 xm1 , xm12 , xm2 , xm22 , xms , xptot , xx , yy , \n     &                 zero , zz\n      integer idev , irej , k , mode\n      save \n \n      include 'inc/dtflka'\n \n      parameter (tiny10=1.0d-10,one=1.0d0,zero=0.0d0)\n \n      dimension pa1(4) , pa2(4) , p1(4) , p2(4)\n \n      irej = 0\n \nc lorentz transformation into system cms\n      px = pa1(1) + pa2(1)\n      py = pa1(2) + pa2(2)\n      pz = pa1(3) + pa2(3)\n      ee = pa1(4) + pa2(4)\n      xptot = sqrt(px**2+py**2+pz**2)\n      xms = (ee-xptot)*(ee+xptot)\nc        write(lout,'(3e12.4)')xms,xm1,xm2\n      if ( xms.lt.(xm1+xm2)**2 ) then\n \n         irej = 1\n         goto 99999\n      end if\n      xms = sqrt(xms)\n      bgx = px/xms\n      bgy = py/xms\n      bgz = pz/xms\n      gam = ee/xms\n      call dt_daltra(gam,-bgx,-bgy,-bgz,pa1(1),pa1(2),pa1(3),pa1(4),\n     &               ptot1,p1(1),p1(2),p1(3),p1(4))\nc rotation angles\n      cod = p1(3)/ptot1\nc     sid = sqrt((one-cod)*(one+cod))\n      ppt = sqrt(p1(1)**2+p1(2)**2)\n      sid = ppt/ptot1\n      cof = one\n      sif = zero\n      if ( ptot1*sid.gt.tiny10 ) then\n         cof = p1(1)/(sid*ptot1)\n         sif = p1(2)/(sid*ptot1)\n         anorf = sqrt(cof*cof+sif*sif)\n         cof = cof/anorf\n         sif = sif/anorf\n      end if\nc new cm momentum and energies (for masses xm1,xm2)\n      xm12 = sign(xm1**2,xm1)\n      xm22 = sign(xm2**2,xm2)\n      ss = xms**2\n      pcmp = dt_ylamb(ss,xm12,xm22)/(2.d0*xms)\n      ee1 = sqrt(xm12+pcmp**2)\n      ee2 = xms - ee1\nc back rotation\n      mode = 1\n      call dt_mytran(mode,zero,zero,pcmp,cod,sid,cof,sif,xx,yy,zz)\n      call dt_daltra(gam,bgx,bgy,bgz,xx,yy,zz,ee1,ptot1,p1(1),p1(2),\n     &               p1(3),p1(4))\n      call dt_daltra(gam,bgx,bgy,bgz,-xx,-yy,-zz,ee2,ptot2,p2(1),p2(2),\n     &               p2(3),p2(4))\nc check consistency\n      del = xms*0.0001d0\n      if ( abs(px-p1(1)-p2(1)).gt.del ) then\n         idev = 1\n      else if ( abs(py-p1(2)-p2(2)).gt.del ) then\n         idev = 2\n      else if ( abs(pz-p1(3)-p2(3)).gt.del ) then\n         idev = 3\n      else if ( abs(ee-p1(4)-p2(4)).gt.del ) then\n         idev = 4\n      else\n         idev = 0\n      end if\n      if ( idev.ne.0 ) then\n \n         if ( lpri.gt.4 ) write (lout,'(/1x,a,i3)')\n     &         'mashel: inconsistent transformation' , idev\n \n         if ( lpri.gt.4 ) write (lout,'(1x,a)')\n     &         'mashel: input momenta/masses:'\n \n         if ( lpri.gt.4 ) write (lout,'(1x,5e12.5)') (pa1(k),k=1,4) , \n     &        xm1\n \n         if ( lpri.gt.4 ) write (lout,'(1x,5e12.5)') (pa2(k),k=1,4) , \n     &        xm2\n \n         if ( lpri.gt.4 ) write (lout,'(1x,a)')\n     &         'mashel: output momenta:'\n \n         if ( lpri.gt.4 ) write (lout,'(5x,4e12.5)') (p1(k),k=1,4)\n \n         if ( lpri.gt.4 ) write (lout,'(5x,4e12.5)') (p2(k),k=1,4)\n      end if\n99999 end subroutine\n"}
{"id": 964, "subroutine": "      subroutine gensingle(sh,school,nparam,\n     $     curpars,ndata, tps, rtn, ndays, epi_model) \n\n      implicit none\n\n      integer iday_per_week\n      parameter(iday_per_week=7)\n      integer nstep\n      parameter (nstep = 6)\n      integer ndata, nparam, ndays\n      integer epi_model\n      real*8 sh(ndata), school(ndata)\n      real*8 curpars(nparam)\n      real*8 pc, e_bckgrnd\n      real*8 tps(ndata)\n      real*8 rtn(ndata)\n      real*8 dsdt((ndays)*nstep)\n      integer imid((ndata+1))\n\n\n!\n! need to find the mid-point\n! this will need to be further cleaned - the cdc data is absolute day numbers..\n!\n\n      if (tps(1) > (iday_per_week * 10)) then\n         call buildimidforcdc(ndata, nstep, tps, imid)\n      else\n         call buildimid(ndata, nstep, tps, imid)\n      endif\n\n      pc = curpars(5)\n      e_bckgrnd = curpars(8)\n\n      rtn = 0.0d0\n      dsdt = 0.0d0\n\n\n      select case (epi_model) \n         case (1) \n            call rk4sironed(sh,school,ndata,ndays,nstep,tps,\n     $           nparam,curpars,dsdt)\n         case (2) \n            call rk4seironed(sh,school,ndata,ndays,nstep,tps,\n     $           nparam,curpars,dsdt)\n        case (3) \n           call rk4vecsironed(ndata,ndays,nstep,tps,\n     $          nparam,curpars,dsdt)\n        case (4) \n           call rk4vecseironed(ndata,ndays,nstep,tps,\n     $          nparam,curpars,dsdt)              \n        case default \n           call rk4sironed(sh,school,ndata,ndays,nstep,tps,\n     $            nparam,curpars,dsdt)\n      end select \n\n\n      call weekly1d(ndata, ndays, nstep, imid, dsdt, pc,e_bckgrnd, \n     $     rtn)\n\n\n      \n      return\n      end subroutine gensingle\n"}
{"id": 965, "subroutine": "  subroutine rootzone_v50_new(rootzone,isforinquiry,cfilename,cworkingdirectory,appgrid,timestep,ntime,et,precip,istat,istrmnodeids,ilakeids)\n    class(rootzone_v50_type)           :: rootzone\n    logical,intent(in)                 :: isforinquiry\n    character(len=*),intent(in)        :: cfilename,cworkingdirectory\n    type(appgridtype),intent(in)       :: appgrid\n    type(timesteptype),intent(in)      :: timestep\n    integer,intent(in)                 :: ntime\n    type(ettype),intent(in)            :: et\n    type(precipitationtype),intent(in) :: precip\n    integer,intent(out)                :: istat\n    integer,optional,intent(in)        :: istrmnodeids(:),ilakeids(:)\n    \n    !local variables\n    character(len=modnamelen+16)                :: thisprocedure = modname // 'rootzone_v50_new'\n    character(len=1000)                         :: aline,agdatafile,urbandatafile,nvrvfile,genericmoisturefile\n    character                                   :: cversionlocal*20\n    real(8)                                     :: factk,factcn,regionarea(appgrid%nsubregions+1),dummyfactor(1)\n    real(8),allocatable                         :: dummyrealarray(:,:)\n    integer                                     :: nelements,nregion,errorcode,indxelem,nsoils,indxregion,indxsoil,isoiltype,iregion, &\n                                                   surfaceflowdest(appgrid%nelements),surfaceflowdesttype(appgrid%nelements),ielemid, &\n                                                   isubregionids(appgrid%nsubregions),ielemids(appgrid%nelements),ielem,iregionid,    &\n                                                   ifeatureindex\n    integer,allocatable                         :: icolgenericmoisture(:,:)\n    type(genericfiletype)                       :: rootzoneparamfile\n    logical                                     :: tracktime,lelemflowtosubregions,lprocessed(appgrid%nsubregions),                   &\n                                                   lprocessed_elem(appgrid%nelements)\n    character(len=f_imaxlocationnamelen)        :: regionnames(appgrid%nsubregions+1)\n    type(elemsurfaceflowtodesttype),allocatable :: elemflowtooutside(:),elemflowtogw(:)\n    character(:),allocatable                    :: cabspathfilename\n    \n    !initialize\n    istat = 0\n    \n    !return if no filename is given\n    if (cfilename .eq. '') return\n    \n    !print progress\n    call echoprogress('instantiating root zone')\n    \n    !initialize\n    rootzone%version       = rootzone%version%new(ilenversion,cversion,crevision)\n    cversionlocal          = adjustl('v' // trim(rootzone%version%getversion()))\n    nelements              = appgrid%nelements\n    nregion                = appgrid%nsubregions\n    isubregionids          = appgrid%appsubregion%id\n    ielemids               = appgrid%appelement%id\n    tracktime              = timestep%tracktime\n    regionarea(1:nregion)  = appgrid%getsubregionarea()\n    regionarea(nregion+1)  = sum(regionarea(1:nregion))\n    regionnames            = ''  ;  regionnames(1:nregion) = appgrid%getsubregionnames()\n    regionnames(nregion+1) = 'entire model area'\n    \n    !open file\n    call rootzoneparamfile%new(filename=cfilename,inputfile=.true.,istsfile=.false.,istat=istat)  \n    if (istat .eq. -1) return\n    \n    !read away the first version number line to avoid any errors\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return\n\n    !read solution scheme controls\n    call rootzoneparamfile%readdata(rootzone%solverdata%tolerance,istat)  ;  if (istat .eq. -1) return\n    call rootzoneparamfile%readdata(rootzone%solverdata%itermax,istat)  ;  if (istat .eq. -1) return\n    call rootzoneparamfile%readdata(nsoils,istat)  ;  if (istat .eq. -1) return  ;  rootzone%nsoils = nsoils\n    call rootzoneparamfile%readdata(factcn,istat)  ;  if (istat .eq. -1) return\n\n    !allocate memory\n    allocate (rootzone%subregionsoilsdata(nsoils,nregion)  , &\n              rootzone%soilregionprecip(nsoils,nregion)    , &\n              rootzone%soilregionarea(nsoils,nregion)      , &\n              rootzone%watersupply(nregion)                , &\n              rootzone%rsoilm_p(nregion+1,f_ingrouplanduse), &\n              rootzone%rsoilm(nregion+1,f_ingrouplanduse)  , &\n              rootzone%elemsoiltype(nelements)             , &\n              rootzone%elemprecipdata(nelements)           , &\n              rootzone%flags%llakeelems(nelements)         , &\n              stat=errorcode                               )\n    if (errorcode .ne. 0) then\n        call setlastmessage('error in allocating memory for root zone soils data!',ifatal,thisprocedure)\n        istat = -1\n        return\n    end if\n\n    !initialize lake element flag\n    rootzone%flags%llakeelems = .false.\n    \n    !initialize related files\n    !-------------------------\n    \n    !agricultural data file\n    call rootzoneparamfile%readdata(agdatafile,istat)  ;  if (istat .eq. -1) return \n    agdatafile = striptextuntilcharacter(agdatafile,'/') \n    call cleanspecialcharacters(agdatafile)\n    call establishabsolutepathfilename(trim(adjustl(agdatafile)),cworkingdirectory,cabspathfilename)\n    call rootzone%agrootzone%new(isforinquiry,cabspathfilename,cworkingdirectory,appgrid,factcn,nsoils,isubregionids,timestep,istat)\n    if (istat .eq. -1) return\n       \n    !urban data file\n    call rootzoneparamfile%readdata(urbandatafile,istat)  ;  if (istat .eq. -1) return  \n    urbandatafile = striptextuntilcharacter(urbandatafile,'/') \n    call cleanspecialcharacters(urbandatafile)\n    call establishabsolutepathfilename(trim(adjustl(urbandatafile)),cworkingdirectory,cabspathfilename)\n    if (present(istrmnodeids)) then\n        if (present(ilakeids)) then\n            call rootzone%urbanrootzone%new(cabspathfilename,cworkingdirectory,appgrid,factcn,nsoils,ielemids,isubregionids,tracktime,istat,istrmnodeids=istrmnodeids,ilakeids=ilakeids)\n        else\n            call rootzone%urbanrootzone%new(cabspathfilename,cworkingdirectory,appgrid,factcn,nsoils,ielemids,isubregionids,tracktime,istat,istrmnodeids=istrmnodeids)\n        end if\n    else\n        if (present(ilakeids)) then\n            call rootzone%urbanrootzone%new(cabspathfilename,cworkingdirectory,appgrid,factcn,nsoils,ielemids,isubregionids,tracktime,istat,ilakeids=ilakeids)\n        else\n            call rootzone%urbanrootzone%new(cabspathfilename,cworkingdirectory,appgrid,factcn,nsoils,ielemids,isubregionids,tracktime,istat)\n        end if    \n    end if\n    if (istat .eq. -1) return\n    \n    !native/riparian veg. data file\n    call rootzoneparamfile%readdata(nvrvfile,istat)  ;  if (istat .eq. -1) return  \n    nvrvfile = striptextuntilcharacter(nvrvfile,'/') \n    call cleanspecialcharacters(nvrvfile)\n    call establishabsolutepathfilename(trim(adjustl(nvrvfile)),cworkingdirectory,cabspathfilename)\n    call rootzone%nvrvrootzone%new(cabspathfilename,cworkingdirectory,factcn,nsoils,nelements,nregion,isubregionids,tracktime,istat)\n    if (istat .eq. -1) return\n    \n    !check if at least one type of land use is specified\n    if ( agdatafile        .eq. ''   .and.   &\n         urbandatafile     .eq. ''   .and.   &\n         nvrvfile          .eq. ''           )  then\n      messagearray(1) = 'at least one type of land use and related data should '\n      messagearray(2) = 'be specified for the simulation of root zone processes!' \n      call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n      istat = -1\n      return\n    end if\n    \n    !define the component simulation flags\n    associate (pflags => rootzone%flags)\n      if (agdatafile .ne. '')      pflags%lag_defined    = .true.\n      if (urbandatafile .ne. '')   pflags%lurban_defined = .true.\n      if (nvrvfile .ne. '')        pflags%lnvrv_defined  = .true.\n    end associate\n    \n    !return flow data file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return  \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .eq. '') then\n        if (rootzone%flags%lag_defined  .or.  rootzone%flags%lurban_defined) then\n            call setlastmessage('missing return flow fractions data file!',ifatal,thisprocedure)\n            istat = -1\n            return\n        end if\n    else\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call rootzone%returnfracfile%init(cabspathfilename,cworkingdirectory,'return flow fractions data file',tracktime,1,.false.,dummyfactor,istat=istat)  \n        if (istat .eq. -1) return\n    end if\n        \n    !re-use data file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return  \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .eq. '') then\n        if (rootzone%flags%lag_defined  .or.  rootzone%flags%lurban_defined) then\n            call setlastmessage('missing irrigation water re-use factors data file!',ifatal,thisprocedure)\n            istat = -1\n            return\n        end if\n    else\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call rootzone%reusefracfile%init(cabspathfilename,cworkingdirectory,'irrigation water re-use factors file',tracktime,1,.false.,dummyfactor,istat=istat)  \n        if (istat .eq. -1) return\n    end if\n    \n    !generic moisture data file\n    call rootzoneparamfile%readdata(genericmoisturefile,istat)  ;  if (istat .eq. -1) return  \n    genericmoisturefile = striptextuntilcharacter(genericmoisturefile,'/') \n    call cleanspecialcharacters(genericmoisturefile)\n    if (genericmoisturefile .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(genericmoisturefile)),cworkingdirectory,cabspathfilename)\n        genericmoisturefile = cabspathfilename\n        rootzone%flags%lgenericmoisturefile_defined = .true.\n    end if\n    \n    !land and water use budget hdf5 output file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call lwusebudrawfile_new(isforinquiry,cabspathfilename,timestep,ntime,nregion+1,regionarea,regionnames,'land and water use budget',cversionlocal,rootzone%lwusebudrawfile,istat)\n        if (istat .eq. -1) return\n        rootzone%flags%lwusebudrawfile_defined = .true.      \n    end if\n\n    !root zone budget hdf5 output file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return  \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call rootzonebudrawfile_new(isforinquiry,cabspathfilename,timestep,ntime,nregion+1,regionarea,regionnames,'root zone budget',cversionlocal,rootzone%rootzonebudrawfile,istat)\n        if (istat .eq. -1) return\n        rootzone%flags%rootzonebudrawfile_defined = .true.\n    end if\n       \n    !are there any flows between elements?\n    if (size(rootzone%elemflowtosubregions) .eq. 0) then\n        lelemflowtosubregions = .false.\n    else\n        lelemflowtosubregions = .true.\n    end if\n    \n    !land and water use zone budget hdf5 output file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call lwusezonebudrawfile_new(isforinquiry,cabspathfilename,timestep,ntime,cversionlocal,lelemflowtosubregions,rootzone%flags,appgrid,rootzone%lwuzonebudrawfile,istat)\n        if (istat .eq. -1) return\n        rootzone%flags%lwusezonebudrawfile_defined = .true.      \n    end if\n\n    !root zone zone budget hdf5 output file\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return  \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        call rootzonezonebudrawfile_new(isforinquiry,cabspathfilename,timestep,ntime,cversionlocal,lelemflowtosubregions,rootzone%flags,appgrid,rootzone%rootzonezonebudrawfile,istat)\n        if (istat .eq. -1) return\n        rootzone%flags%rootzonezonebudrawfile_defined = .true.\n    end if\n       \n    !end-of-simulation moisture results output\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return  \n    aline = striptextuntilcharacter(aline,'/') \n    call cleanspecialcharacters(aline)\n    if (aline .ne. '') then\n        call establishabsolutepathfilename(trim(adjustl(aline)),cworkingdirectory,cabspathfilename)\n        if (isforinquiry) then\n            call rootzone%finalmoistureoutfile%new(filename=cabspathfilename,inputfile=.true.,istsfile=.false.,istat=istat)  \n        else\n            call rootzone%finalmoistureoutfile%new(filename=cabspathfilename,inputfile=.false.,istsfile=.false.,istat=istat)  \n        end if\n        if (istat .eq. -1) return\n        rootzone%flags%finalmoistureoutfile_defined = .true.\n    end if\n \n    !read soil parameters\n    call rootzoneparamfile%readdata(factk,istat)  ;  if (istat .eq. -1) return\n    call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return\n    call cleanspecialcharacters(aline)\n    rootzone%vartimeunit = adjustl(striptextuntilcharacter(aline,'/'))\n    associate (psoilsdata => rootzone%subregionsoilsdata)\n        allocate (dummyrealarray(nsoils,7) , icolgenericmoisture(nsoils,nregion))\n        lprocessed = .false.\n        do indxregion=1,nregion\n            call rootzoneparamfile%readdata(aline,istat)  ;  if (istat .eq. -1) return\n            read (aline,*) iregionid,dummyrealarray(1,:)\n            call rootzoneparamfile%readdata(dummyrealarray(2:,:),istat)  ;  if (istat .eq. -1) return\n            \n            !region id to region index\n            call convertid_to_index(iregionid,isubregionids,iregion)\n            if (iregion .eq. 0) then\n                call setlastmessage('subregion '//trim(inttotext(iregionid))//' listed for soil parameter definition is not in the model!',ifatal,thisprocedure)\n                istat = -1\n                return\n            end if\n            \n            !make sure same subregion is not entered more than once\n            if (lprocessed(iregion)) then\n                call setlastmessage('subregion '//trim(inttotext(iregionid))//' is listed more than once for soil parameter definitions!',ifatal,thisprocedure)\n                istat = -1\n                return\n            end if\n            lprocessed(iregion) = .true.\n            \n            !store parameters in persistent arrays\n            psoilsdata(:,iregion)%wiltingpoint  =     dummyrealarray(:,1)     \n            psoilsdata(:,iregion)%fieldcapacity =     dummyrealarray(:,2)\n            psoilsdata(:,iregion)%totalporosity =     dummyrealarray(:,3)\n            psoilsdata(:,iregion)%lambda        =     dummyrealarray(:,4)\n            psoilsdata(:,iregion)%hydcond       =     dummyrealarray(:,5) * factk * timestep%deltat\n            psoilsdata(:,iregion)%kunsatmethod  = int(dummyrealarray(:,6))\n            icolgenericmoisture(:,iregion)      = int(dummyrealarray(:,7))\n            \n            !check for errors\n            do indxsoil=1,nsoils\n                !method to compute kunsat must be recognized\n                if (locateinlist(psoilsdata(indxsoil,iregion)%kunsatmethod,f_ikunsatmethodlist) .lt. 1) then\n                    call setlastmessage('method to compute unsaturated hydraulic conductivity for soil type ' // trim(inttotext(indxsoil)) //' at subregion ' // trim(inttotext(iregionid)) // ' is not recognized!',ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n        \n                !wilting point should be less than field capacity\n                if (psoilsdata(indxsoil,iregion)%wiltingpoint .ge. psoilsdata(indxsoil,iregion)%fieldcapacity) then\n                    call setlastmessage('for soil type ' // trim(inttotext(indxsoil)) // ' at subregion ' // trim(inttotext(iregionid)) // ' wilting point is greater than or equal to field capacity!',ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n        \n                !field capacity should be less than or equal to total porosity\n                if (psoilsdata(indxsoil,iregion)%fieldcapacity .gt. psoilsdata(indxsoil,iregion)%totalporosity) then\n                    call setlastmessage('for soil type ' // trim(inttotext(indxsoil)) // ' at subregion ' // trim(inttotext(iregionid)) // ' field capacity is greater than total porosity!',ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n            end do\n        end do\n    end associate\n    \n    !instantiate generic moisture data\n    call rootzone%genericmoisturedata%new(genericmoisturefile,cworkingdirectory,nsoils,nregion,icolgenericmoisture,tracktime,istat)\n    if (istat .eq. -1) return\n\n    !read soil type, precipitation and runoff destination information\n    deallocate (dummyrealarray)\n    allocate (dummyrealarray(nelements,6))\n    call rootzoneparamfile%readdata(dummyrealarray,istat)  ;  if (istat .eq. -1) return\n    associate (pprecipdata     => rootzone%elemprecipdata  , &\n               psoiltype       => rootzone%elemsoiltype    , &\n               psoilregionarea => rootzone%soilregionarea  )\n        psoilregionarea = 0.0\n        lprocessed_elem = .false.\n        do indxelem=1,nelements\n            ielemid = int(dummyrealarray(indxelem,1))\n\n            !check if element is in the model\n            call convertid_to_index(ielemid,ielemids,ielem)\n            if (ielem .eq. 0) then\n                call setlastmessage('element '//trim(inttotext(ielemid))//' listed for soil type, precipitation, etc. is not in the model!',ifatal,thisprocedure)\n                istat = -1\n                return\n            end if\n            \n            !check if it was defined before\n            if (lprocessed_elem(ielem)) then\n                call setlastmessage('element '//trim(inttotext(ielemid))//' is listed more than once for soil type, precipitation, etc. definitions!',ifatal,thisprocedure)\n                istat = -1\n                return\n            end if\n            \n            !process data\n            lprocessed_elem(ielem)          = .true.\n            psoiltype(ielem)                = int(dummyrealarray(indxelem,2))\n            pprecipdata(ielem)%icolprecip   = int(dummyrealarray(indxelem,3))\n            pprecipdata(ielem)%precipfactor =     dummyrealarray(indxelem,4)\n            surfaceflowdesttype(ielem)      = int(dummyrealarray(indxelem,5))\n            surfaceflowdest(ielem)          = int(dummyrealarray(indxelem,6))\n            \n            !check for errors and calculate areas for each (soil,region) combination\n            isoiltype = psoiltype(ielem)\n            associate (pdesttype => surfaceflowdesttype(ielem))\n                !make sure soil type is modeled\n                if (isoiltype.lt.1  .or.  isoiltype.gt.nsoils) then\n                    call setlastmessage('soil type at element ' // trim(inttotext(ielemid)) // ' is not recognized!',ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n                \n                !make sure that destination types are recognized\n                if (pdesttype .ne. f_iflowdest_outside    .and.   &\n                    pdesttype .ne. f_iflowdest_strmnode   .and.   &\n                    pdesttype .ne. f_iflowdest_lake       .and.   &\n                    pdesttype .ne. f_iflowdest_gwelement       )  then\n                    call setlastmessage('surface flow destination type for element ' // trim(inttotext(ielemid)) // ' is not recognized!',ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n          \n                !make sure destination locations are modeled and acceptable\n                select case (pdesttype)\n                    case (f_iflowdest_strmnode)\n                        if (present(istrmnodeids)) then\n                            call convertid_to_index(surfaceflowdest(ielem),istrmnodeids,ifeatureindex)\n                            if (ifeatureindex .eq. 0) then\n                                call setlastmessage('surface flow from element '//trim(inttotext(ielemid))//' flows into a stream node ('//trim(inttotext(surfaceflowdest(ielem)))//') that is not in the model!',ifatal,thisprocedure)\n                                istat = -1\n                                return\n                            end if\n                            surfaceflowdest(ielem) = ifeatureindex\n                        end if \n              \n                    case (f_iflowdest_lake)\n                        if (present(ilakeids)) then\n                            call convertid_to_index(surfaceflowdest(ielem),ilakeids,ifeatureindex)\n                            if (ifeatureindex .eq. 0) then\n                                call setlastmessage('surface flow from element '//trim(inttotext(ielemid))//' flows into a lake ('//trim(inttotext(surfaceflowdest(ielem)))//') that is not in the model!',ifatal,thisprocedure)\n                                istat = -1\n                                return\n                            end if\n                            surfaceflowdest(ielem) = ifeatureindex\n                        end if\n                  \n                    case (f_iflowdest_subregion)\n                        call convertid_to_index(surfaceflowdest(ielem),isubregionids,ifeatureindex)\n                        if (ifeatureindex .eq. 0) then\n                            call setlastmessage('surface flow from element '//trim(inttotext(ielemid))//' goes to a subregion ('//trim(inttotext(surfaceflowdest(ielem)))//') that is not in the model!',ifatal,thisprocedure)\n                            istat = -1\n                            return\n                        end if\n                        surfaceflowdest(ielem) = ifeatureindex\n                        if (surfaceflowdest(ielem) .eq. appgrid%appelement(ielem)%subregion) then\n                            call setlastmessage('surface flow from element '//trim(inttotext(ielemid))//' cannot go to the same subregion which the element belongs to!',ifatal,thisprocedure)\n                            istat = -1\n                            return\n                        end if\n                        \n                    case (f_iflowdest_gwelement)\n                        surfaceflowdest(ielem) = ielem\n                        \n                    case (f_iflowdest_outside)\n                        surfaceflowdest(ielem) = 0                        \n                end select              \n            end associate\n            \n            !if made to this point, add element area to its corresponding (soil,region) area\n            iregion                            = appgrid%appelement(ielem)%subregion\n            psoilregionarea(isoiltype,iregion) = psoilregionarea(isoiltype,iregion) + appgrid%appelement(ielem)%area\n        end do\n        \n        !compile element-flow-to-outside connection list\n        call compileelemsurfaceflowtodestinationlist(f_iflowdest_outside,surfaceflowdest,surfaceflowdesttype,elemflowtooutside,istat)  ;  if (istat .eq. -1) return\n        allocate (rootzone%elemflowtooutside(size(elemflowtooutside)))\n        rootzone%elemflowtooutside = elemflowtooutside%ielement\n        \n        !compile element-flow-to-stream-node connection list\n        call compileelemsurfaceflowtodestinationlist(f_iflowdest_strmnode,surfaceflowdest,surfaceflowdesttype,rootzone%elemflowtostreams,istat)  ;  if (istat .eq. -1) return\n      \n        !compile element-flow-to-lake connection list\n        call compileelemsurfaceflowtodestinationlist(f_iflowdest_lake,surfaceflowdest,surfaceflowdesttype,rootzone%elemflowtolakes,istat)  ;  if (istat .eq. -1) return\n      \n        !compile element-flow-to-subregion connection list\n        call compileelemsurfaceflowtodestinationlist(f_iflowdest_subregion,surfaceflowdest,surfaceflowdesttype,rootzone%elemflowtosubregions,istat)  ;  if (istat .eq. -1) return\n\n        !compile element-flow-to-groundwater connection list\n        call compileelemsurfaceflowtodestinationlist(f_iflowdest_gwelement,surfaceflowdest,surfaceflowdesttype,elemflowtogw,istat)  ;  if (istat .eq. -1) return\n        allocate (rootzone%elemflowtogw(size(elemflowtogw)))\n        rootzone%elemflowtogw = elemflowtogw%ielement\n        \n    end associate\n    \n    !check if data column pointers are referring to existing data columns\n    call checktsdatapointers(rootzone,ielemids,isubregionids,precip,et,istat)\n    if (istat .eq. -1) return\n\n    !close file\n    call rootzoneparamfile%kill()\n\n    !clear memory\n    deallocate (dummyrealarray , icolgenericmoisture , elemflowtooutside , elemflowtogw , cabspathfilename , stat=errorcode)\n    \n  end subroutine rootzone_v50_new\n"}
{"id": 966, "subroutine": "  subroutine lwusezonebudrawfile_new(isforinquiry,cfilename,timestep,ntime,cversion,lelemflowtosubregions,flags,appgrid,zbudfile,istat)\n    logical,intent(in)              :: isforinquiry\n    character(len=*),intent(in)     :: cfilename\n    type(timesteptype),intent(in)   :: timestep\n    integer,intent(in)              :: ntime\n    character(len=*),intent(in)     :: cversion\n    logical,intent(in)              :: lelemflowtosubregions\n    type(flags_v50_type),intent(in) :: flags\n    type(appgridtype),intent(in)    :: appgrid\n    type(zbudgettype)               :: zbudfile\n    integer,intent(out)             :: istat\n    \n    !local variables\n    character(len=modnamelen+23),parameter :: thisprocedure = modname // 'lwusezonebudrawfile_new'\n    character(len=13),parameter            :: carea = f_czbud_markerchar // '        (' // f_czbud_areaunitmarker // ')' // f_czbud_markerchar\n    integer                                :: indxelem,indxvertex,errorcode,indxface\n    type(timesteptype)                     :: timesteplocal\n    type(zbudgetheadertype)                :: header\n    type(systemdatatype)                   :: systemdata\n    \n    !initialize\n    istat = 0\n    \n    !if this is for inquiry, open file for reading and return\n    if (isforinquiry) then\n        if (cfilename .ne. '') call zbudfile%new(cfilename,istat)\n        return\n    end if\n    \n    !time step received shows the timestamp at t=0; advance time to show that z-budget output is at t = 1\n    timesteplocal                    = timestep\n    timesteplocal%currentdateandtime = incrementtimestamp(timesteplocal%currentdateandtime,timesteplocal%deltat_inminutes,1)\n    timesteplocal%currenttimestep    = 1\n    \n    !compile system data\n    systemdata%nnodes    = appgrid%nnodes\n    systemdata%nelements = appgrid%nelements\n    systemdata%nlayers   = 1\n    systemdata%nfaces    = appgrid%nfaces\n    allocate (systemdata%ielementids(appgrid%nelements)                   , &\n              systemdata%ielementnnodes(appgrid%nelements)                , &\n              systemdata%ielementnodes(4,appgrid%nelements)               , &\n              systemdata%ifaceelems(2,appgrid%nfaces)                     , &\n              systemdata%lboundaryface(appgrid%nfaces)                    , &\n              systemdata%lactivenode(appgrid%nnodes,1)                    , &\n              systemdata%rnodeareas(appgrid%nnodes)                       , &\n              systemdata%relementareas(appgrid%nelements)                 , &\n              systemdata%relementnodeareas(4,appgrid%nelements)           , &\n              systemdata%relementnodeareafractions(4,appgrid%nelements)   )\n    systemdata%rnodeareas     = appgrid%appnode%area\n    systemdata%relementareas  = appgrid%appelement%area\n    systemdata%ielementnnodes = appgrid%nvertex\n    do indxelem=1,appgrid%nelements\n        systemdata%ielementids(indxelem)     = appgrid%appelement(indxelem)%id\n        systemdata%ielementnodes(:,indxelem) = appgrid%vertex(:,indxelem)\n        do indxvertex=1,appgrid%nvertex(indxelem)\n            systemdata%relementnodeareas(indxvertex,indxelem)         = appgrid%appelement(indxelem)%vertexarea(indxvertex)\n            systemdata%relementnodeareafractions(indxvertex,indxelem) = appgrid%appelement(indxelem)%vertexareafraction(indxvertex)\n        end do\n        if (appgrid%nvertex(indxelem) .eq. 3) then\n            systemdata%relementnodeareas(4,indxelem)         = 0.0\n            systemdata%relementnodeareafractions(4,indxelem) = 0.0\n        end if\n    end do\n    do indxface=1,appgrid%nfaces\n        systemdata%ifaceelems(:,indxface) = appgrid%appface%element(:,indxface)\n    end do\n    systemdata%lboundaryface = appgrid%appface%boundaryface\n    systemdata%lactivenode   = .true.\n    \n    !compile header data\n    header%csoftwareversion   = 'iwfm root zone package (' // trim(cversion) // ')'\n    header%cdescriptor        = 'land and water use zone budget'\n    header%lfaceflows_defined = .false.\n    header%lstorages_defined  = .false.\n    header%lcomputeerror      = .false.\n    header%indata             = f_inlwusebudcolumns\n    allocate (header%idatatypes(f_inlwusebudcolumns)                           , &\n              header%cfulldatanames(f_inlwusebudcolumns)                       , &\n              header%cdatahdfpaths(f_inlwusebudcolumns)                        , &\n              header%indataelems(f_inlwusebudcolumns,1)                        , &\n              header%ielemdatacolumns(appgrid%nelements,f_inlwusebudcolumns,1) , &\n              !header%ierrorincols()                                           , &  ! since mass balance error is not calcuated no need\n              !header%ierroroutcols()                                          , &  !  to allocate these arrays\n              header%cdssfparts(f_inlwusebudcolumns)                           , &\n              header%asciioutput%ccolumntitles(5)                              , &\n              stat = errorcode                                                 )\n    if (errorcode .ne. 0) then\n        call setlastmessage('error allocating memory for land and water use z-budget file!',ifatal,thisprocedure)\n        istat = -1\n        return\n    end if\n    header%idatatypes = [ar                 ,&  !ag area\n                         vr_lwu_potcuaw     ,&  !potential cuaw\n                         vr_lwu_agsupplyreq ,&  !ag supply req.\n                         vr_lwu_agpump      ,&  !pumping for ag\n                         vr_lwu_agdiv       ,&  !diversion for ag\n                         vr_lwu_agothin     ,&  !ag inflow as surface runoff from upstream elements\n                         vr_lwu_agshort     ,&  !ag supply shortage\n                         vr                 ,&  !etaw\n                         vr                 ,&  !etp\n                         vr                 ,&  !etoth\n                         ar                 ,&  !urban area\n                         vr                 ,&  !urban supply req.\n                         vr                 ,&  !pumping for urban\n                         vr                 ,&  !diversion for urban\n                         vr                 ,&  !urban inflow as surface runoff from upstream elements\n                         vr                 ]   !urban supply shortage\n    header%cfulldatanames    = f_clwusebudgetcolumntitles\n    header%cfulldatanames(1)  = trim(header%cfulldatanames(1)) // carea\n    header%cfulldatanames(11) = trim(header%cfulldatanames(11)) // carea\n    header%cdatahdfpaths      = f_clwusebudgetcolumntitles\n    header%indataelems        = 0\n    header%ielemdatacolumns   = 0\n    if (flags%lag_defined) then\n        header%indataelems(1:5,:)  = appgrid%nelements\n        header%indataelems(7:10,:) = appgrid%nelements\n        if (lelemflowtosubregions) header%indataelems(6,:) = appgrid%nelements     !not all applications will have surface inflow for ag and urban water use; update accordingly\n        do indxelem=1,appgrid%nelements\n            header%ielemdatacolumns(indxelem,1:5,:)  = indxelem\n            header%ielemdatacolumns(indxelem,7:10,:) = indxelem\n            if (lelemflowtosubregions) header%ielemdatacolumns(indxelem,6,:) = indxelem\n        end do\n    end if\n    if (flags%lurban_defined) then\n        header%indataelems(11:14,:) = appgrid%nelements\n        header%indataelems(16,:)    = appgrid%nelements\n        if (lelemflowtosubregions) header%indataelems(15,:) = appgrid%nelements     !not all applications will have surface inflow for ag and urban water use; update accordingly\n        do indxelem=1,appgrid%nelements\n            header%ielemdatacolumns(indxelem,11:14,:)  = indxelem\n            header%ielemdatacolumns(indxelem,16,:)     = indxelem\n            if (lelemflowtosubregions) header%ielemdatacolumns(indxelem,15,:) = indxelem\n        end do\n    end if\n    header%asciioutput%intitles         = 5\n    header%asciioutput%ilencolumntitles = 228\n    header%asciioutput%ccolumntitles(1) = '                                                                         agricultural area                                                                                              urban area                                   '\n    header%asciioutput%ccolumntitles(2) = '                 ----------------------------------------------------------------------------------------------------------------------------------   ------------------------------------------------------------------------------ '\n    header%asciioutput%ccolumntitles(3) = '                                            agricultural                            inflow as                                               et                          urban                               inflow as                '\n    header%asciioutput%ccolumntitles(4) = '      time               area    potential     supply         pumping  deliveries  srfc. runoff     shortage                effective   from other            area      supply        pumping  deliveries  srfc. runoff     shortage '\n    header%asciioutput%ccolumntitles(5) = '                 '//carea//'     cuaw      requirement        (-)        (-)          (-)            (=)          etaw      precip      sources     '//carea//'   requirement       (-)        (-)          (-)            (=)    '\n    header%asciioutput%cnumberformat    = '(a16,10(2x,f11.1),3x,6(2x,f11.1))'\n    header%cdssfparts = ['ag_area'         ,&\n                         'ag_potnl_cuaw'   ,&\n                         'ag_sup_req'      ,&    \n                         'ag_pumping'      ,&\n                         'ag_delivery'     ,&\n                         'ag_sr_inflow'    ,&\n                         'ag_shortage'     ,&\n                         'ag_etaw'         ,&\n                         'ag_eff_precip'   ,&\n                         'ag_et_oth'       ,&\n                         'urb_area'        ,&\n                         'urb_sup_req'     ,&       \n                         'urb_pumping'     ,&\n                         'urb_delivery'    ,&\n                         'urb_sr_inflow'   ,&\n                         'urb_shortage'    ]\n                             \n    !instantiate z-budget file\n    call zbudfile%new(cfilename,ntime,timesteplocal,header,systemdata,istat)\n    \n  end subroutine lwusezonebudrawfile_new\n"}
{"id": 967, "subroutine": "  subroutine lwusebudrawfile_new(isforinquiry,cfilename,timestep,ntime,nregion,regionarea,cregionnames,cdescriptor,cversion,rawfile,istat)\n    logical,intent(in)            :: isforinquiry\n    character(len=*),intent(in)   :: cfilename,cregionnames(nregion)\n    type(timesteptype),intent(in) :: timestep\n    integer,intent(in)            :: ntime,nregion\n    real(8),intent(in)            :: regionarea(nregion)\n    character(len=*),intent(in)   :: cdescriptor\n    character(len=*),intent(in)   :: cversion\n    type(budgettype)              :: rawfile\n    integer,intent(out)           :: istat\n    \n    !local variables\n    type(budgetheadertype) :: outputdata\n    type(timesteptype)     :: timesteplocal\n    integer,parameter      :: f_intitles            = 6   , &\n                              f_ititlelen           = 229 , &        \n                              f_incolumnheaderlines = 4   \n    integer                :: indxcol,indxlocation,icount\n    character              :: unitt*10,text*17,text1*13\n    character(len=6)       :: cparts(f_inlwusebudcolumns) = ['area'   , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'area'   , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' , &\n                                                             'volume' ]\n    character(len=13)      :: fparts(f_inlwusebudcolumns) = ['ag_area'         ,&\n                                                             'ag_potnl_cuaw'   ,&\n                                                             'ag_sup_req'      ,&    \n                                                             'ag_pumping'      ,&\n                                                             'ag_delivery'     ,&\n                                                             'ag_sr_inflow'    ,&\n                                                             'ag_shortage'     ,&\n                                                             'ag_etaw'         ,&\n                                                             'ag_eff_precip'   ,&\n                                                             'ag_et_oth'       ,&\n                                                             'urb_area'        ,&\n                                                             'urb_sup_req'     ,&       \n                                                             'urb_pumping'     ,&\n                                                             'urb_delivery'    ,&\n                                                             'urb_sr_inflow'   ,&\n                                                             'urb_shortage'    ]\n    \n    !initialize\n    istat = 0\n\n    !instantiate the land and water use raw file for when it is opened for inquiry\n    if (isforinquiry) then\n        call rawfile%new(cfilename,istat)\n        return\n    end if\n    \n    !budget descriptor\n    outputdata%cbudgetdescriptor = cdescriptor\n    \n    !increment the initial simulation time to represent the data begin date  \n    timesteplocal = timestep\n    if (timestep%tracktime) then\n      timesteplocal%currentdateandtime = incrementtimestamp(timesteplocal%currentdateandtime,timesteplocal%deltat_inminutes)\n      unitt                            = ''\n    else\n      timesteplocal%currenttime        = timesteplocal%currenttime + timesteplocal%deltat\n      unitt                            = '('//trim(timestep%unit)//')'\n    end if\n    \n    !simulation time related data\n    outputdata%ntimesteps = ntime\n    outputdata%timestep   = timesteplocal\n    \n    !areas\n    allocate (outputdata%areas(nregion))\n    outputdata%nareas = nregion\n    outputdata%areas  = regionarea\n    \n    !data for ascii output\n    associate (pasciioutput => outputdata%asciioutput)\n      pasciioutput%titlelen           = f_ititlelen\n      pasciioutput%ntitles            = f_intitles\n      allocate(pasciioutput%ctitles(f_intitles)  ,  pasciioutput%ltitlepersist(f_intitles))\n      pasciioutput%ctitles(1)         = arrangetext('iwfm root zone package ('//trim(cversion)//')' , pasciioutput%titlelen)\n      pasciioutput%ctitles(2)         = arrangetext('land and water use budget in '//f_cvolumeunitmarker//' for '//f_clocationnamemarker , pasciioutput%titlelen)\n      pasciioutput%ctitles(3)         = arrangetext('subregion area: '//f_careamarker//' '//f_careaunitmarker , pasciioutput%titlelen)\n      pasciioutput%ctitles(4)         = repeat('-',pasciioutput%titlelen)\n      pasciioutput%ctitles(5)         = repeat(' ',73)//'agricultural area'//repeat(' ',94)//'urban area'\n      pasciioutput%ctitles(6)         = repeat(' ',17)//repeat('-',130)//repeat(' ',3)//repeat('-',78)\n      pasciioutput%ltitlepersist(1:3) = .true.\n      pasciioutput%ltitlepersist(4:6) = .false.\n      pasciioutput%cformatspec        = adjustl('(a16,1x,10(f12.1,1x),3x,6(f12.1,1x))')\n      pasciioutput%ncolumnheaderlines = f_incolumnheaderlines\n    end associate \n    \n    !location names\n    outputdata%nlocations = nregion\n    allocate (outputdata%clocationnames(nregion))\n    outputdata%clocationnames = cregionnames  \n        \n    !locations\n    allocate (outputdata%locations(1)                                                             , &\n              outputdata%locations(1)%cfullcolumnheaders(f_inlwusebudcolumns+1)                   , &\n              outputdata%locations(1)%idatacolumntypes(f_inlwusebudcolumns)                       , &\n              outputdata%locations(1)%icolwidth(f_inlwusebudcolumns+1)                            , &\n              outputdata%locations(1)%ccolumnheaders(f_inlwusebudcolumns+1,f_incolumnheaderlines) , &\n              outputdata%locations(1)%ccolumnheadersformatspec(f_incolumnheaderlines)             )\n    associate (plocation => outputdata%locations(1))\n      plocation%ndatacolumns           = f_inlwusebudcolumns\n      plocation%cfullcolumnheaders(1)  = 'time'                               \n      plocation%cfullcolumnheaders(2:) = f_clwusebudgetcolumntitles\n      plocation%cfullcolumnheaders(2)  = trim(plocation%cfullcolumnheaders(2))  // ' ('//f_careaunitmarker//')'\n      plocation%cfullcolumnheaders(12) = trim(plocation%cfullcolumnheaders(12)) // ' ('//f_careaunitmarker//')'\n      plocation%idatacolumntypes       = [ar                 ,&  !ag area\n                                          vr_lwu_potcuaw     ,&  !potential cuaw\n                                          vr_lwu_agsupplyreq ,&  !ag supply req.\n                                          vr_lwu_agpump      ,&  !pumping for ag\n                                          vr_lwu_agdiv       ,&  !deliveries for ag\n                                          vr_lwu_agothin     ,&  !ag inflow as surface runoff from upstream elements\n                                          vr_lwu_agshort     ,&  !ag supply shortage\n                                          vr                 ,&  !etaw\n                                          vr                 ,&  !etp\n                                          vr                 ,&  !etoth\n                                          ar                 ,&  !urban area\n                                          vr                 ,&  !urban supply req.\n                                          vr                 ,&  !pumping for urban\n                                          vr                 ,&  !deliveries for urban\n                                          vr                 ,&  !urban inflow as surface runoff from upstream elements\n                                          vr                 ]  !urban supply shortage\n      plocation%icolwidth             = [17,12,14,(13,indxcol=1,7),12,14,(13,indxcol=1,3)]\n      associate (pcolumnheaders => plocation%ccolumnheaders           , &\n                 pformatspecs   => plocation%ccolumnheadersformatspec )\n        text                = arrangetext(trim(unitt),17)\n        text1               = '('//trim(f_careaunitmarker)//')'\n        pcolumnheaders(:,1) = ['                 ','            ','    potential ',' agricultural','             ','             ','  inflow as  ','             ','             ','             ','      et     ','            ','     urban    ','             ','             ','  inflow as  ','             ']\n        pcolumnheaders(:,2) = ['      time       ','        area','      cuaw    ','    supply   ','      pumping',' deliveries  ',' srfc. runoff','     shortage','             ','   effective ','  from other ','        area','     supply   ','      pumping',' deliveries  ',' srfc. runoff','     shortage']\n        pcolumnheaders(:,3) = [               text,         text1,'              ','  requirement','        (-)  ','     (-)     ','     (-)     ','       (=)   ','       etaw  ','    precip   ','   sources   ',         text1,'   requirement','        (-)  ','     (-)     ','     (-)     ','       (=)   ']\n        pcolumnheaders(:,4) = ''\n        pformatspecs(1)     = '(a17,a12,a14,8a13,3x,a12,a14,4a13)'\n        pformatspecs(2)     = '(a17,a12,a14,8a13,3x,a12,a14,4a13)'\n        pformatspecs(3)     = '(a17,a12,a14,8a13,3x,a12,a14,4a13)'\n        pformatspecs(4)     = '(\"'//repeat('-',f_ititlelen)//'\",'//trim(inttotext(f_inlwusebudcolumns+1))//'a0)'\n      end associate\n    end associate\n     \n    !data for dss output  \n    associate (pdssoutput => outputdata%dssoutput)\n      allocate (pdssoutput%cpathnames(f_inlwusebudcolumns*nregion) , pdssoutput%idatatypes(f_inlwusebudcolumns))\n      icount = 1\n      do indxlocation=1,nregion\n        do indxcol=1,f_inlwusebudcolumns\n          pdssoutput%cpathnames(icount) = '/iwfm_l&w_use_bud/'                                           //  &  !a part\n                                          trim(uppercase(outputdata%clocationnames(indxlocation)))//'/'  //  &  !b part\n                                          trim(cparts(indxcol))//'/'                                     //  &  !c part\n                                          '/'                                                            //  &  !d part\n                                           trim(timestep%unit)//'/'                                      //  &  !e part\n                                          trim(fparts(indxcol))//'/'                                            !f part\n          icount = icount+1\n        end do\n      end do\n      pdssoutput%idatatypes = [f_iper_aver,(f_iper_cum,indxcol=1,8),f_iper_aver,(f_iper_cum,indxcol=1,4)]\n    end associate\n                                             \n    !instantiate the land and water use raw file\n    call rawfile%new(cfilename,outputdata,istat)\n    \n  end subroutine lwusebudrawfile_new\n"}
{"id": 968, "subroutine": "  subroutine rootzonezonebudrawfile_new(isforinquiry,cfilename,timestep,ntime,cversion,lelemflowtosubregions,flags,appgrid,zbudfile,istat)\n    logical,intent(in)              :: isforinquiry\n    character(len=*),intent(in)     :: cfilename\n    type(timesteptype),intent(in)   :: timestep\n    integer,intent(in)              :: ntime\n    character(len=*),intent(in)     :: cversion\n    logical,intent(in)              :: lelemflowtosubregions\n    type(flags_v50_type),intent(in) :: flags\n    type(appgridtype),intent(in)    :: appgrid\n    type(zbudgettype)               :: zbudfile\n    integer,intent(out)             :: istat\n    \n    !local variables\n    character(len=modnamelen+26),parameter :: thisprocedure = modname // 'rootzonezonebudrawfile_new'\n    character(len=15),parameter            :: carea = f_czbud_markerchar // '          (' // f_czbud_areaunitmarker // ')' // f_czbud_markerchar\n    integer                                :: indxelem,indxvertex,errorcode,indxface\n    type(timesteptype)                     :: timesteplocal\n    type(zbudgetheadertype)                :: header\n    type(systemdatatype)                   :: systemdata\n    \n    !initialize\n    istat = 0\n    \n    !if this is for inquiry, open file for reading and return\n    if (isforinquiry) then\n        if (cfilename .ne. '') call zbudfile%new(cfilename,istat)\n        return\n    end if\n    \n    !time step received shows the timestamp at t=0; advance time to show that z-budget output is at t = 1\n    timesteplocal                    = timestep\n    timesteplocal%currentdateandtime = incrementtimestamp(timesteplocal%currentdateandtime,timesteplocal%deltat_inminutes,1)\n    timesteplocal%currenttimestep    = 1\n    \n    !compile system data\n    systemdata%nnodes    = appgrid%nnodes\n    systemdata%nelements = appgrid%nelements\n    systemdata%nlayers   = 1\n    systemdata%nfaces    = appgrid%nfaces\n    allocate (systemdata%ielementids(appgrid%nelements)                   , &\n              systemdata%ielementnnodes(appgrid%nelements)                , &\n              systemdata%ielementnodes(4,appgrid%nelements)               , &\n              systemdata%ifaceelems(2,appgrid%nfaces)                     , &\n              systemdata%lboundaryface(appgrid%nfaces)                    , &\n              systemdata%lactivenode(appgrid%nnodes,1)                    , &\n              systemdata%rnodeareas(appgrid%nnodes)                       , &\n              systemdata%relementareas(appgrid%nelements)                 , &\n              systemdata%relementnodeareas(4,appgrid%nelements)           , &\n              systemdata%relementnodeareafractions(4,appgrid%nelements)   )\n    systemdata%rnodeareas     = appgrid%appnode%area\n    systemdata%relementareas  = appgrid%appelement%area\n    systemdata%ielementnnodes = appgrid%nvertex\n    do indxelem=1,appgrid%nelements\n        systemdata%ielementids(indxelem)     = appgrid%appelement(indxelem)%id\n        systemdata%ielementnodes(:,indxelem) = appgrid%vertex(:,indxelem)\n        do indxvertex=1,appgrid%nvertex(indxelem)\n            systemdata%relementnodeareas(indxvertex,indxelem)         = appgrid%appelement(indxelem)%vertexarea(indxvertex)\n            systemdata%relementnodeareafractions(indxvertex,indxelem) = appgrid%appelement(indxelem)%vertexareafraction(indxvertex)\n        end do\n        if (appgrid%nvertex(indxelem) .eq. 3) then\n            systemdata%relementnodeareas(4,indxelem)         = 0.0\n            systemdata%relementnodeareafractions(4,indxelem) = 0.0\n        end if\n    end do\n    do indxface=1,appgrid%nfaces\n        systemdata%ifaceelems(:,indxface) = appgrid%appface%element(:,indxface)\n    end do\n    systemdata%lboundaryface = appgrid%appface%boundaryface\n    systemdata%lactivenode   = .true.\n    \n    !compile header data\n    header%csoftwareversion   = 'iwfm root zone package (' // trim(cversion) // ')'\n    header%cdescriptor        = 'root zone zone budget'\n    header%lfaceflows_defined = .false.\n    header%lstorages_defined  = .false.\n    header%lcomputeerror      = .false.\n    header%indata             = f_inrootzonebudcolumns\n    allocate (header%idatatypes(f_inrootzonebudcolumns)                           , &\n              header%cfulldatanames(f_inrootzonebudcolumns)                       , &\n              header%cdatahdfpaths(f_inrootzonebudcolumns)                        , &\n              header%indataelems(f_inrootzonebudcolumns,1)                        , &\n              header%ielemdatacolumns(appgrid%nelements,f_inrootzonebudcolumns,1) , &\n              !header%ierrorincols()                                              , &  ! since mass balance error is not calcuated no need\n              !header%ierroroutcols()                                             , &  !  to allocate these arrays\n              header%cdssfparts(f_inrootzonebudcolumns)                           , &\n              header%asciioutput%ccolumntitles(5)                                 , &\n              stat = errorcode                                                    )\n    if (errorcode .ne. 0) then\n        call setlastmessage('error allocating memory for root zone z-budget file!',ifatal,thisprocedure)\n        istat = -1\n        return\n    end if\n    header%idatatypes = [ar ,&  !ag area\n                         vr ,&  !ag potential et\n                         vr ,&  !ag precipitation\n                         vr ,&  !ag runoff\n                         vr ,&  !ag prime applied water\n                         vr ,&  !ag applied water from upstream element surface runoff\n                         vr ,&  !ag re-used water\n                         vr ,&  !ag return flow\n                         vlb,&  !ag beginning storage\n                         vr ,&  !ag net gain from land expansion\n                         vr ,&  !ag infiltration\n                         vr ,&  !ag generic inflow\n                         vr ,&  !ag actual et\n                         vr ,&  !ag percolation\n                         vle,&  !ag ending storage\n                         vr ,&  !ag discrepancy\n                         ar ,&  !urban area\n                         vr ,&  !urban potential et\n                         vr ,&  !urban precipitation\n                         vr ,&  !urban runoff\n                         vr ,&  !urban prime applied water\n                         vr ,&  !urban applied water due to upstream element surface runoff\n                         vr ,&  !urban re-used water\n                         vr ,&  !urban return flow\n                         vlb,&  !urban beginning storage\n                         vr ,&  !urban net gain from land expansion\n                         vr ,&  !urban infiltration\n                         vr ,&  !urban generic inflow\n                         vr ,&  !urban actual et\n                         vr ,&  !urban percolation\n                         vle,&  !urban ending storage\n                         vr ,&  !urban discrepancy\n                         ar ,&  !nv&rv area\n                         vr ,&  !nv&rv potential et\n                         vr ,&  !nv&rv precipitation\n                         vr ,&  !nv&rv surface runoff from upstream elements/subregions\n                         vr ,&  !nv&rv runoff\n                         vlb,&  !nv&rv beginning storage\n                         vr ,&  !nv&rv net gain from land expansion\n                         vr ,&  !nv&rv infiltration\n                         vr ,&  !nv&rv generic inflow\n                         vr ,&  !nv&rv actual et\n                         vr ,&  !nv&rv percolation\n                         vle,&  !nv&rv ending storage\n                         vr ]   !nv&rv discrepancy\n    header%cfulldatanames     = f_crootzonebudgetcolumntitles\n    header%cfulldatanames(1)  = trim(header%cfulldatanames(1)) // carea\n    header%cfulldatanames(17) = trim(header%cfulldatanames(17)) // carea\n    header%cfulldatanames(33) = trim(header%cfulldatanames(33)) // carea\n    header%cdatahdfpaths      = f_crootzonebudgetcolumntitles\n    header%indataelems        = 0\n    header%ielemdatacolumns   = 0\n    if (flags%lag_defined) then\n        header%indataelems(1:16,:) = appgrid%nelements\n        do indxelem=1,appgrid%nelements\n            header%ielemdatacolumns(indxelem,1:16,:) = indxelem\n        end do\n        if (.not. lelemflowtosubregions) then\n            header%indataelems(6,:)        = 0\n            header%ielemdatacolumns(:,6,:) = 0\n        end if\n        if (.not. flags%lgenericmoisturefile_defined) then\n            header%indataelems(12,:)        = 0\n            header%ielemdatacolumns(:,12,:) = 0\n        end if\n    end if\n    if (flags%lurban_defined) then\n        header%indataelems(17:32,:) = appgrid%nelements\n        do indxelem=1,appgrid%nelements\n            header%ielemdatacolumns(indxelem,17:32,:) = indxelem\n        end do\n        if (.not. lelemflowtosubregions) then\n            header%indataelems(22,:)        = 0\n            header%ielemdatacolumns(:,22,:) = 0\n        end if\n        if (.not. flags%lgenericmoisturefile_defined) then\n            header%indataelems(28,:)        = 0\n            header%ielemdatacolumns(:,28,:) = 0\n        end if\n    end if\n    if (flags%lnvrv_defined) then\n        header%indataelems(33:,:) = appgrid%nelements\n        do indxelem=1,appgrid%nelements\n            header%ielemdatacolumns(indxelem,33:,:) = indxelem\n        end do\n        if (.not. lelemflowtosubregions) then\n            header%indataelems(36,:)        = 0\n            header%ielemdatacolumns(:,36,:) = 0\n        end if\n        if (.not. flags%lgenericmoisturefile_defined) then\n            header%indataelems(41,:)        = 0\n            header%ielemdatacolumns(:,41,:) = 0\n        end if\n    end if\n    header%asciioutput%intitles         = 5\n    header%asciioutput%ilencolumntitles = 698\n    header%asciioutput%ccolumntitles(1) = '                                                                                                                                agricultural area                                                                                                                                                                                                                                     urban area                                                                                                                                                                                                       native & riparian vegetation area                                                                                  ' \n    header%asciioutput%ccolumntitles(2) = '                 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'\n    header%asciioutput%ccolumntitles(3) = '                                                                                    prime      inflow as            reused          net       beginning  net gain from                        other           actual                       ending                                                                                      prime      inflow as            reused          net       beginning  net gain from                        other           actual                       ending                                                                   inflow as                       beginning  net gain from                        other           actual                       ending                '\n    header%asciioutput%ccolumntitles(4) = '      time                 area      potential   precipitation         runoff      applied   surface runoff         water          return      storage   land expansion   infiltration        inflow            et      percolation        storage    discrepancy             area      potential   precipitation         runoff      applied   surface runoff         water          return      storage   land expansion   infiltration        inflow            et      percolation        storage    discrepancy             area      potential  precipitation  surface runoff        runoff       storage   land expansion   infiltration        inflow            et      percolation        storage    discrepancy'\n    header%asciioutput%ccolumntitles(5) = '                 '    //carea//'        et                                          water                                           flow         (+)           (+)             (+)              (+)             (-)        (-)               (-)          (=)       '    //carea//'        et                                          water                                           flow         (+)           (+)             (+)              (+)             (-)        (-)               (-)          (=)       '    //carea//'        et                                                          (+)           (+)             (+)              (+)             (-)        (-)               (-)          (=)    '\n    header%asciioutput%cnumberformat    = '(a16,16(2x,f13.1),3x,16(2x,f13.1),3x,13(2x,f13.1))'\n    header%cdssfparts = ['ag_area'           ,&\n                         'ag_pot_et'         ,&   \n                         'ag_precip'         ,&   \n                         'ag_runoff'         ,&   \n                         'ag_prm_h2o'        ,&\n                         'ag_sr_inflow'      ,&\n                         'ag_re-use'         ,&   \n                         'ag_nt_rtrn_flow'   ,&   \n                         'ag_begin_stor'     ,&   \n                         'ag_gain_exp'       ,&   \n                         'ag_infiltr'        ,& \n                         'ag_other_inflow'   ,&\n                         'ag_et'             ,&   \n                         'ag_perc'           ,&   \n                         'ag_end_stor'       ,&  \n                         'ag_discrepancy'    ,& \n                         'urb_area'          ,&  \n                         'urb_pot_et'        ,&  \n                         'urb_precip'        ,&  \n                         'urb_runoff'        ,&  \n                         'urb_prm_h2o'       ,& \n                         'urb_sr_inflow'     ,&\n                         'urb_re-use'        ,&     \n                         'urb_nt_rtrn_flow'  ,&     \n                         'urb_begin_stor'    ,&     \n                         'urb_gain_exp'      ,&     \n                         'urb_infiltr'       ,&     \n                         'urb_other_inflow'  ,&\n                         'urb_et'            ,&     \n                         'urb_perc'          ,&     \n                         'urb_end_stor'      ,& \n                         'urb_discrepancy'   ,&    \n                         'nrv_area'          ,&  \n                         'nrv_pot_et'        ,&\n                         'nrv_precip'        ,&\n                         'nrv_sr_inflow'     ,&  \n                         'nrv_runoff'        ,&  \n                         'nrv_begin_stor'    ,&     \n                         'nrv_gain_exp'      ,&     \n                         'nrv_infiltr'       ,&     \n                         'nrv_other_inflow'  ,&\n                         'nrv_et'            ,&     \n                         'nrv_perc'          ,&     \n                         'nrv_end_stor'      ,&\n                         'nrv_discrepancy'   ]\n                             \n    !instantiate z-budget file\n    call zbudfile%new(cfilename,ntime,timesteplocal,header,systemdata,istat)\n    \n  end subroutine rootzonezonebudrawfile_new\n"}
{"id": 969, "subroutine": "  subroutine rootzonebudrawfile_new(isforinquiry,cfilename,timestep,ntime,nregion,regionarea,cregionnames,cdescriptor,cversion,rawfile,istat)\n    logical,intent(in)            :: isforinquiry\n    character(len=*),intent(in)   :: cfilename,cregionnames(nregion)\n    type(timesteptype),intent(in) :: timestep\n    integer,intent(in)            :: ntime,nregion\n    real(8),intent(in)            :: regionarea(nregion)\n    character(len=*),intent(in)   :: cdescriptor\n    character(len=*),intent(in)   :: cversion\n    type(budgettype)              :: rawfile\n    integer,intent(out)           :: istat\n\n    !local variables\n    type(budgetheadertype) :: outputdata\n    type(timesteptype)     :: timesteplocal\n    integer,parameter      :: f_intitles            = 6   , &\n                              f_ititlelen           = 698 , &        \n                              f_incolumnheaderlines = 4   \n    integer                :: indxcol,indxlocation,icount\n    character              :: unitt*10,text*17,text1*13\n    character(len=6)       :: cparts(f_inrootzonebudcolumns) = ['area'   , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'area'   , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'area'   , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume' , &\n                                                                'volume']\n    character(len=15)      :: fparts(f_inrootzonebudcolumns) = ['ag_area'           ,&\n                                                                'ag_pot_et'         ,&   \n                                                                'ag_precip'         ,&   \n                                                                'ag_runoff'         ,&   \n                                                                'ag_prm_h2o'        ,&\n                                                                'ag_sr_inflow'      ,&\n                                                                'ag_re-use'         ,&   \n                                                                'ag_nt_rtrn_flow'   ,&   \n                                                                'ag_begin_stor'     ,&   \n                                                                'ag_gain_exp'       ,&   \n                                                                'ag_infiltr'        ,& \n                                                                'ag_other_inflow'   ,&\n                                                                'ag_et'             ,&   \n                                                                'ag_perc'           ,&   \n                                                                'ag_end_stor'       ,&  \n                                                                'ag_discrepancy'    ,& \n                                                                'urb_area'          ,&  \n                                                                'urb_pot_et'        ,&  \n                                                                'urb_precip'        ,&  \n                                                                'urb_runoff'        ,&  \n                                                                'urb_prm_h2o'       ,& \n                                                                'urb_sr_inflow'     ,&\n                                                                'urb_re-use'        ,&     \n                                                                'urb_nt_rtrn_flow'  ,&     \n                                                                'urb_begin_stor'    ,&     \n                                                                'urb_gain_exp'      ,&     \n                                                                'urb_infiltr'       ,&     \n                                                                'urb_other_inflow'  ,&\n                                                                'urb_et'            ,&     \n                                                                'urb_perc'          ,&     \n                                                                'urb_end_stor'      ,& \n                                                                'urb_discrepancy'   ,&    \n                                                                'nrv_area'          ,&  \n                                                                'nrv_pot_et'        ,&\n                                                                'nrv_precip'        ,&\n                                                                'nrv_sr_inflow'     ,&  \n                                                                'nrv_runoff'        ,&  \n                                                                'nrv_begin_stor'    ,&     \n                                                                'nrv_gain_exp'      ,&     \n                                                                'nrv_infiltr'       ,&     \n                                                                'nrv_other_inflow'  ,&\n                                                                'nrv_et'            ,&     \n                                                                'nrv_perc'          ,&     \n                                                                'nrv_end_stor'      ,&\n                                                                'nrv_discrepancy'   ] \n    \n    !initialize\n    istat = 0\n                                                  \n    !instantiate the root zone budget raw file for when it is opened for inquiry\n    if (isforinquiry) then\n        call rawfile%new(cfilename,istat)\n        return\n    end if\n    \n    !budget descriptor\n    outputdata%cbudgetdescriptor = cdescriptor\n    \n    !increment the initial simulation time to represent the data begin date  \n    timesteplocal = timestep\n    if (timestep%tracktime) then\n      timesteplocal%currentdateandtime = incrementtimestamp(timesteplocal%currentdateandtime,timesteplocal%deltat_inminutes)\n      unitt                            = ''\n    else\n      timesteplocal%currenttime        = timesteplocal%currenttime + timesteplocal%deltat\n      unitt                            = '('//trim(timestep%unit)//')'\n    end if\n\n    !simulation time related data\n    outputdata%ntimesteps = ntime\n    outputdata%timestep   = timesteplocal\n    \n    !areas\n    allocate (outputdata%areas(nregion))\n    outputdata%nareas = nregion\n    outputdata%areas  = regionarea\n    \n    !data for ascii output\n    associate (pasciioutput => outputdata%asciioutput)\n      pasciioutput%titlelen = f_ititlelen\n      pasciioutput%ntitles  = f_intitles\n        allocate(pasciioutput%ctitles(f_intitles)  ,  pasciioutput%ltitlepersist(f_intitles))\n        pasciioutput%ctitles(1)         = arrangetext('iwfm root zone package ('//trim(cversion)//')' , pasciioutput%titlelen)\n        pasciioutput%ctitles(2)         = arrangetext('root zone moisture budget in '//f_cvolumeunitmarker//' for '//f_clocationnamemarker , pasciioutput%titlelen)\n        pasciioutput%ctitles(3)         = arrangetext('subregion area: '//f_careamarker//' '//f_careaunitmarker , pasciioutput%titlelen)\n        pasciioutput%ctitles(4)         = repeat('-',pasciioutput%titlelen)\n        pasciioutput%ctitles(5)         = repeat(' ',128)//'agricultural area'//repeat(' ',229)//'urban area'//repeat(' ',199)//'native & riparian vegetation area'\n        pasciioutput%ctitles(6)         = repeat(' ',17)//repeat('-',240)//repeat(' ',3)//repeat('-',240)//repeat(' ',3)//repeat('-',195)\n        pasciioutput%ltitlepersist(1:3) = .true.\n        pasciioutput%ltitlepersist(4:6) = .false.\n      pasciioutput%cformatspec        = adjustl('(a16,1x,16(f14.1,1x),3x,16(f14.1,1x),3x,13(f14.1,1x))')\n      pasciioutput%ncolumnheaderlines = f_incolumnheaderlines\n    end associate \n                                                     \n    !location names\n    outputdata%nlocations = nregion\n    allocate (outputdata%clocationnames(nregion))\n    outputdata%clocationnames = cregionnames  \n        \n    !locations\n    allocate (outputdata%locations(1)                                                                , &\n              outputdata%locations(1)%cfullcolumnheaders(f_inrootzonebudcolumns+1)                   , &\n              outputdata%locations(1)%idatacolumntypes(f_inrootzonebudcolumns)                       , &\n              outputdata%locations(1)%icolwidth(f_inrootzonebudcolumns+1)                            , &\n              outputdata%locations(1)%ccolumnheaders(f_inrootzonebudcolumns+1,f_incolumnheaderlines) , &\n              outputdata%locations(1)%ccolumnheadersformatspec(f_incolumnheaderlines)                )\n    associate (plocation => outputdata%locations(1))\n      plocation%ndatacolumns           = f_inrootzonebudcolumns\n      plocation%cfullcolumnheaders(1)  = 'time'                                                   \n      plocation%cfullcolumnheaders(2:) = f_crootzonebudgetcolumntitles\n      plocation%cfullcolumnheaders(2)  = trim(plocation%cfullcolumnheaders(2))  // ' ('//f_careaunitmarker//')'                        \n      plocation%cfullcolumnheaders(18) = trim(plocation%cfullcolumnheaders(18)) // ' ('//f_careaunitmarker//')'                        \n      plocation%cfullcolumnheaders(34) = trim(plocation%cfullcolumnheaders(34)) // ' ('//f_careaunitmarker//')'                        \n      plocation%idatacolumntypes       = [ar ,&  !ag area\n                                          vr ,&  !ag potential et\n                                          vr ,&  !ag precipitation\n                                          vr ,&  !ag runoff\n                                          vr ,&  !ag prime applied water\n                                          vr ,&  !ag applied water from upstream element surface runoff\n                                          vr ,&  !ag re-used water\n                                          vr ,&  !ag return flow\n                                          vlb,&  !ag beginning storage\n                                          vr ,&  !ag net gain from land expansion\n                                          vr ,&  !ag infiltration\n                                          vr ,&  !ag generic inflow\n                                          vr ,&  !ag actual et\n                                          vr ,&  !ag percolation\n                                          vle,&  !ag ending storage\n                                          vr ,&  !ag discrepancy\n                                          ar ,&  !urban area\n                                          vr ,&  !urban potential et\n                                          vr ,&  !urban precipitation\n                                          vr ,&  !urban runoff\n                                          vr ,&  !urban prime applied water\n                                          vr ,&  !urban applied water due to upstream element surface runoff\n                                          vr ,&  !urban re-used water\n                                          vr ,&  !urban return flow\n                                          vlb,&  !urban beginning storage\n                                          vr ,&  !urban net gain from land expansion\n                                          vr ,&  !urban infiltration\n                                          vr ,&  !urban generic inflow\n                                          vr ,&  !urban actual et\n                                          vr ,&  !urban percolation\n                                          vle,&  !urban ending storage\n                                          vr ,&  !urban discrepancy\n                                          ar ,&  !nv&rv area\n                                          vr ,&  !nv&rv potential et\n                                          vr ,&  !nv&rv precipitation\n                                          vr ,&  !nv&rv surface runoff from upstream elements/subregions\n                                          vr ,&  !nv&rv runoff\n                                          vlb,&  !nv&rv beginning storage\n                                          vr ,&  !nv&rv net gain from land expansion\n                                          vr ,&  !nv&rv infiltration\n                                          vr ,&  !nv&rv generic inflow\n                                          vr ,&  !nv&rv actual et\n                                          vr ,&  !nv&rv percolation\n                                          vle,&  !nv&rv ending storage\n                                          vr ]  !nv&rv discrepancy\n      plocation%icolwidth              = [17,14,15,16,(14,indxcol=1,14),14,15,16,(15,indxcol=1,13),14,15,16,(15,indxcol=1,10)]\n      associate (pcolumnheaders => plocation%ccolumnheaders           , &\n                 pformatspecs   => plocation%ccolumnheadersformatspec )\n        text                = arrangetext(trim(unitt),17)\n        text1               = '('//trim(f_careaunitmarker)//')'\n        pcolumnheaders(:,1) = ['                 ','              ','               ','                ','               ','       prime   ','   inflow as   ','         reused','          net  ','     beginning ',' net gain from ','               ','        other  ','         actual','               ','        ending ','               ','              ','               ','                ','               ','       prime   ','   inflow as   ','         reused','          net  ','     beginning ',' net gain from ','               ','        other  ','         actual','               ','        ending ','               ','              ','               ','                ','   inflow as   ','               ','     beginning ',' net gain from ','               ','        other  ','         actual','               ','        ending ','               ']\n        pcolumnheaders(:,2) = ['      time       ','          area','      potential','   precipitation','         runoff','      applied  ',' surface runoff','         water ','         return','      storage  ',' land expansion','   infiltration','        inflow ','           et  ','    percolation','        storage','    discrepancy','          area','      potential','   precipitation','         runoff','      applied  ',' surface runoff','         water ','         return','      storage  ',' land expansion','   infiltration','        inflow ','           et  ','    percolation','        storage','    discrepancy','          area','      potential','  precipitation ',' surface runoff','        runoff ','      storage  ',' land expansion','   infiltration','        inflow ','           et  ','    percolation','        storage','    discrepancy']\n        pcolumnheaders(:,3) = [               text,           text1,'         et    ','                ','               ','       water   ','               ','               ','          flow ','        (+)    ','       (+)     ','        (+)    ','          (+)  ','           (-) ','       (-)     ','          (-)  ','        (=)    ',           text1,'         et    ','                ','               ','       water   ','               ','               ','          flow ','        (+)    ','       (+)     ','        (+)    ','          (+)  ','           (-) ','       (-)     ','          (-)  ','        (=)    ',           text1,'         et    ','                ','               ','               ','        (+)    ','       (+)     ','        (+)    ','          (+)  ','           (-) ','       (-)     ','          (-)  ','        (=)    ']\n        pcolumnheaders(:,4) = ''\n        pformatspecs(1)     = '(a17,a14,a15,a16,13a15,3x,a14,a15,a16,13a15,3x,a14,a15,a16,10a15)'\n        pformatspecs(2)     = '(a17,a14,a15,a16,13a15,3x,a14,a15,a16,13a15,3x,a14,a15,a16,10a15)'\n        pformatspecs(3)     = '(a17,a14,a15,a16,13a15,3x,a14,a15,a16,13a15,3x,a14,a15,a16,10a15)'\n        pformatspecs(4)     = '('//trim(inttotext(f_ititlelen))//'(1h-),'//trim(inttotext(f_inrootzonebudcolumns+1))//'a0)'\n      end associate\n    end associate\n\n    !data for dss output  \n    associate (pdssoutput => outputdata%dssoutput)\n      allocate (pdssoutput%cpathnames(f_inrootzonebudcolumns*nregion) , pdssoutput%idatatypes(f_inrootzonebudcolumns))\n      icount = 1\n      do indxlocation=1,nregion\n        do indxcol=1,f_inrootzonebudcolumns\n          pdssoutput%cpathnames(icount) = '/iwfm_rootzn_bud/'                                            //  &  !a part\n                                          trim(uppercase(outputdata%clocationnames(indxlocation)))//'/'  //  &  !b part\n                                          trim(cparts(indxcol))//'/'                                     //  &  !c part\n                                          '/'                                                            //  &  !d part\n                                           trim(timestep%unit)//'/'                                      //  &  !e part\n                                          trim(fparts(indxcol))//'/'                                            !f part\n          icount = icount+1\n        end do\n      end do\n      pdssoutput%idatatypes = [f_iper_aver,(f_iper_cum,indxcol=1,15),f_iper_aver,(f_iper_cum,indxcol=1,15),f_iper_aver,(f_iper_cum,indxcol=1,12)]\n    end associate\n                                             \n    !instantiate the land and water use raw file\n    call rawfile%new(cfilename,outputdata,istat)\n    \n    !free memory\n    call outputdata%kill()\n    \n  end subroutine rootzonebudrawfile_new\n"}
{"id": 970, "subroutine": "  subroutine rootzone_v50_kill(rootzone)\n    class(rootzone_v50_type) :: rootzone\n    \n    !local variables\n    integer               :: errorcode\n    type(solverdatatype)  :: dummysolverdata\n    type(flags_v50_type) :: dummyflags\n    \n    !deallocate arrays\n    deallocate (rootzone%flags%llakeelems   , &\n                rootzone%subregionsoilsdata , &\n                rootzone%elemsoiltype       , &\n                rootzone%soilregionprecip   , &\n                rootzone%soilregionarea     , &\n                rootzone%watersupply        , &\n                stat = errorcode            )\n    \n    !kill components\n    call rootzone%agrootzone%kill()\n    call rootzone%urbanrootzone%kill()\n    call rootzone%nvrvrootzone%kill()\n    call rootzone%genericmoisturedata%kill()\n    call rootzone%lwuzonebudrawfile%kill()\n    call rootzone%rootzonezonebudrawfile%kill()\n    \n    !default other components\n    rootzone%nsoils     = 0\n    rootzone%flags      = dummyflags\n    rootzone%solverdata = dummysolverdata\n    \n  end subroutine rootzone_v50_kill\n"}
{"id": 971, "subroutine": "  subroutine rootzone_v50_getmaxandminnetreturnflowfrac(rootzone,firsttimestep,rmaxfrac,rminfrac,istat)\n    class(rootzone_v50_type)      :: rootzone\n    type(timesteptype),intent(in) :: firsttimestep\n    real(8),intent(out)           :: rmaxfrac,rminfrac\n    integer,intent(out)           :: istat\n    \n    !local variables\n    real(8)                  :: rdummyfactor(1),rmaxfracurb,rminfracurb\n    character(:),allocatable :: creturnfracfilename,cworkdirreturn,creusefracfilename,cworkdirreuse\n    \n    !initialize\n    rmaxfrac = 1.0\n    rminfrac = 0.0\n    \n    !filenames and working directories\n    call rootzone%returnfracfile%getfilename(creturnfracfilename)\n    call getfiledirectory(creturnfracfilename,cworkdirreturn)\n    call rootzone%reusefracfile%getfilename(creusefracfilename)\n    call getfiledirectory(creusefracfilename,cworkdirreuse)\n    \n    !get the min and max return flow fractions from non-ponded ag component\n    if (rootzone%flags%lag_defined) &\n        call rootzone%agrootzone%getmaxandminnetreturnflowfrac(rootzone%returnfracfile,rootzone%reusefracfile,firsttimestep,rmaxfrac,rminfrac,istat)\n    \n    !close/open return and reuse fraction files to initialize them\n    call rootzone%returnfracfile%close()\n    call rootzone%returnfracfile%init(creturnfracfilename,cworkdirreturn,'return flow fractions data file',firsttimestep%tracktime,1,.false.,rdummyfactor,istat=istat)  \n    call rootzone%reusefracfile%close()\n    call rootzone%reusefracfile%init(creusefracfilename,cworkdirreuse,'irrigation water re-use factors file',firsttimestep%tracktime,1,.false.,rdummyfactor,istat=istat)  \n    \n    !get the min and max return flow fractions from urban component\n    if (rootzone%flags%lurban_defined) then\n        call rootzone%urbanrootzone%getmaxandminnetreturnflowfrac(rootzone%returnfracfile,rootzone%reusefracfile,firsttimestep,rmaxfracurb,rminfracurb,istat)\n        if (rootzone%flags%lag_defined) then\n            rmaxfrac = max(rmaxfrac , rmaxfracurb)\n            rminfrac = min(rminfrac , rminfracurb)\n        end if\n    end if\n    \n    !close/open return and reuse fraction files to initialize them\n    call rootzone%returnfracfile%close()\n    call rootzone%returnfracfile%init(creturnfracfilename,cworkdirreturn,'return flow fractions data file',firsttimestep%tracktime,1,.false.,rdummyfactor,istat=istat)  \n    call rootzone%reusefracfile%close()\n    call rootzone%reusefracfile%init(creusefracfilename,cworkdirreuse,'irrigation water re-use factors file',firsttimestep%tracktime,1,.false.,rdummyfactor,istat=istat)  \n    \n  end subroutine rootzone_v50_getmaxandminnetreturnflowfrac\n"}
{"id": 972, "subroutine": "  subroutine rootzone_v50_getdatalist_atlocationtype(rootzone,ilocationtype,cdatalist,cfilelist,lbudgettype)\n     class(rootzone_v50_type),intent(in) :: rootzone\n     integer,intent(in)                  :: ilocationtype\n     character(len=*),allocatable        :: cdatalist(:),cfilelist(:)\n     logical,allocatable                 :: lbudgettype(:)\n     \n     !local variables\n     integer                  :: icount,errorcode\n     logical                  :: lbudgettype_local(10)\n     character(len=500)       :: cfilelist_local(10),cdatalist_local(10)\n     character(:),allocatable :: cfilename\n     \n     !initialize\n     icount = 0\n     deallocate (cdatalist , cfilelist , lbudgettype , stat=errorcode)\n     \n     select case (ilocationtype)\n         case (f_ilocationtype_subregion)\n             !land and water use budget\n             if (rootzone%flags%lwusebudrawfile_defined) then\n                 call rootzone%lwusebudrawfile%getfilename(cfilename)\n                 icount                    = icount + 1\n                 cdatalist_local(icount)   = f_cdatalist_atsubregion(f_ilwu_atsubregion)\n                 cfilelist_local(icount)   = cfilename\n                 lbudgettype_local(icount) = .true.\n             end if\n             \n             !root zone budget\n             if (rootzone%flags%rootzonebudrawfile_defined) then\n                 call rootzone%rootzonebudrawfile%getfilename(cfilename)\n                 icount                    = icount + 1\n                 cdatalist_local(icount)   = f_cdatalist_atsubregion(f_irootzone_atsubregion)\n                 cfilelist_local(icount)   = cfilename\n                 lbudgettype_local(icount) = .true.\n             end if\n                          \n             \n         case (f_ilocationtype_zone)\n             !land and water use zone budget\n             if (rootzone%flags%lwusezonebudrawfile_defined) then\n                 call rootzone%lwuzonebudrawfile%getfilename(cfilename)\n                 icount                    = icount + 1\n                 cdatalist_local(icount)   = f_cdatalist_atzone(f_ilwu_atzone)\n                 cfilelist_local(icount)   = cfilename\n                 lbudgettype_local(icount) = .true.\n             end if\n             \n             !root zone zone budget\n             if (rootzone%flags%rootzonezonebudrawfile_defined) then\n                 call rootzone%rootzonezonebudrawfile%getfilename(cfilename)\n                 icount                    = icount + 1\n                 cdatalist_local(icount)   = f_cdatalist_atzone(f_irootzone_atzone)\n                 cfilelist_local(icount)   = cfilename\n                 lbudgettype_local(icount) = .true.\n             end if\n             \n    end select\n     \n    !store data in return variables\n    allocate (cdatalist(icount) , cfilelist(icount) , lbudgettype(icount))\n    cdatalist   = ''\n    cdatalist   = cdatalist_local(1:icount)\n    cfilelist   = ''\n    cfilelist   = cfilelist_local(1:icount)\n    lbudgettype = lbudgettype_local(1:icount)\n    \n  end subroutine rootzone_v50_getdatalist_atlocationtype\n"}
{"id": 973, "subroutine": "  subroutine rootzone_v50_getlocationswithdata(rootzone,ilocationtype,cdatatype,ilocations)\n     class(rootzone_v50_type),intent(in) :: rootzone\n     integer,intent(in)                  :: ilocationtype\n     character(len=*),intent(in)         :: cdatatype\n     integer,allocatable,intent(out)     :: ilocations(:)\n     \n     select case (ilocationtype)\n         case (f_ilocationtype_subregion)\n             !land and water use budget\n             if (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_ilwu_atsubregion))) then\n                 if (rootzone%flags%lwusebudrawfile_defined) then\n                    allocate (ilocations(1))\n                    ilocations = f_ialllocationidslisted\n                 end if\n                 \n             !root zone budget\n             elseif (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_irootzone_atsubregion))) then\n                 if (rootzone%flags%rootzonebudrawfile_defined) then\n                    allocate (ilocations(1))\n                    ilocations = f_ialllocationidslisted\n                 end if\n             end if\n                          \n             \n         case (f_ilocationtype_zone)\n             !land and water use zone budget\n             if (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_ilwu_atzone))) then\n                 if (rootzone%flags%lwusezonebudrawfile_defined) then\n                    allocate (ilocations(1))\n                    ilocations = f_ialllocationidslisted\n                 end if\n                 \n             !root zone zone budget\n             elseif (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_irootzone_atzone))) then\n                 if (rootzone%flags%rootzonezonebudrawfile_defined) then\n                    allocate (ilocations(1))\n                    ilocations = f_ialllocationidslisted\n                 end if\n             end if\n             \n    end select\n     \n  end subroutine rootzone_v50_getlocationswithdata\n"}
{"id": 974, "subroutine": "  subroutine rootzone_v50_getsubdatalist_forlocationanddatatype(rootzone,ilocationtype,cdatatype,csubdatalist)\n    class(rootzone_v50_type),intent(in)      :: rootzone\n    integer,intent(in)                       :: ilocationtype\n    character(len=*),intent(in)              :: cdatatype\n    character(len=*),allocatable,intent(out) :: csubdatalist(:)\n     \n    !local variables\n    integer :: errorcode\n    \n    !initialize\n    deallocate (csubdatalist , stat=errorcode)\n    \n    select case (ilocationtype)\n        !sub-data for data at subregion\n        case (f_ilocationtype_subregion)\n             !land and water use budget\n             if (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_ilwu_atsubregion))) then\n                 if (rootzone%flags%lwusebudrawfile_defined) then\n                    allocate (csubdatalist(f_inlwusebudcolumns))\n                    csubdatalist = f_clwusebudgetcolumntitles\n                 end if\n                 \n             !root zone budget\n             elseif (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_irootzone_atsubregion))) then\n                 if (rootzone%flags%rootzonebudrawfile_defined) then\n                    allocate (csubdatalist(f_inrootzonebudcolumns))\n                    csubdatalist = f_crootzonebudgetcolumntitles\n                 end if\n             end if\n             \n        !sub-data for data at zone\n        case (f_ilocationtype_zone)\n             !land and water use budget\n             if (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_ilwu_atzone))) then\n                 if (rootzone%flags%lwusezonebudrawfile_defined) then\n                    allocate (csubdatalist(f_inlwusebudcolumns))\n                    csubdatalist = f_clwusebudgetcolumntitles\n                 end if\n                 \n             !root zone budget\n             elseif (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_irootzone_atzone))) then\n                 if (rootzone%flags%rootzonezonebudrawfile_defined) then\n                    allocate (csubdatalist(f_inrootzonebudcolumns))\n                    csubdatalist = f_crootzonebudgetcolumntitles\n                 end if\n             end if\n    end select\n     \n  end subroutine rootzone_v50_getsubdatalist_forlocationanddatatype\n"}
{"id": 975, "subroutine": "  subroutine rootzone_v50_getzbudget_columntitles(rootzone,czbudget,cunitar,cunitvl,ccoltitles,istat)\n    class(rootzone_v50_type),intent(in)      :: rootzone\n    character(len=*),intent(in)              :: czbudget,cunitar,cunitvl\n    character(len=*),allocatable,intent(out) :: ccoltitles(:)\n    integer,intent(out)                      :: istat\n    \n    !local variables\n    character(len=f_icolumnheaderlen),allocatable :: ccoltitles_local(:)\n    \n    !land and water use z-budget\n    if (trim(czbudget) .eq. trim(f_cdatalist_atzone(f_ilwu_atzone))) then\n        if (rootzone%flags%lwusezonebudrawfile_defined) then\n            call rootzone%lwuzonebudrawfile%getfullcolumnheaders(cunitar,cunitvl,ccoltitles_local,istat)\n            if (istat .ne. 0) return\n            allocate(ccoltitles(size(ccoltitles_local)-1))\n            ccoltitles = ''\n            ccoltitles = ccoltitles_local(2:)\n            return\n        end if\n        \n    !root zone budget\n    elseif (trim(czbudget) .eq. trim(f_cdatalist_atzone(f_irootzone_atzone))) then\n        if (rootzone%flags%rootzonezonebudrawfile_defined) then\n            call rootzone%rootzonezonebudrawfile%getfullcolumnheaders(cunitar,cunitvl,ccoltitles_local,istat)\n            if (istat .ne. 0) return\n            allocate(ccoltitles(size(ccoltitles_local)-1))\n            ccoltitles = ''\n            ccoltitles = ccoltitles_local(2:)\n            return        \n        end if\n    end if  \n    \n    !otherwise, allocate zero array\n    allocate(ccoltitles(0))\n        \n  end subroutine rootzone_v50_getzbudget_columntitles\n"}
{"id": 976, "subroutine": "  subroutine rootzone_v50_getzbudget_monthlyflows(czbudget,zbudget,zonelist,izoneid,ilutype,cbegindate,cenddate,rfactvl,rflows,cflownames,istat)\n     character(len=*),intent(in)              :: czbudget\n     type(zbudgettype),intent(in)             :: zbudget              \n     type(zonelisttype),intent(in)            :: zonelist\n     integer,intent(in)                       :: izoneid,ilutype\n     character(len=*),intent(in)              :: cbegindate,cenddate  \n     real(8),intent(in)                       :: rfactvl\n     real(8),allocatable,intent(out)          :: rflows(:,:)          \n     character(len=*),allocatable,intent(out) :: cflownames(:)\n     integer,intent(out)                      :: istat\n     \n  end subroutine rootzone_v50_getzbudget_monthlyflows\n"}
{"id": 977, "subroutine": "  subroutine rootzone_v50_getmodeldata_atlocation(rootzone,izextent,ielems,ilayers,izones,izoneswithnames,czonenames,ilocationtype,ilocationid,cdatatype,icol,coutputbegindateandtime,coutputenddateandtime,coutputinterval,rfact_lt,rfact_ar,rfact_vl,idataunittype,nactualoutput,routputdates,routputvalues,istat)\n    class(rootzone_v50_type)    :: rootzone\n    integer,intent(in)          :: izextent,ielems(:),ilayers(:),izones(:),izoneswithnames(:),ilocationtype,ilocationid,icol\n    character(len=*),intent(in) :: czonenames(:),cdatatype,coutputbegindateandtime,coutputenddateandtime,coutputinterval\n    real(8),intent(in)          :: rfact_lt,rfact_ar,rfact_vl\n    integer,intent(out)         :: idataunittype,nactualoutput\n    real(8),intent(out)         :: routputdates(:),routputvalues(:)\n    integer,intent(out)         :: istat\n    \n    !local variables\n    integer            :: ireadcols(1),idataunittypearray(1)\n    real(8)            :: rvalues(2,size(routputdates))\n    type(zonelisttype) :: zonelist\n    \n    !initialize\n    istat         = 0\n    nactualoutput = 0\n    \n    !proceed based on location type\n    select case (ilocationtype)\n        case (f_ilocationtype_subregion)\n            !land and water use budget\n            if (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_ilwu_atsubregion))) then\n                if (rootzone%flags%lwusebudrawfile_defined) then\n                    call rootzone%lwusebudrawfile%readdata(ilocationid,icol,coutputinterval,coutputbegindateandtime,coutputenddateandtime,1d0,0d0,0d0,rfact_lt,rfact_ar,rfact_vl,idataunittype,nactualoutput,routputdates,routputvalues,istat)\n                end if\n                \n            !root zone budget\n            elseif (trim(cdatatype) .eq. trim(f_cdatalist_atsubregion(f_irootzone_atsubregion))) then\n                if (rootzone%flags%rootzonebudrawfile_defined) then\n                    call rootzone%rootzonebudrawfile%readdata(ilocationid,icol,coutputinterval,coutputbegindateandtime,coutputenddateandtime,1d0,0d0,0d0,rfact_lt,rfact_ar,rfact_vl,idataunittype,nactualoutput,routputdates,routputvalues,istat)\n                end if\n            end if    \n           \n           \n        case (f_ilocationtype_zone)\n            ireadcols = icol\n            \n            !land and water use zone budget\n            if (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_ilwu_atzone))) then\n                if (rootzone%flags%lwusezonebudrawfile_defined) then\n                    !generate zone list\n                    call zonelist%new(rootzone%lwuzonebudrawfile%header%indata,rootzone%lwuzonebudrawfile%header%lfaceflows_defined,rootzone%lwuzonebudrawfile%systemdata,izextent,ielems,ilayers,izones,izoneswithnames,czonenames,istat)  ;  if (istat .eq. -1) return\n                    !read data\n                    call rootzone%lwuzonebudrawfile%readdata(zonelist,ilocationid,ireadcols,coutputinterval,coutputbegindateandtime,coutputenddateandtime,rfact_ar,rfact_vl,idataunittypearray,nactualoutput,rvalues,istat)  ;  if (istat .eq. -1) return\n                    !populate return variables\n                    routputdates(1:nactualoutput)  = rvalues(1,1:nactualoutput)\n                    routputvalues(1:nactualoutput) = rvalues(2,1:nactualoutput)\n                    idataunittype                  = idataunittypearray(1)\n                end if\n                \n            !root zone zone budget\n            elseif (trim(cdatatype) .eq. trim(f_cdatalist_atzone(f_irootzone_atzone))) then\n                if (rootzone%flags%rootzonezonebudrawfile_defined) then\n                    !generate zone list\n                    call zonelist%new(rootzone%lwuzonebudrawfile%header%indata,rootzone%lwuzonebudrawfile%header%lfaceflows_defined,rootzone%lwuzonebudrawfile%systemdata,izextent,ielems,ilayers,izones,izoneswithnames,czonenames,istat)  ;  if (istat .eq. -1) return\n                    !read data\n                    call rootzone%rootzonezonebudrawfile%readdata(zonelist,ilocationid,ireadcols,coutputinterval,coutputbegindateandtime,coutputenddateandtime,rfact_ar,rfact_vl,idataunittypearray,nactualoutput,rvalues,istat)  ;  if (istat .eq. -1) return\n                    !populate return variables\n                    routputdates(1:nactualoutput)  = rvalues(1,1:nactualoutput)\n                    routputvalues(1:nactualoutput) = rvalues(2,1:nactualoutput)\n                    idataunittype                  = idataunittypearray(1)\n                end if\n            end if    \n    end select\n\n  end subroutine rootzone_v50_getmodeldata_atlocation\n"}
{"id": 978, "subroutine": "  pure subroutine rootzone_v50_getratio_destsupplytoregionsupply_ag(rootzone,ratio)\n    class(rootzone_v50_type),intent(in) :: rootzone  !not used in this version\n    real(8),intent(out)                 :: ratio(:)\n    \n    ratio = 1.0\n    \n  end subroutine rootzone_v50_getratio_destsupplytoregionsupply_ag\n"}
{"id": 979, "subroutine": "  subroutine rootzone_v50_getsubregionagareas(rootzone,appgrid,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid   !not used in this version\n    real(8),intent(out)                 :: areas(:)\n    \n    !return subregional ag areas\n    if (rootzone%flags%lag_defined) then\n        areas(1:appgrid%nsubregions) = rootzone%agrootzone%subregionalarea\n        areas(appgrid%nsubregions+1) = sum(areas(1:appgrid%nsubregions))\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getsubregionagareas\n"}
{"id": 980, "subroutine": "  subroutine rootzone_v50_getsubregionnativevegareas(rootzone,appgrid,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8),intent(out)                 :: areas(:)\n    \n    if (rootzone%flags%lnvrv_defined) then\n        areas(1:appgrid%nsubregions) = rootzone%nvrvrootzone%subregionalarea_nv\n        areas(appgrid%nsubregions+1) = sum(areas(1:appgrid%nsubregions))\n    else\n        areas = 0.0\n        return\n    end if\n    \n  end subroutine rootzone_v50_getsubregionnativevegareas\n"}
{"id": 981, "subroutine": "  subroutine rootzone_v50_getelementagareas(rootzone,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    real(8),intent(out)                 :: areas(:)\n    \n    !return elemental ag areas\n    if (rootzone%flags%lag_defined) then\n        areas = rootzone%agrootzone%elementalarea\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getelementagareas\n"}
{"id": 982, "subroutine": "  subroutine rootzone_v50_getelementurbanareas(rootzone,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    real(8),intent(out)                 :: areas(:)\n    \n    !return elemental urabn areas\n    if (rootzone%flags%lurban_defined) then\n        areas = rootzone%urbanrootzone%elementalarea\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getelementurbanareas\n"}
{"id": 983, "subroutine": "  subroutine rootzone_v50_getelementnativevegareas(rootzone,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    real(8),intent(out)                 :: areas(:)\n    \n    if (rootzone%flags%lnvrv_defined) then\n        areas = rootzone%nvrvrootzone%elementalarea_nv\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getelementnativevegareas\n"}
{"id": 984, "subroutine": "  subroutine rootzone_v50_getdemandagareas(rootzone,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    real(8),allocatable                 :: areas(:)\n    \n    !initialize\n    if (.not. allocated(areas)) allocate(areas(size(rootzone%subregionsoilsdata,dim=2)))\n    \n    !return subregional ag areas\n    if (rootzone%flags%lag_defined) then\n        areas = rootzone%agrootzone%subregionalarea\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getdemandagareas\n"}
{"id": 985, "subroutine": "  subroutine rootzone_v50_getdemandurbanareas(rootzone,areas)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    real(8),allocatable                 :: areas(:)\n    \n    !initialize\n    if (.not. allocated(areas)) allocate(areas(size(rootzone%subregionsoilsdata,dim=2)))\n    \n    !return subregional urban areas\n    if (rootzone%flags%lurban_defined) then\n        areas = rootzone%urbanrootzone%subregionalarea\n    else\n        areas = 0.0\n    end if\n\n  end subroutine rootzone_v50_getdemandurbanareas\n"}
{"id": 986, "subroutine": "  subroutine rootzone_v50_getelementprecipinfilt(rootzone,elemregion,precipinfilt)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                  :: elemregion(:)\n    real(8)                             :: precipinfilt(:)\n    \n    !local variables\n    integer :: indxelem,iregion,isoil\n    \n    do indxelem=1,size(elemregion)\n        iregion = elemregion(indxelem)\n        isoil   = rootzone%elemsoiltype(indxelem)\n        \n        !from ag\n        if (rootzone%flags%lag_defined) then\n            precipinfilt(indxelem) = rootzone%agrootzone%agdata(isoil,iregion)%precipinfilt * rootzone%agrootzone%elementalarea(indxelem)\n        else\n            precipinfilt(indxelem) = 0.0\n        end if\n    \n        !from urban\n        if (rootzone%flags%lurban_defined) &\n            precipinfilt(indxelem) = precipinfilt(indxelem) + rootzone%urbanrootzone%urbdata(isoil,iregion)%precipinfilt * rootzone%urbanrootzone%elementalarea(indxelem) * rootzone%urbanrootzone%perviousfrac(iregion)\n    \n        !from native and riparian veg\n        if (rootzone%flags%lnvrv_defined) &\n            precipinfilt(indxelem) = precipinfilt(indxelem) + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%precipinfilt   * rootzone%nvrvrootzone%elementalarea_nv(indxelem)    &\n                                                            + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%precipinfilt * rootzone%nvrvrootzone%elementalarea_rv(indxelem)\n    end do\n    \n  end subroutine rootzone_v50_getelementprecipinfilt\n"}
{"id": 987, "subroutine": "  subroutine rootzone_v50_getwaterdemand(rootzone,idemandfor,rdemand)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                  :: idemandfor\n    real(8)                             :: rdemand(:)\n    \n    if (idemandfor .eq. f_iag) then\n        if (rootzone%flags%lag_defined) then\n            call echoprogress('retrieving subregional agricultural water demand ... ',ladvance=.false.)\n            rdemand = rootzone%agrootzone%subregionaldemand\n            call echoprogress('done')\n        else\n            rdemand = 0.0\n        end if\n    else\n        if (rootzone%flags%lurban_defined) then\n            call echoprogress('retrieving subregional urban water demand ... ',ladvance=.false.)\n            rdemand = rootzone%urbanrootzone%demand\n            call echoprogress('done')\n        else\n            rdemand = 0.0\n        end if\n    end if\n\n  end subroutine rootzone_v50_getwaterdemand\n"}
{"id": 988, "subroutine": "  subroutine rootzone_v50_getwaterdemandatlocations(rootzone,appgrid,ilocationtypeid,ilocationidlist,idemandfor,rdemand,istat)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    integer,intent(in)                  :: ilocationtypeid,ilocationidlist(:),idemandfor\n    real(8)                             :: rdemand(:)\n    integer,intent(out)                 :: istat\n    \n    !local variables\n    character(len=modnamelen+38),parameter :: thisprocedure = modname // 'rootzone_v50_getwaterdemandatlocations'\n    integer                                :: ilocationlist(size(ilocationidlist))\n    \n    !initialize\n    istat = 0\n    \n    select case (idemandfor)\n        case (f_iag)\n            !inform user\n            call echoprogress('retrieving agricultural water demand at specified locations...')\n            !return if no agricultural area is simulated\n            if (.not. rootzone%flags%lag_defined) then\n                rdemand = 0.0\n                return\n            end if\n            !make sure location type is subregion, if so compile information\n            select case (ilocationtypeid)\n                case (f_iflowdest_subregion)\n                    call convertid_to_index(ilocationidlist,appgrid%appsubregion%id,ilocationlist)\n                    rdemand = rootzone%agrootzone%subregionaldemand(ilocationlist)\n                    \n                case default\n                    call setlastmessage('agricultural water demand cannot be retrieved at the specified location type.',ifatal,thisprocedure)\n                    istat = -1\n                    return\n            end select\n                \n        case (f_iurb)\n            !inform user\n            call echoprogress('retrieving urban water demand at specified locations...')\n            !return if no urban area is simulated\n            if (.not. rootzone%flags%lurban_defined) then\n                rdemand = 0.0\n                return\n            end if\n            !make sure location type is subregion, if so compile information\n            select case (ilocationtypeid)\n                case (f_iflowdest_subregion)\n                    call convertid_to_index(ilocationidlist,appgrid%appsubregion%id,ilocationlist)\n                    rdemand = rootzone%urbanrootzone%demand(ilocationlist)\n                    \n                case default\n                    call setlastmessage('urban water demand cannot be retrieved at the specified location type.',ifatal,thisprocedure)\n                    istat = -1\n                    return\n            end select\n    end select\n        \n  end subroutine rootzone_v50_getwaterdemandatlocations\n"}
{"id": 989, "subroutine": "  subroutine rootzone_v50_getwatersupply(rootzone,appgrid,isupplyfor,rsupply)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid \n    integer,intent(in)                  :: isupplyfor\n    real(8)                             :: rsupply(:)\n    \n    if (isupplyfor .eq. f_iag) then\n        if (rootzone%flags%lag_defined) then\n            call echoprogress('retrieving subregional agricultural water supplies ... ',ladvance=.false.)\n            rsupply = rootzone%watersupply%diversion_ag + rootzone%watersupply%pumping_ag + upstrmrunofftolanduse(rootzone,appgrid,f_ilanduse_ag)\n            call echoprogress('done')\n        else\n            rsupply = 0.0\n        end if\n    else\n        if (rootzone%flags%lurban_defined) then\n            call echoprogress('retrieving subregional urban water supplies ... ',ladvance=.false.)\n            rsupply = rootzone%watersupply%diversion_urb + rootzone%watersupply%pumping_urb + upstrmrunofftolanduse(rootzone,appgrid,f_ilanduse_urban)\n            call echoprogress('done')\n        else\n            rsupply = 0.0\n        end if\n    end if\n\n  end subroutine rootzone_v50_getwatersupply\n"}
{"id": 990, "subroutine": "  subroutine rootzone_v50_getelementsoilmvolume(rootzone,appgrid,soilm)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8),intent(out)                 :: soilm(:)\n    \n    !local variables\n    integer :: indxelem,isoil,iregion\n    \n    !soil moisture from ag lands\n    if (rootzone%flags%lag_defined) then\n        soilm = 0.0\n        do indxelem=1,appgrid%nelements\n            isoil           = rootzone%elemsoiltype(indxelem)\n            iregion         = appgrid%appelement(indxelem)%subregion\n            soilm(indxelem) = soilm(indxelem) + ( rootzone%agrootzone%agdata(isoil,iregion)%soilm_precip  &\n                                                + rootzone%agrootzone%agdata(isoil,iregion)%soilm_aw      &\n                                                + rootzone%agrootzone%agdata(isoil,iregion)%soilm_oth   ) * rootzone%agrootzone%elementalarea(indxelem)  \n        end do\n    else\n        soilm = 0.0\n    end if\n    \n    !soil moisture from urban lands\n    if (rootzone%flags%lurban_defined) then\n        do indxelem=1,appgrid%nelements\n            isoil           = rootzone%elemsoiltype(indxelem)\n            iregion         = appgrid%appelement(indxelem)%subregion\n            soilm(indxelem) = soilm(indxelem) + ( rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_precip  &\n                                                + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_aw      &\n                                                + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_oth   ) * rootzone%urbanrootzone%elementalarea(indxelem) * rootzone%urbanrootzone%perviousfrac(iregion)\n        end do\n    end if\n\n    !soil moisture from native and riparian veg\n    if (rootzone%flags%lnvrv_defined) then\n        do indxelem=1,appgrid%nelements\n            isoil           = rootzone%elemsoiltype(indxelem)\n            iregion         = appgrid%appelement(indxelem)%subregion\n            soilm(indxelem) = soilm(indxelem) + ( rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_precip    &\n                                                + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_aw        &\n                                                + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_oth     ) * rootzone%nvrvrootzone%elementalarea_nv(indxelem)  &\n                                              + ( rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_precip  &\n                                                + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_aw      &\n                                                + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_oth   ) * rootzone%nvrvrootzone%elementalarea_rv(indxelem)\n        end do\n    end if\n\n  end subroutine rootzone_v50_getelementsoilmvolume\n"}
{"id": 991, "subroutine": "  subroutine rootzone_v50_getflowstostreams(rootzone,appgrid,directrunoff,returnflow,riparianet)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8),intent(out)                 :: directrunoff(:),returnflow(:)\n    real(8),intent(inout)               :: riparianet(:)                 !included only to be consistent with the baserootzone template! this process is not simulated in this version.\n    \n    !local variables\n    integer :: indx,istrmnode,ielem,isoil,iregion\n    logical :: lag_defined,lurban_defined,lnvrv_defined\n    \n    !initialize\n    directrunoff   = 0.0\n    returnflow     = 0.0\n    lag_defined    = rootzone%flags%lag_defined\n    lurban_defined = rootzone%flags%lurban_defined\n    lnvrv_defined  = rootzone%flags%lnvrv_defined\n        \n    !flows into streams\n    associate (pflowdata  => rootzone%elemflowtostreams              , &\n               psoiltype  => rootzone%elemsoiltype                   , &\n               pag        => rootzone%agrootzone%agdata              , &\n               pagarea    => rootzone%agrootzone%elementalarea       , &\n               purban     => rootzone%urbanrootzone%urbdata          , &\n               purbanarea => rootzone%urbanrootzone%elementalarea    , &\n               pnv        => rootzone%nvrvrootzone%nativeveg         , &\n               prv        => rootzone%nvrvrootzone%riparianveg       , &\n               pnvarea    => rootzone%nvrvrootzone%elementalarea_nv  , &\n               prvarea    => rootzone%nvrvrootzone%elementalarea_rv  )\n    \n      do indx=1,size(pflowdata)\n        !element id\n        ielem = pflowdata(indx)%ielement\n        \n        !soil type and subregion number fo the element\n        isoil   = psoiltype(ielem)\n        iregion = appgrid%appelement(ielem)%subregion\n        \n        !destination stream node\n        istrmnode = pflowdata(indx)%idest\n        \n        !flows from ag lands\n        if (lag_defined) then\n            directrunoff(istrmnode) = directrunoff(istrmnode) + pag(isoil,iregion)%runoff * pagarea(ielem)\n            returnflow(istrmnode)   = returnflow(istrmnode)   + pag(isoil,iregion)%returnflow * pagarea(ielem)\n        end if\n        \n        !flows from urban lands\n        if (lurban_defined) then\n            directrunoff(istrmnode) = directrunoff(istrmnode) + purban(isoil,iregion)%runoff * purbanarea(ielem)\n            returnflow(istrmnode)   = returnflow(istrmnode)   + purban(isoil,iregion)%returnflow * purbanarea(ielem)\n        end if\n        \n        !flows from native/riparian veg\n        if (lnvrv_defined) &\n            directrunoff(istrmnode) = directrunoff(istrmnode) + pnv(isoil,iregion)%runoff * pnvarea(ielem) &\n                                                              + prv(isoil,iregion)%runoff * prvarea(ielem)\n\n      end do\n      \n    end associate\n    \n  end subroutine rootzone_v50_getflowstostreams\n"}
{"id": 992, "subroutine": "  subroutine rootzone_v50_setsupplytosubregion(rootzone,rsupply,isupplytype,isupplyfor)\n    class(rootzone_v50_type) :: rootzone\n    real(8),intent(in)       :: rsupply(:)\n    integer,intent(in)       :: isupplytype,isupplyfor\n\n    !inform user\n    call echoprogress('setting supply to subregions ... ',ladvance=.false.)\n    \n    !set supply\n    select case(isupplytype)\n        case (f_isupply_diversion)\n            if (isupplyfor .eq. f_iag) then\n                rootzone%watersupply%diversion_ag = rsupply\n            else\n                rootzone%watersupply%diversion_urb = rsupply\n            end if\n\n        case (f_isupply_pumping)\n            if (isupplyfor .eq. f_iag) then\n                rootzone%watersupply%pumping_ag = rsupply\n            else\n                rootzone%watersupply%pumping_urb = rsupply\n            end if\n            \n        case (f_isupply_upstrmelemrunoff)\n            rootzone%watersupply%upstrmrunoff = rsupply\n\n    end select\n      \n    call echoprogress('done')\n   \n  end subroutine rootzone_v50_setsupplytosubregion\n"}
{"id": 993, "subroutine": "  subroutine rootzone_v50_setlakeelemflag(rootzone,ilakeelem)\n    class(rootzone_v50_type) :: rootzone\n    integer,intent(in)       :: ilakeelem(:)\n    \n    rootzone%flags%llakeelems(ilakeelem)            = .true.    \n    rootzone%elemprecipdata(ilakeelem)%precipfactor = 0.0\n    \n  end subroutine rootzone_v50_setlakeelemflag\n"}
{"id": 994, "subroutine": "  subroutine rootzone_v50_readrestartdata(rootzone,infile,istat)\n    class(rootzone_v50_type) :: rootzone\n    type(genericfiletype)    :: infile\n    integer,intent(out)      :: istat\n    \n    call infile%readdata(rootzone%rsoilm_p,istat)  ;  if (istat .eq. -1) return\n    call infile%readdata(rootzone%rsoilm,istat)  ;  if (istat .eq. -1) return\n    \n    if (rootzone%flags%lag_defined) then\n        call rootzone%agrootzone%readrestartdata(infile,istat)  \n        if (istat .eq. -1) return\n    end if\n    \n    if (rootzone%flags%lurban_defined) then\n        call rootzone%urbanrootzone%readrestartdata(infile,istat)  \n        if (istat .eq. -1) return\n    end if\n        \n    if (rootzone%flags%lnvrv_defined) call rootzone%nvrvrootzone%readrestartdata(infile,istat)  \n    \n  end subroutine rootzone_v50_readrestartdata\n"}
{"id": 995, "subroutine": "  subroutine rootzone_v50_readtsdata(rootzone,appgrid,timestep,precip,etdata,istat,regionluareas)\n    class(rootzone_v50_type),target    :: rootzone\n    type(appgridtype),intent(in)       :: appgrid\n    type(timesteptype),intent(in)      :: timestep\n    type(precipitationtype),intent(in) :: precip\n    type(ettype),intent(in)            :: etdata\n    integer,intent(out)                :: istat\n    real(8),optional,intent(in)        :: regionluareas(:,:)   !subregional land use areas to overwrite the data read from the file\n    \n    !local variables\n    character(len=modnamelen+24)      :: thisprocedure = modname // 'rootzone_v50_readtsdata'\n    integer                           :: indxelem,nelements,iregion,isoil,indxregion,indxsoil,nsubregions,isubregionids(appgrid%nsubregions)\n    real(8)                           :: area,luarea(appgrid%nsubregions),rregionareas(appgrid%nsubregions)\n    logical                           :: lreturnfracupdated,lreusefracupdated\n    class(genericlandusetype),pointer :: planduse\n    \n    !initialize\n    istat         = 0\n    nelements     = appgrid%nelements\n    nsubregions   = appgrid%nsubregions\n    isubregionids = appgrid%appsubregion%id\n    rregionareas  = appgrid%appsubregion%area\n\n    !read return flow fractions\n    call readreturnflowfractions(timestep,rootzone%returnfracfile,lreturnfracupdated,istat)\n    if (istat .eq. -1) return\n\n    !read re-use fractions\n    call readreusefractions(timestep,rootzone%reusefracfile,lreusefracupdated,istat)\n    if (istat .eq. -1) return\n    \n    !read generic moisture data\n    if (rootzone%flags%lgenericmoisturefile_defined) then\n        call rootzone%genericmoisturedata%readtsdata(timestep,istat)\n        if (istat .eq. -1) return\n    end if\n      \n    !agricultural land use data\n    if (rootzone%flags%lag_defined) then\n        if (present(regionluareas)) then\n            call rootzone%agrootzone%readtsdata(rootzone%nsoils                               , &\n                                                rootzone%elemsoiltype                         , &\n                                                isubregionids                                 , &\n                                                rregionareas                                  , &\n                                                rootzone%soilregionarea                       , &\n                                                rootzone%subregionsoilsdata%wiltingpoint      , &\n                                                rootzone%subregionsoilsdata%fieldcapacity     , &\n                                                rootzone%flags%llakeelems                     , &\n                                                etdata                                        , &\n                                                timestep                                      , &\n                                                appgrid                                       , &\n                                                regionluareas(1:rootzone%agrootzone%ncrops,:) , &\n                                                istat                                         )\n        else\n            call rootzone%agrootzone%readtsdata(rootzone%nsoils                               , &\n                                                rootzone%elemsoiltype                         , &\n                                                isubregionids                                 , &\n                                                rregionareas                                  , &\n                                                rootzone%soilregionarea                       , &\n                                                rootzone%subregionsoilsdata%wiltingpoint      , &\n                                                rootzone%subregionsoilsdata%fieldcapacity     , &\n                                                rootzone%flags%llakeelems                     , &\n                                                etdata                                        , &\n                                                timestep                                      , &\n                                                appgrid                                       , &\n                                                istat=istat                                   )\n        end if\n        if (istat .eq. -1) return\n    end if\n\n    !urban lands related data\n    if (rootzone%flags%lurban_defined) then\n        call rootzone%urbanrootzone%readtsdata(rootzone%elemsoiltype                         , &\n                                               isubregionids                                 , &\n                                               rregionareas                                  , &\n                                               rootzone%flags%llakeelems                     , &\n                                               timestep                                      , &\n                                               appgrid                                       , &\n                                               istat                                         )\n        if (istat .eq. -1) return\n    end if\n    \n    !native and riparian veg data\n    if (rootzone%flags%lnvrv_defined) then\n        call rootzone%nvrvrootzone%readtsdata(rootzone%elemsoiltype     , &\n                                              isubregionids             , &\n                                              rregionareas              , &\n                                              rootzone%flags%llakeelems , &\n                                              timestep                  , &\n                                              appgrid                   , &\n                                              istat                     )\n        if (istat .eq. -1) return\n    end if\n\n    !process land use areas\n    call processlanduseareas(appgrid,timestep,rootzone,istat)\n    if (istat .eq. -1) return\n    \n    !compute precipitation over each element and (soil,subregion) combination\n    if (precip%isupdated()) then\n        rootzone%elemprecipdata%precip = precip%getvalues(rootzone%elemprecipdata%icolprecip) * rootzone%elemprecipdata%precipfactor\n        rootzone%soilregionprecip = 0.0\n        do indxelem=1,nelements\n            area                                     = appgrid%appelement(indxelem)%area\n            iregion                                  = appgrid%appelement(indxelem)%subregion\n            isoil                                    = rootzone%elemsoiltype(indxelem)\n            rootzone%soilregionprecip(isoil,iregion) = rootzone%soilregionprecip(isoil,iregion) + rootzone%elemprecipdata(indxelem)%precip * area\n        end do\n        !convert (soil,region) precipitation to rates\n        do indxregion=1,appgrid%nsubregions\n            do indxsoil=1,rootzone%nsoils\n                if (rootzone%soilregionarea(indxsoil,indxregion) .gt. 0.0)   &\n                    rootzone%soilregionprecip(indxsoil,indxregion) = rootzone%soilregionprecip(indxsoil,indxregion) / rootzone%soilregionarea(indxsoil,indxregion)\n            end do\n        end do\n    end if\n    \n    !compute regional potential et for each land use (athat for ag land is computed in agrootzone class), if needed\n    if (etdata%isupdated()) then\n        if (rootzone%flags%lurban_defined) call computeregionaletpot(etdata,nsubregions,rootzone%urbanrootzone%urbdata(1,:)%icoletc,rootzone%urbanrootzone%subregionalarea,rootzone%urbanrootzone%regionetpot)\n        if (rootzone%flags%lnvrv_defined) then\n            luarea = sum(rootzone%nvrvrootzone%nativeveg%area , dim=1) \n            call computeregionaletpot(etdata,nsubregions,rootzone%nvrvrootzone%nativeveg(1,:)%icoletc,luarea,rootzone%nvrvrootzone%regionetpot_nv)\n            luarea = sum(rootzone%nvrvrootzone%riparianveg%area , dim=1)\n            call computeregionaletpot(etdata,nsubregions,rootzone%nvrvrootzone%riparianveg(1,:)%icoletc,luarea,rootzone%nvrvrootzone%regionetpot_rv)\n        end if\n    end if\n    \n    !make sure that re-use fraction is not larger than return flow factor\n    if (lreturnfracupdated .or. lreusefracupdated) then\n      associate (preturnfrac => rootzone%returnfracfile%rvalues          , &\n                 preusefrac  => rootzone%reusefracfile%rvalues           , &\n                 pag         => rootzone%agrootzone                      , &\n                 purban      => rootzone%urbanrootzone                   ) \n      \n        !ag lands\n        if (rootzone%flags%lag_defined) then\n          do indxregion=1,nsubregions\n              if (preturnfrac(pag%icolreturnfrac(indxregion)) .lt. preusefrac(pag%icolreusefrac(indxregion))) then\n                  messagearray(1) = 'agricultural re-use fraction for subregion ' //trim(inttotext(isubregionids(indxregion)))//' is greater than return flow fraction!'\n                  write (messagearray(2),'(a,f5.3)') 're-use fraction      = ',preusefrac(pag%icolreusefrac(indxregion))\n                  write (messagearray(3),'(a,f5.3)') 'return flow fraction = ',preturnfrac(pag%icolreturnfrac(indxregion))\n                  call setlastmessage(messagearray(1:3),ifatal,thisprocedure)\n                  istat = -1\n                  return\n              end if\n          end do\n        end if\n          \n        !urban lands\n        if (rootzone%flags%lurban_defined) then\n            do indxregion=1,nsubregions\n                if (preturnfrac(purban%icolreturnfrac(indxregion)) .lt. preusefrac(purban%icolreusefrac(indxregion))) then\n                    messagearray(1) = 'urban re-use fraction at subregion '//trim(inttotext(isubregionids(indxregion)))//' is greater than return flow fraction!'\n                    write (messagearray(2),'(a,f5.3)') 're-use fraction      = ',preusefrac(purban%icolreusefrac(indxregion))\n                    write (messagearray(3),'(a,f5.3)') 'return flow fraction = ',preturnfrac(purban%icolreturnfrac(indxregion))\n                    call setlastmessage(messagearray(1:3),ifatal,thisprocedure)\n                    istat = -1\n                    return\n                  end if\n            end do\n        end if\n        \n      end associate\n    end if\n\n    !don't go beyond this point if it is not the first time step\n    if (timestep%currenttimestep .gt. 1) return\n    \n    !computations for first time step only\n    !zero out initial soil moisture where area is zero\n    do indxregion=1,nsubregions\n        do indxsoil=1,rootzone%nsoils\n            !ag lands\n            if (rootzone%flags%lag_defined) then\n                planduse => rootzone%agrootzone%agdata(indxsoil,indxregion)\n                if (planduse%area .eq. 0.0) then\n                    planduse%soilm_precip_p = 0.0\n                    planduse%soilm_aw_p     = 0.0\n                    planduse%soilm_precip   = 0.0\n                    planduse%soilm_aw       = 0.0\n                end if\n            end if\n            !urban lands\n            if (rootzone%flags%lurban_defined) then\n                planduse => rootzone%urbanrootzone%urbdata(indxsoil,indxregion)\n                if (planduse%area .eq. 0.0) then\n                    planduse%soilm_precip_p = 0.0\n                    planduse%soilm_aw_p     = 0.0\n                    planduse%soilm_precip   = 0.0\n                    planduse%soilm_aw       = 0.0\n                end if\n            end if  \n            !native and riparian vegetation\n            if (rootzone%flags%lnvrv_defined) then\n                planduse => rootzone%nvrvrootzone%nativeveg(indxsoil,indxregion)\n                if (planduse%area .eq. 0.0) then\n                    planduse%soilm_precip_p = 0.0\n                    planduse%soilm_precip   = 0.0\n                end if  \n                planduse => rootzone%nvrvrootzone%riparianveg(indxsoil,indxregion)\n                if (planduse%area .eq. 0.0) then\n                    planduse%soilm_precip_p = 0.0\n                    planduse%soilm_precip   = 0.0\n                end if   \n            end if\n        end do\n    end do\n\n    !convert initial soil mositure contents to depths\n    if (.not. rootzone%flags%lmoisturecontenttodepth) then\n        call rootzone%agrootzone%soilmcontent_to_depth(rootzone%nsoils,nsubregions,isubregionids,rootzone%subregionsoilsdata%totalporosity,istat)     ;  if (istat .eq. -1) return\n        call rootzone%urbanrootzone%soilmcontent_to_depth(rootzone%nsoils,nsubregions,isubregionids,rootzone%subregionsoilsdata%totalporosity,istat)  ;  if (istat .eq. -1) return\n        call rootzone%nvrvrootzone%soilmcontent_to_depth(rootzone%nsoils,nsubregions,isubregionids,rootzone%subregionsoilsdata%totalporosity,istat)   ;  if (istat .eq. -1) return\n        rootzone%flags%lmoisturecontenttodepth = .true.\n    end if\n        \n    !make sure that soil moisture at the end of previous timestep is saved, in case it is updated due to chnage in land use area\n    rootzone%agrootzone%agdata%soilm_precip_p_beforeupdate        = rootzone%agrootzone%agdata%soilm_precip_p\n    rootzone%agrootzone%agdata%soilm_aw_p_beforeupdate            = rootzone%agrootzone%agdata%soilm_aw_p\n    rootzone%agrootzone%agdata%soilm_oth_p_beforeupdate           = rootzone%agrootzone%agdata%soilm_oth_p\n    rootzone%urbanrootzone%urbdata%soilm_precip_p_beforeupdate    = rootzone%urbanrootzone%urbdata%soilm_precip_p\n    rootzone%urbanrootzone%urbdata%soilm_aw_p_beforeupdate        = rootzone%urbanrootzone%urbdata%soilm_aw_p\n    rootzone%urbanrootzone%urbdata%soilm_oth_p_beforeupdate       = rootzone%urbanrootzone%urbdata%soilm_oth_p\n    rootzone%nvrvrootzone%nativeveg%soilm_precip_p_beforeupdate   = rootzone%nvrvrootzone%nativeveg%soilm_precip_p\n    rootzone%nvrvrootzone%nativeveg%soilm_aw_p_beforeupdate       = rootzone%nvrvrootzone%nativeveg%soilm_aw_p\n    rootzone%nvrvrootzone%nativeveg%soilm_oth_p_beforeupdate      = rootzone%nvrvrootzone%nativeveg%soilm_oth_p\n    rootzone%nvrvrootzone%riparianveg%soilm_precip_p_beforeupdate = rootzone%nvrvrootzone%riparianveg%soilm_precip_p\n    rootzone%nvrvrootzone%riparianveg%soilm_aw_p_beforeupdate     = rootzone%nvrvrootzone%riparianveg%soilm_aw_p\n    rootzone%nvrvrootzone%riparianveg%soilm_oth_p_beforeupdate    = rootzone%nvrvrootzone%riparianveg%soilm_oth_p\n    \n    !initial regional moisture storage\n    rootzone%rsoilm_p = regionalmoiststorage(nsubregions,rootzone)\n\n  end subroutine rootzone_v50_readtsdata\n"}
{"id": 996, "subroutine": "  subroutine readreturnflowfractions(timestep,returnfracfile,lreturnfracupdated,istat)\n    type(timesteptype),intent(in) :: timestep\n    type(realtsdatainfiletype)    :: returnfracfile\n    logical,intent(out)           :: lreturnfracupdated\n    integer,intent(out)           :: istat\n    \n    !local variables\n    integer :: filereadcode\n\n    !inform user about progress\n    call echoprogress('reading return flow fractions time series data')\n    \n    !read data\n    call readtsdata(timestep,'return flow fractions data',returnfracfile,filereadcode,istat)\n\n    if (filereadcode .eq. 0) then\n        lreturnfracupdated = .true.\n    else\n        lreturnfracupdated = .false.\n    end if\n\n  end subroutine readreturnflowfractions\n"}
{"id": 997, "subroutine": "  subroutine readreusefractions(timestep,reusefracfile,lreusefracupdated,istat)\n    type(timesteptype),intent(in) :: timestep\n    type(realtsdatainfiletype)    :: reusefracfile\n    logical,intent(out)           :: lreusefracupdated\n    integer,intent(out)           :: istat\n    \n    !local variables\n    integer :: filereadcode\n\n    !inform user about progress\n    call echoprogress('reading re-use fractions time series data')\n    \n    !read data\n    call readtsdata(timestep,'applied water re-use fractions data',reusefracfile,filereadcode,istat)\n\n    if (filereadcode .eq. 0) then\n        lreusefracupdated = .true.\n    else\n        lreusefracupdated = .false.\n    end if\n\n  end subroutine readreusefractions\n"}
{"id": 998, "subroutine": "  subroutine rootzone_v50_printrestartdata(rootzone,outfile)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(genericfiletype)               :: outfile\n    \n    call  outfile%writedata(rootzone%rsoilm_p)\n    call  outfile%writedata(rootzone%rsoilm)\n    \n    if (rootzone%flags%lag_defined)    call rootzone%agrootzone%printrestartdata(outfile)\n    if (rootzone%flags%lurban_defined) call rootzone%urbanrootzone%printrestartdata(outfile)\n    if (rootzone%flags%lnvrv_defined)  call rootzone%nvrvrootzone%printrestartdata(outfile)\n    \n  end subroutine rootzone_v50_printrestartdata\n"}
{"id": 999, "subroutine": "  subroutine rootzone_v50_printresults(rootzone,appgrid,etdata,timestep,lendofsimulation)\n    class(rootzone_v50_type)      :: rootzone\n    type(appgridtype),intent(in)  :: appgrid\n    type(ettype),intent(in)       :: etdata          !not used in this version\n    type(timesteptype),intent(in) :: timestep         \n    logical,intent(in)            :: lendofsimulation\n    \n    !local variables\n    integer                                  :: nregions\n    real(8),dimension(appgrid%nsubregions+1) :: rpump_ag,rpump_urb,rdeli_ag,rdeli_urb,                                &\n                                                rupstrmrunoff_ag,rupstrmrunoff_urb,rupstrmrunoff_nv,                  &\n                                                rluarea_ag,rluarea_urb,rluarea_nv,rgenericmoist_ag,rgenericmoist_urb, &\n                                                rgenericmoist_nv,rdemand_urb\n                                                \n    !echo progress\n    call echoprogress('printing results of root zone simulation')\n    \n    !initialize\n    nregions = appgrid%nsubregions\n    \n    associate (pflags            => rootzone%flags                                , &\n               prgenericmoisture => rootzone%genericmoisturedata%rgenericmoisture )\n      !compute variables necessary for land&water use budget and land&water use zone budget files\n      if (pflags%lwusebudrawfile_defined .or. pflags%lwusezonebudrawfile_defined) then\n          rdemand_urb = regionaldemand(nregions,rootzone,f_ilanduse_urban)\n      end if\n\n      !compute variables necessary for both land&water use and root zone budget files\n      if (pflags%lwusebudrawfile_defined .or. pflags%rootzonebudrawfile_defined .or. pflags%lwusezonebudrawfile_defined .or. pflags%rootzonezonebudrawfile_defined) then\n        rpump_ag                      = regionalpumping(nregions,rootzone,f_ilanduse_ag)\n        rpump_urb                     = regionalpumping(nregions,rootzone,f_ilanduse_urban)\n        rdeli_ag                      = regionaldeliveries(nregions,rootzone,f_ilanduse_ag)\n        rdeli_urb                     = regionaldeliveries(nregions,rootzone,f_ilanduse_urban)\n        rupstrmrunoff_ag(1:nregions)  = upstrmrunofftolanduse(rootzone,appgrid,f_ilanduse_ag)     ;  rupstrmrunoff_ag(nregions+1) = sum(rupstrmrunoff_ag(1:nregions))\n        rupstrmrunoff_urb(1:nregions) = upstrmrunofftolanduse(rootzone,appgrid,f_ilanduse_urban)  ;  rupstrmrunoff_urb(nregions+1) = sum(rupstrmrunoff_urb(1:nregions))\n        rupstrmrunoff_nv              = upstrmrunofftolanduse(rootzone,appgrid,f_ilanduse_nvrv)   ;  rupstrmrunoff_nv(nregions+1) = sum(rupstrmrunoff_nv(1:nregions))\n        rluarea_ag                    = regionalluarea(nregions,rootzone,f_ilanduse_ag)\n        rluarea_urb                   = regionalluarea(nregions,rootzone,f_ilanduse_urban)\n        rluarea_nv                    = regionalluarea(nregions,rootzone,f_ilanduse_nvrv)\n        if (pflags%lgenericmoisturefile_defined) then\n            rgenericmoist_ag  = regionalgenericmoistinflow(nregions,rootzone,f_ilanduse_ag)\n            rgenericmoist_urb = regionalgenericmoistinflow(nregions,rootzone,f_ilanduse_urban)\n            rgenericmoist_nv  = regionalgenericmoistinflow(nregions,rootzone,f_ilanduse_nvrv)\n        else\n            rgenericmoist_ag  = 0.0\n            rgenericmoist_urb = 0.0\n            rgenericmoist_nv  = 0.0\n        end if\n      end if\n          \n      !land and water use budget file\n      if (pflags%lwusebudrawfile_defined) call writelwuseflowstobudrawfile(nregions,rluarea_ag,rluarea_urb,rdemand_urb,rpump_ag,rpump_urb,rdeli_ag,rdeli_urb,rupstrmrunoff_ag,rupstrmrunoff_urb,rootzone)\n      \n      !root zone budget file\n      if (pflags%rootzonebudrawfile_defined) call writerootzoneflowstobudrawfile(appgrid,rpump_ag,rdeli_ag,rgenericmoist_ag,rpump_urb,rdeli_urb,rgenericmoist_urb,rupstrmrunoff_ag,rupstrmrunoff_urb,rupstrmrunoff_nv,rluarea_ag,rluarea_urb,rluarea_nv,rgenericmoist_nv,rootzone)\n      \n      !land and water use zone budget\n      if (pflags%lwusezonebudrawfile_defined) call writelwuseflowstozonebudrawfile(appgrid,rdemand_urb,rootzone)\n      \n      !root zone zone budget\n      if (pflags%rootzonezonebudrawfile_defined) call writerootzoneflowstozonebudrawfile(appgrid,rpump_ag+rdeli_ag,rpump_urb+rdeli_urb,rootzone)\n      \n      !ag results print-out\n      if (rootzone%flags%lag_defined) call rootzone%agrootzone%printresults(nregions,timestep,lendofsimulation)\n\n      !final moisture print-out\n      if (lendofsimulation) then\n        if (pflags%finalmoistureoutfile_defined) call writefinalmoistures(nregions,appgrid%appsubregion%id,rootzone)\n      end if\n\n    end associate\n    \n  end subroutine rootzone_v50_printresults\n"}
{"id": 1000, "subroutine": "  subroutine writefinalmoistures(nregions,isubregionids,rootzone)\n    integer,intent(in)      :: nregions,isubregionids(nregions)\n    type(rootzone_v50_type) :: rootzone\n    \n    !local variables\n    integer   :: indxregion,indxsoil\n    real(8)   :: rootdepth,rvalue,rvalue1\n    character :: coutput*100\n    \n    associate (poutfile => rootzone%finalmoistureoutfile , &\n               pflags   => rootzone%flags                , &\n               pag      => rootzone%agrootzone           , &\n               purban   => rootzone%urbanrootzone        , &\n               pnvrv    => rootzone%nvrvrootzone         )\n    \n        !ag moistures\n        if (pflags%lag_defined) then\n         \n            !titles\n            call poutfile%writedata('c*******************************************************************************')\n            call poutfile%writedata('c                           final soil moisture contents')                       \n            call poutfile%writedata('c                              for agricultural lands')\n            call poutfile%writedata('c')                                                                              \n            call poutfile%writedata('c   ir   ;   subregion id')                                                         \n            call poutfile%writedata('c   is   ;   soil type id')                                                         \n            call poutfile%writedata('c   soilm;   final root zone moisture content; [l/l]')\n            call poutfile%writedata('c') \n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n            call poutfile%writedata('c   ir    is    soilm')\n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n        \n            !values\n            do indxregion=1,nregions\n                rootdepth = pag%avgcrop(indxregion)%rootdepth\n                do indxsoil=1,rootzone%nsoils\n                    if (pag%agdata(indxsoil,indxregion)%area .eq. 0.0) then\n                        rvalue = 0.0\n                    else\n                        rvalue = (pag%agdata(indxsoil,indxregion)%soilm_precip + pag%agdata(indxsoil,indxregion)%soilm_aw + pag%agdata(indxsoil,indxregion)%soilm_oth) / rootdepth\n                    end if\n                    write (coutput,'(i6,i6,f9.3)') isubregionids(indxregion),indxsoil,rvalue\n                    call poutfile%writedata(coutput)\n                end do\n            end do\n        end if\n            \n        !urban moistures\n        if (pflags%lurban_defined) then\n         \n            !titles\n            call poutfile%writedata('c*******************************************************************************')\n            call poutfile%writedata('c                           final soil moisture contents')                       \n            call poutfile%writedata('c                                for urban lands')\n            call poutfile%writedata('c')                                                                              \n            call poutfile%writedata('c   ir   ;   subregion id')                                                         \n            call poutfile%writedata('c   is   ;   soil type id')                                                         \n            call poutfile%writedata('c   soilm;   final root zone moisture content; [l/l]')\n            call poutfile%writedata('c') \n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n            call poutfile%writedata('c   ir    is    soilm')\n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n        \n            !values\n            do indxregion=1,nregions\n                do indxsoil=1,rootzone%nsoils\n                    if (purban%urbdata(indxsoil,indxregion)%area .eq. 0.0) then\n                        rvalue = 0.0\n                    else\n                        rvalue = (purban%urbdata(indxsoil,indxregion)%soilm_precip + purban%urbdata(indxsoil,indxregion)%soilm_aw + purban%urbdata(indxsoil,indxregion)%soilm_oth) / purban%rootdepth\n                    end if\n                    write (coutput,'(i6,i6,f9.3)') isubregionids(indxregion),indxsoil,rvalue\n                    call poutfile%writedata(coutput)\n                end do\n            end do\n        end if\n        \n        !native and riparian veg moistures\n        if (pflags%lnvrv_defined) then\n         \n            !titles\n            call poutfile%writedata('c*******************************************************************************')\n            call poutfile%writedata('c                           final soil moisture contents')                       \n            call poutfile%writedata('c                      for native and riparian vegetation lands')\n            call poutfile%writedata('c')                                                                              \n            call poutfile%writedata('c   ir   ;   subregion id')                                                         \n            call poutfile%writedata('c   is   ;   soil type id')                                                         \n            call poutfile%writedata('c   soilm;   final root zone moisture content; [l/l]')\n            call poutfile%writedata('c') \n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n            call poutfile%writedata('c   ir    is    soilm[nv]    soilm[rv]')\n            call poutfile%writedata('c-------------------------------------------------------------------------------')\n        \n            !values\n            do indxregion=1,nregions\n                do indxsoil=1,rootzone%nsoils\n                    if (pnvrv%nativeveg(indxsoil,indxregion)%area .eq. 0.0) then\n                        rvalue = 0.0\n                    else\n                        rvalue = (pnvrv%nativeveg(indxsoil,indxregion)%soilm_precip + pnvrv%nativeveg(indxsoil,indxregion)%soilm_aw + pnvrv%nativeveg(indxsoil,indxregion)%soilm_oth) / pnvrv%rootdepth_native\n                    end if\n                    if (pnvrv%riparianveg(indxsoil,indxregion)%area .eq. 0.0) then\n                        rvalue1 = 0.0\n                    else\n                        rvalue1 = (pnvrv%riparianveg(indxsoil,indxregion)%soilm_precip + pnvrv%riparianveg(indxsoil,indxregion)%soilm_aw + pnvrv%riparianveg(indxsoil,indxregion)%soilm_oth) / pnvrv%rootdepth_riparian\n                    end if\n                    write (coutput,'(i6,i6,f9.3,f9.3)') isubregionids(indxregion),indxsoil,rvalue,rvalue1\n                    call poutfile%writedata(coutput)\n                end do\n            end do\n        end if\n        \n    end associate\n    \n  end subroutine writefinalmoistures\n"}
{"id": 1001, "subroutine": "  subroutine writerootzoneflowstobudrawfile(appgrid,rpump_ag,rdeli_ag,rgenericmoist_ag,rpump_urb,rdeli_urb,rgenericmoist_urb,rupstrmrunoff_ag,rupstrmrunoff_urb,rupstrmrunoff_nv,rluarea_ag,rluarea_urb,rluarea_nv,rgenericmoist_nv,rootzone)\n    type(appgridtype),intent(in)    :: appgrid\n    real(8),dimension(:),intent(in) :: rpump_ag,rdeli_ag,rgenericmoist_ag,rpump_urb,rdeli_urb,rgenericmoist_urb,rupstrmrunoff_ag,rupstrmrunoff_urb,rupstrmrunoff_nv,rluarea_ag,rluarea_urb,rluarea_nv,rgenericmoist_nv\n    type(rootzone_v50_type)         :: rootzone\n    \n    !local variables\n    integer                                  :: nregions\n    real(8)                                  :: dummyarray(f_inrootzonebudcolumns,(appgrid%nsubregions+1)) \n    real(8),dimension(appgrid%nsubregions+1) :: rrunoff_ag,rrunoff_urb,rrunoff_nv,                   &\n                                                rprecip_ag,rprecip_urb,rprecip_nv,                   &\n                                                rreuse_ag,rreuse_urb,                                &\n                                                rreturn_ag,rreturn_urb,                              &\n                                                rsoilmch_ag,rsoilmch_urb,rsoilmch_nv,                &\n                                                rinfilt_ag,rinfilt_urb,rinfilt_nv,                   &\n                                                retpot_ag,retpot_urb,retpot_nv,                      &\n                                                reta_ag,reta_urb,reta_nv,                            &\n                                                rperc_ag,rperc_urb,rperc_nv,                         &\n                                                error_ag,error_urb,error_nv\n    \n    !initialize\n    nregions      = appgrid%nsubregions\n    \n    retpot_ag     = 0.0\n    rprecip_ag    = 0.0\n    rrunoff_ag    = 0.0\n    rreuse_ag     = 0.0\n    rreturn_ag    = 0.0\n    rsoilmch_ag   = 0.0\n    rinfilt_ag    = 0.0\n    reta_ag       = 0.0\n    rperc_ag      = 0.0\n    error_ag      = 0.0\n    retpot_urb    = 0.0\n    rprecip_urb   = 0.0\n    rrunoff_urb   = 0.0\n    rreuse_urb    = 0.0\n    rreturn_urb   = 0.0\n    rsoilmch_urb  = 0.0\n    rinfilt_urb   = 0.0\n    reta_urb      = 0.0\n    rperc_urb     = 0.0\n    error_urb     = 0.0\n    retpot_nv     = 0.0\n    rrunoff_nv    = 0.0\n    rprecip_nv    = 0.0\n    rsoilmch_nv   = 0.0\n    rinfilt_nv    = 0.0\n    reta_nv       = 0.0\n    rperc_nv      = 0.0\n    error_nv      = 0.0\n    \n    !regional moisture storages\n    rootzone%rsoilm = regionalmoiststorage(nregions,rootzone)\n    \n    associate (pflags => rootzone%flags)\n               \n      !compute subregional values\n      !---------------------------\n      !ag lands\n      if (pflags%lag_defined) then\n          call regionaletpot(nregions,rootzone,f_ilanduse_ag,retpot_ag)\n          rprecip_ag   = regionalprecip(nregions,rootzone,f_ilanduse_ag)\n          rrunoff_ag   = regionalrunoff(appgrid,rootzone,f_ilanduse_ag)\n          rreuse_ag    = regionalreuse(nregions,rootzone,f_ilanduse_ag)\n          rreturn_ag   = regionalreturn(appgrid,rootzone,f_ilanduse_ag)\n          rsoilmch_ag  = regionalsoilmchange(nregions,rootzone,f_ilanduse_ag) \n          rinfilt_ag   = regionalinfiltration(appgrid,rootzone,f_ilanduse_ag)\n          reta_ag      = regionaleta(nregions,rootzone,f_ilanduse_ag) \n          rperc_ag     = regionalperc(appgrid,rootzone,f_ilanduse_ag)\n          error_ag     = rootzone%rsoilm_p(:,f_ilanduse_ag) + rsoilmch_ag + rinfilt_ag + rgenericmoist_ag - reta_ag - rperc_ag - rootzone%rsoilm(:,f_ilanduse_ag)\n      end if\n            \n      !urban\n      if (pflags%lurban_defined) then\n          call regionaletpot(nregions,rootzone,f_ilanduse_urban,retpot_urb)\n          rprecip_urb   = regionalprecip(nregions,rootzone,f_ilanduse_urban)\n          rrunoff_urb   = regionalrunoff(appgrid,rootzone,f_ilanduse_urban)\n          rreuse_urb    = regionalreuse(nregions,rootzone,f_ilanduse_urban)\n          rreturn_urb   = regionalreturn(appgrid,rootzone,f_ilanduse_urban)\n          rsoilmch_urb  = regionalsoilmchange(nregions,rootzone,f_ilanduse_urban) \n          rinfilt_urb   = regionalinfiltration(appgrid,rootzone,f_ilanduse_urban)\n          reta_urb      = regionaleta(nregions,rootzone,f_ilanduse_urban)\n          rperc_urb     = regionalperc(appgrid,rootzone,f_ilanduse_urban)\n          error_urb     = rootzone%rsoilm_p(:,f_ilanduse_urban) + rsoilmch_urb + rinfilt_urb + rgenericmoist_urb - reta_urb - rperc_urb - rootzone%rsoilm(:,f_ilanduse_urban)\n      end if\n      \n      !native and riparian veg\n      if (pflags%lnvrv_defined) then\n          call regionaletpot(nregions,rootzone,f_ilanduse_nvrv,retpot_nv)\n          rprecip_nv   = regionalprecip(nregions,rootzone,f_ilanduse_nvrv)       \n          rrunoff_nv   = regionalrunoff(appgrid,rootzone,f_ilanduse_nvrv)\n          rsoilmch_nv  = regionalsoilmchange(nregions,rootzone,f_ilanduse_nvrv) \n          rinfilt_nv   = regionalinfiltration(appgrid,rootzone,f_ilanduse_nvrv)\n          reta_nv      = regionaleta(nregions,rootzone,f_ilanduse_nvrv)\n          rperc_nv     = regionalperc(appgrid,rootzone,f_ilanduse_nvrv)\n          error_nv     = rootzone%rsoilm_p(:,f_ilanduse_nvrv) + rsoilmch_nv + rinfilt_nv + rgenericmoist_nv - reta_nv - rperc_nv - rootzone%rsoilm(:,f_ilanduse_nvrv)\n      end if\n      \n    end associate\n    \n    !store in temporary array\n    dummyarray(1,:)  = rluarea_ag                                                  !agricultural area\n    dummyarray(2,:)  = retpot_ag                                                   !potential et on ag lands\n    dummyarray(3,:)  = rprecip_ag                                                  !precipitation on ag lands\n    dummyarray(4,:)  = rrunoff_ag                                                  !runoff from ag lands\n    dummyarray(5,:)  = rdeli_ag + rpump_ag                                         !prime applied water on ag lands prior to application of re-use water\n    dummyarray(6,:)  = rupstrmrunoff_ag                                            !surface runoff from upstream elements/subregions used on ag lands\n    dummyarray(7,:)  = rreuse_ag                                                   !applied recycled water on ag lands \n    dummyarray(8,:)  = rreturn_ag                                                  !return flow from ag lands\n    dummyarray(9,:)  = rootzone%rsoilm_p(:,f_ilanduse_ag)                          !storage at the beginning of the time interval\n    dummyarray(10,:) = rsoilmch_ag                                                 !soil moisture change due to expansion/contraction of ag lands\n    dummyarray(11,:) = rinfilt_ag                                                  !infiltration on ag lands\n    dummyarray(12,:) = rgenericmoist_ag                                            !generic moisture inflow to ag lands\n    dummyarray(13,:) = reta_ag                                                     !et on ag lands\n    dummyarray(14,:) = rperc_ag                                                    !percolation on ag lands\n    dummyarray(15,:) = rootzone%rsoilm(:,f_ilanduse_ag)                            !storage at the end of the time interval\n    dummyarray(16,:) = error_ag                                                    !mass balance error for ag lands\n    dummyarray(17,:) = rluarea_urb                                                 !urban area\n    dummyarray(18,:) = retpot_urb                                                  !potential et on urban lands\n    dummyarray(19,:) = rprecip_urb                                                 !precipitation on urban lands\n    dummyarray(20,:) = rrunoff_urb                                                 !runoff from urban lands\n    dummyarray(21,:) = rdeli_urb + rpump_urb                                       !prime applied water on urban lands prior to re-used water\n    dummyarray(22,:) = rupstrmrunoff_urb                                           !surface runoff from upstream elements/subregions used on urban lands\n    dummyarray(23,:) = rreuse_urb                                                  !applied recycled water on urban indoors and outdoors\n    dummyarray(24,:) = rreturn_urb                                                 !return flow from urban lands\n    dummyarray(25,:) = rootzone%rsoilm_p(:,f_ilanduse_urban)                       !storage at the beginning of the time interval\n    dummyarray(26,:) = rsoilmch_urb                                                !soil moisture change due to expansion/contraction of urban lands\n    dummyarray(27,:) = rinfilt_urb                                                 !infiltration on urban lands\n    dummyarray(28,:) = rgenericmoist_urb                                           !generic moisture inflow to urban lands\n    dummyarray(29,:) = reta_urb                                                    !et on urban lands\n    dummyarray(30,:) = rperc_urb                                                   !percolation on urban lands\n    dummyarray(31,:) = rootzone%rsoilm(:,f_ilanduse_urban)                         !storage at the end of the time interval     \n    dummyarray(32,:) = error_urb                                                   !mass balance error at urban lands\n    dummyarray(33,:) = rluarea_nv                                                  !natural area\n    dummyarray(34,:) = retpot_nv                                                   !potential et on natural lands\n    dummyarray(35,:) = rprecip_nv                                                  !precipitation on natural lands\n    dummyarray(36,:) = rupstrmrunoff_nv                                            !runoff from upstream elements onto natural lands\n    dummyarray(37,:) = rrunoff_nv                                                  !total surface flow on natural lands\n    dummyarray(38,:) = rootzone%rsoilm_p(:,f_ilanduse_nvrv)                        !storage at the beginning of the time interval\n    dummyarray(39,:) = rsoilmch_nv                                                 !soil moisture change due to expansion/contraction of natural lands\n    dummyarray(40,:) = rinfilt_nv                                                  !infiltration on natural lands\n    dummyarray(41,:) = rgenericmoist_nv                                            !generic moisture inflow to natural lands\n    dummyarray(42,:) = reta_nv                                                     !et on natural lands\n    dummyarray(43,:) = rperc_nv                                                    !percolation on natural lands\n    dummyarray(44,:) = rootzone%rsoilm(:,f_ilanduse_nvrv)                          !storage at the end of the time interval          \n    dummyarray(45,:) = error_nv                                                    !mass balance error at native and riparian lands\n\n    !print out values to binary file\n    call rootzone%rootzonebudrawfile%writedata(dummyarray)\n\n  end subroutine writerootzoneflowstobudrawfile\n"}
{"id": 1002, "subroutine": "  subroutine writelwuseflowstobudrawfile(nregions,rluarea_ag,rluarea_urb,rdemand_urb,rpump_ag,rpump_urb,rdeli_ag,rdeli_urb,rupstrmrunoff_ag,rupstrmrunoff_urb,rootzone)\n    integer,intent(in)              :: nregions\n    real(8),dimension(:),intent(in) :: rluarea_ag,rluarea_urb,rdemand_urb,rpump_ag,rpump_urb,rdeli_ag,rdeli_urb,rupstrmrunoff_ag,rupstrmrunoff_urb\n    type(rootzone_v50_type)        :: rootzone\n    \n    !local variables\n    real(8)                       :: dummyarray(f_inlwusebudcolumns,(nregions+1))\n    real(8),dimension(nregions+1) :: rrawdemand_ag,rdemand_ag,rdemandshort_ag,rdemandshort_urb,         &\n                                     retaw,retp,retoth\n    \n    !compute budget terms\n    if (rootzone%flags%lag_defined) then\n        rrawdemand_ag   = regionalagrawdemand(nregions,rootzone)\n        rdemand_ag      = regionaldemand(nregions,rootzone,f_ilanduse_ag)\n        rdemandshort_ag = rdemand_ag - rpump_ag - rdeli_ag - rupstrmrunoff_ag\n        retaw           = regionaletaw(nregions,rootzone)\n        retp            = regionaletp(nregions,rootzone)\n        retoth          = regionaletoth(nregions,rootzone)\n    else\n        rrawdemand_ag   = 0.0\n        rdemand_ag      = 0.0\n        rdemandshort_ag = 0.0\n        retaw           = 0.0\n        retp            = 0.0\n        retoth          = 0.0\n    end if\n    \n    if (rootzone%flags%lurban_defined) then\n        rdemandshort_urb = rdemand_urb - rpump_urb - rdeli_urb - rupstrmrunoff_urb\n    else\n        rdemandshort_urb = 0.0\n    end if\n    \n    !store in temporary array\n    dummyarray(1,:)  = rluarea_ag\n    dummyarray(2,:)  = rrawdemand_ag\n    dummyarray(3,:)  = rdemand_ag\n    dummyarray(4,:)  = rpump_ag\n    dummyarray(5,:)  = rdeli_ag\n    dummyarray(6,:)  = rupstrmrunoff_ag\n    dummyarray(7,:)  = rdemandshort_ag\n    dummyarray(8,:)  = retaw\n    dummyarray(9,:)  = retp\n    dummyarray(10,:) = retoth\n    dummyarray(11,:) = rluarea_urb\n    dummyarray(12,:) = rdemand_urb\n    dummyarray(13,:) = rpump_urb\n    dummyarray(14,:) = rdeli_urb\n    dummyarray(15,:) = rupstrmrunoff_urb\n    dummyarray(16,:) = rdemandshort_urb\n\n    !print out values to binary file\n    call rootzone%lwusebudrawfile%writedata(dummyarray)\n    \n  end subroutine writelwuseflowstobudrawfile\n"}
{"id": 1003, "subroutine": "  subroutine writelwuseflowstozonebudrawfile(appgrid,rdemand_urb,rootzone)\n    type(appgridtype),intent(in) :: appgrid\n    real(8),intent(in)           :: rdemand_urb(:)\n    type(rootzone_v50_type)      :: rootzone\n    \n    !local variables\n    integer,parameter                      :: nlayers = 1 , &\n                                              nfaces  = 0 , &\n                                              ilayer  = 1\n    real(8),dimension(appgrid%nelements,1) :: ragarea,rcuaw,ragsupreq,ragpump,ragdiver,ragsrfcinflow,ragshort,retaw,retp,retoth, &\n                                              rurbarea,rurbsupreq,rurbpump,rurbdiver,rurbsrfcinflow,rurbshort\n    real(8)                                :: relemfrac\n    integer                                :: isoil,iregion,indxelem\n    \n    !ag area\n    if (rootzone%flags%lag_defined)  call rootzone%getelementagareas(ragarea(:,1))\n    \n    !urban area\n    if (rootzone%flags%lurban_defined) call rootzone%getelementurbanareas(rurbarea(:,1))\n            \n    !compile data\n    do indxelem=1,appgrid%nelements\n        iregion = appgrid%appelement(indxelem)%subregion\n        isoil   = rootzone%elemsoiltype(indxelem)\n        \n        !ag data\n        if (rootzone%flags%lag_defined) then\n            rcuaw(indxelem,1)     = rootzone%agrootzone%agdata(isoil,iregion)%demandraw / rootzone%agrootzone%agdata(isoil,iregion)%area * ragarea(indxelem,1) !potential cuaw\n            ragsupreq(indxelem,1) = rootzone%agrootzone%agdata(isoil,iregion)%demand / rootzone%agrootzone%agdata(isoil,iregion)%area * ragarea(indxelem,1)    !ag supply requirement\n            ragpump(indxelem,1)   = rootzone%watersupply(iregion)%pumping_ag / rootzone%agrootzone%subregionalarea(iregion) * ragarea(indxelem,1)              !ag pumping\n            ragdiver(indxelem,1)  = rootzone%watersupply(iregion)%diversion_ag / rootzone%agrootzone%subregionalarea(iregion) * ragarea(indxelem,1)            !ag diversion\n            ragshort(indxelem,1)  = ragsupreq(indxelem,1) - ragpump(indxelem,1) - ragdiver(indxelem,1)                                                         !ag supply shortage\n            if (size(rootzone%elemflowtosubregions) .gt. 0) then                                                                                               \n                ragsrfcinflow(indxelem,1) = rootzone%watersupply(iregion)%upstrmrunoff / appgrid%appsubregion(iregion)%area / ragarea(indxelem,1)              !surface inflow as runoff into ag areas \n                ragshort(indxelem,1)      = ragshort(indxelem,1) - ragsrfcinflow(indxelem,1)                                                                   !adjust ag shortage\n            end if                                                                                                                                             \n            retaw(indxelem,1)  = rootzone%agrootzone%agdata(isoil,iregion)%etaw * ragarea(indxelem,1)                                                          !etaw\n            retp(indxelem,1)   = rootzone%agrootzone%agdata(isoil,iregion)%etp * ragarea(indxelem,1)                                                           !ag effective precipitation\n            retoth(indxelem,1) = rootzone%agrootzone%agdata(isoil,iregion)%etoth * ragarea(indxelem,1)                                                         !ag et met from other sources\n        end if\n        \n        !urban data\n        if (rootzone%flags%lurban_defined) then\n            relemfrac              = rurbarea(indxelem,1) / rootzone%urbanrootzone%subregionalarea(iregion)\n            rurbsupreq(indxelem,1) = rdemand_urb(iregion) * relemfrac                                                                               !urban supply requirement\n            rurbpump(indxelem,1)   = rootzone%watersupply(iregion)%pumping_urb * relemfrac                                                          !urban pumping\n            rurbdiver(indxelem,1)  = rootzone%watersupply(iregion)%diversion_urb * relemfrac                                                        !urban diversion\n            rurbshort(indxelem,1)  = rurbsupreq(indxelem,1) - rurbpump(indxelem,1) - rurbdiver(indxelem,1)                                          !urban supply shortage\n            if (size(rootzone%elemflowtosubregions) .gt. 0) then\n                rurbsrfcinflow(indxelem,1) = rootzone%watersupply(iregion)%upstrmrunoff /appgrid%appsubregion(iregion)%area / rurbarea(indxelem,1)  !surface inflow as runoff into urban areas \n                rurbshort(indxelem,1)      = rurbshort(indxelem,1) - rurbsrfcinflow(indxelem,1)                                                     !adjust urban shortage\n            end if\n        end if\n    end do\n    \n    !print data\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,1,ilayer,ragarea)             !ag area\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,2,ilayer,rcuaw)               !potential cuaw\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,3,ilayer,ragsupreq)           !ag supply requirement\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,4,ilayer,ragpump)             !ag pumping\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,5,ilayer,ragdiver)            !ag diversion\n    if (size(rootzone%elemflowtosubregions) .gt. 0) &                                               !ag inflow as surface runoff\n        call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,6,ilayer,ragsrfcinflow)   \n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,7,ilayer,ragshort)            !ag shortage\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,8,ilayer,retaw)               !etaw\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,9,ilayer,retp)                !ag effective precipitation\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,10,ilayer,retoth)             !ag et met from other sources\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,11,ilayer,rurbarea)           !urban area\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,12,ilayer,rurbsupreq)         !urban supply requirement\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,13,ilayer,rurbpump)           !urban pumping\n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,14,ilayer,rurbdiver)          !urban diversion\n    if (size(rootzone%elemflowtosubregions) .gt. 0) &                                               !urban inflow as surface runoff\n        call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,15,ilayer,rurbsrfcinflow)       \n    call rootzone%lwuzonebudrawfile%writedata(nlayers,f_ielemdatatype,16,ilayer,rurbshort)          !urban shortage\n        \n  end subroutine writelwuseflowstozonebudrawfile\n"}
{"id": 1004, "subroutine": "  subroutine writerootzoneflowstozonebudrawfile(appgrid,raw_ag,raw_urb,rootzone)\n    type(appgridtype),intent(in) :: appgrid\n    real(8),intent(in)           :: raw_ag(:),raw_urb(:)\n    type(rootzone_v50_type)      :: rootzone\n    \n    !local variables\n    integer,parameter                      :: nlayers = 1 , &\n                                              nfaces  = 0 , &\n                                              ilayer  = 1\n    real(8),dimension(appgrid%nelements,1) :: ragarea,ragpotet,ragprecip,ragrunoff,ragaw,ragsrfcinflow,ragreuse,ragreturn,ragbeginstor,ragsoilmch,raginfilt,ragothin,rageta,ragdp,ragendstor,ragerror,                   &\n                                              rurbarea,rurbpotet,rurbprecip,rurbrunoff,rurbaw,rurbsrfcinflow,rurbreuse,rurbreturn,rurbbeginstor,rurbsoilmch,rurbinfilt,rurbothin,rurbeta,rurbdp,rurbendstor,rurberror,   &\n                                              rnvarea,rrvarea,rnvrvpotet,rnvrvprecip,rnvrvrunoff,rnvrvsrfcinflow,rnvrvbeginstor,rnvrvsoilmch,rnvrvinfilt,rnvrvothin,rnvrveta,rnvrvdp,rnvrvendstor,rnvrverror\n    real(8)                                :: relemfrac \n    integer                                :: iregion,indxelem,isoil,ielem\n    logical                                :: lelemtoelemflows_defined\n    \n    !initialize\n    if (size(rootzone%elemflowtosubregions) .gt. 0) then\n        lelemtoelemflows_defined = .true.\n    else\n        lelemtoelemflows_defined = .false.\n    end if\n    \n    !ag area\n    if (rootzone%flags%lag_defined)  call rootzone%getelementagareas(ragarea(:,1))\n    \n    !urban area\n    if (rootzone%flags%lurban_defined) call rootzone%getelementurbanareas(rurbarea(:,1))\n            \n    !native and riparian veg area\n    if (rootzone%flags%lnvrv_defined) then\n        rnvarea(:,1) = rootzone%nvrvrootzone%elementalarea_nv\n        rrvarea(:,1) = rootzone%nvrvrootzone%elementalarea_rv\n    end if\n            \n    !compile data\n    do indxelem=1,appgrid%nelements\n        iregion = appgrid%appelement(indxelem)%subregion\n        isoil   = rootzone%elemsoiltype(indxelem)\n        \n        !ag data\n        if (rootzone%flags%lag_defined) then\n            relemfrac                = ragarea(indxelem,1) / rootzone%agrootzone%subregionalarea(iregion)\n            ragpotet(indxelem,1)     = rootzone%agrootzone%avgcrop(iregion)%etc * ragarea(indxelem,1)                                                                    !ag potential et \n            ragprecip(indxelem,1)    = rootzone%soilregionprecip(isoil,iregion) * ragarea(indxelem,1)                                                                    !ag precip\n            ragrunoff(indxelem,1)    = rootzone%agrootzone%agdata(isoil,iregion)%runoff * ragarea(indxelem,1)                                                            !ag runoff\n            ragaw(indxelem,1)        = raw_ag(iregion) * relemfrac                                                                                                       !ag prime appliaed water\n            if (lelemtoelemflows_defined) &                                                                                                                              !ag surface inflow from upstream   \n                ragsrfcinflow(indxelem,1) = rootzone%watersupply(iregion)%upstrmrunoff / appgrid%appsubregion(iregion)%area * ragarea(indxelem,1)                                                          \n            ragreuse(indxelem,1)     = rootzone%agrootzone%agdata(isoil,iregion)%reuse * ragarea(indxelem,1)                                                             !ag reuse\n            ragreturn(indxelem,1)    = rootzone%agrootzone%agdata(isoil,iregion)%returnflow * ragarea(indxelem,1)                                                        !ag return\n            ragbeginstor(indxelem,1) = (rootzone%agrootzone%agdata(isoil,iregion)%soilm_precip_p_beforeupdate  &                                                         !ag beginning storage\n                                      + rootzone%agrootzone%agdata(isoil,iregion)%soilm_aw_p_beforeupdate      &                                                                      \n                                      + rootzone%agrootzone%agdata(isoil,iregion)%soilm_oth_p_beforeupdate     ) * rootzone%agrootzone%elementalarea_p(indxelem) \n            if (rootzone%agrootzone%agdata(isoil,iregion)%area .gt. 0.0) then                                                                                            !ag change in soil moisture due to land expansion\n                ragsoilmch(indxelem,1) = rootzone%agrootzone%agdata(isoil,iregion)%soilmch / rootzone%agrootzone%agdata(isoil,iregion)%area * ragarea(indxelem,1)          \n            else\n                ragsoilmch(indxelem,1) = 0.0\n            end if\n            raginfilt(indxelem,1)    = (rootzone%agrootzone%agdata(isoil,iregion)%precipinfilt + rootzone%agrootzone%agdata(isoil,iregion)%iriginfilt) * ragarea(indxelem,1) !ag infiltration\n            if (rootzone%flags%lgenericmoisturefile_defined)   &                                                                                                             !ag other inflow\n                ragothin(indxelem,1) = (rootzone%genericmoisturedata%rgenericmoisture(isoil,iregion) * rootzone%agrootzone%avgcrop(iregion)%rootdepth - rootzone%agrootzone%agdata(isoil,iregion)%gmexcess) * ragarea(indxelem,1) \n            rageta(indxelem,1)       = rootzone%agrootzone%agdata(isoil,iregion)%eta * ragarea(indxelem,1)                                                               !ag actual et\n            ragdp(indxelem,1)        = (rootzone%agrootzone%agdata(isoil,iregion)%perc + rootzone%agrootzone%agdata(isoil,iregion)%percch) * ragarea(indxelem,1)         !ag perc                                                             \n            ragendstor(indxelem,1)   = (rootzone%agrootzone%agdata(isoil,iregion)%soilm_precip  &                                                                        !ag ending storage\n                                      + rootzone%agrootzone%agdata(isoil,iregion)%soilm_aw      &                                                                      \n                                      + rootzone%agrootzone%agdata(isoil,iregion)%soilm_oth     ) * ragarea(indxelem,1)\n            ragerror(indxelem,1)     = ragbeginstor(indxelem,1) + ragsoilmch(indxelem,1) + raginfilt(indxelem,1) - rageta(indxelem,1) - ragdp(indxelem,1) - ragendstor(indxelem,1) !ag error                                                              \n            if (rootzone%flags%lgenericmoisturefile_defined) ragerror(indxelem,1) = ragerror(indxelem,1) + ragothin(indxelem,1)                                                                                                           \n        end if\n        \n        !urban data\n        if (rootzone%flags%lurban_defined) then\n            relemfrac                 = rurbarea(indxelem,1) / rootzone%urbanrootzone%subregionalarea(iregion)\n            rurbpotet(indxelem,1)     = rootzone%urbanrootzone%regionetpot(iregion) * relemfrac                                                                          !urban potential et\n            rurbprecip(indxelem,1)    = rootzone%soilregionprecip(isoil,iregion) * rurbarea(indxelem,1)                                                                  !urban precip\n            rurbrunoff(indxelem,1)    = rootzone%urbanrootzone%urbdata(isoil,iregion)%runoff * rurbarea(indxelem,1)                                                      !urban runoff\n            rurbaw(indxelem,1)        = raw_urb(iregion) * relemfrac                                                                                                     !urban prime appliaed water\n            if (lelemtoelemflows_defined) &                                                                                                                              !urban surface inflow from upstream                                       \n                rurbsrfcinflow(indxelem,1) = rootzone%watersupply(iregion)%upstrmrunoff / appgrid%appsubregion(iregion)%area * rurbarea(indxelem,1)                                                        \n            rurbreuse(indxelem,1)     = rootzone%urbanrootzone%urbdata(isoil,iregion)%reuse * rurbarea(indxelem,1)                                                       !urban reuse\n            rurbreturn(indxelem,1)    = rootzone%urbanrootzone%urbdata(isoil,iregion)%returnflow * rurbarea(indxelem,1)                                                  !urban return\n            rurbbeginstor(indxelem,1) = (rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_precip_p_beforeupdate  &                                                    !urban beginning storage\n                                       + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_aw_p_beforeupdate      &\n                                       + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_oth_p_beforeupdate     ) * rootzone%urbanrootzone%elementalarea_p(indxelem)  &\n                                                                                                                      * rootzone%urbanrootzone%perviousfrac(iregion)                                   \n            if (rootzone%urbanrootzone%urbdata(isoil,iregion)%area .gt. 0.0) then                                                                                        !urban change in soil moisture due to land expansion\n                rurbsoilmch(indxelem,1) = rootzone%urbanrootzone%urbdata(isoil,iregion)%soilmch / rootzone%urbanrootzone%urbdata(isoil,iregion)%area * rurbarea(indxelem,1)  \n            else\n                rurbsoilmch(indxelem,1) = 0.0\n            end if\n            rurbinfilt(indxelem,1)    = (rootzone%urbanrootzone%urbdata(isoil,iregion)%precipinfilt + rootzone%urbanrootzone%urbdata(isoil,iregion)%iriginfilt) * rurbarea(indxelem,1) !urban infiltration\n            if (rootzone%flags%lgenericmoisturefile_defined)   &                                                                                                                       !urban other inflow\n                rurbothin(indxelem,1) = (rootzone%genericmoisturedata%rgenericmoisture(isoil,iregion) * rootzone%urbanrootzone%rootdepth - rootzone%urbanrootzone%urbdata(isoil,iregion)%gmexcess) * rurbarea(indxelem,1) * rootzone%urbanrootzone%perviousfrac(iregion) \n            rurbeta(indxelem,1)       = rootzone%urbanrootzone%urbdata(isoil,iregion)%eta * rurbarea(indxelem,1)                                                                       !urban actual et\n            rurbdp(indxelem,1)        = (rootzone%urbanrootzone%urbdata(isoil,iregion)%perc + rootzone%urbanrootzone%urbdata(isoil,iregion)%percch) * rurbarea(indxelem,1)             !urban perc                                                              ! ag actual et\n            rurbendstor(indxelem,1)   = (rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_precip  &                                                                                 !urban ending storage\n                                       + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_aw      &\n                                       + rootzone%urbanrootzone%urbdata(isoil,iregion)%soilm_oth     ) * rurbarea(indxelem,1) &\n                                                                                                        * rootzone%urbanrootzone%perviousfrac(iregion)                                    \n            rurberror(indxelem,1)    = rurbbeginstor(indxelem,1) + rurbsoilmch(indxelem,1) + rurbinfilt(indxelem,1) - rurbeta(indxelem,1) - rurbdp(indxelem,1) - rurbendstor(indxelem,1) !urban error                                                              ! ag actual et\n            if (rootzone%flags%lgenericmoisturefile_defined) rurberror(indxelem,1) = rurberror(indxelem,1) + rurbothin(indxelem,1)                                                                                                            !ag other inflow\n        end if\n\n        !native and riparian veg. data\n        if (rootzone%flags%lnvrv_defined) then\n            rnvrvpotet(indxelem,1)     = rootzone%nvrvrootzone%regionetpot_nv(iregion) / rootzone%nvrvrootzone%subregionalarea_nv(iregion) * rnvarea(indxelem,1)  &                  !native and riparian potential et\n                                       + rootzone%nvrvrootzone%regionetpot_rv(iregion) / rootzone%nvrvrootzone%subregionalarea_rv(iregion) * rrvarea(indxelem,1)                                             \n            rnvrvprecip(indxelem,1)    = rootzone%soilregionprecip(isoil,iregion) * (rnvarea(indxelem,1)+rrvarea(indxelem,1))                                                        !native and riparian precip\n            if (size(rootzone%elemflowtosubregions) .gt. 0) &                                                                                                                        !surface inflow as runoff into native and riparian veg areas\n                rnvrvsrfcinflow(indxelem,1) = rootzone%watersupply(iregion)%upstrmrunoff / appgrid%appsubregion(iregion)%area * (rnvarea(indxelem,1)+rrvarea(indxelem,1))                                                                           \n            rnvrvrunoff(indxelem,1)    = rootzone%nvrvrootzone%nativeveg(isoil,iregion)%runoff * rnvarea(indxelem,1)   &                                                             !native and riparian runoff\n                                       + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%runoff * rrvarea(indxelem,1)                                                                                     \n            rnvrvbeginstor(indxelem,1) = (rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_precip_p_beforeupdate  &                                                              !native and riparian beginning storage\n                                        + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_aw_p_beforeupdate      &\n                                        + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_oth_p_beforeupdate     ) * rootzone%nvrvrootzone%elementalarea_p_nv(indxelem) &                                   \n                                        +(rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_precip_p_beforeupdate  &\n                                        + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_aw_p_beforeupdate      &\n                                        + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_oth_p_beforeupdate     ) * rootzone%nvrvrootzone%elementalarea_p_rv(indxelem)                                  \n            if (rootzone%nvrvrootzone%nativeveg(isoil,iregion)%area .gt. 0.0) then                                                                                                   !native and riparian change in soil moisture due to land expansion\n                rnvrvsoilmch(indxelem,1) = rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilmch / rootzone%nvrvrootzone%nativeveg(isoil,iregion)%area * rnvarea(indxelem,1)     \n            else\n                rnvrvsoilmch(indxelem,1) = 0.0\n            end if\n            if (rootzone%nvrvrootzone%riparianveg(isoil,iregion)%area .gt. 0.0) then\n                rnvrvsoilmch(indxelem,1) = rnvrvsoilmch(indxelem,1) + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilmch / rootzone%nvrvrootzone%riparianveg(isoil,iregion)%area * rrvarea(indxelem,1)\n            end if\n            rnvrvinfilt(indxelem,1)    = rootzone%nvrvrootzone%nativeveg(isoil,iregion)%precipinfilt * rnvarea(indxelem,1)   &                                                           !native and riparian infiltration\n                                       + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%precipinfilt * rrvarea(indxelem,1)                                                             \n            if (rootzone%flags%lgenericmoisturefile_defined) then                                                                                                                        !native and riparian other inflow\n                rnvrvothin(indxelem,1) = (rootzone%genericmoisturedata%rgenericmoisture(isoil,iregion) * rootzone%nvrvrootzone%rootdepth_native   - rootzone%nvrvrootzone%nativeveg(isoil,iregion)%gmexcess) * rnvarea(indxelem,1)  &\n                                        +(rootzone%genericmoisturedata%rgenericmoisture(isoil,iregion) * rootzone%nvrvrootzone%rootdepth_riparian - rootzone%nvrvrootzone%riparianveg(isoil,iregion)%gmexcess) * rrvarea(indxelem,1) \n            end if\n            rnvrveta(indxelem,1)       = rootzone%nvrvrootzone%nativeveg(isoil,iregion)%eta * rnvarea(indxelem,1)  &                                                                     !native and riparian actual et\n                                       + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%eta * rrvarea(indxelem,1) \n            rnvrvdp(indxelem,1)        = (rootzone%nvrvrootzone%nativeveg(isoil,iregion)%perc + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%percch) * rnvarea(indxelem,1)   &         !native and riparian perc\n                                       + (rootzone%nvrvrootzone%riparianveg(isoil,iregion)%perc + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%percch) * rrvarea(indxelem,1) \n            rnvrvendstor(indxelem,1)   = (rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_precip    &                                                                               !native and riparian ending storage\n                                        + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_aw        &\n                                        + rootzone%nvrvrootzone%nativeveg(isoil,iregion)%soilm_oth       ) * rnvarea(indxelem,1) &                                   \n                                        +(rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_precip  &\n                                        + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_aw      &\n                                        + rootzone%nvrvrootzone%riparianveg(isoil,iregion)%soilm_oth     ) * rrvarea(indxelem,1)                                    \n            rnvrverror(indxelem,1)     = rnvrvbeginstor(indxelem,1) + rnvrvsoilmch(indxelem,1) + rnvrvinfilt(indxelem,1) - rnvrveta(indxelem,1) - rnvrvdp(indxelem,1) - rnvrvendstor(indxelem,1) !urban error                                                              ! ag actual et\n            if (rootzone%flags%lgenericmoisturefile_defined) rnvrverror(indxelem,1) = rnvrverror(indxelem,1) + rnvrvothin(indxelem,1)                                                                                                            !ag other inflow\n        end if\n    end do\n    \n    !update urban infiltration and perc for those elements that surface flows go into groundwater\n    do indxelem=1,size(rootzone%urbanrootzone%elemtogw)\n        ielem               = rootzone%urbanrootzone%elemtogw(indxelem)\n        rurbinfilt(ielem,1) = rurbinfilt(ielem,1) + rurbrunoff(ielem,1) + rurbreturn(ielem,1)\n        rurbdp(ielem,1)     = rurbdp(ielem,1) + rurbrunoff(ielem,1) + rurbreturn(ielem,1)\n    end do\n    \n    !print data\n    if (rootzone%flags%lag_defined) then\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,1,ilayer,ragarea)               !ag area\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,2,ilayer,ragpotet)              !ag potential et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,3,ilayer,ragprecip)             !ag precip\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,4,ilayer,ragrunoff)             !ag runoff\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,5,ilayer,ragaw)                 !ag prime applied water\n        if (lelemtoelemflows_defined)  &                                                                       !ag surface inflow from upstream\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,6,ilayer,ragsrfcinflow)     \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,7,ilayer,ragreuse)              !ag reuse\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,8,ilayer,ragreturn)             !ag return\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,9,ilayer,ragbeginstor)          !ag beginning storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,10,ilayer,ragsoilmch)           !ag change in soil storage from land expansion\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,11,ilayer,raginfilt)            !ag infiltration\n        if (rootzone%flags%lgenericmoisturefile_defined) &                                                     !ag other inflow\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,12,ilayer,ragothin)             \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,13,ilayer,rageta)               !ag actual et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,14,ilayer,ragdp)                !ag perc\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,15,ilayer,ragendstor)           !ag end storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,16,ilayer,ragerror)             !ag error\n    end if                                                                                                   \n                                                                                                             \n    if (rootzone%flags%lurban_defined) then                                                                  \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,17,ilayer,rurbarea)             !urban area\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,18,ilayer,rurbpotet)            !urban potential et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,19,ilayer,rurbprecip)           !urban precip\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,20,ilayer,rurbrunoff)           !urban runoff\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,21,ilayer,rurbaw)               !urban prime applied water\n        if (lelemtoelemflows_defined)  &                                                                       !urban surface inflow from upstream\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,22,ilayer,rurbsrfcinflow)       \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,23,ilayer,rurbreuse)            !urban reuse\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,24,ilayer,rurbreturn)           !urban return\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,25,ilayer,rurbbeginstor)        !urban beginning storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,26,ilayer,rurbsoilmch)          !urban change in soil storage from land expansion\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,27,ilayer,rurbinfilt)           !urban infiltration\n        if (rootzone%flags%lgenericmoisturefile_defined) &                                                     !urban other inflow\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,28,ilayer,rurbothin)             \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,29,ilayer,rurbeta)              !urban actual et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,30,ilayer,rurbdp)               !urban perc\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,31,ilayer,rurbendstor)          !urban end storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,32,ilayer,rurberror)            !urban error\n    end if                                                                                                   \n                                                                                                             \n    if (rootzone%flags%lnvrv_defined) then                                                                   \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,33,ilayer,rnvarea+rrvarea)      !nvrv area\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,34,ilayer,rnvrvpotet)           !nvrv potential et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,35,ilayer,rnvrvprecip)          !nvrv precip\n        if (lelemtoelemflows_defined)  &                                                                       !nvrv surface inflow from upstream elements\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,36,ilayer,rnvrvsrfcinflow)      \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,37,ilayer,rnvrvrunoff)          !nvrv runoff\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,38,ilayer,rnvrvbeginstor)       !nvrv beginning storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,39,ilayer,rnvrvsoilmch)         !nvrv change in soil storage from land expansion\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,40,ilayer,rnvrvinfilt)          !nvrv infiltration\n        if (rootzone%flags%lgenericmoisturefile_defined) &                                                     !nvrv other inflow\n            call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,41,ilayer,rnvrvothin)             \n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,42,ilayer,rnvrveta)             !nvrv actual et\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,43,ilayer,rnvrvdp)              !nvrv perc\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,44,ilayer,rnvrvendstor)         !nvrv end storage\n        call rootzone%rootzonezonebudrawfile%writedata(nlayers,f_ielemdatatype,45,ilayer,rnvrverror)           !nvrv error\n    end if\n    \n  end subroutine writerootzoneflowstozonebudrawfile\n"}
{"id": 1005, "subroutine": "  subroutine rootzone_v50_computewaterdemand(rootzone,appgrid,timestep,etdata,istat)\n    class(rootzone_v50_type)      :: rootzone\n    type(appgridtype),intent(in)  :: appgrid   \n    type(timesteptype),intent(in) :: timestep\n    type(ettype),intent(in)       :: etdata    !not used in this version\n    integer,intent(out)           :: istat\n    \n    !local variables\n    integer :: isubregionids(appgrid%nsubregions)\n    \n    !initialize\n    istat         = 0\n    \n    !compute ag water demand\n    if (rootzone%flags%lag_defined) then\n        call echoprogress('computing agricultural water demand...',ladvance=.false.)\n        isubregionids = appgrid%appsubregion%id\n        call rootzone%agrootzone%computewaterdemand(isubregionids                                 , &\n                                                    timestep%deltat                               , &\n                                                    rootzone%soilregionprecip                     , &\n                                                    rootzone%genericmoisturedata%rgenericmoisture , &\n                                                    rootzone%subregionsoilsdata                   , &\n                                                    rootzone%reusefracfile%rvalues                , &\n                                                    rootzone%returnfracfile%rvalues               , &\n                                                    rootzone%solverdata                           , &\n                                                    istat                                         )\n        if (istat .eq. -1) return\n        call echoprogress('done')\n    end if\n\n  end subroutine rootzone_v50_computewaterdemand\n"}
{"id": 1006, "subroutine": "  subroutine rootzone_v50_simulate(rootzone,appgrid,timestep,etdata,istat)\n    class(rootzone_v50_type)      :: rootzone\n    type(appgridtype),intent(in)  :: appgrid\n    type(timesteptype),intent(in) :: timestep\n    type(ettype),intent(in)       :: etdata\n    integer,intent(out)           :: istat\n    \n    !local variables\n    character(len=modnamelen+21)           :: thisprocedure = modname // 'rootzone_v50_simulate'\n    integer                                :: indxregion,indxiter,isubregionids(appgrid%nsubregions)\n    real(8)                                :: achievedconv,runoff,runoff_p\n    real(8),dimension(appgrid%nsubregions) :: irigsupply_ag,irigsupply_urb,upstrmrunoff_p,inrunoff,supply  \n    \n    !initialize\n    istat         = 0\n    isubregionids = appgrid%appsubregion%id\n                                                              \n    associate (pflags                   => rootzone%flags                                   , &\n               pwatersupply             => rootzone%watersupply                             , &\n               pelemsoiltype            => rootzone%elemsoiltype                            , &\n               psoilsdata               => rootzone%subregionsoilsdata                      , &\n               psoilregionprecip        => rootzone%soilregionprecip                        , &\n               prgenericmoisture        => rootzone%genericmoisturedata%rgenericmoisture    , &\n               preusefracs              => rootzone%reusefracfile%rvalues                   , &\n               preturnfracs             => rootzone%returnfracfile%rvalues                  , &\n               psolverdata              => rootzone%solverdata                              , &\n               pelemtosubregions        => rootzone%elemflowtosubregions                    , &\n               pagland                  => rootzone%agrootzone                              , &\n               purbanland               => rootzone%urbanrootzone                           , &\n               pnvrv                    => rootzone%nvrvrootzone                            )\n        \n      !initialize\n      pwatersupply%upstrmrunoff = 0.0\n      if (pflags%lag_defined)  &\n          irigsupply_ag = (pwatersupply%diversion_ag  + pwatersupply%pumping_ag)  / rootzone%agrootzone%subregionalarea\n      if (pflags%lurban_defined)  &\n          irigsupply_urb = (pwatersupply%diversion_urb + pwatersupply%pumping_urb) / rootzone%urbanrootzone%subregionalarea\n      \n      !check water supply vs. ag lands\n      if (pflags%lag_defined) then\n          do indxregion=1,appgrid%nsubregions\n              !check ag area vs. ag water supply\n              if (irigsupply_ag(indxregion) .gt. 0.0) then\n                  if (pagland%subregionalarea(indxregion) .eq. 0.0) then\n                      call setlastmessage('agricultural applied water in subregion '//trim(inttotext(isubregionids(indxregion)))// 'cannot be non-zero when agricultural area is zero!',ifatal,thisprocedure)\n                      istat = -1\n                      return\n                  end if\n              end if\n          end do\n      end if\n      \n      !check urban area vs. urban water supply\n      if (pflags%lurban_defined) then\n          do indxregion=1,appgrid%nsubregions\n              if (irigsupply_urb(indxregion) .gt. 0.0) then\n                  if (purbanland%subregionalarea(indxregion) .eq. 0.0) then\n                      call setlastmessage('urban applied water in subregion '//trim(inttotext(isubregionids(indxregion)))//' cannot be non-zero when urban area is zero!',ifatal,thisprocedure)\n                      istat = -1\n                      return\n                  end if\n              end if\n          end do\n      end if\n      \n      !iterative solution\n      do indxiter=1,psolverdata%itermax\n          !store upstrmrunoff values in temporary storage and zero it out\n          upstrmrunoff_p            = pwatersupply%upstrmrunoff   !upstrmrunoff is in units of volume\n          pwatersupply%upstrmrunoff = 0.0\n          inrunoff                  = upstrmrunoff_p / appgrid%appsubregion%area\n        \n          !simulate ag lands\n          if (pflags%lag_defined) then\n              supply = inrunoff + irigsupply_ag     \n              call pagland%simulate(isubregionids             , &\n                                    timestep%deltat           , &\n                                    psoilregionprecip         , &\n                                    prgenericmoisture         , &\n                                    psoilsdata                , &\n                                    supply                    , &\n                                    preusefracs               , &\n                                    preturnfracs              , &\n                                    psolverdata               , &\n                                    istat                     )\n              if (istat .eq. -1) return\n              call flowtosubregions(pagland%agdata%runoff     , &\n                                    pagland%elementalarea     , &\n                                    pelemtosubregions         , &\n                                    pelemsoiltype             , &\n                                    appgrid                   , &\n                                    pwatersupply%upstrmrunoff )\n          end if\n          \n          !simulate urban lands\n          if (pflags%lurban_defined) then\n              supply = inrunoff + irigsupply_urb      \n              call purbanland%simulate(etdata                    , &\n                                       isubregionids             , &\n                                       timestep%deltat           , &\n                                       psoilregionprecip         , &\n                                       prgenericmoisture         , &\n                                       psoilsdata                , &\n                                       supply                    , &\n                                       preusefracs               , &\n                                       preturnfracs              , &\n                                       psolverdata               , &\n                                       istat                     )\n              if (istat .eq. -1) return\n              call flowtosubregions(purbanland%urbdata%runoff    , &\n                                    purbanland%elementalarea     , &\n                                    purbanland%elemtosubregions  , &\n                                    pelemsoiltype                , &\n                                    appgrid                      , &\n                                    pwatersupply%upstrmrunoff    )\n          end if\n\n          !simulate native and riparian veg lands\n          if (pflags%lnvrv_defined) then\n              call pnvrv%simulate(etdata               , &\n                                  isubregionids        , &\n                                  timestep%deltat      , &\n                                  psoilregionprecip    , &\n                                  prgenericmoisture    , &\n                                  psoilsdata           , &\n                                  inrunoff             , &\n                                  psolverdata          , &\n                                  istat                )\n              if (istat .eq. -1) return\n              call flowtosubregions(pnvrv%nativeveg%runoff     , &\n                                    pnvrv%elementalarea_nv     , &\n                                    pelemtosubregions          , &\n                                    pelemsoiltype              , &\n                                    appgrid                    , &\n                                    pwatersupply%upstrmrunoff  )\n              call flowtosubregions(pnvrv%riparianveg%runoff   , &\n                                    pnvrv%elementalarea_rv     , &\n                                    pelemtosubregions          , &\n                                    pelemsoiltype              , &\n                                    appgrid                    , &\n                                    pwatersupply%upstrmrunoff  )\n          end if \n          \n          !check convergence\n          achievedconv = 0.0\n          if (any(pwatersupply%upstrmrunoff .ne. 0.0)) then  !needed to add this check to avoid a signaling ieee_invalid flag\n              do indxregion=1,appgrid%nsubregions\n                  runoff   = pwatersupply(indxregion)%upstrmrunoff\n                  runoff_p = upstrmrunoff_p(indxregion)\n                  if (runoff .eq. 0.0) then\n                      if (runoff_p .eq. 0.0) then\n                          cycle\n                      else\n                          achievedconv = max(achievedconv , 1d0)  ! 1d0 = abs((runoff - runoff_p) / runoff_p))\n                      end if\n                  else\n                      achievedconv = max(achievedconv,abs((runoff - runoff_p) / runoff))\n                  end if\n              end do\n          end if\n          if (achievedconv .lt. rootzone%solverdata%tolerance) then\n              achievedconv = 0.0\n              exit\n          end if\n\n      end do\n\n    end associate\n               \n  end subroutine rootzone_v50_simulate\n"}
{"id": 1007, "subroutine": "  subroutine regionaletpot(nregions,rootzone,luindex,retp)\n    type(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                 :: nregions,luindex\n    real(8),intent(out)                :: retp(nregions+1)\n    \n    select case(luindex)\n        !agricultural lands\n        case (f_ilanduse_ag)\n            if (rootzone%flags%lag_defined) then\n                retp(1:nregions) = rootzone%agrootzone%regionetpot\n                retp(nregions+1) = sum(retp(1:nregions))\n            else\n                retp = 0.0\n                return\n            end if\n\n        !urban\n        case (f_ilanduse_urban)\n            if (rootzone%flags%lurban_defined) then\n                retp(1:nregions) = rootzone%urbanrootzone%regionetpot\n                retp(nregions+1) = sum(retp(1:nregions))\n            else\n                retp = 0.0\n                return\n            end if\n            \n        !native and riparian\n        case (f_ilanduse_nvrv)\n            if (rootzone%flags%lnvrv_defined) then\n                retp(1:nregions) = rootzone%nvrvrootzone%regionetpot_nv + rootzone%nvrvrootzone%regionetpot_rv\n                retp(nregions+1) = sum(retp(1:nregions))\n            else\n                retp = 0.0\n                return\n            end if\n    end select\n        \n  end subroutine regionaletpot\n"}
{"id": 1008, "subroutine": "  subroutine rootzone_v50_zerosupply(rootzone)\n    class(rootzone_v50_type) :: rootzone\n    \n    rootzone%watersupply%diversion_ag  = 0.0\n    rootzone%watersupply%diversion_urb = 0.0\n    rootzone%watersupply%pumping_ag    = 0.0\n    rootzone%watersupply%pumping_urb   = 0.0\n    rootzone%watersupply%upstrmrunoff  = 0.0\n    \n  end subroutine rootzone_v50_zerosupply\n"}
{"id": 1009, "subroutine": "  subroutine rootzone_v50_zerosurfaceflows(rootzone)\n    class(rootzone_v50_type) :: rootzone\n    \n    !inform user\n    call echoprogress('resetting rainfall runoff and return flow from elements')\n    \n    !zero out surface flows from ag lands\n    if (rootzone%flags%lag_defined) then\n        rootzone%agrootzone%agdata%runoff     = 0.0\n        rootzone%agrootzone%agdata%returnflow = 0.0\n    end if\n    \n    !zero out surface flows from urban lands\n    if (rootzone%flags%lurban_defined) then\n        rootzone%urbanrootzone%urbdata%runoff     = 0.0\n        rootzone%urbanrootzone%urbdata%returnflow = 0.0\n    end if\n\n    !zero out surface flows from native and riparian veg lands\n    if (rootzone%flags%lnvrv_defined) then\n        rootzone%nvrvrootzone%nativeveg%runoff   = 0.0\n        rootzone%nvrvrootzone%riparianveg%runoff = 0.0\n    end if\n  \n  end subroutine rootzone_v50_zerosurfaceflows\n"}
{"id": 1010, "subroutine": "  subroutine rootzone_v50_converttimeunit(rootzone,newunit)\n    class(rootzone_v50_type)    :: rootzone\n    character(len=*),intent(in) :: newunit\n    \n    !local variables\n    real(8) :: factor\n    \n    !make sure newunit is defined\n    if (newunit .eq. '') return\n    \n    !convert\n    factor                              = timeintervalconversion(newunit,rootzone%vartimeunit)\n    rootzone%vartimeunit                = newunit\n    rootzone%subregionsoilsdata%hydcond = rootzone%subregionsoilsdata%hydcond * factor\n        \n  end subroutine rootzone_v50_converttimeunit\n"}
{"id": 1011, "subroutine": "  subroutine zeroredistributedmoist(rootzone)\n    type(rootzone_v50_type) :: rootzone\n    \n    rootzone%agrootzone%agdata%soilmch        = 0.0\n    rootzone%urbanrootzone%urbdata%soilmch    = 0.0\n    rootzone%nvrvrootzone%nativeveg%soilmch   = 0.0\n    rootzone%nvrvrootzone%riparianveg%soilmch = 0.0\n    \n    rootzone%agrootzone%agdata%percch         = 0.0\n    rootzone%urbanrootzone%urbdata%percch     = 0.0\n    rootzone%nvrvrootzone%nativeveg%percch    = 0.0\n    rootzone%nvrvrootzone%riparianveg%percch  = 0.0\n    \n  end subroutine zeroredistributedmoist\n"}
{"id": 1012, "subroutine": "  subroutine redistributemoist(nelements,nregions,elemregion,rootzone)\n    integer,intent(in)      :: nelements,nregions,elemregion(nelements)\n    type(rootzone_v50_type) :: rootzone\n\n    !local variables\n    integer                                                 :: indxelem,indxlu,iregion,isoil,indxregion,indxsoil\n    real(8)                                                 :: ratio(3),soilm_int_precip,soilm_int_aw,soilm_int_oth,totalreduc,  &\n                                                               factor_precip,factor_aw,factor_oth,totalporosity,perviousfrac,    &\n                                                               rvalue,rtotalporosityd,area_out\n    real(8),dimension(f_inlands+1)                          :: areaexpand,areareduced,area,area_p,rootdepth,sm_precip,sm_aw,sm_oth\n    real(8),dimension(f_inlands+1,nelements)                :: soilmch_precip,soilmch_aw,soilmch_oth,soilm_precip,soilm_aw,soilm_oth,percch\n    real(8),dimension(f_inlands+1,rootzone%nsoils,nregions) :: soilm_precip_soilregion,soilm_aw_soilregion,soilm_oth_soilregion,percch_soilregion , &\n                                                               soilmch_precip_soilregion,soilmch_aw_soilregion,soilmch_oth_soilregion\n    logical                                                 :: lag_defined,lurban_defined,lnvrv_defined\n    integer,parameter                                       :: indxag        = 1 , &\n                                                               indxurban_in  = 2 , &\n                                                               indxurban_out = 3 , &\n                                                               indxnv        = 4 , &\n                                                               indxrv        = 5 , &\n                                                               nlandsext     = f_inlands + 1\n    \n    !initialize\n    lag_defined               = rootzone%flags%lag_defined\n    lurban_defined            = rootzone%flags%lurban_defined\n    lnvrv_defined             = rootzone%flags%lnvrv_defined\n    area                      = 0.0\n    area_p                    = 0.0\n    sm_precip                 = 0.0\n    sm_aw                     = 0.0\n    sm_oth                    = 0.0\n    soilm_precip_soilregion   = 0.0\n    soilm_aw_soilregion       = 0.0\n    soilm_oth_soilregion      = 0.0\n    percch_soilregion         = 0.0\n    soilmch_precip_soilregion = 0.0\n    soilmch_aw_soilregion     = 0.0\n    soilmch_oth_soilregion    = 0.0\n    areaexpand                = 0.0\n    areareduced               = 0.0\n    rootdepth                 = 0.0   ;   if (lurban_defined) then\n                                              rootdepth(indxurban_in)  = rootzone%urbanrootzone%rootdepth\n                                              rootdepth(indxurban_out) = rootzone%urbanrootzone%rootdepth\n                                          end if\n                                          if (lnvrv_defined) then\n                                              rootdepth(indxnv) = rootzone%nvrvrootzone%rootdepth_native\n                                              rootdepth(indxrv) = rootzone%nvrvrootzone%rootdepth_riparian\n                                          end if\n    \n    associate (pag        => rootzone%agrootzone%agdata          , &\n               purban     => rootzone%urbanrootzone%urbdata      , &\n               pnv        => rootzone%nvrvrootzone%nativeveg     , &\n               prv        => rootzone%nvrvrootzone%riparianveg   , &\n               psoilsdata => rootzone%subregionsoilsdata         )\n\n        !compute the details of land use area expansion and contraction to compute new soil moisture contents\n        do indxelem=1,nelements\n            \n            !initialize\n            isoil         = rootzone%elemsoiltype(indxelem)\n            iregion       = elemregion(indxelem)\n            totalporosity = psoilsdata(isoil,iregion)%totalporosity\n            if (lurban_defined) perviousfrac = rootzone%urbanrootzone%perviousfrac(iregion)\n            if (lag_defined) then\n                rootdepth(indxag) = rootzone%agrootzone%avgcrop(iregion)%rootdepth\n                area(indxag)      = rootzone%agrootzone%elementalarea(indxelem)\n                area_p(indxag)    = rootzone%agrootzone%elementalarea_p(indxelem)\n                sm_precip(indxag) = pag(isoil,iregion)%soilm_precip_p\n                sm_aw(indxag)     = pag(isoil,iregion)%soilm_aw_p\n                sm_oth(indxag)    = pag(isoil,iregion)%soilm_oth_p\n            end if \n            if (lurban_defined) then\n                area_p(indxurban_out)    = rootzone%urbanrootzone%elementalarea_p(indxelem) * perviousfrac \n                area_p(indxurban_in)     = rootzone%urbanrootzone%elementalarea_p(indxelem) - area_p(indxurban_out) \n                area(indxurban_out)      = rootzone%urbanrootzone%elementalarea(indxelem) * perviousfrac   \n                area(indxurban_in)       = rootzone%urbanrootzone%elementalarea_p(indxelem) - area(indxurban_out)   \n                sm_precip(indxurban_out) = purban(isoil,iregion)%soilm_precip_p\n                sm_aw(indxurban_out)     = purban(isoil,iregion)%soilm_aw_p\n                sm_oth(indxurban_out)    = purban(isoil,iregion)%soilm_oth_p\n            end if\n            if (lnvrv_defined) then\n                area_p(indxnv)    = rootzone%nvrvrootzone%elementalarea_p_nv(indxelem)\n                area_p(indxrv)    = rootzone%nvrvrootzone%elementalarea_p_rv(indxelem)\n                area(indxnv)      = rootzone%nvrvrootzone%elementalarea_nv(indxelem)\n                area(indxrv)      = rootzone%nvrvrootzone%elementalarea_rv(indxelem)\n                sm_precip(indxnv) = pnv(isoil,iregion)%soilm_precip_p\n                sm_precip(indxrv) = prv(isoil,iregion)%soilm_precip_p\n                sm_aw(indxnv)     = pnv(isoil,iregion)%soilm_aw_p        !although there is no irrigation for native and riparian veg, they\n                sm_aw(indxrv)     = prv(isoil,iregion)%soilm_aw_p        !  can inherit moisture due to irrigtaion when their area expands into ag and urban lands\n                sm_oth(indxnv)    = pnv(isoil,iregion)%soilm_oth_p\n                sm_oth(indxrv)    = prv(isoil,iregion)%soilm_oth_p\n            end if \n\n            !changes in element land use areas\n            areaexpand    = max(area-area_p,0.0)                        !expansion in each land use area\n            areareduced   = max(area_p-area,0.0)                        !reduction in each land use area\n            totalreduc    = sum(areareduced)                            !total area reduction\n            if (totalreduc .eq. 0.0) then\n                soilm_precip(:,indxelem)                 = sm_precip\n                soilm_aw(:,indxelem)                     = sm_aw\n                soilm_oth(:,indxelem)                    = sm_oth\n                soilmch_precip(:,indxelem)               = 0.0\n                soilmch_aw(:,indxelem)                   = 0.0\n                soilmch_oth(:,indxelem)                  = 0.0\n                percch(:,indxelem)                       = 0.0\n                soilm_precip_soilregion(:,isoil,iregion) = soilm_precip_soilregion(:,isoil,iregion) + soilm_precip(:,indxelem) * area\n                soilm_aw_soilregion(:,isoil,iregion)     = soilm_aw_soilregion(:,isoil,iregion)     + soilm_aw(:,indxelem)     * area\n                soilm_oth_soilregion(:,isoil,iregion)    = soilm_oth_soilregion(:,isoil,iregion)    + soilm_oth(:,indxelem)    * area\n                cycle\n            end if\n            factor_precip = sum(sm_precip/totalreduc*areareduced)       !scaling factor for moisture due to precip\n            factor_aw     = sum(sm_aw/totalreduc*areareduced)           !scaling factor for moisture due to irrigation\n            factor_oth    = sum(sm_oth/totalreduc*areareduced)          !scaling factor for moisture due to other generic sources\n\n            !compute new soil moisture volumes under new areas \n            do indxlu=1,nlandsext\n                \n                !area did not expand; moisture content in the land use is the same\n                if (areaexpand(indxlu) .eq. 0.0) then\n                  soilm_int_precip = sm_precip(indxlu) * area(indxlu)\n                  soilm_int_aw     = sm_aw(indxlu)     * area(indxlu)\n                  soilm_int_oth    = sm_oth(indxlu)    * area(indxlu)\n\n                !area expanded; the moisture content will change to assimilate the new moisture \n                else\n                  soilm_int_precip = sm_precip(indxlu)*area_p(indxlu) + factor_precip*areaexpand(indxlu)\n                  soilm_int_aw     = sm_aw(indxlu)    *area_p(indxlu) + factor_aw    *areaexpand(indxlu)\n                  soilm_int_oth    = sm_oth(indxlu)   *area_p(indxlu) + factor_oth   *areaexpand(indxlu)\n                end if\n                \n                !volumetric change in soil moisture\n                soilmch_precip(indxlu,indxelem) = soilm_int_precip - sm_precip(indxlu)*area_p(indxlu)\n                soilmch_aw(indxlu,indxelem)     = soilm_int_aw     - sm_aw(indxlu)    *area_p(indxlu)\n                soilmch_oth(indxlu,indxelem)    = soilm_int_oth    - sm_oth(indxlu)   *area_p(indxlu)\n\n                !modify moisture content in the land use area\n                if (area(indxlu) .gt. 0.0) then\n                    soilm_precip(indxlu,indxelem) = soilm_int_precip/area(indxlu)\n                    soilm_aw(indxlu,indxelem)     = soilm_int_aw/area(indxlu)\n                    soilm_oth(indxlu,indxelem)    = soilm_int_oth/area(indxlu)\n                    !if modified moisture exceeds total porosity turn the excess moisture to perc\n                    percch(indxlu,indxelem)       = max(0.0  ,  soilm_precip(indxlu,indxelem) + soilm_aw(indxlu,indxelem) + soilm_oth(indxlu,indxelem) - totalporosity*rootdepth(indxlu))\n                    rvalue                        = soilm_precip(indxlu,indxelem) + soilm_aw(indxlu,indxelem) + soilm_oth(indxlu,indxelem)\n                    if (rvalue .gt. 0.0) then\n                        ratio                         = [soilm_precip(indxlu,indxelem) , soilm_aw(indxlu,indxelem) , soilm_oth(indxlu,indxelem)]\n                        call normalizearray(ratio)\n                        soilm_precip(indxlu,indxelem) = soilm_precip(indxlu,indxelem) - percch(indxlu,indxelem) * ratio(1)\n                        soilm_aw(indxlu,indxelem)     = soilm_aw(indxlu,indxelem)     - percch(indxlu,indxelem) * ratio(2)\n                        soilm_oth(indxlu,indxelem)    = soilm_oth(indxlu,indxelem)    - percch(indxlu,indxelem) * ratio(3)\n                     end if\n                else\n                     soilm_precip(indxlu,indxelem) = 0.0\n                     soilm_aw(indxlu,indxelem)     = 0.0\n                     soilm_oth(indxlu,indxelem)    = 0.0\n                     percch(indxlu,indxelem)       = 0.0\n                end if\n                \n                !accumulate volumetric rates to soil-region combination\n                soilm_precip_soilregion(indxlu,isoil,iregion)   = soilm_precip_soilregion(indxlu,isoil,iregion)   + soilm_precip(indxlu,indxelem) * area(indxlu)\n                soilm_aw_soilregion(indxlu,isoil,iregion)       = soilm_aw_soilregion(indxlu,isoil,iregion)       + soilm_aw(indxlu,indxelem)     * area(indxlu)\n                soilm_oth_soilregion(indxlu,isoil,iregion)      = soilm_oth_soilregion(indxlu,isoil,iregion)      + soilm_oth(indxlu,indxelem)    * area(indxlu)\n                percch_soilregion(indxlu,isoil,iregion)         = percch_soilregion(indxlu,isoil,iregion)         + percch(indxlu,indxelem)   * area(indxlu)\n                soilmch_precip_soilregion(indxlu,isoil,iregion) = soilmch_precip_soilregion(indxlu,isoil,iregion) + soilmch_precip(indxlu,indxelem)\n                soilmch_aw_soilregion(indxlu,isoil,iregion)     = soilmch_aw_soilregion(indxlu,isoil,iregion)     + soilmch_aw(indxlu,indxelem)\n                soilmch_oth_soilregion(indxlu,isoil,iregion)    = soilmch_oth_soilregion(indxlu,isoil,iregion)    + soilmch_oth(indxlu,indxelem)\n            end do            \n        end do\n\n        !store data in persisting arrays\n        !also, update soilm_p to reflect changes in the moisture due to land expansion/shrinking\n        !*note: soilm_p is now the moisture at the beginning of time step after redistribution.\n        !       it is necessary to be careful when computing the reporting variables\n        if (lag_defined) then\n            do indxregion=1,nregions\n                do indxsoil=1,rootzone%nsoils\n                    if (pag(indxsoil,indxregion)%area .gt. 0.0) then\n                        pag(indxsoil,indxregion)%soilm_precip = soilm_precip_soilregion(indxag,indxsoil,indxregion) / pag(indxsoil,indxregion)%area \n                        pag(indxsoil,indxregion)%soilm_aw     = soilm_aw_soilregion(indxag,indxsoil,indxregion)     / pag(indxsoil,indxregion)%area\n                        pag(indxsoil,indxregion)%soilm_oth    = soilm_oth_soilregion(indxag,indxsoil,indxregion)    / pag(indxsoil,indxregion)%area\n                        pag(indxsoil,indxregion)%soilmch      = soilmch_precip_soilregion(indxag,indxsoil,indxregion) + soilmch_aw_soilregion(indxag,indxsoil,indxregion) + soilmch_oth_soilregion(indxag,indxsoil,indxregion)\n                        pag(indxsoil,indxregion)%percch       = percch_soilregion(indxag,indxsoil,indxregion)       / pag(indxsoil,indxregion)%area\n                    else\n                        pag(indxsoil,indxregion)%soilm_precip = 0.0\n                        pag(indxsoil,indxregion)%soilm_aw     = 0.0\n                        pag(indxsoil,indxregion)%soilm_oth    = 0.0\n                        pag(indxsoil,indxregion)%soilmch      = 0.0\n                        pag(indxsoil,indxregion)%percch       = 0.0\n                    end if\n                end do\n            end do\n        end if\n        \n        if (lurban_defined) then\n            !consolidate urban values to urban outdoors\n            do indxregion=1,nregions\n                perviousfrac = rootzone%urbanrootzone%perviousfrac(indxregion)\n                do indxsoil=1,rootzone%nsoils\n                    if (purban(indxsoil,indxregion)%area .gt. 0.0) then\n                        area_out                                 = purban(indxsoil,indxregion)%area * perviousfrac\n                        purban(indxsoil,indxregion)%soilm_precip = (soilm_precip_soilregion(indxurban_out,indxsoil,indxregion) + soilm_precip_soilregion(indxurban_in,indxsoil,indxregion) * (1d0/perviousfrac - 1d0)) / area_out\n                        purban(indxsoil,indxregion)%soilm_aw     = (soilm_aw_soilregion(indxurban_out,indxsoil,indxregion)     + soilm_aw_soilregion(indxurban_in,indxsoil,indxregion) * (1d0/perviousfrac - 1d0))     / area_out \n                        purban(indxsoil,indxregion)%soilm_oth    = (soilm_oth_soilregion(indxurban_out,indxsoil,indxregion)    + soilm_oth_soilregion(indxurban_in,indxsoil,indxregion) * (1d0/perviousfrac - 1d0))    / area_out\n                        purban(indxsoil,indxregion)%soilmch      = soilmch_precip_soilregion(indxurban_out,indxsoil,indxregion) + soilmch_precip_soilregion(indxurban_in,indxsoil,indxregion) + soilmch_aw_soilregion(indxurban_out,indxsoil,indxregion) + soilmch_aw_soilregion(indxurban_in,indxsoil,indxregion) + soilmch_oth_soilregion(indxurban_out,indxsoil,indxregion) + soilmch_oth_soilregion(indxurban_in,indxsoil,indxregion) \n                        purban(indxsoil,indxregion)%percch       = (percch_soilregion(indxurban_out,indxsoil,indxregion)       + percch_soilregion(indxurban_in,indxsoil,indxregion) * (1d0/perviousfrac - 1d0)) / area_out\n                        \n                        !make sure soil moisture is not above total porosity\n                        rtotalporosityd = psoilsdata(indxsoil,indxregion)%totalporosity * rootdepth(indxurban_out)\n                        rvalue          = purban(indxsoil,indxregion)%soilm_precip + purban(indxsoil,indxregion)%soilm_aw + purban(indxsoil,indxregion)%soilm_oth\n                        if (rvalue .le. rtotalporosityd) cycle\n                        purban(indxsoil,indxregion)%percch       = purban(indxsoil,indxregion)%percch + (rvalue - rtotalporosityd) * area_out\n                        ratio                                    = [purban(indxsoil,indxregion)%soilm_precip , purban(indxsoil,indxregion)%soilm_aw , purban(indxsoil,indxregion)%soilm_oth]\n                        call normalizearray(ratio)\n                        purban(indxsoil,indxregion)%soilm_precip = rtotalporosityd * ratio(1)\n                        purban(indxsoil,indxregion)%soilm_aw     = rtotalporosityd * ratio(2)\n                        purban(indxsoil,indxregion)%soilm_oth    = rtotalporosityd * ratio(3)\n                    else\n                        purban(indxsoil,indxregion)%soilm_precip = 0.0\n                        purban(indxsoil,indxregion)%soilm_aw     = 0.0\n                        purban(indxsoil,indxregion)%soilm_oth    = 0.0\n                        purban(indxsoil,indxregion)%soilmch      = 0.0\n                        purban(indxsoil,indxregion)%percch       = 0.0\n                    end if\n                end do\n            end do\n        end if\n\n        if (lnvrv_defined) then\n            do indxregion=1,nregions\n                do indxsoil=1,rootzone%nsoils\n                    if (pnv(indxsoil,indxregion)%area .gt. 0.0) then\n                        pnv(indxsoil,indxregion)%soilm_precip = soilm_precip_soilregion(indxnv,indxsoil,indxregion) / pnv(indxsoil,indxregion)%area\n                        pnv(indxsoil,indxregion)%soilm_aw     = soilm_aw_soilregion(indxnv,indxsoil,indxregion) / pnv(indxsoil,indxregion)%area\n                        pnv(indxsoil,indxregion)%soilm_oth    = soilm_oth_soilregion(indxnv,indxsoil,indxregion) / pnv(indxsoil,indxregion)%area\n                        pnv(indxsoil,indxregion)%soilmch      = soilmch_precip_soilregion(indxnv,indxsoil,indxregion) + soilmch_aw_soilregion(indxnv,indxsoil,indxregion) + soilmch_oth_soilregion(indxnv,indxsoil,indxregion)\n                        pnv(indxsoil,indxregion)%percch       = percch_soilregion(indxnv,indxsoil,indxregion) / pnv(indxsoil,indxregion)%area\n                    else\n                        pnv(indxsoil,indxregion)%soilm_precip = 0.0\n                        pnv(indxsoil,indxregion)%soilm_aw     = 0.0\n                        pnv(indxsoil,indxregion)%soilm_oth    = 0.0\n                        pnv(indxsoil,indxregion)%soilmch      = 0.0\n                        pnv(indxsoil,indxregion)%percch       = 0.0\n                    end if \n                    \n                    if (prv(indxsoil,indxregion)%area .gt. 0.0) then\n                        prv(indxsoil,indxregion)%soilm_precip = soilm_precip_soilregion(indxrv,indxsoil,indxregion) / prv(indxsoil,indxregion)%area\n                        prv(indxsoil,indxregion)%soilm_aw     = soilm_aw_soilregion(indxrv,indxsoil,indxregion) / prv(indxsoil,indxregion)%area\n                        prv(indxsoil,indxregion)%soilm_oth    = soilm_oth_soilregion(indxrv,indxsoil,indxregion) / prv(indxsoil,indxregion)%area\n                        prv(indxsoil,indxregion)%soilmch      = soilmch_precip_soilregion(indxrv,indxsoil,indxregion) + soilmch_aw_soilregion(indxrv,indxsoil,indxregion) + soilmch_oth_soilregion(indxrv,indxsoil,indxregion)\n                        prv(indxsoil,indxregion)%percch       = percch_soilregion(indxrv,indxsoil,indxregion) / prv(indxsoil,indxregion)%area\n                    else\n                        prv(indxsoil,indxregion)%soilm_precip = 0.0\n                        prv(indxsoil,indxregion)%soilm_aw     = 0.0\n                        prv(indxsoil,indxregion)%soilm_oth    = 0.0\n                        prv(indxsoil,indxregion)%soilmch      = 0.0\n                        prv(indxsoil,indxregion)%percch       = 0.0\n                    end if\n                end do\n            end do\n        end if\n        \n        !advance the soil moisture in time\n        call advancestatelocal(rootzone , ladvancearea=.false.)  !do not advance the area in time; we are only updating the soil moisture beacuse it changed\n\n    end associate\n\nend subroutine redistributemoist\n"}
{"id": 1013, "subroutine": "  subroutine advancestatelocal(rootzone,ladvancearea)\n    type(rootzone_v50_type) :: rootzone\n    logical,intent(in)      :: ladvancearea\n    \n    rootzone%rsoilm_p = rootzone%rsoilm\n\n    if (rootzone%flags%lag_defined) then\n        rootzone%agrootzone%agdata%soilm_precip_p = rootzone%agrootzone%agdata%soilm_precip\n        rootzone%agrootzone%agdata%soilm_aw_p     = rootzone%agrootzone%agdata%soilm_aw\n        rootzone%agrootzone%agdata%soilm_oth_p    = rootzone%agrootzone%agdata%soilm_oth\n        if (ladvancearea) call rootzone%agrootzone%advanceareas()\n    end if\n    \n    if (rootzone%flags%lurban_defined) then\n        rootzone%urbanrootzone%urbdata%soilm_precip_p = rootzone%urbanrootzone%urbdata%soilm_precip\n        rootzone%urbanrootzone%urbdata%soilm_aw_p     = rootzone%urbanrootzone%urbdata%soilm_aw\n        rootzone%urbanrootzone%urbdata%soilm_oth_p    = rootzone%urbanrootzone%urbdata%soilm_oth\n        if (ladvancearea) call rootzone%urbanrootzone%advanceareas()\n    end if\n    \n    if (rootzone%flags%lnvrv_defined) then\n        rootzone%nvrvrootzone%nativeveg%soilm_precip_p    = rootzone%nvrvrootzone%nativeveg%soilm_precip\n        rootzone%nvrvrootzone%nativeveg%soilm_aw_p        = rootzone%nvrvrootzone%nativeveg%soilm_aw\n        rootzone%nvrvrootzone%nativeveg%soilm_oth_p       = rootzone%nvrvrootzone%nativeveg%soilm_oth\n        rootzone%nvrvrootzone%riparianveg%soilm_precip_p  = rootzone%nvrvrootzone%riparianveg%soilm_precip\n        rootzone%nvrvrootzone%riparianveg%soilm_aw_p      = rootzone%nvrvrootzone%riparianveg%soilm_aw\n        rootzone%nvrvrootzone%riparianveg%soilm_oth_p     = rootzone%nvrvrootzone%riparianveg%soilm_oth\n        if (ladvancearea) call rootzone%nvrvrootzone%advanceareas()\n    end if\n    \n  end subroutine advancestatelocal\n"}
{"id": 1014, "subroutine": "  subroutine rootzone_v50_advancestate(rootzone)\n    class(rootzone_v50_type) :: rootzone\n    \n    !store previous moisture stoarge in special arrays before they may be updated\n    if (rootzone%flags%lag_defined) then\n        rootzone%agrootzone%agdata%soilm_precip_p_beforeupdate = rootzone%agrootzone%agdata%soilm_precip\n        rootzone%agrootzone%agdata%soilm_aw_p_beforeupdate     = rootzone%agrootzone%agdata%soilm_aw\n        rootzone%agrootzone%agdata%soilm_oth_p_beforeupdate    = rootzone%agrootzone%agdata%soilm_oth\n    end if\n    if (rootzone%flags%lurban_defined) then\n        rootzone%urbanrootzone%urbdata%soilm_precip_p_beforeupdate = rootzone%urbanrootzone%urbdata%soilm_precip\n        rootzone%urbanrootzone%urbdata%soilm_aw_p_beforeupdate     = rootzone%urbanrootzone%urbdata%soilm_aw\n        rootzone%urbanrootzone%urbdata%soilm_oth_p_beforeupdate    = rootzone%urbanrootzone%urbdata%soilm_oth\n    end if\n    if (rootzone%flags%lnvrv_defined) then\n        rootzone%nvrvrootzone%nativeveg%soilm_precip_p_beforeupdate   = rootzone%nvrvrootzone%nativeveg%soilm_precip\n        rootzone%nvrvrootzone%nativeveg%soilm_aw_p_beforeupdate       = rootzone%nvrvrootzone%nativeveg%soilm_aw\n        rootzone%nvrvrootzone%nativeveg%soilm_oth_p_beforeupdate      = rootzone%nvrvrootzone%nativeveg%soilm_oth\n        rootzone%nvrvrootzone%riparianveg%soilm_precip_p_beforeupdate = rootzone%nvrvrootzone%riparianveg%soilm_precip\n        rootzone%nvrvrootzone%riparianveg%soilm_aw_p_beforeupdate     = rootzone%nvrvrootzone%riparianveg%soilm_aw\n        rootzone%nvrvrootzone%riparianveg%soilm_oth_p_beforeupdate    = rootzone%nvrvrootzone%riparianveg%soilm_oth\n    end if\n    \n    call advancestatelocal(rootzone , ladvancearea=.true.)\n    \n  end subroutine rootzone_v50_advancestate\n"}
{"id": 1015, "subroutine": "  subroutine rootzone_v50_regionalreturnflow_ag(rootzone,appgrid,rreturnflow)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8),intent(out)                 :: rreturnflow(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: nregions\n\n    !initialize\n    nregions = appgrid%nsubregions\n    \n    !ag lands\n    if (rootzone%flags%lag_defined) then\n        rreturnflow(1:nregions) = sum(rootzone%agrootzone%agdata%returnflow * rootzone%agrootzone%agdata%area , dim=1) \n        rreturnflow(nregions+1) = sum(rreturnflow(1:nregions))\n    else\n        rreturnflow = 0.0\n    end if\n\n  end subroutine rootzone_v50_regionalreturnflow_ag\n"}
{"id": 1016, "subroutine": "  subroutine rootzone_v50_regionalreturnflow_urb(rootzone,appgrid,rreturnflow)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    type(appgridtype),intent(in)        :: appgrid\n    real(8),intent(out)                 :: rreturnflow(appgrid%nsubregions+1)\n    \n    !local variables\n    integer :: nregions\n\n    !initialize\n    nregions = appgrid%nsubregions\n    \n    !urban\n    if (rootzone%flags%lurban_defined) then\n        rreturnflow(1:nregions) = sum(rootzone%urbanrootzone%urbdata%returnflow * rootzone%urbanrootzone%urbdata%area , dim=1)    \n        rreturnflow(nregions+1) = sum(rreturnflow(1:nregions))\n    else\n        rreturnflow = 0.0\n    end if\n      \n  end subroutine rootzone_v50_regionalreturnflow_urb\n"}
{"id": 1017, "subroutine": "  subroutine processlanduseareas(appgrid,timestep,rootzone,istat)\n    type(appgridtype),intent(in)  :: appgrid\n    type(timesteptype),intent(in) :: timestep\n    type(rootzone_v50_type)       :: rootzone\n    integer,intent(out)           :: istat\n\n    !local variables\n    character(len=modnamelen+19) :: thisprocedure = modname // 'processlanduseareas'\n    integer                      :: indxelem,ielemid\n    real(8)                      :: luarea_elem(f_inlands,appgrid%nelements)\n    \n    !initialize\n    istat = 0\n    \n    !zero out the variables that hold information regarding soil moisture change due to land area change\n    call zeroredistributedmoist(rootzone) \n    \n    !return if new data is not read\n    if (.not. rootzone_v50_islanduseupdated(rootzone)) return\n        \n    !check for errors and process data\n    luarea_elem = 0.0\n    do indxelem=1,appgrid%nelements\n\n        !if lake element, zero out areas and cycle\n        if (rootzone%flags%llakeelems(indxelem)) then\n            luarea_elem(:,indxelem) = 0.0\n            cycle\n        end if\n          \n        !store data in the work array\n        if (rootzone%flags%lag_defined)    luarea_elem(1,indxelem) = rootzone%agrootzone%elementalarea(indxelem)\n        if (rootzone%flags%lurban_defined) luarea_elem(2,indxelem) = rootzone%urbanrootzone%elementalarea(indxelem)\n        if (rootzone%flags%lnvrv_defined) then\n            luarea_elem(3,indxelem) = rootzone%nvrvrootzone%elementalarea_nv(indxelem)\n            luarea_elem(4,indxelem) = rootzone%nvrvrootzone%elementalarea_rv(indxelem)\n        end if\n        \n        !check for zero area\n        if (all(luarea_elem(:,indxelem) .le. 0.0)) then\n            ielemid = appgrid%appelement(indxelem)%id\n            call setlastmessage('total land use area is zero at element ' // trim(inttotext(ielemid)) // '!',ifatal,thisprocedure)\n            istat = -1\n            return\n        end if\n\n        !normalize the land use areas\n        call normalizearray(luarea_elem(:,indxelem))\n\n        !compute final land use areas \n        luarea_elem(:,indxelem) = luarea_elem(:,indxelem) * appgrid%appelement(indxelem)%area\n        \n    end do\n\n    associate (pag    => rootzone%agrootzone     , &\n               purban => rootzone%urbanrootzone  , &\n               pnvrv  => rootzone%nvrvrootzone   )\n               \n        !store the areas in persistent objects\n        if (rootzone%flags%lag_defined) call pag%setareas(appgrid,rootzone%elemsoiltype,luarea_elem(1,:))\n        if (rootzone%flags%lurban_defined) call purban%setareas(appgrid,rootzone%elemsoiltype,luarea_elem(2,:)) \n        if (rootzone%flags%lnvrv_defined) call pnvrv%setareas(appgrid,rootzone%elemsoiltype,luarea_elem(3,:),luarea_elem(4,:))\n      \n        !if first time step, advance land use areas in time to equal land use areas at previous and current time steps\n        if (timestep%currenttimestep .eq. 1) then\n            call pag%advanceareas()\n            call purban%advanceareas() \n            call pnvrv%advanceareas() \n \n        !otherwise redistribute soil moisture based on the decreased/increased land use area\n        else\n            call redistributemoist(appgrid%nelements,appgrid%nsubregions,appgrid%appelement%subregion,rootzone)\n        end if\n      \n    end associate\n               \n  end subroutine processlanduseareas\n"}
{"id": 1018, "subroutine": "  subroutine checktsdatapointers(rootzone,ielemids,isubregionids,precip,et,istat)\n    class(rootzone_v50_type),intent(in) :: rootzone\n    integer,intent(in)                  :: ielemids(:),isubregionids(:)\n    type(precipitationtype),intent(in)  :: precip\n    type(ettype),intent(in)             :: et\n    integer,intent(out)                 :: istat\n    \n    !local variables\n    character(len=modnamelen+19) :: thisprocedure = modname // 'checktsdatapointers'\n    integer                      :: ielem(1),ietcolmax,indxregion,indxcrop,ireturnflowcol(1),ireusecol(1),ielemid\n    logical                      :: lag_defined,lurban_defined,lnvrv_defined\n    \n    !initialize\n    istat          = 0\n    lag_defined    = rootzone%flags%lag_defined\n    lurban_defined = rootzone%flags%lurban_defined\n    lnvrv_defined  = rootzone%flags%lnvrv_defined\n    \n    !check precipitation\n    if (precip%getndatacolumns() .lt. maxval(rootzone%elemprecipdata%icolprecip)) then\n      ielem   = maxloc(rootzone%elemprecipdata%icolprecip)\n      ielemid = ielem(1)\n      messagearray(1) = 'precipitation data column for element '//trim(inttotext(ielemids(ielemid)))//' in the root zone component'\n      messagearray(2) = 'is greater than the available data columns in the precipitation data file!'\n      call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n      istat = -1\n      return\n    end if\n    \n    !check et, return flow and resue fractions\n    ietcolmax = et%getndatacolumns()\n    do indxregion=1,size(rootzone%subregionsoilsdata , dim=2)\n        !ag lands\n        if (lag_defined) then\n            do indxcrop=1,rootzone%agrootzone%ncrops\n                if (ietcolmax .lt. rootzone%agrootzone%icoletccrop(indxcrop,indxregion)) then\n                    messagearray(1) = 'evapotranspiration data column for agriculrtural crop '//trim(inttotext(indxcrop))//' at subregion '//trim(inttotext(isubregionids(indxregion)))\n                    messagearray(2) = 'is greater than the available data columns in the evapotranspiration data file!'\n                    call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n                    istat = -1\n                    return\n                end if\n            end do\n            ireturnflowcol(1) = rootzone%agrootzone%icolreturnfrac(indxregion)\n            ireusecol(1)      = rootzone%agrootzone%icolreusefrac(indxregion)\n            call rootzone%returnfracfile%checkcolnum('return flow fractions data file (referenced by agricultural main data file for subregion '//trim(inttotext(isubregionids(indxregion)))//')',ireturnflowcol,.true.,istat)  ;  if (istat .eq. -1) return\n            call rootzone%reusefracfile%checkcolnum('re-use fractions data file (referenced by agricultural main data file for subregion '//trim(inttotext(isubregionids(indxregion)))//')',ireusecol,.true.,istat)             ;  if (istat .eq. -1) return\n        end if\n        \n        !urban\n        if (lurban_defined) then\n            if (ietcolmax .lt. rootzone%urbanrootzone%urbdata(1,indxregion)%icoletc) then\n                messagearray(1) = 'evapotranspiration data column for subregion '//trim(inttotext(isubregionids(indxregion)))//' at urban lands '\n                messagearray(2) = 'is greater than the available data columns in the evapotranspiration data file!'\n                call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n                istat = -1\n                return\n            end if \n            ireturnflowcol(1) = rootzone%urbanrootzone%icolreturnfrac(indxregion)\n            ireusecol(1)      = rootzone%urbanrootzone%icolreusefrac(indxregion)\n            call rootzone%returnfracfile%checkcolnum('return flow fractions data file (referenced by urban main data file for subregion '//trim(inttotext(isubregionids(indxregion)))//')',ireturnflowcol,.true.,istat)  ;  if (istat .eq. -1) return\n            call rootzone%reusefracfile%checkcolnum('re-use fractions data file (referenced by urban main data file for subregion '//trim(inttotext(isubregionids(indxregion)))//')',ireusecol,.true.,istat)             ;  if (istat .eq. -1) return\n        end if\n    \n        if (lnvrv_defined) then\n           !native \n            if (ietcolmax .lt. rootzone%nvrvrootzone%nativeveg(1,indxregion)%icoletc) then\n                messagearray(1) = 'evapotranspiration data column for subregion '//trim(inttotext(isubregionids(indxregion)))//' at native vegetation lands '\n                messagearray(2) = 'is greater than the available data columns in the evapotranspiration data file!'\n                call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n                istat = -1\n                return\n            end if   \n        \n            !riparian  \n            if (ietcolmax .lt. rootzone%nvrvrootzone%riparianveg(1,indxregion)%icoletc) then\n                messagearray(1) = 'evapotranspiration data column for subregion '//trim(inttotext(isubregionids(indxregion)))//' at riparian vegetation lands '\n                messagearray(2) = 'is greater than the available data columns in the evapotranspiration data file!'\n                call setlastmessage(messagearray(1:2),ifatal,thisprocedure)\n                istat = -1\n                return\n            end if\n        end if   \n    end do\n    \n  end subroutine checktsdatapointers\n"}
{"id": 1019, "subroutine": "  subroutine flowtosubregions(flow,luarea,elemstosubregions,elemsoiltype,appgrid,tosubregions)\n    real(8),intent(in)                         :: flow(:,:)                    !in unit rate for each (soil,subregion)\n    real(8),intent(in)                         :: luarea(:)                    !land use area at each element\n    type(elemsurfaceflowtodesttype),intent(in) :: elemstosubregions(:)         !element flow to subregion connection list\n    integer,intent(in)                         :: elemsoiltype(:)              !given for each element\n    type(appgridtype),intent(in)               :: appgrid\n    real(8)                                    :: tosubregions(:)              !in units of volume for each (subregion)\n    \n    !local variables\n    integer :: isoil,ielem,indx,iregion,idestregion\n    \n    do indx=1,size(elemstosubregions)\n        ielem       = elemstosubregions(indx)%ielement\n        isoil       = elemsoiltype(ielem)\n        iregion     = appgrid%appelement(ielem)%subregion\n        if (flow(isoil,iregion) .eq. 0.0) cycle\n        idestregion               = elemstosubregions(indx)%idest\n        tosubregions(idestregion) = tosubregions(idestregion) + flow(isoil,iregion) * luarea(ielem)\n    end do\n        \n  end subroutine flowtosubregions\n"}
{"id": 1020, "subroutine": "  subroutine computeregionaletpot(etdata,nsubregions,icoletc,area,etpot)\n    type(ettype),intent(in) :: etdata\n    integer,intent(in)      :: nsubregions,icoletc(:)\n    real(8),intent(in)      :: area(:)\n    real(8),intent(out)     :: etpot(:)\n    \n    !local variables\n    real(8) :: etc(nsubregions)\n    \n    !compile\n    etc   = etdata%getvalues(icoletc)\n    etpot = etc * area\n    \n  end subroutine computeregionaletpot\n"}
{"id": 1021, "subroutine": "  subroutine mf_initializefields_relativistic_ideal &\n    ( programname, mf_ugf, mf_ucf, geom )\n\n    character(len=*),     intent(in)    :: programname\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n    type(amrex_geometry), intent(in)    :: geom  (0:nlevels-1)\n\n    if( amrex_parallel_ioprocessor() )then\n\n      write(*,*)\n      write(*,'(a4,a,a)') '', 'initializing: ', trim( programname )\n\n    end if\n\n    select case ( trim( programname ) )\n\n      case( 'advection' )\n\n        call initializefields_advection( mf_ugf, mf_ucf )\n\n      case( 'riemannproblem1d' )\n\n        call initializefields_riemannproblem1d( mf_ugf, mf_ucf )\n\n      case( 'riemannproblem2d' )\n\n        call initializefields_riemannproblem2d( mf_ugf, mf_ucf )\n\n      case( 'riemannproblemspherical' )\n\n        call initializefields_riemannproblemspherical( mf_ugf, mf_ucf )\n\n      case( 'kelvinhelmholtz' )\n\n        call initializefields_kelvinhelmholtz( mf_ugf, mf_ucf )\n\n      case( 'kelvinhelmholtz3d' )\n\n        call initializefields_kelvinhelmholtz3d( mf_ugf, mf_ucf )\n\n      case( 'standingaccretionshock_relativistic' )\n\n        call initializefields_standingaccretionshock_relativistic &\n               ( mf_ugf, mf_ucf, geom )\n\n      case default\n\n        if( amrex_parallel_ioprocessor() )then\n          write(*,*)\n          write(*,'(4x,a,a)') 'unknown program: ', trim( programname )\n          write(*,'(4x,a)')   'valid options:'\n          write(*,'(6x,a)')     'advection1d'\n          write(*,'(6x,a)')     'advection2d'\n          write(*,'(6x,a)')     'advection3d'\n          write(*,'(6x,a)')     'riemannproblem1d'\n          write(*,'(6x,a)')     'riemannproblem2d'\n          write(*,'(6x,a)')     'riemannproblemspherical'\n          write(*,'(6x,a)')     'kelvinhelmholtz'\n          write(*,'(6x,a)')     'kelvinhelmholtz3d'\n          write(*,'(6x,a)')     'standingaccretionshock_relativistic'\n        end if\n\n        call describeerror_euler( 99 )\n\n    end select\n\n  end subroutine mf_initializefields_relativistic_ideal\n"}
{"id": 1022, "subroutine": "  subroutine initializefields_advection( mf_ugf, mf_ucf )\n\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n\n    ! --- thornado ---\n\n    integer        :: idim\n    integer        :: ix1, ix2, ix3\n    integer        :: inx, inx1, inx2\n    real(dp)       :: x1, x2\n    real(dp)       :: ugf_k(ndofx,ngf)\n    real(dp)       :: ucf_k(ndofx,ncf)\n    real(dp)       :: upf_k(ndofx,npf)\n    real(dp)       :: uaf_k(ndofx,naf)\n    type(meshtype) :: meshx(3)\n\n    ! --- amrex ---\n\n    integer                       :: ilevel\n    integer                       :: lo_g(4), hi_g(4)\n    integer                       :: lo_f(4), hi_f(4)\n    type(amrex_box)               :: bx\n    type(amrex_mfiter)            :: mfi\n    type(amrex_parmparse)         :: pp\n    real(dp), contiguous, pointer :: ugf(:,:,:,:)\n    real(dp), contiguous, pointer :: ucf(:,:,:,:)\n\n    ! --- problem-dependent parameters ---\n\n    character(len=:), allocatable :: advectionprofile\n\n    advectionprofile = 'sinewavex1'\n    call amrex_parmparse_build( pp, 'thornado' )\n      call pp % query( 'advectionprofile', advectionprofile )\n    call amrex_parmparse_destroy( pp )\n\n    if( trim( advectionprofile ) .ne. 'sinewavex1' &\n        .and. trim( advectionprofile ) .ne. 'sinewavex2' &\n        .and. trim( advectionprofile ) .ne. 'sinewavex1x2' )then\n\n      if( amrex_parallel_ioprocessor() )then\n\n        write(*,*)\n        write(*,'(a,a)') &\n          'invalid choice for advectionprofile: ', &\n          trim( advectionprofile )\n        write(*,'(a)') 'valid choices:'\n        write(*,'(a)') '  sinewavex1'\n        write(*,'(a)') '  sinewavex2'\n        write(*,'(a)') '  sinewavex1x2'\n        write(*,*)\n        write(*,'(a)') 'stopping...'\n\n      end if\n\n      call describeerror_euler( 99 )\n\n    end if\n\n    if( amrex_parallel_ioprocessor() )then\n\n      write(*,'(4x,a,a)') 'advection profile: ', trim( advectionprofile )\n\n    end if\n\n    ugf_k = zero\n    ucf_k = zero\n    upf_k = zero\n    uaf_k = zero\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), 0, &\n               xl(idim), xr(idim) )\n\n    end do\n\n    do ilevel = 0, nlevels-1\n\n      call amrex_mfiter_build( mfi, mf_ugf(ilevel), tiling = usetiling )\n\n      do while( mfi % next() )\n\n        ugf => mf_ugf(ilevel) % dataptr( mfi )\n        ucf => mf_ucf(ilevel) % dataptr( mfi )\n\n        bx = mfi % tilebox()\n\n        lo_g = lbound( ugf )\n        hi_g = ubound( ugf )\n\n        lo_f = lbound( ucf )\n        hi_f = ubound( ucf )\n\n        do ix3 = bx % lo(3), bx % hi(3)\n        do ix2 = bx % lo(2), bx % hi(2)\n        do ix1 = bx % lo(1), bx % hi(1)\n\n          ugf_k &\n            = reshape( ugf(ix1,ix2,ix3,lo_g(4):hi_g(4)), [ ndofx, ngf ] )\n\n          do inx = 1, ndofx\n\n            inx1 = nodenumbertablex(1,inx)\n            inx2 = nodenumbertablex(2,inx)\n\n            x1 = nodecoordinate( meshx(1), ix1, inx1 )\n            x2 = nodecoordinate( meshx(2), ix2, inx2 )\n\n            if     ( trim( advectionprofile ) .eq. 'sinewavex1' )then\n\n              upf_k(inx,ipf_d ) = one + 0.1_dp * sin( twopi * x1 )\n              upf_k(inx,ipf_v1) = 0.1_dp\n              upf_k(inx,ipf_v2) = zero\n              upf_k(inx,ipf_v3) = zero\n              upf_k(inx,ipf_e ) = one / ( gamma_ideal - one )\n\n            else if( trim( advectionprofile ) .eq. 'sinewavex2' )then\n\n              upf_k(inx,ipf_d ) = one + 0.1_dp * sin( twopi * x2 )\n              upf_k(inx,ipf_v1) = zero\n              upf_k(inx,ipf_v2) = 0.1_dp\n              upf_k(inx,ipf_v3) = zero\n              upf_k(inx,ipf_e ) = one / ( gamma_ideal - one )\n\n            else if( trim( advectionprofile ) .eq. 'sinewavex1x2' )then\n\n              upf_k(inx,ipf_d ) &\n                = one + 0.1_dp * sin( sqrt( two ) * twopi * ( x1 + x2 ) )\n              upf_k(inx,ipf_v1) = 0.1_dp * cos( pi / four )\n              upf_k(inx,ipf_v2) = 0.1_dp * sin( pi / four )\n              upf_k(inx,ipf_v3) = zero\n              upf_k(inx,ipf_e ) = one / ( gamma_ideal - one )\n\n            end if\n\n          end do\n\n          call computepressurefromprimitive &\n                 ( upf_k(:,ipf_d), upf_k(:,ipf_e), upf_k(:,ipf_ne), &\n                   uaf_k(:,iaf_p) )\n\n          call computeconserved_euler &\n                 ( upf_k(:,ipf_d ), upf_k(:,ipf_v1), upf_k(:,ipf_v2), &\n                   upf_k(:,ipf_v3), upf_k(:,ipf_e ), upf_k(:,ipf_ne), &\n                   ucf_k(:,icf_d ), ucf_k(:,icf_s1), ucf_k(:,icf_s2), &\n                   ucf_k(:,icf_s3), ucf_k(:,icf_e ), ucf_k(:,icf_ne), &\n                   ugf_k(:,igf_gm_dd_11), &\n                   ugf_k(:,igf_gm_dd_22), &\n                   ugf_k(:,igf_gm_dd_33), &\n                   uaf_k(:,iaf_p) )\n\n          ucf(ix1,ix2,ix3,lo_f(4):hi_f(4)) &\n            = reshape( ucf_k, [ hi_f(4) - lo_f(4) + 1 ] )\n\n        end do\n        end do\n        end do\n\n      end do\n\n      call amrex_mfiter_destroy( mfi )\n\n    end do\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n  end subroutine initializefields_advection\n"}
{"id": 1023, "subroutine": "  subroutine initializefields_riemannproblem1d( mf_ugf, mf_ucf )\n\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n\n    ! --- thornado ---\n\n    integer        :: ix1, ix2, ix3\n    integer        :: inx, inx1\n    real(dp)       :: x1\n    real(dp)       :: ugf_k(ndofx,ngf)\n    real(dp)       :: ucf_k(ndofx,ncf)\n    real(dp)       :: upf_k(ndofx,npf)\n    real(dp)       :: uaf_k(ndofx,naf)\n    integer        :: idim\n    type(meshtype) :: meshx(3)\n\n    ! --- amrex ---\n\n    integer                       :: ilevel\n    integer                       :: lo_g(4), hi_g(4)\n    integer                       :: lo_f(4), hi_f(4)\n    type(amrex_box)               :: bx\n    type(amrex_parmparse)         :: pp\n    type(amrex_mfiter)            :: mfi\n    real(dp), contiguous, pointer :: ugf(:,:,:,:)\n    real(dp), contiguous, pointer :: ucf(:,:,:,:)\n\n    ! --- problem-specific parameters ---\n\n    character(len=:), allocatable :: riemannproblemname\n    real(dp)                      :: xd, vs\n    real(dp)                      :: leftstate(npf), rightstate(npf)\n\n    riemannproblemname = 'sod'\n    call amrex_parmparse_build( pp, 'thornado' )\n      call pp % query( 'riemannproblemname', riemannproblemname )\n    call amrex_parmparse_destroy( pp )\n\n    ugf_k = zero\n    ucf_k = zero\n    upf_k = zero\n    uaf_k = zero\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), 0, &\n               xl(idim), xr(idim) )\n\n    end do\n\n    if( amrex_parallel_ioprocessor() )then\n\n      write(*,*)\n      write(*,'(a4,a,a)') &\n        '', 'riemann problem name: ', trim( riemannproblemname )\n      write(*,*)\n\n    end if\n\n    select case( trim( riemannproblemname ) )\n\n      case( 'sod' )\n\n        xd = half\n\n        leftstate(ipf_d ) = 1.0_dp\n        leftstate(ipf_v1) = 0.0_dp\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        rightstate(ipf_d ) = 0.125_dp\n        rightstate(ipf_v1) = 0.0_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 0.1_dp / ( gamma_ideal - one )\n\n      case( 'isolatedshock' )\n\n        xd = half\n\n        vs = 0.01_dp\n\n        rightstate(ipf_d)  = 1.0_dp\n        rightstate(ipf_v1) = -0.9_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e)  = 1.0_dp / ( gamma_ideal - one )\n\n        call computeleftstate &\n               ( vs,                 &\n                 rightstate(ipf_d ), &\n                 rightstate(ipf_v1), &\n                 rightstate(ipf_e ) * ( gamma_ideal - one ), &\n                 leftstate (ipf_d ), &\n                 leftstate (ipf_v1), &\n                 leftstate (ipf_e ) )\n\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n\n      case( 'isolatedcontact' )\n\n        vs = 0.01_dp\n        xd = half\n\n        leftstate(ipf_d ) = 5.9718209694880811e0_dp\n        leftstate(ipf_v1) = vs\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        rightstate(ipf_d ) = 1.0_dp\n        rightstate(ipf_v1) = vs\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n      case( 'mbproblem1' )\n\n        xd = half\n\n        leftstate(ipf_d ) = 1.0_dp\n        leftstate(ipf_v1) = 0.9_dp\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        rightstate(ipf_d ) = 1.0_dp\n        rightstate(ipf_v1) = 0.0_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 10.0_dp / ( gamma_ideal - one )\n\n      case( 'mbproblem4' )\n\n        xd = half\n\n        leftstate(ipf_d ) = 1.0_dp\n        leftstate(ipf_v1) = 0.0_dp\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 1.0e3_dp / ( gamma_ideal - one )\n\n        rightstate(ipf_d ) = 1.0_dp\n        rightstate(ipf_v1) = 0.0_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 1.0e-2_dp / ( gamma_ideal - one )\n\n      case( 'perturbedshocktube' )\n\n        xd = half\n\n        leftstate(ipf_d ) = 5.0_dp\n        leftstate(ipf_v1) = 0.0_dp\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 50.0_dp / ( gamma_ideal - one )\n\n        rightstate(ipf_d ) = 0.0_dp ! --- dummy ---\n        rightstate(ipf_v1) = 0.0_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 5.0_dp / ( gamma_ideal - one )\n\n      case( 'shockreflection' )\n\n        xd = one\n\n        leftstate(ipf_d ) = 1.0_dp\n        leftstate(ipf_v1) = 0.99999_dp\n        leftstate(ipf_v2) = 0.0_dp\n        leftstate(ipf_v3) = 0.0_dp\n        leftstate(ipf_e ) = 0.01_dp / ( gamma_ideal - one )\n\n        ! --- all of these are dummies ---\n        rightstate(ipf_d ) = 0.0_dp\n        rightstate(ipf_v1) = 0.0_dp\n        rightstate(ipf_v2) = 0.0_dp\n        rightstate(ipf_v3) = 0.0_dp\n        rightstate(ipf_e ) = 0.0_dp\n\n      case default\n\n        if( amrex_parallel_ioprocessor() )then\n\n          write(*,*)\n          write(*,'(a,a)') &\n            'invalid choice for riemannproblemname: ', &\n            trim( riemannproblemname )\n          write(*,'(a)') 'valid choices:'\n          write(*,'(a)') &\n            \"  'sod' - &\n            sod's shock tube\"\n          write(*,'(a)') &\n            \"  'mbproblem1' - &\n            mignone & bodo (2005) mnras, 364, 126, problem 1\"\n          write(*,'(a)') &\n            \"  'mbproblem4' - &\n            mignone & bodo (2005) mnras, 364, 126, problem 4\"\n          write(*,'(a)') &\n            \"  'perturbedshocktube' - &\n            del zanna & bucciantini (2002) aa, 390, 1177, &\n            sinusoidal density perturbation\"\n          write(*,'(a)') &\n            \"  'shockreflection' - &\n            del zanna & bucciantini (2002) aa, 390, 1177, &\n            planar shock reflection\"\n          write(*,*)\n          write(*,'(a)') 'stopping...'\n\n        end if\n\n        call describeerror_euler( 99 )\n\n    end select\n\n    if( amrex_parallel_ioprocessor() )then\n\n      if( trim( riemannproblemname ) .eq. 'isolatedshock' )then\n\n        write(*,'(6x,a,es14.6e3)') 'shock velocity = ', vs\n        write(*,*)\n\n      end if\n\n      write(*,'(6x,a,f8.6)') 'gamma_ideal = ', gamma_ideal\n      write(*,*)\n      write(*,'(6x,a,f8.6)') 'xd = ', xd\n      write(*,*)\n      write(*,'(6x,a)') 'right state:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', rightstate(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', rightstate(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', rightstate(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', rightstate(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', rightstate(ipf_e )\n      write(*,*)\n      write(*,'(6x,a)') 'left state:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', leftstate(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', leftstate(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', leftstate(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', leftstate(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', leftstate(ipf_e )\n      write(*,*)\n\n    end if\n\n    do ilevel = 0, nlevels-1\n\n      call amrex_mfiter_build( mfi, mf_ugf(ilevel), tiling = usetiling )\n\n      do while( mfi % next() )\n\n        ugf => mf_ugf(ilevel) % dataptr( mfi )\n        ucf => mf_ucf(ilevel) % dataptr( mfi )\n\n        bx = mfi % tilebox()\n\n        lo_g = lbound( ugf )\n        hi_g = ubound( ugf )\n\n        lo_f = lbound( ucf )\n        hi_f = ubound( ucf )\n\n        do ix3 = bx % lo(3), bx % hi(3)\n        do ix2 = bx % lo(2), bx % hi(2)\n        do ix1 = bx % lo(1), bx % hi(1)\n\n          ugf_k &\n            = reshape( ugf(ix1,ix2,ix3,lo_g(4):hi_g(4)), [ ndofx, ngf ] )\n\n          do inx = 1, ndofx\n\n            inx1 = nodenumbertablex(1,inx)\n\n            x1 = nodecoordinate( meshx(1), ix1, inx1 )\n\n            if( x1 .le. xd ) then\n\n              upf_k(inx,ipf_d)  = leftstate(ipf_d )\n              upf_k(inx,ipf_v1) = leftstate(ipf_v1)\n              upf_k(inx,ipf_v2) = leftstate(ipf_v2)\n              upf_k(inx,ipf_v3) = leftstate(ipf_v3)\n              upf_k(inx,ipf_e)  = leftstate(ipf_e )\n\n            else\n\n              upf_k(inx,ipf_d)  = rightstate(ipf_d )\n              upf_k(inx,ipf_v1) = rightstate(ipf_v1)\n              upf_k(inx,ipf_v2) = rightstate(ipf_v2)\n              upf_k(inx,ipf_v3) = rightstate(ipf_v3)\n              upf_k(inx,ipf_e)  = rightstate(ipf_e )\n\n              if( trim( riemannproblemname ) .eq. 'perturbedshocktube' ) &\n                upf_k(inx,ipf_d) &\n                  = 2.0_dp + 0.3_dp * sin( 50.0_dp * x1 )\n\n            end if\n\n          end do\n\n          call computepressurefromprimitive &\n                 ( upf_k(:,ipf_d), upf_k(:,ipf_e), upf_k(:,ipf_ne), &\n                   uaf_k(:,iaf_p) )\n\n          call computeconserved_euler &\n                 ( upf_k(:,ipf_d ), upf_k(:,ipf_v1), upf_k(:,ipf_v2), &\n                   upf_k(:,ipf_v3), upf_k(:,ipf_e ), upf_k(:,ipf_ne), &\n                   ucf_k(:,icf_d ), ucf_k(:,icf_s1), ucf_k(:,icf_s2), &\n                   ucf_k(:,icf_s3), ucf_k(:,icf_e ), ucf_k(:,icf_ne), &\n                   ugf_k(:,igf_gm_dd_11), &\n                   ugf_k(:,igf_gm_dd_22), &\n                   ugf_k(:,igf_gm_dd_33), &\n                   uaf_k(:,iaf_p) )\n\n          ucf(ix1,ix2,ix3,lo_f(4):hi_f(4)) &\n            = reshape( ucf_k, [ hi_f(4) - lo_f(4) + 1 ] )\n\n        end do\n        end do\n        end do\n\n      end do\n\n      call amrex_mfiter_destroy( mfi )\n\n    end do\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n  end subroutine initializefields_riemannproblem1d\n"}
{"id": 1024, "subroutine": "  subroutine initializefields_riemannproblem2d( mf_ugf, mf_ucf )\n\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n\n    ! --- thornado ---\n\n    integer        :: idim\n    integer        :: ix1, ix2, ix3\n    integer        :: inx, inx1, inx2\n    real(dp)       :: x1, x2\n    real(dp)       :: ugf_k(ndofx,ngf)\n    real(dp)       :: ucf_k(ndofx,ncf)\n    real(dp)       :: upf_k(ndofx,npf)\n    real(dp)       :: uaf_k(ndofx,naf)\n    type(meshtype) :: meshx(3)\n\n    ! --- amrex ---\n\n    integer                       :: ilevel\n    integer                       :: lo_g(4), hi_g(4)\n    integer                       :: lo_f(4), hi_f(4)\n    type(amrex_box)               :: bx\n    type(amrex_mfiter)            :: mfi\n    type(amrex_parmparse)         :: pp\n    real(dp), contiguous, pointer :: ugf(:,:,:,:)\n    real(dp), contiguous, pointer :: ucf(:,:,:,:)\n\n    ! --- problem-specific parameters ---\n\n    character(len=:), allocatable :: riemannproblemname\n    real(dp)                      :: x1d, x2d, vs, v2\n    real(dp)                      :: ne(npf), nw(npf), se(npf), sw(npf)\n\n    riemannproblemname = 'dzb2002'\n    call amrex_parmparse_build( pp, 'thornado' )\n      call pp % query( 'riemannproblemname', riemannproblemname )\n    call amrex_parmparse_destroy( pp )\n\n    ugf_k = zero\n    ucf_k = zero\n    upf_k = zero\n    uaf_k = zero\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), 0, &\n               xl(idim), xr(idim) )\n\n    end do\n\n    if( amrex_parallel_ioprocessor() )then\n\n      write(*,*)\n      write(*,'(a4,a,a)') &\n        '', 'riemann problem name: ', trim( riemannproblemname )\n      write(*,*)\n\n    end if\n\n    select case( trim( riemannproblemname ) )\n\n      case( 'dzb2002' )\n\n        x1d = half\n        x2d = half\n\n        ne(ipf_d ) = 0.1_dp\n        ne(ipf_v1) = 0.0_dp\n        ne(ipf_v2) = 0.0_dp\n        ne(ipf_v3) = 0.0_dp\n        ne(ipf_e ) = 0.01_dp / ( gamma_ideal - one )\n\n        nw(ipf_d ) = 0.1_dp\n        nw(ipf_v1) = 0.99_dp\n        nw(ipf_v2) = 0.0_dp\n        nw(ipf_v3) = 0.0_dp\n        nw(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        sw(ipf_d ) = 0.5_dp\n        sw(ipf_v1) = 0.0_dp\n        sw(ipf_v2) = 0.0_dp\n        sw(ipf_v3) = 0.0_dp\n        sw(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        se(ipf_d ) = 0.1_dp\n        se(ipf_v1) = 0.0_dp\n        se(ipf_v2) = 0.99_dp\n        se(ipf_v3) = 0.0_dp\n        se(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n      case( 'isolatedshock' )\n\n        x1d = half\n        x2d = half\n\n        vs  = 0.01_dp\n\n        ne(ipf_d ) = 1.0_dp\n        ne(ipf_v1) = -0.9_dp\n        ne(ipf_v2) = 0.0_dp\n        ne(ipf_v3) = 0.0_dp\n        ne(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        call computeleftstate &\n               ( vs, &\n                 ne(ipf_d ), &\n                 ne(ipf_v1), &\n                 ne(ipf_e ) * ( gamma_ideal - one ), &\n                 nw(ipf_d ), &\n                 nw(ipf_v1), &\n                 nw(ipf_e ) )\n\n        nw(ipf_v2) = 0.0_dp\n        nw(ipf_v3) = 0.0_dp\n\n        se(ipf_d ) = 1.0_dp\n        se(ipf_v1) = -0.9_dp\n        se(ipf_v2) = 0.0_dp\n        se(ipf_v3) = 0.0_dp\n        se(ipf_e ) = 1.0_dp / ( gamma_ideal - one )\n\n        call computeleftstate &\n               ( vs, &\n                 se(ipf_d ), &\n                 se(ipf_v1), &\n                 se(ipf_e ) * ( gamma_ideal - one ), &\n                 sw(ipf_d ), &\n                 sw(ipf_v1), &\n                 sw(ipf_e ) )\n\n        sw(ipf_v2) = 0.0_dp\n        sw(ipf_v3) = 0.0_dp\n\n      case default\n\n        if( amrex_parallel_ioprocessor() )then\n\n          write(*,*)\n          write(*,'(a,a)') &\n            'invalid choice for riemannproblemname: ', &\n            trim( riemannproblemname )\n          write(*,'(a)') 'valid choices:'\n          write(*,'(a)') &\n            \"  'dzb2002' - &\n            del zanna & bucciantini (2002) aa, 390, 1177, figure 6\"\n          write(*,'(a)') '  isolatedshock'\n          write(*,*)\n          write(*,'(a)') 'stopping...'\n\n        end if\n\n        call describeerror_euler( 99 )\n\n    end select\n\n    if( amrex_parallel_ioprocessor() )then\n\n      if( trim( riemannproblemname ) .eq. 'isolatedshock' )then\n\n        write(*,'(6x,a,es14.6e3)') 'shock velocity = ', vs\n        write(*,*)\n\n      end if\n\n      write(*,'(6x,a,f8.6)') 'gamma_ideal = ', gamma_ideal\n      write(*,*)\n      write(*,'(6x,a,f8.6)') 'x1d = ', x1d\n      write(*,'(6x,a,f8.6)') 'x2d = ', x2d\n      write(*,*)\n      write(*,'(6x,a)') 'ne:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', ne(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', ne(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', ne(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', ne(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', ne(ipf_e )\n      write(*,*)\n      write(*,'(6x,a)') 'nw:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', nw(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', nw(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', nw(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', nw(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', nw(ipf_e )\n      write(*,*)\n      write(*,'(6x,a)') 'sw:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', sw(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', sw(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', sw(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', sw(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', sw(ipf_e )\n      write(*,*)\n      write(*,'(6x,a)') 'se:'\n      write(*,*)\n      write(*,'(8x,a,es14.6e3)') 'pf_d  = ', se(ipf_d )\n      write(*,'(8x,a,es14.6e3)') 'pf_v1 = ', se(ipf_v1)\n      write(*,'(8x,a,es14.6e3)') 'pf_v2 = ', se(ipf_v2)\n      write(*,'(8x,a,es14.6e3)') 'pf_v3 = ', se(ipf_v3)\n      write(*,'(8x,a,es14.6e3)') 'pf_e  = ', se(ipf_e )\n      write(*,*)\n\n    end if\n\n    do ilevel = 0, nlevels-1\n\n      call amrex_mfiter_build( mfi, mf_ugf(ilevel), tiling = usetiling )\n\n      do while( mfi % next() )\n\n        ugf => mf_ugf(ilevel) % dataptr( mfi )\n        ucf => mf_ucf(ilevel) % dataptr( mfi )\n\n        bx = mfi % tilebox()\n\n        lo_g = lbound( ugf )\n        hi_g = ubound( ugf )\n\n        lo_f = lbound( ucf )\n        hi_f = ubound( ucf )\n\n        do ix3 = bx % lo(3), bx % hi(3)\n        do ix2 = bx % lo(2), bx % hi(2)\n        do ix1 = bx % lo(1), bx % hi(1)\n\n          ugf_k &\n            = reshape( ugf(ix1,ix2,ix3,lo_g(4):hi_g(4)), [ ndofx, ngf ] )\n\n          do inx = 1, ndofx\n\n            inx1 = nodenumbertablex(1,inx)\n            inx2 = nodenumbertablex(2,inx)\n\n            x1 = nodecoordinate( meshx(1), ix1, inx1 )\n            x2 = nodecoordinate( meshx(2), ix2, inx2 )\n\n            ! --- ne ---\n            if     ( x1 .gt. x1d .and. x2 .gt. x2d )then\n\n              upf_k(inx,ipf_d ) = ne(ipf_d )\n              upf_k(inx,ipf_v1) = ne(ipf_v1)\n              upf_k(inx,ipf_v2) = ne(ipf_v2)\n              upf_k(inx,ipf_v3) = ne(ipf_v3)\n              upf_k(inx,ipf_e ) = ne(ipf_e )\n\n            ! --- nw ---\n            else if( x1 .le. x1d .and. x2 .gt. x2d )then\n\n              upf_k(inx,ipf_d ) = nw(ipf_d )\n              upf_k(inx,ipf_v1) = nw(ipf_v1)\n              upf_k(inx,ipf_v2) = nw(ipf_v2)\n              upf_k(inx,ipf_v3) = nw(ipf_v3)\n              upf_k(inx,ipf_e ) = nw(ipf_e )\n\n            ! --- sw ---\n            else if( x1 .le. x1d .and. x2 .le. x2d )then\n\n              upf_k(inx,ipf_d ) = sw(ipf_d )\n              upf_k(inx,ipf_v1) = sw(ipf_v1)\n              upf_k(inx,ipf_v2) = sw(ipf_v2)\n              upf_k(inx,ipf_v3) = sw(ipf_v3)\n              upf_k(inx,ipf_e ) = sw(ipf_e )\n\n            ! --- se ---\n            else\n\n              upf_k(inx,ipf_d ) = se(ipf_d )\n              upf_k(inx,ipf_v1) = se(ipf_v1)\n              upf_k(inx,ipf_v2) = se(ipf_v2)\n              upf_k(inx,ipf_v3) = se(ipf_v3)\n              upf_k(inx,ipf_e ) = se(ipf_e )\n\n            end if\n\n            if( trim( riemannproblemname ) .eq. 'isolatedshock' )then\n\n              ! --- perturb velocity in x2-direction ---\n              call random_number( v2 )\n              upf_k(inx,ipf_v2) = 1.0e-13_dp * ( two * v2 - one )\n\n            end if\n\n          end do\n\n          call computepressurefromprimitive &\n                 ( upf_k(:,ipf_d), upf_k(:,ipf_e), upf_k(:,ipf_ne), &\n                   uaf_k(:,iaf_p) )\n\n          call computeconserved_euler &\n                 ( upf_k(:,ipf_d ), upf_k(:,ipf_v1), upf_k(:,ipf_v2), &\n                   upf_k(:,ipf_v3), upf_k(:,ipf_e ), upf_k(:,ipf_ne), &\n                   ucf_k(:,icf_d ), ucf_k(:,icf_s1), ucf_k(:,icf_s2), &\n                   ucf_k(:,icf_s3), ucf_k(:,icf_e ), ucf_k(:,icf_ne), &\n                   ugf_k(:,igf_gm_dd_11), &\n                   ugf_k(:,igf_gm_dd_22), &\n                   ugf_k(:,igf_gm_dd_33), &\n                   uaf_k(:,iaf_p) )\n\n          ucf(ix1,ix2,ix3,lo_f(4):hi_f(4)) &\n            = reshape( ucf_k, [ hi_f(4) - lo_f(4) + 1 ] )\n\n        end do\n        end do\n        end do\n\n      end do\n\n      call amrex_mfiter_destroy( mfi )\n\n    end do\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n  end subroutine initializefields_riemannproblem2d\n"}
{"id": 1025, "subroutine": "  subroutine initializefields_kelvinhelmholtz( mf_ugf, mf_ucf )\n\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n\n    ! --- thornado ---\n\n    integer        :: idim\n    integer        :: ix1, ix2, ix3\n    integer        :: inx, inx1, inx2\n    real(dp)       :: x1, x2\n    real(dp)       :: ugf_k(ndofx,ngf)\n    real(dp)       :: ucf_k(ndofx,ncf)\n    real(dp)       :: upf_k(ndofx,npf)\n    real(dp)       :: uaf_k(ndofx,naf)\n    type(meshtype) :: meshx(3)\n\n    ! --- amrex ---\n\n    integer                       :: ilevel\n    integer                       :: lo_g(4), hi_g(4)\n    integer                       :: lo_f(4), hi_f(4)\n    type(amrex_box)               :: bx\n    type(amrex_mfiter)            :: mfi\n    real(dp), contiguous, pointer :: ugf(:,:,:,:)\n    real(dp), contiguous, pointer :: ucf(:,:,:,:)\n\n    ! --- problem-dependent parameters ---\n\n    real(dp) :: a      = 0.01_dp\n    real(dp) :: vshear = half\n    real(dp) :: a0     = 0.1_dp ! --- perturbation amplitude ---\n    real(dp) :: sigma  = 0.1_dp\n    real(dp) :: rho0   = 0.505_dp\n    real(dp) :: rho1   = 0.495_dp\n\n    ugf_k = zero\n    ucf_k = zero\n    upf_k = zero\n    uaf_k = zero\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), 0, &\n               xl(idim), xr(idim) )\n\n    end do\n\n    do ilevel = 0, nlevels-1\n\n      call amrex_mfiter_build( mfi, mf_ugf(ilevel), tiling = usetiling )\n\n      do while( mfi % next() )\n\n        ugf => mf_ugf(ilevel) % dataptr( mfi )\n        ucf => mf_ucf(ilevel) % dataptr( mfi )\n\n        bx = mfi % tilebox()\n\n        lo_g = lbound( ugf )\n        hi_g = ubound( ugf )\n\n        lo_f = lbound( ucf )\n        hi_f = ubound( ucf )\n\n        do ix3 = bx % lo(3), bx % hi(3)\n        do ix2 = bx % lo(2), bx % hi(2)\n        do ix1 = bx % lo(1), bx % hi(1)\n\n          ugf_k &\n            = reshape( ugf(ix1,ix2,ix3,lo_g(4):hi_g(4)), [ ndofx, ngf ] )\n\n          do inx = 1, ndofx\n\n            inx1 = nodenumbertablex(1,inx)\n            inx2 = nodenumbertablex(2,inx)\n\n            x1 = nodecoordinate( meshx(1), ix1, inx1 )\n            x2 = nodecoordinate( meshx(2), ix2, inx2 )\n\n            ! --- v1 ---\n            if( x2 .gt. zero )then\n\n              upf_k(inx,ipf_v1) &\n                = +vshear * tanh( ( x2 - half ) / a )\n\n            else\n\n              ! --- paper has a typo here, the minus sign is required ---\n              upf_k(inx,ipf_v1) &\n                = -vshear * tanh( ( x2 + half ) / a )\n\n            end if\n\n            ! --- v2 ---\n            if( x2 .gt. zero )then\n\n              upf_k(inx,ipf_v2) &\n                =  a0 * vshear * sin( twopi * x1 ) &\n                    * exp( -( ( x2 - half )**2 / sigma**2 ) )\n\n            else\n\n              upf_k(inx,ipf_v2) &\n                = -a0 * vshear * sin( twopi * x1 ) &\n                    * exp( -( ( x2 + half )**2 / sigma**2 ) )\n\n            end if\n\n            ! --- rho ---\n            if( x2 .gt. zero )then\n\n              upf_k(inx,ipf_d) &\n                = rho0 + rho1 * tanh( ( x2 - half ) / a )\n\n            else\n\n              upf_k(inx,ipf_d) &\n                = rho0 - rho1 * tanh( ( x2 + half ) / a )\n\n            end if\n\n            upf_k(inx,ipf_v3) = zero\n            upf_k(inx,ipf_e)  = one / ( gamma_ideal - one )\n\n          end do\n\n          call computepressurefromprimitive &\n                 ( upf_k(:,ipf_d), upf_k(:,ipf_e), upf_k(:,ipf_ne), &\n                   uaf_k(:,iaf_p) )\n\n          call computeconserved_euler &\n                 ( upf_k(:,ipf_d ), upf_k(:,ipf_v1), upf_k(:,ipf_v2), &\n                   upf_k(:,ipf_v3), upf_k(:,ipf_e ), upf_k(:,ipf_ne), &\n                   ucf_k(:,icf_d ), ucf_k(:,icf_s1), ucf_k(:,icf_s2), &\n                   ucf_k(:,icf_s3), ucf_k(:,icf_e ), ucf_k(:,icf_ne), &\n                   ugf_k(:,igf_gm_dd_11), &\n                   ugf_k(:,igf_gm_dd_22), &\n                   ugf_k(:,igf_gm_dd_33), &\n                   uaf_k(:,iaf_p) )\n\n          ucf(ix1,ix2,ix3,lo_f(4):hi_f(4)) &\n            = reshape( ucf_k, [ hi_f(4) - lo_f(4) + 1 ] )\n\n        end do\n        end do\n        end do\n\n      end do\n\n      call amrex_mfiter_destroy( mfi )\n\n    end do\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n  end subroutine initializefields_kelvinhelmholtz\n"}
{"id": 1026, "subroutine": "  subroutine initializefields_standingaccretionshock_relativistic &\n    ( mf_ugf, mf_ucf, geom )\n\n    type(amrex_multifab), intent(in)    :: mf_ugf(0:nlevels-1)\n    type(amrex_multifab), intent(inout) :: mf_ucf(0:nlevels-1)\n    type(amrex_geometry), intent(in)    :: geom  (0:nlevels-1)\n\n    ! --- thornado ---\n\n    integer        :: idim\n    integer        :: ix1, ix2, ix3\n    integer        :: inx, inx1, inx2\n    real(dp)       :: x1, x2\n    real(dp)       :: ugf_k(ndofx,ngf)\n    real(dp)       :: ucf_k(ndofx,ncf)\n    real(dp)       :: upf_k(ndofx,npf)\n    real(dp)       :: uaf_k(ndofx,naf)\n    type(meshtype) :: meshx(3)\n\n    ! --- amrex ---\n\n    integer                       :: ilevel\n    integer                       :: lo_g(4), hi_g(4)\n    integer                       :: lo_f(4), hi_f(4)\n    type(amrex_box)               :: bx\n    type(amrex_mfiter)            :: mfi\n    real(dp), contiguous, pointer :: ugf(:,:,:,:)\n    real(dp), contiguous, pointer :: ucf(:,:,:,:)\n    type(amrex_parmparse)         :: pp\n\n    ! --- problem-dependent parameters ---\n\n    real(dp) :: masspns, shockradius, accretionrate, polytropicconstant\n    logical  :: applyperturbation\n    integer  :: perturbationorder\n    real(dp) :: perturbationamplitude\n    real(dp) :: rperturbationinner\n    real(dp) :: rperturbationouter\n\n    integer  :: ix1_1, ix1_2, inx1_1, inx1_2\n    integer  :: ix_b0(3), ix_e0(3), ix_b1(3), ix_e1(3), ix_b(3), ix_e(3)\n    real(dp) :: x1_1, x1_2, d_1, d_2, v_1, v_2, p_1, p_2\n    real(dp) :: d0, v0, p0\n    real(dp) :: ka, kb, mdot, advectiontime\n    real(dp), allocatable :: g    (:,:,:,:,:)\n    real(dp), allocatable :: d    (:,:)\n    real(dp), allocatable :: v    (:,:)\n    real(dp), allocatable :: p    (:,:)\n    real(dp), allocatable :: alpha(:,:)\n    real(dp), allocatable :: psi  (:,:)\n    logical               :: initializefromfile, resetendtime\n    integer, parameter    :: nx_leastsquares = 5\n\n    applyperturbation                 = .false.\n    perturbationorder                 = 0\n    perturbationamplitude             = zero\n    rperturbationinner                = zero\n    rperturbationouter                = zero\n    initializefromfile                = .false.\n    resetendtime                      = .false.\n    writenodal1dic_sas                = .false.\n    filename_nodal1dic_sas            = 'nodal1dic_sas.dat'\n    accretionshockdiagnosticsfilename = 'accretionshockdiagnostics.dat'\n    call amrex_parmparse_build( pp, 'sas' )\n      call pp % get  ( 'mass', &\n                        masspns )\n      call pp % get  ( 'accretionrate', &\n                        accretionrate )\n      call pp % get  ( 'shockradius', &\n                        shockradius )\n      call pp % query( 'applyperturbation', &\n                        applyperturbation )\n      call pp % query( 'perturbationorder', &\n                        perturbationorder )\n      call pp % query( 'perturbationamplitude', &\n                        perturbationamplitude )\n      call pp % query( 'rperturbationinner', &\n                        rperturbationinner )\n      call pp % query( 'rperturbationouter', &\n                        rperturbationouter )\n      call pp % query( 'initializefromfile', &\n                        initializefromfile )\n      call pp % query( 'resetendtime', &\n                        resetendtime )\n      call pp % query( 'writenodal1dic_sas', &\n                        writenodal1dic_sas )\n      call pp % query( 'filename_nodal1dic_sas', &\n                        filename_nodal1dic_sas )\n      call pp % query( 'accretionshockdiagnosticsfilename', &\n                        accretionshockdiagnosticsfilename )\n    call amrex_parmparse_destroy( pp )\n\n    masspns            = masspns            * solarmass\n    accretionrate      = accretionrate      * ( solarmass / second )\n    shockradius        = shockradius        * kilometer\n    polytropicconstant = 2.0e14_dp &\n                           * ( erg / centimeter**3 &\n                           / ( gram / centimeter**3 )**( gamma_ideal ) )\n    rperturbationinner = rperturbationinner * kilometer\n    rperturbationouter = rperturbationouter * kilometer\n\n    mdot = accretionrate\n    ka   = polytropicconstant\n\n    if( amrex_parallel_ioprocessor() )then\n\n      write(*,*)\n\n      write(*,'(6x,a,l)') &\n        'initializefromfile:              ', &\n        initializefromfile\n\n      write(*,'(6x,a,a)') &\n        'filename_nodal1dic_sas:          ', &\n        trim( filename_nodal1dic_sas )\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'shock radius:                    ', &\n        shockradius / kilometer, &\n        ' km'\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'pns mass:                        ', &\n        masspns / solarmass, &\n        ' msun'\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'accretion rate:                  ', &\n        accretionrate / ( solarmass / second ), &\n        ' msun/s'\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'polytropic constant (pre-shock): ', &\n        ka / ( ( erg / centimeter**3 ) &\n          / ( gram / centimeter**3 )**( gamma_ideal ) ), &\n        ' erg/cm^3 / (g/cm^3)^( gamma )'\n\n      write(*,*)\n\n      write(*,'(6x,a,l)') &\n        'apply perturbation:           ', &\n        applyperturbation\n\n      write(*,'(6x,a,i1)') &\n        'perturbation order:           ', &\n        perturbationorder\n\n      write(*,'(6x,a,es9.2e3)') &\n        'perturbation amplitude:       ', &\n         perturbationamplitude\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'inner radius of perturbation: ', &\n        rperturbationinner / kilometer, ' km'\n\n      write(*,'(6x,a,es9.2e3,a)') &\n        'outer radius of perturbation: ', &\n        rperturbationouter / kilometer, ' km'\n\n      write(*,*)\n\n      write(*,'(6x,a,l)') &\n        'reset end-time:  ', &\n        resetendtime\n\n    end if\n\n    ugf_k = zero\n    ucf_k = zero\n    upf_k = zero\n    uaf_k = zero\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), swx(idim), &\n               xl(idim), xr(idim) )\n\n    end do\n\n    ix_b1 = [1,1,1] - swx\n    ix_e1 = nx      + swx\n\n    allocate( g    (1:ndofx     ,ix_b1(1):ix_e1(1), &\n                                 ix_b1(2):ix_e1(2), &\n                                 ix_b1(3):ix_e1(3),1:ngf) )\n    allocate( d    (1:nnodesx(1),ix_b1(1):ix_e1(1)) )\n    allocate( v    (1:nnodesx(1),ix_b1(1):ix_e1(1)) )\n    allocate( p    (1:nnodesx(1),ix_b1(1):ix_e1(1)) )\n    allocate( alpha(1:nnodesx(1),ix_b1(1):ix_e1(1)) )\n    allocate( psi  (1:nnodesx(1),ix_b1(1):ix_e1(1)) )\n\n    if( initializefromfile )then\n\n      call readfluidfieldsfromfile( ix_b1, ix_e1, d, v, p )\n\n    else\n\n      ! --- make local copies of lapse and conformal factor ---\n\n      call amrex2thornado_x_global( geom, mf_ugf, ngf, g )\n\n      do ix1 = ix_b1(1), ix_e1(1)\n\n        alpha(:,ix1) = g(1:nnodesx(1),ix1,1,1,igf_alpha)\n        psi  (:,ix1) = g(1:nnodesx(1),ix1,1,1,igf_psi)\n\n      end do\n\n      ! --- quantities with _1 are pre-shock, those with _2 are post-shock ---\n\n      call locatefirstunshockedelement &\n             ( ix_b1, ix_e1, shockradius, meshx, &\n               ix1_1, ix1_2, inx1_1, inx1_2, x1_1, x1_2 )\n\n      ! --- pre-shock fields ---\n\n      x1 = nodecoordinate( meshx(1), ix_e1(1), nnodesx(1) )\n\n      ! --- use newtonian values as initial guesses ---\n\n      v0 = -sqrt( two * gravitationalconstant * masspns / x1 )\n      d0 = -mdot / ( fourpi * x1**2 * v0 )\n      p0 = ka * d0**( gamma_ideal )\n\n      do ix1 = ix_e1(1), ix1_1, -1\n\n        do inx1 = nnodesx(1), 1, -1\n\n          x1 = nodecoordinate( meshx(1), ix1, inx1 )\n\n          if( x1 .le. shockradius ) cycle\n\n          call newtonraphson_sas &\n                 ( x1, masspns, ka, mdot, &\n                   alpha(inx1,ix1), psi(inx1,ix1), d0, v0, p0, &\n                   d(inx1,ix1), v(inx1,ix1), p(inx1,ix1) )\n\n          d0 = d(inx1,ix1)\n          v0 = v(inx1,ix1)\n          p0 = p(inx1,ix1)\n\n        end do\n\n      end do\n\n      ! --- apply jump conditions ---\n\n      d_1 = d(inx1_1,ix1_1)\n      v_1 = v(inx1_1,ix1_1)\n      p_1 = p(inx1_1,ix1_1)\n\n      call applyjumpconditions_sas &\n             ( psi(inx1_1,ix1), d_1, v_1, p_1, d_2, v_2, p_2 )\n\n      kb = p_2 / d_2**( gamma_ideal )\n\n      if( amrex_parallel_ioprocessor() )then\n\n        write(*,*)\n        write(*,'(6x,a)') 'jump conditions'\n        write(*,'(6x,a)') '---------------'\n        write(*,*)\n        write(*,'(8x,a)') 'pre-shock:'\n        write(*,'(10x,a,i4.4)')       'ix1      = ', ix1_1\n        write(*,'(10x,a,i2.2)')       'inx1     = ', inx1_1\n        write(*,'(10x,a,es13.6e3,a)') 'x1       = ', x1_1 / kilometer, '  km'\n        write(*,'(10x,a,es13.6e3,a)') 'density  = ', &\n          d_1 / ( gram / centimeter**3 ), '  g/cm^3'\n        write(*,'(10x,a,es14.6e3,a)') 'velocity = ', &\n          v_1 / ( kilometer / second ), ' km/s'\n        write(*,'(10x,a,es13.6e3,a)') 'pressure = ', &\n          p_1 / ( erg / centimeter**3 ), '  erg/cm^3'\n        write(*,*)\n        write(*,'(8x,a)') 'post-shock:'\n        write(*,'(10x,a,i4.4)')       'ix1      = ', ix1_2\n        write(*,'(10x,a,i2.2)')       'inx1     = ', inx1_2\n        write(*,'(10x,a,es13.6e3,a)') 'x1       = ', x1_2 / kilometer, '  km'\n        write(*,'(10x,a,es13.6e3,a)') 'density  = ', &\n          d_2 / ( gram / centimeter**3 ), '  g/cm^3'\n        write(*,'(10x,a,es14.6e3,a)') 'velocity = ', &\n          v_2 / ( kilometer / second ), ' km/s'\n        write(*,'(10x,a,es13.6e3,a)') 'pressure = ', &\n          p_2 / ( erg / centimeter**3 ), '  erg/cm^3'\n        write(*,*)\n\n      end if\n\n      ! --- post-shock fields ---\n\n      advectiontime = zero\n\n      d0 = d_2\n      v0 = v_2\n      p0 = p_2\n\n      do ix1 = ix1_2, ix_b1(1), -1\n\n        do inx1 = nnodesx(1), 1, -1\n\n          x1 = nodecoordinate( meshx(1), ix1, inx1 )\n\n          if( x1 .gt. shockradius ) cycle\n\n          call newtonraphson_sas &\n                 ( x1, masspns, kb, mdot, &\n                   alpha(inx1,ix1), psi(inx1,ix1), d0, v0, p0, &\n                   d(inx1,ix1), v(inx1,ix1), p(inx1,ix1) )\n\n          d0 = d(inx1,ix1)\n          v0 = v(inx1,ix1)\n          p0 = p(inx1,ix1)\n\n          advectiontime &\n            = advectiontime &\n                + weightsx1(inx1) * meshx(1) % width(ix1) / abs( v(inx1,ix1) )\n\n        end do\n\n      end do\n\n      if( resetendtime ) &\n        t_end = 4.0_dp * advectiontime\n\n    end if\n\n    ! --- map to 3d domain ---\n\n    do ilevel = 0, nlevels-1\n\n      call amrex_mfiter_build( mfi, mf_ugf(ilevel), tiling = usetiling )\n\n      do while( mfi % next() )\n\n        ugf => mf_ugf(ilevel) % dataptr( mfi )\n        ucf => mf_ucf(ilevel) % dataptr( mfi )\n\n        bx = mfi % tilebox()\n\n        lo_g = lbound( ugf )\n        hi_g = ubound( ugf )\n\n        lo_f = lbound( ucf )\n        hi_f = ubound( ucf )\n\n        ix_b0 = bx % lo\n        ix_e0 = bx % hi\n        ix_b1 = bx % lo - swx\n        ix_e1 = bx % hi + swx\n\n        ix_b(1) = ix_b0(1)\n        ix_e(1) = ix_e0(1)\n\n        if( bx % lo(1) .eq. 1     ) ix_b(1) = ix_b1(1)\n        if( bx % hi(1) .eq. nx(1) ) ix_e(1) = ix_e1(1)\n\n        do ix3 = ix_b0(3), ix_e0(3)\n        do ix2 = ix_b0(2), ix_e0(2)\n        do ix1 = ix_b (1), ix_e (1)\n\n          ugf_k &\n            = reshape( ugf(ix1,ix2,ix3,lo_g(4):hi_g(4)), [ ndofx, ngf ] )\n\n          do inx = 1, ndofx\n\n            inx1 = nodenumbertablex(1,inx)\n            inx2 = nodenumbertablex(2,inx)\n\n            if( applyperturbation )then\n\n              x1 = nodecoordinate( meshx(1), ix1, inx1 )\n              x2 = nodecoordinate( meshx(2), ix2, inx2 )\n\n              if( x1 .ge. rperturbationinner &\n                    .and. x1 .le. rperturbationouter )then\n\n                if( perturbationorder .eq. 0 ) &\n                  upf_k(inx,ipf_d) &\n                    = d(inx1,ix1) &\n                        * ( one + perturbationamplitude )\n\n                if( perturbationorder .eq. 1 ) &\n                  upf_k(inx,ipf_d) &\n                    = d(inx1,ix1) &\n                        * ( one + perturbationamplitude * cos( x2 ) )\n\n              else\n\n                upf_k(inx,ipf_d) = d(inx1,ix1)\n\n              end if\n\n            else\n\n              upf_k(inx,ipf_d) = d(inx1,ix1)\n\n            end if\n\n            upf_k(inx,ipf_v1) = v(inx1,ix1)\n            upf_k(inx,ipf_v2) = zero\n            upf_k(inx,ipf_v3) = zero\n            upf_k(inx,ipf_e ) = p(inx1,ix1) / ( gamma_ideal - one )\n\n          end do\n\n          call computepressurefromprimitive &\n                 ( upf_k(:,ipf_d), upf_k(:,ipf_e), upf_k(:,ipf_ne), &\n                   uaf_k(:,iaf_p) )\n\n          call computeconserved_euler &\n                 ( upf_k(:,ipf_d ), upf_k(:,ipf_v1), upf_k(:,ipf_v2), &\n                   upf_k(:,ipf_v3), upf_k(:,ipf_e ), upf_k(:,ipf_ne), &\n                   ucf_k(:,icf_d ), ucf_k(:,icf_s1), ucf_k(:,icf_s2), &\n                   ucf_k(:,icf_s3), ucf_k(:,icf_e ), ucf_k(:,icf_ne), &\n                   ugf_k(:,igf_gm_dd_11), &\n                   ugf_k(:,igf_gm_dd_22), &\n                   ugf_k(:,igf_gm_dd_33), &\n                   uaf_k(:,iaf_p) )\n\n          ucf(ix1,ix2,ix3,lo_f(4):hi_f(4)) &\n            = reshape( ucf_k, [ hi_f(4) - lo_f(4) + 1 ] )\n\n        end do\n        end do\n        end do\n\n      end do\n\n    end do\n\n    deallocate( psi     )\n    deallocate( alpha   )\n    deallocate( p )\n    deallocate( v )\n    deallocate( d )\n    deallocate( g )\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n    call computeextrapolationexponents( mf_ucf, geom, nx_leastsquares )\n\n    if( amrex_parallel_ioprocessor() )then\n\n      if( .not. initializefromfile ) &\n        write(*,'(6x,a,es13.6e3,a)') &\n          'advection time:  ', &\n          advectiontime / millisecond, ' ms'\n\n      write(*,'(6x,a,i2.2)') &\n        'nx_leastsquares: ', &\n        nx_leastsquares\n      write(*,'(6x,a,f8.6)') &\n        'expd:            ', &\n        expd\n      write(*,'(6x,a,f8.6)') &\n        'expe:            ', &\n        expe\n\n    end if\n\n  end subroutine initializefields_standingaccretionshock_relativistic\n"}
{"id": 1027, "subroutine": "  subroutine computeextrapolationexponents( mf_ucf, geom, nx_leastsquares )\n\n    type(amrex_multifab), intent(in) :: mf_ucf(0:nlevels-1)\n    type(amrex_geometry), intent(in) :: geom  (0:nlevels-1)\n    integer             , intent(in) :: nx_leastsquares\n\n    real(dp) :: lnr   (nnodesx(1),1-swx(1):nx(1)+swx(1))\n    real(dp) :: lnd   (nnodesx(1),1-swx(1):nx(1)+swx(1))\n    real(dp) :: lne   (nnodesx(1),1-swx(1):nx(1)+swx(1))\n    real(dp) :: u(ndofx          ,1-swx(1):nx(1)+swx(1), &\n                                  1-swx(2):nx(2)+swx(2), &\n                                  1-swx(3):nx(3)+swx(3),ncf)\n    real(dp) :: lnr_ls(nnodesx(1),nx_leastsquares)\n    real(dp) :: lnd_ls(nnodesx(1),nx_leastsquares)\n    real(dp) :: lne_ls(nnodesx(1),nx_leastsquares)\n\n    integer  :: ix1, inx1, idim\n    real(dp) :: n\n\n    type(meshtype) :: meshx(3)\n\n    do idim = 1, 3\n\n      call createmesh &\n             ( meshx(idim), nx(idim), nnodesx(idim), swx(idim), &\n               xl(idim), xr(idim) )\n\n    end do\n\n    ! --- make local copies of x1, d, and tau ---\n\n    call amrex2thornado_x_global( geom, mf_ucf, ncf, u )\n\n    do ix1 = 1-swx(1), nx(1)+swx(1)\n\n      do inx1 = 1, nnodesx(1)\n\n        lnr(inx1,ix1) = log( nodecoordinate( meshx(1), ix1, inx1 ) )\n        lnd(inx1,ix1) = u(inx1,ix1,1,1,icf_d)\n        lne(inx1,ix1) = u(inx1,ix1,1,1,icf_e)\n\n      end do\n\n    end do\n\n    lnd = log( lnd )\n    lne = log( lne )\n\n    lnr_ls = lnr(:,1:nx_leastsquares)\n    lnd_ls = lnd(:,1:nx_leastsquares)\n    lne_ls = lne(:,1:nx_leastsquares)\n\n    n = dble( nnodesx(1) ) * dble( nx_leastsquares )\n\n    ! --- expression for exponents from:\n    !     https://mathworld.wolfram.com/leastsquaresfittingpowerlaw.html ---\n\n    expd = -( n * sum( lnr_ls * lnd_ls ) - sum( lnr_ls ) * sum( lnd_ls ) ) &\n             / ( n * sum( lnr_ls**2 ) - sum( lnr_ls )**2 )\n\n    expe = -( n * sum( lnr_ls * lne_ls ) - sum( lnr_ls ) * sum( lne_ls ) ) &\n             / ( n * sum( lnr_ls**2 ) - sum( lnr_ls )**2 )\n\n    do idim = 1, 3\n\n      call destroymesh( meshx(idim) )\n\n    end do\n\n  end subroutine computeextrapolationexponents\n"}
{"id": 1028, "subroutine": "  subroutine readfluidfieldsfromfile( ix_b1, ix_e1, d, v, p )\n\n    integer,  intent(in)  :: ix_b1(3), ix_e1(3)\n    real(dp), intent(out) :: d(1:,ix_b1(1):), v(1:,ix_b1(1):), p(1:,ix_b1(1):)\n\n    character(len=16) :: fmt\n    integer           :: ix1\n\n    open( unit = 101, file = trim( filename_nodal1dic_sas ) )\n\n    read(101,*) fmt\n\n    do ix1 = ix_b1(1), ix_e1(1)\n\n      read(101,trim(fmt)) d(:,ix1)\n      read(101,trim(fmt)) v(:,ix1)\n      read(101,trim(fmt)) p(:,ix1)\n\n    end do\n\n    close( 101 )\n\n  end subroutine readfluidfieldsfromfile\n"}
{"id": 1029, "subroutine": "  subroutine newtonraphson_sas &\n    ( x1, masspns, k, mdot, alpha, psi, d0, v0, p0, d, v, p )\n\n    real(dp), intent(in)  :: x1, masspns, k, &\n                             mdot, alpha, psi, d0, v0, p0\n    real(dp), intent(out) :: d ,v ,p\n\n    real(dp) :: w\n    real(dp) :: jac(3,3), invjac(3,3)\n    real(dp) :: f(3), uo(3), un(3), du(3)\n\n    logical             :: converged\n    integer             :: iter\n    real(dp), parameter :: tolu = 1.0e-16_dp\n    real(dp), parameter :: tolf = 1.0e-16_dp\n    integer,  parameter :: max_iter = 4 - int( log( tolu ) /  log( two ) )\n\n    uo(1) = one\n    uo(2) = one\n    uo(3) = one\n\n    converged = .false.\n    iter      = 0\n    do while( .not. converged .and. iter .lt. max_iter )\n\n      iter = iter + 1\n\n      w = lorentzfactor( psi, v0 * uo(2) )\n\n      f(1) &\n        = fourpi * alpha * psi**6 * x1**2 / mdot * d0 * v0 &\n            * uo(1) * w * uo(2) + one\n      f(2) &\n        = alpha * ( one + gamma_ideal / ( gamma_ideal - one ) &\n                      * p0 / ( d0 * speedoflight**2 ) * uo(3) / uo(1) ) * w &\n            - one\n      f(3) &\n        = p0 * d0**( -gamma_ideal ) / k * uo(3) * uo(1)**( -gamma_ideal ) - one\n\n      jac(1,1) = fourpi * alpha * psi**6 * x1**2 / mdot * d0 * v0 &\n                   * w * uo(2)\n      jac(1,2) = fourpi * alpha * psi**6 * x1**2 / mdot * d0 * v0 &\n                   * uo(1) * w**3\n      jac(1,3) = zero\n      jac(2,1) = -alpha * gamma_ideal / ( gamma_ideal - one ) &\n                   * p0 / ( d0 * speedoflight**2 ) * uo(3) / uo(1)**2 * w\n      jac(2,2) = alpha * ( one + gamma_ideal / ( gamma_ideal - one ) &\n                   * p0 / ( d0 * speedoflight**2 ) * uo(3) / uo(1) ) &\n                   * w**3 * psi**4 * v0**2 / speedoflight**2 * uo(2)\n      jac(2,3) = alpha * gamma_ideal / ( gamma_ideal - one ) &\n                   * p0 / ( d0 * speedoflight**2 ) / uo(1) * w\n      jac(3,1) = -p0 * d0**( -gamma_ideal ) / k &\n                   * gamma_ideal * uo(3) * uo(1)**( -gamma_ideal - one )\n      jac(3,2) = zero\n      jac(3,3) = p0 * d0**( -gamma_ideal ) / k &\n                   * uo(1)**( -gamma_ideal )\n\n      invjac = inv3x3( jac )\n\n      un = uo - matmul( invjac, f )\n\n      du = un - uo\n\n      if( maxval( abs( du / uo ) ) .lt. tolu ) converged = .true.\n\n      uo = un\n\n    end do\n\n    d = un(1) * d0\n    v = un(2) * v0\n    p = un(3) * p0\n\n  end subroutine newtonraphson_sas\n"}
{"id": 1030, "subroutine": "  subroutine applyjumpconditions_sas( psi, d_1, v_1, p_1, d_2, v_2, p_2 )\n\n    real(dp), intent(in)  :: psi, d_1, v_1, p_1\n    real(dp), intent(out) ::      d_2, v_2, p_2\n\n    real(dp) :: c1, c2, c3, a, b, c, d, e\n    real(dp) :: w_1, h_1\n    real(dp) :: dx, xa, xb, xc, fa, fb, fc, w_2\n\n    integer             :: iter\n    integer,  parameter :: max_iter = 1000\n    real(dp), parameter :: tolchi = 1.0e-16_dp\n\n    logical :: converged\n\n    w_1 = lorentzfactor( psi, v_1 )\n\n    h_1 = speedoflight**2 + gamma_ideal / ( gamma_ideal - one ) * p_1 / d_1\n\n    c1 = d_1 * w_1 * v_1\n    c2 = d_1 * h_1 * w_1**2 * v_1**2 / speedoflight**2 + psi**( -4 ) * p_1\n    c3 = d_1 * h_1 * w_1**2 * v_1\n\n    a = speedoflight**( -4 ) * ( c3 / c1 )**2 - one\n    b = -two * speedoflight**( 3 ) * c2 * c3 / c1**2 &\n          * gamma_ideal / ( gamma_ideal - one ) * psi**4\n    c = speedoflight**( -2 ) * ( c2 / c1 )**2 &\n          * ( gamma_ideal / ( gamma_ideal - one ) )**2 * psi**8 &\n          + two * speedoflight**( -4 ) * ( c3 / c1 )**2 &\n          / ( gamma_ideal - one ) * psi**4 + psi**4\n    d = -two * speedoflight**( -3 ) * c2 * c3 / c1**2 &\n          * gamma_ideal / ( gamma_ideal - one )**2 * psi**8\n    e = speedoflight**( -4 ) * ( c3 / c1 )**2 &\n          / ( gamma_ideal - one )**2 * psi**8\n\n    ! --- solve with bisection ---\n\n    ! add 1 km/s to exclude smooth solution\n    xa = ( v_1 + one * kilometer / second ) / speedoflight\n\n    xb = 1.0e-10_dp * xa\n\n    fa = a * xa**( -2 ) + b * xa**( -1 ) &\n             + c + d * xa + e * xa**2\n    fb = a * xb**( -2 ) + b * xb**( -1 ) &\n             + c + d * xb + e * xb**2\n\n    dx = xb - xa\n\n    iter      = 0\n    converged = .false.\n    do while( .not. converged .and. iter .lt. max_iter )\n\n      iter = iter + 1\n\n      dx = half * dx\n\n      xc = xa + dx\n\n      fc = a * xc**( -2 ) + b * xc**( -1 ) + c + d * xc + e * xc**2\n\n      if( fa * fc .lt. zero )then\n\n        xb = xc\n        fb = fc\n\n      else if( fa * fc .gt. zero )then\n\n        xa = xc\n        fa = fc\n\n      else\n\n        converged = .true.\n\n      end if\n\n      if( abs( dx / xa ) .lt. tolchi ) converged = .true.\n\n    end do\n\n    v_2 = xc * speedoflight\n\n    w_2 = lorentzfactor( psi, v_2 )\n\n    d_2 = speedoflight**( -1 ) * abs( c1 ) * sqrt( xc**( -2 ) - psi**4 )\n    p_2 = ( c3 - d_2 * speedoflight**2 * w_2**2 * v_2 ) &\n            / ( gamma_ideal / ( gamma_ideal - one ) * w_2**2 * v_2 )\n\n  end subroutine applyjumpconditions_sas\n"}
{"id": 1031, "subroutine": "  subroutine locatefirstunshockedelement &\n    ( ix_b1, ix_e1, shockradius, meshx, &\n      ix1_1, ix1_2, inx1_1, inx1_2, x1_1, x1_2 )\n\n    integer,        intent(in)  :: ix_b1(3), ix_e1(3)\n    real(dp),       intent(in)  :: shockradius\n    type(meshtype), intent(in)  :: meshx(3)\n    integer,        intent(out) :: ix1_1, ix1_2, inx1_1, inx1_2\n    real(dp),       intent(out) :: x1_1, x1_2\n\n    real(dp) :: x1, dx1\n    integer  :: ix1, inx1\n    logical  :: firstpreshockelement = .false.\n\n    x1 = zero\n\n    do ix1 = ix_b1(1), ix_e1(1)\n\n      do inx1 = 1, nnodesx(1)\n\n        dx1 = nodecoordinate( meshx(1), ix1, inx1 ) - x1\n        x1  = nodecoordinate( meshx(1), ix1, inx1 )\n\n        if( x1 .le. shockradius ) cycle\n\n        if( x1 .gt. shockradius .and. .not. firstpreshockelement )then\n\n          ix1_1  = ix1\n          inx1_1 = inx1\n          x1_1   = x1\n          x1_2   = x1 - dx1\n\n          if( inx1_1 .eq. 1 )then\n\n            ix1_2  = ix1_1 - 1\n            inx1_2 = nnodesx(1)\n\n          else\n\n            ix1_2  = ix1_1\n            inx1_2 = inx1_1 - 1\n\n          end if\n\n          firstpreshockelement = .true.\n\n        end if\n\n      end do\n\n    end do\n\n  end subroutine locatefirstunshockedelement\n"}
{"id": 1032, "subroutine": "  subroutine computeleftstate( vs, dr, vr, pr, dl, vl, pl )\n\n    real(dp), intent(in)  :: vs, dr, vr, pr\n    real(dp), intent(out) ::     dl, vl, pl\n\n    call applyjumpconditions_leftstate( vs, dr, vr, pr, dl, vl, pl )\n\n    ! --- return energy-density instead of pressure ---\n    pl = pl / ( gamma_ideal - one )\n\n  end subroutine computeleftstate\n"}
{"id": 1033, "subroutine": "  subroutine applyjumpconditions_leftstate( vs, dr, vr, pr, dl, vl, pl )\n\n    real(dp), intent(in)  :: vs, dr, vr, pr\n    real(dp), intent(out) ::     dl, vl, pl\n\n    real(dp), parameter :: eps = 1.0e-15_dp\n\n    real(dp), parameter :: toldv = eps\n    real(dp), parameter :: tolf  = eps\n    integer,  parameter :: nmaxiter = 1000\n\n    integer :: iteration\n    real(dp) :: d, v, p, f\n    real(dp) :: vmin, vmax, fmin, fmax, vv, ff\n\n    if( vr .lt. zero )then\n\n      vmin = vr   + eps\n      vmax = +one - eps\n\n    else\n\n      vmin = -one + eps\n      vmax = vr   - eps\n\n    end if\n\n    d = density ( vs, dr, vr, vmin )\n    p = pressure( vs, dr, vr, pr, d, vmin )\n    fmin = postshockvelocity( vs, dr, vr, pr, d, vmin, p )\n\n    d = density ( vs, dr, vr, vmax )\n    p = pressure( vs, dr, vr, pr, d, vmax )\n    fmax = postshockvelocity( vs, dr, vr, pr, d, vmax, p )\n\n    if( .not. fmin * fmax .lt. zero )then\n\n      write(*,*) 'root not bracketed. stopping...'\n      write(*,*) 'fmin = ', fmin\n      write(*,*) 'fmax = ', fmax\n\n      call describeerror_euler( 10 )\n\n    end if\n\n    if( fmin .gt. zero )then\n\n      vv = vmax\n      ff = fmax\n\n      vmax = vmin\n      vmin = vv\n\n      fmax = fmin\n      fmin = ff\n\n    end if\n\n    iteration = 0\n    do while( iteration .lt. nmaxiter )\n\n      iteration = iteration + 1\n\n      v = ( vmin + vmax ) / two\n\n      d = density ( vs, dr, vr, v )\n      p = pressure( vs, dr, vr, pr, d, v )\n\n      f = postshockvelocity( vs, dr, vr, pr, d, v, p )\n\n      if( abs( v - vmin ) / max( abs( vmax ), abs( vmin ) ) .lt. toldv ) exit\n\n      if( f .gt. zero )then\n\n        vmax = v\n        fmax = f\n\n     else\n\n        vmin = v\n        fmin = f\n\n     end if\n\n    end do\n\n!!$    write(*,*) 'converged at iteration ', iteration\n!!$    write(*,*) '|f|:  ' , abs( f )\n!!$    write(*,*) 'dv/v: ', abs( v - vmax ) / abs( vmax )\n\n    vl = v\n    dl = density ( vs, dr, vr, vl )\n    pl = pressure( vs, dr, vr, pr, dl, vl )\n\n  end subroutine applyjumpconditions_leftstate\n"}
{"id": 1034, "subroutine": "subroutine initialize_w(is_star,r,w)\n  use iso_fortran_env\n  implicit none\n  logical, intent(in) :: is_star\n  integer(kind=int32), intent(in) :: r\n  real(kind=real64), intent(inout) :: w(-r:r,-r:r)\n  integer(kind=int32) :: ii, jj\n  ! fill the stencil weights to reflect a discrete divergence operator\n  w = 0.0d0\n  if (is_star) then\n    do ii=1,r\n      w(0, ii) =  1.0d0/real(2*ii*r,real64)\n      w(0,-ii) = -1.0d0/real(2*ii*r,real64)\n      w( ii,0) =  1.0d0/real(2*ii*r,real64)\n      w(-ii,0) = -1.0d0/real(2*ii*r,real64)\n    enddo\n  else\n    ! jeff: check that this is correct with the new w indexing\n    do jj=1,r\n      do ii=-jj+1,jj-1\n        w( ii, jj) =  1.0d0/real(4*jj*(2*jj-1)*r,real64)\n        w( ii,-jj) = -1.0d0/real(4*jj*(2*jj-1)*r,real64)\n        w( jj, ii) =  1.0d0/real(4*jj*(2*jj-1)*r,real64)\n        w(-jj, ii) = -1.0d0/real(4*jj*(2*jj-1)*r,real64)\n      enddo\n      w( jj, jj)  =  1.0d0/real(4*jj*r,real64)\n      w(-jj,-jj)  = -1.0d0/real(4*jj*r,real64)\n    enddo\n  endif\nend subroutine initialize_w\n"}
{"id": 1035, "subroutine": "subroutine apply_stencil(is_star,tiling,tile_size,r,n,w,a,b)\n  use iso_fortran_env\n  implicit none\n  logical, intent(in) :: is_star, tiling\n  integer(kind=int32), intent(in) :: tile_size, r, n\n  real(kind=real64), intent(in) :: w(-r:r,-r:r)\n  real(kind=real64), intent(in) :: a(n,n)\n  real(kind=real64), intent(inout) :: b(n,n)\n  integer(kind=int32) :: i, j, ii, jj, it, jt\n  if (is_star) then\n    if (.not.tiling) then\n      !$omp taskloop shared(w,a,b) firstprivate(r,n) private(i,j,ii,jj)\n      do j=r,n-r-1\n        do i=r,n-r-1\n            ! do not use intel fortran unroll directive here (slows down)\n            do jj=-r,r\n              b(i+1,j+1) = b(i+1,j+1) + w(0,jj) * a(i+1,j+jj+1)\n            enddo\n            do ii=-r,-1\n              b(i+1,j+1) = b(i+1,j+1) + w(ii,0) * a(i+ii+1,j+1)\n            enddo\n            do ii=1,r\n              b(i+1,j+1) = b(i+1,j+1) + w(ii,0) * a(i+ii+1,j+1)\n            enddo\n        enddo\n      enddo\n      !$omp end taskloop\n    else ! tiling\n      !$omp taskloop shared(w,a,b) firstprivate(r,n,tile_size) &\n      !$omp&                       private(it,jt,i,j,ii,jj)\n      do jt=r,n-r-1,tile_size\n        do it=r,n-r-1,tile_size\n          do j=jt,min(n-r-1,jt+tile_size-1)\n            do i=it,min(n-r-1,it+tile_size-1)\n              do jj=-r,r\n                b(i+1,j+1) = b(i+1,j+1) + w(0,jj) * a(i+1,j+jj+1)\n              enddo\n              do ii=-r,-1\n                b(i+1,j+1) = b(i+1,j+1) + w(ii,0) * a(i+ii+1,j+1)\n              enddo\n              do ii=1,r\n                b(i+1,j+1) = b(i+1,j+1) + w(ii,0) * a(i+ii+1,j+1)\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n      !$omp end taskloop\n    endif ! tiling\n  else ! grid\n    if (.not.tiling) then\n      !$omp taskloop shared(w,a,b) firstprivate(r,n) private(i,j,ii,jj)\n      do j=r,n-r-1\n        do i=r,n-r-1\n          do jj=-r,r\n            do ii=-r,r\n              b(i+1,j+1) = b(i+1,j+1) + w(ii,jj) * a(i+ii+1,j+jj+1)\n            enddo\n          enddo\n        enddo\n      enddo\n      !$omp end taskloop\n    else ! tiling\n      !$omp taskloop shared(w,a,b) firstprivate(r,n,tile_size) &\n      !$omp&                       private(it,jt,i,j,ii,jj)\n      do jt=r,n-r-1,tile_size\n        do it=r,n-r-1,tile_size\n          do j=jt,min(n-r-1,jt+tile_size-1)\n            do i=it,min(n-r-1,it+tile_size-1)\n              do jj=-r,r\n                do ii=-r,r\n                  b(i+1,j+1) = b(i+1,j+1) + w(ii,jj) * a(i+ii+1,j+jj+1)\n                enddo\n              enddo\n            enddo\n          enddo\n        enddo\n      enddo\n      !$omp end taskloop\n    endif ! tiling\n  endif ! star\nend subroutine apply_stencil\n"}
{"id": 1036, "subroutine": "      subroutine read_dkes_input\n      use safe_open_mod\n      use vimatrix, only: ioout, ioout_opt\n      implicit none\nc-----------------------------------------------\nc   l o c a l   p a r a m e t e r s\nc-----------------------------------------------\n      integer, parameter :: idata = 7\n      integer, parameter :: iout = 20\n      integer, parameter :: iout_opt = 14\nc-----------------------------------------------\nc   l o c a l   v a r i a b l e s\nc-----------------------------------------------\n      integer :: numargs, icount, istat, index_blank, iodata\n      character*120 :: output_file, opt_file, input_file\n      character*120 :: arg1(5)\n      logical :: lexist\nc-----------------------------------------------\nc   e x t e r n a l   f u n c t i o n s\nc-----------------------------------------------\n      external getcarg, dkes_input_prepare\nc-----------------------------------------------\n      lscreen = .true.\n\nc  read input data from \"datain\" namelist\n      call getcarg(1, arg1(1), numargs)\n\n      do icount = 2, numargs\n         call getcarg(icount, arg1(icount), istat)\n      end do\n      if (numargs .ge. 4) then\n         if (numargs .eq. 4) arg1(5) = 't'\n         call dkes_input_prepare (arg1, input_file)\n         if (arg1(5)(1:1).eq.'f' .or. arg1(5)(1:1).eq.'f') \n     1      lscreen = .false.\n      else if (numargs .eq. 1) then\n         input_file = trim(arg1(1))\n      else\n         print *, ' must enter input filename on command line'\n         stop\n      end if\n\n      index_blank = index(input_file,'input.')\n\n      if (index_blank .eq. 0) then\n         inquire (file=trim(input_file), exist=lexist)        \n         if (.not.lexist) then\n            input_file = 'input.' // trim(input_file)\n            index_blank = 1\n         else\n            index_blank = index(input_file,'.') - 5\n         end if\n      end if\n\n      index_blank = max(index_blank + 5,1)\n      output_file= 'dkesout' // input_file(index_blank:)\n      opt_file= 'opt_dkes' // input_file(index_blank:)             !das 2/21/2000\n\n!\n!     open input and output files for reading (and writing output)\n!\n      iodata = idata\n      call safe_open(iodata, istat, input_file, 'old', 'formatted')\n      if (istat .ne. 0) stop 'error reading input file in dkes'\n      ioout = iout\n      call safe_open(ioout, istat, output_file, 'replace', 'formatted')\n      if (istat .ne. 0) stop 'error writing output file'\n      ioout_opt = iout_opt\n      call safe_open(ioout_opt, istat, opt_file, 'replace','formatted')\n      if (istat .ne. 0) stop 'error writing opt_output file'\n\n!     read namelist (datain) input\n      nvalsb(1) = -bigint-1\n      idisk = 1\n      lfout = 0\n      ibbi = 1\n      read (iodata, datain)\n      close (iodata)\n\n!     perform error checking on input data\n\n      if (nzperiod .le. 0) nzperiod = 1\n      if (ibbi<1 .or. ibbi >2) then\n         write (ioout,'(a)') ' ibbi must =1 or =2'\n         stop ' ibbi <1 or ibbi >2 in dkes input'\n      end if\n\n      if (mpol < 1) then\n         write (ioout, 10) mpol\n  10     format(' mpol = ',i5,'  is less than 1')\n         stop ' mpol < 1 in dkes input'\n      endif\n\n      if (mpol > mpold) then\n         write (ioout, 15) mpol, mpold\n  15     format(' mpol = ',i5,'  is greater than mpold = ',i5)\n         stop ' mpol > mpold in dkes input'\n      endif\n\n      if (mpolb < 2) then\n         write (ioout, 20) mpolb\n  20     format(' mpolb = ',i5,'  is less than 2')\n         stop ' mpolb < 2 in dkes input'\n      endif\n\n      if (mpolb > mpolbd) then\n         write (ioout, 25) mpolb, mpolbd\n  25     format(' mpolb = ',i5,'  is greater than mpolbd = ',i5)\n         stop ' mpolb > mpolbd in dkes input'\n      endif\n\n      if (ntor < 1) then\n         write (ioout, 30) ntor\n  30     format(' ntor = ',i5,'  is less than 1')\n         stop ' ntor < 1 in dkes input'\n      endif\n\n      if (ntor > ntord) then\n         write (ioout, 35) ntor, ntord\n  35     format(' ntor = ',i5,'  is greater than ntord = ',i5)\n         stop ' ntor > ntord in dkes input'\n      endif\n\n      if (ntorb < 1) then\n         write (ioout, 40) ntorb\n  40     format(' ntorb = ',i5,'  is less than 1')\n         stop ' ntorb < 1 in dkes input'\n      endif\n\n      if (ntorb > ntorbd) then\n         write (ioout, 45) ntorb, ntorbd\n  45     format(' ntorb = ',i5,'  is greater than ntorbd = ',i5)\n         stop ' ntorb > ntorbd in dkes input'\n      endif\n\n      if (lalpha < 6) then\n         write (ioout, 50) lalpha\n  50     format(' lalpha = ',i5,'  is less than 6')\n         stop ' lalpha < 6 in dkes input'\n      endif\n\n      if (ipmb<0 .or. ipmb>2) ipmb = 0\n\n      meshtz = max(0,meshtz)\n\n      do istat = 1, len(dashes)\n         dashes(istat:istat) = \"-\"\n      end do\n\n      end subroutine read_dkes_input\n"}
{"id": 1037, "subroutine": "      subroutine odexq(n,fcn,x,y,xend,h, &\n                      rtol,atol,itol, &\n                      solout,iout, &\n                      work,lwork,iwork,liwork,idid)\n      implicit double precision (a-h,o-z)\n      implicit integer (i-n)\n      dimension work(lwork),iwork(liwork)\n      real*8 rrtol(2), aatol(2), rpar(2)\n      integer ipar(2)\n      logical arret\n      external fcn,solout\n#ifdef realgo\n#define xxx 1\n#else\n#define xxx 2\n#endif\n      datatype y(n/xxx)\n      real*8 real_y(n), realvec(2)\n      datatype cvec(2)\n      \n      real_y(:) = transfer(y,realvec)\n      rrtol=rtol; aatol=atol\n      call odex(n,fcn,x,real_y,xend,h, &\n                      rrtol,aatol,itol, &\n                      solout,iout, &\n                      work,lwork,iwork,liwork,rpar,ipar,idid)\n      y(:) = transfer(real_y,cvec)\n      end subroutine odexq\n"}
{"id": 1038, "subroutine": "  subroutine backup_mod_read_variable(fh, disp, vc, var_name, var)\n!------------------------------------------------------------------------------!\n!   reads a whole variable from backup file.                                   !\n!------------------------------------------------------------------------------!\n!----------------------------------[modules]-----------------------------------!\n  use comm_mod\n  use grid_mod\n  use var_mod\n!------------------------------------------------------------------------------!\n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  integer          :: fh, disp, vc\n  character(len=*) :: var_name\n  type(var_type)   :: var\n!-----------------------------------[locals]-----------------------------------!\n  character(len=80) :: vn\n  integer           :: vs, disp_loop, cnt_loop\n!==============================================================================!\n\n  cnt_loop  = 0\n  disp_loop = 0\n\n  !--------------------------------------------------------!\n  !   browse the entire file until you find the variable   !\n  !--------------------------------------------------------!\n  do\n\n    call comm_mod_read_text(fh, vn, disp_loop)  ! variable name\n    call comm_mod_read_int (fh, vs, disp_loop)  ! variable size  \n\n    ! if variable is found, read it and retrun\n    if(vn .eq. var_name) then\n      if(this_proc < 2) print *, '# reading variable: ', trim(vn)\n      call comm_mod_read_cell_real(fh, var % n(1:nc_s),   disp_loop)\n      call comm_mod_read_bnd_real (fh, var % n(-nb_s:-1), disp_loop)\n      call comm_mod_read_bnd_real (fh, var % q(-nb_s:-1), disp_loop)\n      call comm_mod_read_cell_real(fh, var % o(1:nc_s),   disp_loop)\n      disp = disp_loop\n      return\n\n    ! if variable not found, advance the offset only\n    else\n      disp_loop = disp_loop + vs\n    end if\n\n    ! check if variable is in the file\n    cnt_loop = cnt_loop + 1\n    if(cnt_loop > vc) goto 1\n\n  end do\n\n1 if(this_proc < 2) print *, '# variable: ', trim(vn), ' not found!'\n\n  end subroutine\n"}
{"id": 1039, "subroutine": "    subroutine psb_z_map_x2y(alpha,x,beta,y,map,info,work)\n      import :: psb_ipk_, psb_dpk_, psb_zlinmap_type\n      implicit none \n      type(psb_zlinmap_type), intent(in) :: map\n      complex(psb_dpk_), intent(in)     :: alpha,beta\n      complex(psb_dpk_), intent(inout)  :: x(:)\n      complex(psb_dpk_), intent(out)    :: y(:)\n      integer(psb_ipk_), intent(out)           :: info \n      complex(psb_dpk_), optional       :: work(:)\n    end subroutine psb_z_map_x2y\n"}
{"id": 1040, "subroutine": "    subroutine psb_z_map_x2y_vect(alpha,x,beta,y,map,info,work,vtx,vty)\n      use psb_z_vect_mod, only : psb_z_vect_type\n      import :: psb_ipk_, psb_dpk_, psb_zlinmap_type\n      implicit none \n      type(psb_zlinmap_type), intent(in) :: map\n      complex(psb_dpk_), intent(in)     :: alpha,beta\n      type(psb_z_vect_type), intent(inout)  :: x,y\n      integer(psb_ipk_), intent(out)           :: info \n      complex(psb_dpk_), optional       :: work(:)\n      type(psb_z_vect_type), optional, target, intent(inout)  :: vtx,vty\n    end subroutine psb_z_map_x2y_vect\n"}
{"id": 1041, "subroutine": "  subroutine psb_z_map_cscnv(map,info,type,mold,imold)    \n    implicit none\n    class(psb_zlinmap_type), intent(inout)  :: map\n    integer(psb_ipk_), intent(out)                   :: info\n    character(len=*), intent(in), optional :: type\n    class(psb_z_base_sparse_mat), intent(in), optional :: mold\n    class(psb_i_base_vect_type), intent(in), optional  :: imold\n\n    if (map%map_x2y%is_asb())&\n         & call map%map_x2y%cscnv(info,type=type,mold=mold)\n    if (info == psb_success_ .and.map%map_y2x%is_asb())&\n         & call map%map_y2x%cscnv(info,type=type,mold=mold)\n    if (present(imold)) then \n      call map%desc_x%cnv(mold=imold)\n      call map%desc_y%cnv(mold=imold)\n    end if\n\n  end subroutine psb_z_map_cscnv\n"}
{"id": 1042, "subroutine": "  subroutine psb_z_linmap_sub(out_map,map_kind,desc_x, desc_y,&\n       & map_x2y, map_y2x,iaggr,naggr)\n    implicit none \n    type(psb_zlinmap_type), intent(out)     :: out_map    \n    type(psb_desc_type), target             :: desc_x, desc_y\n    type(psb_zspmat_type), intent(inout)    :: map_x2y, map_y2x\n    integer(psb_ipk_), intent(in)           :: map_kind\n    integer(psb_lpk_), intent(in), optional :: iaggr(:), naggr(:)\n    out_map = psb_linmap(map_kind,desc_x,desc_y,map_x2y,map_y2x,iaggr,naggr)\n  end subroutine psb_z_linmap_sub\n"}
{"id": 1043, "subroutine": "  subroutine  psb_zlinmap_transfer(mapin,mapout,info)\n    use psb_realloc_mod\n    implicit none \n    type(psb_zlinmap_type) :: mapin,mapout\n    integer(psb_ipk_), intent(out)      :: info \n    \n    call psb_move_alloc(mapin%psb_base_linmap_type, &\n         & mapout%psb_base_linmap_type,info)\n    call psb_move_alloc(mapin%map_x2y,mapout%map_x2y,info)\n    call psb_move_alloc(mapin%map_y2x,mapout%map_y2x,info)\n\n  end subroutine psb_zlinmap_transfer\n"}
{"id": 1044, "subroutine": "  subroutine  z_free(map,info)\n    implicit none \n    class(psb_zlinmap_type) :: map\n    integer(psb_ipk_), intent(out)      :: info \n    \n    call map%psb_base_linmap_type%free(info)\n    \n    call map%map_x2y%free()\n    call map%map_y2x%free()\n\n  end subroutine z_free\n"}
{"id": 1045, "subroutine": "  subroutine  z_clone(map,mapout,info)\n    use psb_error_mod\n    implicit none \n    class(psb_zlinmap_type), intent(inout) :: map\n    class(psb_base_linmap_type), intent(inout) :: mapout\n    integer(psb_ipk_)     :: info \n    \n    integer(psb_ipk_) :: err_act\n    character(len=20)  :: name='clone'\n\n    info = 0\n    select type(mout => mapout)\n    class is (psb_zlinmap_type)\n      call mout%free(info)\n      ! base clone!    \n      if (info == 0) call &\n           & map%psb_base_linmap_type%clone(mout%psb_base_linmap_type,info)\n      if (info == 0) call map%map_x2y%clone(mout%map_x2y,info)\n      if (info == 0) call map%map_y2x%clone(mout%map_y2x,info)\n    class default\n      info = psb_err_invalid_dynamic_type_\n      info = psb_err_missing_override_method_\n      call psb_errpush(info,name,m_err=(/2/))\n      call psb_erractionsave(err_act)\n\n      call psb_error_handler(err_act)\n    end select\n\n      \n  end subroutine z_clone\n"}
{"id": 1046, "subroutine": "  subroutine outer ( iits, otno, t, do_grp, ng_per_thrd, nnstd_used,   &\n    grp_act, iitm_i )\n\n!-----------------------------------------------------------------------\n!\n! do a single outer iteration. sets the out-of-group sources, performs\n! inners for all groups.\n!\n!-----------------------------------------------------------------------\n\n    integer(i_knd), intent(in) :: otno, t, iitm_i\n\n    integer(i_knd), intent(inout) :: ng_per_thrd, nnstd_used\n\n    integer(i_knd), dimension(ng), intent(out) :: iits\n\n    integer(i_knd), dimension(ng), intent(inout) :: do_grp\n\n    integer(i_knd), dimension(ng,nthreads), intent(inout) :: grp_act\n!_______________________________________________________________________\n!\n!   local variables\n!_______________________________________________________________________\n\n    integer(i_knd) :: inno, g, n\n\n    real(r_knd) :: t1, t2, t3, t4\n!_______________________________________________________________________\n!\n!   compute the outer source: sum of fixed + out-of-group sources.\n!   each thread t will do a set of energy groups. nested threads will\n!   work over local ny*nz span. in many instances, changing do_grp\n!   will not change grp_act, but the action better resembles production.\n!_______________________________________________________________________\n\n  !$omp master\n\n    call wtime ( t1 )\n\n    inrdone = .false.\n    iits = 0\n\n    do g = 1, ng\n      do_grp(g) = ng - g + 1\n    end do\n\n    call assign_thrd_set ( do_grp, ng, ng_per_thrd, ny*nz, nnstd_used, &\n      grp_act )\n\n  !$omp end master\n  !$omp barrier\n\n    call outer_src ( ng_per_thrd, nnstd_used, grp_act(:,t) )\n  !$omp barrier\n\n  !$omp master\n    call wtime ( t2 )\n    totrsrc = totrsrc + t2 - t1\n  !$omp end master\n!_______________________________________________________________________\n!\n!   zero out the inner iterations group count. save the flux for\n!   comparison. initialize inrdone.\n!_______________________________________________________________________\n\n    do n = 1, ng_per_thrd\n      g = grp_act(n,t)\n      if ( g == 0 ) exit\n      flux0po(:,:,:,g) = flux0(:,:,:,g)\n    end do\n!_______________________________________________________________________\n!\n!   start the inner iterations\n!_______________________________________________________________________\n\n  !$omp master\n    call wtime ( t3 )\n  !$omp end master\n\n  !$omp barrier\n\n    inner_loop: do inno = 1, iitm_i\n\n      call inner ( inno, iits, t, do_grp, ng_per_thrd, nnstd_used,     &\n        grp_act )\n  !$omp barrier\n\n      if ( all( inrdone ) ) exit inner_loop\n\n    end do inner_loop\n\n  !$omp master\n\n    call wtime ( t4 )\n    tinners = tinners + t4 - t3\n!_______________________________________________________________________\n!\n!   check outer convergence. apply nested threads to group sets.\n!_______________________________________________________________________\n\n    do_grp = 1\n    call assign_thrd_set ( do_grp, ng, ng_per_thrd, 0, nnstd_used,     &\n      grp_act )\n\n  !$omp end master\n  !$omp barrier\n\n    call outer_conv ( otno, ng_per_thrd, nnstd_used, grp_act(:,t) )\n!_______________________________________________________________________\n!_______________________________________________________________________\n\n  end subroutine outer\n"}
{"id": 1047, "subroutine": "  subroutine outer_src ( ng_per_thrd, nnstd_used, grp_act )\n\n!-----------------------------------------------------------------------\n!\n! loop over groups to compute each one's outer loop source.\n!\n!-----------------------------------------------------------------------\n\n    integer(i_knd), intent(in) :: ng_per_thrd, nnstd_used\n\n    integer(i_knd), dimension(ng), intent(in) :: grp_act\n!_______________________________________________________________________\n!\n!   local variables\n!_______________________________________________________________________\n\n    integer(i_knd) :: n, g, k, j\n!_______________________________________________________________________\n!\n!   loop over each set of groups. use nested threads if available.\n!_______________________________________________________________________\n\n  !$omp parallel num_threads(nnstd_used) if(nnstd_used>1)              &\n  !$omp& default(shared) private(n,g,k,j) proc_bind(close)\n    do n = 1, ng_per_thrd\n\n      g = grp_act(n)\n      if ( g == 0 ) exit\n\n  !$omp do schedule(static,1) collapse(2)\n      do k = 1, nz\n      do j = 1, ny\n        call outer_src_calc ( g, j, k, qi(:,j,k,g), slgg(:,:,:,g),     &\n          mat(:,j,k), q2grp0(:,j,k,g), q2grpm(:,:,j,k,g) )\n      end do\n      end do\n  !$omp end do nowait\n\n    end do\n  !$omp end parallel\n!_______________________________________________________________________\n!_______________________________________________________________________\n\n  end subroutine outer_src\n"}
{"id": 1048, "subroutine": "  subroutine outer_src_calc ( g, j, k, qi0, sxs_g, map, qo0, qom )\n\n!-----------------------------------------------------------------------\n!\n! compute the scattering source for all cells and moments. this routine\n! is called for each group. it computes source components from all the\n! other groups, which are looped over here. it skips computing the\n! source from itself, which is captured in the inner iterations.\n!\n!-----------------------------------------------------------------------\n\n    integer(i_knd), intent(in) :: g, j, k\n\n    integer(i_knd), dimension(nx), intent(in) :: map\n\n    real(r_knd), dimension(nx), intent(in) :: qi0\n\n    real(r_knd), dimension(nx), intent(out) :: qo0\n\n    real(r_knd), dimension(cmom-1,nx), intent(out) :: qom\n\n    real(r_knd), dimension(nmat,nmom,ng), intent(in) :: sxs_g\n!_______________________________________________________________________\n!\n!   local variables\n!_______________________________________________________________________\n\n    integer(i_knd) :: gp\n\n    real(r_knd), dimension(nx) :: cs0\n\n    real(r_knd), dimension(cmom-1,nx) :: csm\n!_______________________________________________________________________\n!\n!   initialize sources. include isotropic inhomogeneous source.\n!_______________________________________________________________________\n\n    qo0 = qi0\n    qom = zero\n!_______________________________________________________________________\n!\n!   loop over originating groups, gp. skip own group.\n!_______________________________________________________________________\n\n    do gp = 1, ng\n\n      if ( gp == g ) cycle\n!_______________________________________________________________________\n!\n!     expand isotropic cross sections to fine mesh for current gp->g.\n!     add out of group scattering source.\n!_______________________________________________________________________\n\n      call expxs_reg ( sxs_g(:,1,gp), map, cs0 )\n\n      qo0 = qo0 + cs0*flux0(:,j,k,gp)\n!_______________________________________________________________________\n!\n!     expand anisotropic cross sections to fine mesh for gp->g. add\n!     components to group scattering source moments. close the loop.\n!_______________________________________________________________________\n\n      if ( nmom == 1 ) cycle\n\n      call expxs_slgg ( sxs_g(:,:,gp), map, csm )\n\n      qom = qom + csm*fluxm(:,:,j,k,gp)\n\n    end do\n!_______________________________________________________________________\n!_______________________________________________________________________\n\n  end subroutine outer_src_calc\n"}
{"id": 1049, "subroutine": "  subroutine outer_conv ( otno, ng_per_thrd, nnstd_used, grp_act )\n\n!-----------------------------------------------------------------------\n!\n! check for convergence of outer iterations. use only the zeroth moment\n! data (flux0/flux0po).\n!\n!-----------------------------------------------------------------------\n\n    integer(i_knd), intent(in) :: otno, ng_per_thrd, nnstd_used\n\n    integer(i_knd), dimension(ng), intent(in) :: grp_act\n!_______________________________________________________________________\n!\n!   local variables\n!_______________________________________________________________________\n\n    integer(i_knd) :: n, g\n\n    real(r_knd) :: dft\n\n    real(r_knd), dimension(nx,ny,nz,ng_per_thrd) :: df\n!_______________________________________________________________________\n!\n!   thread to speed up computation of df by looping over groups. rejoin\n!   threads and then determine max error.\n!_______________________________________________________________________\n\n  !$omp parallel do num_threads(nnstd_used) if(nnstd_used>1)           &\n  !$omp& schedule(static,1) default(shared) private(n,g)               &\n  !$omp& proc_bind(close)\n    do n = 1, ng_per_thrd\n\n      g = grp_act(n)\n      if ( g == 0 ) then\n        df(:,:,:,n) = -one\n        cycle\n      end if\n\n      df(:,:,:,n) = one\n      where( abs( flux0po(:,:,:,g) ) < tolr )\n        flux0po(:,:,:,g) = one\n        df(:,:,:,n) = zero\n      end where\n      df(:,:,:,n) = abs( flux0(:,:,:,g)/flux0po(:,:,:,g) - df(:,:,:,n) )\n\n    end do\n  !$omp end parallel do\n\n    dft = maxval( df )\n\n  !$omp master\n    dfmxo = -huge( one )\n  !$omp end master\n  !$omp barrier\n\n  !$omp critical\n    dfmxo = max( dfmxo, dft )\n  !$omp end critical\n  !$omp barrier\n\n  !$omp master\n\n    call glmax ( dfmxo, comm_snap )\n\n    if ( dfmxo<=100.0_r_knd*epsi .and. all( inrdone ) .and. otno/=1 )  &\n      otrdone = .true.\n\n  !$omp end master\n!_______________________________________________________________________\n!_______________________________________________________________________\n\n  end subroutine outer_conv\n"}
{"id": 1050, "subroutine": "subroutine inieva(runid     ,cyclic    ,timnow    ,evaint    ,j         , &\n                & nmmaxj    ,nmmax     ,evap      ,precip    ,gdp       )\n!----- gpl ---------------------------------------------------------------------\n!                                                                               \n!  copyright (c)  stichting deltares, 2011-2016.                                \n!                                                                               \n!  this program is free software: you can redistribute it and/or modify         \n!  it under the terms of the gnu general public license as published by         \n!  the free software foundation version 3.                                      \n!                                                                               \n!  this program is distributed in the hope that it will be useful,              \n!  but without any warranty; without even the implied warranty of               \n!  merchantability or fitness for a particular purpose.  see the                \n!  gnu general public license for more details.                                 \n!                                                                               \n!  you should have received a copy of the gnu general public license            \n!  along with this program.  if not, see <http://www.gnu.org/licenses/>.        \n!                                                                               \n!  contact: delft3d.support@deltares.nl                                         \n!  stichting deltares                                                           \n!  p.o. box 177                                                                 \n!  2600 mh delft, the netherlands                                               \n!                                                                               \n!  all indications and logos of, and references to, \"delft3d\" and \"deltares\"    \n!  are registered trademarks of stichting deltares, and remain the property of  \n!  stichting deltares. all rights reserved.                                     \n!                                                                               \n!-------------------------------------------------------------------------------\n!  $id: inieva.f90 5717 2016-01-12 11:35:24z mourits $\n!  $headurl: https://svn.oss.deltares.nl/repos/delft3d/tags/6686/src/engines_gpl/flow2d3d/packages/kernel/src/inichk/inieva.f90 $\n!!--description-----------------------------------------------------------------\n!\n!    function: reads the time dependent data for rainfall /\n!              evaporation model from file for the first time\n! method used:\n!\n!!--pseudo code and references--------------------------------------------------\n! none\n!!--declarations----------------------------------------------------------------\n    use precision\n    use globaldata\n    use string_module\n    !\n    implicit none\n    !\n    type(globdat),target :: gdp\n    !\n    ! the following list of pointer parameters is used to point inside the gdp structure\n    !\n    integer     , pointer :: it0eva\n    integer     , pointer :: it1eva\n    real(fp)    , pointer :: dt\n    integer     , pointer :: luneva\n    real(fp)    , pointer :: evapor\n    real(fp)    , pointer :: devapo\n    real(fp)    , pointer :: precipt\n    real(fp)    , pointer :: dpreci\n    real(fp)    , pointer :: train\n    real(fp)    , pointer :: dtrain\n    logical     , pointer :: fleva\n!\n! global variables\n!\n    integer                                                 :: j      !!  begin pointer for arrays which have been transformed into 1d arrays. due to the shift in the 2nd (m-) index, j = -2*nmax + 1\n    integer                                   , intent(in)  :: nmmax  !  description and declaration in dimens.igs\n    integer                                                 :: nmmaxj !  description and declaration in dimens.igs\n    logical                                                 :: cyclic !!  flag = true if cyclic system assumed\n    real(fp)                                                :: timnow !!  current timestep (itstrt * dt)\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub), intent(out) :: evap   !  description and declaration in esm_alloc_real.f90\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub), intent(out) :: precip !  description and declaration in esm_alloc_real.f90\n    character(*)                                            :: runid\n    character(1)                              , intent(in)  :: evaint !  description and declaration in tricom.igs\n!\n! local variables\n!\n    integer           :: itfac    ! interpolation factor \n    integer           :: lrid     ! length of character string runid \n    integer           :: newlun\n    integer           :: nm       ! loop counter for nmmax \n    logical           :: first    ! help var. it is always set to true before calling the relevant routines for the time dependent data, because they are activated here for the first time \n    logical           :: inteva   ! interpolation method between consecu- tive rain/evaporation data: n = no     interpolation. y = linear interpolation. \n    logical           :: opend    ! help flag = true when file is still open (delft3d) and \n    character(256)    :: filnam   ! help var. for file name \n!\n!! executable statements -------------------------------------------------------\n!\n    fleva       => gdp%gdtmpfil%fleva\n    evapor      => gdp%gdheat%evapor\n    devapo      => gdp%gdheat%devapo\n    precipt     => gdp%gdheat%precipt\n    dpreci      => gdp%gdheat%dpreci\n    train       => gdp%gdheat%train\n    dtrain      => gdp%gdheat%dtrain\n    luneva      => gdp%gdluntmp%luneva\n    dt          => gdp%gdexttim%dt\n    it0eva      => gdp%gdinttim%it0eva\n    it1eva      => gdp%gdinttim%it1eva\n    !\n    inteva = .false.\n    if (evaint=='y') inteva = .true.\n    !\n    ! initilisation global parameters, initial pressure and common\n    !     values of heat\n    !\n    precipt = 0.0_fp\n    dpreci  = 0.0_fp\n    evapor  = 0.0_fp\n    devapo  = 0.0_fp\n    train   = 0.0_fp\n    dtrain  = 0.0_fp\n    !\n    ! define length of runid\n    !\n    call remove_leading_spaces(runid     ,lrid      )\n    !\n    ! time dependent rainfall / evaporation\n    ! only if keva > 0 fleva = .true. (see readmd)\n    !\n    if (fleva) then\n       filnam = 'tmp_' // runid(:lrid) // '.eva'\n       !\n       ! test if file is already opened (multi entry delft3d)\n       !\n       inquire (file = filnam(:8 + lrid), opened = opend)\n       if (.not.opend) then\n          luneva = newlun(gdp)\n          open (luneva, file = filnam(:8 + lrid), form = 'unformatted',         &\n               & status = 'old')\n       endif\n       !\n       ! always rewind file, reset time parameters and read new time\n       ! dependent input\n       !\n       rewind (luneva)\n       it0eva = -1\n       it1eva = -1\n       !\n       ! read new time dep. input\n       !\n       first = .true.\n       call updeva(luneva    ,timnow    ,dt        ,inteva    ,first     , &\n                 & gdp       )\n       !\n       !\n       ! interpolate between it0eva and timnow for rainfall/evaporation\n       ! data when interpolation is requested\n       !\n       if (inteva) then\n          itfac   = (int(timnow) - it0eva)*2\n          precipt = precipt + dpreci*itfac\n          evapor  = evapor + devapo*itfac\n          train   = train + dtrain*itfac\n       endif\n       !\n       ! update evaporation and rainfall (start value for both block function as\n       ! step interpolation)\n       !\n       do nm = 1, nmmax\n          evap  (nm) = evapor\n          precip(nm) = precipt\n       enddo\n    endif\nend subroutine inieva\n"}
{"id": 1051, "subroutine": "subroutine test1(a, i)\n  integer i\n  real a(10)\n  one: critical\n    if (a(i) < 0.0) then\n      a(i) = 20.20\n    end if\n  !error: critical construct name mismatch\n  end critical two\nend subroutine test1\n"}
{"id": 1052, "subroutine": "subroutine test2(a, i)\n  integer i\n  real a(10)\n  critical\n    if (a(i) < 0.0) then\n      a(i) = 20.20\n    end if\n  !error: critical construct name unexpected\n  end critical two\nend subroutine test2\n"}
{"id": 1053, "subroutine": "subroutine gang (a)\n  use param\n  !$acc routine gang\n  integer, intent (inout) :: a(n)\n  integer :: i\n\n  !$acc loop\n  do i = 1, n\n     a(i) = a(i) - a(i)\n  end do\n\n  !$acc loop gang\n  do i = 1, n\n     a(i) = a(i) - a(i)\n  end do\n\n  !$acc loop worker\n  do i = 1, n\n     a(i) = a(i) - a(i)\n  end do\n\n  !$acc loop vector\n  do i = 1, n\n     a(i) = a(i) - a(i)\n  end do\nend subroutine gang\n"}
{"id": 1054, "subroutine": "    subroutine test_path()\n\n        implicit none\n\n        test = test_type(modulename=module_name)\n        call test%run(test_isdir_1, \"test_isdir_1\")\n        call test%run(test_query_1, \"test_query_1\")\n        call test%run(test_query_2, \"test_query_2\")\n        call test%run(test_query_3, \"test_query_3\")\n        call test%run(test_mkdir_1, \"test_mkdir_1\")\n        call test%run(test_mkdir_2, \"test_mkdir_2\")\n        call test%run(test_mkdir_3, \"test_mkdir_3\")\n        call test%run(test_modify_1, \"test_modify_1\")\n        call test%run(test_winify_1, \"test_winify_1\")\n        call test%run(test_winify_2, \"test_winify_2\")\n        call test%run(test_winify_3, \"test_winify_3\")\n        call test%run(test_linify_1, \"test_linify_1\")\n        call test%run(test_linify_2, \"test_linify_2\")\n        call test%run(test_getnameext_1, \"test_getnameext_1\")\n        call test%run(test_getnameext_2, \"test_getnameext_2\")\n        call test%run(test_constructpath, \"test_constructpath\")\n        call test%run(test_getdirnameext_1, \"test_getdirnameext_1\")\n        call test%run(test_getdirnameext_2, \"test_getdirnameext_2\")\n        call test%run(test_getdirfullname_1, \"test_getdirfullname_1\")\n        call test%run(test_getdirfullname_2, \"test_getdirfullname_2\")\n        call test%finalize()\n\n    end subroutine test_path\n"}
{"id": 1055, "subroutine": "subroutine jetini(jp, jt, itrig)\n  character beam*16, targ*16\n  dimension xsec0(8, 0:200), coef0(8, 200, 20), ini(8), mint44(8), mint45(8)\n  common /hjcrdn/yp(3, 300), yt(3, 300)\n  common /hparnt/hipr1(100), ihpr2(50), hint1(100), ihnt2(50)\n  common /hstrng/nfp(300, 15), pp(300, 15), nft(300, 15), pt(300, 15)\n  common /hpint/mint4, mint5, atco(200, 20), atxs(0:200)\n  common /ludat1/mstu(200), paru(200), mstj(200), parj(200)\n  common /ludat3/mdcy(500, 3), mdme(2000, 2), brat(2000), kfdp(2000, 5)\n  common /pysubs/msel, msub(200), kfin(2, -40:40), ckin(200)\n  common /pypars/mstp(200), parp(200), msti(200), pari(200)\n  common /pyint1/mint(400), vint(400)\n  common /pyint2/iset(200), kfpr(200, 2), coef(200, 20), icol(40, 4, 2)\n  common /pyint5/ngen(0:200, 3), xsec(0:200, 3)\n  save\n  data ini/8*0/, ilast/ -1/\n  ihnt2(11) = jp\n  ihnt2(12) = jt\n  if (ihnt2(5)/=0 .and. ihnt2(6)/=0) then\n    itype = 1\n  else if (ihnt2(5)/=0 .and. ihnt2(6)==0) then\n    itype = 1\n    if (nft(jt,4)==2112) itype = 2\n  else if (ihnt2(5)==0 .and. ihnt2(6)/=0) then\n    itype = 1\n    if (nfp(jp,4)==2112) itype = 2\n  else\n    if (nfp(jp,4)==2212 .and. nft(jt,4)==2212) then\n      itype = 1\n    else if (nfp(jp,4)==2212 .and. nft(jt,4)==2112) then\n      itype = 2\n    else if (nfp(jp,4)==2112 .and. nft(jt,4)==2212) then\n      itype = 3\n    else\n      itype = 4\n    end if\n  end if\n  if (itrig/=0) goto 160\n  if (itrig==ilast) goto 150\n  mstp(2) = 2\n  mstp(33) = 1\n  parp(31) = hipr1(17)\n  mstp(51) = 3\n  mstp(61) = 1\n  mstp(71) = 1\n  if (ihpr2(2)==0 .or. ihpr2(2)==2) mstp(61) = 0\n  if (ihpr2(2)==0 .or. ihpr2(2)==1) mstp(71) = 0\n  mstp(81) = 0\n  mstp(82) = 1\n  mstp(111) = 0\n  if (ihpr2(10)==0) mstp(122) = 0\n  parp(81) = hipr1(8)\n  ckin(5) = hipr1(8)\n  ckin(3) = hipr1(8)\n  ckin(4) = hipr1(9)\n  if (hipr1(9)<=hipr1(8)) ckin(4) = -1.0\n  ckin(9) = -10.0\n  ckin(10) = 10.0\n  msel = 0\n  do isub = 1, 200\n    msub(isub) = 0\n  end do\n  msub(11) = 1\n  msub(12) = 1\n  msub(13) = 1\n  msub(28) = 1\n  msub(53) = 1\n  msub(68) = 1\n  msub(81) = 1\n  msub(82) = 1\n  do j = 1, min(8, mdcy(21,3))\n    mdme(mdcy(21,2)+j-1, 1) = 0\n  end do\n  isel = 4\n  if (hint1(1)>=20.0 .and. ihpr2(18)==1) isel = 5\n  mdme(mdcy(21,2)+isel-1, 1) = 1\n  msub(14) = 1\n  msub(18) = 1\n  msub(29) = 1\n  150 if (ini(itype)/=0) goto 800\n  goto 400\n  160 itype = 4 + itype\n  if (itrig==ilast) goto 260\n  parp(81) = abs(hipr1(10)) - 0.25\n  ckin(5) = abs(hipr1(10)) - 0.25\n  ckin(3) = abs(hipr1(10)) - 0.25\n  ckin(4) = abs(hipr1(10)) + 0.25\n  if (hipr1(10)<hipr1(8)) ckin(4) = -1.0\n  msel = 0\n  do isub = 1, 200\n    msub(isub) = 0\n  end do\n  if (ihpr2(3)==1) then\n    msub(11) = 1\n    msub(12) = 1\n    msub(13) = 1\n    msub(28) = 1\n    msub(53) = 1\n    msub(68) = 1\n    msub(81) = 1\n    msub(82) = 1\n    msub(14) = 1\n    msub(18) = 1\n    msub(29) = 1\n    do j = 1, min(8, mdcy(21,3))\n      mdme(mdcy(21,2)+j-1, 1) = 0\n    end do\n    isel = 4\n    if (hint1(1)>=20.0 .and. ihpr2(18)==1) isel = 5\n    mdme(mdcy(21,2)+isel-1, 1) = 1\n  else if (ihpr2(3)==2) then\n    msub(14) = 1\n    msub(18) = 1\n    msub(29) = 1\n  else if (ihpr2(3)==3) then\n    ckin(3) = max(0.0, hipr1(10))\n    ckin(5) = hipr1(8)\n    parp(81) = hipr1(8)\n    msub(81) = 1\n    msub(82) = 1\n    do j = 1, min(8, mdcy(21,3))\n      mdme(mdcy(21,2)+j-1, 1) = 0\n    end do\n    isel = 4\n    if (hint1(1)>=20.0 .and. ihpr2(18)==1) isel = 5\n    mdme(mdcy(21,2)+isel-1, 1) = 1\n  end if\n  260 if (ini(itype)/=0) goto 800\n  400 ini(itype) = 1\n  if (ihpr2(10)==0) mstp(122) = 0\n  if (nfp(jp,4)==2212) then\n    beam = 'p'\n  else if (nfp(jp,4)==-2212) then\n    beam = 'p~'\n  else if (nfp(jp,4)==2112) then\n    beam = 'n'\n  else if (nfp(jp,4)==-2112) then\n    beam = 'n~'\n  else if (nfp(jp,4)==211) then\n    beam = 'pi+'\n  else if (nfp(jp,4)==-211) then\n    beam = 'pi-'\n  else if (nfp(jp,4)==321) then\n    beam = 'pi+'\n  else if (nfp(jp,4)==-321) then\n    beam = 'pi-'\n  else\n    write (6, *) 'unavailable beam type', nfp(jp, 4)\n  end if\n  if (nft(jt,4)==2212) then\n    targ = 'p'\n  else if (nft(jt,4)==-2212) then\n    targ = 'p~'\n  else if (nft(jt,4)==2112) then\n    targ = 'n'\n  else if (nft(jt,4)==-2112) then\n    targ = 'n~'\n  else if (nft(jt,4)==211) then\n    targ = 'pi+'\n  else if (nft(jt,4)==-211) then\n    targ = 'pi-'\n  else if (nft(jt,4)==321) then\n    targ = 'pi+'\n  else if (nft(jt,4)==-321) then\n    targ = 'pi-'\n  else\n    write (6, *) 'unavailable target type', nft(jt, 4)\n  end if\n  ihnt2(16) = 1\n  call pyinit('cms', beam, targ, hint1(1))\n  mint4 = mint(44)\n  mint5 = mint(45)\n  mint44(itype) = mint(44)\n  mint45(itype) = mint(45)\n  atxs(0) = xsec(0, 1)\n  xsec0(itype, 0) = xsec(0, 1)\n  do i = 1, 200\n    atxs(i) = xsec(i, 1)\n    xsec0(itype, i) = xsec(i, 1)\n    do j = 1, 20\n      atco(i, j) = coef(i, j)\n      coef0(itype, i, j) = coef(i, j)\n    end do\n  end do\n  ihnt2(16) = 0\n  return\n  800 mint(44) = mint44(itype)\n  mint(45) = mint45(itype)\n  mint4 = mint(44)\n  mint5 = mint(45)\n  xsec(0, 1) = xsec0(itype, 0)\n  atxs(0) = xsec(0, 1)\n  do i = 1, 200\n    xsec(i, 1) = xsec0(itype, i)\n    atxs(i) = xsec(i, 1)\n    do j = 1, 20\n      coef(i, j) = coef0(itype, i, j)\n      atco(i, j) = coef(i, j)\n    end do\n  end do\n  ilast = itrig\n  mint(11) = nfp(jp, 4)\n  mint(12) = nft(jt, 4)\n  return\nend subroutine jetini\n"}
{"id": 1056, "subroutine": "  subroutine get_from_memorylist(name, origin, mt, found, check)\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    type(memorytype), pointer, intent(out) :: mt\n    logical,intent(out) :: found\n    logical, intent(in), optional :: check\n    integer(i4b) :: ipos\n    logical check_opt\n    character(len=linelength) :: ermsg\n    mt => null()\n    found = .false.\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      if(mt%name == name .and. mt%origin == origin) then\n        found = .true.\n        exit\n      endif\n    enddo\n    check_opt = .true.\n    if (present(check)) check_opt = check\n    if (check_opt) then\n      if (.not. found) then\n        ermsg = 'programming error in memory manager. variable ' // name // &\n          ' in origin ' // origin // &\n          ' cannot be assigned because it does not exist in memory manager. '\n        call store_error(ermsg)\n        call ustop()\n      endif\n    end if\n    return\n  end subroutine get_from_memorylist\n"}
{"id": 1057, "subroutine": "  subroutine allocate_error(varname, origin, istat, errmsg, isize)\n    use simmodule, only: store_error, ustop\n    character(len=*), intent(in) :: varname\n    character(len=*), intent(in) :: origin\n    integer(i4b), intent(in) :: istat\n    character(len=*), intent(in) :: errmsg\n    integer(i4b), intent(in) :: isize\n    character(len=20) :: cint\n    call store_error('error trying to allocate memory.')\n    call store_error('  origin: ' // origin)\n    call store_error('  variable name: ' // varname)\n    write(cint, '(i0)') isize\n    call store_error('  size: ' // cint)\n    call store_error('  error message: ' // errmsg)\n    cint = ''\n    write(cint, '(i0)') istat\n    call store_error('  status code: ' // cint)\n    call ustop()\n  end subroutine allocate_error\n"}
{"id": 1058, "subroutine": "  subroutine check_varname(name)\n    character(len=*), intent(in) :: name\n    character(len=linelength) :: ermsg\n    if(len(name) > lenvarname) then\n      write(ermsg, '(*(g0))')                                                  &\n        'programming error in memory manager. variable ', name, ' must be ',   &\n        lenvarname, ' characters or less.'\n      call store_error(ermsg)\n      call ustop()\n    endif\n  end subroutine check_varname\n"}
{"id": 1059, "subroutine": "  subroutine allocate_logical(logicalsclr, name, origin)\n    logical, pointer, intent(inout) :: logicalsclr\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    allocate(logicalsclr, stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, 1)\n    nvalues_alogical = nvalues_alogical + 1\n    allocate(mt)\n    mt%logicalsclr => logicalsclr\n    mt%isize = 1\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a)\") 'logical'\n    call memorylist%add(mt)\n  end subroutine allocate_logical\n"}
{"id": 1060, "subroutine": "  subroutine allocate_int(intsclr, name, origin)\n    integer(i4b), pointer, intent(inout) :: intsclr\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    call check_varname(name)\n    allocate(intsclr, stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, 1)\n    nvalues_aint = nvalues_aint + 1\n    allocate(mt)\n    mt%intsclr => intsclr\n    mt%isize = 1\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a)\") 'integer'\n    call memorylist%add(mt)\n  end subroutine allocate_int\n"}
{"id": 1061, "subroutine": "  subroutine allocate_int1d(aint, isize, name, origin)\n    integer(i4b), dimension(:), pointer, contiguous, intent(inout) :: aint\n    integer(i4b), intent(in) :: isize\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    call check_varname(name)\n    allocate(aint(isize), stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, isize)\n    nvalues_aint = nvalues_aint + isize\n    allocate(mt)\n    mt%aint1d => aint\n    mt%isize = isize\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a,' (',i0,')')\") 'integer', isize\n    call memorylist%add(mt)\n  end subroutine allocate_int1d\n"}
{"id": 1062, "subroutine": "  subroutine allocate_dbl(dblsclr, name, origin)\n    real(dp), pointer, intent(inout) :: dblsclr\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    call check_varname(name)\n    allocate(dblsclr, stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, 1)\n    nvalues_aint = nvalues_aint + 1\n    allocate(mt)\n    mt%dblsclr => dblsclr\n    mt%isize = 1\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a)\") 'double'\n    call memorylist%add(mt)\n  end subroutine allocate_dbl\n"}
{"id": 1063, "subroutine": "  subroutine allocate_dbl1d(adbl, isize, name, origin)\n    real(dp), dimension(:), pointer, contiguous, intent(inout) :: adbl\n    integer(i4b), intent(in) :: isize\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    call check_varname(name)\n    allocate(adbl(isize), stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, isize)\n    nvalues_adbl = nvalues_adbl + isize\n    allocate(mt)\n    mt%adbl1d => adbl\n    mt%isize = isize\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a,' (',i0,')')\") 'double', isize\n    call memorylist%add(mt)\n  end subroutine allocate_dbl1d\n"}
{"id": 1064, "subroutine": "  subroutine allocate_dbl2d(adbl, ncol, nrow, name, origin)\n    real(dp), dimension(:, :), pointer, contiguous, intent(inout) :: adbl\n    integer(i4b), intent(in) :: ncol\n    integer(i4b), intent(in) :: nrow\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    integer(i4b) :: isize\n    type(memorytype), pointer :: mt\n    character(len=100) :: ermsg\n    call check_varname(name)\n    isize = ncol * nrow\n    allocate(adbl(ncol, nrow), stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, isize)\n    nvalues_adbl = nvalues_adbl + isize\n    allocate(mt)\n    mt%adbl2d => adbl\n    mt%isize = isize\n    mt%name = name\n    mt%origin = origin\n    write(mt%memtype, \"(a,' (',i0,',',i0,')')\") 'double', ncol, nrow\n    call memorylist%add(mt)\n  end subroutine allocate_dbl2d\n"}
{"id": 1065, "subroutine": "  subroutine reallocate_int1d(aint, isize, name, origin)\n    integer(i4b), dimension(:), pointer, contiguous, intent(inout) :: aint\n    integer(i4b), intent(in) :: isize\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    integer(i4b) :: i, isizeold\n    character(len=100) :: ermsg\n    logical :: found\n    !\n    ! -- find and assign mt\n    call get_from_memorylist(name, origin, mt, found)\n    !\n    ! -- allocate aint and then refill\n    isizeold = size(mt%aint1d)\n    allocate(aint(isize), stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, isize)\n    do i = 1, isizeold\n      aint(i) = mt%aint1d(i)\n    enddo\n    !\n    ! -- deallocate mt pointer, repoint, recalculate isize\n    deallocate(mt%aint1d)\n    mt%aint1d => aint\n    mt%isize = isize\n    mt%nrealloc = mt%nrealloc + 1\n    mt%master = .true.\n    nvalues_aint = nvalues_aint + isize - isizeold\n    !\n    ! -- return\n    return\n  end subroutine reallocate_int1d\n"}
{"id": 1066, "subroutine": "  subroutine reallocate_dbl2d(adbl, ncol, nrow, name, origin)\n    real(dp), dimension(:, :), pointer, contiguous, intent(inout) :: adbl\n    integer(i4b), intent(in) :: ncol\n    integer(i4b), intent(in) :: nrow\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    integer(i4b) :: istat\n    type(memorytype), pointer :: mt\n    integer(i4b), dimension(2) :: ishape\n    integer(i4b) :: i, j, isize, isizeold\n    character(len=100) :: ermsg\n    logical :: found\n    !\n    ! -- find and assign mt\n    call get_from_memorylist(name, origin, mt, found)\n    !\n    ! -- allocate adbl and then refill\n    ishape = shape(mt%adbl2d)\n    isize = nrow * ncol\n    isizeold = ishape(1) * ishape(2)\n    allocate(adbl(ncol, nrow), stat=istat, errmsg=ermsg)\n    if(istat /= 0) call allocate_error(name, origin, istat, ermsg, isize)\n    do i = 1, ishape(2)\n      do j = 1, ishape(1)\n        adbl(j, i) = mt%adbl2d(j, i)\n      enddo\n    enddo\n    !\n    ! -- deallocate mt pointer, repoint, recalculate isize\n    deallocate(mt%adbl2d)\n    mt%adbl2d => adbl\n    mt%isize = isize\n    mt%nrealloc = mt%nrealloc + 1\n    mt%master = .true.\n    nvalues_adbl = nvalues_adbl + isize - isizeold\n    write(mt%memtype, \"(a,' (',i0,',',i0,')')\") 'double', ncol, nrow\n    !\n    ! -- return\n    return\n  end subroutine reallocate_dbl2d\n"}
{"id": 1067, "subroutine": "  subroutine setptr_logical(logicalsclr, name, origin)\n    logical, pointer, intent(inout) :: logicalsclr\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    type(memorytype), pointer :: mt\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)    \n    logicalsclr => mt%logicalsclr\n  end subroutine setptr_logical\n"}
{"id": 1068, "subroutine": "  subroutine setptr_dbl2d(adbl, name, origin)\n    real(dp), dimension(:, :), pointer, contiguous, intent(inout) :: adbl\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    type(memorytype), pointer :: mt\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)    \n    adbl => mt%adbl2d\n  end subroutine setptr_dbl2d\n"}
{"id": 1069, "subroutine": "  subroutine copyptr_int1d(aint, name, origin, origin2)\n    integer(i4b), dimension(:), pointer, contiguous, intent(inout) :: aint\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    character(len=*), intent(in), optional :: origin2\n    type(memorytype), pointer :: mt\n    integer(i4b) :: n\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)    \n    aint => null()\n    ! -- check the copy into the memory manager\n    if (present(origin2)) then\n      call allocate_int1d(aint, size(mt%aint1d), mt%name, origin2)\n    ! -- create a local copy\n    else\n      allocate(aint(size(mt%aint1d)))\n    end if\n    do n = 1, size(mt%aint1d)\n      aint(n) = mt%aint1d(n)\n    end do\n  end subroutine copyptr_int1d\n"}
{"id": 1070, "subroutine": "  subroutine copyptr_int2d(aint, name, origin, origin2)\n    integer(i4b), dimension(:,:), pointer, contiguous, intent(inout) :: aint\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    character(len=*), intent(in), optional :: origin2\n    type(memorytype), pointer :: mt\n    integer(i4b) :: i, j\n    integer(i4b) :: ncol, nrow\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)    \n    aint => null()\n    ncol = size(mt%aint2d, dim=1)\n    nrow = size(mt%aint2d, dim=2)\n    ! -- check the copy into the memory manager\n    if (present(origin2)) then\n      call allocate_int2d(aint, ncol, nrow, mt%name, origin2)\n    ! -- create a local copy\n    else\n      allocate(aint(ncol,nrow))\n    end if\n    do i = 1, nrow\n      do j = 1, ncol\n        aint(j,i) = mt%aint2d(j,i)\n      end do\n    end do\n  end subroutine copyptr_int2d\n"}
{"id": 1071, "subroutine": "  subroutine reassignptr_int1d(aint1d, name, origin, name2, origin2)\n    integer(i4b), dimension(:), pointer, contiguous, intent(inout) :: aint1d\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    character(len=*), intent(in) :: name2\n    character(len=*), intent(in) :: origin2\n    type(memorytype), pointer :: mt, mt2\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)\n    call get_from_memorylist(name2, origin2, mt2, found)\n    if (size(aint1d) > 0) then\n      nvalues_aint = nvalues_aint - size(aint1d)\n      deallocate(aint1d)\n    end if\n    aint1d => mt2%aint1d\n    mt%aint1d => aint1d\n    mt%isize = size(aint1d)\n    write(mt%memtype, \"(a,' (',i0,')')\") 'integer', mt%isize\n    mt%master = .false.\n    return\n  end subroutine reassignptr_int1d\n"}
{"id": 1072, "subroutine": "  subroutine reassignptr_int2d(aint2d, name, origin, name2, origin2)\n    integer(i4b), dimension(:,:), pointer, contiguous, intent(inout) :: aint2d\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    character(len=*), intent(in) :: name2\n    character(len=*), intent(in) :: origin2\n    integer(i4b) :: ncol, nrow\n    type(memorytype), pointer :: mt, mt2\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)\n    call get_from_memorylist(name2, origin2, mt2, found)\n    if (size(aint2d) > 0) then\n      nvalues_aint = nvalues_aint - size(aint2d)\n      deallocate(aint2d)\n    end if\n    aint2d => mt2%aint2d\n    mt%aint2d => aint2d\n    mt%isize = size(aint2d)\n    ncol = size(aint2d, dim=1)\n    nrow = size(aint2d, dim=2)\n    write(mt%memtype, \"(a,' (',i0,',',i0,')')\") 'integer', ncol, nrow\n    mt%master = .false.\n    return\n  end subroutine reassignptr_int2d\n"}
{"id": 1073, "subroutine": "  subroutine reassignptr_dbl1d(adbl1d, name, origin, name2, origin2)\n    real(dp), dimension(:), pointer, contiguous, intent(inout) :: adbl1d\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in) :: origin\n    character(len=*), intent(in) :: name2\n    character(len=*), intent(in) :: origin2\n    type(memorytype), pointer :: mt, mt2\n    logical :: found\n    call get_from_memorylist(name, origin, mt, found)\n    call get_from_memorylist(name2, origin2, mt2, found)\n    if (size(adbl1d) > 0) then\n      nvalues_adbl = nvalues_adbl - size(adbl1d)\n      deallocate(adbl1d)\n    end if\n    adbl1d => mt2%adbl1d\n    mt%adbl1d => adbl1d\n    mt%isize = size(adbl1d)\n    write(mt%memtype, \"(a,' (',i0,')')\") 'double', mt%isize\n    mt%master = .false.\n    return\n  end subroutine reassignptr_dbl1d\n"}
{"id": 1074, "subroutine": "  subroutine deallocate_logical(logicalsclr)\n    logical, pointer, intent(inout) :: logicalsclr\n    class(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    logical :: found\n    found = .false.\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      if(associated(mt%logicalsclr, logicalsclr)) then\n        nullify(mt%logicalsclr)\n        found = .true.\n        exit\n      endif\n    enddo\n    if (.not. found) then\n      call store_error('programming error in deallocate_logical')\n      call ustop()\n    else\n      if (mt%master) then\n        deallocate(logicalsclr)\n      else\n        nullify(logicalsclr)\n      end if\n    endif\n  end subroutine deallocate_logical\n"}
{"id": 1075, "subroutine": "  subroutine deallocate_int(intsclr)\n    integer(i4b), pointer, intent(inout) :: intsclr\n    class(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    logical :: found\n    found = .false.\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      if(associated(mt%intsclr, intsclr)) then\n        nullify(mt%intsclr)\n        found = .true.\n        exit\n      endif\n    enddo\n    if (.not. found) then\n      call store_error('programming error in deallocate_int')\n      call ustop()\n    else\n      if (mt%master) then\n        deallocate(intsclr)\n      else\n        nullify(intsclr)\n      end if\n    endif\n  end subroutine deallocate_int\n"}
{"id": 1076, "subroutine": "  subroutine deallocate_int1d(aint1d, name, origin)\n    integer(i4b), dimension(:), pointer, contiguous, intent(inout) :: aint1d\n    character(len=*), optional :: name\n    character(len=*), optional :: origin\n    type(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    logical :: found\n    if (present(name) .and. present(origin)) then\n      call get_from_memorylist(name, origin, mt, found)\n      nullify(mt%aint1d)\n    else\n      found = .false.\n      do ipos = 1, memorylist%count()\n        mt => memorylist%get(ipos)\n        if(associated(mt%aint1d, aint1d)) then\n          nullify(mt%aint1d)\n          found = .true.\n          exit\n        endif\n      enddo\n    end if\n    if (.not. found .and. size(aint1d) > 0 ) then\n      call store_error('programming error in deallocate_int1d')\n      call ustop()\n    else\n      if (mt%master) then\n        deallocate(aint1d)\n      else\n        nullify(aint1d)\n      end if\n    endif\n  end subroutine deallocate_int1d\n"}
{"id": 1077, "subroutine": "  subroutine deallocate_int2d(aint2d, name, origin)\n    integer(i4b), dimension(:, :), pointer, contiguous, intent(inout) :: aint2d\n    character(len=*), optional :: name\n    character(len=*), optional :: origin\n    type(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    logical :: found\n    if (present(name) .and. present(origin)) then\n      call get_from_memorylist(name, origin, mt, found)\n      nullify(mt%aint2d)\n    else\n      found = .false.\n      do ipos = 1, memorylist%count()\n        mt => memorylist%get(ipos)\n        if(associated(mt%aint2d, aint2d)) then\n          nullify(mt%aint2d)\n          found = .true.\n          exit\n        endif\n      enddo\n    end if\n    if (.not. found .and. size(aint2d) > 0 ) then\n      call store_error('programming error in deallocate_int2d')\n      call ustop()\n    else\n      if (mt%master) then\n        deallocate(aint2d)\n      else\n        nullify(aint2d)\n      end if\n    endif\n  end subroutine deallocate_int2d\n"}
{"id": 1078, "subroutine": "  subroutine deallocate_dbl1d(adbl1d, name, origin)\n    real(dp), dimension(:), pointer, contiguous, intent(inout) :: adbl1d\n    character(len=*), optional :: name\n    character(len=*), optional :: origin\n    type(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    logical :: found\n    if (present(name) .and. present(origin)) then\n      call get_from_memorylist(name, origin, mt, found)\n      nullify(mt%adbl1d)\n    else\n      found = .false.\n      do ipos = 1, memorylist%count()\n        mt => memorylist%get(ipos)\n        if(associated(mt%adbl1d, adbl1d)) then\n          nullify(mt%adbl1d)\n          found = .true.\n          exit\n        endif\n      enddo\n    end if\n    if (.not. found .and. size(adbl1d) > 0 ) then\n      call store_error('programming error in deallocate_dbl1d')\n      call ustop()\n    else\n      if (mt%master) then\n        deallocate(adbl1d)\n      else\n        nullify(adbl1d)\n      end if\n    endif\n  end subroutine deallocate_dbl1d\n"}
{"id": 1079, "subroutine": "  subroutine deallocate_ts1d(ats1d)\n    type (memorytstype), dimension(:), pointer, contiguous, intent(inout) :: ats1d\n    class(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    integer(i4b) :: i\n    logical :: found \n    found = .false.\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      if (associated(mt%ats1d, ats1d)) then\n        nullify(mt%ats1d)\n        found = .true.\n        exit\n      end if\n    end do\n    if (.not. found .and. size(ats1d) > 0 ) then\n      call store_error('programming error in deallocate_ts1d')\n      call ustop()\n    else\n      do i = 1, size(ats1d)\n        deallocate(ats1d(i)%name)\n        deallocate(ats1d(i)%value)\n      enddo\n      if (mt%master) then\n        deallocate(ats1d)\n      else\n        nullify(ats1d)\n      end if\n    endif\n    return\n  end subroutine deallocate_ts1d\n"}
{"id": 1080, "subroutine": "  subroutine mem_set_print_option(iout, keyword, errmsg)\n    integer(i4b), intent(in) :: iout\n    character(len=*), intent(in) :: keyword\n    character(len=*), intent(inout) :: errmsg\n    select case (keyword)\n      case ('none')\n        iprmem = 0\n        write(iout, '(4x, a)')                                                 &\n              'limited memory information will be written.'\n      case ('summary')\n        iprmem = 1\n        write(iout, '(4x, a)')                                                 &\n              'a summary of simulation memory information will be written.'\n      case ('all')\n        iprmem = 2\n        write(iout, '(4x, a)')                                                 &\n              'all simulation memory information will be written.'\n      case default\n        write(errmsg,'(4x,a,a)')                                               &\n          'unknown memory print option: ', trim(keyword)\n    end select\n    return\n  end subroutine mem_set_print_option\n"}
{"id": 1081, "subroutine": "  subroutine mem_usage(iout)\n    integer(i4b), intent(in) :: iout\n    class(memorytype), pointer :: mt\n    character(len=*), parameter :: fmt = \"(1x, a, i0)\"\n    character(len=*), parameter :: fmtd = \"(1x, a, 1(1pg15.6))\"\n    character(len=*), parameter :: fmttitle = \"(/, 1x, a)\"\n    character(len=*), parameter :: fmtheader = &\n      \"(1x, a40, a20, a20, a10, a10, a10, /, 1x, 110('-'))\"\n    character(len=200) :: msg\n    character(len=lenorigin), allocatable, dimension(:) :: cunique\n    real(dp) :: bytesmb\n    integer(i4b) :: ipos\n    integer(i4b) :: icomp, ilen\n    integer(i8b) :: nint, nreal\n    !\n    ! -- write info to simulation list file\n    write(iout, fmttitle) 'information on variables stored in the memory manager'\n    !\n    ! -- write summary table for simulatation components\n    if (iprmem == 1) then\n      !\n      ! -- find unique names of simulation componenets\n      call mem_unique_origins(cunique)\n      write(iout, '(*(g0))') '      component     ', &\n                             '   nints  ', &\n                             '   nreal  ', &\n                             '      mbytes    '\n      write(iout, \"(56('-'))\")\n      do icomp = 1, size(cunique)\n        nint = 0\n        nreal = 0\n        bytesmb = dzero\n        ilen = len_trim(cunique(icomp))\n        do ipos = 1, memorylist%count()\n          mt => memorylist%get(ipos)\n          if (cunique(icomp) /= mt%origin(1:ilen)) cycle\n          if (.not. mt%master) cycle\n          if (mt%memtype(1:7) == 'integer') nint = nint + mt%isize\n          if (mt%memtype(1:6) == 'double') nreal = nreal + mt%isize\n        enddo\n        bytesmb = (nint * i4b + nreal * dp) / 1000000.d0\n        write(iout, '(a20, i10, i10, 1pg16.2)') cunique(icomp), nint, nreal, bytesmb\n      enddo\n    endif\n    !\n    ! -- write table with all variables for iprmem == 2\n    if (iprmem == 2) then\n      write(iout, *)\n      write(iout, fmtheader) '                 origin                 ',       &\n                             '        name        ',                           &\n                             '        type        ',                           &\n                             '   size   ',                                     &\n                             ' nrealloc ',                                     &\n                             '  pointer '\n      do ipos = 1, memorylist%count()\n        mt => memorylist%get(ipos)\n        call mt%table_entry(msg)\n        write(iout, '(a)') msg \n      enddo\n    endif\n    !\n    ! -- calculate and write total memory allocation\n    bytesmb = (nvalues_aint * i4b + &\n               nvalues_adbl * dp + &\n               nvalues_ats * dp) / 1000000.d0\n    write(iout, *)\n    write(iout, fmt) 'number of allocated integer variables:   ', nvalues_aint\n    write(iout, fmt) 'number of allocated real variables:    ', nvalues_adbl + nvalues_ats\n    write(iout, fmtd) 'allocated memory in megabytes: ', bytesmb\n    write(iout, *)\n  end subroutine mem_usage\n"}
{"id": 1082, "subroutine": "  subroutine mem_da()\n    class(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      deallocate(mt)\n    enddo\n    call memorylist%clear()\n  end subroutine mem_da\n"}
{"id": 1083, "subroutine": "  subroutine mem_unique_origins(cunique)\n    use arrayhandlersmodule, only: expandarray, ifind\n    use inputoutputmodule, only: parseline\n    character(len=lenorigin), allocatable, dimension(:), intent(inout) :: cunique\n    class(memorytype), pointer :: mt\n    integer(i4b) :: ipos\n    integer(i4b) :: ipa\n    integer(i4b) :: nwords\n    character(len=lenorigin), allocatable, dimension(:) :: words\n    allocate(cunique(0))\n    do ipos = 1, memorylist%count()\n      mt => memorylist%get(ipos)\n      call parseline(mt%origin, nwords, words)\n      ipa = ifind(cunique, words(1))\n      if(ipa < 1) then\n        call expandarray(cunique, 1)\n        cunique(size(cunique)) = words(1)\n      endif\n    enddo\n    return\n  end subroutine mem_unique_origins\n"}
{"id": 1084, "subroutine": "  subroutine calcvist_spa_all(grid, n) \n!------------------------------------------------------------------------------!\n!   computes the turbulent viscosity for rans models.                          !\n!------------------------------------------------------------------------------!\n!----------------------------------[modules]-----------------------------------!\n  use all_mod\n  use pro_mod\n  use les_mod\n  use rans_mod\n  use grid_mod\n  use parameters_mod\n!------------------------------------------------------------------------------!\n  implicit none\n!---------------------------------[arguments]----------------------------------!\n  type(grid_type) :: grid\n!-----------------------------------[locals]-----------------------------------!\n  integer :: c, n \n  real    :: xrat, fv1, lf, cs \n!==============================================================================!\n\n  if(simula == des_spa) then\n    do c = 1, grid % n_cells\n      xrat     = vis % n(c)/visc\n      fv1      = xrat**3/(xrat**3 + cvis1**3)\n      vist(c)  = denc(material(c)) * fv1 * vis % n(c)\n    end do\n  end if\n\n  if(simula == spa_all) then\n    do c = 1, grid % n_cells\n      xrat     = vis % n(c)/visc\n      fv1      = xrat**3/(xrat**3 + cvis1**3)\n      vist(c)  = denc(material(c)) * fv1 * vis % n(c)\n    end do\n  end if\n\n  call exchange(grid, vist)  \n\n  end subroutine\n"}
{"id": 1085, "subroutine": "    subroutine psb_z_diag_apply_vect(alpha,prec,x,beta,y,desc_data,info,trans,work)\n      import :: psb_ipk_, psb_desc_type, psb_z_diag_prec_type, psb_z_vect_type, psb_dpk_\n      type(psb_desc_type),intent(in)    :: desc_data\n      class(psb_z_diag_prec_type), intent(inout)  :: prec\n      type(psb_z_vect_type),intent(inout)   :: x\n      complex(psb_dpk_),intent(in)         :: alpha, beta\n      type(psb_z_vect_type),intent(inout)   :: y\n      integer(psb_ipk_), intent(out)              :: info\n      character(len=1), optional        :: trans\n      complex(psb_dpk_),intent(inout), optional, target :: work(:)\n    end subroutine psb_z_diag_apply_vect\n"}
{"id": 1086, "subroutine": "    subroutine psb_z_diag_precbld(a,desc_a,prec,info,amold,vmold,imold)\n      import :: psb_ipk_, psb_desc_type, psb_z_diag_prec_type, psb_z_vect_type, psb_dpk_, &\n           & psb_zspmat_type, psb_z_base_sparse_mat, psb_z_base_vect_type, &\n           & psb_i_base_vect_type\n      type(psb_zspmat_type), intent(in), target :: a\n      type(psb_desc_type), intent(inout), target   :: desc_a\n      class(psb_z_diag_prec_type),intent(inout) :: prec\n      integer(psb_ipk_), intent(out)                      :: info\n      class(psb_z_base_sparse_mat), intent(in), optional :: amold\n      class(psb_z_base_vect_type), intent(in), optional  :: vmold\n      class(psb_i_base_vect_type), intent(in), optional  :: imold\n    end subroutine psb_z_diag_precbld\n"}
{"id": 1087, "subroutine": "    subroutine psb_z_diag_dump(prec,info,prefix,head)\n      import :: psb_ipk_, psb_desc_type, psb_z_diag_prec_type, psb_z_vect_type, psb_dpk_\n      implicit none \n      class(psb_z_diag_prec_type), intent(in) :: prec\n      integer(psb_ipk_), intent(out)                    :: info\n      character(len=*), intent(in), optional  :: prefix,head\n    end subroutine psb_z_diag_dump\n"}
{"id": 1088, "subroutine": "  subroutine psb_z_diag_precinit(prec,info)\n    implicit none\n\n    class(psb_z_diag_prec_type),intent(inout) :: prec\n    integer(psb_ipk_), intent(out)                     :: info\n    integer(psb_ipk_) :: err_act, nrow\n    character(len=20)  :: name='z_diag_precinit'\n\n    call psb_erractionsave(err_act)\n\n    info = psb_success_\n\n\n    call psb_erractionrestore(err_act)\n    return\n\n9999 call psb_error_handler(err_act)\n\n    return\n  end subroutine psb_z_diag_precinit\n"}
{"id": 1089, "subroutine": "  subroutine psb_z_diag_precdescr(prec,iout,root)\n    use psb_penv_mod\n    use psb_error_mod\n    implicit none\n\n    class(psb_z_diag_prec_type), intent(in) :: prec\n    integer(psb_ipk_), intent(in), optional    :: iout\n    integer(psb_ipk_), intent(in), optional    :: root\n\n    integer(psb_ipk_) :: err_act, nrow, info\n    character(len=20)  :: name='z_diag_precdescr'\n    integer(psb_ipk_) :: iout_, ictxt, iam, np, root_\n\n    call psb_erractionsave(err_act)\n\n    info = psb_success_\n\n    if (present(iout)) then \n      iout_ = iout\n    else\n      iout_ = 6 \n    end if\n    if (present(root)) then \n      root_ = root\n    else\n      root_ = psb_root_\n    end if\n    \n    ictxt = prec%ictxt\n    call psb_info(ictxt,iam,np)\n  \n    if (root_ == -1) root_ = iam\n    \n    if (iam == root_) &\n         &  write(iout_,*) trim(prec%desc_prefix()),' ',&\n         & 'diagonal scaling'\n\n    call psb_erractionsave(err_act)\n\n    info = psb_success_\n\n    call psb_erractionrestore(err_act)\n    return\n\n9999 call psb_error_handler(err_act)\n\n    return\n\n  end subroutine psb_z_diag_precdescr\n"}
{"id": 1090, "subroutine": "  subroutine psb_z_diag_clone(prec,precout,info)\n    use psb_error_mod\n    use psb_realloc_mod\n\n    implicit none\n\n    class(psb_z_diag_prec_type), intent(inout) :: prec\n    class(psb_z_base_prec_type), allocatable, intent(inout)  :: precout\n    integer(psb_ipk_), intent(out)               :: info\n\n    integer(psb_ipk_) :: err_act, i\n    character(len=20)  :: name='z_diag_clone'\n\n    call psb_erractionsave(err_act)\n\n    info = psb_success_\n    if (allocated(precout)) then\n      call precout%free(info)\n      if (info == psb_success_) deallocate(precout, stat=info)\n    end if\n    if (info == psb_success_) &\n         & allocate(psb_z_diag_prec_type :: precout, stat=info)\n    if (info /= 0) goto 9999\n    select type(pout => precout)\n    type is (psb_z_diag_prec_type) \n      call pout%set_ctxt(prec%get_ctxt())\n\n      if (allocated(prec%dv)) then \n        allocate(pout%dv,stat=info)\n        if (info == 0) call prec%dv%clone(pout%dv,info)\n      end if\n      if (info == 0) call psb_safe_ab_cpy(prec%d,pout%d,info)\n      class default\n      info = psb_err_internal_error_\n    end select\n    if (info /= 0) goto 9999\n\n    call psb_erractionrestore(err_act)\n    return\n\n9999 call psb_error_handler(err_act)\n\n    return\n\n  end subroutine psb_z_diag_clone\n"}
{"id": 1091, "subroutine": "  subroutine stereo_projection(kji,kjj,kjk,knorth_pole,kway)\n    !\n    integer,intent(in) :: kji,kjj,kjk\n\tlogical,intent(in) :: knorth_pole\n\tinteger,intent(in) :: kway\n\tinteger :: klon, klat\n\treal*8,dimension(4) :: dlx, dly\n\treal*8,dimension(4) :: dllam, dlphi, dlk\n\treal*8 :: dl_lat0, dl_long0\n\t!\n    dl_lat0 = dlat0 * pi/180.\n    dl_long0 = dlong0 * pi/180.\n    !\n\t!either we interpolate along longitude or along latitude\n\tif(kway.eq.1)then\n\t  klon = 1\n\t  klat = 0\n\telseif(kway.eq.2) then\n\t  klon = 0\n\t  klat = 1\n\tendif\n\t!\n\t! check the discontinuity +/- 180\n\tif(kway.eq.1)then\n\t  if(smixgrd%glam(kji,kjj).lt.180..and.smixgrd%glam(kji+3*nn_rhox,kjj).gt.180.) then\n\t    if(smixgrd%glam(kji+2*nn_rhox,kjj).lt.180.) then\n\t      idisc = 1\n\t    elseif(smixgrd%glam(kji+1*nn_rhox,kjj).gt.180.) then \n\t      idisc = 2\n        elseif(smixgrd%glam(kji+2*nn_rhox,kjj).gt.180.and.smixgrd%glam(kji+1*nn_rhox,kjj).lt.180.)then\n\t      idisc = 3\n\t    endif\n\t  else\n\t  idisc = 0\n\t  endif\n\tendif\n\t!\n\tdllam(1) = smixgrd%glam(kji,kjj) * pi/180.\n\tdlphi(1) = smixgrd%gphi(kji,kjj) * pi/180.\n\tdlk(1)   = (2*dray) / (1 + (sin(dl_lat0)*sin(dlphi(1))) + (cos(dl_lat0)*cos(dlphi(1))*cos(dllam(1) - dl_long0)))\n\t!\n\tdllam(2) = smixgrd%glam(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) * pi/180.\n\tdlphi(2) = smixgrd%gphi(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) * pi/180.\n\tdlk(2)   = (2*dray) / (1 + (sin(dl_lat0)*sin(dlphi(2))) + (cos(dl_lat0)*cos(dlphi(2))*cos(dllam(2) - dl_long0)))\n\t!\n\tdllam(3) = smixgrd%glam(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) * pi/180.\n\tdlphi(3) = smixgrd%gphi(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) * pi/180.\n\tdlk(3)   = (2*dray) / (1 + (sin(dl_lat0)*sin(dlphi(3))) + (cos(dl_lat0)*cos(dlphi(3))*cos(dllam(3) - dl_long0)))\n\t!\n\tdllam(4) = smixgrd%glam(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat) * pi/180.\n\tdlphi(4) = smixgrd%gphi(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat) * pi/180.\n\tdlk(4)   = (2*dray) / (1 + (sin(dl_lat0)*sin(dlphi(4))) + (cos(dl_lat0)*cos(dlphi(4))*cos(dllam(4) - dl_long0)))\n\t!\t\n\tdlx(1) = dlk(1) * cos(dlphi(1)) * sin(dllam(1) - dl_long0)\n\tdly(1) = dlk(1) * ((cos(dl_lat0) * sin(dlphi(1))) - (sin(dl_lat0) * cos(dlphi(1)) * cos(dllam(1) - dl_long0)))\n    !\n\tdlx(2) = dlk(2) * cos(dlphi(2)) * sin(dllam(2) - dl_long0)\n\tdly(2) = dlk(2) * ((cos(dl_lat0) * sin(dlphi(2))) - (sin(dl_lat0) * cos(dlphi(2)) * cos(dllam(2) - dl_long0)))\n    !\n\tdlx(3) = dlk(3) * cos(dlphi(3)) * sin(dllam(3) - dl_long0)\n\tdly(3) = dlk(3) * ((cos(dl_lat0) * sin(dlphi(3))) - (sin(dl_lat0) * cos(dlphi(3)) * cos(dllam(3) - dl_long0)))\n    !\n\tdlx(4) = dlk(4) * cos(dlphi(4)) * sin(dllam(4) - dl_long0)\n\tdly(4) = dlk(4) * ((cos(dl_lat0) * sin(dlphi(4))) - (sin(dl_lat0) * cos(dlphi(4)) * cos(dllam(4) - dl_long0)))\n    ! \n\tdmixlam(1) = smixgrd%glam(kji,kjj)         \n\tdmixlam(2) = smixgrd%glam(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) \n    dmixlam(3) = smixgrd%glam(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) \n    dmixlam(4) = smixgrd%glam(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)\n\t!\n\tdmixphi(1) = smixgrd%gphi(kji,kjj)       \n\tdmixphi(2) = smixgrd%gphi(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) \n    dmixphi(3) = smixgrd%gphi(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) \n    dmixphi(4) = smixgrd%gphi(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)\n\t!\n\tsmixgrd%glam(kji,kjj)                               = dlx(1)\n\tsmixgrd%glam(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) = dlx(2)\n\tsmixgrd%glam(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) = dlx(3)\n\tsmixgrd%glam(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat) = dlx(4)\n\t!\n\tsmixgrd%gphi(kji,kjj)                               = dly(1)\n\tsmixgrd%gphi(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat) = dly(2)\n    smixgrd%gphi(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat) = dly(3)\n    smixgrd%gphi(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat) = dly(4)\n\t!\n  end subroutine stereo_projection\n"}
{"id": 1092, "subroutine": "  subroutine stereo_projection_inv(kji,kjj,kjk,knorth_pole,kway)\n    !\n    integer,intent(in) :: kji,kjj,kjk\n\tlogical,intent(in) :: knorth_pole\n\tinteger,intent(in) :: kway\n\tinteger :: klon, klat\n\treal*8,dimension(5) :: dlx, dly\n\treal*8,dimension(5)  :: dllam, dlphi\n    real*8,dimension(5)  :: dlro, dlc\n\treal*8 :: dl_long0, dl_lat0\n\t!\t\n    dl_lat0 = dlat0 * pi/180.\n    dl_long0 = dlong0 * pi/180.\n    !\n \tif(kway.eq.1)then\n\t  klon = 1\n\t  klat = 0\n\telseif(kway.eq.2) then\n\t  klon = 0\n\t  klat = 1\n\tendif\n\t!\n\t!\n\tdlx(1) = smixgrd%glam(kji,kjj)\n\tdlx(2) = smixgrd%glam(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat)\n\tdlx(3) = smixgrd%glam(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat)\n\tdlx(4) = smixgrd%glam(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)\t\n\tdlx(5) = smixgrd%glam(kji+(nn_rhox+kjk)*klon,kjj+(nn_rhoy+kjk)*klat) \n\t!\n\tdly(1) = smixgrd%gphi(kji,kjj)\n\tdly(2) = smixgrd%gphi(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat)\n\tdly(3) = smixgrd%gphi(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat)\n\tdly(4) = smixgrd%gphi(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)\t\n\tdly(5) = smixgrd%gphi(kji+(nn_rhox+kjk)*klon,kjj+(nn_rhoy+kjk)*klat) \t\n\t!\n\tdlro(1) = sqrt(dlx(1)*dlx(1) + dly(1)*dly(1))\n\tdlro(2) = sqrt(dlx(2)*dlx(2) + dly(2)*dly(2))\n\tdlro(3) = sqrt(dlx(3)*dlx(3) + dly(3)*dly(3))\n\tdlro(4) = sqrt(dlx(4)*dlx(4) + dly(4)*dly(4))\n\tdlro(5) = sqrt(dlx(5)*dlx(5) + dly(5)*dly(5))\n\t!\n\tdlc(1) = 2*atan(dlro(1)/(2*dray))\n\tdlc(2) = 2*atan(dlro(2)/(2*dray))\n\tdlc(3) = 2*atan(dlro(3)/(2*dray))\n\tdlc(4) = 2*atan(dlro(4)/(2*dray))\n\tdlc(5) = 2*atan(dlro(5)/(2*dray))\n\t!\n\tdlphi(1) =  asin(cos(dlc(1))*sin(dl_lat0) + (dly(1)*sin(dlc(1))*cos(dl_lat0) / dlro(1)))\n\tdlphi(2) =  asin(cos(dlc(2))*sin(dl_lat0) + (dly(2)*sin(dlc(2))*cos(dl_lat0) / dlro(2)))\n\tdlphi(3) =  asin(cos(dlc(3))*sin(dl_lat0) + (dly(3)*sin(dlc(3))*cos(dl_lat0) / dlro(3)))\n\tdlphi(4) =  asin(cos(dlc(4))*sin(dl_lat0) + (dly(4)*sin(dlc(4))*cos(dl_lat0) / dlro(4)))\n\tdlphi(5) =  asin(cos(dlc(5))*sin(dl_lat0) + (dly(5)*sin(dlc(5))*cos(dl_lat0) / dlro(5)))\n    !\t\n\tdlphi(:) = dlphi(:) * 180./pi\n    !\n\tdllam(1) = dl_long0 + atan(dlx(1)*sin(dlc(1) / ((dlro(1)*cos(dl_lat0)*cos(dlc(1)))-(dly(1)*sin(dl_lat0)*sin(dlc(1))))))\n\tdllam(2) = dl_long0 + atan(dlx(2)*sin(dlc(2) / ((dlro(2)*cos(dl_lat0)*cos(dlc(2)))-(dly(2)*sin(dl_lat0)*sin(dlc(2))))))\n\tdllam(3) = dl_long0 + atan(dlx(3)*sin(dlc(3) / ((dlro(3)*cos(dl_lat0)*cos(dlc(3)))-(dly(3)*sin(dl_lat0)*sin(dlc(3))))))\n\tdllam(4) = dl_long0 + atan(dlx(4)*sin(dlc(4) / ((dlro(4)*cos(dl_lat0)*cos(dlc(4)))-(dly(4)*sin(dl_lat0)*sin(dlc(4))))))\n\tdllam(5) = dl_long0 + atan(dlx(5)*sin(dlc(5) / ((dlro(5)*cos(dl_lat0)*cos(dlc(5)))-(dly(5)*sin(dl_lat0)*sin(dlc(5))))))\n    !\n\tdllam(1) = dllam(1) * 180./pi\n\tdllam(2) = dllam(2) * 180./pi \n\tdllam(3) = dllam(3) * 180./pi \n\tdllam(4) = dllam(4) * 180./pi \n    !\n\tdllam(5) = dllam(5) * 180./pi \n\t!\n\tif(kway.eq.1)then\t\t\n\t  if(idisc.eq.1) then\n\t\tdllam(5) = dllam(5) + 180.\n\t  elseif(idisc.eq.2) then\n\t\tdllam(5) = dllam(5) - 180.\n\t  elseif(idisc.eq.3) then\n\t\t dllam(5) = dllam(5) - 180.\n\t  else\n\t\tdllam(5) = dllam(5)  \n\t  endif\n\t  !\n\telseif(kway.eq.2)then\n\t  if(smixgrd%glam(kji,kjj+1*nn_rhoy).gt.0.and.smixgrd%glam(kji,kjj+2*nn_rhoy).gt.0)then\n\t    if(dllam(5).lt.0.)then\n\t      dllam(5) = dllam(5) + 180\n\t\tendif\n\t  elseif(smixgrd%glam(kji,kjj+1*nn_rhoy).lt.0.and.smixgrd%glam(kji,kjj+2*nn_rhoy).lt.0)then\n\t    if(dllam(5).gt.0.)then\n\t\t  dllam(5) = dllam(5) - 180\n\t    endif\n\t  elseif(smixgrd%glam(kji,kjj+1*nn_rhoy)*smixgrd%glam(kji,kjj+2*nn_rhoy).lt.0)then\n\t    if(dllam(5).lt.0.)then\n\t      dllam(5) = dllam(5) + 180\n\t    elseif(dllam(5).gt.0.)then\n\t      dllam(5) = dllam(5) - 180\n\t    endif\n\t  endif\n\tendif\n\t!\n\tsmixgrd%glam(kji,kjj)                                       = dmixlam(1)\n\tsmixgrd%glam(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat)         = dmixlam(2)\n    smixgrd%glam(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat)         = dmixlam(3)\n    smixgrd%glam(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)         = dmixlam(4)\n\t!\n    smixgrd%glam(kji+(nn_rhox+kjk)*klon,kjj+(nn_rhoy+kjk)*klat) = dllam(5)\n\t!\n\tsmixgrd%gphi(kji,kjj)                                       = dmixphi(1)\n\tsmixgrd%gphi(kji+1*nn_rhox*klon,kjj+1*nn_rhoy*klat)         = dmixphi(2)\n    smixgrd%gphi(kji+2*nn_rhox*klon,kjj+2*nn_rhoy*klat)         = dmixphi(3)\n    smixgrd%gphi(kji+3*nn_rhox*klon,kjj+3*nn_rhoy*klat)         = dmixphi(4)\n\t!\n    smixgrd%gphi(kji+(nn_rhox+kjk)*klon,kjj+(nn_rhoy+kjk)*klat) = dlphi(5)\n\t!\n  end subroutine stereo_projection_inv\n"}
{"id": 1093, "subroutine": "      subroutine zgesvx_f95( a, b, x, af, ipiv, fact, trans, equed, r, c, ferr, berr, rcond,     &\n                             rpvgrw, info )\n!\n!  -- lapack95 interface driver routine (version 3.0) --\n!     uni-c, denmark; univ. of tennessee, usa; nag ltd., uk\n!     september, 2000\n!\n!     .. use statements ..\n      use la_precision, only: wp => dp\n      use la_auxmod, only: lsame, erinfo\n      use f77_lapack, only: gesvx_f77 => la_gesvx\n!     .. implicit statement ..\n      implicit none\n!     .. scalar arguments ..\n      character(len=1), intent(in), optional :: trans, fact\n      character(len=1), intent(inout), optional :: equed\n      integer, intent(out), optional :: info\n      real(wp), intent(out), optional :: rcond, rpvgrw\n!     .. array arguments ..\n      complex(wp), intent(inout) :: a(:,:), b(:,:)\n      complex(wp), intent(out) :: x(:,:)\n      integer, intent(inout), optional, target :: ipiv(:)\n      real(wp), intent(inout), optional, target :: c(:), r(:)\n      complex(wp), intent(inout), optional, target :: af(:,:)\n      real(wp), intent(out), optional, target :: ferr(:), berr(:)\n!----------------------------------------------------------------------\n! \n! purpose\n! =======\n! \n!    la_gesvx computes the solution to a real or complex linear system of\n! equations of the form a*x = b, a^t*x = b or a^h*x = b, where a is a \n! square matrix and x and b are rectangular matrices or vectors.\n!    la_gesvx can also optionally equilibrate the system if a is poorly\n! scaled, estimate the condition number of (the equilibrated) a, return \n! the pivot growth factor, and compute error bounds.\n! \n! =========\n! \n\n!                  trans=trans, equed=equed, r=r, c=c, ferr=ferr, &\n!                  berr=berr, rcond=rcond, rpvgrw=rpvgrw, &\n!                  info=info )\n!          <type>(<wp>), intent(inout) :: a(:,:), <rhs>\n!          <type>(<wp>), intent(out) :: <sol>\n!          <type>(<wp>), intent(inout), optional :: af(:,:)\n!          integer, intent(inout), optional :: ipiv(:)\n!          character(len=1), intent(in), optional :: fact, &\n!                                       trans\n!          character(len=1), intent(inout), optional :: equed\n!          real(<wp>), intent(inout), optional :: r(:), c(:)\n!          real(<wp>), intent(out), optional :: <err>, rcond, rpvgrw\n!          integer, intent(out), optional :: info\n!     where\n!          <type> ::= real | complex\n!          <wp>   ::= kind(1.0) | kind(1.0d0)\n!          <rhs>  ::= b(:,:) | b(:)\n!          <sol>  ::= x(:,:) | x(:)\n!          <err>  ::= ferr(:), berr(:) | ferr, berr\n! \n! arguments\n! =========\n! \n! a         (input/output) real or complex square array, shape (:,:).\n!           on entry, the matrix a or its equilibration:\n!           if fact = 'f' and equed /= 'n' then a has been equilibrated \n!           by the scaling factors in r and/or c during a previous call\n! \t    to la_gesvx.\n!           on exit, if fact = 'e', then the equilibrated version of a\n! \t    is stored in a; otherwise, a is unchanged.\n! b         (input/output) real or complex array, shape (:,:) with \n!           size(b,1) = size(a,1) or shape (:) with size(b) = size(a,1).\n!           on entry, the matrix b.\n!           on exit, the scaled version of b if the system has been \n!           equilibrated; otherwise, b is unchanged.\n! x         (output) real or complex array, shape (:,:) with size(x,1) =\n!           size(a,1) and size(x,2) = size(b,2), or shape (:) with \n! \t    size(x) = size(a,1).\n!           the solution matrix x .\n! af        optional (input or output) real or complex square array, \n!           shape (:,:) with the same size as a.\n!           if fact = 'f' then af is an input argument that contains the\n!           factors l and u of (the equilibrated) a returned by a\n! \t    previous call to la_gesvx.\n!           if fact /= 'f' then af is an output argument that contains \n!           the factors l and u of (the equilibrated) a.\n! ipiv      optional (input or output) integer array, shape (:) with \n!           size(ipiv) = size(a,1).\n!           if fact = 'f' then ipiv is an input argument that contains \n!           the pivot indices from the factorization of (the \n! \t    equilibrated) a, returned by a previous call to la_gesvx.\n!           if fact /= 'f' then ipiv is an output argument that contains\n!           the pivot indices from the factorization of (the\n! \t    equilibrated) a.\n! fact      optional (input) character(len=1).\n!           specifies whether the factored form of the matrix a is \n!           supplied on entry, and, if not, whether the matrix a should\n!           be equilibrated before it is factored.\n!            = 'n': the matrix a will be copied to af and factored (no \n! \t          equilibration).\n!            = 'e': the matrix a will be equilibrated, then copied to af\n! \t          and factored.\n!            = 'f': af and ipiv contain the factored form of (the \n! \t          equilibrated) a.\n!           default value: 'n'.\n! trans     optional (input) character(len=1).\n!           specifies the form of the system of equations:\n!            = 'n': a*x = b (no transpose)\n!            = 't': a^t*x = b (transpose)\n!            = 'c': a^h*x = b (conjugate transpose)\n! equed     optional (input or output) character(len=1).\n!           specifies the form of equilibration that was done.\n!           equed is an input argument if fact = 'f', otherwise it is an\n!           output argument:\n!            = 'n': no equilibration (always true if fact = 'n').\n!            = 'r': row equilibration, i.e., a has been premultiplied by\n! \t          diag(r).\n!            = 'c': column equilibration, i.e., a has been postmultiplied \n! \t          by diag(c).\n!            = 'b': both row and column equilibration.\n!           default value: 'n'.\n! r         optional (input or output) real array, shape (:) with size(r)\n!           = size(a,1). the row scale factors for a.\n!           r is an input argument if fact = 'f' and equed = 'r' or 'b'.\n!           r is an output argument if fact = 'e' and equed = 'r' or 'b'.\n! c         optional (input or output) real array, shape (:) with size(c) \n!           = size(a,1). the column scale factors for a.\n!           c is an input argument if fact = 'f' and equed = 'c' or 'b'.\n!           c is an output argument if fact = 'e' and equed = 'c' or 'b'.\n! ferr      optional (output) real array of shape (:), with size(ferr) =\n!           size(x,2), or real scalar.\n!           the estimated forward error bound for each solution vector \n!           x(j) (the j-th column of the solution matrix x). if xtrue is \n!           the true solution corresponding to x(j) , ferr(j) is an \n! \t    estimated upper bound for the magnitude of the largest \n! \t    element in (x(j)-xtrue) divided by the magnitude of the \n! \t    largest element in x(j). the estimate is as reliable as the\n!           estimate for rcond and is almost always a slight \n! \t    overestimate of the true error.\n! berr      optional (output) real array of shape (:), with size(berr) =\n!           size(x,2), or real scalar.\n!           the componentwise relative backward error of each solution \n!           vector x(j) (i.e., the smallest relative change in any\n!           element of a or b that makes x(j) an exact solution).\n! rcond     optional (output) real.\n!           the estimate of the reciprocal condition number of (the \n!           equilibrated) a. if rcond is less than the machine precision,\n!           the matrix is singular to working precision. this condition \n!           is indicated by a return code of info > 0.\n! rpvgrw    optional (output) real.\n!           the reciprocal pivot growth factor ||a||inf = ||u||inf. if\n!           rpvgrw is much less than 1, then the stability of the lu \n!           factorization of the (equilibrated) matrix a could be poor.\n!           this also means that the solution x , condition estimator \n!           rcond, and forward error bound ferr could be unreliable. if\n!           the factorization fails with 0 < info <= size(a,1), then\n!           rpvgrw contains the reciprocal pivot growth factor for the \n!           leading info columns of a.\n! info      optional (output) integer\n!           = 0: successful exit.\n!           < 0: if info = -i, the i-th argument had an illegal value.\n!           > 0: if info = i, and i is\n!               <= n: u(i,i) = 0. the factorization has been completed,\n!                    but the factor u is singular, so the solution could \n! \t\t   not be computed.\n!               = n+1: u is nonsingular, but rcond is less than machine \n! \t           precision, so the matrix is singular to working \n! \t\t   precision. nevertheless, the solution and error\n!                    bounds are computed because the computed solution \n! \t\t   can be more accurate than the value of rcond would \n! \t\t   suggest.\n!           if info is not present and an error occurs, then the program \n! \t    is terminated with an error message.\n!----------------------------------------------------------------------\n!     .. parameters ..\n      character(len=8), parameter :: srname = 'la_gesvx'\n!     .. local scalars ..\n      character(len=1) :: lfact, ltrans, lequed\n      integer :: istat, istat1, ld, linfo, n, nrhs, s1af, s2af, sberr, sc, sferr, sipiv, sr\n      real(wp) :: lrcond, mvr, mvc\n!     .. local pointers ..\n      integer, pointer :: lpiv(:)\n      real(wp),  pointer :: lc(:), lr(:), lferr(:), lberr(:), rwork(:)\n      complex(wp),  pointer :: work(:), laf(:, :)\n!     .. intrinsic functions ..\n      intrinsic max, present, size, minval, tiny\n!     .. executable statements ..\n      linfo = 0; istat = 0; n = size(a, 1); nrhs = size(b, 2)\n      ld = max(1,n)\n      if( present(rcond) ) rcond = 1.0_wp\n      if( present(rpvgrw) ) rpvgrw = 1.0_wp\n      if( present(fact) )then\n         lfact = fact\n      else\n         lfact='n'\n      end if\n      if( present(equed) .and. lsame(lfact,'f') )then\n         lequed = equed\n      else\n         lequed='n'\n      end if\n      if( present(ipiv) )then\n         sipiv = size(ipiv)\n      else\n         sipiv = n\n      end if\n      if( present(af) )then\n         s1af = size(af,1); s2af = size(af,2)\n      else\n         s1af = n; s2af = n\n      end if\n      if( ( present(c) ) )then\n         sc = size(c)\n      else\n         sc = n\n      end if\n      if( ( present(c) .and. lsame(lfact,'f') ) .and.                   &\n     &    ( lsame(lequed,'c') .or. lsame(lequed,'b') ) )then\n         mvc = minval(c)\n      else\n         mvc = tiny(1.0_wp)\n      end if\n      if( present(r) )then\n         sr = size(r)\n      else\n         sr = n\n      end if\n      if( ( present(r) .and. lsame(lfact,'f') ) .and.                   &\n     &    ( lsame(lequed,'r') .or. lsame(lequed,'b') ) )then\n         mvr = minval(r)\n      else\n         mvr = tiny(1.0_wp)\n      end if\n      if( present(ferr) )then\n         sferr = size(ferr)\n      else\n         sferr = nrhs\n      end if\n      if( present(berr) )then\n         sberr = size(berr)\n      else\n         sberr = nrhs\n      end if\n      if(present(trans))then\n         ltrans = trans\n      else\n         ltrans='n'\n      end if\n!     .. test the arguments\n      if( size(a, 2) /= n .or. n < 0 )then\n         linfo = -1\n      else if( size(b, 1) /= n .or. nrhs < 0 )then\n         linfo = -2\n      else if( size(x, 1) /= n .or. size(x, 2) /= nrhs )then\n         linfo = -3\n      else if( s1af /= n .or. s2af /= n ) then\n         linfo = -4\n      else if( sipiv /= n )then\n         linfo = -5\n      else if( sr /= n .or. mvr <= 0.0_wp )then\n         linfo = -9\n      else if( sc /= n .or. mvc <= 0.0_wp )then\n         linfo = -10\n      else if( sferr /= nrhs )then\n         linfo = -11\n      else if( sberr /= nrhs )then\n         linfo = -12\n      else if( ( .not. ( lsame(lfact,'f') .or. lsame(lfact,'n') .or.    &\n     &                 lsame(lfact,'e') ) ) .or.                        &\n     &    ( lsame(lfact,'f') .and. .not.( present(af) .and.             &\n     &      present(ipiv) ) ) )then\n         linfo = -6\n      else if( .not.( lsame(ltrans,'n') .or.  lsame(ltrans,'t') .or.    &\n     &               lsame(ltrans,'c') ) )then\n         linfo = -7\n      else if( ( .not.( lsame(lequed,'n') .or. lsame(lequed,'r') .or.   &\n     &       lsame(lequed,'c') .or. lsame(lequed,'b') )                 &\n     &           .and. lsame(lfact,'f') ) .or.                          &\n     &      ( ( lsame(lequed,'r') .or. lsame(lequed,'b') ) .and.        &\n     &           .not.present(r) ) .or.                                 &\n     &      ( ( lsame(lequed,'c') .or. lsame(lequed,'b') ) .and.        &\n     &           .not.present(c) ) )then\n         linfo = -8\n      else if ( n > 0 )then\n         if( .not.present(af) ) then\n            allocate( laf(ld,n), stat=istat )\n         else\n            laf => af\n         end if\n         if( istat == 0 )then\n            if( .not.present(ipiv) )then\n               allocate( lpiv(n), stat=istat )\n            else\n               lpiv => ipiv\n            end if\n         end if\n         if( istat == 0 )then\n            if( .not.present(r) )then\n               allocate( lr(n), stat=istat )\n            else\n               lr => r\n            end if\n         end if\n         if( istat == 0 )then\n            if( .not.present(c) )then\n               allocate( lc(n), stat=istat )\n            else\n               lc => c\n            end if\n         end if\n         if( istat == 0 )then\n            if( .not.present(ferr) )then\n               allocate( lferr(nrhs), stat=istat )\n            else\n               lferr => ferr\n            end if\n         end if\n         if( istat == 0 )then\n            if( .not.present(berr) )then\n               allocate( lberr(nrhs), stat=istat )\n            else\n               lberr => berr\n            end if\n         end if\n         if( istat == 0 )then\n            allocate(work(2*n), rwork(2*n), stat=istat )\n         end if\n         if( istat == 0 )then\n!           .. call lapack77 routine\n            call gesvx_f77( lfact, ltrans, n, nrhs, a, ld, laf, ld, lpiv, lequed, lr, lc, b, ld, &\n                            x, ld, lrcond, lferr, lberr, work, rwork, linfo )\n         else\n            linfo = -100\n         end if\n         if( .not.present(r) ) deallocate( lr, stat=istat1 )\n         if( .not.present(c) ) deallocate( lc, stat=istat1 )\n         if( .not.present(af) ) deallocate( laf, stat=istat1 )\n         if( .not.present(ipiv) ) deallocate( lpiv, stat=istat1 )\n         if( .not.present(ferr) ) deallocate( lferr, stat=istat1 )\n         if( .not.present(berr) ) deallocate( lberr, stat=istat1 )\n         if( present(rpvgrw) ) rpvgrw=rwork(1)\n         if( present(rcond) ) rcond=lrcond\n         if( present(equed) .and. .not.lsame(lfact,'f') ) equed=lequed\n         deallocate( work, rwork, stat=istat1 )\n      end if\n      call erinfo( linfo, srname, info, istat )\n      end subroutine zgesvx_f95\n"}
{"id": 1094, "subroutine": "    subroutine init_int(integr, imodel)\n      import integrator, model\n      class(integrator), intent(inout) :: integr\n      class(model), intent(in), target :: imodel\n    end subroutine init_int\n"}
{"id": 1095, "subroutine": "    subroutine step_int(integr, y,t,res)\n      import integrator\n      class(integrator), intent(inout) :: integr\n      real(kind=8), dimension(0:integr%ndim), intent(in) :: y\n      real(kind=8), intent(inout) :: t\n      real(kind=8), dimension(0:integr%ndim), intent(out) :: res\n    end subroutine step_int\n"}
{"id": 1096, "subroutine": "    subroutine clean_int(integr)\n      import integrator\n      class(integrator), intent(inout) :: integr\n    end subroutine clean_int\n"}
{"id": 1097, "subroutine": "    subroutine ll_continuity_netflowrate_cc (outcol, thiscol, npack)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% compute net flowrates for channels, conduits and special elements\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol, thiscol, npack\n        real(8), pointer :: fq(:), eqlat(:)\n        integer, pointer :: iup(:), idn(:), thisp(:)\n        !%-----------------------------------------------------------------------------\n        thisp => elemp(1:npack,thiscol)\n        fq    => facer(:,fr_flowrate)\n        eqlat => elemr(:,er_flowratelateral)\n        iup   => elemi(:,ei_mface_ul)\n        idn   => elemi(:,ei_mface_dl)\n        !%-----------------------------------------------------------------------------\n\n        elemr(thisp,outcol) = fq(iup(thisp)) - fq(idn(thisp)) + eqlat(thisp)\n\n        !print *, 'in ll_continuity_netflowrate_cc'\n        !print *, fq(iup(ietmp(3))), fq(idn(ietmp(3))), eqlat(ietmp(3))\n        !print *, elemr(ietmp(3),outcol)\n\n    end subroutine ll_continuity_netflowrate_cc\n"}
{"id": 1098, "subroutine": "    subroutine ll_continuity_netflowrate_jm (outcol, thiscol, npack)\n        !%------------------------------------------------------------------\n        !% description:\n        !% compute net flowrates for junction mains\n        !%------------------------------------------------------------------\n        !% declarations:\n            integer, intent(in) :: outcol, thiscol, npack\n            real(8), pointer :: branchq(:), eqlat(:), fq(:)\n            integer, pointer :: thisp(:), isbranch(:), fup(:), fdn(:)\n            integer :: ii, jj\n        !%------------------------------------------------------------------\n        !% aliases\n            thisp    => elemp(1:npack,thiscol)\n            branchq  => elemr(:,er_flowrate)\n            eqlat    => elemr(:,er_flowratelateral)\n            isbranch => elemsi(:,esi_junctionbranch_exists)\n            fq       => facer(:,fr_flowrate)\n            fup      => elemi(:,ei_mface_ul)\n            fdn      => elemi(:,ei_mface_dl)\n        !%------------------------------------------------------------------\n        !% note that 1, 3 and 5 are nominal upstream branches and 2, 4, 6 are nominal\n        !% downstream branches\n        elemr(thisp,outcol) = eqlat(thisp)\n\n        ! print *, 'in ll_continuity_netflowrate_jm'\n        ! print *, elemr(iet(1),outcol)\n        ! do ii=1,max_branch_per_node,2\n        !     print *, fq(fup(iet(1)+ii)), real(isbranch(iet(1)+ii  ),8)\n        !     print *, fq(fdn(iet(1)+ii+1)), real(isbranch(iet(1)+ii+1),8)\n        ! end do\n\n        !% approach using branch q\n        ! do ii = 1,max_branch_per_node,2\n        !     elemr(thisp,outcol) = elemr(thisp,outcol)                 &\n        !         + real(isbranch(thisp+ii  ),8) * branchq(thisp+ii  )  &\n        !         - real(isbranch(thisp+ii+1),8) * branchq(thisp+ii+1)\n        ! end do\n\n        !% approach using face q up/dn of branch (mass conservative)\n        do ii = 1,max_branch_per_node,2\n            elemr(thisp,outcol) = elemr(thisp,outcol) &\n                + real(isbranch(thisp+ii  ),8) * fq(fup(thisp+ii)) &\n                - real(isbranch(thisp+ii+1),8) * fq(fdn(thisp+ii+1))\n        end do\n\n        ! if (this_image() == 2) then\n        !     do ii=1,max_branch_per_node,2\n        !         print *, fq(fup(5428+ii)),   real(isbranch(5428+ii  ),8)\n        !         print *, fq(fdn(5428+ii+1)), real(isbranch(5428+ii+1),8)\n        !     end do\n        ! end if\n\n        !%-----------------------------------------------------------------\n    end subroutine ll_continuity_netflowrate_jm\n"}
{"id": 1099, "subroutine": "    subroutine ll_continuity_volume_ccjm_etm (outcol, thiscol, npack, istep)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% solve for volume from continuity in etm step\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol, thiscol, npack, istep\n        integer, pointer :: thisp(:)\n        real(8), pointer :: csource(:), volumen0(:)\n        real(8), pointer :: crk(:), dt\n        !%-----------------------------------------------------------------------------\n        thisp    => elemp(1:npack,thiscol)\n        volumen0 => elemr(:,er_volume_n0)\n        csource  => elemr(:,er_sourcecontinuity)\n        crk      => setting%solver%crk2\n        dt       => setting%time%hydraulics%dt\n        !%-----------------------------------------------------------------------------\n\n        elemr(thisp,outcol) = volumen0(thisp) + crk(istep) * dt * csource(thisp)\n\n        !% reset the source\n        csource(thisp) = zeror\n\n        ! if (this_image() == 2) then\n        !     write(*,\"(a,4f12.4)\") ' in ll source ', crk(istep) * dt * csource(5428)\n        ! end if\n\n       !print *, 'in ll_continuity_volume'\n       !print *, volumen0(1), crk(istep)* dt * csource(1), elemr(1,outcol)\n\n    end subroutine ll_continuity_volume_ccjm_etm\n"}
{"id": 1100, "subroutine": "    subroutine ll_continuity_volume_ccjm_ac_open (outcol,  thiscol, npack, istep)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% solves continuity for volume in ac method with open channel flow\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol,  thiscol, npack, istep\n        integer, pointer :: thisp(:)\n        real(8), pointer :: csource(:), volumem(:), cgamma(:)\n        real(8), pointer :: crk, dtau\n        !%-----------------------------------------------------------------------------\n        thisp   => elemp(1:npack,thiscol)\n        volumem => elemr(:,er_volumelastac) !% last complete ac solve\n        csource => elemr(:,er_sourcecontinuity)\n        cgamma  => elemr(:,er_gammac)\n        crk     => setting%solver%crk2(istep)\n        dtau    => setting%acmethod%dtau\n        !%-----------------------------------------------------------------------------\n\n        elemr(thisp,outcol) = &\n              ( volumem(thisp) + crk * dtau * csource(thisp) ) &\n              / (oner + crk * dtau * cgamma(thisp) )\n\n        !% reset the source\n        csource(thisp) = zeror      \n\n    end subroutine ll_continuity_volume_ccjm_ac_open\n"}
{"id": 1101, "subroutine": "    subroutine ll_continuity_head_ccjm_ac_surcharged (outcol, thiscol, npack, istep)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% solves continuity for head in ac method with surcharged flow\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol,  thiscol, npack, istep\n        integer, pointer :: thisp(:)\n        real(8), pointer :: csource(:),  cgamma(:), eheadm(:)\n        real(8), pointer :: crk, dtau\n        !%-----------------------------------------------------------------------------\n        thisp   => elemp(1:npack,thiscol)\n        eheadm  => elemr(:,er_headlastac)\n        csource => elemr(:,er_sourcecontinuity)\n        cgamma  => elemr(:, er_gammac)\n        crk     => setting%solver%crk2(istep)\n        dtau    => setting%acmethod%dtau\n        !%-----------------------------------------------------------------------------\n\n        elemr(thisp ,outcol) = &\n              ( eheadm(thisp) + crk * dtau * csource(thisp ) ) &\n              / (oner + crk * dtau * cgamma(thisp ) )\n\n        !% reset the source\n        csource(thisp) = zeror      \n\n    end subroutine ll_continuity_head_ccjm_ac_surcharged\n"}
{"id": 1102, "subroutine": "    subroutine ll_continuity_add_source_ccjm_ac_open (outcol, thiscol, npack)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !%\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol,  thiscol, npack\n        !%-----------------------------------------------------------------------------\n        !%\n\n        !% hack -- needs revision for packing\n\n        !     (inoutcol, thismaskcol)\n\n        ! integer, intent(in) :: inoutcol, thismaskcol\n\n        ! real(8), pointer :: ell(:), area(:), dhda(:), head(:)\n        ! real(8), pointer :: qnet(:), volumen0(:), volumen1(:)\n        ! real(8), pointer :: fr, a2, a3,\n        ! !%-------------------------------------------------\n        ! a2 => setting%acmethod%implicitcoef%a2\n        ! a3 => setting%acmethod%implicitcoef%a3\n        ! fr => setting%acmethod%froude\n\n        ! qnet => elemr(:,inoutcol) !% used and updated\n\n        ! ell => elemr(:,er_ell)\n        ! area => elemr(:,er_area)\n        ! dhda => elemr(:,er_dhda)\n        ! head => elemr(:,er_head)\n\n        ! volumen0 => elemr(:,volume_n0)\n        ! volumen1 => elemr(:,volume_n1)\n\n        ! where elemm(:,thismaskcol)\n        !     elemr(:,inoutcol) =  &\n        !         ell(:) *( fr**twor) / (area(:) * dhda(:) + head(:))\n        !         (qnet(:) - (a2/dt) * volumen0(:) - (a3/dt) * volumen1(:))\n        ! endwhere\n\n        print *, \"inside ll_continuity_add_source_ccjm_ac_open stub\"\n        stop 9366\n\n    end subroutine ll_continuity_add_source_ccjm_ac_open\n"}
{"id": 1103, "subroutine": "    subroutine ll_continuity_add_source_ccjm_ac_surcharged (outcol, thiscol, npack)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% performs a single hydrology step\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol,  thiscol, npack\n        !%-----------------------------------------------------------------------------\n        !%\n                !% hack needs to be rewritten for packing\n\n        !     (inoutcol, thismaskcol)\n\n        ! integer, intent(in) :: inoutcol, thismaskcol\n\n        ! real(8), pointer :: ell(:), area(:), qnet(:)\n        ! real(8), pointer :: fr\n        ! !%-------------------------------------------------\n        ! fr => setting%acmethod%froude\n\n        ! qnet => elemr(:,inoutcol) !% used and updated\n\n        ! ell => elemr(:,er_ell)\n        ! area => elemr(:,er_area)\n\n        ! where elemm(:,thismaskcol)\n        !     elemr(:,inoutcol) =  &\n        !         (ell(:) * (fr**twor) / area(:)) * qnet(:)\n        ! endwhere\n\n        print *, \"inside ll_continuity_add_source_ccmjm_ac_surcharged stub\"\n        stop 84792\n\n    end subroutine ll_continuity_add_source_ccjm_ac_surcharged\n"}
{"id": 1104, "subroutine": "    subroutine ll_continuity_add_gamma_ccjm_ac_open (outcol, thiscol, npack)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !%\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol,  thiscol, npack\n        !%-----------------------------------------------------------------------------\n        !%\n\n        !     (er_outcol, thismaskcol)\n\n        ! !% provides the gamma factor for continuity for the open-channel ac solution\n\n        ! integer, intent(in) :: outcol, thismaskcol\n\n        ! real(8), pointer :: ell(:), area(:), dhda(:), head(:)\n        ! real(8), pointer :: fr, a1\n        ! !%-------------------------------------------------\n        ! a1 => setting%acmethod%implicitcoef%a1\n        ! fr => setting%acmethod%froude\n\n        ! ell => elemr(:,er_ell)\n        ! area => elemr(:,er_area)\n        ! dhda => elemr(:,er_dhda)\n        ! head => elemr(:,er_head)\n\n        ! where elemm(:,thismaskcol)\n        !     elemr(:,outcol) = &\n        !         ell(:) * (fr**twor) * a1  &\n        !         / ( dt * ( area(:) * dhda(:) + head(:) ) )\n        ! endwhere\n\n        print *, \"inside ll_continuity_add_gamma_ccjm_ac_open stub\"\n        stop 29870\n\n    end subroutine ll_continuity_add_gamma_ccjm_ac_open\n"}
{"id": 1105, "subroutine": "    subroutine ll_momentum_ksource_cc (outcol, thiscol, npack)\n        !%-----------------------------------------------------------------------------\n        !% description:\n        !% momentum k source terms for different methods for etm\n        !% this is the k term common to ac and etm momentum advance for\n        !% different t00, t10, t20 methods\n        !%-----------------------------------------------------------------------------\n        integer, intent(in) :: outcol, thiscol, npack\n        real(8), pointer :: fadn(:), faup(:), fhdn(:), fhup(:), ehead(:), grav\n        integer, pointer :: iup(:), idn(:), thisp(:)\n        !%-----------------------------------------------------------------------------\n        thisp  => elemp(1:npack,thiscol)\n        fadn   => facer(:,fr_area_d)\n        faup   => facer(:,fr_area_u)\n        fhdn   => facer(:,fr_head_d)\n        fhup   => facer(:,fr_head_u)\n        ehead  => elemr(:,er_head)\n        iup    => elemi(:,ei_mface_ul)\n        idn    => elemi(:,ei_mface_dl)\n        grav => setting%constant%gravity\n        !%-----------------------------------------------------------------------------\n\n        select case (setting%solver%momentumsourcemethod)\n        case (t00)\n            elemr(thisp,outcol) = grav * ( &\n                ( faup(idn(thisp)) - fadn(iup(thisp)) ) * ehead(thisp) )\n\n                ! print *, 'faup : ', faup(idn(thisp(1:2)))\n                ! print *, 'fadn : ', fadn(iup(thisp(1:2)))\n                ! print *, 'head : ', ehead(thisp(1:2))\n\n        case (t10)\n            elemr(thisp,outcol) = grav * onehalfr *  ( &\n                +faup(idn(thisp)) * fhdn(iup(thisp))   &\n                -fadn(iup(thisp)) * fhup(idn(thisp)) )\n        case (t20)\n            elemr(thisp,outcol) = grav * onesixthr *  (                       &\n                +faup(idn(thisp)) * ( fhdn(iup(thisp)) + fourr * ehead(thisp) )   &\n                -fadn(iup(thisp)) * ( fhup(idn(thisp)) + fourr * ehead(thisp) ) )\n        case default\n            print *, 'code error setting.solver.momentumsourcemethod type unknown for # ', setting%solver%momentumsourcemethod\n            print *, 'which has key ',trim(reversekey(setting%solver%momentumsourcemethod))\n            stop 2382\n        end select\n\n        !print *, ' ksource ',elemr(780,outcol)\n        !print *, 'in ll_momentum_ksource_cc'\n        !print *, elemr(1,outcol), faup(idn(1))* ehead(1) * grav, fadn(iup(1)) * ehead(1) * grav\n\n    end subroutine ll_momentum_ksource_cc\n"}
{"id": 1106, "subroutine": "subroutine raylist_brute(ipart,iptmass,n,tmax)\n!********************************************\n! given a particle, ray vector and maximum distance\n\n! by ray \n\n!*******************************************\n\nuse sphdata\nuse treedata\n\nimplicit none\n\ninteger, intent(in) :: ipart,iptmass\nreal,intent(in) :: tmax\nreal,dimension(3),intent(in) :: n\n\ninteger :: jpart,k\nreal :: t_try\n\nnray = 0\nt_sphere(:) = 0.0\n\ndo jpart=1,npart\n\n   if(jpart==ipart .or.jpart==listpm(iptmass)) cycle ! ignore self and sink\n   \n   if(iphase(jpart)/=0) cycle\n ! calculate t_min\n\n        t_try = 0.0\n\n        do k=1,3\n           t_try = t_try + n(k)*(xyzmh(k,jpart)-xyzmh(k,ipart))\n        enddo\n\n        ! t must be less than tmax, otherwise goes past sink\n        if(t_try>tmax) cycle\n\n        ! calculate b - impact parameter with ray\n\n        b(jpart) = 0.0\n\n        do k=1,3\n           b(jpart) = b(jpart) + &\n                (xyzmh(k,ipart) + t_try*n(k) - xyzmh(k,jpart))**2\n        enddo\n\n        b(jpart) = sqrt(b(jpart))\n\n        t_sphere(jpart) = 2.0d0*sqrt(4.0d0*xyzmh(5,jpart)**2 - b(jpart)*b(jpart))\n\n        ! if t -ve and sufficiently distant, jpart is behind ray \n        ! should not be counted\n        if(t_try<0.0d0 .and. abs(t_try)>0.5*t_sphere(jpart)) cycle\n\n        ! if b < 2*h_i, then add to list\n\n        if(b(jpart) < 2.0*xyzmh(5,jpart)) then\n\n           ! add particle to raylist\n           nray = nray +1\n           ray(nray) = jpart\n           t_min(nray) = t_try\n        endif\n\n     enddo\n    ! end of loop over jpart\n\nend subroutine raylist_brute\n"}
{"id": 1107, "subroutine": "      subroutine setupdirectories\n      use glovars, only : borrardirectorio, rutaout,printnum,saveg\n      character(10) :: time\n      character(len=400) :: path\n      character(len=32) :: arg\n      integer :: status\n      ! preparar los directorios de trabajo y de resultados\n      call getcwd(path)\n      write(6,'(a,/,a)') 'at:',trim(path)\n      write(path,'(a,a)') trim(path),\"/workdir\"\n      call chdir(trim(path))\n      call getcwd(path)\n      write(6,'(a,/,a)') 'workdirectory:',trim(path)\n      call getmaininput\n      call get_command_argument(1, arg)\n      if ((trim(arg) .ne. '-r') .and. (trim(arg) .ne. '-f')) borrardirectorio = .true.\n      if (borrardirectorio .eqv. .false.) then\n      call date_and_time(time=time); write(printnum,'(a,a)') \"hhmmss.sss = \",time\n      write(rutaout,'(a,a)') \"mkdir outs_\",time\n      call system(trim(adjustl(rutaout)))\n      call chdir(trim(adjustl(rutaout)),status)\n      write(rutaout,'(a,a)') \"outs_\",time\n      else \n      call get_command_argument(1, arg)\n      if (len_trim(arg) .ne. 0) then\n        if (trim(arg) .eq. '-l') then\n        saveg = .false.\n        go to 296\n        end if\n      end if\n      call system('rm -rf outs')\n      call system('mkdir outs')\n 296  call chdir(\"outs\",status)\n      write(rutaout,'(a)') \"outs\"\n      end if!\n      if (status .eq. 0) call chdir(\"..\") !workdir\n      write(path,'(a,a,a)') 'rm -rf ',trim(adjustl(rutaout)),'/insbackup'\n      call system(trim(adjustl(path)))\n      write(path,'(a,a,a)') 'cp -r ins ',trim(adjustl(rutaout)),'/insbackup'\n      call system(trim(adjustl(path)))\n      call chdir(trim(adjustl(rutaout)),status) !outs\n      if (status .eq. 0) call system(\"rm *.*\")\n      if (printnum /= 6) open(printnum,file= \"logfile.txt\")\n      call date_and_time(time=time); write(printnum,'(a,a)') \"hhmmss.sss = \",time\n      call system('mkdir subdivs')\n      call system('cp ../../dwnlibem.f90 dwnlibem.f90')\n      call chdir(\"..\")\n      write(printnum,'(///)')\n      end subroutine setupdirectories\n"}
{"id": 1108, "subroutine": "      subroutine getmaininput\n      use glovars\n      use geometryvars , only : staywiththefinersubdivision,finersubdivisionj,&\n       longitudcaracteristica_a, fracciondesmallestwl_segm_de_esquina\n      use resultvars, only : overdeterminedsystem,od_jini,od_jend\n      use wavenumvars, only : splik\n      implicit none\n      logical :: lexist\n      call chdir(\"ins\")\n      inquire(file=\"maininput.txt\",exist=lexist)\n      if (lexist) then\n        open(35,file=\"maininput.txt\",form=\"formatted\")\n      else\n        write(6,'(a)') 'there is a missing input file. '\n        stop 'check \"maininput.txt\" on working directory'\n      end if\n      read(35,'(i1)') verbose!; print*,\"verbose =\",verbose\n      read(35,'(l1)') makevideo!; print*,\"make a video =\",makevideo\n      read(35,'(l1)') vivachurubusco\n      read(35,'(l1)') vivacine\n      read(35,'(l1)') workboundary!; print*,\"boundary? \",workboundary\n      read(35,'(l1)') flip12; if(.not. workboundary) flip12 = .false.\n      read(35,'(l1)') plotfks!; print*,\"plotfk?\",plotfks\n      read(35,'(l1)') plotfkck\n      read(35,'(l1)') printetas\n      read(35,'(l1)') plotfilledsabanas\n      read(35,'(l1)') saveg!; print*,\"save green funcs?\", saveg\n      read(35,*) multsubdiv!; print*,\"division multiple = \", multsubdiv\n      read(35,*) staywiththefinersubdivision, finersubdivisionj\n      read(35,*) overdeterminedsystem,od_jini,od_jend\n      read(35,*) ckbeta!; print*,\"multbminintegrando = \", ckbeta\n      read(35,*) splik\n      read(35,*) periodicdamper!; print*,\"periodic sources damping factor = \", periodicdamper\n      read(35,*) useazimi\n      read(35,*) developerfeature\n      read(35,*) borrardirectorio\n      read(35,*) printnum\n      read(35,*) longitudcaracteristica_a\n      read(35,*) fracciondesmallestwl_segm_de_esquina\n      read(35,*) pwfrecreal\n      read(35,*) comofacdeamplidinamica\n      close(35)\n      call chdir(\"..\")\n      end subroutine getmaininput\n"}
{"id": 1109, "subroutine": "      subroutine getsoilprops\n      use soilvars; use wavenumvars; use wavevars, only : dt; use fitting\n      use glovars, only : verbose,pi, ckbeta,outpf => printnum,periodicdamper\n      implicit none\n      logical :: lexist\n      real :: h, alf, bet, ro\n      real*8 :: maxbeta,bealf, k1_3,kmax,frac!,m\n      integer :: j,i\n\n      call chdir(\"ins\")\n      inquire(file=\"hvdepth.txt\",exist=lexist)\n      if (lexist) then\n        open(7,file=\"hvdepth.txt\",form=\"formatted\")\n      else\n        write(6,'(a)') 'there is a missing input file. '\n        stop 'check \"hvdepth.txt\" on working directory'\n      end if\n\n      read(7,*)\n      read(7,'(i2)')n   !number of layers not counting upper/lower half-space\n      read(7,*)\n      write(outpf,'(/,a,i2,a,/)') '  ',n,' layers'\n      allocate (z(0:n+1));allocate (rho(0:n+2)); allocate(anu(0:n+2))\n      allocate (beta0  (0:n+2)); allocate (alfa0(0:n+2))\n      allocate (beta   (0:n+2)); allocate (alfa (0:n+2))\n      allocate (lambda0(0:n+2)); allocate (amu0 (0:n+2))\n      allocate (lambda (0:n+2)); allocate (amu  (0:n+2))\n      allocate (layershadecolor(0:n+2))\n\n      z(0)=real(1000,8);      z(1)=real(0,8)\n      if (verbose >= 1) write(outpf,'(a)')&\n      '        depth       alpha0    beta0      mu0     rho      lambda0       nu0'\n      do j=1,n\n         read(7,*) h, alf, bet, ro\n        if (h .lt. 0.0) then\n          z(0) = real(h)\n          amu0(0)=ro*bet**2.0\n          beta0(0)=bet\n          alfa0(0)=alf\n          rho(0) = ro\n          lambda0(0)=rho(0)*alf**2.0 - real(2.)*real(amu0(0))\n          bealf = beta0(0)/alfa0(0)\n          anu(0) = (bealf**2 - 0.5)/(-1 + bealf**2)!#< b\n         write(outpf,'(a,f7.1,2x, f7.1,2x, f7.1,2x, e8.2,2x, e8.2,2x, e8.2,2x, e8.2)') &\n       ' -inf.  - ',z(1),alfa0(0),beta0(0),real(amu0(0)),  rho(0), real(lambda0(0)),real(anu(j))!#>\n          read(7,*) h, alf, bet, ro\n        end if\n         z(j+1)=z(j)+real(h)\n         amu0(j)=ro*bet**2.0\n         beta0(j)=bet\n         alfa0(j)=alf\n         rho(j) = ro\n         lambda0(j)=rho(j)*alf**2.0 - real(2.)*real(amu0(j))\n!        bealf=sqrt((0.5-anu)/(1.0-anu)) !if poisson ratio is given\n         bealf = beta0(j)/alfa0(j)\n         anu(j) = (bealf**2 - 0.5)/(-1 + bealf**2)\n!        alfa(j)=bet/bealf !#< b\n          write(outpf,&\n          '(f7.1,a,f7.1,2x, f7.1,2x, f7.1,2x, e8.2,2x, e8.2,2x, e8.2,2x, e8.2)') &\n          z(j),' - ',z(j+1),alfa0(j),beta0(j),real(amu0(j)),&\n          rho(j), real(lambda0(j)),real(anu(j)) !#>\n      end do\n\n      read(7,*) h, alf, bet, ro\n      if (h .lt. 0.0) then !(caso: semiespacio arriba, semiespacio abajo)\n         z(0) = real(h)\n         amu0(0)=ro*bet**2.0\n         beta0(0)=bet\n         alfa0(0)=alf\n         rho(0) = ro\n         lambda0(0)=rho(0)*alf**2.0 - real(2.)*real(amu0(0))\n         bealf = beta0(0)/alfa0(0)\n         anu(0) = (bealf**2 - 0.5)/(-1 + bealf**2)!#< b\n         write(outpf,'(a,f7.1,2x, f7.1,2x, f7.1,2x, e8.2,2x, e8.2,2x, e8.2,2x, e8.2)') &\n         ' -inf.  - ',z(1),alfa0(0),beta0(0),real(amu0(0)),&\n         rho(0), real(lambda0(0)),real(anu(0)) !#>\n         read(7,*) h, alf, bet, ro\n      end if\n      amu0(n+1)=ro*bet**2\n      beta0(n+1)=bet\n      alfa0(n+1)=alf\n      rho(n+1) = ro\n      lambda0(n+1)=rho(n+1)*alf**2 - real(2.)*real(amu0(n+1))\n      bealf = beta0(n+1)/alfa0(n+1)\n      anu(n+1) = (bealf**2 - 0.5)/(-1 + bealf**2) !#< b\n         write(outpf,'(f7.1,2x,a, f7.1,2x, f7.1,2x, e8.2,2x, e8.2,2x, e8.2,2x, e8.2)') &\n         z(1),' -  inf. ',alfa0(n+1),beta0(n+1),real(amu0(n+1)),&\n         rho(n+1), real(lambda0(n+1)),real(anu(n+1)) !#>\n      i = 1;  if (z(0) .lt. 0.0) i = 0\n      minbeta = minval(beta0(i:n+1));  maxbeta = maxval(beta0(i:n+1))\n      if (abs(minbeta - maxbeta) .lt. 0.01) then\n       layershadecolor(i:n+1) = 0.8_4\n      else\n       do j=i,n+1\n        layershadecolor(j)= real(0.6-(maxbeta-beta0(j))*((0.6-0.89)/(maxbeta-minbeta)),4)\n!       print*,i,layershadecolor(j)\n       end do\n      end if\n      read(7,*)\n      read(7,*)dfrec,nfrec,nptstime,nk,qq,tw\n      close(7)\n      call chdir(\"..\")\n\n      !#< r ---- calculamos nfrec resultados y hacemos zeropadding hasta npstime--- !#>\n         nptstime = int(log10(real(nptstime)) / log10(2.)+0.99 )\n         nptstime = 2** nptstime     !adjuste to a 2**n value\n         if (nptstime .lt. 2*nfrec) then\n           nptstime=2*nfrec\n           print*,\"warning, modified nptstime to\" , nptstime\n         end if\n      dt = (1.0) / (real(nptstime) * dfrec)\n\n      !#< r ----  dk para ver estar ckbeta veces por arriba de polo rayleigh------- !#>\n      frac = 1./3.\n      kmax = 0.9* (2*pi*dfrec*nfrec) / minbeta * ckbeta !1.5\n      dk = kmax / nk\n      k1_3 = (2*pi*dfrec*nfrec * frac) / minbeta * ckbeta\n\n      allocate(vecnk(nfrec+1))\n      ! cantidad de numeros de onda {donde se invierte la matriz} en cada frecuencia\n      ! el resto hasta nmax+1(o hasta splik) se interpola\n      vecnk = (/(i,i=1, nfrec+1)/)\n      call splinein(vecnk, & ! vector x [int]\n                    vecnk, & ! vector interpolado [int]\n                    int(nfrec * frac),& ! n puntos [x0 ... x1-1]\n                    nfrec+1-int(nfrec * frac), & ! [x1 ...  x2 ]\n                    1,                  int(0.55*nk), &  !x0,y0\n                    int(nfrec * frac)+1,int(0.6*nk), &  !x1,y1\n                    nfrec+1,            nk) !x2,y2\n      nmax = vecnk(nfrec)!     if (vecnk(nfrec) .gt. nmax)\n      nmax = int(log10(real(nmax)) / log10(2.)+0.99 )\n      nmax = 2**nmax     !adjuste to a 2**n value\n\n      ! complex frecuency to \"smooth\" the poles and be able to integrate\n        ! bouchon (2003) omei entre -pi/t y -2pi/t ; t= 2pi/dfrec tiempo total\n        ! tengo tw la ventana de tiempo de inter\u00e9s.\n      omei = - periodicdamper*pi/tw ! se cumple que exp(omei tw) << 1\n\n      if (verbose .ge. 1) then !#< b\n       write(outpf,'(a)') &\n       \"--- frecuency --------------------------------------------------------------------\"\n       write(outpf,'(a,f9.7,/,a,f15.5)') \"   dt = (1.0) / (real(nptstime) * dfrec) = \",dt,\"   tmax=\",dt* nptstime\n       write(outpf,'(a,f8.1)') '   atenuation q = ',qq\n       write(outpf,'(a,i0,a,f8.4,a,f12.4,a,/)') &\n           '   n. frequencies: ',nfrec,'  @',dfrec,'hertz :. fmax = ', &\n           nfrec*dfrec,'hertz'\n\n       write(outpf,'(a)') &\n       \"--- dwn -------------------------------------------------------------------------\"\n       write(outpf,'(a,f15.7)') \"   kmax = 0.9* (2*pi*dfrec*nfrec) / minbeta * ckbeta = \",kmax\n       write(outpf,'(a,f9.7)') \"   dk = kmax / nk = \",dk\n       write(outpf,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,i0,a)') \"   nk a 3pt spline with (\",&\n          1,\",\",int(0.55*nk),\"), (\",&\n          int(nfrec * frac)+1,\",\",int(0.6*nk),\"), (\",&\n          nfrec+1,\",\",nk,\")\"\n       write(outpf,'(a,i0)') '   nk average = ',int(sum(vecnk)/(nfrec+1))\n       write(outpf,'(a,i0)') '   nmax (each sign): ',nmax\n       write(outpf,'(a,f12.7)') \"   delta x = \", real(pi / (nmax * dk),4)\n       write(outpf,'(a,en14.2e2,a)') \"   l = 2*pi/dk = \",2*pi/dk, \"m\"\n       write(outpf,'(a,en19.5e2,a)') &\n       \"   l/mxaalfa = \",(2*pi/dk)/maxval(abs(alfa0(1:n+1))), \"seconds\"\n       write(outpf,'(a,en19.5e2,a)') &\n       \"   l/maxbeta = \",(2*pi/dk)/maxval(abs(beta0(1:n+1))), \"seconds\"\n       write(outpf,'(a,en19.5e2,a)') &\n       \"   l/minalfa = \",(2*pi/dk)/minval(abs(alfa0(1:n+1))), \"seconds\"\n       write(outpf,'(a,en19.5e2,a)') &\n       \"   l/minbeta = \",(2*pi/dk)/minval(abs(beta0(1:n+1))), \"seconds\"\n       write(outpf,'(a,e10.2,a)') '   frec. imaginary part: - periodicdamper*pi/tw = ',omei,' rad/s'\n       write(outpf,'(a)') &\n       \"---------------------------------------------------------------------------------\"\n      end if !#>\n      end subroutine getsoilprops\n"}
{"id": 1110, "subroutine": "      subroutine checarwisdom(a,b,c)\n      use wavenumvars, only : plannmaxf,plannmaxb,&\n                             plannfrecf,plannfrecb,&\n                             planntimef,planntimeb\n      use, intrinsic :: iso_c_binding\n      use glovars, only : printnum\n      include 'fftw3.f03'\n      type(c_ptr) :: plan\n      integer(c_int) :: j,a,b,c,flag\n      complex*16, dimension(a) :: ua,va !frec\n      complex*16, dimension(b) :: ub,vb !nmax\n      complex*16, dimension(c) :: uc,vc !npstime\n      character(len=100) :: tx\n      logical :: lexist\n      write(tx,'(a,i0,a,i0,a,i0,a)') \"wis\",a,\"-\",b,\"-\",c,\".dat\"\n      inquire(file=trim(tx),exist=lexist)\n      if (lexist .eqv. .false.) then\n      flag = fftw_patient ! fftw_measure\n      plan = fftw_plan_dft_1d(a, ua,va, fftw_forward,flag)\n      plan = fftw_plan_dft_1d(a, ua,va, fftw_backward,flag)\n      plan = fftw_plan_dft_1d(b, ub,vb, fftw_forward, flag)\n      plan = fftw_plan_dft_1d(b, ub,vb, fftw_backward, flag)\n      plan = fftw_plan_dft_1d(c, uc,vc, fftw_forward, flag)\n      plan = fftw_plan_dft_1d(c, uc,vc, fftw_backward, flag)\n      j = fftw_export_wisdom_to_filename(trim(tx) // c_null_char)\n      call fftw_destroy_plan(plan)\n      if (j .eq. 0) then\n      print*,\"i=\",j,\" (non-zero on success)\"\n      stop \"error al exportar wisdom en :checarwisdom\"\n      else\n      print*, \"plans created, at\"\n      print*,trim(tx)\n      stop \"re run program\"\n      end if\n      print*,\"se export\u00f3 wisdom \",trim(tx)\n      else\n      !importar\n      j = fftw_import_wisdom_from_filename(trim(tx) // c_null_char)\n      if (j .eq. 0) then\n      print*,\"i=\",j,\" (non-zero on success)\"\n      stop \"error al importar wisdom en :fftw\"\n      else\n      write(printnum,*)\"  \"\n      write(printnum,*)\"  le\u00eddo wisdom \",trim(tx)\n      ! crear planos\n      flag = fftw_wisdom_only\n      plannfrecf = fftw_plan_dft_1d(a, ua,va, fftw_forward,flag)\n      plannfrecb = fftw_plan_dft_1d(a, ua,va, fftw_backward,flag)\n      plannmaxf = fftw_plan_dft_1d(b, ub,vb, fftw_forward, flag)\n      plannmaxb = fftw_plan_dft_1d(b, ub,vb, fftw_backward, flag)\n      planntimef = fftw_plan_dft_1d(c, uc,vc, fftw_forward, flag)\n      planntimeb = fftw_plan_dft_1d(c, uc,vc, fftw_backward, flag)\n      write(printnum,*)\"  planos creados\"\n      end if\n      end if\n      end subroutine checarwisdom\n"}
{"id": 1111, "subroutine": "      subroutine vaciarwisdom\n      use wavenumvars, only : plannmaxf,plannmaxb,&\n                             plannfrecf,plannfrecb,&\n                             planntimef,planntimeb\n      use, intrinsic :: iso_c_binding\n      include 'fftw3.f03'\n      call fftw_destroy_plan(plannfrecf)\n      call fftw_destroy_plan(plannfrecb)\n      call fftw_destroy_plan(plannmaxf)\n      call fftw_destroy_plan(plannmaxb)\n      call fftw_destroy_plan(planntimef)\n      call fftw_destroy_plan(planntimeb)\n      !call fftwf_forget_wisdom()\n      !call fftwf_cleanup()\n      end subroutine vaciarwisdom\n"}
{"id": 1112, "subroutine": "      subroutine getinquirepoints\n      use resultvars, only : punto,nptsolos,inqpoints, nipts, iptini,iptfin, &\n                       nsabanapts, nsecciones, sabana,sabzeroini,sabzerofin,&\n                       sabanaplotindividual, sabanabajarafrontera, &\n                       n_od,overdeterminedsystem,punenlafront,punto2d,promp2d,negp2d, &\n                       nbpt_topo,nbpt_cont,nbpt_vall\n      use wavenumvars, only : nptstime\n      use geometryvars, only: nxi,origgeom,n_topo,n_cont,n_vall,spacebarvall\n      use glovars, only : flip12\n      implicit none\n      interface\n        function tellisoninterface(zi)\n        real*8 :: zi\n        end function tellisoninterface\n      end interface\n\n      integer :: thelayeris\n      integer :: i,j,k,iindex, nnsabanas,nnsecciones,nboup,thisnsab\n      logical :: lexist, tellisoninterface, ths_isoninterface,wtfk\n      integer :: auxguardarfk, ths_layer, sabanabajarmax\n      real :: xini,deltax,zini,deltaz,dx,dz, sbanadeltaz\n      real*8 :: escalax,escalay,escaladx,escalady,offsetx,offsety,r,nx,nz\n      logical :: cn,adentrooafuera,tellpunenlafront\n      integer, dimension(0:2) :: reg\n      type (punto), dimension(:), allocatable :: auxinq\n      call chdir(\"ins\")\n      ! read file\n      inquire(file=\"interestingpoints.txt\", exist=lexist)\n      if(lexist)then\n        open(7,file=\"interestingpoints.txt\",form=\"formatted\")\n      else\n        write(6,'(a,a)') 'there is a missing input file. ',&\n        'check \"interestingpoints.txt\" on working directory'\n        stop 1\n      end if\n      read(7,*) !points of interest for an accelerogram\n      read(7,*) nipts\n      nptsolos = nipts\n      read(7,*) nnsabanas, nsabanapts, sabanaplotindividual, sbanadeltaz, sabanabajarmax\n      read(7,*) nnsecciones, nsecciones\n      read(7,*) tellpunenlafront, spacebarvall\n      punenlafront=tellpunenlafront\n      if (punenlafront) then; nboup = nxi\n      else; nboup = 0\n      end if\n      read(7,*) !__________________________________________\n      read(7,*) escalax,escalay\n      read(7,*) offsetx,offsety\n      iptini = 1\n      if (nnsabanas .eq. 0) nsabanapts=0\n      if (nnsecciones .eq. 0) nsecciones=0\n      iptfin = nipts + nsabanapts + nsecciones + nboup\n      allocate(inqpoints(nipts + nsabanapts + nsecciones + nboup))\n      inqpoints(:)%normal%x = 0\n      inqpoints(:)%normal%z = 0\n      inqpoints(:)%isoninterface = .false.\n      inqpoints(:)%isboundary = .false.\n      inqpoints(:)%guardarfk = .false.\n      inqpoints(:)%guardarmoviesiblings = .false.\n      inqpoints(:)%issabana = .false.\n      inqpoints(:)%issourcesegmentforce= .false.\n      inqpoints(:)%isod= .false. ; n_od = 0\n      inqpoints(:)%region = 1\n      inqpoints(:)%boundaryindex = 0\n      inqpoints(:)%atbou = .false.\n      read(7,*) !  x        z          nx       nz     guardarfk   isod    tipofrontera\n      do i=1, nipts\n         read(7,*) inqpoints(i)%center%x, inqpoints(i)%center%z, &\n             inqpoints(i)%normal%x, inqpoints(i)%normal%z, auxguardarfk, &\n             inqpoints(i)%isod,inqpoints(i)%tipofrontera\n           inqpoints(i)%center%x = inqpoints(i)%center%x * escalax + offsetx\n           inqpoints(i)%center%z = inqpoints(i)%center%z * escalay + offsety\n           if (inqpoints(i)%isod) then\n           n_od = n_od +1\n           if (inqpoints(i)%tipofrontera .eq. 1) n_od = n_od +1\n           end if\n      !encontrar el layer en el que estan o 0 si est\u00e1 sobre la interfaz\n           inqpoints(i)%layer = thelayeris(real(inqpoints(i)%center%z,8))\n           if (auxguardarfk .ge. 1 ) inqpoints(i)%guardarfk = .true.\n           inqpoints(i)%isoninterface = &\n                         tellisoninterface(real(inqpoints(i)%center%z,8))\n      end do\n\n!     addod = 0\n      iindex = nipts\n      ! !#< r putnos sobre la geometr\u00eda -------------------------- !#>\n      if (punenlafront) then\n      reg(0) = 0; reg(1)= 1; reg(2) = 2\n      if (flip12) then\n        reg(0) = 0; reg(1)= 2; reg(2) = 1\n      end if\n      nbpt_topo=0;nbpt_cont=0;nbpt_vall=0\n      do i =1,nxi\n       if (tellisoninterface(real(origgeom(i)%bord_a%z,8))) then\n       if (origgeom(i)%tipofrontera .eq. 1) then\n       iptfin = iptfin -1\n       nboup = nboup -1\n       cycle\n       end if;end if\n       iindex = iindex + 1\n       inqpoints(iindex)%center = origgeom(i)%bord_a\n!      print*,\"------------------------\";print*,inqpoints(iindex)%center\n       inqpoints(iindex)%tipofrontera = origgeom(i)%tipofrontera\n       if (origgeom(i)%tipofrontera .eq. 0) then\n         inqpoints(iindex)%region = reg(1)\n       nbpt_topo = nbpt_topo+1\n       if (i .eq. 1) then                            !#< r tipofrontera 0 !#>\n       inqpoints(iindex)%normal = promp2d(origgeom(1)%normal,origgeom(n_topo)%normal)\n!      print*,origgeom(1)%normal,origgeom(n_topo)%normal,\" ->\",inqpoints(iindex)%normal\n       else\n       inqpoints(iindex)%normal = promp2d(origgeom(i)%normal,origgeom(i-1)%normal)\n!      print*,origgeom(i)%normal,origgeom(i-1)%normal,\" ->\",inqpoints(iindex)%normal\n       end if\n       else if (origgeom(i)%tipofrontera .eq. 1) then !#< r tipofrontera 1 !#>\n         inqpoints(iindex)%region = reg(1)\n       nbpt_cont=nbpt_cont+1\n       if (i .eq. n_topo+1) then\n       inqpoints(iindex)%normal = negp2d(promp2d(origgeom(n_topo+1)%normal, &\n                                                 origgeom(n_topo+n_cont)%normal))\n!      print*,origgeom(n_topo+1)%normal,origgeom(n_topo+n_cont)%normal,\" ->\", &\n!                                                      inqpoints(iindex)%normal\n       else\n       inqpoints(iindex)%normal = negp2d(promp2d(origgeom(i)%normal,origgeom(i-1)%normal))\n!      print*,origgeom(i)%normal,origgeom(i-1)%normal,\" ->\",inqpoints(iindex)%normal\n       end if\n\n       else if (origgeom(i)%tipofrontera .eq. 2) then !#< r tipofrontera 2 !#>\n         inqpoints(iindex)%region = reg(2)\n       nbpt_vall=nbpt_vall+1\n       if (i .eq. n_topo+n_cont+n_vall) then\n       inqpoints(iindex)%normal = promp2d(origgeom(n_topo+n_cont+1)%normal, &\n                                          origgeom(n_topo+n_cont+n_vall)%normal)\n!      print*,origgeom(n_topo+n_cont+1)%normal,origgeom(n_topo+n_cont+n_vall)%normal, &\n!                                                     \" ->\",inqpoints(iindex)%normal\n       else\n       inqpoints(iindex)%normal = promp2d(origgeom(i)%normal,origgeom(i+1)%normal)\n!      print*,origgeom(i)%normal,origgeom(i-1)%normal,\" ->\",inqpoints(iindex)%normal\n       end if\n       ! hacer que no esten exacto sobre la frotnera\n       inqpoints(iindex)%center%x = inqpoints(iindex)%center%x + spacebarvall * inqpoints(iindex)%normal%x\n       inqpoints(iindex)%center%z = inqpoints(iindex)%center%z + spacebarvall * inqpoints(iindex)%normal%z\n\n       !#< r sobredeterminar sistema en frontera 2 !#>\n!      if ( overdeterminedsystem ) then\n!          n_od = n_od +1\n!          inqpoints(iindex)%isod = .true.\n!      end if\n       end if\n       if (abs(inqpoints(iindex)%normal%x) .lt. 0.0001) inqpoints(iindex)%normal%x = 0\n       if (abs(inqpoints(iindex)%normal%z) .lt. 0.0001) inqpoints(iindex)%normal%z = 0\n       ! angulo para hacer la rotaci\u00f3n a coordenadas normal y tangencial\n       r = sqrt(inqpoints(iindex)%normal%z**2 + inqpoints(iindex)%normal%x**2)\n       inqpoints(iindex)%cost = inqpoints(iindex)%normal%x/r\n       inqpoints(iindex)%sint = inqpoints(iindex)%normal%z/r\n!      print*,inqpoints(iindex)%normal,inqpoints(iindex)%cost,inqpoints(iindex)%sint\n\n       inqpoints(iindex)%layer = origgeom(i)%layer\n       inqpoints(iindex)%isoninterface = .false. !tellisoninterface(real(inqpoints(iindex)%center%z,8))\n       inqpoints(iindex)%atbou = .true.\n\n      end do ! iindex\n      nipts = nipts + nboup\n      end if ! pu en la frontera\n\n      if (.not. overdeterminedsystem) n_od = 0        !#< r en caso de que no hay puntos !#>\n      if (n_od .eq. 0) then\n      overdeterminedsystem = .false. ! de coloc. adicionales\n      print*,\"found no points to overdetermine the system\"\n      end if\n      !\n      if (nnsecciones .gt. 0) then\n      read(7,*) !secciones -------------------------\n      read(7,*) escalax,escalay !; print*,escalax,escalay\n      read(7,*) escaladx,escalady !; print*,escalax,escalay\n      read(7,*) offsetx,offsety !; print*, offsetx,offsety\n      read(7,*) ! npuntos     xi        deltax      zi       deltaz       nx       nz\n      do j=1,nnsecciones\n        read(7,*) thisnsab,xini,deltax,zini,deltaz,nx,nz\n        dx = 0.0\n        dz = 0.0\n        do i = 1,thisnsab\n        iindex = iindex + 1\n        inqpoints(iindex)%isseccion = .true.\n        inqpoints(iindex)%center%x = (xini*escalax + dx) + offsetx\n        inqpoints(iindex)%center%z = (zini*escalay + dz) + offsety\n        inqpoints(iindex)%normal%x = nx\n        inqpoints(iindex)%normal%z = nz\n         if (abs(inqpoints(iindex)%normal%x) .lt. 0.0001) inqpoints(iindex)%normal%x = 0\n         if (abs(inqpoints(iindex)%normal%z) .lt. 0.0001) inqpoints(iindex)%normal%z = 0\n       ! angulo para hacer la rotaci\u00f3n a coordenadas normal y tangencial\n         r = sqrt(inqpoints(iindex)%normal%z**2 + inqpoints(iindex)%normal%x**2)\n         inqpoints(iindex)%cost = inqpoints(iindex)%normal%x/r\n         inqpoints(iindex)%sint = inqpoints(iindex)%normal%z/r\n        ths_layer = thelayeris(inqpoints(iindex)%center%z)\n        ths_isoninterface = tellisoninterface(inqpoints(iindex)%center%z)\n        inqpoints(iindex)%layer = ths_layer\n        inqpoints(iindex)%isoninterface = ths_isoninterface\n        dx = dx + deltax*escaladx\n        dz = dz + deltaz*escalady\n        end do\n      end do\n      nipts = nipts + nsecciones\n      else\n        read(7,*) !secciones -------------------------\n        read(7,*) !; print*,escalax,escalay\n        read(7,*) !; print*, offsetx,offsety\n        read(7,*) ! npuntos     xi        del\n      end if !nsecciones\n\n      !\n      if (nsabanapts .gt. 0) then\n      print*,\"ahora con los puntos de la sabana\"\n      allocate(sabana(nsabanapts, nptstime))\n      read(7,*) !sabanapoints -------------------------\n      read(7,*) escalax,escalay !; print*,escalax,escalay\n      read(7,*) offsetx,offsety\n      read(7,*) !npuntos xini   deltax   zini   delta z  guardarfk\n      do j=1,nnsabanas\n      read(7,*) thisnsab,xini,deltax,zini,deltaz,wtfk, sabanabajarafrontera\n      dx = 0.0\n      dz = 0.0\n      do i=1,thisnsab\n        iindex = iindex + 1\n        inqpoints(iindex)%issabana = .true.\n        inqpoints(iindex)%center%x = (xini + dx)*escalax + offsetx\n        inqpoints(iindex)%center%z = (zini + dz)*escalay\n\n        if (sabanabajarafrontera) then\n         do k= 1,sabanabajarmax\n           cn = adentrooafuera(real(inqpoints(iindex)%center%x,4), &\n                               real(inqpoints(iindex)%center%z,4),'void')\n           if (cn .eqv. .true.) then !esta en el aire\n             inqpoints(iindex)%center%z = inqpoints(iindex)%center%z + k* sbanadeltaz\n           else\n             exit\n           end if\n         end do\n        end if\n        inqpoints(iindex)%center%z = inqpoints(iindex)%center%z + offsety\n\n        ths_layer = thelayeris(inqpoints(iindex)%center%z)\n        ths_isoninterface = tellisoninterface(inqpoints(iindex)%center%z)\n        inqpoints(iindex)%layer = ths_layer\n        inqpoints(iindex)%isoninterface = ths_isoninterface\n        dx = dx + deltax\n        dz = dz + deltaz\n        inqpoints(iindex)%guardarfk = wtfk\n      end do ! i\n      end do ! j\n      read(7,*) !hacer zeros el rango en la sabana:\n      read(7,*) sabzeroini,sabzerofin\n      nipts = nipts + nsabanapts\n      else\n       read(7,*) ! sbana---\n       read(7,*) !escala\n       read(7,*) !offset\n       read(7,*) ! encabezados\n       read(7,*) ! hacer zeros\n       read(7,*) ! valores\n      end if !sabanas\n\n\n      close(7)\n\n      if (nipts .lt. size(inqpoints)) then\n        allocate(auxinq(nipts))\n        auxinq = inqpoints\n        deallocate(inqpoints)\n        allocate(inqpoints(nipts))\n        inqpoints = auxinq\n        deallocate(auxinq)\n      end if\n      call chdir(\"..\")\n      print*,\"chido con los puntos de interes\"\n      end subroutine getinquirepoints\n"}
{"id": 1113, "subroutine": "      subroutine getpolaridad(skipdir,psv,sh)\n\n      logical :: skipdir(3),psv,sh\n      logical :: lexist\n      integer :: input\n      call chdir(\"ins\")\n      inquire(file=\"source.txt\",exist=lexist)\n      if (lexist) then\n        open(77,file=\"source.txt\",form=\"formatted\")\n      else\n        write(6,'(a)') 'there is a missing input file. '\n        stop 'check \"source.txt\" on working directory'\n      end if\n      read(77,*);read(77,*) input\n      close(77)\n      sh = .false.; psv = .false.;skipdir = .true.\n\n      if (input .eq. 2) then\n      sh = .true.\n      skipdir(2) = .false.\n      return\n      end if\n      !\n      if (input .eq. 1) then\n      psv = .true.\n      skipdir(1) = .false.\n      return\n      end if\n      !\n      if (input .eq. 3) then\n      psv = .true.\n      skipdir(3) = .false.\n      return\n      end if\n      !\n      if (input .eq. 4) then\n      psv = .true.\n      skipdir(1) = .false.\n      skipdir(3) = .false.\n      return\n      end if\n      end subroutine getpolaridad\n"}
{"id": 1114, "subroutine": "      subroutine getsource\n      use wavevars, only: t0,maxtime! escala,ts,tp, ampfunction, siggaus,\n      use sourcevars, only: po, nfuentes!, tipofuente, pw_pol,\n      use glovars, only:pi,printnum\n      use resultvars, only : punto\n      use gquadrature, only: gquad_n\n      use soilvars, only : z,n\n      implicit none\n      interface\n        subroutine punga (bp)\n        use resultvars, only : punto\n        type (punto), pointer :: bp\n        end subroutine punga\n      end interface\n\n      integer :: thelayeris,efsource,i,regi\n      logical :: lexist, tellisoninterface, intfsource\n      real    :: xfsource,zfsource,l\n      real*8  :: nxfsource,nyfsource,nzfsource, pw_theta\n      type (punto), pointer :: bpi\n        real :: escala\n        real :: mastimere,ts,tp\n        integer :: ampfunction\n        real :: siggaus\n        integer :: pw_pol\n        integer :: tipofuente\n\n\n      call chdir(\"ins\")\n      inquire(file=\"source.txt\",exist=lexist)\n      if (lexist) then\n        open(77,file=\"source.txt\",form=\"formatted\")\n      else\n        write(6,'(a)') 'there is a missing input file. '\n        stop 'check \"source.txt\" on working directory'\n      end if\n      read(77,*);read(77,*);read(77,*);\n      read(77,*) nfuentes;read(77,*);read(77,*)\n\n      allocate(po(nfuentes))\n      allocate(maxtime(nfuentes))\n      write(printnum,'(a)') &\n       \"---------------------------------------------------------------------------------\"\n      do i=1,nfuentes\n       read(77,*) xfsource, zfsource, &\n                  nxfsource, nzfsource, &\n                  pw_theta, l, regi,&\n                  escala, ampfunction,  mastimere, ts, tp, siggaus,&\n                  pw_pol, tipofuente\n       po(i)%center%x = xfsource\n       po(i)%center%z = zfsource\n       po(i)%normal%x = nxfsource\n!      po(i)%normal%y = nyfsource\n       po(i)%normal%z = nzfsource\n       po(i)%cost = cos((360-pw_theta)*pi/180.0)\n       po(i)%sint = sin((360-pw_theta)*pi/180.0)\n       po(i)%gamma = pw_theta*pi/180.0 !clockwise desde el eje z (hacia abajo)\n       if (tipofuente .eq. 2) then\n       po(i)%length = l\n       else\n       po(i)%length = 1\n       end if\n       if (tipofuente .eq. 1) then ! onda plana\n!         if (po(i)%center%z .gt. 0.001) then\n            po(i)%center%z = z(n+1)\n            efsource = n+1\n!         else\n !           po(i)%center%z = 0\n  !          efsource = 1\n   !      end if\n         intfsource = .true.\n       else\n         efsource = thelayeris(real(zfsource,8))\n         intfsource = tellisoninterface(real(zfsource,8))\n       end if\n       po(i)%region = regi\n       if (regi .eq. 2) then\n         efsource = n+2\n         intfsource = .false.\n       end if\n       po(i)%layer = efsource\n       po(i)%isoninterface = intfsource\n       po(i)%isboundary = .false.\n       if (tipofuente .eq. 2) then ! fuente segmento\n        po(i)%bord_a%x = xfsource - l * 0.5 * po(i)%cost\n        po(i)%bord_a%z = zfsource - l * 0.5 * po(i)%sint\n        po(i)%bord_b%x = xfsource + l * 0.5 * po(i)%cost\n        po(i)%bord_b%z = zfsource + l * 0.5 * po(i)%sint\n        po(i)%issourcesegmentforce = .true.\n        bpi => po(i)\n        allocate(bpi%gq_xxx_coords(gquad_n,2,2))\n        allocate(bpi%gq_xxx_c(gquad_n,2))\n        call punga(bpi)\n       else\n        po(i)%issourcesegmentforce = .false.\n        po(i)%length = 1.0_8\n       end if\n       po(i)%escala=escala\n       po(i)%ampfunction=ampfunction\n       maxtime(i) = mastimere\n       po(i)%ts=ts\n       po(i)%tp=tp\n       po(i)%siggaus=siggaus\n       po(i)%pw_pol=pw_pol\n       po(i)%tipofuente=tipofuente\n      write(printnum,'(/,a,f8.2,a,f8.2,a,2x,a,f9.2,a,f9.2,a,i0,a,i0,a,l2)') &\n      \"   source: (\",po(i)%center%x,\",\",po(i)%center%z,\")\", &\n      \"n=[\",po(i)%normal%x,\",\",po(i)%normal%z,&\n      \"] r= \",po(i)%region,\" e=\",po(i)%layer,\" intf=\",po(i)%isoninterface\n      write(printnum,'(a,f8.2,a,f8.2)') \"   cost=\",po(i)%cost,\" sint=\",po(i)%sint\n      if (tipofuente .eq. 2) then ! fuente segmento\n        write(printnum,'(a,f8.2,f8.2,a,f8.2,f8.2,a)') &\n        \"   a=(\",po(i)%bord_a%x,po(i)%bord_a%z,\")   b=(\",po(i)%bord_b%x,po(i)%bord_b%z,\")\"\n        write(printnum,'(a,f8.2)') \"   clockwise angle from z: \",po(i)%gamma\n      end if\n      end do\n      read(77,*);read(77,*) t0\n      close(77); call chdir(\"..\")\n\n      end subroutine getsource\n"}
{"id": 1115, "subroutine": "      subroutine getvideopoints\n      use resultvars, only : moviepoints, nmpts, &\n                             iptfin,mptini,mptfin\n      use peli, only : coords_z,coords_x,fotogramas,fotogramas_region\n      use meshvars\n      use glovars,only: makevideo,z0\n      use wavenumvars, only : nptstime\n      use sourcevars, only : nfuentes\n      implicit none\n      integer :: iz,thelayeris\n      real :: firstz\n      logical :: tellisoninterface,lexist\n      call chdir(\"ins\")\n      inquire(file=\"videoparameters.txt\",exist=lexist)\n      if (lexist) then\n        open(7,file=\"videoparameters.txt\",form=\"formatted\")\n      else\n        write(6,'(a)') 'there is a missing input file. '\n        stop 'check \"videoparameters.txt\" on working directory'\n      end if\n\n      read(7,*) !      resolution (vertical, horizontal)\n      read(7,*) npixz,npixx,nmarkz,nmarkx\n      read(7,*) !      vertical (start,end)\n      read(7,*) meshminz,meshmaxz,firstz\n      read(7,*) !      horizontal (start,end)\n      read(7,*) meshminx,meshmaxx\n      read(7,*) meshveclen\n      read(7,*) meshveclen2\n      close(7)\n      call chdir(\"..\")\n      if (makevideo .eqv. .false.) return\n        allocate(coords_x(npixx))\n        allocate(coords_z(npixz))\n        allocate(fotogramas(npixz,npixx,nptstime,3,nfuentes))\n        allocate(fotogramas_region(npixz,npixx))\n\n        fotogramas = z0\n        fotogramas_region = 1!'estr' ! la region exterior\n        nmpts = npixz\n        mptini = iptfin + 1\n        mptfin = mptini + nmpts - 1\n        allocate(moviepoints(nmpts))\n      moviepoints(:)%normal%x = 0\n      moviepoints(:)%normal%z = 0\n      moviepoints(:)%isoninterface = .false.\n      moviepoints(:)%isboundary = .false.\n      moviepoints(:)%guardarfk = .false.\n      moviepoints(:)%guardarmoviesiblings = .true.\n      moviepoints(:)%issabana = .false.\n      moviepoints(:)%issourcesegmentforce= .false.\n      moviepoints(:)%isod= .false. \n      moviepoints(:)%region = 1\n      moviepoints(:)%boundaryindex = 0\n      moviepoints(:)%atbou = .false.\n        \n        do iz = 1, npixz\n          moviepoints(iz)%center%x = meshminx\n          moviepoints(iz)%center%z = firstz + (meshmaxz - firstz)/(npixz-1) * (iz-1)\n          coords_z(iz) = real(moviepoints(iz)%center%z,4)\n          moviepoints(iz)%layer = thelayeris(real(moviepoints(iz)%center%z,8))\n          moviepoints(iz)%isoninterface = tellisoninterface(real(moviepoints(iz)%center%z,8))\n        end do!\n        do iz = 1, npixx\n          coords_x(iz) = real(meshminx + (meshmaxx - meshminx)/(npixx-1) * (iz-1),4)\n        end do\n      end subroutine getvideopoints\n"}
{"id": 1116, "subroutine": "      subroutine gettopography\n      !read coordinates of collocation points and fix if there are\n      !intersections with inferfaces. also find normal vectors of segments.\n      use geometryvars, only: n_topo,n_cont,n_vall,nxi, xcoord_er, &\n      xcoord_voidonly, xcoord_incluonly,xcoord_flip_out,boxincl_maxx,boxincl_maxy, &\n      boxincl_minx,boxincl_miny,boxvoid_maxx,boxvoid_maxy,boxvoid_minx,&\n      boxvoid_miny, midpoint,normxi, origgeom, surf_poly,&\n      n_de_regdionesr, n_de_segmentosr,xcoord_incluonly_e\n      use glovars\n      use fitting\n      use soilvars, only : z,n,rho,beta0,alfa0,shadecolor_inc,lambda0,anu,amu0, layershadecolor\n      use ploteo10pesos\n\n      implicit none\n      logical :: lexist, hubocambios\n      real*8, dimension(:,:,:), allocatable :: auxvector\n      real*8 :: l, m,bealf\n      integer :: ixi,e\n      real*8 :: nuevopx, escalax,escalay,offsetx,offsety,escala_n,minbeta,maxbeta\n\n      real     :: errt = 0.0001\n      logical, dimension(:), allocatable  :: isonif\n      real, dimension(:), allocatable :: auxa,auxb\n      character(len=32) :: arg\n      real*8, allocatable, save :: lengthxi(:),layerxi(:),cost(:),sint(:)\n      logical, dimension(:), allocatable :: es_de_esquina\n      integer :: nxioriginal\n      integer :: ir\n      hubocambios = .false.\n      allocate(auxa(1)); allocate(auxb(1))\n      print*,\"reading topography file\"\n      call chdir(\"ins\")\n      !read surface topography\n      inquire(file=\"boundaries.txt\",exist=lexist)\n      if (lexist) then\n        open(77,file=\"boundaries.txt\",form=\"formatted\")\n      else\n        write(6,'(a)')'there is a missing input file. '\n        stop 'check \"boundaries.txt\" on working directory'\n      end if\n      call get_command_argument(1, arg)\n      if ((len_trim(arg) .ne. 0) .and. (trim(arg) .eq. '-g')) verbose = 3\n      read(77,*)\n      read(77,*) n_topo\n      read(77,*) n_cont\n      read(77,*) n_vall\n      nxi = n_topo + n_cont + n_vall !numero total de segmentos originales\n      if (allocated(xcoord_er)) deallocate(xcoord_er)\n      allocate (xcoord_er(nxi+300,2,2))\n      allocate (es_de_esquina(nxi*2+300))\n      allocate(auxvector(nxi+1+300,2,2))\n      read(77,*)\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n      read(77,*) escala_n\n      do ixi = 1,n_topo\n         if (escala_n .gt. 0.0) then\n         read(77,*) xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),&\n         xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),es_de_esquina(ixi)\n         else\n         read(77,*) xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),&\n         xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),es_de_esquina(ixi)\n         end if\n         xcoord_er(ixi,1,1:2) = xcoord_er(ixi,1,1:2) * escalax + offsetx\n         xcoord_er(ixi,2,1:2) = xcoord_er(ixi,2,1:2) * escalay + offsety\n      end do\n      read(77,*)\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n      read(77,*) escala_n\n      do ixi = n_topo+1, n_topo+n_cont\n         if (escala_n .gt. 0.0) then\n         read(77,*) xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),&\n         xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),es_de_esquina(ixi)\n         else\n         read(77,*) xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),&\n         xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),es_de_esquina(ixi)\n         end if\n         xcoord_er(ixi,1,1:2) = xcoord_er(ixi,1,1:2) * escalax + offsetx\n         xcoord_er(ixi,2,1:2) = xcoord_er(ixi,2,1:2) * escalay + offsety\n      end do\n      read(77,*)\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n      read(77,*) escala_n\n      do ixi = n_topo+n_cont+1,n_topo+n_cont+n_vall !nxi\n         if (escala_n .gt. 0.0) then\n         read(77,*) xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),&\n         xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),es_de_esquina(ixi)\n         else\n         read(77,*) xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),&\n         xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),es_de_esquina(ixi)\n         end if\n         xcoord_er(ixi,1,1:2) = xcoord_er(ixi,1,1:2) * escalax + offsetx\n         xcoord_er(ixi,2,1:2) = xcoord_er(ixi,2,1:2) * escalay + offsety\n      end do\n      read(77,*) ! inclusion properties\n      read(77,*) ! alfa(m/s) beta(m/s) dens(t/m3)\n      read(77,*) alfa0(n+2),beta0(n+2),rho(n+2)\n\n      amu0(n+2)=rho(n+2)*beta0(n+2)**2.0\n      lambda0(n+2)=rho(n+2)*alfa0(n+2)**2.0 - &\n                        real(2.)*real(amu0(n+2))\n      bealf = beta0(n+2)/alfa0(n+2)\n      anu(n+2) = (bealf**2 - 0.5)/(-1 + bealf**2)\n\n      if (allocated(xcoord_incluonly)) deallocate(xcoord_incluonly)\n      allocate (xcoord_incluonly(n_cont + n_vall,2,2))\n      do ixi = 1,n_cont + n_vall\n          xcoord_incluonly(ixi,:,:) = xcoord_er(n_topo+ixi,:,:)\n          if (abs(xcoord_incluonly(ixi,2,1)) .le. 0.06) xcoord_incluonly(ixi,2,1) = 0\n          if (abs(xcoord_incluonly(ixi,2,2)) .le. 0.06) xcoord_incluonly(ixi,2,2) = 0\n      end do\n\n      ! bounding box\n      boxincl_maxx = maxval(xcoord_incluonly(:,1,:))\n      boxincl_maxy = maxval(xcoord_incluonly(:,2,:))\n      boxincl_minx = minval(xcoord_incluonly(:,1,:))\n      boxincl_miny = minval(xcoord_incluonly(:,2,:))\n      read(77,*) ! and make anything inside is on the air\n      read(77,*) e\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n      if (e .ne. 0) then\n      if (allocated(xcoord_voidonly)) deallocate(xcoord_voidonly)\n      allocate (xcoord_voidonly(e,2,2))\n      do ixi = 1,e\n         read(77,*) xcoord_voidonly(ixi,1,1),xcoord_voidonly(ixi,2,1),&\n                    xcoord_voidonly(ixi,1,2),xcoord_voidonly(ixi,2,2)\n         xcoord_voidonly(ixi,1,1:2) = xcoord_voidonly(ixi,1,1:2) * escalax + offsetx\n         xcoord_voidonly(ixi,2,1:2) = xcoord_voidonly(ixi,2,1:2) * escalay + offsety\n      end do\n      ! bounding box\n      boxvoid_maxx = maxval(xcoord_voidonly(:,1,:))\n      boxvoid_maxy = maxval(xcoord_voidonly(:,2,:))\n      boxvoid_minx = minval(xcoord_voidonly(:,1,:))\n      boxvoid_miny = minval(xcoord_voidonly(:,2,:))\n      end if\n\n      read(77,*) !cualquier receptor dentro de estas superficies est\u00e1 en la region homogenea\n      read(77,*) n_de_regdionesr !n de regiones\n      read(77,*) n_de_segmentosr !total de segmentos\n      if (n_de_regdionesr .ne. 0) then\n      if (allocated(xcoord_incluonly)) deallocate(xcoord_incluonly)\n      allocate (xcoord_incluonly(n_de_segmentosr,2,2))\n      if (allocated(xcoord_incluonly_e)) deallocate(xcoord_incluonly_e)\n      allocate (xcoord_incluonly_e(n_de_regdionesr+1))\n      xcoord_incluonly_e(1) = 1\n      do ir = 1,n_de_regdionesr\n      read(77,*) xcoord_incluonly_e(ir+1)\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n!     print*,\"from \",sum(xcoord_incluonly_e(1:ir)),\" to \",sum(xcoord_incluonly_e(2:ir+1))\n      do ixi = sum(xcoord_incluonly_e(1:ir)),sum(xcoord_incluonly_e(2:ir+1))\n         read(77,*) xcoord_incluonly(ixi,1,1), xcoord_incluonly(ixi,2,1),&\n                    xcoord_incluonly(ixi,1,2), xcoord_incluonly(ixi,2,2)\n\n         xcoord_incluonly(ixi,1,1:2) = xcoord_incluonly(ixi,1,1:2) * escalax + offsetx\n         xcoord_incluonly(ixi,2,1:2) = xcoord_incluonly(ixi,2,1:2) * escalay + offsety\n      end do\n      end do\n!     do ixi = 1, n_de_segmentosr; print*,ixi,xcoord_incluonly(ixi,1,1), xcoord_incluonly(ixi,2,1),&\n!        xcoord_incluonly(ixi,1,2), xcoord_incluonly(ixi,2,2); end do\n!     do ixi = 1, n_de_regdionesr+1; print*,ixi,xcoord_incluonly_e(ixi)\n!     end do\n!     stop\n      ! bounding box\n      boxincl_maxx = maxval(xcoord_incluonly(:,1,:))\n      boxincl_maxy = maxval(xcoord_incluonly(:,2,:))\n      boxincl_minx = minval(xcoord_incluonly(:,1,:))\n      boxincl_miny = minval(xcoord_incluonly(:,2,:))\n      else\n       read(77,*)\n       read(77,*)\n       read(77,*)\n      end if\n      !\n      if (flip12) then\n      read(77,*) ! borde de regi\u00f3n e cuando flip12 .true.\n      read(77,*) e\n      read(77,*) escalax,escalay\n      read(77,*) offsetx,offsety\n      if (e .ne. 0) then\n      if (allocated(xcoord_flip_out)) deallocate(xcoord_flip_out)\n      allocate (xcoord_flip_out(e,2,2))\n      do ixi = 1,e\n         read(77,*) xcoord_flip_out(ixi,1,1),xcoord_flip_out(ixi,2,1),&\n                    xcoord_flip_out(ixi,1,2),xcoord_flip_out(ixi,2,2)\n         xcoord_flip_out(ixi,1,1:2) = xcoord_flip_out(ixi,1,1:2) * escalax + offsetx\n         xcoord_flip_out(ixi,2,1:2) = xcoord_flip_out(ixi,2,1:2) * escalay + offsety\n      end do\n      end if\n      end if\n      close(77)\n      call chdir(\"..\")\n\n      minbeta = minval(beta0(1:n+2))\n      maxbeta = maxval(beta0(1:n+2))\n\n      if (abs(minbeta - maxbeta) .lt. 0.01) then\n        shadecolor_inc = layershadecolor(1)\n      else\n        e=n+2\n!         layershadecolor(e)= real(0.4-(maxbeta-beta0(e))*((0.4-0.89)/(maxbeta-minbeta)),4)\n          layershadecolor(e)= real(0.6-(maxbeta-beta0(e))*((0.6-0.89)/(maxbeta-minbeta)),4)\n          !print*,e,layershadecolor(e)\n!       end do\n          shadecolor_inc = layershadecolor(n+2)\n      end if\n\n!     go to 384\n      nxioriginal = nxi\n      ! cortar en intersecci\u00f3n con estratos y determinar estrato de cada segemento\n      if (verbose >= 4) write(printnum,*)\"begin slice with layers\"\n      ixi = 1\n      do !para cada segmento\n\n      !#< r we check if there is a change of medium along segment ixi  !#>\n      do e = 2,n+1 !en cada interfaz (excepto la superficie)\n      if (verbose >= 4) write(printnum,*) \"e= \",e\n        if ((abs(xcoord_er(ixi,2,1) - z(e)) < errt) .or. &\n            (abs(xcoord_er(ixi,2,2) - z(e)) < errt)) then\n!       if ((abs(anint(xcoord_er(ixi,2,1) * 1000) - anint(z(e) * 1000)) < errt) .or. &\n!           (abs(anint(xcoord_er(ixi,2,2) * 1000) - anint(z(e) * 1000)) < errt)) then\n            if (verbose >= 4) write(printnum,*)\"already sliced here\"\n        else ! not already\n          if (verbose >= 4) write(printnum,*) \"divi\"\n            ! si es un segmento que se forma recorriendo los puntos hacia z+\n            if (xcoord_er(ixi,2,1) < z(e)  .and. xcoord_er(ixi,2,2) > z(e)) then\n               if (verbose >= 4) write(printnum,*)\"hay un cambio de estrato hacia z+\"\n               if (abs(xcoord_er(ixi,1,2) - xcoord_er(ixi,1,1)) .le. 0.001) then ! es vertical\n                 nuevopx = xcoord_er(ixi,1,1)\n               else ! es inclinado\n                 m = (xcoord_er(ixi,2,2) - xcoord_er(ixi,2,1))/(xcoord_er(ixi,1,2) - xcoord_er(ixi,1,1))\n                 surf_poly = real((/xcoord_er(ixi,2,1) - xcoord_er(ixi,1,1)*m , m /),4)\n                 !are the polynomial coefficients from lower to top. a0 a1 a2 ... an\n                 nuevopx = splitaty(surf_poly,1,real(z(e),4),&\n                 real(xcoord_er(ixi,1,1),4),real(xcoord_er(ixi,1,2),4))\n               end if !\n               if ((sqrt((xcoord_er(ixi,1,1)-nuevopx)**2 + (xcoord_er(ixi,2,1) - z(e))**2) .lt. 0.001) .or. &\n                   (sqrt((xcoord_er(ixi,1,2)-nuevopx)**2 + (xcoord_er(ixi,2,2) - z(e))**2) .lt. 0.001)) then\n                   if (verbose >= 4) write(printnum,*) \"muy corto\"\n                   cycle ! si es muy corto no lo queremos\n               end if!\n             if (verbose >= 4) then\n              write(printnum,'(a,f10.4,f10.4,a,f10.4,f10.4,a,f10.4,a,f10.4,a)') &\n              \"(dn)segment (x,z):[\",xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),\" to\" &\n              ,xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),\"] crosses interface at (x,z)=(\",nuevopx,\",\",z(e),\")\"\n             end if\n\n               ! insertamos el nuevo punto en el vector de puntos\n!              if (allocated(auxvector)) deallocate(auxvector)\n!              allocate(auxvector(nxi+1,2,2)) ! una arista nueva\n               auxvector(1:ixi,1:2,1:2) = xcoord_er(1:ixi,1:2,1:2)\n               auxvector(ixi,1,2) = nuevopx\n               auxvector(ixi,2,2) = z(e)\n               auxvector(ixi+1,1,1) = nuevopx\n               auxvector(ixi+1,2,1) = z(e)\n               auxvector(ixi+1,1,2) = xcoord_er(ixi,1,2)\n               auxvector(ixi+1,2,2) = xcoord_er(ixi,2,2)\n               auxvector(ixi+2:nxi+1,1:2,1:2) = xcoord_er(ixi+1:nxi,1:2,1:2)\n!              es_de_esquina(1:ixi) !se queda igual\n               es_de_esquina(ixi+2:nxi+1) = es_de_esquina(ixi+1:nxi) !recorre\n               es_de_esquina(ixi+1) = es_de_esquina(ixi) ! se duplica\n\n               nxi = nxi + 1\n               xcoord_er(1:nxi,1:2,1:2) = auxvector(1:nxi,1:2,1:2)\n\n!              if (allocated(xcoord_er))  deallocate(xcoord_er)\n!              nxi = nxi + 1\n!              allocate(xcoord_er(nxi,2,2))\n!              xcoord_er(1:nxi,1:2,1:2) = auxvector(1:nxi,1:2,1:2)\n\n               if(n_topo+n_cont+1 .le. ixi) n_vall = n_vall + 1\n               if(n_topo+1 .le. ixi .and. ixi .le. n_cont+n_topo) n_cont = n_cont + 1\n               if(ixi .le. n_topo) n_topo = n_topo + 1\n               if (verbose >= 4) write(printnum,*) \"fin hacia z+\"\n               cycle !estrato\n            end if !(xcoord_er(ixi,2,1) < z(e)  .and. xcoord_er(ixi,2,2) > z(e))\n      ! si es un segmento que se forma recorriendo los puntos hacia z-\n            if (xcoord_er(ixi,2,1) > z(e)  .and. xcoord_er(ixi,2,2) < z(e)) then\n               if (verbose >= 4) write(printnum,*)\"hay un cambio de estrato hacia z-\"\n               if (abs(xcoord_er(ixi,1,2) - xcoord_er(ixi,1,1)) .le. 0.001) then ! es vertical\n                 nuevopx = xcoord_er(ixi,1,1)\n               else ! es inclinado\n                 m = (xcoord_er(ixi,2,2) - xcoord_er(ixi,2,1))/(xcoord_er(ixi,1,2) - xcoord_er(ixi,1,1))\n                 surf_poly = real((/xcoord_er(ixi,2,1) - xcoord_er(ixi,1,1)*m , m /),4)\n                 nuevopx = splitaty(surf_poly,1,real(z(e),4),&\n                 real(xcoord_er(ixi,1,1),4),real(xcoord_er(ixi,1,2),4))\n               end if!\n               if ((sqrt((xcoord_er(ixi,1,1)-nuevopx)**2 + (xcoord_er(ixi,2,1) - z(e))**2) .lt. 0.001) .or. &\n                   (sqrt((xcoord_er(ixi,1,2)-nuevopx)**2 + (xcoord_er(ixi,2,2) - z(e))**2) .lt. 0.001)) then\n                   if (verbose >= 4) write(printnum,*) \"muy corto\"\n                   cycle ! si es muy corto no lo queremos\n               end if!\n             if (verbose >= 4) then\n               write(printnum,'(a,f10.4,f10.4,a,f10.4,f10.4,a,f10.4,a,f10.4,a)') &\n              \"(dn)segment (x,z):[\",xcoord_er(ixi,1,1),xcoord_er(ixi,2,1),\" to\" &\n              ,xcoord_er(ixi,1,2),xcoord_er(ixi,2,2),\"] crosses interface at (x,z)=(\",nuevopx,\",\",z(e),\")\"\n             end if\n\n               ! insertamos el nuevo punto en el vector de puntos\n!              if (allocated(auxvector)) deallocate(auxvector)\n!              allocate(auxvector(nxi+1,2,2)) ! un segmento m\u00e1s\n               auxvector(1:ixi,1:2,1:2) = xcoord_er(1:ixi,1:2,1:2)\n               auxvector(ixi,1,2) = nuevopx\n               auxvector(ixi,2,2) = z(e)\n               auxvector(ixi+1,1,1) = nuevopx\n               auxvector(ixi+1,2,1) = z(e)\n               auxvector(ixi+1,1,2) = xcoord_er(ixi,1,2)\n               auxvector(ixi+1,2,2) = xcoord_er(ixi,2,2)\n               auxvector(ixi+2:nxi+1,1:2,1:2) = xcoord_er(ixi+1:nxi,1:2,1:2)\n!              es_de_esquina(1:ixi) !se queda igual\n               es_de_esquina(ixi+2:nxi+1) = es_de_esquina(ixi+1:nxi) ! se recorre\n               es_de_esquina(ixi+1) = es_de_esquina(ixi) ! se duplica\n\n               nxi = nxi + 1\n               xcoord_er(1:nxi,1:2,1:2) = auxvector(1:nxi,1:2,1:2)\n\n\n!              if (allocated(xcoord_er)) deallocate(xcoord_er)\n!              nxi = nxi + 1\n!              allocate(xcoord_er(nxi,2,2))\n!              xcoord_er(1:nxi,1:2,1:2) = auxvector(1:nxi,1:2,1:2)\n\n               if(n_topo+n_cont+1 .le. ixi) n_vall = n_vall + 1\n               if(n_topo+1 .le. ixi .and. ixi .le. n_cont+n_topo) n_cont = n_cont + 1\n               if(ixi .le. n_topo) n_topo = n_topo + 1\n               if (verbose >= 4) write(printnum,*) \"fin hacia z-\"\n               cycle !estrato\n            end if !(xcoord_er(ixi,2,1) > z(e)  .and. xcoord_er(ixi,2,2) < z(e))\n        end if ! already\n        if (verbose >= 4) write(printnum,*) \"fin e=\",e\n      end do ! e\n      !n_topo+n_cont+1,n_topo+n_cont+n_vall\n      if (ixi .eq. n_topo+n_cont) exit ! salidr de do de ixi\n!     if (ixi .eq. nxi) exit ! salidr de do de ixi\n      ixi = ixi+1\n      end do !ixi\n\n      deallocate(auxvector)\n      if (verbose >= 4) write(printnum,*)\"out of slice\"\n      if (nxi .le. 0) stop \"errror nxi <= 0\"\n\n      ! right hand normals\n      allocate (normxi(nxi,2))\n      do ixi=1,nxi\n        normxi(ixi,1) = xcoord_er(ixi,2,1) - xcoord_er(ixi,2,2)\n        normxi(ixi,2) = xcoord_er(ixi,1,2) - xcoord_er(ixi,1,1)\n        l = sqrt(normxi(ixi,1)**2. + normxi(ixi,2)**2.)\n        normxi(ixi,1) = normxi(ixi,1)/ l\n        normxi(ixi,2) = normxi(ixi,2)/ l\n      end do\n\n      ! midpoints and lenght\n      allocate (midpoint(nxi,2))\n      allocate (lengthxi(nxi))\n      allocate (cost(nxi))\n      allocate (sint(nxi))\n      do ixi=1,nxi\n        midpoint(ixi,1) = (xcoord_er(ixi,1,2) + xcoord_er(ixi,1,1))/2.0\n        midpoint(ixi,2) = (xcoord_er(ixi,2,2) + xcoord_er(ixi,2,1))/2.0\n        lengthxi(ixi) = sqrt((xcoord_er(ixi,1,2)-xcoord_er(ixi,1,1))**2.0 &\n                             +(xcoord_er(ixi,2,2)-xcoord_er(ixi,2,1))**2.0)\n      end do\n      cost = (xcoord_er(1:nxi,1,2)- midpoint(1:nxi,1))/(lengthxi(1:nxi)/2.)\n      sint = (xcoord_er(1:nxi,2,2)- midpoint(1:nxi,2))/(lengthxi(1:nxi)/2.)\n\n      ! estrato\n      allocate (layerxi(nxi))\n      layerxi(:) = n+1\n      do e=1,n\n        forall(ixi=1:nxi, &\n          (z(e) < midpoint(ixi,2) .and. midpoint(ixi,2) <= z(e+1))) &\n          layerxi(ixi) = e\n      end do\n\n      allocate (isonif(nxi)) ; isonif = .false.\n      do e=1,n+1\n        forall(ixi=1:nxi, &\n          ((z(e)-errt .lt. midpoint(ixi,2)) &\n            .and. (midpoint(ixi,2) .lt. z(e)+errt))) &\n          isonif(ixi) = .true.\n      end do\n\n      ! save original geometry for the posterity\n      allocate(origgeom(nxi))\n      ! central point\n      origgeom(1:nxi)%center%x = midpoint(1:nxi,1)\n      origgeom(1:nxi)%center%z = midpoint(1:nxi,2)\n      !borders of segment\n      origgeom(1:nxi)%bord_a%x = xcoord_er(1:nxi,1,1)\n      origgeom(1:nxi)%bord_a%z = xcoord_er(1:nxi,2,1)\n      origgeom(1:nxi)%bord_b%x = xcoord_er(1:nxi,1,2)\n      origgeom(1:nxi)%bord_b%z = xcoord_er(1:nxi,2,2)\n      !add normal\n      origgeom(1:nxi)%normal%x = normxi(1:nxi,1)\n      origgeom(1:nxi)%normal%z = normxi(1:nxi,2)\n      !add length\n      origgeom(1:nxi)%length = lengthxi(1:nxi)\n      origgeom(1:nxi)%segmentodeesquina = es_de_esquina(1:nxi)\n      origgeom(1:nxi)%cost = cost(1:nxi)\n      origgeom(1:nxi)%sint = sint(1:nxi)\n      !add layer\n      origgeom(1:nxi)%layer = int(layerxi(1:nxi))\n      origgeom(1:nxi)%isboundary = .true.\n      origgeom(1:nxi)%isoninterface = isonif(1:nxi)\n      origgeom(1:nxi)%guardarfk = .false.\n      origgeom(1:nxi)%guardarmoviesiblings = .false.\n\n      !tipo de frontera\n      !  te^0 + te^d = 0\n      origgeom(1:n_topo)%tipofrontera = 0\n      !  te^0 + te^d = tr^r; ue^0 + ue^d = ur^r\n      origgeom(n_topo+1:n_cont+n_topo)%tipofrontera = 1\n      !  tr^r = 0\n      origgeom(n_cont+n_topo+1:nxi)%tipofrontera = 2\n\n      write(printnum,'(/,a,/,a, f7.1,2x, f7.1,2x, e8.2,2x, e8.2,2x, e8.2,2x, e8.2)') &\n         '--- inclusion -------------------------------------------------------------------',&\n         '   ',alfa0(n+2),beta0(n+2),real(amu0(n+2)),&\n         rho(n+2), real(lambda0(n+2)),real(anu(n+2))\n\n        if (verbose .ge. 2) then\n        write(printnum,'(/,a)') '--- geometry---------------------------------------------------------------------'\n         do ixi = 1,nxi\n        write(printnum,'(a,i0,a,f5.2,a,f5.2,a,f5.2,a,f5.2,a,f5.2)', advance = \"no\") &\n        '   ',&\n         ixi,\" c[\",origgeom(ixi)%center%x,\",\",origgeom(ixi)%center%z,\"] n[\",&\n         origgeom(ixi)%normal%x,\",\",origgeom(ixi)%normal%z,\"] l:\",origgeom(ixi)%length\n        write(printnum,'(a,f5.2,a,f5.2,a,i0,a,i0)') &\n        \"  co\",origgeom(ixi)%cost,\" si\",origgeom(ixi)%sint,\" e\",origgeom(ixi)%layer, &\n        \" tipo\",origgeom(ixi)%tipofrontera\n         end do\n         write(printnum,'(a,/)') '---------------------------------------------------------------------------------'\n        end if\n      deallocate(auxa);deallocate(auxb);deallocate(es_de_esquina);deallocate(isonif)\n      deallocate(lengthxi);deallocate(layerxi);deallocate(cost);deallocate(sint)\n      end subroutine gettopography\n"}
{"id": 1117, "subroutine": "      subroutine setvideopointsregions\n      use peli, only : coords_z,coords_x,fotogramas_region\n      use meshvars, only : npixx,npixz\n      use glovars, only : flip12,printnum,verbose\n      use debugstuff\n      implicit none\n      integer :: i,j\n      integer, dimension(0:2) :: reg\n      logical :: cn, adentrooafuera\n      ! !1 estr, 2 incl, 0 void\n      reg(0) = 0; reg(1)= 1; reg(2) = 2\n      if (flip12) then\n      reg(0) = 0; reg(1)= 2; reg(2) = 1\n      end if\n      ! asigmar la region a cada pixel de la pelicula\n       do i=1,npixz\n        do j=1,npixx\n          fotogramas_region(i,j) = reg(1)!'estr'\n          cn = adentrooafuera(coords_x(j), coords_z(i),'void')\n          if (cn .eqv. .true.) then\n            fotogramas_region(i,j) = reg(0)!'void'\n            cycle\n          end if\n          cn = adentrooafuera(coords_x(j), coords_z(i),'incl')\n          if (cn .eqv. .true.) then\n            fotogramas_region(i,j) = reg(2)!'incl'\n          end if\n        end do\n       end do\n      if (verbose .ge. 2) then\n      print*,\"\";print*,\"fotogramas_region\"\n      call showmnmatrixi(npixz,npixx,fotogramas_region,\"fotre\",printnum)\n      end if\n\n      end subroutine setvideopointsregions\n"}
{"id": 1118, "subroutine": "      subroutine setinqpointsregions\n      use resultvars, only : allpoints,npts,n_od,nipts\n      use soilvars, only : n\n      use glovars, only : verbose, printnum, flip12\n      implicit none\n      integer :: i\n      integer, dimension(0:2) :: reg\n      logical :: cn,adentrooafuera\n      !! 0 void, 1 estr, 2 incl\n      reg(0) = 0; reg(1)= 1; reg(2) = 2\n      if (flip12) then\n        reg(0) = 0; reg(1)= 2; reg(2) = 1\n      end if\n!     allpoints(1:npts)%region = reg(1)!'estr'\n      if (verbose .ge. 1) then\n      write(printnum,'(a)') \"------------------------------------------------\"\n      write(printnum,'(a,i0)') \"npts=\",npts\n      write(printnum,'(a,i0)') \"nipts=\",nipts\n      write(printnum,'(a,i0,a)') \"there are \",n_od,\" points to overdetermine the system\"\n      write(printnum,*) \"center,region,layer,isod,isoninterface,guardarmoviesiblings,atbou\"\n      end if\n      do i = 1, npts\n        if (allpoints(i)%atbou .eqv. .false.) then\n        allpoints(i)%region = reg(1)!'estr'\n        cn = adentrooafuera(real(allpoints(i)%center%x,4), &\n                            real(allpoints(i)%center%z,4),'void')\n!       print*,i,cn;cycle\n        if (cn .eqv. .true.) then\n            allpoints(i)%region = reg(0)!'void'\n            cycle\n        end if\n        cn = adentrooafuera(real(allpoints(i)%center%x,4), &\n                            real(allpoints(i)%center%z,4),'incl')\n        if (cn .eqv. .true.) then\n            allpoints(i)%region = reg(2)!'incl'\n        end if\n!       if (abs(z(0)) .gt. 0.0001) then ! si no hay un semiespacio arriba\n!         if (real(allpoints(i)%center%z,4) .lt. 0.0) then\n!           allpoints(i)%region = reg(0)!'void'\n!         end if\n!       end if!\n        end if!\n        !if (allpoints(i)%region .eq. 2) allpoints(i)%layer = n+2\n        if (verbose .ge. 1) then\n        write(printnum,'(i0,2x,a,f7.2,a,f7.2,a,i0,a,i0,a,l,a,l,a,l,a,l)'),& \n        i,\"[\",allpoints(i)%center%x,\",\",allpoints(i)%center%z,\"] is r\",& \n        allpoints(i)%region,& \n        \" l\",allpoints(i)%layer,& \n        \" od\",allpoints(i)%isod,&\n        \" inf\",allpoints(i)%isoninterface, &\n        \" mv\",allpoints(i)%guardarmoviesiblings,& \n        \" bou\",allpoints(i)%atbou\n        end if\n      end do!;stop \"setinqpointsregions\"\n      end subroutine setinqpointsregions\n"}
{"id": 1119, "subroutine": "  subroutine starttimer()\n    \n    call date_and_time(values = starttimevalues)\n    timerstopped = .false.\n    timerstarted = .true.\n    \n  end subroutine starttimer\n"}
{"id": 1120, "subroutine": "  subroutine stoptimer()\n\n    call date_and_time(values = endtimevalues)\n    timerstopped = .true.\n\n  end subroutine stoptimer\n"}
{"id": 1121, "subroutine": "  subroutine getruntime(hour,minute,second)\n    integer,intent(out) :: hour,minute\n    real(8),intent(out) :: second\n\n    !local variables\n    integer :: ijulianstart,ijulianend,iyear,imonth,iday\n    real(8) :: runtime,julianstart,julianend,rhour,rmin,rsec,rmsec\n\n    !initialize\n    hour   = 0\n    minute = 0\n    second = 0.0\n    \n    !if timer hasn't been started at all run time cannot be computed; return\n    if (.not. timerstarted) return\n    \n    !start date and time in julian days\n    rhour        = real(starttimevalues(5),8)  \n    rmin         = real(starttimevalues(6),8)\n    rsec         = real(starttimevalues(7),8)\n    rmsec        = real(starttimevalues(8),8)\n    iday         = starttimevalues(3)\n    imonth       = starttimevalues(2)\n    iyear        = starttimevalues(1)\n    ijulianstart = iday-32075+1461*(iyear+4800+(imonth-14)/12)/4+367*(imonth-2-(imonth-14)/12*12)/12-3*((iyear+4900+(imonth-14)/12)/100)/4\n    julianstart  = real(ijulianstart,8) + rhour/24.0 + rmin/1440.0 + rsec/86400.0 + rmsec/86400000.0\n    \n    !end date and time in julian days\n    rhour      = real(endtimevalues(5),8)  \n    rmin       = real(endtimevalues(6),8)\n    rsec       = real(endtimevalues(7),8)\n    rmsec      = real(endtimevalues(8),8)\n    iday       = endtimevalues(3)\n    imonth     = endtimevalues(2)\n    iyear      = endtimevalues(1)\n    ijulianend = iday-32075+1461*(iyear+4800+(imonth-14)/12)/4+367*(imonth-2-(imonth-14)/12*12)/12-3*((iyear+4900+(imonth-14)/12)/100)/4\n    julianend  = real(ijulianend,8) + rhour/24.0 + rmin/1440.0 + rsec/86400.0 + rmsec/86400000.0\n    \n    runtime = (julianend-julianstart)*86400.0  !in seconds\n    hour    = int(runtime/3600.0)\n    minute  = int((runtime-hour*3600.0)/60.0)\n    second  = runtime-hour*3600.0-minute*60.0\n\n  end subroutine getruntime\n"}
{"id": 1122, "subroutine": "subroutine z_dif_ws(j         ,nmmaxj    ,nmmax     ,kmax      ,lsal      , &\n                  & ltem      ,lstsci    ,lsed      ,kcs       ,kfs       , &\n                  & gsqs      ,ws        ,aakl      ,bbkl      ,cckl      , &\n                  & kfsmx0    ,gdp       )\n!----- gpl ---------------------------------------------------------------------\n!                                                                               \n!  copyright (c)  stichting deltares, 2011-2016.                                \n!                                                                               \n!  this program is free software: you can redistribute it and/or modify         \n!  it under the terms of the gnu general public license as published by         \n!  the free software foundation version 3.                                      \n!                                                                               \n!  this program is distributed in the hope that it will be useful,              \n!  but without any warranty; without even the implied warranty of               \n!  merchantability or fitness for a particular purpose.  see the                \n!  gnu general public license for more details.                                 \n!                                                                               \n!  you should have received a copy of the gnu general public license            \n!  along with this program.  if not, see <http://www.gnu.org/licenses/>.        \n!                                                                               \n!  contact: delft3d.support@deltares.nl                                         \n!  stichting deltares                                                           \n!  p.o. box 177                                                                 \n!  2600 mh delft, the netherlands                                               \n!                                                                               \n!  all indications and logos of, and references to, \"delft3d\" and \"deltares\"    \n!  are registered trademarks of stichting deltares, and remain the property of  \n!  stichting deltares. all rights reserved.                                     \n!!--version information---------------------------------------------------------\n! $author$\n! $date$\n! $revision$\n!!--description-----------------------------------------------------------------\n!\n!    function: includes settling velocity in the coefficient\n!              matrices (for sediment constituents only).\n!     comment:\n!\n!!--pseudo code and references--------------------------------------------------\n! none\n!!--declarations----------------------------------------------------------------\n    use precision\n    use globaldata\n    !\n    implicit none\n    !\n    type(globdat),target :: gdp\n    integer , dimension(:,:)             , pointer :: kmxsed\n!\n! global variables\n!\n    integer                                                                   :: j      !  begin pointer for arrays which have been transformed into 1d arrays. due to the shift in the 2nd (m-)index, j = -2*nmax + 1\n    integer                                                     , intent(in)  :: kmax   !  description and declaration in iidim.f90\n    integer                                                     , intent(in)  :: lsal   !  description and declaration in dimens.igs\n    integer                                                     , intent(in)  :: lsed   !  description and declaration in iidim.f90\n    integer                                                     , intent(in)  :: lstsci !  description and declaration in iidim.f90\n    integer                                                     , intent(in)  :: ltem   !  description and declaration in dimens.igs\n    integer                                                     , intent(in)  :: nmmax  !  description and declaration in dimens.igs\n    integer                                                                   :: nmmaxj !  description and declaration in dimens.igs\n    integer , dimension(gdp%d%nmlb:gdp%d%nmub)                  , intent(in)  :: kfsmx0 !  description and declaration in iidim.f90\n    integer , dimension(gdp%d%nmlb:gdp%d%nmub)                  , intent(in)  :: kcs    !  description and declaration in iidim.f90\n    integer , dimension(gdp%d%nmlb:gdp%d%nmub)                  , intent(in)  :: kfs    !  description and declaration in iidim.f90\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub)                  , intent(in)  :: gsqs   !  description and declaration in rjdim.f90\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub, 0:kmax, lstsci)  , intent(in)  :: ws     !  description and declaration in rjdim.f90\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub, kmax, lstsci)                  :: aakl   !  internal work array, lower diagonal tridiagonal matrix, implicit coupling of concentration in (n,m,k) with concentration in (n,m,k-1)\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub, kmax, lstsci)                  :: bbkl   !  internal work array, main diagonal tridiagonal matrix, implicit coupling of concentration in (n,m,k)\n    real(fp), dimension(gdp%d%nmlb:gdp%d%nmub, kmax, lstsci)                  :: cckl   !  internal work array, lower diagonal tridiagonal matrix, implicit coupling of concentration in (n,m,k) with concentration in (n,m,k+1)\n!\n! local variables\n!\n    integer :: k    ! help var. \n    integer :: kfd  ! mutiplicity factor for top flux \n    integer :: kft  ! mutiplicity factor for bottom flux \n    integer :: l    ! help var. \n    integer :: ll\n    integer :: lst\n    integer :: nm   ! help var. \n!\n!! executable statements -------------------------------------------------------\n!\n    kmxsed              => gdp%gderosed%kmxsed\n    !\n    ! vertical advection; particles fall downward\n    !                     no fluxes through free surface\n    !                     no fluxes through bottom sand layer for 'sand'\n    !                     no fluxes through bed for non-'sand'\n    !\n    lst = max(lsal, ltem)\n    do l = 1, lsed\n       ll = lst + l\n       do nm = 1, nmmax\n          if (kfs(nm)==1 .and. kcs(nm)<=2) then\n             do k = kfsmx0(nm), kmxsed(nm, l),-1\n                if (k/=kmxsed(nm, l)) then\n                   kft = 1\n                else\n                   kft = 0\n                endif\n                if (k/=kfsmx0(nm)) then\n                   kfd = 1\n                else\n                   kfd = 0\n                endif\n                cckl(nm, k, ll) = cckl(nm, k, ll) - gsqs(nm)*ws(nm, k, l)  * kfd\n                bbkl(nm, k, ll) = bbkl(nm, k, ll) + gsqs(nm)*ws(nm, k-1, l)* kft\n             enddo\n          endif\n       enddo\n    enddo\nend subroutine z_dif_ws\n"}
{"id": 1123, "subroutine": "subroutine join(str_array, separator, joined)\n  character(len=*), intent(in) :: str_array(:)\n  character(len=*), intent(in) :: separator\n  character(len=*), intent(inout) :: joined\n  integer :: i, joined_len\n  joined_len = 0\n  !! calculate the length of the joined string\n  do i = 1, size(str_array)\n    joined_len = joined_len + len_trim(str_array(i))\n  end do\n  joined_len = joined_len + (size(str_array) - 1) * len(separator)\n  if (len(joined) < joined_len) stop 'utils: join: error given string joined is too short.' \n  joined = trim(adjustl(str_array(1))) \n  do i = 2, size(str_array)\n    joined = trim(adjustl(joined)) // separator // trim(adjustl(str_array(i)))\n  end do  \nend subroutine\n"}
{"id": 1124, "subroutine": "subroutine splitstr(str, delimiterstr, strarr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: delimiterstr\n  character(len=len(str)), dimension(:), allocatable, intent(inout) :: strarr\n  integer :: dim, i \n  integer :: lastpos\n  integer :: step\n  dim = substrcount(str, delimiterstr) + 1\n  allocate(strarr(dim))\n  lastpos = 1\n  do i = 1, dim\n    step = index(str(lastpos:), delimiterstr)\n    if (step /= 0) then\n      strarr(i) = str(lastpos:lastpos + step - 2)\n    else ! last substr\n      strarr(i) = str(lastpos:)\n    end if\n    lastpos = lastpos + step - 1 + len(delimiterstr)\n  end do\nend subroutine\n"}
{"id": 1125, "subroutine": "pure subroutine rotate_vector(x, y, z, nx, ny, nz, angle, xp, yp, zp)\n  implicit none\n  intrinsic dot_product\n  intrinsic cos\n  intrinsic sin\n  real(dp), intent(in) :: x, y, z, nx, ny, nz, angle\n  real(dp), intent(out) :: xp, yp, zp\n  real(dp) :: dotpr, cp, sp\n  real(dp), dimension(3) :: vec1 \n  real(dp), dimension(3) :: vec2 \n  vec1 = (/nx, ny, nz/)\n  vec2 = (/x, y, z/)\n  dotpr = dot_product(vec1, vec2)\n  cp = cos(angle)\n  sp = sin(angle)\n  call crossp(x, y, z, nx, ny, nz, xp, yp, zp)\n  xp = x * cp + nx * dotpr * (1._dp - cp) + xp * sp\n  yp = y * cp + ny * dotpr * (1._dp - cp) + yp * sp\n  zp = z * cp + nz * dotpr * (1._dp - cp) + zp * sp\nend subroutine rotate_vector\n"}
{"id": 1126, "subroutine": "subroutine rotate_tensor(original, old_axes, new_axes, rotated)\n  real(dp), intent(in) :: original(3, 3), old_axes(3, 3), new_axes(3, 3)\n  real(dp), intent(out) :: rotated(3, 3)\n\n  real(dp) :: cosines(3, 3)\n  integer :: a, b, i, j\n\n  do a = 1, 3\n    do i = 1, 3\n      cosines(a, i) = dot_product(new_axes(1:3, a), old_axes(1:3, i)) \n    end do\n  end do\n\n  rotated = 0._dp\n  do a = 1, 3\n  do b = 1, 3\n    do i = 1, 3\n      do j = 1, 3\n        rotated(a, b) = rotated(a, b) + cosines(a, i) * cosines(b, j) * original(i, j)\n      end do\n    end do\n  end do\n  end do\nend subroutine  \n"}
{"id": 1127, "subroutine": "pure subroutine nvec(nx, ny, nz, genstate)\n  !!\n  !! generates a random unit vector (nx, ny, nz). \n  !!\n  !! @see understanding mol. sim. 2nd ed.  frenkel, smit p. 578\n  !!\n  include 'rng.inc'\n  intrinsic sqrt\n  double precision, intent(out) :: nx, ny, nz\n  type(rngstate), intent(inout) :: genstate\n  double precision :: l, u1, u2, s\n  double precision :: r\n  l = 0.0_dp\n  do\n     call rng(genstate, r)\n     u1 = 1._dp - 2._dp * r\n     call rng(genstate, r)\n     u2 = 1._dp - 2._dp * r\n     l = u1 * u1 + u2 * u2\n     if(l <= 1._dp) exit\n  end do\n  s = 2.0_dp * sqrt(1._dp - l)\n  nx = u1 * s\n  ny = u2 * s\n  nz = 1._dp - 2._dp * l\nend subroutine\n"}
{"id": 1128, "subroutine": "pure subroutine xvec2(x, y, z, nx, ny, nz, phi, xp, yp, zp)\n  intrinsic cos\n  intrinsic sin\n  intrinsic dot_product\n  !!\n  !! rotates the vector (x,y,z) into (xp,yp,zp) around axis\n  !! (nx,ny,nz) [unit vector of the direction] through angle phi\n  !! goldstein: classical mechanics 2nd ed., p. 165\n  !!\n  real(dp), intent(in) :: x, y, z\n  real(dp), intent(in) :: nx, ny, nz \n  real(dp), intent(in) :: phi\n  real(dp), intent(out) :: xp, yp, zp\n  real(dp) :: dotp\n  dotp = dot_product((/nx, ny, nz/), (/x, y, z/))\n  call crossp(x, y, z, nx, ny, nz, xp, yp, zp)\n  xp = x * cos(phi) + nx * dotp * (1._dp - cos(phi)) + xp * sin(phi)\n  yp = y * cos(phi) + ny * dotp * (1._dp - cos(phi)) + yp * sin(phi)\n  zp = z * cos(phi) + nz * dotp * (1._dp - cos(phi)) + zp * sin(phi)\nend subroutine\n"}
{"id": 1129, "subroutine": "pure subroutine crossp(ax,ay,az,bx,by,bz,cx,cy,cz)\n  !!\n  !! calculates (ax,ay,az) x (bx,by,bz) = (cz,cy,cz)\n  !!\n  real(dp), intent(in) :: ax, ay, az, bx, by, bz\n  real(dp), intent(out) :: cx, cy, cz\n  cx = ay * bz - az * by\n  cy = az * bx - ax * bz\n  cz = ax * by - ay * bx\nend subroutine\n"}
{"id": 1130, "subroutine": "      subroutine mcpout(name, ik, ntestg, inpci)\n!                                                                      *\n!   this routine controls the computation  and storage of the values   *\n!   and all indices of the angular coefficients                        *\n!                                                                      *\n!                                                                      *\n!                   t  (ab)                                            *\n!                    rs                                                *\n!                                                                      *\n!   k is the multipolarity of a two-particle coulomb integral. a, b,   *\n!   are orbital sequence numbers.  r and s are configuration           *\n!   state function indices.                                            *\n!                                                                      *\n!   call(s) to: [lib92]: alloc, dalloc, tnsrjj                         *\n!               [genmcp]: qsort.                                       *\n!                                                                      *\n!   written by per jonsson                last revision: june 1996     *\n!                                                                      *\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:35:02   1/ 6/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      use vast_kind_param, only: double\n      use parameter_def,   only: nnnw, keyorb\n      use memory_man\n      use foparm_c\n      use mcp_c\n      use prnt_c\n      use syma_c\n      use stat_c\n      use blk_c\n      use orb_c,           only: ncf, nw,nak, iqa\n      use jqjc_c\n      use orbord_c\n      use mcpdata_c\n      use sbdat_c,         only: kamax,nlmax,nakinvii,nakinvff\n!-----------------------------------------------\n!   i n t e r f a c e   b l o c k s\n!-----------------------------------------------\n      use onescalar_i\n      use cord_i\n      use itjpo_i\n      use angdata_i\n      use qqsort_i\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer  :: ik\n      integer, intent(in) :: ntestg\n      integer  :: inpci\n      character  :: name*24\n!-----------------------------------------------\n!   l o c a l   p a r a m e t e r s\n!-----------------------------------------------\n      integer, parameter :: nf = 200\n      integer, parameter :: nvmax = 100\n      integer, parameter :: key = keyorb\n      integer, parameter :: keysq = key*key\n      real(double), parameter :: cutoff = 1.0d-10\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer, dimension(nlmax) :: llistt\n      integer, dimension(nnnw) :: nakinv\n      integer, dimension(nlmax) :: nshl, ninl\n      integer :: i, ntestl, ntest, ka, iopar, j, ncf0, iblk, k, &\n         ja, jb, ibb, ia, ib, lab, jan, jbn, l\n      real(double), dimension(nnnw) :: tshell\n      real(double), dimension(nvmax) :: sc\n      real(double), dimension(20*nlmax*nlmax) :: cirot\n      real(double), dimension(10000) :: evsc\n      logical   :: f0int, lincr, restrt, comp, avail\n      character :: cnum*20, ck*2\n!-----------------------------------------------\n!\n! locals\n!     pointer (pscr, scr(1))\n!     pointer (pciout, ciout(1))\n!\n\n      write (6, *) 'nblock,(ncfblk(i),i=1,nblock)'\n      write (6, *) nblock, (ncfblk(i),i=1,nblock)\n\n      ntestl = 0\n      ntest = max(ntestg,ntestl)\n      ntest = 0\n!\n!   set the rank (zero) and parity (even) for the one-particle\n!   coefficients\n!\n      ka = 0\n      iopar = 1\n!\n!   check if angular data is available. if available read this data.\n!   if not available calculate the data\n!\n      call angdata (name, avail, kamax)\n      write (6, *) 'avail=', avail\n      if (avail) return\n\n      if (ik == 1) then\n         nakinv(:nnnw) = nakinvii(:nnnw)\n      else\n         nakinv(:nnnw) = nakinvff(:nnnw)\n      endif\n\n\n\n      write (6, *) ' open sorted ang. file .tb(nf)', nf\n      j = index(name,' ')\n      open(unit=nf, file=name(1:j-1)//'.tb', status='unknown', form=&\n         'unformatted', position='asis')\n\n      ncf0 = 1\n      do iblk = 1, nblock\n!\n!   open scratchfiles to dump the t coefficients for each kappa\n!\n         do k = 1, kamax\n            open(unit=80 + k, status='unknown', form='unformatted', position=&\n               'asis')\n         end do\n!\n!   initialize the counters for the total number of t coefficients\n!\n         llistt(:nlmax) = 0\n!\n!   ja and jb respectively refer to the initial and final states\n!   in the list of ncf configurations\n!\n         do ja = ncf0, ncfblk(iblk)\n            if (mod(ja,100)==0 .and. ik==1) then\n               write (*, *) ' ja1 =', ja, ja - ncf0 + 1\n            else if (mod(ja,100)==0 .and. ik==2) then\n               write (*, *) ' ja2 =', ja, ja - ncf0 + 1\n            endif\n!\n            do jb = ncf0, ncfblk(iblk)\n!\n!   call the mct package to compute t coefficients\n!\n               if (ntrans == 1) then\n                  comp = .false.\n                  if (ik == 1) then\n                     do ibb = 1, jqj1\n                        if (itjpo(ja) /= itjqj1(ibb)) cycle\n                        comp = .true.\n                     end do\n                  else\n                     do ibb = 1, jqj2\n                        if (itjpo(ja) /= itjqj2(ibb)) cycle\n                        comp = .true.\n                     end do\n                  endif\n               else\n                  comp = .true.\n               endif\n\n\n               if (.not.comp) cycle\n!            write(*,*) ja,jb\n!gg               call tnsrjj (ka, iopar, ja, jb, ia, ib, tshell)\n              call onescalar(ja,jb,ia,ib,tshell)\n               if (ia == 0) cycle\n               if (ia == ib) then\n                  do ia = 1, nw\n!\n!   if t coefficient is greater than zero and the kappa quantum numbers\n!   of the two orbitals are the same dump to file\n!   in a later version use a buffer with a reasonable record length\n!\n                     if (dabs(tshell(ia)) <= cutoff) cycle\n                     llistt(nakinv(ia)) = llistt(nakinv(ia)) + 1\n                     lab = ia*key + ia\n                     write (80 + nakinv(ia)) ja - ncf0 + 1, jb - ncf0 + 1, lab&\n                        , tshell(ia)\n                  end do\n               else\n                  if (dabs(tshell(1))>cutoff .and. nak(ia)==nak(ib)) then\n                     llistt(nakinv(ia)) = llistt(nakinv(ia)) + 1\n                     if (nordii==0 .and. nordff==0) then\n!\n!   experssion for normal orbital ordering\n!\n                        lab = ia*key + ib\n                        jan = ja - ncf0 + 1\n                        jbn = jb - ncf0 + 1\n                     else if (nordii==1 .and. nordff==1) then\n!\n!   experssion for reversed orbital ordering\n!\n                        lab = ib*key + ia\n                        jan = jb - ncf0 + 1\n                        jbn = ja - ncf0 + 1\n                     else\n                        write (*, *) 'something wrong'\n                        stop\n                     endif\n                     write (80 + nakinv(ia)) jan, jbn, lab, tshell(1)\n                  endif\n               endif\n!\n            end do\n         end do\n\n\n!\n!   sort the mcp data into inegral based lists.\n!\n         do l = 1, kamax\n            if (llistt(l) > 0) then\n               call qqsort (l, llistt(l), ik, name, kamax)\n            else\n               if (l == 1) write (nf) ncf, nw, kamax\n               write (nf) llistt(l), llistt(l)\n            endif\n         end do\n!\n!  close the angular files\n!\n         do l = 1, kamax\n            close(l + 80, status='delete')\n         end do\n!\n         ncf0 = ncfblk(iblk) + 1\n      end do\n!\n!   deallocate storage that is no longer required. this was\n!   allocated in lodcsl.\n!\n      call dalloc (iqa, 'iqa', 'mcpout')\n      call dalloc (jqsa, 'jqsa', 'mcpout')\n      call dalloc (jcupa, 'jcupa', 'mcpout')\n      return\n      end subroutine mcpout\n"}
{"id": 1131, "subroutine": "  subroutine read_grid_5d_int8(group, path, array, geo)\n    \n    implicit none\n    \n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(out) :: array(:,:,:)\n    type(grid_geometry_desc),intent(in) :: geo\n    integer(idp), allocatable :: array5d(:,:,:,:,:)\n    integer :: n_cells, n_dust, n_isrf_lam\n\n    character(len=32) :: geometry_id_check\n\n    call mp_read_keyword(group,path, 'geometry', geometry_id_check)\n    if(geometry_id_check.ne.geo%id) then\n       call error(\"read_grid\", \"geometry ids do not match\")\n    end if\n    call mp_read_array_auto(group,path, array5d)\n\n    if(any(is_nan(array5d))) call error(\"read_grid_5d\", \"nan values in 5d array\")\n\n    n_cells = size(array, 1)\n    n_dust = size(array, 2)\n    n_isrf_lam = size(array,3)\n\n    array = reshape(array5d, (/n_cells, n_dust, n_isrf_lam/))\n\n  end subroutine read_grid_5d_int8\n"}
{"id": 1132, "subroutine": "  subroutine read_grid_4d_int8(group, path, array, geo)\n\n    implicit none\n\n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(out) :: array(:,:)\n    type(grid_geometry_desc),intent(in) :: geo\n    integer(idp), allocatable :: array4d(:,:,:,:)\n    integer :: n_cells, n_dust\n\n    character(len=32) :: geometry_id_check\n\n    call mp_read_keyword(group,path, 'geometry', geometry_id_check)\n    if(geometry_id_check.ne.geo%id) then\n       call error(\"read_grid\", \"geometry ids do not match\")\n    end if\n    call mp_read_array_auto(group,path, array4d)\n\n    if(any(is_nan(array4d))) call error(\"read_grid_4d\", \"nan values in 4d array\")\n\n    n_cells = size(array, 1)\n    n_dust = size(array, 2)\n\n    array = reshape(array4d, (/n_cells, n_dust/))\n\n  end subroutine read_grid_4d_int8\n"}
{"id": 1133, "subroutine": "  subroutine read_grid_3d_int8(group, path, array, geo)\n\n    implicit none\n\n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(out) :: array(:)\n    type(grid_geometry_desc),intent(in) :: geo\n    integer(idp), allocatable :: array3d(:, :, :)\n    integer :: n_cells\n\n    character(len=32) :: geometry_id_check\n\n    call mp_read_keyword(group,path, 'geometry', geometry_id_check)\n    if(geometry_id_check.ne.geo%id) then\n       call error(\"read_grid\", \"geometry ids do not match\")\n    end if\n    call mp_read_array_auto(group,path, array3d)\n\n    if(any(is_nan(array3d))) call error(\"read_grid_3d\", \"nan values in 3d array\")\n\n    n_cells = size(array)\n\n    array = reshape(array3d, (/n_cells/))\n\n  end subroutine read_grid_3d_int8\n"}
{"id": 1134, "subroutine": "  subroutine write_grid_5d_int8(group, path, array, geo)\n\n    implicit none\n\n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(in) :: array(:,:,:)\n    type(grid_geometry_desc),intent(in) :: geo\n\n    call mp_write_array(group, path, reshape(array, (/geo%n1, geo%n2, geo%n3, size(array,2), size(array,3)/)))\n    call mp_write_keyword(group, path, 'geometry', geo%id)\n\n  end subroutine write_grid_5d_int8\n"}
{"id": 1135, "subroutine": "  subroutine write_grid_4d_int8(group, path, array, geo)\n\n    implicit none\n\n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(in) :: array(:,:)\n    type(grid_geometry_desc),intent(in) :: geo\n\n    call mp_write_array(group, path, reshape(array, (/geo%n1, geo%n2, geo%n3, size(array,2)/)))\n    call mp_write_keyword(group, path, 'geometry', geo%id)\n\n  end subroutine write_grid_4d_int8\n"}
{"id": 1136, "subroutine": "  subroutine write_grid_3d_int8(group, path, array, geo)\n\n    implicit none\n\n    integer(hid_t), intent(in) :: group\n    character(len=*), intent(in) :: path\n    integer(idp), intent(in) :: array(:)\n    type(grid_geometry_desc),intent(in) :: geo\n\n    call mp_write_array(group,path, reshape(array, (/geo%n1, geo%n2, geo%n3/)))\n    call mp_write_keyword(group,path, 'geometry', geo%id)\n\n  end subroutine write_grid_3d_int8\n"}
{"id": 1137, "subroutine": "subroutine sub(a,b)\n  type t1\n     sequence\n     integer :: value\n  end type t1\n  type t2\n     integer :: value\n     type(t1), pointer :: link\n  end type t2\n  type(t1) :: a\n  type(t2) :: b\n  \n  print *, a%value\n  print *, b%value, b%link%value\n  \nend subroutine sub\n"}
{"id": 1138, "subroutine": "  subroutine multifab_physbc(s,start_scomp,start_bccomp,num_comp,the_bc_level, &\n                             time_in,dx_in,prob_lo_in,prob_hi_in)\n\n    type(multifab) , intent(inout) :: s\n    integer        , intent(in   ) :: start_scomp,start_bccomp,num_comp\n    type(bc_level) , intent(in   ) :: the_bc_level\n    real(kind=dp_t), intent(in   ), optional :: time_in,dx_in(:),prob_lo_in(:),prob_hi_in(:)\n\n    ! local\n    integer                  :: lo(get_dim(s))\n    integer                  :: i,ng,dm,scomp,bccomp\n    real(kind=dp_t), pointer :: sp(:,:,:,:)\n    \n    type(mfiter) :: mfi\n    type(box) :: growntilebox\n    integer :: gtlo(get_dim(s)), gthi(get_dim(s))\n\n    type(bl_prof_timer), save :: bpt\n    \n    call build(bpt,\"multifab_physbc\")\n\n    ng = nghost(s)\n    dm = get_dim(s)\n    \n    !$omp parallel private(mfi,i,growntilebox,gtlo,gthi) &\n    !$omp private(sp,lo,scomp,bccomp)\n\n    call mfiter_build(mfi,s,tiling=.true.)\n\n    do while(next_tile(mfi,i))\n\n       growntilebox = get_growntilebox(mfi,ng)\n       gtlo = lwb(growntilebox)\n       gthi = upb(growntilebox)\n\n       sp => dataptr(s,i)\n       lo = lwb(get_box(s,i))\n       select case (dm)\n       case (2)\n          do scomp = start_scomp,start_scomp+num_comp-1\n             bccomp = start_bccomp + scomp - start_scomp\n             call physbc_2d(sp(:,:,1,scomp), lo, ng, &\n                            the_bc_level%adv_bc_level_array(i,:,:,bccomp),bccomp, &\n                            gtlo,gthi)\n          end do\n       case (3)\n          do scomp = start_scomp,start_scomp+num_comp-1\n             bccomp = start_bccomp + scomp - start_scomp\n             call physbc_3d(sp(:,:,:,scomp), lo, ng, &\n                            the_bc_level%adv_bc_level_array(i,:,:,bccomp),bccomp, &\n                            gtlo,gthi)\n          end do\n       end select\n    end do\n    !$omp end parallel\n \n    call destroy(bpt)\n\n  end subroutine multifab_physbc\n"}
{"id": 1139, "subroutine": "  subroutine physbc_2d(s,glo,ng,bc,icomp,gtlo,gthi)\n\n    use bl_constants_module\n    use bc_module\n\n    integer        , intent(in   ) :: glo(:),ng,gtlo(:),gthi(:)\n    real(kind=dp_t), intent(inout) :: s(glo(1)-ng:,glo(2)-ng:)\n    integer        , intent(in   ) :: bc(:,:)\n    integer        , intent(in   ) :: icomp\n\n    ! local variables\n    integer :: i,j,ghi(2)\n\n    ghi(1) = glo(1) + size(s,dim=1) - (2*ng+1)\n    ghi(2) = glo(2) + size(s,dim=2) - (2*ng+1)\n\n    if (gtlo(1)+ng .eq. glo(1)) then\n       if (bc(1,1) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2)) = u_bc(1,1)\n          if (icomp.eq.2) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2)) = v_bc(1,1)\n          if (icomp.eq.3) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2)) = rho_bc(1,1)\n          if (icomp.eq.4) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2)) = trac_bc(1,1)\n       else if (bc(1,1) .eq. foextrap) then\n          do j = gtlo(2), gthi(2)\n             s(gtlo(1):gtlo(1)+ng-1,j) = s(gtlo(1)+ng,j)\n          end do\n       else if (bc(1,1) .eq. hoextrap) then\n          do j = gtlo(2), gthi(2)\n             s(gtlo(1):gtlo(1)+ng-1,j) = eighth* &\n                  ( 15.0_dp_t*s(gtlo(1)+ng  ,j) &\n                   -10.0_dp_t*s(gtlo(1)+ng+1,j) &\n                   + 3.0_dp_t*s(gtlo(1)+ng+2,j) )\n          end do\n       else if (bc(1,1) .eq. reflect_even) then\n          do j = gtlo(2), gthi(2)\n             do i = 1, ng\n                s(gtlo(1)+ng-i,j) = s(gtlo(1)+ng+i-1,j)\n             end do\n          end do\n       else if (bc(1,1) .eq. reflect_odd) then\n          do j = gtlo(2), gthi(2)\n             do i = 1, ng\n                s(gtlo(1)+ng-i,j) = -s(gtlo(1)+ng+i-1,j)\n             end do\n          end do\n       else if (bc(1,1) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(1,1) = ',bc(1,1)\n          call bl_error('bc(1,1) = not yet supported')\n       end if\n    end if\n\n    if (gthi(1)-ng .eq. ghi(1)) then\n       if (bc(1,2) .eq. ext_dir) then\n          if (icomp.eq.1) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2)) = u_bc(1,2)\n          if (icomp.eq.2) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2)) = v_bc(1,2)\n          if (icomp.eq.3) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2)) = rho_bc(1,2)\n          if (icomp.eq.4) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2)) = trac_bc(1,2)\n       else if (bc(1,2) .eq. foextrap) then\n          do j = gtlo(2), gthi(2)\n             s(gthi(1)-ng+1:gthi(1),j) = s(gthi(1)-ng,j)\n          end do\n       else if (bc(1,2) .eq. hoextrap) then\n          do j = gtlo(2), gthi(2)\n             s(gthi(1)-ng+1:gthi(1),j) = eighth* &\n                  ( 15.0_dp_t * s(gthi(1)-ng  ,j) &\n                   -10.0_dp_t * s(gthi(1)-ng-1,j) &\n                   + 3.0_dp_t * s(gthi(1)-ng-2,j) )\n          end do\n       else if (bc(1,2) .eq. reflect_even) then\n          do j = gtlo(2), gthi(2)\n             do i = 1, ng\n                s(gthi(1)-ng+i,j) = s(gthi(1)-ng-i+1,j)\n             end do\n          end do\n       else if (bc(1,2) .eq. reflect_odd) then\n          do j = gtlo(2), gthi(2)\n             do i = 1, ng\n                s(gthi(1)-ng+i,j) = -s(gthi(1)-ng-i+1,j)\n             end do\n          end do\n       else if (bc(1,2) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(1,2) = ',bc(1,2)\n          call bl_error('bc(1,2) = not yet supported')\n       end if\n    end if\n\n    if (gtlo(2)+ng .eq. glo(2)) then\n       if (bc(2,1) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1) = u_bc(2,1)\n          if (icomp.eq.2) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1) = v_bc(2,1)\n          if (icomp.eq.3) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1) = rho_bc(2,1)\n          if (icomp.eq.4) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1) = trac_bc(2,1)\n       else if (bc(2,1) .eq. foextrap) then\n          do i = gtlo(1), gthi(1)\n             s(i,gtlo(2):gtlo(2)+ng-1) = s(i,gtlo(2)+ng)\n          end do\n       else if (bc(2,1) .eq. hoextrap) then\n          do i = gtlo(1), gthi(1)\n             s(i,gtlo(2):gtlo(2)+ng-1) = eighth* &\n                 ( 15.0_dp_t*s(i,gtlo(2)+ng) &\n                  -10.0_dp_t*s(i,gtlo(2)+ng+1) &\n                  + 3.0_dp_t*s(i,gtlo(2)+ng+2) )\n          end do\n       else if (bc(2,1) .eq. reflect_even) then\n          do i = gtlo(1), gthi(1)\n             do j = 1, ng\n                s(i,gtlo(2)+ng-j) = s(i,gtlo(2)+ng+j-1)\n             end do\n          end do\n       else if (bc(2,1) .eq. reflect_odd) then\n          do i = gtlo(1), gthi(1)\n             do j = 1, ng\n                s(i,gtlo(2)+ng-j) = -s(i,gtlo(2)+ng+j-1)\n             end do\n          end do\n       else if (bc(2,1) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(2,1) = ',bc(2,1)\n          call bl_error('bc(2,1) = not yet supported')\n       end if\n    end if\n\n    if (gthi(2)-ng .eq. ghi(2)) then\n       if (bc(2,2) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2)) = u_bc(2,2)\n          if (icomp.eq.2) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2)) = v_bc(2,2)\n          if (icomp.eq.3) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2)) = rho_bc(2,2)\n          if (icomp.eq.4) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2)) = trac_bc(2,2)\n       else if (bc(2,2) .eq. foextrap) then\n          do i = gtlo(1), gthi(1)\n             s(i,gthi(2)-ng+1:gthi(2)) = s(i,gthi(2)-ng)\n          end do\n       else if (bc(2,2) .eq. hoextrap) then\n          do i = gtlo(1), gthi(1)\n             s(i,gthi(2)-ng+1:gthi(2)) = eighth* &\n                 ( 15.0_dp_t*s(i,gthi(2)-ng) &\n                  -10.0_dp_t*s(i,gthi(2)-ng-1) &\n                  + 3.0_dp_t*s(i,gthi(2)-ng-2) )\n          end do\n       else if (bc(2,2) .eq. reflect_even) then\n          do i = gtlo(1), gthi(1)\n             do j = 1, ng\n                s(i,gthi(2)-ng+j) = s(i,gthi(2)-ng-j+1)\n             end do\n          end do\n       else if (bc(2,2) .eq. reflect_odd) then\n          do i = gtlo(1), gthi(1)\n             do j = 1, ng\n                s(i,gthi(2)-ng+j) = -s(i,gthi(2)-ng-j+1)\n             end do\n          end do\n       else if (bc(2,2) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(2,2) = ',bc(2,2)\n          call bl_error('bc(2,2) = not yet supported')\n       end if\n    end if\n\n  end subroutine physbc_2d\n"}
{"id": 1140, "subroutine": "  subroutine physbc_3d(s,glo,ng,bc,icomp,gtlo,gthi)\n\n    use bl_constants_module\n    use bc_module\n\n    integer        , intent(in   ) :: glo(:),ng,gtlo(:),gthi(:)\n    real(kind=dp_t), intent(inout) :: s(glo(1)-ng:, glo(2)-ng:, glo(3)-ng:)\n    integer        , intent(in   ) :: bc(:,:)\n    integer        , intent(in   ) :: icomp\n\n    ! local variables\n    integer :: i,j,k,ghi(3)\n\n    ghi(1) = glo(1) + size(s,dim=1) - (2*ng+1)\n    ghi(2) = glo(2) + size(s,dim=2) - (2*ng+1)\n    ghi(3) = glo(3) + size(s,dim=3) - (2*ng+1)\n\n    if (gtlo(1)+ng .eq. glo(1)) then\n       if (bc(1,1) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2),gtlo(3):gthi(3)) = u_bc(1,1)\n          if (icomp.eq.2) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2),gtlo(3):gthi(3)) = v_bc(1,1)\n          if (icomp.eq.3) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2),gtlo(3):gthi(3)) = w_bc(1,1)\n          if (icomp.eq.4) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2),gtlo(3):gthi(3)) = rho_bc(1,1)\n          if (icomp.eq.5) s(gtlo(1):gtlo(1)+ng-1,gtlo(2):gthi(2),gtlo(3):gthi(3)) = trac_bc(1,1)\n       else if (bc(1,1) .eq. foextrap) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                s(gtlo(1):gtlo(1)+ng-1,j,k) = s(gtlo(1)+ng,j,k)\n             end do\n          end do\n       else if (bc(1,1) .eq. hoextrap) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                s(gtlo(1):gtlo(1)+ng-1,j,k) = &\n                     ( 15.0_dp_t * s(gtlo(1)+ng  ,j,k) &\n                     -10.0_dp_t * s(gtlo(1)+ng+1,j,k) &\n                     + 3.0_dp_t * s(gtlo(1)+ng+2,j,k) ) * eighth\n             end do\n          end do\n       else if (bc(1,1) .eq. reflect_even) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                do i = 1,ng\n                   s(gtlo(1)+ng-i,j,k) = s(gtlo(1)+ng+i-1,j,k)\n                end do\n             end do\n          end do\n       else if (bc(1,1) .eq. reflect_odd) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                do i = 1,ng\n                   s(gtlo(1)+ng-i,j,k) = -s(gtlo(1)+ng+i-1,j,k)\n                end do\n             end do\n          end do\n       else if (bc(1,1) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(1,1) = ',bc(1,1)\n          call bl_error('bc(1,1) = not yet supported')\n       end if\n    end if\n\n    if (gthi(1)-ng .eq. ghi(1)) then\n       if (bc(1,2) .eq. ext_dir) then\n          if (icomp.eq.1) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2),gtlo(3):gthi(3)) = u_bc(1,2)\n          if (icomp.eq.2) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2),gtlo(3):gthi(3)) = v_bc(1,2)\n          if (icomp.eq.3) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2),gtlo(3):gthi(3)) = w_bc(1,2)\n          if (icomp.eq.4) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2),gtlo(3):gthi(3)) = rho_bc(1,2)\n          if (icomp.eq.5) s(gthi(1)-ng+1:gthi(1),gtlo(2):gthi(2),gtlo(3):gthi(3)) = trac_bc(1,2)\n       else if (bc(1,2) .eq. foextrap) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                s(gthi(1)-ng+1:gthi(1),j,k) = s(gthi(1)-ng,j,k)\n             end do\n          end do\n       else if (bc(1,2) .eq. hoextrap) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                s(gthi(1)-ng+1:gthi(1),j,k) = &\n                     ( 15.0_dp_t * s(gthi(1)-ng  ,j,k) &\n                     -10.0_dp_t * s(gthi(1)-ng-1,j,k) &\n                     + 3.0_dp_t * s(gthi(1)-ng-2,j,k) ) * eighth\n             end do\n          end do\n       else if (bc(1,2) .eq. reflect_even) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                do i = 1,ng\n                   s(gthi(1)-ng+i,j,k) = s(gthi(1)-ng-i+1,j,k)\n                end do\n             end do\n          end do\n       else if (bc(1,2) .eq. reflect_odd) then\n          do k = gtlo(3),gthi(3)\n             do j = gtlo(2),gthi(2)\n                do i = 1,ng\n                   s(gthi(1)-ng+i,j,k) = -s(gthi(1)-ng-i+1,j,k)\n                end do\n             end do\n          end do\n       else if (bc(1,2) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(1,2) = ',bc(1,2)\n          call bl_error('bc(1,2) = not yet supported')\n       end if\n    end if\n\n   if (gtlo(2)+ng .eq. glo(2)) then\n      if (bc(2,1) .eq. ext_dir) then\n         if (icomp.eq.1) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1,gtlo(3):gthi(3)) = u_bc(2,1)\n         if (icomp.eq.2) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1,gtlo(3):gthi(3)) = v_bc(2,1)\n         if (icomp.eq.3) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1,gtlo(3):gthi(3)) = w_bc(2,1)\n         if (icomp.eq.4) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1,gtlo(3):gthi(3)) = rho_bc(2,1)\n         if (icomp.eq.5) s(gtlo(1):gthi(1),gtlo(2):gtlo(2)+ng-1,gtlo(3):gthi(3)) = trac_bc(2,1)\n      else if (bc(2,1) .eq. foextrap) then\n         do k = gtlo(3),gthi(3)\n            do i = gtlo(1),gthi(1)\n               s(i,gtlo(2):gtlo(2)+ng-1,k) = s(i,gtlo(2)+ng,k)\n            end do\n         end do\n      else if (bc(2,1) .eq. hoextrap) then\n         do k = gtlo(3),gthi(3)\n            do i = gtlo(1),gthi(1)\n               s(i,gtlo(2):gtlo(2)+ng-1,k) = &\n                    ( 15.0_dp_t * s(i,gtlo(2)+ng  ,k) &\n                    -10.0_dp_t * s(i,gtlo(2)+ng+1,k) &\n                    + 3.0_dp_t * s(i,gtlo(2)+ng+2,k) ) * eighth\n            end do\n         end do\n      else if (bc(2,1) .eq. reflect_even) then\n         do k = gtlo(3),gthi(3)\n            do i = gtlo(1),gthi(1)\n               do j = 1,ng\n                  s(i,gtlo(2)+ng-j,k) = s(i,gtlo(2)+ng+j-1,k)\n               end do\n            end do\n         end do\n      else if (bc(2,1) .eq. reflect_odd) then\n         do k = gtlo(3),gthi(3)\n            do i = gtlo(1),gthi(1)\n               do j = 1,ng\n                  s(i,gtlo(2)+ng-j,k) = -s(i,gtlo(2)+ng+j-1,k)\n               end do\n            end do\n         end do\n      else if (bc(2,1) .eq. interior) then\n         ! do nothing\n      else \n         print *,'bc(2,1) = ',bc(2,1)\n         call bl_error('bc(2,1) = not yet supported')\n      end if\n    end if\n\n    if (gthi(2)-ng .eq. ghi(2)) then\n       if (bc(2,2) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2),gtlo(3):gthi(3)) = u_bc(2,2)\n          if (icomp.eq.2) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2),gtlo(3):gthi(3)) = v_bc(2,2)\n          if (icomp.eq.3) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2),gtlo(3):gthi(3)) = w_bc(2,2)\n          if (icomp.eq.4) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2),gtlo(3):gthi(3)) = rho_bc(2,2)\n          if (icomp.eq.5) s(gtlo(1):gthi(1),gthi(2)-ng+1:gthi(2),gtlo(3):gthi(3)) = trac_bc(2,2)\n       else if (bc(2,2) .eq. foextrap) then\n          do k = gtlo(3),gthi(3)\n             do i = gtlo(1),gthi(1)\n                s(i,gthi(2)-ng+1:gthi(2),k) = s(i,gthi(2)-ng,k)\n             end do\n          end do\n       else if (bc(2,2) .eq. hoextrap) then\n          do k = gtlo(3),gthi(3)\n             do i = gtlo(1),gthi(1)\n                s(i,gthi(2)-ng+1:gthi(2),k) = &\n                    ( 15.0_dp_t * s(i,gthi(2)-ng  ,k) &\n                     -10.0_dp_t * s(i,gthi(2)-ng-1,k) &\n                     + 3.0_dp_t * s(i,gthi(2)-ng-2,k) ) * eighth\n             end do\n          end do\n       else if (bc(2,2) .eq. reflect_even) then\n          do k = gtlo(3),gthi(3)\n             do i = gtlo(1),gthi(1)\n                do j = 1,ng\n                   s(i,gthi(2)-ng+j,k) = s(i,gthi(2)-ng-j+1,k)\n                end do\n             end do\n          end do\n       else if (bc(2,2) .eq. reflect_odd) then\n          do k = gtlo(3),gthi(3)\n             do i = gtlo(1),gthi(1)\n                do j = 1,ng\n                   s(i,gthi(2)-ng+j,k) = -s(i,gthi(2)-ng-j+1,k)\n                end do\n             end do\n          end do\n       else if (bc(2,2) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(2,2) = ',bc(2,2)\n          call bl_error('bc(2,2) = not yet supported')\n       end if\n    end if\n\n    if (gtlo(3)+ng .eq. glo(3)) then\n       if (bc(3,1) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gtlo(3):gtlo(3)+ng-1) = u_bc(3,1)\n          if (icomp.eq.2) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gtlo(3):gtlo(3)+ng-1) = v_bc(3,1)\n          if (icomp.eq.3) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gtlo(3):gtlo(3)+ng-1) = w_bc(3,1)\n          if (icomp.eq.4) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gtlo(3):gtlo(3)+ng-1) = rho_bc(3,1)\n          if (icomp.eq.5) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gtlo(3):gtlo(3)+ng-1) = trac_bc(3,1)\n       else if (bc(3,1) .eq. foextrap) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                s(i,j,gtlo(3):gtlo(3)+ng-1) = s(i,j,gtlo(3)+ng)\n             end do\n          end do\n       else if (bc(3,1) .eq. hoextrap) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                s(i,j,gtlo(3):gtlo(3)+ng-1) = &\n                    ( 15.0_dp_t * s(i,j,gtlo(3)+ng  ) &\n                     -10.0_dp_t * s(i,j,gtlo(3)+ng+1) &\n                     + 3.0_dp_t * s(i,j,gtlo(3)+ng+2) ) * eighth\n             end do\n          end do\n       else if (bc(3,1) .eq. reflect_even) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                do k = 1,ng\n                   s(i,j,gtlo(3)+ng-k) = s(i,j,gtlo(3)+ng+k-1)\n                end do\n             end do\n          end do\n       else if (bc(3,1) .eq. reflect_odd) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                do k = 1,ng\n                   s(i,j,gtlo(3)+ng-k) = -s(i,j,gtlo(3)+ng+k-1)\n                end do\n             end do\n          end do\n       else if (bc(3,1) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(3,1) = ',bc(3,1)\n          call bl_error('bc(3,1) = not yet supported')\n       end if\n    end if\n\n    if (gthi(3)-ng .eq. ghi(3)) then\n       if (bc(3,2) .eq. ext_dir) then\n          if (icomp.eq.1) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gthi(3)-ng+1:gthi(3)) = u_bc(3,2)\n          if (icomp.eq.2) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gthi(3)-ng+1:gthi(3)) = v_bc(3,2)\n          if (icomp.eq.3) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gthi(3)-ng+1:gthi(3)) = w_bc(3,2)\n          if (icomp.eq.4) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gthi(3)-ng+1:gthi(3)) = rho_bc(3,2)\n          if (icomp.eq.5) s(gtlo(1):gthi(1),gtlo(2):gthi(2),gthi(3)-ng+1:gthi(3)) = trac_bc(3,2)\n       else if (bc(3,2) .eq. foextrap) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                s(i,j,gthi(3)-ng+1:gthi(3)) = s(i,j,gthi(3)-ng)\n             end do\n          end do\n       else if (bc(3,2) .eq. hoextrap) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                s(i,j,gthi(3)-ng+1:gthi(3)) = &\n                    ( 15.0_dp_t * s(i,j,gthi(3)-ng  ) &\n                     -10.0_dp_t * s(i,j,gthi(3)-ng-1) &\n                     + 3.0_dp_t * s(i,j,gthi(3)-ng-2) ) * eighth\n             end do\n          end do\n       else if (bc(3,2) .eq. reflect_even) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                do k = 1,ng\n                   s(i,j,gthi(3)-ng+k) = s(i,j,gthi(3)-ng-k+1)\n                end do\n             end do\n          end do\n       else if (bc(3,2) .eq. reflect_odd) then\n          do j = gtlo(2),gthi(2)\n             do i = gtlo(1),gthi(1)\n                do k = 1,ng\n                   s(i,j,gthi(3)-ng+k) = -s(i,j,gthi(3)-ng-k+1)\n                end do\n             end do\n          end do\n       else if (bc(3,2) .eq. interior) then\n          ! do nothing\n       else \n          print *,'bc(3,2) = ',bc(3,2)\n          call bl_error('bc(3,2) = not yet supported')\n       end if\n    end if\n\n  end subroutine physbc_3d\n"}
{"id": 1141, "subroutine": "  module subroutine slabrange(maxzn,ximat,yimat,zimat,sourcemlat,xnrange,ynrange,gridflag)\n    real(wp), intent(in) :: maxzn\n    real(wp), dimension(:,:,:), intent(in) :: ximat,yimat,zimat\n    real(wp), intent(in) :: sourcemlat\n    real(wp), dimension(2), intent(out) :: xnrange,ynrange     !for min and max\n    integer, intent(in) :: gridflag\n  end subroutine slabrange\n"}
{"id": 1142, "subroutine": "  module subroutine  range2inds(ranges,zn,xnall,ynall,indices)\n    real(wp), dimension(6), intent(in) :: ranges\n    real(wp), dimension(:), intent(in) :: zn,xnall,ynall\n    integer, dimension(6), intent(out) :: indices\n  end subroutine range2inds\n"}
{"id": 1143, "subroutine": "  module subroutine dneu_root2workers(paramall,tag,slabsizes,indx,param)\n    real(wp), dimension(:,:,:), intent(in) :: paramall\n    integer, intent(in) :: tag\n    integer, dimension(0:,:), intent(in) :: slabsizes\n    integer, dimension(0:,:), intent(in) :: indx\n    real(wp), dimension(:,:,:), intent(inout) :: param\n  end subroutine dneu_root2workers\n"}
{"id": 1144, "subroutine": "  module subroutine dneu_workers_from_root(tag,param)\n    integer, intent(in) :: tag\n    real(wp), dimension(:,:,:), intent(inout) :: param\n  end subroutine dneu_workers_from_root\n"}
{"id": 1145, "subroutine": "  subroutine init_neu3d(self,cfg,sourcedir,x,dtmodel,dtdata,ymd,utsec)\n    class(neutraldata3d), intent(inout) :: self\n    type(gemini_cfg), intent(in) :: cfg\n    character(*), intent(in) :: sourcedir\n    class(curvmesh), intent(in) :: x\n    real(wp), intent(in) :: dtmodel,dtdata\n    integer, dimension(3), intent(in) :: ymd            ! target date of initiation\n    real(wp), intent(in) :: utsec                       ! target time of initiation\n    integer :: lc1,lc2,lc3\n    character(:), allocatable :: strname    ! allow auto-allocate for strings\n\n    ! force 3d interpolation regardless of working subarray size\n    self%flagforcenative=.true.\n\n    ! tell our object where its data are and give the dataset a name\n    call self%set_source(sourcedir)\n    strname='neutral perturbations (3d)'\n    call self%set_name(strname)\n    call self%set_cadence(dtdata)\n    self%flagdoinput=cfg%flagdneu/=0\n\n    ! set sizes, we have 7 arrays all 3d (irrespective of 2d vs. 3d neutral input).  for 3d neutral input\n    !    the situation is more complicated that for other datasets because you cannot compute the number of\n    !    source grid points for each worker until you have root compute the entire grid and slice everything up\n    allocate(self%lc1,self%lc2,self%lc3)                                     ! these are pointers, even though scalar\n    self%lzn=>self%lc1; self%lxn=>self%lc2; self%lyn=>self%lc3;              ! these referenced while reading size and grid data\n    call self%set_coordsi(cfg,x)                   ! since this preceeds init_storage it must do the work of allocating some spaces\n    call self%load_sizeandgrid_neu3d(cfg)          ! cfg needed to form source neutral grid\n    call self%set_sizes( &\n             0, &          ! number scalar parts to dataset\n             0, 0, 0, &    ! number 1d data along each axis\n             0, 0, 0, &    ! number 2d data\n             7, &          ! number 3d datasets\n             x)          ! the main purpose of this is to set the number of 3d datasets (other params already set)\n\n    ! allocate space for arrays, note for neutrals some of this has already happened so there is an overloaded procedure\n    call self%init_storage()\n\n    ! set aliases to point to correct source data arrays\n    self%dno=>self%data3d(:,:,:,1)\n    self%dnn2=>self%data3d(:,:,:,2)\n    self%dno2=>self%data3d(:,:,:,3)\n    self%dvnz=>self%data3d(:,:,:,4)\n    self%dvnx=>self%data3d(:,:,:,5)\n    self%dvny=>self%data3d(:,:,:,6)\n    self%dtn=>self%data3d(:,:,:,7)\n\n    ! call to base class procedure to set pointers for prev,now,next\n    call self%setptrs_grid()\n\n    ! initialize previous data so we get a correct starting value\n    self%dnoiprev=0\n    self%dnn2iprev=0\n    self%dno2iprev=0\n    self%dvn1iprev=0\n    self%dvn2iprev=0\n    self%dvn3iprev=0\n    self%dtniprev=0\n\n    ! set to start time of simulation - not needed since assigned by update on first call.  fixme: a bit messy\n    !self%ymdref(:,1)=cfg%ymd0; self%ymdref(:,2)=cfg%ymd0;\n    !self%utsecref(1)=cfg%utsec0; self%utsecref(2)=cfg%utsec0;\n\n    ! prime input data\n    call self%prime_data(cfg,x,dtmodel,ymd,utsec)\n  end subroutine init_neu3d\n"}
{"id": 1146, "subroutine": "  subroutine init_storage(self)\n    class(neutraldata3d), intent(inout) :: self\n    integer :: lc1,lc2,lc3\n    integer :: lc1i,lc2i,lc3i\n    integer :: l0d\n    integer :: l1dax1,l1dax2,l1dax3\n    integer :: l2dax23,l2dax12,l2dax13\n    integer :: l3d\n\n    ! check sizes are set\n    if (.not. self%flagsizes) error stop 'inpudata:init_storage(); must set sizes before allocations...'\n\n    ! local size variables for convenience\n    lc1=self%lc1; lc2=self%lc2; lc3=self%lc3;\n    lc1i=self%lc1i; lc2i=self%lc2i; lc3i=self%lc3i;\n    l0d=self%l0d\n    l1dax1=self%l1dax1; l1dax2=self%l1dax2; l1dax3=self%l1dax3;\n    l2dax23=self%l2dax23; l2dax12=self%l2dax12; l2dax13=self%l2dax13;\n    l3d=self%l3d\n\n    ! note: type extensions are reponsible for zeroing out any arrays they will use...\n\n    ! input data coordinate arrays are set by load_gridandsize()\n\n    ! allocate target coords, for neutral3d the standard set (coord1i, etc.) are done in set_coordsi()\n    allocate(self%coord1iax1(lc1i),self%coord2iax2(lc2i),self%coord3iax3(lc3i))\n    allocate(self%coord2iax23(lc2i*lc3i),self%coord3iax23(lc2i*lc3i))\n    allocate(self%coord1iax13(lc1i*lc3i),self%coord3iax13(lc1i*lc3i))\n    allocate(self%coord1iax12(lc1i*lc2i),self%coord2iax12(lc1i*lc2i))\n\n    ! allocate object arrays for input data at a reference time.  fixme: do we even need to store this perm. or can be local to\n    ! load_data?\n    allocate(self%data0d(l0d))\n    allocate(self%data1dax1(lc1,l1dax1), self%data1dax2(lc2,l1dax2), self%data1dax3(lc3,l1dax3))\n    allocate(self%data2dax23(lc2,lc3,l2dax23), self%data2dax12(lc1,lc2,l2dax12), self%data2dax13(lc1,lc3,l2dax13))\n    allocate(self%data3d(lc1,lc2,lc3,l3d))\n\n    ! allocate object arrays for interpolation sites at reference times\n    allocate(self%data0di(l0d,2))\n    allocate(self%data1dax1i(lc1i,l1dax1,2), self%data1dax2i(lc2i,l1dax2,2), self%data1dax3i(lc3i,l1dax3,2))\n    allocate(self%data2dax23i(lc2i,lc3i,l2dax23,2), self%data2dax12i(lc1i,lc2i,l2dax12,2), self%data2dax13i(lc1i,lc3i,l2dax13,2))\n    allocate(self%data3di(lc1i,lc2i,lc3i,l3d,2))\n\n    ! allocate object arrays at interpolation sites for current time.  fixme: do we even need to store permanently?\n    allocate(self%data0dinow(l0d))\n    allocate(self%data1dax1inow(lc1i,l1dax1), self%data1dax2inow(lc2i,l1dax2), self%data1dax3inow(lc3i,l1dax3))\n    allocate(self%data2dax23inow(lc2i,lc3i,l2dax23), self%data2dax12inow(lc1i,lc2i,l2dax12), self%data2dax13inow(lc1i,lc3i,l2dax13))\n    allocate(self%data3dinow(lc1i,lc2i,lc3i,l3d))\n\n    self%flagalloc=.true.\n  end subroutine init_storage\n"}
{"id": 1147, "subroutine": "  subroutine load_size_neu3d(self)\n    class(neutraldata3d), intent(inout) :: self\n\n  end subroutine load_size_neu3d\n"}
{"id": 1148, "subroutine": "  subroutine load_grid_neu3d(self)\n    class(neutraldata3d), intent(inout) :: self\n\n  end subroutine load_grid_neu3d\n"}
{"id": 1149, "subroutine": "  subroutine load_sizeandgrid_neu3d(self,cfg)\n    class(neutraldata3d), intent(inout) :: self\n    type(gemini_cfg), intent(in) :: cfg\n    real(wp), dimension(:), allocatable :: xn,yn             ! for root to break off pieces of the entire grid array\n    integer :: ix1,ix2,ix3,ihorzn,izn,iid,ierr\n    integer :: lxntmp,lyntmp                                   ! local copies for root, eventually these need to be stored in object\n    real(wp) :: maxzn\n    real(wp), dimension(2) :: xnrange,ynrange                ! these eventually get stored in extents\n    integer, dimension(6) :: indices                         ! these eventually get stored in indx\n    integer :: ixn,iyn\n    integer :: lxn,lyn\n    real(wp) :: meanxn,meanyn\n\n    if (mpi_cfg%myid==0) then    !root must establish the size of the grid based on input file and distribute to workers\n      print '(a,/,a)', 'read neutral size from:', self%sourcedir\n      call get_simsize3(self%sourcedir, lx1=self%lxnall, lx2all=self%lynall, lx3all=self%lzn)\n      print *, 'neutral data has lx,ly,lz size:  ',self%lxnall,self%lynall,self%lzn, &\n                   ' with spacing dx,dy,dz',cfg%dxn,cfg%drhon,cfg%dzn\n      if (self%lxnall < 1 .or. self%lynall < 1 .or. self%lzn < 1) then\n        write(stderr,*) 'error: reading ' // self%sourcedir\n        error stop 'neutral:gridproj_dneu3d: grid size must be strictly positive'\n      endif\n\n      ! allocate space for target coordinate and bind alias\n      allocate(self%coord1(self%lzn))\n      self%zn=>self%coord1\n      allocate(self%xnall(self%lxnall))\n      allocate(self%ynall(self%lynall))\n\n      !calculate the z grid (same for all) and distribute to workers so we can figure out their x-y slabs\n      print*, '...creating vertical grid and sending to workers...'\n      self%zn=[ ((real(izn, wp)-1)*cfg%dzn, izn=1,self%lzn) ]    !root calculates and distributes but this is the same for all workers - assmes that the max neutral grid extent in altitude is always less than the plasma grid (should almost always be true)\n      maxzn=maxval(self%zn)\n      do iid=1,mpi_cfg%lid-1\n        call mpi_send(self%lzn,1,mpi_integer,iid,tag%lz,mpi_comm_world,ierr)\n        call mpi_send(self%zn,self%lzn,mpi_realprec,iid,tag%zn,mpi_comm_world,ierr)\n      end do\n\n      !define a neutral grid (input data) x,y extent by assuming that the spacing is constant\n      self%ynall=[ ((real(iyn, wp)-1)*cfg%drhon, iyn=1,self%lynall) ]\n      meanyn=sum(self%ynall,1)/size(self%ynall,1)\n      self%ynall=self%ynall-meanyn     !the neutral grid should be centered on zero for a cartesian interpolation\n      self%xnall=[ ((real(ixn, wp)-1)*cfg%dxn, ixn=1,self%lxnall) ]\n      meanxn=sum(self%xnall,1)/size(self%xnall,1)\n      self%xnall=self%xnall-meanxn     !the neutral grid should be centered on zero for a cartesian interpolation\n      print *, 'created full neutral grid with y,z extent:',minval(self%xnall),maxval(self%xnall),minval(self%ynall), &\n                    maxval(self%ynall),minval(self%zn),maxval(self%zn)\n\n      ! calculate the extents of root grid using max altitude specified for the neutral grid\n      call slabrange(maxzn,self%ximat,self%yimat,self%zimat,cfg%sourcemlat,xnrange,ynrange,gridflag)\n      allocate(self%extents(0:mpi_cfg%lid-1,6),self%indx(0:mpi_cfg%lid-1,6),self%slabsizes(0:mpi_cfg%lid-1,2))\n      self%extents(0,1:6)=[0._wp,maxzn,xnrange(1),xnrange(2),ynrange(1),ynrange(2)]\n\n      !receive extents of each of the other workers: extents(mpi_cfg%lid,6)\n      print*, 'receiving xn and yn ranges from workers...'\n      do iid=1,mpi_cfg%lid-1\n        call mpi_recv(xnrange,2,mpi_realprec,iid,tag%xnrange,mpi_comm_world,mpi_status_ignore,ierr)\n        call mpi_recv(ynrange,2,mpi_realprec,iid,tag%ynrange,mpi_comm_world,mpi_status_ignore,ierr)\n        self%extents(iid,1:6)=[0._wp,maxzn,xnrange(1),xnrange(2),ynrange(1),ynrange(2)]     !need to store values as xnrange overwritten for each worker\n        print*, 'subgrid extents:  ',iid,self%extents(iid,:)\n      end do\n\n      !find index into into neutral arrays for each worker:  indx(mpi_cfg%lid,6)\n      print*, 'root grid check:  ',self%ynall(1),self%ynall(self%lynall)\n      print*, 'converting ranges to indices...'\n      do iid=0,mpi_cfg%lid-1\n        call range2inds(self%extents(iid,1:6),self%zn,self%xnall,self%ynall,indices)\n        self%indx(iid,1:6)=indices\n        print*, 'subgrid indices',iid,self%indx(iid,:)\n      end do\n\n      !send each worker the sizes for their particular chunk (all different) and send worker that grid chunk\n      print*,'sending sizes and xn,yn subgrids to workers...'\n      do iid=1,mpi_cfg%lid-1\n        lxn=self%indx(iid,4)-self%indx(iid,3)+1\n        lyn=self%indx(iid,6)-self%indx(iid,5)+1\n        self%slabsizes(iid,1:2)=[lxn,lyn]\n        call mpi_send(lyn,1,mpi_integer,iid,tag%lrho,mpi_comm_world,ierr)\n        call mpi_send(lxn,1,mpi_integer,iid,tag%lx,mpi_comm_world,ierr)\n        allocate(xn(lxn),yn(lyn))\n        xn=self%xnall(self%indx(iid,3):self%indx(iid,4))\n        yn=self%ynall(self%indx(iid,5):self%indx(iid,6))\n        call mpi_send(xn,lxn,mpi_realprec,iid,tag%xn,mpi_comm_world,ierr)\n        call mpi_send(yn,lyn,mpi_realprec,iid,tag%yn,mpi_comm_world,ierr)\n        deallocate(xn,yn)\n      end do\n\n      !have root store its part to the full neutral grid\n      print*, 'root is picking out its own subgrid...'\n      self%lxn=self%indx(0,4)-self%indx(0,3)+1\n      self%lyn=self%indx(0,6)-self%indx(0,5)+1\n      self%slabsizes(0,1:2)=[self%lxn,self%lyn]\n\n      ! allocate space and bind alias\n      allocate(self%coord2(self%lxn),self%coord3(self%lyn))\n      self%xn=>self%coord2; self%yn=>self%coord3;        ! input data coordinates\n\n      ! store source coordinates\n      self%xn=self%xnall(self%indx(0,3):self%indx(0,4))\n      self%yn=self%ynall(self%indx(0,5):self%indx(0,6))\n    else                 !workers\n      !get the z-grid from root so we know what the max altitude we have to deal with will be\n      call mpi_recv(self%lzn,1,mpi_integer,0,tag%lz,mpi_comm_world,mpi_status_ignore,ierr)\n\n      ! allocate space for target coordinate and bind alias\n      allocate(self%coord1(self%lzn))\n      self%zn=>self%coord1\n\n      ! receive data from root\n      call mpi_recv(self%zn,self%lzn,mpi_realprec,0,tag%zn,mpi_comm_world,mpi_status_ignore,ierr)\n      maxzn=maxval(self%zn)\n\n      !calculate the extent of my grid\n      call slabrange(maxzn,self%ximat,self%yimat,self%zimat,cfg%sourcemlat,xnrange,ynrange,gridflag)\n\n      !send ranges to root\n      call mpi_send(xnrange,2,mpi_realprec,0,tag%xnrange,mpi_comm_world,ierr)\n      call mpi_send(ynrange,2,mpi_realprec,0,tag%ynrange,mpi_comm_world,ierr)\n\n      !receive my sizes from root, allocate then receive my pieces of the grid\n      call mpi_recv(self%lxn,1,mpi_integer,0,tag%lx,mpi_comm_world,mpi_status_ignore,ierr)\n      call mpi_recv(self%lyn,1,mpi_integer,0,tag%lrho,mpi_comm_world,mpi_status_ignore,ierr)\n\n      ! at this point we can allocate space for the source coordinates and bind aliases as needed\n      allocate(self%coord2(self%lxn),self%coord3(self%lyn))\n      self%xn=>self%coord2; self%yn=>self%coord3;        ! input data coordinates\n\n      ! recieve data from root\n      call mpi_recv(self%xn,self%lxn,mpi_realprec,0,tag%xn,mpi_comm_world,mpi_status_ignore,ierr)\n      call mpi_recv(self%yn,self%lyn,mpi_realprec,0,tag%yn,mpi_comm_world,mpi_status_ignore,ierr)\n    end if\n\n    self%flagdatasize=.true.\n  end subroutine load_sizeandgrid_neu3d\n"}
{"id": 1150, "subroutine": "  subroutine set_coordsi_neu3d(self,cfg,x)\n    class(neutraldata3d), intent(inout) :: self\n    type(gemini_cfg), intent(in) :: cfg\n    class(curvmesh), intent(in) :: x\n    real(wp) :: theta1,phi1,theta2,phi2,gammarads,theta3,phi3,gamma1,gamma2,phip\n    real(wp) :: xp,yp\n    real(wp), dimension(3) :: ezp,eyp,tmpvec,exprm\n    real(wp) :: tmpsca\n    integer :: ix1,ix2,ix3,iyn,izn,ixn,iid,ierr\n\n\n    ! space for coordinate sites and projections in neutraldata3d object\n    allocate(self%coord1i(x%lx1*x%lx2*x%lx3),self%coord2i(x%lx1*x%lx2*x%lx3),self%coord3i(x%lx1*x%lx2*x%lx3))\n    self%zi=>self%coord1i; self%xi=>self%coord2i; self%yi=>self%coord3i;     ! coordinates of interpolation sites\n    allocate(self%ximat(x%lx1,x%lx2,x%lx3),self%yimat(x%lx1,x%lx2,x%lx3),self%zimat(x%lx1,x%lx2,x%lx3))\n    allocate(self%proj_ezp_e1(x%lx1,x%lx2,x%lx3),self%proj_ezp_e2(x%lx1,x%lx2,x%lx3),self%proj_ezp_e3(x%lx1,x%lx2,x%lx3))\n    allocate(self%proj_eyp_e1(x%lx1,x%lx2,x%lx3),self%proj_eyp_e2(x%lx1,x%lx2,x%lx3),self%proj_eyp_e3(x%lx1,x%lx2,x%lx3))\n    allocate(self%proj_exp_e1(x%lx1,x%lx2,x%lx3),self%proj_exp_e2(x%lx1,x%lx2,x%lx3),self%proj_exp_e3(x%lx1,x%lx2,x%lx3))\n\n    !neutral source locations specified in input file, here referenced by spherical magnetic coordinates.\n    phi1=cfg%sourcemlon*pi/180\n    theta1=pi/2 - cfg%sourcemlat*pi/180\n\n    !convert plasma simulation grid locations to z,rho values to be used in interoplation.  altitude ~ zi; lat/lon --> rhoi.  also compute unit vectors and projections\n    if (mpi_cfg%myid==0) then\n      print *, 'computing alt,radial distance values for plasma grid and completing rotations'\n    end if\n\n    self%zimat=x%alt     !vertical coordinate is just altitude array already stored in grid object\n    do ix3=1,x%lx3\n      do ix2=1,x%lx2\n        do ix1=1,x%lx1\n          ! interpolation based on geomag\n          theta2=x%theta(ix1,ix2,ix3)                    !field point zenith angle\n\n          !print*, ' center ns set',shape(self%zi),shape(self%zimat),theta2,x%theta(ix1,ix2,ix3)\n\n          if (x%lx2/=1) then\n            phi2=x%phi(ix1,ix2,ix3)                      !field point azimuth, full 3d calculation\n          else\n            phi2=phi1                                    !assume the longitude is the samem as the source in 2d, i.e. assume the source epicenter is in the meridian of the grid\n          end if\n\n          !we need a phi locationi (not spherical phi, but azimuth angle from epicenter), as well, but not for interpolation - just for doing vector rotations\n          theta3=theta2\n          phi3=phi1\n          gamma1=cos(theta2)*cos(theta3)+sin(theta2)*sin(theta3)*cos(phi2-phi3)\n          if (gamma1 > 1) then     !handles weird precision issues in 2d\n            gamma1 = 1\n          else if (gamma1 < -1) then\n            gamma1 = -1\n          end if\n          gamma1=acos(gamma1)\n\n          gamma2=cos(theta1)*cos(theta3)+sin(theta1)*sin(theta3)*cos(phi1-phi3)\n          if (gamma2 > 1) then     !handles weird precision issues in 2d\n            gamma2= 1\n          else if (gamma2 < -1) then\n            gamma2= -1\n          end if\n          gamma2=acos(gamma2)\n          xp=re*gamma1\n          yp=re*gamma2     !this will likely always be positive, since we are using center of earth as our origin, so this should be interpreted as distance as opposed to displacement\n\n          ! coordinates from distances\n          if (theta3>theta1) then       !place distances in correct quadrant, here field point (theta3=theta2) is is southward of source point (theta1), whreas yp is distance northward so throw in a negative sign\n            yp= -yp            !do we want an abs here to be safe\n          end if\n          if (phi2<phi3) then     !assume we aren't doing a global grid otherwise need to check for wrapping, here field point (phi2) less than source point (phi3=phi1)\n            xp= -xp\n          end if\n\n          self%ximat(ix1,ix2,ix3)=xp     !eastward distance\n          self%yimat(ix1,ix2,ix3)=yp     !northward distance\n\n          !projections from neutural grid vectors to plasma grid vectors\n          !projection factors for mapping from axisymmetric to dipole (go ahead and compute projections so we don't have to do it repeatedly as sim runs\n          ezp=x%er(ix1,ix2,ix3,:)\n\n          tmpvec=ezp*x%e2(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_ezp_e2(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=ezp*x%e1(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_ezp_e1(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=ezp*x%e3(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)    !should be zero, but leave it general for now\n          self%proj_ezp_e3(ix1,ix2,ix3)=tmpsca\n\n          eyp= -x%etheta(ix1,ix2,ix3,:)\n\n          tmpvec=eyp*x%e1(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_eyp_e1(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=eyp*x%e2(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_eyp_e2(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=eyp*x%e3(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_eyp_e3(ix1,ix2,ix3)=tmpsca\n\n          exprm=x%ephi(ix1,ix2,ix3,:)   !for 3d interpolation need to have a unit vector/projection onto x-direction (longitude)\n\n          tmpvec=exprm*x%e1(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_exp_e1(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=exprm*x%e2(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_exp_e2(ix1,ix2,ix3)=tmpsca\n\n          tmpvec=exprm*x%e3(ix1,ix2,ix3,:)\n          tmpsca=sum(tmpvec)\n          self%proj_exp_e3(ix1,ix2,ix3)=tmpsca\n        end do\n      end do\n    end do\n\n    !assign values for flat lists of grid points\n    if (mpi_cfg%myid==0) then\n      print*, '...packing interpolation target points...'\n    end if\n    self%zi=pack(self%zimat,.true.)     !create a flat list of grid points to be used by interpolation functions\n    self%yi=pack(self%yimat,.true.)\n    self%xi=pack(self%ximat,.true.)\n\n    ! fixme: do we need to have the new grid code clear its unit vectors?  or maybe this isn't a huge waste of memory???\n    if (mpi_cfg%myid==0) then\n      print*, '...clearing out unit vectors (after projections)...'\n    end if\n    !call clear_unitvecs(x)\n\n    if(mpi_cfg%myid==0) then\n      print*, 'interpolation coords:  ',minval(self%zi),maxval(self%zi), &\n                                        minval(self%xi),maxval(self%xi), &\n                                        minval(self%yi),maxval(self%yi)\n      print*, 'projection checking:  ',minval(self%proj_exp_e1),maxval(self%proj_exp_e1), &\n                                       minval(self%proj_exp_e2),maxval(self%proj_exp_e2), &\n                                       minval(self%proj_exp_e3),maxval(self%proj_exp_e3)\n    end if\n\n    self%flagcoordsi=.true.\n  end subroutine set_coordsi_neu3d\n"}
{"id": 1151, "subroutine": "  subroutine load_data_neu3d(self,t,dtmodel,ymdtmp,utsectmp)\n    class(neutraldata3d), intent(inout) :: self\n    real(wp), intent(in) :: t,dtmodel\n    integer, dimension(3), intent(inout) :: ymdtmp\n    real(wp), intent(inout) :: utsectmp\n    integer :: iid,ierr\n    integer :: lhorzn                        !number of horizontal grid points\n    real(wp), dimension(:,:,:), allocatable :: paramall\n    type(hdf5_file) :: hf\n    character(:), allocatable :: fn\n\n    lhorzn=self%lyn\n    ymdtmp = self%ymdref(:,2)\n    utsectmp = self%utsecref(2)\n    call dateinc(self%dt,ymdtmp,utsectmp)                !get the date for \"next\" params\n\n    !read in the data from file\n    if (mpi_cfg%myid==0) then    !root\n      !in the 3d case we cannot afford to send full grid data and need to instead use neutral subgrid splits defined earlier\n      allocate(paramall(self%lzn,self%lxnall,self%lynall))     ! space to store a single neutral input parameter\n\n      !print*, '  date and time (neutral3d):  ',ymdtmp,utsectmp\n\n      fn=date_filename(self%sourcedir,ymdtmp,utsectmp)\n      fn=get_filename(fn)\n      if (debug) print *, 'read neutral 3d data from file: ',fn\n      if (suffix(fn) == '.h5') then\n        call hf%open(fn, action='r')\n      else\n        error stop '3d neutral input only supported for hdf5 files; please regenerate input'\n      end if\n\n      call hf%read('/dn0all', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dnoall: non-finite value(s)'\n      if (debug) print*, 'min/max values for dnoall:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dno,self%slabsizes,self%indx,self%dno)\n      call hf%read('/dnn2all', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dnn2all: non-finite value(s)'\n      if (debug) print*, 'min/max values for dnn2all:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dnn2,self%slabsizes,self%indx,self%dnn2)\n      call hf%read('/dno2all', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dno2all: non-finite value(s)'\n      if (debug) print*, 'min/max values for dno2all:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dno2,self%slabsizes,self%indx,self%dno2)\n      call hf%read('/dtnall', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dtnall: non-finite value(s)'\n      if (debug) print*, 'min/max values for dtnall:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dtn,self%slabsizes,self%indx,self%dtn)\n      call hf%read('/dvnrhoall', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dvnrhoall: non-finite value(s)'\n      if (debug) print*, 'min/max values for dvnrhoall:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dvnrho,self%slabsizes,self%indx,self%dvny)\n      call hf%read('/dvnzall', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dvnzall: non-finite value(s)'\n      if (debug) print*, 'min/max values for dvnzall:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dvnz,self%slabsizes,self%indx,self%dvnz)\n      call hf%read('/dvnxall', paramall)\n      if (.not. all(ieee_is_finite(paramall))) error stop 'dvnxall: non-finite value(s)'\n      if (debug) print*, 'min/max values for dvnxall:  ',minval(paramall),maxval(paramall)\n      call dneu_root2workers(paramall,tag%dvnx,self%slabsizes,self%indx,self%dvnx)\n\n      call hf%close()\n      deallocate(paramall)\n    else     !workers\n      !receive a subgrid copy of the data from root\n      call dneu_workers_from_root(tag%dno,self%dno)\n      call dneu_workers_from_root(tag%dnn2,self%dnn2)\n      call dneu_workers_from_root(tag%dno2,self%dno2)\n      call dneu_workers_from_root(tag%dtn,self%dtn)\n      call dneu_workers_from_root(tag%dvnrho,self%dvny)\n      call dneu_workers_from_root(tag%dvnz,self%dvnz)\n      call dneu_workers_from_root(tag%dvnx,self%dvnx)\n    end if\n\n\n    if (mpi_cfg%myid==mpi_cfg%lid/2 .and. debug) then\n      print *, 'min/max values for dno:  ',mpi_cfg%myid,minval(self%dno),maxval(self%dno)\n      print *, 'min/max values for dnn:  ',mpi_cfg%myid,minval(self%dnn2),maxval(self%dnn2)\n      print *, 'min/max values for dno2:  ',mpi_cfg%myid,minval(self%dno2),maxval(self%dno2)\n      print *, 'min/max values for dvnx:  ',mpi_cfg%myid,minval(self%dvnx),maxval(self%dvnx)\n      print *, 'min/max values for dvnrho:  ',mpi_cfg%myid,minval(self%dvny),maxval(self%dvny)\n      print *, 'min/max values for dvnz:  ',mpi_cfg%myid,minval(self%dvnz),maxval(self%dvnz)\n      print *, 'min/max values for dtn:  ',mpi_cfg%myid,minval(self%dtn),maxval(self%dtn)\n    !  print*, 'coordinate ranges:  ',minval(zn),maxval(zn),minval(rhon),maxval(rhon),minval(zi),maxval(zi),minval(rhoi),maxval(rhoi)\n    end if\n  end subroutine load_data_neu3d\n"}
{"id": 1152, "subroutine": "  subroutine update(self,cfg,dtmodel,t,x,ymd,utsec)\n    class(neutraldata3d), intent(inout) :: self\n    type(gemini_cfg), intent(in) :: cfg\n    real(wp), intent(in) :: dtmodel             ! need both model and input data time stepping\n    real(wp), intent(in) :: t                   ! simulation absoluate time for which perturabation is to be computed\n    class(curvmesh), intent(in) :: x            ! mesh object\n    integer, dimension(3), intent(in) :: ymd    ! date for which we wish to calculate perturbations\n    real(wp), intent(in) :: utsec               ! ut seconds for which we with to compute perturbations\n\n    ! execute a basic update\n    call self%update_simple(cfg,dtmodel,t,x,ymd,utsec)\n\n    ! fixme: more efficient to rotate the winds only when interpolations are done...\n    ! now we need to rotate velocity fields following interpolation (they are magnetic enu prior to this step)\n    call self%rotate_winds()\n\n    if (mpi_cfg%myid==mpi_cfg%lid/2 .and. debug) then\n      print*, ''\n      print*, 'neutral data size:  ',mpi_cfg%myid,self%lzn,self%lxn,self%lyn\n      print*, 'neutral data time:  ',ymd,utsec\n      print*, ''\n      print *, 'min/max values for dnoinext:  ',mpi_cfg%myid,minval(self%dnoinext),maxval(self%dnoinext)\n      print *, 'min/max values for dnninext:  ',mpi_cfg%myid,minval(self%dnn2inext),maxval(self%dnn2inext)\n      print *, 'min/max values for dno2inext:  ',mpi_cfg%myid,minval(self%dno2inext),maxval(self%dno2inext)\n      print *, 'min/max values for dvn1inext:  ',mpi_cfg%myid,minval(self%dvn1inext),maxval(self%dvn1inext)\n      print *, 'min/max values for dvn2inext:  ',mpi_cfg%myid,minval(self%dvn2inext),maxval(self%dvn2inext)\n      print *, 'min/max values for dvn3inext:  ',mpi_cfg%myid,minval(self%dvn3inext),maxval(self%dvn3inext)\n      print *, 'min/max values for dtninext:  ',mpi_cfg%myid,minval(self%dtninext),maxval(self%dtninext)\n      print*, ''\n      print *, 'min/max values for dnoinow:  ',mpi_cfg%myid,minval(self%dnoinow),maxval(self%dnoinow)\n      print *, 'min/max values for dnninow:  ',mpi_cfg%myid,minval(self%dnn2inow),maxval(self%dnn2inow)\n      print *, 'min/max values for dno2inow:  ',mpi_cfg%myid,minval(self%dno2inow),maxval(self%dno2inow)\n      print *, 'min/max values for dvn1inow:  ',mpi_cfg%myid,minval(self%dvn1inow),maxval(self%dvn1inow)\n      print *, 'min/max values for dvn2inow:  ',mpi_cfg%myid,minval(self%dvn2inow),maxval(self%dvn2inow)\n      print *, 'min/max values for dvn3inow:  ',mpi_cfg%myid,minval(self%dvn3inow),maxval(self%dvn3inow)\n      print *, 'min/max values for dtninow:  ',mpi_cfg%myid,minval(self%dtninow),maxval(self%dtninow)\n    end if\n  end subroutine update\n"}
{"id": 1153, "subroutine": "  subroutine rotate_winds(self)\n    class(neutraldata3d), intent(inout) :: self\n    integer :: ix1,ix2,ix3\n    real(wp) :: vnx,vny,vnz\n\n    ! do rotations one grid point at a time to cut down on temp storage needed\n    do ix3=1,self%lc3i\n      do ix2=1,self%lc2i\n        do ix1=1,self%lc1i\n          vnz=self%dvn1inow(ix1,ix2,ix3)\n          vnx=self%dvn2inow(ix1,ix2,ix3)\n          vny=self%dvn3inow(ix1,ix2,ix3)\n          self%dvn1inow(ix1,ix2,ix3)=vnz*self%proj_ezp_e1(ix1,ix2,ix3) + vnx*self%proj_exp_e1(ix1,ix2,ix3) + &\n                                        vny*self%proj_eyp_e1(ix1,ix2,ix3)\n          self%dvn2inow(ix1,ix2,ix3)=vnz*self%proj_ezp_e2(ix1,ix2,ix3) + vnx*self%proj_exp_e2(ix1,ix2,ix3) + &\n                                        vny*self%proj_eyp_e2(ix1,ix2,ix3)\n          self%dvn3inow(ix1,ix2,ix3)=vnz*self%proj_ezp_e3(ix1,ix2,ix3) + vnx*self%proj_exp_e3(ix1,ix2,ix3) + &\n                                        vny*self%proj_eyp_e3(ix1,ix2,ix3)\n        end do\n      end do\n    end do\n  end subroutine rotate_winds\n"}
{"id": 1154, "subroutine": "  subroutine destructor(self)\n    type(neutraldata3d) :: self\n\n    ! deallocate arrays from base inputdata class\n    call self%dissociate_pointers()\n\n    ! null pointers specific to parent neutraldata class\n    call self%dissociate_neutral_pointers()\n\n    ! now deallocate arrays specific to this extension\n    deallocate(self%proj_ezp_e1,self%proj_ezp_e2,self%proj_ezp_e3)\n    deallocate(self%proj_eyp_e1,self%proj_eyp_e2,self%proj_eyp_e3)\n    deallocate(self%proj_exp_e1,self%proj_exp_e2,self%proj_exp_e3)\n    deallocate(self%ximat,self%yimat,self%zimat)\n\n    ! root has some extra data\n    if (mpi_cfg%myid==0) then\n      deallocate(self%extents,self%indx,self%slabsizes)\n      deallocate(self%xnall,self%ynall)\n    end if\n\n    ! set pointers to null\n    nullify(self%xi,self%yi,self%zi);\n    nullify(self%xn,self%yn,self%zn);\n    nullify(self%dno,self%dnn2,self%dno2,self%dvnz,self%dvnx,self%dvny,self%dtn)\n  end subroutine destructor\n"}
{"id": 1155, "subroutine": "subroutine mpir_keyval_set_proxy(keyval, attr_copy_proxy, attr_delete_proxy) bind(c, name=\"mpir_keyval_set_proxy\")\n    use :: iso_c_binding, only : c_int, c_funptr\n    integer(c_int), value, intent(in) :: keyval\n    type(c_funptr), value, intent(in) :: attr_copy_proxy, attr_delete_proxy\n\nend subroutine mpir_keyval_set_proxy\n"}
{"id": 1156, "subroutine": "subroutine mpir_grequest_set_lang_fortran(request) bind(c, name=\"mpir_grequest_set_lang_f77\")\n    use :: mpi_c_interface_types, only : c_request\n    integer(c_request), value, intent(in) :: request\n\nend subroutine mpir_grequest_set_lang_fortran\n"}
{"id": 1157, "subroutine": "subroutine mpir_fortran_string_f2c(fstring, cstring)\n    implicit none\n    character(len=*), intent(in) :: fstring\n    character(kind=c_char), intent(out) :: cstring(:)\n    integer :: i, j\n    logical :: met_non_blank\n\n    ! trim the leading and trailing blank characters\n    j = 1\n    met_non_blank = .false.\n    do i = 1, len_trim(fstring)\n        if (met_non_blank) then\n            cstring(j) = fstring(i:i)\n            j = j + 1\n        else if (fstring(i:i) /= ' ') then\n            met_non_blank = .true.\n            cstring(j) = fstring(i:i)\n            j = j + 1\n        end if\n    end do\n\n    cstring(j) = c_null_char\nend subroutine mpir_fortran_string_f2c\n"}
{"id": 1158, "subroutine": "subroutine mpir_fortran_string_c2f(cstring, fstring)\n    implicit none\n    character(kind=c_char), intent(in) :: cstring(:)\n    character(len=*), intent(out) :: fstring\n    integer :: i, j, length\n\n    i = 1\n    do while (cstring(i) /= c_null_char)\n        fstring(i:i) = cstring(i)\n        i = i + 1\n    end do\n\n    ! zero out the trailing characters\n    length = len(fstring)\n    do j = i, length\n        fstring(j:j) = ' '\n    end do\nend subroutine mpir_fortran_string_c2f\n"}
{"id": 1159, "subroutine": "  subroutine wrf_debug(errnum, error_message)\n    implicit none\n    integer :: errnum\n    character(len=*) error_message\n\n!bloss    write(*,*) 'error number = ', errnum\n    write(*,*) error_message\n  end subroutine wrf_debug\n"}
{"id": 1160, "subroutine": "  subroutine  clcrhsx_pimp(ux,uy,uz,rhsx,histxold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(out)::rhsx\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histxold\n    \n    ! locals    \n    integer::im,ic,ip,jc,jm,jp,km,kc,kp,ierror\n    real(rk)::qdx1,qdx3,h11,h12,h13,sucaj,s3tot,s3tot1,dp1ns,dpmdxns\n    real(rk)::d11q1,d22q1,d33q1,dcq13,conved1,gradp1,interpy1,interpy2,interpy3,interpy4\n    \n    s3tot=zero\n    qdx1=quarter*rdx\n    qdx3=quarter*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1;kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1;jp=jc+1\n        sucaj=half*rdyp(jc)\n        interpy1= yinterpcoe(jm); interpy2=one-interpy1  \n        interpy3= yinterpcoe(jc); interpy4=one-interpy3            \n        do ic=ystart(1),yend(1)\n          im=ic-1;ip=ic+1\n\n          h11=( (ux(ip,jc,kc)+ux(ic,jc,kc))* (ux(ip,jc,kc)+ux(ic,jc,kc))  &\n               -(ux(ic,jc,kc)+ux(im,jc,kc))* (ux(ic,jc,kc)+ux(im,jc,kc)) )*qdx1\n          h12=( (uy(ic,jp,kc)+uy(im,jp,kc))* (interpy3*ux(ic,jc,kc) +interpy4*ux(ic,jp,kc))  &\n               -(uy(ic,jc,kc)+uy(im,jc,kc))* (interpy1*ux(ic,jm,kc) +interpy2*ux(ic,jc,kc)) )*sucaj           \n          h13=( (uz(ic,jc,kp)+uz(im,jc,kp))* (ux(ic,jc,kp)+ux(ic,jc,kc))  &\n               -(uz(ic,jc,kc)+uz(im,jc,kc))* (ux(ic,jc,kc)+ux(ic,jc,km)) )*qdx3\n                \n          d11q1= (ux(ip,jc,kc)-two*ux(ic,jc,kc)+ux(im,jc,kc))*rdx2\n          d22q1= ap2c(jc)*ux(ic,jp,kc) + ac2c(jc)*ux(ic,jc,kc)+ am2c(jc)*ux(ic,jm,kc)                \n          d33q1= ap3c(kc)*ux(ic,jc,kp) + ac3c(kc)*ux(ic,jc,kc)+ am3c(kc)*ux(ic,jc,km)\n          dcq13= d11q1+d33q1\n             \n          gradp1= (pressure(ic,jc,kc)-pressure(im,jc,kc))*rdx\n#if defined cfddem || defined cfdacm\n          s3tot=s3tot+ux(ic,jc,kc)*dyp(jc)\n#else\n          s3tot=s3tot+(dcq13+d22q1)*dyp(jc)\n#endif\n#ifndef cfddem\n          conved1= -h11-h12-h13 + xnu*dcq13 + gravity(1)\n#else\n          conved1= -h11-h12-h13 + xnu*dcq13 + gravity(1)+half*(fpforce_x(ic,jc,kc)+fpforce_x(im,jc,kc))\n#endif\n          rhsx(ic,jc,kc)=pmgamma*conved1+ pmtheta*histxold(ic,jc,kc)- pmalpha*gradp1+ two*pmbeta*d22q1\n          histxold(ic,jc,kc)=conved1\n        enddo\n      enddo\n    enddo\n  \n    ! in dp1ns there is the mean pressure gradient to keep constant mass\n#if defined cfddem || defined cfdacm\n    if(isuxconst) then\n      call mpi_allreduce(s3tot,s3tot1,1,real_type,mpi_sum,mpi_comm_world,ierror)\n      s3tot1=s3tot1/(real(nxc*nzc,kind=rk))/yly\n      dpmdxns= ubulk - s3tot1\n\n      dp1ns  = pmalphac* dpmdxns\n      do kc=ystart(3),yend(3)\n        do jc=ystart(2),yend(2)\n          do ic=ystart(1),yend(1)\n            rhsx(ic,jc,kc)=rhsx(ic,jc,kc)+ dp1ns\n          enddo\n        enddo\n      enddo\n      prgradaver = prgradaver+ dpmdxns * pmalphac/dt\n    endif\n#else\n    if(isuxconst) then\n      call mpi_allreduce(s3tot,s3tot1,1,real_type,mpi_sum,mpi_comm_world,ierror)\n      dpmdxns= xnu*s3tot1/(real(nxc*nzc,kind=rk))/yly\n      dp1ns  = pmalpha* dpmdxns\n      do kc=ystart(3),yend(3)\n        do jc=ystart(2),yend(2)\n          do ic=ystart(1),yend(1)\n            rhsx(ic,jc,kc)=rhsx(ic,jc,kc)- dp1ns\n          enddo\n        enddo\n      enddo\n      prgradaver = prgradaver+ dpmdxns * pmalphac\n    endif\n#endif\n  end subroutine clcrhsx_pimp\n"}
{"id": 1161, "subroutine": "  subroutine  clcrhsx_pimp_les(ux,uy,uz,rhsx,histxold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(out)::rhsx\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histxold\n    \n    ! locals    \n    integer::im,ic,ip,jc,jm,jp,km,kc,kp,ierror\n    real(rk)::qdx1,qdx3,h11,h12,h13,sucaj,s3tot,s3tot1,dp1ns,dpmdxns\n    real(rk)::d11q1,d22q1,d33q1,dcq13,conved1,gradp1\n    real(rk)::visa,visb,visc,visd,sgs1,sgs2,sgs3\n    \n    s3tot=zero\n    qdx1=quarter*rdx\n    qdx3=quarter*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1\n      kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1\n        jp=jc+1\n        sucaj=quarter*rdyp(jc)            \n        do ic=ystart(1),yend(1)\n          im=ic-1\n          ip=ic+1\n          h11=( (ux(ip,jc,kc)+ux(ic,jc,kc))* (ux(ip,jc,kc)+ux(ic,jc,kc))  &\n               -(ux(ic,jc,kc)+ux(im,jc,kc))* (ux(ic,jc,kc)+ux(im,jc,kc)) )*qdx1\n\n          h12=( (uy(ic,jp,kc)+uy(im,jp,kc))* (ux(ic,jp,kc)+ux(ic,jc,kc))  &\n               -(uy(ic,jc,kc)+uy(im,jc,kc))* (ux(ic,jc,kc)+ux(ic,jm,kc)) )*sucaj            \n          h13=( (uz(ic,jc,kp)+uz(im,jc,kp))* (ux(ic,jc,kp)+ux(ic,jc,kc))  &\n               -(uz(ic,jc,kc)+uz(im,jc,kc))* (ux(ic,jc,kc)+ux(ic,jc,km)) )*qdx3\n\n          visa=quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jm,kc)+nut(im,jm,kc))\n          visb=quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jp,kc)+nut(im,jp,kc))\n          visc=quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jc,km)+nut(im,jc,km))\n          visd=quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jc,kp)+nut(im,jc,kp))\n          sgs1=rdx2*(nut(ic,jc,kc)*(ux(ip,jc,kc)-ux(ic,jc,kc))-nut(im,jc,kc)*(ux(ic,jc,kc)-ux(im,jc,kc)))\n          sgs2=rdx*rdyp(jc)*(visb*(uy(ic,jp,kc)-uy(im,jp,kc))-visa*(uy(ic,jc,kc)-uy(im,jc,kc)))\n          sgs3=rdx*rdz     *(visd*(uz(ic,jc,kp)-uz(im,jc,kp))-visc*(uz(ic,jc,kc)-uz(im,jc,kc)))\n                \n          d11q1= sgs1\n          d22q1= ap2c(jc)*visb*(ux(ic,jp,kc)-ux(ic,jc,kc))-am2c(jc)*visa*(ux(ic,jc,kc)-ux(ic,jm,kc))\n          d33q1= ap3c(kc)*visd*(ux(ic,jc,kp)-ux(ic,jc,kc))-am3c(kc)*visc*(ux(ic,jc,kc)-ux(ic,jc,km))\n          dcq13= d11q1+d33q1\n                \n          gradp1= (pressure(ic,jc,kc)-pressure(im,jc,kc))*rdx\n#if defined cfddem || defined cfdacm\n          s3tot=s3tot+ux(ic,jc,kc)*dyp(jc)\n#else\n          s3tot=s3tot+(dcq13+d22q1)*dyp(jc)\n#endif              \n#ifndef cfddem\n          conved1= -h11-h12-h13 +sgs1+sgs2+sgs3+dcq13+gravity(1)\n#else\n          conved1= -h11-h12-h13 +sgs1+sgs2+sgs3+dcq13+gravity(1)+half*(fpforce_x(ic,jc,kc)+fpforce_x(im,jc,kc))\n#endif\n          rhsx(ic,jc,kc)=pmgamma*conved1+ pmtheta*histxold(ic,jc,kc)- pmalpha*gradp1+ two*pmbetat*d22q1\n          histxold(ic,jc,kc)=conved1\n        enddo\n      enddo\n    enddo\n  \n    ! in dp1ns there is the mean pressure gradient to keep constant mass  \n#if defined cfddem || defined cfdacm\n    if(isuxconst) then\n      call mpi_allreduce(s3tot,s3tot1,1,real_type,mpi_sum,mpi_comm_world,ierror)\n      s3tot1=s3tot1/(real(nxc*nzc,kind=rk))/yly\n      dpmdxns= ubulk - s3tot1\n\n      dp1ns  = pmalphac* dpmdxns\n      do kc=ystart(3),yend(3)\n        do jc=ystart(2),yend(2)\n          do ic=ystart(1),yend(1)\n            rhsx(ic,jc,kc)=rhsx(ic,jc,kc)+ dp1ns\n          enddo\n        enddo\n      enddo\n      prgradaver = prgradaver+ dpmdxns * pmalphac/dt\n    endif\n#else\n    if(isuxconst) then\n      call mpi_allreduce(s3tot,s3tot1,1,real_type,mpi_sum,mpi_comm_world,ierror)\n      dpmdxns= s3tot1/(real(nxc*nzc,kind=rk))/yly\n      dp1ns  = pmalpha* dpmdxns\n      do kc=ystart(3),yend(3)\n        do jc=ystart(2),yend(2)\n          do ic=ystart(1),yend(1)\n            rhsx(ic,jc,kc)=rhsx(ic,jc,kc)- dp1ns\n          enddo\n        enddo\n      enddo\n      prgradaver = prgradaver+ dpmdxns * pmalphac\n    endif\n#endif\n  end subroutine clcrhsx_pimp_les\n"}
{"id": 1162, "subroutine": "  subroutine  clcrhsy_pimp(ux,uy,uz,rhsy,histyold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure \n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(out)::rhsy\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histyold\n   \n    ! locals \n    integer::im,ic,ip,jc,jm,jp,km,kc,kp\n    real(rk)::hdx1,hdx3,h21,h22,h23,sucac,qsucac\n    real(rk)::d11q2,d22q2,d33q2,dcq13,conved2,gradp2,interpy1,interpy2     \n    \n    hdx1=half*rdx\n    hdx3=half*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1; kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1; jp=jc+1\n        sucac = rdyc(jc)\n        qsucac= quarter*sucac\n        interpy1= yinterpcoe(jm); interpy2=one-interpy1\n        do ic=ystart(1),yend(1)\n          im=ic-1; ip=ic+1\n\n          h21=( (interpy1*ux(ip,jm,kc)+interpy2*ux(ip,jc,kc))* (uy(ip,jc,kc)+uy(ic,jc,kc)) &\n               -(interpy1*ux(ic,jm,kc)+interpy2*ux(ic,jc,kc))* (uy(ic,jc,kc)+uy(im,jc,kc)) )*hdx1\n          h22=( (uy(ic,jp,kc)+uy(ic,jc,kc))* (uy(ic,jp,kc)+uy(ic,jc,kc)) &\n               -(uy(ic,jc,kc)+uy(ic,jm,kc))* (uy(ic,jc,kc)+uy(ic,jm,kc)) )*qsucac\n          h23=( (interpy1*uz(ic,jm,kp)+interpy2*uz(ic,jc,kp))* (uy(ic,jc,kp)+uy(ic,jc,kc)) &\n               -(interpy1*uz(ic,jm,kc)+interpy2*uz(ic,jc,kc))* (uy(ic,jc,kc)+uy(ic,jc,km)) )*hdx3\n                \n          d11q2= ap1c(ic)*uy(ip,jc,kc)+ac1c(ic)*uy(ic,jc,kc)+am1c(ic)*uy(im,jc,kc)\n          d22q2= ap2p(jc)*uy(ic,jp,kc)+ac2p(jc)*uy(ic,jc,kc)+am2p(jc)*uy(ic,jm,kc)\n          d33q2= ap3c(kc)*uy(ic,jc,kp)+ac3c(kc)*uy(ic,jc,kc)+am3c(kc)*uy(ic,jc,km)\n          dcq13= d11q2+d33q2\n       \n          gradp2= (pressure(ic,jc,kc)-pressure(ic,jm,kc))*sucac\n#ifndef cfddem\n          conved2= -h21-h22-h23+xnu*dcq13+ gravity(2)\n#else\n          conved2= -h21-h22-h23+xnu*dcq13+ gravity(2) +interpy1*fpforce_y(ic,jm,kc)+interpy2*fpforce_y(ic,jc,kc)\n#endif\n          rhsy(ic,jc,kc)=pmgamma*conved2+ pmtheta*histyold(ic,jc,kc)- pmalpha*gradp2+ two*pmbeta*d22q2\n          histyold(ic,jc,kc)=conved2   \n        enddo\n      enddo\n    enddo\n  end subroutine clcrhsy_pimp\n"}
{"id": 1163, "subroutine": "  subroutine  clcrhsy_pimp_les(ux,uy,uz,rhsy,histyold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(out)::rhsy\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histyold\n   \n    ! locals \n    integer::im,ic,ip,jc,jm,jp,km,kc,kp\n    real(rk)::qdx1,qdx3,h21,h22,h23,sucac,qsucac\n    real(rk)::d11q2,d22q2,d33q2,dcq13,conved2,gradp2  \n    real(rk)::visa,visb,visc,visd,sgs1,sgs2,sgs3  \n    \n    qdx1=quarter*rdx\n    qdx3=quarter*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1\n      kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1\n        jp=jc+1\n        sucac= rdyc(jc)\n        qsucac=quarter*sucac\n        do ic=ystart(1),yend(1)\n          im=ic-1                \n          ip=ic+1\n          h21=( (ux(ip,jc,kc)+ux(ip,jm,kc))* (uy(ip,jc,kc)+uy(ic,jc,kc)) &\n               -(ux(ic,jc,kc)+ux(ic,jm,kc))* (uy(ic,jc,kc)+uy(im,jc,kc)) )*qdx1\n          h22=( (uy(ic,jp,kc)+uy(ic,jc,kc))* (uy(ic,jp,kc)+uy(ic,jc,kc)) &\n               -(uy(ic,jc,kc)+uy(ic,jm,kc))* (uy(ic,jc,kc)+uy(ic,jm,kc)) )*qsucac\n          h23=( (uz(ic,jc,kp)+uz(ic,jm,kp))* (uy(ic,jc,kp)+uy(ic,jc,kc)) &\n               -(uz(ic,jc,kc)+uz(ic,jm,kc))* (uy(ic,jc,kc)+uy(ic,jc,km)) )*qdx3\n\n          visa=quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jm,kc)+nut(im,jm,kc))\n          visb=quarter*(nut(ic,jc,kc)+nut(ip,jc,kc)+nut(ic,jm,kc)+nut(ip,jm,kc))\n          visc=quarter*(nut(ic,jc,kc)+nut(ic,jm,kc)+nut(ic,jc,km)+nut(ic,jm,km))\n          visd=quarter*(nut(ic,jc,kc)+nut(ic,jm,kc)+nut(ic,jc,kp)+nut(ic,jm,kp))\n          sgs1=rdx*sucac*(visb*(ux(ip,jc,kc)-ux(ip,jm,kc))-visa*(ux(ic,jc,kc)-ux(ic,jm,kc)))\n          sgs2=ap2p(jc)*nut(ic,jc,kc)*(uy(ic,jp,kc)-uy(ic,jc,kc))-am2p(jc)*nut(ic,jm,kc)*(uy(ic,jc,kc)-uy(ic,jm,kc))\n          sgs3=rdz*sucac*(visd*(uz(ic,jc,kp)-uz(ic,jm,kp))-visc*(uz(ic,jc,kc)-uz(ic,jm,kc)))\n\n          d11q2= ap1c(ic)*visb*(uy(ip,jc,kc)-uy(ic,jc,kc) ) -am1c(ic)*visa*(uy(ic,jc,kc)- uy(im,jc,kc)) \n          d22q2= sgs2\n          d33q2= ap3c(kc)*visd*(uy(ic,jc,kp)-uy(ic,jc,kc) ) -am3c(kc)*visc*(uy(ic,jc,kc)-uy(ic,jc,km))\n          dcq13= d11q2+d33q2\n                \n          gradp2= (pressure(ic,jc,kc)-pressure(ic,jm,kc))*sucac\n#ifndef cfddem\n          conved2= -h21-h22-h23+sgs1+sgs2+sgs3 +dcq13+ gravity(2)\n#else\n          conved2= -h21-h22-h23+sgs1+sgs2+sgs3+dcq13+ gravity(2)+half*(fpforce_y(ic,jc,kc)+fpforce_y(ic,jm,kc))\n#endif\n          rhsy(ic,jc,kc)=pmgamma*conved2+ pmtheta*histyold(ic,jc,kc)- pmalpha*gradp2+ two*pmbetat*d22q2\n          histyold(ic,jc,kc)=conved2   \n        enddo\n      enddo\n    enddo\n  end subroutine clcrhsy_pimp_les\n"}
{"id": 1164, "subroutine": "  subroutine  clcrhsz_pimp(ux,uy,uz,rhsz,histzold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::rhsz\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histzold\n   \n    ! locals\n    integer::im,ic,ip,jc,jm,jp,km,kc,kp\n    real(rk)::d11q3,d22q3,d33q3,dcq13,conved3,gradp3\n    real(rk)::qdx1,qdx3,h31,h32,h33,sucaj,interpy1,interpy2,interpy3,interpy4\n    \n    qdx1=quarter*rdx\n    qdx3=quarter*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1; kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1; jp=jc+1\n        sucaj=half*rdyp(jc)\n        interpy1= yinterpcoe(jm); interpy2=one-interpy1  \n        interpy3= yinterpcoe(jc); interpy4=one-interpy3\n        do ic=ystart(1),yend(1)\n          im=ic-1; ip=ic+1\n\n          h31=( (ux(ip,jc,kc)+ux(ip,jc,km))* (uz(ip,jc,kc)+uz(ic,jc,kc)) &\n               -(ux(ic,jc,kc)+ux(ic,jc,km))* (uz(ic,jc,kc)+uz(im,jc,kc)) )*qdx1\n          h32=( (uy(ic,jp,kc)+uy(ic,jp,km))* (interpy3*uz(ic,jc,kc) +interpy4*uz(ic,jp,kc)) &\n               -(uy(ic,jc,kc)+uy(ic,jc,km))* (interpy1*uz(ic,jm,kc) +interpy2*uz(ic,jc,kc)) )*sucaj                \n          h33=( (uz(ic,jc,kp)+uz(ic,jc,kc))* (uz(ic,jc,kp)+uz(ic,jc,kc)) &\n               -(uz(ic,jc,kc)+uz(ic,jc,km))* (uz(ic,jc,kc)+uz(ic,jc,km)) )*qdx3\n\n          d11q3= ap1c(ic)*uz(ip,jc,kc)+ac1c(ic)*uz(ic,jc,kc)+am1c(ic)*uz(im,jc,kc)\n          d22q3= ap2c(jc)*uz(ic,jp,kc)+ac2c(jc)*uz(ic,jc,kc)+am2c(jc)*uz(ic,jm,kc)                \n          d33q3= (uz(ic,jc,kp)-two*uz(ic,jc,kc)+uz(ic,jc,km))*rdz2\n          dcq13= d11q3+d33q3\n                \n          gradp3= (pressure(ic,jc,kc)-pressure(ic,jc,km))*rdz                \n#ifndef cfddem\n          conved3= -h31-h32-h33+xnu*dcq13+ gravity(3)\n#else\n          conved3= -h31-h32-h33+xnu*dcq13+ gravity(3)+half*(fpforce_z(ic,jc,kc)+fpforce_z(ic,jc,km))\n#endif\n          rhsz(ic,jc,kc)= pmgamma*conved3+ pmtheta*histzold(ic,jc,kc)- pmalpha*gradp3+ two*pmbeta*d22q3\n          histzold(ic,jc,kc)=conved3\n        enddo\n      enddo\n    enddo \n  end subroutine clcrhsz_pimp\n"}
{"id": 1165, "subroutine": "  subroutine  clcrhsz_pimp_les(ux,uy,uz,rhsz,histzold,pressure)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in)::ux,uy,uz,pressure\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::rhsz\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::histzold\n   \n    ! locals\n    integer::im,ic,ip,jc,jm,jp,km,kc,kp\n    real(rk)::qdx1,qdx3,h31,h32,h33,sucaj\n    real(rk)::d11q3,d22q3,d33q3,dcq13,conved3,gradp3\n    real(rk)::visa,visb,visc,visd,sgs1,sgs2,sgs3\n    \n    qdx1=quarter*rdx\n    qdx3=quarter*rdz\n    do kc=ystart(3),yend(3)\n      km=kc-1\n      kp=kc+1\n      do jc=ystart(2),yend(2)\n        jm=jc-1\n        jp=jc+1\n        sucaj=quarter*rdyp(jc)\n        do ic=ystart(1),yend(1)\n          im=ic-1\n          ip=ic+1\n          h31=( (ux(ip,jc,kc)+ux(ip,jc,km))* (uz(ip,jc,kc)+uz(ic,jc,kc)) &\n               -(ux(ic,jc,kc)+ux(ic,jc,km))* (uz(ic,jc,kc)+uz(im,jc,kc)) )*qdx1\n          h32=( (uy(ic,jp,kc)+uy(ic,jp,km))* (uz(ic,jp,kc)+uz(ic,jc,kc)) &\n               -(uy(ic,jc,kc)+uy(ic,jc,km))* (uz(ic,jc,kc)+uz(ic,jm,kc)) )*sucaj                \n          h33=( (uz(ic,jc,kp)+uz(ic,jc,kc))* (uz(ic,jc,kp)+uz(ic,jc,kc)) &\n               -(uz(ic,jc,kc)+uz(ic,jc,km))* (uz(ic,jc,kc)+uz(ic,jc,km)) )*qdx3\n\n          visa=quarter*(nut(ic,jc,km)+nut(im,jc,km)+nut(ic,jc,kc)+nut(im,jc,kc))\n          visb=quarter*(nut(ic,jc,km)+nut(ip,jc,km)+nut(ic,jc,kc)+nut(ip,jc,kc))\n          visc=quarter*(nut(ic,jc,km)+nut(ic,jm,km)+nut(ic,jm,kc)+nut(ic,jc,kc))\n          visd=quarter*(nut(ic,jc,km)+nut(ic,jp,km)+nut(ic,jp,kc)+nut(ic,jc,kc))\n          sgs1=rdx*rdz     *(visb*(ux(ip,jc,kc)-ux(ip,jc,km))-visa*(ux(ic,jc,kc)-ux(ic,jc,km)))\n          sgs2=rdz*rdyp(jc)*(visd*(uy(ic,jp,kc)-uy(ic,jp,km))-visc*(uy(ic,jc,kc)-uy(ic,jc,km)))\n          sgs3=rdz2*(nut(ic,jc,kc)*(uz(ic,jc,kp)-uz(ic,jc,kc))-nut(ic,jc,km)*(uz(ic,jc,kc)-uz(ic,jc,km)))\n\n          d11q3= ap1c(ic)*visb*(uz(ip,jc,kc)-uz(ic,jc,kc)) -am1c(ic)*visa*(uz(ic,jc,kc)-uz(im,jc,kc)) \n          d22q3= ap2c(jc)*visd*(uz(ic,jp,kc)-uz(ic,jc,kc)) -am2c(jc)*visc*(uz(ic,jc,kc)-uz(ic,jm,kc))        \n          d33q3= sgs3\n          dcq13= d11q3+d33q3\n                \n          gradp3= (pressure(ic,jc,kc)-pressure(ic,jc,km))*rdz \n#ifndef cfddem\n          conved3=-h31-h32-h33+sgs1+sgs2+sgs3+dcq13+gravity(3)\n#else\n          conved3=-h31-h32-h33+sgs1+sgs2+sgs3+dcq13+gravity(3)+half*(fpforce_z(ic,jc,kc)+fpforce_z(ic,jc,km))\n#endif   \n          rhsz(ic,jc,kc)= pmgamma*conved3+ pmtheta*histzold(ic,jc,kc)- pmalpha*gradp3+ two*pmbetat*d22q3\n          histzold(ic,jc,kc)=conved3\n        enddo\n      enddo\n    enddo \n  end subroutine clcrhsz_pimp_les\n"}
{"id": 1166, "subroutine": "  subroutine clcu1hat_pimp(ux,rhsx)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsx\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::ux    \n    \n    ! locals\n    integer::ic,jc,kc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n \n    do jc=ystart(2),yend(2)\n      do ic=ystart(1),yend(1)\n        tridpj(ic,jc) = -pmbeta*ap2cforcn(jc) \n        tridmj(ic,jc) = -pmbeta*am2cforcn(jc) \n        tridcj(ic,jc) = -tridpj(ic,jc)-tridmj(ic,jc)+one\n      enddo\n    enddo   \n    do kc=ystart(3),yend(3)  \n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          tridfj(ic,jc) =  rhsx(ic,jc,kc)\n        enddo\n      enddo  \n      call inversetridiagonal(tridmj, tridcj, tridpj, tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          ux(ic,jc,kc)= ux(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu1hat_pimp\n"}
{"id": 1167, "subroutine": "  subroutine clcu1hat_pimp_0(ux,rhsx)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsx\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::ux    \n    \n    ! locals\n    integer::ic,jc,kc\n    real(rk):: mjc,cjc,pjc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridfj\n    \n    mjc= -pmbeta*rdy2\n    pjc= -pmbeta*rdy2\n    cjc=  pmbeta*rdy2*two +one\n    do kc=ystart(3),yend(3)  \n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          tridfj(ic,jc) =  rhsx(ic,jc,kc)\n        enddo\n      enddo  \n      call inverseptrifixedcoe(mjc,cjc,pjc, tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          ux(ic,jc,kc)= ux(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu1hat_pimp_0\n"}
{"id": 1168, "subroutine": "  subroutine clcu1hat_pimp_les(ux,rhsx)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsx  \n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::ux    \n    \n    ! locals\n    integer:: ic,jc,kc,im,jm,jp\n    real(rk)::visc,visd,rt1,rt2\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n    \n    do kc=ystart(3),yend(3)  \n      do jc=ystart(2),yend(2)\n        jm=jc-1\n        jp=jc+1\n        do ic=ystart(1),yend(1)\n          im=ic-1\n          visc= quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jm,kc)+nut(im,jm,kc))\n          visd= quarter*(nut(ic,jc,kc)+nut(im,jc,kc)+nut(ic,jp,kc)+nut(im,jp,kc))\n          rt1 = pmbetat*visc*am2cforcn(jc)\n          rt2 = pmbetat*visd*ap2cforcn(jc)\n          tridmj(ic,jc) = -rt1 \n          tridcj(ic,jc) =  rt1+rt2+one\n          tridpj(ic,jc) = -rt2\n          tridfj(ic,jc) =  rhsx(ic,jc,kc)\n        enddo\n      enddo  \n      call inversetridiagonal(tridmj, tridcj, tridpj, tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          ux(ic,jc,kc)= ux(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu1hat_pimp_les\n"}
{"id": 1169, "subroutine": "  subroutine clcu2hat_pimp(uy,rhsy,duy_ym)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsy\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uy\n    real(rk),dimension(ystart(1):yend(1),ystart(3):yend(3)),intent(in):: duy_ym\n    \n    ! locals\n    integer::ic,jc,kc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n\n    do ic=ystart(1),yend(1) \n      tridpj(ic,1)=zero\n      tridcj(ic,1)=one\n      tridmj(ic,1)=zero\n    enddo\n    do jc=2,nyc\n      do ic=ystart(1),yend(1) \n        tridpj(ic,jc) = -pmbeta*ap2p(jc)\n        tridcj(ic,jc) = -pmbeta*ac2p(jc)+one\n        tridmj(ic,jc) = -pmbeta*am2p(jc)\n      enddo\n    enddo\n    do kc=ystart(3),yend(3) \n      do ic=ystart(1),yend(1)\n        tridfj(ic,1)=duy_ym(ic,kc)\n      enddo\n      do jc=2,nyc\n        do ic=ystart(1),yend(1)\n          tridfj(ic,jc) = rhsy(ic,jc,kc)\n        enddo\n      enddo\n      call inversetridiagonal(tridmj,tridcj,tridpj,tridfj,ysize(1),nyc)\n      do jc=1,nyc\n        do ic=ystart(1),yend(1) \n          uy(ic,jc,kc)= uy(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo  \n    enddo\n  end subroutine clcu2hat_pimp \n"}
{"id": 1170, "subroutine": "  subroutine clcu2hat_pimp_0(uy,rhsy,duy_ym)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsy\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uy\n    real(rk),dimension(ystart(1):yend(1),ystart(3):yend(3)),intent(in):: duy_ym\n    \n    ! locals\n    integer::ic,jc,kc\n    real(rk):: mjc,cjc,pjc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridfj\n\n    mjc= -pmbeta*rdy2\n    pjc= -pmbeta*rdy2\n    cjc=  pmbeta*rdy2*two +one\n    do kc=ystart(3),yend(3) \n      do jc=1,nyc\n        do ic=ystart(1),yend(1) \n          tridfj(ic,jc) = rhsy(ic,jc,kc)\n        enddo\n       enddo\n       call inverseptrifixedcoe(mjc,cjc,pjc,tridfj,ysize(1),nyc)\n       do jc=1,nyc\n         do ic=ystart(1),yend(1) \n           uy(ic,jc,kc)= uy(ic,jc,kc)+tridfj(ic,jc)\n         enddo\n       enddo  \n     enddo\n  end subroutine clcu2hat_pimp_0 \n"}
{"id": 1171, "subroutine": "  subroutine clcu2hat_pimp_les_0(uy,rhsy,duy_ym)\n    implicit none\n    real(rk),dimension(ystart(1):yend(1),ystart(2):yend(2),ystart(3):yend(3)),intent(inout)::rhsy\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uy\n    real(rk),dimension(ystart(1):yend(1),ystart(3):yend(3)),intent(in):: duy_ym\n    \n    ! locals\n    integer::ic,jc,kc,jm\n    real(rk)::rt1,rt2\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n\n    do kc=ystart(3),yend(3)\n      do jc=1,nyc\n        jm=jc-1\n        do ic=ystart(1),yend(1) \n          rt1= pmbetat*nut(ic,jm,kc)*rdy2\n          rt2= pmbetat*nut(ic,jc,kc)*rdy2\n          tridmj(ic,jc) = -rt1\n          tridcj(ic,jc) =  rt1+rt2+one\n          tridpj(ic,jc) = -rt2\n          tridfj(ic,jc) =  rhsy(ic,jc,kc)\n        enddo\n       enddo\n       call inverseperiodictridiagonal(tridmj,tridcj,tridpj,tridfj,ysize(1),nyc)\n       do jc=1,nyc\n         do ic=ystart(1),yend(1) \n           uy(ic,jc,kc)= uy(ic,jc,kc)+tridfj(ic,jc)\n         enddo\n       enddo  \n     enddo\n  end subroutine clcu2hat_pimp_les_0\n"}
{"id": 1172, "subroutine": "  subroutine clcu3hat_pimp(uz,rhsz)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(inout)::rhsz\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uz\n  \n    ! locals\n    integer::ic,jc,kc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n\n    do jc=ystart(2),yend(2)\n      do ic=ystart(1),yend(1)\n        tridpj(ic,jc) = -pmbeta*ap2cforcn(jc)\n        tridmj(ic,jc) = -pmbeta*am2cforcn(jc)\n        tridcj(ic,jc) = -tridpj(ic,jc)-tridmj(ic,jc)+one\n      enddo\n    enddo  \n    do kc=ystart(3),yend(3)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          tridfj(ic,jc) = rhsz(ic,jc,kc)\n        enddo\n      enddo\n      call inversetridiagonal(tridmj,tridcj,tridpj,tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          uz(ic,jc,kc)= uz(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu3hat_pimp\n"}
{"id": 1173, "subroutine": "  subroutine clcu3hat_pimp_0(uz,rhsz)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(inout)::rhsz\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uz\n  \n    ! locals\n    integer::ic,jc,kc\n    real(rk):: mjc,cjc,pjc\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridfj\n\n    mjc= -pmbeta*rdy2\n    pjc= -pmbeta*rdy2\n    cjc=  pmbeta*rdy2*two +one\n    do kc=ystart(3),yend(3)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          tridfj(ic,jc) = rhsz(ic,jc,kc)\n        enddo\n      enddo\n      call inverseptrifixedcoe(mjc,cjc,pjc,tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          uz(ic,jc,kc)= uz(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu3hat_pimp_0 \n"}
{"id": 1174, "subroutine": "  subroutine clcu3hat_pimp_les(uz,rhsz)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(inout)::rhsz\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out)::uz\n  \n    ! locals\n    integer::ic,jc,kc,jm,jp,km\n    real(rk)::visc,visd,rt1,rt2\n    real(rk),dimension(ystart(1):yend(1), ystart(2):yend(2))::tridmj,tridcj,tridpj,tridfj\n    \n    do kc=ystart(3),yend(3)\n      km=kc-1\n      do jc=ystart(2),yend(2)\n        jm=jc-1\n        jp=jc+1\n        do ic=ystart(1),yend(1)\n          visc=quarter*(nut(ic,jc,km)+nut(ic,jm,km)+nut(ic,jc,kc)+nut(ic,jm,kc))\n          visd=quarter*(nut(ic,jc,km)+nut(ic,jp,km)+nut(ic,jc,kc)+nut(ic,jp,kc))\n          rt1= pmbetat*visc*am2cforcn(jc)\n          rt2= pmbetat*visd*ap2cforcn(jc)\n          tridmj(ic,jc) = -rt1\n          tridcj(ic,jc) =  rt1+rt2+one\n          tridpj(ic,jc) = -rt2\n          tridfj(ic,jc) =  rhsz(ic,jc,kc)\n        enddo\n      enddo\n      call inversetridiagonal(tridmj,tridcj,tridpj,tridfj,ysize(1),nyc)\n      do jc=ystart(2),yend(2)\n        do ic=ystart(1),yend(1)\n          uz(ic,jc,kc)= uz(ic,jc,kc)+tridfj(ic,jc)\n        enddo\n      enddo\n    enddo\n  end subroutine clcu3hat_pimp_les\n"}
{"id": 1175, "subroutine": "  subroutine pressureupdate_pimp(pressure, prphihalo)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in):: prphihalo\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out):: pressure\n    \n    integer::ic,jc,kc,jp,jm\n    real(rk)::pmbetap,pmbetac,pmbetam\n\n    do kc=ystart(3),yend(3)\n      do jc=ystart(2),yend(2)\n        jp=jc+1\n        jm=jc-1\n        pmbetap= -pmbeta*ap2ph(jc)\n        pmbetac= -pmbeta*ac2ph(jc) + one\n        pmbetam= -pmbeta*am2ph(jc)\n        do ic=ystart(1),yend(1)\n          pressure(ic,jc,kc)= pressure(ic,jc,kc)+ pmbetap*prphihalo(ic,jp,kc)+ pmbetac*prphihalo(ic,jc,kc)+ &\n                                                  pmbetam*prphihalo(ic,jm,kc)\n        enddo\n      enddo\n    enddo\n  end subroutine pressureupdate_pimp\n"}
{"id": 1176, "subroutine": "  subroutine pressureupdate_pimp_les(pressure, prphihalo)\n    implicit none\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(in):: prphihalo\n    real(rk),dimension(mb1%xmm:mb1%xpm,mb1%ymm:mb1%ypm,mb1%zmm:mb1%zpm),intent(out):: pressure\n    \n    !locals\n    integer::ic,jc,kc,jp,jm\n    real(rk)::visd,visc,metr1,metr2,pmbetap,pmbetac,pmbetam\n\n    do kc=ystart(3),yend(3)\n      do jc=ystart(2),yend(2)\n        jp=jc+1\n        jm=jc-1\n        metr1=rdyp(jc)*rdyc(jc)\n        metr2=rdyp(jc)*rdyc(jp)\n        do ic=ystart(1),yend(1)\n          visd= half*(nut(ic,jp,kc)+nut(ic,jc,kc))\n          visc= half*(nut(ic,jc,kc)+nut(ic,jm,kc))\n          pmbetap= -pmbetat*metr2*visd\n          pmbetam= -pmbetat*metr1*visc\n          pmbetac= -(pmbetap + pmbetam) +one\n          pressure(ic,jc,kc)= pressure(ic,jc,kc)+ pmbetap*prphihalo(ic,jp,kc)+ pmbetac*prphihalo(ic,jc,kc)+ &\n                                                  pmbetam*prphihalo(ic,jm,kc)\n        enddo\n      enddo\n    enddo\n  end subroutine pressureupdate_pimp_les\n"}
{"id": 1177, "subroutine": "subroutine suits(na,litab,lidf,tts,tto,cts,cto,psi,ctscto, &\n        ks,ko,sob,sof,sdb,sdf,dob,dof,ddb,ddf)\n\n    implicit none\n    integer, intent(in) :: na\n    real*8, intent(in) :: litab(na),lidf(na),tts,tto,cts,cto,psi,ctscto\n    real*8, intent(out) :: ks,ko,sob,sof,sdb,sdf,dob,dof,ddb,ddf\n\n    real*8 :: pi,rd\n    common /angle/ pi,rd\n    real*8 :: bf,ttl,ctl,chi_s,chi_o,frho,ftau,ksli,koli,sobli,sofli,bfli\n    integer :: i\n\n    !\tcalculate geometric factors associated with extinction and scattering \n    !\tinitialise sums\n    ks  = 0\n    ko  = 0\n    bf  = 0\n    sob = 0\n    sof = 0\n\n    !\tweighted sums over lidf\n    do i = 1,na\n        ttl = litab(i)      ! leaf inclination discrete values\n        ctl = cos(rd*ttl)\n        !\tsail volume scattering phase function gives interception and portions to be \n        !\tmultiplied by rho and tau\n        call volscatt(tts,tto,psi,ttl,chi_s,chi_o,frho,ftau)\n\n        !********************************************************************************\n        !*                   suits system coefficients \n        !*\n        !*\tks  : extinction coefficient for direct solar flux\n        !*\tko  : extinction coefficient for direct observed flux\n        !*\tatt : attenuation coefficient for diffuse flux\n        !*\tsigb : backscattering coefficient of the diffuse downward flux\n        !*\tsigf : forwardscattering coefficient of the diffuse upward flux\n        !*\tsf  : scattering coefficient of the direct solar flux for downward diffuse flux\n        !*\tsb  : scattering coefficient of the direct solar flux for upward diffuse flux\n        !*\tvf   : scattering coefficient of upward diffuse flux in the observed direction\n        !*\tvb   : scattering coefficient of downward diffuse flux in the observed direction\n        !*\tw   : bidirectional scattering coefficient\n        !********************************************************************************\n\n        !\textinction coefficients\n        ksli = chi_s/cts\n        koli = chi_o/cto\n\n        !\tarea scattering coefficient fractions\n        sobli = frho*pi/ctscto\n        sofli = ftau*pi/ctscto\n        bfli  = ctl*ctl\n        ks    = ks+ksli*lidf(i)\n        ko    = ko+koli*lidf(i)\n        bf    = bf+bfli*lidf(i)\n        sob   = sob+sobli*lidf(i)\n        sof   = sof+sofli*lidf(i)\n\n    enddo\n\n    !\tgeometric factors to be used later with rho and tau\n    sdb = 0.5*(ks+bf)\n    sdf = 0.5*(ks-bf)\n    dob = 0.5*(ko+bf)\n    dof = 0.5*(ko-bf)\n    ddb = 0.5*(1.+bf)\n    ddf = 0.5*(1.-bf)\n\n    return\nend subroutine suits\n"}
{"id": 1178, "subroutine": "subroutine rtgeom(rho,tau,ddb,ddf,sdb,sdf,dob,dof,sob,sof, &\n        sigb,att,m,sb,sf,vb,vf,w)\n\n    use mod_dataspec_wavelength\n    implicit none\n    real*8,intent(in),dimension(nw) :: rho,tau\n    real*8,intent(in) :: ddb,ddf,sdb,sdf,dob,dof,sob,sof\n    real*8,intent(out),dimension(nw) :: sigb,att,m,sb,sf,vb,vf,w\n\n    real*8,dimension(nw) :: m2,sigf\n\n    sigb = ddb*rho+ddf*tau\n    sigf = ddf*rho+ddb*tau\n    att  = 1.-sigf\n    m2   = (att+sigb)*(att-sigb)\n    where (m2 < 0) \n        m2 = 0\n    endwhere\n    m  = sqrt(m2)\n    sb = sdb*rho+sdf*tau\n    sf = sdf*rho+sdb*tau\n    vb = dob*rho+dof*tau\n    vf = dof*rho+dob*tau\n    w  = sob*rho+sof*tau\n\n    return\nend subroutine rtgeom\n"}
{"id": 1179, "subroutine": "      subroutine e3_int_conserv(s,shp,shgl,sgn)\n        implicit none\n        real*8, dimension(:,:), pointer :: s\n        real*8, dimension(nshl,ngauss), intent(in) :: shp\n        real*8, dimension(nsd,nshl,ngauss), intent(in) :: shgl\n        integer, dimension(npro,nshl), intent(in) :: sgn\nc\n        integer :: iflow\n        real*8 :: shp_qpt(npro,nshl)\n        real*8 :: dui(npro,nflow)\nc        real*8 :: dxidx(npro,nsd,nsd)\n        real*8, dimension(:), pointer :: wdetj\n        real*8, dimension(:,:,:), pointer :: shg_qpt, shgl_qpt\n        real*8, dimension(:,:,:), pointer :: dxidx ! added\nc\n        allocate(wdetj(npro))\n        allocate(shg_qpt(npro,nshl,nsd))\n        allocate(shgl_qpt(npro,nsd,nshl))\n        allocate(dxidx(npro,nsd,nsd)) !added\nc\n        s = zero\nc\n        do intp = 1,ngauss\nc\n          call getshp(shp, shgl, sgn, shp_qpt, shgl_qpt)\n          call calc_primitive(dui,shp_qpt)\n          call getthm6_ptr\n          call calc_conservative(dui)\n          call e3metric(shg_qpt,dxidx,shgl_qpt,xl)\nc\nc... multiply by weight\nc\n          do iflow = 1,nflow\n            s(:,iflow) = s(:,iflow) + wdetj(:)*dui(:,iflow)\n          enddo\nc\n        enddo\nc\n        deallocate(wdetj,shg_qpt,shgl_qpt)\nc\n      end subroutine e3_int_conserv\n"}
{"id": 1180, "subroutine": "      subroutine calc_primitive(dui,shp)\n        real*8, dimension(npro,nflow), intent(out) :: dui\n        real*8, dimension(npro,nshl), intent(in) :: shp\n        integer :: n\n        dui = zero\n        do n = 1, nshl\n           dui(:,1) = dui(:,1) + shp(:,n) * yl(:,n,1) ! p\n           dui(:,2) = dui(:,2) + shp(:,n) * yl(:,n,2) ! u1\n           dui(:,3) = dui(:,3) + shp(:,n) * yl(:,n,3) ! u2\n           dui(:,4) = dui(:,4) + shp(:,n) * yl(:,n,4) ! u3\n           dui(:,5) = dui(:,5) + shp(:,n) * yl(:,n,5) ! t\n        enddo\n        pres = dui(:,1)\n        t = dui(:,5)\n      end subroutine calc_primitive\n"}
{"id": 1181, "subroutine": "      subroutine calc_conservative(dui)\n        real*8, dimension(npro,nflow), intent(inout) :: dui\n        dui(:,1) = rho\n        dui(:,2) = rho * dui(:,2)\n        dui(:,3) = rho * dui(:,3)\n        dui(:,4) = rho * dui(:,4)\n        dui(:,5) = rho * (ei + rk)\n      end subroutine calc_conservative\n"}
{"id": 1182, "subroutine": "subroutine  f2gp(nodoss,geness,imm)\n\ninteger :: n1,n2,j,ii,jj,im,ki,kii,rat                                     \ninteger :: nodoss(10),geness(10)\ninteger :: plot_type                                 ! 1 for linear plot, 2 for log plot, 3 for log-log plot\n character(len=20) :: xlabel,ylabel                  ! plot axis labels and title\n character(len=40)  ::title1,title2,arxiv  \n!---------------\n\ninteger :: i,imm                                     ! number of lines i the plot points\ninteger :: ret\n\n!---------------\n\n\n\n\nxlabel='time'\nylabel='gene concentration'\nplot_type=1                                         ! 1 for linear plot, 2 for log plot, 3 for log-log plot\n\n!!!!!!!! it comes back if gnuplot is not installed\nrat=0\ncall checkgnuplot(rat)\nif(rat.eq.1)then\n write(*,*)'sorry, gene concentration can not be plotted because'\n write(*,*)'gnuplot is not installed'\n return\nend if\n\n\n! create gnuplot command file\n\nopen(10,access='sequential',file='gp.txt')\nwrite(10,*) 'set xlabel '//'\"'//trim(xlabel)//'\"'\nwrite(10,*) 'set ylabel '//'\"'//trim(ylabel)//'\"'\nwrite(10,*) 'set autoscale'\nif (plot_type==2) write(10,*) 'set log y'\nif (plot_type==3) then\n   write(10,*) 'set log x' ;  write(10,*) 'set log y'\nendif\nwrite(10,*) 'set style line 1  lt 2 lw 1 pt 4 ps 2'\n\njj=0 \ndo i=1,10\n  ki=nodoss(i)   \n  if(ki.ne.0)then\n    do j=1,10\n      kii=geness(j)\n      if(kii.ne.0)then        \n        jj=jj+1\n        write(arxiv,*)\"n\",ki,\"g\",kii\n        do im=1,40\n          if (arxiv(im:im)==\" \")then; arxiv(im:im)=\"_\";end if    \n          arxiv(im:im)=arxiv(im:im)\n        end do\n        open(11111+jj,file=arxiv,status='unknown',action='read') \n        write(title1,*)'node',ki,'gen',kii             \n        \n        if(jj.lt.imm)then  \n          if(jj.eq.1)then\n            write(10,*) 'plot \"'//arxiv//'\" using 1:2 with lines title \"'//trim(title1)//'\",\\'\n          else\n            write(10,*) '\"'//arxiv//'\" using 1:2 with lines title \"'//trim(title1)//'\",\\'\n          end if\n        else\n          if(imm.gt.1)then\n            write(10,*) '\"'//arxiv//'\" using 1:2 with lines title \"'//trim(title1)//'\"'   \n          else  ! only one gene in a node has been selected\n            write(10,*) 'plot \"'//arxiv//'\" using 1:2 with lines title \"'//trim(title1)//'\"'\n          end if\n        end if     \n        close(11111+jj)\n      end if\n    end do\n  end if\nend do\n\n close(10,status='keep')\n\n! plot curve with gnuplot and cleanup files\nret=system('gnuplot -persist gp.txt')\nret=system('rm gp.txt')\n\n\nend subroutine\n"}
{"id": 1183, "subroutine": "subroutine checkgnuplot(rat)\n integer :: rat,ret,i\n character(len=10) :: output\n\n open(9999,file='check',status='unknown')\n ret=system('dpkg -l | grep gnuplot > check')\n open(9959,file='check1',status='unknown')\n ret=system('dpkg -l | du -bsh check > check1')\n read(9959,'(a)')output\n if(output(1:1).eq.'0')then\n    rat=1\n end if\n ret=system('rm check*')\n! ret=system('rm check1*')\nend subroutine checkgnuplot\n"}
{"id": 1184, "subroutine": "    subroutine init(self)\n        class(scalar_advection_diffusion_ale),   intent(inout)  :: self\n\n        call self%set_name('scalar advection diffusion ale')\n\n    end subroutine init\n"}
{"id": 1185, "subroutine": "      subroutine el52int(jja,jjb,ja,jb,jc,jd,irez,icolbrei,interact)\n!                                                                  *\n!   --------------  section metwo    subprogram 13  -------------  *\n!                                                                  *\n!     this package evaluated the cases - 1324, 3142, 1342, 3124    *\n!                                                   ( irez = 1),   *\n!                                                   ( + + - - ),   *\n!     which appears in calculation matrix elements between         *\n!     configurations:                               n'1 = n1 - 1   *\n!                                                   n'2 = n2 + 1   *\n!                                                   n'3 = n3 - 1   *\n!                                                   n'4 = n4 + 1   *\n!     and    2413, 4231, 2431, 4213                 ( irez = 2),   *\n!                                                   ( + + - - ),   *\n!     which appears in calculation matrix elements between         *\n!     configurations:                               n'1 = n1 + 1   *\n!                                                   n'2 = n2 - 1   *\n!                                                   n'3 = n3 + 1   *\n!                                                   n'4 = n4 - 1   *\n!                                                                  *\n\n!                        reco,rec4                                 *\n!                                                                  *\n!   written by  g. gaigalas                   nist, december 2015  *\n!                                                                  *\n!*******************************************************************\n!\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      use vast_kind_param, only:  double\n      use cons_c\n      use m_c\n      use orb_c\n      use trk_c\n!-----------------------------------------------\n!   i n t e r f a c e   b l o c k s\n!-----------------------------------------------\n      use reco_i\n      use reco4_i\n      use perko2_i\n      use snrc_i\n!      use gg1234_i\n      use itrexg_i\n      use ixjtik_i\n      use coulom_i\n!      use sixj_i\n!      use speak_i\n      use itrig_i\n!      use cxk_i\n!      use talk_i\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(in) :: jja,jjb,ja,jb,jc,jd,irez,icolbrei\n      integer, intent(out) :: interact\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: ia,ib,ic,id,ibrd,ibre,ii,ip1,ip2,ig1,ig2,ikk,i2,i3,  &\n!                 i4,ifaz,ifazp,ifazfrcs,inn,iat,kra,kra1,l1,l2,l3,l4, &\n                 i4,ifaz,ifazp,inn,iat,kra,kra1,l1,l2,l3,l4, &\n                 j12,jb1,jd1,nd1,nd2,ne1,ne2,n,nn,nu,nup1,mu\n      integer :: interact1, interact2\n      integer, dimension(4) :: j\n      integer, dimension(4) :: is,kaps,ks\n!      real(double)          :: aa,ab,a1,bb,qm1,qm2,qm3,qm4,rag,recc,si\n      real(double)          :: aa,a1,bb,recc\n!      real(double), dimension(12) :: s\n      real(double), dimension(30) :: pmgg\n!      real(double), dimension(12,20) :: cond,cone\n!-----------------------------------------------\n      interact=0\n      if(npeel.le.3)return\n      call reco(ja,jd,jc,jb,3,iat)\n      if(iat.eq.0)return\n      ia=jlist(ja)\n      ib=jlist(jb)\n      ic=jlist(jc)\n      id=jlist(jd)\n!      if(irez.eq.2) then\n!        qm1=-half\n!        qm2=half\n!        qm3=-half\n!        qm4=half\n!      else\n!        qm1=half\n!        qm2=-half\n!        qm3=half\n!        qm4=-half\n!      end if\n      call perko2(ja,jb,jc,jd,4)\n      j(1)=id1(3)\n      j(2)=id2(3)\n      j(3)=id3(3)\n      j(4)=id4(3)\n      l1=(j(1)+1)/2\n      l2=(j(2)+1)/2\n      l3=(j(3)+1)/2\n      l4=(j(4)+1)/2\n      if (icolbrei .eq. 2) then\n        if(irez .eq. 1) then\n          is(1)=ia\n          is(2)=ic\n          is(3)=ib\n          is(4)=id\n        else if(irez .eq. 2) then\n          is(1)=ib\n          is(2)=id\n          is(3)=ia\n          is(4)=ic\n        end if\n        kaps(1)=2*nak(is(1))\n        kaps(2)=2*nak(is(2))\n        kaps(3)=2*nak(is(3))\n        kaps(4)=2*nak(is(4))\n        ks(1)=iabs(kaps(1))\n        ks(2)=iabs(kaps(2))\n        ks(3)=iabs(kaps(3))\n        ks(4)=iabs(kaps(4))\n        call snrc(is,kaps,ks,nd1,nd2,ne1,ne2,ibrd,ibre)\n        if(ibrd .le. 0 .and. ibre .le. 0)return\n!        do ii=1,20\n!          cond(1,ii) =zero\n!          cond(2,ii) =zero\n!          cond(3,ii) =zero\n!          cond(4,ii) =zero\n!          cond(5,ii) =zero\n!          cond(6,ii) =zero\n!          cond(7,ii) =zero\n!          cond(8,ii) =zero\n!          cond(9,ii) =zero\n!          cond(10,ii)=zero\n!          cond(11,ii)=zero\n!          cond(12,ii)=zero\n!          cone(1,ii) =zero\n!          cone(2,ii) =zero\n!          cone(3,ii) =zero\n!          cone(4,ii) =zero\n!          cone(5,ii) =zero\n!          cone(6,ii) =zero\n!          cone(7,ii) =zero\n!          cone(8,ii) =zero\n!          cone(9,ii) =zero\n!          cone(10,ii)=zero\n!          cone(11,ii)=zero\n!          cone(12,ii)=zero\n!        end do\n      end if\n!      call gg1234(ik1,ik2,ik3,ik4,bk1,bk2,bk3,bk4,id1,id2,  &\n!      id3,id4,bd1,bd2,bd3,bd4,qm1,qm2,qm3,qm4,rag)\n!      if(dabs(rag).lt.eps) return\n      ip1=itrexg(j(1),j(2),j(3),j(4),ikk)+1\n      if(ikk.le.0)return\n      ig1=ip1+ikk-1\n      do i4=ip1,ig1,2\n        kra=(i4-1)/2\n        kra1=kra+1\n        if(kra1.gt.30)go to 10\n        pmgg(kra1)=zero\n        call reco4(ja,jb,jc,jd,j(1),j(2),j(3),j(4),kra*2,0,iat,recc)\n        if(iat.eq.0) cycle\n!        call reco4(ja,jb,jc,jd,j(1),j(2),j(3),j(4),kra*2,1,iat,recc)\n!        pmgg(kra1)=recc\n        pmgg(kra1)=one\n      end do\n!\n!     transform fano & racah phase convention\n!     to condon & shortley phase convention\n!\n!      ifazfrcs=1\n!      ifaz=ik1(5)*ik1(4)+ik2(5)*ik2(4)-id1(5)*id1(4)-id2(5)*id2(4)  &\n!      +ik3(5)*ik3(4)-id3(5)*id3(4)+ik4(5)*ik4(4)-id4(5)*id4(4)\n!      if((ifaz/4)*4.ne.ifaz)ifazfrcs=-ifazfrcs\n!\n!      nn=0\n!      jb1=jb-1\n!      ifazp=1\n!      do ii=ja,jb1\n!        inn=jlist(ii)\n!        nn=nq1(inn)+nn\n!      end do\n!      if((nn/2)*2.eq.nn)ifazp=-ifazp\n!      nn=0\n!      jd1=jd-1\n!      do ii=jc,jd1\n!        inn=jlist(ii)\n!        nn=nq1(inn)+nn\n!      end do\n!      if((nn/2)*2.eq.nn)ifazp=-ifazp\n! * * *                      * * *                      * * *\n!     cases 1324   + + - -        transform to  1234   + - + -\n!           1342                                1234\n!                                                    (irez = 1)\n!     or\n!     cases 2413   + + - -        transform to  1234   - + - +\n!           4231                                1234\n!                                                    (irez = 2)\n      do i3=ip1,ig1,2\n        kra=(i3-1)/2\n        if (icolbrei .eq. 1) then\n          interact1 = 0\n          if(irez.eq.2) then\n            call coulom(l2,l4,l1,l3,id2(5),id4(5),id1(5),id3(5),kra,a1)\n          else\n            call coulom(l1,l3,l2,l4,id1(5),id3(5),id2(5),id4(5),kra,a1)\n          end if\n          if(dabs(a1).lt.eps) cycle\n          interact1 = 1\n        end if\n        kra1=kra+1\n        if(kra1.gt.30)go to 10\n        aa=pmgg(kra1)\n        if(dabs(aa).lt.eps) cycle\n!        aa=aa*rag\n!        if(dabs(aa).lt.eps) cycle\n!        aa=aa/dsqrt(dble(i3))\n!        ab=aa*dble(ifazp)\n!        if(irez.eq.2) then\n!          ifaz=j(1)+j(2)+j(4)+j(3)+4*kra\n!          if((ifaz/4)*4.ne.ifaz)ab=-ab\n!        end if\n        if (icolbrei .eq. 1) then\n           interact = interact1\n           if(interact .gt. 0) return\n!          bb=a1*ab*dble(ifazfrcs)\n!          if(irez.eq.1)call speak(jja,jjb,ia,ic,ib,id,kra,bb)\n!          if(irez.eq.2)call speak(jja,jjb,ib,id,ia,ic,kra,bb)\n        else if (icolbrei .eq. 2) then\n           interact = 1\n           return\n!          nu=kra\n!          if(((nu-nd1)/2)*2 .eq. (nu-nd1)) then\n!            if((itrig(ks(1),ks(3),nu+nu+1).ne.0) .and.  &\n!               (itrig(ks(2),ks(4),nu+nu+1).ne.0)) then\n!              n=(nu-nd1)/2+1\n!              if(nu .gt. 0) then\n!                call cxk(s,is,kaps,nu,kra,1,1)\n!                do mu = 1,4\n!                  cond(mu,n)=cond(mu,n)+ab*s(mu)\n!                end do\n!              end if\n!            end if\n!          end if\n!          nu=kra+1\n!          if(((nu-nd1)/2)*2 .eq. (nu-nd1)) then\n!            if((itrig(ks(1),ks(3),nu+nu-1).ne.0) .and.  &\n!               (itrig(ks(2),ks(4),nu+nu-1).ne.0)) then\n!              n=(nu-nd1)/2+1\n!              if(n .le. nd2) then\n!                call cxk(s,is,kaps,nu,kra,1,1)\n!                do mu = 1,4\n!                  cond(mu,n)=cond(mu,n)+ab*s(mu)\n!                end do\n!              end if\n!            end if\n!          end if\n!          nu=kra-1\n!          if(((nu-nd1)/2)*2 .eq. (nu-nd1)) then\n!            if((itrig(ks(1),ks(3),nu+nu+3).ne.0) .and.   &\n!               (itrig(ks(2),ks(4),nu+nu+3).ne.0)) then\n!              if(nu .ge. 0) then\n!                n=(nu-nd1)/2+1\n!                if(n .lt. nd2) then\n!                  call cxk(s,is,kaps,nu,kra,1,1)\n!                  do mu = 1,12\n!                    cond(mu,n)=cond(mu,n)+ab*s(mu)\n!                  end do\n!                end if\n!              end if\n!            end if\n!          end if\n        end if\n      end do\n!      if (icolbrei .eq. 2) then\n!        do n = 1,nd2\n!          nu=nd1+2*(n-1)\n!          call talk(jja,jjb,nu,is(1),is(3),is(2),is(4),1,cond(1,n))\n!          call talk(jja,jjb,nu,is(3),is(1),is(4),is(2),1,cond(2,n))\n!          call talk(jja,jjb,nu,is(1),is(3),is(4),is(2),1,cond(3,n))\n!          call talk(jja,jjb,nu,is(3),is(1),is(2),is(4),1,cond(4,n))\n!          if(n.eq.nd2) cycle\n!          nup1=nu+1\n!          call talk(jja,jjb,nup1,is(1),is(3),is(2),is(4),2,cond(5,n))\n!          call talk(jja,jjb,nup1,is(2),is(4),is(1),is(3),2,cond(6,n))\n!          call talk(jja,jjb,nup1,is(3),is(1),is(4),is(2),2,cond(7,n))\n!          call talk(jja,jjb,nup1,is(4),is(2),is(3),is(1),2,cond(8,n))\n!          call talk(jja,jjb,nup1,is(1),is(3),is(4),is(2),2,cond(9,n))\n!          call talk(jja,jjb,nup1,is(4),is(2),is(1),is(3),2,cond(10,n))\n!          call talk(jja,jjb,nup1,is(3),is(1),is(2),is(4),2,cond(11,n))\n!          call talk(jja,jjb,nup1,is(2),is(4),is(3),is(1),2,cond(12,n))\n!        end do\n!      end if\n! * * *                      * * *                      * * *\n!     cases 1342   + + - -        transform to  1234   + - + -\n!           3124                                1234\n!                                                    (irez = 1)\n!     or\n!     cases 2431   + + - -        transform to  1234   - + - +\n!           4213                                1234\n!                                                    (irez = 2)\n      ip2=itrexg(j(1),j(4),j(2),j(3),ikk)+1\n      if(ikk.le.0) return\n      ig2=ip2+ikk-1\n      do i2=ip2,ig2,2\n        kra=(i2-1)/2\n!\n        if (icolbrei .eq. 1) then\n          interact1 = 0\n          if(irez.eq.2) then\n            call coulom(l2,l4,l3,l1,id2(5),id4(5),id3(5),id1(5),kra,a1)\n          else\n            call coulom(l1,l3,l4,l2,id1(5),id3(5),id4(5),id2(5),kra,a1)\n          end if\n          if(dabs(a1).lt.eps) cycle\n          interact1 = 1\n        end if\n!\n!        ab=zero\n        interact2 = 0\n        do i3=ip1,ig1,2\n          j12=(i3-1)/2\n          ifaz=j(1)-j(3)+2*j12\n          if(irez.eq.2)ifaz=j(4)-j(2)-2*j12\n          if((ifaz/2)*2.ne.ifaz) cycle\n          kra1=j12+1\n          if(kra1.gt.30)go to 10\n          aa=pmgg(kra1)\n          if(dabs(aa).lt.eps) cycle\n!          aa=aa*rag\n!          if(dabs(aa).lt.eps) cycle\n          if(ixjtik(j(1),j(4),kra*2,j(3),j(2),j12*2).eq.0) cycle\n          interact2 = interact2 + 1\n!          call sixj(j(1),j(4),kra*2,j(3),j(2),j12*2,0,si)\n!          aa=aa*si*dsqrt(dble(i3))\n!          ifaz=2*j(3)-4*kra-4*j12\n!          if(irez.eq.2)ifaz=j(1)+j(2)+j(3)-j(4)-4*kra\n!          if((ifaz/4)*4.ne.ifaz)aa=-aa\n!          ab=ab+aa\n        end do\n        if(interact2 .eq. 0) cycle\n!        if(dabs(ab).lt.eps) cycle\n!        ab=-ab*dble(ifazp)\n!\n        if (icolbrei .eq. 1) then\n           interact = interact1\n           if(interact .gt. 0) return\n!          bb=a1*ab*dble(ifazfrcs)\n!          if(irez.eq.1)call speak(jja,jjb,ia,ic,id,ib,kra,bb)\n!          if(irez.eq.2)call speak(jja,jjb,ib,id,ic,ia,kra,bb)\n        else if (icolbrei .eq. 2) then\n           interact = 1\n           return\n!          nu=kra\n!          if(((nu-ne1)/2)*2 .eq. (nu-ne1)) then\n!            if((itrig(ks(1),ks(4),nu+nu+1).ne.0) .and.  &\n!               (itrig(ks(2),ks(3),nu+nu+1).ne.0)) then\n!              n=(nu-ne1)/2+1\n!              if(nu .gt. 0) then\n!                call cxk(s,is,kaps,nu,kra,1,2)\n!                do mu = 1,4\n!                  cone(mu,n)=cone(mu,n)+ab*s(mu)\n!                end do\n!              end if\n!            end if\n!          end if\n!          nu=kra+1\n!          if(((nu-ne1)/2)*2 .eq. (nu-ne1)) then\n!            if((itrig(ks(1),ks(4),nu+nu-1).ne.0) .and.  &\n!               (itrig(ks(2),ks(3),nu+nu-1).ne.0)) then\n!              n=(nu-ne1)/2+1\n!              if(n .le. ne2) then\n!                call cxk(s,is,kaps,nu,kra,1,2)\n!                do mu = 1,4\n!                  cone(mu,n)=cone(mu,n)+ab*s(mu)\n!                end do\n!              end if\n!            end if\n!          end if\n!          nu=kra-1\n!          if(((nu-ne1)/2)*2 .eq. (nu-ne1)) then\n!            if((itrig(ks(1),ks(4),nu+nu+3).ne.0) .and.  &\n!               (itrig(ks(2),ks(3),nu+nu+3).ne.0)) then\n!              if(nu .ge. 0) then\n!                n=(nu-ne1)/2+1\n!                if(n .lt. ne2) then\n!                  call cxk(s,is,kaps,nu,kra,1,2)\n!                  do mu = 1,12\n!                    cone(mu,n)=cone(mu,n)+ab*s(mu)\n!                  end do\n!                end if\n!              end if\n!            end if\n!          end if\n        end if\n      end do\n!      if (icolbrei .eq. 2) then\n!        do n = 1,ne2\n!          nu=ne1+2*(n-1)\n!          call talk(jja,jjb,nu,is(1),is(4),is(2),is(3),1,cone(1,n))\n!          call talk(jja,jjb,nu,is(4),is(1),is(3),is(2),1,cone(2,n))\n!          call talk(jja,jjb,nu,is(1),is(4),is(3),is(2),1,cone(3,n))\n!          call talk(jja,jjb,nu,is(4),is(1),is(2),is(3),1,cone(4,n))\n!          if(n.eq.ne2) cycle\n!          nup1=nu+1\n!          call talk(jja,jjb,nup1,is(1),is(4),is(2),is(3),2,cone(5,n))\n!          call talk(jja,jjb,nup1,is(2),is(3),is(1),is(4),2,cone(6,n))\n!          call talk(jja,jjb,nup1,is(4),is(1),is(3),is(2),2,cone(7,n))\n!          call talk(jja,jjb,nup1,is(3),is(2),is(4),is(1),2,cone(8,n))\n!          call talk(jja,jjb,nup1,is(1),is(4),is(3),is(2),2,cone(9,n))\n!          call talk(jja,jjb,nup1,is(3),is(2),is(1),is(4),2,cone(10,n))\n!          call talk(jja,jjb,nup1,is(4),is(1),is(2),is(3),2,cone(11,n))\n!          call talk(jja,jjb,nup1,is(2),is(3),is(4),is(1),2,cone(12,n))\n!        end do\n!      end if\n      return\n   10 write(99,100)\n  100 format(5x,'erro in el52int  pmgg ragg')\n      stop\n      end subroutine el52int\n"}
{"id": 1186, "subroutine": "    subroutine init(self)\n        class(rans_efficient),   intent(inout)  :: self\n\n        call self%set_name('rans efficient')\n\n    end subroutine init\n"}
{"id": 1187, "subroutine": "subroutine zarcg33(ar,ai,b,cr,ci,s,nrm,info)\n\n  implicit none\n  \n  ! input variables\n  integer, intent(inout) :: info\n  real(8), intent(in) :: ar, ai, b\n  real(8), intent(inout) :: cr, ci, s, nrm\n  \n  ! compute variables\n  real(8) :: tar, tai, tb\n  real(8) :: nar, nai, nb\n  real(8), parameter :: tol = epsilon(1d0)\n  \n  ! initialize info\n  info = 0\n\n  ! check error in debug mode\n  if (debug) then\n  \n    ! check ar\n    call darnan(ar,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"ar is invalid\",info,-1)\n      return\n    end if\n    call darinf(ar,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"ar is invalid\",info,-1)\n      return\n    end if   \n\n    ! check ai\n    call darnan(ai,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"ai is invalid\",info,-2)\n      return\n    end if\n    call darinf(ai,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"ai is invalid\",info,-2)\n      return\n    end if  \n\n    ! check b\n    call darnan(b,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"b is invalid\",info,-3)\n      return\n    end if\n    call darinf(b,info)\n    if (info.ne.0) then\n      call uarerr(__file__,__line__,\"b is invalid\",info,-3)\n      return\n    end if\n\n  end if\n\n  ! set local variables\n  nar = abs(ar)\n  nai = abs(ai)\n  nb = abs(b)\n  nrm = 1d0\n  \n  if(nar.eq.0 .and. nai.eq.0 .and. nb.eq.0)then\n    cr = 1d0\n    ci = 0d0\n    s = 0d0\n    nrm = 0d0\n  else if(nb.eq.0 .and. nar > nai)then\n    tai = ai/ar\n    nrm = sqrt(1d0 + tai*tai)\n    if(ar < 0)then\n      cr = -1d0/nrm\n      ci = tai*cr\n      s = 0d0\n      nrm = -ar*nrm\n    else\n      cr = 1d0/nrm\n      ci = tai*cr\n      s = 0d0\n      nrm = ar*nrm\n    end if\n  else if(nb.eq.0)then\n    tar = ar/ai\n    nrm = sqrt(1d0 + tar*tar)\n    if(ai < 0)then\n      ci = -1d0/nrm\n      cr = tar*ci\n      s = 0d0\n      nrm = -ai*nrm\n    else\n      ci = 1d0/nrm\n      cr = tar*ci\n      s = 0d0\n      nrm = ai*nrm\n    end if\n  else if(nar >= nb .and. nar >= nai)then\n    tb = b/ar\n    tai = ai/ar\n    nrm = sqrt(1d0 + tb*tb + tai*tai)\n    if(ar < 0)then\n      cr = -1d0/nrm\n      ci = tai*cr\n      s = tb*cr\n      nrm = -ar*nrm\n    else\n      cr = 1d0/nrm\n      ci = tai*cr\n      s = tb*cr\n      nrm = ar*nrm\n    end if\n  else if(nai >= nb .and. nai >= nar)then\n    tb = b/ai\n    tar = ar/ai\n    nrm = sqrt(1d0 + tb*tb + tar*tar)\n    if(ai < 0)then\n      ci = -1d0/nrm\n      cr = tar*ci\n      s = tb*ci\n      nrm = -ai*nrm\n    else\n      ci = 1d0/nrm\n      cr = tar*ci\n      s = tb*ci\n      nrm = ai*nrm\n    end if\n  else\n    tar = ar/b\n    tai = ai/b\n    nrm = sqrt(1d0 + tai*tai + tar*tar)\n    if(b < 0)then\n      s = -1d0/nrm\n      cr = tar*s\n      ci = tai*s\n      nrm = -b*nrm\n    else\n      s = 1d0/nrm\n      cr = tar*s\n      ci = tai*s\n      nrm = b*nrm\n    end if\n  end if\n\nend subroutine zarcg33\n"}
{"id": 1188, "subroutine": "subroutine flexeft_simple\nuse bio_mod\nimplicit none\ninteger :: k\nreal    :: qn, mu0\nreal    :: par_\nreal    :: lno3\nreal    :: no3, phy, zoo, det\nreal    :: pp_pn\nreal    :: kn = 1d0\nreal    :: munet\nreal    :: kp, gmax, rdn, mz\nreal,    external  :: wapr\n\nkp  =0.5\nrdn =0.1\nmz  =params(imz)\ngmax=params(igmax)\nmu0 =params(imu0)\ndo k = nlev,1,-1    ! k from surface to bottom, cannot be reversed\n   det  = vars(idet,k)\n   no3  = vars(ino3,k)\n   phy  = vars(iphy(1),k)\n   zoo  = vars(izoo,k)  !zooplankton biomass\n\n   ! check whether in the mld or not\n   if (k .lt. n_mld) then\n      par_ = par(k)\n   else\n      par_ = paravg\n   endif\n   varout(opar_,k) = par_\n! phytoplankton section:\n! calculate phytoplankton growth rate, theta, and qn based on environmental conditions\n   call eft_phygrowth(mu0,kn,params(ia0n), params(iai0), no3,temp(k),par(k),&\n                   munet, qn,                                         &\n                   varout(otheta(1),k),                               &\n                   varout(osi(1),k), varout(olno3(1),k))\n\n   varout(oppt,k) = phy*munet/dtdays/varout(oqn(1),k)*12d0\n\n   !call again with par_\n   call eft_phygrowth(mu0,kn,params(ia0n), params(iai0), no3,temp(k),par_,&\n                   munet, varout(oqn(1),k),                               &\n                   varout(otheta(1),k),                               &\n                   varout(osi(1),k), varout(olno3(1),k))\n   \n   !save net growth rate\n   varout(omunet(1),k) = munet/dtdays\n    \n   !phytoplankton sinking rate at the average size\n   ! varout(ow_p(1),  k) = abs(w_p0)  !positive\n!---------------------------------------------------------------\n!! zooplankton section:\n   tf_z = tempbol(ez,temp(k))\n\n ! the grazing dependence on total prey (dimensionless)\n   gbar = grazing(grazing_formulation,kp,phy)\n\n !zooplankton total ingestion rate\n   inges = tf_z*dtdays*gmax*gbar\n\n !zooplankton excretion rate (-> dom)\n   res  = inges*(1d0-gge-unass)\n\n !zooplankton egestion (-> pom)\n   eges = inges*unass\n    \n! grazing rate on phy(specific to n-based phy biomass, unit: d-1)\n   ! calculate the specific grazing rate for phy\n   varout(ograz(1),k) = inges*zoo/phy/dtdays\n   \n   varout(ophy(1),k)  = phy*(1d0+munet)-inges*zoo\n!!end of zooplankton section\n!=============================================================\n!! solve ode functions:\n  zmort = zoo*zoo*dtdays*mz*tf_z  !mortality term for zoo\n \n  ! for production/destruction matrix:\n  pp_pn=phy*munet\n  pp_nd=dtdays* rdn*det*tf_z   \n  pp_nz=zoo*res        \n  pp_dz=zoo*eges+zmort \n  pp_zp=zoo*inges      \n  \n  varout(odet,k) = (det+pp_dz)-pp_nd\n  varout(ono3,k) = (no3+pp_nd+pp_nz)-pp_pn\n  varout(ozoo,k) = (zoo+pp_zp)-pp_dz-pp_nz\n  varout(oz2n,k) = pp_nz/dtdays\n  varout(od2n,k) = pp_nd/dtdays\n  varout(ochlt,k)= vars(iphy(1),k)/varout(oqn(1),k)*varout(otheta(1),k)\n  varout(opon, k)= phy+zoo+det\n  varout(ochl(1),k)=varout(ochlt,k)\nenddo\nend subroutine flexeft_simple\n"}
{"id": 1189, "subroutine": "   subroutine reset_peak_values\n!\n\n     implicit none\n!\n     type mat_peak_variable_t\n!\n          character(100),dimension(:),pointer,contiguous :: &\n                                                 names => null() !# peak names\n     end type mat_peak_variable_t\n!\n     real,dimension(:,:,:),pointer :: peaks\n     type(mat_peak_variable_t),pointer    :: epeak,ipeak\n!\n!\n           if    (ipeak%names(1)(1:3)==\"max\") then\n             peaks(:,:,1)= 0.\n           endif\n    end subroutine reset_peak_values\n"}
{"id": 1190, "subroutine": "  subroutine test\n    complex, save :: z[*]\n    if (z /= cmplx (0.0, 0.0)) stop 1\n  end subroutine test\n"}
{"id": 1191, "subroutine": "    subroutine lttb_downsize(data, threshold, series)\n        implicit none\n\n        real, intent(in) :: data(:)\n        integer, intent(in) :: threshold\n        real, intent(out), allocatable :: series(:)\n\n        ! internal variables\n        integer i, sampledindex, a, nexta, datalength\n        real maxareapoint, maxarea, area, every\n\n        datalength = size(data)\n\n        ! just copy the data 'as-is'\n        if (datalength .le. threshold) then\n            print *, 'no downsizing needed, copying time-series'\n\n            allocate (series(datalength))\n            series(:) = data(:)\n\n            return\n        end if\n\n        print *, 'downsizing time-series with largest-triangle-three-buckets'\n\n        allocate (series(threshold))\n\n        ! always add the first point\n        series(1) = data(1)\n        sampledindex = 1\n        a = 0\n        nexta = 0\n        maxareapoint = 0.0\n\n        ! bucket size. leave room for start and end data points\n        every = real(datalength - 2)/real(threshold - 2)\n\n        do i = 0, threshold - 2 - 1\n            block\n                integer avgrangestart, avgrangeend, avgrangelength\n                real avgx, avgy, pointax, pointay\n                integer rangeoffs, rangeto\n\n                avgrangestart = floor((i + 1)*every) + 1\n                avgrangeend = floor((i + 2)*every) + 1\n                avgrangeend = min(avgrangeend, datalength)\n                avgrangelength = avgrangeend - avgrangestart\n\n                avgx = 0.0\n                avgy = 0.0\n\n                do while (avgrangestart < avgrangeend)\n                    avgx = avgx + avgrangestart\n                    avgy = avgy + data(1 + avgrangestart)\n                    avgrangestart = avgrangestart + 1\n                end do\n\n                avgx = avgx/avgrangelength\n                avgy = avgy/avgrangelength\n\n                ! get the range for this bucket\n                rangeoffs = floor((i + 0)*every) + 1\n                rangeto = floor((i + 1)*every) + 1\n\n                ! point a\n                pointax = a\n                pointay = data(1 + a)\n\n                maxarea = -1\n\n                do while (rangeoffs < rangeto)\n                    ! calculate triangle area over three buckets\n                    area = abs((pointax - avgx)*(data(1 + rangeoffs) - pointay) -&\n                    &(pointax - rangeoffs)*(avgy - pointay))*0.5\n\n                    if (area .gt. maxarea) then\n                        maxarea = area\n                        maxareapoint = data(1 + rangeoffs)\n                        nexta = rangeoffs ! next a is this b\n                    end if\n\n                    rangeoffs = rangeoffs + 1\n                end do\n\n                series(1 + sampledindex) = maxareapoint ! pick this point from the bucket\n                sampledindex = sampledindex + 1\n                a = nexta ! this a is the next a (chosen b)\n            end block\n        end do\n\n        ! always add the last element\n        series(1 + sampledindex) = data(datalength)\n        sampledindex = sampledindex + 1\n\n    end subroutine lttb_downsize\n"}
{"id": 1192, "subroutine": "\tsubroutine initdefaultmatrix( this, nrows, ncols, val )\n\t\tclass(matrix) :: this\n\t\tinteger, intent(in) :: nrows\n\t\tinteger, intent(in) :: ncols\n\t\treal(8), optional, intent(in) :: val\n\t\t\n\t\tthis.nrows = nrows\n\t\tthis.ncols = ncols\n\t\t\n\t\tif( this.nrows == this.ncols ) then\n\t\t\tthis.type = square_matrix\n\t\telse if( this.ncols == 1 ) then\n\t\t\tthis.type = column_matrix\n\t\telse if( this.nrows == 1 ) then\n\t\t\tthis.type = row_matrix\n\t\telse\n\t\t\tthis.type = unknown_matrix\n\t\tend if\n\t\t\n\t\tif( allocated(this.data) ) deallocate(this.data)\n\t\tallocate( this.data(nrows,ncols) )\n\t\t\n\t\tthis.data = 0.0_8\n\t\tif( present(val) ) this.data = val\n\tend subroutine initdefaultmatrix\n"}
{"id": 1193, "subroutine": "\tsubroutine fromarray( this, arr )\n\t\tclass(matrix) :: this\n\t\treal(8), intent(in) :: arr(:,:)\n\t\t\n\t\tcall this.initdefaultmatrix( size(arr,dim=1), size(arr,dim=2) )\n\t\tthis.data = arr\n\tend subroutine fromarray\n"}
{"id": 1194, "subroutine": "\tsubroutine fromarraydiag( this, arr )\n\t\tclass(matrix) :: this\n\t\treal(8), intent(in) :: arr(:)\n\t\t\n\t\tinteger :: i\n\t\t\n\t\tcall this.initdefaultmatrix( size(arr), size(arr) )\n\t\t\n\t\tdo i=1,size(arr)\n\t\t\tthis.data(i,i) = arr(i)\n\t\tend do\n\tend subroutine fromarraydiag\n"}
{"id": 1195, "subroutine": "\tsubroutine identity( this, nrows, ncols )\n\t\tclass(matrix) :: this\n\t\tinteger, intent(in) :: nrows\n\t\tinteger, intent(in) :: ncols\n\t\t\n\t\tinteger i, j\n\t\t\n\t\tcall this.initdefaultmatrix( nrows, ncols )\n\t\t\n\t\tdo i=1,this.nrows\n\t\t\tthis.data(i,i) = 1.0_8\n\t\tend do\n\tend subroutine identity\n"}
{"id": 1196, "subroutine": "\tsubroutine random( this, nrows, ncols, symmetric )\n\t\tclass(matrix) :: this\n\t\tinteger, intent(in) :: nrows\n\t\tinteger, intent(in) :: ncols\n\t\tlogical, optional, intent(in) :: symmetric\n\t\t\n\t\tinteger :: i, j, n, clock\n\t\tinteger, dimension(:), allocatable :: seed\n\t\tlogical :: effsymmetric\n\t\t\n\t\teffsymmetric = .false.\n\t\tif( present(symmetric) ) effsymmetric = symmetric\n\t\t\n\t\tcall this.initdefaultmatrix( nrows, ncols )\n\t\t\n\t\tcall randomutils_init()\n\t\t\n\t\tif( effsymmetric ) then\n\t\t\tdo i=1,nrows\n\t\t\t\tdo j=i,ncols\n\t\t\t\t\tcall random_number( this.data(i,j) )\n\t\t\t\t\tthis.data(j,i) = this.data(i,j)\n\t\t\t\tend do\n\t\t\tend do\n\t\t\t! @todo hay que implementar el type como bits para que la matriz pueda ser sim\u00e9trica y cuadrada por ejemplo\n\t\telse\n\t\t\tdo i=1,nrows\n\t\t\t\tdo j=1,ncols\n\t\t\t\t\tcall random_number( this.data(i,j) )\n\t\t\t\tend do\n\t\t\tend do\n\t\tend if\n\tend subroutine random\n"}
{"id": 1197, "subroutine": "\tsubroutine columnvector( this, nelems, val, values )\n\t\tclass(matrix) :: this\n\t\tinteger, intent(in) :: nelems\n\t\treal(8), optional, intent(in) :: val\n\t\treal(8), optional, intent(in) :: values(:)\n\t\t\n\t\tif( present(val) ) then\n\t\t\tcall this.initdefaultmatrix( nelems, 1, val )\n\t\telse if( present(values) ) then\n\t\t\tcall this.initdefaultmatrix( nelems, 1 )\n\t\t\tthis.data(:,1) = values(1:nelems)\n\t\telse\n\t\t\tcall this.initdefaultmatrix( nelems, 1 )\n\t\tend if\n\tend subroutine columnvector\n"}
{"id": 1198, "subroutine": "\tsubroutine copymatrix( this, other )\n\t\tclass(matrix), intent(inout) :: this\n\t\tclass(matrix), intent(in) :: other\n\t\t\n\t\tthis.nrows = other.nrows\n\t\tthis.ncols = other.ncols\n\t\t\n\t\tif( allocated(this.data) ) deallocate(this.data)\n\t\tallocate( this.data(other.nrows,other.ncols) )\n\t\t\n\t\tthis.data = other.data\n\t\tthis.type = other.type\n\tend subroutine copymatrix\n"}
{"id": 1199, "subroutine": "\tsubroutine destroymatrix( this )\n\t\ttype(matrix) :: this\n\t\t\n\t\tthis.nrows = 0\n\t\tthis.ncols = 0\n\t\tif( allocated(this.data) ) deallocate(this.data)\n\tend subroutine destroymatrix\n"}
{"id": 1200, "subroutine": "\tsubroutine eigen( this, evalues, evals, evecs )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), allocatable, optional, intent(inout) :: evalues(:)\n\t\ttype(matrix), optional, intent(inout) :: evals\n\t\ttype(matrix), optional, intent(inout) :: evecs\n\t\t\n\t\ttype(matrix) :: evecsbuffer\n\t\treal(8), allocatable :: evaluesbuffer(:)\n\t\treal(8), allocatable :: workspace(:)\n\t\tinteger :: i, ssize, info\n\t\t\n\t\tif( this.type /= square_matrix ) then\n\t\t\twrite(*,*) \"### error ### matrix.eigen: matrix not square\"\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tssize = this.nrows\n\t\tevecsbuffer = this\n\t\t\n\t\tallocate( evaluesbuffer(ssize) )\n\t\tallocate( workspace( 3*ssize-1 ) )\n\t\t\n\t\t! compute the eigen values and eigen vectors using the upper elements of the symmetric matrix\n\t\tcall dsyev( 'v', 'l', ssize, evecsbuffer.data, ssize, evaluesbuffer, workspace, 3*ssize-1, info )\n\t\t\n\t\t! utilizando el m\u00e9todo dsyev con ( 'v', 'u', ... ) me ha dado problemas para diagonalizar esta matrix\n\t\t! \n\t\t!     48749.900676       0.000000  -48749.900676\n\t\t!         0.000000   97499.801352       0.000000\n\t\t!    -48749.900676       0.000000   48749.900676\n\t\t!\n\t\t! dando valores propios correctos, pero vectores propios totalmente errados que no son ni ortogonales\n\t\t!\n\t\t! \t     -0.707107      -0.408248       0.577350\n\t\t!         0.000000      -0.816497      -0.577350\n\t\t!        -0.707107       0.408248      -0.577350\n\t\t!\n\t\t! sin embargo utilizando el m\u00e9todo dsyev con ( 'v', 'l', ... ) esto se corrige, pero no se el porqu\u00e9,\n\t\t! dando su valor correcto\n\t\t!\n\t\t!         0.707107       0.000000       0.707107\n\t\t!        -0.000000       1.000000       0.000000\n\t\t!         0.707107       0.000000      -0.707107\n\t\t\n\t\tif ( info /= 0 ) then\n\t\t\twrite(*,*) \"### error ### matrix.eigen: values matrix failed\"\n\t\tend if\n\t\t\n\t\tif( present(evalues) ) then\n\t\t\tif( allocated(evalues) ) deallocate(evalues)\n\t\t\tallocate(evalues(ssize))\n\t\t\tevalues = evaluesbuffer\n\t\tend if\n\t\t\n\t\tif( present(evals) ) then\n\t\t\tcall evals.init( ssize, ssize, 0.0_8 )\n\t\t\tdo i=1,ssize\n\t\t\t\tcall evals.set( i, i, evaluesbuffer(i) )\n\t\t\tend do\n\t\tend if\n\t\t\n\t\tif( present(evecs) ) then\n\t\t\tevecs = evecsbuffer\n\t\tend if\n\t\t\n\t\tdeallocate( workspace )\n\t\tdeallocate( evaluesbuffer )\n\tend subroutine eigen\n"}
{"id": 1201, "subroutine": "\tsubroutine eigennotsorted( this, evalues, evals, evecs )\n\t\tclass(matrix), intent(in) :: this\n\t\treal(8), allocatable, optional, intent(inout) :: evalues(:)\n\t\ttype(matrix), optional, intent(inout) :: evals\n\t\ttype(matrix), optional, intent(inout) :: evecs\n\t\t\n\t\ttype(matrix) :: copymat, evecsbufferr, evecsbufferl\n\t\treal(8), allocatable :: evaluesbufferr(:), evaluesbufferl(:)\n\t\treal(8), allocatable :: workspace(:)\n\t\tinteger :: i, ssize, info\n\t\t\n\t\tif( this.type /= square_matrix ) then\n\t\t\twrite(*,*) \"### error ### matrix.eigennotsorted: matrix not square\"\n\t\t\tstop\n\t\tend if\n\t\t\n\t\tssize = this.nrows\n\t\tcopymat = this\n\t\tevecsbufferr = this\n\t\tevecsbufferl = this\n\t\t\n\t\tallocate( evaluesbufferr(ssize) )\n\t\tallocate( evaluesbufferl(ssize) )\n\t\tallocate( workspace( 4*ssize ) )\n\t\t\n\t\tcall dgeev( 'n', 'v', ssize, copymat.data, ssize, evaluesbufferr, evaluesbufferl, evecsbufferl.data, ssize, evecsbufferr.data, ssize, workspace, 4*ssize, info )\n\t\t\n\t\tif ( info /= 0 ) then\n\t\t\twrite(*,*) \"### error ### matrix.eigennotsorted: values matrix failed\"\n\t\tend if\n\t\t\n\t\tif( present(evalues) ) then\n\t\t\tif( allocated(evalues) ) deallocate(evalues)\n\t\t\tallocate(evalues(ssize))\n\t\t\tevalues = evaluesbufferr\n\t\tend if\n\t\t\n\t\tif( present(evals) ) then\n\t\t\tcall evals.init( ssize, ssize, 0.0_8 )\n\t\t\tdo i=1,ssize\n\t\t\t\tcall evals.set( i, i, evaluesbufferr(i) )\n\t\t\tend do\n\t\tend if\n\t\t\n\t\tif( present(evecs) ) then\n\t\t\tevecs = evecsbufferr\n\t\tend if\n\t\t\n\t\tdeallocate( workspace )\n\t\tdeallocate( evaluesbufferl )\n\t\tdeallocate( evaluesbufferr )\n\tend subroutine eigennotsorted\n"}
{"id": 1202, "subroutine": "subroutine psi_s_convert_hll_from_coo(a,hksz,tmp,info)\n  use psb_base_mod\n  use psb_s_hll_mat_mod, psb_protect_name => psi_s_convert_hll_from_coo\n  use psi_ext_util_mod\n  implicit none \n  class(psb_s_hll_sparse_mat), intent(inout) :: a\n  class(psb_s_coo_sparse_mat), intent(in)    :: tmp\n  integer(psb_ipk_), intent(in)               :: hksz\n  integer(psb_ipk_), intent(out)             :: info\n\n  !locals\n  integer(psb_ipk_)   :: nza, nr, i,j,irw, idl,err_act, nc, isz,irs\n  integer(psb_ipk_)   :: nzm, ir, ic, k, hk, mxrwl, noffs, kc\n\n\n  if (.not.tmp%is_by_rows()) then \n    info = -98765\n    return\n  end if\n\n\n  nr  = tmp%get_nrows()\n  nc  = tmp%get_ncols()\n  nza = tmp%get_nzeros()\n  ! if it is sorted then we can lessen memory impact \n  a%psb_s_base_sparse_mat = tmp%psb_s_base_sparse_mat\n\n  ! first compute the number of nonzeros in each row.\n  call psb_realloc(nr,a%irn,info) \n  if (info /= 0) return\n  a%irn = 0\n  do i=1, nza\n    a%irn(tmp%ia(i)) = a%irn(tmp%ia(i)) + 1\n  end do\n\n  a%nzt = nza\n  ! second. figure out the block offsets. \n  call a%set_hksz(hksz)\n  noffs = (nr+hksz-1)/hksz\n  call psb_realloc(noffs+1,a%hkoffs,info) \n  if (info /= 0) return\n  a%hkoffs(1) = 0\n  j=1\n  do i=1,nr,hksz\n    ir    = min(hksz,nr-i+1) \n    mxrwl = a%irn(i)\n    do k=1,ir-1\n      mxrwl = max(mxrwl,a%irn(i+k))\n    end do\n    a%hkoffs(j+1) = a%hkoffs(j) + mxrwl*hksz\n    j = j + 1 \n  end do\n\n  !\n  ! at this point a%hkoffs(noffs+1) contains the allocation\n  ! size a%ja a%val. \n  ! \n  isz = a%hkoffs(noffs+1)\n  call psb_realloc(nr,a%idiag,info) \n  if (info == 0) call psb_realloc(isz,a%ja,info) \n  if (info == 0) call psb_realloc(isz,a%val,info) \n  if (info /= 0) return\n  ! init last chunk of data\n  nzm = a%hkoffs(noffs+1)-a%hkoffs(noffs)\n  a%val(isz-(nzm-1):isz) = szero\n  a%ja(isz-(nzm-1):isz)  = nr\n  !\n  ! now copy everything, noting the position of the diagonal. \n  !\n  kc = 1 \n  k  = 1\n  do i=1, nr,hksz\n    ir    = min(hksz,nr-i+1) \n    irs   = (i-1)/hksz\n    hk    = irs + 1\n    isz   = (a%hkoffs(hk+1)-a%hkoffs(hk))\n    mxrwl = isz/hksz\n    nza   = sum(a%irn(i:i+ir-1))\n    call psi_s_xtr_ell_from_coo(i,ir,mxrwl,tmp%ia(kc:kc+nza-1),&\n         & tmp%ja(kc:kc+nza-1),tmp%val(kc:kc+nza-1),&\n         & a%ja(k:k+isz-1),a%val(k:k+isz-1),a%irn(i:i+ir-1),&\n         & a%idiag(i:i+ir-1),hksz)\n    k  = k + isz\n    kc = kc + nza\n\n  enddo\n\n  ! third copy the other stuff\n  if (info /= 0) return\n  call a%set_sorted(.true.)\n\nend subroutine psi_s_convert_hll_from_coo\n"}
{"id": 1203, "subroutine": "    subroutine ext1 (a, b)\n      real, intent (in), dimension (:, :) :: a, b\n    end subroutine ext1\n"}
{"id": 1204, "subroutine": "    subroutine ext3 (a, b)\n      real, dimension (:, :) :: a, b\n    end subroutine ext3\n"}
{"id": 1205, "subroutine": "  subroutine test1 (n, a, b, c)\n    integer :: n\n    real, dimension (n, n) :: a, b, c\n    a = matmul (transpose (b), c)\n  end subroutine test1\n"}
{"id": 1206, "subroutine": "  subroutine test4 (n, a, b)\n    integer :: n\n    real, dimension (n, n) :: a, b\n    a = matmul (transpose (a), b)       ! { dg-warning \"creating array temporary\" }\n  end subroutine test4\n"}
{"id": 1207, "subroutine": "  subroutine test5 (n, a)\n    integer :: n\n    real, dimension (n, n) :: a\n    call imp1 (transpose (a), a)        ! { dg-warning \"creating array temporary\" }\n  end subroutine test5\n"}
{"id": 1208, "subroutine": "  subroutine test6_bis (n, a, b)\n    integer :: n\n    real, dimension (n, n) :: a, b\n    call ext3 (transpose (a), transpose (b))\n  end subroutine test6_bis\n"}
{"id": 1209, "subroutine": "  subroutine test7 (n, a)\n    integer :: n\n    real, dimension (n, n) :: a\n    call ext1 (transpose (a), a)\n  end subroutine test7\n"}
{"id": 1210, "subroutine": "  subroutine test10 (n, a)\n    integer :: n\n    real, dimension (n, n) :: a\n    call ext2 (transpose (transpose (a)), a)    ! { dg-warning \"creating array temporary\" }\n  end subroutine test10\n"}
{"id": 1211, "subroutine": "    subroutine allocate_arrays(this, c_size, a_size, b_size)\n        class(tc_descriptor), intent(inout) :: this\n        integer, intent(in) :: c_size, a_size, b_size\n\n        call this%deallocate_arrays()\n\n        allocate(this%c_indices( c_size ))\n        allocate(this%a_indices( a_size ))\n        allocate(this%b_indices( b_size ))\n    end subroutine allocate_arrays\n"}
{"id": 1212, "subroutine": "    subroutine deallocate_arrays(this)\n        class(tc_descriptor), intent(inout) :: this\n\n        if ( allocated(this%c_indices) ) deallocate(this%c_indices)\n        if ( allocated(this%a_indices) ) deallocate(this%a_indices)\n        if ( allocated(this%b_indices) ) deallocate(this%b_indices)\n    end subroutine deallocate_arrays\n"}
{"id": 1213, "subroutine": "    subroutine cleanup(this)\n        class(tc_descriptor), intent(inout) :: this\n\n        call this%deallocate_arrays()\n        call this%clear()\n    end subroutine cleanup\n"}
{"id": 1214, "subroutine": "    subroutine clear(this)\n        class(tc_descriptor), intent(inout) :: this\n\n        this%num_unique_indices = 0\n        this%num_external_indices = 0\n        this%num_internal_indices = 0\n    end subroutine clear\n"}
{"id": 1215, "subroutine": "subroutine matrixd_initialise(this, n, m, nb, mb, scalapack_obj)\n  type(matrixd), intent(out) :: this\n  integer, intent(in), optional :: n, m, nb, mb\n  type(scalapack), intent(in), optional :: scalapack_obj\n\n  call finalise(this)\n\n  call matrixany_initialise(n, m, nb, mb, scalapack_obj, this%n, this%m, this%l_n, this%l_m, &\n                            this%scalapack_info_obj)\n  if (this%l_n > 0 .and. this%l_m > 0) then\n    allocate(this%data(this%l_n, this%l_m))\n    call alloc_trace(\"matrixd_initialise \"//this%l_n//\" \"//this%l_m, size(this%data)*real_size)\n  else\n    allocate(this%data(1,1))\n    call alloc_trace(\"matrixd_initialise \"//1//\" \"//1, size(this%data)*real_size)\n  endif\n\nend subroutine matrixd_initialise\n"}
{"id": 1216, "subroutine": "subroutine matrixd_initialise_mat(this, from)\n  type(matrixd), intent(out) :: this\n  type(matrixd), intent(in) :: from\n\n  call finalise(this)\n\n  this%n = from%n\n  this%m = from%m\n  this%l_n = from%l_n\n  this%l_m = from%l_m\n  this%scalapack_info_obj = from%scalapack_info_obj\n\n  if (this%l_n > 0 .and. this%l_m > 0) then\n    allocate(this%data(this%l_n, this%l_m))\n    call alloc_trace(\"matrixd_initialise_mat \"//this%l_n//\" \"//this%l_m,size(this%data)*real_size)\n  else\n    allocate(this%data(1,1))\n    call alloc_trace(\"matrixd_initialise_mat \"//1//\" \"//1, size(this%data)*real_size)\n  endif\n\nend subroutine matrixd_initialise_mat\n"}
{"id": 1217, "subroutine": "subroutine matrixd_to_array1d(this, array)\n  type(matrixd), intent(inout) :: this\n  real(dp), intent(out), dimension(:) :: array\n\n  integer :: nrows\n\n  if (this%scalapack_info_obj%active) then\n    call scalapack_to_array1d(this%scalapack_info_obj, this%data, array)\n  else\n    nrows = min(this%n, size(array, 1))\n    array(:nrows) = this%data(:nrows,1)\n    array(nrows+1:) = 0.0_dp\n  end if\nend subroutine matrixd_to_array1d\n"}
{"id": 1218, "subroutine": "subroutine matrixd_qr_solve(a_sp, b_sp)\n  type(matrixd), intent(inout) :: a_sp, b_sp\n\n  if (a_sp%scalapack_info_obj%active .and. &\n      b_sp%scalapack_info_obj%active) then\n    call scalapack_matrix_qr_solve(a_sp%scalapack_info_obj, a_sp%data, b_sp%scalapack_info_obj, b_sp%data)\n  else\n    call system_abort(\"matrixd_qr_solve() without scalapack is not implemented.\")\n  endif\nend subroutine matrixd_qr_solve\n"}
{"id": 1219, "subroutine": "subroutine sp_matrix_qr_solve(a, b, x, procs, scalapack_obj)\n  real(dp), intent(in), dimension(:,:) :: a\n  real(dp), intent(in), dimension(:) :: b\n  real(dp), intent(out), dimension(:) :: x\n  integer, intent(in) :: procs\n  type(scalapack), intent(in) :: scalapack_obj\n\n  integer :: m, n, mb, nb\n  type(matrixd) :: a_sp, b_sp\n\n  mb = size(a, 1)\n  nb = size(a, 2)\n  m = mb * procs\n  n = nb\n\n  ! @fixme hotfix: nb=max(mb, nb) ; nb=nb throws an error in pdtrtrs().\n  call initialise(a_sp, m, n, mb, max(mb, nb), scalapack_obj=scalapack_obj)\n  call initialise(b_sp, m, 1, mb, 1, scalapack_obj=scalapack_obj)\n\n  a_sp%data(:,:) = 0.0_qp\n  a_sp%data(:,:) = a\n  b_sp%data(:,:) = 0.0_qp\n  b_sp%data(:,1) = b\n\n  call matrixd_qr_solve(a_sp, b_sp)\n  call matrixd_to_array1d(b_sp, x)\n\n  call finalise(a_sp)\n  call finalise(b_sp)\nend subroutine sp_matrix_qr_solve\n"}
{"id": 1220, "subroutine": "subroutine matrixz_initialise(this, n, m, nb, mb, scalapack_obj)\n  type(matrixz), intent(out) :: this\n  integer, intent(in), optional :: n, m, nb, mb\n  type(scalapack), intent(in), optional :: scalapack_obj\n\n  call finalise(this)\n\n  call matrixany_initialise(n, m, nb, mb, scalapack_obj, this%n, this%m, this%l_n, this%l_m, &\n                            this%scalapack_info_obj)\n\n  if (this%l_n > 0 .and. this%l_m > 0) then\n    allocate(this%data(this%l_n, this%l_m))\n    call alloc_trace(\"matrixz_initialise \"//this%l_n//\" \"//this%l_m, size(this%data)*complex_size)\n  else\n    allocate(this%data(1,1))\n    call alloc_trace(\"matrixz_initialise \"//1//\" \"//1, size(this%data)*real_size)\n  endif\n\nend subroutine matrixz_initialise\n"}
{"id": 1221, "subroutine": "subroutine matrixany_initialise(n, m, nb, mb, scalapack_obj, this_n, this_m, this_l_n, this_l_m, &\n                                this_scalapack_info_obj)\n  integer, intent(in), optional :: n, m, nb, mb\n  type(scalapack), intent(in), target, optional :: scalapack_obj\n  integer, intent(out) :: this_n, this_m, this_l_n, this_l_m\n  type(matrix_scalapack_info), intent(out) :: this_scalapack_info_obj\n\n  integer use_nb, use_mb\n\n  this_n = 0\n  this_m = 0\n  this_l_n = 0\n  this_l_m = 0\n\n  if (present(n)) then\n    this_n = n\n    if (present(m)) then\n      this_m = m\n    else\n      this_m = n\n    endif\n\n    if (present(nb)) then\n      use_nb = nb\n    else\n      use_nb = 36\n    endif\n    if (present(mb)) then\n      use_mb = mb\n    else\n      use_mb = 36\n    endif\n\n    if (present(scalapack_obj)) then\n      call initialise(this_scalapack_info_obj, this_n, this_m, use_nb, use_mb, scalapack_obj)\n    else\n      call initialise(this_scalapack_info_obj, n, m, use_nb, use_mb)\n    endif\n    if (this_scalapack_info_obj%active) then\n      this_l_n = this_scalapack_info_obj%l_n_r\n      this_l_m = this_scalapack_info_obj%l_n_c\n    else\n      this_l_n = this_n\n      this_l_m = this_m\n    endif\n  endif\nend subroutine matrixany_initialise\n"}
{"id": 1222, "subroutine": "subroutine matrixd_finalise(this)\n  type(matrixd), intent(inout) :: this\n\n  call wipe(this)\n  call finalise(this%scalapack_info_obj)\n\nend subroutine matrixd_finalise\n"}
{"id": 1223, "subroutine": "subroutine matrixd_wipe(this)\n  type(matrixd), intent(inout) :: this\n\n  call wipe(this%scalapack_info_obj)\n\n  if (allocated(this%data)) then\n    call dealloc_trace(\"matrixd_wipe \", size(this%data)*real_size)\n    deallocate(this%data)\n  endif\n\n  this%n = 0\n  this%m = 0\n  this%l_n = 0\n  this%l_m = 0\n\nend subroutine matrixd_wipe\n"}
{"id": 1224, "subroutine": "subroutine matrixd_zero(this, d_mask, od_mask)\n  type(matrixd), intent(inout) :: this\n  logical, intent(in), optional :: d_mask(:), od_mask(:)\n\n  integer i\n\n  if (allocated(this%data)) then\n    if (present(d_mask) .or. present(od_mask)) then\n      if (present(d_mask)) then\n        do i=1, min(size(d_mask), this%n, this%m)\n          if (d_mask(i)) this%data(i,i) = 0.0_dp\n        end do\n      end if\n      if (present(od_mask)) then\n        do i=1, size(od_mask)\n          if (od_mask(i)) then\n            if (i <= this%m) this%data(:,i) = 0.0_dp\n            if (i <= this%n) this%data(i,:) = 0.0_dp\n          end if\n        end do\n      end if\n    else\n      this%data = 0.0_dp\n    endif\n  endif\n\nend subroutine\n"}
{"id": 1225, "subroutine": "subroutine matrixz_finalise(this)\n  type(matrixz), intent(inout) :: this\n\n  call matrixz_wipe(this)\n  call finalise(this%scalapack_info_obj)\n\nend subroutine matrixz_finalise\n"}
{"id": 1226, "subroutine": "subroutine matrixz_wipe(this)\n  type(matrixz), intent(inout) :: this\n\n  call wipe(this%scalapack_info_obj)\n\n  if (allocated(this%data)) then\n    call dealloc_trace(\"matrixz_wipe \", size(this%data)*complex_size)\n    deallocate(this%data)\n  endif\n\n  this%n = 0\n  this%m = 0\n  this%l_n = 0\n  this%l_m = 0\n\nend subroutine matrixz_wipe\n"}
{"id": 1227, "subroutine": "subroutine matrixd_print(this,file)\n  type(matrixd),    intent(in)           :: this\n  type(inoutput), intent(inout),optional:: file\n\n  if (current_verbosity() < print_normal) return\n\n  call print (\"matrixd : \", file=file)\n\n  call print (\"n m \" // this%n // \" \" // this%m // \" l_n l_m \"  // this%l_n // \" \" // this%l_m, file=file)\n  call print (this%scalapack_info_obj, file=file)\n  call print (\"matrixd data:\", file=file)\n  if (this%scalapack_info_obj%active)  then\n    call print(this%scalapack_info_obj, this%data, file=file)\n  else\n    if (allocated(this%data)) then\n      call print(this%data, file=file)\n    endif\n  endif\n\nend subroutine matrixd_print\n"}
{"id": 1228, "subroutine": "subroutine matrixd_add_block(this, block, block_nr, block_nc, first_row, first_col)\n  type(matrixd), intent(inout) :: this\n  real(dp), intent(in) :: block(:,:)\n  integer, intent(in) :: block_nr, block_nc   !% number of rows and columns of the block\n  integer, intent(in) :: first_row, first_col\n\n  integer i, j, io, jo, li, lj\n\n  if (this%scalapack_info_obj%active) then\n    do jo=1, block_nc\n    j = first_col + jo - 1\n    do io=1, block_nr\n      i = first_row + io - 1\n      call coords_global_to_local(this%scalapack_info_obj, i, j, li, lj)\n      if (li > 0 .and. lj > 0) then\n        this%data(li,lj) = this%data(li,lj) + block(io,jo)\n      endif\n    end do\n    end do\n  else\n    this%data(first_row:first_row+block_nr-1,first_col:first_col+block_nc-1) = &\n      this%data(first_row:first_row+block_nr-1,first_col:first_col+block_nc-1) + &\n      block(1:block_nr,1:block_nc)\n  endif\n\nend subroutine\n"}
{"id": 1229, "subroutine": "subroutine matrixd_diagonalise(this, evals, evecs, ignore_symmetry, error)\n  type(matrixd), intent(in), target :: this\n  real(dp), intent(inout) :: evals(:)    !% eigenvalues\n  type(matrixd), intent(inout), target, optional :: evecs  !% eigenvectors\n  logical, intent(in), optional :: ignore_symmetry\n  integer, intent(out), optional :: error\n\n  real(dp), pointer :: u_evecs(:,:)\n  type(matrix_scalapack_info), pointer :: evecs_scalapack_info\n\n  init_error(error)\n\n  if (present(evecs)) then\n    u_evecs => evecs%data\n    evecs_scalapack_info => evecs%scalapack_info_obj\n  else\n    allocate(u_evecs(this%l_n,this%l_m))\n    call alloc_trace(\"matrixd_diagonalise evecs \", size(u_evecs)*real_size)\n    evecs_scalapack_info => this%scalapack_info_obj\n  endif\n\n  if (this%scalapack_info_obj%active) then\n    call diagonalise(this%scalapack_info_obj, this%data, evals, evecs_scalapack_info, u_evecs, error = error)\n  else\n    call diagonalise(this%data, evals, u_evecs, ignore_symmetry = ignore_symmetry, error = error)\n  endif\n\n  if (.not.present(evecs)) then\n    call dealloc_trace(\"matrixd_diagonalise evecs \",-size(u_evecs)*real_size)\n    deallocate(u_evecs)\n  endif\n\n  pass_error(error)\n\nend subroutine matrixd_diagonalise\n"}
{"id": 1230, "subroutine": "subroutine matrixd_diagonalise_gen(this, overlap, evals, evecs, ignore_symmetry, error)\n  type(matrixd), intent(in), target :: this\n  type(matrixd), intent(in) :: overlap\n  real(dp), intent(inout) :: evals(:)\n  type(matrixd), intent(inout), target, optional :: evecs\n  logical, intent(in), optional :: ignore_symmetry\n  integer, intent(out), optional :: error\n\n  real(dp), pointer :: u_evecs(:,:)\n  type(matrix_scalapack_info), pointer :: evecs_scalapack_info\n\n  init_error(error)\n\n  if (present(evecs)) then\n    u_evecs => evecs%data\n    evecs_scalapack_info => evecs%scalapack_info_obj\n  else\n    allocate(u_evecs(this%l_n,this%l_m))\n    call alloc_trace(\"matrixd_diagonalise_gen evecs\", size(u_evecs)*real_size)\n    evecs_scalapack_info => this%scalapack_info_obj\n  endif\n\n  if (this%scalapack_info_obj%active) then\n    call diagonalise(this%scalapack_info_obj, this%data, overlap%scalapack_info_obj, &\n      overlap%data, evals, evecs_scalapack_info, u_evecs, error)\n  else\n    call diagonalise(this%data, overlap%data, evals, u_evecs, error = error)\n  endif\n\n  if (.not.present(evecs)) then\n    call dealloc_trace(\"matrixd_diagonalise_gen u_evecs\", size(u_evecs)*real_size)\n    deallocate(u_evecs)\n  endif\n\n  pass_error(error)\n\nend subroutine matrixd_diagonalise_gen\n"}
{"id": 1231, "subroutine": "subroutine matrixz_diagonalise(this, evals, evecs, ignore_symmetry, error)\n  type(matrixz), intent(in), target :: this\n  real(dp), intent(inout) :: evals(:)\n  type(matrixz), intent(inout), target, optional :: evecs\n  logical, intent(in), optional :: ignore_symmetry\n  integer, intent(out), optional :: error\n\n  complex(dp), pointer :: u_evecs(:,:)\n  type(matrix_scalapack_info), pointer :: evecs_scalapack_info\n\n  init_error(error)\n\n  if (present(evecs)) then\n    u_evecs => evecs%data\n    evecs_scalapack_info => evecs%scalapack_info_obj\n  else\n    allocate(u_evecs(this%l_n,this%l_m))\n    call alloc_trace(\"matrixz_diagonalise u_evecs\", size(u_evecs)*complex_size)\n    evecs_scalapack_info => this%scalapack_info_obj\n  endif\n\n  if (this%scalapack_info_obj%active) then\n    call diagonalise(this%scalapack_info_obj, this%data, evals, evecs_scalapack_info, u_evecs, error)\n  else\n    call diagonalise(this%data, evals, u_evecs, ignore_symmetry = ignore_symmetry, error = error)\n  endif\n\n  if (.not.present(evecs)) then\n    call dealloc_trace(\"matrixz_diagonalise u_evecs\", size(u_evecs)*complex_size)\n    deallocate(u_evecs)\n  endif\n\n  pass_error(error)\n\nend subroutine matrixz_diagonalise\n"}
{"id": 1232, "subroutine": "subroutine matrix_scaled_sum_zdd(this, f1, m1, f2, m2)\n  type(matrixz), intent(inout) :: this\n  complex(dp), intent(in) :: f1\n  type(matrixd), intent(in) :: m1\n  complex(dp), intent(in) :: f2\n  type(matrixd), intent(in) :: m2\n\n  integer i\n\n  if (m1%scalapack_info_obj%active .neqv. m2%scalapack_info_obj%active) then\n    call system_abort(\"can't do scaled_sum for mixed scalapcak non-scalapack matrices\")\n  endif\n\n  do i=1, size(this%data,2)\n    this%data(:,i) = f1*m1%data(:,i) + f2*m2%data(:,i)\n  end do\n\nend subroutine matrix_scaled_sum_zdd\n"}
{"id": 1233, "subroutine": "subroutine matrix_scaled_accum_dz(this, f1, m1)\n  type(matrixd), intent(inout) :: this\n  complex(dp), intent(in) :: f1\n  type(matrixz), intent(in) :: m1\n\n  integer i\n\n  if (this%scalapack_info_obj%active .neqv. m1%scalapack_info_obj%active) then\n    call system_abort(\"can't do scaled_accum for mixed scalapcak non-scalapack matrices\")\n  endif\n\n  do i=1, size(this%data,2)\n    this%data(:,i) = this%data(:,i) + f1*m1%data(:,i)\n  end do\n\nend subroutine matrix_scaled_accum_dz\n"}
{"id": 1234, "subroutine": "subroutine matrixd_inverse(this, inv, positive)\n  type(matrixd), intent(inout) :: this\n  type(matrixd), intent(out), optional :: inv\n  logical, intent(in), optional :: positive\n\n  if (this%scalapack_info_obj%active) then\n    if (present(inv)) then\n      call inverse(this%scalapack_info_obj, this%data, inv%scalapack_info_obj, inv%data, positive)\n    else\n      call inverse(this%scalapack_info_obj, this%data, positive_in = positive)\n    endif\n  else\n    if (present(inv)) then\n      call inverse(this%data, inv%data, positive)\n    else\n      call inverse(this%data, positive_in = positive)\n    endif\n  endif\nend subroutine matrixd_inverse\n"}
{"id": 1235, "subroutine": "subroutine matrixd_multdiag_d(this, a, diag)\n  type(matrixd), intent(inout) :: this\n  type(matrixd), intent(in) :: a\n  real(dp), intent(in) :: diag(:)\n\n  if (this%m /= size(diag) .or. a%m /= size(diag)) &\n    call system_abort(\"called matrixd_multdiag_d with mismatched sizes\")\n\n  if (this%scalapack_info_obj%active .and. a%scalapack_info_obj%active) then\n    call matrix_product_vect_asdiagonal_sub(this%scalapack_info_obj, this%data, a%scalapack_info_obj, a%data, diag)\n  else if (.not.this%scalapack_info_obj%active .and. .not.a%scalapack_info_obj%active) then\n    call matrix_product_vect_asdiagonal_sub(this%data, a%data, diag)\n  else\n    call system_abort(\"called matrixd_multdiag_d with mix of scalapack and non-scalapack objects\")\n  endif\nend subroutine matrixd_multdiag_d\n"}
{"id": 1236, "subroutine": "subroutine matrixd_multdiagrl_d(this, a, diag)\n  type(matrixd), intent(inout) :: this\n  type(matrixd), intent(in) :: a\n  real(dp), intent(in) :: diag(:)\n\n  if (this%m /= size(diag) .or. a%m /= size(diag)) &\n    call system_abort(\"called matrixd_multdiagrl_d with mismatched sizes\")\n\n  call matrix_product_vect_asdiagonal_rl_sub(this%data, a%data, diag)\nend subroutine matrixd_multdiagrl_d\n"}
{"id": 1237, "subroutine": "subroutine matrixz_matrix_product_sub_zz(c, a, b, a_transpose, a_conjugate, b_transpose, b_conjugate)\n  type(matrixz), intent(inout) :: c\n  type(matrixz), intent(in) :: a, b\n  logical, intent(in), optional :: a_transpose, a_conjugate, b_transpose, b_conjugate\n\n  if (a%scalapack_info_obj%active .and. &\n      b%scalapack_info_obj%active .and. &\n      c%scalapack_info_obj%active) then\n    call matrix_product_sub(c%scalapack_info_obj, c%data, a%scalapack_info_obj, a%data, b%scalapack_info_obj, b%data, &\n      a_transpose, a_conjugate, b_transpose, b_conjugate)\n  else if (.not.a%scalapack_info_obj%active .and. &\n           .not.b%scalapack_info_obj%active .and. &\n           .not.c%scalapack_info_obj%active) then\n    call matrix_product_sub(c%data, a%data, b%data, a_transpose, a_conjugate, b_transpose, b_conjugate)\n  else\n    call system_abort(\"called matrixz_matric_product_sub_zz with a mix of scalapack and non-scalapack matrices\")\n  endif\nend subroutine matrixz_matrix_product_sub_zz\n"}
{"id": 1238, "subroutine": "subroutine matrixz_matrix_product_sub_dz(c, a, b, a_transpose, b_transpose, b_conjugate)\n  type(matrixz), intent(inout) :: c\n  type(matrixd), intent(in) :: a\n  type(matrixz), intent(in) :: b\n  logical, intent(in), optional :: a_transpose, b_transpose, b_conjugate\n\n  logical a_transp, b_transp, b_conjg\n  real(dp), allocatable :: tc(:,:), tb(:,:)\n\n  allocate(tc(c%l_n, c%l_m))\n  call alloc_trace(\"matrixz_product_sub_dz tc\", size(tc)*real_size)\n  allocate(tb(b%l_n, b%l_m))\n  call alloc_trace(\"matrixz_product_sub_dz tb\", size(tb)*real_size)\n\n  a_transp = optional_default(.false., a_transpose)\n  b_transp = optional_default(.false., b_transpose)\n  b_conjg  = optional_default(.false., b_conjugate)\n\n  if (a%scalapack_info_obj%active .and. &\n      b%scalapack_info_obj%active .and. &\n      c%scalapack_info_obj%active) then\n    tb = dble(b%data)\n    call matrix_product_sub(c%scalapack_info_obj, tc, a%scalapack_info_obj, a%data, b%scalapack_info_obj, tb, &\n      a_transp, b_transp .or. b_conjg)\n    c%data = tc\n    if (b_conjg) then\n      tb = -aimag(b%data)\n    else\n      tb = aimag(b%data)\n    endif\n    call matrix_product_sub(c%scalapack_info_obj, tc, a%scalapack_info_obj, a%data, b%scalapack_info_obj, tb, &\n      a_transp, b_transp .or. b_conjg)\n    c%data = c%data + cmplx(0.0_dp, tc, dp)\n  else if (.not.a%scalapack_info_obj%active .and. &\n           .not.b%scalapack_info_obj%active .and. &\n           .not.c%scalapack_info_obj%active) then\n    tb = dble(b%data)\n    call matrix_product_sub(tc, a%data, tb, a_transp, b_transp .or. b_conjg)\n    c%data = tc\n    if (b_conjg) then\n      tb = -aimag(b%data)\n    else\n      tb = aimag(b%data)\n    endif\n    call matrix_product_sub(tc, a%data, tb, a_transp, b_transp .or. b_conjg)\n    c%data = c%data + cmplx(0.0_dp, tc, dp)\n  else\n    call system_abort(\"called matrixz_matric_product_sub_dz with a mix of scalapack and non-scalapack matrices\")\n  endif\n\n  call dealloc_trace(\"matrixz_product_sub_dz tc\", size(tc)*real_size)\n  deallocate(tc)\n  call dealloc_trace(\"matrixz_product_sub_dz tb\", size(tb)*real_size)\n  deallocate(tb)\nend subroutine matrixz_matrix_product_sub_dz\n"}
{"id": 1239, "subroutine": "subroutine matrixz_matrix_product_sub_zd(c, a, b, a_transpose, a_conjugate, b_transpose)\n  type(matrixz), intent(inout) :: c\n  type(matrixz), intent(in) :: a\n  type(matrixd), intent(in) :: b\n  logical, intent(in), optional :: a_transpose, a_conjugate, b_transpose\n\n  logical a_transp, a_conjg, b_transp\n  real(dp), allocatable :: tc(:,:), ta(:,:)\n\n  allocate(tc(c%l_n, c%l_m))\n  call alloc_trace(\"matrixz_product_sub_zd tc\", size(tc)*real_size)\n  allocate(ta(a%l_n, a%l_m))\n  call alloc_trace(\"matrixz_product_sub_zd ta\", size(ta)*real_size)\n\n  a_transp = optional_default(.false., a_transpose)\n  a_conjg  = optional_default(.false., a_conjugate)\n  b_transp = optional_default(.false., b_transpose)\n\n  if (a%scalapack_info_obj%active .and. &\n      b%scalapack_info_obj%active .and. &\n      c%scalapack_info_obj%active) then\n    ta = dble(a%data)\n    call matrix_product_sub(c%scalapack_info_obj, tc, a%scalapack_info_obj, ta, b%scalapack_info_obj, b%data, &\n      a_transp .or. a_conjg, b_transp)\n    c%data = tc\n    if (a_conjg) then\n      ta = -aimag(a%data)\n    else\n      ta = aimag(a%data)\n    endif\n    call matrix_product_sub(c%scalapack_info_obj, tc, a%scalapack_info_obj, ta, b%scalapack_info_obj, b%data, &\n      a_transp .or. a_conjg, b_transp)\n    c%data = c%data + cmplx(0.0_dp, tc, dp)\n  else if (.not.a%scalapack_info_obj%active .and. &\n           .not.b%scalapack_info_obj%active .and. &\n           .not.c%scalapack_info_obj%active) then\n    ta = dble(a%data)\n    call matrix_product_sub(tc, ta, b%data, a_transp .or. a_conjg, b_transp)\n    c%data = tc\n    if (a_conjg) then\n      ta = -aimag(a%data)\n    else\n      ta = aimag(a%data)\n    endif\n    call matrix_product_sub(tc, ta, b%data, a_transp .or. a_conjg, b_transp)\n    c%data = c%data + cmplx(0.0_dp, tc, dp)\n  else\n    call system_abort(\"called matrixz_matric_product_sub_zd with a mix of scalapack and non-scalapack matrices\")\n  endif\n\n  call dealloc_trace(\"matrixz_product_sub_zd tc\", size(tc)*real_size)\n  deallocate(tc)\n  call dealloc_trace(\"matrixz_product_sub_zd ta\", size(ta)*real_size)\n  deallocate(ta)\nend subroutine matrixz_matrix_product_sub_zd\n"}
{"id": 1240, "subroutine": "subroutine matrixd_matrix_product_sub_dd(c, a, b, a_transpose, b_transpose)\n  type(matrixd), intent(inout) :: c\n  type(matrixd), intent(in) :: a, b\n  logical, intent(in), optional :: a_transpose, b_transpose\n\n  if (a%scalapack_info_obj%active .and. &\n      b%scalapack_info_obj%active .and. &\n      c%scalapack_info_obj%active) then\n    call matrix_product_sub(c%scalapack_info_obj, c%data, a%scalapack_info_obj, a%data, b%scalapack_info_obj, b%data, &\n      a_transpose, b_transpose)\n  else if (.not.a%scalapack_info_obj%active .and. &\n           .not.b%scalapack_info_obj%active .and. &\n           .not.c%scalapack_info_obj%active) then\n    call matrix_product_sub(c%data, a%data, b%data, a_transpose, b_transpose)\n  else\n    call system_abort(\"called matrixd_matric_product_sub_dd with a mix of scalapack and non-scalapack matrices\")\n  endif\nend subroutine matrixd_matrix_product_sub_dd\n"}
{"id": 1241, "subroutine": "subroutine matrixd_matrix_product_sub_dr2(c, a, b, a_transpose, b_transpose)\n  type(matrixd), intent(inout) :: c\n  type(matrixd), intent(in) :: a\n  real(dp), intent(in) :: b(:,:)\n  logical, intent(in), optional :: a_transpose, b_transpose\n\n  if (.not.a%scalapack_info_obj%active .and.  .not.c%scalapack_info_obj%active) then\n    call matrix_product_sub(c%data, a%data, b, a_transpose, b_transpose)\n  else\n    call system_abort(\"called matrixz_matric_product_sub_dr2 with a mix of scalapack and non-scalapack matrices\")\n  endif\n\nend subroutine matrixd_matrix_product_sub_dr2\n"}
{"id": 1242, "subroutine": "subroutine matrixd_add_identity(a)\n  type(matrixd), intent(inout) :: a\n\n  if (a%scalapack_info_obj%active) then\n    call add_identity(a%scalapack_info_obj, a%data)\n  else\n    call add_identity(a%data)\n  endif\nend subroutine\n"}
{"id": 1243, "subroutine": "subroutine matrixd_scale(a, scale)\n  type(matrixd), intent(inout) :: a\n  real(dp), intent(in) :: scale\n\n  a%data = a%data * scale\nend subroutine\n"}
{"id": 1244, "subroutine": "subroutine matrixd_transpose_sub(this, m)\n  type(matrixd), intent(inout) :: this\n  type(matrixd), intent(in) :: m\n\n  if (this%n /= m%m .or. this%m /= m%n) call system_abort(\"called matrixd_transpose_sub with mismatched sizes \"// &\n    \"this \" // this%n // \" \" // this%m // \" m \" // m%n // \" \" //m%m)\n\n\n  if (this%scalapack_info_obj%active .and. m%scalapack_info_obj%active) then\n    call system_abort(\"matrixd_transpose_sub not yet implemented for scalapack matrices\")\n  else\n    this%data = transpose(m%data)\n  endif\nend subroutine matrixd_transpose_sub\n"}
{"id": 1245, "subroutine": "subroutine matrixd_make_hermitian(this)\n  type(matrixd), intent(inout) :: this\n\n  if (this%scalapack_info_obj%active) then\n    call system_abort(\"matrixd_make_hermitian not yet implemented for scalapack matrices\")\n  else\n    call make_hermitian(this%data)\n  endif\nend subroutine matrixd_make_hermitian\n"}
{"id": 1246, "subroutine": "subroutine matrixz_make_hermitian(this)\n  type(matrixz), intent(inout) :: this\n\n  if (this%scalapack_info_obj%active) then\n    call system_abort(\"matrixz_make_hermitian not yet implemented for scalapack matrices\")\n  else\n    call make_hermitian(this%data)\n  endif\nend subroutine matrixz_make_hermitian\n"}
{"id": 1247, "subroutine": "      subroutine fieldlines_init_fline\n!-----------------------------------------------------------------------\n!     libraries\n!-----------------------------------------------------------------------\n      use stel_kinds, only: rprec\n      use fieldlines_lines, only: nlines\n      use fieldlines_runtime\n      use ez_hdf5\n      use mpi_params\n      use mpi_inc\n!-----------------------------------------------------------------------\n!     local variables\n!          ier            error flag\n!-----------------------------------------------------------------------\n      implicit none\n      integer :: ier, i\n      integer :: npoinc_old, nlines_old\n      real(rprec) :: dphi_old\n      real(rprec), allocatable, dimension(:,:) :: r_old, z_old, phi_old\n\n!      integer, parameter :: line_select = 64\n      integer, parameter :: nnew_lines = 2**17\n!-----------------------------------------------------------------------\n\n!-----------------------------------------------------------------------\n      if (lverb) then\n         write(6,'(a)')  '----- generating starting points -----'\n         write(6,'(a)')  '   file: '//trim(restart_string)\n         write(6,'(a,i6)') '   new_lines: ',nnew_lines*2\n         write(6,'(a,i3)') '      line #: ',line_select\n      end if\n#if defined(mpi_opt)\n      call mpi_barrier(mpi_comm_fieldlines,ierr_mpi)\n#endif\n      ! setup phi_end before going on\n      i = maxloc(abs(phi_end),dim=1)\n      phi_end(1:nnew_lines) = phi_end(i)\n      ! initialize fieldine data\n      r_start   = -1\n      z_start   = -1\n      phi_start =  0\n      phi_end(nnew_lines+1:maxlines)   =  0\n#if defined(lhdf5)\n      if (myworkid == master) then\n         call open_hdf5(trim(restart_string),fid,ier,lcreate=.false.)\n         call read_scalar_hdf5(fid,'nsteps',ier,intvar=npoinc_old)\n         call read_scalar_hdf5(fid,'nlines',ier,intvar=nlines_old)\n         if (lverb) then\n            write(6,'(a,i3)') '   old_lines: ',nlines_old\n            write(6,'(a,i6)') '      nsteps: ',npoinc_old\n         end if\n         allocate(r_old(nlines_old,npoinc_old+1), &\n                  z_old(nlines_old,npoinc_old+1), &\n                  phi_old(nlines_old,npoinc_old+1))\n         call read_var_hdf5(fid,'r_lines',nlines_old,npoinc_old+1,ier,dblvar=r_old)\n         call read_var_hdf5(fid,'z_lines',nlines_old,npoinc_old+1,ier,dblvar=z_old)\n         call read_var_hdf5(fid,'phi_lines',nlines_old,npoinc_old+1,ier,dblvar=phi_old)\n         call close_hdf5(fid,ier)\n         npoinc_old = npoinc_old - 1\n         ! setup new phi\n         dphi_old = phi_old(line_select,2) - phi_old(line_select,1)\n         call random_number(phi_start(1:nnew_lines))\n         phi_start = phi_start * phi_old(line_select,npoinc_old)\n         call spline_it(npoinc_old, &\n                        phi_old(line_select,1:npoinc_old), &\n                        r_old(line_select,1:npoinc_old), &\n                        nnew_lines, &\n                        phi_start(1:nnew_lines), &\n                        r_start(1:nnew_lines), 0)\n         call spline_it(npoinc_old, &\n                        phi_old(line_select,1:npoinc_old), &\n                        z_old(line_select,1:npoinc_old), &\n                        nnew_lines, &\n                        phi_start(1:nnew_lines), &\n                        z_start(1:nnew_lines), 0)\n         deallocate(r_old, phi_old, z_old)\n         ! now setup reverse fieldline trace\n         i = nnew_lines+1\n         phi_start(i:2*nnew_lines) = phi_start(1:nnew_lines)\n         r_start(i:2*nnew_lines) = r_start(1:nnew_lines)\n         z_start(i:2*nnew_lines) = z_start(1:nnew_lines)\n         phi_end(i:2*nnew_lines) = -phi_end(1:nnew_lines)\n         nlines = 2*nnew_lines\n      end if\n#endif\n#if defined(mpi_opt)\n      call mpi_barrier(mpi_comm_fieldlines,ierr_mpi)\n      call mpi_bcast(nlines,           1, mpi_integer, master, mpi_comm_fieldlines, ierr_mpi)\n      call mpi_bcast(r_start,   maxlines,   mpi_real8, master, mpi_comm_fieldlines, ierr_mpi)\n      call mpi_bcast(z_start,   maxlines,   mpi_real8, master, mpi_comm_fieldlines, ierr_mpi)\n      call mpi_bcast(phi_start, maxlines,   mpi_real8, master, mpi_comm_fieldlines, ierr_mpi)\n      call mpi_bcast(phi_end,   maxlines,   mpi_real8, master, mpi_comm_fieldlines, ierr_mpi)\n#endif\n      return\n!-----------------------------------------------------------------------\n\n!-----------------------------------------------------------------------    \n      end subroutine fieldlines_init_fline\n"}
{"id": 1248, "subroutine": "    subroutine yca_integ_nconc ( &\r\n        iswnit    ,    brstage        & \r\n        )\r\n        \r\n        use yca_first_trans_m\r\n        use yca_control_plant\r\n        \r\n        implicit none\r\n        \r\n        character(len=1) iswnit   \r\n        integer :: br                      ! index for branch number/cohorts#          ! (from seasinit)  \r\n        integer :: lf                      ! loop counter leaves            #          !lpm 21mar15 to add a leaf counter\r\n        real  brstage \r\n        \r\n        !-----------------------------------------------------------------------\r\n        !         calculate nitrogen concentrations\r\n        !-----------------------------------------------------------------------\r\n                    \r\n        if (iswnit /= 'n') then\r\n            \r\n            !lpm 22may2015 the leaf nitrogen concentration tends to keep the same value through the growing season however in the future\r\n            !could be considered different leaf nitrogen concentration based on the leaf age (maybe is it not needed that detail?)\r\n            lncx = (lncxs(0) + lncxs(1))/2.0                                                    \r\n            lncm = (lncmn(0) + lncmn(1))/2.0   \r\n            !lpm 22may2015 the root nitrogenc concentration tends to keep constant through the growing season\r\n            rncx = (rncxs(0) + rncxs(1))/2.0 \r\n            rncm = (rncmn(0) + rncmn(1))/2.0\r\n            !lpm 22may2015 the stem nitrogen concentration changes according with the canopy level age (non-lignified to lignified)\r\n            if((llifatt+llifstt) > zero) then\r\n                do br = 0, brstage                                                                                        \r\n                 do lf = 1, lnumsimstg(br)\r\n                    node(br,lf)%sncx = sncxs(0) + (node(br,lf)%lagett*(sncxs(1)-sncxs(0)) / (llifatt+llifstt) )\r\n                    node(br,lf)%sncm = sncmn(0) + (node(br,lf)%lagett*(sncmn(1)-sncmn(0)) / (llifatt+llifstt) )\r\n                 enddo\r\n                enddo\r\n            endif\r\n            ! n concentrations\r\n            ! not reseting all to zero an leaving last value just in case it can't be calculated\r\n            ranc = amax1(0.0,ranc)\r\n            lanc = amax1(0.0,lanc)\r\n            node%sanc = amax1(0.0,node%sanc)\r\n            vanc = amax1(0.0,vanc)\r\n            vcnc = amax1(0.0,vcnc)\r\n            vmnc = amax1(0.0,vmnc)\r\n            \r\n            if (rtwt > zero) ranc = rootn / rtwt        !eqn 017\r\n            if (lfwt > zero) lanc = leafn / lfwt        !eqn 243 \r\n\r\n            if ((woodyweight()) > zero .and. (stwtp+crwtp) > zero) then\r\n                do br = 0, brstage                                                                                        \r\n                    do lf = 1, lnumsimstg(br)\r\n                        if (node(br,lf)%nodewt*(woodyweight())/(stwtp+crwtp) > 0.0) then\r\n                            node(br,lf)%sanc = node(br,lf)%stemnn / (node(br,lf)%nodewt*(woodyweight())/(stwtp+crwtp))\r\n                        endif\r\n                    enddo\r\n                enddo\r\n            endif\r\n            if (vwad > 0.0) vanc = vnad/vwad                                                                          !eqn 020\r\n            if (lanc < 0.0) then \r\n                write(message(1),'(a27,f4.1)') 'lanc below 0 with value of ',lanc\r\n                write(message(2),'(a27,2f5.1)') 'leafn,lfwt had values of   ',leafn,lfwt\r\n                call warning(2,'csyca',message)\r\n                lanc = amax1(0.0,lanc)\r\n            endif\r\n            \r\n            scnct = 0.0\r\n            scnmt = 0.0\r\n            if ((lfwt+woodyweight()) > zero .and. (stwtp+crwtp) > zero) then\r\n                do br = 0, brstage                                                                                        \r\n                    do lf = 1, lnumsimstg(br)\r\n                        node(br,lf)%scnc = (node(br,lf)%nodewt*(woodyweight())/(stwtp+crwtp))*node(br,lf)%sncx\r\n                        scnct =  scnct + node(br,lf)%scnc\r\n                        node(br,lf)%scnm = (node(br,lf)%nodewt*(woodyweight())/(stwtp+crwtp))*node(br,lf)%sncm\r\n                        scnmt =  scnmt + node(br,lf)%scnm\r\n                    enddo\r\n                enddo\r\n                vcnc = (lncx*amax1(0.0,lfwt)+scnct)/ &                      !eqn 021\r\n                (amax1(0.0,lfwt)+amax1(0.0,woodyweight()))\r\n                vmnc = (lncm*amax1(0.0,lfwt)+scnmt)/ &                      !eqn 022\r\n                (amax1(0.0,lfwt)+amax1(0.0,woodyweight()))\r\n            endif  \r\n            \r\n            \r\n            \r\n            sdnc = 0.0\r\n            sranc = 0.0\r\n            if (seedrs > 0.0) sdnc = seedn/(seedrs+sdcoat)\r\n            if (srwt > 0) sranc = srootn/srwt\r\n            lncr = 0.0\r\n            node%sncr = 0.0\r\n            rncr = 0.0\r\n            if (lncx > 0.0) lncr = amax1(0.0,amin1(1.0,lanc/lncx))\r\n            do br = 0, brstage                                                                              !lpm25may2015 to consider different n concentration by node according with node age                                                                       \r\n                do lf = 1, lnumsimstg(br)  \r\n                    if (node(br,lf)%sncx > 0.0) then\r\n                        node(br,lf)%sncr = amax1(0.0,amin1(1.0,node(br,lf)%sanc/node(br,lf)%sncx))\r\n                    endif\r\n                enddo\r\n            enddo\r\n            !sncrm = sum(sncr, mask = sncr >= 0.0)/max(1,count(sncr))\r\n            sncrm = 1.0\r\n            if (rncx > 0.0) rncr = amax1(0.0,amin1(1.0,ranc/rncx))\r\n        else\r\n            lncr = 1.0\r\n            node%sncr = 1.0\r\n            rncr = 1.0\r\n        endif\r\n        \r\n    end subroutine yca_integ_nconc\r\n"}
{"id": 1249, "subroutine": "  subroutine interp_buildvector(rdiscretisation, rform, nelements, npointsperelement,&\n      dpoints, idofstest, rdomainintsubset, dcoefficients, rcollection)\n\n    use basicgeometry\n    use collection\n    use derivatives\n    use domainintegration\n    use feevaluation\n    use fsystem\n    use linearsystemblock\n    use linearsystemscalar\n    use scalarpde\n    use spatialdiscretisation\n    use triangulation\n    \n  !<description>\n\n    ! the coefficients in front of the terms of the linear form.\n    !\n    ! the routine accepts a set of elements and a set of points on these\n    ! elements (cubature points) in in real coordinates.\n    ! according to the terms in the linear form, the routine has to compute\n    ! simultaneously for all these points and all the terms in the linear form\n    ! the corresponding coefficients in front of the terms.\n  !</description>\n    \n  !<input>\n    ! the discretisation structure that defines the basic shape of the\n    ! triangulation with references to the underlying triangulation,\n    ! analytic boundary boundary description etc.\n    type(t_spatialdiscretisation), intent(in) :: rdiscretisation\n    \n    ! the linear form which is currently to be evaluated:\n    type(t_linearform), intent(in) :: rform\n    \n    ! number of elements, where the coefficients must be computed.\n    integer, intent(in) :: nelements\n    \n    ! number of points per element, where the coefficients must be computed\n    integer, intent(in) :: npointsperelement\n    \n    ! this is an array of all points on all the elements where coefficients\n    ! are needed.\n    ! remark: this usually coincides with rdomainsubset%p_dcubptsreal.\n    ! dimension(dimension,npointsperelement,nelements)\n    real(dp), dimension(:,:,:), intent(in) :: dpoints\n\n    ! an array accepting the dof`s on all elements test in the test space.\n    ! dimension(\\#local dof`s in test space,number of elements)\n    integer, dimension(:,:), intent(in) :: idofstest\n\n    ! this is a t_domainintsubset structure specifying more detailed information\n    ! about the element set that is currently being integrated.\n    ! it is usually used in more complex situations (e.g. nonlinear matrices).\n    type(t_domainintsubset), intent(in) :: rdomainintsubset\n\n    ! optional: a collection structure to provide additional\n    ! information to the coefficient routine.\n    type(t_collection), intent(inout), optional :: rcollection\n    \n  !</input>\n  \n  !<output>\n    ! a list of all coefficients in front of all terms in the linear form -\n    ! for all given points on all given elements.\n    !   dimension(itermcount,npointsperelement,nelements)\n    ! with itermcount the number of terms in the linear form.\n    real(dp), dimension(:,:,:), intent(out) :: dcoefficients\n  !</output>\n\n    \n    ! evaluation of the given fe-function (very slowly but it works)\n    do iel = 1, nelements\n      call fevl_evaluate(der_func, dcoefficients(1,:,iel),&\n          rcollection%p_rvectorquickaccess1%rvectorblock(1), dpoints(:,:,iel))\n    end do\n    \n  end subroutine interp_buildvector\n"}
{"id": 1250, "subroutine": "  subroutine interp_reffunction(cderivative, rdiscretisation, nelements,&\n      npointsperelement, dpoints, idofstest, rdomainintsubset, dvalues, rcollection)\n    \n    use fsystem\n    use basicgeometry\n    use triangulation\n    use scalarpde\n    use domainintegration\n    use spatialdiscretisation\n    use collection\n    \n  !<description>\n\n    ! the (analytical) values of a function in a couple of points on a couple\n    ! of elements. these values are compared to those of a computed fe function\n    ! and used to calculate an error.\n    !\n    ! the routine accepts a set of elements and a set of points on these\n    ! elements (cubature points) in real coordinates.\n    ! according to the terms in the linear form, the routine has to compute\n    ! simultaneously for all these points.\n  !</description>\n    \n  !<input>\n    ! this is a der_xxxx derivative identifier (from derivative.f90) that\n    ! specifies what to compute: der_func=function value, der_deriv_x=x-derivative,...\n    ! the result must be written to the dvalue-array below.\n    integer, intent(in) :: cderivative\n  \n    ! the discretisation structure that defines the basic shape of the\n    ! triangulation with references to the underlying triangulation,\n    ! analytic boundary boundary description etc.\n    type(t_spatialdiscretisation), intent(in) :: rdiscretisation\n    \n    ! number of elements, where the coefficients must be computed.\n    integer, intent(in) :: nelements\n    \n    ! number of points per element, where the coefficients must be computed\n    integer, intent(in) :: npointsperelement\n    \n    ! this is an array of all points on all the elements where coefficients\n    ! are needed.\n    ! dimension(ndim2d,npointsperelement,nelements)\n    ! remark: this usually coincides with rdomainsubset%p_dcubptsreal.\n    real(dp), dimension(:,:,:), intent(in) :: dpoints\n\n    ! an array accepting the dof`s on all elements trial in the trial space.\n    ! dimension(\\#local dof`s in trial space,number of elements)\n    integer, dimension(:,:), intent(in) :: idofstest\n\n    ! this is a t_domainintsubset structure specifying more detailed information\n    ! about the element set that is currently being integrated.\n    ! it is usually used in more complex situations (e.g. nonlinear matrices).\n    type(t_domainintsubset), intent(in) :: rdomainintsubset\n\n    ! optional: a collection structure to provide additional\n    ! information to the coefficient routine.\n    type(t_collection), intent(inout), optional :: rcollection\n    \n  !</input>\n  \n  !<output>\n    ! this array has to receive the values of the (analytical) function\n    ! in all the points specified in dpoints, or the appropriate derivative\n    ! of the function, respectively, according to cderivative.\n    !   dimension(npointsperelement,nelements)\n    real(dp), dimension(:,:), intent(out) :: dvalues\n  !</output>\n\n  \n    ! local variables\n    integer :: ivt,iel\n\n    do iel = 1, nelements\n      do ivt = 1, npointsperelement\n        if (sqrt((dpoints(1,ivt,iel)-0.5_dp)**2+&\n                 (dpoints(2,ivt,iel)-0.5_dp)**2) .le. 0.3) then\n          dvalues(ivt,iel) = 1.0_dp\n        else\n          dvalues(ivt,iel) = 0.01_dp\n        end if\n      end do\n    end do\n\n  end subroutine interp_reffunction\n"}
{"id": 1251, "subroutine": "  subroutine hecmw_mat_dump( hecmat, hecmesh )\n    implicit none\n    type(hecmwst_matrix) :: hecmat\n    type(hecmwst_local_mesh) :: hecmesh\n    numcall = numcall + 1\n    select case( hecmw_mat_get_dump(hecmat) )\n      case (hecmw_mat_dump_type_none)\n        return\n      case (hecmw_mat_dump_type_mm)\n        call hecmw_mat_dump_mm(hecmat)\n      case (hecmw_mat_dump_type_csr)\n        call hecmw_mat_dump_csr(hecmat)\n      case (hecmw_mat_dump_type_bsr)\n        call hecmw_mat_dump_bsr(hecmat)\n    end select\n    call hecmw_mat_dump_rhs(hecmat)\n    if (hecmw_mat_get_dump_exit(hecmat) /= 0) then\n      call hecmw_barrier( hecmesh )\n      stop \"exiting program after dumping matrix\"\n    end if\n  end subroutine hecmw_mat_dump\n"}
{"id": 1252, "subroutine": "  subroutine make_file_name(ext, fname)\n    implicit none\n    character(*) :: ext\n    character(*) :: fname\n    write(fname,\"('dump_matrix_',i0,'_',i0,a)\") &\n      numcall, hecmw_comm_get_rank(), ext\n  end subroutine make_file_name\n"}
{"id": 1253, "subroutine": "  subroutine hecmw_mat_dump_mm( hecmat )\n    implicit none\n    type(hecmwst_matrix) :: hecmat\n    integer, parameter :: idump = 201\n    character(len=64) :: fname\n    integer :: i, j, i0, j0, idof, jdof, ii, jj\n    integer :: idxl0, idxl, idxd, idxu0, idxu\n    integer :: n, np, ndof, ndof2, nnz\n    character(len=64), parameter :: lineformat = \"(i0,' ',i0,' ',e20.12e3)\"\n    integer :: stat\n    !n = hecmat%n\n    n = hecmat%np\n    np = hecmat%np\n    ndof = hecmat%ndof\n    ndof2 = ndof * ndof\n    ! make fname\n    call make_file_name('.mm', fname)\n    ! open file\n    open(idump, file=fname, status='replace', iostat=stat)\n    if (stat /= 0) then\n      write(*,*) 'warning: cannot open file ', fname, ' for matrix dump'\n      return\n    end if\n    ! header\n    write(idump,\"(a)\") '%%matrixmarket matrix coordinate real general'\n    nnz = ndof2 * (n + hecmat%indexl(n) + hecmat%indexu(n))\n    write(idump,\"(i0,' ',i0,' ',i0)\") n*ndof, np*ndof, nnz\n    idxd = 0\n    do i = 1, n\n      i0 = (i-1)*ndof\n      do idof = 1, ndof\n        ii = i0 + idof\n        ! lower\n        do j = hecmat%indexl(i-1)+1,hecmat%indexl(i)\n          j0 = (hecmat%iteml(j)-1)*ndof\n          idxl0 = (j-1)*ndof2 + (idof-1)*ndof\n          do jdof = 1, ndof\n            jj = j0 + jdof\n            idxl = idxl0 + jdof\n            write(idump,lineformat) ii, jj, hecmat%al(idxl)\n          end do\n        end do\n        ! diagonal\n        j0 = i0\n        do jdof = 1, ndof\n          jj = j0 + jdof\n          idxd = idxd + 1\n          write(idump,lineformat) ii, jj, hecmat%d(idxd)\n        end do\n        ! upper\n        do j = hecmat%indexu(i-1)+1,hecmat%indexu(i)\n          j0 = (hecmat%itemu(j)-1)*ndof\n          idxu0 = (j-1)*ndof2 + (idof-1)*ndof\n          do jdof = 1, ndof\n            jj = j0 + jdof\n            idxu = idxu0 + jdof\n            write(idump,lineformat) ii, jj, hecmat%au(idxu)\n          end do\n        end do\n      end do\n    end do\n    ! close file\n    close(idump)\n  end subroutine hecmw_mat_dump_mm\n"}
{"id": 1254, "subroutine": "  subroutine hecmw_mat_dump_bsr( hecmat )\n    implicit none\n    type(hecmwst_matrix) :: hecmat\n    integer, parameter :: idump = 201\n    character(len=64) :: fname\n    integer :: i, j\n    integer :: idx, idxl0, idxd0, idxu0\n    integer :: n, np, ndof, ndof2, nnz, nnz1\n    character(len=64), parameter :: lineformat = \"(e20.12e3)\"\n    integer :: stat\n    !n = hecmat%n\n    n = hecmat%np\n    np = hecmat%np\n    ndof = hecmat%ndof\n    ndof2 = ndof * ndof\n    ! make fname\n    call make_file_name('.bsr', fname)\n    ! open file\n    open(idump, file=fname, status='replace', iostat=stat)\n    if (stat /= 0) then\n      write(*,*) 'warning: cannot open file ', fname, ' for matrix dump'\n      return\n    end if\n    ! header\n    write(idump,\"(a)\") '%%block-csr matrix real general'\n    nnz = n + hecmat%indexl(n) + hecmat%indexu(n)\n    write(idump,\"(a)\") '% nrow ncol nnonzero ndof'\n    write(idump,\"(i0,' ',i0,' ',i0,' ',i0)\") n, np, nnz, ndof\n    ! index\n    write(idump,\"(a)\") '% index(0:nrow)'\n    idx = 0\n    write(idump, \"(i0)\") idx\n    do i = 1, n\n      nnz1 = (hecmat%indexl(i)-hecmat%indexl(i-1)) + &\n        1 + (hecmat%indexu(i)-hecmat%indexu(i-1))\n      idx = idx + nnz1\n      write(idump, \"(i0)\") idx\n    end do\n    ! item\n    write(idump,\"(a)\") '% item(1:nnonzero)'\n    do i = 1, n\n      ! lower\n      do j = hecmat%indexl(i-1)+1,hecmat%indexl(i)\n        write(idump,\"(i0)\") hecmat%iteml(j)\n      end do\n      ! diagonal\n      write(idump,\"(i0)\") i\n      ! upper\n      do j = hecmat%indexu(i-1)+1,hecmat%indexu(i)\n        write(idump,\"(i0)\") hecmat%itemu(j)\n      end do\n    end do\n    ! values\n    write(idump,\"(a)\") '% value(1:nnonzero*ndof*ndof)'\n    idxd0 = 0\n    do i = 1, n\n      ! lower\n      do j = hecmat%indexl(i-1)+1,hecmat%indexl(i)\n        idxl0 = (j-1)*ndof2\n        write(idump,lineformat) hecmat%al(idxl0+1:idxl0+ndof2)\n      end do\n      ! diagonal\n      write(idump,lineformat) hecmat%d(idxd0+1:idxd0+ndof2)\n      idxd0 = idxd0 + ndof2\n      ! upper\n      do j = hecmat%indexu(i-1)+1,hecmat%indexu(i)\n        idxu0 = (j-1)*ndof2\n        write(idump,lineformat) hecmat%au(idxu0+1:idxu0+ndof2)\n      end do\n    end do\n    ! close file\n    close(idump)\n  end subroutine hecmw_mat_dump_bsr\n"}
{"id": 1255, "subroutine": "  subroutine hecmw_mat_dump_rhs( hecmat )\n    implicit none\n    type(hecmwst_matrix) :: hecmat\n    integer, parameter :: idump = 201\n    character(len=64) :: fname\n    integer :: i\n    integer :: n, np, ndof, ndof2\n    character(len=64), parameter :: lineformat = \"(e20.12e3)\"\n    integer :: stat\n    if( hecmw_mat_get_dump(hecmat) == hecmw_mat_dump_type_none) return\n    !n = hecmat%n\n    n = hecmat%np\n    np = hecmat%np\n    ndof = hecmat%ndof\n    ndof2 = ndof * ndof\n    ! make fname\n    call make_file_name('.rhs', fname)\n    ! open file\n    open(idump, file=fname, status='replace', iostat=stat)\n    if (stat /= 0) then\n      write(*,*) 'warning: cannot open file ', fname, ' for matrix dump'\n      return\n    end if\n    do i = 1, np*ndof\n      write(idump,lineformat) hecmat%b(i)\n    end do\n    ! close file\n    close(idump)\n  end subroutine hecmw_mat_dump_rhs\n"}
{"id": 1256, "subroutine": "subroutine write_matrix(a)\n! it writes a matrix of doubles nxm on the screen\n  double precision, dimension(:,:) :: a\n  character(len=105) string\n  character(len=105) aux_char\n  integer :: aux\n\n  aux = int(ubound(a,2))\n  !write(*,*) aux\n  write(aux_char,\"(i4)\") aux\n  aux_char = trim(aux_char)\n  write(string,\"(a1,i4,a6)\") \"(\",aux,\"e15.6)\"\n\n  do i = lbound(a,1), ubound(a,1)\n     write(*,string) (a(i,j), j = lbound(a,2), ubound(a,2))\n  end do\n  write(*,*)\n  write(*,*)\nend subroutine write_matrix\n"}
{"id": 1257, "subroutine": "subroutine write_matrix_int(a)\n!it writes a matrix of integer nxm on the screen\n  integer, dimension(:,:) :: a\n  write(*,*)\n  do i = lbound(a,1), ubound(a,1)\n     write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2))\n  end do\nend subroutine write_matrix_int\n"}
{"id": 1258, "subroutine": "subroutine coordinatepacking(d,a,v,r,c,index,info)\n  implicit none\n  integer,intent(in):: d\n  complex*16,dimension(d,d),intent(in)  :: a\n  complex*16,dimension(d*d),intent(out) :: v\n  integer, dimension(d*d),  intent(out) :: r,c\n  integer, intent(out)   :: index\n  integer, intent(inout) :: info\n  \n  integer i,j\n  v=0\n  r=0\n  c=0\n  \n  index = 1\n  do i=1,d\n     do j=1,d\n        if(abs(a(i,j)).gt.0) then\n           v(index) = a(i,j)\n           r(index) = i\n           c(index) = j\n           index = index+1\n        end if\n     end do\n  end do\n  index = index-1\nend subroutine coordinatepacking\n"}
{"id": 1259, "subroutine": "     subroutine appendarrays(v,b,info)\n       complex*16, dimension(:),allocatable, intent(inout) :: v\n       complex*16, dimension(:),intent(in)    :: b\n       integer,                 intent(inout) :: info\n     end subroutine appendarrays\n"}
{"id": 1260, "subroutine": "     subroutine appendarraysi(v,b,info)\n       integer, dimension(:),allocatable, intent(inout) :: v\n       integer, dimension(:),intent(in)    :: b\n       integer,                 intent(inout) :: info\n     end subroutine appendarraysi\n"}
{"id": 1261, "subroutine": "subroutine appendarrays(v,b,info)\n  complex*16, dimension(:),allocatable, intent(inout) :: v\n  complex*16, dimension(:),intent(in)    :: b\n  integer,                 intent(inout) :: info\n  \n  complex*16,dimension(:),allocatable :: tmp_arr\n!  write(*,*) v\n!  write(*,*) b\n  allocate(tmp_arr(size(v,1)+size(b,1)))\n  tmp_arr(1:size(v,1))=v\n  tmp_arr(size(v,1)+1:size(tmp_arr))=b\n  deallocate(v)\n  allocate(v(size(tmp_arr)))\n  v=tmp_arr\nend subroutine appendarrays\n"}
{"id": 1262, "subroutine": "            recursive subroutine horizontal_transport\r\n            end subroutine horizontal_transport\r\n"}
{"id": 1263, "subroutine": "  subroutine update_tile_halo_l_kernel(x_min,x_max,y_min,y_max,                            &\n                                       density0,                                                   &\n                                       energy0,                                                    &\n                                       pressure,                                                   &\n                                       viscosity,                                                  &\n                                       soundspeed,                                                 &\n                                       density1,                                                   &\n                                       energy1,                                                    &\n                                       xvel0,                                                      &\n                                       yvel0,                                                      &\n                                       xvel1,                                                      &\n                                       yvel1,                                                      &\n                                       vol_flux_x,                                                 &\n                                       vol_flux_y,                                                 &\n                                       mass_flux_x,                                                &\n                                       mass_flux_y,                                                &\n                                       left_xmin, left_xmax, left_ymin, left_ymax,                 &\n                                       left_density0,                                                   &\n                                       left_energy0,                                                    &\n                                       left_pressure,                                                   &\n                                       left_viscosity,                                                  &\n                                       left_soundspeed,                                                 &\n                                       left_density1,                                                   &\n                                       left_energy1,                                                    &\n                                       left_xvel0,                                                      &\n                                       left_yvel0,                                                      &\n                                       left_xvel1,                                                      &\n                                       left_yvel1,                                                      &\n                                       left_vol_flux_x,                                                 &\n                                       left_vol_flux_y,                                                 &\n                                       left_mass_flux_x,                                                &\n                                       left_mass_flux_y,                                                &\n                                       fields,                                                     &\n                                       depth)\n\n    implicit none\n\n    integer :: x_min,x_max,y_min,y_max\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density0,energy0\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: pressure,viscosity,soundspeed\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density1,energy1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel0,yvel0\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel1,yvel1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2) :: vol_flux_x,mass_flux_x\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3) :: vol_flux_y,mass_flux_y\n    integer :: left_xmin, left_xmax, left_ymin, left_ymax\n    real(kind=8), dimension(left_xmin-2:left_xmax+2,left_ymin-2:left_ymax+2) :: left_density0,left_energy0\n    real(kind=8), dimension(left_xmin-2:left_xmax+2,left_ymin-2:left_ymax+2) :: left_pressure,left_viscosity,left_soundspeed\n    real(kind=8), dimension(left_xmin-2:left_xmax+2,left_ymin-2:left_ymax+2) :: left_density1,left_energy1\n    real(kind=8), dimension(left_xmin-2:left_xmax+3,left_ymin-2:left_ymax+3) :: left_xvel0,left_yvel0\n    real(kind=8), dimension(left_xmin-2:left_xmax+3,left_ymin-2:left_ymax+3) :: left_xvel1,left_yvel1\n    real(kind=8), dimension(left_xmin-2:left_xmax+3,left_ymin-2:left_ymax+2) :: left_vol_flux_x,left_mass_flux_x\n    real(kind=8), dimension(left_xmin-2:left_xmax+2,left_ymin-2:left_ymax+3) :: left_vol_flux_y,left_mass_flux_y\n\n    integer :: fields(:),depth\n\n    integer :: j,k\n\n\n    !$omp parallel private(j)\n\n    ! density 0\n   \n\n    if(fields(field_density0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          density0(x_min-j,k)=left_density0(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! density 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          density1(x_min-j,k)=left_density1(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n   \n    ! energy 0\n    if(fields(field_energy0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          energy0(x_min-j,k)=left_energy0(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! energy 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          energy1(x_min-j,k)=left_energy1(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  \n    ! pressure\n    if(fields(field_pressure).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          pressure(x_min-j,k)=left_pressure(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! viscocity\n    if(fields(field_viscosity).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          viscosity(x_min-j,k)=left_viscosity(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! soundspeed\n    if(fields(field_soundspeed).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          soundspeed(x_min-j,k)=left_soundspeed(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n\n    ! xvel 0\n    if(fields(field_xvel0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          xvel0(x_min-j,k)=left_xvel0(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! xvel 1\n    if(fields(field_xvel1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          xvel1(x_min-j,k)=left_xvel1(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 0\n    if(fields(field_yvel0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          yvel0(x_min-j,k)=left_yvel0(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 1\n    if(fields(field_yvel1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          yvel1(x_min-j,k)=left_yvel1(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_x\n    if(fields(field_vol_flux_x).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          vol_flux_x(x_min-j,k)=left_vol_flux_x(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_x\n    if(fields(field_mass_flux_x).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          mass_flux_x(x_min-j,k)=left_mass_flux_x(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_y\n    if(fields(field_vol_flux_y).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          vol_flux_y(x_min-j,k)=left_vol_flux_y(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_y\n    if(fields(field_mass_flux_y).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          mass_flux_y(x_min-j,k)=left_mass_flux_y(left_xmax+1-j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  !$omp end parallel\n\n  end subroutine update_tile_halo_l_kernel\n"}
{"id": 1264, "subroutine": "  subroutine update_tile_halo_r_kernel(x_min,x_max,y_min,y_max,                            &\n                                       density0,                                                   &\n                                       energy0,                                                    &\n                                       pressure,                                                   &\n                                       viscosity,                                                  &\n                                       soundspeed,                                                 &\n                                       density1,                                                   &\n                                       energy1,                                                    &\n                                       xvel0,                                                      &\n                                       yvel0,                                                      &\n                                       xvel1,                                                      &\n                                       yvel1,                                                      &\n                                       vol_flux_x,                                                 &\n                                       vol_flux_y,                                                 &\n                                       mass_flux_x,                                                &\n                                       mass_flux_y,                                                &\n                                       right_xmin, right_xmax, right_ymin, right_ymax,                 &\n                                       right_density0,                                                   &\n                                       right_energy0,                                                    &\n                                       right_pressure,                                                   &\n                                       right_viscosity,                                                  &\n                                       right_soundspeed,                                                 &\n                                       right_density1,                                                   &\n                                       right_energy1,                                                    &\n                                       right_xvel0,                                                      &\n                                       right_yvel0,                                                      &\n                                       right_xvel1,                                                      &\n                                       right_yvel1,                                                      &\n                                       right_vol_flux_x,                                                 &\n                                       right_vol_flux_y,                                                 &\n                                       right_mass_flux_x,                                                &\n                                       right_mass_flux_y,                                                &\n                                       fields,                                                     &\n                                       depth)\n\n    implicit none\n\n    integer :: x_min,x_max,y_min,y_max\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density0,energy0\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: pressure,viscosity,soundspeed\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density1,energy1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel0,yvel0\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel1,yvel1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2) :: vol_flux_x,mass_flux_x\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3) :: vol_flux_y,mass_flux_y\n    integer :: right_xmin, right_xmax, right_ymin, right_ymax\n    real(kind=8), dimension(right_xmin-2:right_xmax+2,right_ymin-2:right_ymax+2) :: right_density0,right_energy0\n    real(kind=8), dimension(right_xmin-2:right_xmax+2,right_ymin-2:right_ymax+2) :: right_pressure,right_viscosity,right_soundspeed\n    real(kind=8), dimension(right_xmin-2:right_xmax+2,right_ymin-2:right_ymax+2) :: right_density1,right_energy1\n    real(kind=8), dimension(right_xmin-2:right_xmax+3,right_ymin-2:right_ymax+3) :: right_xvel0,right_yvel0\n    real(kind=8), dimension(right_xmin-2:right_xmax+3,right_ymin-2:right_ymax+3) :: right_xvel1,right_yvel1\n    real(kind=8), dimension(right_xmin-2:right_xmax+3,right_ymin-2:right_ymax+2) :: right_vol_flux_x,right_mass_flux_x\n    real(kind=8), dimension(right_xmin-2:right_xmax+2,right_ymin-2:right_ymax+3) :: right_vol_flux_y,right_mass_flux_y\n\n    integer :: fields(:),depth\n\n    integer :: j,k\n\n\n    !$omp parallel private(j)\n\n    ! density 0\n    if(fields(field_density0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          density0(x_max+j,k)=right_density0(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! density 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          density1(x_max+j,k)=right_density1(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n   \n    ! energy 0\n    if(fields(field_energy0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          energy0(x_max+j,k)=right_energy0(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! energy 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          energy1(x_max+j,k)=right_energy1(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  \n    ! pressure\n    if(fields(field_pressure).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          pressure(x_max+j,k)=right_pressure(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! viscocity\n    if(fields(field_viscosity).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          viscosity(x_max+j,k)=right_viscosity(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! soundspeed\n    if(fields(field_soundspeed).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          soundspeed(x_max+j,k)=right_soundspeed(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n\n    ! xvel 0\n    if(fields(field_xvel0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          xvel0(x_max+1+j,k)=right_xvel0(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! xvel 1\n    if(fields(field_xvel1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          xvel1(x_max+1+j,k)=right_xvel1(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 0\n    if(fields(field_yvel0).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          yvel0(x_max+1+j,k)=right_yvel0(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 1\n    if(fields(field_yvel1).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          yvel1(x_max+1+j,k)=right_yvel1(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_x\n    if(fields(field_vol_flux_x).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          vol_flux_x(x_max+1+j,k)=right_vol_flux_x(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_x\n    if(fields(field_mass_flux_x).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+depth\n        do j=1,depth\n          mass_flux_x(x_max+1+j,k)=right_mass_flux_x(right_xmin+1-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_y\n    if(fields(field_vol_flux_y).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          vol_flux_y(x_max+j,k)=right_vol_flux_y(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_y\n    if(fields(field_mass_flux_y).eq.1) then\n      !$omp do\n      do k=y_min-depth,y_max+1+depth\n        do j=1,depth\n          mass_flux_y(x_max+j,k)=right_mass_flux_y(right_xmin-1+j,k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  !$omp end parallel\n\n  end subroutine update_tile_halo_r_kernel\n"}
{"id": 1265, "subroutine": "  subroutine update_tile_halo_t_kernel(x_min,x_max,y_min,y_max,                            &\n                                       density0,                                                   &\n                                       energy0,                                                    &\n                                       pressure,                                                   &\n                                       viscosity,                                                  &\n                                       soundspeed,                                                 &\n                                       density1,                                                   &\n                                       energy1,                                                    &\n                                       xvel0,                                                      &\n                                       yvel0,                                                      &\n                                       xvel1,                                                      &\n                                       yvel1,                                                      &\n                                       vol_flux_x,                                                 &\n                                       vol_flux_y,                                                 &\n                                       mass_flux_x,                                                &\n                                       mass_flux_y,                                                &\n                                       top_xmin, top_xmax, top_ymin, top_ymax,                 &\n                                       top_density0,                                                   &\n                                       top_energy0,                                                    &\n                                       top_pressure,                                                   &\n                                       top_viscosity,                                                  &\n                                       top_soundspeed,                                                 &\n                                       top_density1,                                                   &\n                                       top_energy1,                                                    &\n                                       top_xvel0,                                                      &\n                                       top_yvel0,                                                      &\n                                       top_xvel1,                                                      &\n                                       top_yvel1,                                                      &\n                                       top_vol_flux_x,                                                 &\n                                       top_vol_flux_y,                                                 &\n                                       top_mass_flux_x,                                                &\n                                       top_mass_flux_y,                                                &\n                                       fields,                                                     &\n                                       depth)\n\n    implicit none\n\n    integer :: x_min,x_max,y_min,y_max\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density0,energy0\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: pressure,viscosity,soundspeed\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density1,energy1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel0,yvel0\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel1,yvel1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2) :: vol_flux_x,mass_flux_x\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3) :: vol_flux_y,mass_flux_y\n    integer :: top_xmin, top_xmax, top_ymin, top_ymax\n    real(kind=8), dimension(top_xmin-2:top_xmax+2,top_ymin-2:top_ymax+2) :: top_density0,top_energy0\n    real(kind=8), dimension(top_xmin-2:top_xmax+2,top_ymin-2:top_ymax+2) :: top_pressure,top_viscosity,top_soundspeed\n    real(kind=8), dimension(top_xmin-2:top_xmax+2,top_ymin-2:top_ymax+2) :: top_density1,top_energy1\n    real(kind=8), dimension(top_xmin-2:top_xmax+3,top_ymin-2:top_ymax+3) :: top_xvel0,top_yvel0\n    real(kind=8), dimension(top_xmin-2:top_xmax+3,top_ymin-2:top_ymax+3) :: top_xvel1,top_yvel1\n    real(kind=8), dimension(top_xmin-2:top_xmax+3,top_ymin-2:top_ymax+2) :: top_vol_flux_x,top_mass_flux_x\n    real(kind=8), dimension(top_xmin-2:top_xmax+2,top_ymin-2:top_ymax+3) :: top_vol_flux_y,top_mass_flux_y\n\n    integer :: fields(:),depth\n\n    integer :: j,k\n\n\n    !$omp parallel private(j)\n\n    ! density 0\n    if(fields(field_density0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          density0(j,y_max+k)=top_density0(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! density 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          density1(j,y_max+k)=top_density1(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n   \n    ! energy 0\n    if(fields(field_energy0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          energy0(j,y_max+k)=top_energy0(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! energy 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          energy1(j,y_max+k)=top_energy1(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  \n    ! pressure\n    if(fields(field_pressure).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          pressure(j,y_max+k)=top_pressure(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! viscocity\n    if(fields(field_viscosity).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          viscosity(j,y_max+k)=top_viscosity(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! soundspeed\n    if(fields(field_soundspeed).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          soundspeed(j,y_max+k)=top_soundspeed(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n\n    ! xvel 0\n    if(fields(field_xvel0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          xvel0(j,y_max+1+k)=top_xvel0(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! xvel 1\n    if(fields(field_xvel1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          xvel1(j,y_max+1+k)=top_xvel1(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 0\n    if(fields(field_yvel0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          yvel0(j,y_max+1+k)=top_yvel0(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 1\n    if(fields(field_yvel1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          yvel1(j,y_max+1+k)=top_yvel1(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_x\n    if(fields(field_vol_flux_x).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          vol_flux_x(j,y_max+k)=top_vol_flux_x(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_x\n    if(fields(field_mass_flux_x).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          mass_flux_x(j,y_max+k)=top_mass_flux_x(j,top_ymin-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_y\n    if(fields(field_vol_flux_y).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          vol_flux_y(j,y_max+1+k)=top_vol_flux_y(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_y\n    if(fields(field_mass_flux_y).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          mass_flux_y(j,y_max+1+k)=top_mass_flux_y(j,top_ymin+1-1+k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  !$omp end parallel\n\n  end subroutine update_tile_halo_t_kernel\n"}
{"id": 1266, "subroutine": "  subroutine update_tile_halo_b_kernel(x_min,x_max,y_min,y_max,                     &\n                                       density0,                                           &\n                                       energy0,                                            &\n                                       pressure,                                           &\n                                       viscosity,                                          &\n                                       soundspeed,                                         &\n                                       density1,                                           &\n                                       energy1,                                            &\n                                       xvel0,                                              &\n                                       yvel0,                                              &\n                                       xvel1,                                              &\n                                       yvel1,                                              &\n                                       vol_flux_x,                                         &\n                                       vol_flux_y,                                         &\n                                       mass_flux_x,                                        &\n                                       mass_flux_y,                                        &\n                                       bottom_xmin, bottom_xmax, bottom_ymin, bottom_ymax, &\n                                       bottom_density0,                                    &\n                                       bottom_energy0,                                     &\n                                       bottom_pressure,                                    &\n                                       bottom_viscosity,                                   &\n                                       bottom_soundspeed,                                  &\n                                       bottom_density1,                                    &\n                                       bottom_energy1,                                     &\n                                       bottom_xvel0,                                       &\n                                       bottom_yvel0,                                       &\n                                       bottom_xvel1,                                       &\n                                       bottom_yvel1,                                       &\n                                       bottom_vol_flux_x,                                  &\n                                       bottom_vol_flux_y,                                  &\n                                       bottom_mass_flux_x,                                 &\n                                       bottom_mass_flux_y,                                 &\n                                       fields,                                             &\n                                       depth)\n\n    implicit none\n\n    integer :: x_min,x_max,y_min,y_max\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density0,energy0\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: pressure,viscosity,soundspeed\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+2) :: density1,energy1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel0,yvel0\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+3) :: xvel1,yvel1\n    real(kind=8), dimension(x_min-2:x_max+3,y_min-2:y_max+2) :: vol_flux_x,mass_flux_x\n    real(kind=8), dimension(x_min-2:x_max+2,y_min-2:y_max+3) :: vol_flux_y,mass_flux_y\n    integer :: bottom_xmin, bottom_xmax, bottom_ymin, bottom_ymax\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+2,bottom_ymin-2:bottom_ymax+2) :: &\n      bottom_density0,bottom_energy0\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+2,bottom_ymin-2:bottom_ymax+2) :: &\n      bottom_pressure,bottom_viscosity,bottom_soundspeed\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+2,bottom_ymin-2:bottom_ymax+2) :: &\n      bottom_density1,bottom_energy1\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+3,bottom_ymin-2:bottom_ymax+3) :: &\n      bottom_xvel0,bottom_yvel0\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+3,bottom_ymin-2:bottom_ymax+3) :: &\n      bottom_xvel1,bottom_yvel1\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+3,bottom_ymin-2:bottom_ymax+2) :: &\n      bottom_vol_flux_x,bottom_mass_flux_x\n    real(kind=8), dimension(bottom_xmin-2:bottom_xmax+2,bottom_ymin-2:bottom_ymax+3) :: &\n      bottom_vol_flux_y,bottom_mass_flux_y\n\n    integer :: fields(:),depth\n\n\n    integer :: j,k\n\n\n    !$omp parallel private(j)\n\n    ! density 0\n    if(fields(field_density0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          density0(j,y_min-k)=bottom_density0(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! density 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          density1(j,y_min-k)=bottom_density1(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n   \n    ! energy 0\n    if(fields(field_energy0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          energy0(j,y_min-k)=bottom_energy0(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! energy 1\n    if(fields(field_density1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          energy1(j,y_min-k)=bottom_energy1(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  \n    ! pressure\n    if(fields(field_pressure).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          pressure(j,y_min-k)=bottom_pressure(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! viscocity\n    if(fields(field_viscosity).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          viscosity(j,y_min-k)=bottom_viscosity(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! soundspeed\n    if(fields(field_soundspeed).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          soundspeed(j,y_min-k)=bottom_soundspeed(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n\n    ! xvel 0\n    if(fields(field_xvel0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          xvel0(j,y_min-k)=bottom_xvel0(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! xvel 1\n    if(fields(field_xvel1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          xvel1(j,y_min-k)=bottom_xvel1(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 0\n    if(fields(field_yvel0).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          yvel0(j,y_min-k)=bottom_yvel0(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! yvel 1\n    if(fields(field_yvel1).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          yvel1(j,y_min-k)=bottom_yvel1(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_x\n    if(fields(field_vol_flux_x).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          vol_flux_x(j,y_min-k)=bottom_vol_flux_x(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_x\n    if(fields(field_mass_flux_x).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+1+depth\n          mass_flux_x(j,y_min-k)=bottom_mass_flux_x(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! vol_flux_y\n    if(fields(field_vol_flux_y).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          vol_flux_y(j,y_min-k)=bottom_vol_flux_y(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n    ! mass_flux_y\n    if(fields(field_mass_flux_y).eq.1) then\n      !$omp do\n      do k=1,depth\n        do j=x_min-depth, x_max+depth\n          mass_flux_y(j,y_min-k)=bottom_mass_flux_y(j,bottom_ymax+1-k)\n        enddo\n      enddo\n    !$omp end do\n    endif\n\n  !$omp end parallel\n\n  end subroutine update_tile_halo_b_kernel\n"}
{"id": 1267, "subroutine": "subroutine kppsolvetr ( jvs, x, xx )\n\n! jvs - sparse jacobian of variables\n  real(kind=dp) :: jvs(lu_nonzero)\n! x - vector for variables\n  real(kind=dp) :: x(nvar)\n! xx - vector for output variables\n  real(kind=dp) :: xx(nvar)\n\n  xx(1) = x(1)/jvs(1)\n  xx(2) = x(2)/jvs(2)\n  xx(3) = x(3)/jvs(3)\n  xx(4) = (x(4)-jvs(4)*xx(3))/(jvs(6))\n  xx(5) = x(5)/jvs(10)\n  xx(6) = x(6)/jvs(15)\n  xx(7) = x(7)/jvs(18)\n  xx(8) = x(8)/jvs(20)\n  xx(9) = (x(9)-jvs(7)*xx(4))/(jvs(22))\n  xx(10) = x(10)/jvs(25)\n  xx(11) = x(11)/jvs(27)\n  xx(12) = x(12)/jvs(29)\n  xx(13) = x(13)/jvs(31)\n  xx(14) = x(14)/jvs(33)\n  xx(15) = x(15)/jvs(35)\n  xx(16) = x(16)/jvs(37)\n  xx(17) = x(17)/jvs(39)\n  xx(18) = x(18)/jvs(41)\n  xx(19) = x(19)/jvs(43)\n  xx(20) = x(20)/jvs(45)\n  xx(21) = x(21)/jvs(47)\n  xx(22) = x(22)/jvs(49)\n  xx(23) = x(23)/jvs(51)\n  xx(24) = x(24)/jvs(53)\n  xx(25) = x(25)/jvs(55)\n  xx(26) = x(26)/jvs(57)\n  xx(27) = x(27)/jvs(59)\n  xx(28) = x(28)/jvs(61)\n  xx(29) = x(29)/jvs(63)\n  xx(30) = x(30)/jvs(65)\n  xx(31) = x(31)/jvs(67)\n  xx(32) = x(32)/jvs(69)\n  xx(33) = x(33)/jvs(72)\n  xx(34) = x(34)/jvs(75)\n  xx(35) = x(35)/jvs(78)\n  xx(36) = x(36)/jvs(80)\n  xx(37) = x(37)/jvs(83)\n  xx(38) = x(38)/jvs(86)\n  xx(39) = x(39)/jvs(90)\n  xx(40) = x(40)/jvs(94)\n  xx(41) = (x(41)-jvs(16)*xx(6))/(jvs(97))\n  xx(42) = x(42)/jvs(100)\n  xx(43) = x(43)/jvs(103)\n  xx(44) = x(44)/jvs(106)\n  xx(45) = x(45)/jvs(110)\n  xx(46) = x(46)/jvs(116)\n  xx(47) = x(47)/jvs(120)\n  xx(48) = x(48)/jvs(125)\n  xx(49) = x(49)/jvs(129)\n  xx(50) = x(50)/jvs(133)\n  xx(51) = x(51)/jvs(136)\n  xx(52) = (x(52)-jvs(5)*xx(3)-jvs(11)*xx(5))/(jvs(141))\n  xx(53) = x(53)/jvs(146)\n  xx(54) = x(54)/jvs(150)\n  xx(55) = x(55)/jvs(154)\n  xx(56) = x(56)/jvs(158)\n  xx(57) = x(57)/jvs(162)\n  xx(58) = x(58)/jvs(166)\n  xx(59) = x(59)/jvs(170)\n  xx(60) = x(60)/jvs(174)\n  xx(61) = x(61)/jvs(178)\n  xx(62) = x(62)/jvs(182)\n  xx(63) = x(63)/jvs(186)\n  xx(64) = x(64)/jvs(190)\n  xx(65) = x(65)/jvs(194)\n  xx(66) = x(66)/jvs(198)\n  xx(67) = x(67)/jvs(202)\n  xx(68) = x(68)/jvs(206)\n  xx(69) = x(69)/jvs(210)\n  xx(70) = x(70)/jvs(214)\n  xx(71) = x(71)/jvs(218)\n  xx(72) = x(72)/jvs(222)\n  xx(73) = x(73)/jvs(226)\n  xx(74) = x(74)/jvs(230)\n  xx(75) = x(75)/jvs(234)\n  xx(76) = x(76)/jvs(238)\n  xx(77) = x(77)/jvs(244)\n  xx(78) = x(78)/jvs(247)\n  xx(79) = x(79)/jvs(252)\n  xx(80) = x(80)/jvs(256)\n  xx(81) = (x(81)-jvs(84)*xx(37))/(jvs(261))\n  xx(82) = x(82)/jvs(265)\n  xx(83) = x(83)/jvs(269)\n  xx(84) = x(84)/jvs(273)\n  xx(85) = x(85)/jvs(277)\n  xx(86) = x(86)/jvs(281)\n  xx(87) = x(87)/jvs(285)\n  xx(88) = x(88)/jvs(289)\n  xx(89) = x(89)/jvs(293)\n  xx(90) = x(90)/jvs(297)\n  xx(91) = x(91)/jvs(301)\n  xx(92) = x(92)/jvs(305)\n  xx(93) = x(93)/jvs(309)\n  xx(94) = x(94)/jvs(313)\n  xx(95) = (x(95)-jvs(73)*xx(33))/(jvs(317))\n  xx(96) = x(96)/jvs(321)\n  xx(97) = x(97)/jvs(325)\n  xx(98) = x(98)/jvs(329)\n  xx(99) = (x(99)-jvs(87)*xx(38))/(jvs(333))\n  xx(100) = (x(100)-jvs(88)*xx(38))/(jvs(337))\n  xx(101) = x(101)/jvs(341)\n  xx(102) = x(102)/jvs(345)\n  xx(103) = x(103)/jvs(350)\n  xx(104) = x(104)/jvs(354)\n  xx(105) = x(105)/jvs(358)\n  xx(106) = x(106)/jvs(362)\n  xx(107) = x(107)/jvs(372)\n  xx(108) = (x(108)-jvs(98)*xx(41))/(jvs(380))\n  xx(109) = (x(109)-jvs(12)*xx(5))/(jvs(385))\n  xx(110) = x(110)/jvs(389)\n  xx(111) = x(111)/jvs(393)\n  xx(112) = x(112)/jvs(397)\n  xx(113) = x(113)/jvs(401)\n  xx(114) = x(114)/jvs(405)\n  xx(115) = (x(115)-jvs(107)*xx(44))/(jvs(409))\n  xx(116) = x(116)/jvs(413)\n  xx(117) = x(117)/jvs(417)\n  xx(118) = x(118)/jvs(421)\n  xx(119) = x(119)/jvs(426)\n  xx(120) = x(120)/jvs(430)\n  xx(121) = x(121)/jvs(435)\n  xx(122) = x(122)/jvs(439)\n  xx(123) = x(123)/jvs(443)\n  xx(124) = x(124)/jvs(447)\n  xx(125) = x(125)/jvs(451)\n  xx(126) = x(126)/jvs(455)\n  xx(127) = (x(127)-jvs(8)*xx(4)-jvs(23)*xx(9))/(jvs(459))\n  xx(128) = x(128)/jvs(465)\n  xx(129) = x(129)/jvs(469)\n  xx(130) = x(130)/jvs(474)\n  xx(131) = x(131)/jvs(481)\n  xx(132) = x(132)/jvs(489)\n  xx(133) = x(133)/jvs(498)\n  xx(134) = x(134)/jvs(503)\n  xx(135) = x(135)/jvs(508)\n  xx(136) = x(136)/jvs(512)\n  xx(137) = x(137)/jvs(517)\n  xx(138) = x(138)/jvs(522)\n  xx(139) = x(139)/jvs(529)\n  xx(140) = x(140)/jvs(537)\n  xx(141) = x(141)/jvs(542)\n  xx(142) = x(142)/jvs(548)\n  xx(143) = (x(143)-jvs(137)*xx(51))/(jvs(554))\n  xx(144) = (x(144)-jvs(191)*xx(64))/(jvs(558))\n  xx(145) = (x(145)-jvs(179)*xx(61))/(jvs(563))\n  xx(146) = (x(146)-jvs(211)*xx(69))/(jvs(568))\n  xx(147) = (x(147)-jvs(175)*xx(60))/(jvs(573))\n  xx(148) = x(148)/jvs(580)\n  xx(149) = x(149)/jvs(591)\n  xx(150) = x(150)/jvs(603)\n  xx(151) = x(151)/jvs(614)\n  xx(152) = (x(152)-jvs(239)*xx(76))/(jvs(622))\n  xx(153) = (x(153)-jvs(111)*xx(45)-jvs(574)*xx(147))/(jvs(628))\n  xx(154) = (x(154)-jvs(240)*xx(76))/(jvs(634))\n  xx(155) = (x(155)-jvs(499)*xx(133)-jvs(543)*xx(141))/(jvs(648))\n  xx(156) = (x(156)-jvs(104)*xx(43)-jvs(235)*xx(75)-jvs(278)*xx(85))/(jvs(654))\n  xx(157) = (x(157)-jvs(219)*xx(71))/(jvs(661))\n  xx(158) = x(158)/jvs(668)\n  xx(159) = (x(159)-jvs(363)*xx(106)-jvs(373)*xx(107)-jvs(490)*xx(132))/(jvs(674))\n  xx(160) = (x(160)-jvs(245)*xx(77)-jvs(509)*xx(135))/(jvs(678))\n  xx(161) = x(161)/jvs(684)\n  xx(162) = (x(162)-jvs(138)*xx(51)-jvs(564)*xx(145))/(jvs(691))\n  xx(163) = (x(163)-jvs(294)*xx(89)-jvs(422)*xx(118)-jvs(604)*xx(150)-jvs(635)*xx(154))/(jvs(696))\n  xx(164) = (x(164)-jvs(91)*xx(39)-jvs(364)*xx(106)-jvs(569)*xx(146))/(jvs(701))\n  xx(165) = x(165)/jvs(710)\n  xx(166) = (x(166)-jvs(270)*xx(83))/(jvs(718))\n  xx(167) = (x(167)-jvs(241)*xx(76))/(jvs(727))\n  xx(168) = (x(168)-jvs(452)*xx(125)-jvs(491)*xx(132))/(jvs(737))\n  xx(169) = x(169)/jvs(746)\n  xx(170) = (x(170)-jvs(248)*xx(78)-jvs(470)*xx(129))/(jvs(755))\n  xx(171) = (x(171)-jvs(142)*xx(52)-jvs(460)*xx(127))/(jvs(762))\n  xx(172) = (x(172)-jvs(461)*xx(127)-jvs(763)*xx(171))/(jvs(769))\n  xx(173) = (x(173)-jvs(9)*xx(4)-jvs(462)*xx(127))/(jvs(779))\n  xx(174) = (x(174)-jvs(355)*xx(104)-jvs(466)*xx(128)-jvs(623)*xx(152))/(jvs(786))\n  xx(175) = (x(175)-jvs(112)*xx(45)-jvs(559)*xx(144)-jvs(615)*xx(151)-jvs(685)*xx(161))/(jvs(791))\n  xx(176) = (x(176)-jvs(513)*xx(136)-jvs(592)*xx(149))/(jvs(795))\n  xx(177) = (x(177)-jvs(257)*xx(80)-jvs(530)*xx(139))/(jvs(800))\n  xx(178) = (x(178)-jvs(187)*xx(63)-jvs(402)*xx(113))/(jvs(806))\n  xx(179) = x(179)/jvs(815)\n  xx(180) = x(180)/jvs(829)\n  xx(181) = (x(181)-jvs(302)*xx(91)-jvs(431)*xx(120)-jvs(605)*xx(150)-jvs(636)*xx(154))/(jvs(839))\n  xx(182) = (x(182)-jvs(242)*xx(76))/(jvs(849))\n  xx(183) = (x(183)-jvs(314)*xx(94))/(jvs(861))\n  xx(184) = (x(184)-jvs(322)*xx(96)-jvs(448)*xx(124)-jvs(492)*xx(132))/(jvs(870))\n  xx(185) = x(185)/jvs(886)\n  xx(186) = (x(186)-jvs(199)*xx(66)-jvs(203)*xx(67)-jvs(711)*xx(165)-jvs(887)*xx(185))/(jvs(903))\n  xx(187) = x(187)/jvs(922)\n  xx(188) = (x(188)-jvs(290)*xx(88)-jvs(686)*xx(161))/(jvs(936))\n  xx(189) = x(189)/jvs(963)\n  xx(190) = (x(190)-jvs(444)*xx(123)-jvs(669)*xx(158)-jvs(862)*xx(183)-jvs(888)*xx(185)-jvs(964)*xx(189))/(jvs(988))\n  xx(191) = (x(191)-jvs(274)*xx(84)-jvs(398)*xx(112)-jvs(965)*xx(189))/(jvs(998))\n  xx(192) = (x(192)-jvs(475)*xx(130)-jvs(523)*xx(138)-jvs(606)*xx(150)-jvs(728)*xx(167)-jvs(850)*xx(182)-jvs(966)&\n              &*xx(189))/(jvs(1007))\n  xx(193) = (x(193)-jvs(967)*xx(189))/(jvs(1028))\n  xx(194) = (x(194)-jvs(365)*xx(106)-jvs(889)*xx(185)-jvs(968)*xx(189)-jvs(1029)*xx(193))/(jvs(1046))\n  xx(195) = (x(195)-jvs(249)*xx(78)-jvs(471)*xx(129)-jvs(830)*xx(180))/(jvs(1054))\n  xx(196) = (x(196)-jvs(890)*xx(185)-jvs(969)*xx(189)-jvs(999)*xx(191))/(jvs(1066))\n  xx(197) = (x(197)-jvs(282)*xx(86)-jvs(414)*xx(116)-jvs(816)*xx(179)-jvs(970)*xx(189)-jvs(1030)*xx(193)-jvs(1067)&\n              &*xx(196))/(jvs(1077))\n  xx(198) = (x(198)-jvs(286)*xx(87)-jvs(406)*xx(114)-jvs(817)*xx(179)-jvs(971)*xx(189)-jvs(1031)*xx(193)-jvs(1068)&\n              &*xx(196))/(jvs(1087))\n  xx(199) = (x(199)-jvs(195)*xx(65)-jvs(359)*xx(105)-jvs(1069)*xx(196))/(jvs(1109))\n  xx(200) = (x(200)-jvs(500)*xx(133)-jvs(544)*xx(141)-jvs(581)*xx(148)-jvs(729)*xx(167)-jvs(851)*xx(182)-jvs(1032)&\n              &*xx(193)-jvs(1110)*xx(199))/(jvs(1120))\n  xx(201) = (x(201)-jvs(366)*xx(106)-jvs(891)*xx(185)-jvs(972)*xx(189)-jvs(1033)*xx(193)-jvs(1078)*xx(197))/(jvs(1130))\n  xx(202) = (x(202)-jvs(476)*xx(130)-jvs(524)*xx(138)-jvs(582)*xx(148)-jvs(607)*xx(150)-jvs(637)*xx(154)-jvs(730)&\n              &*xx(167)-jvs(852)*xx(182)-jvs(973)*xx(189)-jvs(1034)*xx(193)-jvs(1111)*xx(199))/(jvs(1138))\n  xx(203) = (x(203)-jvs(183)*xx(62)-jvs(394)*xx(111)-jvs(974)*xx(189))/(jvs(1145))\n  xx(204) = (x(204)-jvs(310)*xx(93)-jvs(679)*xx(160)-jvs(863)*xx(183)-jvs(892)*xx(185)-jvs(923)*xx(187)-jvs(975)*xx(189)&\n              &-jvs(989)*xx(190)-jvs(1000)*xx(191))/(jvs(1156))\n  xx(205) = (x(205)-jvs(163)*xx(57)-jvs(351)*xx(103)-jvs(482)*xx(131)-jvs(756)*xx(170)-jvs(831)*xx(180)-jvs(1055)&\n              &*xx(195))/(jvs(1164))\n  xx(206) = (x(206)-jvs(893)*xx(185)-jvs(976)*xx(189))/(jvs(1208))\n  xx(207) = (x(207)-jvs(346)*xx(102)-jvs(518)*xx(137)-jvs(747)*xx(169))/(jvs(1226))\n  xx(208) = (x(208)-jvs(171)*xx(59)-jvs(583)*xx(148))/(jvs(1236))\n  xx(209) = (x(209)-jvs(101)*xx(42)-jvs(227)*xx(73)-jvs(306)*xx(92)-jvs(1112)*xx(199)-jvs(1209)*xx(206))/(jvs(1260))\n  xx(210) = (x(210)-jvs(334)*xx(99)-jvs(338)*xx(100)-jvs(924)*xx(187))/(jvs(1273))\n  xx(211) = (x(211)-jvs(76)*xx(34)-jvs(81)*xx(36)-jvs(298)*xx(90)-jvs(342)*xx(101)-jvs(1210)*xx(206))/(jvs(1302))\n  xx(212) = (x(212)-jvs(215)*xx(70)-jvs(318)*xx(95)-jvs(662)*xx(157)-jvs(925)*xx(187)-jvs(1157)*xx(204)-jvs(1211)&\n              &*xx(206)-jvs(1303)*xx(211))/(jvs(1318))\n  xx(213) = (x(213)-jvs(155)*xx(55)-jvs(266)*xx(82)-jvs(538)*xx(140)-jvs(584)*xx(148))/(jvs(1333))\n  xx(214) = (x(214)-jvs(223)*xx(72)-jvs(326)*xx(97)-jvs(374)*xx(107)-jvs(796)*xx(176)-jvs(926)*xx(187)-jvs(1212)*xx(206)&\n              &-jvs(1237)*xx(208)-jvs(1261)*xx(209)-jvs(1274)*xx(210)-jvs(1304)*xx(211)-jvs(1334)*xx(213))/(jvs(1345))\n  xx(215) = (x(215)-jvs(134)*xx(50)-jvs(159)*xx(56)-jvs(330)*xx(98))/(jvs(1365))\n  xx(216) = (x(216)-jvs(410)*xx(115)-jvs(1146)*xx(203)-jvs(1262)*xx(209)-jvs(1335)*xx(213))/(jvs(1376))\n  xx(217) = (x(217)-jvs(151)*xx(54)-jvs(418)*xx(117)-jvs(818)*xx(179)-jvs(1035)*xx(193)-jvs(1213)*xx(206))/(jvs(1399))\n  xx(218) = (x(218)-jvs(262)*xx(81)-jvs(801)*xx(177)-jvs(1227)*xx(207)-jvs(1366)*xx(215)-jvs(1377)*xx(216)-jvs(1400)&\n              &*xx(217))/(jvs(1411))\n  xx(219) = (x(219)-jvs(147)*xx(53)-jvs(456)*xx(126)-jvs(977)*xx(189)-jvs(1214)*xx(206)-jvs(1305)*xx(211))/(jvs(1452))\n  xx(220) = (x(220)-jvs(167)*xx(58)-jvs(1036)*xx(193)-jvs(1215)*xx(206)-jvs(1263)*xx(209)-jvs(1453)*xx(219))/(jvs(1484))\n  xx(221) = (x(221)-jvs(207)*xx(68)-jvs(440)*xx(122)-jvs(832)*xx(180)-jvs(927)*xx(187)-jvs(1306)*xx(211)-jvs(1319)&\n              &*xx(212)-jvs(1401)*xx(217)-jvs(1454)*xx(219)-jvs(1485)*xx(220))/(jvs(1498))\n  xx(222) = (x(222)-jvs(19)*xx(7)-jvs(92)*xx(39)-jvs(113)*xx(45)-jvs(139)*xx(51)-jvs(143)*xx(52)-jvs(367)*xx(106)&\n              &-jvs(375)*xx(107)-jvs(493)*xx(132)-jvs(549)*xx(142)-jvs(555)*xx(143)-jvs(629)*xx(153)-jvs(675)*xx(159)&\n              &-jvs(692)*xx(162)-jvs(702)*xx(164)-jvs(712)*xx(165)-jvs(719)*xx(166)-jvs(738)*xx(168)-jvs(764)*xx(171)&\n              &-jvs(770)*xx(172)-jvs(780)*xx(173)-jvs(792)*xx(175)-jvs(807)*xx(178)-jvs(871)*xx(184)-jvs(894)*xx(185)&\n              &-jvs(904)*xx(186)-jvs(928)*xx(187)-jvs(937)*xx(188)-jvs(978)*xx(189)-jvs(1037)*xx(193)-jvs(1047)*xx(194)&\n              &-jvs(1056)*xx(195)-jvs(1070)*xx(196)-jvs(1088)*xx(198)-jvs(1113)*xx(199)-jvs(1131)*xx(201)-jvs(1165)*xx(205)&\n              &-jvs(1216)*xx(206)-jvs(1275)*xx(210)-jvs(1307)*xx(211)-jvs(1320)*xx(212)-jvs(1336)*xx(213)-jvs(1346)*xx(214)&\n              &-jvs(1367)*xx(215)-jvs(1402)*xx(217)-jvs(1412)*xx(218)-jvs(1455)*xx(219)-jvs(1486)*xx(220)-jvs(1499)*xx(221))&\n              &/(jvs(1517))\n  xx(223) = (x(223)-jvs(253)*xx(79)-jvs(258)*xx(80)-jvs(531)*xx(139)-jvs(1228)*xx(207)-jvs(1368)*xx(215)-jvs(1378)&\n              &*xx(216)-jvs(1403)*xx(217)-jvs(1456)*xx(219)-jvs(1487)*xx(220))/(jvs(1532))\n  xx(224) = (x(224)-jvs(347)*xx(102)-jvs(519)*xx(137)-jvs(748)*xx(169)-jvs(1488)*xx(220))/(jvs(1547))\n  xx(225) = (x(225)-jvs(504)*xx(134)-jvs(514)*xx(136)-jvs(593)*xx(149)-jvs(1238)*xx(208)-jvs(1264)*xx(209)-jvs(1369)&\n              &*xx(215)-jvs(1404)*xx(217)-jvs(1457)*xx(219))/(jvs(1569))\n  xx(226) = (x(226)-jvs(895)*xx(185)-jvs(979)*xx(189)-jvs(1147)*xx(203)-jvs(1265)*xx(209))/(jvs(1592))\n  xx(227) = (x(227)-jvs(95)*xx(40)-jvs(152)*xx(54)-jvs(156)*xx(55)-jvs(188)*xx(63)-jvs(196)*xx(65)-jvs(200)*xx(66)&\n              &-jvs(250)*xx(78)-jvs(254)*xx(79)-jvs(279)*xx(85)-jvs(299)*xx(90)-jvs(307)*xx(92)-jvs(319)*xx(95)-jvs(323)&\n              &*xx(96)-jvs(327)*xx(97)-jvs(331)*xx(98)-jvs(335)*xx(99)-jvs(348)*xx(102)-jvs(352)*xx(103)-jvs(376)*xx(107)&\n              &-jvs(390)*xx(110)-jvs(423)*xx(118)-jvs(432)*xx(120)-jvs(467)*xx(128)-jvs(483)*xx(131)-jvs(494)*xx(132)&\n              &-jvs(505)*xx(134)-jvs(525)*xx(138)-jvs(532)*xx(139)-jvs(539)*xx(140)-jvs(545)*xx(141)-jvs(550)*xx(142)&\n              &-jvs(560)*xx(144)-jvs(565)*xx(145)-jvs(570)*xx(146)-jvs(575)*xx(147)-jvs(585)*xx(148)-jvs(594)*xx(149)&\n              &-jvs(608)*xx(150)-jvs(616)*xx(151)-jvs(624)*xx(152)-jvs(638)*xx(154)-jvs(649)*xx(155)-jvs(655)*xx(156)&\n              &-jvs(663)*xx(157)-jvs(670)*xx(158)-jvs(680)*xx(160)-jvs(687)*xx(161)-jvs(697)*xx(163)-jvs(713)*xx(165)&\n              &-jvs(720)*xx(166)-jvs(731)*xx(167)-jvs(739)*xx(168)-jvs(749)*xx(169)-jvs(757)*xx(170)-jvs(771)*xx(172)&\n              &-jvs(781)*xx(173)-jvs(787)*xx(174)-jvs(797)*xx(176)-jvs(802)*xx(177)-jvs(808)*xx(178)-jvs(819)*xx(179)&\n              &-jvs(833)*xx(180)-jvs(840)*xx(181)-jvs(853)*xx(182)-jvs(864)*xx(183)-jvs(872)*xx(184)-jvs(896)*xx(185)&\n              &-jvs(905)*xx(186)-jvs(929)*xx(187)-jvs(938)*xx(188)-jvs(980)*xx(189)-jvs(990)*xx(190)-jvs(1001)*xx(191)&\n              &-jvs(1008)*xx(192)-jvs(1038)*xx(193)-jvs(1048)*xx(194)-jvs(1057)*xx(195)-jvs(1071)*xx(196)-jvs(1079)*xx(197)&\n              &-jvs(1089)*xx(198)-jvs(1114)*xx(199)-jvs(1121)*xx(200)-jvs(1132)*xx(201)-jvs(1139)*xx(202)-jvs(1148)*xx(203)&\n              &-jvs(1158)*xx(204)-jvs(1166)*xx(205)-jvs(1217)*xx(206)-jvs(1229)*xx(207)-jvs(1239)*xx(208)-jvs(1266)*xx(209)&\n              &-jvs(1276)*xx(210)-jvs(1308)*xx(211)-jvs(1321)*xx(212)-jvs(1337)*xx(213)-jvs(1347)*xx(214)-jvs(1370)*xx(215)&\n              &-jvs(1379)*xx(216)-jvs(1405)*xx(217)-jvs(1413)*xx(218)-jvs(1458)*xx(219)-jvs(1489)*xx(220)-jvs(1500)*xx(221)&\n              &-jvs(1518)*xx(222)-jvs(1533)*xx(223)-jvs(1548)*xx(224)-jvs(1570)*xx(225)-jvs(1593)*xx(226))/(jvs(1662))\n  xx(228) = (x(228)-jvs(13)*xx(5)-jvs(17)*xx(6)-jvs(21)*xx(8)-jvs(24)*xx(9)-jvs(26)*xx(10)-jvs(28)*xx(11)-jvs(30)*xx(12)&\n              &-jvs(32)*xx(13)-jvs(34)*xx(14)-jvs(36)*xx(15)-jvs(38)*xx(16)-jvs(40)*xx(17)-jvs(42)*xx(18)-jvs(44)*xx(19)&\n              &-jvs(46)*xx(20)-jvs(48)*xx(21)-jvs(50)*xx(22)-jvs(52)*xx(23)-jvs(54)*xx(24)-jvs(56)*xx(25)-jvs(58)*xx(26)&\n              &-jvs(60)*xx(27)-jvs(62)*xx(28)-jvs(64)*xx(29)-jvs(66)*xx(30)-jvs(68)*xx(31)-jvs(74)*xx(33)-jvs(79)*xx(35)&\n              &-jvs(82)*xx(36)-jvs(85)*xx(37)-jvs(89)*xx(38)-jvs(93)*xx(39)-jvs(96)*xx(40)-jvs(99)*xx(41)-jvs(102)*xx(42)&\n              &-jvs(105)*xx(43)-jvs(108)*xx(44)-jvs(114)*xx(45)-jvs(117)*xx(46)-jvs(121)*xx(47)-jvs(126)*xx(48)-jvs(130)&\n              &*xx(49)-jvs(135)*xx(50)-jvs(140)*xx(51)-jvs(148)*xx(53)-jvs(153)*xx(54)-jvs(157)*xx(55)-jvs(160)*xx(56)&\n              &-jvs(164)*xx(57)-jvs(168)*xx(58)-jvs(172)*xx(59)-jvs(176)*xx(60)-jvs(180)*xx(61)-jvs(184)*xx(62)-jvs(189)&\n              &*xx(63)-jvs(192)*xx(64)-jvs(197)*xx(65)-jvs(201)*xx(66)-jvs(204)*xx(67)-jvs(208)*xx(68)-jvs(212)*xx(69)&\n              &-jvs(216)*xx(70)-jvs(220)*xx(71)-jvs(224)*xx(72)-jvs(228)*xx(73)-jvs(231)*xx(74)-jvs(236)*xx(75)-jvs(243)&\n              &*xx(76)-jvs(246)*xx(77)-jvs(251)*xx(78)-jvs(255)*xx(79)-jvs(259)*xx(80)-jvs(263)*xx(81)-jvs(267)*xx(82)&\n              &-jvs(271)*xx(83)-jvs(275)*xx(84)-jvs(280)*xx(85)-jvs(283)*xx(86)-jvs(287)*xx(87)-jvs(291)*xx(88)-jvs(295)&\n              &*xx(89)-jvs(300)*xx(90)-jvs(303)*xx(91)-jvs(308)*xx(92)-jvs(311)*xx(93)-jvs(315)*xx(94)-jvs(320)*xx(95)&\n              &-jvs(324)*xx(96)-jvs(328)*xx(97)-jvs(332)*xx(98)-jvs(336)*xx(99)-jvs(339)*xx(100)-jvs(343)*xx(101)-jvs(349)&\n              &*xx(102)-jvs(353)*xx(103)-jvs(356)*xx(104)-jvs(360)*xx(105)-jvs(368)*xx(106)-jvs(377)*xx(107)-jvs(381)&\n              &*xx(108)-jvs(386)*xx(109)-jvs(391)*xx(110)-jvs(395)*xx(111)-jvs(399)*xx(112)-jvs(403)*xx(113)-jvs(407)&\n              &*xx(114)-jvs(411)*xx(115)-jvs(415)*xx(116)-jvs(419)*xx(117)-jvs(424)*xx(118)-jvs(427)*xx(119)-jvs(433)&\n              &*xx(120)-jvs(436)*xx(121)-jvs(441)*xx(122)-jvs(445)*xx(123)-jvs(449)*xx(124)-jvs(453)*xx(125)-jvs(457)&\n              &*xx(126)-jvs(463)*xx(127)-jvs(468)*xx(128)-jvs(472)*xx(129)-jvs(477)*xx(130)-jvs(484)*xx(131)-jvs(495)&\n              &*xx(132)-jvs(501)*xx(133)-jvs(506)*xx(134)-jvs(510)*xx(135)-jvs(515)*xx(136)-jvs(520)*xx(137)-jvs(526)&\n              &*xx(138)-jvs(533)*xx(139)-jvs(540)*xx(140)-jvs(546)*xx(141)-jvs(551)*xx(142)-jvs(556)*xx(143)-jvs(586)&\n              &*xx(148)-jvs(595)*xx(149)-jvs(609)*xx(150)-jvs(617)*xx(151)-jvs(625)*xx(152)-jvs(630)*xx(153)-jvs(639)&\n              &*xx(154)-jvs(650)*xx(155)-jvs(656)*xx(156)-jvs(664)*xx(157)-jvs(671)*xx(158)-jvs(676)*xx(159)-jvs(681)&\n              &*xx(160)-jvs(688)*xx(161)-jvs(693)*xx(162)-jvs(698)*xx(163)-jvs(703)*xx(164)-jvs(714)*xx(165)-jvs(721)&\n              &*xx(166)-jvs(732)*xx(167)-jvs(740)*xx(168)-jvs(750)*xx(169)-jvs(758)*xx(170)-jvs(765)*xx(171)-jvs(772)&\n              &*xx(172)-jvs(782)*xx(173)-jvs(788)*xx(174)-jvs(793)*xx(175)-jvs(809)*xx(178)-jvs(820)*xx(179)-jvs(834)&\n              &*xx(180)-jvs(841)*xx(181)-jvs(854)*xx(182)-jvs(865)*xx(183)-jvs(873)*xx(184)-jvs(897)*xx(185)-jvs(906)&\n              &*xx(186)-jvs(930)*xx(187)-jvs(939)*xx(188)-jvs(981)*xx(189)-jvs(991)*xx(190)-jvs(1002)*xx(191)-jvs(1009)&\n              &*xx(192)-jvs(1039)*xx(193)-jvs(1049)*xx(194)-jvs(1058)*xx(195)-jvs(1072)*xx(196)-jvs(1080)*xx(197)-jvs(1090)&\n              &*xx(198)-jvs(1115)*xx(199)-jvs(1122)*xx(200)-jvs(1133)*xx(201)-jvs(1140)*xx(202)-jvs(1149)*xx(203)-jvs(1159)&\n              &*xx(204)-jvs(1167)*xx(205)-jvs(1218)*xx(206)-jvs(1230)*xx(207)-jvs(1240)*xx(208)-jvs(1267)*xx(209)-jvs(1277)&\n              &*xx(210)-jvs(1309)*xx(211)-jvs(1322)*xx(212)-jvs(1338)*xx(213)-jvs(1348)*xx(214)-jvs(1371)*xx(215)-jvs(1380)&\n              &*xx(216)-jvs(1406)*xx(217)-jvs(1414)*xx(218)-jvs(1459)*xx(219)-jvs(1490)*xx(220)-jvs(1501)*xx(221)-jvs(1519)&\n              &*xx(222)-jvs(1534)*xx(223)-jvs(1549)*xx(224)-jvs(1571)*xx(225)-jvs(1594)*xx(226)-jvs(1663)*xx(227))&\n              &/(jvs(1881))\n  xx(229) = (x(229)-jvs(70)*xx(32)-jvs(77)*xx(34)-jvs(122)*xx(47)-jvs(131)*xx(49)-jvs(144)*xx(52)-jvs(232)*xx(74)&\n              &-jvs(288)*xx(87)-jvs(396)*xx(111)-jvs(400)*xx(112)-jvs(416)*xx(116)-jvs(428)*xx(119)-jvs(437)*xx(121)&\n              &-jvs(442)*xx(122)-jvs(458)*xx(126)-jvs(464)*xx(127)-jvs(552)*xx(142)-jvs(751)*xx(169)-jvs(766)*xx(171)&\n              &-jvs(773)*xx(172)-jvs(783)*xx(173)-jvs(821)*xx(179)-jvs(835)*xx(180)-jvs(898)*xx(185)-jvs(931)*xx(187)&\n              &-jvs(982)*xx(189)-jvs(1003)*xx(191)-jvs(1040)*xx(193)-jvs(1081)*xx(197)-jvs(1091)*xx(198)-jvs(1134)*xx(201)&\n              &-jvs(1150)*xx(203)-jvs(1219)*xx(206)-jvs(1268)*xx(209)-jvs(1310)*xx(211)-jvs(1460)*xx(219)-jvs(1491)*xx(220)&\n              &-jvs(1502)*xx(221)-jvs(1520)*xx(222)-jvs(1535)*xx(223)-jvs(1550)*xx(224)-jvs(1572)*xx(225)-jvs(1595)*xx(226)&\n              &-jvs(1664)*xx(227)-jvs(1882)*xx(228))/(jvs(1998))\n  xx(230) = (x(230)-jvs(71)*xx(32)-jvs(118)*xx(46)-jvs(123)*xx(47)-jvs(127)*xx(48)-jvs(132)*xx(49)-jvs(378)*xx(107)&\n              &-jvs(382)*xx(108)-jvs(387)*xx(109)-jvs(392)*xx(110)-jvs(429)*xx(119)-jvs(438)*xx(121)-jvs(496)*xx(132)&\n              &-jvs(511)*xx(135)-jvs(553)*xx(142)-jvs(557)*xx(143)-jvs(561)*xx(144)-jvs(566)*xx(145)-jvs(571)*xx(146)&\n              &-jvs(576)*xx(147)-jvs(587)*xx(148)-jvs(596)*xx(149)-jvs(610)*xx(150)-jvs(618)*xx(151)-jvs(626)*xx(152)&\n              &-jvs(631)*xx(153)-jvs(640)*xx(154)-jvs(651)*xx(155)-jvs(657)*xx(156)-jvs(665)*xx(157)-jvs(672)*xx(158)&\n              &-jvs(677)*xx(159)-jvs(689)*xx(161)-jvs(694)*xx(162)-jvs(699)*xx(163)-jvs(704)*xx(164)-jvs(715)*xx(165)&\n              &-jvs(722)*xx(166)-jvs(733)*xx(167)-jvs(741)*xx(168)-jvs(752)*xx(169)-jvs(759)*xx(170)-jvs(767)*xx(171)&\n              &-jvs(774)*xx(172)-jvs(784)*xx(173)-jvs(789)*xx(174)-jvs(794)*xx(175)-jvs(798)*xx(176)-jvs(803)*xx(177)&\n              &-jvs(810)*xx(178)-jvs(822)*xx(179)-jvs(836)*xx(180)-jvs(842)*xx(181)-jvs(855)*xx(182)-jvs(866)*xx(183)&\n              &-jvs(874)*xx(184)-jvs(899)*xx(185)-jvs(907)*xx(186)-jvs(932)*xx(187)-jvs(940)*xx(188)-jvs(983)*xx(189)&\n              &-jvs(992)*xx(190)-jvs(1004)*xx(191)-jvs(1010)*xx(192)-jvs(1041)*xx(193)-jvs(1050)*xx(194)-jvs(1059)*xx(195)&\n              &-jvs(1073)*xx(196)-jvs(1082)*xx(197)-jvs(1092)*xx(198)-jvs(1116)*xx(199)-jvs(1123)*xx(200)-jvs(1135)*xx(201)&\n              &-jvs(1141)*xx(202)-jvs(1151)*xx(203)-jvs(1160)*xx(204)-jvs(1168)*xx(205)-jvs(1220)*xx(206)-jvs(1231)*xx(207)&\n              &-jvs(1241)*xx(208)-jvs(1269)*xx(209)-jvs(1278)*xx(210)-jvs(1311)*xx(211)-jvs(1323)*xx(212)-jvs(1339)*xx(213)&\n              &-jvs(1349)*xx(214)-jvs(1372)*xx(215)-jvs(1381)*xx(216)-jvs(1407)*xx(217)-jvs(1415)*xx(218)-jvs(1461)*xx(219)&\n              &-jvs(1492)*xx(220)-jvs(1503)*xx(221)-jvs(1521)*xx(222)-jvs(1536)*xx(223)-jvs(1551)*xx(224)-jvs(1573)*xx(225)&\n              &-jvs(1596)*xx(226)-jvs(1665)*xx(227)-jvs(1883)*xx(228)-jvs(1999)*xx(229))/(jvs(2080))\n  xx(231) = (x(231)-jvs(900)*xx(185)-jvs(984)*xx(189)-jvs(1312)*xx(211)-jvs(1462)*xx(219)-jvs(1666)*xx(227)-jvs(1884)&\n              &*xx(228)-jvs(2000)*xx(229)-jvs(2081)*xx(230))/(jvs(2120))\n  xx(232) = (x(232)-jvs(14)*xx(5)-jvs(145)*xx(52)-jvs(149)*xx(53)-jvs(161)*xx(56)-jvs(165)*xx(57)-jvs(169)*xx(58)&\n              &-jvs(173)*xx(59)-jvs(177)*xx(60)-jvs(181)*xx(61)-jvs(185)*xx(62)-jvs(193)*xx(64)-jvs(205)*xx(67)-jvs(209)&\n              &*xx(68)-jvs(213)*xx(69)-jvs(217)*xx(70)-jvs(221)*xx(71)-jvs(225)*xx(72)-jvs(229)*xx(73)-jvs(233)*xx(74)&\n              &-jvs(237)*xx(75)-jvs(260)*xx(80)-jvs(264)*xx(81)-jvs(268)*xx(82)-jvs(272)*xx(83)-jvs(276)*xx(84)-jvs(284)&\n              &*xx(86)-jvs(292)*xx(88)-jvs(296)*xx(89)-jvs(304)*xx(91)-jvs(312)*xx(93)-jvs(316)*xx(94)-jvs(340)*xx(100)&\n              &-jvs(344)*xx(101)-jvs(357)*xx(104)-jvs(361)*xx(105)-jvs(369)*xx(106)-jvs(379)*xx(107)-jvs(404)*xx(113)&\n              &-jvs(408)*xx(114)-jvs(412)*xx(115)-jvs(420)*xx(117)-jvs(446)*xx(123)-jvs(450)*xx(124)-jvs(454)*xx(125)&\n              &-jvs(473)*xx(129)-jvs(478)*xx(130)-jvs(485)*xx(131)-jvs(497)*xx(132)-jvs(502)*xx(133)-jvs(516)*xx(136)&\n              &-jvs(521)*xx(137)-jvs(534)*xx(139)-jvs(541)*xx(140)-jvs(562)*xx(144)-jvs(567)*xx(145)-jvs(572)*xx(146)&\n              &-jvs(577)*xx(147)-jvs(588)*xx(148)-jvs(597)*xx(149)-jvs(611)*xx(150)-jvs(619)*xx(151)-jvs(627)*xx(152)&\n              &-jvs(641)*xx(154)-jvs(652)*xx(155)-jvs(658)*xx(156)-jvs(666)*xx(157)-jvs(673)*xx(158)-jvs(690)*xx(161)&\n              &-jvs(700)*xx(163)-jvs(716)*xx(165)-jvs(723)*xx(166)-jvs(734)*xx(167)-jvs(742)*xx(168)-jvs(753)*xx(169)&\n              &-jvs(760)*xx(170)-jvs(790)*xx(174)-jvs(799)*xx(176)-jvs(804)*xx(177)-jvs(811)*xx(178)-jvs(823)*xx(179)&\n              &-jvs(837)*xx(180)-jvs(843)*xx(181)-jvs(856)*xx(182)-jvs(867)*xx(183)-jvs(875)*xx(184)-jvs(901)*xx(185)&\n              &-jvs(908)*xx(186)-jvs(933)*xx(187)-jvs(941)*xx(188)-jvs(985)*xx(189)-jvs(993)*xx(190)-jvs(1005)*xx(191)&\n              &-jvs(1011)*xx(192)-jvs(1042)*xx(193)-jvs(1051)*xx(194)-jvs(1060)*xx(195)-jvs(1074)*xx(196)-jvs(1083)*xx(197)&\n              &-jvs(1093)*xx(198)-jvs(1117)*xx(199)-jvs(1124)*xx(200)-jvs(1136)*xx(201)-jvs(1142)*xx(202)-jvs(1152)*xx(203)&\n              &-jvs(1161)*xx(204)-jvs(1169)*xx(205)-jvs(1221)*xx(206)-jvs(1232)*xx(207)-jvs(1242)*xx(208)-jvs(1270)*xx(209)&\n              &-jvs(1279)*xx(210)-jvs(1313)*xx(211)-jvs(1324)*xx(212)-jvs(1340)*xx(213)-jvs(1350)*xx(214)-jvs(1373)*xx(215)&\n              &-jvs(1382)*xx(216)-jvs(1408)*xx(217)-jvs(1416)*xx(218)-jvs(1463)*xx(219)-jvs(1493)*xx(220)-jvs(1504)*xx(221)&\n              &-jvs(1522)*xx(222)-jvs(1537)*xx(223)-jvs(1552)*xx(224)-jvs(1574)*xx(225)-jvs(1597)*xx(226)-jvs(1667)*xx(227)&\n              &-jvs(1885)*xx(228)-jvs(2001)*xx(229)-jvs(2082)*xx(230)-jvs(2121)*xx(231))/(jvs(2257))\n  xx(232) = xx(232)\n  xx(231) = xx(231)-jvs(2256)*xx(232)\n  xx(230) = xx(230)-jvs(2119)*xx(231)-jvs(2255)*xx(232)\n  xx(229) = xx(229)-jvs(2079)*xx(230)-jvs(2118)*xx(231)-jvs(2254)*xx(232)\n  xx(228) = xx(228)-jvs(1997)*xx(229)-jvs(2078)*xx(230)-jvs(2117)*xx(231)-jvs(2253)*xx(232)\n  xx(227) = xx(227)-jvs(1880)*xx(228)-jvs(1996)*xx(229)-jvs(2077)*xx(230)-jvs(2116)*xx(231)-jvs(2252)*xx(232)\n  xx(226) = xx(226)-jvs(1661)*xx(227)-jvs(1879)*xx(228)-jvs(1995)*xx(229)-jvs(2076)*xx(230)-jvs(2115)*xx(231)-jvs(2251)&\n              &*xx(232)\n  xx(225) = xx(225)-jvs(1591)*xx(226)-jvs(1660)*xx(227)-jvs(1878)*xx(228)-jvs(1994)*xx(229)-jvs(2075)*xx(230)-jvs(2114)&\n              &*xx(231)-jvs(2250)*xx(232)\n  xx(224) = xx(224)-jvs(1568)*xx(225)-jvs(1590)*xx(226)-jvs(1659)*xx(227)-jvs(1877)*xx(228)-jvs(1993)*xx(229)-jvs(2074)&\n              &*xx(230)-jvs(2113)*xx(231)-jvs(2249)*xx(232)\n  xx(223) = xx(223)-jvs(1546)*xx(224)-jvs(1567)*xx(225)-jvs(1589)*xx(226)-jvs(1658)*xx(227)-jvs(1876)*xx(228)-jvs(1992)&\n              &*xx(229)-jvs(2073)*xx(230)-jvs(2112)*xx(231)-jvs(2248)*xx(232)\n  xx(222) = xx(222)-jvs(1531)*xx(223)-jvs(1545)*xx(224)-jvs(1566)*xx(225)-jvs(1588)*xx(226)-jvs(1657)*xx(227)-jvs(1875)&\n              &*xx(228)-jvs(1991)*xx(229)-jvs(2072)*xx(230)-jvs(2111)*xx(231)-jvs(2247)*xx(232)\n  xx(221) = xx(221)-jvs(1530)*xx(223)-jvs(1544)*xx(224)-jvs(1587)*xx(226)-jvs(1656)*xx(227)-jvs(1874)*xx(228)-jvs(1990)&\n              &*xx(229)-jvs(2071)*xx(230)-jvs(2110)*xx(231)-jvs(2246)*xx(232)\n  xx(220) = xx(220)-jvs(1655)*xx(227)-jvs(1873)*xx(228)-jvs(1989)*xx(229)-jvs(2070)*xx(230)-jvs(2109)*xx(231)-jvs(2245)&\n              &*xx(232)\n  xx(219) = xx(219)-jvs(1654)*xx(227)-jvs(1872)*xx(228)-jvs(1988)*xx(229)-jvs(2069)*xx(230)-jvs(2244)*xx(232)\n  xx(218) = xx(218)-jvs(1451)*xx(219)-jvs(1483)*xx(220)-jvs(1529)*xx(223)-jvs(1543)*xx(224)-jvs(1565)*xx(225)-jvs(1586)&\n              &*xx(226)-jvs(1653)*xx(227)-jvs(1871)*xx(228)-jvs(1987)*xx(229)-jvs(2068)*xx(230)-jvs(2108)*xx(231)-jvs(2243)&\n              &*xx(232)\n  xx(217) = xx(217)-jvs(1450)*xx(219)-jvs(1652)*xx(227)-jvs(1870)*xx(228)-jvs(1986)*xx(229)-jvs(2067)*xx(230)-jvs(2107)&\n              &*xx(231)-jvs(2242)*xx(232)\n  xx(216) = xx(216)-jvs(1398)*xx(217)-jvs(1449)*xx(219)-jvs(1482)*xx(220)-jvs(1564)*xx(225)-jvs(1651)*xx(227)-jvs(1869)&\n              &*xx(228)-jvs(1985)*xx(229)-jvs(2066)*xx(230)-jvs(2106)*xx(231)-jvs(2241)*xx(232)\n  xx(215) = xx(215)-jvs(1397)*xx(217)-jvs(1585)*xx(226)-jvs(1650)*xx(227)-jvs(1868)*xx(228)-jvs(1984)*xx(229)-jvs(2065)&\n              &*xx(230)-jvs(2240)*xx(232)\n  xx(214) = xx(214)-jvs(1364)*xx(215)-jvs(1396)*xx(217)-jvs(1448)*xx(219)-jvs(1481)*xx(220)-jvs(1563)*xx(225)-jvs(1649)&\n              &*xx(227)-jvs(1867)*xx(228)-jvs(1983)*xx(229)-jvs(2064)*xx(230)-jvs(2105)*xx(231)-jvs(2239)*xx(232)\n  xx(213) = xx(213)-jvs(1395)*xx(217)-jvs(1447)*xx(219)-jvs(1648)*xx(227)-jvs(1866)*xx(228)-jvs(1982)*xx(229)-jvs(2063)&\n              &*xx(230)-jvs(2104)*xx(231)-jvs(2238)*xx(232)\n  xx(212) = xx(212)-jvs(1394)*xx(217)-jvs(1446)*xx(219)-jvs(1480)*xx(220)-jvs(1542)*xx(224)-jvs(1647)*xx(227)-jvs(1865)&\n              &*xx(228)-jvs(1981)*xx(229)-jvs(2062)*xx(230)-jvs(2237)*xx(232)\n  xx(211) = xx(211)-jvs(1646)*xx(227)-jvs(1864)*xx(228)-jvs(1980)*xx(229)-jvs(2061)*xx(230)-jvs(2236)*xx(232)\n  xx(210) = xx(210)-jvs(1301)*xx(211)-jvs(1332)*xx(213)-jvs(1445)*xx(219)-jvs(1479)*xx(220)-jvs(1562)*xx(225)-jvs(1645)&\n              &*xx(227)-jvs(1863)*xx(228)-jvs(1979)*xx(229)-jvs(2060)*xx(230)-jvs(2235)*xx(232)\n  xx(209) = xx(209)-jvs(1644)*xx(227)-jvs(1862)*xx(228)-jvs(1978)*xx(229)-jvs(2059)*xx(230)-jvs(2103)*xx(231)-jvs(2234)&\n              &*xx(232)\n  xx(208) = xx(208)-jvs(1363)*xx(215)-jvs(1393)*xx(217)-jvs(1444)*xx(219)-jvs(1643)*xx(227)-jvs(1861)*xx(228)-jvs(1977)&\n              &*xx(229)-jvs(2058)*xx(230)-jvs(2102)*xx(231)-jvs(2233)*xx(232)\n  xx(207) = xx(207)-jvs(1478)*xx(220)-jvs(1561)*xx(225)-jvs(1584)*xx(226)-jvs(1642)*xx(227)-jvs(1860)*xx(228)-jvs(1976)&\n              &*xx(229)-jvs(2057)*xx(230)-jvs(2101)*xx(231)-jvs(2232)*xx(232)\n  xx(206) = xx(206)-jvs(1859)*xx(228)-jvs(1975)*xx(229)-jvs(2056)*xx(230)-jvs(2231)*xx(232)\n  xx(205) = xx(205)-jvs(1362)*xx(215)-jvs(1410)*xx(218)-jvs(1477)*xx(220)-jvs(1528)*xx(223)-jvs(1583)*xx(226)-jvs(1641)&\n              &*xx(227)-jvs(1858)*xx(228)-jvs(1974)*xx(229)-jvs(2055)*xx(230)-jvs(2230)*xx(232)\n  xx(204) = xx(204)-jvs(1207)*xx(206)-jvs(1300)*xx(211)-jvs(1392)*xx(217)-jvs(1443)*xx(219)-jvs(1476)*xx(220)-jvs(1640)&\n              &*xx(227)-jvs(1857)*xx(228)-jvs(1973)*xx(229)-jvs(2054)*xx(230)-jvs(2229)*xx(232)\n  xx(203) = xx(203)-jvs(1259)*xx(209)-jvs(1639)*xx(227)-jvs(1856)*xx(228)-jvs(1972)*xx(229)-jvs(2053)*xx(230)-jvs(2100)&\n              &*xx(231)-jvs(2228)*xx(232)\n  xx(202) = xx(202)-jvs(1206)*xx(206)-jvs(1258)*xx(209)-jvs(1299)*xx(211)-jvs(1361)*xx(215)-jvs(1391)*xx(217)-jvs(1442)&\n              &*xx(219)-jvs(1560)*xx(225)-jvs(1638)*xx(227)-jvs(1855)*xx(228)-jvs(1971)*xx(229)-jvs(2052)*xx(230)-jvs(2227)&\n              &*xx(232)\n  xx(201) = xx(201)-jvs(1205)*xx(206)-jvs(1441)*xx(219)-jvs(1516)*xx(222)-jvs(1637)*xx(227)-jvs(1854)*xx(228)-jvs(1970)&\n              &*xx(229)-jvs(2051)*xx(230)-jvs(2226)*xx(232)\n  xx(200) = xx(200)-jvs(1204)*xx(206)-jvs(1257)*xx(209)-jvs(1298)*xx(211)-jvs(1360)*xx(215)-jvs(1390)*xx(217)-jvs(1440)&\n              &*xx(219)-jvs(1559)*xx(225)-jvs(1636)*xx(227)-jvs(1853)*xx(228)-jvs(1969)*xx(229)-jvs(2050)*xx(230)-jvs(2225)&\n              &*xx(232)\n  xx(199) = xx(199)-jvs(1203)*xx(206)-jvs(1635)*xx(227)-jvs(1852)*xx(228)-jvs(1968)*xx(229)-jvs(2049)*xx(230)-jvs(2224)&\n              &*xx(232)\n  xx(198) = xx(198)-jvs(1129)*xx(201)-jvs(1202)*xx(206)-jvs(1439)*xx(219)-jvs(1634)*xx(227)-jvs(1851)*xx(228)-jvs(1967)&\n              &*xx(229)-jvs(2048)*xx(230)-jvs(2223)*xx(232)\n  xx(197) = xx(197)-jvs(1201)*xx(206)-jvs(1438)*xx(219)-jvs(1633)*xx(227)-jvs(1850)*xx(228)-jvs(1966)*xx(229)-jvs(2047)&\n              &*xx(230)-jvs(2222)*xx(232)\n  xx(196) = xx(196)-jvs(1200)*xx(206)-jvs(1632)*xx(227)-jvs(1849)*xx(228)-jvs(1965)*xx(229)-jvs(2046)*xx(230)-jvs(2221)&\n              &*xx(232)\n  xx(195) = xx(195)-jvs(1475)*xx(220)-jvs(1527)*xx(223)-jvs(1582)*xx(226)-jvs(1631)*xx(227)-jvs(1848)*xx(228)-jvs(1964)&\n              &*xx(229)-jvs(2045)*xx(230)-jvs(2220)*xx(232)\n  xx(194) = xx(194)-jvs(1065)*xx(196)-jvs(1086)*xx(198)-jvs(1437)*xx(219)-jvs(1515)*xx(222)-jvs(1847)*xx(228)-jvs(1963)&\n              &*xx(229)-jvs(2044)*xx(230)-jvs(2219)*xx(232)\n  xx(193) = xx(193)-jvs(1436)*xx(219)-jvs(1846)*xx(228)-jvs(2218)*xx(232)\n  xx(192) = xx(192)-jvs(1027)*xx(193)-jvs(1108)*xx(199)-jvs(1256)*xx(209)-jvs(1297)*xx(211)-jvs(1359)*xx(215)-jvs(1558)&\n              &*xx(225)-jvs(1630)*xx(227)-jvs(1845)*xx(228)-jvs(1962)*xx(229)-jvs(2043)*xx(230)-jvs(2217)*xx(232)\n  xx(191) = xx(191)-jvs(1199)*xx(206)-jvs(1629)*xx(227)-jvs(1844)*xx(228)-jvs(1961)*xx(229)-jvs(2042)*xx(230)-jvs(2216)&\n              &*xx(232)\n  xx(190) = xx(190)-jvs(1198)*xx(206)-jvs(1435)*xx(219)-jvs(1474)*xx(220)-jvs(1628)*xx(227)-jvs(1843)*xx(228)-jvs(1960)&\n              &*xx(229)-jvs(2041)*xx(230)-jvs(2215)*xx(232)\n  xx(189) = xx(189)-jvs(1842)*xx(228)-jvs(2214)*xx(232)\n  xx(188) = xx(188)-jvs(962)*xx(189)-jvs(1026)*xx(193)-jvs(1197)*xx(206)-jvs(1434)*xx(219)-jvs(1627)*xx(227)-jvs(1841)&\n              &*xx(228)-jvs(1959)*xx(229)-jvs(2040)*xx(230)-jvs(2213)*xx(232)\n  xx(187) = xx(187)-jvs(1296)*xx(211)-jvs(1433)*xx(219)-jvs(1473)*xx(220)-jvs(1840)*xx(228)\n  xx(186) = xx(186)-jvs(921)*xx(187)-jvs(1163)*xx(205)-jvs(1497)*xx(221)-jvs(1626)*xx(227)-jvs(1839)*xx(228)-jvs(1958)&\n              &*xx(229)-jvs(2039)*xx(230)-jvs(2212)*xx(232)\n  xx(185) = xx(185)-jvs(1838)*xx(228)-jvs(1957)*xx(229)-jvs(2038)*xx(230)\n  xx(184) = xx(184)-jvs(920)*xx(187)-jvs(1162)*xx(205)-jvs(1196)*xx(206)-jvs(1344)*xx(214)-jvs(1625)*xx(227)-jvs(1837)&\n              &*xx(228)-jvs(1956)*xx(229)-jvs(2037)*xx(230)-jvs(2211)*xx(232)\n  xx(183) = xx(183)-jvs(961)*xx(189)-jvs(1472)*xx(220)-jvs(1624)*xx(227)-jvs(1836)*xx(228)-jvs(1955)*xx(229)-jvs(2036)&\n              &*xx(230)-jvs(2210)*xx(232)\n  xx(182) = xx(182)-jvs(1107)*xx(199)-jvs(1295)*xx(211)-jvs(1358)*xx(215)-jvs(1835)*xx(228)-jvs(2209)*xx(232)\n  xx(181) = xx(181)-jvs(848)*xx(182)-jvs(960)*xx(189)-jvs(1025)*xx(193)-jvs(1106)*xx(199)-jvs(1255)*xx(209)-jvs(1623)&\n              &*xx(227)-jvs(1834)*xx(228)-jvs(1954)*xx(229)-jvs(2035)*xx(230)-jvs(2208)*xx(232)\n  xx(180) = xx(180)-jvs(1471)*xx(220)-jvs(1526)*xx(223)-jvs(1581)*xx(226)-jvs(1833)*xx(228)-jvs(2207)*xx(232)\n  xx(179) = xx(179)-jvs(1024)*xx(193)-jvs(1195)*xx(206)-jvs(1432)*xx(219)-jvs(1832)*xx(228)-jvs(2206)*xx(232)\n  xx(178) = xx(178)-jvs(1045)*xx(194)-jvs(1128)*xx(201)-jvs(1194)*xx(206)-jvs(1622)*xx(227)-jvs(1831)*xx(228)-jvs(1953)&\n              &*xx(229)-jvs(2034)*xx(230)-jvs(2205)*xx(232)\n  xx(177) = xx(177)-jvs(1225)*xx(207)-jvs(1357)*xx(215)-jvs(1375)*xx(216)-jvs(1431)*xx(219)-jvs(1541)*xx(224)-jvs(1621)&\n              &*xx(227)-jvs(1830)*xx(228)-jvs(1952)*xx(229)-jvs(2033)*xx(230)-jvs(2204)*xx(232)\n  xx(176) = xx(176)-jvs(1235)*xx(208)-jvs(1254)*xx(209)-jvs(1331)*xx(213)-jvs(1430)*xx(219)-jvs(1620)*xx(227)-jvs(1829)&\n              &*xx(228)-jvs(1951)*xx(229)-jvs(2032)*xx(230)-jvs(2099)*xx(231)-jvs(2203)*xx(232)\n  xx(175) = xx(175)-jvs(805)*xx(178)-jvs(935)*xx(188)-jvs(959)*xx(189)-jvs(1023)*xx(193)-jvs(1127)*xx(201)-jvs(1193)&\n              &*xx(206)-jvs(1429)*xx(219)-jvs(1514)*xx(222)-jvs(1619)*xx(227)-jvs(1828)*xx(228)-jvs(1950)*xx(229)-jvs(2031)&\n              &*xx(230)-jvs(2202)*xx(232)\n  xx(174) = xx(174)-jvs(1022)*xx(193)-jvs(1105)*xx(199)-jvs(1356)*xx(215)-jvs(1525)*xx(223)-jvs(1618)*xx(227)-jvs(1827)&\n              &*xx(228)-jvs(1949)*xx(229)-jvs(2030)*xx(230)-jvs(2201)*xx(232)\n  xx(173) = xx(173)-jvs(1513)*xx(222)-jvs(1617)*xx(227)-jvs(1826)*xx(228)-jvs(1948)*xx(229)-jvs(2029)*xx(230)-jvs(2200)&\n              &*xx(232)\n  xx(172) = xx(172)-jvs(778)*xx(173)-jvs(1294)*xx(211)-jvs(1512)*xx(222)-jvs(1616)*xx(227)-jvs(1825)*xx(228)-jvs(1947)&\n              &*xx(229)-jvs(2199)*xx(232)\n  xx(171) = xx(171)-jvs(777)*xx(173)-jvs(1293)*xx(211)-jvs(1511)*xx(222)-jvs(1615)*xx(227)-jvs(1824)*xx(228)-jvs(1946)&\n              &*xx(229)-jvs(2198)*xx(232)\n  xx(170) = xx(170)-jvs(828)*xx(180)-jvs(1580)*xx(226)-jvs(1614)*xx(227)-jvs(1823)*xx(228)-jvs(1945)*xx(229)-jvs(2028)&\n              &*xx(230)-jvs(2197)*xx(232)\n  xx(169) = xx(169)-jvs(1470)*xx(220)-jvs(1557)*xx(225)-jvs(1822)*xx(228)-jvs(2098)*xx(231)-jvs(2196)*xx(232)\n  xx(168) = xx(168)-jvs(1192)*xx(206)-jvs(1343)*xx(214)-jvs(1613)*xx(227)-jvs(1821)*xx(228)-jvs(1944)*xx(229)-jvs(2027)&\n              &*xx(230)-jvs(2195)*xx(232)\n  xx(167) = xx(167)-jvs(1104)*xx(199)-jvs(1253)*xx(209)-jvs(1556)*xx(225)-jvs(1820)*xx(228)-jvs(2194)*xx(232)\n  xx(166) = xx(166)-jvs(1191)*xx(206)-jvs(1612)*xx(227)-jvs(1819)*xx(228)-jvs(1943)*xx(229)-jvs(2026)*xx(230)-jvs(2097)&\n              &*xx(231)-jvs(2193)*xx(232)\n  xx(165) = xx(165)-jvs(885)*xx(185)-jvs(1496)*xx(221)-jvs(1818)*xx(228)-jvs(2025)*xx(230)-jvs(2192)*xx(232)\n  xx(164) = xx(164)-jvs(709)*xx(165)-jvs(902)*xx(186)-jvs(919)*xx(187)-jvs(1053)*xx(195)-jvs(1317)*xx(212)-jvs(1510)&\n              &*xx(222)-jvs(1611)*xx(227)-jvs(1817)*xx(228)-jvs(1942)*xx(229)-jvs(2024)*xx(230)-jvs(2191)*xx(232)\n  xx(163) = xx(163)-jvs(958)*xx(189)-jvs(1103)*xx(199)-jvs(1252)*xx(209)-jvs(1610)*xx(227)-jvs(1816)*xx(228)-jvs(1941)&\n              &*xx(229)-jvs(2023)*xx(230)-jvs(2190)*xx(232)\n  xx(162) = xx(162)-jvs(957)*xx(189)-jvs(1292)*xx(211)-jvs(1330)*xx(213)-jvs(1509)*xx(222)-jvs(1609)*xx(227)-jvs(1815)&\n              &*xx(228)-jvs(1940)*xx(229)-jvs(2022)*xx(230)-jvs(2096)*xx(231)-jvs(2189)*xx(232)\n  xx(161) = xx(161)-jvs(1021)*xx(193)-jvs(1190)*xx(206)-jvs(1428)*xx(219)-jvs(1814)*xx(228)-jvs(1939)*xx(229)\n  xx(160) = xx(160)-jvs(860)*xx(183)-jvs(884)*xx(185)-jvs(918)*xx(187)-jvs(956)*xx(189)-jvs(997)*xx(191)-jvs(1389)&\n              &*xx(217)-jvs(1813)*xx(228)-jvs(1938)*xx(229)-jvs(2021)*xx(230)-jvs(2188)*xx(232)\n  xx(159) = xx(159)-jvs(736)*xx(168)-jvs(869)*xx(184)-jvs(955)*xx(189)-jvs(1189)*xx(206)-jvs(1272)*xx(210)-jvs(1342)&\n              &*xx(214)-jvs(1508)*xx(222)-jvs(1812)*xx(228)-jvs(2020)*xx(230)-jvs(2187)*xx(232)\n  xx(158) = xx(158)-jvs(859)*xx(183)-jvs(883)*xx(185)-jvs(954)*xx(189)-jvs(1427)*xx(219)-jvs(1811)*xx(228)-jvs(2019)&\n              &*xx(230)\n  xx(157) = xx(157)-jvs(1155)*xx(204)-jvs(1608)*xx(227)-jvs(1810)*xx(228)-jvs(1937)*xx(229)-jvs(2018)*xx(230)-jvs(2186)&\n              &*xx(232)\n  xx(156) = xx(156)-jvs(917)*xx(187)-jvs(1388)*xx(217)-jvs(1607)*xx(227)-jvs(1809)*xx(228)-jvs(1936)*xx(229)-jvs(2017)&\n              &*xx(230)-jvs(2185)*xx(232)\n  xx(155) = xx(155)-jvs(726)*xx(167)-jvs(1020)*xx(193)-jvs(1606)*xx(227)-jvs(1808)*xx(228)-jvs(1935)*xx(229)-jvs(2016)&\n              &*xx(230)-jvs(2184)*xx(232)\n  xx(154) = xx(154)-jvs(1102)*xx(199)-jvs(1251)*xx(209)-jvs(1807)*xx(228)-jvs(2183)*xx(232)\n  xx(153) = xx(153)-jvs(953)*xx(189)-jvs(1101)*xx(199)-jvs(1188)*xx(206)-jvs(1507)*xx(222)-jvs(1605)*xx(227)-jvs(1806)&\n              &*xx(228)-jvs(1934)*xx(229)-jvs(2015)*xx(230)-jvs(2182)*xx(232)\n  xx(152) = xx(152)-jvs(1100)*xx(199)-jvs(1355)*xx(215)-jvs(1524)*xx(223)-jvs(1805)*xx(228)-jvs(2181)*xx(232)\n  xx(151) = xx(151)-jvs(683)*xx(161)-jvs(934)*xx(188)-jvs(952)*xx(189)-jvs(1804)*xx(228)-jvs(2180)*xx(232)\n  xx(150) = xx(150)-jvs(951)*xx(189)-jvs(1803)*xx(228)-jvs(2179)*xx(232)\n  xx(149) = xx(149)-jvs(1234)*xx(208)-jvs(1250)*xx(209)-jvs(1426)*xx(219)-jvs(1802)*xx(228)\n  xx(148) = xx(148)-jvs(1387)*xx(217)-jvs(1425)*xx(219)-jvs(1801)*xx(228)\n  xx(147) = xx(147)-jvs(1187)*xx(206)-jvs(1604)*xx(227)-jvs(1800)*xx(228)-jvs(1933)*xx(229)-jvs(2014)*xx(230)-jvs(2178)&\n              &*xx(232)\n  xx(146) = xx(146)-jvs(708)*xx(165)-jvs(1603)*xx(227)-jvs(1799)*xx(228)-jvs(1932)*xx(229)-jvs(2013)*xx(230)-jvs(2177)&\n              &*xx(232)\n  xx(145) = xx(145)-jvs(1602)*xx(227)-jvs(1798)*xx(228)-jvs(1931)*xx(229)-jvs(2012)*xx(230)-jvs(2095)*xx(231)-jvs(2176)&\n              &*xx(232)\n  xx(144) = xx(144)-jvs(613)*xx(151)-jvs(1601)*xx(227)-jvs(1797)*xx(228)-jvs(1930)*xx(229)-jvs(2011)*xx(230)-jvs(2175)&\n              &*xx(232)\n  xx(143) = xx(143)-jvs(717)*xx(166)-jvs(950)*xx(189)-jvs(1186)*xx(206)-jvs(1291)*xx(211)-jvs(1386)*xx(217)-jvs(1506)&\n              &*xx(222)-jvs(1796)*xx(228)-jvs(2010)*xx(230)\n  xx(142) = xx(142)-jvs(768)*xx(172)-jvs(1505)*xx(222)-jvs(1600)*xx(227)-jvs(1929)*xx(229)\n  xx(141) = xx(141)-jvs(725)*xx(167)-jvs(1019)*xx(193)-jvs(1795)*xx(228)-jvs(1928)*xx(229)-jvs(2174)*xx(232)\n  xx(140) = xx(140)-jvs(579)*xx(148)-jvs(1424)*xx(219)-jvs(1794)*xx(228)-jvs(2094)*xx(231)-jvs(2173)*xx(232)\n  xx(139) = xx(139)-jvs(1354)*xx(215)-jvs(1374)*xx(216)-jvs(1423)*xx(219)-jvs(1793)*xx(228)\n  xx(138) = xx(138)-jvs(847)*xx(182)-jvs(1018)*xx(193)-jvs(1792)*xx(228)-jvs(1927)*xx(229)-jvs(2172)*xx(232)\n  xx(137) = xx(137)-jvs(745)*xx(169)-jvs(1579)*xx(226)-jvs(1791)*xx(228)-jvs(2093)*xx(231)-jvs(2171)*xx(232)\n  xx(136) = xx(136)-jvs(590)*xx(149)-jvs(1249)*xx(209)-jvs(1790)*xx(228)-jvs(2092)*xx(231)-jvs(2170)*xx(232)\n  xx(135) = xx(135)-jvs(858)*xx(183)-jvs(882)*xx(185)-jvs(949)*xx(189)-jvs(1789)*xx(228)-jvs(2009)*xx(230)-jvs(2169)&\n              &*xx(232)\n  xx(134) = xx(134)-jvs(589)*xx(149)-jvs(1248)*xx(209)-jvs(1788)*xx(228)-jvs(1926)*xx(229)-jvs(2091)*xx(231)-jvs(2168)&\n              &*xx(232)\n  xx(133) = xx(133)-jvs(724)*xx(167)-jvs(1017)*xx(193)-jvs(1787)*xx(228)-jvs(2167)*xx(232)\n  xx(132) = xx(132)-jvs(1341)*xx(214)-jvs(1786)*xx(228)\n  xx(131) = xx(131)-jvs(1353)*xx(215)-jvs(1409)*xx(218)-jvs(1469)*xx(220)-jvs(1785)*xx(228)\n  xx(130) = xx(130)-jvs(846)*xx(182)-jvs(1016)*xx(193)-jvs(1784)*xx(228)-jvs(2166)*xx(232)\n  xx(129) = xx(129)-jvs(827)*xx(180)-jvs(1578)*xx(226)-jvs(1783)*xx(228)-jvs(2165)*xx(232)\n  xx(128) = xx(128)-jvs(621)*xx(152)-jvs(1015)*xx(193)-jvs(1782)*xx(228)-jvs(1925)*xx(229)-jvs(2164)*xx(232)\n  xx(127) = xx(127)-jvs(776)*xx(173)-jvs(1781)*xx(228)-jvs(2163)*xx(232)\n  xx(126) = xx(126)-jvs(948)*xx(189)-jvs(1185)*xx(206)-jvs(1422)*xx(219)-jvs(1780)*xx(228)-jvs(1924)*xx(229)\n  xx(125) = xx(125)-jvs(488)*xx(132)-jvs(735)*xx(168)-jvs(1184)*xx(206)-jvs(1779)*xx(228)-jvs(1923)*xx(229)\n  xx(124) = xx(124)-jvs(487)*xx(132)-jvs(868)*xx(184)-jvs(1183)*xx(206)-jvs(1778)*xx(228)-jvs(2162)*xx(232)\n  xx(123) = xx(123)-jvs(667)*xx(158)-jvs(987)*xx(190)-jvs(1182)*xx(206)-jvs(1777)*xx(228)-jvs(2161)*xx(232)\n  xx(122) = xx(122)-jvs(826)*xx(180)-jvs(916)*xx(187)-jvs(1495)*xx(221)-jvs(1776)*xx(228)-jvs(1922)*xx(229)\n  xx(121) = xx(121)-jvs(825)*xx(180)-jvs(881)*xx(185)-jvs(1775)*xx(228)-jvs(1921)*xx(229)-jvs(2008)*xx(230)\n  xx(120) = xx(120)-jvs(602)*xx(150)-jvs(845)*xx(182)-jvs(1774)*xx(228)-jvs(1920)*xx(229)-jvs(2160)*xx(232)\n  xx(119) = xx(119)-jvs(744)*xx(169)-jvs(880)*xx(185)-jvs(1773)*xx(228)-jvs(1919)*xx(229)-jvs(2007)*xx(230)\n  xx(118) = xx(118)-jvs(601)*xx(150)-jvs(633)*xx(154)-jvs(1772)*xx(228)-jvs(1918)*xx(229)-jvs(2159)*xx(232)\n  xx(117) = xx(117)-jvs(814)*xx(179)-jvs(1181)*xx(206)-jvs(1771)*xx(228)-jvs(2090)*xx(231)-jvs(2158)*xx(232)\n  xx(116) = xx(116)-jvs(813)*xx(179)-jvs(947)*xx(189)-jvs(1076)*xx(197)-jvs(1770)*xx(228)-jvs(1917)*xx(229)\n  xx(115) = xx(115)-jvs(1329)*xx(213)-jvs(1421)*xx(219)-jvs(1468)*xx(220)-jvs(1555)*xx(225)-jvs(1769)*xx(228)\n  xx(114) = xx(114)-jvs(1014)*xx(193)-jvs(1064)*xx(196)-jvs(1085)*xx(198)-jvs(1768)*xx(228)-jvs(2157)*xx(232)\n  xx(113) = xx(113)-jvs(1044)*xx(194)-jvs(1126)*xx(201)-jvs(1180)*xx(206)-jvs(1767)*xx(228)-jvs(2156)*xx(232)\n  xx(112) = xx(112)-jvs(946)*xx(189)-jvs(996)*xx(191)-jvs(1179)*xx(206)-jvs(1766)*xx(228)-jvs(1916)*xx(229)\n  xx(111) = xx(111)-jvs(945)*xx(189)-jvs(1144)*xx(203)-jvs(1765)*xx(228)-jvs(1915)*xx(229)-jvs(2089)*xx(231)\n  xx(110) = xx(110)-jvs(547)*xx(142)-jvs(1178)*xx(206)-jvs(1599)*xx(227)-jvs(1914)*xx(229)\n  xx(109) = xx(109)-jvs(761)*xx(171)-jvs(879)*xx(185)-jvs(1764)*xx(228)-jvs(2006)*xx(230)-jvs(2155)*xx(232)\n  xx(108) = xx(108)-jvs(384)*xx(109)-jvs(388)*xx(110)-jvs(878)*xx(185)-jvs(1290)*xx(211)-jvs(1763)*xx(228)-jvs(2005)&\n              &*xx(230)-jvs(2154)*xx(232)\n  xx(107) = xx(107)-jvs(1271)*xx(210)-jvs(1762)*xx(228)\n  xx(106) = xx(106)-jvs(1761)*xx(228)-jvs(2153)*xx(232)\n  xx(105) = xx(105)-jvs(1063)*xx(196)-jvs(1177)*xx(206)-jvs(1760)*xx(228)-jvs(2152)*xx(232)\n  xx(104) = xx(104)-jvs(620)*xx(152)-jvs(1013)*xx(193)-jvs(1759)*xx(228)-jvs(2151)*xx(232)\n  xx(103) = xx(103)-jvs(480)*xx(131)-jvs(754)*xx(170)-jvs(1758)*xx(228)-jvs(1913)*xx(229)\n  xx(102) = xx(102)-jvs(743)*xx(169)-jvs(1757)*xx(228)-jvs(1912)*xx(229)\n  xx(101) = xx(101)-jvs(1176)*xx(206)-jvs(1289)*xx(211)-jvs(1756)*xx(228)-jvs(2150)*xx(232)\n  xx(100) = xx(100)-jvs(915)*xx(187)-jvs(1328)*xx(213)-jvs(1554)*xx(225)-jvs(1755)*xx(228)\n  xx(99) = xx(99)-jvs(914)*xx(187)-jvs(1327)*xx(213)-jvs(1754)*xx(228)-jvs(1911)*xx(229)\n  xx(98) = xx(98)-jvs(1577)*xx(226)-jvs(1753)*xx(228)-jvs(1910)*xx(229)-jvs(2149)*xx(232)\n  xx(97) = xx(97)-jvs(371)*xx(107)-jvs(1752)*xx(228)-jvs(1909)*xx(229)-jvs(2148)*xx(232)\n  xx(96) = xx(96)-jvs(486)*xx(132)-jvs(1175)*xx(206)-jvs(1751)*xx(228)-jvs(1908)*xx(229)\n  xx(95) = xx(95)-jvs(913)*xx(187)-jvs(1540)*xx(224)-jvs(1750)*xx(228)-jvs(1907)*xx(229)\n  xx(94) = xx(94)-jvs(857)*xx(183)-jvs(944)*xx(189)-jvs(1467)*xx(220)-jvs(1749)*xx(228)\n  xx(93) = xx(93)-jvs(912)*xx(187)-jvs(986)*xx(190)-jvs(1154)*xx(204)-jvs(1748)*xx(228)\n  xx(92) = xx(92)-jvs(1747)*xx(228)-jvs(1906)*xx(229)-jvs(2088)*xx(231)-jvs(2147)*xx(232)\n  xx(91) = xx(91)-jvs(600)*xx(150)-jvs(844)*xx(182)-jvs(1746)*xx(228)-jvs(2146)*xx(232)\n  xx(90) = xx(90)-jvs(1174)*xx(206)-jvs(1745)*xx(228)-jvs(1905)*xx(229)-jvs(2145)*xx(232)\n  xx(89) = xx(89)-jvs(599)*xx(150)-jvs(632)*xx(154)-jvs(1744)*xx(228)-jvs(2144)*xx(232)\n  xx(88) = xx(88)-jvs(682)*xx(161)-jvs(943)*xx(189)-jvs(1743)*xx(228)-jvs(2143)*xx(232)\n  xx(87) = xx(87)-jvs(1084)*xx(198)-jvs(1125)*xx(201)-jvs(1742)*xx(228)-jvs(1904)*xx(229)\n  xx(86) = xx(86)-jvs(1062)*xx(196)-jvs(1075)*xx(197)-jvs(1420)*xx(219)-jvs(1741)*xx(228)\n  xx(85) = xx(85)-jvs(911)*xx(187)-jvs(1740)*xx(228)-jvs(1903)*xx(229)-jvs(2142)*xx(232)\n  xx(84) = xx(84)-jvs(995)*xx(191)-jvs(1173)*xx(206)-jvs(1739)*xx(228)-jvs(2141)*xx(232)\n  xx(83) = xx(83)-jvs(1172)*xx(206)-jvs(1738)*xx(228)-jvs(1902)*xx(229)-jvs(2087)*xx(231)\n  xx(82) = xx(82)-jvs(536)*xx(140)-jvs(1737)*xx(228)-jvs(2086)*xx(231)-jvs(2140)*xx(232)\n  xx(81) = xx(81)-jvs(1224)*xx(207)-jvs(1466)*xx(220)-jvs(1523)*xx(223)-jvs(1736)*xx(228)\n  xx(80) = xx(80)-jvs(528)*xx(139)-jvs(1539)*xx(224)-jvs(1735)*xx(228)\n  xx(79) = xx(79)-jvs(527)*xx(139)-jvs(1223)*xx(207)-jvs(1734)*xx(228)-jvs(1901)*xx(229)\n  xx(78) = xx(78)-jvs(824)*xx(180)-jvs(1733)*xx(228)-jvs(1900)*xx(229)\n  xx(77) = xx(77)-jvs(507)*xx(135)-jvs(994)*xx(191)-jvs(1385)*xx(217)-jvs(1732)*xx(228)-jvs(2139)*xx(232)\n  xx(76) = xx(76)-jvs(1099)*xx(199)-jvs(1731)*xx(228)\n  xx(75) = xx(75)-jvs(910)*xx(187)-jvs(1730)*xx(228)-jvs(2138)*xx(232)\n  xx(74) = xx(74)-jvs(1729)*xx(228)-jvs(1899)*xx(229)-jvs(2137)*xx(232)\n  xx(73) = xx(73)-jvs(1728)*xx(228)-jvs(2085)*xx(231)-jvs(2136)*xx(232)\n  xx(72) = xx(72)-jvs(370)*xx(107)-jvs(1727)*xx(228)-jvs(2135)*xx(232)\n  xx(71) = xx(71)-jvs(660)*xx(157)-jvs(1153)*xx(204)-jvs(1726)*xx(228)\n  xx(70) = xx(70)-jvs(659)*xx(157)-jvs(1316)*xx(212)-jvs(1725)*xx(228)\n  xx(69) = xx(69)-jvs(707)*xx(165)-jvs(1724)*xx(228)-jvs(1898)*xx(229)\n  xx(68) = xx(68)-jvs(1315)*xx(212)-jvs(1494)*xx(221)-jvs(1723)*xx(228)\n  xx(67) = xx(67)-jvs(706)*xx(165)-jvs(1722)*xx(228)-jvs(2134)*xx(232)\n  xx(66) = xx(66)-jvs(705)*xx(165)-jvs(1721)*xx(228)-jvs(1897)*xx(229)\n  xx(65) = xx(65)-jvs(1061)*xx(196)-jvs(1720)*xx(228)-jvs(1896)*xx(229)\n  xx(64) = xx(64)-jvs(612)*xx(151)-jvs(1719)*xx(228)-jvs(2133)*xx(232)\n  xx(63) = xx(63)-jvs(1043)*xx(194)-jvs(1718)*xx(228)-jvs(1895)*xx(229)\n  xx(62) = xx(62)-jvs(1143)*xx(203)-jvs(1247)*xx(209)-jvs(1717)*xx(228)\n  xx(61) = xx(61)-jvs(1716)*xx(228)-jvs(1894)*xx(229)-jvs(2084)*xx(231)\n  xx(60) = xx(60)-jvs(1171)*xx(206)-jvs(1715)*xx(228)-jvs(1893)*xx(229)\n  xx(59) = xx(59)-jvs(578)*xx(148)-jvs(1352)*xx(215)-jvs(1714)*xx(228)\n  xx(58) = xx(58)-jvs(1012)*xx(193)-jvs(1246)*xx(209)-jvs(1713)*xx(228)\n  xx(57) = xx(57)-jvs(479)*xx(131)-jvs(1052)*xx(195)-jvs(1712)*xx(228)\n  xx(56) = xx(56)-jvs(1576)*xx(226)-jvs(1711)*xx(228)-jvs(2132)*xx(232)\n  xx(55) = xx(55)-jvs(535)*xx(140)-jvs(1710)*xx(228)-jvs(1892)*xx(229)\n  xx(54) = xx(54)-jvs(812)*xx(179)-jvs(1709)*xx(228)-jvs(1891)*xx(229)\n  xx(53) = xx(53)-jvs(1288)*xx(211)-jvs(1419)*xx(219)-jvs(1708)*xx(228)\n  xx(52) = xx(52)-jvs(1287)*xx(211)-jvs(2131)*xx(232)\n  xx(51) = xx(51)-jvs(1286)*xx(211)-jvs(1707)*xx(228)\n  xx(50) = xx(50)-jvs(1384)*xx(217)-jvs(1575)*xx(226)-jvs(1706)*xx(228)-jvs(2130)*xx(232)\n  xx(49) = xx(49)-jvs(434)*xx(121)-jvs(1890)*xx(229)\n  xx(48) = xx(48)-jvs(128)*xx(49)-jvs(877)*xx(185)-jvs(1705)*xx(228)-jvs(2004)*xx(230)\n  xx(47) = xx(47)-jvs(425)*xx(119)-jvs(1889)*xx(229)\n  xx(46) = xx(46)-jvs(119)*xx(47)-jvs(876)*xx(185)-jvs(1704)*xx(228)-jvs(2003)*xx(230)\n  xx(45) = xx(45)-jvs(1703)*xx(228)-jvs(2129)*xx(232)\n  xx(44) = xx(44)-jvs(1326)*xx(213)-jvs(1418)*xx(219)-jvs(1465)*xx(220)-jvs(1702)*xx(228)\n  xx(43) = xx(43)-jvs(909)*xx(187)-jvs(1383)*xx(217)-jvs(1701)*xx(228)-jvs(2128)*xx(232)\n  xx(42) = xx(42)-jvs(1098)*xx(199)-jvs(1700)*xx(228)-jvs(2083)*xx(231)-jvs(2127)*xx(232)\n  xx(41) = xx(41)-jvs(383)*xx(109)-jvs(1285)*xx(211)-jvs(1699)*xx(228)\n  xx(40) = xx(40)-jvs(1598)*xx(227)-jvs(1698)*xx(228)-jvs(1888)*xx(229)\n  xx(39) = xx(39)-jvs(1314)*xx(212)-jvs(1697)*xx(228)\n  xx(38) = xx(38)-jvs(1325)*xx(213)-jvs(1696)*xx(228)\n  xx(37) = xx(37)-jvs(1222)*xx(207)-jvs(1464)*xx(220)-jvs(1695)*xx(228)\n  xx(36) = xx(36)-jvs(1170)*xx(206)-jvs(1694)*xx(228)-jvs(2126)*xx(232)\n  xx(35) = xx(35)-jvs(109)*xx(45)-jvs(598)*xx(150)-jvs(942)*xx(189)-jvs(1693)*xx(228)-jvs(2125)*xx(232)\n  xx(34) = xx(34)-jvs(1284)*xx(211)-jvs(1887)*xx(229)\n  xx(33) = xx(33)-jvs(1538)*xx(224)-jvs(1692)*xx(228)\n  xx(32) = xx(32)-jvs(1886)*xx(229)-jvs(2002)*xx(230)\n  xx(31) = xx(31)-jvs(1233)*xx(208)-jvs(1245)*xx(209)-jvs(1417)*xx(219)-jvs(1691)*xx(228)\n  xx(30) = xx(30)-jvs(124)*xx(48)-jvs(838)*xx(181)-jvs(1690)*xx(228)-jvs(2124)*xx(232)\n  xx(29) = xx(29)-jvs(115)*xx(46)-jvs(695)*xx(163)-jvs(1689)*xx(228)-jvs(2123)*xx(232)\n  xx(28) = xx(28)-jvs(647)*xx(155)-jvs(1119)*xx(200)-jvs(1688)*xx(228)\n  xx(27) = xx(27)-jvs(646)*xx(155)-jvs(1118)*xx(200)-jvs(1687)*xx(228)\n  xx(26) = xx(26)-jvs(1006)*xx(192)-jvs(1137)*xx(202)-jvs(1686)*xx(228)\n  xx(25) = xx(25)-jvs(653)*xx(156)-jvs(1351)*xx(215)-jvs(1685)*xx(228)\n  xx(24) = xx(24)-jvs(785)*xx(174)-jvs(1684)*xx(228)\n  xx(23) = xx(23)-jvs(645)*xx(155)-jvs(1683)*xx(228)\n  xx(22) = xx(22)-jvs(644)*xx(155)-jvs(1682)*xx(228)\n  xx(21) = xx(21)-jvs(643)*xx(155)-jvs(1681)*xx(228)\n  xx(20) = xx(20)-jvs(642)*xx(155)-jvs(1680)*xx(228)\n  xx(19) = xx(19)-jvs(1283)*xx(211)-jvs(1679)*xx(228)\n  xx(18) = xx(18)-jvs(1097)*xx(199)-jvs(1678)*xx(228)\n  xx(17) = xx(17)-jvs(1096)*xx(199)-jvs(1677)*xx(228)\n  xx(16) = xx(16)-jvs(1095)*xx(199)-jvs(1676)*xx(228)\n  xx(15) = xx(15)-jvs(1094)*xx(199)-jvs(1675)*xx(228)\n  xx(14) = xx(14)-jvs(1244)*xx(209)-jvs(1674)*xx(228)\n  xx(13) = xx(13)-jvs(1282)*xx(211)-jvs(1673)*xx(228)\n  xx(12) = xx(12)-jvs(1281)*xx(211)-jvs(1672)*xx(228)\n  xx(11) = xx(11)-jvs(1280)*xx(211)-jvs(1671)*xx(228)\n  xx(10) = xx(10)-jvs(1553)*xx(225)-jvs(1670)*xx(228)\n  xx(9) = xx(9)-jvs(2122)*xx(232)\n  xx(8) = xx(8)-jvs(1243)*xx(209)-jvs(1669)*xx(228)\n  xx(7) = xx(7)-jvs(775)*xx(173)-jvs(1668)*xx(228)\n  xx(6) = xx(6)\n  xx(5) = xx(5)\n  xx(4) = xx(4)\n  xx(3) = xx(3)\n  xx(2) = xx(2)\n  xx(1) = xx(1)\n      \nend subroutine kppsolvetr\n"}
{"id": 1268, "subroutine": "subroutine static_init_model()\n\nreal(r8) :: x_loc\ninteger  :: i, iunit, io, dom_id\n\n! print module information to log file and stdout.\ncall register_module(source, revision, revdate)\n\n! read the namelist entry\ncall find_namelist_in_file(\"input.nml\", \"model_nml\", iunit)\nread(iunit, nml = model_nml, iostat = io)\ncall check_namelist_read(iunit, io, \"model_nml\")\n\n! model size is twice the number of state_vars\nmodel_size = 2 * num_state_vars\n\n! record the namelist values used for the run ...\nif (do_nml_file()) write(nmlfileunit, nml=model_nml)\nif (do_nml_term()) write(     *     , nml=model_nml)\n\n! create storage for locations\nallocate(state_loc(model_size))\n\n! define the locations of the model state variables\ndo i = 1, num_state_vars\n   x_loc = (i - 1.0_r8) / num_state_vars\n   state_loc(i) =  set_location(x_loc)\n   ! forcing is at same location as corresponding state variable\n   state_loc(i + num_state_vars) = set_location(x_loc)\nend do\n\n! the time_step in terms of a time type must also be initialized. need\n! to determine appropriate non-dimensionalization conversion for l96 from\n! shree khare.\ntime_step = set_time(time_step_seconds, time_step_days)\n\n! initialize the random sequence\ncall init_random_seq(random)\n\n! tell the dart i/o routines how large the model data is so they\n! can read/write it.\ndom_id = add_domain(model_size)\n\nend subroutine static_init_model\n"}
{"id": 1269, "subroutine": "subroutine comp_dt(x, dt)\n\nreal(r8), intent( in) ::  x(:)\nreal(r8), intent(out) :: dt(:)\n\ninteger :: j, jp1, jm1, jm2\n\ndo j = 1, num_state_vars\n   jp1 = j + 1\n   if(jp1 > num_state_vars) jp1 = 1\n   jm2 = j - 2\n   if(jm2 < 1) jm2 = num_state_vars + jm2\n   jm1 = j - 1\n   if(jm1 < 1) jm1 = num_state_vars\n   \n   dt(j) = (x(jp1) - x(jm2)) * x(jm1) - x(j) + x(num_state_vars + j)\nend do\n\n! time tendency for the forcing variables\ndt(num_state_vars + 1 : model_size) = 0.0_r8\n\n\n! try adding in some random spread; fixed across the instances (basically a global var)\nif(.not. reset_forcing) &\n   dt(num_state_vars + 1 : model_size) = &\n      random_gaussian(random, 0.0_r8, random_forcing_amplitude)\n\n! try adding in some random noise to each forcing variable, completely local\n!if(.not. reset_forcing) then\n!   do j = num_state_vars + 1, model_size\n!      dt(j) = random_gaussian(random, 0.0_r8, random_forcing_amplitude)\n!   end do\n!endif \n   \nend subroutine comp_dt\n"}
{"id": 1270, "subroutine": "subroutine adv_1step(x, time)\n\nreal(r8), intent(inout) :: x(:)\ntype(time_type), intent(in) :: time\n\nreal(r8), dimension(size(x)) :: x1, x2, x3, x4, dx, inter\n\n! if reset forcing is set, grab the value from the namelist and hold it fixed\nif(reset_forcing) x(num_state_vars + 1: model_size) = forcing\n\ncall comp_dt(x, dx)        !  compute the first intermediate step\nx1    = delta_t * dx\ninter = x + x1 / 2.0_r8\n\ncall comp_dt(inter, dx)    !  compute the second intermediate step\nx2    = delta_t * dx\ninter = x + x2 / 2.0_r8\n\ncall comp_dt(inter, dx)    !  compute the third intermediate step\nx3    = delta_t * dx\ninter = x + x3\n\ncall comp_dt(inter, dx)    !  compute fourth intermediate step\nx4 = delta_t * dx\n\n!  compute new value for x\n\nx = x + x1/6.0_r8 + x2/3.0_r8 + x3/3.0_r8 + x4/6.0_r8\n\nend subroutine adv_1step\n"}
{"id": 1271, "subroutine": "subroutine init_conditions(x)\n\nreal(r8), intent(out) :: x(:)\n\n! set state variable to the value of forcing with 1st element slightly perturbed\n! set forcing parameters to 8.0 if being assimilated\nx    = forcing\nx(1) = 1.001_r8 * forcing\n\nend subroutine init_conditions\n"}
{"id": 1272, "subroutine": "subroutine model_interpolate(state_handle, ens_size, location, itype, expected_val, istatus)\n\ntype(ensemble_type), intent(in) :: state_handle\ninteger,             intent(in) :: ens_size\ntype(location_type), intent(in) :: location\ninteger,             intent(in) :: itype\nreal(r8),           intent(out) :: expected_val(ens_size)\ninteger,            intent(out) :: istatus(ens_size)\n\ninteger(i8) :: lower_index, upper_index\ninteger :: i\nreal(r8) :: lctn, lctnfrac\n\n! all forward operators supported\nistatus(:) = 0\n\n! convert location to real\nlctn = get_location(location)\n! multiply by model size assuming domain is [0, 1] cyclic\nlctn = num_state_vars * lctn\n\nlower_index = int(lctn) + 1\nupper_index = lower_index + 1\nif(lower_index > num_state_vars) lower_index = lower_index - num_state_vars\nif(upper_index > num_state_vars) upper_index = upper_index - num_state_vars\n\nlctnfrac = lctn - int(lctn)\nexpected_val(:) = (1.0_r8 - lctnfrac) * get_state(lower_index, state_handle) + &\n                            lctnfrac  * get_state(upper_index, state_handle)\n\nif(1 == 1) return\n\n\n! all the stuff below is for strange forward operator tests; not currently used\n!-----------------------------------------------\n!!!expected_val = expected_val ** 2\n!!!if(1 == 1) return\n\n! temporarily add on an observation from the other side of the domain, too\nlower_index = lower_index + model_size / 2\nif(lower_index > model_size) lower_index = lower_index - model_size\nupper_index = upper_index + model_size / 2\nif(upper_index > model_size) upper_index = upper_index - model_size\nexpected_val(:) = expected_val(:) + &\n             lctnfrac  * get_state(lower_index, state_handle) + &\n   (1.0_r8 - lctnfrac) * get_state(upper_index, state_handle)\nif(1 == 1) return\n\n\n! next one does an average over a range of points\nexpected_val(:) = 0.0_r8\nlower_index = lower_index - 7\nupper_index = upper_index - 7\nif(lower_index < 1) lower_index = lower_index + model_size\nif(upper_index < 1) upper_index = upper_index + model_size\n\ndo i = 1, 15\n   if(lower_index > model_size) lower_index = lower_index - model_size\n   if(upper_index > model_size) upper_index = upper_index - model_size\n   expected_val(:) = expected_val(:) + &\n      (1.0_r8 - lctnfrac) * get_state(lower_index, state_handle) + &\n                lctnfrac  * get_state(upper_index, state_handle)\n   lower_index = lower_index + 1\n   upper_index = upper_index + 1\nend do\n\nend subroutine model_interpolate\n"}
{"id": 1273, "subroutine": "subroutine get_state_meta_data(index_in, location, var_type)\n\ninteger(i8),         intent(in)  :: index_in\ntype(location_type), intent(out) :: location\ninteger,             intent(out), optional :: var_type\n\nlocation = state_loc(index_in)\nif (present(var_type)) then\n   if(index_in <= num_state_vars) then\n      var_type = qty_state_variable    ! default variable type\n   else\n      ! if forcing parameter is being assimilated, it has this var_type\n      var_type = qty_1d_parameter\n   endif \nendif\n\nend subroutine get_state_meta_data\n"}
{"id": 1274, "subroutine": "subroutine nc_write_model_atts(ncid, domain_id)\n\ninteger, intent(in)  :: ncid\ninteger, intent(in) :: domain_id\n\ninteger :: msize\n\n! other parts of the dart system will write the state into the file\n! so this routine just needs to write any model-specific\n! attributes it wants to record.\n\nmsize = int(model_size, i4)\n\n! write global attributes\n\ncall nc_begin_define_mode(ncid)\n\ncall nc_add_global_creation_time(ncid)\n\ncall nc_add_global_attribute(ncid, \"model_source\", source )\ncall nc_add_global_attribute(ncid, \"model_revision\", revision )\ncall nc_add_global_attribute(ncid, \"model_revdate\", revdate )\n\ncall nc_add_global_attribute(ncid, \"model\", \"forced_lorenz_96\")\ncall nc_add_global_attribute(ncid, \"model_forcing\", forcing )\ncall nc_add_global_attribute(ncid, \"model_delta_t\", delta_t )\ncall nc_add_global_attribute(ncid, \"model_num_state_vars\", num_state_vars)\ncall nc_add_global_attribute(ncid, \"model_time_step_days\", time_step_days)\ncall nc_add_global_attribute(ncid, \"model_time_step_seconds\", time_step_seconds)\ncall nc_add_global_attribute(ncid, \"model_random_forcing_amplitude\", random_forcing_amplitude)\nif (reset_forcing) then\n   call nc_add_global_attribute(ncid, \"model_reset_forcing\", \"true\")\nelse\n   call nc_add_global_attribute(ncid, \"model_reset_forcing\", \"false\")\nendif\n\ncall nc_write_location_atts(ncid, msize)\ncall nc_end_define_mode(ncid)\ncall nc_write_location(ncid, state_loc, msize)\n\ncall nc_synchronize_file(ncid)\n\nend subroutine nc_write_model_atts\n"}
{"id": 1275, "subroutine": "subroutine iarnan(num,info)\n\n  implicit none\n  \n  ! input variables\n  integer, intent(in) :: num\n  integer, intent(inout) :: info\n  \n  ! initialize info\n  info = 0\n  \n  ! check self equality\n  if (num.ne.num) then\n    info = 1\n  end if\n\nend subroutine iarnan\n"}
{"id": 1276, "subroutine": "    subroutine f(s, s2)\n    character(len=:), allocatable, intent(in) :: s\n    character(:), allocatable, intent(in) :: s2\n    end subroutine\n"}
{"id": 1277, "subroutine": "    subroutine g(s, s2)\n    character(len=*), intent(in) :: s\n    character(*), intent(in) :: s2\n    end subroutine\n"}
{"id": 1278, "subroutine": "    subroutine h(s, s2)\n    character(len=80), intent(in) :: s\n    character(80), intent(in) :: s2\n    end subroutine\n"}
{"id": 1279, "subroutine": "    subroutine m(s, s2)\n    character(len=40+40), intent(in) :: s\n    character(100-20), intent(in) :: s2\n    end subroutine\n"}
{"id": 1280, "subroutine": "subroutine tem_turnof(a)\n   use typre\n   use mod_temperature\n   use mod_r1pelementallocation\n   use def_parame\n   implicit none\n   class(temperatureproblem) :: a\n   \n   integer(ip) :: ndime,npoin,nelem,tesgs_coun,ncsgs,pnode,pgaus,ielem,nboun,ncomp,ibody,nbody, sig_coun\n\n   !unknowns\n   call a%mesh%getndime(ndime)\n   call a%mesh%getnpoin(npoin)\n   call a%mesh%getnelem(nelem)\n   call a%mesh%getnboun(nboun)\n   call a%mesh%getnbody(nbody)\n   ncomp = a%ncomp\n   \n   !write tail for formatted files\n   if (a%mpirank == a%mpiroot) then\n      write(a%lun_outph,'(//,a,/)') '     * * * end of temperature run * * *'\n      write(a%lun_solve,'(//,a,/)') '     * * * end of temperature run * * *'\n   endif\n   \n   call a%memor%dealloc(npoin,a%ncomp,a%tempe,'tempe','tem_turnof')\n   \n   if (a%kfl_sourc == 2) then\n      call a%memor%dealloc(npoin,a%pointwisesource,'pointwisesource','tem_reabcs')\n   endif      \n   \n   if(a%kfl_trasg/=0) then\n      tesgs_coun = 0\n      ncsgs=2\n      \n      do ielem=1,nelem\n         call a%mesh%getelemarraysize(ielem,pnode,pgaus)\n         deallocate(a%tesgs(ielem)%a)\n         tesgs_coun = tesgs_coun + ncsgs*pgaus\n      end do\n      call a%memor%deallocobj(0,'tesgs%a','tem_memall',tesgs_coun*rp)\n      call a%memor%dealloc(nelem,a%tesgs,'tesgs','tem_memall')\n   end if\n\n   if(allocated(a%repro)) then\n      call a%memor%dealloc(npoin,a%repro,'repro','tem_memall')\n   endif\n  \n   !gradient orthogonal projection\n   if(a%kfl_adapsgs == 1) then\n      call a%memor%alloc(ndime,npoin,a%grprj,'grprj','tem_turnof')\n   end if\n   \n   if (allocated(a%gradient)) then\n      call a%memor%dealloc(ndime,npoin,a%gradient,'gradient','tem_memall')\n   endif\n   \n   if (allocated(a%gradientgausspoints)) then\n      call deallocater2pelement(a%mesh,ndime,a%gradientgausspoints,a%memor,'gradient')\n   endif\n   \n   if (a%npp_stepi(8) /= 0) then\n      call deallocater1pelement(a%mesh,a%shockcapturingviscosity,a%memor)\n   endif\n   \n   if(a%kfl_dispa /= 0) then\n      call a%memor%dealloc(npoin,a%dissipation,'dissipation','tem_memall')\n   endif\n   \n   if(a%kfl_outfm==1)then   \n      call a%memor%dealloc(nbody,a%heatf,'heatf','tem_turnof')\n      do ibody=1,nbody\n         close(a%lun_force(ibody))\n      end do\n      call a%memor%dealloc(nbody,a%lun_force,'lun_force','tem_turnof')\n   end if\n\n if (a%kfl_couplingthreefield==1) then\n      call a%memor%dealloc(ndime,ndime,npoin,a%smoothedvelocitygradient,'smoothedvelocitygradient','tem_turnof')  \n      if (a%npp_stepi(9) /= 0) then  \n         sig_coun = 0\n         do ielem=1,nelem\n            call a%mesh%getelemarraysize(ielem,pnode,pgaus)        \n            deallocate(a%sigmatermarray(ielem)%a)\n            sig_coun = sig_coun + pgaus        \n         end do\n         call a%memor%deallocobj(0,'sigmatermarray%a','tem_turnof',sig_coun*rp)\n         call a%memor%dealloc(nelem,a%sigmatermarray,'sigmatermarray','tem_turnof')\n         call a%memor%dealloc(npoin,a%viscousdissipation,'viscousdissipation','tem_turnof')\n      end if\n  end if\n   \n   !materials\n   deallocate(a%materials)\n   call a%memor%deallocobj(0,'materials','tempe_memall',1*a%numberofmaterials)\n\n   if (a%numberofmaterials > 1) then\n      call a%memor%dealloc(nelem,a%elementmaterials,'elementmaterials','tem_memall')\n   endif\n   \n   \nend subroutine\n"}
{"id": 1281, "subroutine": "      subroutine alloc_ter_arrays(idnode,mxnode)\n      \n      implicit none\n      \n      integer, parameter :: nnn=20\n\n      logical safe\n      integer i,fail,idnode,mxnode,npairs\n      dimension fail(nnn)\n\n      safe=.true.\n\nc     allocate arrays\n\n      fail(:)=0\n      \n      npairs=(mxter*(mxter+1))/2\n      allocate (prmter(mxter,mxpter),stat=fail(1))\n      allocate (prmter2(2,npairs),stat=fail(2))\n      allocate (lstter(mxter),stat=fail(3))\n      allocate (ltpter(mxter),stat=fail(4))\n      allocate (lattsf(mxatms),stat=fail(5))\n      allocate (xtf(mxatms),stat=fail(6))\n      allocate (ytf(mxatms),stat=fail(7))\n      allocate (ztf(mxatms),stat=fail(8))\n      allocate (rtf(mxatms),stat=fail(9))\n      allocate (ert(mxatms),stat=fail(10))\n      allocate (eat(mxatms),stat=fail(11))\n      allocate (grt(mxatms),stat=fail(12))\n      allocate (gat(mxatms),stat=fail(13))\n      allocate (scr(mxatms),stat=fail(14))\n      allocate (gcr(mxatms),stat=fail(15))\n      allocate (gam(mxatms),stat=fail(16))\n      allocate (gvr(mxatms),stat=fail(17))\n      allocate (vmbp(mxgrid,npairs,3),stat=fail(18))\n      allocate (gmbp(mxgrid,npairs,3),stat=fail(19))\n      allocate (filter(mxsite),stat=fail(20))\n      \n      if(any(fail.gt.0))safe=.false.      \n      if(mxnode.gt.1)call gstate(safe)    \n      if(.not.safe)call error(idnode,1945)\n      \n      end subroutine alloc_ter_arrays\n"}
{"id": 1282, "subroutine": "subroutine asolve_sp(b,x,itrnsp)\n  use mo_kind, only: sp, i4\n  use mo_nrutil, only : assert_eq,nrerror\n  use mo_nr, only : sprsdiag\n  use xlinbcg_data_sp\n  real(sp), dimension(:), intent(in) :: b\n  real(sp), dimension(:), intent(out) :: x\n  integer(i4), intent(in) :: itrnsp\n  integer(i4) :: ndum\n  ndum=assert_eq(size(b),size(x),'asolve_sp')\n  call sprsdiag(sa,x)\n  if (any(x == 0.0_sp)) call nrerror('asolve_sp: singular diagonal matrix')\n  x=b/x\nend subroutine asolve_sp\n"}
{"id": 1283, "subroutine": "subroutine asolve_dp(b,x,itrnsp)\n  use mo_kind, only: dp, i4\n  use mo_nrutil, only : assert_eq,nrerror\n  use mo_nr, only : sprsdiag\n  use xlinbcg_data_dp\n  real(dp), dimension(:), intent(in) :: b\n  real(dp), dimension(:), intent(out) :: x\n  integer(i4), intent(in) :: itrnsp\n  integer(i4) :: ndum\n  ndum=assert_eq(size(b),size(x),'asolve_dp')\n  call sprsdiag(sa,x)\n  if (any(x == 0.0_dp)) call nrerror('asolve_dp: singular diagonal matrix')\n  x=b/x\nend subroutine asolve_dp\n"}
{"id": 1284, "subroutine": "subroutine qinit(meqn,mbc,mx,my,xlower,ylower,dx,dy,q,maux,aux)\n    \n    use qinit_module, only: qinit_type,add_perturbation\n    use geoclaw_module, only: sea_level\n    \n    implicit none\n\n    integer, intent(in) :: meqn,mbc,mx,my,maux\n    real(kind=8), intent(in) :: xlower,ylower,dx,dy\n    real(kind=8), intent(inout) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)\n    real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)\n    \n    ! locals\n    integer :: i,j,m\n    real(kind=8) :: discharge\n    \n    ! set flat state based on sea_level\n    q = 0.d0\n    discharge = 0.115d0 * 0.054  ! free stream\n    forall(i=1:mx, j=1:my)\n        q(1,i,j) = max(0.d0, sea_level - aux(1,i,j))\n        q(2,i,j) = discharge   ! 0.115d0 * q(1,i,j)\n    end forall\n\nend subroutine qinit\n"}
{"id": 1285, "subroutine": "  subroutine testprintmatrix9 (rmatrix)\n  \n    type(t_matrixscalar) , intent(in) :: rmatrix\n    \n    ! some local variables\n    integer :: i, j, nvt\n    integer(prec_vecidx), dimension(:), pointer :: p_kcol\n    integer(prec_matidx), dimension(:), pointer :: p_kld , p_kdiagonal\n    real(dp), dimension(:), pointer :: p_da_mass, p_da\n    integer , dimension(:) , allocatable :: iaux\n\n    call lsyssc_getbase_kld (rmatrix,p_kld)\n    call lsyssc_getbase_kcol (rmatrix,p_kcol)\n    call lsyssc_getbase_kdiagonal(rmatrix, p_kdiagonal)\n    call lsyssc_getbase_double (rmatrix,p_da)\n    nvt = rmatrix%neq\n    \n    do i = 1,nvt\n        do j = p_kld(i), p_kld(i+1)-1\n            print *,i,\": \",p_kcol(j),\": \",p_da( j )\n        end do\n    end do\n    \n  end subroutine\n"}
{"id": 1286, "subroutine": "  subroutine testprintvector (rvector)\n  \n    type(t_vectorscalar) , intent(in) :: rvector\n    real(dp), dimension(:), pointer :: p_vector\n        \n    ! some local variables\n    integer :: i, j, nvt\n\n    call lsyssc_getbase_double (rvector,p_vector)\n    nvt = rvector%neq\n    \n    do i = 1,nvt\n        print *,i,\": \",p_vector( i )\n    end do\n    \n  end subroutine\n"}
{"id": 1287, "subroutine": "  subroutine multinvlumpedvector (rmatrix, rvector)\n\n    type(t_matrixscalar) , intent(in) :: rmatrix\n    type(t_vectorscalar) , intent(inout) :: rvector\n    real(dp), dimension(:), pointer :: p_vector\n    \n    ! some local variables\n    integer :: i, nvt\n    integer(prec_vecidx), dimension(:), pointer :: p_kcol\n    integer(prec_matidx), dimension(:), pointer :: p_kld , p_kdiagonal\n    real(dp), dimension(:), pointer :: p_da_mass, p_da\n\n    !matrix initialization things\n    !call lsyssc_getbase_kld (rmatrix,p_kld)\n    !call lsyssc_getbase_kcol (rmatrix,p_kcol)\n    call lsyssc_getbase_kdiagonal(rmatrix, p_kdiagonal)\n    call lsyssc_getbase_double (rmatrix,p_da)\n    nvt = rmatrix%neq\n    \n    !vector initialization things\n    call lsyssc_getbase_double (rvector,p_vector)\n    nvt = rvector%neq\n    \n    do i = 1,nvt\n        p_vector( i ) = (1.0_dp/p_da(p_kdiagonal(i)))*p_vector( i )\n    end do\n    \n  end subroutine\n"}
{"id": 1288, "subroutine": "  subroutine vector_writetofile (rtria, rvector, filename, filenumber, itimestep)\n  \n    type(t_vectorscalar), intent(in) :: rvector\n    character (len=*), intent(in) :: filename\n    integer,  intent(inout), optional :: filenumber\n    integer,  intent(in), optional :: itimestep\n    type(t_triangulation), intent(in) :: rtria\n    real(dp), dimension(:,:), pointer :: p_dvertexcoords\n\n    !auxiliary\n    real(dp), dimension(:), pointer :: p_vector\n    integer :: i, j, nvt\n    integer :: filenumber_local\n  \n    ! set variables\n    call lsyssc_getbase_double (rvector,p_vector)\n    nvt = rvector%neq\n    if(present(filenumber)) then\n\tfilenumber_local=filenumber\n    else\n\tfilenumber_local=1313\n    endif\n\n    ! get coordinates\n    call storage_getbase_double2d (rtria%h_dvertexcoords,p_dvertexcoords)\n\n    !open(filenumber,file=filename//trim(sys_si0l(itimestep,5)),status=\"new\")\n    if(present(itimestep)) then\n\topen(filenumber_local,file=filename//trim('_y05')//trim(sys_si0l(itimestep,5)),status=\"replace\")\n    else\n    \topen(filenumber_local,file=filename//trim('_y05'),status=\"replace\")\n    endif\n    do i = 1,nvt\n\t!print filenumber,p_vector(i)\n\t!write(mfile,'(a,1x,i10)') 'nodes',rexport%nvertices\n\tif( p_dvertexcoords(2,i).eq.0.5d0 ) then\n\t    write(filenumber_local,'(es16.8e3,1x,es16.8e3,1x,es16.8e3)') &\n\t\t\t\t     p_dvertexcoords(1,i), p_dvertexcoords(2,i), p_vector(i)\n        endif\n    end do\n    close(filenumber_local)\n\n    !write x=0.5 cutline\n    !open(filenumber,file=filename//trim(sys_si0l(itimestep,5)),status=\"new\")\n    if(present(itimestep)) then\n\topen(filenumber_local,file=filename//trim('_x05')//trim(sys_si0l(itimestep,5)),status=\"replace\")\n    else\n    \topen(filenumber_local,file=filename//trim('_x05'),status=\"replace\")\n    endif\n    do i = 1,nvt\n\t!print filenumber,p_vector(i)\n\t!write(mfile,'(a,1x,i10)') 'nodes',rexport%nvertices\n\tif( p_dvertexcoords(1,i).eq.0.5d0 ) then\n\t    write(filenumber_local,'(es16.8e3,1x,es16.8e3,1x,es16.8e3)') &\n\t\t\t\t     p_dvertexcoords(1,i), p_dvertexcoords(2,i), p_vector(i)\n        endif\n    end do\n    close(filenumber_local)\n\t\n  end subroutine\n"}
{"id": 1289, "subroutine": "            subroutine lagrange_any(xi,ngll,xigll,h,hprime)\n              integer(kind=4) :: ngll\n              real(kind=8) :: xi\n              real(kind=8) :: xigll(ngll)\n              real(kind=8) :: h(ngll)\n              real(kind=8) :: hprime(ngll)\n            end subroutine lagrange_any\n"}
{"id": 1290, "subroutine": "  subroutine sub1()\n    !$omp task\n    !$omp cancellation point taskgroup\n    a = 3.14\n    !$omp end task\n\n    !$omp taskloop\n    do i = 1, n\n      !$omp parallel\n      !$omp end parallel\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n    !$omp end taskloop\n\n    !$omp taskloop nogroup\n    do i = 1, n\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n\n    !$omp parallel\n    !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n    !$omp cancellation point taskgroup\n    a = 3.14\n    !$omp end parallel\n\n    !$omp do\n    do i = 1, n\n      !$omp task\n      !$omp cancellation point taskgroup\n      a = 3.14\n      !$omp end task\n    end do\n    !$omp end do\n\n    !$omp parallel\n    !$omp taskgroup\n    !$omp task\n    !$omp cancellation point taskgroup\n    a = 3.14\n    !$omp end task\n    !$omp end taskgroup\n    !$omp end parallel\n\n    !$omp parallel\n    !$omp task\n    !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n    !$omp cancellation point taskgroup\n    a = 3.14\n    !$omp end task\n    !$omp end parallel\n\n    !$omp parallel\n    !$omp do\n    do i = 1, n\n      !$omp task\n      !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n      !$omp cancellation point taskgroup\n      a = 3.14\n      !$omp end task\n    end do\n    !$omp end do\n    !$omp end parallel\n\n    !$omp target parallel\n    !$omp task\n    !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n    !$omp cancellation point taskgroup\n    a = 3.14\n    !$omp end task\n    !$omp end target parallel\n\n    !$omp parallel\n    !$omp taskloop private(j) nogroup\n    do i = 1, n\n      !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n    !$omp end taskloop\n    !$omp end parallel\n\n    !$omp parallel\n    !$omp taskloop\n    do i = 1, n\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n    !$omp end taskloop\n    !$omp end parallel\n\n    !$omp parallel\n    !$omp taskgroup\n    !$omp taskloop nogroup\n    do i = 1, n\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n    !$omp end taskloop\n    !$omp end taskgroup\n    !$omp end parallel\n\n    !$omp target parallel\n    !$omp taskloop nogroup\n    do i = 1, n\n      !error: with taskgroup clause, cancellation point construct must be closely nested inside task or taskloop construct and cancellation point region must be closely nested inside taskgroup region\n      !$omp cancellation point taskgroup\n      a = 3.14\n    end do\n    !$omp end taskloop\n    !$omp end target parallel\n  end subroutine sub1\n"}
{"id": 1291, "subroutine": "subroutine aderpicardloopnonlinear(luh,dt,dx,lqh,lfh) \n    use typesdef\n    use, intrinsic :: iso_c_binding\n    implicit none \n    ! argument list \n    double precision, intent(in)  :: luh(nvar,ndof(1),ndof(2),ndof(3))              ! spatial degrees of freedom \n    double precision, intent(in)  :: dt                                             ! \n    double precision, intent(in)  :: dx(d)                                          ! \n    double precision, intent(out) :: lqh(nvar,ndof(0),ndof(1),ndof(2),ndof(3))      ! space-time degrees of freedom  \n    double precision, intent(out) :: lfh(nvar,d+1,ndof(1),ndof(2),ndof(3),ndof(0))    ! nonlinear flux tensor in each space-time dof \n    ! local variables \n    integer :: i,j,k,l,ivar, iter \n    double precision    :: rhs0(nvar,ndof(1),ndof(2),ndof(3),ndof(0))               ! contribution of the initial condition to the known right hand side \n    double precision    :: rhs(nvar,ndof(1),ndof(2),ndof(3),ndof(0))                ! known right hand side \n    double precision    :: aux(d)                                                   ! auxiliary variables \n    double precision    :: lqhold(nvar,ndof(0),ndof(1),ndof(2),ndof(3))             ! old space-time degrees of freedom\n    double precision    :: lqx(nvar,ndof(1),ndof(2),ndof(3),ndof(0))                ! spatial derivative qx of q \n    double precision    :: lqy(nvar,ndof(1),ndof(2),ndof(3),ndof(0))                ! spatial derivative qy of q \n    double precision    :: lqz(nvar,ndof(1),ndof(2),ndof(3),ndof(0))                ! spatial derivative qz of q \n    double precision    :: lqt(nvar,ndof(1),ndof(2),ndof(3),ndof(0))                ! time derivative qt of q \n    double precision    :: src(nvar), bgradq(nvar), gradq(nvar,d) \n    double precision    :: res                                                      ! residual\n    double precision, parameter :: tol = 1e-7                                       ! tolerance \n    !\n    do k = 1, ndof(3) \n     do j = 1, ndof(2) \n      do i = 1, ndof(1) \n        ! trivial initial guess (can be significantly improved) \n        do ivar = 1, nvar\n            lqh(ivar,:,i,j,k) = luh(ivar,i,j,k) \n        enddo \n        ! compute the contribution of the initial condition uh to the time update. i prefer to compute it once\n        ! and store it in rhs0, but if you think it is faster, you can also recompute this contribution \n        ! inside the picard loop (do iter = 1, n+1) \n        aux = (/ wgpn(i), wgpn(j), wgpn(k) /) \n\n        do ivar = 1, nvar \n         rhs0(ivar,i,j,k,:) = product(aux(1:ndim))*f0(:)*luh(ivar,i,j,k) \n        enddo\n        ! \n      enddo \n     enddo\n    enddo \n        \n    ! \n    ! discrete picard iterations. this set of nested loops should (theoretically) be a dream for vectorization, since they are rather independent... \n    do iter = 1, n+1   \n        ! save old space-time dof \n        !lqhold = lqh\n        do l = 1, ndof(0) ! loop over dof in time \n         ! compute the fluxes (once these fluxes are available, the subsequent operations are independent from each other) \n         do k = 1, ndof(3) \n          do j = 1, ndof(2) \n           do i = 1, ndof(1) \n                call pdeflux(lfh(:,:,i,j,k,l),lqh(:,l,i,j,k)) \n           enddo\n          enddo\n         enddo                   \n         \n         ! compute the \"derivatives\" (contributions of the stiffness matrix) \n         ! x direction (independent from the y and z derivatives) \n        do k = 1, ndof(3) \n          do j = 1, ndof(2) \n              aux = (/ wgpn(l), wgpn(j), wgpn(k) /) \n              rhs(:,:,j,k,l) = rhs0(:,:,j,k,l) - product(aux(1:ndim))*dt/dx(1)*matmul( lfh(:,1,:,j,k,l), kxi ) \n              lqx(:,:,j,k,l) = 1.0/dx(1)*matmul( lqh(:,l,:,j,k), transpose(dudx) )         ! currently used only for debugging purposes, to check if derivatives are correctly computed  \n          enddo\n         enddo \n         \n         ! y direction (independent from the x and z derivatives) - should not be used for 1d \n         if(ndim>=2) then\n             do k = 1, ndof(3) \n              do i = 1, ndof(1) \n                  aux = (/ wgpn(l), wgpn(i), wgpn(k) /) \n                  rhs(:,i,:,k,l) = rhs(:,i,:,k,l) - product(aux(1:ndim))*dt/dx(2)*matmul( lfh(:,2,i,:,k,l), kxi ) \n                  lqy(:,i,:,k,l) = 1.0/dx(2)*matmul( lqh(:,l,i,:,k), transpose(dudx) )     ! currently used only for debugging purposes, to check if derivatives are correctly computed \n              enddo\n             enddo \n         endif \n         ! z direction (independent from the x and y derivatives) - should not be used for 1d and 2d \n         if(ndim>=3) then\n             do j = 1, ndof(2) \n              do i = 1, ndof(1) \n                  aux = (/ wgpn(l), wgpn(i), wgpn(j) /) \n                  rhs(:,i,j,:,l) = rhs(:,i,j,:,l) - product(aux(1:ndim))*dt/dx(3)*matmul( lfh(:,3,i,j,:,l), kxi ) \n                  lqz(:,i,j,:,l) = 1.0/dx(3)*matmul( lqh(:,l,i,j,:), transpose(dudx) )     ! currently used only for debugging purposes, to check if derivatives are correctly computed  \n              enddo\n             enddo \n         endif \n         !\n         do k = 1, ndof(3) \n          do j = 1, ndof(2) \n           do i = 1, ndof(1)\n                aux = (/ wgpn(i), wgpn(j), wgpn(k) /) \n                gradq(:,1) = lqx(:,i,j,k,l) \n                gradq(:,2) = lqy(:,i,j,k,l) \n                gradq(:,3) = lqz(:,i,j,k,l) \n                call pdesource(src,lqh(:,l,i,j,k)) \n                call pdencp(bgradq,lqh(:,l,i,j,k),gradq) \n                lfh(:,d+1,i,j,k,l) = src - bgradq\n                rhs(:,i,j,k,l) = rhs(:,i,j,k,l) + product(aux(1:ndim))*wgpn(l)*dt*lfh(:,d+1,i,j,k,l)   \n           enddo\n          enddo\n         enddo             \n         !\n        enddo ! end loop over time dof \n        !\n        ! multiply with (k1)^(-1) to get the discrete time integral of the discrete picard iteration \n        ! \n        do k = 1, ndof(3)  \n         do j = 1, ndof(2)  \n          do i = 1, ndof(1)\n             aux = (/ wgpn(i), wgpn(j), wgpn(k) /) \n             lqh(:,:,i,j,k) = 1./(product(aux(1:ndim)))*matmul( rhs(:,i,j,k,:), transpose(ik1) ) \n             !lqt(:,i,j,k,:) = 1.0/dt*matmul( lqh(:,:,i,j,k), transpose(dudx) )         ! currently used only for debugging purposes, to check if derivatives are correctly computed  \n           enddo\n         enddo\n        enddo\n\n        !\n        ! we can stop the iterations if a certain tolerance has been reached. if you do not like this unpredictable feature (it depends on the solution of the pde) \n        ! simply comment the lines below, so each element will always do the same number of iterations in the predictor step, i.e. the same number of operations         \n        !\n        res = sqrt(sum((lqh-lqhold)**2)) \n        if(res.lt.tol) then\n           exit\n        endif\n        !\n    enddo    \n    \n    !print *, 'lqh=', lqh\nend subroutine aderpicardloopnonlinear\n"}
{"id": 1292, "subroutine": "subroutine aderpredictornonlinear(lqh,lfh,lqhi,lfhi_x,lfhi_y,lfhi_z,lshi)\n    use typesdef\n    use, intrinsic :: iso_c_binding\n    implicit none \n    ! argument list \n    double precision, intent(in)  :: lqh(nvar,ndof(0),ndof(1),ndof(2),ndof(3))      ! space-time degrees of freedom  \n    double precision, intent(in)  :: lfh(nvar,d+1,ndof(1),ndof(2),ndof(3),ndof(0))    ! nonlinear flux tensor in each space-time dof \n    double precision, intent(out) :: lqhi(nvar,ndof(1),ndof(2),ndof(3))             ! time-averaged space-time degrees of freedom \n    double precision, intent(out) :: lfhi_x(nvar,ndof(1),ndof(2),ndof(3))           ! time-averaged nonlinear flux tensor in each space-time dof in x direction\n    double precision, intent(out) :: lfhi_y(nvar,ndof(2),ndof(1),ndof(3))           ! time-averaged nonlinear flux tensor in each space-time dof in y direction\n    double precision, intent(out) :: lfhi_z(nvar,ndof(3),ndof(1),ndof(2))           ! time-averaged nonlinear flux tensor in each space-time dof in z direction\n    double precision, intent(out) :: lshi(nvar,ndof(1),ndof(2),ndof(3))             ! time-averaged nonlinear source\n    ! local variables \n    integer :: i,j,k,idim\n    !\n    !open(unit=12, file=\"aoutput_lqh2.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lqh\n    \n    !open(unit=12, file=\"aoutput_lfh.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lfh\n    !\n    ! immediately compute the time-averaged space-time polynomials \n    !\n    do k = 1, ndof(3)  \n     do j = 1, ndof(2)  \n      do i = 1, ndof(1) \n         lqhi(:,i,j,k) = matmul( lqh(:,:,i,j,k), wgpn )\n         !do idim = 1, ndim\n         !   lfhi(:,i,j,k,idim) = matmul( lfh(:,idim,i,j,k,:), wgpn )\n         !enddo\n         lfhi_x(:,i,j,k) = matmul( lfh(:,1,i,j,k,:), wgpn )\n         lfhi_y(:,j,i,k) = matmul( lfh(:,2,i,j,k,:), wgpn )\n         lfhi_z(:,k,i,j) = matmul( lfh(:,3,i,j,k,:), wgpn )\n         lshi(:,i,j,k)   = matmul( lfh(:,4,i,j,k,:), wgpn )\n      enddo\n     enddo\n    enddo\n    \n    !open(unit=12, file=\"aoutput_lqhi.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lqhi\n\n    !open(unit=12, file=\"aoutput_lfhi_x.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lfhi_x\n    \n    !open(unit=12, file=\"aoutput_lfhi_y.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lfhi_y\n    \n    !open(unit=12, file=\"aoutput_lfhi_z.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lfhi_z\n\n    !call exit\n    \n    !\nend subroutine aderpredictornonlinear\n"}
{"id": 1293, "subroutine": "subroutine aderextrapolatornonlinear(lqhi,lfhi_x,lfhi_y,lfhi_z,lqbnd,lfbnd)\n    use typesdef\n    use, intrinsic :: iso_c_binding\n    implicit none \n    ! argument list \n    double precision, intent(in)  :: lqhi(nvar,ndof(1),ndof(2),ndof(3))             ! time-averaged space-time degrees of freedom \n    double precision, intent(in)  :: lfhi_x(nvar,ndof(1),ndof(2),ndof(3))           ! time-averaged nonlinear flux tensor in each space-time dof in x direction\n    double precision, intent(in)  :: lfhi_y(nvar,ndof(2),ndof(1),ndof(3))           ! time-averaged nonlinear flux tensor in each space-time dof in y direction\n    double precision, intent(in)  :: lfhi_z(nvar,ndof(3),ndof(1),ndof(2))           ! time-averaged nonlinear flux tensor in each space-time dof in z direction\n    double precision, intent(out) :: lqbnd(nvar,ndof(2),ndof(3),6)                  ! time-averaged space-time degrees of freedom \n    double precision, intent(out) :: lfbnd(nvar,ndof(2),ndof(3),6)                  ! time-averaged nonlinear flux tensor in each space-time dof \n    ! local variables \n    integer :: i,j,k\n    ! \n    !\n    ! compute the bounday-extrapolated values for q and f*n\n    !\n    lqbnd = 0. \n    lfbnd = 0. \n    ! x-direction: face 1 (left) and face 2 (right) \n    do k = 1, ndof(3) \n     do j = 1, ndof(2) \n        lqbnd(:,j,k,1) = matmul( lqhi(:,:,j,k),   flcoeff )   ! left \n        lqbnd(:,j,k,2) = matmul( lqhi(:,:,j,k),   frcoeff )   ! right \n        lfbnd(:,j,k,1) = matmul( lfhi_x(:,:,j,k), flcoeff )   ! left \n        lfbnd(:,j,k,2) = matmul( lfhi_x(:,:,j,k), frcoeff )   ! right \n     enddo\n    enddo \n    ! y-direction: face 3 (left) and face 4 (right) \n    if(ndim>=2) then\n        do k = 1, ndof(3) \n         do i = 1, ndof(1) \n            lqbnd(:,i,k,3) = matmul( lqhi(:,i,:,k),   flcoeff )   ! left \n            lqbnd(:,i,k,4) = matmul( lqhi(:,i,:,k),   frcoeff )   ! right \n            lfbnd(:,i,k,3) = matmul( lfhi_y(:,:,i,k), flcoeff )   ! left \n            lfbnd(:,i,k,4) = matmul( lfhi_y(:,:,i,k), frcoeff )   ! right \n         enddo\n        enddo \n    endif    \n    ! z-direction: face 5 (left) and face 6 (right) \n    if(ndim>=3) then\n        do j = 1, ndof(2) \n         do i = 1, ndof(1) \n            lqbnd(:,i,j,5) = matmul( lqhi(:,i,j,:),   flcoeff )   ! left \n            lqbnd(:,i,j,6) = matmul( lqhi(:,i,j,:),   frcoeff )   ! right \n            lfbnd(:,i,j,5) = matmul( lfhi_z(:,:,i,j), flcoeff )   ! left\n            lfbnd(:,i,j,6) = matmul( lfhi_z(:,:,i,j), frcoeff )   ! right\n         enddo\n        enddo \n    endif       \n    !\n    !open(unit=12, file=\"aoutput_lfbnd.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lfbnd\n\n    !open(unit=12, file=\"aoutput_lqbnd.txt\", action=\"write\", status=\"replace\")\n    !write(12, '(es24.16,1x)') , lqbnd\n    !call exit    \n\nend subroutine aderextrapolatornonlinear\n"}
{"id": 1294, "subroutine": "    subroutine init(self)\n        class(hp_boundary_average_t),   intent(inout)  :: self\n\n        ! set operator name\n        call self%set_name('hyperbolized poisson boundary average operator')\n\n        ! set operator type\n        call self%set_operator_type('boundary advective operator')\n\n        ! set operator equations\n        call self%add_primary_field('u')\n        call self%add_primary_field('p')\n        call self%add_primary_field('q')\n        call self%add_primary_field('r')\n\n    end subroutine init\n"}
{"id": 1295, "subroutine": "    subroutine compute(self,worker,prop)\n        class(hp_boundary_average_t),    intent(inout)   :: self\n        type(chidg_worker_t),                               intent(inout)   :: worker\n        class(properties_t),                                intent(inout)   :: prop\n\n\n        type(ad_d), allocatable, dimension(:)   ::  &\n            u_m, u_p,                               &\n            p_m, p_p,                               &\n            q_m, q_p,                               &\n            r_m, r_p,                               &\n            flux_1_m, flux_2_m, flux_3_m,           &\n            flux_1_p, flux_2_p, flux_3_p, sumsqr_m, sumsqr_p, mag_m, mag_p\n\n\n        !\n        ! interpolate solution to quadrature nodes\n        !\n        u_m       = worker%get_field('u','value','face interior')\n        u_p       = worker%get_field('u','value','face exterior')\n\n        p_m = worker%get_field('p','value','face interior')\n        p_p = worker%get_field('p','value','face exterior')\n        q_m = worker%get_field('q','value','face interior')\n        q_p = worker%get_field('q','value','face exterior')\n        r_m = worker%get_field('r','value','face interior')\n        r_p = worker%get_field('r','value','face exterior')\n\n\n        ! allocate derivatives\n        flux_1_m = u_m*zero\n        flux_2_m = u_m*zero\n        flux_3_m = u_m*zero\n\n        flux_1_p = u_p*zero\n        flux_2_p = u_p*zero\n        flux_3_p = u_p*zero\n\n\n        !\n        ! u-equation\n        !\n\n        sumsqr_m = p_m*p_m + q_m*q_m + r_m*r_m\n        sumsqr_p = p_p*p_p + q_p*q_p + r_p*r_p\n        if (abs(p_param-2._rk) > 1.e-8_rk) then\n            mag_m = sumsqr_m**((p_param-two)/two)\n            mag_p = sumsqr_p**((p_param-two)/two)\n        else\n            mag_m = sumsqr_m\n            mag_p = sumsqr_p\n            mag_m = one\n            mag_p = one\n        end if\n\n        flux_1_m = mag_m*p_m\n        flux_2_m = mag_m*q_m\n        flux_3_m = mag_m*r_m\n\n        flux_1_p = mag_p*p_p\n        flux_2_p = mag_p*q_p\n        flux_3_p = mag_p*r_p\n\n\n!        flux_1_m = p_m\n!        flux_2_m = q_m\n!        flux_3_m = r_m\n!\n!        flux_1_p = p_p\n!        flux_2_p = q_p\n!        flux_3_p = r_p\n\n        call worker%integrate_boundary_average('u','advection',                 &\n                                                flux_1_m, flux_2_m, flux_3_m,   &\n                                                flux_1_p, flux_2_p, flux_3_p)\n\n\n        !\n        ! p-equation\n        !\n        flux_1_m = u_m\n        flux_2_m = zero\n        flux_3_m = zero\n\n        flux_1_p = u_p\n        flux_2_p = zero\n        flux_3_p = zero\n\n        call worker%integrate_boundary_average('p','advection',                 &\n                                                flux_1_m, flux_2_m, flux_3_m,   &\n                                                flux_1_p, flux_2_p, flux_3_p)\n\n        !\n        ! q-equation\n        !\n        flux_1_m = zero\n        flux_2_m = u_m\n        flux_3_m = zero\n\n        flux_1_p = zero\n        flux_2_p = u_p\n        flux_3_p = zero\n\n        call worker%integrate_boundary_average('q','advection',                 &\n                                                flux_1_m, flux_2_m, flux_3_m,   &\n                                                flux_1_p, flux_2_p, flux_3_p)\n\n        !\n        ! r-equation\n        !\n        flux_1_m = zero\n        flux_2_m = zero\n        flux_3_m = u_m\n\n        flux_1_p = zero\n        flux_2_p = zero\n        flux_3_p = u_p\n\n        call worker%integrate_boundary_average('r','advection',                 &\n                                                flux_1_m, flux_2_m, flux_3_m,   &\n                                                flux_1_p, flux_2_p, flux_3_p)\n\n    end subroutine compute\n"}
{"id": 1296, "subroutine": "  subroutine dia_tmb_init\n    integer :: ios\n    namelist /nam_diatmb/ ln_diatmb\n    rewind(unit = numnam_ref)\n    read(numnam_ref, nam_diatmb, iostat = ios, err = 901)\n901 if (ios /= 0) call ctl_nam(ios, 'nam_diatmb in reference namelist', lwp)\n    rewind(unit = numnam_cfg)\n    read(numnam_cfg, nam_diatmb, iostat = ios, err = 902)\n902 if (ios > 0) call ctl_nam(ios, 'nam_diatmb in configuration namelist', lwp)\n    if (lwm) write(numond, nam_diatmb)\n    if (lwp) then\n      write(numout, fmt = *)\n      write(numout, fmt = *) 'dia_tmb_init : output top, middle, bottom diagnostics'\n      write(numout, fmt = *) '~~~~~~~~~~~~'\n      write(numout, fmt = *) '   namelist nam_diatmb : set tmb outputs '\n      write(numout, fmt = *) '      switch for tmb diagnostics (t) or not (f)  ln_diatmb  = ', ln_diatmb\n    end if\n  end subroutine dia_tmb_init\n"}
{"id": 1297, "subroutine": "  subroutine dia_calctmb(pfield, ptmb)\n    real(kind = wp), dimension(jpi, jpj, jpk), intent(in   ) :: pfield\n    real(kind = wp), dimension(jpi, jpj, 3), intent(  out) :: ptmb\n    integer :: ji, jj\n    integer :: itop, imid, ibot\n    real(kind = wp) :: zmdi = 1.e+20_wp\n    !$acc kernels\n    do jj = 1, jpj\n      do ji = 1, jpi\n        itop = mikt(ji, jj)\n        ibot = mbkt(ji, jj)\n        imid = itop + (ibot - itop + 1) / 2\n        ptmb(ji, jj, 1) = pfield(ji, jj, itop) * tmask(ji, jj, itop) + zmdi * (1._wp - tmask(ji, jj, itop))\n        ptmb(ji, jj, 2) = pfield(ji, jj, imid) * tmask(ji, jj, imid) + zmdi * (1._wp - tmask(ji, jj, imid))\n        ptmb(ji, jj, 3) = pfield(ji, jj, ibot) * tmask(ji, jj, ibot) + zmdi * (1._wp - tmask(ji, jj, ibot))\n      end do\n    end do\n    !$acc end kernels\n  end subroutine dia_calctmb\n"}
{"id": 1298, "subroutine": "  subroutine dia_tmb\n    real(kind = wp) :: zmdi = 1.e+20\n    real(kind = wp), dimension(jpi, jpj, 3) :: zwtmb\n    call dia_calctmb(tsn(:, :, :, jp_tem), zwtmb)\n    call iom_put(\"sshnmasked\", sshn(:, :) * tmask(:, :, 1) + zmdi * (1.0 - tmask(:, :, 1)))\n    call iom_put(\"top_temp\", zwtmb(:, :, 1))\n    call iom_put(\"mid_temp\", zwtmb(:, :, 2))\n    call iom_put(\"bot_temp\", zwtmb(:, :, 3))\n    call dia_calctmb(tsn(:, :, :, jp_sal), zwtmb)\n    call iom_put(\"top_sal\", zwtmb(:, :, 1))\n    call iom_put(\"mid_sal\", zwtmb(:, :, 2))\n    call iom_put(\"bot_sal\", zwtmb(:, :, 3))\n    call dia_calctmb(un(:, :, :), zwtmb)\n    call iom_put(\"top_u\", zwtmb(:, :, 1))\n    call iom_put(\"mid_u\", zwtmb(:, :, 2))\n    call iom_put(\"bot_u\", zwtmb(:, :, 3))\n    call dia_calctmb(vn(:, :, :), zwtmb)\n    call iom_put(\"top_v\", zwtmb(:, :, 1))\n    call iom_put(\"mid_v\", zwtmb(:, :, 2))\n    call iom_put(\"bot_v\", zwtmb(:, :, 3))\n  end subroutine dia_tmb\n"}
{"id": 1299, "subroutine": "subroutine bd_generategll(n1, gll_nodes, errstat, errmsg)\n\n   ! input variables\n\n   integer(intki),          intent(in   ) :: n1             !< 1 + the order of spectral element, or equivalently p%nodes_per_elem\n   real(bdki), allocatable, intent(  out) :: gll_nodes(:)   !< location of gll nodes\n   integer(intki),          intent(  out) :: errstat        !< error status of the operation\n   character(*),            intent(  out) :: errmsg         !< error message if errstat /= errid_none\n\n   real(bdki)      , parameter            :: tol   = 10.0_bdki*epsilon(tol) / 2.0_bdki   ! tolerance for newton-raphson solve (ignores 1 significant digit)\n   integer(intki)  , parameter            :: maxit = 1000                                ! maximum allowable iterations in newton-raphson solve\n\n   real(bdki)                             :: x_it        ! current nr-iteration value\n   real(bdki)                             :: x_old       ! last nr-iteration value\n   real(bdki)                             :: dleg(n1)    ! legendre polynomial\n   integer(intki)                         :: n           ! order of spectral element\n   integer(intki)                         :: i           ! do-loop counter\n   integer(intki)                         :: j           ! do-loop counter\n   integer(intki)                         :: k           ! do-loop counter\n\n   integer(intki)                         :: errstat2\n   character(errmsglen)                   :: errmsg2\n   character(*), parameter                :: routinename = 'bd_generategll'\n\n\n   errstat = errid_none\n   errmsg  = \"\"\n\n   n = n1 - 1\n\n\n   call allocary(gll_nodes,n1,'gll points array',errstat2,errmsg2); call seterrstat( errstat2, errmsg2, errstat, errmsg, routinename )\n      if (errstat >= aborterrlev) return\n\n\n   !bjj: these are getting overwritten later....\n   ! enter known endpoints  [-1.0, 1.0]\n   gll_nodes(1) = -1.0_bdki\n   gll_nodes(n1) = 1.0_bdki\n\n   do i = 1, n1\n\n      x_it = -cos(pi_d * real(i-1,bdki) / n) ! initial guess - chebyshev points\n      do j = 1, maxit\n         x_old = x_it\n         dleg(1) = 1.0_bdki\n         dleg(2) = x_it\n         do k = 2,n\n            dleg(k+1) = (  real(2*k - 1,bdki) * dleg(k) * x_it &\n                         - real(  k - 1,bdki) * dleg(k-1) ) / real(k,bdki)\n         enddo\n         x_it = x_it - ( x_it * dleg(n1) - dleg(n) ) / &\n                       (real(n1,bdki) * dleg(n1) )\n         if (abs(x_it - x_old) .lt. tol) exit\n      enddo\n\n      gll_nodes(i) = x_it\n     !gll_weights(i) = 2.0_bdki / (real(n * n1, bdki) * dleg(n1)**2 )\n\n   enddo\n\nend subroutine bd_generategll\n"}
{"id": 1300, "subroutine": "subroutine analyt( cp, cs, rho, medium, n1 )\r\n\r\n  !     munk profile\r\n\r\n  !     returns\r\n  !        cs, cp, rho at depths i*h i = 1, n\r\n  !        depths of interfaces\r\n\r\n  implicit none\r\n  integer,           intent(in)  :: medium, n1\r\n  real     (kind=8), intent(out) :: rho( * )\r\n  complex  (kind=8), intent(out) :: cp( * ), cs( * )\r\n  integer                        :: i, n\r\n  real     (kind=8), parameter   :: eps = 0.00737\r\n  real     (kind=8)              :: h, x, z\r\n\r\n  n = n1 - 1\r\n\r\n  select case ( medium )\r\n\r\n  case ( 1 )   ! the ocean\r\n     h = 5000.0 / n\r\n     do i = 1, n1\r\n        z = ( i - 1 ) * h\r\n        x = 2.0 * ( z - 1300.0 ) / 1300.0\r\n        cp(  i ) = 1500.0 * ( 1.0 + eps * ( x - 1.0 + exp( -x ) ) )\r\n        cs(  i ) = 0.0\r\n        rho( i ) = 1.0\r\n     end do\r\n     return\r\n\r\n  case ( 2 )   ! the fluid half-space\r\n     cp(  1 ) = 1551.91\r\n     cs(  1 ) = 0.0\r\n     rho( 1 ) = 1.0e20\r\n     return\r\n\r\n  case( 9 )  ! an elastic layer\r\n     h = 1000.0 / n\r\n     z = 5000.0\r\n\r\n     do i = 1,n+1\r\n        cp( i ) = 4700.0 + ( z - 5000.0 ) / 10.0\r\n        cs( i ) = 2000.0 + ( z - 5000.0 ) / 10.0\r\n        cp( i ) = 4700.0\r\n        cs( i ) = 2000.0\r\n        rho( i ) = 2.0\r\n        z = z + h\r\n     end do\r\n  end select\r\n\r\nend subroutine analyt\r\n"}
{"id": 1301, "subroutine": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"}
{"id": 1302, "subroutine": "  subroutine sortarray(myarray,low,high)\n\n    implicit none\n    integer,intent(in)       :: low,high\n    real(prec),intent(inout) :: myarray(low:high)\n    ! local\n    integer :: locofmin\n    integer :: ind\n    real(prec) :: temp\n\n    do ind = low,high - 1\n      locofmin = minloc(abs(myarray(ind:high)),1) + low - 1 + ind\n      temp = myarray(ind)\n      myarray(ind) = myarray(locofmin)\n      myarray(locofmin) = temp\n    end do\n\n  end subroutine sortarray\n"}
{"id": 1303, "subroutine": "  subroutine sortandsum(myarray,low,high,arraysum)\n\n    implicit none\n    integer,intent(in)       :: low,high\n    real(prec),intent(inout) :: myarray(low:high)\n    real(prec),intent(out)   :: arraysum\n    ! local\n    integer :: ind\n\n    call sortarray(myarray,low,high)\n    arraysum = 0.0_prec\n    do ind = low,high\n      arraysum = arraysum + myarray(ind)\n    end do\n\n  end subroutine sortandsum\n"}
{"id": 1304, "subroutine": "  subroutine reversearray(myarray,low,high)\n\n    implicit none\n    integer,intent(in)       :: low,high\n    real(prec),intent(inout) :: myarray(low:high)\n    ! local\n    real(prec) :: temp(low:high)\n    integer    :: i,j\n\n    temp = myarray\n    j = high\n    do i = low,high\n      myarray(i) = temp(j)\n      j = j - 1\n    end do\n\n  end subroutine reversearray\n"}
{"id": 1305, "subroutine": "  subroutine forwardshift(myarray,n)\n\n    implicit none\n    integer,intent(in)    :: n\n    integer,intent(inout) :: myarray(1:n)\n    ! local\n    integer :: temp(1:n)\n\n    temp = myarray\n    myarray(1) = temp(n)\n    myarray(2:n) = temp(1:n - 1)\n\n  end subroutine forwardshift\n"}
{"id": 1306, "subroutine": "  subroutine tspsi (n,x,y, yp, sigma,ier,sigerr)\r\n    integer n, ier, sigerr\r\n    double precision x(n), y(n), yp(n), sigma(n)\r\n!***********************************************************\r\n!                                                from tspack\r\n!                                            robert j. renka\r\n!                                  dept. of computer science\r\n!                                       univ. of north texas\r\n!                                           renka@cs.unt.edu\r\n!                                                   07/08/92\r\n\n! define a hermite interpolatory tension spline h(x).  the\r\n! parameters consist of knot derivative values yp computed\r\n\n\n\n! and sig2.\r\n\n! parameters which define a smoothing curve rather than an\r\n! interpolatory curve.\r\n\n! or functions hval (values), hpval (first derivatives),\r\n! hppval (second derivatives), and tsintl (integrals).\r\n! on input:\r\n!       n = number of data points.  n .ge. 2 and n .ge. 3 if\r\n!           per = true.\r\n!       x = array of length n containing a strictly in-\r\n!           creasing sequence of abscissae:  x(i) < x(i+1)\r\n!           for i = 1,...,n-1.\r\n!       y = array of length n containing data values asso-\r\n!           ciated with the abscissae.  h(x(i)) = y(i) for\r\n!           i = 1,...,n.\r\n!       yp = array of length n containing first derivatives\r\n\n! on output:\r\n!       yp = array containing derivatives of h at the\r\n!            abscissae.  yp is not altered if -4 < ier < 0,\r\n!            and yp is only partially defined if ier = -4.\r\n!       sigma = array containing tension factors.  sigma(i)\r\n!               is associated with interval (x(i),x(i+1))\r\n!               for i = 1,...,n-1.  sigma is not altered if\r\n!               -4 < ier < 0 (unless iendc is invalid), and\r\n!               sigma is constant (not optimal) if ier = -4\r\n!               or iendc (if used) is invalid.\r\n!       ier = error indicator or iteration count:\r\n!             ier = ic .ge. 0 if no errors were encountered\r\n!                      and ic calls to sigs and ic+1 calls\r\n!                      to ypc1, ypc1p, ypc2 or ypc2p were\r\n!                      employed.  (ic = 0 if ncd = 1).\r\n!             ier = -1 if n, ncd, or iendc is outside its\r\n!                      valid range.\r\n!             ier = -2 if lwk is too small.\r\n!             ier = -3 if unifrm = true and sigma(1) is out-\r\n!                      side its valid range.\r\n!             ier = -4 if the abscissae x are not strictly\r\n!                      increasing.\r\n! procedures required by tspsi:  sigs, store, ypc1\r\n! intrinsic functions called by tspsi:  abs, max\r\n!***********************************************************\r\n!\r\n    integer ierr\r\n\r\n    ier = 0\r\n\r\n    if (n .lt. 2) then\r\n      ! invalid input parameter n\r\n      ier = -1\r\n    else\r\n\r\n      call ypc1 (n,x,y,yp,ierr)\r\n\r\n      if (ierr .ne. 0) then\r\n        !abscissae are not strictly increasing.\r\n        ier = -4\r\n      else\r\n        call sigs (n,x,y,yp,sigma,ierr,sigerr)\r\n      endif\r\n\r\n    endif\r\n\r\n  end subroutine\r\n"}
{"id": 1307, "subroutine": "subroutine ufo_rttovonedvarcheck_initpcemis(self, filepath, atlaspath)\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(out) :: self !< pc emissivity type\ncharacter(len=*), intent(in) :: filepath\ncharacter(len=*), intent(in), optional :: atlaspath\n\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_initpcemis\"\nlogical                     :: file_exists  ! check if a file exists logical\ninteger                     :: fileunit     ! unit number for reading in files\n\n! read eigenvector file\ninquire(file=trim(filepath), exist=file_exists)\nif (file_exists) then\n  fileunit = ufo_utils_iogetfreeunit()\n  open(unit = fileunit, file = trim(filepath))\n  call ufo_rttovonedvarcheck_getemiseigenvec(self, fileunit)\n  close(unit = fileunit)\n  call fckit_log % info(\"rttovonedvarcheck emiseigenvec file exists and read in\")\nelse\n  call abor1_ftn(\"rttovonedvarcheck emiseigenvec file not found: aborting\")\nend if\n\nself % initialised = .true.\n\n! read in emissivity atlas if file path present - \n! if not a first guess will be used from eigenvector file\nif (present(atlaspath)) then\n  inquire(file=trim(atlaspath), exist=file_exists)\n  if (file_exists) then\n    fileunit = ufo_utils_iogetfreeunit()\n    open(unit = fileunit, file = trim(filepath))\n    call ufo_rttovonedvarcheck_getemisatlas(self, fileunit)\n    close(unit = fileunit)\n    call fckit_log % info(\"rttovonedvarcheck emis atlas file exists and read in\")\n  else\n    call abor1_ftn(\"rttovonedvarcheck emis atlas file not found but requested: aborting\")\n  end if\nend if\n\ncall self % info()\n\nend subroutine ufo_rttovonedvarcheck_initpcemis\n"}
{"id": 1308, "subroutine": "subroutine ufo_rttovonedvarcheck_getemiseigenvec (self,     &\n                                                  fileunit  )\n\nimplicit none\n\ntype(ufo_rttovonedvarcheck_pcemis), intent(out) :: self !< pc emissivity type\ninteger, intent(in)                     :: fileunit\n\n! local declarations:\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_getemiseigenvec\"\ninteger :: eigversion\ninteger :: i\ninteger :: readstatus\ncharacter(len=max_string)   :: message\n\n!----------------------------------------------\n! 1. read header information and allocate arrays\n!----------------------------------------------\n\nread(fileunit, *, iostat = readstatus) eigversion, self % emis_eigen % nchans, &\n                                        self % emis_eigen % numev\n\nallocate (self % emis_eigen % channels( self % emis_eigen % nchans))\nallocate (self % emis_eigen % mean( self % emis_eigen % nchans))\nallocate (self % emis_eigen % pcmin( self % emis_eigen % numev))\nallocate (self % emis_eigen % pcmax( self % emis_eigen % numev))\nallocate (self % emis_eigen % pcguess( self % emis_eigen % numev))\nallocate (self % emis_eigen % ev( self % emis_eigen % numev, self % emis_eigen % nchans))\nif (eigversion >= 2) then\n  allocate (self % emis_eigen % ev_inverse( self % emis_eigen % nchans, self % emis_eigen % numev))\nend if\n\n!--------------------------------------------------------\n! 2. read the channels, mean emissivities and eigenvectors\n!--------------------------------------------------------\n\nread (fileunit, *, iostat = readstatus) self % emis_eigen % channels(:)\nread (fileunit, *, iostat = readstatus) self % emis_eigen % mean(:)\nread (fileunit, *, iostat = readstatus) self % emis_eigen % pcmin(:)\nread (fileunit, *, iostat = readstatus) self % emis_eigen % pcmax(:)\nread (fileunit, *, iostat = readstatus) self % emis_eigen % pcguess(:)\ndo i = 1, self % emis_eigen % numev\n  read (fileunit, *, iostat = readstatus) self % emis_eigen % ev(i,:)\nend do\n\n! has there been an error in the read?\nif (readstatus /= 0) then\n  write(message,*) routinename,  &\n       'problem reading in emis eigenvectors - please check the file '\n  call abor1_ftn(message)\nend if\n\nif (eigversion >= 2) then\n  do i = 1, self % emis_eigen % nchans\n    read (fileunit, *, iostat = readstatus) self % emis_eigen % ev_inverse(i,:)\n  end do\n  ! has there been an error in the read?\n  if (readstatus /= 0) then\n    write(message,*) routinename,  &\n         'problem reading in inverse emis eigenvectors - please check the file '\n    call abor1_ftn(message)\n  end if\nend if\n\nwrite(*, '(a,i0,a,i0,a)') 'finished reading ',self % emis_eigen % numev, &\n                          ' emissivity eigenvectors on ', &\n                           self % emis_eigen % nchans,' channels.'\n\nend subroutine ufo_rttovonedvarcheck_getemiseigenvec\n"}
{"id": 1309, "subroutine": "subroutine ufo_rttovonedvarcheck_getemisatlas (self, fileunit)\n\nimplicit none\n\ntype(ufo_rttovonedvarcheck_pcemis), intent(out) :: self !< pc emissivity type\ninteger, intent(in) :: fileunit\n\n! local declarations:\ncharacter(len=*), parameter          :: routinename = \"ufo_rttovonedvarcheck_getemisatlas\"\ncharacter(len=max_string)            :: message\ninteger                              :: readstatus\ninteger                              :: i\ninteger                              :: j\n\n!----------------------------------------------\n! 1. read header information and allocate arrays\n!----------------------------------------------\n\nread (fileunit, *, iostat = readstatus) self % emis_atlas % nlat, &\n                                        self % emis_atlas % nlon, &\n                                        self % emis_atlas % npc, &\n                                        self % emis_atlas % gridstep\n\nallocate (self % emis_atlas % emispc(self % emis_atlas % nlon, &\n                                     self % emis_atlas % nlat, &\n                                     self % emis_atlas % npc))\n\n!--------------------------------------------------------\n! 2. read the emissivity pcs\n!--------------------------------------------------------\n\ndo i = 1, self % emis_atlas % nlon\n  do j = 1, self % emis_atlas % nlat\n    read (fileunit, '(12f10.6)', iostat = readstatus) self % emis_atlas % emispc(i,j,:)\n  end do\nend do\n\n! has there been an error in the read?\nif (readstatus /= 0) then\n  write(message,*) routinename,  &\n       'problem reading in emisatlas - please check the file'\n  call abor1_ftn(message)\nelse\n  write (*, '(a,i0,a)') 'finished reading ir emissivity atlas with ', &\n                         self % emis_atlas % npc, ' principal components.'\nend if\n\nend subroutine ufo_rttovonedvarcheck_getemisatlas\n"}
{"id": 1310, "subroutine": "subroutine ufo_rttovonedvarcheck_deletepcemis(self)    ! inout\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(inout) :: self !< pc emissivity type\n\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_deletepcemis\"\n\nself % emis_eigen % nchans = 0\nself % emis_eigen % numev = 0\nif (associated (self % emis_eigen % channels)) deallocate (self % emis_eigen % channels)\nif (associated (self % emis_eigen % mean)) deallocate (self % emis_eigen % mean)\nif (associated (self % emis_eigen % pcmin)) deallocate (self % emis_eigen % pcmin)\nif (associated (self % emis_eigen % pcmax)) deallocate (self % emis_eigen % pcmax)\nif (associated (self % emis_eigen % pcguess)) deallocate (self % emis_eigen % pcguess)\nif (associated (self % emis_eigen % ev)) deallocate (self % emis_eigen % ev)\nif (associated (self % emis_eigen % ev_inverse)) deallocate (self % emis_eigen % ev_inverse)\n\nend subroutine ufo_rttovonedvarcheck_deletepcemis\n"}
{"id": 1311, "subroutine": "subroutine ufo_rttovonedvarcheck_printpcemis(self)\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(inout) :: self !< pc emissivity type\n\nwrite(*,*) \"printing contents of pc emiss\"\nwrite(*,*) \"emis_eigen % channels = \",self % emis_eigen % channels\n\nend subroutine ufo_rttovonedvarcheck_printpcemis\n"}
{"id": 1312, "subroutine": "subroutine ufo_rttovonedvarcheck_emistopc (self,       &\n                                           channels,   &\n                                           emissivity, &\n                                           pc)\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(inout) :: self !< pc emissivity type\ninteger, intent(in)          :: channels(:)\nreal(kind_real), intent(in)  :: emissivity(:)\nreal(kind_real), intent(out) :: pc(:)\n\n! local declarations:\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_emistopc\"\nreal(kind_real)             :: temp_emissivity(size(emissivity))\ninteger                     :: npc\ncharacter(len=max_string)   :: message\n\nnpc = size(pc)\n\nif (associated(self % emis_eigen % ev_inverse)) then\n\n  ! convert from emissivity to sine transform\n  temp_emissivity(:) = asin( 2.0_kind_real * emissivity(:) - 1.0_kind_real )\n\n  ! subtract means from transformed emissivities\n  temp_emissivity(:) = temp_emissivity(:) - self % emis_eigen % mean(channels(:))\n\n  ! calculate pc weights from emissivity spectrum\n  pc(1:npc) = matmul(temp_emissivity(:), self % emis_eigen % ev_inverse(channels(:),1:npc))\n\nelse\n\n  write(message, *) routinename,                             &\n                 'missing inverse eigenvector matrix - cannot convert emissivities to pcs'\n  call abor1_ftn(message)\n\nend if\n\nend subroutine ufo_rttovonedvarcheck_emistopc\n"}
{"id": 1313, "subroutine": "subroutine ufo_rttovonedvarcheck_pctoemis (self, &\n                                numchans,   &\n                                channels,   &\n                                numpc,      &\n                                pc,         &\n                                emissivity)\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(inout) :: self !< pc emissivity type\ninteger, intent(in)          :: numchans\ninteger, intent(in)          :: channels(numchans)\ninteger, intent(in)          :: numpc\nreal(kind_real), intent(in)  :: pc(numpc)\nreal(kind_real), intent(out) :: emissivity(numchans)\n\n! local declarations:\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_pctoemis\"\nreal(kind_real)             :: bigeof(numchans,numchans)\nreal(kind_real)             :: bigpc(numchans)\n\n! populate pc array with nchans elements\nbigpc(:) = 0.0_kind_real\nbigpc(1:numpc) = pc(:)\n\n! populate eof array with nchans elements\nbigeof(:,:) = 0.0_kind_real\nbigeof(1:numpc,:) = self % emis_eigen % ev(1:numpc,channels)\n\n! calculate reconstructed emissivity spectrum\nemissivity = matmul(bigpc, bigeof)\n\n! add means (these may have been subtracted off, otherwise they are zero)\nemissivity(:) = emissivity(:) + self % emis_eigen % mean(channels)\n\n! convert from sine transform to physical emissivity\nemissivity(1:numchans) = 0.5_kind_real * (sin(emissivity(1:numchans)) + 1.0_kind_real)\n\nend subroutine ufo_rttovonedvarcheck_pctoemis\n"}
{"id": 1314, "subroutine": "subroutine ufo_rttovonedvarcheck_emisktopc (self, &\n                                 numchans,     &\n                                 channels,     &\n                                 numpc,        &\n                                 emissivity,   &\n                                 emissivity_k, &\n                                 pc_k)\n\nimplicit none\n\nclass(ufo_rttovonedvarcheck_pcemis), intent(inout) :: self !< pc emissivity type\ninteger, intent(in)          :: numchans\ninteger, intent(in)          :: channels(numchans)\ninteger, intent(in)          :: numpc\nreal(kind_real), intent(in)  :: emissivity(numchans)\nreal(kind_real), intent(in)  :: emissivity_k(numchans)\nreal(kind_real), intent(out) :: pc_k(numchans,numpc)\n\n! local declarations:\ncharacter(len=*), parameter :: routinename = \"ufo_rttovonedvarcheck_emisktopc\"\nreal(kind_real)             :: jematrix_element\ninteger                     :: ichan\n\ndo ichan = 1, numchans\n  ! calculate diagonal matrix elements of emissivity jacobians\n  ! convert emissivity_k to sine transform\n  ! cos(asin(2x-1)) === sqrt(1-(1-2x)^2)\n  jematrix_element = emissivity_k(ichan) * 0.5_kind_real* &\n                     sqrt (1.0_kind_real - (1.0_kind_real - 2.0_kind_real * emissivity(ichan)) ** 2)\n\n! eof array === emiseigenvec % ev for the appropriate channel selection\n! n.b. note 'manual' transposition of matrix here\n  pc_k(ichan,1:numpc) = self % emis_eigen % ev(1:numpc,channels(ichan)) * jematrix_element\nend do\n\nend subroutine ufo_rttovonedvarcheck_emisktopc\n"}
{"id": 1315, "subroutine": "  subroutine create_datastore\n    type(sidredatastore) ds\n\n    call set_case_name(\"create_datastore\")\n\n    ds = sidredatastore()\n    call ds%delete()\n\n    call assert_true(.true.)\n  end subroutine create_datastore\n"}
{"id": 1316, "subroutine": "  subroutine valid_invalid\n    type(sidredatastore) ds\n    type(sidregroup) root\n    integer(sidre_indextype) idx\n    character(10) name\n\n    call set_case_name(\"valid_invalid\")\n\n    ds = sidredatastore()\n\n    idx = 3;\n    call assert_true(idx /= invalid_index, \"invalid_index does not compare\")\n\n    name = \"foo\"\n    call assert_true(name_is_valid(name), \"name_is_valid\")\n\n    root = ds%get_root()\n\n    call assert_true(root%get_group_name(idx) == \" \", &\n         \"error return from get_group_name\")\n    call assert_true(root%get_group_index(name) == invalid_index, &\n         \"root%get_group_index(name) == invalid_index\")\n\n    call ds%delete()\n  end subroutine valid_invalid\n"}
{"id": 1317, "subroutine": "subroutine mkwf(rr,iband,ikpt,ncg,nkpt,npwt,cg,kpt,indxkcg,indxkpw,npwarr,kg,wf)\nimplicit none\ninteger :: ncg,iband,ikpt,nkpt,npwt\ndouble complex :: cg(ncg)\ndouble precision :: kpt(3,nkpt),rr(3),xk(3),pi\ninteger :: indxkcg(nkpt),indxkpw(nkpt),npwarr(nkpt),kg(3,npwt)\ndouble complex :: wf\ndouble complex :: phase\n!double precision :: xnorm\ninteger :: ii,ig,icg\nparameter (pi=3.1415926535897932384626433832795d0)\n\nwf=(0.d0,0.d0)\n!xnorm=0.d0\ndo ig=1,npwarr(ikpt)\n  do ii=1,3\n    xk(ii)=kpt(ii,ikpt)+kg(ii,indxkpw(ikpt)+ig)\n  enddo\n  phase=2.d0*pi*(rr(1)*xk(1)+rr(2)*xk(2)+rr(3)*xk(3))*(0.d0,1.d0)\n  icg=indxkcg(ikpt)+(iband-1)*npwarr(ikpt)+ig\n  wf=wf+cg(icg)*exp(phase)\n!  xnorm=xnorm+dble(cg(icg)*conjg(cg(icg)))\n!  write(6,*) ig,wf\n!  write(6,'(3i3,3(3x,2es10.3))') kg(1:3,indxkpw(ikpt)+ig), &\n!&  cg(icg),wf,xnorm\nenddo\n\nreturn\nend subroutine mkwf\n"}
{"id": 1318, "subroutine": "  subroutine random_init\n\n    logical, save :: init_done = .false.\n    integer :: n, count\n    integer, dimension(:), allocatable :: seed\n    real :: warm(1000)\n\n    if (init_done) return\n    init_done = .true.\n    call random_seed(size=n)\n    allocate(seed(n))\n    do n = 1, size(seed)\n      seed(n) = n\n    end do\n    call random_seed(put = seed)\n\n    !warm up the rng\n    call random_number(warm)\n\n  end subroutine random_init\n"}
{"id": 1319, "subroutine": "  subroutine lwc2vapor(lwc,sh,t,p,thresh,lwc_m,sh_m,rh_m)\n\n\n    implicit none\n\n    ! inputs:\n\n    real, intent(in)    :: lwc    ! cloud water mixing ratio (kg/kg)\n    real, intent(in)    :: sh     ! specific humidity (kg/kg)   \n    real, intent(in)    :: t      ! temperature (k)\n    real, intent(in)    :: p      ! pressure (pa)\n    real, intent(in)    :: thresh ! saturation factor    \n              ! set thresh to 1.0 to convert cloud water up to\n              ! vapor saturation.  1.1 will allow 110% rh, and so\n              ! forth\n\n    ! outputs:\n   \n    real, intent(out)   :: lwc_m  ! adjusted lwc\n    real, intent(out)   :: sh_m   ! adjusted specific humidity\n    real, intent(out)   :: rh_m   ! adjusted rh (%)\n\n    ! locals\n\n    real :: shsat,mrmax,mr,mr_m,mrsat\n    real, external :: ssh,make_rh\n\n    \n    ! set saturation specific humidity for this point         \n\n    shsat = ssh(p,t-273.15)*0.001\n \n    ! convert specific humidity to mixing ratio \n    mrsat = shsat/(1.-shsat)\n    mr = sh/(1.-sh)\n     \n    mrmax = mrsat*thresh\n\n    ! create modified mixing ratio (mr_m) by adding cloud liquid\n\n    mr_m = mr + lwc\n\n    ! zero out the modified cloud water\n\n    lwc_m = 0.\n\n    ! if mr_m exceeds mrmax, convert the excess amount \n    ! back to cloud water\n\n    if (mr_m .gt. mrmax) then\n      lwc_m = mr_m - mrmax\n      mr_m = mrmax\n    endif\n\n    ! compute rh from modified mixing ratio\n    rh_m = (mr_m/mrsat)*100.\n\n    ! convert modified mixing ratio back to specific humidity\n    sh_m = mr_m/(1.+mr_m)\n\n    return\n  end subroutine lwc2vapor\n"}
{"id": 1320, "subroutine": "    subroutine psb_zmsort_u(x,nout,dir)\n      import \n      complex(psb_dpk_), intent(inout)           :: x(:) \n      integer(psb_ipk_), intent(out)             :: nout\n      integer(psb_ipk_), optional, intent(in)    :: dir\n    end subroutine psb_zmsort_u\n"}
{"id": 1321, "subroutine": "    subroutine psb_zmsort(x,ix,dir,flag)\n      import \n      complex(psb_dpk_), intent(inout)  :: x(:) \n      integer(psb_ipk_), optional, intent(in)    :: dir, flag\n      integer(psb_ipk_), optional, intent(inout) :: ix(:)\n    end subroutine psb_zmsort\n"}
{"id": 1322, "subroutine": "    subroutine psi_z_lmsort_up(n,k,l,iret)\n      import\n      implicit none\n      integer(psb_ipk_) :: n, iret\n      complex(psb_dpk_)  ::  k(n)\n      integer(psb_ipk_) :: l(0:n+1)\n    end subroutine psi_z_lmsort_up\n"}
{"id": 1323, "subroutine": "    subroutine psi_z_insert_heap(key,last,heap,dir,info)\n      import \n      implicit none \n\n      !  \n      ! input: \n      !   key:  the new value\n      !   last: pointer to the last occupied element in heap\n      !   heap: the heap\n      !   dir:  sorting direction\n\n      complex(psb_dpk_), intent(in)     :: key\n      complex(psb_dpk_), intent(inout)  :: heap(:)\n      integer(psb_ipk_), intent(in)     :: dir\n      integer(psb_ipk_), intent(inout)  :: last\n      integer(psb_ipk_), intent(out)    :: info\n    end subroutine psi_z_insert_heap\n"}
{"id": 1324, "subroutine": "    subroutine psi_z_idx_insert_heap(key,index,last,heap,idxs,dir,info)\n      import \n      implicit none \n\n      !  \n      ! input: \n      !   key:  the new value\n      !   last: pointer to the last occupied element in heap\n      !   heap: the heap\n      !   dir:  sorting direction\n\n      complex(psb_dpk_), intent(in)     :: key\n      complex(psb_dpk_), intent(inout)  :: heap(:)\n      integer(psb_ipk_), intent(in)     :: index\n      integer(psb_ipk_), intent(in)     :: dir\n      integer(psb_ipk_), intent(inout)  :: idxs(:)\n      integer(psb_ipk_), intent(inout)  :: last\n      integer(psb_ipk_), intent(out)    :: info\n    end subroutine psi_z_idx_insert_heap\n"}
{"id": 1325, "subroutine": "    subroutine psi_z_heap_get_first(key,last,heap,dir,info)\n      import \n      implicit none \n      complex(psb_dpk_), intent(inout)  :: key\n      integer(psb_ipk_), intent(inout)  :: last\n      integer(psb_ipk_), intent(in)     :: dir\n      complex(psb_dpk_), intent(inout)  :: heap(:)\n      integer(psb_ipk_), intent(out)    :: info\n    end subroutine psi_z_heap_get_first\n"}
{"id": 1326, "subroutine": "    subroutine psi_z_idx_heap_get_first(key,index,last,heap,idxs,dir,info)\n      import\n      complex(psb_dpk_), intent(inout)    :: key\n      integer(psb_ipk_), intent(out)    :: index\n      complex(psb_dpk_), intent(inout)    :: heap(:)\n      integer(psb_ipk_), intent(in)     :: dir\n      integer(psb_ipk_), intent(inout)  :: last\n      integer(psb_ipk_), intent(inout)  :: idxs(:)\n      integer(psb_ipk_), intent(out)    :: info\n    end subroutine psi_z_idx_heap_get_first\n"}
{"id": 1327, "subroutine": "    subroutine psi_zlisrx_up(n,x,ix)\n      import \n      complex(psb_dpk_), intent(inout)  :: x(:) \n      integer(psb_ipk_), intent(inout) :: ix(:)\n      integer(psb_ipk_), intent(in)   :: n\n    end subroutine psi_zlisrx_up\n"}
{"id": 1328, "subroutine": "    subroutine psi_zlqsr_up(n,x)\n      import \n      complex(psb_dpk_), intent(inout)  :: x(:) \n      integer(psb_ipk_), intent(in)   :: n\n    end subroutine psi_zlqsr_up\n"}
{"id": 1329, "subroutine": "  subroutine psb_z_init_heap(heap,info,dir)\n    use psb_realloc_mod, only : psb_ensure_size\n    implicit none \n    class(psb_z_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)            :: info\n    integer(psb_ipk_), intent(in), optional   :: dir\n\n    info = psb_success_\n    heap%last=0\n    if (present(dir)) then \n      heap%dir = dir\n    else\n      heap%dir = psb_asort_up_\n    endif\n    select case(heap%dir) \n    case (psb_asort_up_,psb_asort_down_)\n      ! ok, do nothing\n    case default\n      write(psb_err_unit,*) 'invalid direction, defaulting to psb_asort_up_'\n      heap%dir = psb_asort_up_\n    end select\n    call psb_ensure_size(psb_heap_resize,heap%keys,info)\n\n    return\n  end subroutine psb_z_init_heap\n"}
{"id": 1330, "subroutine": "  subroutine psb_z_insert_heap(key,heap,info)\n    use psb_realloc_mod, only : psb_ensure_size\n    implicit none \n\n    complex(psb_dpk_), intent(in)              :: key\n    class(psb_z_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)                       :: info\n\n    info = psb_success_\n    if (heap%last < 0) then \n      write(psb_err_unit,*) 'invalid last in heap ',heap%last\n      info = heap%last\n      return\n    endif\n\n    call psb_ensure_size(heap%last+1,heap%keys,info,addsz=psb_heap_resize)\n    if (info /= psb_success_) then \n      write(psb_err_unit,*) 'memory allocation failure in heap_insert'\n      info = -5\n      return\n    end if\n    call psi_z_insert_heap(key,&\n         & heap%last,heap%keys,heap%dir,info)\n\n    return\n  end subroutine psb_z_insert_heap\n"}
{"id": 1331, "subroutine": "  subroutine psb_z_heap_get_first(key,heap,info)\n    implicit none \n\n    class(psb_z_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)     :: info\n    complex(psb_dpk_), intent(out)       :: key\n\n\n    info = psb_success_\n\n    call psi_z_heap_get_first(key,&\n         & heap%last,heap%keys,heap%dir,info)\n\n    return\n  end subroutine psb_z_heap_get_first\n"}
{"id": 1332, "subroutine": "  subroutine psb_z_dump_heap(iout,heap,info)\n\n    implicit none \n    class(psb_z_heap), intent(in) :: heap\n    integer(psb_ipk_), intent(out)    :: info\n    integer(psb_ipk_), intent(in)     :: iout\n\n    info = psb_success_\n    if (iout < 0) then\n      write(psb_err_unit,*) 'invalid file '\n      info =-1\n      return\n    end if\n\n    write(iout,*) 'heap direction ',heap%dir\n    write(iout,*) 'heap size      ',heap%last\n    if ((heap%last > 0).and.((.not.allocated(heap%keys)).or.&\n         & (size(heap%keys)<heap%last))) then\n      write(iout,*) 'inconsistent size/allocation status!!'\n    else\n      write(iout,*) heap%keys(1:heap%last)\n    end if\n  end subroutine psb_z_dump_heap\n"}
{"id": 1333, "subroutine": "  subroutine psb_z_free_heap(heap,info)\n    implicit none \n    class(psb_z_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)           :: info\n\n    info=psb_success_\n    if (allocated(heap%keys)) deallocate(heap%keys,stat=info)\n\n  end subroutine psb_z_free_heap\n"}
{"id": 1334, "subroutine": "  subroutine psb_z_idx_heap_get_first(key,index,heap,info)\n    implicit none \n\n    class(psb_z_idx_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)       :: index\n    integer(psb_ipk_), intent(out)       :: info\n    complex(psb_dpk_), intent(out)           :: key\n\n\n    info = psb_success_\n\n    call psi_z_idx_heap_get_first(key,index,&\n         & heap%last,heap%keys,heap%idxs,heap%dir,info)\n\n    return\n  end subroutine psb_z_idx_heap_get_first\n"}
{"id": 1335, "subroutine": "  subroutine psb_z_idx_free_heap(heap,info)\n    implicit none \n    class(psb_z_idx_heap), intent(inout) :: heap\n    integer(psb_ipk_), intent(out)           :: info\n\n    info=psb_success_\n    if (allocated(heap%keys)) deallocate(heap%keys,stat=info)\n    if ((info == psb_success_).and.(allocated(heap%idxs))) deallocate(heap%idxs,stat=info)\n\n  end subroutine psb_z_idx_free_heap\n"}
{"id": 1336, "subroutine": "      subroutine compute_permfactor_vonmises(el, node_k, duu, dvv, dww\n     &, dpp, flag_u_pp)\n!***********************************************************************\n! copyright 2011 los alamos national security, llc  all rights reserved\n! unless otherwise indicated,  this information has been authored by an\n! employee or employees of the los alamos national security, llc (lans),\n! operator of the  los  alamos national  laboratory  under contract  no.\n! de-ac52-06na25396  with  the u. s. department  of  energy.  the  u. s.\n! government   has   rights  to  use,  reproduce,  and  distribute  this\n! information.  the  public may copy  and  use this  information without\n! charge, provided that this  notice and any statement of authorship are\n! reproduced on all copies.  neither  the  government nor lans makes any\n! warranty,   express   or   implied,   or   assumes  any  liability  or\n! responsibility for the use of this information.\n!***********************************************************************\n!\n! similar to compute_permfactor but use effective stress\n!\n! author : satish karra\n! date updated: 1/26/12\n\n      use comai, only: nei, neq, ns, iout\n      use combi, only: nelm\n      use comdi, only: t, tini, phi, phini\n      use comsi, only: ipermstr2, perx_m, pery_m, perz_m\n      use comsi, only: e1, e2, e3\n      use comsi, only: ipermstr22\n      use comsi, only: spm1f, spm2f, spm3f, spm4f, du, dv, dw, alp, bulk\n      use comfem\n      use comsi, only: modelnumber, plasticparam1, plasticmodel\n      use comai, only: iptty\n      use comsi, only: plastic_strain, ispmd\n\n      implicit none\n\n      double precision                   :: duu, dvv, dww\n      double precision                   :: dpp\n      double precision                   :: mean_str(6)\n      double precision                   :: d(6,6)\n      double precision                   :: b(6, 24)\n      integer                            :: node(8)\n      double precision                   :: disp(24)\n      double precision                   :: gp_strain(6), gp_stress(6)\n      double precision                   :: d_strain(6)\n      double precision                   :: fac, perm_fac\n      double precision                   :: str_max, str_tol\n      double precision                   :: alphadeltat, betadeltap\n      double precision                   :: e1bar, e2bar, e3bar\n      double precision                   :: p_eff,mean_str_eff\n      double precision                   :: dev_stress(6)\n      double precision                   :: g(8)\n      double precision                   :: trace, sigma_y, phi_trial \n      double precision                   :: q, j2, deltagamma, g_bar\n      double precision                   :: accum_pstrain\n      double precision                   :: phi_tol, mean_accum_pstrain\n      double precision                   :: accum_pstrain_max\n      double precision                   :: norm_per, change_pstrain\n      \n      integer, parameter                 :: numedges = 28\n      integer el, node_k, i, j, k\n      integer node_i, node_j, edge_1, edge_2\n      logical recompute\n      integer flag_u_pp\n      integer itmp, imodel\n      logical iunload\n\n      str_max = 1.0d0\n      mean_str = 0.0\n      mean_str_eff = 0.0\n      p_eff = 0.0\n      mean_accum_pstrain = 0.0\n      \n      if(ispmd.eq.100) then\n        perx_m  = spm1f(1)\nc        pery_m  = spm2f(1)\nc        perz_m  = spm3f(1)\n        accum_pstrain_max = spm4f(1)\n      else\n          write(iout, *) 'only permmodel 100 is supported ! \n     &        with von mises! '\n          write(iptty, *) 'only permmodel 100 is supported ! \n     &        with von mises! '\n          stop\n      endif\n\n      recompute = .false.\n      do j=1,ns\n         if(flag_u_pp.eq.1) then\n            if(elnode(el,j).eq.node_k) then\n               recompute=.true.\n            endif\n         endif\n      enddo\n      \n      if(recompute) then\n        ! recompute the stress in the element\n        do j=1,numgausspoints\n          ! first compute the strain\n          alphadeltat = 0.0d0\n          betadeltap = 0.0d0\n          e1bar = 0.0d0\n          e2bar = 0.0d0\n          e3bar = 0.0d0\n\n          disp = 0.0d0\n          do k=1,ns\n            node(k) = elnode(el, k)\n            if(node(k).eq.node_k) then\n              disp(3*k-2) = duu\n              disp(3*k-1) = dvv\n              disp(3*k  ) = dww\n            endif\n\n            alphadeltat = alphadeltat + alp(node(k))*\n     &            psi(el, j, k)*(t(node(k)) - tini(node(k)))\n            betadeltap = betadeltap + bulk(node(k))*\n     &            psi(el, j, k)*(phi(node(k)) - phini(node(k)))\n            e1bar = e1bar + e1(node(k))*psi(el, j, k)\n            e2bar = e2bar + e2(node(k))*psi(el, j, k)\n            e3bar = e3bar + e3(node(k))*psi(el, j, k)\n            g(k) = 0.5d0*(e1(k) - e2(k))\n            g_bar = g_bar + g(k)*psi(el ,j, k)\n\n\n          enddo\n\n          b = 0.0d0\n          do k=1,ns\n            b(1,3*(k-1) + 1) = dpsidx(el, j, k)\n            b(2,3*(k-1) + 2) = dpsidy(el, j, k)\n            b(3,3*(k-1) + 3) = dpsidz(el, j, k)\n            b(4,3*(k-1) + 1) = dpsidy(el, j, k)\n            b(4,3*(k-1) + 2) = dpsidx(el, j, k)\n            b(5,3*(k-1) + 2) = dpsidz(el, j, k)\n            b(5,3*(k-1) + 3) = dpsidy(el, j, k)\n            b(6,3*(k-1) + 1) = dpsidz(el, j, k)\n            b(6,3*(k-1) + 3) = dpsidx(el, j, k)\n          enddo\n          \n          !! computing incremental change in strain\n          d_strain = matmul(b, disp)\n\n          !! add incremental strain to elastic strain at gausspoint\n          gp_strain = fem_strain(el, j, :) + d_strain \n          gp_strain(1) = gp_strain(1) - alphadeltat - betadeltap\n          gp_strain(2) = gp_strain(2) - alphadeltat - betadeltap\n          gp_strain(3) = gp_strain(3) - alphadeltat - betadeltap\n\n          d = 0.0d0\n          !! fem_material_stiffness returns elasto-plastic matrix for\n          !! plastic, otherwise elastic matrix\n          call fem_material_stiffness(el, j, d)\n\n          gp_stress = matmul(d, gp_strain)\n\n          \n          ! assuming that when in plastic region, whatever is the change in \n          ! strain there is, it is due to plastic strain \n          change_pstrain = sqrt(sum(gp_strain(1:6)**2))\n          accum_pstrain = plastic_strain(el, j) + change_pstrain\n!             trace = (gp_stress(1) + gp_stress(2) + gp_stress(3))/3\n!             dev_stress(1) = gp_stress(1) - trace\n!             dev_stress(2) = gp_stress(2) - trace\n!             dev_stress(3) = gp_stress(3) - trace\n!             dev_stress(4) = gp_stress(4) \n!             dev_stress(5) = gp_stress(5)          \n!             dev_stress(6) = gp_stress(6)             \n! \n!           !! going through von mises calculations           \n!             call j2invariant(j2, dev_stress)\n!             itmp = modelnumber(elnode(el, 1))\n!             sigma_y = plasticparam1(itmp)\n!             imodel = plasticmodel(itmp)\n! \n!             q = sqrt(3.0d0*j2)\n!             phi_trial = q - sigma_y\n!             phi_tol = 1.0d-6\n!             iunload = .false.\n!             if((phi_trial.ge.phi_tol).and.(iunload.eqv..false.)) then\n!               deltagamma = phi_trial/(3.0d0*g_bar)\n!               accum_pstrain = plastic_strain(el,j) + deltagamma\n!             else\n!               write(iout, *) 'in the elastic region ! \n!      &          should not be checking for von mises criterion! '\n!               write(iptty, *) 'in the elastic region ! \n!      &          should not be checking for von mises criterion! '\n!            endif\n          \n          mean_str = mean_str + gp_stress\n          mean_accum_pstrain = mean_accum_pstrain + accum_pstrain\n        enddo\n        mean_str = mean_str/numgausspoints\n        mean_accum_pstrain = mean_accum_pstrain/numgausspoints\n      else\n        mean_str = 0.0d0\n        mean_accum_pstrain = 0.0d0\n        do j=1,numgausspoints\n          mean_str = mean_str + fem_stress(el, j, :)\n          mean_accum_pstrain = mean_accum_pstrain + \n     &                            plastic_strain(el,j)\n        enddo\n        mean_str = mean_str/numgausspoints\n        mean_accum_pstrain = mean_accum_pstrain/numgausspoints\n      endif\n     \n      do j=1, numedges\n        node_i = elnode(el, edges(j,1))\n        node_j = elnode(el, edges(j,2))\n        edge_1 = edgenum1(el, j)\n        edge_2 = edgenum2(el, j)\n      \n        !! perm dependence on accumulated plastic strain\n        !! ramp function upto a maximum value in acc. plastic strain\n        !! maximum acc. plastic strain -- karra\n        if(mean_accum_pstrain.gt.0.0) then\n          if(mean_accum_pstrain.lt.accum_pstrain_max) then\n            fac = mean_accum_pstrain/accum_pstrain_max\n            else \n            fac = 1.d0 \n          endif\n        else \n          fac = 0.d0 \n        endif\n\nc        norm_per = sqrt(perx_m*perx_m + pery_m*pery_m +\nc     &                  perz_m*perz_m)\n        norm_per = perx_m\n\n        perm_fac = fac*(norm_per - 1.0d0) + 1.0d0\n\n        write(iout,*) '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'\n        write(iout,*) 'mean_accum_pstrain, fac,norm_per,perm_fac'\n        write(iout,*) mean_accum_pstrain, fac,norm_per,perm_fac\n        write(iout,*) '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'\n \n        permfactor(edge_1, :) = permfactor(edge_1, :) + perm_fac\n        permfactor(edge_2, :) = permfactor(edge_2, :) + perm_fac\n    \n       enddo\n\n      end subroutine compute_permfactor_vonmises\n"}
{"id": 1337, "subroutine": "      subroutine specfile_squeeze( string, new_length, break )\n\n!     removes repeated, leading and trailing blanks, and computes the position\n!     of the command value within the (cleaned up) command line.\n\n!     argument\n\n      integer              , intent( out )   :: new_length, break\n      character( len = 80 ), intent( inout ) :: string\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      integer              :: i, j, nl, nb, last\n      character( len = 1 ) :: c\n\n!     remove the leading and trailing blanks\n\n      string = adjustl( trim( string ) )\n\n!     compute the length of the resulting string\n\n      new_length = len_trim( string )\n\n!     return if nothing is left\n\n      if ( new_length == 0 ) return\n\n!     initialize the position of the second \"word\"\n\n      break = 0\n\n!     initialize the position of the last non-blank seen (character 1\n!     must be non-blank because the leading blanks have been removed)\n\n      last  = 1\n\n!     loop of the string characters, starting from character 2\n\n      i     = 2\n      do j  = 2, new_length\n\n!        get the next character\n\n         c = string( i:i )\n\n!        action if it is not blank\n\n         if ( c /= ' ' ) then\n\n!           if the rest of the line is a comment, skip it\n\n            if ( c == '!' .or. c == '*' ) exit\n\n!           compute the number of blanks since the last non-blank character\n\n            nb = i - last - 1\n\n!           if this is the first internal blank, remember the position\n!           that follows it\n\n            if ( nb >= 1 .and. break == 0 ) break = last + 2\n\n!           if there is more than one blank, remove the redundant ones\n\n            if ( nb > 1 ) then\n               nl = new_length - nb + 1\n               string( last+2:nl ) = string( i:new_length )\n               new_length = nl\n               i = i - nb + 1\n            end if\n\n!           remember that this character is not a blank\n\n            last = i\n\n         end if\n\n!        consider the next character\n\n         i = i + 1\n\n!        exit if we have seen all non-blank characters\n\n         if ( i > new_length ) exit\n\n      end do\n\n      new_length = last\n      if ( break == 0 ) break = new_length + 1\n\n      return\n\n      end subroutine specfile_squeeze\n"}
{"id": 1338, "subroutine": "      subroutine specfile_assign_integer( specitem, iparam, errout )\n\n!     translate the string value of an integer control parameter into\n!     its proper value\n\n      type( specfile_item_type ), intent( in ):: specitem\n\n!        the specification item\n\n      integer, intent( inout ) :: iparam\n\n!        the control parameter to be assigned.\n\n      integer, intent ( inout ) :: errout\n\n!        the error output device number. note that it has inout for intent as\n!        the assignment may be used to reassign errout itself.\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      integer               :: lvalue, ios, itmp\n      character( len = 8 )  :: fmt\n\n      if ( specitem%line > 0 ) then\n         lvalue = len_trim( specitem%value )\n         if ( lvalue == 0 ) then\n            write( errout, * ) ' *** specfile warning: integer value ',        &\n                    trim( specitem%value )\n            write( errout, * ) '      not recognized in line',                 &\n                    specitem%line, 'of the specification file.'\n            write( errout, * ) '     corresponding assignment skipped.'\n            return\n         else if ( lvalue < 10 ) then\n             write( fmt, '( ''(i'',i1, '')'' )' ) lvalue\n         else \n             write( fmt, '( ''(i'',i2, '')'' )' ) lvalue\n         end if\n         read( specitem%value, fmt, iostat = ios ) itmp\n         if ( ios == 0 ) then\n            iparam = itmp\n         else\n            write( errout, * ) ' *** specfile warning: integer value ',        &\n                    trim( specitem%value )\n            write( errout, * ) '     not recognized in line',                  &\n                    specitem%line, 'of the specification file.'\n            write( errout, * ) '     corresponding assignment skipped.'\n         end if\n      end if\n\n      return\n\n      end subroutine specfile_assign_integer\n"}
{"id": 1339, "subroutine": "      subroutine specfile_assign_string( specitem, sparam, errout )\n\n!     translate the string value of a character control parameter into\n!     its proper value.\n\n      type( specfile_item_type ), intent( in ):: specitem\n\n!        the specification item\n\n      character( len = 30 ), intent( inout ) :: sparam\n\n!        the control parameter to be assigned.\n\n      integer, intent ( in ) :: errout\n\n!        the error output device number\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      integer               :: lvalue\n\n      if ( specitem%line > 0 ) then\n         lvalue = len_trim( specitem%value )\n         if ( lvalue > 0 ) then\n            sparam = trim( specitem%value )\n         else\n            write( errout, * ) ' *** specfile warning: string value ',         &\n                    trim( specitem%value )\n            write( errout, * ) '    not recognized in line',                   &\n                    specitem%line, 'of the specification file.'\n            write( errout, * ) '    corresponding assignment skipped.'\n         end if\n      end if\n\n      return\n\n      end subroutine specfile_assign_string\n"}
{"id": 1340, "subroutine": "      subroutine specfile_assign_logical( specitem, lparam, errout )\n\n!     translate the string value of an real control parameter into\n!     its proper value\n\n      type( specfile_item_type ), intent( in ):: specitem\n\n!        the specification item\n\n      logical, intent( inout ) :: lparam\n\n!        the control parameter to be assigned.\n\n      integer, intent ( in ) :: errout\n\n!        the error output device number\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      character( len = 30 ) :: tmp\n\n      if ( specitem%line > 0 ) then\n         tmp = trim( specitem%value )\n         call specfile_upper_case( tmp, len_trim( tmp ) )\n         if (      tmp == 'on'     .or. tmp == 't'       .or. &\n                   tmp == 'yes'    .or. tmp == 'y'       .or. &\n                   tmp == '.true.' .or. tmp == 'true'    .or. &\n                   tmp == ''                                  ) then\n            lparam = .true.\n         else if ( tmp == 'off'    .or. tmp == 'f'       .or. &\n                   tmp == 'no'     .or. tmp == 'n'       .or. &\n                   tmp == 'false'  .or. tmp == '.false.'      ) then\n            lparam = .false.\n         else\n            write( errout, * ) ' *** specfile warning: logical value ',        &\n                    trim( specitem%value )\n            write( errout, * ) '     not recognized in line',                  &\n                    specitem%line, 'of the specification file.'\n            write( errout, * ) '     corresponding assignment skipped.'\n            return\n         end if\n\n      end if\n\n      return\n\n      end subroutine specfile_assign_logical\n"}
{"id": 1341, "subroutine": "      subroutine specfile_assign_symbol( specitem, param, errout )\n\n!     translate the symbol value of a control parameter into\n!     its proper (integer) value\n\n      type( specfile_item_type ), intent( in ):: specitem\n\n!        the specification item\n\n      integer, intent( inout ) :: param\n\n!        the control parameter to be assigned.\n\n      integer, intent ( in ) :: errout\n\n!        the error output device number\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      character( len = 30 ) :: upper_value\n\n      if ( specitem%line > 0 ) then\n\n!        convert the value to upper case before interpretation\n\n         upper_value = trim( specitem%value )\n         call specfile_upper_case( upper_value, len_trim( upper_value ) )\n\n!        interpret the value\n\n         if ( trim( upper_value )      == 'silent'                ) then\n            param = galahad_silent\n         else if ( trim( upper_value ) == 'trace'                 ) then\n            param = galahad_trace\n         else if ( trim( upper_value ) == 'action'                ) then\n            param = galahad_action\n         else if ( trim( upper_value ) == 'details'               ) then\n            param = galahad_details\n         else if ( trim( upper_value ) == 'debug'                 ) then\n            param = galahad_debug\n         else if ( trim( upper_value ) == 'crazy'                 ) then\n            param = galahad_crazy\n         else if ( trim( upper_value ) == 'keep'                  ) then\n           param = galahad_keep\n         else if ( trim( upper_value ) == 'delete'                ) then\n            param = galahad_delete\n         else if ( trim( upper_value ) == 'none'                  ) then\n            param = galahad_none\n         else if ( trim( upper_value ) == 'basic'                 ) then\n            param = galahad_basic \n         else if ( trim( upper_value ) == 'severe'                ) then\n            param = galahad_severe\n         else if ( trim( upper_value ) == 'reduced_size'          ) then\n            param = galahad_reduced_size\n         else if ( trim( upper_value ) == 'full_presolve'         ) then\n            param = galahad_full_presolve  \n         else if ( trim( upper_value ) == 'all_zeros'             ) then\n            param = galahad_all_zeros\n         else if ( trim( upper_value ) == 'all_ones'              ) then\n            param = galahad_all_ones\n         else if ( trim( upper_value ) == 'general'               ) then\n            param = galahad_general\n         else if ( trim( upper_value ) == 'positive'              ) then\n            param = galahad_positive\n         else if ( trim( upper_value ) == 'negative'              ) then\n            param = galahad_negative\n         else if ( trim( upper_value ) == 'leave_as_is'           ) then\n            param = galahad_leave_as_is \n         else if ( trim( upper_value ) == 'force_to_zero'         ) then\n            param = galahad_force_to_zero\n         else if ( trim( upper_value ) == 'tightest'              ) then\n            param = galahad_tightest\n         else if ( trim( upper_value ) == 'non_degenerate'        ) then\n            param = galahad_non_degenerate\n         else if ( trim( upper_value ) == 'loosest'               ) then\n            param = galahad_loosest\n         else if ( trim( upper_value ) == 'dense'                 ) then\n            param = galahad_dense\n         else if ( trim( upper_value ) == 'sparse'                ) then\n            param = galahad_sparse_by_rows \n         else if ( trim( upper_value ) == 'coordinate'            ) then\n            param = galahad_coordinate\n         else if ( trim( upper_value ) == 'elemental'             ) then\n            param = galahad_elemental\n         else if ( trim( upper_value ) == 'unconstrained'         ) then\n            param = galahad_unconstrained\n         else if ( trim( upper_value ) == 'constrained'           ) then\n            param = galahad_constrained\n         else if ( trim( upper_value ) == 'inactive'              ) then\n            param = galahad_inactive\n         else if ( trim( upper_value ) == 'eliminated'            ) then\n            param = galahad_eliminated\n         else if ( trim( upper_value ) == 'active'                ) then\n            param = galahad_active\n         else if ( trim( upper_value ) == 'fixed'                 ) then\n            param = galahad_fixed\n         else if ( trim( upper_value ) == 'range'                 ) then\n            param = galahad_range\n         else if ( trim( upper_value ) == 'upper'                 ) then\n            param = galahad_upper\n         else if ( trim( upper_value ) == 'lower'                 ) then\n            param = galahad_lower\n         else if ( trim( upper_value ) == 'free'                  ) then\n            param = galahad_free\n         else if ( trim( upper_value ) == 'positive'              ) then\n            param = galahad_positive\n         else if ( trim( upper_value ) == 'negative'              ) then\n            param = galahad_negative\n         else if ( trim( upper_value ) == 'success'               ) then\n            param = galahad_success\n         else if ( trim( upper_value ) == 'memory_full'           ) then\n            param = galahad_memory_full\n         else if ( trim( upper_value ) == 'could_not_write'       ) then\n            param = galahad_could_not_write\n         else if ( trim( upper_value ) == 'file_not_opened'       ) then\n            param = galahad_file_not_opened\n         else if ( trim( upper_value ) == 'exact'                 ) then\n            param = galahad_exact\n         else if ( trim( upper_value ) == 'forward'               ) then\n            param = galahad_forward\n         else if ( trim( upper_value ) == 'central'               ) then\n            param = galahad_central\n         else if ( trim( upper_value ) == 'bfgs'                  ) then\n            param = galahad_bfgs\n         else if ( trim( upper_value ) == 'dfp'                   ) then\n            param = galahad_dfp\n         else if ( trim( upper_value ) == 'psb'                   ) then\n            param = galahad_psb\n         else if ( trim( upper_value ) == 'sr1'                   ) then\n            param = galahad_sr1\n         else if ( trim( upper_value ) == 'cg'                    ) then\n            param = galahad_cg\n         else if ( trim( upper_value ) == 'diagonal_cg'           ) then\n            param = galahad_diagonal_cg\n         else if ( trim( upper_value ) == 'users_cg'              ) then\n            param = galahad_users_cg\n         else if ( trim( upper_value ) == 'expanding_band_cg'     ) then\n            param = galahad_expanding_band_cg\n         else if ( trim( upper_value ) == 'munksgaard_cg'         ) then\n            param = galahad_munksgaard_cg\n         else if ( trim( upper_value ) == 'schnabel_eskow_cg'     ) then\n            param = galahad_schnabel_eskow_cg\n         else if ( trim( upper_value ) == 'gmps_cg'               ) then\n            param = galahad_gmps_cg\n         else if ( trim( upper_value ) == 'band_cg'               ) then\n            param = galahad_band_cg\n         else if ( trim( upper_value ) == 'lin_more_cg'           ) then\n            param = galahad_lin_more_cg\n         else if ( trim( upper_value ) == 'multifrontal'          ) then\n            param = galahad_multifrontal\n         else if ( trim( upper_value ) == 'modified_multifrontal' ) then\n            param = galahad_modified_multifrontal\n         else if ( trim( upper_value ) == 'banded'                ) then\n            param = galahad_banded\n         else if ( trim( upper_value ) == 'automatic'             ) then\n            param = galahad_automatic\n         else if ( trim( upper_value ) == 'user_defined'          ) then\n            param = galahad_user_defined\n         else if ( trim( upper_value ) == 'never'                 ) then\n            param = galahad_never\n         else if ( trim( upper_value ) == 'initial'               ) then\n            param = galahad_initial\n         else if ( trim( upper_value ) == 'always'                ) then\n            param = galahad_always\n         else if ( trim( upper_value ) == 'gauss_newton'          ) then\n            param = galahad_gauss_newton\n         else if ( trim( upper_value ) == 'newton'                ) then\n            param = galahad_newton\n         else if ( trim( upper_value ) == 'adaptive'              ) then\n            param = galahad_adaptive\n         else if ( trim( upper_value ) == 'full'                  ) then\n            param = galahad_full\n         else if ( trim( upper_value ) == 'current'               ) then\n            param = galahad_current\n         else if ( trim( upper_value ) == 'smallest'              ) then\n            param = galahad_smallest\n         else if ( trim( upper_value ) == 'best_fit'              ) then\n            param = galahad_best_fit\n         else if ( trim( upper_value ) == 'best_reduction'        ) then\n            param = galahad_best_reduction\n         else if ( trim( upper_value ) == '1' ) then\n            param = galahad_1\n         else if ( trim( upper_value ) == '2' ) then\n            param = galahad_2\n         else if ( trim( upper_value ) == '3' ) then\n            param = galahad_3\n         else if ( trim( upper_value ) == '4' ) then\n            param = galahad_4\n         else if ( trim( upper_value ) == '5' ) then\n            param = galahad_5\n         else if ( trim( upper_value ) == '6' ) then\n            param = galahad_6\n         else if ( trim( upper_value ) == '7' ) then\n            param = galahad_7\n         else if ( trim( upper_value ) == '8' ) then\n            param = galahad_8\n         else if ( trim( upper_value ) == '9' ) then\n            param = galahad_9\n         else if ( trim( upper_value ) == '10' ) then\n            param = galahad_10\n         else if ( trim( upper_value ) == '11' ) then\n            param = galahad_11\n         else if ( trim( upper_value ) == '12' ) then\n            param = galahad_12\n         else\n            write( errout, * )                                                 &\n                 ' *** specfile warning: symbol value ', trim( upper_value ) \n            write( errout, * ) '     not recognized at line ', specitem%line,  &\n                'in the specification file.'\n            write( errout, * ) '     corresponding assignment skipped.'\n         end if\n      end if\n         \n      return\n\n      end subroutine specfile_assign_symbol\n"}
{"id": 1342, "subroutine": "      subroutine specfile_upper_case( string, length )\n\n!     convert any lower case characters in the character array string to\n!     upper case. this is not very efficient and maybe should be replaced\n!     by a hashing routine.\n\n!     arguments:\n\n      integer, intent( in ) :: length\n\n!            the length of the string to convert\n\n      character ( len = length ), intent( inout ) :: string\n\n!            the string to convert\n\n!     programming: n. gould, 1991, with modifs by ph. toint, january 2002.\n!\n!===============================================================================\n\n!     local variables\n\n      integer :: i, letter\n      character, dimension( 26 ) :: lower, upper\n\n      data lower / 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',         &\n                   'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',         &\n                   'u', 'v', 'w', 'x', 'y', 'z' /\n      data upper / 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',         &\n                   'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',         &\n                   'u', 'v', 'w', 'x', 'y', 'z' /\n\n!     loop over each character in the string\n\n      do i = 1, length\n\n!     see if the current letter is lower case. if so replace it by its\n!     upper case counterpart\n\n         do letter = 1, 26\n            if ( string( i:i ) == lower( letter ) ) then\n               string( i:i )   =  upper( letter )\n               exit\n            end if\n         end do\n\n      end do\n\n      return\n\n      end subroutine specfile_upper_case\n"}
{"id": 1343, "subroutine": "      subroutine specfile_read( device, algo_name, spec, lspec, errout )\n\n!     reads the content of a specification files and performs the assignment\n!     of values associated with given keywords to the corresponding control\n!     parameters.\n\n!     arguments\n\n      integer, intent( in ) :: device\n\n!            the device number associated with the specification file. note\n!            that the file must be open for input.  the file is rewinded\n!            before use.\n\n      character( len = 16 ), intent ( in ) :: algo_name\n\n      integer, intent( in ) :: lspec\n\n      type ( specfile_item_type ), dimension( lspec ), intent( inout ) :: spec\n\n      integer, intent( in ) :: errout\n\n!     programming: ph. toint, december 2001.\n!\n!===============================================================================\n\n!     local variables\n\n      integer               :: ios, break, endvalue, lenline, nline, ikey\n      logical               :: applicable, found, opened\n      character( len = 30 ) :: value\n      character( len = 50 ) :: keyword\n      character( len = 80 ) :: line\n\n!     unset all items in the spec list\n\n      do ikey = 1, lspec\n         spec( ikey )%line = 0\n      end do\n\n!     check that the specfile is open\n\n      inquire( unit = device, opened = opened )\n      if ( .not. opened ) then\n         write( errout, * )                                                    &\n              ' *** specfile warning: specfile not opened on device', device,'.'\n         write( errout, * ) '     corresponding specifications skipped.'\n         return\n      end if\n\n!     assume a priori that the line is not applicable to presolve\n\n      applicable = .false.\n\n!     start at the beginning of the file\n\n      rewind device\n\n!     make sure all keywords are in upper case \n!     (in order to make keyword matching case insensitive)\n\n      do ikey = 1, lspec\n         call specfile_upper_case( spec( ikey )%keyword,                       &\n                                   len_trim( spec( ikey )%keyword )  )\n      end do\n\n!     loop over the file lines\n\n      nline = 0\n      do \n\n!        read the next line\n\n         read( device, '(a80)', iostat = ios ) line\n         if ( ios /= 0 ) return\n\n!        increment the line number\n\n         nline = nline + 1\n\n!        remove the unnecessary blanks and compute the position of the\n!        second keyword\n\n         call specfile_squeeze( line, lenline, break ) \n\n!        if the line is commented out or blank, ignore it\n\n         if ( line( 1:1 ) == '!' .or. line( 1:1 ) == '*' .or. &\n              lenline == 0                                    ) cycle\n\n!        consider first the case where the line is applicable\n\n         if ( applicable ) then\n\n!           if this is the end of the specifications, ignore what follows\n\n            if ( line( 1:3 ) == 'end' ) return\n\n!           otherwise, isolate the keyword ...\n\n            keyword = line( 1:break-1 )\n\n!           ... convert it to upper case...\n\n            call specfile_upper_case( keyword, break-1 )\n\n!           ... and isolate the associated string value\n\n            if ( break > lenline ) then\n               value = ''\n            else\n               endvalue = index( line( break:lenline ), ' ' )\n               if ( endvalue == 0 ) then\n                  value = line( break:lenline )\n               else\n                  value = line( break:endvalue )\n               end if\n            end if\n\n!           perform the implied assignment\n\n            found = .false.\n            do ikey = 1, lspec\n               if ( keyword == spec( ikey )%keyword ) then\n                  spec( ikey )%line  = nline\n                  spec( ikey )%value = value\n                  found = .true.\n                  exit\n               end if\n            end do\n            \n            if ( .not. found ) then\n               write( errout, * )                                              &\n                    ' *** specfile warning: keyword ', trim( keyword )\n               write( errout, * ) '     not recognized in line',               &\n                    nline, 'of the specification file.'\n               write( errout, * ) '     corresponding assignment skipped.'\n            end if\n\n!        check for the beginning of the specifications\n\n         else if ( line( 1:5 ) ==  'begin' ) then\n            if ( index( line, trim( algo_name ) ) == break ) applicable = .true.\n         end if\n\n      end do\n\n      return\n\n      end subroutine specfile_read\n"}
{"id": 1344, "subroutine": "  subroutine save_forward_arrays_undoatt(iteration_on_subset)\n\n  use specfem_par\n\n  implicit none\n\n  ! local parameters\n  integer :: iteration_on_subset,iteration_on_subset_tmp\n\n\n  ! current subset iteration\n  iteration_on_subset_tmp = iteration_on_subset\n\n  ! saves frame of the forward simulation\n\n  write(outputname,'(a,i6.6,a,i6.6,a)') 'proc',myrank,'_save_frame_at',iteration_on_subset_tmp,'.bin'\n  open(unit=iout_undo_att  ,file='output_files/'//outputname, &\n       status='unknown',form='unformatted',action='write',iostat=ier)\n  if( ier /= 0 ) call exit_mpi('error opening file proc***_save_frame_at** for writing')\n\n  if( any_acoustic ) then\n    write( iout_undo_att ) potential_dot_dot_acoustic\n    write( iout_undo_att ) potential_dot_acoustic\n    write( iout_undo_att ) potential_acoustic\n  endif\n\n  if( any_elastic ) then\n    write(iout_undo_att ) accel_elastic\n    write(iout_undo_att ) veloc_elastic\n    write(iout_undo_att ) displ_elastic\n\n    if( attenuation_viscoelastic_solid ) then\n      write(iout_undo_att ) e1\n      write(iout_undo_att ) e11\n      write(iout_undo_att ) e13\n    endif\n  endif\n\n  close(iout_undo_att)\n\n  end subroutine save_forward_arrays_undoatt\n"}
{"id": 1345, "subroutine": "  subroutine read_forward_arrays_undoatt(iteration_on_subset)\n\n! reads in saved wavefields\n\n  use specfem_par\n\n  implicit none\n\n  ! local parameters\n  integer :: iteration_on_subset,iteration_on_subset_tmp\n\n  ! current subset iteration\n  iteration_on_subset_tmp = nstep/nt_dump_attenuation - iteration_on_subset + 1\n\n  ! reads in saved wavefield\n  write(outputname,'(a,i6.6,a,i6.6,a)') 'proc',myrank,'_save_frame_at',iteration_on_subset_tmp,'.bin'\n\n  ! opens corresponding snapshot file for reading\n  open(unit=iin_undo_att,file='output_files/'//outputname, &\n       status='old',action='read',form='unformatted',iostat=ier)\n  if( ier /= 0 ) call exit_mpi('error opening file proc***_save_frame_at** for reading')\n\n  if( any_acoustic ) then\n    read( iin_undo_att ) b_potential_dot_dot_acoustic\n    read( iin_undo_att ) b_potential_dot_acoustic\n    read( iin_undo_att ) b_potential_acoustic\n  endif\n\n  if( any_elastic ) then\n    read(iin_undo_att ) b_accel_elastic\n    read(iin_undo_att ) b_veloc_elastic\n    read(iin_undo_att ) b_displ_elastic\n\n    if( attenuation_viscoelastic_solid ) then\n      read(iin_undo_att ) b_e1\n      read(iin_undo_att ) b_e11\n      read(iin_undo_att ) b_e13\n    endif\n  endif\n\n  close(iout_undo_att)\n\n  end subroutine read_forward_arrays_undoatt\n"}
{"id": 1346, "subroutine": "    subroutine sub2\n      use intermediate\n      implicit none\n    end subroutine sub2\n"}
{"id": 1347, "subroutine": "subroutine sub\n  use intermediate\n  implicit none\n  print *, a\nend subroutine\n"}
{"id": 1348, "subroutine": "subroutine run_me(a, i, z)\n  implicit none\n\n  real, intent(in) :: a\n  integer, intent(in) :: i\n  complex, intent(in) :: z\n\n  call check_equal_i (i**0, 1)\n  call check_equal_i (i**1, i)\n  call check_equal_i (i**2, i*i)\n  call check_equal_i (i**3, i*(i**2))\n\n  ! i has default integer kind.\n  call check_equal_i (int(i**0_8,kind=kind(i)), 1)\n  call check_equal_i (int(i**1_8,kind=kind(i)), i)\n  call check_equal_i (int(i**2_8,kind=kind(i)), i*i)\n  call check_equal_i (int(i**3_8,kind=kind(i)), i*i*i)\n\n  call check_equal_r (a**0.0, 1.0)\n  call check_equal_r (a**1.0, a)\n  call check_equal_r (a**2.0, a*a)\n  call check_equal_r (a**3.0, a*(a**2))\n  call check_equal_r (a**(-1.0), 1/a)\n  call check_equal_r (a**(-2.0), (1/a)*(1/a))\n\n  call check_equal_r (a**0, 1.0)\n  call check_equal_r (a**1, a)\n  call check_equal_r (a**2, a*a)\n  call check_equal_r (a**3, a*(a**2))\n  call check_equal_r (a**(-1), 1/a)\n  call check_equal_r (a**(-2), (1/a)*(1/a))\n\n  call check_equal_r (a**0_8, 1.0)\n  call check_equal_r (a**1_8, a)\n  call check_equal_r (a**2_8, a*a)\n  call check_equal_r (a**3_8, a*(a**2))\n  call check_equal_r (a**(-1_8), 1/a)\n  call check_equal_r (a**(-2_8), (1/a)*(1/a))\n\n  call check_equal_c (z**0.0, (1.0,0.0))\n  call check_equal_c (z**1.0, z)\n  call check_equal_c (z**2.0, z*z)\n  call check_equal_c (z**3.0, z*(z**2))\n  call check_equal_c (z**(-1.0), 1/z)\n  call check_equal_c (z**(-2.0), (1/z)*(1/z))\n\n  call check_equal_c (z**(0.0,0.0), (1.0,0.0))\n  call check_equal_c (z**(1.0,0.0), z)\n  call check_equal_c (z**(2.0,0.0), z*z)\n  call check_equal_c (z**(3.0,0.0), z*(z**2))\n  call check_equal_c (z**(-1.0,0.0), 1/z)\n  call check_equal_c (z**(-2.0,0.0), (1/z)*(1/z))\n\n  call check_equal_c (z**0, (1.0,0.0))\n  call check_equal_c (z**1, z)\n  call check_equal_c (z**2, z*z)\n  call check_equal_c (z**3, z*(z**2))\n  call check_equal_c (z**(-1), 1/z)\n  call check_equal_c (z**(-2), (1/z)*(1/z))\n\n  call check_equal_c (z**0_8, (1.0,0.0))\n  call check_equal_c (z**1_8, z)\n  call check_equal_c (z**2_8, z*z)\n  call check_equal_c (z**3_8, z*(z**2))\n  call check_equal_c (z**(-1_8), 1/z)\n  call check_equal_c (z**(-2_8), (1/z)*(1/z))\n\n\ncontains\n\n  subroutine check_equal_r (a, b)\n    real, intent(in) :: a, b\n    if (abs(a - b) > 1.e-5 * abs(b)) call abort\n  end subroutine check_equal_r\n\n  subroutine check_equal_c (a, b)\n    complex, intent(in) :: a, b\n    if (abs(a - b) > 1.e-5 * abs(b)) call abort\n  end subroutine check_equal_c\n\n  subroutine check_equal_i (a, b)\n    integer, intent(in) :: a, b\n    if (a /= b) call abort\n  end subroutine check_equal_i\n\nend subroutine run_me\n"}
{"id": 1349, "subroutine": "subroutine foo(a)\n  implicit none\n\n  real, intent(in) :: a\n  integer :: i\n  complex :: z\n\n  ! integer\n  call gee_i(i**0_1)\n  call gee_i(i**1_1)\n  call gee_i(i**2_1)\n  call gee_i(i**3_1)\n  call gee_i(i**(-1_1))\n  call gee_i(i**(-2_1))\n  call gee_i(i**(-3_1))\n  call gee_i(i**huge(0_1))\n  call gee_i(i**(-huge(0_1)))\n  call gee_i(i**(-huge(0_1)-1_1))\n\n  call gee_i(i**0_2)\n  call gee_i(i**1_2)\n  call gee_i(i**2_2)\n  call gee_i(i**3_2)\n  call gee_i(i**(-1_2))\n  call gee_i(i**(-2_2))\n  call gee_i(i**(-3_2))\n  call gee_i(i**huge(0_2))\n  call gee_i(i**(-huge(0_2)))\n  call gee_i(i**(-huge(0_2)-1_2))\n\n  call gee_i(i**0_4)\n  call gee_i(i**1_4)\n  call gee_i(i**2_4)\n  call gee_i(i**3_4)\n  call gee_i(i**(-1_4))\n  call gee_i(i**(-2_4))\n  call gee_i(i**(-3_4))\n  call gee_i(i**huge(0_4))\n  call gee_i(i**(-huge(0_4)))\n  call gee_i(i**(-huge(0_4)-1_4))\n\n  call gee_i(i**0_8) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**1_8) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**2_8) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**3_8) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**(-1_8)) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**(-2_8)) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**(-3_8)) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**huge(0_8)) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**(-huge(0_8))) ! { dg-warning \"type mismatch in argument\" }\n  call gee_i(i**(-huge(0_8)-1_8)) ! { dg-warning \"type mismatch in argument\" }\n\n  ! real\n  call gee_r(a**0_1)\n  call gee_r(a**1_1)\n  call gee_r(a**2_1)\n  call gee_r(a**3_1)\n  call gee_r(a**(-1_1))\n  call gee_r(a**(-2_1))\n  call gee_r(a**(-3_1))\n  call gee_r(a**huge(0_1))\n  call gee_r(a**(-huge(0_1)))\n  call gee_r(a**(-huge(0_1)-1_1))\n\n  call gee_r(a**0_2)\n  call gee_r(a**1_2)\n  call gee_r(a**2_2)\n  call gee_r(a**3_2)\n  call gee_r(a**(-1_2))\n  call gee_r(a**(-2_2))\n  call gee_r(a**(-3_2))\n  call gee_r(a**huge(0_2))\n  call gee_r(a**(-huge(0_2)))\n  call gee_r(a**(-huge(0_2)-1_2))\n\n  call gee_r(a**0_4)\n  call gee_r(a**1_4)\n  call gee_r(a**2_4)\n  call gee_r(a**3_4)\n  call gee_r(a**(-1_4))\n  call gee_r(a**(-2_4))\n  call gee_r(a**(-3_4))\n  call gee_r(a**huge(0_4))\n  call gee_r(a**(-huge(0_4)))\n  call gee_r(a**(-huge(0_4)-1_4))\n\n  call gee_r(a**0_8)\n  call gee_r(a**1_8)\n  call gee_r(a**2_8)\n  call gee_r(a**3_8)\n  call gee_r(a**(-1_8))\n  call gee_r(a**(-2_8))\n  call gee_r(a**(-3_8))\n  call gee_r(a**huge(0_8))\n  call gee_r(a**(-huge(0_8)))\n  call gee_r(a**(-huge(0_8)-1_8))\n\n  ! complex\n  call gee_z(z**0_1)\n  call gee_z(z**1_1)\n  call gee_z(z**2_1)\n  call gee_z(z**3_1)\n  call gee_z(z**(-1_1))\n  call gee_z(z**(-2_1))\n  call gee_z(z**(-3_1))\n  call gee_z(z**huge(0_1))\n  call gee_z(z**(-huge(0_1)))\n  call gee_z(z**(-huge(0_1)-1_1))\n\n  call gee_z(z**0_2)\n  call gee_z(z**1_2)\n  call gee_z(z**2_2)\n  call gee_z(z**3_2)\n  call gee_z(z**(-1_2))\n  call gee_z(z**(-2_2))\n  call gee_z(z**(-3_2))\n  call gee_z(z**huge(0_2))\n  call gee_z(z**(-huge(0_2)))\n  call gee_z(z**(-huge(0_2)-1_2))\n\n  call gee_z(z**0_4)\n  call gee_z(z**1_4)\n  call gee_z(z**2_4)\n  call gee_z(z**3_4)\n  call gee_z(z**(-1_4))\n  call gee_z(z**(-2_4))\n  call gee_z(z**(-3_4))\n  call gee_z(z**huge(0_4))\n  call gee_z(z**(-huge(0_4)))\n  call gee_z(z**(-huge(0_4)-1_4))\n\n  call gee_z(z**0_8)\n  call gee_z(z**1_8)\n  call gee_z(z**2_8)\n  call gee_z(z**3_8)\n  call gee_z(z**(-1_8))\n  call gee_z(z**(-2_8))\n  call gee_z(z**(-3_8))\n  call gee_z(z**huge(0_8))\n  call gee_z(z**(-huge(0_8)))\n  call gee_z(z**(-huge(0_8)-1_8))\nend subroutine foo\n"}
{"id": 1350, "subroutine": "subroutine gee_i(i)\n  integer :: i\nend subroutine gee_i\n"}
{"id": 1351, "subroutine": "subroutine gee_r(r)\n  real :: r\nend subroutine gee_r\n"}
{"id": 1352, "subroutine": "subroutine gee_z(c)\n  complex :: c\nend subroutine gee_z\n"}
{"id": 1353, "subroutine": "            subroutine cpl_comp_embm(dum_n_atm,dum_n_i_atm,dum_n_j_atm, &\n     &dum_n_i_ocn,dum_n_j_ocn,dum_t,dum_q,dum_sfcatm1)\n              integer(kind=4), intent(in) :: dum_n_j_ocn\n              integer(kind=4), intent(in) :: dum_n_i_ocn\n              integer(kind=4), intent(in) :: dum_n_j_atm\n              integer(kind=4), intent(in) :: dum_n_i_atm\n              integer(kind=4), intent(in) :: dum_n_atm\n              real(kind=8), intent(in) :: dum_t(dum_n_i_atm,dum_n_j_atm)\n              real(kind=8), intent(in) :: dum_q(dum_n_i_atm,dum_n_j_atm)\n              real(kind=8), intent(inout) :: dum_sfcatm1(dum_n_atm,     &\n     &dum_n_i_ocn,dum_n_j_ocn)\n            end subroutine cpl_comp_embm\n"}
{"id": 1354, "subroutine": "      subroutine dawrt1 (v, len, idaf, ns) \r\n      use vast_kind_param,only: double       \r\n      integer, intent(in) :: len \r\n      integer, intent(in) :: idaf \r\n      integer, intent(in) :: ns \r\n      real(double), dimension(len), intent(in) :: v \r\n      end subroutine  \r\n"}
{"id": 1355, "subroutine": "subroutine sum(myarr1,myarr2,ub)\n  integer, pointer :: myarr1(:)\n  integer, pointer :: myarr2(:)\n  integer :: ub\n\n  !$omp simd collapse(2)\n  do i=1,ub\n    myarr1(i) = myarr1(i)+myarr2(i)\n  end do\nend subroutine\n"}
