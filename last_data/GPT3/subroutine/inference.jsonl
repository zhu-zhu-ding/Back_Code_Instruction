{"instruction": "Create a Fortran subroutine named lttb_downsize to downsize a time-series data using the largest-triangle-three-buckets algorithm. The number of input parameters is 2, the test_data type is ['real', 'integer'], and the number of output parameters is 1, the test_data type is ['real, allocatable'].", "code": "Here's a Fortran subroutine named lttb_downsize that downsizes a time-series data using the largest-triangle-three-buckets algorithm:\n\n```fortran\nsubroutine lttb_downsize(input_data, output_data)\n  real, dimension(:), intent(in) :: input_data\n  real, dimension(:), allocatable, intent(out) :: output_data\n  integer :: n, m, i, k, index, bucket_size, num_buckets, a, b, c, max_area_index\n  real :: area, max_area, x, y, min, max, slope, new_slope\n\n  n = size(input_data)\n  m = n / 2\n  allocate(output_data(m))\n\n  output_data(1) = input_data(1)\n  output_data(m) = input_data(n)\n\n  num_buckets = m - 2\n  bucket_size = n / num_buckets\n\n  index = 2\n  do k = 1, num_buckets - 1\n    a = (k - 1) * bucket_size + 1\n    b = k * bucket_size\n    c = (k + 1) * bucket_size\n\n    max_area = 0.0\n    max_area_index = a\n\n    do i = a + 1, c - 1\n      x = real(i - a)\n      y = input_data(i)\n      min = input_data(a)\n      max = input_data(c)\n\n      if (max - min == 0.0) then\n        slope = 0.0\n      else\n        slope = (y - min) / (x / (c - a))\n      end if\n\n      new_slope = (max - min) / real(c - a)\n\n      area = abs(x * (y - min) - x * slope) / 2.0\n\n      if (area > max_area .and. slope > new_slope) then\n        max_area = area\n        max_area_index = i\n      end if\n    end do\n\n    output_data(index) = input_data(max_area_index)\n    index = index + 1\n  end do\n\nend subroutine lttb_downsize\n```\n\nThis subroutine takes in the input_data time-series data and downsizes it using the largest-triangle-three-buckets algorithm. The downsized data is stored in the output_data array. The input_data is of type real and the output_data is of type real and allocatable."}
{"instruction": "Write a Fortran subroutine named eisensteinhu that computes the transfer function for the matter power spectrum using the Eisenstein and Hu (1998) model. The subroutine takes 3 input parameters of type double precision (ak, omegamh2, fb) and returns 1 output parameter of type double precision (t).", "code": "Here's a Fortran subroutine that computes the transfer function for the matter power spectrum using the Eisenstein and Hu (1998) model:\n\n```fortran\nsubroutine eisensteinhu(ak, omegamh2, fb, t)\n  implicit none\n  double precision, intent(in) :: ak, omegamh2, fb\n  double precision, intent(out) :: t\n\n  double precision :: q, gamma, omegab, omegac, omegak, omegav, hubble, theta, alpha, beta, sound, s, r, k, y, z, g, qeff\n\n  omegab = 0.046\n  omegac = omegamh2 - omegab\n  omegak = 1.0 - omegamh2\n  omegav = 1.0 - omegamh2 - omegak\n\n  hubble = 0.1 * sqrt(omegamh2 / ak)\n  theta = 2.728 / 2.7\n  q = ak * hubble / 0.7\n  gamma = omegamh2 * hubble\n  sound = 44.5 * log(9.83 / gamma) / sqrt(1.0 + 10.0 * (gamma / 0.7)**0.75)\n  r = 31.5 * omegab * hubble * sqrt(sound) / (1.0 + 10.0 * (gamma / 0.7)**0.75)\n  k = 0.0746 * q * (omegamh2 / 0.15)**0.22 * (1.0 + r)**(-0.57)\n\n  y = 1.0 / (1.0 + z)\n  g = y * (-6.0 * sqrt(1.0 + y) / (1.0 + 2.0 * sqrt(1.0 + y)) + 2.0 * log((sqrt(1.0 + y) + 1.0) / (sqrt(1.0 + y) - 1.0)))\n  qeff = q / (1.0 + g * (omegak / (y**2) + (1.0 + y) * (0.15 * omegab + y * omegac)))\n\n  alpha = 1.0 - 0.328 * log(431.0 * omegamh2) * omegab / omegamh2 + 0.38 * log(22.3 * omegamh2) * (omegab / omegamh2)**2\n  beta = 0.944 / (1.0 + (458.0 * omegamh2)**(-0.708))\n  s = omegamh2 / (1.0 + (beta / qeff**2) + (alpha / qeff) * (qeff / k)**(3.0))\n\n  t = log(exp(1.0) + 1.84 * s * (1.0 + s)**(-0.5)) / (1.0 + 2.0 * s)\nend subroutine eisensteinhu\n```\n\nYou can call this subroutine from your main program and pass the input parameters ak, omegamh2, and fb to compute the transfer function t."}
{"instruction": "Write a Fortran subroutine named zdepth to calculate the vertical grid and depths in an ocean model. The subroutine takes 5 input parameters of type real, real, real, real, and integer, and returns 5 output parameters of type real, real, real, real, and real.", "code": "Here's a Fortran subroutine named zdepth that calculates the vertical grid and depths in an ocean model:\n\n```fortran\nsubroutine zdepth(h, zeta, theta_s, theta_b, N, Hz, z_r, z_w)\n  real, intent(in) :: h, zeta, theta_s, theta_b\n  integer, intent(in) :: N\n  real, intent(out) :: Hz(N), z_r(N), z_w(N+1)\n\n  ! Calculate vertical grid spacing\n  real :: alpha, beta\n  real :: h_c, c1, c2\n  real :: ds, cff1, cff2\n  integer :: k\n\n  alpha = 1.0\n  beta = 0.0\n  h_c = min(h, zeta)\n  c1 = (1.0 - cosh(theta_s*alpha))/(cosh(theta_s*alpha))\n  c2 = (tanh(alpha*(h_c + h_c)) - alpha*tanh(alpha*h_c))/(tanh(alpha*h_c))\n  ds = (h_c/N)\n\n  do k = 1, N\n    cff1 = sinh(theta_s*alpha*ds*(N+1-k))/sinh(theta_s*alpha)\n    cff2 = tanh(theta_s*(alpha*(ds*(N+1-k) - h_c) + h_c))\n    Hz(k) = h_c*theta_b + (h - h_c)*((theta_s*alpha*c1 + beta*c2)*cff1 + (1.0 - theta_s*alpha)*cff2)/((theta_b - 1.0)*c1 + beta*c2)\n  end do\n\n  ! Calculate depths\n  do k = 1, N\n    z_r(k) = -sum(Hz(1:k))\n    z_w(k) = -sum(Hz(1:k-1))\n  end do\n  z_w(N+1) = 0.0\nend subroutine zdepth\n```\n\nIn this subroutine, the input parameters are h (bottom depth), zeta (free-surface height), theta_s (surface stretching parameter), theta_b (bottom stretching parameter), and N (number of vertical levels). The output parameters are Hz (vertical grid spacing), z_r (depth at vertical levels), and z_w (depth at vertical interfaces)."}
{"instruction": "Create a Fortran subroutine named local_minima_potential_energy to identify local minima in potential energy data. It takes 5 input parameters: n_nodes (integer), ktot (integer), t_ind (integer array of size ktot), t_pe (double precision array of size n_nodes), t_start (integer array of size n_nodes+1), and returns 1 output parameter: is_minimum (logical array of size n_nodes).", "code": "Here's a Fortran subroutine that identifies local minima in potential energy data:\n\n```fortran\nsubroutine local_minima_potential_energy(n_nodes, ktot, t_ind, t_pe, t_start, is_minimum)\n  integer, intent(in) :: n_nodes, ktot\n  integer, intent(in) :: t_ind(ktot)\n  real*8, intent(in) :: t_pe(n_nodes)\n  integer, intent(in) :: t_start(n_nodes+1)\n  logical, intent(out) :: is_minimum(n_nodes)\n\n  ! Local variables\n  integer :: i, j\n  logical :: is_min\n\n  ! Initialize is_minimum array\n  is_minimum = .false.\n\n  do i = 1, n_nodes\n    is_min = .true.\n    do j = t_start(i) + 1, t_start(i+1) - 2\n      if (t_pe(t_ind(j)) <= t_pe(t_ind(j-1)) .or. &\n          t_pe(t_ind(j)) <= t_pe(t_ind(j+1))) then\n        is_min = .false.\n        exit\n      end if\n    end do\n    is_minimum(i) = is_min\n  end do\n\nend subroutine local_minima_potential_energy\n```\n\nThis subroutine takes in the number of nodes (n_nodes), the total number of data points (ktot), the indices of the data points (t_ind), the potential energy values (t_pe), and the start indices for each node (t_start). It then calculates the local minima in the potential energy data and stores the results in the is_minimum array."}
{"instruction": "Provide a Fortran subroutine named calc_f_pendula to compute the forces acting on a pendulum system. \n\nThe subroutine takes 10 input parameters:\n1. bc_flag (integer) - indicates the boundary condition flag\n2. lowerbound (integer) - lower bound of the dimension array\n3. upperbound (integer) - upper bound of the dimension array\n4. m (real, dimension(2)) - mass values\n5. b (real, dimension(1)) - damping coefficient\n6. p (real, dimension(1)) - external force\n7. g (real) - acceleration due to gravity\n8. k (real, dimension(1)) - spring constant\n9. l (real, dimension(1)) - length of pendulum\n10. x (real, dimension(lowerbound:upperbound)) - displacement array\n\nThe subroutine has 1 output parameter:\n1. f (real, dimension(2)) - forces acting on the pendulum system\n\nThe subroutine performs calculations based on the given boundary conditions (bc_flag) and computes the forces (f) acting on the pendulum system.\n\nPlease note that the code snippet provided is incomplete and may require additional code to be functional.", "code": "Here's a possible implementation of the calc_f_pendula subroutine in Fortran:\n\n```fortran\nsubroutine calc_f_pendula(bc_flag, lowerbound, upperbound, m, b, p, g, k, l, x, f)\n  integer, intent(in) :: bc_flag, lowerbound, upperbound\n  real, intent(in) :: m(2), b(1), p(1), g, k(1), l(1), x(lowerbound:upperbound)\n  real, intent(out) :: f(2)\n\n  ! Additional variable declarations\n  real :: force_spring, force_damping, force_external\n\n  ! Calculate forces based on boundary conditions\n  if (bc_flag == 1) then\n    ! Boundary condition 1 calculations\n    force_spring = -k(1) * x(1)\n    force_damping = -b(1) * x(2)\n    force_external = p(1)\n  else\n    ! Other boundary condition calculations\n    force_spring = -k(1) * x(1)\n    force_damping = -b(1) * x(2)\n    force_external = p(1)\n  end if\n\n  ! Calculate gravitational force\n  f(1) = m(1) * g - force_spring\n  f(2) = m(2) * g - force_damping + force_external\nend subroutine calc_f_pendula\n```\n\nThis subroutine takes the input parameters bc_flag, lowerbound, upperbound, m, b, p, g, k, l, and x, and computes the forces acting on the pendulum system based on the given boundary conditions. The forces are stored in the output parameter f. Note that the actual boundary condition calculations are not provided and need to be implemented based on the specific requirements of the pendulum system."}
{"instruction": "Create a Fortran subroutine named look_up_grib_code that takes an integer input parameter and returns a character string. The purpose of this subroutine is to look up and assign the appropriate variable type based on the given grib code number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=*)'].", "code": "Here's a Fortran subroutine named look_up_grib_code that takes an integer input parameter and returns a character string:\n\n```fortran\nsubroutine look_up_grib_code(grib_code, variable_type)\n  integer, intent(in) :: grib_code\n  character(len=*) :: variable_type\n\n  select case(grib_code)\n    case(1)\n      variable_type = 'Temperature'\n    case(2)\n      variable_type = 'Pressure'\n    case(3)\n      variable_type = 'Humidity'\n    case default\n      variable_type = 'Unknown'\n  end select\nend subroutine look_up_grib_code\n```\n\nIn this subroutine, the input parameter grib_code is an integer that represents the grib code number. The output parameter variable_type is a character string that will be assigned the appropriate variable type based on the given grib code number. The select case statement is used to check the value of grib_code and assign the corresponding variable type to variable_type. If the grib code number does not match any of the cases, the variable type is set to 'Unknown'."}
{"instruction": "Create a Fortran subroutine named greg2modjul to convert the Gregorian calendar date to the modified Julian date. The subroutine takes 6 input parameters of type integer (year, month, day, hour, minute, sec) and returns 1 output parameter of type real*8 (mjd).", "code": "Here's a Fortran subroutine named greg2modjul that converts the Gregorian calendar date to the modified Julian date:\n\n```fortran\nsubroutine greg2modjul(year, month, day, hour, minute, sec, mjd)\n  implicit none\n  integer, intent(in) :: year, month, day, hour, minute, sec\n  real*8, intent(out) :: mjd\n  integer :: a, b, c, d, m\n\n  a = (14 - month) / 12\n  y = year - a\n  m = month + 12*a - 3\n  b = y / 100\n  c = y - 100*b\n  d = (146097*b) / 4 + (1461*c) / 4 + (153*m + 2) / 5 + day - 678882\n  mjd = d + (hour - 12) / 24.0d0 + minute / 1440.0d0 + sec / 86400.0d0\nend subroutine greg2modjul\n```\n\nYou can use this subroutine by passing the year, month, day, hour, minute, and second as input parameters, and it will return the modified Julian date in the output parameter `mjd`."}
{"instruction": "Create a Fortran subroutine named modjul2greg to convert the modified Julian date (mjd) into the corresponding Gregorian calendar date, including year, month, day, hour, minute, and second. The input parameter is a real*8 type, and the output parameters are six integers representing year, month, day, hour, minute, and second.", "code": "Here's a Fortran subroutine named modjul2greg to convert the modified Julian date (mjd) into the corresponding Gregorian calendar date:\n\n```fortran\nsubroutine modjul2greg(mjd, year, month, day, hour, minute, second)\n  real*8, intent(in) :: mjd\n  integer, intent(out) :: year, month, day, hour, minute, second\n\n  ! Constants\n  real*8 :: jd, jdfrac, z, f, a, b, c, d, e\n  integer :: alpha, beta\n\n  ! Convert MJD to Julian Date\n  jd = mjd + 2400000.5\n  jdfrac = jd - int(jd)\n\n  if (jd < 2299161.0) then\n    alpha = jd\n  else\n    z = jd\n    a = int((z - 1867216.25) / 36524.25)\n    a = z + 1 + a - int(a / 4)\n  end if\n\n  b = a + 1524\n  c = int((b - 122.1) / 365.25)\n  d = int(365.25 * c)\n  e = int((b - d) / 30.6001)\n\n  ! Calculate Year, Month, and Day\n  day = int(b - d - int(30.6001 * e))\n  if (e < 14) then\n    month = e - 1\n  else\n    month = e - 13\n  end if\n  if (month > 2) then\n    year = c - 4716\n  else\n    year = c - 4715\n  end if\n\n  ! Calculate Hour, Minute, and Second\n  beta = int(jdfrac * 24.0)\n  hour = beta\n  beta = int((jdfrac * 24.0 - hour) * 60.0)\n  minute = beta\n  beta = int(((jdfrac * 24.0 - hour) * 60.0 - beta) * 60.0)\n  second = beta\n\nend subroutine modjul2greg\n```\n\nYou can use this subroutine by passing the modified Julian date as the input parameter and receiving the corresponding Gregorian calendar date in the output parameters."}
{"instruction": "Create a Fortran subroutine named dccon1 to calculate station geometry constants for a point source. The subroutine takes 5 input parameters of type real*8: x, y, d, sd, and cd. It also provides 5 output parameters of type real*8: r, p, q, s, and t. The subroutine's purpose is to calculate the values of r, p, q, s, and t based on the input parameters x, y, d, sd, and cd. Use the imperative tone in the instructions.", "code": "Here's a Fortran subroutine named dccon1 to calculate station geometry constants for a point source:\n\n```fortran\nsubroutine dccon1(x, y, d, sd, cd, r, p, q, s, t)\n  real*8, intent(in) :: x, y, d, sd, cd\n  real*8, intent(out) :: r, p, q, s, t\n\n  ! Calculate station geometry constants\n  r = sqrt(x**2 + y**2)\n  p = atan2(y, x)\n  q = d * sin(sd) / sin(pi - sd - cd)\n  s = d * sin(cd) / sin(pi - sd - cd)\n  t = d * cos(sd) / sin(pi - sd - cd)\nend subroutine dccon1\n```\n\nTo use this subroutine, simply call it with the input parameters x, y, d, sd, and cd, and it will calculate the values of r, p, q, s, and t based on those inputs."}
{"instruction": "Create a Fortran subroutine named eq14_xy to compute the equations (14) for x11, x32, y11, and y32. The subroutine takes 5 input parameters of type real*8, real*8, integer, integer, and real*8. It returns 4 output parameters of type real*8 for x11, x32, y11, and y32. The subroutine calculates the values based on the provided station coordinates and conditions kxi and ket.", "code": "Here's a Fortran subroutine named eq14_xy that computes the equations (14) for x11, x32, y11, and y32:\n\n```fortran\nsubroutine eq14_xy(x, y, kxi, ket, x11, x32, y11, y32)\n  real*8, intent(in) :: x, y\n  integer, intent(in) :: kxi, ket\n  real*8, intent(out) :: x11, x32, y11, y32\n\n  ! Calculate x11, x32, y11, and y32 based on the provided station coordinates and conditions kxi and ket\n  ! ... (insert calculation here)\n\n  ! Example calculation:\n  x11 = x * kxi\n  x32 = x / kxi\n  y11 = y * ket\n  y32 = y / ket\n\nend subroutine eq14_xy\n```\n\nIn this example, the subroutine takes 5 input parameters x, y, kxi, and ket of type real*8 and integer, and returns 4 output parameters x11, x32, y11, and y32 of type real*8. The actual calculation for x11, x32, y11, and y32 based on the provided station coordinates and conditions kxi and ket should be inserted in place of the comment."}
{"instruction": "Write a Fortran subroutine named stop_acc_data to initialize an accumulation process. The subroutine takes 1 input parameter of type real and returns 2 output parameters, one of type real and the other of type integer. The input parameter represents a missing value, while the output parameters store the accumulation of data and the status of accumulation (0/1) respectively.", "code": "Here's a possible implementation of the stop_acc_data subroutine in Fortran:\n\n```fortran\nsubroutine stop_acc_data(missing_value, accumulation, status)\n  real, intent(in) :: missing_value\n  real, intent(out) :: accumulation\n  integer, intent(out) :: status\n\n  ! Initialize accumulation and status\n  accumulation = 0.0\n  status = 0\n\nend subroutine stop_acc_data\n```\n\nIn this subroutine, the input parameter `missing_value` represents a missing value. The output parameters `accumulation` and `status` store the accumulation of data and the status of accumulation (0/1) respectively. The accumulation is initialized to 0.0 and the status is initialized to 0."}
{"instruction": "Create a Fortran subroutine named calculate_fit that takes 5 input parameters of types integer, real, real, real, and integer, and 1 output parameter of type real. The subroutine computes fitness criteria for a given set of computed and recorded values based on various statistical calculations.", "code": "Here's a sample Fortran subroutine named calculate_fit:\n\n```fortran\nsubroutine calculate_fit(n, x, y, z, m, fit)\n  integer, intent(in) :: n, m\n  real, intent(in) :: x(n), y(n), z(n)\n  real, intent(out) :: fit\n\n  ! Declare local variables\n  real :: sum_x, sum_y, sum_z, sum_xy, sum_xz, sum_yz, sum_x2, sum_y2, sum_z2\n  real :: mean_x, mean_y, mean_z, mean_xy, mean_xz, mean_yz, mean_x2, mean_y2, mean_z2\n  real :: var_x, var_y, var_z, cov_xy, cov_xz, cov_yz, r\n\n  ! Calculate sums\n  sum_x = sum(x)\n  sum_y = sum(y)\n  sum_z = sum(z)\n  sum_xy = sum(x*y)\n  sum_xz = sum(x*z)\n  sum_yz = sum(y*z)\n  sum_x2 = sum(x**2)\n  sum_y2 = sum(y**2)\n  sum_z2 = sum(z**2)\n\n  ! Calculate means\n  mean_x = sum_x / real(n)\n  mean_y = sum_y / real(n)\n  mean_z = sum_z / real(n)\n  mean_xy = sum_xy / real(n)\n  mean_xz = sum_xz / real(n)\n  mean_yz = sum_yz / real(n)\n  mean_x2 = sum_x2 / real(n)\n  mean_y2 = sum_y2 / real(n)\n  mean_z2 = sum_z2 / real(n)\n\n  ! Calculate variances and covariances\n  var_x = sum_x2 / real(n) - mean_x**2\n  var_y = sum_y2 / real(n) - mean_y**2\n  var_z = sum_z2 / real(n) - mean_z**2\n  cov_xy = mean_xy - mean_x * mean_y\n  cov_xz = mean_xz - mean_x * mean_z\n  cov_yz = mean_yz - mean_y * mean_z\n\n  ! Calculate correlation coefficient\n  r = (cov_xy * cov_xz * cov_yz) / sqrt(var_x * var_y * var_z)\n\n  ! Calculate fitness criteria\n  fit = r**2\n\nend subroutine calculate_fit\n```\n\nIn this subroutine, the input parameters are:\n- n: the number of data points\n- x, y, z: arrays of computed and recorded values\n- m: another integer parameter (not used in the example)\n\nThe output parameter is:\n- fit: the fitness criteria computed based on the correlation coefficient (r) between the given set of values.\n\nThe subroutine calculates the fitness criteria using statistical calculations such as sums, means, variances, covariances, and correlation coefficient. The fitness criteria is then stored in the output parameter fit."}
{"instruction": "Create a Fortran subroutine named calculate_ra to compute the fitness criterion based on given arrays and parameters. The subroutine takes 6 input parameters of types [integer, real array, real array, real, real, integer], and outputs 1 parameter of type real.", "code": "Here's a sample Fortran subroutine named calculate_ra:\n\n```fortran\nsubroutine calculate_ra(n, x, y, a, b, m, ra)\n  integer, intent(in) :: n, m\n  real, intent(in) :: x(n), y(n), a, b\n  real, intent(out) :: ra\n  \n  ! Local variables\n  real :: sum_sq_diff, mean_y, pred_y\n  integer :: i\n  \n  ! Calculate fitness criterion\n  sum_sq_diff = 0.0\n  mean_y = sum(y) / real(n)\n  do i = 1, n\n     pred_y = a * x(i) + b\n     sum_sq_diff = sum_sq_diff + (y(i) - pred_y)**2\n  end do\n  ra = 1.0 - (sum_sq_diff / sum((y - mean_y)**2))\n  \nend subroutine calculate_ra\n```\n\nIn this subroutine, the input parameters are:\n- n: integer, the size of the arrays x and y\n- x: real array, the input data for the independent variable\n- y: real array, the input data for the dependent variable\n- a: real, a parameter for the fitness criterion calculation\n- b: real, a parameter for the fitness criterion calculation\n- m: integer, an additional parameter\n\nThe output parameter is:\n- ra: real, the fitness criterion value calculated based on the input arrays and parameters."}
{"instruction": "Create a Fortran subroutine named \"spherical_mesh\" that generates a mesh of points on the surface of a sphere based on the given sphere radius and the number of points per dimension. The subroutine must take 2 input parameters of type real(8) and integer and provide 1 output parameter of type real(8), allocatable.", "code": "Here's a Fortran subroutine that generates a mesh of points on the surface of a sphere:\n\n```fortran\nsubroutine spherical_mesh(radius, num_points, mesh_points)\n  implicit none\n  real(8), intent(in) :: radius\n  integer, intent(in) :: num_points\n  real(8), allocatable, intent(out) :: mesh_points(:,:)\n\n  integer :: i, j\n  real(8) :: theta, phi\n\n  allocate(mesh_points(3, num_points**2))\n\n  do i = 1, num_points\n    do j = 1, num_points\n      theta = 2.0d0 * 3.141592653589793d0 * real(i-1) / real(num_points)\n      phi = 3.141592653589793d0 * real(j-1) / real(num_points)\n\n      mesh_points(1, (i-1)*num_points + j) = radius * sin(phi) * cos(theta)\n      mesh_points(2, (i-1)*num_points + j) = radius * sin(phi) * sin(theta)\n      mesh_points(3, (i-1)*num_points + j) = radius * cos(phi)\n    end do\n  end do\n\nend subroutine spherical_mesh\n```\n\nThis subroutine takes the radius of the sphere and the number of points per dimension as input parameters, and it allocates an array of mesh points on the surface of the sphere as the output parameter. The mesh points are calculated using spherical coordinates and stored in the `mesh_points` array."}
{"instruction": "Create a Fortran subroutine named \"renum1\" to compute the connections between degrees of freedom and store them as a linked list. The subroutine should have 4 input parameters of type integer (kind=4) and 2 output parameters of type integer (kind=4). The function should receive the inputs nnode, npoin, nelem, lnods, and produce the outputs nodad and nposi.", "code": "Here's a possible implementation of the \"renum1\" subroutine in Fortran:\n\n```fortran\nsubroutine renum1(nnode, npoin, nelem, lnods, nodad, nposi)\n  implicit none\n  integer(kind=4), intent(in) :: nnode, npoin, nelem\n  integer(kind=4), intent(in) :: lnods(npoin, nnode)\n  integer(kind=4), intent(out) :: nodad(npoin)\n  integer(kind=4), intent(out) :: nposi(npoin)\n\n  integer(kind=4) :: i, j, k, l, m, n, n1, n2, n3, n4, n5, n6, n7, n8\n  integer(kind=4), dimension(npoin) :: nlist\n  integer(kind=4), dimension(npoin) :: nhead\n  integer(kind=4), dimension(npoin) :: nlink\n\n  ! Initialize nodad and nposi\n  nodad = 0\n  nposi = 0\n\n  ! Initialize nlist, nhead, and nlink\n  nlist = 0\n  nhead = 0\n  nlink = 0\n\n  ! Loop over all elements\n  do i = 1, nelem\n    ! Loop over all nodes in the element\n    do j = 1, nnode\n      ! Get the global node number\n      k = lnods(i, j)\n\n      ! Add the element number to the list for this node\n      l = nodad(k)\n      nodad(k) = i\n      nlist(k) = j\n      nlink(k) = l\n    end do\n  end do\n\n  ! Loop over all nodes\n  do i = 1, npoin\n    nhead(i) = -1\n  end do\n\n  ! Loop over all nodes\n  do i = 1, npoin\n    ! Loop over all elements connected to this node\n    n = nodad(i)\n    do while (n /= 0)\n      ! Get the local node number in the element\n      j = nlist(i)\n\n      ! Get the global node number of the connected node\n      k = lnods(n, mod(j+nnode-2, nnode) + 1)\n\n      ! Add the element number to the list for the connected node\n      l = nhead(k)\n      nhead(k) = n\n      nlink(n) = l\n\n      ! Move to the next element connected to this node\n      n = nodad(n)\n    end do\n  end do\n\n  ! Count the number of connections for each node\n  do i = 1, npoin\n    nposi(i) = 0\n    n = nhead(i)\n    do while (n /= 0)\n      nposi(i) = nposi(i) + 1\n      n = nlink(n)\n    end do\n  end do\nend subroutine renum1\n```\n\nIn this implementation, the subroutine \"renum1\" takes the input parameters nnode, npoin, nelem, lnods, and produces the output parameters nodad and nposi. The subroutine computes the connections between degrees of freedom and stores them as a linked list using arrays nlist, nhead, and nlink."}
{"instruction": "Write a Fortran subroutine named pan_etal_1994 that calculates the values of psiq and psiq2. The subroutine takes 5 input parameters of real type (z1, ustar, karman, psih, psih2) and returns 2 output parameters of real type (psiq, psiq2). The subroutine computes the values of psiq and psiq2 based on the given equations and parameters.", "code": "Here's a Fortran subroutine that calculates the values of psiq and psiq2 based on the given equations and parameters:\n\n```fortran\nsubroutine pan_etal_1994(z1, ustar, karman, psih, psih2, psiq, psiq2)\n  real, intent(in) :: z1, ustar, karman, psih, psih2\n  real, intent(out) :: psiq, psiq2\n\n  psiq = (ustar / karman) * log(z1 / psih)\n  psiq2 = (ustar / karman) * log(z1 / psih2)\n\nend subroutine pan_etal_1994\n```\n\nIn this subroutine, the input parameters z1, ustar, karman, psih, and psih2 are of real type, and the output parameters psiq and psiq2 are also of real type. The subroutine calculates the values of psiq and psiq2 based on the given equations and parameters and returns the results as output parameters."}
{"instruction": "Create a Fortran subroutine named andreas_2002 to calculate zt and zq based on the input parameters z_0 and ren. The number of input parameters is 2, with test_data type ['real', 'real'], and the number of output parameters is 2, with test_data type ['real', 'real']. The subroutine should use the imperative tone and implement the Andreas (2002) parameterization for the calculation.", "code": "Here's a Fortran subroutine named andreas_2002 to calculate zt and zq based on the input parameters z_0 and ren:\n\n```fortran\nsubroutine andreas_2002(z_0, ren, zt, zq)\n  real, intent(in) :: z_0, ren\n  real, intent(out) :: zt, zq\n\n  ! Implement Andreas (2002) parameterization\n  zt = z_0 * (1.0 + 0.35 * ren**0.75)\n  zq = z_0 * (1.0 + 0.622 * ren**0.89)\n\nend subroutine andreas_2002\n```\n\nThis subroutine takes in the input parameters z_0 and ren, and calculates the output parameters zt and zq using the Andreas (2002) parameterization. The calculated values are then returned as the output parameters."}
{"instruction": "Write a Fortran subroutine named psi_hogstrom_1996 to calculate the Monin-Obukhov stability functions psi_m and psi_h. The subroutine takes 4 input parameters of type real (zl, zt, z_0, za) and returns 2 output parameters of type real (psi_m, psi_h).", "code": "Here's a Fortran subroutine named psi_hogstrom_1996 to calculate the Monin-Obukhov stability functions psi_m and psi_h:\n\n```fortran\nsubroutine psi_hogstrom_1996(zl, zt, z_0, za, psi_m, psi_h)\n  real, intent(in) :: zl, zt, z_0, za\n  real, intent(out) :: psi_m, psi_h\n\n  ! Constants\n  real, parameter :: kappa = 0.4 ! Von Karman constant\n\n  ! Calculate Monin-Obukhov length\n  real :: L\n  L = -zt * zt * zt / (kappa * 9.81 * (za - zt))\n\n  ! Calculate stability functions\n  if (zl > 0) then\n     psi_m = -5.0 * zl / (1 + 5.0 * zl)\n     psi_h = -5.0 * zl / (1 + 5.0 * zl)\n  else\n     psi_m = (1 - 16.0 * zl) ** 0.25\n     psi_h = -2.0 * log((1 + (1 - 16.0 * zl) ** 0.5) / 2.0)\n  end if\nend subroutine psi_hogstrom_1996\n```\n\nIn this subroutine, the input parameters zl, zt, z_0, and za represent the dimensionless stability parameter, the height of the temperature measurement, the roughness length, and the measurement height, respectively. The output parameters psi_m and psi_h represent the Monin-Obukhov stability functions. The subroutine calculates the Monin-Obukhov length L and then uses it to calculate the stability functions psi_m and psi_h based on the stability parameter zl."}
{"instruction": "Write a Fortran subroutine named intplt3d to compute interpolation indices and coefficients using bi-linear interpolation. The subroutine takes 5 input parameters of types integer, integer, real, real, and real, and 3 output parameters of types integer, integer, and real.", "code": "Here's a Fortran subroutine named intplt3d that computes interpolation indices and coefficients using bi-linear interpolation:\n\n```fortran\nsubroutine intplt3d(nx, ny, x, y, z, i1, i2, w1)\n  integer, intent(in) :: nx, ny\n  real, intent(in) :: x, y, z\n  integer, intent(out) :: i1, i2\n  real, intent(out) :: w1\n\n  real :: dx, dy\n\n  i1 = int(x)\n  i2 = int(y)\n\n  dx = x - real(i1)\n  dy = y - real(i2)\n\n  w1 = (1.0 - dx) * (1.0 - dy) * z(i1, i2) &\n       + dx * (1.0 - dy) * z(i1+1, i2) &\n       + (1.0 - dx) * dy * z(i1, i2+1) &\n       + dx * dy * z(i1+1, i2+1)\nend subroutine intplt3d\n```\n\nIn this subroutine, nx and ny are the dimensions of the input array z, x and y are the coordinates of the point to be interpolated, and i1, i2, and w1 are the output interpolation indices and coefficients. The subroutine uses bi-linear interpolation to compute the interpolated value at the given coordinates (x, y) in the input array z."}
{"instruction": "Write a Fortran subroutine named split to separate a given string into individual words and store them in an array of strings. The input parameter is a single character array and the output parameter is an array of strings.", "code": "Here's a Fortran subroutine named split that separates a given string into individual words and stores them in an array of strings:\n\n```fortran\nsubroutine split(input_string, output_array)\n  character(len=*) :: input_string\n  character(len=100) :: word\n  character(len=100), dimension(:), allocatable :: output_array\n  integer :: i, j, n, start, end\n\n  n = len_trim(input_string)\n  allocate(output_array(1:n))\n\n  j = 1\n  start = 1\n  do i = 1, n\n    if (input_string(i:i) /= ' ') then\n      word(j:j) = input_string(i:i)\n      j = j + 1\n    else\n      end = i - 1\n      output_array(start:end) = word(1:j-1)\n      start = i + 1\n      j = 1\n    end if\n  end do\n\n  end = n\n  output_array(start:end) = word(1:j-1)\n\nend subroutine split\n```\n\nYou can use this subroutine by passing the input string and an array of strings as parameters. The output array will contain the individual words from the input string."}
{"instruction": "Write a Fortran subroutine named normalweight that calculates the points and weights based on the given spread and returns them as output parameters. The number of input parameters is 1 and the test_data type is ['real(kind=8)']. The number of output parameters is 2 and the test_data type is ['real(kind=8)', 'real(kind=8)'].", "code": "Here's a Fortran subroutine named normalweight that calculates the points and weights based on the given spread and returns them as output parameters:\n\n```fortran\nsubroutine normalweight(spread, points, weights)\n  real(kind=8), intent(in) :: spread\n  real(kind=8), intent(out) :: points, weights\n\n  ! Calculate points and weights based on spread\n  points = 0.5 * spread\n  weights = 1.0 / spread\nend subroutine normalweight\n```\n\nIn this subroutine, the input parameter `spread` is of type real(kind=8), and the output parameters `points` and `weights` are also of type real(kind=8). The subroutine calculates the points and weights based on the given spread and returns them as output parameters."}
{"instruction": "Create a Fortran subroutine named displacement to calculate the best shift value for a given set of data. The subroutine takes 4 input parameters of types integer, real*8 array, real*8 array, and real*8 array, and returns 3 output parameters of types real*8, real*8, and real*8 array.", "code": "Here's a Fortran subroutine named displacement that calculates the best shift value for a given set of data:\n\n```fortran\nsubroutine displacement(n, x, y, shift, best_shift, min_displacement, shifted_y)\n  implicit none\n  integer, intent(in) :: n\n  real*8, intent(in) :: x(n), y(n), shift\n  real*8, intent(out) :: best_shift, min_displacement\n  real*8, intent(out) :: shifted_y(n)\n  real*8 :: displacement, min_disp\n  integer :: i, j\n\n  min_disp = 1.0E20\n  do i = 1, n\n    shifted_y = y - shift\n    displacement = 0.0\n    do j = 1, n\n      displacement = displacement + (x(j) - x(i))**2 + (shifted_y(j) - y(i))**2\n    end do\n    if (displacement < min_disp) then\n      min_disp = displacement\n      best_shift = shift\n    end if\n  end do\n\n  min_displacement = min_disp\nend subroutine displacement\n```\n\nIn this subroutine, the input parameters are n (the number of data points), x (an array of x-coordinates), y (an array of y-coordinates), and shift (the initial shift value). The output parameters are best_shift (the best shift value), min_displacement (the minimum displacement), and shifted_y (the array of y-coordinates after applying the best shift value)."}
{"instruction": "Create a Fortran subroutine named dot_d to calculate the dot product of two 3-dimensional vectors and their corresponding derivatives. The subroutine takes 4 input parameters of type real(kind=8) - a(3), ad(3), b(3), bd(3). It returns 2 output parameters of type real(kind=8) - dot_prod and dot_prodd.", "code": "Here's a Fortran subroutine named dot_d to calculate the dot product of two 3-dimensional vectors and their corresponding derivatives:\n\n```fortran\nsubroutine dot_d(a, ad, b, bd, dot_prod, dot_prodd)\n  real(kind=8), intent(in) :: a(3), ad(3), b(3), bd(3)\n  real(kind=8), intent(out) :: dot_prod, dot_prodd\n\n  dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  dot_prodd = a(1)*bd(1) + ad(1)*b(1) + a(2)*bd(2) + ad(2)*b(2) + a(3)*bd(3) + ad(3)*b(3)\nend subroutine dot_d\n```\n\nIn this subroutine, the input parameters a, ad, b, and bd are the 3-dimensional vectors and their corresponding derivatives. The output parameters dot_prod and dot_prodd are the dot product of the vectors and their derivatives, respectively. The dot product is calculated using the formula a(1)*b(1) + a(2)*b(2) + a(3)*b(3), and the derivative of the dot product is calculated using the product rule for differentiation."}
{"instruction": "Create a Fortran subroutine named cross_d. It takes 4 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8). The function computes the cross product of two 3D vectors and their derivatives. The resulting cross product and its derivatives are stored in the output parameters.", "code": "Here's a Fortran subroutine named cross_d that takes 4 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8) to compute the cross product of two 3D vectors and their derivatives:\n\n```fortran\nsubroutine cross_d(a, b, da, db, c, dc)\n  real(kind=8), intent(in) :: a(3), b(3), da(3), db(3)\n  real(kind=8), intent(out) :: c(3), dc(3)\n\n  c(1) = a(2)*b(3) - a(3)*b(2)\n  c(2) = a(3)*b(1) - a(1)*b(3)\n  c(3) = a(1)*b(2) - a(2)*b(1)\n\n  dc(1) = da(2)*b(3) - da(3)*b(2) - a(2)*db(3) + a(3)*db(2)\n  dc(2) = da(3)*b(1) - da(1)*b(3) - a(3)*db(1) + a(1)*db(3)\n  dc(3) = da(1)*b(2) - da(2)*b(1) - a(1)*db(2) + a(2)*db(1)\nend subroutine cross_d\n```\n\nIn this subroutine, the input parameters a and b are the 3D vectors, and da and db are their derivatives. The output parameters c and dc store the resulting cross product and its derivatives, respectively."}
{"instruction": "Write a Fortran subroutine named exp1reg to calculate the value and derivative of a function. The subroutine takes 2 input parameters of type real*8 and an array of real*8 as input, and returns 2 output parameters of type real*8. The test_data type for input parameters is ['real*8', 'real*8'], and for output parameters is ['real*8 ', 'real*8 '].", "code": "Here's a Fortran subroutine named exp1reg that calculates the value and derivative of a function:\n\n```fortran\nsubroutine exp1reg(x, a, y, dy)\n  real*8, intent(in) :: x, a\n  real*8, intent(out) :: y, dy\n  real*8 :: exp_value, exp_derivative\n\n  exp_value = exp(a * x)\n  exp_derivative = a * exp_value\n\n  y = exp_value\n  dy = exp_derivative\nend subroutine exp1reg\n```\n\nHere's how you can use the subroutine with test data:\n\n```fortran\nprogram test_exp1reg\n  real*8 :: x, a, y, dy\n  type(test_data) :: input_params, output_params\n\n  ! Set input parameters\n  input_params = test_data(['real*8', 'real*8'])\n  x = 2.0d0\n  a = 0.5d0\n\n  ! Call the subroutine\n  call exp1reg(x, a, y, dy)\n\n  ! Set output parameters\n  output_params = test_data(['real*8', 'real*8'])\n  output_params%data = [y, dy]\n\n  ! Print the results\n  print *, \"Function value: \", output_params%data(1)\n  print *, \"Derivative value: \", output_params%data(2)\nend program test_exp1reg\n```"}
{"instruction": "Create a Fortran subroutine named func to calculate the product of two real(8) numbers. The subroutine should have 2 input parameters of type real(8) and 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named func to calculate the product of two real(8) numbers:\n\n```fortran\nsubroutine func(x, y, result)\n  real(8), intent(in) :: x, y\n  real(8), intent(out) :: result\n  \n  result = x * y\nend subroutine func\n```\n\nIn this subroutine, the input parameters x and y are of type real(8), and the output parameter result is also of type real(8). The result is calculated by multiplying x and y, and then stored in the result parameter."}
{"instruction": "Create a Fortran subroutine named split_first_last to compute the first and last indices of tokens in an input string, delimited by specified characters. The number of input parameters is 2, with test_data types ['character(*)', 'character(*)']. The number of output parameters is 2, with test_data types ['integer, allocatable', 'integer, allocatable'].", "code": "Here's a Fortran subroutine named split_first_last:\n\n```fortran\nsubroutine split_first_last(input_string, delimiters, first_indices, last_indices)\n  character(*), intent(in) :: input_string\n  character(*), intent(in) :: delimiters\n  integer, allocatable, intent(out) :: first_indices(:)\n  integer, allocatable, intent(out) :: last_indices(:)\n  \n  ! Local variables\n  character(len(input_string)) :: temp_string\n  integer :: i, count, start_index, end_index\n  \n  ! Initialize arrays\n  first_indices = 0\n  last_indices = 0\n  \n  ! Loop through input string\n  count = 0\n  do i = 1, len(input_string)\n     if (index(delimiters, input_string(i:i)) /= 0) then\n        count = count + 1\n        if (count == 1) then\n           start_index = i\n        end if\n        if (i == len(input_string)) then\n           end_index = i\n           temp_string = input_string(start_index:end_index)\n           first_indices = [first_indices, start_index]\n           last_indices = [last_indices, end_index]\n        end if\n     else\n        if (count == 1) then\n           end_index = i - 1\n           temp_string = input_string(start_index:end_index)\n           first_indices = [first_indices, start_index]\n           last_indices = [last_indices, end_index]\n           count = 0\n        end if\n     end if\n  end do\n  \n  ! Remove initial 0 from arrays\n  first_indices = first_indices(2:)\n  last_indices = last_indices(2:)\n  \nend subroutine split_first_last\n```\n\nThis subroutine takes in an input string and delimiters, and computes the first and last indices of tokens in the input string delimited by the specified characters. The first_indices and last_indices arrays are allocated and filled with the computed indices."}
{"instruction": "Write a Fortran subroutine named compute_min_oxygen to calculate the minimum dissolved oxygen concentration and the time at which it occurs based on environmental parameters. The subroutine takes 7 input parameters of type real: bod, oxy, k, ka, h, oxysat, and dt. It also returns 2 output parameters of type real: oxymin and time. This subroutine uses imperative programming to iterate and calculate the minimum dissolved oxygen concentration and the corresponding time.", "code": "Here's a Fortran subroutine named compute_min_oxygen:\n\n```fortran\nsubroutine compute_min_oxygen(bod, oxy, k, ka, h, oxysat, dt, oxymin, time)\n  real, intent(in) :: bod, oxy, k, ka, h, oxysat, dt\n  real, intent(out) :: oxymin, time\n  real :: t, oxy_prev, oxy_next, time_min\n  integer :: i, n\n\n  n = 1000  ! Number of time steps\n  t = 0.0  ! Initial time\n  oxymin = oxy  ! Initialize minimum dissolved oxygen concentration\n  time_min = t  ! Initialize time at which minimum occurs\n\n  do i = 1, n\n    oxy_prev = oxy\n    oxy_next = oxy - (k*oxy*dt) - (ka*bod*oxy*dt) + (h*(oxysat - oxy)*dt)\n    t = t + dt\n\n    if (oxy_next < oxymin) then\n      oxymin = oxy_next\n      time_min = t\n    end if\n\n    oxy = oxy_next\n  end do\n\n  time = time_min\nend subroutine compute_min_oxygen\n```\n\nIn this subroutine, we use a simple iterative approach to calculate the minimum dissolved oxygen concentration and the corresponding time. We initialize the minimum concentration and time at the current concentration and time, and then iterate through a number of time steps, updating the concentration and time if a new minimum is found. The input parameters are the biochemical oxygen demand (bod), initial dissolved oxygen concentration (oxy), reaction rate constants (k and ka), oxygen saturation (oxysat), half-saturation constant (h), and time step (dt). The output parameters are the minimum dissolved oxygen concentration (oxymin) and the time at which it occurs (time)."}
{"instruction": "Create a Fortran subroutine named dof_locglobunimult_p1_1d to calculate the global degrees of freedom for a list of elements with q1 shape and uniform grid. The subroutine should take 2 input parameters of type ['integer, dimension(:,:)', 'integer, dimension(:)'] and 1 output parameter of type ['integer, dimension(:,:)'].", "code": "Here's a possible implementation of the Fortran subroutine:\n\n```fortran\nsubroutine dof_locglobunimult_p1_1d(elements, nodes_per_element, global_dofs)\n  integer, dimension(:,:), intent(in) :: elements\n  integer, dimension(:), intent(in) :: nodes_per_element\n  integer, dimension(:,:), intent(out) :: global_dofs\n  \n  integer :: num_elements, num_nodes, i, j, k\n  \n  num_elements = size(elements, 1)\n  num_nodes = maxval(elements)\n  \n  do i = 1, num_elements\n    do j = 1, nodes_per_element(i)\n      k = elements(i, j)\n      global_dofs(i, j) = k\n    end do\n  end do\nend subroutine dof_locglobunimult_p1_1d\n```\n\nIn this subroutine, the input parameters are `elements` which is a 2D array representing the connectivity of the elements, and `nodes_per_element` which is a 1D array containing the number of nodes for each element. The output parameter `global_dofs` is a 2D array that will store the global degrees of freedom for each element.\n\nThe subroutine calculates the global degrees of freedom for each element by simply copying the node numbers from the `elements` array to the `global_dofs` array."}
{"instruction": "Create a Fortran subroutine named running_average to calculate the running average, standard deviation, and number of data points based on the received data values. The subroutine takes 2 input parameters of type real and logical and returns 3 output parameters of type real, real, and integer. If the reset flag is true, the subroutine clears the running sums and exits.", "code": "Here's a Fortran subroutine named running_average that calculates the running average, standard deviation, and number of data points based on the received data values:\n\n```fortran\nsubroutine running_average(data, reset, average, stddev, num_points)\n  real, intent(in) :: data\n  logical, intent(in) :: reset\n  real, intent(out) :: average\n  real, intent(out) :: stddev\n  integer, intent(out) :: num_points\n  real, save :: sum, sum_sq\n  integer, save :: count\n\n  if (reset) then\n    sum = 0.0\n    sum_sq = 0.0\n    count = 0\n    return\n  end if\n\n  sum = sum + data\n  sum_sq = sum_sq + data**2\n  count = count + 1\n\n  average = sum / real(count)\n  stddev = sqrt((sum_sq - (sum**2 / real(count))) / real(count))\n  num_points = count\nend subroutine running_average\n```\n\nIn this subroutine, the input parameters are the data value and the reset flag, and the output parameters are the running average, standard deviation, and number of data points. If the reset flag is true, the subroutine clears the running sums and exits. Otherwise, it updates the running sums and calculates the average and standard deviation based on the new data value."}
{"instruction": "Write a Fortran subroutine named iup_ to unpack the canonical index for a symmetric matrix (1e). The number of input parameters is 1, with test_data type ['integer'], and the number of output parameters is 2, with test_data type ['integer', 'integer'].", "code": "Here's a Fortran subroutine named iup_ to unpack the canonical index for a symmetric matrix:\n\n```fortran\nsubroutine iup_(n, k, i, j)\n  integer, intent(in) :: n, k\n  integer, intent(out) :: i, j\n\n  i = n - 1 - int(sqrt(real(2*(n-k)+0.25)))\n  j = k + i*(n - i) / 2\nend subroutine iup_\n```\n\nIn this subroutine, the input parameter `n` is the size of the symmetric matrix, and `k` is the canonical index. The output parameters `i` and `j` are the row and column indices corresponding to the canonical index `k`."}
{"instruction": "Create a Fortran subroutine named m33inv to calculate the inverse of a 3x3 matrix. The subroutine takes 1 input parameter of type double precision and returns 2 output parameters of type double precision and logical, respectively.", "code": "Here's a Fortran subroutine named m33inv to calculate the inverse of a 3x3 matrix:\n\n```fortran\nsubroutine m33inv(A, Ainv, success)\n  implicit none\n  double precision, intent(in) :: A(3,3)\n  double precision, intent(out) :: Ainv(3,3)\n  logical, intent(out) :: success\n  double precision :: det\n\n  det = A(1,1)*(A(2,2)*A(3,3) - A(2,3)*A(3,2)) - A(1,2)*(A(2,1)*A(3,3) - A(2,3)*A(3,1)) + A(1,3)*(A(2,1)*A(3,2) - A(2,2)*A(3,1))\n\n  if (det == 0.0d0) then\n    success = .false.\n    return\n  else\n    success = .true.\n    Ainv(1,1) = (A(2,2)*A(3,3) - A(2,3)*A(3,2)) / det\n    Ainv(1,2) = (A(1,3)*A(3,2) - A(1,2)*A(3,3)) / det\n    Ainv(1,3) = (A(1,2)*A(2,3) - A(1,3)*A(2,2)) / det\n    Ainv(2,1) = (A(2,3)*A(3,1) - A(2,1)*A(3,3)) / det\n    Ainv(2,2) = (A(1,1)*A(3,3) - A(1,3)*A(3,1)) / det\n    Ainv(2,3) = (A(1,3)*A(2,1) - A(1,1)*A(2,3)) / det\n    Ainv(3,1) = (A(2,1)*A(3,2) - A(2,2)*A(3,1)) / det\n    Ainv(3,2) = (A(1,2)*A(3,1) - A(1,1)*A(3,2)) / det\n    Ainv(3,3) = (A(1,1)*A(2,2) - A(1,2)*A(2,1)) / det\n  end if\nend subroutine m33inv\n```\n\nIn this subroutine, the input parameter A is the 3x3 matrix for which we want to calculate the inverse. The output parameter Ainv is the inverse of the input matrix A, and the logical output parameter success indicates whether the inverse calculation was successful (i.e., whether the input matrix was non-singular). If the input matrix is singular (i.e., its determinant is zero), the success parameter is set to .false. and the Ainv parameter is not modified. Otherwise, the success parameter is set to .true. and the Ainv parameter is filled with the inverse of the input matrix A."}
{"instruction": "Create a Fortran subroutine named calc_hartree_radial_1d to calculate the Hartree potential and energy for a one-dimensional system. It takes 3 input parameters of type real(8) in arrays rad, rab, and rho, and 2 output parameters of type real(8) in arrays vh and eh.", "code": "Here's a Fortran subroutine named calc_hartree_radial_1d that calculates the Hartree potential and energy for a one-dimensional system:\n\n```fortran\nsubroutine calc_hartree_radial_1d(rad, rab, rho, vh, eh)\n  implicit none\n  real(8), intent(in) :: rad(:), rab(:), rho(:)\n  real(8), intent(out) :: vh(:), eh(:)\n  integer :: i, j\n  real(8) :: dr, v, e\n\n  dr = rad(2) - rad(1)\n  do i = 1, size(rad)\n     v = 0.0\n     e = 0.0\n     do j = 1, size(rab)\n        v = v + rho(j) / (abs(rad(i) - rab(j)))\n        e = e + rho(j) * rho(j) / (abs(rad(i) - rab(j)))\n     end do\n     vh(i) = v * dr\n     eh(i) = e * dr\n  end do\nend subroutine calc_hartree_radial_1d\n```\n\nIn this subroutine, the input parameters rad, rab, and rho are arrays of type real(8) representing the radial grid, the electron-electron distances, and the electron density, respectively. The output parameters vh and eh are also arrays of type real(8) representing the Hartree potential and energy, respectively. The subroutine calculates the Hartree potential and energy for each point in the radial grid and stores the results in the vh and eh arrays."}
{"instruction": "Create a Fortran subroutine named datefromsecondssince1970 to calculate the date and time from the seconds that have passed since the start of the year 1970. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "code": "Here's a Fortran subroutine that calculates the date and time from the seconds since 1970:\n\n```fortran\nsubroutine datefromsecondssince1970(seconds, year, month, day, hour, minute, second)\n  integer, intent(in) :: seconds\n  integer, intent(out) :: year, month, day, hour, minute, second\n\n  integer :: days_per_month(12) = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  integer :: seconds_in_day = 86400\n  integer :: seconds_in_hour = 3600\n  integer :: seconds_in_minute = 60\n\n  year = 1970\n  month = 1\n  day = 1\n  hour = 0\n  minute = 0\n  second = 0\n\n  ! Calculate the year\n  do while (seconds >= 31536000) ! 365 days in a year\n    if (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0)) then\n      seconds = seconds - 31622400 ! Leap year\n    else\n      seconds = seconds - 31536000 ! Non-leap year\n    end if\n    year = year + 1\n  end do\n\n  ! Calculate the month and day\n  do while (seconds >= seconds_in_day * days_per_month(month))\n    seconds = seconds - seconds_in_day * days_per_month(month)\n    month = month + 1\n  end do\n  day = 1 + seconds / seconds_in_day\n  seconds = mod(seconds, seconds_in_day)\n\n  ! Calculate the hour, minute, and second\n  hour = seconds / seconds_in_hour\n  seconds = mod(seconds, seconds_in_hour)\n  minute = seconds / seconds_in_minute\n  second = mod(seconds, seconds_in_minute)\nend subroutine datefromsecondssince1970\n```\n\nYou can call this subroutine from your main program and pass the seconds since 1970 as input to get the corresponding date and time as output."}
{"instruction": "Create a Fortran subroutine named datefromhourssince1900 to calculate the date and time from the number of hours that have passed since the start of the year 1900. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "code": "Here's a Fortran subroutine named datefromhourssince1900:\n\n```fortran\nsubroutine datefromhourssince1900(hours_since_1900, year, month, day, hour, minute, second)\n  integer, intent(in) :: hours_since_1900\n  integer, intent(out) :: year, month, day, hour, minute, second\n\n  ! Constants\n  integer, parameter :: hours_per_day = 24\n  integer, parameter :: days_per_year = 365\n  integer, parameter :: days_per_leap_year = 366\n  integer, parameter :: hours_per_year = hours_per_day * days_per_year\n  integer, parameter :: hours_per_leap_year = hours_per_day * days_per_leap_year\n  integer, parameter :: hours_per_month = hours_per_day * 30 ! Approximation\n\n  ! Variables\n  integer :: total_years\n  integer :: remaining_hours\n  integer :: leap_years\n  integer :: days_in_year\n  integer :: days_in_month\n\n  ! Calculate total years and remaining hours\n  total_years = hours_since_1900 / hours_per_year\n  remaining_hours = mod(hours_since_1900, hours_per_year)\n\n  ! Calculate leap years\n  leap_years = (total_years + 25) / 4 - (total_years + 1) / 100 + (total_years + 375) / 400\n\n  ! Adjust for leap years\n  total_years = total_years - leap_years\n  remaining_hours = remaining_hours + leap_years * hours_per_day\n\n  ! Calculate year\n  year = 1900 + total_years\n\n  ! Determine if it's a leap year\n  if (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0)) then\n    days_in_year = days_per_leap_year\n  else\n    days_in_year = days_per_year\n  end if\n\n  ! Calculate month and day\n  month = 1\n  do while (remaining_hours >= hours_per_month)\n    remaining_hours = remaining_hours - hours_per_month\n    month = month + 1\n  end do\n  days_in_month = remaining_hours / hours_per_day\n  day = days_in_month + 1\n\n  ! Calculate hour, minute, and second\n  hour = mod(remaining_hours, hours_per_day)\n  minute = mod(remaining_hours, 60)\n  second = mod(remaining_hours, 60)\n\nend subroutine datefromhourssince1900\n```\n\nThis subroutine takes the number of hours since 1900 as input and calculates the corresponding year, month, day, hour, minute, and second. The calculated values are returned as output parameters."}
{"instruction": "Create a Fortran subroutine named \"secondssince1970\" to calculate the number of seconds that have passed since the start of the year 1970 based on the given date. The input parameter is an integer array with 4 elements. The output parameter is an integer representing the number of seconds.", "code": "Here's a Fortran subroutine to calculate the number of seconds since 1970:\n\n```fortran\nsubroutine secondssince1970(date, seconds)\n  integer, intent(in) :: date(4)\n  integer, intent(out) :: seconds\n  integer :: year, month, day, hour, minute, second\n  integer :: days_in_month(12) = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  integer :: leap_year, i\n\n  year = date(1)\n  month = date(2)\n  day = date(3)\n  hour = date(4)\n\n  ! Check for leap year\n  leap_year = 0\n  if (mod(year, 4) == 0) then\n    if (mod(year, 100) /= 0 .or. mod(year, 400) == 0) then\n      leap_year = 1\n    endif\n  endif\n\n  ! Calculate the number of days since 1970\n  seconds = (year - 1970) * 365 * 24 * 60 * 60\n  do i = 1, month - 1\n    seconds = seconds + days_in_month(i) * 24 * 60 * 60\n  end do\n  seconds = seconds + (day - 1) * 24 * 60 * 60\n  seconds = seconds + hour * 60 * 60\n\n  ! Add leap days\n  seconds = seconds + ((year - 1968) / 4 - (year - 1900) / 100 + (year - 1600) / 400) * 24 * 60 * 60\n\n  ! Add leap day for current year\n  if (leap_year .and. month > 2) then\n    seconds = seconds + 24 * 60 * 60\n  endif\n\n  ! Add seconds for the current day\n  seconds = seconds + minute * 60 + second\nend subroutine secondssince1970\n```\n\nYou can call this subroutine with an integer array containing the year, month, day, and hour, and it will calculate the number of seconds since the start of 1970."}
{"instruction": "Create a Fortran subroutine named scattering_matrix_fresnel to calculate the scattering matrix for Fresnel reflection and transmission. The subroutine takes 3 input parameters of types complex*16, complex*16, and double precision, and returns 1 output parameter of type complex*16, dimension(2,2).", "code": "Here's a Fortran subroutine named scattering_matrix_fresnel that calculates the scattering matrix for Fresnel reflection and transmission:\n\n```fortran\nsubroutine scattering_matrix_fresnel(r_parallel, r_perpendicular, theta, s_matrix)\n  implicit none\n  complex*16, intent(in) :: r_parallel, r_perpendicular\n  real*8, intent(in) :: theta\n  complex*16, intent(out), dimension(2,2) :: s_matrix\n  real*8 :: cos_theta, sin_theta\n\n  cos_theta = cos(theta)\n  sin_theta = sin(theta)\n\n  s_matrix(1,1) = cos_theta\n  s_matrix(1,2) = 0.d0\n  s_matrix(2,1) = 0.d0\n  s_matrix(2,2) = cos_theta\n\n  s_matrix(1,1) = s_matrix(1,1) + r_parallel * r_parallel * sin_theta * sin_theta\n  s_matrix(1,2) = r_parallel * r_perpendicular * sin_theta * sin_theta\n  s_matrix(2,1) = r_perpendicular * r_parallel * sin_theta * sin_theta\n  s_matrix(2,2) = s_matrix(2,2) + r_perpendicular * r_perpendicular * sin_theta * sin_theta\nend subroutine scattering_matrix_fresnel\n```\n\nIn this subroutine, r_parallel and r_perpendicular are the complex reflection coefficients for parallel and perpendicular polarizations, respectively. Theta is the angle of incidence, and s_matrix is the output scattering matrix for Fresnel reflection and transmission."}
{"instruction": "Create a Fortran subroutine named dayfraction2hms_int to convert a fractional number representing a time of day into hours, minutes, and seconds. The subroutine takes 1 input parameter of type real*8. The output consists of 3 parameters of type integer representing hour, minute, and second, respectively.", "code": "Here's a Fortran subroutine named dayfraction2hms_int:\n\n```fortran\nsubroutine dayfraction2hms_int(dayfraction, hour, minute, second)\n  real*8, intent(in) :: dayfraction\n  integer, intent(out) :: hour, minute, second\n\n  ! Convert dayfraction to hours, minutes, and seconds\n  hour = int(dayfraction*24.0)\n  minute = int(mod(dayfraction*24.0*60.0, 60.0))\n  second = int(mod(dayfraction*24.0*60.0*60.0, 60.0))\n\nend subroutine dayfraction2hms_int\n```\n\nYou can use this subroutine by passing a fractional number representing a time of day as the input parameter `dayfraction`, and the subroutine will return the corresponding hours, minutes, and seconds in the output parameters `hour`, `minute`, and `second`, respectively."}
{"instruction": "Create a Fortran subroutine named dp_dt that takes 5 input parameters of type real(8) and one 2-dimensional array of real(8), and returns 1 output parameter of type real(8). The input parameters are rho, delta, tau, r, ar, and the output parameter is dpdt. The subroutine calculates dpdt as rho times r times (1.d0 plus delta times ar(2, 1) minus delta times tau times ar(3, 3)).", "code": "```fortran\nsubroutine dp_dt(rho, delta, tau, r, ar, dpdt)\n  real(8), intent(in) :: rho, delta, tau, r\n  real(8), intent(in) :: ar(3,3)\n  real(8), intent(out) :: dpdt\n  \n  dpdt = rho * r * (1.d0 + delta * ar(2,1) - delta * tau * ar(3,3))\n  \nend subroutine dp_dt\n```"}
{"instruction": "Create a Fortran subroutine named dp_dv to calculate the derivative of pressure with respect to molar volume. It takes 5 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are delta, r, rho, t, and ar(3,3). The output parameter is dpdv.", "code": "Here's a Fortran subroutine named dp_dv that calculates the derivative of pressure with respect to molar volume:\n\n```fortran\nsubroutine dp_dv(delta, r, rho, t, ar, dpdv)\n  real(8), intent(in) :: delta, r, rho, t, ar(3,3)\n  real(8), intent(out) :: dpdv\n  real(8) :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, s, u, v, w, x, y, z\n\n  ! Calculate the derivative of pressure with respect to molar volume\n  a = ar(1,1)\n  b = ar(1,2)\n  c = ar(1,3)\n  d = ar(2,1)\n  e = ar(2,2)\n  f = ar(2,3)\n  g = ar(3,1)\n  h = ar(3,2)\n  i = ar(3,3)\n\n  j = delta * r * t\n  k = rho * t\n  l = rho * rho\n  m = l * rho\n  n = l * l\n  o = l * l * l\n  p = l * l * l * l\n  q = l * l * l * l * l\n  s = l * l * l * l * l * l\n  u = l * l * l * l * l * l * l\n  v = l * l * l * l * l * l * l * l\n  w = l * l * l * l * l * l * l * l * l\n  x = l * l * l * l * l * l * l * l * l * l\n  y = l * l * l * l * l * l * l * l * l * l * l\n  z = l * l * l * l * l * l * l * l * l * l * l * l\n\n  dpdv = j * (a + b * k + c * m + d * n + e * o + f * p + g * q + h * s + i * u) &\n       + j * j * (b * b * v + 2.0d0 * b * c * w + 2.0d0 * b * d * x + 2.0d0 * b * e * y + 2.0d0 * b * f * z + c * c * x + 2.0d0 * c * d * y + 2.0d0 * c * e * z + d * d * z) &\n       + j * j * j * (b * b * b * y + 3.0d0 * b * b * c * z + 3.0d0 * b * c * c * z + 3.0d0 * b * b * d * z + 3.0d0 * b * c * d * z + 3.0d0 * b * b * e * z + 3.0d0 * b * c * e * z + b * b * f * z + 3.0d0 * b * d * d * z + 3.0d0 * b * e * d * z + 3.0d0 * b * d * e * z + 3.0d0 * b * e * e * z + c * c * c * z + 3.0d0 * c * c * d * z + 3.0d0 * c * c * e * z + 3.0d0 * c * d * d * z + 3.0d0 * c * e * d * z + 3.0d0 * c * d * e * z + 3.0d0 * c * e * e * z + d * d * d * z + 3.0d0 * d * d * e * z + 3.0d0 * d * e * e * z + e * e * e * z)\nend subroutine dp_dv\n```"}
{"instruction": "Create a Fortran subroutine named entropy that takes in four real(8) input parameters: tau, r, ao(3,3), and ar(3,3). It also has one real(8) output parameter, s. The subroutine computes the value of s using the formula: s = (tau * (ao(2,2) + ar(2,2)) - ao(1,1) - ar(1,1)) * r.", "code": "```fortran\nsubroutine entropy(tau, r, ao, ar, s)\n  real(8), intent(in) :: tau, r\n  real(8), intent(in) :: ao(3,3), ar(3,3)\n  real(8), intent(out) :: s\n  \n  s = (tau * (ao(2,2) + ar(2,2)) - ao(1,1) - ar(1,1)) * r\nend subroutine entropy\n```"}
{"instruction": "Write a Fortran subroutine code named four_point_triangle_real that calculates the derivative of a given function using the four-point triangle method. The subroutine takes 3 input parameters: an integer llim, a real array f with dimensions llim and above, and a real value del. It also has 1 output parameter: a real array df with dimensions llim and above. \n\nIn the subroutine, the input array f is used to calculate the derivative values, which are stored in the output array df. The subroutine implements a second-order accurate centered difference approximation. The derivative values are computed at specific points using the four-point triangle formula. The derivative values at the boundaries of the array f are computed differently than the interior points.\n\nTo use the subroutine, call it and provide the necessary input parameters: llim, f, and del. After the subroutine is executed, the derivative values will be stored in the df array.", "code": "```fortran\nsubroutine four_point_triangle_real(llim, f, del, df)\n  integer, intent(in) :: llim\n  real, dimension(llim), intent(in) :: f\n  real, intent(in) :: del\n  real, dimension(llim), intent(out) :: df\n  integer :: i\n\n  ! Compute derivative at the boundaries\n  df(1) = (-3.0*f(1) + 4.0*f(2) - f(3)) / (2.0*del)\n  df(llim) = (3.0*f(llim) - 4.0*f(llim-1) + f(llim-2)) / (2.0*del)\n\n  ! Compute derivative at interior points\n  do i = 2, llim-1\n     df(i) = (f(i-2) - 8.0*f(i-1) + 8.0*f(i+1) - f(i+2)) / (12.0*del)\n  end do\nend subroutine four_point_triangle_real\n```"}
{"instruction": "Implement a Fortran subroutine named second_order_centered_zed_real that performs second-order finite difference calculations for a given range of data. The subroutine takes in 9 input parameters: llim (integer), iseg (integer), nseg (integer), f (real array with dimension(llim:)), sgn (integer), del (real), fl (real array), fr (real array), and periodic (logical). It also has 1 output parameter: df (real array with dimension(llim:)).\n\nThe subroutine computes the central difference approximation for the derivative of the input data within the specified range. It handles boundary conditions and determines the appropriate neighboring values to calculate the derivative accurately. The resulting derivative values are stored in the df array.\n\nTo use the subroutine, provide the required input parameters and allocate memory for the output array. After calling the subroutine, you can access the derivative values stored in df.\n\nEnsure that the input and output arrays have the correct dimensions and types to avoid any runtime errors.\n\n", "code": "Here's a possible implementation of the Fortran subroutine named second_order_centered_zed_real:\n\n```fortran\nsubroutine second_order_centered_zed_real(llim, iseg, nseg, f, sgn, del, fl, fr, periodic, df)\n  integer, intent(in) :: llim, iseg, nseg\n  real, intent(in) :: f(llim)\n  integer, intent(in) :: sgn\n  real, intent(in) :: del\n  real, intent(in) :: fl(llim), fr(llim)\n  logical, intent(in) :: periodic\n  real, intent(out) :: df(llim)\n\n  ! Perform second-order finite difference calculations\n  ! ...\n\n  ! Example code for central difference approximation\n  do i = iseg, iseg + nseg - 1\n    if (periodic) then\n      im1 = mod(i-2, llim) + 1\n      ip1 = mod(i, llim) + 1\n    else\n      im1 = max(i-1, 1)\n      ip1 = min(i+1, llim)\n    end if\n    df(i) = (f(ip1) - f(im1)) / (2.0 * del)\n  end do\n\nend subroutine second_order_centered_zed_real\n```\n\nTo use the subroutine, you can call it from your main program and provide the required input parameters:\n\n```fortran\nprogram main\n  integer :: llim, iseg, nseg\n  real :: f(llim), del, fl(llim), fr(llim), df(llim)\n  integer :: sgn\n  logical :: periodic\n\n  ! Initialize input parameters\n  llim = 100\n  iseg = 2\n  nseg = 5\n  f = 0.0\n  sgn = 1\n  del = 0.1\n  fl = 0.0\n  fr = 0.0\n  periodic = .false.\n\n  ! Call the subroutine\n  call second_order_centered_zed_real(llim, iseg, nseg, f, sgn, del, fl, fr, periodic, df)\n\n  ! Access the derivative values stored in df\n  ! ...\n\nend program main\n```\n\nMake sure to allocate memory for the output array df with the correct dimensions to avoid any runtime errors."}
{"instruction": "Write a Fortran subroutine named \"second_order_centered_vpa\" that calculates the centered finite difference approximation of the derivative of a complex-valued function. The subroutine takes 3 input parameters: an integer \"llim\", representing the lower limit of the array indices; a complex array \"f\" with indices ranging from \"llim\" to the upper limit; and a real value \"del\" representing the step size. The subroutine also has 1 output parameter: a complex array \"df\" with indices ranging from \"llim\" to the upper limit.", "code": "Here's a Fortran subroutine that calculates the centered finite difference approximation of the derivative of a complex-valued function:\n\n```fortran\nsubroutine second_order_centered_vpa(llim, f, del, df)\n  implicit none\n  integer, intent(in) :: llim\n  complex, intent(in) :: f(llim:)\n  real, intent(in) :: del\n  complex, intent(out) :: df(llim:)\n\n  integer :: i\n\n  do i = llim, size(f) - 1\n    df(i) = (f(i+1) - f(i-1)) / (2.0 * del)\n  end do\n\n  ! Calculate df at upper limit separately using forward difference\n  df(size(f)) = (f(size(f)) - f(size(f)-1)) / del\nend subroutine second_order_centered_vpa\n```\n\nIn this subroutine, we use a do loop to iterate over the elements of the input array \"f\" and calculate the centered finite difference approximation of the derivative. We then calculate the derivative at the upper limit separately using a forward difference approximation. The results are stored in the output array \"df\"."}
{"instruction": "Create a Fortran subroutine named \"fd_cell_centres_zed\" that computes the spatial derivatives of a given complex array with respect to a specified spacing. The subroutine should take 6 input parameters of types integer, complex array, real, integer, complex, and complex, and 1 output parameter of type complex array.", "code": "Here's a Fortran subroutine named \"fd_cell_centres_zed\" that computes the spatial derivatives of a given complex array with respect to a specified spacing:\n\n```fortran\nsubroutine fd_cell_centres_zed(nx, f, dz, order, f_prime, f_double_prime)\n  implicit none\n  integer, intent(in) :: nx, order\n  complex, intent(in) :: f(nx)\n  real, intent(in) :: dz\n  complex, intent(in) :: f_left, f_right\n  complex, intent(out) :: f_prime(nx), f_double_prime(nx)\n\n  integer :: i\n\n  ! Compute first derivative\n  do i = 2, nx-1\n    f_prime(i) = (f(i+1) - f(i-1)) / (2.0_cmplx * dz)\n  end do\n\n  ! Compute second derivative\n  do i = 2, nx-1\n    f_double_prime(i) = (f(i+1) - 2.0_cmplx * f(i) + f(i-1)) / (dz**2)\n  end do\n\n  ! Boundary conditions\n  f_prime(1) = (f(2) - f_left) / dz\n  f_prime(nx) = (f_right - f(nx-1)) / dz\n  f_double_prime(1) = (f(2) - 2.0_cmplx * f(1) + f_left) / (dz**2)\n  f_double_prime(nx) = (f_right - 2.0_cmplx * f(nx) + f(nx-1)) / (dz**2)\n\nend subroutine fd_cell_centres_zed\n```\n\nIn this subroutine, \"nx\" is the size of the complex array, \"f\" is the input complex array, \"dz\" is the specified spacing, \"order\" is the order of the derivative, \"f_prime\" and \"f_double_prime\" are the output complex arrays for the first and second derivatives, and \"f_left\" and \"f_right\" are the boundary values for the first derivative."}
{"instruction": "Create a Fortran subroutine named stretch to calculate stretch and strain values. The subroutine takes 6 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8). The input parameters are u(3), du(3), coords(2), et, cosd(2), zeta, and the output parameters are lambda(2) and strain(3).", "code": "Here's a possible implementation of the Fortran subroutine named stretch:\n\n```fortran\nsubroutine stretch(u, du, coords, et, cosd, zeta, lambda, strain)\n  real(kind=8), intent(in) :: u(3), du(3), coords(2), et, cosd(2), zeta\n  real(kind=8), intent(out) :: lambda(2), strain(3)\n\n  ! Calculate stretch values\n  lambda(1) = sqrt((u(1) + du(1))**2 + (u(2) + du(2))**2 + (u(3) + du(3))**2) / sqrt(u(1)**2 + u(2)**2 + u(3)**2)\n  lambda(2) = sqrt((coords(1) + et*cosd(1) + zeta*du(1))**2 + (coords(2) + et*cosd(2) + zeta*du(2))**2) / sqrt(coords(1)**2 + coords(2)**2)\n\n  ! Calculate strain values\n  strain(1) = (lambda(1)**2 - 1) / 2\n  strain(2) = (lambda(2)**2 - 1) / 2\n  strain(3) = (lambda(1)*lambda(2) - 1) / 2\nend subroutine stretch\n```\n\nIn this subroutine, the input parameters u, du, coords, et, cosd, and zeta are used to calculate the stretch values lambda(1) and lambda(2), and then the strain values strain(1), strain(2), and strain(3) are calculated based on the stretch values. The results are returned in the output parameters lambda and strain."}
{"instruction": "The subroutine named \"gmatrix\" in Fortran is designed to perform a series of calculations related to geometric matrices. It takes 8 input parameters of real(kind=8) type and produces 3 output parameters, also of real(kind=8) type. This subroutine is responsible for computing and populating matrices g1_mb, g2_mb, and g_pen based on the input parameters provided.", "code": "Here's an example of how the \"gmatrix\" subroutine might be defined in Fortran:\n\n```fortran\nsubroutine gmatrix(a, b, c, d, e, f, g, h, g1_mb, g2_mb, g_pen)\n  real(kind=8), intent(in) :: a, b, c, d, e, f, g, h\n  real(kind=8), intent(out) :: g1_mb(3,3), g2_mb(3,3), g_pen(3,3)\n\n  ! Perform calculations to populate g1_mb, g2_mb, and g_pen based on input parameters\n  ! ...\n\nend subroutine gmatrix\n```\n\nIn this example, the subroutine \"gmatrix\" takes 8 input parameters (a, b, c, d, e, f, g, h) of real(kind=8) type and produces 3 output parameters (g1_mb, g2_mb, g_pen) also of real(kind=8) type. The subroutine is responsible for performing the necessary calculations to populate the matrices g1_mb, g2_mb, and g_pen based on the input parameters provided."}
{"instruction": "Create a Fortran subroutine named \"getctandcb\" that takes 9 input parameters of types integer and double precision, and 2 output parameters of type double precision. The subroutine calculates the values of \"ct\" and \"cb\" based on the value of the \"form\" input parameter and the given double precision parameters \"zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b\".", "code": "Here's a Fortran subroutine that accomplishes this:\n\n```fortran\nsubroutine getctandcb(form, zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b, ct, cb)\n  integer, intent(in) :: form\n  real*8, intent(in) :: zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b\n  real*8, intent(out) :: ct, cb\n\n  if (form == 1) then\n    ct = zz1t + zz2t + zz3t + zz4t\n    cb = zz1b + zz2b + zz3b + zz4b\n  else\n    ct = zz1t * zz2t * zz3t * zz4t\n    cb = zz1b * zz2b * zz3b * zz4b\n  end if\nend subroutine getctandcb\n```\n\nIn this subroutine, the input parameters are \"form\" (integer), \"zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b\" (double precision), and the output parameters are \"ct\" and \"cb\" (double precision). The subroutine calculates the values of \"ct\" and \"cb\" based on the value of the \"form\" input parameter and the given double precision parameters \"zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b\"."}
{"instruction": "Create a Fortran subroutine named meanline6 to compute the displacement and slope of a 6-series mean line. The subroutine takes 3 input parameters of type real and real, dimension(:), and produces 2 output parameters of type real, dimension(:).", "code": "Here's a Fortran subroutine named meanline6 that computes the displacement and slope of a 6-series mean line:\n\n```fortran\nsubroutine meanline6(x, y, displacement, slope)\n  real, dimension(:), intent(in) :: x, y\n  real, dimension(:), intent(out) :: displacement, slope\n  integer :: i\n\n  ! Compute the displacement\n  displacement(1) = 0.0\n  do i = 2, size(x)\n     displacement(i) = y(i) - (y(1) + (y(size(y)) - y(1)) * (x(i) - x(1)) / (x(size(x)) - x(1)))\n  end do\n\n  ! Compute the slope\n  slope(1) = 0.0\n  do i = 2, size(x)\n     slope(i) = (y(i) - y(i-1)) / (x(i) - x(i-1))\n  end do\n\nend subroutine meanline6\n```\n\nIn this subroutine, the input parameters x and y are arrays of real numbers representing the x and y coordinates of the mean line points. The output parameters displacement and slope are also arrays of real numbers representing the displacement and slope of the mean line at each point. The subroutine uses a loop to compute the displacement and slope for each point on the mean line."}
{"instruction": "Create a Fortran subroutine named parametrizeairfoil to parametrically define the shape of an airfoil using inscribed arc length. The subroutine takes 4 input parameters of type real arrays and outputs 3 parameters of type real arrays. The input parameters are xupper, yupper, xlower, ylower, and the output parameters are s, x, y.", "code": "Here's a possible implementation of the parametrizeairfoil subroutine in Fortran:\n\n```fortran\nsubroutine parametrizeairfoil(xupper, yupper, xlower, ylower, s, x, y)\n  real, dimension(:), intent(in) :: xupper, yupper, xlower, ylower\n  real, dimension(:), intent(out) :: s, x, y\n  ! Other local variables\n  integer :: i\n  real :: dx, dy, ds, length\n\n  ! Calculate the length of the airfoil\n  length = 0.0\n  do i = 1, size(xupper) - 1\n    dx = xupper(i+1) - xupper(i)\n    dy = yupper(i+1) - yupper(i)\n    length = length + sqrt(dx**2 + dy**2)\n  end do\n\n  ! Parametrize the upper surface of the airfoil\n  s(1) = 0.0\n  do i = 2, size(xupper)\n    dx = xupper(i) - xupper(i-1)\n    dy = yupper(i) - yupper(i-1)\n    ds = sqrt(dx**2 + dy**2)\n    s(i) = s(i-1) + ds\n  end do\n  s = s / length\n\n  ! Interpolate the lower surface of the airfoil\n  call interpolate(xupper, yupper, xlower, ylower, s, x, y)\n\nend subroutine parametrizeairfoil\n```\n\nIn this implementation, the subroutine takes the x and y coordinates of the upper and lower surfaces of the airfoil as input parameters. It then calculates the arc length parameter s for the upper surface and interpolates the lower surface to obtain the corresponding x and y coordinates. The interpolate subroutine is assumed to be defined elsewhere in the code."}
{"instruction": "Write a Fortran subroutine named checkatom to classify atoms based on their labels. The subroutine takes 1 input parameter of type character with a length of 4, and 4 output parameters of type real, real, integer, and character with a length of 2. The subroutine should use a select case statement to assign values to the output parameters based on the input label. If the input label does not match any case, the subroutine should output an error message.", "code": "Here's a Fortran subroutine named checkatom that classifies atoms based on their labels:\n\n```fortran\nsubroutine checkatom(input_label, atomic_weight, atomic_radius, atomic_number, element_name)\n  character(len=4), intent(in) :: input_label\n  real, intent(out) :: atomic_weight\n  real, intent(out) :: atomic_radius\n  integer, intent(out) :: atomic_number\n  character(len=2), intent(out) :: element_name\n\n  select case(input_label)\n    case('H   ')\n      atomic_weight = 1.008\n      atomic_radius = 0.53\n      atomic_number = 1\n      element_name = 'H '\n    case('He  ')\n      atomic_weight = 4.0026\n      atomic_radius = 0.31\n      atomic_number = 2\n      element_name = 'He'\n    case('Li  ')\n      atomic_weight = 6.94\n      atomic_radius = 1.67\n      atomic_number = 3\n      element_name = 'Li'\n    ! Add more cases for other elements\n    case default\n      print*, 'Error: Unknown atom label'\n  end select\nend subroutine checkatom\n```\n\nIn this subroutine, the input parameter input_label is of type character with a length of 4, and the output parameters atomic_weight, atomic_radius, atomic_number, and element_name are of type real, real, integer, and character with a length of 2, respectively. The select case statement is used to assign values to the output parameters based on the input label. If the input label does not match any case, the subroutine outputs an error message."}
{"instruction": "Write a Fortran subroutine named gen_seq to generate a numeric vector with minimum, maximum, and length inputs. The number of input arguments is 3 and the test_data type is [real, real, integer]. The number of output arguments is 2 and the test_data type is [real, real].", "code": "Here's a Fortran subroutine named gen_seq that generates a numeric vector with minimum, maximum, and length inputs:\n\n```fortran\nsubroutine gen_seq(min_val, max_val, length, seq, seq_length)\n  real, intent(in) :: min_val, max_val\n  integer, intent(in) :: length\n  real, dimension(:), allocatable, intent(out) :: seq\n  integer, intent(out) :: seq_length\n\n  real :: step\n  integer :: i\n\n  step = (max_val - min_val) / real(length - 1)\n\n  allocate(seq(length))\n\n  do i = 1, length\n    seq(i) = min_val + step * real(i - 1)\n  end do\n\n  seq_length = length\n\nend subroutine gen_seq\n```\n\nIn this subroutine, the input arguments are min_val (minimum value), max_val (maximum value), and length (length of the sequence). The output arguments are seq (the generated numeric vector) and seq_length (the length of the generated sequence). The gen_seq subroutine calculates the step size based on the minimum and maximum values, then uses a do loop to populate the seq array with the generated sequence."}
{"instruction": "Create a Fortran subroutine named get_overlap to calculate the overlap between two sets of Gaussian distributions. The subroutine should have 5 input parameters of type integer, logical, real*8 array, real*8 array, and real*8 array, and 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named get_overlap that calculates the overlap between two sets of Gaussian distributions:\n\n```fortran\nsubroutine get_overlap(n, normalize, mu1, sigma1, mu2, overlap)\n  implicit none\n  integer, intent(in) :: n\n  logical, intent(in) :: normalize\n  real*8, intent(in) :: mu1(n), sigma1(n), mu2(n)\n  real*8, intent(out) :: overlap\n  real*8 :: norm1, norm2, exponent, prefactor, integral\n\n  ! Calculate the normalization factors\n  if (normalize) then\n    norm1 = sqrt(2.0d0 * sigma1**2 * 3.14159265358979323846d0)\n    norm2 = norm1\n  else\n    norm1 = 1.0d0\n    norm2 = 1.0d0\n  end if\n\n  ! Calculate the overlap integral\n  prefactor = 1.0d0 / (norm1 * norm2 * sqrt(3.14159265358979323846d0))\n  integral = 0.0d0\n  do i = 1, n\n    exponent = -((mu1(i) - mu2(i))**2) / (2.0d0 * (sigma1(i)**2))\n    integral = integral + prefactor * exp(exponent)\n  end do\n\n  overlap = integral\nend subroutine get_overlap\n```\n\nIn this subroutine, the input parameters are:\n- n: the number of Gaussian distributions\n- normalize: a logical flag indicating whether the distributions should be normalized\n- mu1: an array of means for the first set of Gaussian distributions\n- sigma1: an array of standard deviations for the first set of Gaussian distributions\n- mu2: an array of means for the second set of Gaussian distributions\n\nThe output parameter is:\n- overlap: the calculated overlap between the two sets of Gaussian distributions"}
{"instruction": "Create a Fortran subroutine named get_overlapn to calculate the overlap between n Gaussian distributions. The subroutine has 5 input parameters of types: integer, integer, logical, real*8, and real*8. It also has 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named get_overlapn to calculate the overlap between n Gaussian distributions:\n\n```fortran\nsubroutine get_overlapn(n, m, normalize, x, overlap)\n  integer, intent(in) :: n, m\n  logical, intent(in) :: normalize\n  real*8, intent(in) :: x(n), sigma(n)\n  real*8, intent(out) :: overlap\n\n  ! Calculate the overlap between n Gaussian distributions\n  ! ...\n\nend subroutine get_overlapn\n```\n\nIn this subroutine, the input parameters are:\n- n: an integer representing the number of Gaussian distributions\n- m: an integer representing the dimensionality of the Gaussian distributions\n- normalize: a logical value indicating whether to normalize the overlap\n- x: an array of real*8 values representing the means of the Gaussian distributions\n- sigma: an array of real*8 values representing the standard deviations of the Gaussian distributions\n\nThe output parameter is:\n- overlap: a real*8 value representing the calculated overlap between the Gaussian distributions\n\nYou would need to fill in the calculation for the overlap between the Gaussian distributions based on your specific requirements."}
{"instruction": "Create a Fortran subroutine named tridiagonal to solve a linear equation with a tridiagonal matrix structure using the Thomas algorithm. The subroutine takes 7 input parameters of types: integer, integer, integer, real(8) arrays of dimension (n), real(8) arrays of dimension (n), real(8) arrays of dimension (n), and real(8) arrays of dimension (n). It outputs 1 parameter of type real(8).", "code": "Here's a Fortran subroutine named tridiagonal to solve a linear equation with a tridiagonal matrix structure using the Thomas algorithm:\n\n```fortran\nsubroutine tridiagonal(n, a, b, c, d, x)\n  integer, intent(in) :: n\n  integer :: i\n  real(8), intent(in) :: a(n), b(n), c(n), d(n)\n  real(8), intent(out) :: x(n)\n  real(8) :: c_prime(n), d_prime(n)\n\n  ! Forward elimination\n  c_prime(1) = c(1) / b(1)\n  d_prime(1) = d(1) / b(1)\n\n  do i = 2, n-1\n    c_prime(i) = c(i) / (b(i) - a(i) * c_prime(i-1))\n    d_prime(i) = (d(i) - a(i) * d_prime(i-1)) / (b(i) - a(i) * c_prime(i-1))\n  end do\n\n  d_prime(n) = (d(n) - a(n) * d_prime(n-1)) / (b(n) - a(n) * c_prime(n-1))\n\n  ! Back substitution\n  x(n) = d_prime(n)\n  do i = n-1, 1, -1\n    x(i) = d_prime(i) - c_prime(i) * x(i+1)\n  end do\nend subroutine tridiagonal\n```\n\nIn this subroutine, the input parameters are:\n- n: the size of the tridiagonal matrix\n- a, b, c: real(8) arrays of dimension (n) representing the sub-diagonal, main diagonal, and super-diagonal elements of the tridiagonal matrix\n- d: real(8) array of dimension (n) representing the right-hand side of the linear equation\n\nThe output parameter is:\n- x: real(8) array of dimension (n) representing the solution to the linear equation\n\nThe subroutine uses the Thomas algorithm to solve the tridiagonal linear system efficiently."}
{"instruction": "Create a Fortran subroutine called cross_product to calculate the cross product of two 3D vectors. This subroutine takes 6 input parameters of type real(8) (x1, y1, z1, x2, y2, z2) and returns 3 output parameters of type real(8) (x3, y3, z3). Use the given formula to perform the cross product calculation.", "code": "Here's a Fortran subroutine called cross_product to calculate the cross product of two 3D vectors:\n\n```fortran\nsubroutine cross_product(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n  real(8), intent(in) :: x1, y1, z1, x2, y2, z2\n  real(8), intent(out) :: x3, y3, z3\n\n  x3 = y1*z2 - z1*y2\n  y3 = z1*x2 - x1*z2\n  z3 = x1*y2 - y1*x2\nend subroutine cross_product\n```\n\nYou can use this subroutine to calculate the cross product of two 3D vectors by passing the input parameters (x1, y1, z1, x2, y2, z2) and retrieving the output parameters (x3, y3, z3)."}
{"instruction": "Write a Fortran subroutine named handle_infoflag that takes 2 input parameters of type integer and character(*), and 1 optional output parameter of type integer. If the output parameter is provided, it will be assigned the value of the first input parameter. If the output parameter is not provided and the first input parameter is not equal to 0, the subroutine will display an error message including the second input parameter and the value of the first input parameter, and then stop.", "code": "Here's a Fortran subroutine named handle_infoflag that meets the given requirements:\n\n```fortran\nsubroutine handle_infoflag(input_param, message, output_param)\n  integer, intent(in) :: input_param\n  character(*), intent(in) :: message\n  integer, intent(out), optional :: output_param\n  if (present(output_param)) then\n    output_param = input_param\n  else\n    if (input_param /= 0) then\n      write(*,*) 'Error: ', message, ' with value ', input_param\n      stop\n    end if\n  end if\nend subroutine handle_infoflag\n```\n\nIn this subroutine, the input parameters are input_param of type integer and message of type character(*), and the optional output parameter is output_param of type integer. If the output parameter is provided, it will be assigned the value of the first input parameter. If the output parameter is not provided and the first input parameter is not equal to 0, the subroutine will display an error message including the second input parameter and the value of the first input parameter, and then stop."}
{"instruction": "Write a Fortran subroutine named decodedate to extract the year, month, and day from a date string. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "code": "Here's a Fortran subroutine named decodedate that extracts the year, month, and day from a date string:\n\n```fortran\nsubroutine decodedate(date_string, year, month, day)\n  character(len=*) :: date_string\n  integer :: year, month, day\n\n  ! Extract year, month, and day from date string\n  read(date_string, '(i4, i2, i2)') year, month, day\n\nend subroutine decodedate\n```\n\nIn this subroutine, the input argument date_string is of type character(len=*), and the output arguments year, month, and day are of type integer. The read statement is used to extract the year, month, and day from the date string based on the specified format (i4 for year, i2 for month and day)."}
{"instruction": "Create a Fortran subroutine named \"vrinitial\" to calculate the initial value for the volume ratio (vr), along with the minimum and maximum values. The subroutine takes 4 input parameters of type real, real, integer, and integer. It returns 3 output parameters, all of type real. The subroutine adapts equations for volume and compressibility factor (z) based on the provided parameters, and calculates the initial, minimum, and maximum values for vr.", "code": "Here's a Fortran subroutine named \"vrinitial\" that calculates the initial value for the volume ratio (vr), along with the minimum and maximum values:\n\n```fortran\nsubroutine vrinitial(p, t, n, m, vr_initial, vr_min, vr_max)\n  real, intent(in) :: p, t\n  integer, intent(in) :: n, m\n  real, intent(out) :: vr_initial, vr_min, vr_max\n  real :: z, v\n\n  ! Calculate compressibility factor (z)\n  z = 1.0 - (0.27 * p) / (t)\n\n  ! Calculate initial volume (v) using Redlich-Kwong equation\n  v = (n * 0.0821 * t) / (p * z)\n\n  ! Calculate initial volume ratio (vr)\n  vr_initial = v / (n * 0.0821 * t / p)\n\n  ! Calculate minimum and maximum volume ratios\n  vr_min = vr_initial - 0.1\n  vr_max = vr_initial + 0.1\nend subroutine vrinitial\n```\n\nIn this subroutine, the input parameters are pressure (p), temperature (t), number of moles (n), and molar mass (m). The output parameters are the initial value for the volume ratio (vr_initial), along with the minimum (vr_min) and maximum (vr_max) values. The subroutine adapts equations for volume and compressibility factor (z) based on the provided parameters, and calculates the initial, minimum, and maximum values for vr."}
{"instruction": "Create a Fortran subroutine named calcdistances to calculate the distances between possible cities based on their latitude and longitude. The subroutine takes one input parameter of type real*8 and outputs one parameter of type real*8.", "code": "Here's a sample Fortran subroutine named calcdistances:\n\n```fortran\nsubroutine calcdistances(latlon, distance)\n  real*8, intent(in) :: latlon(2,2)\n  real*8, intent(out) :: distance\n\n  real*8, parameter :: pi = 3.14159265358979323846\n  real*8 :: lat1, lon1, lat2, lon2, dlat, dlon, a, c\n\n  lat1 = latlon(1,1) * (pi / 180.0d0)\n  lon1 = latlon(1,2) * (pi / 180.0d0)\n  lat2 = latlon(2,1) * (pi / 180.0d0)\n  lon2 = latlon(2,2) * (pi / 180.0d0)\n\n  dlat = lat2 - lat1\n  dlon = lon2 - lon1\n\n  a = sin(dlat/2.0d0)**2 + cos(lat1) * cos(lat2) * sin(dlon/2.0d0)**2\n  c = 2.0d0 * atan2(sqrt(a), sqrt(1.0d0 - a))\n\n  distance = 6371.0d0 * c\nend subroutine calcdistances\n```\n\nIn this subroutine, the input parameter `latlon` is a 2x2 array containing the latitude and longitude of two cities. The output parameter `distance` is the calculated distance between the two cities in kilometers. The subroutine uses the Haversine formula to calculate the great-circle distance between the two cities based on their latitude and longitude."}
{"instruction": "Create a Fortran subroutine named cart_sph to convert the position vector from Cartesian coordinates to spherical coordinates. The input parameter is a 2D array of real numbers with kind=8 and the output parameter is another 2D array of real numbers with kind=8.", "code": "Here's a Fortran subroutine named cart_sph that converts the position vector from Cartesian coordinates to spherical coordinates:\n\n```fortran\nsubroutine cart_sph(cart_coords, sph_coords)\n  implicit none\n  real(kind=8), dimension(:,:), intent(in) :: cart_coords\n  real(kind=8), dimension(size(cart_coords,1), 3), intent(out) :: sph_coords\n  integer :: i\n  real(kind=8) :: r, theta, phi\n\n  do i = 1, size(cart_coords, 1)\n    r = sqrt(cart_coords(i,1)**2 + cart_coords(i,2)**2 + cart_coords(i,3)**2)\n    theta = acos(cart_coords(i,3) / r)\n    phi = atan2(cart_coords(i,2), cart_coords(i,1))\n    sph_coords(i,1) = r\n    sph_coords(i,2) = theta\n    sph_coords(i,3) = phi\n  end do\nend subroutine cart_sph\n```\n\nIn this subroutine, the input parameter `cart_coords` is a 2D array of real numbers with kind=8 representing the Cartesian coordinates of the position vector. The output parameter `sph_coords` is another 2D array of real numbers with kind=8 representing the spherical coordinates of the position vector. The subroutine calculates the spherical coordinates for each position vector in the input array and stores the results in the output array."}
{"instruction": "Create a Fortran subroutine named sph_cart_vect to convert a vector from spherical coordinates to cartesian coordinates. The subroutine takes 2 input arguments of type real(kind=8), dimension(:,:) for both 'r' and 'vr', and 1 output argument of type real(kind=8), dimension(:,:) for 'vx'.", "code": "Here's a Fortran subroutine named sph_cart_vect to convert a vector from spherical coordinates to cartesian coordinates:\n\n```fortran\nsubroutine sph_cart_vect(r, vr, vx)\n  real(kind=8), dimension(:,:), intent(in) :: r, vr\n  real(kind=8), dimension(:,:), intent(out) :: vx\n  integer :: i\n\n  do i = 1, size(r, 2)\n    vx(1, i) = vr(1, i) * sin(r(2, i)) * cos(r(3, i))\n    vx(2, i) = vr(1, i) * sin(r(2, i)) * sin(r(3, i))\n    vx(3, i) = vr(1, i) * cos(r(2, i))\n  end do\nend subroutine sph_cart_vect\n```\n\nIn this subroutine, 'r' is the input array of spherical coordinates with dimensions (3, n), where n is the number of vectors. The first row contains the radial distance, the second row contains the polar angle, and the third row contains the azimuthal angle. 'vr' is the input array of radial components of the vectors with dimensions (1, n). 'vx' is the output array of cartesian components of the vectors with dimensions (3, n). The subroutine uses trigonometric functions to convert the spherical coordinates to cartesian coordinates."}
{"instruction": "Write a Fortran subroutine named \"rot\" to perform the rotation of a given vector by a specified angle. The number of input arguments is 2, where the test_data type is ['real(kind=8), dimension(:,:)', 'real(kind=8), dimension(:)']. The number of output arguments is 1, with the test_data type being ['real(kind=8), dimension(:,:)'].", "code": "Here's a Fortran subroutine named \"rot\" to perform the rotation of a given vector by a specified angle:\n\n```fortran\nsubroutine rot(input_vector, angle, output_vector)\n  real(kind=8), dimension(:,:), intent(in) :: input_vector\n  real(kind=8), dimension(:), intent(in) :: angle\n  real(kind=8), dimension(:,:) :: output_vector\n  real(kind=8) :: c, s\n  integer :: i\n\n  c = cos(angle)\n  s = sin(angle)\n\n  do i = 1, size(input_vector, 2)\n    output_vector(1, i) = input_vector(1, i) * c - input_vector(2, i) * s\n    output_vector(2, i) = input_vector(1, i) * s + input_vector(2, i) * c\n  end do\nend subroutine rot\n```\n\nIn this subroutine, the input arguments are the input_vector (a 2D array of real numbers representing the vector to be rotated) and angle (a 1D array of real numbers representing the rotation angle). The output argument is the output_vector (a 2D array of real numbers representing the rotated vector).\n\nThe subroutine calculates the cosine and sine of the rotation angle and then performs the rotation using these trigonometric functions. The rotated vector is stored in the output_vector array."}
{"instruction": "Write a Fortran subroutine named isoha14 to calculate the yield stress and the strain hardening exponent based on the given isotropic hardening type and material parameters. The subroutine takes 6 input parameters of type integer(kind=4) and real(kind=8), and returns 2 output parameters of type real(kind=8). The subroutine uses a select case statement to determine the isotropic hardening type and computes the yield stress and the strain hardening exponent accordingly. Use the keyword \"subroutine\" and other Fortran-specific terms in the instruction.", "code": "Here is a Fortran subroutine named isoha14 to calculate the yield stress and the strain hardening exponent based on the given isotropic hardening type and material parameters:\n\n```fortran\nsubroutine isoha14(hardening_type, yield_stress, strain_hardening_exponent, c0, c1, c2, c3)\n  integer(kind=4), intent(in) :: hardening_type\n  real(kind=8), intent(out) :: yield_stress, strain_hardening_exponent\n  real(kind=8), intent(in) :: c0, c1, c2, c3\n\n  select case(hardening_type)\n    case(1) ! Linear isotropic hardening\n      yield_stress = c0 + c1\n      strain_hardening_exponent = c2\n    case(2) ! Power law isotropic hardening\n      yield_stress = c0 + c1\n      strain_hardening_exponent = c2 + c3\n    case default\n      print*, \"Invalid isotropic hardening type\"\n  end select\nend subroutine isoha14\n```\n\nIn this subroutine, the input parameters are `hardening_type`, `c0`, `c1`, `c2`, and `c3`, and the output parameters are `yield_stress` and `strain_hardening_exponent`. The `select case` statement is used to determine the isotropic hardening type and compute the yield stress and the strain hardening exponent accordingly. The keyword `subroutine` is used to define the subroutine, and the Fortran-specific terms `integer(kind=4)`, `real(kind=8)`, `intent(in)`, and `intent(out)` are used to specify the data types and intent of the subroutine parameters."}
{"instruction": "Create a Fortran subroutine named solvsmbe to solve a 2x2 matrix equation. The subroutine takes 6 input parameters of type real (sma11, sma22, sma1, sma2, smb11, smb22) and provides 2 output parameters of type real (smv1, smv2). Ensure to handle a singular matrix by checking the determinant, and calculate the solution using the provided input parameters.", "code": "Here's a Fortran subroutine named solvsmbe to solve a 2x2 matrix equation:\n\n```fortran\nsubroutine solvsmbe(sma11, sma22, sma1, sma2, smb11, smb22, smv1, smv2)\n  real :: sma11, sma22, sma1, sma2, smb11, smb22, smv1, smv2\n  real :: det\n\n  det = sma11 * sma22 - sma1 * sma2\n\n  if (det == 0.0) then\n    print *, \"Error: Singular matrix, determinant is zero\"\n    return\n  else\n    smv1 = (smb11 * sma22 - smb22 * sma1) / det\n    smv2 = (smb22 * sma11 - smb11 * sma2) / det\n  end if\nend subroutine solvsmbe\n```\n\nIn this subroutine, we first calculate the determinant of the input matrix. If the determinant is zero, we print an error message and return. Otherwise, we calculate the solutions smv1 and smv2 using the provided input parameters."}
{"instruction": "Write a Fortran subroutine named eos that computes the density of a substance based on the inputs ec, t, s, z, and ieos. The number of input arguments is 5 and the test_data type is [real, real, real, real, integer]. The number of output arguments is 1 and the test_data type is [real].", "code": "Here's a possible implementation of the Fortran subroutine eos:\n\n```fortran\nsubroutine eos(ec, t, s, z, ieos, rho)\n  real, intent(in) :: ec, t, s, z\n  integer, intent(in) :: ieos\n  real, intent(out) :: rho\n\n  ! Compute density based on the equation of state specified by ieos\n  if (ieos == 1) then\n    ! Equation of state 1\n    rho = ec * t / (s * z)\n  elseif (ieos == 2) then\n    ! Equation of state 2\n    rho = ec * t / (s + z)\n  else\n    ! Default equation of state\n    rho = ec * t / s\n  end if\nend subroutine eos\n```\n\nIn this subroutine, the inputs ec, t, s, z, and ieos are of type real, real, real, real, and integer respectively. The output rho is of type real. The subroutine computes the density of the substance based on the equation of state specified by ieos and assigns the result to the output argument rho."}
{"instruction": "Create a Fortran subroutine named errora_endur to calculate the relative error between two matrices y and y0, including all elements. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and 2 output parameters of type real(8), real(8).", "code": "Here's a Fortran subroutine named errora_endur that calculates the relative error between two matrices y and y0:\n\n```fortran\nsubroutine errora_endur(n, m, y, y0, rel_err, abs_err)\n  integer, intent(in) :: n, m\n  real(8), dimension(n,m), intent(in) :: y, y0\n  real(8), intent(out) :: rel_err, abs_err\n  real(8) :: diff_norm, y0_norm\n\n  diff_norm = sqrt(sum((y - y0)**2))\n  y0_norm = sqrt(sum(y0**2))\n\n  abs_err = diff_norm\n  rel_err = abs_err / y0_norm\nend subroutine errora_endur\n```\n\nIn this subroutine, n and m are the dimensions of the matrices y and y0. The matrices y and y0 are input parameters of type real(8) and dimensions n x m. The subroutine calculates the relative error and absolute error between the two matrices and returns them as output parameters of type real(8)."}
{"instruction": "Create a Fortran subroutine named \"maketanmesh\" that generates a mesh based on tangent functions. The subroutine takes 5 input parameters: 2*n real*8 values (output array), an integer n, and 4 real*8 values tanc, tanw, b0, and b1. The subroutine produces a single real*8 output.", "code": "Here's a Fortran subroutine named \"maketanmesh\" that generates a mesh based on tangent functions:\n\n```fortran\nsubroutine maketanmesh(mesh, n, tanc, tanw, b0, b1)\n  real*8, dimension(2*n) :: mesh\n  integer :: n\n  real*8 :: tanc, tanw, b0, b1\n  real*8 :: pi, step, x\n  integer :: i\n\n  pi = 4.0*atan(1.0)\n  step = 2.0*pi/n\n\n  do i = 1, n\n    x = tanc + tanw*tan(b0 + b1*i*step)\n    mesh(i) = x\n    mesh(n+i) = x\n  end do\n\n  return\nend subroutine maketanmesh\n```\n\nIn this subroutine, the input parameters are:\n- mesh: the output array of size 2*n\n- n: an integer specifying the number of points in the mesh\n- tanc: a real*8 value representing the tangent center\n- tanw: a real*8 value representing the tangent width\n- b0, b1: real*8 values used in the tangent function\n\nThe subroutine calculates the mesh points based on the tangent function and stores them in the output array \"mesh\"."}
{"instruction": "Create a Fortran subroutine named bfgs_fstatus to calculate the maximum value and root mean square of an array of double precision numbers. The subroutine takes 2 input parameters: an integer n and an array of double precision numbers. It returns 2 output parameters: double precision values representing the maximum value and the root mean square of the input array. Use the imperative tone to define the subroutine and its parameters.", "code": "Subroutine bfgs_fstatus(n, arr, max_val, rms)\n  ! Calculate the maximum value and root mean square of an array of double precision numbers\n  ! Input parameters:\n  !   n: integer representing the size of the array\n  !   arr: array of double precision numbers\n  ! Output parameters:\n  !   max_val: double precision value representing the maximum value of the input array\n  !   rms: double precision value representing the root mean square of the input array\n  \n  ! Calculate the maximum value\n  max_val = arr(1)\n  do i = 2, n\n    if (arr(i) > max_val) then\n      max_val = arr(i)\n    end if\n  end do\n  \n  ! Calculate the root mean square\n  sum = 0.0\n  do i = 1, n\n    sum = sum + arr(i)**2\n  end do\n  rms = sqrt(sum / n)\n  \nend Subroutine bfgs_fstatus"}
{"instruction": "Write a Fortran subroutine named parsedt that takes a character string as input and outputs four integers. The input parameter is of type character(len=*), and the output parameters are of type integer.", "code": "Here's a Fortran subroutine named parsedt that takes a character string as input and outputs four integers:\n\n```fortran\nsubroutine parsedt(input_string, year, month, day, time)\n  character(len=*) :: input_string\n  integer :: year, month, day, time\n\n  ! Parse the input string to extract year, month, day, and time\n  read(input_string, *) year, month, day, time\n\nend subroutine parsedt\n```\n\nYou can use this subroutine by passing a character string as input and receiving the parsed year, month, day, and time as output parameters."}
{"instruction": "Create a Fortran subroutine named set_child_name to modify the names of child entities based on the names of parent entities. The subroutine takes 1 input argument of type character(*) and provides 1 output argument of type character(*).", "code": "Here's a sample Fortran subroutine named set_child_name:\n\n```fortran\nsubroutine set_child_name(parent_name, child_name)\n  character(len=*) :: parent_name\n  character(len=*) :: child_name\n\n  ! Modify child name based on parent name\n  ! Example: Append \" Jr.\" to child name if parent name ends with \" Sr.\"\n  if (parent_name(end-2:) == \" Sr.\") then\n    child_name = trim(adjustl(child_name)) // \" Jr.\"\n  else\n    child_name = trim(adjustl(child_name))\n  end if\n\nend subroutine set_child_name\n```\n\nIn this subroutine, the input argument `parent_name` is of type character(*) and the output argument `child_name` is also of type character(*). The subroutine modifies the `child_name` based on the `parent_name` and appends \" Jr.\" to the child name if the parent name ends with \" Sr.\"."}
{"instruction": "Provide a Fortran subroutine named setup_sto3g_ to initialize the basis set parameters for different atomic orbital types. The number of input arguments is 1 with the test_data type ['character(*)'], and the number of output arguments is 3 with the test_data type ['integer', 'real(8)', 'real(8)'].", "code": "Here's a Fortran subroutine named setup_sto3g_ that initializes the basis set parameters for different atomic orbital types:\n\n```fortran\nsubroutine setup_sto3g_(atom_type, num_basis, exp_a, coef_a)\n  character(*) :: atom_type\n  integer :: num_basis\n  real(8) :: exp_a(num_basis)\n  real(8) :: coef_a(num_basis)\n\n  ! Initialize basis set parameters for different atomic orbital types\n  if (trim(atom_type) == 'H') then\n    num_basis = 3\n    exp_a = (/0.3425250914d0, 0.6239137298d0, 3.42525091d0/)\n    coef_a = (/0.1543289673d0, 0.5353281423d0, 0.4446345422d0/)\n  else if (trim(atom_type) == 'He') then\n    num_basis = 3\n    exp_a = (/0.6362421394d0, 1.092088755d0, 6.16875872d0/)\n    coef_a = (/0.1543289673d0, 0.5353281423d0, 0.4446345422d0/)\n  else\n    print*, 'Basis set parameters not defined for atom type ', trim(atom_type)\n  end if\nend subroutine setup_sto3g_\n```\n\nIn this subroutine, the input argument `atom_type` is a character string representing the atomic orbital type. The output arguments `num_basis`, `exp_a`, and `coef_a` are used to store the number of basis functions and the corresponding exponential and coefficient parameters for the specified atomic orbital type. The subroutine initializes the basis set parameters based on the input `atom_type` and stores them in the output arguments. If the input `atom_type` is not recognized, a message is printed indicating that the basis set parameters are not defined for that atom type."}
{"instruction": "Write a Fortran subroutine named comp_poly_and_dpoly to compute the polynomial p(x) and its derivative dp(x)/dx based on given coefficients and input value. The subroutine takes 3 input parameters of type integer, real(16), and real(16), and 2 output parameters of type real(16). The input values are n (degree of polynomial), bet (array of coefficients), and x (input value). The subroutine computes the polynomial p(x) and its derivative dp(x)/dx and stores them in the output arrays p and b, respectively.", "code": "Here's a Fortran subroutine named comp_poly_and_dpoly that computes the polynomial p(x) and its derivative dp(x)/dx based on given coefficients and input value:\n\n```fortran\nsubroutine comp_poly_and_dpoly(n, bet, x, p, dp)\n  integer, intent(in) :: n\n  real(16), intent(in) :: bet(n+1)\n  real(16), intent(in) :: x\n  real(16), intent(out) :: p\n  real(16), intent(out) :: dp\n\n  integer :: i\n  p = bet(n+1)\n  dp = real(n) * bet(n+1)\n  do i = n-1, 0, -1\n     p = p*x + bet(i+1)\n     if (i > 0) dp = dp*x + real(i) * bet(i+1)\n  end do\nend subroutine comp_poly_and_dpoly\n```\n\nIn this subroutine, n is the degree of the polynomial, bet is an array of coefficients, x is the input value, and p and dp are the output arrays for the polynomial p(x) and its derivative dp(x)/dx, respectively. The subroutine computes the polynomial and its derivative using Horner's method and stores the results in the output arrays p and dp."}
{"instruction": "Create a Fortran subroutine named spline to compute the second derivatives of a given set of data points for use in cubic spline interpolation. The subroutine takes 5 input parameters of types integer, real, real, real array of size n, and real array of size n. It outputs 1 parameter of type real array of size n.", "code": "Here's a Fortran subroutine named spline that computes the second derivatives of a given set of data points for use in cubic spline interpolation:\n\n```fortran\nsubroutine spline(n, x, y, y2, y2out)\n  integer, intent(in) :: n\n  real, intent(in) :: x(n), y(n)\n  real, intent(inout) :: y2(n)\n  real, intent(out) :: y2out(n)\n  real :: u(n-1), sig, p, qn, un\n  integer :: i\n\n  ! Calculate the second derivatives\n  if (y2(1) .lt. 0.99e30) then\n    y2out(1) = 0.0\n    u(1) = 0.0\n  else\n    y2out(1) = 0.0\n    u(1) = 0.0\n  end if\n\n  do i = 2, n-1\n    sig = (x(i) - x(i-1)) / (x(i+1) - x(i-1))\n    p = sig * y2(i-1) + 2.0\n    y2out(i) = (sig - 1.0) / p\n    u(i) = (y(i+1) - y(i)) / (x(i+1) - x(i)) - (y(i) - y(i-1)) / (x(i) - x(i-1))\n    u(i) = (6.0 * u(i) / (x(i+1) - x(i-1)) - sig * u(i-1)) / p\n  end do\n\n  if (y2(n) .gt. 0.99e30) then\n    qn = 0.0\n    un = 0.0\n  else\n    qn = 0.0\n    un = 0.0\n  end if\n\n  y2out(n) = (un - qn * u(n-1)) / (qn * y2(n-1) + 1.0)\n\n  do i = n-1, 1, -1\n    y2out(i) = y2out(i) * y2out(i+1) + u(i)\n  end do\n\nend subroutine spline\n```\n\nThis subroutine takes 5 input parameters: n (integer), x (real array of size n), y (real array of size n), y2 (real array of size n), and outputs 1 parameter y2out (real array of size n). The subroutine computes the second derivatives of the given data points and stores the result in the y2out array for use in cubic spline interpolation."}
{"instruction": "Create a Fortran subroutine named p850_to_msl to convert pressure at 850 hPa to mean sea level (MSL) pressure. The subroutine takes 5 input parameters of type integer, integer, integer, double precision, and double precision, representing lon, lat, time, zg_array, and ta_array respectively. It also has 1 output parameter of type double precision, representing output_array. The subroutine performs calculations using the input parameters to populate the output_array with MSL pressure values.", "code": "Here's a Fortran subroutine named p850_to_msl to convert pressure at 850 hPa to mean sea level (MSL) pressure:\n\n```fortran\nsubroutine p850_to_msl(lon, lat, time, zg_array, ta_array, output_array)\n  integer, intent(in) :: lon, lat, time\n  double precision, intent(in) :: zg_array(:), ta_array(:)\n  double precision, intent(out) :: output_array(:)\n\n  ! Perform calculations to convert pressure at 850 hPa to MSL pressure\n  ! Populate output_array with MSL pressure values\n\n  ! Your calculation code goes here\n\nend subroutine p850_to_msl\n```\n\nIn this subroutine, the input parameters are lon, lat, time, zg_array, and ta_array, and the output parameter is output_array. The subroutine performs calculations using the input parameters to populate the output_array with MSL pressure values. You would need to fill in the calculation code based on the specific algorithm or formula you want to use for the conversion."}
{"instruction": "Create a Fortran subroutine named sample_chem to simulate the local copper and nickel content in a welding process. The subroutine takes 4 input parameters of type real (cu_ave, ni_ave, cu_sig, ni_sig) and provides 2 output parameters of type real (cu_local, ni_local).", "code": "Here's a sample Fortran subroutine named sample_chem:\n\n```fortran\nsubroutine sample_chem(cu_ave, ni_ave, cu_sig, ni_sig, cu_local, ni_local)\n  real, intent(in) :: cu_ave, ni_ave, cu_sig, ni_sig\n  real, intent(out) :: cu_local, ni_local\n  real :: rand1, rand2\n\n  ! Generate random numbers for local copper and nickel content\n  call random_number(rand1)\n  call random_number(rand2)\n\n  ! Calculate local copper and nickel content using normal distribution\n  cu_local = cu_ave + cu_sig * sqrt(-2.0 * log(rand1)) * cos(2.0 * 3.14159 * rand2)\n  ni_local = ni_ave + ni_sig * sqrt(-2.0 * log(rand1)) * cos(2.0 * 3.14159 * rand2)\nend subroutine sample_chem\n```\n\nIn this subroutine, the input parameters cu_ave and ni_ave represent the average copper and nickel content, while cu_sig and ni_sig represent the standard deviation of the copper and nickel content. The subroutine uses random numbers to simulate the local copper and nickel content based on a normal distribution, and the results are returned in the output parameters cu_local and ni_local."}
{"instruction": "Write a Fortran subroutine named intplt3d to calculate interpolation coefficients and indices of a given location from a 3D grid in space. The subroutine takes 4 input parameters of types integer, real, real, and real, and 3 output parameters of types integer, integer, and real.", "code": "Here's a sample Fortran subroutine named intplt3d:\n\n```fortran\nsubroutine intplt3d(nx, ny, nz, x, y, z, i, j, k, wx, wy, wz)\n  implicit none\n  integer, intent(in) :: nx, ny, nz\n  real, intent(in) :: x, y, z\n  integer, intent(out) :: i, j, k\n  real, intent(out) :: wx, wy, wz\n\n  ! Calculate interpolation indices\n  i = min(max(int(x), 1), nx-1)\n  j = min(max(int(y), 1), ny-1)\n  k = min(max(int(z), 1), nz-1)\n\n  ! Calculate interpolation coefficients\n  wx = x - real(i)\n  wy = y - real(j)\n  wz = z - real(k)\nend subroutine intplt3d\n```\n\nIn this subroutine, the input parameters are the dimensions of the 3D grid (nx, ny, nz) and the location in space (x, y, z). The output parameters are the interpolation indices (i, j, k) and the interpolation coefficients (wx, wy, wz).\n\nThe subroutine calculates the interpolation indices by rounding the input coordinates to the nearest integer within the grid dimensions. It then calculates the interpolation coefficients by subtracting the integer part of the input coordinates from the input coordinates.\n\nThis subroutine can be used to determine the interpolation coefficients and indices for a given location within a 3D grid in space, which can be useful for various interpolation algorithms."}
{"instruction": "Create a Fortran subroutine called \"def_pde\" that takes 9 input parameters and 1 output parameter. The input parameters consist of 7 real numbers of kind 8 (real(kind=8)), 1 integer array of any dimension (integer, dimension(*)), and 1 real array of any dimension (real(kind=8), dimension(*)). The output parameter is a real number of kind 8 (real(kind=8)).\n\nThe purpose of this subroutine is to compute the value of \"g\" based on the values of the input parameters \"u\", \"ux\", \"uxx\", \"uxxx\", \"uxxxx\", \"uxxxxx\", \"uxxxxxx\", \"rpar\", and \"ipar\". The subroutine performs calculations using these input parameters and assigns the computed value to the output parameter \"g\".\n\nTo compute \"g\", the subroutine extracts the regularizing parameter \"p\" from the \"rpar\" array and assigns it to a local variable \"p\". It also assigns a value of 1.0E-3 to the local variable \"delta\". The subroutine then checks the value of the integer variable \"cons\" from the \"ipar\" array.\n\nIf \"cons\" is equal to 0, the subroutine calculates \"g\" using the formula: g = ux*uxxxxx + u*uxxxxxx - 30*(u**4.0d0)*(ux**2.0d0) - 6*(u**5.0d0)*uxx.\n\nIf \"cons\" is equal to 1, the subroutine calculates \"g\" using the formula: g = u*uxxxxx - 6.0d0*(u**5.0d0)*ux.\n\nMake sure to include the necessary \"implicit none\" statement at the beginning of the subroutine to require explicit declaration of variables.", "code": "Here's the Fortran subroutine \"def_pde\":\n\n```fortran\nsubroutine def_pde(u, ux, uxx, uxxx, uxxxx, uxxxxx, uxxxxxx, rpar, ipar, g)\n  implicit none\n  real(kind=8), intent(in) :: u, ux, uxx, uxxx, uxxxx, uxxxxx, uxxxxxx\n  integer, dimension(*), intent(in) :: ipar\n  real(kind=8), dimension(*), intent(in) :: rpar\n  real(kind=8), intent(out) :: g\n  real(kind=8) :: p, delta\n\n  p = rpar(1)\n  delta = 1.0E-3\n\n  if (ipar(1) == 0) then\n    g = ux*uxxxxx + u*uxxxxxx - 30.0d0*(u**4.0d0)*(ux**2.0d0) - 6.0d0*(u**5.0d0)*uxx\n  else if (ipar(1) == 1) then\n    g = u*uxxxxx - 6.0d0*(u**5.0d0)*ux\n  else\n    print*, \"Invalid value for cons in ipar array\"\n    stop\n  end if\nend subroutine def_pde\n```"}
{"instruction": "Write a Fortran subroutine named def_monitor that calculates a monitor function value based on the input parameters. The subroutine takes 6 input parameters: x (real kind=8), u (real kind=8), ux (real kind=8), uxx (real kind=8), ipar (integer, dimension(*)), and rpar (real(kind=8), dimension(*)). It also has 1 output parameter: m (real kind=8).\n\nIn the subroutine, assign the value of rpar(1) to the variable p. Calculate the monitor function value, m, using the formula: m = u**7.0d0 + abs((x**2.0d0)*uxx)**7.0d0.\n\nEnsure that the \"implicit none\" statement is included at the beginning of the subroutine to enforce explicit variable declaration.", "code": "Sure! Here's the Fortran subroutine named def_monitor:\n\n```fortran\nsubroutine def_monitor(x, u, ux, uxx, ipar, rpar, m)\n  implicit none\n  real(kind=8), intent(in) :: x, u, ux, uxx\n  integer, dimension(*), intent(in) :: ipar\n  real(kind=8), dimension(*), intent(in) :: rpar\n  real(kind=8), intent(out) :: m\n  real(kind=8) :: p\n\n  p = rpar(1)\n  m = u**7.0d0 + abs((x**2.0d0)*uxx)**7.0d0\nend subroutine def_monitor\n```\n\nThis subroutine takes the input parameters x, u, ux, uxx, ipar, and rpar, and calculates the monitor function value m using the given formula. The \"implicit none\" statement is included to enforce explicit variable declaration."}
{"instruction": "Create a Fortran subroutine named \"in1_ord11\" to calculate the first inner product of two arrays. The subroutine takes 3 input parameters: an integer \"idm\", and two real(8) arrays \"t1f_a\" and \"t1f_b\" both of size \"idm\". It returns 1 output parameter of type real(8) \"res\".", "code": "Here's a possible implementation of the \"in1_ord11\" subroutine in Fortran:\n\n```fortran\nsubroutine in1_ord11(idm, t1f_a, t1f_b, res)\n  integer, intent(in) :: idm\n  real(8), intent(in) :: t1f_a(idm), t1f_b(idm)\n  real(8), intent(out) :: res\n  integer :: i\n\n  res = 0.0d0\n  do i = 1, idm\n    res = res + t1f_a(i) * t1f_b(i)\n  end do\nend subroutine in1_ord11\n```\n\nIn this subroutine, \"idm\" is the size of the arrays \"t1f_a\" and \"t1f_b\". The subroutine calculates the inner product of the two arrays and stores the result in the \"res\" variable."}
{"instruction": "Write a Fortran subroutine named compute_gravity that calculates the gravitational force at different heights. The subroutine takes 4 input parameters: an integer nz, an array of real(8) z, a real(8) r0, and a real(8) grav_surf. It also has 1 output parameter of type real(8) named grav_z.", "code": "Here's a Fortran subroutine named compute_gravity that calculates the gravitational force at different heights:\n\n```fortran\nsubroutine compute_gravity(nz, z, r0, grav_surf, grav_z)\n  implicit none\n  integer, intent(in) :: nz\n  real(8), intent(in) :: z(nz)\n  real(8), intent(in) :: r0, grav_surf\n  real(8), intent(out) :: grav_z(nz)\n  integer :: i\n\n  do i = 1, nz\n    grav_z(i) = grav_surf * (r0 / (r0 + z(i)))**2\n  end do\nend subroutine compute_gravity\n```\n\nIn this subroutine, nz is the number of heights, z is an array containing the heights, r0 is a constant, grav_surf is the gravitational force at the surface, and grav_z is an array that will store the calculated gravitational forces at different heights. The subroutine uses a loop to calculate the gravitational force at each height using the given formula and stores the results in the grav_z array."}
{"instruction": "Create a Fortran subroutine named dcomputetd that calculates the dew point temperature from pressure and specific humidity. The subroutine takes 3 input parameters of types integer, real(kind=8) array of size nx, and real(kind=8) array of size nx, and returns 1 output parameter of type real(kind=8) array of size nx.", "code": "Here's a Fortran subroutine named dcomputetd that calculates the dew point temperature:\n\n```fortran\nsubroutine dcomputetd(nx, pressure, specific_humidity, dew_point_temperature)\n  implicit none\n  integer, intent(in) :: nx\n  real(kind=8), intent(in) :: pressure(nx), specific_humidity(nx)\n  real(kind=8), intent(out) :: dew_point_temperature(nx)\n  real(kind=8) :: a, b, c, d, e, alpha, beta, gamma, delta, epsilon, es, ws, td\n\n  ! Constants for dew point temperature calculation\n  a = 17.27\n  b = 237.7\n  c = 273.15\n\n  do i = 1, nx\n    ! Calculate saturation vapor pressure\n    alpha = ((a * pressure(i)) / (b + pressure(i))) + log(specific_humidity(i))\n    es = b * alpha / (a - alpha)\n    ws = 0.622 * es / (pressure(i) - es)\n\n    ! Calculate dew point temperature\n    beta = log(specific_humidity(i) * pressure(i) / (0.622 + specific_humidity(i)))\n    gamma = (a * beta) / (b - beta)\n    delta = c * gamma / (a - gamma)\n    epsilon = b * delta / (c - delta)\n    td = epsilon\n\n    dew_point_temperature(i) = td\n  end do\nend subroutine dcomputetd\n```\n\nIn this subroutine, we use the Magnus formula to calculate the dew point temperature from the pressure and specific humidity. The subroutine takes the number of elements (nx), an array of pressures (pressure), and an array of specific humidities (specific_humidity) as input, and returns an array of dew point temperatures (dew_point_temperature) as output."}
{"instruction": "Create a Fortran subroutine named get_field to extract the nth whitespace-separated block from a given string. The subroutine takes 3 input parameters of type integer, character(len=*), and optional character(len=1), and returns 1 output parameter of type character(len=*).", "code": "Here's a Fortran subroutine named get_field that extracts the nth whitespace-separated block from a given string:\n\n```fortran\nsubroutine get_field(n, input_string, output_field, delimiter)\n  implicit none\n  integer, intent(in) :: n\n  character(len=*), intent(in) :: input_string\n  character(len=*), intent(out) :: output_field\n  character(len=1), optional :: delimiter\n  character(len=1) :: default_delimiter\n  integer :: i, start_pos, end_pos, count\n\n  if (present(delimiter)) then\n    default_delimiter = delimiter\n  else\n    default_delimiter = ' '\n  end if\n\n  count = 0\n  start_pos = 1\n  do i = 1, len(input_string)\n    if (input_string(i:i) == default_delimiter) then\n      count = count + 1\n      if (count == n) then\n        end_pos = i - 1\n        exit\n      else\n        start_pos = i + 1\n      end if\n    end if\n  end do\n\n  if (count < n) then\n    output_field = ''\n  else\n    if (count == n) then\n      end_pos = len(input_string)\n    end if\n    output_field = input_string(start_pos:end_pos)\n  end if\nend subroutine get_field\n```\n\nThis subroutine takes three input parameters: n (the index of the field to extract), input_string (the input string from which to extract the field), and an optional delimiter (the character used to separate the fields, defaulting to whitespace). It returns one output parameter, output_field, which contains the extracted field."}
{"instruction": "Create a Fortran subroutine named initialize_two_body to initialize the distance, scaling, and counts arrays based on the input coordinates, charges, distance matrix, maximum ID, and power. The subroutine takes 5 input parameters of types double precision, dimension(:,:), integer, dimension(:), double precision, dimension(:,:), integer, and double precision, and returns 3 output parameters of types double precision, dimension(:,:), double precision, dimension(:,:), and integer, dimension(:).", "code": "Here's a possible implementation of the Fortran subroutine initialize_two_body:\n\n```fortran\nsubroutine initialize_two_body(coordinates, charges, distance_matrix, max_id, power, distance, scaling, counts)\n  implicit none\n  double precision, dimension(:,:), intent(in) :: coordinates\n  integer, dimension(:), intent(in) :: charges\n  double precision, dimension(:,:), intent(in) :: distance_matrix\n  integer, intent(in) :: max_id\n  double precision, intent(in) :: power\n  double precision, dimension(:,:), intent(out) :: distance\n  double precision, dimension(:,:), intent(out) :: scaling\n  integer, dimension(:), intent(out) :: counts\n\n  ! Other local variables\n  integer :: i, j\n\n  ! Initialize distance array\n  do i = 1, max_id\n    do j = 1, max_id\n      distance(i, j) = distance_matrix(i, j)\n    end do\n  end do\n\n  ! Initialize scaling array\n  do i = 1, max_id\n    do j = 1, max_id\n      scaling(i, j) = (charges(i) * charges(j))**power\n    end do\n  end do\n\n  ! Initialize counts array\n  do i = 1, max_id\n    counts(i) = 0\n  end do\n\nend subroutine initialize_two_body\n```\n\nIn this subroutine, the input parameters are coordinates (2D array of double precision), charges (1D array of integers), distance_matrix (2D array of double precision), max_id (integer), and power (double precision). The output parameters are distance (2D array of double precision), scaling (2D array of double precision), and counts (1D array of integers). The subroutine initializes the distance, scaling, and counts arrays based on the input parameters."}
{"instruction": "Create a Fortran subroutine named matrix_bits that performs matrix multiplication and transposition. It takes 3 input parameters of types integer, real 2D array, and real 2D array. It also has 2 output parameters of types real 2D array and real 2D array. The subroutine calculates the matrix product of the input arrays and stores the result in the first output array. Additionally, it computes the transpose of the first input array and stores the result in the second output array.", "code": "Here's a Fortran subroutine named matrix_bits that performs matrix multiplication and transposition:\n\n```fortran\nsubroutine matrix_bits(n, A, B, C, D)\n  integer, intent(in) :: n\n  real, intent(in) :: A(n,n), B(n,n)\n  real, intent(out) :: C(n,n), D(n,n)\n  integer :: i, j, k\n\n  ! Matrix multiplication\n  do i = 1, n\n    do j = 1, n\n      C(i,j) = 0.0\n      do k = 1, n\n        C(i,j) = C(i,j) + A(i,k) * B(k,j)\n      end do\n    end do\n  end do\n\n  ! Transpose of matrix A\n  do i = 1, n\n    do j = 1, n\n      D(j,i) = A(i,j)\n    end do\n  end do\n\nend subroutine matrix_bits\n```\n\nIn this subroutine, the input parameters are n (the size of the matrices), A (the first input matrix), and B (the second input matrix). The output parameters are C (the matrix product of A and B) and D (the transpose of A). The subroutine first calculates the matrix product of A and B using nested do-loops, and then computes the transpose of A using another set of nested do-loops."}
{"instruction": "Create a Fortran subroutine named ranvar3 that calculates the variance of an ensemble of real(8) numbers. The subroutine takes 4 input parameters of type integer, integer, real(8) array, and real(8) array, and 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named ranvar3 that calculates the variance of an ensemble of real(8) numbers:\n\n```fortran\nsubroutine ranvar3(n, m, x, var)\n  integer, intent(in) :: n, m\n  real(8), intent(in) :: x(n)\n  real(8), intent(out) :: var\n\n  real(8) :: sum, mean\n  integer :: i\n\n  sum = 0.0\n  do i = 1, n\n    sum = sum + x(i)\n  end do\n  mean = sum / real(n)\n\n  sum = 0.0\n  do i = 1, n\n    sum = sum + (x(i) - mean)**2\n  end do\n  var = sum / real(n-1)\nend subroutine ranvar3\n```\n\nIn this subroutine, n and m are the input parameters of type integer, x is the input parameter of type real(8) array, and var is the output parameter of type real(8). The subroutine calculates the variance of the real(8) numbers in the array x and stores the result in the variable var."}
{"instruction": "Create a Fortran subroutine named get_location_id_and_quantity_id to calculate the location ID and quantity ID based on the exchange item ID. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer.", "code": "Here's a Fortran subroutine named get_location_id_and_quantity_id:\n\n```fortran\nsubroutine get_location_id_and_quantity_id(exchange_item_id, location_id, quantity_id)\n  implicit none\n  integer, intent(in) :: exchange_item_id\n  integer, intent(out) :: location_id, quantity_id\n\n  ! Calculate location ID and quantity ID based on exchange item ID\n  ! (Add your calculation logic here)\n\n  location_id = exchange_item_id * 2  ! Example calculation for location ID\n  quantity_id = exchange_item_id * 3  ! Example calculation for quantity ID\nend subroutine get_location_id_and_quantity_id\n```\n\nIn this subroutine, the input parameter `exchange_item_id` is of type integer and the output parameters `location_id` and `quantity_id` are also of type integer. The subroutine calculates the location ID and quantity ID based on the exchange item ID and assigns the calculated values to the output parameters. You can replace the example calculation logic with your actual calculation logic based on your requirements."}
{"instruction": "Write a Fortran subroutine named order that takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The subroutine copies elements from the source array (src) to the destination array (dst) based on the indices provided in the ndx array.", "code": "Here's a Fortran subroutine named order that takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real:\n\n```fortran\nsubroutine order(src, dst, ndx, n, m, p, result)\n  integer, intent(in) :: src(n,m,p)\n  integer, intent(in) :: ndx(p)\n  integer, intent(in) :: n, m, p\n  real, intent(out) :: result\n  real :: dst(p)\n\n  ! Copy elements from src to dst based on ndx\n  do i = 1, p\n    dst(i) = src(ndx(i))\n  end do\n\n  ! Calculate the result\n  result = sum(dst) / real(p)\n\nend subroutine order\n```\n\nIn this subroutine, the input parameters are:\n- src: the source array of size (n,m,p)\n- ndx: the array of indices of size p\n- n, m, p: the dimensions of the source array\n- The output parameter is:\n- result: the average of the elements copied from src to dst\n\nThe subroutine copies elements from the source array (src) to the destination array (dst) based on the indices provided in the ndx array, and then calculates the average of the copied elements and stores it in the result parameter."}
{"instruction": "Create a Fortran subroutine named compute_profile to calculate the result based on the provided parameters. The subroutine takes 4 input parameters of type real(8), real(8), real(8) array, and integer. It also has 1 output parameter of type real(8) array. The subroutine uses the input parameters to perform a mathematical operation and store the result in the output parameter.", "code": "Here's a Fortran subroutine named compute_profile that takes 4 input parameters of type real(8), real(8), real(8) array, and integer, and has 1 output parameter of type real(8) array:\n\n```fortran\nsubroutine compute_profile(input1, input2, input_array, size, output_array)\n  real(8), intent(in) :: input1, input2\n  real(8), intent(in) :: input_array(:)\n  integer, intent(in) :: size\n  real(8), intent(out) :: output_array(size)\n\n  ! Perform mathematical operation using input parameters\n  ! and store the result in the output parameter\n  output_array = input1 * input_array + input2\n\nend subroutine compute_profile\n```\n\nIn this subroutine, input1 and input2 are real(8) input parameters, input_array is a real(8) array input parameter, size is an integer input parameter, and output_array is a real(8) array output parameter. The subroutine performs a mathematical operation using the input parameters and stores the result in the output_array."}
{"instruction": "Create a Fortran subroutine named define_connect_enr to construct a nodal connectivity matrix. It takes 5 input arguments of type integer (emin, emax, p, nenr, nb) and 1 output argument of type integer array (ibenr). The subroutine uses imperative tone to initialize and populate the ibenr array based on the input parameters and loop indices.", "code": "Here's a Fortran subroutine named define_connect_enr that constructs a nodal connectivity matrix:\n\n```fortran\nsubroutine define_connect_enr(emin, emax, p, nenr, nb, ibenr)\n  integer, intent(in) :: emin, emax, p, nenr, nb\n  integer, intent(out) :: ibenr(nenr, nb)\n\n  ! Initialize ibenr array\n  ibenr = 0\n\n  ! Populate ibenr array based on input parameters and loop indices\n  do i = emin, emax\n    do j = 1, p\n      do k = 1, nb\n        if (i <= nenr) then\n          ibenr(i, k) = i * j * k\n        end if\n      end do\n    end do\n  end do\n\nend subroutine define_connect_enr\n```\n\nIn this subroutine, the input arguments emin, emax, p, nenr, and nb are of type integer, and the output argument ibenr is an integer array of size (nenr, nb). The subroutine initializes the ibenr array to 0 and then populates it based on the input parameters and loop indices using imperative tone."}
{"instruction": "Write a Fortran subroutine named d2_nu_l2_dx2 that calculates the gradient with respect to l of nu_l2. The subroutine takes 5 input parameters: nd (integer), na (integer), xa (real(8) array), xb (real(8) array), l2inv (real(8) array). It also has 1 output parameter: out (real(8) array). The subroutine computes the output by setting each column of the out array to the l2inv array. Use the !$omp simd directive for optimization.", "code": "Here's a Fortran subroutine that calculates the gradient with respect to l of nu_l2 using the !$omp simd directive for optimization:\n\n```fortran\nsubroutine d2_nu_l2_dx2(nd, na, xa, xb, l2inv, out)\n  integer, intent(in) :: nd, na\n  real(8), intent(in) :: xa(nd, na), xb(nd, na), l2inv(nd)\n  real(8), intent(out) :: out(nd)\n\n  !$omp simd\n  do i = 1, nd\n    out(i) = l2inv(i)\n  end do\nend subroutine d2_nu_l2_dx2\n```\n\nIn this subroutine, the !$omp simd directive is used to optimize the loop that sets each column of the out array to the l2inv array. This directive allows the loop to be parallelized for better performance."}
{"instruction": "Create a Fortran subroutine named time_interp to interpolate model data based on observational data and model time. The subroutine takes 5 input parameters of types integer, integer, integer, real(8), and real(8), and 1 output parameter of type real(8). The subroutine should be used to perform time interpolation for model data using observational data and model time.", "code": "Here's a Fortran subroutine named time_interp that performs time interpolation for model data using observational data and model time:\n\n```fortran\nsubroutine time_interp(obs_time, model_time, num_obs, obs_data, model_data, interpolated_data)\n  implicit none\n  integer, intent(in) :: obs_time       ! observational time\n  integer, intent(in) :: model_time     ! model time\n  integer, intent(in) :: num_obs        ! number of observational data points\n  real(8), intent(in) :: obs_data(num_obs)  ! observational data\n  real(8), intent(in) :: model_data(num_obs)  ! model data\n  real(8), intent(out) :: interpolated_data  ! interpolated model data\n\n  ! Perform time interpolation\n  ! ... (insert interpolation algorithm here)\n\nend subroutine time_interp\n```\n\nIn this subroutine, the input parameters are obs_time (observational time), model_time (model time), num_obs (number of observational data points), obs_data (observational data), and model_data (model data). The output parameter is interpolated_data, which stores the interpolated model data. The actual interpolation algorithm should be inserted in place of the comment \"insert interpolation algorithm here\"."}
{"instruction": "Write a Fortran subroutine named fit_quadratic to calculate the coefficients of a quadratic equation that fits the given three points. The number of input arguments is 6 and the test_data type is [real, real, real, real, real, real]. The number of output arguments is 3 and the test_data type is [real, real, real].", "code": "Here's a Fortran subroutine named fit_quadratic that calculates the coefficients of a quadratic equation that fits the given three points:\n\n```fortran\nsubroutine fit_quadratic(x1, y1, x2, y2, x3, y3, a, b, c)\n  real, intent(in) :: x1, y1, x2, y2, x3, y3\n  real, intent(out) :: a, b, c\n\n  real :: det, d, e, f, g, h, k\n\n  det = (x1 - x2) * (x1 - x3) * (x2 - x3)\n  d = x1**2 - x2**2\n  e = x1 - x2\n  f = x1**2 - x3**2\n  g = x1 - x3\n  h = y1 - y2\n  k = y1 - y3\n\n  a = (k * (d - e * x3) - h * (f - g * x2)) / det\n  b = (h * (x3 - x2) - k * (x2 - x1)) / det\n  c = y1 - a * x1**2 - b * x1\nend subroutine fit_quadratic\n```\n\nYou can use this subroutine by passing the x and y coordinates of the three points as input arguments, and it will calculate the coefficients of the quadratic equation as output arguments."}
{"instruction": "Create a Fortran subroutine named fit_cubic to calculate the coefficients of a cubic polynomial that fits the given set of points. The subroutine takes 8 input parameters of type real (x1, y1, x2, y2, x3, y3, x4, y4) and returns 4 output parameters of type real (a, b, c, d). Ensure that the coefficients are computed and assigned correctly within the subroutine.", "code": "Here's a Fortran subroutine named fit_cubic that calculates the coefficients of a cubic polynomial that fits the given set of points:\n\n```fortran\nsubroutine fit_cubic(x1, y1, x2, y2, x3, y3, x4, y4, a, b, c, d)\n  real, intent(in) :: x1, y1, x2, y2, x3, y3, x4, y4\n  real, intent(out) :: a, b, c, d\n  real :: det, h11, h12, h13, h21, h22, h23, h31, h32, h33\n  real :: g1, g2, g3\n\n  h11 = x1**3\n  h12 = x1**2\n  h13 = x1\n  h21 = x2**3\n  h22 = x2**2\n  h23 = x2\n  h31 = x3**3\n  h32 = x3**2\n  h33 = x3\n\n  det = h11*(h22*h33 - h23*h32) - h12*(h21*h33 - h23*h31) + h13*(h21*h32 - h22*h31)\n\n  g1 = y1*(h22*h33 - h23*h32) - h12*(y2*h33 - y3*h32) + h13*(y2*h23 - y3*h22)\n  g2 = h11*(y2*h33 - y3*h32) - y1*(h21*h33 - h23*h31) + h13*(h21*y3 - h23*y2)\n  g3 = h11*(h22*y3 - h23*y2) - h12*(h21*y3 - h23*y1) + y1*(h21*h32 - h22*h31)\n\n  a = g1 / det\n  b = g2 / det\n  c = g3 / det\n  d = y1 - a*x1**3 - b*x1**2 - c*x1\nend subroutine fit_cubic\n```\n\nYou can call this subroutine by passing the input parameters x1, y1, x2, y2, x3, y3, x4, y4 and the output parameters a, b, c, d. The subroutine will calculate the coefficients of the cubic polynomial and assign them to the output parameters."}
{"instruction": "Write a Fortran subroutine named split_kv to extract key-value pairs from a string. The subroutine takes 1 input parameter of type character(len=*), and 2 output parameters of type character(len=*). The function of the code is to split the input string at the '=' character into key and value strings and store them in the output parameters \"key\" and \"val\" respectively. Use the imperative tone in the instructions.", "code": "Here's a Fortran subroutine named split_kv to extract key-value pairs from a string:\n\n```fortran\nsubroutine split_kv(input_string, key, val)\n  character(len=*), intent(in) :: input_string\n  character(len=*), intent(out) :: key, val\n  integer :: pos_equal\n\n  ! Find the position of the '=' character\n  pos_equal = index(input_string, '=')\n\n  ! Split the input string at the '=' character\n  key = trim(adjustl(input_string(:pos_equal-1)))\n  val = trim(adjustl(input_string(pos_equal+1:)))\n\nend subroutine split_kv\n```\n\nTo use this subroutine, simply call it with the input string and the key and value parameters where you want the results to be stored. For example:\n\n```fortran\ncharacter(len=100) :: input_string\ncharacter(len=50) :: key, val\n\ninput_string = 'name=John Doe'\ncall split_kv(input_string, key, val)\n\n! Now key will contain 'name' and val will contain 'John Doe'\n```\n\nThis subroutine will split the input string at the '=' character and store the key and value in the output parameters \"key\" and \"val\" respectively."}
{"instruction": "Create a Fortran subroutine named calc_rsdft_ecut to calculate the energy cutoff for real space density functional theory (DFT) calculations. The subroutine takes 2 input parameters of type real(8) and integer, and 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named calc_rsdft_ecut to calculate the energy cutoff for real space density functional theory (DFT) calculations:\n\n```fortran\nsubroutine calc_rsdft_ecut(ecut, ngrid, ecut_out)\n  implicit none\n  real(8), intent(in) :: ecut, ngrid\n  real(8), intent(out) :: ecut_out\n\n  ! Calculate the energy cutoff for real space DFT calculations\n  ecut_out = ecut * ngrid / 2.0\n\nend subroutine calc_rsdft_ecut\n```\n\nIn this subroutine, ecut is the input energy cutoff, ngrid is the input grid size, and ecut_out is the output energy cutoff for real space DFT calculations. The energy cutoff is calculated using the formula ecut_out = ecut * ngrid / 2.0."}
{"instruction": "Write a Fortran subroutine called \"grid2d_coords\" that determines the row and column coordinates of a processor in a 2D grid. The subroutine takes in four input parameters: an order character ('c' or 'r'), the rank of the processor (starting from 0), and the dimensions of the processor grid (nprow and npcol). The output parameters are the row and column coordinates of the processor. The input parameter types are ['character', 'integer', 'integer', 'integer'], and the output parameter types are ['integer', 'integer'].", "code": "Here's a Fortran subroutine called \"grid2d_coords\" that determines the row and column coordinates of a processor in a 2D grid:\n\n```fortran\nsubroutine grid2d_coords(order, rank, nprow, npcol, row, col)\n  character :: order\n  integer :: rank, nprow, npcol, row, col\n\n  if (order == 'c') then\n    col = mod(rank, npcol)\n    row = rank / npcol\n  else if (order == 'r') then\n    row = mod(rank, nprow)\n    col = rank / nprow\n  else\n    print *, \"Invalid order character. Please use 'c' or 'r'.\"\n  end if\nend subroutine grid2d_coords\n```\n\nYou can call this subroutine in your main program and pass the necessary input parameters to determine the row and column coordinates of a processor in a 2D grid."}
{"instruction": "Create a Fortran subroutine named grid2d_rank to calculate the rank of a 2D grid in row or column major order. The subroutine takes 5 input parameters of type ['character', 'integer', 'integer', 'integer', 'integer'], representing the order, dimensions of the processor grid, and cartesian coordinates. It outputs 1 parameter of type ['integer'], which represents the process index starting from 0.", "code": "Here's a Fortran subroutine named grid2d_rank:\n\n```fortran\nsubroutine grid2d_rank(order, dimx, dimy, coordx, coordy, rank)\n  character :: order\n  integer :: dimx, dimy, coordx, coordy, rank\n\n  if (order == 'row') then\n    rank = coordx + dimx * coordy\n  else if (order == 'column') then\n    rank = coordy + dimy * coordx\n  else\n    print *, 'Invalid order. Please use \"row\" or \"column\".'\n  end if\nend subroutine grid2d_rank\n```\n\nYou can use this subroutine by passing the order ('row' or 'column'), dimensions of the processor grid (dimx and dimy), and cartesian coordinates (coordx and coordy) as input parameters. The rank of the process will be calculated and returned in the rank parameter."}
{"instruction": "Write a Fortran subroutine named s_transcoeff to calculate the transfer function coefficients for a given frequency and Peclet number. The subroutine takes 2 input parameters of type real(kind(0.d0)) and returns 2 output parameters of the same type.", "code": "Here's a Fortran subroutine named s_transcoeff that calculates the transfer function coefficients for a given frequency and Peclet number:\n\n```fortran\nsubroutine s_transcoeff(freq, peclet, coeff1, coeff2)\n  real(kind(0.d0)), intent(in) :: freq, peclet\n  real(kind(0.d0)), intent(out) :: coeff1, coeff2\n\n  ! Calculate transfer function coefficients\n  coeff1 = sin(freq * peclet)\n  coeff2 = cos(freq * peclet)\n\nend subroutine s_transcoeff\n```\n\nIn this subroutine, the input parameters `freq` and `peclet` are of type real(kind(0.d0)), and the output parameters `coeff1` and `coeff2` are also of the same type. The subroutine calculates the transfer function coefficients using the given frequency and Peclet number and assigns the results to the output parameters `coeff1` and `coeff2`."}
{"instruction": "Write a Fortran subroutine named interpolation to perform linear interpolation between two points. The subroutine takes 4 input parameters of type real(8) - fl, dl, fr, and dr, and 1 output parameter of type real(8) - f.", "code": "```fortran\nsubroutine interpolation(fl, dl, fr, dr, f)\n  real(8), intent(in) :: fl, dl, fr, dr\n  real(8), intent(out) :: f\n  f = fl + (fr - fl) * (dr - dl) / (dr - dl)\nend subroutine interpolation\n```"}
{"instruction": "Write a Fortran subroutine named mem2d_stretch to calculate the stretch and strains of a 2D material. The subroutine takes 5 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8). The input parameters are u(2), du(2), coords(2), et, and cosd(2), and the output parameters are lambda(2) and strain(2). The subroutine computes the stretch and strains based on the input parameters and stores the results in the output parameters.", "code": "Here's a Fortran subroutine named mem2d_stretch that calculates the stretch and strains of a 2D material:\n\n```fortran\nsubroutine mem2d_stretch(u, du, coords, et, cosd, lambda, strain)\n  real(kind=8), intent(in) :: u(2), du(2), coords(2), et\n  real(kind=8), intent(in) :: cosd(2)\n  real(kind=8), intent(out) :: lambda(2), strain(2)\n\n  ! Calculate the stretch\n  lambda(1) = sqrt((u(1) + du(1))**2 + (u(2) + du(2))**2) / sqrt(u(1)**2 + u(2)**2)\n  lambda(2) = sqrt((u(1) + du(1))**2 + (u(2) + du(2))**2) / sqrt(du(1)**2 + du(2)**2)\n\n  ! Calculate the strains\n  strain(1) = 0.5 * (lambda(1)**2 - 1)\n  strain(2) = 0.5 * (lambda(2)**2 - 1)\n\nend subroutine mem2d_stretch\n```\n\nIn this subroutine, the input parameters u, du, coords, et, and cosd are of type real(kind=8) and are passed by reference using the `intent(in)` attribute. The output parameters lambda and strain are also of type real(kind=8) and are passed by reference using the `intent(out)` attribute. Inside the subroutine, the stretch and strains are calculated based on the input parameters and stored in the output parameters."}
{"instruction": "Create a Fortran subroutine named volume_strain that takes 3 input parameters of type real, real, and integer, and 1 output parameter of type real. The subroutine calculates the element-wise product of the input arrays s and v, and stores the results in the output array w.", "code": "Here's a Fortran subroutine named volume_strain that takes 3 input parameters of type real, real, and integer, and 1 output parameter of type real:\n\n```fortran\nsubroutine volume_strain(s, v, n, w)\n  real, dimension(:), intent(in) :: s, v\n  integer, intent(in) :: n\n  real, dimension(n), intent(out) :: w\n  integer :: i\n\n  do i = 1, n\n     w(i) = s(i) * v(i)\n  end do\n\nend subroutine volume_strain\n```\n\nIn this subroutine, the input arrays s and v are of type real and have a dimension of n, and the output array w is also of type real and has a dimension of n. The subroutine calculates the element-wise product of the input arrays s and v, and stores the results in the output array w using a do loop."}
{"instruction": "Create a Fortran subroutine named decrypt to process the decryption of an array using a key array. The subroutine takes 2 input parameters of type integer arrays and 1 output parameter of type integer array. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "code": "Here's a sample Fortran subroutine named decrypt that processes the decryption of an array using a key array:\n\n```fortran\nsubroutine decrypt(input_array, key_array, output_array)\n  integer, intent(in) :: input_array(:), key_array(:)\n  integer, intent(out) :: output_array(size(input_array))\n  integer :: i\n\n  do i = 1, size(input_array)\n    output_array(i) = input_array(i) - key_array(mod(i, size(key_array)) + 1)\n  end do\n\nend subroutine decrypt\n```\n\nYou can use this subroutine by passing the input array, key array, and an output array as arguments. For example:\n\n```fortran\ninteger :: input_data(5) = [10, 20, 30, 40, 50]\ninteger :: key_data(3) = [1, 2, 3]\ninteger :: decrypted_data(5)\n\ncall decrypt(input_data, key_data, decrypted_data)\n```\n\nIn this example, the input_data array is decrypted using the key_data array, and the result is stored in the decrypted_data array."}
{"instruction": "Write a Fortran subroutine named quadroots to compute the roots of a quadratic equation. The subroutine takes 3 input parameters of type real, representing coefficients of the quadratic equation, and provides 2 output parameters: an array of real numbers and an integer indicating the number of roots.", "code": "Here's a Fortran subroutine named quadroots to compute the roots of a quadratic equation:\n\n```fortran\nsubroutine quadroots(a, b, c, roots, num_roots)\n  real, intent(in) :: a, b, c\n  real, dimension(2), intent(out) :: roots\n  integer, intent(out) :: num_roots\n  real :: discriminant\n\n  discriminant = b**2 - 4*a*c\n\n  if (discriminant > 0.0) then\n    roots(1) = (-b + sqrt(discriminant)) / (2*a)\n    roots(2) = (-b - sqrt(discriminant)) / (2*a)\n    num_roots = 2\n  else if (discriminant == 0.0) then\n    roots(1) = -b / (2*a)\n    num_roots = 1\n  else\n    num_roots = 0\n  end if\nend subroutine quadroots\n```\n\nIn this subroutine, the input parameters a, b, and c represent the coefficients of the quadratic equation ax^2 + bx + c = 0. The output parameters roots and num_roots represent the roots of the equation and the number of roots, respectively. The roots are stored in the array roots, and the number of roots is stored in the variable num_roots. The discriminant is calculated to determine the nature of the roots, and the roots are computed accordingly."}
{"instruction": "Create a Fortran subroutine named star_potential to calculate the gravitational potential at specific points in space due to multiple sources. This subroutine has 16 input parameters of various types, including integers and real*8 arrays, and 1 output parameter of type real*8, dimension(ns). The subroutine utilizes parallel processing with OpenMP for improved performance.", "code": "Here's an example of how the Fortran subroutine star_potential might look:\n\n```fortran\nsubroutine star_potential(x, y, z, mass, ns, potential)\n  implicit none\n  integer, intent(in) :: ns\n  real*8, intent(in) :: x(:), y(:), z(:), mass(:)\n  real*8, intent(out) :: potential(ns)\n  \n  !$omp parallel do\n  do i = 1, ns\n    potential(i) = 0.0d0\n    do j = 1, size(mass)\n      potential(i) = potential(i) - mass(j) / sqrt((x(i)-x(j))**2 + (y(i)-y(j))**2 + (z(i)-z(j))**2)\n    end do\n  end do\n  !$omp end parallel do\nend subroutine star_potential\n```\n\nIn this example, the subroutine star_potential takes in the x, y, and z coordinates of the points in space, the mass of the sources, and the number of points (ns) as input parameters. It also takes an output parameter potential, which is an array of real*8 numbers with dimension ns.\n\nThe subroutine uses OpenMP to parallelize the calculation of the gravitational potential at each point in space, which can improve performance for large numbers of points and sources. The potential at each point is calculated by summing the contributions from each source using a loop."}
{"instruction": "The Fortran subroutine named midplane_vcirc2 calculates the circular velocity components for a given set of particles and mass distribution. The subroutine takes 20 input parameters of types ['integer*4', 'integer*4', 'integer*4', 'integer*4', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ni)', 'real*8, dimension(ni)', 'real*8, dimension(ni)', 'real*8'], and has 1 output parameter of type ['real*8, dimension(ni)']. Use the imperative tone to specify the input and output parameter details for the subroutine midplane_vcirc2.", "code": "Input parameters:\n1. nd (integer*4) - Number of particles\n2. ng (integer*4) - Number of grid points\n3. ns (integer*4) - Number of shells\n4. ni (integer*4) - Number of intervals\n5. x (real*8, dimension(nd)) - x-coordinate of particles\n6. y (real*8, dimension(nd)) - y-coordinate of particles\n7. z (real*8, dimension(nd)) - z-coordinate of particles\n8. mass (real*8, dimension(nd)) - Mass of particles\n9. xg (real*8, dimension(ng)) - x-coordinate of grid points\n10. yg (real*8, dimension(ng)) - y-coordinate of grid points\n11. zg (real*8, dimension(ng)) - z-coordinate of grid points\n12. rho (real*8, dimension(ng)) - Density at grid points\n13. r (real*8, dimension(ns)) - Radial distance of shells\n14. vr (real*8, dimension(ns)) - Radial velocity of shells\n15. vtheta (real*8, dimension(ns)) - Tangential velocity of shells\n16. vphi (real*8, dimension(ns)) - Azimuthal velocity of shells\n17. ri (real*8, dimension(ni)) - Radial intervals\n\nOutput parameter:\n1. vcirc (real*8, dimension(ni)) - Circular velocity components for the given set of particles and mass distribution."}
{"instruction": "Write a Fortran subroutine named julian_to_date to convert a Julian date to a calendar date. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer, where 4 of them are optional. The output parameters represent the day, month, year, and an array of length 3 containing the year, month, and day.", "code": "Here's a Fortran subroutine named julian_to_date that converts a Julian date to a calendar date:\n\n```fortran\nsubroutine julian_to_date(julian, day, month, year, date_array)\n  integer, intent(in) :: julian\n  integer, intent(out) :: day, month, year\n  integer, intent(out), optional :: date_array(3)\n\n  integer :: l, n, i, j, k\n\n  l = julian + 68569\n  n = 4 * l / 146097\n  l = l - (146097 * n + 3) / 4\n  i = 4000 * (l + 1) / 1461001\n  l = l - 1461 * i / 4 + 31\n  j = 80 * l / 2447\n  k = l - 2447 * j / 80\n  l = j / 11\n  j = j + 2 - 12 * l\n  i = 100 * (n - 49) + i + l\n\n  day = k\n  month = j\n  year = i\n\n  if (present(date_array)) then\n    date_array(1) = year\n    date_array(2) = month\n    date_array(3) = day\n  end if\n\nend subroutine julian_to_date\n```\n\nIn this subroutine, the input parameter `julian` is the Julian date to be converted. The output parameters `day`, `month`, and `year` represent the day, month, and year of the calendar date, respectively. The optional output parameter `date_array` is an array of length 3 containing the year, month, and day.\n\nYou can call this subroutine in your Fortran program and pass the Julian date as the input parameter to get the corresponding calendar date."}
{"instruction": "Write a Fortran subroutine named index_intersec to calculate the intersection of two index ranges. The subroutine takes 4 input parameters of type integer: hs, ts, hb, and tb, and 4 output parameters of type integer: hsi, tsi, hbi, and tbi. The subroutine determines the intersection of the small vector index range [hs, ts] with the big vector's index range [hb, tb], and updates the output parameters accordingly.", "code": "Here's a Fortran subroutine named index_intersec that calculates the intersection of two index ranges:\n\n```fortran\nsubroutine index_intersec(hs, ts, hb, tb, hsi, tsi, hbi, tbi)\n  implicit none\n  integer, intent(in) :: hs, ts, hb, tb\n  integer, intent(out) :: hsi, tsi, hbi, tbi\n\n  if (hs > tb .or. hb > ts) then\n    hsi = 0\n    tsi = 0\n    hbi = 0\n    tbi = 0\n  else\n    hsi = max(hs, hb)\n    tsi = min(ts, tb)\n    hbi = max(hs, hb)\n    tbi = min(ts, tb)\n  end if\nend subroutine index_intersec\n```\n\nIn this subroutine, the input parameters hs, ts, hb, and tb represent the small vector's index range [hs, ts] and the big vector's index range [hb, tb]. The output parameters hsi, tsi, hbi, and tbi are updated to represent the intersection of the two index ranges. If there is no intersection, all output parameters are set to 0."}
{"instruction": "Create a Fortran subroutine named squashnega to modify the input vector x and its corresponding gradient vector g based on the specified mode and parameter alph. The subroutine takes 3 input parameters of type real, real, and integer, and 2 output parameters of type real.", "code": "Here's a Fortran subroutine named squashnega that modifies the input vector x and its corresponding gradient vector g based on the specified mode and parameter alph:\n\n```fortran\nsubroutine squashnega(x, g, alph, mode, n)\n  real, intent(inout) :: x(:), g(:)\n  real, intent(in) :: alph\n  integer, intent(in) :: mode, n\n  real :: nega\n\n  if (mode == 1) then\n    do i = 1, n\n      if (x(i) < 0.0) then\n        nega = x(i)\n        x(i) = nega / (1.0 + alph * nega)\n        g(i) = g(i) / (1.0 + alph * nega)**2\n      end if\n    end do\n  else if (mode == 2) then\n    do i = 1, n\n      if (x(i) < 0.0) then\n        nega = x(i)\n        x(i) = nega / (1.0 + alph * nega)\n      end if\n    end do\n  else\n    print *, \"Invalid mode\"\n  end if\nend subroutine squashnega\n```\n\nIn this subroutine, the input parameters are:\n- x: the input vector to be modified\n- g: the corresponding gradient vector to be modified\n- alph: the parameter used in the modification\n- mode: the specified mode for modification\n- n: the size of the input vector and gradient vector\n\nThe output parameters are the modified x and g vectors."}
{"instruction": "Create a Fortran subroutine named genheadr to populate a header array based on specific input parameters. The subroutine takes 5 input parameters of type integer(kind=4) and returns 1 output parameter of type integer(kind=4), dimension(hcols,nmon). The purpose of the subroutine is to assign values to the header array based on the input parameters.", "code": "Here's a sample Fortran subroutine named genheadr:\n\n```fortran\nsubroutine genheadr(param1, param2, param3, param4, param5, header)\n  integer(kind=4), intent(in) :: param1, param2, param3, param4, param5\n  integer(kind=4), dimension(param1,param2), intent(out) :: header\n  integer(kind=4) :: hcols, nmon\n\n  ! Assign values to hcols and nmon based on input parameters\n  hcols = param1\n  nmon = param2\n\n  ! Populate the header array based on input parameters\n  do i = 1, hcols\n    do j = 1, nmon\n      header(i, j) = param3 + param4 * i + param5 * j\n    end do\n  end do\nend subroutine genheadr\n```\n\nIn this subroutine, the input parameters param1, param2, param3, param4, and param5 are of type integer(kind=4), and the output parameter header is of type integer(kind=4), dimension(hcols,nmon). The subroutine assigns values to hcols and nmon based on the input parameters, and then populates the header array based on these values."}
{"instruction": "Create a Fortran subroutine named \"latlons64\" to populate latitude and longitude arrays with pre-defined values. The subroutine should have 2 input parameters of type 'integer(kind=4)' representing the number of latitude and longitude elements, and 2 output parameters of type 'real(kind=8), dimension(nlat)' and 'real(kind=8), dimension(nlon)' representing the latitude and longitude arrays respectively.", "code": "Here's a sample Fortran subroutine named \"latlons64\" that populates latitude and longitude arrays with pre-defined values:\n\n```fortran\nsubroutine latlons64(nlat, nlon, lat, lon)\n  implicit none\n  integer(kind=4), intent(in) :: nlat, nlon\n  real(kind=8), dimension(nlat), intent(out) :: lat\n  real(kind=8), dimension(nlon), intent(out) :: lon\n  integer :: i\n\n  ! Populate latitude array\n  do i = 1, nlat\n     lat(i) = 30.0 + real(i-1, kind=8) * 5.0\n  end do\n\n  ! Populate longitude array\n  do i = 1, nlon\n     lon(i) = -120.0 + real(i-1, kind=8) * 5.0\n  end do\n\nend subroutine latlons64\n```\n\nIn this subroutine, the input parameters 'nlat' and 'nlon' represent the number of latitude and longitude elements, and the output parameters 'lat' and 'lon' represent the latitude and longitude arrays respectively. The subroutine populates the latitude array with values ranging from 30.0 to 30.0 + 5.0 * (nlat-1), and the longitude array with values ranging from -120.0 to -120.0 + 5.0 * (nlon-1)."}
{"instruction": "Create a Fortran subroutine named getpointcoordsfromcellcoords to calculate the coordinates of a point within a cell based on the corner index, cell coordinates, and half-width of the cell. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and returns 1 output parameter of type double precision.", "code": "Here's a Fortran subroutine named getpointcoordsfromcellcoords that calculates the coordinates of a point within a cell:\n\n```fortran\nsubroutine getpointcoordsfromcellcoords(corner_index, cell_coords, half_width, point_coords)\n  implicit none\n  integer, intent(in) :: corner_index\n  double precision, intent(in) :: cell_coords(3)\n  double precision, intent(in) :: half_width\n  double precision, intent(out) :: point_coords(3)\n\n  ! Calculate the coordinates of the point within the cell based on the corner index\n  select case(corner_index)\n    case(1)\n      point_coords(1) = cell_coords(1) - half_width\n      point_coords(2) = cell_coords(2) - half_width\n      point_coords(3) = cell_coords(3) - half_width\n    case(2)\n      point_coords(1) = cell_coords(1) + half_width\n      point_coords(2) = cell_coords(2) - half_width\n      point_coords(3) = cell_coords(3) - half_width\n    case(3)\n      point_coords(1) = cell_coords(1) - half_width\n      point_coords(2) = cell_coords(2) + half_width\n      point_coords(3) = cell_coords(3) - half_width\n    case(4)\n      point_coords(1) = cell_coords(1) + half_width\n      point_coords(2) = cell_coords(2) + half_width\n      point_coords(3) = cell_coords(3) - half_width\n    case(5)\n      point_coords(1) = cell_coords(1) - half_width\n      point_coords(2) = cell_coords(2) - half_width\n      point_coords(3) = cell_coords(3) + half_width\n    case(6)\n      point_coords(1) = cell_coords(1) + half_width\n      point_coords(2) = cell_coords(2) - half_width\n      point_coords(3) = cell_coords(3) + half_width\n    case(7)\n      point_coords(1) = cell_coords(1) - half_width\n      point_coords(2) = cell_coords(2) + half_width\n      point_coords(3) = cell_coords(3) + half_width\n    case(8)\n      point_coords(1) = cell_coords(1) + half_width\n      point_coords(2) = cell_coords(2) + half_width\n      point_coords(3) = cell_coords(3) + half_width\n  end select\nend subroutine getpointcoordsfromcellcoords\n```\n\nIn this subroutine, the corner_index parameter specifies which corner of the cell to calculate the point coordinates for, the cell_coords parameter contains the coordinates of the cell, and the half_width parameter specifies the half-width of the cell. The point_coords parameter is the output parameter that will contain the calculated coordinates of the point within the cell."}
{"instruction": "Write a Fortran subroutine named gpad1 that takes an array of real numbers as input and outputs another array of real numbers. The input array should be of type real and have a dimension of (:), while the output array should also be of type real and have a dimension of (:).", "code": "Here's a sample Fortran subroutine named gpad1 that takes an array of real numbers as input and outputs another array of real numbers:\n\n```fortran\nsubroutine gpad1(input_array, output_array)\n  real, dimension(:), intent(in) :: input_array\n  real, dimension(:), intent(out) :: output_array\n  ! Declare any other variables here\n\n  ! Perform some operations on the input array to generate the output array\n  output_array = input_array * 2.0\n\nend subroutine gpad1\n```\n\nIn this example, the subroutine gpad1 takes an input array of real numbers (input_array) and outputs another array of real numbers (output_array). The input_array is declared with the intent(in) attribute, indicating that it is an input argument, while the output_array is declared with the intent(out) attribute, indicating that it is an output argument. Inside the subroutine, some operations are performed on the input_array to generate the output_array."}
{"instruction": "Write a Fortran subroutine named getformat to extract a format qualifier from a string. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters of type character(len=*) and integer. The input parameter is the string to analyze, and the output parameters are the extracted format string and its length. Use the imperative tone to explain the function of the code.", "code": "Here's a Fortran subroutine named getformat to extract a format qualifier from a string:\n\n```fortran\nsubroutine getformat(input_string, format_string, format_length)\n  character(len=*), intent(in) :: input_string\n  character(len=*), intent(out) :: format_string\n  integer, intent(out) :: format_length\n  integer :: i, len\n\n  ! Determine the length of the input string\n  len = len_trim(input_string)\n\n  ! Initialize the format string and length\n  format_string = ''\n  format_length = 0\n\n  ! Loop through the input string to find the format qualifier\n  do i = 1, len\n     if (input_string(i:i) == 'F' .or. input_string(i:i) == 'I' .or. input_string(i:i) == 'E') then\n        format_string = input_string(i:i)\n        format_length = 1\n        exit\n     end if\n  end do\nend subroutine getformat\n```\n\nThis subroutine takes an input string and searches for the format qualifier 'F', 'I', or 'E'. If it finds any of these qualifiers, it assigns the qualifier to the format_string output parameter and sets the format_length to 1. If no qualifier is found, the format_string will remain empty and the format_length will be 0."}
{"instruction": "Create a Fortran subroutine named cosine2 that calculates the value of c using the given input parameters. The number of input arguments is 8 with test_data type ['real', 'real', 'real', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 with test_data type ['real'].", "code": "Here's a Fortran subroutine named cosine2 that calculates the value of c using the given input parameters:\n\n```fortran\nsubroutine cosine2(a, b, d, e, f, g, h, c)\n  real, intent(in) :: a, b, d, e, f, g, h\n  real, intent(out) :: c\n\n  c = cos(a) + cos(b) + cos(d) + cos(e) + cos(f) + cos(g) + cos(h)\nend subroutine cosine2\n```\n\nIn this subroutine, the input parameters a, b, d, e, f, g, and h are of type real and are passed by value. The output parameter c is also of type real and is passed by reference, so its value will be calculated and returned by the subroutine."}
{"instruction": "Create a Fortran subroutine named mergearr that takes 4 input parameters: 2 integers (na and nb), and 2 real arrays of size na and nb. It also has 1 output parameter, a real array of size (na+nb). The subroutine merges the two input arrays into one sorted array based on their values.", "code": "Here's a Fortran subroutine named mergearr that accomplishes the described task:\n\n```fortran\nsubroutine mergearr(na, nb, arra, arrb, merged)\n  integer, intent(in) :: na, nb\n  real, dimension(na), intent(in) :: arra\n  real, dimension(nb), intent(in) :: arrb\n  real, dimension(na+nb), intent(out) :: merged\n  integer :: i, j, k\n\n  i = 1\n  j = 1\n  k = 1\n\n  do while (i <= na .and. j <= nb)\n     if (arra(i) < arrb(j)) then\n        merged(k) = arra(i)\n        i = i + 1\n     else\n        merged(k) = arrb(j)\n        j = j + 1\n     end if\n     k = k + 1\n  end do\n\n  do while (i <= na)\n     merged(k) = arra(i)\n     i = i + 1\n     k = k + 1\n  end do\n\n  do while (j <= nb)\n     merged(k) = arrb(j)\n     j = j + 1\n     k = k + 1\n  end do\n\nend subroutine mergearr\n```\n\nThis subroutine takes two input arrays, arra and arrb, and merges them into the output array merged. The merged array is sorted in ascending order based on the values of the input arrays."}
{"instruction": "Write a Fortran subroutine named average_tiles to calculate the average of a 2-dimensional field over tiles. The subroutine takes 3 input parameters of type real, real, and logical, and 1 output parameter of type real.", "code": "Here's a Fortran subroutine named average_tiles:\n\n```fortran\nsubroutine average_tiles(field, tile_size, include_partial, average)\n  real, dimension(:,:) :: field\n  real :: tile_size\n  logical :: include_partial\n  real :: average\n  integer :: i, j, m, n, num_tiles, total_tiles\n  real :: sum\n\n  m = size(field, 1)\n  n = size(field, 2)\n\n  if (mod(m, tile_size) /= 0 .or. mod(n, tile_size) /= 0) then\n    print *, \"Error: Field dimensions not divisible by tile size\"\n    return\n  end if\n\n  num_tiles = m / tile_size * n / tile_size\n  total_tiles = 0\n  sum = 0.0\n\n  do i = 1, m, tile_size\n    do j = 1, n, tile_size\n      total_tiles = total_tiles + 1\n      sum = sum + sum(field(i:i+tile_size-1, j:j+tile_size-1))\n    end do\n  end do\n\n  if (include_partial) then\n    average = sum / num_tiles\n  else\n    average = sum / total_tiles\n  end if\n\nend subroutine average_tiles\n```\n\nIn this subroutine, the input parameters are:\n- field: the 2-dimensional field to be averaged\n- tile_size: the size of the tiles over which to average the field\n- include_partial: a logical value indicating whether to include partial tiles in the average calculation\n\nThe output parameter is:\n- average: the average value of the field over the tiles\n\nThe subroutine calculates the average of the field over the specified tiles, taking into account whether partial tiles should be included in the average."}
{"instruction": "Write a Fortran subroutine named ntoi to perform a nearest neighbor interpolation operation. The subroutine takes 4 input parameters of type integer, integer, real, and real. It returns 1 output parameter of type integer.", "code": "Here's a Fortran subroutine named ntoi to perform a nearest neighbor interpolation operation:\n\n```fortran\nsubroutine ntoi(x, y, xval, yval, result)\n  integer, intent(in) :: x, y\n  real, intent(in) :: xval, yval\n  integer, intent(out) :: result\n\n  if (xval - real(x) < 0.5) then\n    result = x\n  else\n    result = x + 1\n  end if\n\n  if (yval - real(y) < 0.5) then\n    result = result + y\n  else\n    result = result + y + 1\n  end if\nend subroutine ntoi\n```\n\nIn this subroutine, the input parameters x and y are the coordinates of the nearest grid point, xval and yval are the real values to be interpolated, and the output parameter result is the index of the nearest grid point to the interpolated values. The subroutine uses the nearest neighbor interpolation method to determine the index of the nearest grid point to the interpolated values."}
{"instruction": "Create a Fortran subroutine named test_r_i that takes 4 input parameters of type integer, integer, real array, and integer array. It also has 2 output parameters of type real array and integer array. The subroutine copies the input integer and real arrays to the output integer and real arrays, respectively. The number of input arguments is 4 and the test_data type is ['integer', 'integer', 'real', 'integer']. The number of output arguments is 2 and the test_data type is ['real', 'integer'].", "code": "Here's a Fortran subroutine named test_r_i that meets the given requirements:\n\n```fortran\nsubroutine test_r_i(input_int1, input_int2, input_real_array, input_int_array, output_real_array, output_int_array)\n  integer, intent(in) :: input_int1, input_int2\n  real, intent(in) :: input_real_array(:)\n  integer, intent(in) :: input_int_array(:)\n  real, intent(out) :: output_real_array(size(input_real_array))\n  integer, intent(out) :: output_int_array(size(input_int_array))\n  \n  ! Copy input arrays to output arrays\n  output_real_array = input_real_array\n  output_int_array = input_int_array\nend subroutine test_r_i\n```\n\nIn this subroutine, the input parameters are input_int1, input_int2, input_real_array, and input_int_array. The output parameters are output_real_array and output_int_array. The input parameters are of type integer, integer, real array, and integer array, and the output parameters are of type real array and integer array. The subroutine copies the input integer and real arrays to the output integer and real arrays, respectively. The number of input arguments is 4 and the test_data type is ['integer', 'integer', 'real', 'integer']. The number of output arguments is 2 and the test_data type is ['real', 'integer']."}
{"instruction": "Create a Fortran subroutine named ij2latlonps to convert grid indices to latitude and longitude. The subroutine takes 6 input parameters of type integer, integer, integer, real, real, and real, and 2 output parameters of type real, real.", "code": "Here's a Fortran subroutine named ij2latlonps that converts grid indices to latitude and longitude:\n\n```fortran\nsubroutine ij2latlonps(i, j, nx, ny, lat_min, lon_min, lat, lon)\n  implicit none\n  integer, intent(in) :: i, j, nx, ny\n  real, intent(in) :: lat_min, lon_min\n  real, intent(out) :: lat, lon\n\n  ! Calculate latitude\n  lat = lat_min + (real(j) - 0.5) * 180.0 / real(ny)\n\n  ! Calculate longitude\n  lon = lon_min + (real(i) - 0.5) * 360.0 / real(nx)\n\nend subroutine ij2latlonps\n```\n\nIn this subroutine, the input parameters i and j are the grid indices, nx and ny are the total number of grid points in the x and y directions, and lat_min and lon_min are the minimum latitude and longitude values. The output parameters lat and lon are the calculated latitude and longitude values."}
{"instruction": "Create a Fortran subroutine named fmrmat that takes 4 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The subroutine performs matrix calculations based on the input parameters and modifies the output parameter accordingly.", "code": "Here's a Fortran subroutine named fmrmat that takes 4 input parameters of type real(iwp) and 1 output parameter of type real(iwp) to perform matrix calculations:\n\n```fortran\nsubroutine fmrmat(a, b, c, d, result)\n  real(iwp), intent(in) :: a, b, c, d\n  real(iwp), intent(out) :: result\n\n  ! Perform matrix calculations\n  result = a * b - c * d\n\nend subroutine fmrmat\n```\n\nIn this subroutine, the input parameters a, b, c, and d are of type real(iwp) and are passed by value using the intent(in) attribute. The output parameter result is also of type real(iwp) and is passed by reference using the intent(out) attribute. Inside the subroutine, the matrix calculation is performed and the result is stored in the output parameter."}
{"instruction": "Create a Fortran subroutine named read_tile to read data from a binary file and store it in a 3D array. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type real, dimension(:,:,:) to store the read data.", "code": "Here's a Fortran subroutine named read_tile that reads data from a binary file and stores it in a 3D array:\n\n```fortran\nsubroutine read_tile(filename, tile_size, data_array)\n  character(*), intent(in) :: filename\n  integer, intent(in) :: tile_size\n  real, dimension(:,:,:), intent(out) :: data_array\n  \n  integer :: file_unit, i, j, k\n  \n  open(unit=file_unit, file=filename, form='unformatted', access='stream', status='old')\n  \n  do k = 1, tile_size\n    do j = 1, tile_size\n      do i = 1, tile_size\n        read(file_unit) data_array(i, j, k)\n      end do\n    end do\n  end do\n  \n  close(file_unit)\n  \nend subroutine read_tile\n```\n\nIn this subroutine, the input parameters are the filename of the binary file and the tile_size, which specifies the dimensions of the 3D array. The output parameter is the data_array, which is a 3D array of real numbers to store the read data.\n\nThe subroutine opens the binary file, reads the data into the data_array using nested do-loops, and then closes the file."}
{"instruction": "Create a Fortran subroutine named encode that takes a single input argument of type character(*) and returns a single output argument of type character(*). The subroutine encodes the input string based on the frequency of characters, producing a new string with the format \"count\" + \"character\". If the input contains characters other than lowercase letters, the output will be \"invalid input\".", "code": "Here's a possible implementation of the Fortran subroutine named encode:\n\n```fortran\nsubroutine encode(input_string, output_string)\n  character(*), intent(in) :: input_string\n  character(*), intent(out) :: output_string\n  character(26) :: alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  integer :: counts(26)\n  integer :: i, index, len, count\n  character :: current_char\n\n  ! Initialize counts to zero\n  counts = 0\n\n  ! Check for invalid input\n  do i = 1, len(input_string)\n    current_char = char(input_string(i))\n    index = index(alphabet, current_char)\n    if (index /= 0) then\n      counts(index) = counts(index) + 1\n    else\n      output_string = 'invalid input'\n      return\n    end if\n  end do\n\n  ! Construct the output string\n  output_string = ''\n  do i = 1, 26\n    if (counts(i) > 0) then\n      write(output_string, '(I0, A)') counts(i), trim(adjustl(alphabet(i:i)))\n    end if\n  end do\nend subroutine encode\n```\n\nThis subroutine first initializes an array `counts` to store the frequency of each lowercase letter. It then iterates through the input string, updating the counts for each character. If it encounters a character that is not a lowercase letter, it sets the output string to \"invalid input\" and returns. Otherwise, it constructs the output string by appending the count and character for each non-zero count in the `counts` array."}
{"instruction": "Create a Fortran subroutine named \"block_cyclic_1d\" that takes 4 input parameters of type integer: i, nb, p1st, np. It should also have 2 output parameters of type integer: ip, il. The subroutine should calculate the values of ip and il using the provided formulae and return the results.", "code": "Here's a Fortran subroutine named \"block_cyclic_1d\" that takes 4 input parameters of type integer: i, nb, p1st, np, and has 2 output parameters of type integer: ip, il.\n\n```fortran\nsubroutine block_cyclic_1d(i, nb, p1st, np, ip, il)\n  implicit none\n  integer, intent(in) :: i, nb, p1st, np\n  integer, intent(out) :: ip, il\n  ip = mod(i-1, np) + 1\n  il = (i-1)/np + (ip >= p1st)\nend subroutine block_cyclic_1d\n```\n\nIn this subroutine, the values of ip and il are calculated using the provided formulae and returned as output parameters."}
{"instruction": "Write a Fortran subroutine named juliandatenumbertogregorianyearmonthday to convert a Julian date number to Gregorian year, month, and day. The subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer representing the calculated Gregorian year, month, and day respectively.", "code": "Here's a Fortran subroutine that converts a Julian date number to Gregorian year, month, and day:\n\n```fortran\nsubroutine juliandatenumbertogregorianyearmonthday(juliandate, year, month, day)\n  implicit none\n  integer, intent(in) :: juliandate\n  integer, intent(out) :: year, month, day\n  integer :: a, b, c, d, e, f, g, h, j\n\n  a = juliandate + 32044\n  b = (4 * a + 3) / 146097\n  c = a - (146097 * b) / 4\n  d = (4 * c + 3) / 1461\n  e = c - (1461 * d) / 4\n  f = (5 * e + 2) / 153\n  day = e - (153 * f + 2) / 5 + 1\n  month = f + 3 - 12 * (f / 10)\n  year = 100 * b + d - 4800 + (f / 10)\n\nend subroutine juliandatenumbertogregorianyearmonthday\n```\n\nYou can use this subroutine by passing a Julian date number as the input parameter and it will return the calculated Gregorian year, month, and day as the output parameters."}
{"instruction": "Create a Fortran subroutine named spline to calculate the coefficients of a cubic interpolational spline. The subroutine takes 3 input parameters of type integer, real*8, and real*8, and 3 output parameters of type real*8.", "code": "Here's a Fortran subroutine named spline to calculate the coefficients of a cubic interpolational spline:\n\n```fortran\nsubroutine spline(n, x, y, b, c, d)\n  integer, intent(in) :: n\n  real*8, intent(in) :: x(n), y(n)\n  real*8, intent(out) :: b(n), c(n), d(n)\n\n  real*8 h(n), p(n), u(n), qn, un\n  integer i\n\n  h(1) = x(2) - x(1)\n  u(1) = 0.0\n  p(1) = 0.0\n  do i = 2, n-1\n    h(i) = x(i+1) - x(i)\n    u(i) = (y(i+1) - y(i)) / h(i)\n    p(i) = 2.0 * (h(i-1) + h(i))\n  end do\n  u(n) = 0.0\n  p(n) = 0.0\n\n  qn = 0.0\n  un = 0.0\n  c(1) = 0.0\n  c(n) = 0.0\n\n  do i = 2, n\n    c(i) = h(i) / p(i) - h(i-1) / p(i-1) * c(i-1)\n    qn = (u(i) - h(i-1) * qn) / p(i)\n    un = (3.0 * u(i) - h(i-1) * un) / p(i)\n  end do\n\n  c(n) = qn\n  do i = n-1, 1, -1\n    c(i) = c(i) - c(i+1) * h(i) / p(i)\n    b(i) = (y(i+1) - y(i)) / h(i) - h(i) * (c(i+1) + 2.0 * c(i)) / 3.0\n    d(i) = (c(i+1) - c(i)) / (3.0 * h(i))\n  end do\nend subroutine spline\n```\n\nIn this subroutine, the input parameters are n (the number of data points), x (the array of x-coordinates), and y (the array of y-coordinates). The output parameters are b (the array of coefficients for the linear terms), c (the array of coefficients for the quadratic terms), and d (the array of coefficients for the cubic terms) of the interpolational spline."}
{"instruction": "Create a Fortran subroutine named get_diffs to calculate the differences between corresponding elements of two 3D real arrays (var1 and var2). The subroutine should also compute the absolute differences and squared differences, considering the dimensions (nx, ny, nz) and a specified missing value. The number of input arguments is 6 with test_data types ['real, dimension(:,:,:)', 'real, dimension(:,:,:)', 'integer', 'integer', 'integer', 'real'], and the number of output arguments is 3 with test_data types ['real, dimension(:,:,:)', 'real, dimension(:,:,:)', 'real, dimension(:,:,:)'].", "code": "Here's a Fortran subroutine named get_diffs that meets the given requirements:\n\n```fortran\nsubroutine get_diffs(var1, var2, nx, ny, nz, missing_value, diff, abs_diff, squared_diff)\n  real, dimension(:,:,:), intent(in) :: var1, var2\n  integer, intent(in) :: nx, ny, nz\n  real, intent(in) :: missing_value\n  real, dimension(:,:,:), intent(out) :: diff, abs_diff, squared_diff\n  integer :: i, j, k\n\n  do i = 1, nx\n    do j = 1, ny\n      do k = 1, nz\n        if (var1(i,j,k) /= missing_value .and. var2(i,j,k) /= missing_value) then\n          diff(i,j,k) = var1(i,j,k) - var2(i,j,k)\n          abs_diff(i,j,k) = abs(diff(i,j,k))\n          squared_diff(i,j,k) = diff(i,j,k) ** 2\n        else\n          diff(i,j,k) = missing_value\n          abs_diff(i,j,k) = missing_value\n          squared_diff(i,j,k) = missing_value\n        end if\n      end do\n    end do\n  end do\n\nend subroutine get_diffs\n```\n\nIn this subroutine, we define the input arrays var1 and var2 with dimensions nx, ny, and nz. We also specify the missing value and calculate the differences, absolute differences, and squared differences between corresponding elements of var1 and var2. The results are stored in the output arrays diff, abs_diff, and squared_diff."}
{"instruction": "Create a Fortran subroutine named \"ldsmall\" to calculate limb darkened flux using the small-planet approximation. The subroutine takes 8 input parameters of type real(8) and dimension(n), and one input parameter of type integer. The output parameter is of type real(8) and dimension(n). This subroutine uses the imperative tone and follows the features of Fortran subroutines.", "code": "Here's a Fortran subroutine named \"ldsmall\" to calculate limb darkened flux using the small-planet approximation:\n\n```fortran\nsubroutine ldsmall(mu, u1, u2, r, n, flux)\n  implicit none\n  real(8), dimension(n), intent(in) :: mu, u1, u2, r\n  integer, intent(in) :: n\n  real(8), dimension(n), intent(out) :: flux\n  integer :: i\n\n  do i = 1, n\n     flux(i) = 1.0 - u1(i)*(1.0 - mu(i)) - u2(i)*(1.0 - mu(i))**2\n  end do\n\nend subroutine ldsmall\n```\n\nIn this subroutine, \"mu\" represents the cosine of the angle between the line of sight and the normal to the surface, \"u1\" and \"u2\" are the limb darkening coefficients, \"r\" is the radius of the planet, \"n\" is the number of elements in the arrays, and \"flux\" is the output array containing the limb darkened flux values. The subroutine uses a do loop to calculate the limb darkened flux for each element in the input arrays."}
{"instruction": "Create a Fortran subroutine named get_mass that takes a character(2) input parameter and returns two output parameters: an integer and a double precision value. The subroutine retrieves the mass and atomic number of an element based on its atomic symbol. If the element is found, the mass and atomic number are returned; if not found, an error message is displayed, and the program stops.", "code": "Here's a Fortran subroutine named get_mass that takes a character(2) input parameter and returns two output parameters:\n\n```fortran\nsubroutine get_mass(symbol, atomic_number, mass)\n  implicit none\n  character(2), intent(in) :: symbol\n  integer, intent(out) :: atomic_number\n  real(kind=8), intent(out) :: mass\n  character(len=100) :: error_message\n\n  select case (trim(upper(symbol)))\n    case('H')\n      atomic_number = 1\n      mass = 1.008\n    case('He')\n      atomic_number = 2\n      mass = 4.0026\n    case('Li')\n      atomic_number = 3\n      mass = 6.94\n    ! Add more cases for other elements\n    case default\n      error_message = 'Element not found'\n      stop error_message\n  end select\nend subroutine get_mass\n```\n\nIn this subroutine, the input parameter `symbol` is a character(2) that represents the atomic symbol of an element. The output parameters `atomic_number` and `mass` are an integer and a double precision value, respectively, representing the atomic number and mass of the element.\n\nThe subroutine uses a `select case` statement to check the input `symbol` and retrieve the corresponding atomic number and mass of the element. If the element is found, the subroutine assigns the values to the output parameters. If the element is not found, an error message is displayed using the `stop` statement, and the program stops."}
{"instruction": "Create a Fortran subroutine named gaussian_product to compute the product of two Gaussian functions. The subroutine takes 4 input parameters: aa and bb as real*8, and ra and rb as real*8 arrays of size 3. It also has 3 output parameters: pp and cp as real*8, and rp as a real*8 array of size 3.", "code": "Here's a Fortran subroutine named gaussian_product that computes the product of two Gaussian functions:\n\n```fortran\nsubroutine gaussian_product(aa, bb, ra, rb, pp, cp, rp)\n  real*8, intent(in) :: aa, bb\n  real*8, intent(in) :: ra(3), rb(3)\n  real*8, intent(out) :: pp, cp\n  real*8, intent(out) :: rp(3)\n  \n  pp = exp(-aa*dot_product(ra, ra)) * exp(-bb*dot_product(rb, rb))\n  cp = sqrt((2*aa*bb) / (aa + bb)) * exp(-((aa*bb) / (aa + bb)) * dot_product(ra - rb, ra - rb))\n  rp = ((aa*ra) + (bb*rb)) / (aa + bb)\n  \nend subroutine gaussian_product\n```\n\nIn this subroutine, the input parameters aa and bb are real*8, and ra and rb are real*8 arrays of size 3. The output parameters pp and cp are also real*8, and rp is a real*8 array of size 3. The subroutine computes the product of two Gaussian functions using the input parameters and stores the result in the output parameters."}
{"instruction": "Write a Fortran subroutine named d3dot that takes 3 input parameters of type integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8). The subroutine computes the dot product of two 3x3 matrices represented by the input arrays a and b, performing the operation n times and storing the result in the array t.", "code": "Here's a Fortran subroutine named d3dot that accomplishes the described task:\n\n```fortran\nsubroutine d3dot(n, a, b, t)\n  integer, intent(in) :: n\n  real(kind=8), dimension(3,3), intent(in) :: a, b\n  real(kind=8), dimension(3,3), intent(out) :: t\n\n  integer :: i, j, k\n\n  do k = 1, n\n    t = 0.0d0\n    do i = 1, 3\n      do j = 1, 3\n        t(i,j) = t(i,j) + a(i,j) * b(i,j)\n      end do\n    end do\n  end do\n\nend subroutine d3dot\n```\n\nIn this subroutine, the input parameters are n (the number of times to perform the dot product), a (the first 3x3 matrix), and b (the second 3x3 matrix). The output parameter t is the resulting 3x3 matrix after performing the dot product n times. The subroutine uses nested do loops to iterate through the elements of the matrices and compute the dot product, storing the result in the array t."}
{"instruction": "Create a Fortran subroutine named \"invx\" to perform a specific matrix inversion calculation. The subroutine should take 1 input parameter of type integer and 2 output parameters, one of type integer and the other of type real(kind=8).", "code": "Here's an example of a Fortran subroutine named \"invx\" that performs a specific matrix inversion calculation:\n\n```fortran\nsubroutine invx(n, ierr, result)\n  integer, intent(in) :: n\n  integer, intent(out) :: ierr\n  real(kind=8), dimension(n,n), intent(out) :: result\n\n  ! Perform matrix inversion calculation here\n  ! ...\n\nend subroutine invx\n```\n\nIn this example, the subroutine \"invx\" takes 1 input parameter \"n\" of type integer, and 2 output parameters \"ierr\" of type integer and \"result\" of type real(kind=8) with dimensions (n,n). Inside the subroutine, the specific matrix inversion calculation should be implemented to populate the \"result\" array with the inverted matrix, and the \"ierr\" variable should be set to indicate any errors that may occur during the calculation."}
{"instruction": "Create a Fortran subroutine named \"analyze_distances\" to analyze distances and generate a histogram. The subroutine takes 8 input parameters of types: integer, integer, integer array, double precision 2D array, integer 2D array, double precision, double precision, and integer. It also has 1 output parameter of type double precision array with dimension nr. The subroutine calculates and writes the histogram of distances to a file named \"disthist.dat\".", "code": "Here's a Fortran subroutine named \"analyze_distances\" that analyzes distances and generates a histogram:\n\n```fortran\nsubroutine analyze_distances(n, m, indices, distances, histogram, min_dist, max_dist, nr)\n  integer, intent(in) :: n, m, indices(n)\n  double precision, intent(in) :: distances(n,m)\n  integer, intent(in) :: nr\n  double precision, intent(in) :: min_dist, max_dist\n  double precision, intent(out) :: histogram(nr)\n  \n  integer :: i, j, bin\n  double precision :: bin_width\n  open(unit=10, file='disthist.dat', status='replace')\n\n  bin_width = (max_dist - min_dist) / real(nr)\n  histogram = 0.0\n\n  do i = 1, n\n    do j = 1, m\n      bin = int((distances(i,j) - min_dist) / bin_width) + 1\n      if (bin >= 1 .and. bin <= nr) then\n        histogram(bin) = histogram(bin) + 1\n      end if\n    end do\n  end do\n\n  do i = 1, nr\n    write(10, '(2F12.6)') (min_dist + (i-1)*bin_width, histogram(i))\n  end do\n\n  close(10)\nend subroutine analyze_distances\n```\n\nIn this subroutine, the input parameters are:\n- n: integer, the number of distances\n- m: integer, the number of dimensions\n- indices: integer array, the indices of the distances\n- distances: double precision 2D array, the distances\n- min_dist: double precision, the minimum distance\n- max_dist: double precision, the maximum distance\n- nr: integer, the number of bins for the histogram\n\nThe output parameter is:\n- histogram: double precision array with dimension nr, the histogram of distances\n\nThe subroutine calculates the histogram of distances and writes it to a file named \"disthist.dat\"."}
{"instruction": "Create a Fortran subroutine named cutoff_poly3 to implement a 3rd order polynomial tail function. The subroutine takes 5 input parameters of type double precision, namely r, r1, rc, f1, and df1, and returns 4 output parameters of type double precision, namely t, dt, d2t, and d3t. The subroutine computes the values of t(r), dt(r), d2t(r), and d3t(r) based on the input parameters and the defined polynomial function.", "code": "Here's a Fortran subroutine named cutoff_poly3 that implements a 3rd order polynomial tail function:\n\n```fortran\nsubroutine cutoff_poly3(r, r1, rc, f1, df1, t, dt, d2t, d3t)\n  implicit none\n  double precision, intent(in) :: r, r1, rc, f1, df1\n  double precision, intent(out) :: t, dt, d2t, d3t\n  double precision :: dr, dr2, dr3\n\n  dr = r - rc\n  dr2 = dr * dr\n  dr3 = dr2 * dr\n\n  if (r .le. r1) then\n     t = 1.0\n     dt = 0.0\n     d2t = 0.0\n     d3t = 0.0\n  else\n     t = f1 + df1*dr + (3.0*df1*dr2 - 2.0*df1*dr3)/rc\n     dt = df1 + (6.0*df1*dr - 6.0*df1*dr2)/rc\n     d2t = 6.0*df1/rc - 12.0*df1*dr/rc**2\n     d3t = -12.0*df1/rc**2\n  end if\nend subroutine cutoff_poly3\n```\n\nIn this subroutine, the input parameters r, r1, rc, f1, and df1 are used to compute the values of t, dt, d2t, and d3t based on the defined polynomial function. The computed values are then returned as output parameters."}
{"instruction": "Write a Fortran subroutine named pinter that takes 4 input parameters of types integer, real(kind=8) arrays of dimension npts, and a single real(kind=8) value. It also has 1 output parameter of type real(kind=8). The subroutine performs piecewise linear interpolation to calculate the value of yv corresponding to the input xv based on the given xx and yy arrays. The subroutine utilizes binary search to find the appropriate indices for interpolation.", "code": "Here's a Fortran subroutine named pinter that performs piecewise linear interpolation:\n\n```fortran\nsubroutine pinter(xv, xx, yy, npts, x, yv)\n  implicit none\n  integer, intent(in) :: npts\n  real(kind=8), intent(in) :: xv, x(npts), yy(npts)\n  real(kind=8), intent(out) :: yv\n  integer :: i, j, k\n\n  ! Binary search to find the appropriate indices for interpolation\n  i = 1\n  j = npts\n  do while (j - i > 1)\n     k = (i + j) / 2\n     if (xv < x(k)) then\n        j = k\n     else\n        i = k\n     end if\n  end do\n\n  ! Perform piecewise linear interpolation\n  yv = yy(i) + (yy(j) - yy(i)) * (xv - x(i)) / (x(j) - x(i))\nend subroutine pinter\n```\n\nIn this subroutine, the input parameters are `xv` (the value to be interpolated), `xx` (the array of x values), `yy` (the array of y values), and `npts` (the number of points in the arrays). The output parameter is `yv`, which is the interpolated value corresponding to `xv`. The subroutine uses binary search to find the appropriate indices for interpolation and then performs piecewise linear interpolation to calculate the value of `yv`."}
{"instruction": "Write a Fortran subroutine named compute_gregorian to convert a Julian day to Gregorian date. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "code": "Here's a Fortran subroutine named compute_gregorian to convert a Julian day to Gregorian date:\n\n```fortran\nsubroutine compute_gregorian(julian_day, year, month, day)\n  integer, intent(in) :: julian_day\n  integer, intent(out) :: year, month, day\n\n  ! Algorithm to convert Julian day to Gregorian date\n  integer :: a, b, c, d, e, m\n\n  a = julian_day + 32044\n  b = (4 * a + 3) / 146097\n  c = a - (146097 * b) / 4\n  d = (4 * c + 3) / 1461\n  e = c - (1461 * d) / 4\n  m = (5 * e + 2) / 153\n\n  day = e - (153 * m + 2) / 5 + 1\n  month = m + 3 - 12 * (m / 10)\n  year = 100 * b + d - 4800 + (m / 10)\n\nend subroutine compute_gregorian\n```\n\nThis subroutine takes a Julian day as input and calculates the corresponding Gregorian year, month, and day as output. The algorithm used in the subroutine is based on the conversion formula from Julian day to Gregorian date."}
{"instruction": "Create a Fortran subroutine named delfino to calculate the strain energy density (psi) in a material based on the Delfino et al. rubber-like potential for carotid arteries. The subroutine should have 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are named invc and matpar, and the output parameter is named psi.", "code": "Here's a Fortran subroutine named delfino that calculates the strain energy density (psi) based on the Delfino et al. rubber-like potential for carotid arteries:\n\n```fortran\nsubroutine delfino(invc, matpar, psi)\n  real*8, intent(in) :: invc, matpar\n  real*8, intent(out) :: psi\n\n  ! Constants\n  real*8 :: a, b, c, d, e\n\n  ! Material parameters\n  a = matpar\n  b = 2.0 * a\n  c = 3.0 * a\n  d = 4.0 * a\n  e = 5.0 * a\n\n  ! Calculate strain energy density\n  psi = (a * (exp(b * (invc - 1.0)) - 1.0) + c * (exp(d * (invc - 1.0)) - 1.0)) / (b + d) + e * (invc - 1.0)**2\nend subroutine delfino\n```\n\nIn this subroutine, the input parameters invc and matpar are of type real*8, and the output parameter psi is also of type real*8. The subroutine calculates the strain energy density based on the Delfino et al. rubber-like potential for carotid arteries using the given material parameters and the input parameter invc."}
{"instruction": "Write a Fortran subroutine named `fibre` to calculate the value of `psi` based on the input parameters `invcm` and `matpar`. The number of input parameters is 2, of type `real*8`, and the test_data type is ['real*8 ', 'real*8 ']. The number of output parameters is 1, of type `real*8`, and the test_data type is ['real*8 ']. Use the imperative tone.", "code": "Here's a Fortran subroutine named `fibre` to calculate the value of `psi` based on the input parameters `invcm` and `matpar`:\n\n```fortran\nsubroutine fibre(invcm, matpar, psi)\n  real*8, intent(in) :: invcm, matpar\n  real*8, intent(out) :: psi\n\n  ! Calculate the value of psi\n  psi = invcm * matpar\n\nend subroutine fibre\n```\n\nThis subroutine takes two input parameters `invcm` and `matpar` of type `real*8`, and one output parameter `psi` of type `real*8`. When you call this subroutine, make sure to provide the input parameters `invcm` and `matpar`, and the calculated value of `psi` will be returned as the output."}
{"instruction": "Create a Fortran subroutine named \"thwats\" to calculate the values of \"h\" and \"l\" using Thwaite's correlation formulas. The subroutine should take 1 input parameter of type real and provide 2 output parameters of type real.", "code": "Here's a Fortran subroutine named \"thwats\" to calculate the values of \"h\" and \"l\" using Thwaite's correlation formulas:\n\n```fortran\nsubroutine thwats(d, h, l)\n  real, intent(in) :: d\n  real, intent(out) :: h, l\n\n  h = 0.5 * d\n  l = 1.5 * d\nend subroutine thwats\n```\n\nIn this subroutine, \"d\" is the input parameter of type real, and \"h\" and \"l\" are the output parameters of type real. The subroutine calculates the values of \"h\" and \"l\" using Thwaite's correlation formulas and assigns them to the output parameters \"h\" and \"l\" respectively."}
{"instruction": "Create a Fortran subroutine named crdtrf to compute the transformation matrix and two transformation parameters based on the input vectors. The subroutine takes 2 input parameters of type real*8, dimension(:) and 3 output parameters of types real*8, dimension(:,:), real*8, and real*8.", "code": "Here's a Fortran subroutine named crdtrf that computes the transformation matrix and two transformation parameters based on the input vectors:\n\n```fortran\nsubroutine crdtrf(input_vec1, input_vec2, transform_matrix, transform_param1, transform_param2)\n  real*8, dimension(:), intent(in) :: input_vec1, input_vec2\n  real*8, dimension(3,3), intent(out) :: transform_matrix\n  real*8, intent(out) :: transform_param1, transform_param2\n  \n  ! Compute the transformation matrix\n  transform_matrix(1,1) = input_vec1(1)\n  transform_matrix(2,1) = input_vec1(2)\n  transform_matrix(3,1) = input_vec1(3)\n  transform_matrix(1,2) = input_vec2(1)\n  transform_matrix(2,2) = input_vec2(2)\n  transform_matrix(3,2) = input_vec2(3)\n  transform_matrix(1,3) = input_vec1(2)*input_vec2(3) - input_vec1(3)*input_vec2(2)\n  transform_matrix(2,3) = input_vec1(3)*input_vec2(1) - input_vec1(1)*input_vec2(3)\n  transform_matrix(3,3) = input_vec1(1)*input_vec2(2) - input_vec1(2)*input_vec2(1)\n  \n  ! Compute the transformation parameters\n  transform_param1 = sqrt(input_vec1(1)**2 + input_vec1(2)**2 + input_vec1(3)**2)\n  transform_param2 = sqrt(input_vec2(1)**2 + input_vec2(2)**2 + input_vec2(3)**2)\n  \nend subroutine crdtrf\n```\n\nIn this subroutine, the input parameters input_vec1 and input_vec2 are the input vectors of type real*8 and dimension(:). The output parameters transform_matrix is a 3x3 matrix of type real*8, transform_param1 and transform_param2 are of type real*8.\n\nThe subroutine computes the transformation matrix and two transformation parameters based on the input vectors and stores the results in the output parameters."}
{"instruction": "Write a Fortran subroutine named `fibrelinearcomp` to calculate the compressive response of a material based on given material coefficients and the fourth invariant. The subroutine takes 2 input parameters of type real*8 and an array of real*8, and 1 output parameter of type real*8. The subroutine uses the imperative tone to declare the purpose of the code and its input/output parameters.", "code": "```fortran\nsubroutine fibrelinearcomp(C11, C12, C44, I4, response)\n  ! This subroutine calculates the compressive response of a material\n  ! based on given material coefficients and the fourth invariant.\n\n  ! Input parameters:\n  ! C11 - material coefficient 11 (type real*8)\n  ! C12 - material coefficient 12 (type real*8)\n  ! C44 - material coefficient 44 (type real*8)\n  ! I4 - fourth invariant (type real*8)\n\n  ! Output parameter:\n  ! response - compressive response of the material (type real*8)\n\n  real*8, intent(in) :: C11, C12, C44, I4\n  real*8, intent(out) :: response\n\n  ! Calculate the compressive response using the given material coefficients and the fourth invariant\n  response = C11*I4**2 + 2.0*(C12 + 2.0*C44)*I4\nend subroutine fibrelinearcomp\n```"}
{"instruction": "Create a Fortran subroutine named fibrelinearregnew to calculate the value of psi based on the input parameters i4 and matpar. The subroutine takes 2 input parameters of type real*8, and an array of real*8 for matpar. It returns 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named fibrelinearregnew to calculate the value of psi based on the input parameters i4 and matpar:\n\n```fortran\nsubroutine fibrelinearregnew(i4, matpar, psi)\n  real*8, intent(in) :: i4\n  real*8, intent(in) :: matpar(:)\n  real*8, intent(out) :: psi\n  \n  ! Calculate the value of psi based on i4 and matpar\n  ! ... (your calculation here)\n  \n  ! Set the calculated value to psi\n  psi = 0.0 ! Replace with your calculation\n  \nend subroutine fibrelinearregnew\n```\n\nIn this subroutine, i4 is a real*8 input parameter, matpar is an array of real*8 input parameter, and psi is a real*8 output parameter. You can replace the placeholder calculation with your actual calculation to determine the value of psi based on i4 and matpar."}
{"instruction": "Write a Fortran subroutine named dfibrelinearcomp to calculate the change in the potential function dpsi. The subroutine takes 2 input parameters of type real*8 and an array of real*8. The output parameter is of type real*8.", "code": "Here's a possible implementation of the dfibrelinearcomp subroutine in Fortran:\n\n```fortran\nsubroutine dfibrelinearcomp(x, y, z, dpsi)\n  real*8, intent(in) :: x, y\n  real*8, dimension(:), intent(in) :: z\n  real*8, intent(out) :: dpsi\n  \n  ! Calculate the change in the potential function\n  dpsi = x * y + sum(z)\n  \nend subroutine dfibrelinearcomp\n```\n\nIn this subroutine, x and y are input parameters of type real*8, and z is an array of real*8. The output parameter dpsi is also of type real*8. The subroutine calculates the change in the potential function using the formula x * y + sum(z) and stores the result in the dpsi variable."}
{"instruction": "Create a Fortran subroutine named mag to calculate the magnitude of a vector. The subroutine takes 2 input parameters of types integer and real, denoted as n and a respectively. It also has 1 output parameter of type real, denoted as a_mag.", "code": "Here's a Fortran subroutine named mag to calculate the magnitude of a vector:\n\n```fortran\nsubroutine mag(n, a, a_mag)\n  integer, intent(in) :: n\n  real, intent(in) :: a(n)\n  real, intent(out) :: a_mag\n  integer :: i\n\n  a_mag = 0.0\n  do i = 1, n\n    a_mag = a_mag + a(i)**2\n  end do\n  a_mag = sqrt(a_mag)\nend subroutine mag\n```\n\nIn this subroutine, n is the number of elements in the vector, a is the vector itself, and a_mag is the output parameter that will contain the magnitude of the vector. The subroutine calculates the magnitude by summing the squares of each element in the vector and then taking the square root of the sum."}
{"instruction": "Create a Fortran subroutine named poisson_prob to calculate the Poisson probability mass function and cumulative distribution function. The subroutine takes 3 input parameters of type integer, integer, and double precision, and 2 output parameters of type double precision.", "code": "Here's a Fortran subroutine named poisson_prob to calculate the Poisson probability mass function and cumulative distribution function:\n\n```fortran\nsubroutine poisson_prob(k, lambda, pmf, cdf)\n  integer, intent(in) :: k, lambda\n  real*8, intent(out) :: pmf, cdf\n  real*8 :: factorial, exp_lambda\n\n  factorial = 1.0\n  exp_lambda = exp(-real(lambda))\n\n  do i = 1, k\n    factorial = factorial * real(i)\n  end do\n\n  pmf = (exp_lambda * real(lambda)**real(k)) / factorial\n\n  cdf = 0.0\n  do i = 0, k\n    factorial = 1.0\n    do j = 1, i\n      factorial = factorial * real(j)\n    end do\n    cdf = cdf + (exp_lambda * real(lambda)**real(i)) / factorial\n  end do\nend subroutine poisson_prob\n```\n\nIn this subroutine, the input parameters k and lambda are the values at which the Poisson probability mass function and cumulative distribution function are to be evaluated, and the output parameters pmf and cdf store the calculated values."}
{"instruction": "Create a Fortran subroutine named fgroup_aqns to process and group input arrays. The subroutine takes 3 input parameters of type integer, integer, and real*8, and 3 output parameters of type integer, integer, and real*8. The subroutine should be able to process and group the input arrays according to specified conditions and update the output arrays accordingly.", "code": "Here's an example of how the Fortran subroutine fgroup_aqns might look:\n\n```fortran\nsubroutine fgroup_aqns(n, m, input_array, output_array1, output_array2, output_array3)\n  integer, intent(in) :: n, m\n  real*8, intent(in) :: input_array(n,m)\n  integer, intent(out) :: output_array1(n)\n  integer, intent(out) :: output_array2(n)\n  real*8, intent(out) :: output_array3(n)\n\n  ! Processing and grouping input arrays\n  do i = 1, n\n    output_array1(i) = 0\n    output_array2(i) = 0\n    output_array3(i) = 0.0d0\n    do j = 1, m\n      if (input_array(i,j) > 0) then\n        output_array1(i) = output_array1(i) + 1\n      else\n        output_array2(i) = output_array2(i) + 1\n      end if\n      output_array3(i) = output_array3(i) + input_array(i,j)\n    end do\n  end do\n\nend subroutine fgroup_aqns\n```\n\nIn this example, the subroutine fgroup_aqns takes 3 input parameters: n (the number of rows in the input array), m (the number of columns in the input array), and input_array (the 2D array of real*8 values). It also takes 3 output parameters: output_array1 (an array of integers), output_array2 (an array of integers), and output_array3 (an array of real*8 values).\n\nThe subroutine processes and groups the input arrays according to the specified conditions and updates the output arrays accordingly. In this example, it counts the number of positive and negative values in each row of the input array and calculates the sum of each row, updating the output arrays accordingly."}
{"instruction": "Write a Fortran subroutine named \"simple\" to calculate the sum of two real numbers. The subroutine takes 2 input parameters of type real and returns 1 output parameter of type real.", "code": "Here's a Fortran subroutine named \"simple\" to calculate the sum of two real numbers:\n\n```fortran\nsubroutine simple(a, b, result)\n  real :: a, b, result\n  result = a + b\nend subroutine simple\n```\n\nIn this subroutine, \"a\" and \"b\" are the input parameters of type real, and \"result\" is the output parameter of type real. The subroutine calculates the sum of \"a\" and \"b\" and stores the result in the \"result\" variable."}
{"instruction": "Create a Fortran subroutine named diag_mark to implement the diagonal Markowitz algorithm for finding permutations that produce near-optimal LU fill-in. The subroutine takes 2 input parameters of type integer and logical and 1 output parameter of type integer.", "code": "Here's a Fortran subroutine named diag_mark that implements the diagonal Markowitz algorithm:\n\n```fortran\nsubroutine diag_mark(n, m, a, perm)\n  integer, intent(in) :: n, m\n  logical, intent(in) :: a(n, m)\n  integer, intent(out) :: perm(n)\n  integer :: i, j, k, l, p, q, r, s, t, u, v, w, x, y, z\n  integer :: mark(n), mark2(n), mark3(n), mark4(n), mark5(n), mark6(n)\n  integer :: count, count2, count3, count4, count5, count6\n  integer :: mincount, mincount2, mincount3, mincount4, mincount5, mincount6\n  integer :: minperm(n), minperm2(n), minperm3(n), minperm4(n), minperm5(n), minperm6(n)\n  integer :: temp(n), temp2(n), temp3(n), temp4(n), temp5(n), temp6(n)\n  \n  ! Initialize permutation\n  do i = 1, n\n    perm(i) = i\n  end do\n  \n  ! Initialize mark arrays\n  do i = 1, n\n    mark(i) = 0\n    mark2(i) = 0\n    mark3(i) = 0\n    mark4(i) = 0\n    mark5(i) = 0\n    mark6(i) = 0\n  end do\n  \n  ! Initialize counts\n  count = 0\n  count2 = 0\n  count3 = 0\n  count4 = 0\n  count5 = 0\n  count6 = 0\n  \n  ! Loop over all permutations\n  do i = 1, n-1\n    do j = i+1, n\n      ! Swap elements in permutation\n      temp = perm\n      temp2 = perm\n      temp3 = perm\n      temp4 = perm\n      temp5 = perm\n      temp6 = perm\n      temp(i) = perm(j)\n      temp(j) = perm(i)\n      temp2(i) = perm(j)\n      temp2(j) = perm(i)\n      temp3(i) = perm(j)\n      temp3(j) = perm(i)\n      temp4(i) = perm(j)\n      temp4(j) = perm(i)\n      temp5(i) = perm(j)\n      temp5(j) = perm(i)\n      temp6(i) = perm(j)\n      temp6(j) = perm(i)\n      \n      ! Calculate Markowitz counts\n      do k = 1, m\n        do l = 1, n\n          if (a(l, k)) then\n            if (l == k) then\n              mark(l) = 0\n              mark2(l) = 0\n              mark3(l) = 0\n              mark4(l) = 0\n              mark5(l) = 0\n              mark6(l) = 0\n            else\n              mark(l) = count\n              mark2(l) = count2\n              mark3(l) = count3\n              mark4(l) = count4\n              mark5(l) = count5\n              mark6(l) = count6\n              do p = 1, n\n                if (a(p, k) .and. p /= k) then\n                  if (p < l) then\n                    count = count + 1\n                  else\n                    count2 = count2 + 1\n                  end if\n                end if\n                if (a(l, p) .and. p /= l) then\n                  if (p < k) then\n                    count3 = count3 + 1\n                  else\n                    count4 = count4 + 1\n                  end if\n                end if\n                if (a(p, l) .and. p /= l) then\n                  if (p < k) then\n                    count5 = count5 + 1\n                  else\n                    count6 = count6 + 1\n                  end if\n                end if\n              end do\n            end if\n          end if\n        end do\n      end do\n      \n      ! Check if current permutation has lower Markowitz count\n      if (i == 1 .and. j == 2) then\n        mincount = count\n        mincount2 = count2\n        mincount3 = count3\n        mincount4 = count4\n        mincount5 = count5\n        mincount6 = count6\n        minperm = temp\n        minperm2 = temp2\n        minperm3 = temp3\n        minperm4 = temp4\n        minperm5 = temp5\n        minperm6 = temp6\n      else\n        if (count < mincount) then\n          mincount = count\n          minperm = temp\n        end if\n        if (count2 < mincount2) then\n          mincount2 = count2\n          minperm2 = temp2\n        end if\n        if (count3 < mincount3) then\n          mincount3 = count3\n          minperm3 = temp3\n        end if\n        if (count4 < mincount4) then\n          mincount4 = count4\n          minperm4 = temp4\n        end if\n        if (count5 < mincount5) then\n          mincount5 = count5\n          minperm5 = temp5\n        end if\n        if (count6 < mincount6) then\n          mincount6 = count6\n          minperm6 = temp6\n        end if\n      end if\n    end do\n  end do\n  \n  ! Choose permutation with lowest Markowitz count\n  if (mincount < mincount2 .and. mincount < mincount3 .and. mincount < mincount4 .and. mincount < mincount5 .and. mincount < mincount6) then\n    perm = minperm\n  else if (mincount2 < mincount .and. mincount2 < mincount3 .and. mincount2 < mincount4 .and. mincount2 < mincount5 .and. mincount2 < mincount6) then\n    perm = minperm2\n  else if (mincount3 < mincount .and. mincount3 < mincount2 .and. mincount3 < mincount4 .and. mincount3 < mincount5 .and. mincount3 < mincount6) then\n    perm = minperm3\n  else if (mincount4 < mincount .and. mincount4 < mincount2 .and. mincount4 < mincount3 .and. mincount4 < mincount5 .and. mincount4 < mincount6) then\n    perm = minperm4\n  else if (mincount5 < mincount .and. mincount5 < mincount2 .and. mincount5 < mincount3 .and. mincount5 < mincount4 .and. mincount5 < mincount6) then\n    perm = minperm5\n  else\n    perm = minperm6\n  end if\nend subroutine diag_mark\n```"}
{"instruction": "Create a Fortran subroutine named eigen_max that implements the power method to compute the eigenvector and eigenvalue of maximum modulus for a given symmetric matrix. The subroutine takes in four input parameters: a real matrix 'a', an integer 'maxiter' representing the maximum number of iterations, a real 'err_v' specifying the precision for the stop criterion, and a real vector 'v_0' as the initial vector for the iteration. The subroutine returns two output parameters: a real vector 'v' representing the eigenvector and a real 'lambda' representing the eigenvalue.", "code": "Here's a Fortran subroutine named eigen_max that implements the power method:\n\n```fortran\nsubroutine eigen_max(a, maxiter, err_v, v_0, v, lambda)\n  real, dimension(:,:) :: a\n  real, dimension(:) :: v_0, v\n  integer :: maxiter, i, n\n  real :: err_v, lambda, norm_v, norm_diff, tol\n  real, dimension(:), allocatable :: temp\n\n  n = size(a, 1)\n  allocate(temp(n))\n\n  v = v_0\n  do i = 1, maxiter\n    temp = matmul(a, v)\n    lambda = dot_product(v, temp)\n    v = temp / norm2(temp)\n\n    norm_v = norm2(v_0)\n    norm_diff = norm2(v - v_0)\n    tol = err_v * norm_v\n\n    if (norm_diff < tol) exit\n    v_0 = v\n  end do\n\n  deallocate(temp)\nend subroutine eigen_max\n```\n\nIn this subroutine, 'a' is the input symmetric matrix, 'maxiter' is the maximum number of iterations, 'err_v' is the precision for the stop criterion, and 'v_0' is the initial vector for the iteration. The subroutine returns 'v' as the eigenvector and 'lambda' as the eigenvalue. The power method is used to iteratively compute the eigenvector and eigenvalue of maximum modulus for the given symmetric matrix."}
{"instruction": "Create a Fortran subroutine named \"recenter_positions\" to calculate the center of mass for a system of particles. The subroutine takes 5 input parameters: 2 integers, 1 real*8 array of size nat, 1 integer array of size nat, and 1 real*8 3D array of size (nstep, nat, 3). It produces 1 output parameter of type real*8 3D array of size (nstep, nat, 3).", "code": "Here's a possible implementation of the \"recenter_positions\" subroutine in Fortran:\n\n```fortran\nsubroutine recenter_positions(nstep, nat, masses, types, positions, center_of_mass)\n  implicit none\n  integer, intent(in) :: nstep, nat\n  real*8, intent(in) :: masses(nat)\n  integer, intent(in) :: types(nat)\n  real*8, intent(inout) :: positions(nstep, nat, 3)\n  real*8, intent(out) :: center_of_mass(nstep, nat, 3)\n\n  integer :: istep, ipart, idim\n  real*8 :: total_mass\n  real*8 :: com_x, com_y, com_z\n\n  do istep = 1, nstep\n    do ipart = 1, nat\n      total_mass = 0.0\n      com_x = 0.0\n      com_y = 0.0\n      com_z = 0.0\n\n      do idim = 1, 3\n        total_mass = total_mass + masses(ipart)\n        com_x = com_x + masses(ipart) * positions(istep, ipart, idim)\n        com_y = com_y + masses(ipart) * positions(istep, ipart, idim)\n        com_z = com_z + masses(ipart) * positions(istep, ipart, idim)\n      end do\n\n      com_x = com_x / total_mass\n      com_y = com_y / total_mass\n      com_z = com_z / total_mass\n\n      center_of_mass(istep, ipart, 1) = com_x\n      center_of_mass(istep, ipart, 2) = com_y\n      center_of_mass(istep, ipart, 3) = com_z\n    end do\n  end do\nend subroutine recenter_positions\n```\n\nIn this subroutine, we calculate the center of mass for each particle at each time step and store the results in the \"center_of_mass\" array. The input parameters are the number of time steps (nstep), the number of particles (nat), the masses of the particles (masses), the types of the particles (types), and the positions of the particles (positions). The output parameter is the center of mass for each particle at each time step (center_of_mass)."}
{"instruction": "Write a Fortran subroutine named fkron_coo with 10 input parameters of types integer and complex*16, and 3 output parameters of types integer and complex*16. The subroutine computes the Kronecker product of two sparse matrices in coordinate format and stores the result in the output parameters. The input parameters represent the dimensions and data of the two sparse matrices, and the output parameters store the dimensions and data of the resulting Kronecker product in coordinate format.", "code": "Here's a Fortran subroutine named fkron_coo that computes the Kronecker product of two sparse matrices in coordinate format:\n\n```fortran\nsubroutine fkron_coo(n1, n2, nnz1, nnz2, row1, col1, val1, row2, col2, val2, n_out, nnz_out, row_out, col_out, val_out)\n  implicit none\n  integer, intent(in) :: n1, n2, nnz1, nnz2\n  integer, intent(out) :: n_out, nnz_out\n  integer, dimension(nnz1), intent(in) :: row1, col1\n  integer, dimension(nnz2), intent(in) :: row2, col2\n  complex*16, dimension(nnz1), intent(in) :: val1\n  complex*16, dimension(nnz2), intent(in) :: val2\n  integer, dimension(:), allocatable :: row_out, col_out\n  complex*16, dimension(:), allocatable :: val_out\n  integer :: i, j, k, l, count\n\n  ! Compute the dimensions of the resulting Kronecker product\n  n_out = n1 * n2\n  nnz_out = nnz1 * nnz2\n\n  ! Allocate memory for the output arrays\n  allocate(row_out(nnz_out), col_out(nnz_out), val_out(nnz_out))\n\n  ! Compute the Kronecker product in coordinate format\n  count = 1\n  do i = 1, nnz1\n     do j = 1, nnz2\n        row_out(count) = (row1(i) - 1) * n2 + row2(j)\n        col_out(count) = (col1(i) - 1) * n2 + col2(j)\n        val_out(count) = val1(i) * val2(j)\n        count = count + 1\n     end do\n  end do\n\nend subroutine fkron_coo\n```\n\nIn this subroutine, the input parameters n1 and n2 represent the dimensions of the two sparse matrices, nnz1 and nnz2 represent the number of non-zero elements in each matrix, and row1, col1, val1, row2, col2, and val2 represent the row indices, column indices, and values of the non-zero elements in the two matrices. The output parameters n_out, nnz_out, row_out, col_out, and val_out store the dimensions and data of the resulting Kronecker product in coordinate format."}
{"instruction": "Write a Fortran subroutine named findfactor that takes an integer as input and returns the factors of the input number in an integer array along with the total number of factors. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2, where the first output argument is an integer array and the second output argument is an integer.", "code": "Here's a Fortran subroutine named findfactor that takes an integer as input and returns the factors of the input number in an integer array along with the total number of factors:\n\n```fortran\nsubroutine findfactor(n, factors, num_factors)\n  integer, intent(in) :: n\n  integer, intent(out) :: factors(n)\n  integer, intent(out) :: num_factors\n  integer :: i, count\n\n  count = 0\n  do i = 1, n\n     if (mod(n, i) == 0) then\n        count = count + 1\n        factors(count) = i\n     end if\n  end do\n\n  num_factors = count\nend subroutine findfactor\n```\n\nYou can call this subroutine from your main program and pass an integer as input to get the factors and the total number of factors in return."}
{"instruction": "Create a Fortran subroutine named calc_delo_p_thin_single to calculate a specific operation involving matrix multiplication and mathematical operations. The subroutine takes 6 input parameters of type real(kind=8) and dimensions, and 1 output parameter of type real(kind=8) and dimension. The input parameters are imatrix (4x4 real matrix), dx (real), j (4 real array), j1 (4 real array), ki (real), and ki1 (real). The subroutine computes the values for the output parameter p using matrix multiplication and arithmetic operations.", "code": "Here's a Fortran subroutine named calc_delo_p_thin_single that performs the specified operation:\n\n```fortran\nsubroutine calc_delo_p_thin_single(imatrix, dx, j, j1, ki, ki1, p)\n  real(kind=8), dimension(4,4), intent(in) :: imatrix\n  real(kind=8), intent(in) :: dx, j(4), j1(4), ki, ki1\n  real(kind=8), intent(out) :: p\n\n  ! Local variables\n  real(kind=8) :: temp(4)\n\n  ! Perform matrix multiplication and arithmetic operations\n  temp = matmul(imatrix, j) + dx * j1\n  p = sum(temp) + ki * ki1\n\nend subroutine calc_delo_p_thin_single\n```\n\nIn this subroutine, the input parameters are imatrix, dx, j, j1, ki, and ki1, and the output parameter is p. The subroutine first performs matrix multiplication between imatrix and j, then adds the result to the product of dx and j1. The temporary array temp stores the intermediate result. Finally, the subroutine calculates the sum of the elements in temp and adds the product of ki and ki1 to obtain the output parameter p."}
{"instruction": "Create a Fortran subroutine named calc_delo_q_thin_single to calculate the value of matrix q based on the input parameters. The subroutine takes 6 input parameters of type real(kind=8) and dimension(4,4) and one output parameter of type real(kind=8) and dimension(4,4). The subroutine performs a series of matrix calculations using the input parameters to compute the value of matrix q.", "code": "Here's a Fortran subroutine named calc_delo_q_thin_single that performs the described calculations:\n\n```fortran\nsubroutine calc_delo_q_thin_single(a, b, c, d, e, f, q)\n  real(kind=8), dimension(4,4), intent(in) :: a, b, c, d, e, f\n  real(kind=8), dimension(4,4), intent(out) :: q\n  ! Perform matrix calculations to compute q\n  q = matmul(matmul(matmul(matmul(matmul(a, b), c), d), e), f)\nend subroutine calc_delo_q_thin_single\n```\n\nIn this subroutine, the input parameters a, b, c, d, e, and f are 4x4 matrices of type real(kind=8), and the output parameter q is also a 4x4 matrix of type real(kind=8). The subroutine uses the matmul function to perform a series of matrix multiplications to compute the value of matrix q based on the input parameters."}
{"instruction": "Create a Fortran subroutine named \"to1stquadrant\" that transforms the input array into the first quadrant of the coordinate system. The input parameter is a 1D real array, and the output parameters are two 1D arrays of real and integer types.", "code": "Here's a Fortran subroutine named \"to1stquadrant\" that transforms the input array into the first quadrant of the coordinate system:\n\n```fortran\nsubroutine to1stquadrant(input_array, output_real_array, output_integer_array)\n  real, dimension(:), intent(in) :: input_array\n  real, dimension(:), intent(out) :: output_real_array\n  integer, dimension(:), intent(out) :: output_integer_array\n  integer :: i\n\n  do i = 1, size(input_array)\n    if (input_array(i) < 0.0) then\n      output_real_array(i) = -input_array(i)\n      output_integer_array(i) = -1\n    else\n      output_real_array(i) = input_array(i)\n      output_integer_array(i) = 1\n    end if\n  end do\nend subroutine to1stquadrant\n```\n\nIn this subroutine, the input parameter is a 1D real array \"input_array\", and the output parameters are two 1D arrays of real and integer types \"output_real_array\" and \"output_integer_array\" respectively. The subroutine loops through the input array and transforms the values into the first quadrant of the coordinate system, storing the transformed values in the output arrays. If the input value is negative, the corresponding output value is made positive and the integer output is set to -1, otherwise, the output values remain the same and the integer output is set to 1."}
{"instruction": "Write a Fortran subroutine named compute_lneta_f to calculate the lneta values based on the given input parameters. The subroutine takes 7 input parameters of types integer, integer, real(8), real(8), real(8), real(8), real(8), and has 1 output parameter of type real(8). The subroutine uses imperative tone to loop through the calculations and assign the lneta values to the output parameter.", "code": "Here's a Fortran subroutine named compute_lneta_f to calculate the lneta values based on the given input parameters:\n\n```fortran\nsubroutine compute_lneta_f(n, m, a, b, c, d, e, lneta)\n  integer, intent(in) :: n, m\n  real(8), intent(in) :: a, b, c, d, e\n  real(8), intent(out) :: lneta\n  integer :: i, j\n  real(8) :: sum\n\n  sum = 0.0d0\n  do i = 1, n\n    do j = 1, m\n      sum = sum + a * b * c * d * e / (a + b + c + d + e)\n    end do\n  end do\n\n  lneta = log(sum)\nend subroutine compute_lneta_f\n```\n\nIn this subroutine, we use imperative tone to loop through the calculations and assign the lneta values to the output parameter. The input parameters n, m, a, b, c, d, e are used to perform the calculations, and the result is stored in the output parameter lneta."}
{"instruction": "Create a Fortran subroutine named viterbi_f to perform the Viterbi algorithm for hidden Markov models. The subroutine takes 5 input parameters of type integer, integer, real(8), real(8), and real(8), and returns 2 output parameters of type integer(8) and real(8). ", "code": "Here's a Fortran subroutine named viterbi_f to perform the Viterbi algorithm for hidden Markov models:\n\n```fortran\nsubroutine viterbi_f(N, T, S, A, B, path, prob)\n  implicit none\n  integer, intent(in) :: N, T\n  real(8), intent(in) :: S(N), A(N,N), B(N,T)\n  integer(8), intent(out) :: path(T)\n  real(8), intent(out) :: prob\n\n  integer :: i, j, t\n  real(8) :: delta(N,T)\n  integer :: psi(N,T)\n\n  ! Initialization\n  do i = 1, N\n    delta(i,1) = S(i) * B(i,1)\n    psi(i,1) = 0\n  end do\n\n  ! Recursion\n  do t = 2, T\n    do j = 1, N\n      delta(j,t) = maxval(delta(:,t-1) * A(:,j)) * B(j,t)\n      psi(j,t) = maxloc(delta(:,t-1) * A(:,j))\n    end do\n  end do\n\n  ! Termination\n  prob = maxval(delta(:,T))\n  path(T) = maxloc(delta(:,T))\n\n  ! Backtrack\n  do t = T-1, 1, -1\n    path(t) = psi(path(t+1),t+1)\n  end do\n\nend subroutine viterbi_f\n```\n\nIn this subroutine, N is the number of hidden states, T is the number of observations, S is the initial state probabilities, A is the state transition probabilities, and B is the observation probabilities. The subroutine calculates the most likely sequence of hidden states (path) and the probability of that sequence (prob) using the Viterbi algorithm."}
{"instruction": "Create a Fortran subroutine named check_name_value_pair_validity to validate the input name and value pairs. The subroutine takes 2 input parameters of type character(len=*) and 2 output parameters of type logical.", "code": "Here's a Fortran subroutine named check_name_value_pair_validity:\n\n```fortran\nsubroutine check_name_value_pair_validity(name, value, valid_name, valid_value)\n  character(len=*) :: name, value\n  logical :: valid_name, valid_value\n\n  ! Check if name is valid\n  if (len_trim(name) > 0) then\n    valid_name = .true.\n  else\n    valid_name = .false.\n  end if\n\n  ! Check if value is valid\n  if (len_trim(value) > 0) then\n    valid_value = .true.\n  else\n    valid_value = .false.\n  end if\n\nend subroutine check_name_value_pair_validity\n```\n\nIn this subroutine, the input parameters are `name` and `value` of type character(len=*) and the output parameters are `valid_name` and `valid_value` of type logical. The subroutine checks if the input name and value pairs are valid by checking if they are non-empty strings and sets the corresponding output parameters accordingly."}
{"instruction": "Create a Fortran subroutine named tolowercase that takes an input string of type character(*) and converts it to lowercase. The subroutine has 1 input parameter of type character(*) and 1 output parameter of type character(*).", "code": "Here's a Fortran subroutine named tolowercase that takes an input string and converts it to lowercase:\n\n```fortran\nsubroutine tolowercase(input_string, output_string)\n  character(*), intent(in) :: input_string\n  character(*), intent(out) :: output_string\n  integer :: i\n\n  output_string = input_string\n\n  do i = 1, len_trim(output_string)\n    if (achar(output_string(i)) >= 'A' .and. achar(output_string(i)) <= 'Z') then\n      output_string(i:i) = char(ichar(output_string(i)) + ichar('a') - ichar('A'))\n    end if\n  end do\n\nend subroutine tolowercase\n```\n\nYou can use this subroutine by passing an input string and an output string to it. The output string will contain the lowercase version of the input string."}
{"instruction": "Create a Fortran subroutine named \"appminbtomolinvol\" to calculate the mole quantities of two elements within a given volume. The subroutine takes 6 input parameters of types integer, real(8), and real(8), and 2 output parameters of type real(8). The input parameters include the scale of mole values, ppm values, mass per mole for two different elements, density, and volume. The output parameters represent the mole quantities of the two elements within the given volume.", "code": "Here's a Fortran subroutine named \"appminbtomolinvol\" that calculates the mole quantities of two elements within a given volume:\n\n```fortran\nsubroutine appminbtomolinvol(scale, ppm1, ppm2, mass_per_mole1, mass_per_mole2, density, volume, mole_quantity1, mole_quantity2)\n  implicit none\n  integer, intent(in) :: scale\n  real(8), intent(in) :: ppm1, ppm2, mass_per_mole1, mass_per_mole2, density, volume\n  real(8), intent(out) :: mole_quantity1, mole_quantity2\n\n  ! Calculate mole quantities\n  mole_quantity1 = (ppm1 * 1.0d-6 * density * volume) / mass_per_mole1\n  mole_quantity2 = (ppm2 * 1.0d-6 * density * volume) / mass_per_mole2\n\nend subroutine appminbtomolinvol\n```\n\nIn this subroutine, the input parameters are:\n- `scale` (integer): the scale of mole values\n- `ppm1` (real(8)): parts per million value for the first element\n- `ppm2` (real(8)): parts per million value for the second element\n- `mass_per_mole1` (real(8)): mass per mole for the first element\n- `mass_per_mole2` (real(8)): mass per mole for the second element\n- `density` (real(8)): density of the substance\n- `volume` (real(8)): given volume\n\nThe output parameters are:\n- `mole_quantity1` (real(8)): mole quantity of the first element within the given volume\n- `mole_quantity2` (real(8)): mole quantity of the second element within the given volume"}
{"instruction": "Write a Fortran subroutine named triangle to compute the squares of the lengths of the sides and the area of a triangle defined by three points x1, x2, and x3 in 3D Euclidean space. The number of input arguments is 3 and the test_data type is ['real*8', 'real*8', 'real*8'].The number of output arguments is 4 and the test_data type is ['real*8', 'real*8', 'real*8', 'real*8'].", "code": "Here's a Fortran subroutine named triangle that computes the squares of the lengths of the sides and the area of a triangle defined by three points x1, x2, and x3 in 3D Euclidean space:\n\n```fortran\nsubroutine triangle(x1, x2, x3, side1_sq, side2_sq, side3_sq, area)\n  implicit none\n  real*8, intent(in) :: x1(3), x2(3), x3(3)\n  real*8, intent(out) :: side1_sq, side2_sq, side3_sq, area\n  real*8 :: a, b, c, s\n\n  ! Compute the squares of the lengths of the sides\n  a = sqrt((x2(1) - x1(1))**2 + (x2(2) - x1(2))**2 + (x2(3) - x1(3))**2)\n  b = sqrt((x3(1) - x2(1))**2 + (x3(2) - x2(2))**2 + (x3(3) - x2(3))**2)\n  c = sqrt((x1(1) - x3(1))**2 + (x1(2) - x3(2))**2 + (x1(3) - x3(3))**2)\n  side1_sq = a**2\n  side2_sq = b**2\n  side3_sq = c**2\n\n  ! Compute the area of the triangle using Heron's formula\n  s = (a + b + c) / 2.0\n  area = sqrt(s * (s - a) * (s - b) * (s - c))\nend subroutine triangle\n```\n\nIn this subroutine, the input arguments x1, x2, and x3 are arrays of three real*8 values representing the coordinates of the three points in 3D space. The output arguments side1_sq, side2_sq, side3_sq, and area are real*8 values representing the squares of the lengths of the sides and the area of the triangle, respectively."}
{"instruction": "Write a Fortran subroutine named integer_flux_x to calculate the flux of a three-dimensional array based on input arrays c and q. The number of input parameters is 2, with test_data types ['real, dimension(:,:,:)','real, dimension(:,:,:)'], and the number of output parameters is 1, with test_data type ['real, dimension(:,:,:)'].", "code": "Here's a Fortran subroutine named integer_flux_x that calculates the flux of a three-dimensional array based on input arrays c and q:\n\n```fortran\nsubroutine integer_flux_x(c, q, flux)\n  real, dimension(:,:,:), intent(in) :: c, q\n  real, dimension(:,:,:), intent(out) :: flux\n  integer :: i, j, k\n\n  do k = 1, size(c, 3)\n    do j = 1, size(c, 2)\n      do i = 1, size(c, 1)-1\n        flux(i,j,k) = c(i,j,k) * q(i,j,k) - c(i+1,j,k) * q(i+1,j,k)\n      end do\n    end do\n  end do\n\nend subroutine integer_flux_x\n```\n\nIn this subroutine, the input arrays c and q are three-dimensional arrays, and the output array flux is also a three-dimensional array. The subroutine calculates the flux in the x-direction based on the input arrays c and q."}
{"instruction": "Write a Fortran subroutine named \"mooneyrivlinmodified\" to calculate the strain energy density \"psi\" based on the given input parameters. The subroutine should take 2 input parameters of type real*8, invc and matpar, and 1 output parameter of type real*8, psi. The \"mooneyrivlinmodified\" subroutine should use the \"intent(in)\" attribute for the input parameters and the \"intent(out)\" attribute for the output parameter.", "code": "Here's a Fortran subroutine named \"mooneyrivlinmodified\" to calculate the strain energy density \"psi\" based on the given input parameters:\n\n```fortran\nsubroutine mooneyrivlinmodified(invc, matpar, psi)\n  real*8, intent(in) :: invc, matpar\n  real*8, intent(out) :: psi\n\n  ! Calculate the strain energy density\n  psi = 0.5 * matpar * (invc**2 - 3.0) + (1.0 - invc**2 + log(invc**2)) / (invc**2 - 1.0)\n\nend subroutine mooneyrivlinmodified\n```\n\nIn this subroutine, the input parameters \"invc\" and \"matpar\" are of type real*8 and have the \"intent(in)\" attribute, indicating that they are input parameters. The output parameter \"psi\" is also of type real*8 and has the \"intent(out)\" attribute, indicating that it is an output parameter. The subroutine calculates the strain energy density \"psi\" based on the input parameters \"invc\" and \"matpar\" using the Mooney-Rivlin modified model."}
{"instruction": "Write a Fortran subroutine named find_bounds to calculate the bounds of a given value within an array of profile data. The subroutine takes 3 input parameters of type real, dimension(:), real, and returns 2 output parameters of type real, dimension(2).", "code": "Here's a possible implementation of the find_bounds subroutine in Fortran:\n\n```fortran\nsubroutine find_bounds(profile, value, bounds)\n  real, dimension(:), intent(in) :: profile\n  real, intent(in) :: value\n  real, dimension(2), intent(out) :: bounds\n  integer :: lower_bound, upper_bound, i\n\n  ! Initialize lower and upper bounds\n  lower_bound = 1\n  upper_bound = size(profile)\n\n  ! Search for lower bound\n  do while (lower_bound < upper_bound)\n    i = (lower_bound + upper_bound) / 2\n    if (profile(i) < value) then\n      lower_bound = i + 1\n    else\n      upper_bound = i\n    end if\n  end do\n\n  ! Set lower bound\n  bounds(1) = lower_bound\n\n  ! Reset upper bound\n  upper_bound = size(profile)\n\n  ! Search for upper bound\n  do while (lower_bound < upper_bound)\n    i = (lower_bound + upper_bound) / 2\n    if (profile(i) <= value) then\n      lower_bound = i + 1\n    else\n      upper_bound = i\n    end if\n  end do\n\n  ! Set upper bound\n  bounds(2) = upper_bound\n\nend subroutine find_bounds\n```\n\nThis subroutine uses a binary search algorithm to find the lower and upper bounds of the given value within the profile array. The lower and upper bounds are then returned in the bounds array."}
{"instruction": "Write a Fortran subroutine named getarg_a to retrieve the command-line arguments. The subroutine takes 1 input argument of type integer and returns 1 output argument of type character(*). The input argument specifies the order of the argument to retrieve.", "code": "Here's a Fortran subroutine named getarg_a to retrieve the command-line arguments:\n\n```fortran\nsubroutine getarg_a(arg_order, arg_value)\n  integer, intent(in) :: arg_order\n  character(len=*), intent(out) :: arg_value\n\n  call get_command_argument(arg_order, arg_value)\nend subroutine getarg_a\n```\n\nIn this subroutine, the input argument `arg_order` specifies the order of the command-line argument to retrieve, and the output argument `arg_value` is of type character(*) and will contain the value of the specified command-line argument. The `get_command_argument` function is used to retrieve the command-line argument based on the specified order."}
{"instruction": "Write a Fortran subroutine named mop4_kursawe to calculate the fitness and violation of an individual for a multi-objective optimization problem. The subroutine takes 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer.", "code": "Here's a possible implementation of the subroutine mop4_kursawe:\n\n```fortran\nsubroutine mop4_kursawe(x, n, m, f, violation)\n  implicit none\n  integer, intent(in) :: n, m\n  real, intent(in) :: x(n)\n  real, intent(out) :: f(m)\n  integer, intent(out) :: violation\n\n  ! Calculate fitness\n  f(1) = 0.0\n  do i = 1, n-1\n    f(1) = f(1) + (-10.0 * exp(-0.2 * sqrt(x(i)**2 + x(i+1)**2)))\n  end do\n\n  f(2) = 0.0\n  do i = 1, n\n    f(2) = f(2) + abs(x(i))**0.8 + 5.0 * sin(x(i)**3)\n  end do\n\n  ! Calculate violation\n  violation = 0\n  do i = 1, n\n    if (x(i) < -5.0 .or. x(i) > 5.0) then\n      violation = violation + 1\n    end if\n  end do\n\nend subroutine mop4_kursawe\n```\n\nIn this subroutine, the input parameters are the integer n (the number of decision variables), the integer m (the number of objectives), and the real array x (the decision variables). The output parameters are the real array f (the fitness values for each objective) and the integer violation (the number of constraint violations).\n\nThe subroutine calculates the fitness values for the Kursawe multi-objective optimization problem using the input decision variables x. It also calculates the violation by checking if any decision variable is outside the range [-5, 5].\n\nThis subroutine can be called from a main program or another subroutine to evaluate the fitness and violation of an individual for the Kursawe problem in a multi-objective optimization context."}
{"instruction": "Write a Fortran subroutine named c_mult to perform complex multiplication. The subroutine takes 4 input arguments of type real(kind=8) - ar, ai, br, bi and 2 output arguments of type real(kind=8) - cr, ci.", "code": "Here's a Fortran subroutine named c_mult to perform complex multiplication:\n\n```fortran\nsubroutine c_mult(ar, ai, br, bi, cr, ci)\n  real(kind=8), intent(in) :: ar, ai, br, bi\n  real(kind=8), intent(out) :: cr, ci\n\n  cr = ar*br - ai*bi\n  ci = ar*bi + ai*br\nend subroutine c_mult\n```\n\nYou can use this subroutine to perform complex multiplication by passing in the real and imaginary parts of the two complex numbers as input arguments, and the real and imaginary parts of the result as output arguments."}
{"instruction": "Write a Fortran subroutine named \"diag_double\" that takes a vector as input and generates a matrix with the diagonal elements containing the vector values. The input parameter is of type double precision, dimension(:), and intent(in), while the output parameter is of type double precision, dimension(size(vector), size(vector)), and intent(out).", "code": "Here's a Fortran subroutine named \"diag_double\" that accomplishes the task:\n\n```fortran\nsubroutine diag_double(vector, matrix)\n  double precision, dimension(:), intent(in) :: vector\n  double precision, dimension(size(vector), size(vector)), intent(out) :: matrix\n  integer :: i, j\n\n  do i = 1, size(vector)\n     do j = 1, size(vector)\n        if (i == j) then\n           matrix(i, j) = vector(i)\n        else\n           matrix(i, j) = 0.0\n        end if\n     end do\n  end do\n\nend subroutine diag_double\n```\n\nThis subroutine takes a vector as input and generates a matrix with the diagonal elements containing the vector values. The input parameter \"vector\" is of type double precision, dimension(:), and intent(in), while the output parameter \"matrix\" is of type double precision, dimension(size(vector), size(vector)), and intent(out). Inside the subroutine, a nested loop is used to iterate over the elements of the matrix and set the diagonal elements to the corresponding values from the input vector, while setting all other elements to 0.0."}
{"instruction": "Create a Fortran subroutine named mmul that takes two input parameters of type real, dimension(:,:) and one output parameter of type real, dimension(:,:). The subroutine computes the matrix multiplication of the input arrays a and b and stores the result in the output array c.", "code": "Here's a Fortran subroutine named mmul that performs matrix multiplication:\n\n```fortran\nsubroutine mmul(a, b, c)\n  real, dimension(:,:), intent(in) :: a, b\n  real, dimension(:,:), intent(out) :: c\n  integer :: m, n, p\n  integer :: i, j, k\n\n  m = size(a, 1)\n  n = size(a, 2)\n  p = size(b, 2)\n\n  if (n /= size(b, 1)) then\n    print *, \"Error: Matrix dimensions do not match for multiplication\"\n    return\n  end if\n\n  do i = 1, m\n    do j = 1, p\n      c(i, j) = 0.0\n      do k = 1, n\n        c(i, j) = c(i, j) + a(i, k) * b(k, j)\n      end do\n    end do\n  end do\n\nend subroutine mmul\n```\n\nYou can use this subroutine by passing the input matrices a and b and the output matrix c as arguments. The subroutine will compute the matrix multiplication of a and b and store the result in c."}
{"instruction": "Write a Fortran subroutine named \"est_weirdim\" to estimate rectangular weir dimensions based on the width-depth ratio of the weir at different stages. The subroutine should take 3 input parameters of type real (depwid, desdis, cd) and provide 2 output parameters of type real (wwidth, wdepth).", "code": "Here's a Fortran subroutine that estimates rectangular weir dimensions based on the width-depth ratio:\n\n```fortran\nsubroutine est_weirdim(depwid, desdis, cd, wwidth, wdepth)\n  real, intent(in) :: depwid, desdis, cd\n  real, intent(out) :: wwidth, wdepth\n\n  ! Constants\n  real, parameter :: g = 9.81 ! Acceleration due to gravity (m/s^2)\n\n  ! Calculate the width and depth of the weir\n  wwidth = depwid * desdis / (cd * sqrt(2 * g * desdis))\n  wdepth = depwid / wwidth\nend subroutine est_weirdim\n```\n\nIn this subroutine, `depwid` is the depth-width ratio of the weir, `desdis` is the design discharge, and `cd` is the coefficient of discharge. The subroutine calculates the width and depth of the weir based on these input parameters and provides them as output parameters `wwidth` and `wdepth`."}
{"instruction": "Create a Fortran subroutine named field_h to calculate the electric and magnetic field components for a given set of input parameters. The subroutine takes 11 input parameters of types real(8), complex(8), and integer(8), and returns 3 output parameters of type complex(8).", "code": "Here's a sample Fortran subroutine named field_h that calculates the electric and magnetic field components:\n\n```fortran\nsubroutine field_h(x, y, z, t, rho, phi, omega, epsilon, mu, n, m, e_field, b_field)\n  implicit none\n  real(8), intent(in) :: x, y, z, t, rho, phi, omega, epsilon, mu\n  integer(8), intent(in) :: n, m\n  complex(8), intent(out) :: e_field(3), b_field(3)\n  \n  ! Calculate electric field components\n  e_field(1) = 0.0_8\n  e_field(2) = 0.0_8\n  e_field(3) = 0.0_8\n  \n  ! Calculate magnetic field components\n  b_field(1) = 0.0_8\n  b_field(2) = 0.0_8\n  b_field(3) = 0.0_8\n  \nend subroutine field_h\n```\n\nIn this example, the subroutine takes 11 input parameters (x, y, z, t, rho, phi, omega, epsilon, mu, n, m) and returns 3 output parameters (e_field, b_field), all of which are of the specified types. You can modify the calculations inside the subroutine to suit your specific needs."}
{"instruction": "Create a Fortran subroutine named deriv_s to carry out differentiation by wavenumber multiplication. It takes 4 input parameters: m (integer), n (integer), k (double precision array of length n), var (double precision 2D array with dimensions m and n). It outputs a double precision 2D array der with dimensions m and n+1.", "code": "Here's a Fortran subroutine named deriv_s that carries out differentiation by wavenumber multiplication:\n\n```fortran\nsubroutine deriv_s(m, n, k, var, der)\n  integer, intent(in) :: m, n\n  double precision, intent(in) :: k(n), var(m,n)\n  double precision, intent(out) :: der(m,n+1)\n  integer :: i, j\n\n  do i = 1, m\n    der(i,1) = 0.0\n    do j = 1, n\n      der(i,1) = der(i,1) + k(j) * var(i,j)\n      der(i,j+1) = k(j) * var(i,j)\n    end do\n  end do\n\nend subroutine deriv_s\n```\n\nIn this subroutine, the input parameters are m (integer), n (integer), k (double precision array of length n), and var (double precision 2D array with dimensions m and n). The output is a double precision 2D array der with dimensions m and n+1. The differentiation is carried out by multiplying each element of the var array by the corresponding element of the k array and storing the result in the der array."}
{"instruction": "Create a Fortran subroutine named utility_recip_lattice to calculate the reciprocal lattice vectors and the cell volume. The subroutine takes 1 input parameter of type real*8 and returns 2 output parameters of type real*8.", "code": "Here's a Fortran subroutine named utility_recip_lattice:\n\n```fortran\nsubroutine utility_recip_lattice(a, recip_a, recip_b, recip_c, volume)\n  real*8, intent(in) :: a(3,3)  ! Input lattice vectors\n  real*8, intent(out) :: recip_a(3), recip_b(3), recip_c(3)  ! Output reciprocal lattice vectors\n  real*8, intent(out) :: volume  ! Output cell volume\n  real*8 :: det, b(3,3)\n\n  ! Calculate the determinant of the input lattice vectors\n  det = a(1,1)*(a(2,2)*a(3,3) - a(2,3)*a(3,2)) - a(1,2)*(a(2,1)*a(3,3) - a(2,3)*a(3,1)) + a(1,3)*(a(2,1)*a(3,2) - a(2,2)*a(3,1))\n\n  ! Calculate the reciprocal lattice vectors\n  b(1,1) = (a(2,2)*a(3,3) - a(2,3)*a(3,2)) / det\n  b(1,2) = (a(1,3)*a(3,2) - a(1,2)*a(3,3)) / det\n  b(1,3) = (a(1,2)*a(2,3) - a(1,3)*a(2,2)) / det\n  b(2,1) = (a(2,3)*a(3,1) - a(2,1)*a(3,3)) / det\n  b(2,2) = (a(1,1)*a(3,3) - a(1,3)*a(3,1)) / det\n  b(2,3) = (a(1,3)*a(2,1) - a(1,1)*a(2,3)) / det\n  b(3,1) = (a(2,1)*a(3,2) - a(2,2)*a(3,1)) / det\n  b(3,2) = (a(1,2)*a(3,1) - a(1,1)*a(3,2)) / det\n  b(3,3) = (a(1,1)*a(2,2) - a(1,2)*a(2,1)) / det\n\n  ! Calculate the volume of the cell\n  volume = abs(det)\n\n  ! Return the reciprocal lattice vectors\n  recip_a = 2*acos(-1.d0)*b(:,1)\n  recip_b = 2*acos(-1.d0)*b(:,2)\n  recip_c = 2*acos(-1.d0)*b(:,3)\n\nend subroutine utility_recip_lattice\n```\n\nThis subroutine takes an input parameter `a` which is a 3x3 matrix representing the lattice vectors, and returns the reciprocal lattice vectors `recip_a`, `recip_b`, and `recip_c`, as well as the cell volume `volume`. The subroutine first calculates the determinant of the input lattice vectors, then uses it to calculate the reciprocal lattice vectors and the cell volume. Finally, it returns the calculated values."}
{"instruction": "Create a Fortran subroutine named dcomputewspd to calculate the wind speed magnitude from the horizontal wind components. The subroutine takes 3 input parameters of types integer, real(kind=8) arrays of dimension n, and real(kind=8) arrays of dimension n. It returns 1 output parameter of type real(kind=8) array of dimension n.", "code": "Here's a Fortran subroutine named dcomputewspd that calculates the wind speed magnitude from the horizontal wind components:\n\n```fortran\nsubroutine dcomputewspd(n, u, v, wspd)\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), dimension(n), intent(in) :: u, v\n  real(kind=8), dimension(n), intent(out) :: wspd\n  integer :: i\n\n  do i = 1, n\n     wspd(i) = sqrt(u(i)**2 + v(i)**2)\n  end do\n\nend subroutine dcomputewspd\n```\n\nIn this subroutine, n is the number of elements in the arrays u, v, and wspd. The arrays u and v contain the horizontal wind components, and the array wspd will store the calculated wind speed magnitudes. The subroutine uses a do loop to calculate the wind speed magnitude for each element in the arrays u and v and stores the result in the corresponding element of the array wspd."}
{"instruction": "Write a Fortran subroutine named linur to solve a system of linear equations using the Upper-Right Cholesky Decomposition method. The subroutine takes 4 input parameters of types integer, integer, double precision array, and double precision array. It returns 2 output parameters of types integer and double precision array.", "code": "Here's a Fortran subroutine named linur to solve a system of linear equations using the Upper-Right Cholesky Decomposition method:\n\n```fortran\nsubroutine linur(n, m, A, b, info, x)\n  integer, intent(in) :: n, m\n  double precision, dimension(n, n), intent(in) :: A\n  double precision, dimension(n), intent(in) :: b\n  integer, intent(out) :: info\n  double precision, dimension(n), intent(out) :: x\n  double precision, dimension(n, n) :: R\n  double precision, dimension(n) :: y\n  integer :: i, j, k\n\n  ! Perform Cholesky decomposition\n  R = 0.0\n  do j = 1, n\n    do i = j, n\n      R(i, j) = A(i, j)\n      do k = 1, j - 1\n        R(i, j) = R(i, j) - R(i, k) * R(j, k)\n      end do\n      if (i == j) then\n        if (R(j, j) <= 0.0) then\n          info = -1\n          return\n        end if\n        R(j, j) = sqrt(R(j, j))\n      else\n        R(i, j) = R(i, j) / R(j, j)\n      end if\n    end do\n  end do\n\n  ! Solve the system using back substitution\n  do i = 1, n\n    y(i) = b(i)\n    do j = 1, i - 1\n      y(i) = y(i) - R(j, i) * x(j)\n    end do\n    y(i) = y(i) / R(i, i)\n  end do\n\n  do i = n, 1, -1\n    x(i) = y(i)\n    do j = i + 1, n\n      x(i) = x(i) - R(i, j) * x(j)\n    end do\n    x(i) = x(i) / R(i, i)\n  end do\n\n  info = 0\nend subroutine linur\n```\n\nIn this subroutine, n is the size of the system of linear equations, m is not used, A is the coefficient matrix, b is the right-hand side vector, info is a flag indicating success or failure, and x is the solution vector. The subroutine first performs the Upper-Right Cholesky Decomposition on the coefficient matrix A, and then solves the system using back substitution. If the Cholesky decomposition fails (i.e., the matrix is not positive definite), the info flag is set to -1."}
{"instruction": "Create a Fortran subroutine named \"dhkmrk\" to evaluate a feature based on the input feature index and value. The subroutine should take 2 input parameters of type integer and 1 output parameter of type integer. The input parameters should be named \"iknmrk\" and \"kenmrk\", and the output parameter should be named \"knmrki\".", "code": "Here's a Fortran subroutine named \"dhkmrk\" that evaluates a feature based on the input feature index and value:\n\n```fortran\nsubroutine dhkmrk(iknmrk, kenmrk, knmrki)\n  integer, intent(in) :: iknmrk, kenmrk\n  integer, intent(out) :: knmrki\n  \n  ! Evaluate the feature based on the input feature index and value\n  ! (Add your feature evaluation logic here)\n  \n  ! Assign the evaluated feature value to the output parameter\n  knmrki = iknmrk + kenmrk\n  \nend subroutine dhkmrk\n```\n\nIn this subroutine, \"iknmrk\" and \"kenmrk\" are the input parameters of type integer, and \"knmrki\" is the output parameter of type integer. The feature evaluation logic should be added in the subroutine based on the input feature index and value."}
{"instruction": "Create a Fortran subroutine named \"io_pathextract\" to extract the path and filename from a given path+filename string. The subroutine should have 1 input parameter of type character(len=*), and 3 optional output parameters of types character(len=*), character(len=*), and logical.", "code": "Here's a Fortran subroutine named \"io_pathextract\" that extracts the path and filename from a given path+filename string:\n\n```fortran\nsubroutine io_pathextract(fullpath, path, filename, success)\n  character(len=*), intent(in) :: fullpath\n  character(len=*), intent(out), optional :: path\n  character(len=*), intent(out), optional :: filename\n  logical, intent(out), optional :: success\n  character(len=256) :: temp_path\n  character(len=256) :: temp_filename\n  integer :: i, last_slash\n\n  ! Initialize success flag\n  if (present(success)) then\n    success = .false.\n  endif\n\n  ! Find the last occurrence of the slash character\n  last_slash = 0\n  do i = len(fullpath), 1, -1\n    if (fullpath(i:i) == '/') then\n      last_slash = i\n      exit\n    endif\n  end do\n\n  ! Extract the path and filename\n  if (last_slash > 0) then\n    if (present(path)) then\n      path = fullpath(1:last_slash)\n    endif\n    if (present(filename)) then\n      filename = fullpath(last_slash+1:)\n    endif\n    if (present(success)) then\n      success = .true.\n    endif\n  else\n    if (present(path)) then\n      path = ''\n    endif\n    if (present(filename)) then\n      filename = fullpath\n    endif\n  endif\nend subroutine io_pathextract\n```\n\nIn this subroutine, the input parameter \"fullpath\" is the path+filename string from which the path and filename will be extracted. The optional output parameters \"path\" and \"filename\" will contain the extracted path and filename, respectively. The optional output parameter \"success\" will be set to .true. if the extraction was successful, and .false. otherwise. If the \"success\" parameter is not provided, the subroutine will not set it.\n\nYou can call this subroutine with the \"fullpath\" string and the optional output parameters to extract the path and filename from the given path+filename string."}
{"instruction": "Create a Fortran subroutine named linear_regression to perform linear regression analysis. The subroutine takes 2 input parameters of type real, and the output consists of 3 parameters, all of type real.", "code": "Here's a Fortran subroutine named linear_regression that performs linear regression analysis:\n\n```fortran\nsubroutine linear_regression(x, y, slope, intercept, r_squared)\n  real, intent(in) :: x(:), y(:)\n  real, intent(out) :: slope, intercept, r_squared\n  real :: sum_x, sum_y, sum_xy, sum_x_squared, n\n  real :: mean_x, mean_y\n\n  n = real(size(x))\n  sum_x = sum(x)\n  sum_y = sum(y)\n  sum_xy = dot_product(x, y)\n  sum_x_squared = dot_product(x, x)\n\n  mean_x = sum_x / n\n  mean_y = sum_y / n\n\n  slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x**2)\n  intercept = mean_y - slope * mean_x\n\n  r_squared = ((n * sum_xy - sum_x * sum_y)**2) / ((n * sum_x_squared - sum_x**2) * (n * dot_product(y, y) - sum_y**2))\n\nend subroutine linear_regression\n```\n\nThis subroutine takes two input parameters x and y, which are arrays of real numbers representing the independent and dependent variables, respectively. It also has three output parameters slope, intercept, and r_squared, which are the slope, intercept, and coefficient of determination (R-squared) of the linear regression model."}
{"instruction": "Write a Fortran subroutine named get1dpbc to calculate periodic boundary conditions for a one-dimensional system. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are pos and lsze, while the output parameters are r and l. The subroutine should calculate the values of r and l based on the input parameters pos and lsze using periodic boundary conditions.", "code": "Here's a Fortran subroutine named get1dpbc that calculates periodic boundary conditions for a one-dimensional system:\n\n```fortran\nsubroutine get1dpbc(pos, lsze, r, l)\n  integer, intent(in) :: pos, lsze\n  integer, intent(out) :: r, l\n\n  r = mod(pos - 1, lsze) + 1\n  l = mod(pos + lsze - 2, lsze) + 1\nend subroutine get1dpbc\n```\n\nIn this subroutine, the input parameters pos and lsze are of type integer and are passed by reference using the intent(in) attribute. The output parameters r and l are also of type integer and are passed by reference using the intent(out) attribute.\n\nThe subroutine calculates the values of r and l based on the input parameters pos and lsze using periodic boundary conditions. The mod function is used to ensure that the values of r and l are within the range of 1 to lsze."}
{"instruction": "Create a Fortran subroutine named \"inverse_ordered_comb2_iterator\" to handle the inverse ordered combination of binary data. The subroutine should take 3 input arguments of type integer, integer, and integer array with dimensions (0:h-1, 0:l-1), and 1 output argument of type integer array with dimensions (0:h-1, 0:l/2-1).", "code": "Here's a possible implementation of the Fortran subroutine \"inverse_ordered_comb2_iterator\":\n\n```fortran\nsubroutine inverse_ordered_comb2_iterator(h, l, data, result)\n  integer, intent(in) :: h, l\n  integer, intent(in) :: data(0:h-1, 0:l-1)\n  integer, intent(out) :: result(0:h-1, 0:l/2-1)\n  \n  ! Your implementation here\n  \nend subroutine inverse_ordered_comb2_iterator\n```\n\nYou can fill in the implementation of the subroutine with the necessary logic to handle the inverse ordered combination of binary data. The input arguments are the integers h and l, and the array data with dimensions (0:h-1, 0:l-1). The output argument is the array result with dimensions (0:h-1, 0:l/2-1)."}
{"instruction": "Create a Fortran subroutine named inverse_3_3 to calculate the inverse of a 3x3 real-valued matrix. The subroutine takes one input parameter of type real(kind=8), dimension(3,3) and one output parameter of the same type and dimensions.", "code": "Here's a Fortran subroutine named inverse_3_3 to calculate the inverse of a 3x3 real-valued matrix:\n\n```fortran\nsubroutine inverse_3_3(matrix, inv_matrix)\n  real(kind=8), dimension(3,3), intent(in) :: matrix\n  real(kind=8), dimension(3,3), intent(out) :: inv_matrix\n  real(kind=8) :: det\n\n  det = matrix(1,1)*(matrix(2,2)*matrix(3,3) - matrix(2,3)*matrix(3,2)) &\n      - matrix(1,2)*(matrix(2,1)*matrix(3,3) - matrix(2,3)*matrix(3,1)) &\n      + matrix(1,3)*(matrix(2,1)*matrix(3,2) - matrix(2,2)*matrix(3,1))\n\n  inv_matrix(1,1) = (matrix(2,2)*matrix(3,3) - matrix(2,3)*matrix(3,2)) / det\n  inv_matrix(1,2) = (matrix(1,3)*matrix(3,2) - matrix(1,2)*matrix(3,3)) / det\n  inv_matrix(1,3) = (matrix(1,2)*matrix(2,3) - matrix(1,3)*matrix(2,2)) / det\n  inv_matrix(2,1) = (matrix(2,3)*matrix(3,1) - matrix(2,1)*matrix(3,3)) / det\n  inv_matrix(2,2) = (matrix(1,1)*matrix(3,3) - matrix(1,3)*matrix(3,1)) / det\n  inv_matrix(2,3) = (matrix(1,3)*matrix(2,1) - matrix(1,1)*matrix(2,3)) / det\n  inv_matrix(3,1) = (matrix(2,1)*matrix(3,2) - matrix(2,2)*matrix(3,1)) / det\n  inv_matrix(3,2) = (matrix(1,2)*matrix(3,1) - matrix(1,1)*matrix(3,2)) / det\n  inv_matrix(3,3) = (matrix(1,1)*matrix(2,2) - matrix(1,2)*matrix(2,1)) / det\nend subroutine inverse_3_3\n```\n\nThis subroutine takes a 3x3 real-valued matrix as input and calculates its inverse, storing the result in the output parameter inv_matrix. The determinant of the input matrix is calculated using the standard formula, and then the elements of the inverse matrix are computed using the determinant and the cofactor matrix."}
{"instruction": "Create a Fortran subroutine named assigncomplex to convert a complex number to a 2x2 real matrix. The subroutine has 1 input parameter of type complex*16 and 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named assigncomplex to convert a complex number to a 2x2 real matrix:\n\n```fortran\nsubroutine assigncomplex(complex_num, real_matrix)\n  complex*16 :: complex_num\n  real*8 :: real_matrix(2,2)\n  \n  real_matrix(1,1) = real(complex_num)\n  real_matrix(1,2) = aimag(complex_num)\n  real_matrix(2,1) = -aimag(complex_num)\n  real_matrix(2,2) = real(complex_num)\n  \nend subroutine assigncomplex\n```\n\nIn this subroutine, the input parameter complex_num is of type complex*16, and the output parameter real_matrix is of type real*8. The subroutine assigns the real and imaginary parts of the complex number to the elements of the 2x2 real matrix."}
{"instruction": "Write a Fortran subroutine named xpoint to calculate the intersection point of two given lines. The subroutine takes 6 input parameters of type real(8) and returns 2 output parameters of type real(8).", "code": "Here's a Fortran subroutine named xpoint to calculate the intersection point of two given lines:\n\n```fortran\nsubroutine xpoint(x1, y1, m1, x2, y2, m2, x_int, y_int)\n  real(8), intent(in) :: x1, y1, m1, x2, y2, m2\n  real(8), intent(out) :: x_int, y_int\n\n  if (m1 == m2) then\n    write(*,*) 'Error: Lines are parallel, no intersection point'\n  else\n    x_int = (y2 - y1 + m1*x1 - m2*x2) / (m1 - m2)\n    y_int = y1 + m1*(x_int - x1)\n  end if\nend subroutine xpoint\n```\n\nIn this subroutine, x1, y1, m1, x2, y2, and m2 are the input parameters representing the coordinates and slopes of the two lines. x_int and y_int are the output parameters representing the intersection point. If the two lines are parallel, an error message is printed. Otherwise, the intersection point is calculated and returned."}
{"instruction": "Write a Fortran subroutine named preparetitle that constructs a title string from an array of strings. The subroutine takes 3 input parameters of type character array, integer, and integer, and 1 output parameter of type character.", "code": "Here's a Fortran subroutine named preparetitle that constructs a title string from an array of strings:\n\n```fortran\nsubroutine preparetitle(input_strings, num_strings, max_length, title)\n  character(len=*) :: input_strings(:)\n  character(len=*) :: title\n  integer :: num_strings, max_length, i, j\n\n  title = \"\"\n  do i = 1, num_strings\n    do j = 1, max_length\n      if (j <= len(input_strings(i))) then\n        title = trim(title) // trim(input_strings(i)(j:j))\n      else\n        title = trim(title) // \" \"\n      end if\n    end do\n  end do\nend subroutine preparetitle\n```\n\nIn this subroutine, the input parameters are:\n- input_strings: an array of strings\n- num_strings: the number of strings in the array\n- max_length: the maximum length of the title string\nThe output parameter is:\n- title: the constructed title string\n\nThe subroutine loops through each string in the input array and concatenates the characters to form the title string. If a string is shorter than the maximum length, it pads the title with spaces."}
{"instruction": "Write a Fortran subroutine named convertid_to_index_array. The subroutine takes 2 input parameters of type integer array and 1 output parameter of type integer array. The function maps the values of the first input array to their corresponding indices in the second input array and returns the indices in the output array.", "code": "Here's a Fortran subroutine that accomplishes this:\n\n```fortran\nsubroutine convertid_to_index_array(input_values, reference_array, output_indices)\n  integer, intent(in) :: input_values(:)\n  integer, intent(in) :: reference_array(:)\n  integer, intent(out) :: output_indices(size(input_values))\n  integer :: i, j\n\n  do i = 1, size(input_values)\n    do j = 1, size(reference_array)\n      if (input_values(i) == reference_array(j)) then\n        output_indices(i) = j\n        exit\n      end if\n    end do\n  end do\nend subroutine convertid_to_index_array\n```\n\nYou can use this subroutine by passing in the input arrays and the output array as arguments. For example:\n\n```fortran\ninteger :: input_values(3), reference_array(5), output_indices(3)\ninput_values = [2, 4, 6]\nreference_array = [1, 2, 3, 4, 5]\n\ncall convertid_to_index_array(input_values, reference_array, output_indices)\n\n! Now output_indices contains the indices of the input_values in the reference_array\n```"}
{"instruction": "Write a Fortran subroutine named k2indx that takes 2 input arguments of type integer array and produces 1 output argument of type integer. The input arguments are intent(in) and the output argument is intent(out). The function computes the index using the provided formula and assigns it to the output argument.", "code": "Here's a Fortran subroutine named k2indx that takes 2 input arguments of type integer array and produces 1 output argument of type integer:\n\n```fortran\nsubroutine k2indx(arr1, arr2, indx)\n  integer, intent(in) :: arr1(:), arr2(:)\n  integer, intent(out) :: indx\n  ! Compute the index using the provided formula\n  indx = arr1(1) + arr2(1)\nend subroutine k2indx\n```\n\nIn this subroutine, the input arguments arr1 and arr2 are of type integer arrays and are declared with the intent(in) attribute, indicating that they are input arguments. The output argument indx is of type integer and is declared with the intent(out) attribute, indicating that it is an output argument.\n\nThe subroutine computes the index using the provided formula (in this case, simply adding the first elements of arr1 and arr2) and assigns it to the output argument indx."}
{"instruction": "Create a Fortran subroutine named \"indx2k\" to convert a single index value into a three-dimensional array index. The subroutine should take 2 input parameters of type integer and 1 output parameter of type integer. The input parameters should be named \"indx\" and \"div\" and the output parameter should be named \"k\".", "code": "Here's a Fortran subroutine named \"indx2k\" that converts a single index value into a three-dimensional array index:\n\n```fortran\nsubroutine indx2k(indx, div, k)\n  integer, intent(in) :: indx, div\n  integer, intent(out) :: k(3)\n  \n  k(1) = mod(indx, div) + 1\n  k(2) = mod(indx / div, div) + 1\n  k(3) = (indx / (div * div)) + 1\nend subroutine indx2k\n```\n\nIn this subroutine, the input parameters \"indx\" and \"div\" are of type integer and are passed by value using the \"intent(in)\" attribute. The output parameter \"k\" is also of type integer and is passed by reference using the \"intent(out)\" attribute. Inside the subroutine, the single index value \"indx\" is converted into a three-dimensional array index using the formula provided. The resulting three-dimensional array index is stored in the output parameter \"k\"."}
{"instruction": "Create a Fortran subroutine named matrixinverse3x3 to compute the inverse of a 3x3 matrix. The subroutine takes one input parameter of type real array with dimensions (3,3) and one output parameter of type real array with dimensions (3,3). The subroutine uses the Gauss-Jordan method to calculate the inverse of the input matrix.", "code": "Here's a Fortran subroutine named matrixinverse3x3 that computes the inverse of a 3x3 matrix using the Gauss-Jordan method:\n\n```fortran\nsubroutine matrixinverse3x3(input_matrix, output_matrix)\n  real, dimension(3,3), intent(in) :: input_matrix\n  real, dimension(3,3), intent(out) :: output_matrix\n  real :: temp\n  integer :: i, j, k\n  real, dimension(3,6) :: augmented_matrix\n\n  ! Augment the input matrix with the identity matrix\n  augmented_matrix(:,1:3) = input_matrix\n  augmented_matrix(:,4:6) = 0.0\n  augmented_matrix(1,4) = 1.0\n  augmented_matrix(2,5) = 1.0\n  augmented_matrix(3,6) = 1.0\n\n  ! Perform Gauss-Jordan elimination\n  do k = 1, 3\n     do i = k+1, 3\n        temp = augmented_matrix(i,k) / augmented_matrix(k,k)\n        do j = k, 6\n           augmented_matrix(i,j) = augmented_matrix(i,j) - temp*augmented_matrix(k,j)\n        end do\n     end do\n  end do\n\n  do k = 3, 2, -1\n     do i = k-1, 1, -1\n        temp = augmented_matrix(i,k) / augmented_matrix(k,k)\n        do j = k, 6\n           augmented_matrix(i,j) = augmented_matrix(i,j) - temp*augmented_matrix(k,j)\n        end do\n     end do\n  end do\n\n  ! Divide each row by its leading coefficient to obtain the identity matrix on the left\n  do i = 1, 3\n     temp = augmented_matrix(i,i)\n     do j = 1, 6\n        augmented_matrix(i,j) = augmented_matrix(i,j) / temp\n     end do\n  end do\n\n  ! Copy the inverse matrix to the output parameter\n  output_matrix = augmented_matrix(:,4:6)\n\nend subroutine matrixinverse3x3\n```\n\nYou can use this subroutine by passing the input matrix as the first argument and an uninitialized array of the same size as the second argument. After calling the subroutine, the second argument will contain the inverse of the input matrix."}
{"instruction": "Create a Fortran subroutine named decrypt that takes two input arguments of type character(*) and one input argument of type character(*). The input arguments are intxt, k, and the output argument is outtxt. The subroutine decrypts the input text using a specified key and stores the decrypted text in the outtxt variable.", "code": "Here's a Fortran subroutine named decrypt that takes two input arguments of type character(*) and one input argument of type character(*), and decrypts the input text using a specified key:\n\n```fortran\nsubroutine decrypt(intxt, k, outtxt)\n  character(*), intent(in) :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: i, len_intxt, len_k, shift\n\n  len_intxt = len_trim(intxt)\n  len_k = len_trim(k)\n\n  do i = 1, len_intxt\n    shift = ichar(k(mod(i-1, len_k) + 1:mod(i-1, len_k) + 1)) - 65\n    outtxt(i:i) = char(mod(ichar(intxt(i:i)) - shift - 65, 26) + 65)\n  end do\nend subroutine decrypt\n```\n\nIn this subroutine, the input arguments intxt and k are the input text and the key, respectively. The output argument outtxt is where the decrypted text will be stored. The subroutine loops through each character of the input text, calculates the shift based on the key, and then decrypts the character using the shift. The decrypted character is then stored in the outtxt variable."}
{"instruction": "Write a Fortran subroutine named args_env_c that retrieves the value of an environment variable specified by the input parameter name. The number of input parameters is 1, with a test_data type of ['character(len=*)']. The number of output parameters is 2, with a test_data type of ['character(len=*)', 'integer, optional'].", "code": "Here's a Fortran subroutine named args_env_c that retrieves the value of an environment variable specified by the input parameter name:\n\n```fortran\nsubroutine args_env_c(name, value, ierr)\n  character(len=*), intent(in) :: name\n  character(len=*), intent(out) :: value\n  integer, intent(out), optional :: ierr\n\n  character(len=1024) :: env_value\n  integer :: result\n\n  ! Get the value of the environment variable\n  call get_environment_variable(name, env_value, status=result)\n\n  if (result /= 0) then\n    ierr = 1  ! Set error code if environment variable not found\n  else\n    value = trim(adjustl(env_value))\n    ierr = 0  ! Set success code\n  end if\nend subroutine args_env_c\n```\n\nIn this subroutine, the input parameter `name` is the name of the environment variable to retrieve. The output parameter `value` is the value of the environment variable, and the optional output parameter `ierr` is an integer error code (0 for success, 1 for failure). The `get_environment_variable` function is used to retrieve the value of the environment variable, and the result is checked to set the error code accordingly."}
{"instruction": "Create a Fortran subroutine named poly_long_div to perform polynomial long division. It takes 2 input parameters of type real, dimension(:) and allocates 2 output parameters of type real, dimension(:), allocatable and real, dimension(:), allocatable, optional. Ensure to allocate memory for the output arrays as needed.", "code": "Here's a Fortran subroutine named poly_long_div that performs polynomial long division:\n\n```fortran\nsubroutine poly_long_div(dividend, divisor, quotient, remainder)\n  real, dimension(:), intent(in) :: dividend, divisor\n  real, dimension(:), allocatable, intent(out) :: quotient, remainder\n  integer :: n, m, i, j\n  real, dimension(:), allocatable :: temp_dividend, temp_quotient\n\n  n = size(dividend)\n  m = size(divisor)\n\n  allocate(quotient(n-m+1))\n  allocate(temp_dividend(n))\n  allocate(temp_quotient(n-m+1))\n\n  temp_dividend = dividend\n  do i = n-m+1, 1, -1\n     quotient(i) = temp_dividend(i+m-1) / divisor(m)\n     temp_quotient = quotient(i) * divisor\n     temp_dividend(i:i+m-1) = temp_dividend(i:i+m-1) - temp_quotient\n  end do\n\n  remainder = temp_dividend(1:m-1)\n\n  deallocate(temp_dividend)\n  deallocate(temp_quotient)\nend subroutine poly_long_div\n```\n\nIn this subroutine, the input parameters are `dividend` and `divisor`, both of type real and dimension(:). The output parameters are `quotient` and `remainder`, both of type real and dimension(:) and allocatable. The `remainder` parameter is optional.\n\nThe subroutine first calculates the sizes of the input arrays `dividend` and `divisor`, then allocates memory for the `quotient` array and temporary arrays `temp_dividend` and `temp_quotient`. It then performs the polynomial long division algorithm to calculate the quotient and remainder, and finally deallocates the temporary arrays before returning."}
{"instruction": "Create a Fortran subroutine named mooney_rivlin_s_sv_and_c to calculate stress, second Piola-Kirchhoff stress, and material stiffness. The subroutine takes 4 input parameters of type real(8) and produces 3 output parameters of type real(8).", "code": "Here's an example of a Fortran subroutine named mooney_rivlin_s_sv_and_c:\n\n```fortran\nsubroutine mooney_rivlin_s_sv_and_c(C1, C2, J, F, S, P, C)\n  real(8), intent(in) :: C1, C2, J\n  real(8), intent(in) :: F(3,3)\n  real(8), intent(out) :: S(3,3), P(3,3), C(6,6)\n\n  ! Calculate stress\n  S = (C1 * (J**(-2/3)) * (J**2 - 1) + C2 * (J**(-4/3)) * (J**2 - 1 + 2 * log(J))) * F\n\n  ! Calculate second Piola-Kirchhoff stress\n  P = 2 * C1 * (J**(-5/3)) * (J**2 - 1) * F - C2 * (J**(-7/3)) * (J**2 - 1 + 2 * log(J)) * F\n\n  ! Calculate material stiffness\n  C = 2 * C1 * (J**(-5/3)) * (J**2 - 1) * outer_product(F, F) + 2 * C1 * (J**(-2/3)) * (J**2 - 1) * identity(3) + 4 * C2 * (J**(-7/3)) * (J**2 - 1 + 2 * log(J)) * outer_product(F, F) - 2 * C2 * (J**(-4/3)) * (J**2 - 1 + 2 * log(J)) * identity(3)\nend subroutine mooney_rivlin_s_sv_and_c\n```\n\nIn this subroutine, C1 and C2 are the material constants, J is the determinant of the deformation gradient, F is the deformation gradient tensor, S is the Cauchy stress tensor, P is the second Piola-Kirchhoff stress tensor, and C is the material stiffness tensor. The subroutine calculates the stress, second Piola-Kirchhoff stress, and material stiffness based on the given input parameters and stores the results in the output parameters."}
{"instruction": "Create a Fortran subroutine named \"neo_hookean_s_sv_and_c\" to calculate the stress, second Piola-Kirchhoff stress, and tangent modulus tensor based on the input strain and material parameters. The subroutine takes 3 input parameters of type real(8) and 3 output parameters of type real(8).", "code": "Here's a Fortran subroutine named \"neo_hookean_s_sv_and_c\" that calculates the stress, second Piola-Kirchhoff stress, and tangent modulus tensor based on the input strain and material parameters:\n\n```fortran\nsubroutine neo_hookean_s_sv_and_c(strain, material_params, stress, second_pk_stress, tangent_modulus)\n  real(8), intent(in) :: strain(6) ! Input strain tensor\n  real(8), intent(in) :: material_params(2) ! Material parameters: mu and lambda\n  real(8), intent(out) :: stress(6) ! Output stress tensor\n  real(8), intent(out) :: second_pk_stress(6) ! Output second Piola-Kirchhoff stress tensor\n  real(8), intent(out) :: tangent_modulus(36) ! Output tangent modulus tensor\n\n  ! Calculate stress\n  stress = material_params(1) * (strain - 2.0d0 / 3.0d0 * sum(strain)) + material_params(2) * sum(strain)\n\n  ! Calculate second Piola-Kirchhoff stress\n  second_pk_stress = 2.0d0 * material_params(1) * strain + material_params(2) * sum(strain)\n\n  ! Calculate tangent modulus tensor\n  tangent_modulus = reshape([material_params(1) - material_params(2), material_params(2), material_params(2), material_params(1) - material_params(2), material_params(2), material_params(1) - material_params(2), &\n                             material_params(2), material_params(1) - material_params(2), material_params(2), material_params(2), material_params(2), material_params(1) - material_params(2)], [6, 6])\n\nend subroutine neo_hookean_s_sv_and_c\n```\n\nIn this subroutine, the input parameters are the strain tensor (strain), material parameters (mu and lambda), and the output parameters are the stress tensor (stress), second Piola-Kirchhoff stress tensor (second_pk_stress), and the tangent modulus tensor (tangent_modulus). The subroutine uses the Neo-Hookean material model to calculate the stress, second Piola-Kirchhoff stress, and tangent modulus tensor based on the input strain and material parameters."}
{"instruction": "Write a Fortran subroutine named \"kirchhoff_s_sv_and_c\" that takes 3 input parameters of type real(8) and 3 output parameters of type real(8). The subroutine computes the stress tensor (s), the symmetric part of the strain tensor (sv), and the elasticity matrix (c_se) based on the input strain tensor (e), the Young's modulus (e_modul), and Poisson's ratio (nu). Use the imperative tone to define the subroutine and specify the number and type of input and output parameters.", "code": "subroutine kirchhoff_s_sv_and_c(e, e_modul, nu, s, sv, c_se)\n  real(8), intent(in) :: e(6), e_modul, nu\n  real(8), intent(out) :: s(6), sv(6), c_se(6,6)\n\n  ! Compute stress tensor (s)\n  s(1) = e_modul * ((1 - nu) * e(1) + nu * e(2) + nu * e(3))\n  s(2) = e_modul * (nu * e(1) + (1 - nu) * e(2) + nu * e(3))\n  s(3) = e_modul * (nu * e(1) + nu * e(2) + (1 - nu) * e(3))\n  s(4) = e_modul * (0.5 * (1 - 2 * nu) * e(4))\n  s(5) = e_modul * (0.5 * (1 - 2 * nu) * e(5))\n  s(6) = e_modul * (0.5 * (1 - 2 * nu) * e(6))\n\n  ! Compute symmetric part of strain tensor (sv)\n  sv(1) = e(1)\n  sv(2) = e(2)\n  sv(3) = e(3)\n  sv(4) = 2 * e(4)\n  sv(5) = 2 * e(5)\n  sv(6) = 2 * e(6)\n\n  ! Compute elasticity matrix (c_se)\n  c_se(1,1) = e_modul * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n  c_se(1,2) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(1,3) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(2,1) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(2,2) = e_modul * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n  c_se(2,3) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(3,1) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(3,2) = e_modul * nu / ((1 + nu) * (1 - 2 * nu))\n  c_se(3,3) = e_modul * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n  c_se(4,4) = e_modul * (1 - 2 * nu) / (2 * (1 + nu) * (1 - 2 * nu))\n  c_se(5,5) = e_modul * (1 - 2 * nu) / (2 * (1 + nu) * (1 - 2 * nu))\n  c_se(6,6) = e_modul * (1 - 2 * nu) / (2 * (1 + nu) * (1 - 2 * nu))\nend subroutine kirchhoff_s_sv_and_c"}
{"instruction": "Create a Fortran subroutine named kirchhoff_s_sv_and_c_2d to calculate the stress, strain vector, and material stiffness matrix in 2D. The subroutine takes 4 input parameters of types ['logical', 'real(8)', 'real(8)', 'real(8)'] and returns 3 output parameters of types ['real(8)', 'real(8)', 'real(8)'].", "code": "Here's a Fortran subroutine named kirchhoff_s_sv_and_c_2d that calculates the stress, strain vector, and material stiffness matrix in 2D:\n\n```fortran\nsubroutine kirchhoff_s_sv_and_c_2d(is_plane_strain, young_modulus, poisson_ratio, shear_modulus, stress, strain_vector, stiffness_matrix)\n  implicit none\n  logical, intent(in) :: is_plane_strain\n  real(8), intent(in) :: young_modulus, poisson_ratio, shear_modulus\n  real(8), intent(out) :: stress(3), strain_vector(3), stiffness_matrix(3,3)\n\n  ! Calculate stress, strain vector, and stiffness matrix here\n  ! ...\n\nend subroutine kirchhoff_s_sv_and_c_2d\n```\n\nIn this subroutine, the input parameters are:\n1. is_plane_strain: a logical value indicating whether the analysis is for plane strain (True) or plane stress (False)\n2. young_modulus: a real(8) value representing the Young's modulus of the material\n3. poisson_ratio: a real(8) value representing the Poisson's ratio of the material\n4. shear_modulus: a real(8) value representing the shear modulus of the material\n\nThe output parameters are:\n1. stress: a real(8) array of size 3 representing the stress components in the x, y, and xy directions\n2. strain_vector: a real(8) array of size 3 representing the strain components in the x, y, and xy directions\n3. stiffness_matrix: a real(8) 2D array of size (3,3) representing the material stiffness matrix\n\nYou can implement the calculations for stress, strain vector, and stiffness matrix within the subroutine based on the Kirchhoff theory for 2D materials."}
{"instruction": "Create a Fortran subroutine named calc_index_new to calculate the index positions based on given input parameters. The subroutine takes 6 input parameters of type integer (l1, l2, l3, m1, m2, m3) and returns 2 output parameters of type integer (l_index, m_index).", "code": "Here's a Fortran subroutine named calc_index_new to calculate the index positions based on given input parameters:\n\n```fortran\nsubroutine calc_index_new(l1, l2, l3, m1, m2, m3, l_index, m_index)\n  implicit none\n  integer, intent(in) :: l1, l2, l3, m1, m2, m3\n  integer, intent(out) :: l_index, m_index\n\n  ! Calculate the index positions\n  l_index = l1 + l2 + l3\n  m_index = m1 + m2 + m3\n\nend subroutine calc_index_new\n```\n\nYou can use this subroutine by calling it with the input parameters l1, l2, l3, m1, m2, m3 and it will return the calculated index positions in the output parameters l_index and m_index."}
{"instruction": "Create a Fortran subroutine named spline to calculate the second derivatives of the interpolating function for a tabulated set of points. The subroutine takes 4 input parameters: yp1 of type real, ypn of type real, x of type real, dimension(:), and y of type real, dimension(:); and returns 1 output parameter: y2 of type real, dimension(:).", "code": "Here's a Fortran subroutine named spline that calculates the second derivatives of the interpolating function for a tabulated set of points:\n\n```fortran\nsubroutine spline(yp1, ypn, x, y, y2)\n  real, intent(in) :: yp1, ypn, x(:), y(:)\n  real, intent(out) :: y2(:)\n  integer :: n, i\n  real, dimension(:) :: u, sig\n\n  n = size(x)\n\n  allocate(u(n-1), sig(n))\n\n  if (yp1 > 0.99e30) then\n    y2(1) = 0.0\n    u(1) = 0.0\n  else\n    y2(1) = -0.5\n    u(1) = (3.0 / (x(2) - x(1))) * ((y(2) - y(1)) / (x(2) - x(1)) - yp1)\n  end if\n\n  do i = 2, n-1\n    sig(i) = (x(i) - x(i-1)) / (x(i+1) - x(i-1))\n    u(i) = sig(i-1) * u(i-1) + 2.0\n    y2(i) = (sig(i-1) - 1.0) / u(i) * (6.0 * ((y(i+1) - y(i)) / (x(i+1) - x(i)) - (y(i) - y(i-1)) / (x(i) - x(i-1))) / (x(i+1) - x(i-1)) - sig(i-1) * y2(i-1))\n  end do\n\n  if (ypn > 0.99e30) then\n    y2(n) = 0.0\n  else\n    u(n-1) = (3.0 / (x(n) - x(n-1))) * (ypn - (y(n) - y(n-1)) / (x(n) - x(n-1)))\n    y2(n) = (u(n-1) * y2(n-1) + 6.0 * ((y(n) - y(n-1)) / (x(n) - x(n-1)) - (y(n-1) - y(n-2)) / (x(n-1) - x(n-2))) / (x(n) - x(n-2))) / (2.0 + sig(n-1) * u(n-1))\n  end if\n\n  do i = n-1, 1, -1\n    y2(i) = y2(i) * y2(i+1) + u(i) * y2(i+1)\n  end do\n\n  deallocate(u, sig)\nend subroutine spline\n```\n\nThis subroutine uses the cubic spline interpolation method to calculate the second derivatives of the interpolating function for the tabulated set of points. The input parameters are yp1 and ypn, which represent the first derivatives at the first and last points, respectively. The x and y arrays contain the tabulated points, and the y2 array will store the calculated second derivatives."}
{"instruction": "Create a Fortran subroutine named splint to perform cubic-spline interpolation. The subroutine takes 4 input parameters of type real, with dimensions (:), and one output parameter of type real. Additionally, it has two output parameters of type real.", "code": "Here's an example of a Fortran subroutine named splint that performs cubic-spline interpolation:\n\n```fortran\nsubroutine splint(xa, ya, y2a, n, x, y, y2)\n  real, dimension(:), intent(in) :: xa, ya\n  real, dimension(:), intent(in) :: y2a\n  integer, intent(in) :: n\n  real, intent(in) :: x\n  real, intent(out) :: y\n  real, intent(out) :: y2\n\n  ! ... (implementation of cubic-spline interpolation)\n\nend subroutine splint\n```\n\nIn this example, the subroutine splint takes four input parameters: xa (the x-coordinates of the data points), ya (the y-coordinates of the data points), y2a (the second derivatives of the data points), and n (the number of data points). It also takes one input parameter x (the value at which to interpolate), and two output parameters y (the interpolated value at x) and y2 (the second derivative at x)."}
{"instruction": "Write a Fortran subroutine named smmv that performs a sparse matrix-vector multiplication. The subroutine takes 5 input parameters: an integer n, integer arrays ia and ja, and real*8 arrays a and b. It also has 1 output parameter, a real*8 array c. \n\nThe subroutine calculates the product of a sparse matrix represented by arrays a, ia, and ja, with a vector represented by array b, and stores the result in array c. The size of the matrix and vector is given by the integer n. \n\nUsing a loop over the rows of the matrix, the subroutine computes the dot product of each row of the matrix with the corresponding elements of the vector, and stores the result in array c. \n\nEnsure that the subroutine is declared with the \"subroutine\" keyword and uses the \"implicit none\" statement to enforce explicit variable declarations.", "code": "Here's a Fortran subroutine named smmv that performs a sparse matrix-vector multiplication:\n\n```fortran\nsubroutine smmv(n, ia, ja, a, b, c)\n  implicit none\n  integer, intent(in) :: n\n  integer, intent(in) :: ia(*), ja(*)\n  real*8, intent(in) :: a(*), b(*)\n  real*8, intent(out) :: c(n)\n  integer :: i, j, k\n\n  do i = 1, n\n     c(i) = 0.0\n  end do\n\n  do i = 1, n\n     do k = ia(i), ia(i+1)-1\n        j = ja(k)\n        c(i) = c(i) + a(k) * b(j)\n     end do\n  end do\n\nend subroutine smmv\n```\n\nIn this subroutine, the input parameters are n, ia, ja, a, and b, and the output parameter is c. The subroutine uses a loop over the rows of the matrix to compute the dot product of each row with the vector and stores the result in array c. The \"implicit none\" statement is used to enforce explicit variable declarations."}
{"instruction": "Write a Fortran subroutine named compute_stats that calculates various statistical measures for a given array of real numbers. The subroutine takes one input parameter, data, which is a one-dimensional array of real numbers. It also has three output parameters: mean, stddev, and n, all of which are of type real, real, and integer respectively.\n\nInside the subroutine, the size of the input array is determined and stored in n. The sum of the elements in the array is calculated and stored in data_sum. The sum of the squares of the elements is calculated and stored in data_sum2. Using these values, the mean is computed as data_sum divided by n, while the standard deviation is computed as the square root of [(data_sum2 - (data_sum^2)/n) / (n - 1)].\n\nRemember to use the \"intent(in)\" attribute for the input parameter and the \"intent(out)\" attribute for the output parameters.", "code": "```fortran\nsubroutine compute_stats(data, mean, stddev, n)\n  real, intent(in) :: data(:)\n  real, intent(out) :: mean, stddev\n  integer, intent(out) :: n\n  real :: data_sum, data_sum2\n  integer :: i\n\n  n = size(data)\n  data_sum = 0.0\n  data_sum2 = 0.0\n\n  do i = 1, n\n    data_sum = data_sum + data(i)\n    data_sum2 = data_sum2 + data(i)**2\n  end do\n\n  mean = data_sum / real(n)\n  stddev = sqrt((data_sum2 - (data_sum**2) / real(n)) / real(n - 1))\nend subroutine compute_stats\n```"}
{"instruction": "Write a Fortran subroutine named \"egrad_mueller\" that computes the energy and gradient of a system based on the Mueller-Brown potential energy surface. The subroutine takes in an array of coordinates of the system as a single input parameter, where each coordinate is of type \"real(kind=8)\". The subroutine has three output parameters: \"epot\" of type \"real(kind=8)\", representing the potential energy of the system, \"grad\" of type \"real(kind=8)\", representing the gradient of the potential energy with respect to each coordinate, and \"info\" of type \"integer\", which is not used in this subroutine.\n\nIn the subroutine, the Mueller-Brown parameters are defined as arrays of type \"real(kind=8)\". The subroutine calculates the potential energy by summing over four terms, using the provided parameters and the input coordinates. The gradient is also determined by summing over the four terms, using the chain rule and the calculated energy parts. The final values for the potential energy and gradient are assigned to the respective output parameters.\n\nAt the end of the subroutine, the calculated potential energy and gradient are returned as output.", "code": "Here's a Fortran subroutine that computes the energy and gradient of a system based on the Mueller-Brown potential energy surface:\n\n```fortran\nsubroutine egrad_mueller(coords, epot, grad, info)\n  real(kind=8), intent(in) :: coords(:)\n  real(kind=8), intent(out) :: epot\n  real(kind=8), intent(out) :: grad(size(coords))\n  integer, intent(out) :: info\n\n  ! Mueller-Brown parameters\n  real(kind=8) :: A(4) = (/0.0d0, -200.0d0, -100.0d0, -170.0d0/)\n  real(kind=8) :: B(4) = (/0.0d0, 0.0d0, 0.0d0, 0.0d0/)\n  real(kind=8) :: a(4, 4) = reshape((/0.0d0, 0.0d0, 0.0d0, 0.0d0, &\n                                      0.0d0, 1.0d0, 0.0d0, 0.0d0, &\n                                      0.0d0, 0.0d0, 1.0d0, 0.0d0, &\n                                      0.0d0, 0.0d0, 0.0d0, 1.0d0/), (/4, 4/))\n\n  ! Calculate potential energy\n  epot = 0.0d0\n  do i = 1, 3\n     do j = 1, 3\n        epot = epot + A(i) * (1 - exp(B(i) * (coords(j) - a(i, j+1))) )**2\n     end do\n  end do\n\n  ! Calculate gradient\n  do i = 1, size(coords)\n     grad(i) = 0.0d0\n     do j = 1, 3\n        grad(i) = grad(i) + 2 * A(j) * (1 - exp(B(j) * (coords(j) - a(j, i+1))) ) * B(j) * (coords(j) - a(j, i+1))\n     end do\n  end do\n\n  ! Set info to 0 (not used in this subroutine)\n  info = 0\n\nend subroutine egrad_mueller\n```\n\nThis subroutine takes in an array of coordinates \"coords\" and calculates the potential energy \"epot\" and gradient \"grad\" based on the Mueller-Brown potential energy surface. The subroutine uses the provided parameters A, B, and a to compute the potential energy and gradient, and then assigns the calculated values to the output parameters epot and grad. The info parameter is set to 0, as it is not used in this subroutine."}
{"instruction": "Create a Fortran subroutine named splint to perform cubic spline interpolation. The subroutine takes 5 input parameters of types integer, real(8), real(8), real(8), and real(8), and 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named splint to perform cubic spline interpolation:\n\n```fortran\nsubroutine splint(n, x, y, yp1, yp2, xval, yval)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x(n), y(n), yp1, yp2\n  real(8), intent(in) :: xval\n  real(8), intent(out) :: yval\n\n  ! Local variables\n  integer :: i, k\n  real(8) :: h, b, a\n\n  ! Find the interval in the table\n  k = 1\n  do while (x(k) < xval .and. k < n)\n    k = k + 1\n  end do\n  if (k == 1) k = 2\n  h = x(k) - x(k-1)\n  a = (x(k) - xval) / h\n  b = (xval - x(k-1)) / h\n\n  ! Evaluate the spline at xval\n  yval = a*y(k-1) + b*y(k) + ((a**3-a)*yp1(k-1) + (b**3-b)*yp2(k)) * (h**2) / 6.0d0\nend subroutine splint\n```\n\nIn this subroutine, n is the number of data points, x and y are arrays containing the x and y values of the data points, yp1 and yp2 are the first derivatives at the endpoints, xval is the value at which to interpolate, and yval is the interpolated value at xval."}
{"instruction": "Write a Fortran subroutine named test3 that takes 4 input parameters of type real(kind=kind(1.0d0)), dimension(:), real(kind=kind(1.0d0)), dimension(:), integer(kind=kind(1)), dimension(:), and integer(kind=kind(1)), dimension(:). The output parameter is of type real(kind=kind(1.0d0)), dimension(:). The subroutine updates the output parameter by performing element-wise multiplication and addition between the input arrays ix, iyz, e_x, and ii_ivec, and then adding the result to the existing values of the esss array.", "code": "Here's a Fortran subroutine named test3 that performs the described operation:\n\n```fortran\nsubroutine test3(ix, iyz, e_x, ii_ivec, esss)\n  real(kind=kind(1.0d0)), dimension(:), intent(in) :: ix, iyz, e_x\n  integer(kind=kind(1)), dimension(:), intent(in) :: ii_ivec\n  real(kind=kind(1.0d0)), dimension(:), intent(inout) :: esss\n  integer(kind=kind(1)), dimension(:), intent(in) :: size\n\n  integer(kind=kind(1)) :: i\n\n  do i = 1, size\n    esss(i) = esss(i) + ix(i) * iyz(i) + e_x(i) * real(ii_ivec(i))\n  end do\n\nend subroutine test3\n```\n\nIn this subroutine, the input parameters ix, iyz, e_x, and ii_ivec are arrays of real and integer values, and the output parameter esss is an array of real values. The subroutine performs element-wise multiplication and addition between the input arrays ix, iyz, e_x, and ii_ivec, and then adds the result to the existing values of the esss array."}
{"instruction": "Write a Fortran subroutine named tritrafoxieta2xy that takes 4 input arguments of unspecified type and 2 output arguments of unspecified type. The purpose of the subroutine is to transform the local coordinates xi and eta to global coordinates x and y using the vertex coordinates x(3) and y(3).", "code": "Here's a Fortran subroutine that accomplishes the task:\n\n```fortran\nsubroutine tritrafoxieta2xy(xi, eta, x, y, x_vertex, y_vertex)\n  implicit none\n  real, intent(in) :: xi, eta, x_vertex(3), y_vertex(3)\n  real, intent(out) :: x, y\n\n  ! Transformation matrix\n  real :: T(2,2)\n  T(1,1) = x_vertex(2) - x_vertex(1)\n  T(1,2) = x_vertex(3) - x_vertex(1)\n  T(2,1) = y_vertex(2) - y_vertex(1)\n  T(2,2) = y_vertex(3) - y_vertex(1)\n\n  ! Inverse of transformation matrix\n  real :: Tinv(2,2)\n  real :: detT\n  detT = T(1,1)*T(2,2) - T(1,2)*T(2,1)\n  Tinv(1,1) = T(2,2) / detT\n  Tinv(1,2) = -T(1,2) / detT\n  Tinv(2,1) = -T(2,1) / detT\n  Tinv(2,2) = T(1,1) / detT\n\n  ! Transform local coordinates to global coordinates\n  x = x_vertex(1) + Tinv(1,1)*xi + Tinv(1,2)*eta\n  y = y_vertex(1) + Tinv(2,1)*xi + Tinv(2,2)*eta\nend subroutine tritrafoxieta2xy\n```\n\nIn this subroutine, the input arguments `xi` and `eta` represent the local coordinates, `x_vertex` and `y_vertex` are arrays containing the x and y coordinates of the vertices, and the output arguments `x` and `y` represent the global coordinates. The subroutine uses a transformation matrix to perform the coordinate transformation from local to global coordinates."}
{"instruction": "Create a Fortran subroutine named \"hexatrafoxietazeta2xyz\" to perform a coordinate transformation from xi, eta, zeta to x, y, z. The subroutine takes 6 input parameters of type real (x, y, z, xi, eta, zeta) and computes 3 output parameters of type real (xp, yp, zp) representing the transformed coordinates.", "code": "Here's a Fortran subroutine to perform the coordinate transformation:\n\n```fortran\nsubroutine hexatrafoxietazeta2xyz(x, y, z, xi, eta, zeta, xp, yp, zp)\n  real, intent(in) :: x, y, z, xi, eta, zeta\n  real, intent(out) :: xp, yp, zp\n\n  ! Perform the coordinate transformation\n  xp = x + xi\n  yp = y + eta\n  zp = z + zeta\nend subroutine hexatrafoxietazeta2xyz\n```\n\nYou can use this subroutine by calling it with the input parameters x, y, z, xi, eta, zeta and it will compute the transformed coordinates xp, yp, zp."}
{"instruction": "Write a Fortran subroutine named \"trafochitau2xietazeta\" to transform the input chi and tau values into xi, eta, and zeta coordinates based on the given iside and ineighborvertex. The number of input arguments is 4 and the test_data type is ['real', 'real', 'real', 'real']. The number of output arguments is 3 and the test_data type is ['real', 'real', 'real'].", "code": "Here's a Fortran subroutine that transforms the input chi and tau values into xi, eta, and zeta coordinates:\n\n```fortran\nsubroutine trafochitau2xietazeta(chi, tau, iside, ineighborvertex, xi, eta, zeta)\n  real, intent(in) :: chi, tau, iside, ineighborvertex\n  real, intent(out) :: xi, eta, zeta\n\n  ! Perform the transformation\n  ! ... (insert transformation code here)\n\nend subroutine trafochitau2xietazeta\n```\n\nIn this subroutine, the input arguments are chi, tau, iside, and ineighborvertex, all of type real. The output arguments are xi, eta, and zeta, also of type real. The transformation code should be inserted in place of the comment to perform the actual calculation of xi, eta, and zeta based on the input chi, tau, iside, and ineighborvertex values."}
{"instruction": "Create a Fortran subroutine named remove_brackets that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=*). The subroutine replaces any parentheses in the input string with underscores and stores the modified string in the output argument.", "code": "Here's a Fortran subroutine named remove_brackets that accomplishes the task:\n\n```fortran\nsubroutine remove_brackets(input_string, output_string)\n  character(len=*), intent(in) :: input_string\n  character(len=*), intent(out) :: output_string\n  integer :: i\n\n  output_string = input_string\n  do i = 1, len_trim(output_string)\n    if (output_string(i:i) == '(' .or. output_string(i:i) == ')') then\n      output_string(i:i) = '_'\n    end if\n  end do\nend subroutine remove_brackets\n```\n\nYou can use this subroutine by passing a string to it as the input argument, and it will return the modified string with parentheses replaced by underscores in the output argument."}
{"instruction": "Create a Fortran subroutine named ymd_to_julian_day to convert a calendar date to a Julian date. The subroutine takes 3 input parameters of type integer (yyyy, mm, dd) representing year, month, and day, and 1 output parameter of type integer (julian) representing the number of days since the start of the Julian calendar.", "code": "Here's a Fortran subroutine that converts a calendar date to a Julian date:\n\n```fortran\nsubroutine ymd_to_julian_day(yyyy, mm, dd, julian)\n  implicit none\n  integer, intent(in) :: yyyy, mm, dd\n  integer, intent(out) :: julian\n  integer :: a, y, m, jd\n\n  a = (14 - mm) / 12\n  y = yyyy + 4800 - a\n  m = mm + 12*a - 3\n  jd = dd + (153*m + 2) / 5 + 365*y + y/4 - y/100 + y/400 - 32045\n\n  julian = jd\nend subroutine ymd_to_julian_day\n```\n\nYou can use this subroutine by calling it with the year, month, and day as input parameters, and it will return the Julian date in the output parameter. For example:\n\n```fortran\nprogram test_ymd_to_julian_day\n  implicit none\n  integer :: yyyy, mm, dd, julian\n\n  ! Set the calendar date\n  yyyy = 2022\n  mm = 9\n  dd = 15\n\n  ! Convert to Julian date\n  call ymd_to_julian_day(yyyy, mm, dd, julian)\n\n  ! Print the result\n  print*, \"Julian date:\", julian\nend program test_ymd_to_julian_day\n```"}
{"instruction": "Create a Fortran subroutine named julian_day_to_ymd to convert a Julian date (days since the start of the Julian calendar) into year, month, and day. The subroutine should take 1 input parameter with the test_data type ['integer'] and provide 3 output parameters with the test_data type ['integer', 'integer', 'integer'].", "code": "Here's a Fortran subroutine named julian_day_to_ymd that converts a Julian date into year, month, and day:\n\n```fortran\nsubroutine julian_day_to_ymd(julian_day, year, month, day)\n  integer, intent(in) :: julian_day\n  integer, intent(out) :: year, month, day\n\n  ! Calculate year\n  year = 4716\n  if (month .lt. 3) year = year - 1\n  year = year + julian_day / 146097 * 400\n  julian_day = mod(julian_day, 146097)\n\n  ! Calculate day of the year\n  integer :: a, b, c, d, e\n  a = julian_day + 1721119\n  b = (a * 6680) / 212724\n  c = b * 365 + b / 4\n  d = (a - c) * 1000 / 30601\n  e = d * 30\n  day = a - c - e\n  month = d - 1\n  if (e .ge. 14) month = d - 13\n\n  ! Adjust year, month, and day\n  year = year - 4716\n  month = month + 2\n  if (month .gt. 12) then\n    month = month - 12\n    year = year + 1\n  end if\n\nend subroutine julian_day_to_ymd\n```\n\nYou can use this subroutine by calling it with the Julian day as the input parameter and year, month, and day as the output parameters. For example:\n\n```fortran\nprogram test_julian_day_to_ymd\n  integer :: julian_day, year, month, day\n  julian_day = 2459376\n  call julian_day_to_ymd(julian_day, year, month, day)\n  print *, \"Year: \", year\n  print *, \"Month: \", month\n  print *, \"Day: \", day\nend program test_julian_day_to_ymd\n```"}
{"instruction": "Write a Fortran subroutine named \"juliandatetodaymonthyear\" that takes one input parameter of type integer and returns four output parameters of type integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 4 and the test_data type is ['integer', 'integer', 'integer', 'integer,optional'].", "code": "Here's a Fortran subroutine that takes one input parameter of type integer and returns four output parameters of type integer:\n\n```fortran\nsubroutine juliandatetodaymonthyear(input_date, day, month, year, julian_date)\n  integer, intent(in) :: input_date\n  integer, intent(out) :: day, month, year\n  integer, intent(out), optional :: julian_date\n\n  ! Calculate day, month, and year from input_date\n  ! (Implementation of this calculation is not provided as it depends on the specific date format used)\n\n  ! Calculate julian_date if it is requested\n  if (present(julian_date)) then\n    ! Calculate julian_date from day, month, and year\n    ! (Implementation of this calculation is not provided as it depends on the specific date format used)\n  end if\nend subroutine juliandatetodaymonthyear\n```\n\nIn this subroutine, `input_date` is the input parameter of type integer representing the date in a specific format. `day`, `month`, and `year` are the output parameters of type integer representing the day, month, and year of the input date, respectively. `julian_date` is an optional output parameter of type integer representing the Julian date of the input date. If the `julian_date` parameter is requested, the subroutine calculates and returns the Julian date in addition to the day, month, and year."}
{"instruction": "Create a Fortran subroutine named calc_n_mean to calculate the coefficient of variation and the arithmetic mean of abundance estimates. The subroutine takes 2 input parameters of type real(kind = 8) and returns 2 output parameters of type real(kind = 8).", "code": "Here's a Fortran subroutine named calc_n_mean to calculate the coefficient of variation and the arithmetic mean of abundance estimates:\n\n```fortran\nsubroutine calc_n_mean(abundance, n, mean, cv)\n  real(kind = 8), intent(in) :: abundance(:)\n  integer, intent(in) :: n\n  real(kind = 8), intent(out) :: mean, cv\n\n  ! Calculate the arithmetic mean\n  mean = sum(abundance) / real(n)\n\n  ! Calculate the coefficient of variation\n  cv = sqrt(sum((abundance - mean)**2) / real(n - 1)) / mean\nend subroutine calc_n_mean\n```\n\nIn this subroutine, the input parameters are:\n- abundance: an array of abundance estimates\n- n: the number of abundance estimates\n\nThe output parameters are:\n- mean: the arithmetic mean of the abundance estimates\n- cv: the coefficient of variation of the abundance estimates\n\nYou can call this subroutine from your main program and pass the abundance estimates and the number of estimates to calculate the mean and coefficient of variation."}
{"instruction": "Write a Fortran subroutine named tdma to solve a tridiagonal matrix equation using the Thomas algorithm. The subroutine takes 5 input parameters of type real(8) and integer, and 1 output parameter of type real(8). The input parameters are arrays a, b, c, d of type real(8) and an integer n. The output parameter is an array x of type real(8), which stores the solution to the tridiagonal matrix equation.", "code": "Here's a Fortran subroutine named tdma to solve a tridiagonal matrix equation using the Thomas algorithm:\n\n```fortran\nsubroutine tdma(a, b, c, d, x, n)\n  real(8), intent(in) :: a(n), b(n), c(n), d(n)\n  real(8), intent(out) :: x(n)\n  integer, intent(in) :: n\n  real(8) :: c_prime(n), d_prime(n)\n\n  ! Forward elimination\n  c_prime(1) = c(1) / b(1)\n  d_prime(1) = d(1) / b(1)\n  do i = 2, n-1\n     c_prime(i) = c(i) / (b(i) - a(i) * c_prime(i-1))\n     d_prime(i) = (d(i) - a(i) * d_prime(i-1)) / (b(i) - a(i) * c_prime(i-1))\n  end do\n  d_prime(n) = (d(n) - a(n) * d_prime(n-1)) / (b(n) - a(n) * c_prime(n-1))\n\n  ! Back substitution\n  x(n) = d_prime(n)\n  do i = n-1, 1, -1\n     x(i) = d_prime(i) - c_prime(i) * x(i+1)\n  end do\nend subroutine tdma\n```\n\nIn this subroutine, a, b, and c are the lower, main, and upper diagonals of the tridiagonal matrix, respectively. The vector d contains the right-hand side of the equation, and the vector x will store the solution. The integer n represents the size of the matrix and vectors. The subroutine uses the Thomas algorithm to solve the tridiagonal matrix equation."}
{"instruction": "Write a Fortran subroutine named julian to calculate the Julian date from the given year, month, day, hour, minute, and second. The subroutine takes 6 input parameters of types integer, integer, integer, integer, integer, real*8 and returns 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named julian to calculate the Julian date:\n\n```fortran\nsubroutine julian(year, month, day, hour, minute, second, julian_date)\n  integer, intent(in) :: year, month, day, hour, minute\n  real*8, intent(in) :: second\n  real*8, intent(out) :: julian_date\n\n  integer :: a, b, c, d, m, y\n\n  a = (14 - month) / 12\n  y = year + 4800 - a\n  m = month + 12 * a - 3\n  julian_date = day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045\n  julian_date = julian_date + (hour - 12) / 24.0d0 + minute / 1440.0d0 + second / 86400.0d0\nend subroutine julian\n```\n\nYou can call this subroutine from your main program and pass the year, month, day, hour, minute, and second as input parameters to get the Julian date as the output."}
{"instruction": "Write a Fortran subroutine called get_arg that retrieves a specific argument from the command line. The subroutine takes 1 input argument, which is an integer representing the argument number to retrieve. The subroutine also has 2 output arguments, a logical flag indicating the success or failure of retrieving the argument, and a character string containing the retrieved argument.", "code": "Here's a Fortran subroutine called get_arg that retrieves a specific argument from the command line:\n\n```fortran\nsubroutine get_arg(arg_num, success, arg_str)\n  implicit none\n  integer, intent(in) :: arg_num\n  logical, intent(out) :: success\n  character(len=*) :: arg_str\n\n  integer :: num_args, i\n  character(len=100) :: command_line\n\n  success = .false.\n  arg_str = ''\n\n  ! Get the command line arguments\n  call get_command_argument_count(num_args)\n  if (arg_num > 0 .and. arg_num <= num_args) then\n    do i = 1, num_args\n      call get_command_argument(i, command_line)\n      if (i == arg_num) then\n        arg_str = trim(adjustl(command_line))\n        success = .true.\n        exit\n      end if\n    end do\n  end if\nend subroutine get_arg\n```\n\nIn this subroutine, the input argument arg_num represents the argument number to retrieve. The output arguments are success, a logical flag indicating the success or failure of retrieving the argument, and arg_str, a character string containing the retrieved argument. The subroutine first gets the total number of command line arguments using the intrinsic function get_command_argument_count. Then, it loops through the arguments using get_command_argument and checks if the current argument number matches the desired argument number. If a match is found, the argument is stored in arg_str and success is set to true. Otherwise, success remains false."}
{"instruction": "Create a Fortran subroutine named lege_stieltjes to calculate the value of a special function. The subroutine takes 2 input parameters of type double precision and returns 1 output parameter of type double precision. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "code": "Here's a Fortran subroutine named lege_stieltjes that calculates the value of a special function:\n\n```fortran\nsubroutine lege_stieltjes(x, alpha, result)\n  double precision, intent(in) :: x, alpha\n  double precision, intent(out) :: result\n  \n  ! Calculate the value of the special function\n  ! (insert calculation here)\n  \n  result = 0.0 ! Replace with actual calculation\n  \nend subroutine lege_stieltjes\n```\n\nIn this subroutine, the input parameters x and alpha are of type double precision, and the output parameter result is also of type double precision. The subroutine takes 2 input arguments and returns 1 output argument, as specified in the test_data type ['double precision', 'double precision'] and ['double precision'] respectively."}
{"instruction": "Create a Fortran subroutine named sumvectorsub to calculate the sum of all elements in an integer array. The subroutine takes 1 input parameter of type integer array and 1 output parameter of type integer.", "code": "Here's a Fortran subroutine named sumvectorsub to calculate the sum of all elements in an integer array:\n\n```fortran\nsubroutine sumvectorsub(arr, n, result)\n  integer, intent(in) :: arr(:)\n  integer, intent(out) :: result\n  integer :: i\n\n  result = 0\n  do i = 1, size(arr)\n     result = result + arr(i)\n  end do\nend subroutine sumvectorsub\n```\n\nIn this subroutine, the input parameter `arr` is an integer array, `n` is the size of the array, and the output parameter `result` is an integer that will store the sum of all elements in the array. The subroutine uses a do loop to iterate through the array and calculate the sum of its elements, which is then stored in the `result` variable."}
{"instruction": "Create a Fortran subroutine named f_computeomega to calculate the vertical velocity component (omega) in atmospheric models. The subroutine takes 7 input parameters of types integer and real(kind=8) arrays with dimensions mx, my, and mz. It returns 1 output parameter, a real(kind=8) array with dimensions mx, my, and mz.", "code": "Here's a possible implementation of the Fortran subroutine f_computeomega:\n\n```fortran\nsubroutine f_computeomega(mx, my, mz, u, v, w, rho, omega)\n  integer, intent(in) :: mx, my, mz\n  real(kind=8), dimension(mx, my, mz), intent(in) :: u, v, w, rho\n  real(kind=8), dimension(mx, my, mz), intent(out) :: omega\n  ! Other local variables\n  integer :: i, j, k\n  \n  ! Calculate omega\n  do k = 1, mz\n     do j = 1, my\n        do i = 1, mx\n           omega(i, j, k) = -rho(i, j, k) * (u(i, j, k) + v(i, j, k)) / w(i, j, k)\n        end do\n     end do\n  end do\nend subroutine f_computeomega\n```\n\nIn this subroutine, mx, my, and mz are the dimensions of the arrays u, v, w, rho, and omega. The input arrays u, v, w, and rho represent the horizontal wind components and density, while the output array omega represents the vertical velocity component. The subroutine calculates the vertical velocity component using the given formula and stores the result in the omega array."}
{"instruction": "Create a Fortran subroutine named f_computetv that calculates the virtual temperature for a given set of temperature and specific humidity arrays. The subroutine takes 5 input parameters: three integers (nx, ny, nz), and two real arrays of dimension nx, ny, nz (temp and qv). It also has one output parameter, a real array of dimension nx, ny, nz (tv). Use the imperative tone to define the instructions.", "code": "```fortran\nsubroutine f_computetv(nx, ny, nz, temp, qv, tv)\n  integer, intent(in) :: nx, ny, nz\n  real, dimension(nx,ny,nz), intent(in) :: temp, qv\n  real, dimension(nx,ny,nz), intent(out) :: tv\n  ! Calculate the virtual temperature for each grid point\n  do k = 1, nz\n    do j = 1, ny\n      do i = 1, nx\n        ! Calculate the virtual temperature using the formula\n        tv(i,j,k) = temp(i,j,k) * (1.0 + 0.61 * qv(i,j,k))\n      end do\n    end do\n  end do\nend subroutine f_computetv\n```"}
{"instruction": "Create a Fortran subroutine named limit_t_infty_fc_fs_mono to compute the limit of fc and fs as t tends to infinity. The subroutine takes 5 input parameters of type real * 8 and dimension(:), and 2 output parameters of type real * 8 and dimension(:). The subroutine uses the imperative tone to perform the computation.", "code": "Here's a Fortran subroutine named limit_t_infty_fc_fs_mono to compute the limit of fc and fs as t tends to infinity:\n\n```fortran\nsubroutine limit_t_infty_fc_fs_mono(t, fc, fs, limit_fc, limit_fs)\n  real*8, dimension(:), intent(in) :: t, fc, fs\n  real*8, dimension(:), intent(out) :: limit_fc, limit_fs\n  ! Perform the computation\n  ! Compute the limit of fc as t tends to infinity\n  limit_fc = fc(size(fc))\n  ! Compute the limit of fs as t tends to infinity\n  limit_fs = fs(size(fs))\nend subroutine limit_t_infty_fc_fs_mono\n```\n\nIn this subroutine, the input parameters t, fc, and fs are arrays of type real*8 and dimension(:), indicating that they are arrays of real numbers of any size. The output parameters limit_fc and limit_fs are also arrays of type real*8 and dimension(:), representing the limits of fc and fs as t tends to infinity.\n\nThe subroutine uses the imperative tone to perform the computation, as indicated by the comments. The limit of fc as t tends to infinity is computed by taking the last element of the fc array, and similarly, the limit of fs as t tends to infinity is computed by taking the last element of the fs array."}
{"instruction": "Create a Fortran subroutine named gaulob. This subroutine takes 3 input parameters of type real, integer, and real array and 2 output parameters of type real array and real array. The subroutine computes the Gauss-Lobatto nodes and weights for numerical integration over a specified interval. The subroutine uses the Newton-Raphson method to update the nodes and calculates the corresponding weights.", "code": "Here's a Fortran subroutine named gaulob that computes the Gauss-Lobatto nodes and weights:\n\n```fortran\nsubroutine gaulob(a, b, n, x, w)\n  real, intent(in) :: a, b\n  integer, intent(in) :: n\n  real, intent(out) :: x(n), w(n)\n  real :: tol, eps\n  real :: p(n,n), dp(n,n), f(n), df(n)\n  integer :: i, j, k\n  eps = 1.0e-10\n  tol = 1.0e-10\n  do i = 1, n\n    x(i) = -cos((i-1)*pi/(n-1))\n  end do\n  do k = 1, 100\n    do i = 1, n\n      p(i,1) = 1.0\n      p(i,2) = x(i)\n    end do\n    do j = 3, n\n      do i = 1, n\n        p(i,j) = ((2.0*j-3.0)*x(i)*p(i,j-1)-(j-2.0)*p(i,j-2))/(j-1.0)\n      end do\n    end do\n    do i = 1, n\n      f(i) = (1.0-x(i)**2)*dp(i,n-1)\n      df(i) = -2.0*x(i)*dp(i,n-1)\n      do j = 1, n-2\n        f(i) = f(i) + dp(i,j)\n        df(i) = df(i) + (2.0*j+1.0)*dp(i,j)\n      end do\n    end do\n    do i = 1, n\n      dp(i,n) = f(i)/df(i)\n    end do\n    if (maxval(abs(dp(:,n))) < tol) exit\n    do i = 1, n\n      x(i) = x(i) - dp(i,n)\n    end do\n  end do\n  do i = 1, n\n    w(i) = 2.0/(n*(n-1)*p(i,n-1)**2)\n  end do\nend subroutine gaulob\n```\n\nThis subroutine takes the input parameters a (lower limit of the interval), b (upper limit of the interval), and n (number of nodes) and computes the Gauss-Lobatto nodes and weights, which are returned in the arrays x and w, respectively. The subroutine uses the Newton-Raphson method to update the nodes and calculates the corresponding weights."}
{"instruction": "Create a Fortran subroutine named make_wrf_file_name that generates the WRF output file name based on the working directory, domain number, and number of minutes into the simulation. The number of input parameters is 3, and their types are ['character(len=*)', 'integer', 'integer']. The number of output parameters is 1, of type ['character(len=255)']. Use the subroutine's imperative tone to specify the required inputs and the output file name generation process.", "code": "subroutine make_wrf_file_name(working_dir, domain_num, minutes, output_file_name)\n  ! This subroutine generates the WRF output file name based on the working directory, domain number, and number of minutes into the simulation.\n  ! Inputs:\n  !   working_dir: character(len=*) - the working directory where the WRF output file will be stored\n  !   domain_num: integer - the domain number for the WRF simulation\n  !   minutes: integer - the number of minutes into the simulation\n  ! Output:\n  !   output_file_name: character(len=255) - the generated WRF output file name\n  \n  ! Construct the WRF output file name based on the inputs\n  write(output_file_name, '(A,I2.2,\"_d\",I2.2,\"_\",I4.4,\"min.nc\")') trim(working_dir), domain_num, minutes\n  \nend subroutine make_wrf_file_name"}
{"instruction": "Create a Fortran subroutine named gsub that takes 4 input parameters of type double precision and returns 1 output parameter of type double precision with the dimension (4, 2, 2). The subroutine computes and populates the output parameter based on the input parameters using complex number operations and reshaping.", "code": "Here's a Fortran subroutine named gsub that takes 4 input parameters of type double precision and returns 1 output parameter of type double precision with the dimension (4, 2, 2):\n\n```fortran\nsubroutine gsub(a, b, c, d, result)\n  double precision, intent(in) :: a, b, c, d\n  double precision, intent(out) :: result(4, 2, 2)\n  complex(kind=8) :: z1, z2, z3, z4\n  \n  z1 = cmplx(a, b)\n  z2 = cmplx(c, d)\n  \n  z3 = z1 + z2\n  z4 = z1 * z2\n  \n  result(1, 1, 1) = real(z3)\n  result(1, 1, 2) = aimag(z3)\n  result(1, 2, 1) = real(z4)\n  result(1, 2, 2) = aimag(z4)\n  \n  z3 = z1 - z2\n  z4 = z1 / z2\n  \n  result(2, 1, 1) = real(z3)\n  result(2, 1, 2) = aimag(z3)\n  result(2, 2, 1) = real(z4)\n  result(2, 2, 2) = aimag(z4)\n  \n  z3 = conjg(z1)\n  z4 = conjg(z2)\n  \n  result(3, 1, 1) = real(z3)\n  result(3, 1, 2) = aimag(z3)\n  result(3, 2, 1) = real(z4)\n  result(3, 2, 2) = aimag(z4)\n  \n  z3 = z1**2\n  z4 = z2**2\n  \n  result(4, 1, 1) = real(z3)\n  result(4, 1, 2) = aimag(z3)\n  result(4, 2, 1) = real(z4)\n  result(4, 2, 2) = aimag(z4)\n  \nend subroutine gsub\n```\n\nIn this subroutine, we first convert the input parameters `a`, `b`, `c`, and `d` into complex numbers `z1` and `z2`. Then we perform various complex number operations on `z1` and `z2` and store the real and imaginary parts of the results in the output parameter `result` with the specified dimensions."}
{"instruction": "Create a Fortran subroutine named xdiff2_l2 that calculates the squared distance between points in arrays xa and xb, and stores the results in xdiff2. The subroutine takes 5 input parameters of types integer, real*8, and 1D or 2D real*8 arrays, and 1 output parameter of type real*8.", "code": "Here's a Fortran subroutine named xdiff2_l2 that calculates the squared distance between points in arrays xa and xb, and stores the results in xdiff2:\n\n```fortran\nsubroutine xdiff2_l2(n, m, xa, xb, xdiff2)\n  integer, intent(in) :: n, m\n  real*8, intent(in) :: xa(n,m), xb(n,m)\n  real*8, intent(out) :: xdiff2(n,n)\n  integer :: i, j, k\n\n  do i = 1, n\n    do j = 1, n\n      xdiff2(i,j) = 0.0\n      do k = 1, m\n        xdiff2(i,j) = xdiff2(i,j) + (xa(i,k) - xb(j,k))**2\n      end do\n    end do\n  end do\nend subroutine xdiff2_l2\n```\n\nIn this subroutine, n and m are the dimensions of the arrays, xa and xb are the input arrays containing the points, and xdiff2 is the output array that stores the squared distances between points. The subroutine calculates the squared distance between each pair of points in xa and xb and stores the results in xdiff2."}
{"instruction": "Write a Fortran subroutine named put_characters_default_unit to output a string to the default output unit. The input parameter is a string of variable length (character(len=*)), and the output parameter is an optional integer (integer, optional).", "code": "Here's a Fortran subroutine named put_characters_default_unit:\n\n```fortran\nsubroutine put_characters_default_unit(str, ierr)\n  character(len=*) :: str\n  integer, optional :: ierr\n\n  write(*, '(A)') str\n  if (present(ierr)) then\n    ierr = 0\n  end if\nend subroutine put_characters_default_unit\n```\n\nIn this subroutine, the input parameter `str` is a string of variable length, and the output parameter `ierr` is an optional integer. The `write(*, '(A)') str` statement outputs the string `str` to the default output unit. If the `ierr` parameter is present, it is set to 0 to indicate successful execution of the subroutine."}
{"instruction": "Write a Fortran subroutine named setx_crit that takes 4 input arguments of type real (tc, vc, zc(2), pc) and 1 output argument of type real (x(4)). The subroutine sets the elements of the output array x to zc(1), log(tc), log(vc), and log(pc) respectively.", "code": "Here's a Fortran subroutine that accomplishes this:\n\n```fortran\nsubroutine setx_crit(tc, vc, zc, pc, x)\n  real, intent(in) :: tc, vc, zc(2), pc\n  real, intent(out) :: x(4)\n\n  x(1) = zc(1)\n  x(2) = log(tc)\n  x(3) = log(vc)\n  x(4) = log(pc)\n\nend subroutine setx_crit\n```\n\nThis subroutine takes the input arguments tc, vc, zc(2), and pc, and sets the elements of the output array x to zc(1), log(tc), log(vc), and log(pc) respectively."}
{"instruction": "Write a Fortran subroutine named getpropfromxaz to calculate various properties based on input values. The subroutine takes 2 input parameters of types real(4) and integer, and 4 output parameters of types real, real, real, and real. The inputs represent an array of 4 real numbers and an integer, while the outputs represent real numbers corresponding to temperature (t), vapor density (vg), liquid density (vl), and an array of 2 real numbers (z).", "code": "Here's a sample Fortran subroutine named getpropfromxaz:\n\n```fortran\nsubroutine getpropfromxaz(xaz, n, t, vg, vl, z)\n  real(4), dimension(4), intent(in) :: xaz\n  integer, intent(in) :: n\n  real, intent(out) :: t, vg, vl\n  real, dimension(2), intent(out) :: z\n\n  ! Calculate temperature\n  t = xaz(1) * n + xaz(2) * n**2 + xaz(3) * n**3 + xaz(4) * n**4\n\n  ! Calculate vapor density\n  vg = xaz(1) + xaz(2) * n + xaz(3) * n**2 + xaz(4) * n**3\n\n  ! Calculate liquid density\n  vl = xaz(1) - xaz(2) * n + xaz(3) * n**2 - xaz(4) * n**3\n\n  ! Calculate array z\n  z(1) = xaz(1) * n\n  z(2) = xaz(2) * n**2\n\nend subroutine getpropfromxaz\n```\n\nIn this subroutine, the input parameters xaz and n represent the array of 4 real numbers and an integer, respectively. The output parameters t, vg, vl, and z represent the calculated temperature, vapor density, liquid density, and an array of 2 real numbers, respectively. The subroutine uses the input values to perform calculations and assigns the results to the output parameters."}
{"instruction": "Create a Fortran subroutine named setxaz that takes 5 input parameters of type real, real, real, real, and integer, and 1 output parameter of type real. The subroutine computes the natural logarithm of the first input parameter, assigns the value of the second element of the input array z to the second element of the output array x, and computes the natural logarithm of the third and fourth input parameters, and assigns the results to the third and fourth elements of the output array x, respectively.", "code": "Here's a Fortran subroutine named setxaz that meets the given requirements:\n\n```fortran\nsubroutine setxaz(a, z, b, c, d, n, x)\n  real, intent(in) :: a, z(n)\n  real, intent(out) :: x(n)\n  real :: b, c, d\n  integer, intent(in) :: n\n\n  x(1) = log(a)\n  x(2) = z(2)\n  x(3) = log(b)\n  x(4) = log(c)\nend subroutine setxaz\n```\n\nIn this subroutine, the input parameters are a, z, b, c, d, and n, and the output parameter is x. The subroutine computes the natural logarithm of a and assigns it to the first element of x. It then assigns the value of the second element of the input array z to the second element of the output array x. Finally, it computes the natural logarithm of b and c, and assigns the results to the third and fourth elements of the output array x, respectively."}
{"instruction": "Create a Fortran subroutine named cubspline_init to initialize a cubic spline. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and 1 output parameter of type real(8).", "code": "Here's a sample Fortran code for the subroutine cubspline_init:\n\n```fortran\nsubroutine cubspline_init(n, x, y, yp)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x(n), y(n)\n  real(8), intent(out) :: yp(n)\n  real(8) :: h(n-1), p(n-1), u(n-1), qn, un\n  integer :: i\n\n  h = 0.0d0\n  p = 0.0d0\n  u = 0.0d0\n\n  do i = 1, n-1\n    h(i) = x(i+1) - x(i)\n    p(i) = (y(i+1) - y(i)) / h(i)\n  end do\n\n  u(2) = 2.0d0 * (h(1) + h(2))\n  qn = 3.0d0 * (p(n-1) - p(n-2)) / h(n-1)\n  un = 3.0d0 * (h(n-1) + h(n-2))\n\n  do i = 3, n-1\n    u(i) = 2.0d0 * (h(i-1) + h(i)) - h(i-1)**2 / u(i-1)\n    qn = (3.0d0 * (p(i) - p(i-1)) - h(i-1) * qn) / u(i)\n  end do\n\n  yp(n) = qn / un\n\n  do i = n-1, 1, -1\n    yp(i) = (p(i) - h(i) * yp(i+1)) / u(i)\n  end do\n\nend subroutine cubspline_init\n```\n\nIn this subroutine, the input parameters are:\n- n: the number of data points\n- x: an array of size n containing the x-coordinates of the data points\n- y: an array of size n containing the y-coordinates of the data points\n\nThe output parameter is:\n- yp: an array of size n containing the second derivatives of the cubic spline at the data points\n\nThis subroutine initializes a cubic spline by calculating the second derivatives of the spline at the given data points using the input x and y coordinates."}
{"instruction": "Create a Fortran subroutine named bdy_tracer_value to calculate the value of a tracer variable. The subroutine takes 4 input parameters of type real, real, real, and integer, and returns 1 output parameter of type real. The subroutine computes the value of the tracer variable based on the input values and a small epsilon value. Use the imperative tone in your instructions.", "code": "Here's a Fortran subroutine named bdy_tracer_value that calculates the value of a tracer variable:\n\n```fortran\nsubroutine bdy_tracer_value(input1, input2, input3, input4, output)\n  real, intent(in) :: input1, input2, input3\n  integer, intent(in) :: input4\n  real, intent(out) :: output\n  real :: epsilon\n\n  ! Calculate the value of the tracer variable\n  epsilon = 1.0e-6\n  output = input1 * input2 / (input3 + input4) + epsilon\nend subroutine bdy_tracer_value\n```\n\nYou can use this subroutine by passing in the input parameters and receiving the calculated value in the output parameter."}
{"instruction": "Create a Fortran subroutine named sl_stcov to compute the block-toeplitz covariance matrix for MSSA analysis. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter var does not need to be centered.", "code": "Here's a Fortran subroutine named sl_stcov to compute the block-toeplitz covariance matrix for MSSA analysis:\n\n```fortran\nsubroutine sl_stcov(var, cov)\n  real, intent(in) :: var(:)  ! Input parameter of type real\n  real, intent(out) :: cov(size(var), size(var))  ! Output parameter of type real\n  integer :: i, j, k\n\n  cov = 0.0  ! Initialize covariance matrix to zero\n\n  do i = 1, size(var)\n    do j = 1, size(var)\n      do k = 1, min(i, j)\n        cov(i, j) = cov(i, j) + var(abs(i-j)+k) * var(k)\n      end do\n    end do\n  end do\n\nend subroutine sl_stcov\n```\n\nIn this subroutine, the input parameter var is an array of real numbers, and the output parameter cov is a 2D array representing the block-toeplitz covariance matrix. The subroutine uses nested do-loops to compute the covariance matrix based on the input var."}
{"instruction": "Create a Fortran subroutine named rotaxis to calculate the rotation axis and the rotation angle based on the input Euler angles. The subroutine takes 3 input parameters of type real: alpha, beta, and gamma. It returns 2 output parameters of type real: rax (an array of 4 elements) and theta.", "code": "Here's a Fortran subroutine named rotaxis that calculates the rotation axis and rotation angle based on the input Euler angles:\n\n```fortran\nsubroutine rotaxis(alpha, beta, gamma, rax, theta)\n  real, intent(in) :: alpha, beta, gamma\n  real, intent(out) :: rax(4), theta\n  real :: ca, cb, cg, sa, sb, sg\n\n  ca = cos(alpha/2.0)\n  cb = cos(beta/2.0)\n  cg = cos(gamma/2.0)\n  sa = sin(alpha/2.0)\n  sb = sin(beta/2.0)\n  sg = sin(gamma/2.0)\n\n  rax(1) = ca*cb*sg - sa*sb*cg\n  rax(2) = sa*cb*sg + ca*sb*cg\n  rax(3) = ca*sb*sg - sa*cb*cg\n  rax(4) = ca*cb*cg + sa*sb*sg\n\n  theta = 2.0*acos(ca*cb*cg + sa*sb*sg)\nend subroutine rotaxis\n```\n\nIn this subroutine, the input parameters alpha, beta, and gamma are the Euler angles, and the output parameters rax and theta are the rotation axis and rotation angle, respectively. The rotation axis is represented as a 4-element array, and the rotation angle is calculated using the input Euler angles."}
{"instruction": "Create a Fortran subroutine named map_mstep_dense. This subroutine takes 5 input parameters of types integer, double precision, and double precision, and produces 3 output parameters of type double precision. The subroutine performs a specific calculation involving arrays and loops.", "code": "Here's an example of a Fortran subroutine named map_mstep_dense that takes 5 input parameters and produces 3 output parameters:\n\n```fortran\nsubroutine map_mstep_dense(n, x, y, z, a, b, c)\n  integer, intent(in) :: n\n  double precision, intent(in) :: x(n), y(n), z(n)\n  double precision, intent(out) :: a(n), b(n), c(n)\n  integer :: i\n\n  do i = 1, n\n    a(i) = x(i) * y(i) + z(i)\n    b(i) = x(i) / y(i) - z(i)\n    c(i) = x(i) + y(i) * z(i)\n  end do\n\nend subroutine map_mstep_dense\n```\n\nIn this example, the subroutine map_mstep_dense takes 5 input parameters: n (an integer), x, y, and z (arrays of double precision), and produces 3 output parameters: a, b, and c (arrays of double precision). The subroutine performs a specific calculation involving arrays and loops, where each element of the output arrays is calculated based on the corresponding elements of the input arrays."}
{"instruction": "Create a Fortran subroutine named makeobsbinary that takes 5 input parameters of type real (a, ecc, inc, phi, mean) and 1 output parameter of type real (sky(1:2)). The subroutine calculates the position of an object in the sky based on the input orbital parameters.", "code": "Here's a possible implementation of the makeobsbinary subroutine in Fortran:\n\n```fortran\nsubroutine makeobsbinary(a, ecc, inc, phi, mean, sky)\n  real, intent(in) :: a, ecc, inc, phi, mean\n  real, intent(out) :: sky(2)\n\n  ! Calculate position of object in the sky based on orbital parameters\n  ! (implementation details would depend on the specific calculation method)\n\n  ! Example calculation (replace with actual calculation)\n  sky(1) = a * cos(phi) * (cos(mean) - ecc)\n  sky(2) = a * sin(phi) * (sqrt(1.0 - ecc**2) * sin(mean))\n\nend subroutine makeobsbinary\n```\n\nThis subroutine takes 5 input parameters (a, ecc, inc, phi, mean) of type real and 1 output parameter (sky) of type real array with 2 elements. The subroutine calculates the position of an object in the sky based on the input orbital parameters and stores the result in the sky array. Note that the actual calculation method would need to be implemented based on the specific requirements."}
{"instruction": "Create a Fortran subroutine named linear_regress to calculate the linear regression coefficients and optionally the correlation coefficient. The subroutine takes 3 input parameters of type integer, real(kind=8) array of dimension nn, and real(kind=8) array of dimension nn. It returns 3 output parameters of type real(kind=8), real(kind=8), and optionally real(kind=8).", "code": "Here's a Fortran subroutine named linear_regress that calculates the linear regression coefficients and optionally the correlation coefficient:\n\n```fortran\nsubroutine linear_regress(nn, x, y, slope, intercept, correlation)\n  implicit none\n  integer, intent(in) :: nn\n  real(kind=8), dimension(nn), intent(in) :: x, y\n  real(kind=8), intent(out) :: slope, intercept, correlation\n  real(kind=8) :: sum_x, sum_y, sum_xy, sum_x_squared, sum_y_squared\n  real(kind=8) :: mean_x, mean_y\n  integer :: i\n\n  ! Calculate the sums and means of x and y\n  sum_x = 0.0d0\n  sum_y = 0.0d0\n  do i = 1, nn\n     sum_x = sum_x + x(i)\n     sum_y = sum_y + y(i)\n  end do\n  mean_x = sum_x / real(nn, kind=8)\n  mean_y = sum_y / real(nn, kind=8)\n\n  ! Calculate the sums of xy, x^2, and y^2\n  sum_xy = 0.0d0\n  sum_x_squared = 0.0d0\n  sum_y_squared = 0.0d0\n  do i = 1, nn\n     sum_xy = sum_xy + x(i) * y(i)\n     sum_x_squared = sum_x_squared + x(i) * x(i)\n     sum_y_squared = sum_y_squared + y(i) * y(i)\n  end do\n\n  ! Calculate the slope and intercept of the regression line\n  slope = (nn * sum_xy - sum_x * sum_y) / (nn * sum_x_squared - sum_x**2)\n  intercept = mean_y - slope * mean_x\n\n  ! Calculate the correlation coefficient if requested\n  if (present(correlation)) then\n     correlation = (nn * sum_xy - sum_x * sum_y) / sqrt((nn * sum_x_squared - sum_x**2) * (nn * sum_y_squared - sum_y**2))\n  end if\nend subroutine linear_regress\n```\n\nIn this subroutine, nn is the number of data points, x and y are the arrays of x and y values, and slope, intercept, and correlation are the output parameters for the regression coefficients and correlation coefficient. The subroutine calculates the regression coefficients and optionally the correlation coefficient using the least squares method."}
{"instruction": "Write a Fortran subroutine named spl_make_open_knots to generate open knot vector for a spline. The subroutine takes 2 input parameters of type integer, p and n, and has 1 output parameter of type real(kind=8), dimension(:), knots.", "code": "Here's a possible implementation of the subroutine spl_make_open_knots:\n\n```fortran\nsubroutine spl_make_open_knots(p, n, knots)\n  integer, intent(in) :: p, n\n  real(kind=8), dimension(:), intent(out) :: knots\n  integer :: m, i\n\n  m = n + p + 1\n  allocate(knots(m))\n\n  do i = 1, p\n    knots(i) = 0.0d0\n  end do\n\n  do i = p+1, n+1\n    knots(i) = real(i - p, kind=8)\n  end do\n\n  do i = n+2, m\n    knots(i) = real(n - p + 1, kind=8)\n  end do\n\nend subroutine spl_make_open_knots\n```\n\nIn this subroutine, we first calculate the total number of knots, m, based on the degree of the spline (p) and the number of control points (n). We then allocate an array of real numbers to store the knots.\n\nWe then initialize the first p knots to 0, set the internal knots to be equally spaced from p+1 to n+1, and set the last p knots to n-p+1.\n\nThis subroutine generates the open knot vector for a spline and stores it in the knots array."}
{"instruction": "Create a Fortran subroutine named lin_reg to perform linear regression on a set of data points. The subroutine takes 3 input parameters of type integer, real(kind=8), and real(kind=8) and 3 output parameters of type real(kind=8), real(kind=8), and real(kind=8), respectively. The subroutine calculates the slope, y-intercept, and correlation coefficient for the given data points.", "code": "Here's a Fortran subroutine named lin_reg that performs linear regression on a set of data points:\n\n```fortran\nsubroutine lin_reg(n, x, y, slope, y_intercept, correlation)\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), intent(in) :: x(n), y(n)\n  real(kind=8), intent(out) :: slope, y_intercept, correlation\n  real(kind=8) :: sum_x, sum_y, sum_xy, sum_x2, sum_y2\n  real(kind=8) :: mean_x, mean_y\n  integer :: i\n\n  ! Calculate the sums\n  sum_x = 0.0d0\n  sum_y = 0.0d0\n  sum_xy = 0.0d0\n  sum_x2 = 0.0d0\n  sum_y2 = 0.0d0\n  do i = 1, n\n     sum_x = sum_x + x(i)\n     sum_y = sum_y + y(i)\n     sum_xy = sum_xy + x(i) * y(i)\n     sum_x2 = sum_x2 + x(i) * x(i)\n     sum_y2 = sum_y2 + y(i) * y(i)\n  end do\n\n  ! Calculate the means\n  mean_x = sum_x / real(n)\n  mean_y = sum_y / real(n)\n\n  ! Calculate the slope and y-intercept\n  slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x**2)\n  y_intercept = mean_y - slope * mean_x\n\n  ! Calculate the correlation coefficient\n  correlation = (n * sum_xy - sum_x * sum_y) / sqrt((n * sum_x2 - sum_x**2) * (n * sum_y2 - sum_y**2))\n\nend subroutine lin_reg\n```\n\nIn this subroutine, the input parameters are the number of data points (n), the arrays of x and y values, and the output parameters are the slope, y-intercept, and correlation coefficient. The subroutine calculates the sums, means, slope, y-intercept, and correlation coefficient using the given data points."}
{"instruction": "Write a Fortran subroutine named cholsl that performs backward and forward substitution to solve a linear system of equations using the Cholesky factorization method. The subroutine takes 5 input parameters of type integer(4), integer(4), real(8), real(8), and real(8), and 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named cholsl that performs backward and forward substitution to solve a linear system of equations using the Cholesky factorization method:\n\n```fortran\nsubroutine cholsl(n, a, b, x, info)\n  integer(4), intent(in) :: n\n  integer(4), intent(in) :: a(n,n)\n  real(8), intent(in) :: b(n)\n  real(8), intent(out) :: x(n)\n  integer(4), intent(out) :: info\n\n  real(8) :: y(n)\n  real(8) :: l(n,n)\n  integer(4) :: i, j\n\n  ! Perform Cholesky factorization\n  call dpofa(a, n, n, info)\n  if (info /= 0) then\n    print *, \"Cholesky factorization failed\"\n    return\n  endif\n\n  ! Solve Ly = b using forward substitution\n  do i = 1, n\n    y(i) = b(i)\n    do j = 1, i-1\n      y(i) = y(i) - l(i,j) * y(j)\n    end do\n    y(i) = y(i) / l(i,i)\n  end do\n\n  ! Solve L^T x = y using backward substitution\n  do i = n, 1, -1\n    x(i) = y(i)\n    do j = i+1, n\n      x(i) = x(i) - l(j,i) * x(j)\n    end do\n    x(i) = x(i) / l(i,i)\n  end do\nend subroutine cholsl\n```\n\nIn this subroutine, the input parameters are:\n- n: the size of the linear system\n- a: the coefficient matrix of the linear system\n- b: the right-hand side vector of the linear system\n\nThe output parameter is:\n- x: the solution vector of the linear system\n\nThe subroutine uses the Cholesky factorization method to factorize the coefficient matrix a into the lower triangular matrix l. Then, it solves the linear system using forward and backward substitution. The info parameter is used to indicate whether the Cholesky factorization was successful."}
{"instruction": "Create a Fortran subroutine named calc_rcouple_scales to calculate the rscale values based on the input arrays a and msf. The subroutine takes 6 input parameters of types integer, integer, integer, integer, real, and real, and 1 output parameter of type real. The function computes the rscale values using the formula rscale(i) = a(i)/msf(i) for the specified range of indices.", "code": "Here's a Fortran subroutine named calc_rcouple_scales that calculates the rscale values based on the input arrays a and msf:\n\n```fortran\nsubroutine calc_rcouple_scales(start_index, end_index, a_size, msf_size, a, msf, rscale)\n  integer, intent(in) :: start_index, end_index, a_size, msf_size\n  real, dimension(a_size), intent(in) :: a\n  real, dimension(msf_size), intent(in) :: msf\n  real, dimension(a_size), intent(out) :: rscale\n  integer :: i\n\n  do i = start_index, end_index\n    rscale(i) = a(i) / msf(i)\n  end do\nend subroutine calc_rcouple_scales\n```\n\nIn this subroutine, start_index and end_index specify the range of indices for which the rscale values will be calculated. a_size and msf_size specify the size of the input arrays a and msf, respectively. The input arrays a and msf are of type real and have sizes a_size and msf_size, respectively. The output parameter rscale is also an array of type real with size a_size.\n\nThe subroutine uses a do loop to iterate over the specified range of indices and calculates the rscale values using the formula rscale(i) = a(i)/msf(i)."}
{"instruction": "Write a Fortran subroutine named minmax_r that takes an array of 64-bit real numbers as input and returns the minimum and maximum values found in the array as output. The input parameter should be of type real(kind=8), dimension(:), and the output parameters should be of type real(kind=8).", "code": "Here's a Fortran subroutine named minmax_r that accomplishes the described task:\n\n```fortran\nsubroutine minmax_r(arr, min_val, max_val)\n  real(kind=8), dimension(:), intent(in) :: arr\n  real(kind=8), intent(out) :: min_val, max_val\n  integer :: i\n\n  min_val = arr(1)\n  max_val = arr(1)\n\n  do i = 2, size(arr)\n    if (arr(i) < min_val) min_val = arr(i)\n    if (arr(i) > max_val) max_val = arr(i)\n  end do\n\nend subroutine minmax_r\n```\n\nYou can use this subroutine by passing an array of 64-bit real numbers as input and receiving the minimum and maximum values as output. For example:\n\n```fortran\nprogram test_minmax_r\n  real(kind=8), dimension(5) :: my_array = [1.0d0, 2.0d0, 3.0d0, 4.0d0, 5.0d0]\n  real(kind=8) :: min_value, max_value\n\n  call minmax_r(my_array, min_value, max_value)\n\n  print *, \"Minimum value: \", min_value\n  print *, \"Maximum value: \", max_value\nend program test_minmax_r\n```"}
{"instruction": "Create a Fortran subroutine named calend that takes two input parameters of type integer, yyyy and ddd, and two output parameters of type integer, mm and dd. The subroutine is responsible for converting a given year and day of the year into the corresponding month and day of the month, using the ACM Algorithm 398. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "code": "Here's a Fortran subroutine named calend that takes two input parameters of type integer, yyyy and ddd, and two output parameters of type integer, mm and dd:\n\n```fortran\nsubroutine calend(yyyy, ddd, mm, dd)\n  integer, intent(in) :: yyyy, ddd\n  integer, intent(out) :: mm, dd\n  integer :: i, k, l, n\n\n  k = mod(yyyy, 100)\n  l = k - mod(k, 4)\n  n = 365 * yyyy + (yyyy/4) - l + ddd\n  mm = (n - 122 * (mod(n, 1461) / 1460)) / 306 + 2\n  dd = n - 306 * (mm + 1) / 10\n\n  if (mod(n, 1461) == 0) then\n    mm = 12\n    dd = 31\n  endif\n\n  if (mm < 10) then\n    mm = mm + 3\n  else\n    mm = mm - 9\n    yyyy = yyyy + 1\n  endif\n\n  dd = dd - 30\n\nend subroutine calend\n```\n\nYou can use this subroutine to convert a given year and day of the year into the corresponding month and day of the month by calling it with the yyyy and ddd as input parameters and mm and dd as output parameters."}
{"instruction": "Create a Fortran subroutine named m_wat to compute the complex index of refraction of liquid water based on frequency and temperature. The subroutine takes 2 input parameters of type real*8, representing frequency and temperature, and returns 2 output parameters of type real*8, representing the real and imaginary parts of the index of refraction.", "code": "Here's a Fortran subroutine named m_wat to compute the complex index of refraction of liquid water based on frequency and temperature:\n\n```fortran\nsubroutine m_wat(freq, temp, n_real, n_imag)\n  real*8, intent(in) :: freq, temp\n  real*8, intent(out) :: n_real, n_imag\n\n  ! Constants\n  real*8, parameter :: A1 = 1.0, A2 = 5.084e-3, A3 = 1.636e-2, A4 = -2.118e-2, A5 = 1.362e-2\n  real*8, parameter :: B1 = 1.0, B2 = 3.14e-2, B3 = 8.17e-2, B4 = 2.1e-2\n\n  ! Compute real part of index of refraction\n  n_real = 1.0 + A1 + A2*freq**2 / (freq**2 - A3) + A4*freq**2 / (freq**2 - A5)\n\n  ! Compute imaginary part of index of refraction\n  n_imag = B1*temp + B2*temp**2 / (freq**2 + B3) + B4*temp**2\n\nend subroutine m_wat\n```\n\nIn this subroutine, the input parameters `freq` and `temp` represent the frequency and temperature, respectively. The output parameters `n_real` and `n_imag` represent the real and imaginary parts of the index of refraction, respectively. The subroutine uses the given constants and formulas to compute the real and imaginary parts of the index of refraction for liquid water."}
{"instruction": "Create a Fortran subroutine named \"hmatrix\" to generate a matrix \"h\" based on the input data. The subroutine should take 6 input parameters: nl and nr of type integer(ip), model_i and model_j of type integer(ip) arrays with dimension nl, and codar_i and codar_j of type integer(ip) arrays with dimension nr. It should also have 1 output parameter: h of type integer(ip) array with dimension (2*nr,2*nl). This subroutine allocates memory for array \"c\", initializes matrix \"h\" with zeros, populates array \"c\" based on the input data, and then fills matrix \"h\" based on the values of array \"c\".", "code": "Here's a Fortran subroutine named \"hmatrix\" that accomplishes the described task:\n\n```fortran\nsubroutine hmatrix(nl, nr, model_i, model_j, codar_i, codar_j, h)\n  integer, intent(in) :: nl, nr\n  integer, dimension(nl), intent(in) :: model_i, model_j\n  integer, dimension(nr), intent(in) :: codar_i, codar_j\n  integer, dimension(2*nr, 2*nl), intent(out) :: h\n  integer, dimension(nr, nl) :: c\n  integer :: i, j, k, l\n\n  allocate(c(nr, nl))\n\n  ! Initialize matrix h with zeros\n  h = 0\n\n  ! Populate array c based on input data\n  do i = 1, nr\n    do j = 1, nl\n      if (model_i(j) == codar_i(i) .and. model_j(j) == codar_j(i)) then\n        c(i, j) = 1\n      else\n        c(i, j) = 0\n      end if\n    end do\n  end do\n\n  ! Fill matrix h based on values of array c\n  do i = 1, nr\n    do j = 1, nl\n      do k = 1, 2\n        do l = 1, 2\n          h(2*(i-1)+k, 2*(j-1)+l) = c(i, j)\n        end do\n      end do\n    end do\n  end do\n\n  deallocate(c)\nend subroutine hmatrix\n```\n\nThis subroutine allocates memory for array \"c\", initializes matrix \"h\" with zeros, populates array \"c\" based on the input data, and then fills matrix \"h\" based on the values of array \"c\"."}
{"instruction": "Create a Fortran subroutine named perform_integral to calculate the integral of a given function using the trapezoidal rule. The subroutine takes 3 input parameters of type real, dimension(1:), real, dimension(1:), and integer, and 1 output parameter of type real.", "code": "Here's a Fortran subroutine named perform_integral to calculate the integral of a given function using the trapezoidal rule:\n\n```fortran\nsubroutine perform_integral(func, x, n, result)\n  real, dimension(1:), intent(in) :: func\n  real, dimension(1:), intent(in) :: x\n  integer, intent(in) :: n\n  real, intent(out) :: result\n  real :: h, sum\n  integer :: i\n\n  h = (x(n) - x(1)) / real(n)\n  sum = 0.5 * (func(1) + func(n))\n  do i = 2, n-1\n    sum = sum + func(i)\n  end do\n  result = h * sum\nend subroutine perform_integral\n```\n\nIn this subroutine, the input parameters are:\n- func: an array containing the values of the function to be integrated\n- x: an array containing the x-coordinates of the function values\n- n: the number of intervals to use in the trapezoidal rule\n\nThe output parameter is:\n- result: the calculated integral value\n\nThe subroutine calculates the integral using the trapezoidal rule and stores the result in the output parameter \"result\"."}
{"instruction": "Create a Fortran subroutine named snowz0 that calculates the effective roughness length (z0) for snow-covered surfaces. The subroutine takes 2 input parameters of type real (z0brd and snowh) and returns 1 output parameter of type real (z0).", "code": "Here's a Fortran subroutine named snowz0 that calculates the effective roughness length (z0) for snow-covered surfaces:\n\n```fortran\nsubroutine snowz0(z0brd, snowh, z0)\n  real, intent(in) :: z0brd, snowh\n  real, intent(out) :: z0\n\n  ! Constants\n  real, parameter :: vonKarman = 0.4\n\n  ! Calculate z0 for snow-covered surfaces\n  z0 = z0brd * exp(-0.2 * snowh)\n\nend subroutine snowz0\n```\n\nIn this subroutine, z0brd is the bare surface roughness length, snowh is the snow depth, and z0 is the effective roughness length for snow-covered surfaces. The subroutine uses the input parameters to calculate z0 and returns the result as the output parameter."}
{"instruction": "Create a Fortran subroutine named setwtlimits that calculates the maximum and minimum values of weights for each category. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are numcatobs and weights, and the output parameters are maxw and minw.", "code": "Here's a possible implementation of the setwtlimits subroutine in Fortran:\n\n```fortran\nsubroutine setwtlimits(numcatobs, weights, maxw, minw)\n  implicit none\n  integer, intent(in) :: numcatobs\n  integer, intent(in) :: weights(numcatobs)\n  integer, intent(out) :: maxw\n  integer, intent(out) :: minw\n  integer :: i\n\n  maxw = weights(1)\n  minw = weights(1)\n\n  do i = 2, numcatobs\n    if (weights(i) > maxw) then\n      maxw = weights(i)\n    endif\n    if (weights(i) < minw) then\n      minw = weights(i)\n    endif\n  end do\n\nend subroutine setwtlimits\n```\n\nIn this subroutine, we first declare the input and output parameters using the `intent(in)` and `intent(out)` attributes. Inside the subroutine, we initialize the `maxw` and `minw` variables with the first element of the `weights` array. Then, we loop through the remaining elements of the `weights` array and update `maxw` and `minw` if we find a larger or smaller value, respectively. Finally, the calculated `maxw` and `minw` values are returned as output parameters."}
{"instruction": "Write a Fortran subroutine named mapc2pspherical to convert Cartesian coordinates to spherical coordinates. The subroutine takes 5 input parameters of type real(kind=8) and dimension, and 3 output parameters of type real(kind=8) and dimension. The input parameters are xc, yc, zc, xyz0, and xyzn, while the output parameters are xp, yp, and zp.", "code": "Here's a Fortran subroutine named mapc2pspherical to convert Cartesian coordinates to spherical coordinates:\n\n```fortran\nsubroutine mapc2pspherical(xc, yc, zc, xyz0, xyzn, xp, yp, zp)\n  real(kind=8), dimension(3), intent(in) :: xc, yc, zc, xyz0, xyzn\n  real(kind=8), dimension(3), intent(out) :: xp, yp, zp\n  real(kind=8) :: r, theta, phi\n\n  r = sqrt((xc - xyz0(1))**2 + (yc - xyz0(2))**2 + (zc - xyz0(3))**2)\n  theta = atan2(sqrt((xc - xyz0(1))**2 + (yc - xyz0(2))**2), (zc - xyz0(3)))\n  phi = atan2(yc - xyz0(2), xc - xyz0(1))\n\n  xp = r * sin(theta) * cos(phi) + xyzn(1)\n  yp = r * sin(theta) * sin(phi) + xyzn(2)\n  zp = r * cos(theta) + xyzn(3)\nend subroutine mapc2pspherical\n```\n\nIn this subroutine, xc, yc, and zc are the input Cartesian coordinates, and xyz0 and xyzn are the reference and new origins, respectively. The subroutine calculates the spherical coordinates (r, theta, phi) and then converts them back to Cartesian coordinates using the new origin xyzn. The resulting Cartesian coordinates are stored in xp, yp, and zp."}
{"instruction": "Create a Fortran subroutine named calc_signal to calculate a signal value based on given parameters. The subroutine takes 8 input parameters of types integer, real(8), real(8), real(8), real(8), real(8), real(8), real(8). It returns 1 output parameter of type real(8).", "code": "Here's a Fortran subroutine named calc_signal that takes 8 input parameters and returns 1 output parameter:\n\n```fortran\nsubroutine calc_signal(param1, param2, param3, param4, param5, param6, param7, param8, result)\n  integer, intent(in) :: param1\n  real(8), intent(in) :: param2, param3, param4, param5, param6, param7, param8\n  real(8), intent(out) :: result\n  \n  ! Calculate the signal value based on the given parameters\n  result = param2 * param3 + param4 / param5 - param6 * param7 / param8 + real(param1, 8)\n  \nend subroutine calc_signal\n```\n\nIn this subroutine, param1 to param8 are the input parameters of types integer and real(8), and result is the output parameter of type real(8). The subroutine calculates the signal value based on the given parameters and stores the result in the output parameter."}
{"instruction": "Create a Fortran subroutine named calindex to calculate the indices i, j, and k based on the input parameters para, nvx, and nvz. The number of input parameters is 3, and the test_data type is ['integer', 'integer', 'integer']. The number of output parameters is 3, and the test_data type is ['integer', 'integer', 'integer'].", "code": "Here's a Fortran subroutine named calindex that calculates the indices i, j, and k based on the input parameters para, nvx, and nvz:\n\n```fortran\nsubroutine calindex(para, nvx, nvz, i, j, k)\n  integer, intent(in) :: para, nvx, nvz\n  integer, intent(out) :: i, j, k\n\n  i = para / (nvx * nvz)\n  j = mod(para / nvz, nvx)\n  k = mod(para, nvz)\nend subroutine calindex\n```\n\nIn this subroutine, the input parameters para, nvx, and nvz are of type integer and are passed by value using the `intent(in)` attribute. The output parameters i, j, and k are also of type integer and are calculated based on the input parameters. They are passed by reference using the `intent(out)` attribute. The calculated indices i, j, and k are then returned as the output of the subroutine."}
{"instruction": "Write a Fortran subroutine named \"raingas\" that computes the gas-phase rainwater mixing ratio.The subroutine takes 7 input parameters of type real: rrain, dtscav, clwx, cfx, qm, qt, qtdis, and returns 1 output parameter of type real: qtrain.", "code": "Here's a possible implementation of the \"raingas\" subroutine in Fortran:\n\n```fortran\nsubroutine raingas(rrain, dtscav, clwx, cfx, qm, qt, qtdis, qtrain)\n  real, intent(in) :: rrain, dtscav, clwx, cfx, qm, qt, qtdis\n  real, intent(out) :: qtrain\n\n  ! Compute gas-phase rainwater mixing ratio\n  qtrain = (rrain * dtscav * clwx * cfx) / (qm * qt * qtdis)\n\nend subroutine raingas\n```\n\nYou can use this subroutine by passing the input parameters rrain, dtscav, clwx, cfx, qm, qt, qtdis and receiving the output parameter qtrain."}
{"instruction": "Write a Fortran subroutine named set_descra to determine the descriptor string for a matrix based on its properties. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of types character*11 and integer. The descriptor string represents various properties of the matrix and is stored in the output parameter descra. The integer output parameter ierr indicates the success or failure of the operation.", "code": "Here's a sample Fortran subroutine named set_descra:\n\n```fortran\nsubroutine set_descra(n, descra, ierr)\n  integer, intent(in) :: n\n  character*11, intent(out) :: descra\n  integer, intent(out) :: ierr\n\n  ! Determine the properties of the matrix based on its size\n  if (n > 0) then\n    descra = 'General    '\n    ierr = 0  ! Success\n  else\n    descra = 'Invalid    '\n    ierr = 1  ! Failure\n  end if\n\nend subroutine set_descra\n```\n\nIn this subroutine, the input parameter `n` represents the size of the matrix. The output parameter `descra` is a character string of length 11 that represents the properties of the matrix. The output parameter `ierr` is an integer that indicates the success or failure of the operation, with 0 indicating success and 1 indicating failure.\n\nThis is a simple example, and you can modify the subroutine to determine the descriptor string based on other properties of the matrix, such as symmetry, sparsity, etc."}
{"instruction": "Write a Fortran subroutine named get_infoa to retrieve specific information from an integer array based on the given description. The subroutine takes 2 input parameters of type ['integer, dimension(10)', 'character'] and 2 output parameters of type ['integer', 'integer']. The subroutine uses a select case statement to determine the value of 'val' based on the input 'descr' and assigns it to the output parameter 'val'. Additionally, the subroutine sets the output parameter 'ierr' to 0 if the operation is successful, otherwise sets it to -1.", "code": "Here's a possible implementation of the get_infoa subroutine in Fortran:\n\n```fortran\nsubroutine get_infoa(arr, descr, val, ierr)\n  integer, dimension(10), intent(in) :: arr\n  character, intent(in) :: descr\n  integer, intent(out) :: val, ierr\n\n  select case(descr)\n    case('max')\n      val = maxval(arr)\n      ierr = 0\n    case('min')\n      val = minval(arr)\n      ierr = 0\n    case default\n      ierr = -1\n  end select\nend subroutine get_infoa\n```\n\nIn this subroutine, the input parameters are the integer array 'arr' and the character 'descr', and the output parameters are the integer 'val' and the integer 'ierr'. The select case statement is used to determine the value of 'val' based on the input 'descr', and 'ierr' is set accordingly. If the operation is successful, 'ierr' is set to 0, otherwise it is set to -1."}
{"instruction": "Write a Fortran subroutine named mk_iseed that takes 4 input parameters of type integer: ymdh, ij, ilev, and n. It also has 1 output parameter of type integer: iseed. The subroutine computes the value of iseed based on the input parameters using a series of arithmetic operations.", "code": "Here's a Fortran subroutine named mk_iseed that takes 4 input parameters of type integer: ymdh, ij, ilev, and n, and has 1 output parameter of type integer: iseed.\n\n```fortran\nsubroutine mk_iseed(ymdh, ij, ilev, n, iseed)\n  integer, intent(in) :: ymdh, ij, ilev, n\n  integer, intent(out) :: iseed\n\n  ! Compute iseed based on input parameters\n  iseed = ymdh * 1000000 + ij * 10000 + ilev * 100 + n\n\nend subroutine mk_iseed\n```\n\nIn this subroutine, the value of iseed is computed by multiplying ymdh by 1000000, ij by 10000, ilev by 100, and adding n. The result is then assigned to the output parameter iseed."}
{"instruction": "Write a Fortran subroutine named copy_data_5d_real8 that takes an input array of 5D real(8) data and copies it to an output array of the same type and dimensions.The number of input arguments is 1 and the test_data type is [real(8)], and the number of output arguments is 1 with the test_data type [real(8)].", "code": "Here's a Fortran subroutine that accomplishes this:\n\n```fortran\nsubroutine copy_data_5d_real8(input_data, output_data)\n  real(8), dimension(:,:,:,:,:), intent(in) :: input_data\n  real(8), dimension(:,:,:,:,:), intent(out) :: output_data\n  \n  ! Get the dimensions of the input array\n  integer :: dim1, dim2, dim3, dim4, dim5\n  dim1 = size(input_data, 1)\n  dim2 = size(input_data, 2)\n  dim3 = size(input_data, 3)\n  dim4 = size(input_data, 4)\n  dim5 = size(input_data, 5)\n  \n  ! Copy the input data to the output array\n  output_data(1:dim1, 1:dim2, 1:dim3, 1:dim4, 1:dim5) = input_data(1:dim1, 1:dim2, 1:dim3, 1:dim4, 1:dim5)\n  \nend subroutine copy_data_5d_real8\n```\n\nYou can use this subroutine by passing in the input array and an uninitialized output array of the same dimensions. After calling the subroutine, the output array will contain a copy of the input data."}
{"instruction": "Create a Fortran subroutine named \"mc_step\" that takes 3 input parameters of type real(8) in the form of arrays \"rthetaphi1\", \"center_xyz\", and \"stepsize\". The subroutine should also have 2 output parameters of type real(8) in the form of arrays \"rthetaphi2\" and \"xyz2\". The subroutine should compute changes in spherical coordinates and corresponding Cartesian coordinates based on the input parameters using Monte Carlo simulation steps. Ensure that the subroutine uses the random_number function to generate random numbers and returns the updated values in \"rthetaphi2\" and \"xyz2\".", "code": "Here's a Fortran subroutine that accomplishes the described task:\n\n```fortran\nsubroutine mc_step(rthetaphi1, center_xyz, stepsize, rthetaphi2, xyz2)\n  real(8), intent(in) :: rthetaphi1(3), center_xyz(3), stepsize(3)\n  real(8), intent(out) :: rthetaphi2(3), xyz2(3)\n  real(8) :: rand1, rand2, rand3\n  real(8) :: dr, dtheta, dphi\n\n  ! Compute changes in spherical coordinates using Monte Carlo simulation steps\n  call random_number(rand1)\n  call random_number(rand2)\n  call random_number(rand3)\n\n  dr = stepsize(1) * (2.0_rand1 - 1.0)\n  dtheta = stepsize(2) * (2.0_rand2 - 1.0)\n  dphi = stepsize(3) * (2.0_rand3 - 1.0)\n\n  rthetaphi2(1) = rthetaphi1(1) + dr\n  rthetaphi2(2) = rthetaphi1(2) + dtheta\n  rthetaphi2(3) = rthetaphi1(3) + dphi\n\n  ! Convert spherical coordinates to Cartesian coordinates\n  xyz2(1) = rthetaphi2(1) * sin(rthetaphi2(2)) * cos(rthetaphi2(3)) + center_xyz(1)\n  xyz2(2) = rthetaphi2(1) * sin(rthetaphi2(2)) * sin(rthetaphi2(3)) + center_xyz(2)\n  xyz2(3) = rthetaphi2(1) * cos(rthetaphi2(2)) + center_xyz(3)\nend subroutine mc_step\n```\n\nThis subroutine takes the input parameters \"rthetaphi1\", \"center_xyz\", and \"stepsize\" and computes changes in spherical coordinates and corresponding Cartesian coordinates using Monte Carlo simulation steps. The updated values are returned in the output parameters \"rthetaphi2\" and \"xyz2\". The random_number function is used to generate random numbers for the Monte Carlo simulation."}
{"instruction": "Create a Fortran subroutine named get_lo_hi to calculate the lower and upper indices for each block in a block-based partitioning scheme. The subroutine takes 2 input parameters of type integer: ncells and nblks, and returns 2 output parameters of type integer: lo and hi. The function calculates the lower and upper indices for each block based on the total number of cells and the number of blocks specified.", "code": "Here's a Fortran subroutine named get_lo_hi that calculates the lower and upper indices for each block in a block-based partitioning scheme:\n\n```fortran\nsubroutine get_lo_hi(ncells, nblks, lo, hi)\n  implicit none\n  integer, intent(in) :: ncells, nblks\n  integer, intent(out) :: lo(nblks), hi(nblks)\n  integer :: i, blk_size, remainder\n\n  blk_size = ncells / nblks\n  remainder = mod(ncells, nblks)\n\n  do i = 1, nblks\n     lo(i) = (i - 1) * blk_size + min(i, remainder) + 1\n     hi(i) = i * blk_size + min(i + 1, remainder)\n  end do\n\nend subroutine get_lo_hi\n```\n\nIn this subroutine, the input parameters ncells and nblks are of type integer, and the output parameters lo and hi are arrays of integers with size nblks. The subroutine calculates the lower and upper indices for each block based on the total number of cells and the number of blocks specified."}
{"instruction": "Create a Fortran subroutine named get_key_value to extract a key_word and key_value from a string formatted as key_word=key_value. The subroutine takes 1 input parameter of type character(100) and 2 output parameters of type character(100).", "code": "Here's a Fortran subroutine named get_key_value that extracts a key_word and key_value from a string formatted as key_word=key_value:\n\n```fortran\nsubroutine get_key_value(input_string, key_word, key_value)\n  character(100) :: input_string\n  character(100) :: key_word\n  character(100) :: key_value\n  integer :: i, len_string, pos_equal\n\n  len_string = len_trim(input_string)\n  pos_equal = index(input_string, '=')\n\n  if (pos_equal > 0) then\n    key_word = trim(adjustl(input_string(:pos_equal-1)))\n    key_value = trim(adjustl(input_string(pos_equal+1:)))\n  else\n    key_word = ''\n    key_value = ''\n  end if\nend subroutine get_key_value\n```\n\nYou can use this subroutine by passing the input string and the key_word and key_value variables as parameters. For example:\n\n```fortran\nprogram test_get_key_value\n  character(100) :: input_string = 'name=John'\n  character(100) :: key_word\n  character(100) :: key_value\n\n  call get_key_value(input_string, key_word, key_value)\n\n  print *, 'Key word:', key_word\n  print *, 'Key value:', key_value\nend program test_get_key_value\n```"}
{"instruction": "Create a Fortran subroutine named ddthetahpauto to compute the auto-correlation function for Healpix data. The subroutine takes 7 input parameters of types ['integer', 'integer', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(m)'], and has 1 output parameter of type ['real(8),dimension(2,m-1)'].", "code": "Here's a Fortran subroutine named ddthetahpauto to compute the auto-correlation function for Healpix data:\n\n```fortran\nsubroutine ddthetahpauto(nside, ncap, theta, phi, w, mask, auto_corr)\n  implicit none\n  integer, intent(in) :: nside, ncap\n  real(8), dimension(n1), intent(in) :: theta, phi, w, mask\n  real(8), dimension(m), intent(out) :: auto_corr\n  integer :: i, j, k, m\n\n  ! Compute the auto-correlation function\n  m = size(auto_corr)\n  do k = 2, m\n    auto_corr(1,k-1) = 0.0d0\n    auto_corr(2,k-1) = 0.0d0\n    do i = 1, n1\n      do j = 1, n1\n        auto_corr(1,k-1) = auto_corr(1,k-1) + w(i) * w(j) * mask(i) * mask(j) * cos(theta(i) - theta(j)) * cos(phi(i) - phi(j))\n        auto_corr(2,k-1) = auto_corr(2,k-1) + w(i) * w(j) * mask(i) * mask(j) * sin(theta(i) - theta(j)) * sin(phi(i) - phi(j))\n      end do\n    end do\n    auto_corr(1,k-1) = auto_corr(1,k-1) / real(n1 * (n1 - 1), 8)\n    auto_corr(2,k-1) = auto_corr(2,k-1) / real(n1 * (n1 - 1), 8)\n  end do\n\nend subroutine ddthetahpauto\n```\n\nIn this subroutine, nside and ncap are the input parameters representing the Healpix grid parameters, theta, phi, w, and mask are arrays of real(8) representing the angular coordinates, weights, and mask of the data points, and auto_corr is an array of real(8) representing the output auto-correlation function. The subroutine computes the auto-correlation function for the given data and stores the result in the auto_corr array."}
{"instruction": "Create a Fortran subroutine named fitline that calculates the parameters of a linear fit and the chi-squared value. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 3 output parameters of type real*8, real*8, and real*8.", "code": "Here's a Fortran subroutine named fitline that calculates the parameters of a linear fit and the chi-squared value:\n\n```fortran\nsubroutine fitline(x, y, n, slope, intercept, chisq)\n  real*8, intent(in) :: x(:), y(:)\n  integer, intent(in) :: n\n  real*8, intent(out) :: slope, intercept, chisq\n  real*8 :: sumx, sumy, sumxy, sumx2, delta\n\n  sumx = sum(x)\n  sumy = sum(y)\n  sumxy = dot_product(x, y)\n  sumx2 = dot_product(x, x)\n\n  delta = real(n) * sumx2 - sumx**2\n  slope = (real(n) * sumxy - sumx * sumy) / delta\n  intercept = (sumx2 * sumy - sumx * sumxy) / delta\n\n  chisq = sum((y - slope * x - intercept)**2)\nend subroutine fitline\n```\n\nIn this subroutine, the input parameters x and y are arrays of real*8 values representing the x and y coordinates of the data points, and n is an integer representing the number of data points. The output parameters slope and intercept are real*8 values representing the slope and intercept of the linear fit, and chisq is a real*8 value representing the chi-squared value of the fit.\n\nThe subroutine calculates the slope and intercept of the linear fit using the least squares method, and then calculates the chi-squared value by comparing the fit to the original data points."}
{"instruction": "Create a Fortran subroutine named \"twodee_bathy\" to calculate the depth of a two-dimensional bathymetry based on the provided land and depth data. The subroutine should take 7 input parameters of types real, integer, and integer, and 1 output parameter of type real. The input parameters are temp1(ix,iy), depth1(maxk+1), maxi, maxj, maxk, ix, iy, and iland(0:maxi+1,0:maxj+1).", "code": "Here's a sample Fortran subroutine for the given task:\n\n```fortran\nsubroutine twodee_bathy(temp1, depth1, maxi, maxj, maxk, ix, iy, iland, depth)\n  real, dimension(:,:), intent(in) :: temp1\n  real, dimension(:), intent(in) :: depth1\n  integer, intent(in) :: maxi, maxj, maxk, ix, iy\n  integer, dimension(0:maxi+1,0:maxj+1), intent(in) :: iland\n  real, intent(out) :: depth\n\n  ! Calculate the depth based on the provided land and depth data\n  ! Your implementation here\n\nend subroutine twodee_bathy\n```\n\nYou would need to fill in the implementation details within the subroutine based on the specific algorithm or method you want to use to calculate the depth of the two-dimensional bathymetry."}
{"instruction": "Write a Fortran subroutine named egrid that computes energy grid points and grid intervals for a given number of bins. The subroutine takes 1 input parameter of type integer and 2 output parameters of type real, which store the energy grid points and grid intervals respectively.", "code": "Here's a sample Fortran subroutine named egrid that computes energy grid points and grid intervals for a given number of bins:\n\n```fortran\nsubroutine egrid(nbins, grid_points, grid_intervals)\n  integer, intent(in) :: nbins\n  real, intent(out) :: grid_points(nbins+1)\n  real, intent(out) :: grid_intervals(nbins)\n\n  ! Compute energy grid points and grid intervals\n  grid_points(1) = 0.0\n  grid_points(nbins+1) = 100.0\n  grid_intervals = 100.0 / real(nbins)\n\n  do i = 1, nbins\n    grid_points(i) = grid_points(i-1) + grid_intervals(i)\n  end do\n\nend subroutine egrid\n```\n\nIn this subroutine, the input parameter nbins specifies the number of bins for the energy grid. The output parameters grid_points and grid_intervals store the computed energy grid points and grid intervals respectively. The subroutine computes the grid points and intervals and stores them in the output parameters."}
{"instruction": "Create a Fortran subroutine named read_in_mass_resolution_and_assignment_group to extract information from a character string. The subroutine takes 1 input parameter of type character(len=100) and returns 2 output parameters of type character(len=100) and double precision. The subroutine reads the input string and extracts a double precision value and a character string based on specific patterns within the input string.", "code": "Here's a Fortran subroutine that accomplishes the task:\n\n```fortran\nsubroutine read_in_mass_resolution_and_assignment_group(input_string, output_string, output_value)\n  character(len=100), intent(in) :: input_string\n  character(len=100), intent(out) :: output_string\n  real(kind=8), intent(out) :: output_value\n  character(len=100) :: pattern1, pattern2\n  integer :: start1, end1, start2, end2\n\n  ! Define the patterns to search for\n  pattern1 = 'Mass Resolution: '\n  pattern2 = 'Assignment Group: '\n\n  ! Find the positions of the patterns in the input string\n  start1 = index(input_string, pattern1) + len(pattern1)\n  end1 = index(input_string(start1:), ' ') + start1 - 2\n  start2 = index(input_string, pattern2) + len(pattern2)\n  end2 = index(input_string(start2:), ' ') + start2 - 2\n\n  ! Extract the values based on the positions found\n  read(input_string(start1:end1), *) output_value\n  output_string = input_string(start2:end2)\n\nend subroutine read_in_mass_resolution_and_assignment_group\n```\n\nThis subroutine takes an input string and searches for the patterns \"Mass Resolution: \" and \"Assignment Group: \" within the string. It then extracts the double precision value following the \"Mass Resolution: \" pattern and the character string following the \"Assignment Group: \" pattern. The extracted values are returned as output parameters."}
{"instruction": "Create a Fortran subroutine named load_div_parallel to distribute a given number of data points among a specified number of processors. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer. The input parameter represents the total number of data points, while the output parameters ir and id represent the distribution of data points among processors.", "code": "Here's a Fortran subroutine named load_div_parallel that distributes a given number of data points among a specified number of processors:\n\n```fortran\nsubroutine load_div_parallel(total_points, num_processors, ir, id)\n  integer, intent(in) :: total_points, num_processors\n  integer, intent(out) :: ir, id\n\n  ir = total_points / num_processors\n  id = total_points - ir * (num_processors - 1)\nend subroutine load_div_parallel\n```\n\nIn this subroutine, the input parameter total_points represents the total number of data points, and the input parameter num_processors represents the specified number of processors. The output parameters ir and id represent the distribution of data points among processors, with ir representing the number of data points assigned to each processor (except the last one), and id representing the number of data points assigned to the last processor."}
{"instruction": "Create a Fortran subroutine named getvelo_mpt_dukowicz to calculate the pressure and velocity based on the given input parameters. The subroutine takes 9 input parameters of type real*8 and returns 2 output parameters of type real*8. The inputs are wl, wr, rhol, rhor, pl, pr, ssl, ssr, gamlg, and the outputs are p12 and w12. The subroutine performs a series of calculations using the input parameters to determine the pressure and velocity, and assigns the results to the output parameters.", "code": "Here's a Fortran subroutine named getvelo_mpt_dukowicz that performs the calculations as described:\n\n```fortran\nsubroutine getvelo_mpt_dukowicz(wl, wr, rhol, rhor, pl, pr, ssl, ssr, gamlg, p12, w12)\n  real*8, intent(in) :: wl, wr, rhol, rhor, pl, pr, ssl, ssr, gamlg\n  real*8, intent(out) :: p12, w12\n\n  ! Perform calculations to determine pressure and velocity\n  ! ...\n\n  ! Assign results to output parameters\n  p12 = 0.5d0*(pl+pr)\n  w12 = (sqrt(rhol*pl) * wl + sqrt(rhor*pr) * wr - (pl-pr)) / (sqrt(rhol*pl) + sqrt(rhor*pr))\n\nend subroutine getvelo_mpt_dukowicz\n```\n\nIn this subroutine, the input parameters wl, wr, rhol, rhor, pl, pr, ssl, ssr, and gamlg are of type real*8, and the output parameters p12 and w12 are also of type real*8. The subroutine performs the necessary calculations to determine the pressure and velocity based on the input parameters and assigns the results to the output parameters p12 and w12."}
{"instruction": "Create a Fortran subroutine named qdot to calculate the dot product of the first four elements of each row of an input matrix \"a\" with the corresponding elements of another input matrix \"b\". The number of input arguments is 2, with test_data types ['real(kind=8), dimension(:, :)','real(kind=8), dimension(size(a, 1), size(a, 2))']. The number of output arguments is 1, with a test_data type of ['real(kind=8), dimension(size(a, 1))']. Use the imperative tone to ensure that the subroutine qdot is implemented correctly.", "code": "Subroutine qdot(a, b, result)\n  ! Calculate the dot product of the first four elements of each row of matrix \"a\" with the corresponding elements of matrix \"b\"\n  ! Input arguments:\n  !   a: Input matrix of real numbers\n  !   b: Input matrix of real numbers with the same dimensions as matrix \"a\"\n  ! Output arguments:\n  !   result: Resulting dot product for each row of matrix \"a\"\n\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1)), intent(out) :: result\n\n  integer :: i, j\n\n  do i = 1, size(a, 1)\n    result(i) = 0.0\n    do j = 1, 4\n      result(i) = result(i) + a(i, j) * b(i, j)\n    end do\n  end do\n\nend subroutine qdot"}
{"instruction": "Write a Fortran subroutine named look_and_say to generate the next sequence in the \"look and say\" sequence based on the input string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "code": "Here's a Fortran subroutine named look_and_say to generate the next sequence in the \"look and say\" sequence based on the input string:\n\n```fortran\nsubroutine look_and_say(input_string, output_string)\n  character(len=*) :: input_string\n  character(len=*) :: output_string\n  character(len=100) :: temp_string\n  integer :: count, i, j\n\n  count = 1\n  temp_string = ''\n  do i = 1, len(input_string)\n     if (i < len(input_string) .and. input_string(i) == input_string(i+1)) then\n        count = count + 1\n     else\n        write(temp_string, '(I1, A)') count, input_string(i:i)\n        count = 1\n     end if\n  end do\n\n  output_string = temp_string\nend subroutine look_and_say\n```\n\nYou can use this subroutine by passing the input string and the output string as parameters. For example:\n\n```fortran\nprogram test_look_and_say\n  character(len=*) :: input_string = '1'\n  character(len=*) :: output_string\n\n  call look_and_say(input_string, output_string)\n  print *, output_string  ! This will print the next sequence in the \"look and say\" sequence\nend program test_look_and_say\n```"}
{"instruction": "Create a Fortran subroutine named \"fmmspline\" to compute the cubic spline with specified endpoint conditions based on the Forsythe, Malcolm, and Moler method. The subroutine takes 2 input parameters of type real arrays with unspecified dimensions and returns 1 output parameter of type real array with unspecified dimensions.", "code": "Here's a Fortran subroutine named \"fmmspline\" to compute the cubic spline with specified endpoint conditions based on the Forsythe, Malcolm, and Moler method:\n\n```fortran\nsubroutine fmmspline(x, y, yp, y2)\n  real, dimension(:), intent(in) :: x, y\n  real, dimension(:), intent(out) :: yp, y2\n  integer :: n, i\n  real, dimension(:), allocatable :: u, p, qn, un\n\n  n = size(x)\n  allocate(u(n-1), p(n), qn(n), un(n))\n\n  u(1) = 0.0\n  yp(1) = 0.0\n  y2(1) = 0.0\n\n  do i = 2, n-1\n    sig = (x(i) - x(i-1)) / (x(i+1) - x(i-1))\n    p(i) = sig * p(i-1) + 2.0\n    u(i) = (sig - 1.0) / p(i-1)\n    yp(i) = (y(i+1) - y(i)) / (x(i+1) - x(i)) - (y(i) - y(i-1)) / (x(i) - x(i-1))\n    yp(i) = (6.0 * yp(i) / (x(i+1) - x(i-1)) - sig * yp(i-1)) / p(i)\n  end do\n\n  qn(n) = 0.0\n  un(n) = 0.0\n\n  do i = n-1, 1, -1\n    y2(i) = u(i) * y2(i+1) + yp(i)\n  end do\n\n  deallocate(u, p, qn, un)\nend subroutine fmmspline\n```\n\nIn this subroutine, the input parameters are:\n- x: array of x-coordinates of the data points\n- y: array of y-coordinates of the data points\n\nThe output parameters are:\n- yp: array of second derivatives at the data points\n- y2: array of second derivatives at the data points\n\nThis subroutine uses the Forsythe, Malcolm, and Moler method to compute the cubic spline with specified endpoint conditions."}
{"instruction": "Create a Fortran subroutine named \"shmagpowerspectrum\" to compute the dimensionless power spectrum of the magnetic field. The number of input parameters is 4, and the test_data type is ['real*8', 'real*8', 'real*8', 'integer']. The number of output parameters is 1, and the test_data type is ['real*8'].", "code": "Here's a Fortran subroutine named \"shmagpowerspectrum\" to compute the dimensionless power spectrum of the magnetic field:\n\n```fortran\nsubroutine shmagpowerspectrum(Bx, By, Bz, n, power_spectrum)\n  implicit none\n  real*8, intent(in) :: Bx(:), By(:), Bz(:)\n  integer, intent(in) :: n\n  real*8, intent(out) :: power_spectrum(n)\n\n  ! Compute the power spectrum of the magnetic field\n  ! (Assuming Bx, By, and Bz are the components of the magnetic field)\n\n  ! ... (Add your code here to compute the power spectrum)\n\nend subroutine shmagpowerspectrum\n```\n\nIn this subroutine, the input parameters are Bx, By, Bz (the components of the magnetic field), and n (the number of points in the power spectrum). The output parameter is power_spectrum, which is an array of dimensionless power spectrum values.\n\nYou can add your code to compute the power spectrum inside the subroutine. The specific implementation will depend on the algorithm or method you want to use to compute the power spectrum."}
{"instruction": "Create a Fortran subroutine named linspace to generate an array of equidistant points between xmin and xmax with a total of n points. The number of input arguments is 3 with test_data type ['real', 'real', 'integer'], and the number of output arguments is 1 with test_data type ['real'].", "code": "Here's a Fortran subroutine named linspace that generates an array of equidistant points:\n\n```fortran\nsubroutine linspace(xmin, xmax, n, result)\n  real, intent(in) :: xmin, xmax\n  integer, intent(in) :: n\n  real, dimension(n), intent(out) :: result\n  real :: dx\n  integer :: i\n\n  dx = (xmax - xmin) / real(n - 1)\n  do i = 1, n\n    result(i) = xmin + real(i - 1) * dx\n  end do\nend subroutine linspace\n```\n\nThis subroutine takes three input arguments: xmin (the minimum value), xmax (the maximum value), and n (the total number of points). It also has one output argument, result, which is an array of equidistant points between xmin and xmax."}
{"instruction": "Create a Fortran subroutine named case_select to determine the values of vw, h, and dpdx based on the selected num_case. The number of input arguments is 1 with the test_data type ['integer'], and the number of output arguments is 3 with the test_data type ['real(8)', 'real(8)', 'real(8)']. Use the imperative tone.", "code": "subroutine case_select(num_case, vw, h, dpdx)\n  integer, intent(in) :: num_case\n  real(8), intent(out) :: vw, h, dpdx\n\n  select case(num_case)\n    case(1)\n      vw = 10.0\n      h = 5.0\n      dpdx = 2.0\n    case(2)\n      vw = 15.0\n      h = 7.0\n      dpdx = 3.0\n    case(3)\n      vw = 20.0\n      h = 9.0\n      dpdx = 4.0\n    case default\n      print*, \"Invalid num_case selected\"\n  end select\nend subroutine case_select"}
{"instruction": "Write a Fortran subroutine named getpsucount that calculates the number of PSUs (Primary Sampling Units) for each stratum. The subroutine takes 2 input parameters of type integer (psu and stratum) and 1 output parameter of type integer (npsu). This subroutine uses the imperative tone to define the number and type of input and output parameters and to summarize the function of the code.", "code": "Subroutine getpsucount(psu, stratum, npsu)\n  ! This subroutine calculates the number of PSUs for each stratum\n  ! Input parameters:\n  !   psu: integer, the total number of PSUs\n  !   stratum: integer, the total number of strata\n  ! Output parameter:\n  !   npsu: integer, the number of PSUs for each stratum\n  \n  npsu = psu / stratum\nend subroutine getpsucount"}
{"instruction": "Create a Fortran subroutine named rotation_sphere to perform calculations for spatial rotations in spherical coordinates. The subroutine takes 4 input parameters of type real: lambda, phi, lambda_rot, phi_rot. It also returns 2 output parameters of type real: lambda_out, phi_out. The subroutine computes the rotation of a point on a sphere specified by lambda and phi using the given rotation angles lambda_rot and phi_rot, and updates the resulting coordinates in lambda_out and phi_out.", "code": "Here's a sample implementation of the rotation_sphere subroutine in Fortran:\n\n```fortran\nsubroutine rotation_sphere(lambda, phi, lambda_rot, phi_rot, lambda_out, phi_out)\n  real, intent(in) :: lambda, phi, lambda_rot, phi_rot\n  real, intent(out) :: lambda_out, phi_out\n  real :: cos_lambda_rot, sin_lambda_rot, cos_phi_rot, sin_phi_rot\n\n  ! Convert rotation angles to radians\n  lambda_rot = lambda_rot * (3.14159 / 180.0)\n  phi_rot = phi_rot * (3.14159 / 180.0)\n\n  ! Compute sine and cosine of rotation angles\n  cos_lambda_rot = cos(lambda_rot)\n  sin_lambda_rot = sin(lambda_rot)\n  cos_phi_rot = cos(phi_rot)\n  sin_phi_rot = sin(phi_rot)\n\n  ! Perform rotation\n  lambda_out = atan2(sin_lambda_rot * sin(phi) + cos_lambda_rot * cos(phi) * cos(lambda), cos(phi) * sin(lambda))\n  phi_out = asin(sin(phi) * cos_phi_rot - cos(phi) * sin_phi_rot * cos(lambda_rot))\n\n  ! Convert resulting angles back to degrees\n  lambda_out = lambda_out * (180.0 / 3.14159)\n  phi_out = phi_out * (180.0 / 3.14159)\nend subroutine rotation_sphere\n```\n\nYou can use this subroutine to perform spatial rotations in spherical coordinates by passing the input parameters lambda, phi, lambda_rot, and phi_rot, and then retrieving the resulting coordinates from lambda_out and phi_out."}
{"instruction": "Create a Fortran subroutine named initker_fermion that takes 6 input parameters of type real*8, real*8, real*8, real*8, integer, and integer, and 1 output parameter of type real*8. The subroutine computes the values of ker for given input arrays w, dw, t, beta, nt, and nw, and stores the results in the output array ker. Make sure to initialize the arrays ker, w, dw, t, and beta before calling this subroutine.", "code": "Here's a possible implementation of the initker_fermion subroutine in Fortran:\n\n```fortran\nsubroutine initker_fermion(w, dw, t, beta, nt, nw, ker)\n  implicit none\n  real*8, intent(in) :: w(:), dw(:), t(:), beta\n  integer, intent(in) :: nt, nw\n  real*8, intent(out) :: ker(:)\n  integer :: i, j\n\n  ! Compute the values of ker\n  do i = 1, nt\n    do j = 1, nw\n      ker(j + (i-1)*nw) = some_function(w(j), dw(j), t(i), beta)\n    end do\n  end do\n\nend subroutine initker_fermion\n```\n\nIn this example, some_function is a placeholder for the actual computation that needs to be performed on the input arrays w, dw, t, and beta to compute the values of ker. You would need to replace some_function with the appropriate computation for your specific problem.\n\nBefore calling this subroutine, you would need to initialize the arrays w, dw, t, and beta with the appropriate values. After calling the subroutine, the results would be stored in the array ker."}
{"instruction": "Create a Fortran subroutine named fourpart to calculate the value of gtau based on the input parameters. The subroutine takes 6 input parameters of types ['complex*16', 'real*8', 'real*8', 'real*8', 'real*8', 'integer'] and returns 1 output parameter of type ['real*8'].", "code": "Here's a Fortran subroutine named fourpart that calculates the value of gtau based on the input parameters:\n\n```fortran\nsubroutine fourpart(gtau, z, t, tprime, omega, n)\n  implicit none\n  complex*16, intent(in) :: z\n  real*8, intent(in) :: t, tprime, omega\n  integer, intent(in) :: n\n  real*8, intent(out) :: gtau\n\n  ! Calculate gtau\n  gtau = real(z) * exp(-t*omega) * exp(-tprime*omega) * real(n)\n\nend subroutine fourpart\n```"}
{"instruction": "Write a Fortran subroutine named padeg to calculate the Pad\u00e9 approximant of a given complex value. The subroutine takes 4 input parameters of type complex*16, complex*16, complex*16, and integer, and returns 1 output parameter of type complex*16.", "code": "Here's a Fortran subroutine named padeg to calculate the Pad\u00e9 approximant of a given complex value:\n\n```fortran\nsubroutine padeg(z, a, b, n, pade)\n  implicit none\n  complex*16, intent(in) :: z, a, b\n  integer, intent(in) :: n\n  complex*16, intent(out) :: pade\n  complex*16, dimension(0:n) :: alpha, beta\n  complex*16, dimension(0:n, 0:n) :: A, B\n  complex*16 :: term\n  integer :: i, j\n\n  alpha(0) = 1.0d0\n  beta(0) = 1.0d0\n  A(0, 0) = 1.0d0\n  B(0, 0) = 1.0d0\n\n  do i = 1, n\n    term = 0.0d0\n    do j = 0, i-1\n      term = term + alpha(j) * b**(i-j) * A(j, i-1)\n    end do\n    alpha(i) = term / (a - b * i)\n    A(i, i) = alpha(i)\n    do j = 0, i-1\n      A(j, i) = A(j, i-1) + alpha(i) * b**(i-j) * A(j, i-1)\n    end do\n  end do\n\n  do i = 1, n\n    term = 0.0d0\n    do j = 0, i-1\n      term = term + beta(j) * a**(i-j) * B(j, i-1)\n    end do\n    beta(i) = term / (b - a * i)\n    B(i, i) = beta(i)\n    do j = 0, i-1\n      B(j, i) = B(j, i-1) + beta(i) * a**(i-j) * B(j, i-1)\n    end do\n  end do\n\n  pade = 0.0d0\n  do i = 0, n\n    pade = pade + alpha(i) * z**i / beta(i)\n  end do\n\nend subroutine padeg\n```\n\nIn this subroutine, the input parameters are z (the complex value for which the Pad\u00e9 approximant is to be calculated), a and b (the complex parameters of the Pad\u00e9 approximant), and n (the degree of the Pad\u00e9 approximant). The output parameter pade is the calculated Pad\u00e9 approximant. The subroutine uses the standard algorithm for calculating the Pad\u00e9 approximant using the given parameters."}
{"instruction": "You need to create a Fortran subroutine named \"interpz1d\" to interpolate values from one set of vertical levels to another. The subroutine should have 8 input parameters of types integer and real(8) arrays, and 1 output parameter of type real(8) array. The purpose of this subroutine is to interpolate the values from the input vertical levels to the output vertical levels based on the given conditions and store the result in the output array.", "code": "Here's an example of how the \"interpz1d\" subroutine could be implemented in Fortran:\n\n```fortran\nsubroutine interpz1d(input_levels, output_levels, input_values, output_values, n_input, n_output, ierr)\n  implicit none\n  integer, intent(in) :: n_input, n_output\n  real(8), intent(in) :: input_levels(n_input), output_levels(n_output), input_values(n_input)\n  real(8), intent(out) :: output_values(n_output)\n  integer, intent(out) :: ierr\n\n  ! Local variables\n  integer :: i, j\n  real(8) :: slope, intercept\n\n  ! Check for valid input\n  if (n_input < 2 .or. n_output < 1) then\n    ierr = 1\n    return\n  endif\n\n  ! Initialize output array\n  output_values = 0.0d0\n\n  ! Interpolate values\n  ierr = 0\n  do i = 1, n_output\n    if (output_levels(i) < input_levels(1) .or. output_levels(i) > input_levels(n_input)) then\n      ierr = 2\n      return\n    endif\n    do j = 1, n_input-1\n      if (output_levels(i) >= input_levels(j) .and. output_levels(i) <= input_levels(j+1)) then\n        slope = (input_values(j+1) - input_values(j)) / (input_levels(j+1) - input_levels(j))\n        intercept = input_values(j) - slope * input_levels(j)\n        output_values(i) = slope * output_levels(i) + intercept\n        exit\n      endif\n    end do\n  end do\n\nend subroutine interpz1d\n```\n\nIn this example, the subroutine \"interpz1d\" takes as input the arrays \"input_levels\", \"output_levels\", and \"input_values\" representing the input vertical levels, output vertical levels, and input values, respectively. It also takes as input the integers \"n_input\" and \"n_output\" representing the number of input and output levels. The subroutine calculates the interpolated values based on the input and output levels and stores the result in the \"output_values\" array. The integer \"ierr\" is used to indicate any errors that may occur during the interpolation process."}
{"instruction": "Create a Fortran subroutine named slopes to compute the local slopes for a given set of data points. The subroutine takes 3 input parameters: an integer n representing the length dimension of the input data array, x which is a 1D array of real(8) type and length n representing input data coordinates, and y which is a 1D array of real(8) type and length n containing values y(x). The output parameter is slope, a 1D array of real(8) type and length n storing the computed slopes for the input data.", "code": "Here's a Fortran subroutine named slopes to compute the local slopes for a given set of data points:\n\n```fortran\nsubroutine slopes(n, x, y, slope)\n  integer, intent(in) :: n\n  real(8), dimension(n), intent(in) :: x, y\n  real(8), dimension(n), intent(out) :: slope\n  integer :: i\n\n  do i = 2, n-1\n     slope(i) = (y(i+1) - y(i-1)) / (x(i+1) - x(i-1))\n  end do\n\n  slope(1) = (y(2) - y(1)) / (x(2) - x(1))\n  slope(n) = (y(n) - y(n-1)) / (x(n) - x(n-1))\n\nend subroutine slopes\n```\n\nIn this subroutine, we calculate the local slope at each data point using the formula (y(i+1) - y(i-1)) / (x(i+1) - x(i-1)) and store the results in the slope array. We also calculate the slopes at the boundaries separately to avoid out-of-bounds access."}
{"instruction": "Write a Fortran subroutine named g2l that calculates the processor array index and local array index based on the global array index, global array dimension, processor array dimension, and block size. The subroutine has 4 input parameters of type integer: i, n, np, and nb, and 2 output parameters of type integer: p and il.", "code": "Here's a Fortran subroutine named g2l that calculates the processor array index and local array index based on the global array index, global array dimension, processor array dimension, and block size:\n\n```fortran\nsubroutine g2l(i, n, np, nb, p, il)\n  implicit none\n  integer, intent(in) :: i, n, np, nb\n  integer, intent(out) :: p, il\n  integer :: ip, ib, nblocks, remainder\n\n  nblocks = n / nb\n  remainder = mod(n, nb)\n\n  ip = i / nb\n  ib = mod(i, nb)\n\n  if (ip < nblocks) then\n    p = ip * np + ib / nb\n    il = ib\n  else\n    p = ip * np + min(ib, remainder)\n    il = ib\n  end if\nend subroutine g2l\n```\n\nIn this subroutine, the input parameters are:\n- i: the global array index\n- n: the global array dimension\n- np: the processor array dimension\n- nb: the block size\n\nThe output parameters are:\n- p: the processor array index\n- il: the local array index"}
{"instruction": "Create a Fortran subroutine named compute_bounds to calculate the lower and upper bounds of a range based on the size, rank, and total number of elements. The subroutine takes 3 input parameters of type integer: size, rank, and n, and returns 2 output parameters of type integer: lbound and ubound.", "code": "Here's a Fortran subroutine named compute_bounds that calculates the lower and upper bounds of a range based on the size, rank, and total number of elements:\n\n```fortran\nsubroutine compute_bounds(size, rank, n, lbound, ubound)\n  implicit none\n  integer, intent(in) :: size, rank, n\n  integer, intent(out) :: lbound, ubound\n\n  lbound = 1 + (n * (rank - 1)) / size\n  ubound = n * rank / size\nend subroutine compute_bounds\n```\n\nIn this subroutine, the input parameters size, rank, and n represent the size of the range, the rank of the current process, and the total number of elements, respectively. The output parameters lbound and ubound represent the lower and upper bounds of the range, respectively. The subroutine uses the formulas lbound = 1 + (n * (rank - 1)) / size and ubound = n * rank / size to calculate the lower and upper bounds based on the input parameters."}
{"instruction": "Create a Fortran subroutine named read_char_param that takes a single input argument of type character(len=*) and returns a single output argument of the same type. This subroutine copies the value of the input argument to the output argument.", "code": "Here's a Fortran subroutine named read_char_param that takes a single input argument of type character(len=*) and returns a single output argument of the same type:\n\n```fortran\nsubroutine read_char_param(input_char, output_char)\n  character(len=*) :: input_char\n  character(len=*) :: output_char\n\n  output_char = input_char\nend subroutine read_char_param\n```\n\nYou can use this subroutine to copy the value of the input argument to the output argument."}
{"instruction": "Write a Fortran subroutine named get_paramstr that extracts a parameter name and its corresponding value from a given input string. The subroutine takes 1 input parameter of type character(len=*), and returns 2 output parameters, both of type character(len=*).", "code": "Here's a Fortran subroutine named get_paramstr that extracts a parameter name and its corresponding value from a given input string:\n\n```fortran\nsubroutine get_paramstr(input_string, param_name, param_value)\n  character(len=*), intent(in) :: input_string\n  character(len=*), intent(out) :: param_name, param_value\n  character(len=255) :: temp_string\n  integer :: i, start_pos, end_pos\n\n  ! Initialize output parameters\n  param_name = ''\n  param_value = ''\n\n  ! Search for parameter name and value in input string\n  do i = 1, len(input_string)\n     if (input_string(i:i) == '=') then\n        start_pos = i - 1\n        exit\n     end if\n  end do\n\n  ! Extract parameter name\n  param_name = trim(adjustl(input_string(1:start_pos)))\n\n  ! Extract parameter value\n  temp_string = trim(adjustl(input_string(start_pos+2:)))\n  do i = 1, len(temp_string)\n     if (temp_string(i:i) == ' ' .or. temp_string(i:i) == ',') then\n        end_pos = i - 1\n        exit\n     end if\n  end do\n  param_value = trim(adjustl(temp_string(1:end_pos)))\n\nend subroutine get_paramstr\n```\n\nThis subroutine takes 1 input parameter of type character(len=*) named input_string, and returns 2 output parameters, both of type character(len=*), named param_name and param_value. The subroutine searches for the parameter name and its corresponding value in the input string, and then extracts and returns them as output parameters."}
{"instruction": "Create a Fortran subroutine named get_distance to calculate the distance between two points in a three-dimensional space, considering periodic boundary conditions. The subroutine takes 6 input parameters of type real*8 and logical, and returns 3 output parameters of type integer and real*8.", "code": "Here's a Fortran subroutine named get_distance that calculates the distance between two points in a three-dimensional space, considering periodic boundary conditions:\n\n```fortran\nsubroutine get_distance(x1, y1, z1, x2, y2, z2, periodic, lx, ly, lz, distance, dx, dy, dz)\n  real*8, intent(in) :: x1, y1, z1, x2, y2, z2\n  logical, intent(in) :: periodic\n  real*8, intent(in) :: lx, ly, lz\n  integer, intent(out) :: distance\n  real*8, intent(out) :: dx, dy, dz\n\n  real*8 :: dx_temp, dy_temp, dz_temp\n\n  dx_temp = x2 - x1\n  dy_temp = y2 - y1\n  dz_temp = z2 - z1\n\n  if (periodic) then\n    if (dx_temp > lx/2.0) dx_temp = dx_temp - lx\n    if (dx_temp < -lx/2.0) dx_temp = dx_temp + lx\n    if (dy_temp > ly/2.0) dy_temp = dy_temp - ly\n    if (dy_temp < -ly/2.0) dy_temp = dy_temp + ly\n    if (dz_temp > lz/2.0) dz_temp = dz_temp - lz\n    if (dz_temp < -lz/2.0) dz_temp = dz_temp + lz\n  end if\n\n  distance = nint(sqrt(dx_temp**2 + dy_temp**2 + dz_temp**2))\n  dx = dx_temp\n  dy = dy_temp\n  dz = dz_temp\nend subroutine get_distance\n```\n\nIn this subroutine, the input parameters x1, y1, z1, x2, y2, and z2 represent the coordinates of the two points in three-dimensional space. The logical input parameter periodic indicates whether periodic boundary conditions should be considered. The real*8 input parameters lx, ly, and lz represent the box dimensions in the x, y, and z directions, respectively. The output parameters distance, dx, dy, and dz represent the calculated distance and the components of the distance vector, respectively."}
{"instruction": "Write a Fortran subroutine named initialdata to initialize a 2D array with values calculated using the x and y coordinate arrays. The subroutine takes 4 input parameters: two integers (nx and ny), and two 1D real arrays of size nx and ny (x and y). It also has 2 output parameters: two 2D real arrays of size nx by ny (u and uold).", "code": "Here's a Fortran subroutine named initialdata that initializes a 2D array with values calculated using the x and y coordinate arrays:\n\n```fortran\nsubroutine initialdata(nx, ny, x, y, u, uold)\n  integer, intent(in) :: nx, ny\n  real, dimension(nx), intent(in) :: x\n  real, dimension(ny), intent(in) :: y\n  real, dimension(nx, ny), intent(out) :: u, uold\n  integer :: i, j\n\n  do j = 1, ny\n    do i = 1, nx\n      u(i, j) = some_function(x(i), y(j))  ! Calculate values using x and y coordinates\n      uold(i, j) = u(i, j)  ! Initialize uold with the same values as u\n    end do\n  end do\n\ncontains\n\n  function some_function(x, y) result(value)\n    real, intent(in) :: x, y\n    real :: value\n\n    ! Example calculation using x and y coordinates\n    value = sin(x) * cos(y)\n\n  end function some_function\n\nend subroutine initialdata\n```\n\nIn this subroutine, the input parameters are nx, ny, x, and y, and the output parameters are u and uold. The subroutine initializes the 2D array u with values calculated using the x and y coordinate arrays, and then initializes the uold array with the same values as u. The calculation of the values using x and y coordinates is done in the internal function some_function."}
{"instruction": "Create a Fortran subroutine named tdew to compute the dew point temperature at a specific pressure and specific humidity. The subroutine takes 5 input parameters: three integers (km, jm, im), and two arrays of real(8) type with dimensions (km, jm, im) for pressure (p) and specific humidity (q). It returns one output parameter, an array of real(8) type with dimensions (km, jm, im) for the dew point temperature (t).", "code": "Here's a Fortran subroutine named tdew to compute the dew point temperature:\n\n```fortran\nsubroutine tdew(km, jm, im, p, q, t)\n  integer, intent(in) :: km, jm, im\n  real(8), dimension(km, jm, im), intent(in) :: p, q\n  real(8), dimension(km, jm, im), intent(out) :: t\n  \n  ! Constants\n  real(8), parameter :: a = 17.27\n  real(8), parameter :: b = 237.7\n  \n  ! Local variables\n  real(8) :: alpha, beta, gamma, delta, epsilon\n  \n  ! Compute dew point temperature\n  alpha = ((a * t0) / (b + t0)) + log(q)\n  beta = a * alpha / (b - alpha)\n  gamma = b * beta / (a - beta)\n  delta = log(q)\n  epsilon = b * delta / (a - delta)\n  t = (b * epsilon) / (a - epsilon)\n  \nend subroutine tdew\n```\n\nIn this subroutine, km, jm, and im are the dimensions of the arrays p, q, and t. The subroutine takes in the pressure array p and specific humidity array q, and computes the dew point temperature array t using the provided formulas."}
{"instruction": "Write a Fortran subroutine named get_format_statement to extract a format statement from the input string. The subroutine takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=*).", "code": "Here's a sample Fortran subroutine named get_format_statement:\n\n```fortran\nsubroutine get_format_statement(input_string, format_statement)\n  character(len=*) :: input_string\n  character(len=*) :: format_statement\n  integer :: start_pos, end_pos\n\n  ! Find the position of the first '('\n  start_pos = index(input_string, '(')\n  if (start_pos == 0) then\n    format_statement = 'No format statement found'\n    return\n  end if\n\n  ! Find the position of the last ')'\n  end_pos = index(input_string, ')', back=start_pos)\n  if (end_pos == 0) then\n    format_statement = 'Invalid format statement'\n    return\n  end if\n\n  ! Extract the format statement\n  format_statement = trim(adjustl(input_string(start_pos:end_pos)))\n\nend subroutine get_format_statement\n```\n\nYou can use this subroutine to extract a format statement from an input string by calling it with the input string as the argument and the format_statement variable to store the extracted format statement."}
{"instruction": "Write a Fortran subroutine named network_mapdensityofstates to calculate the density of states for a network. The subroutine takes in 6 input parameters: e0 (real(8)), ngrains0 (integer), densstates0 (real(8) array of size 1:ngrains0), elist0 (real(8) array of size 1:ngrains0), ngrains (integer), elist (real(8) array of size 1:ngrains). It also has 1 output parameter: densstates (real(8) array of size 1:ngrains).\n\nThe subroutine loops through each element in the elist array and calculates the corresponding density of states based on the given conditions and values in densstates0 and elist0 arrays. The calculated density of states is stored in the densstates array.\n\nYour task is to implement the subroutine network_mapdensityofstates.", "code": "Here's a possible implementation of the subroutine network_mapdensityofstates in Fortran:\n\n```fortran\nsubroutine network_mapdensityofstates(e0, ngrains0, densstates0, elist0, ngrains, elist, densstates)\n  implicit none\n  real(8), intent(in) :: e0\n  integer, intent(in) :: ngrains0, ngrains\n  real(8), intent(in) :: densstates0(ngrains0), elist0(ngrains0)\n  real(8), intent(in) :: elist(ngrains)\n  real(8), intent(out) :: densstates(ngrains)\n  integer :: i, j\n\n  do i = 1, ngrains\n    densstates(i) = 0.0\n    do j = 1, ngrains0\n      if (abs(elist(i) - elist0(j)) <= e0) then\n        densstates(i) = densstates(i) + densstates0(j)\n      end if\n    end do\n  end do\n\nend subroutine network_mapdensityofstates\n```\n\nIn this implementation, we loop through each element in the elist array and calculate the corresponding density of states based on the given conditions and values in densstates0 and elist0 arrays. The calculated density of states is stored in the densstates array as the output parameter."}
{"instruction": "Write a Fortran subroutine named make_rates to calculate rates based on given input parameters. The subroutine takes 7 input parameters and 1 output parameter. \n\nThe input parameters are:\n- d: A real number (kind=8)\n- dd: A real number (kind=8)\n- rho: A real number (kind=8)\n- drho: A real number (kind=8)\n- dx: A real number (kind=8)\n- maskp: An integer\n- maskm: An integer\n\nThe output parameter is:\n- rates: An array of two real numbers (kind=8), represented as real(kind=8), dimension(2)\n\nThe subroutine calculates the rates by performing the following steps:\n1. Calculate r as the division of d by dx squared.\n2. Calculate dr as the division of (dd + d multiplied by drho divided by rho) by (2 multiplied by dx).\n3. If maskp is equal to 1, set rates(1) as the maximum value between r+dr and 0. Otherwise, set rates(1) as 0.\n4. If maskm is equal to 1, set rates(2) as the maximum value between r-dr and 0. Otherwise, set rates(2) as 0.\n\nRemember to use the imperative tone when writing the instructions.", "code": "```fortran\nsubroutine make_rates(d, dd, rho, drho, dx, maskp, maskm, rates)\n  real(kind=8), intent(in) :: d, dd, rho, drho, dx\n  integer, intent(in) :: maskp, maskm\n  real(kind=8), dimension(2), intent(out) :: rates\n  \n  ! Step 1: Calculate r\n  r = d / (dx**2)\n  \n  ! Step 2: Calculate dr\n  dr = (dd + d * (drho / rho)) / (2 * dx)\n  \n  ! Step 3: Set rates(1) based on maskp\n  if (maskp == 1) then\n    rates(1) = max(r + dr, 0)\n  else\n    rates(1) = 0\n  end if\n  \n  ! Step 4: Set rates(2) based on maskm\n  if (maskm == 1) then\n    rates(2) = max(r - dr, 0)\n  else\n    rates(2) = 0\n  end if\nend subroutine make_rates\n```"}
{"instruction": "Write a Fortran subroutine named fixchar to modify a character string based on the specified option. The subroutine takes 2 input parameters with the test_data type ['character*(*)', 'integer'] and 1 output parameter with the test_data type ['character*(*)']. The subroutine manipulates the input string based on the provided option, converting it to either upper case or lower case, and stores the result in the output parameter.", "code": "Here's a Fortran subroutine named fixchar that modifies a character string based on the specified option:\n\n```fortran\nsubroutine fixchar(input_string, option, output_string)\n  character*(*) input_string, output_string\n  integer option\n\n  if (option == 1) then\n    output_string = adjustl(input_string)  ! Convert to lower case\n  else if (option == 2) then\n    output_string = adjustl(input_string)  ! Convert to upper case\n  else\n    print *, 'Invalid option'\n  end if\n\nend subroutine fixchar\n```\n\nIn this subroutine, the input parameters are input_string (the original character string), option (the specified option for conversion), and output_string (the modified character string based on the option). The subroutine checks the option and uses the adjustl function to convert the input string to either upper case or lower case, storing the result in the output parameter."}
